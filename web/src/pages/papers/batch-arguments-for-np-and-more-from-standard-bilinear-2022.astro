---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/336';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Batch Arguments for NP and More from Standard Bilinear Group Assumptions';
const AUTHORS_HTML = 'Brent Waters, David J. Wu';

const CONTENT = `    <p class="text-gray-300">Brent Waters UT Austin and NTT Research bwaters@cs.utexas.edu David J. Wu UT Austin dwu4@cs.utexas.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Non-interactive batch arguments for NP provide a way to amortize the cost of NP verification across multiple instances. They enable a prover to convince a verifier of multiple NP statements with communication much smaller than the total witness length and verification time much smaller than individually checking each instance.</p>

    <p class="text-gray-300">In this work, we give the first construction of a non-interactive batch argument for NP from standard assumptions on groups with bilinear maps (specifically, from either the subgroup decision assumption in composite-order groups or from the <span class="math">k</span>-Lin assumption in prime-order groups for any <span class="math">k\\geq 1</span>). Previously, batch arguments for NP were only known from LWE, or a combination of multiple assumptions, or from non-standard/non-falsifiable assumptions. Moreover, our work introduces a new <em>direct</em> approach for batch verification and avoids heavy tools like correlation-intractable hash functions or probabilistically-checkable proofs common to previous approaches.</p>

    <p class="text-gray-300">As corollaries to our main construction, we obtain the first publicly-verifiable non-interactive delegation scheme for RAM programs (i.e., a succinct non-interactive argument (SNARG) for P) with a CRS of sublinear size (in the running time of the RAM program), as well as the first aggregate signature scheme (supporting bounded aggregation) from standard assumptions on bilinear maps.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Consider the following scenario: a prover has a batch of <span class="math">m</span> NP statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}</span> and seeks to convince the verifier that all of these statements are true (i.e., convince the verifier that <span class="math">\\mathbf{x}_{i}\\in\\mathcal{L}</span> for all <span class="math">i\\in[m]</span>, where <span class="math">\\mathcal{L}</span> is the associated NP language). A naïve solution is for the prover to provide the <span class="math">m</span> witnesses <span class="math">\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}</span> to the verifier and have the verifier check the NP relation on each pair <span class="math">(\\mathbf{x}_{i},\\mathbf{w}_{i})</span>. A natural question is whether we could do this more efficiently. Namely, can the prover convince the verifier that <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\mathcal{L}</span> with a proof of size <span class="math">o(m)</span>—that is, can the size of the proof grow <em>sublinearly</em> with the number of instances?</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Batch arguments.</h4>

    <p class="text-gray-300">The focus of this work is on constructing non-interactive <em>batch arguments</em> (BARGs) for NP languages in the common reference string (CRS) model. In this model, a (trusted) setup algorithm samples a common reference string crs that is used to construct and verify proofs. The goal of a BARG is to amortize the cost of NP verification across multiple instances. Specifically, a BARG for NP allows a prover to construct a proof <span class="math">\\pi</span> of <span class="math">m</span> NP statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span> where the size of the proof <span class="math">\\pi</span> scales sublinearly with <span class="math">m</span>. We focus on the setting where the proof is <em>non-interactive</em> and <em>publicly verifiable</em>. The soundness requirement is that no <em>computationally-bounded</em> prover can convince the verifier of a tuple <span class="math">(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span> that contains a false instance <span class="math">\\mathbf{x}_{i}\\notin\\mathcal{L}</span>; namely, we focus on batch <em>argument</em> systems.</p>

    <p class="text-gray-300">Constructing non-interactive batch arguments for NP is challenging, and until very recently, constructions have either relied on idealized models <em>(Mc95, Gro16, BBHR18, COS20, CHM^{∗}20, Set20)</em> or on non-standard <em>(KPY19)</em>, and oftentimes, non-falsifiable cryptographic assumptions <em>(Gro10, BCCT12, DFH12, Lip13, PHGR13, GGPR13, BCI^{∗}13, BCPR14, BISW17, BCC^{+}17)</em> (see also Section 1.3 for more detail). This state of affairs changed in two very recent and exciting works by Choudhuri et al. In the first work <em>(CJJ21a)</em>, they show how to construct a BARG assuming both subexponential hardness of DDH in pairing-free groups and polynomial hardness of QR. Subsequently, they</p>

    <p class="text-gray-300">construct a BARG from polynomial hardness of LWE <em>[x10]</em>. Both works leverage correlation-intractable hash functions <em>[x12, CCH^{+}19, x33, x28]</em> to <em>provably</em> instantiate the Fiat-Shamir heuristic <em>[x15]</em>.</p>

    <p class="text-gray-300">In this work, we take a <em>direct</em> approach for constructing BARGs from bilinear maps, and provide a new instantiation from either polynomial hardness of the <span class="math">k</span>-Lin assumption on prime-order bilinear groups, or from polynomial hardness of the subgroup decision assumption on composite-order bilinear groups. This is the first BARG for NP under standard assumptions over bilinear groups. Moreover, our construction is direct and avoids powerful tools like correlation-intractable hash functions or probabilistically-checkable proofs used in many previous constructions.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Delegation for RAM programs.</h4>

    <p class="text-gray-300">A closely related problem is delegation for RAM programs (also known as a succinct non-interactive argument (SNARG) for the class P of polynomial-time deterministic computations). In a delegation scheme for RAM programs, the prover has a RAM program <span class="math">\\mathcal{P}</span>, an input <span class="math">x</span>, and output <span class="math">y</span>, and its goal is to convince the verifier that <span class="math">y=\\mathcal{P}(x)</span>. The efficiency requirement is that the length of the proof and the verification time should be sublinear (ideally, polylogarithmic) in the running time of the RAM program. There is a close connection between batch arguments for NP and delegation schemes for RAM programs <em>[x1, x21, x22, x11]</em>, and several of these works show how to construct a delegation scheme for RAM programs using a batch argument for NP. As a corollary to our main construction, we use our BARG to obtain a non-interactive delegation scheme for RAM programs under the SXDH assumption in asymmetric bilinear groups. The CRS size of our construction is short (i.e., sublinear in the running time of the RAM computation).</p>

    <p class="text-gray-300">Previously, Kalai et al. <em>[x21]</em> constructed a delegation scheme for RAM programs with a short CRS from a non-standard, but falsifiable, <span class="math">q</span>-type assumption on bilinear groups, and more recently, González and Zacharakis <em>[x16]</em> showed how to construct a delegation scheme with a <em>long</em> CRS for arithmetic circuits from a <em>bilateral <span class="math">k</span>-Lin</em> assumption in asymmetric bilinear groups. Choudhuri et al. <em>[x11]</em> showed how to construct a delegation scheme for RAM programs from LWE, and previously, Jawale et al. <em>[x23]</em> constructed a delegation scheme for bounded-depth circuits also from LWE; both of these schemes also have a short CRS. Recently, Hulett et al. <em>[x18]</em> showed how to construct a SNARG for P from sub-exponential DDH (in <em>pairing-free</em> groups) in conjunction with the QR assumption. In the designated-verifier model where a <em>secret</em> key is needed to check proofs, Kalai et al. <em>[x12]</em> showed how to construct a delegation scheme from any computational private information retrieval scheme.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">In this work, we introduce a simpler and more direct approach for constructing BARGs using bilinear maps. Our main result is a BARG for NP assuming either the polynomial hardness of <span class="math">k</span>-Lin in asymmetric prime-order pairing groups (for any <span class="math">k\\geq 1</span>), or alternatively, the subgroup decision assumption in composite-order pairing groups. We capture this in the informal theorem statement below:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.1 (Informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Take any constant <span class="math">\\varepsilon&gt;0</span>. Under the <span class="math">k</span>-Lin assumption (for any <span class="math">k\\geq 1</span>) in a prime-order pairing group (alternatively, the subgroup decision assumption in a composite-order pairing group), there exists a publicly-verifiable non-interactive BARG for Boolean circuit satisfiability with proof size $\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, verification complexity </span>\\operatorname{poly}(\\lambda,m,n)+\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and CRS size </span>m^{\\varepsilon}\\cdot\\operatorname{poly}(\\lambda)<span class="math">, where </span>\\lambda<span class="math"> is a security parameter, </span>C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}<span class="math"> is the Boolean circuit, </span>n<span class="math"> is the statement size, and </span>m$ is the number of instances. The BARG satisfies semi-adaptive soundness (Definition 2.5).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">A new approach for batch verification.</h4>

    <p class="text-gray-300">In contrast to many recent works (see also Section 1.3) on constructing succinct arguments that rely on probabilistically-checkable proofs (PCPs) <em>[x20, x21, x1, x13, x22]</em> or correlation-intractable hash functions <em>[x23, x11, x11, x12, x13]</em>, we take a direct “low-tech” approach in our construction. Our construction follows a “commit-and-prove” strategy and is reminiscent of the classic pairing-based non-interactive proof systems by Groth et al. <em>[x14]</em> and Groth and Sahai <em>[x16]</em>. Essentially, the prover starts by providing a (succinct) commitment to the values associated with each wire in the circuit. The prover commits to <span class="math">m</span> bits for each wire, one for each instance, and we require that the size of the commitment be sublinear in <span class="math">m</span>. Then, for</p>

    <p class="text-gray-300">each gate in the circuit, the prover provides a short proof that the committed wire values are consistent with the gate operation. The succinct commitment scheme to the wire labels can be viewed as a non-hiding version of the vector commitment scheme of Catalano and Fiore <em>[x10]</em>. The key challenge in the construction is proving consistency of the gate computations given only the <em>succinct</em> commitments to the input and output wires of each gate. We give a technical overview of our approach in Section 1.2 and the formal description in Sections 3 and 4.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Application to delegating RAM programs.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof size in Theorem 1.1 is <em>independent</em> of the number of instances <span class="math">m</span>, but the verification time contains a component <span class="math">\\poly(\\lambda,m,n)</span> that scales with <span class="math">m</span>. For general NP languages, some type of linear dependence on the number of instances is inherent since the verification algorithm must at least read the input (of size <span class="math">m\\cdot n</span>). However, when the statements have a “succinct description,” (e.g., they are simply the indices <span class="math">1,\\dots,m</span>), and it is unnecessary for the verifier to read the full input, we can reduce the the verification cost down to $\\poly(\\lambda,\\log m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. This setting is useful for applications to delegation <em>[x11, x23]</em>. Our main constructions (Theorem 1.1 and Construction 4.5) directly support this setting. Indeed, combining our new pairing-based BARGs with the compiler from Choudhuri et al. <em>[x11]</em>, we also obtain a delegation scheme for RAM programs from the SXDH assumption over pairing groups.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note here that invoking the compiler from <em>[x11]</em> additionally requires a “somewhere extractable commitment” scheme (that supports succinct local openings). The pairing-based techniques underlying our BARG construction naturally give rise to a somewhere extractable commitment (in conjunction with a somewhere extractable hash function <em>[x22, x26]</em>). This is the first construction of a somewhere extractable commitment that supports succinct local openings from standard assumptions over bilinear groups and may be of independent interest. We describe the construction in Section 6. We summarize our result on delegation in the following informal theorem:</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.2 (Informal).</h6>

    <p class="text-gray-300">Take any constant <span class="math">\\varepsilon&gt;0</span>. Under the SXDH assumption in a prime-order pairing group, for every polynomial <span class="math">T=T(\\lambda)</span>, there exists a publicly-verifiable non-interactive delegation scheme for RAM programs with proof size <span class="math">\\poly(\\lambda,\\log T)</span>, verification complexity <span class="math">\\poly(\\lambda,\\log T)</span>, a verification key of size <span class="math">\\poly(\\lambda,\\log T)</span>, and a proving key of size <span class="math">T^{\\varepsilon}\\cdot\\poly(\\lambda)</span>. Here, <span class="math">\\lambda</span> is the security parameter and <span class="math">T</span> is the running time of the RAM program. The delegation scheme is adaptively sound.</p>

    <p class="text-gray-300">Theorem 1.2 gives the first RAM delegation scheme from standard assumptions over bilinear maps with a CRS whose size is <em>sublinear</em> in the running time of the computation. Previously constructions of RAM delegation based on pairings either relied on non-standard <span class="math">q</span>-type assumptions <em>[x20]</em> or a CRS of size <em>super-linear</em> in the running time of the RAM computation <em>[x16]</em>.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Application to aggregate signatures.</h5>

    <p class="text-gray-300">As a final application, we use our BARG for NP to obtain the first aggregate signature scheme that supports bounded aggregation from standard assumptions over bilinear maps. In an aggregate signature scheme, there is a public algorithm that takes a collection of message-signature pairs <span class="math">(\\mu_{1},\\sigma_{1}),\\dots,(\\mu_{m},\\sigma_{m})</span> under (possibly distinct) verification keys <span class="math">\\text{vk}_{1},\\dots,\\text{vk}_{m}</span>, respectively, and outputs a new signature <span class="math">\\sigma_{\\text{agg}}</span> on <span class="math">(\\mu_{1},\\dots,\\mu_{m})</span> under the joint verification key <span class="math">(\\text{vk}_{1},\\dots,\\text{vk}_{m})</span>. The requirement is that the size of <span class="math">\\sigma_{\\text{agg}}</span> scales <em>sublinearly</em> with <span class="math">m</span>. A BARG for circuit satisfiability directly yields an aggregate signature scheme via the following straightforward construction. Define the circuit <span class="math">C(\\text{vk},m,\\sigma)</span> that takes as input the verification key vk, message <span class="math">\\mu</span>, and signature <span class="math">\\sigma</span>, and outputs <span class="math">1</span> if <span class="math">\\sigma</span> is a valid signature on <span class="math">\\mu</span> under vk. An aggregate signature on <span class="math">(\\mu_{1},\\sigma_{1},\\text{vk}_{1}),\\dots,(\\mu_{m},\\sigma_{m},\\text{vk}_{m})</span> is a BARG proof that <span class="math">C(\\text{vk}_{i},\\mu_{i},\\sigma_{i})=1</span> for all <span class="math">i\\in[m]</span>. Succinctness of the BARG ensures that the size of the aggregate signature is sublinear in the number of signatures <span class="math">m</span>. Realizing the above blueprint requires that the underlying BARG satisfy a (weak) form of extractability; the BARGs we construct in this work satisfy this property, and we refer to Section 7 for the details. We obtain the first aggregate signature scheme supporting (bounded) aggregation from standard pairing assumptions. We summarize the instantiation here and compare with previous approaches in Section 1.3:</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Corollary 1.3 (Informal).</h6>

    <p class="text-gray-300">Under the <span class="math">k</span>-Lin assumption (for any <span class="math">k\\geq 1</span>) in a prime-order pairing group (alternatively, the subgroup decision assumption in a composite-order pairing group), there exists an aggregate signature scheme that supports bounded aggregation. In particular, for any a priori bounded polynomial <span class="math">m=m(\\lambda)</span>, aggregating up to <span class="math">T\\leq m</span> message-signature pairs <span class="math">(\\mu_{1},\\sigma_{1}),\\dots,(\\mu_{T},\\sigma_{T})</span> under verification keys <span class="math">\\text{vk}_{1},\\dots,\\text{vk}_{T}</span> yields an aggregate signature <span class="math">\\sigma_{\\text{agg}}</span> of size <span class="math">\\poly(\\lambda)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.2 Technical Overview</p>

    <p class="text-gray-300">In this work, we focus on constructing BARGs for the language of Boolean circuit satisfiability. Let <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{b}\\to\\{0,1\\}</span> be a Boolean circuit of size <span class="math">s</span>. A tuple <span class="math">(C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span> is true if for all <span class="math">i\\in[m]</span>, there exists a witness <span class="math">\\mathbf{w}_{i}</span> such that <span class="math">C(\\mathbf{x}_{i},\\mathbf{w}_{i})=1</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">General blueprint.</h4>

    <p class="text-gray-300">Our BARG for circuit satisfiability follows a “commit-and-prove” paradigm. To construct a proof <span class="math">\\pi</span> of a statement <span class="math">(C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span> with associated witnesses <span class="math">(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m})</span>, the prover proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Wire commitments: The prover starts by evaluating <span class="math">C(\\mathbf{x}_{i},\\mathbf{w}_{i})</span> for each <span class="math">i\\in[m]</span>. Let <span class="math">t</span> be the number of wires in circuit <span class="math">C</span>. For each instance <span class="math">i\\in[m]</span> and wire <span class="math">k\\in[t]</span>, we write <span class="math">w_{i,k}\\in\\{0,1\\}</span> to denote the value of wire <span class="math">k</span> in instance <span class="math">i</span>. Then <span class="math">(w_{1,k},\\ldots,w_{m,k})\\in\\{0,1\\}^{m}</span> is the vector of assignments to wire <span class="math">k</span> across all <span class="math">m</span> instances. The prover starts by constructing a vector commitment <span class="math">U_{k}</span> to each vector <span class="math">(w_{1,k},\\ldots,w_{m,k})</span>. Here, we require the commitment to be succinct: namely, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\log m)<span class="math">, where </span>\\lambda<span class="math"> is a security parameter. The prover additionally constructs a proof </span>V_{k}<span class="math"> that </span>U_{k}<span class="math"> is a commitment to a </span>0/1<span class="math"> vector (i.e., </span>w_{i,k}\\in\\{0,1\\}<span class="math"> for all </span>i\\in[m]<span class="math">). We similarly require that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\log m)<span class="math">. Both the commitments to the wire assignments </span>U_{1},\\ldots,U_{k}<span class="math"> and the proofs of valid assignment </span>V_{1},\\ldots,V_{k}$ are included in the BARG proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The overall proof is <span class="math">\\pi=\\big{(}\\{(U_{k},V_{k})\\}_{k\\in[t]},\\{W_{\\ell}\\}_{\\ell\\in[s]}\\big{)}</span>, and the proof size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\text{poly}(\\lambda,\\log m)$, which satisfies the efficiency requirements on the BARG. To verify the proof, the verifier checks the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input validity: Without loss of generality, we associate wires <span class="math">1,\\ldots,n</span> with the bits of the statement. The verifier checks that <span class="math">U_{1},\\ldots,U_{n}</span> are commitments to the bits of <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>. In our construction, each commitment is a deterministic function of the input vector, so the verifier can compute <span class="math">U_{1},\\ldots,U_{n}</span> directly from <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}</span>.</li>

      <li>Wire validity: For each <span class="math">k\\in[t]</span>, the verifier checks that <span class="math">U_{k}</span> is a commitment to a <span class="math">0/1</span> vector using <span class="math">V_{k}</span>.</li>

      <li>Gate consistency: For each gate <span class="math">G_{\\ell}=(k_{1},k_{2},k_{3})</span>, the verifier uses <span class="math">W_{\\ell}</span> to check that <span class="math">U_{k_{1}}</span>, <span class="math">U_{k_{2}}</span>, and <span class="math">U_{k_{3}}</span> are commitments to a set of valid wire assignments consistent with the gate operation <span class="math">G_{\\ell}</span>.</li>

      <li>Output satisfiability: Let <span class="math">t</span> be the index of the output wire in <span class="math">C</span>. The verifier checks that the commitment to the output wire <span class="math">U_{t}</span> is a commitment to the all-ones vector (indicating that all <span class="math">m</span> instances accept).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the verifier needs to read the statement, the statement validity check runs in time <span class="math">\\text{poly}(\\lambda,n,m)</span>. The remaining checks run in time $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\text{poly}(\\lambda)$, which yields the desired verification complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">1.2.1 Construction from Composite-Order Pairing Groups</h4>

    <p class="text-gray-300">To illustrate the main ideas underlying our construction, we first describe it using symmetric composite-order groups and argue soundness under the subgroup decision assumption <em>[x10]</em>. We believe this construction is conceptually simple and best illustrates the core ideas behind the construction. The approach described here translates to the setting of asymmetric prime-order pairing groups to yield a construction from the <span class="math">k</span>-Lin assumption.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Composite-order pairing groups.</h5>

    <p class="text-gray-300">A symmetric composite-order pairing group consists of two cyclic groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{T}</span> of order <span class="math">N=pq</span>, where <span class="math">p,q</span> are prime. Let <span class="math">g</span> be a generator of <span class="math">\\mathbb{G}</span>. By the Chinese Remainder Theorem, we can write <span class="math">\\mathbb{G}\\cong\\mathbb{G}_{p}\\times\\mathbb{G}_{q}</span>, where <span class="math">\\mathbb{G}_{p}</span> is a subgroup of order <span class="math">p</span> (generated by <span class="math">g_{p}=g^{q}</span>) and <span class="math">\\mathbb{G}_{q}</span> is a subgroup of order <span class="math">q</span> (generated by <span class="math">g_{q}=g^{p}</span>). Additionally, there exists an efficiently-computable, non-degenerate bilinear map <span class="math">e\\colon\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{T}</span> called the “pairing:” namely, for all <span class="math">a,b\\in\\mathbb{Z}_{N}</span>, it holds that <span class="math">e(g^{a},g^{b})=e(g,g)^{ab}</span>. Finally, the subgroups <span class="math">\\mathbb{G}_{p}</span> and <span class="math">\\mathbb{G}_{q}</span> are orthogonal: <span class="math">e(g_{p},g_{q})=1</span>, where <span class="math">1</span> denotes the identity element in <span class="math">\\mathbb{G}_{T}</span>. In our construction, the real scheme operates entirely in the order-<span class="math">p</span> subgroup <span class="math">\\mathbb{G}_{p}</span> of <span class="math">\\mathbb{G}</span>; the full group <span class="math">\\mathbb{G}</span> only plays a role in the soundness analysis.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Vector commitments.</h5>

    <p class="text-gray-300">The first ingredient we need to implement the above blueprint is a vector commitment scheme for vectors of dimension <span class="math">m</span> (<span class="math">m</span> being the number of instances). We start by constructing a common reference string with <span class="math">m</span> group elements <span class="math">(A_{1},\\ldots,A_{m})</span> where each <span class="math">A_{i}=g_{p}^{\\alpha_{i}}</span> for some <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\cong}}{{\\longleftarrow}}\\mathbb{Z}_{N}</span>. A commitment to a vector <span class="math">(w_{1,k},\\ldots,w_{m,k})</span> is a subset product of the associated group elements <span class="math">U_{k}=\\prod_{i\\in[m]}A_{i}^{w_{i,k}}=g_{p}^{\\sum_{i\\in[m]}\\alpha_{i}w_{i,k}}\\in\\mathbb{G}_{p}</span>. We note that this is essentially the vector commitment scheme of Catalano and Fiore <em>[x10]</em> instantiated in <span class="math">\\mathbb{G}_{p}</span>, but without randomization (in our setting, we do not require a hiding property on the commitments). With this instantiation, the commitment to each wire has size <span class="math">\\operatorname{poly}(\\lambda)</span>, and is independent of <span class="math">m</span>.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Wire validity checks.</h5>

    <p class="text-gray-300">The second ingredient we require is a way for the prover to demonstrate that the committed values satisfy the wire validity and gate consistency relations. We start by describing the wire validity checks. Consider a vector of candidate wire assignments <span class="math">(w_{1},\\ldots,w_{m})</span>. The prover needs to convince the verifier that <span class="math">w_{i}\\in\\{0,1\\}</span> for all <span class="math">i\\in[m]</span>, or equivalently, that <span class="math">w_{i}^{2}=w_{i}</span>. Now, a correctly-generated commitment to <span class="math">(w_{1},\\ldots,w_{m})</span> is an encoding of <span class="math">\\sum_{i\\in[m]}\\alpha_{i}w_{i}</span> (in the exponent). We can now write</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i\\in[m]}\\alpha_{i}\\right)</span> <span class="math">\\left(\\sum_{i\\in[m]}\\alpha_{i}w_{i}\\right)=\\sum_{i\\in[m]}\\alpha_{i}^{2}w_{i}+\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}w_{j}</span> <span class="math">\\left(\\sum_{i\\in[m]}\\alpha_{i}w_{i}\\right)^{2}=\\sum_{i\\in[m]}\\alpha_{i}^{2}w_{i}^{2}+\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}w_{i}w_{j}.</span></p>

    <p class="text-gray-300">When <span class="math">w_{i}^{2}=w_{i}</span>, the difference between these two expressions is <span class="math">\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}(1-w_{i})w_{j}</span>. Notably, this difference is a linear combination of the products <span class="math">\\alpha_{i}\\alpha_{j}</span> where <span class="math">i\\neq j</span>; we refer to these terms as the cross terms. Conversely, if <span class="math">w_{i}^{2}\\neq w_{i}</span> for some <span class="math">i</span>, then the difference between the two relations always depends on the non-cross-term <span class="math">\\alpha_{i}^{2}</span>. This suggests the following strategy for proof generation and verification: we publish encodings <span class="math">B_{i,j}\\coloneqq g_{p}^{\\alpha_{i}\\alpha_{j}}</span> for <span class="math">i\\neq j</span> in the CRS to allow the prover to “cancel out” cross terms but not the non-cross terms. We also include an encoding <span class="math">A\\coloneqq\\prod_{i\\in[m]}A_{i}=g_{p}^{\\sum_{i\\in[m]}\\alpha_{i}}</span> that will be used for verification. Specifically, we define the CRS to be</p>

    <p class="text-gray-300"><span class="math">\\operatorname{crs}=\\left(\\{A_{i}\\coloneqq g_{p}^{\\alpha_{i}}\\}_{i\\in[m]}\\;,\\;A\\coloneqq\\prod_{i\\in[m]}A_{i}=g_{p}^{\\sum_{i\\in[m]}\\alpha_{i}}\\;,\\;\\{B_{i,j}\\coloneqq g_{p}^{\\alpha_{i}\\alpha_{j}}\\}_{i\\neq j}\\right).</span> (1.1)</p>

    <p class="text-gray-300">Then, the prover can compute the quantity <span class="math">V=\\prod_{i\\neq j}B_{i,j}^{(1-w_{i})w_{j}}=g_{p}^{\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}(1-w_{i})w_{j}}</span>. By the above relations, we see that if <span class="math">U=g_{p}^{\\sum_{i\\in[m]}\\alpha_{i}w_{i}}</span>, then</p>

    <p class="text-gray-300"><span class="math">e(A,U)=e(U,U)e(g_{p},V).</span> (1.2)</p>

    <p class="text-gray-300">The analysis above shows that if <span class="math">U</span> is a valid commitment to a binary vector, then the prover can always compute <span class="math">V</span> that satisfies the verification relation. When <span class="math">U</span> is not a commitment to a binary vector, we need to argue that the prover cannot craft a proof <span class="math">V</span> that satisfies Eq. (1.2). The intuition is that there will be “non-cross-terms” that cannot be cancelled using the components available to the prover. Formalizing this intuition requires some care and we provide additional details below. We also note here that the size of the CRS (Eq. (1.1)) in our construction scales quadratically with the number of instances <span class="math">m</span>. In the following, we will describe a bootstrapping technique to reduce the CRS size to scale with <span class="math">m^{\\varepsilon}</span> for any constant <span class="math">\\varepsilon&gt;0</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Gate consistency checks.</p>

    <p class="text-gray-300">The approach we take for wire validity checks readily extends to enable gate consistency checks. We describe our approach for verifying a single NAND gate. To simplify the description, suppose <span class="math">U_{1}</span> and <span class="math">U_{2}</span> are vector commitments to the input wires <span class="math">(w_{1,1},\\ldots,w_{m,1})</span> and <span class="math">(w_{1,2},\\ldots,w_{m,2})</span>, and <span class="math">U_{3}</span> is a vector commitment to the output wire <span class="math">(w_{1,3},\\ldots,w_{m,3})</span>. The prover wants to show that <span class="math">w_{i,3}=\\text{NAND}(w_{i,1},w_{i,2})</span> for all <span class="math">i\\in[m]</span>. This is equivalent to checking satisfiability of the <em>quadratic</em> relation <span class="math">w_{i,3}+w_{i,1}w_{i,2}=1</span>. In this case, the prover computes the element <span class="math">W\\in\\mathbb{G}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\frac{e(A,U_{3})e(U_{1},U_{2})}{e(A,A)}=e(g_{p},W).</span> (1.3)</p>

    <p class="text-gray-300">Suppose <span class="math">U_{1},U_{2},U_{3}</span> are properly-generated commitments. Then, if we consider the exponents for the left-hand side of the verification relation, we have</p>

    <p class="text-gray-300"><span class="math">\\underbrace{\\sum_{i\\in[m]}\\alpha_{i}^{2}w_{i,3}+\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}w_{j,3}}_{e(A,U_{3})}+\\underbrace{\\sum_{i\\in[m]}\\alpha_{i}^{2}w_{i,1}w_{i,2}+\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}w_{i,1}w_{j,2}}_{e(U_{1},U_{2})}-\\underbrace{\\sum_{i\\in[m]}\\alpha_{i}^{2}-\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}}_{e(A,A)}.</span></p>

    <p class="text-gray-300">If <span class="math">w_{i,3}+w_{i,1}w_{i,2}=1</span>, then all of the non-cross terms vanish, and we are left with <span class="math">\\sum_{i\\neq j}\\alpha_{i}\\alpha_{j}(w_{j,3}+w_{i,1}w_{j,2}-1)</span>. The prover can thus set <span class="math">W=\\prod_{i\\neq j}B_{i,j}^{w_{j,3}+w_{i,1}w_{j,2}-1}</span> to satisfy the above verification relation. Similar to the case with wire consistency checks, we now have to show that if there exists an <span class="math">i\\in[m]</span> where <span class="math">w_{i,3}+w_{i,1}w_{i,2}\\neq 1</span>, then the prover is <em>unable</em> to compute a <span class="math">W</span> that satisfies Eq. (1.3).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Proving soundness.</h4>

    <p class="text-gray-300">To argue soundness of our argument system, we take the dual-mode approach from <em>[x10, x10]</em>. Specifically in this setting, there are two computationally indistinguishable ways to sample the CRS: (1) the normal mode described above; and (2) a trapdoor mode that takes as input an instance index <span class="math">i^{<em>}\\in[m]</span> and outputs a trapdoor CRS <span class="math">\\text{crs}^{</em>}</span>. The requirement is that in trapdoor mode, the scheme is <em>statistically</em> sound for instance <span class="math">i^{<em>}</span>. Namely, with overwhelming probability over the choice of <span class="math">\\text{crs}^{</em>}</span>, there does <em>not</em> exist any proof <span class="math">\\pi</span> for <span class="math">(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span> that convinces the verifier when <span class="math">\\mathbf{x}_{i^{<em>}}</span> is false. However, it is still possible that there exists valid proofs of tuples where <span class="math">\\mathbf{x}_{i^{</em>}}</span> is true but <span class="math">\\mathbf{x}_{i}</span> is false for some <span class="math">i\\neq i^{<em>}</span>. By a standard hybrid argument, it is easy to see that a BARG with this dual-mode “somewhere statistical soundness” property also satisfies </em>non-adaptive soundness<em> (i.e., soundness for statements that are </em>independent<em> of the CRS). Achieving the stronger notion of </em>adaptive<em> soundness where security holds for statements that depend on the CRS seems challenging and in certain settings, will either require non-black-box techniques or basing security on non-falsifiable assumptions </em>[x13, x12]*.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Somewhere statistical soundness.</h4>

    <p class="text-gray-300">To argue that our construction above satisfies somewhere statistical soundness, we start by describing the trapdoor CRS. To ensure statistical soundness for index <span class="math">i^{<em>}\\in[m]</span>, we replace the encoding <span class="math">A_{i^{</em>}}=g_{p}^{\\alpha_{i^{<em>}}}</span> associated with instance <span class="math">i^{</em>}</span> with <span class="math">A_{i^{<em>}}\\leftarrow g^{\\alpha_{i^{</em>}}}\\in\\mathbb{G}</span>. Critically, <span class="math">A_{i^{<em>}}</span> is now in the </em>full group<em> rather than the order-<span class="math">p</span> subgroup <span class="math">\\mathbb{G}_{p}</span>. The encodings <span class="math">A_{i}</span> associated with instances <span class="math">i\\neq i^{</em>}</span> are still sampled from <span class="math">\\mathbb{G}_{p}</span>. We can construct the cross terms <span class="math">B_{i,j}</span> in a similar manner as before: the components for <span class="math">i,j\\neq i^{<em>}</span> are unaffected and we set <span class="math">B_{i^{</em>},j}=B_{j,i^{<em>}}=A_{i^{</em>}}^{\\alpha_{j}}\\in\\mathbb{G}</span>. The trapdoor CRS is computationally indistinguishable from the normal CRS by the subgroup decision assumption <em>[x4]</em>. Consider the wire consistency checks and gate consistency checks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wire consistency checks. Let <span class="math">U\\in\\mathbb{G}</span> be a commitment to a tuple of wire values and <span class="math">V\\in\\mathbb{G}</span> be the wire consistency proof. We can decompose <span class="math">U</span> as <span class="math">U=g_{p}^{\\beta_{p}}g_{q}^{\\beta_{q}}</span> for some <span class="math">\\beta_{p}\\in\\mathbb{Z}_{p}</span>, <span class="math">\\beta_{q}\\in\\mathbb{Z}_{q}</span>. Moreover, by construction, the verification component <span class="math">A</span> is defined to be <span class="math">A=\\prod_{i\\in[m]}A_{i}=g_{p}^{\\sum_{i\\in[m]}\\alpha_{i}}g_{q}^{\\alpha_{i^{<em>}}}</span>. Consider now the verification relation from Eq. (1.2). If this relation holds in <span class="math">\\mathbb{G}_{T}</span>, it must in particular hold in the order-<span class="math">q</span> subgroup of <span class="math">\\mathbb{G}_{T}</span>. The key observation is that projecting the relation into the order-<span class="math">q</span> subgroup of <span class="math">\\mathbb{G}_{T}</span> </em>isolates<em> instance <span class="math">i^{</em>}</span> (since</li>

    </ul>

    <p class="text-gray-300">only the encoding <span class="math">A_{i^{<em>}}</span> contains components in the order-<span class="math">q</span> subgroup). Moreover, the pairing <span class="math">e(g_{p},V)</span> </em>vanishes<em> in the order-<span class="math">q</span> subgroup, so the prover has </em>no control<em> over the validity check in the order-<span class="math">q</span> subgroup. Now, for 1.2 to be satisfied, it must be the case that <span class="math">\\alpha_{i^{</em>}}\\beta_{q}=\\beta_{q}^{2}\\bmod q</span>. Thus, either <span class="math">\\beta_{q}=0</span> or <span class="math">\\beta_{q}=\\alpha_{i^{<em>}}</span> and so the wire checks ensure that <span class="math">U_{k}=g_{p}^{\\beta_{p}}g_{q}^{\\xi_{k}\\alpha_{i^{</em>}}}</span> where <span class="math">\\xi_{k}\\in\\{0,1\\}</span> for all <span class="math">k\\in[m]</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gate consistency checks. Now, consider the gate consistency checks. We again consider the projection of the pairing check into the order-<span class="math">q</span> subgroup. If we project 1.3 in the order-<span class="math">q</span> subgroup and using the above relations for <span class="math">U_{k}</span> and <span class="math">A</span>, we obtain the relation</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\xi_{k_{3}}\\alpha_{i^{<em>}}^{2}+\\xi_{k_{1}}\\xi_{k_{2}}\\alpha_{i^{</em>}}^{2}-\\alpha_{i^{*}}^{2}=0\\bmod q.</span></p>

    <p class="text-gray-300">If <span class="math">\\alpha_{i^{<em>}}\\neq 0\\bmod q</span>, then <span class="math">\\xi_{k_{3}}+\\xi_{k_{1}}\\xi_{k_{2}}-1=0\\bmod q</span>. Since <span class="math">\\xi_{k_{1}},\\xi_{k_{2}},\\xi_{k_{3}}\\in\\{0,1\\}</span>, this means that <span class="math">\\xi_{k_{3}}=\\textsc{NAND}(\\xi_{k_{1}},\\xi_{k_{2}})</span>. The above relations show that <span class="math">(\\xi_{1},\\ldots,\\xi_{t})\\in\\{0,1\\}^{t}</span> constitutes a valid assignment to the wires of <span class="math">C((\\xi_{1},\\ldots,\\xi_{n}),\\mathbf{w}^{</em>})</span> where <span class="math">\\mathbf{w}^{<em>}=(\\xi_{n+1},\\ldots,\\xi_{n+h})</span>. Again considering the verification relations in the order-<span class="math">q</span> subgroup, the input validity checks ensure that <span class="math">\\mathbf{x}_{i^{</em>}}=(\\xi_{1},\\ldots,\\xi_{n})</span> and the output satisfiability check ensures that <span class="math">C(\\mathbf{x}_{i^{<em>}},\\mathbf{w}^{</em>})=\\xi_{t}=1</span>. The above argument shows that if all of the validity checks pass, then we can <em>extract</em> a witness for instance <span class="math">i^{<em>}</span>. Thus, statistical soundness for instance <span class="math">\\mathbf{x}_{i^{</em>}}</span> holds. In fact, this extraction procedure can be made efficient given a trapdoor (i.e., the factorization of <span class="math">N</span>). We provide the full construction and security analysis in Section 3.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">1.2.2 The Prime-Order Instantiation, Bootstrapping, and Applications</h4>

    <p class="text-gray-300">The BARG construction from symmetric composite-order groups is conceptually simple to describe and illustrates the main ideas behind our construction. We now describe several extensions and generalizations of these ideas.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Instantiation from <span class="math">k</span>-Lin.</h5>

    <p class="text-gray-300">The ideas underlying the composite-order construction (Sections 1.2.1 and 3) naturally extend to the setting of asymmetric prime-order groups. Recall that an asymmetric prime-order group consists of two base groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, a target group <span class="math">\\mathbb{G}_{T}</span>, all of prime order <span class="math">p</span>, and an efficiently-computable, non-degenerate pairing <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span>. In this setting, we can base security on the standard <span class="math">k</span>-Lin assumption for any <span class="math">k\\geq 1</span>. Recall that the case <span class="math">k=1</span> corresponds to the SXDH assumption (i.e., DDH in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>) and the case <span class="math">k=2</span> corresponds to the DLIN assumption <em>[x1, x10, x26]</em>. The key property we relied on in the soundness analysis of the composite-order construction is the ability to isolate a single instance by <em>projecting</em> the verification relations into a suitable subgroup. In the prime-order setting, we can simulate this projection property by considering subspaces of vector spaces <em>[x16, x18]</em>. We refer to Section 4 for the full description and security analysis.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Bootstrapping to reduce CRS size.</h5>

    <p class="text-gray-300">The size of the CRS in the above construction scales <em>quadratically</em> with the number of instances <span class="math">m</span> (due to the cross terms). However, we can adapt the bootstrapping approach from Kalai et al. <em>[x22]</em> reduce the size of the CRS to grow with <span class="math">m^{\\varepsilon}</span> (for any constant <span class="math">\\varepsilon&gt;0</span>). Soundness of the bootstrapping construction critically relies on the ability to extract the witness for <em>one</em> of the instances in the BARG.</p>

    <p class="text-gray-300">The construction is simple. To verify statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}</span>, we consider a two-tiered construction where we group the statements into <span class="math">m/B</span> batches of statements, each containing exactly <span class="math">B</span> statements. We use a BARG (on <span class="math">B</span> instances) to prove that all of the statements in each batch <span class="math">(\\mathbf{x}_{B(i-1)+1},\\ldots,\\mathbf{x}_{iB})</span> are true. Let <span class="math">\\pi_{i}</span> be the BARG proof for the <span class="math">i^{\\text{th}}</span> batch. The prover then shows that it knows accepting proofs <span class="math">\\pi_{1},\\ldots,\\pi_{m/B}</span> of each of the <span class="math">m/B</span> batches of statements. Here, it will be critical that the size of the BARG verification circuit for checking <span class="math">\\pi_{i}</span> be <em>sublinear</em> in the batch size <span class="math">B</span>. This is not possible in general since the verification circuit has to read the statement which already has length <span class="math">B</span>. However, when the underlying BARG satisfies a “split verification” property (Definition 2.9), where the verification algorithm decomposes into (1) a circuit-independent preprocessing step that reads the statement and outputs a <em>succinct</em> verification key vk; and (2) a fast “online” verification step whose running time is <em>polylogarithmic</em> in the number of instances, it suffices to use the BARG to <em>only</em> check the online verification step.</p>

    <p class="text-gray-300">Now, if we set <span class="math">B=\\sqrt{m}</span> in this framework, both the BARG for checking each batch of <span class="math">B</span> statements as well as the BARG for verifying the <span class="math">m/B=\\sqrt{m}</span> batches are BARGs on <span class="math">\\sqrt{m}</span> instances. Thus, we can use a BARG on <span class="math">\\sqrt{m}</span> instances to construct a BARG on <span class="math">m</span> instances. If we start with a BARG with CRS size <span class="math">m^{d}</span>, then the two-tiered construction reduces the CRS size to roughly <span class="math">m^{d/2}</span>. We can apply this approach recursively (with a constant number of iterations) to reduce the CRS size from <span class="math">\\text{poly}(\\lambda,m)</span> to <span class="math">m^{\\varepsilon}\\cdot\\text{poly}(\\lambda)</span> for any constant <span class="math">\\varepsilon&gt;0</span>. We refer to Section 5 for the full details.</p>

    <p class="text-gray-300">Application to delegation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Choudhuri et al. <em>[x10]</em> showed how to combine a “BARG for index languages” with a somewhere extractable commitment scheme to obtain a delegation scheme for RAM programs. In a BARG for index languages, the statements to the <span class="math">m</span> instances are always fixed to be the binary representation of the integers <span class="math">1,\\ldots,m</span>. In this setting, the prover and the verifier do not need to read the statement anymore, and correspondingly, the verification algorithm is required to run in time $\\poly(\\lambda,\\log m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> when checking a circuit </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our BARG construction extends naturally to this setting. In the construction described in Section 1.2.1 (see also Section 3), the verifier starts by computing the commitments <span class="math">U_{1},\\ldots,U_{n}</span> to the bits of the statement. This takes time <span class="math">\\poly(\\lambda,n,m)</span> since the verifier has to minimally read the statement (of length <span class="math">mn</span>). However in the case of an index BARG, the statements are known in advance, so the encodings <span class="math">U_{i}</span> can be computed in advance and included as part of a verification key <span class="math">\\operatorname{vk}=(U_{1},\\ldots U_{n})</span> that the verifier uses for verification. Given <span class="math">\\operatorname{vk}</span>, the statement validity checks can be implemented by simply comparing the precomputed commitments with those provided by the adversary; notably this check is now independent of the number of instances. Using the precomputed commitments, we can bring the overall verification cost down to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\poly(\\lambda,\\log m)$, which meets the efficiency requirements for an index BARG.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second ingredient we require to instantiate the Choudhuri et al. <em>[x10]</em> compiler is a somewhere extractable commitment scheme. Our techniques for constructing BARGs can also be used to directly construct a somewhere extractable commitment scheme (when combined with a somewhere statistically binding hash function <em>[x16, x23]</em>). We can thus appeal to the compiler of Choudhuri et al. to obtain a delegation scheme for RAM programs from the SXDH assumption in bilinear groups. Similar to the case with BARGs, we first describe a construction with a long CRS where the length of the CRS grows quadratically with the length of the committed message (Section 6.2). We then describe a similar kind of bootstrapping technique to obtain a somewhere extractable commitment scheme with a CRS of size sublinear in the message size (Section 6.3). We refer to Section 6 for the full details.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Application to aggregate signatures.</h5>

    <p class="text-gray-300">As described in Section 1.1, our BARG construction directly implies an aggregate signature scheme supporting bounded aggregation. We describe this construction in Section 7.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Generalized BARGs.</h5>

    <p class="text-gray-300">As previously noted for the case of BARGs for index languages, when the statements are fixed in advance, we can precompute commitments to them during setup and include the honestly-generated commitments to their values as part of a verification key. In this case, the verifier can use the precomputed encodings during verification and no longer needs to perform the statement validity checks. In Appendix A, we describe a more generalized view where some of the statement wires are fixed while others can be chosen by the prover. This generalization captures both the standard setting (where all of the statement wires can be chosen by the prover) and the BARG for index languages setting (where all of the statement wires are fixed ahead of time) as special cases.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <h5 id="sec-26" class="text-base font-semibold mt-4">SNARGs.</h5>

    <p class="text-gray-300">Batch arguments for NP can be constructed from any succinct non-interactive argument (SNARG) for NP. Existing constructions of SNARGs have either relied on random oracles <em>[x22, x1, x11, x12, x13]</em>, the generic group model <em>[x15]</em>, or strong non-falsifiable assumptions <em>[x11, x5, x14, x12, x16, x17, x18, BCPT14, BCPT13, BCPT15, BCPT16, BCPT17]</em>. Indeed, Gentry and Wichs <em>[x13]</em> showed that no construction of an (adaptively-sound) SNARG for NP can be proven secure via a black-box reduction to a falsifiable assumption <em>[x24]</em>. This separation also extends to adaptively-sound BARGs of knowledge (i.e., “BARKs”) for NP <em>[x4]</em>. The only construction of non-adaptively sound SNARGs from falsifiable assumptions is the construction based on indistinguishability obfuscation <em>[x29]</em>. We note that Lipmaa and Pavlyk <em>[x20]</em> recently proposed a candidate SNARG from a non-standard, but falsifiable, <span class="math">q</span>-type assumption on bilinear groups. However, we were recently informed <em>[x28]</em> that the proof of security was fundamentally flawed and later confirmed this with the authors of <em>[x20]</em>.</p>

    <p class="text-gray-300">##</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Batch arguments for NP.</h5>

    <p class="text-gray-300">If we focus specifically on constructions of BARGs for NP, <em>Kalai et al. [KPY19]</em> showed how to construct a BARG for NP from a non-standard, but falsifiable, <span class="math">q</span>-type assumption on bilinear groups. More recently, Choudhuri et al. gave constructions from subexponentially-hard DDH in pairing-free groups in conjunction with polynomial hardness of the QR assumption <em>[CJJ21a]</em>, as well as from polynomial hardness of the LWE assumption <em>[CJJ21b]</em>. Both of these constructions leverage correlation-intractable hash functions. The size of the proof in the DDH + QR construction grows with <span class="math">\\sqrt{m}</span>, where <span class="math">m</span> is the number of instances, while that in the LWE construction scales <em>polylogarithmically</em> with the number of instances. Our work provides the first BARG for NP from standard assumptions on bilinear groups (with proof size that is <em>independent</em> of the number of instances).</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Interactive schemes.</h5>

    <p class="text-gray-300">Batch arguments for NP have also been considered in the interactive setting. First, the classic <span class="math">\\mathsf{IP}=\\mathsf{PSPACE}</span> theorem <em>[LFKN90, Sha90]</em> implies a interactive <em>proof</em> for batch NP verification, albeit with an <em>inefficient</em> prover. For interactive proofs with an <em>efficient</em> prover, batch verification is known for the class <span class="math">\\mathsf{UP}</span> of NP languages with <em>unique</em> witnesses <em>[RRR16, RRR18, RR20]</em>. If we relax to interactive <em>arguments</em>, <em>Brakerski et al. [BHK17]</em> constructed 2-message BARGs for NP from any computational private information retrieval (PIR) scheme.</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">Delegation schemes.</h5>

    <p class="text-gray-300">Many works have focused on constructing delegation schemes for deterministic computations. In the interactive setting, we have succinct <em>proofs</em> for both bounded-depth computations <em>[GKR08]</em> and bounded-space computations <em>[RRR16]</em>. In the non-interactive setting, <em>Kalai et al. [KPY19]</em> gave the first construction from a falsifiable (but non-standard) assumption on bilinear groups. Using correlation-intractable hash functions based on LWE, <em>Jawale et al. [JKKZ21]</em> and <em>Choudhuri et al. [CJJ21b]</em> constructed delegation schemes for bounded-depth computations and general polynomial-time computations, respectively. Recently, <em>González and Zacharakis [GZ21]</em> constructed a delegation scheme for arithmetic circuits with a <em>long</em> CRS from a <em>bilateral</em> (or “split”) <span class="math">k</span>-Lin assumption in asymmetric groups. The size of the CRS in their construction is <em>quadratic</em> in the circuit size. Our scheme is based on the vanilla SXDH assumption in asymmetric groups and has a CRS whose size is <em>sublinear</em> in the running time of the RAM computation (specifically, <span class="math">T^{*}</span> for any constant <span class="math">\\varepsilon&gt;0</span>, where <span class="math">T</span> is the running time of the RAM computation).</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Aggregate signatures.</h5>

    <p class="text-gray-300">Aggregate signatures were introduced by <em>Boneh et al. [BGLS03]</em> who also gave an efficient construction using bilinear maps in the random oracle model. In the standard model, constructions of aggregate signatures have typically considered restricted settings such as sequential aggregation <em>[LMRS04, LOS</em>06]<em> where the aggregate signature is constructed by having each signer </em>sequentially<em> “add” its signature to an aggregated signature, or synchronized aggregation </em>[GR06, AGH10, HW18]<em>, which assumes that signers have a synchronized clock and aggregation is only allowed on signatures from the same time period (with exactly 1 signature from each signer per time period). Other (standard model) constructions have relied on heavy tools such as multilinear maps </em>[RS09, FHPS13]<em> or indistinguishability obfuscation </em>[HKW15]<em>. Aggregate signatures can also be constructed generically from </em>adaptively-sound<em> succinct arguments </em>of knowledge<em> (SNARKs), which are only known from non-falsifiable assumptions or idealized models. In the case of bounded aggregation (where there is an </em>a priori<em> bound on the number of signatures that can be aggregated), the somewhere extractable BARG by </em>Choudhuri et al. [CJJ21b]* can be used to obtain a construction from LWE. Our work provides the first instantiation of an aggregate signature supporting bounded aggregation from standard assumptions over bilinear groups in the plain model.</p>

    <h2 id="sec-31" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">For a positive integer <span class="math">n</span>, we write <span class="math">[n]</span> to denote the set <span class="math">\\{1,\\ldots,n\\}</span>. For a positive integer <span class="math">p\\in\\mathbb{N}</span>, we write <span class="math">\\mathbb{Z}_{p}</span> to denote the ring of integers modulo <span class="math">p</span>. We use bold-face uppercase letters (e.g., <span class="math">\\mathbf{A}</span>, <span class="math">\\mathbf{B}</span> to denote matrices) and bold-face lowercase letters (e.g., <span class="math">\\mathbf{x}</span>, <span class="math">\\mathbf{w}</span>) to denote vectors. For a finite set <span class="math">S</span>, we write <span class="math">x\\xleftarrow{\\mathbf{s}}S</span> to indicate that <span class="math">x</span> is sampled uniformly at random from <span class="math">S</span>. We use non-bold-face letters to denote their components (e.g., <span class="math">\\mathbf{x}=(x_{1},\\ldots,x_{n})</span>). We write <span class="math">\\mathrm{poly}(\\lambda)</span> to denote a function that is <span class="math">O(\\lambda^{c})</span> for some <span class="math">c\\in\\mathbb{N}</span> and <span class="math">\\mathrm{negl}(\\lambda)</span> to denote a function that is <span class="math">o(\\lambda^{-c})</span> for all <span class="math">c\\in\\mathbb{N}</span>. We say an event <span class="math">E</span> occurs with overwhelming probability if its complement occurs with negligible probability. An algorithm is efficient if it runs in probabilistic polynomial time in its input length. We say that two families of distributions <span class="math">\\mathcal{D}_{1}=\\{\\mathcal{D}_{1,\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> and <span class="math">\\mathcal{D}_{2}=\\{\\mathcal{D}_{2,\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> are computationally indistinguishable if no efficient algorithm</p>

    <p class="text-gray-300">can distinguish them with non-negligible probability. We say they are statistically indistinguishable if the statistical distance between them is bounded by a negligible function.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">2.1 Non-Interactive Batch Arguments for NP</h3>

    <p class="text-gray-300">In this work, we consider the NP-complete language of Boolean circuit satisfiability. For ease of exposition, we focus on Boolean circuits comprised exclusively of NAND gates in our main construction. In Remark 4.16, we describe how to generalize the construction to support gates that compute arbitrary quadratic relations over their inputs. This allows us to support both general gates (e.g., AND, OR, XOR) as well as gates with more than two inputs.</p>

    <p class="text-gray-300">For a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> with <span class="math">t</span> wires, we associate wires <span class="math">1,\\ldots,n</span> with the bits of the statement <span class="math">x_{1},\\ldots,x_{n}</span>, and wires <span class="math">n+1,\\ldots,n+h</span> with the bits of the witness <span class="math">w_{1},\\ldots,w_{h}</span>, respectively. We associate wire <span class="math">t</span> with the output wire. We measure the size <span class="math">s</span> of <span class="math">C</span> by the number of NAND gates it has. By construction, <span class="math">t\\leq n+h+s</span>. We now define the (batch) circuit satisfiability language we consider in this work:</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 2.1 (Circuit Satisfiability).</h6>

    <p class="text-gray-300">We define <span class="math">\\mathcal{L}_{\\mathrm{CSAT}}=\\{(C,\\mathbf{x})\\mid\\exists\\mathbf{w}\\in\\{0,1\\}^{h}:C(\\mathbf{x},\\mathbf{w})=1\\}</span> to be the language of Boolean circuit satisfiability, where <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> is a Boolean circuit and <span class="math">\\mathbf{x}\\in\\{0,1\\}^{n}</span> is a statement. For a positive integer <span class="math">m\\in\\mathbb{N}</span>, we define the <em>batch circuit satisfiability</em> language <span class="math">\\mathcal{L}_{\\mathrm{BatchCSAT},m}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathrm{BatchCSAT},m}=\\{(C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})\\mid\\forall i\\in[m]:\\exists\\mathbf{w}_{i}\\in\\{0,1\\}^{h}:C(\\mathbf{x}_{i},\\mathbf{w}_{i})=1\\},</span></p>

    <p class="text-gray-300">where <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> is a Boolean circuit and <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span> are the instances.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 2.2 (Batch Argument for Circuit Satisfiability).</h6>

    <p class="text-gray-300">A non-interactive batch argument (BARG) for circuit satisfiability is a tuple of three efficient algorithms <span class="math">\\Pi_{\\mathrm{BARG}}=({\\mathrm{Setup}},\\mathrm{Prove},\\mathrm{Verify})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s})\\to\\mathrm{crs}</span>: On input the security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, the number of instances <span class="math">m\\in\\mathbb{N}</span>, and a bound on the circuit size <span class="math">s\\in\\mathbb{N}</span>, the setup algorithm outputs a common reference string <span class="math">\\mathrm{crs}</span>.</li>

      <li><span class="math">\\mathrm{Prove}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}))\\to\\pi</span>: On input the common reference string <span class="math">\\mathrm{crs}</span>, a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span>, statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and witnesses <span class="math">\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}\\in\\{0,1\\}^{h}</span>, the prove algorithm outputs a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathrm{Verify}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)\\to b</span>: On input the common reference string <span class="math">\\mathrm{crs}</span>, the Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span>, statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span> and a proof <span class="math">\\pi</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 2.3 (Completeness).</h6>

    <p class="text-gray-300">A BARG <span class="math">\\Pi_{\\mathrm{BARG}}=({\\mathrm{Setup}},\\mathrm{Prove},\\mathrm{Verify})</span> is complete if for all <span class="math">\\lambda,m,s\\in\\mathbb{N}</span>, all Boolean circuits <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, all statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and all witnesses <span class="math">\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}\\in\\{0,1\\}^{h}</span> where <span class="math">C(\\mathbf{x}_{i},\\mathbf{w}_{i})=1</span> for all <span class="math">i\\in[m]</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathrm{Verify}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)=1:\\begin{array}[]{c}\\mathrm{crs}\\leftarrow\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s});\\\\ \\pi\\leftarrow\\mathrm{Prove}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}))\\end{array}\\right]=1. \\]</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 2.4 (Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathrm{BARG}}=({\\mathrm{Setup}},\\mathrm{Prove},\\mathrm{Verify})</span> be a BARG. We consider two notions of soundness:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-adaptive soundness: We say that <span class="math">\\Pi_{\\mathrm{BARG}}</span> satisfies non-adaptive soundness if for all polynomials <span class="math">m=m(\\lambda)</span>, <span class="math">s=s(\\lambda)</span>, and efficient adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, and every statement <span class="math">(C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})\\notin\\mathcal{L}_{\\mathrm{BatchCSAT},m}</span>, where <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> is a Boolean circuit of size at most <span class="math">s(\\lambda)</span> and <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{n}\\in\\{0,1\\}^{n}</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathrm{Verify}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)=1:\\begin{array}[]{c}\\mathrm{crs}\\leftarrow\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s});\\\\ \\pi\\leftarrow\\mathcal{A}(1^{\\lambda},\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}))\\end{array}\\right]=\\mathrm{negl}(\\lambda). \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive soundness: We say that <span class="math">\\Pi_{\\mathrm{BARG}}</span> is adaptively sound if for every efficient adversary <span class="math">\\mathcal{A}</span> and every polynomial <span class="math">m=m(\\lambda)</span>, <span class="math">s=s(\\lambda)</span>, there exists a negligible function of <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathrm{Verify}(\\mathrm{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)=1\\\\ \\text{and}\\\\ (C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})\\notin\\mathcal{L}_{\\mathrm{BatchCSAT},m}\\end{array}:\\begin{array}[]{c}\\mathrm{crs}\\leftarrow\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s});\\\\ (C,\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m},\\pi)\\leftarrow\\mathcal{A}(1^{\\lambda},\\mathrm{crs})\\end{array}\\right]=\\mathrm{negl}(\\lambda). \\]</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 2.5 (Semi-Adaptive Somewhere Soundness <em>[x10]</em>).</h6>

    <p class="text-gray-300">A BARG <span class="math">\\Pi_{\\text{BARG}}=</span> (Setup, Prove, Verify) satisfies semi-adaptive somewhere soundness if there exists an efficient algorithm TrapSetup with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{<em>})\\to\\text{crs}^{</em>}</span>: On input the security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, the number of instances <span class="math">m\\in\\mathbb{N}</span>, the size of the circuit <span class="math">s\\in\\mathbb{N}</span>, and an index <span class="math">i^{<em>}\\in[m]</span>, the trapdoor setup algorithm outputs a (trapdoor) common reference string <span class="math">\\text{crs}^{</em>}</span>.</li>

    </ul>

    <p class="text-gray-300">We require TrapSetup satisfy the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS indistinguishability: For integers <span class="math">m\\in\\mathbb{N}</span>, <span class="math">s\\in\\mathbb{N}</span>, a bit <span class="math">b\\in\\{0,1\\}</span>, and an adversary <span class="math">\\mathcal{A}</span>, define the CRS indistinguishability experiment <span class="math">\\text{ExptCRS}_{\\mathcal{A}}(\\lambda,m,s,b)</span> as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda},1^{m},1^{s})</span> outputs an index <span class="math">i^{*}\\in[m]</span>.</li>

      <li>If <span class="math">b=0</span>, the challenger gives <span class="math">\\text{crs}\\leftarrow\\text{Setup}(1^{\\lambda},1^{m},1^{s})</span> to <span class="math">\\mathcal{A}</span>. If <span class="math">b=1</span>, the challenger gives <span class="math">\\text{crs}^{<em>}\\leftarrow\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{</em>})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}\\in\\{0,1\\}</span>, which is the output of the experiment.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{\\text{BARG}}</span> satisfies CRS indistinguishability if for every efficient adversary <span class="math">\\mathcal{A}</span>, every polynomial <span class="math">m=m(\\lambda)</span>, <span class="math">s=s(\\lambda)</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{ExptCRS}_{\\mathcal{A}}(\\lambda,m,s,0)=1]-\\Pr[\\text{ExptCRS}_{\\mathcal{A}}(\\lambda,m,s,1)=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere soundness in trapdoor mode: Define the somewhere soundness security game between an adversary <span class="math">\\mathcal{A}</span> and a challenger as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda},1^{m},1^{s})</span> outputs an index <span class="math">i^{*}\\in[m]</span>.</li>

      <li>The challenger samples <span class="math">\\text{crs}^{<em>}\\leftarrow\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{</em>})</span> and gives <span class="math">\\text{crs}^{*}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and a proof <span class="math">\\pi</span>. The output of the game is <span class="math">b=1</span> if <span class="math">\\text{Verify}(\\text{crs}^{<em>},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)=1</span> and <span class="math">(C,\\mathbf{x}_{i^{</em>}})\\notin\\mathcal{L}_{\\text{CSAT}}</span>. Otherwise, the output is <span class="math">b=0</span>.</li>

    </ul>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{\\text{BARG}}</span> satisfies somewhere soundness in trapdoor mode if for every adversary <span class="math">\\mathcal{A}</span>, and every polynomial <span class="math">m=m(\\lambda)</span>, <span class="math">s=s(\\lambda)</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\Pr[b=1]=\\text{negl}(\\lambda)</span> in the somewhere soundness security game.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 2.6 (Somewhere Argument of Knowledge <em>[x10]</em>).</h6>

    <p class="text-gray-300">A BARG <span class="math">\\Pi_{\\text{BARG}}=</span> (Setup, Prove, Verify) is a somewhere argument of knowledge if there exists a pair of efficient algorithms (TrapSetup, Extract) with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{<em>})\\to(\\text{crs}^{</em>},\\text{td})</span>: On input the security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, the number of instances <span class="math">m\\in\\mathbb{N}</span>, the size of the circuit <span class="math">s\\in\\mathbb{N}</span>, and an index <span class="math">i^{<em>}\\in[m]</span>, the trapdoor setup algorithm outputs a common reference string <span class="math">\\text{crs}^{</em>}</span> and an extraction trapdoor <span class="math">\\text{td}</span>.</li>

      <li><span class="math">\\text{Extract}(\\text{td},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)\\to\\mathbf{w}^{<em>}</span> On input the trapdoor <span class="math">\\text{td}</span>, statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}</span>, and a proof <span class="math">\\pi</span>, the extraction algorithm outputs a witness <span class="math">\\mathbf{w}^{</em>}\\in\\{0,1\\}^{h}</span>. The extraction algorithm is deterministic.</li>

    </ul>

    <p class="text-gray-300">We require (TrapSetup, Extract) to satisfy the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS indistinguishability: Same as in Definition 2.5.</li>

      <li>Somewhere extractable in trapdoor mode: Define the somewhere extractable security game between an adversary <span class="math">\\mathcal{A}</span> and a challenger as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda},1^{m},1^{s})</span> outputs an index <span class="math">i^{*}\\in[m]</span>.</li>

      <li>The challenger samples <span class="math">(\\text{crs}^{<em>},\\text{td})\\leftarrow\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{</em>})</span> and gives <span class="math">\\text{crs}^{*}</span> to <span class="math">\\mathcal{A}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and a proof <span class="math">\\pi</span>. Let <span class="math">\\mathbf{w}^{*}\\leftarrow\\text{Extract}(\\operatorname{td},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{w}_{m}),\\pi)</span>.</li>

      <li>The output of the game is <span class="math">b=1</span> if <span class="math">\\text{Verify}(\\operatorname{crs}^{<em>},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)=1</span> and <span class="math">C(\\mathbf{x}_{i^{</em>}},\\mathbf{w}^{*})\\neq 1</span>. Otherwise, the output is <span class="math">b=0</span>.</li>

    </ul>

    <p class="text-gray-300">Then <span class="math">\\Pi_{\\text{BARG}}</span> is somewhere extractable in trapdoor mode if for every adversary <span class="math">\\mathcal{A}</span> and every polynomial <span class="math">m=m(\\lambda)</span>, <span class="math">s=s(\\lambda)</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that <span class="math">\\Pr[b=1]=\\operatorname{negl}(\\lambda)</span> in the somewhere extractable game.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 2.7 (Soundness Notions).</h6>

    <p class="text-gray-300">The notion of semi-adaptive somewhere soundness from Definition 2.5 is stronger than and implies non-adaptive soundness. Somewhere extractability (Definition 2.6) is a further strengthening of semi-adaptive somewhere soundness.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 2.8 (Succinctness).</h6>

    <p class="text-gray-300">A BARG <span class="math">\\Pi_{\\text{BARG}}=(\\text{Setup},\\text{Prove},\\text{Verify})</span> is succinct if there exists a fixed polynomial <span class="math">\\operatorname{poly}(\\cdot,\\cdot,\\cdot)</span> such that for all <span class="math">\\lambda,m,s\\in\\mathbb{N}</span>, all <span class="math">\\operatorname{crs}</span> in the support of <span class="math">\\text{Setup}(1^{\\lambda},1^{m},1^{s})</span>, and all Boolean circuits <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, the following properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct proofs: The proof <span class="math">\\pi</span> output by <span class="math">\\text{Prove}(\\operatorname{crs},C,\\cdot,\\cdot)</span> satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(\\lambda,\\log m,s)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification: The verification algorithm runs in time <span class="math">\\operatorname{poly}(\\lambda,m,n)+\\operatorname{poly}(\\lambda,\\log m,s)</span>.</li>

    </ul>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">BARGs with split verification.</h4>

    <p class="text-gray-300">Our bootstrapping construction in Section 5 (for reducing the size of the CRS) will rely on a BARG with a split verification property where the verification algorithm can be decomposed into a input-dependent algorithm that pre-processes the statements into a short verification key together with a fast online verification algorithm that takes the precomputed verification key and checks the proof. A similar property was also considered by Choudhuri et al. <em>[x10]</em> to realize their RAM delegation construction.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 2.9 (BARG with Split Verification).</h6>

    <p class="text-gray-300">A BARG <span class="math">\\Pi_{\\text{BARG}}=(\\text{Setup},\\text{Prove},\\text{Verify})</span> supports split verification if there exists a pair of efficient and deterministic algorithms <span class="math">(\\text{GenVK},\\text{OnlineVerify})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{GenVK}(\\operatorname{crs},(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}))\\to\\text{vk}</span>: On input the common reference string <span class="math">\\operatorname{crs}</span> and statements <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, the verification key generation algorithm outputs a verification key <span class="math">\\operatorname{vk}</span>.</li>

      <li><span class="math">\\text{OnlineVerify}(\\operatorname{vk},C,\\pi)\\to b</span>: On input a verification key <span class="math">\\operatorname{vk}</span>, a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> and a proof <span class="math">\\pi</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Then, we say <span class="math">\\Pi_{\\text{BARG}}</span> supports split verification if <span class="math">\\text{Verify}(\\operatorname{crs},C,(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}),\\pi)</span> outputs</p>

    <p class="text-gray-300"><span class="math">\\text{OnlineVerify}(\\text{GenVK}(\\operatorname{crs},(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})),C,\\pi).</span></p>

    <p class="text-gray-300">We additionally require that there exists a fixed polynomial <span class="math">\\operatorname{poly}(\\cdot,\\cdot,\\cdot)</span> such that for all <span class="math">\\lambda,m,s\\in\\mathbb{N}</span>, all <span class="math">\\operatorname{crs}</span> in the support of <span class="math">\\text{Setup}(1^{\\lambda},1^{m},1^{s})</span>, and all Boolean circuits <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, the following efficiency properties hold (in addition to the properties in Definition 2.8):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct verification key: The verification key generation algorithm <span class="math">\\text{GenVK}</span> runs in time <span class="math">\\operatorname{poly}(\\lambda,m,n)</span>, and the size of the <span class="math">\\operatorname{vk}</span> output by <span class="math">\\text{GenVK}</span> satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(\\lambda,\\log m,n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct online verification: The algorithm <span class="math">\\text{OnlineVerify}(\\operatorname{vk},C,\\pi)</span> runs in time <span class="math">\\operatorname{poly}(\\lambda,\\log m,s)</span>.</li>

    </ul>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 2.10 (BARGs for Index Languages <em>[x10]</em>).</h6>

    <p class="text-gray-300">BARGs for index languages <em>[x10]</em> (“index BARGs”) are a useful building block for constructing delegation schemes for RAM programs. In an index BARG with <span class="math">m</span> instances, the statement to the <span class="math">i^{\\text{th}}</span> instance is the binary representation of the index <span class="math">i</span>. Since the statements are fixed in an index BARG, they are not included in the input to the Prove and Verify algorithms. Moreover, the running time</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of the verification algorithm Verify on input a verification key vk, a circuit <span class="math">C</span>, and a proof <span class="math">\\pi</span> is required to be $\\mathrm{poly}(\\lambda,\\log m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It is easy to see that any BARG with a split verification procedure can also be used to build an index BARG. Specifically, after the Setup algorithm samples the common reference string crs, it precomputes the (short) verification key vk </span>\\leftarrow<span class="math"> GenVK(crs, </span>(1,2,\\ldots,m)<span class="math">). The verification algorithm Verify then takes as input the precomputed verification key vk, the circuit </span>C<span class="math">, and the proof </span>\\pi<span class="math">, and outputs OnlineVerify(vk, </span>C,\\pi$). The succinctness requirements on the split verification procedure implies the succinctness requirement on the index BARG.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-44" class="text-2xl font-bold">3 BARG for NP from Subgroup Decision in Bilinear Groups</h2>

    <p class="text-gray-300">In this section, we show how to construct a BARGs from the subgroup decision assumption over symmetric composite-order groups. We refer to Section 1.2.1 for a general overview of this construction. We start by recalling the definition of a composite-order pairing group <em>[x1]</em> and the subgroup decision assumption.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 3.1 (Composite-Order Bilinear Groups <em>[x1]</em>).</h6>

    <p class="text-gray-300">A (symmetric) composite-order bilinear group generator is an efficient algorithm CompGroupGen that takes as input the security parameter <span class="math">\\lambda</span> and outputs a description <span class="math">\\mathcal{G}=(\\mathbb{G},\\mathbb{G}_{T},p,q,g,e)</span> of a bilinear group where <span class="math">p,q</span> are distinct primes, <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{T}</span> are cyclic groups of order <span class="math">N=pq</span>, and <span class="math">e\\colon\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{T}</span> is a non-degenerate bilinear map (called the ”pairing”). We require that the group operation in <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{T}</span> as well as the pairing operation to be efficiently computable.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 3.2 (Subgroup Decision <em>[x1]</em>).</h6>

    <p class="text-gray-300">The subgroup decision assumption holds with respect to a composite-order bilinear group generator CompGroupGen if for every efficient adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[\\mathcal{A}((\\mathbb{G},\\mathbb{G}_{T},N,g_{p},e),g^{r})=1]-\\Pr[\\mathcal{A}((\\mathbb{G},\\mathbb{G}_{T},N,g_{p},e),g^{r}_{p})=1]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\mathrm{negl}(\\lambda),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">(\\mathbb{G},\\mathbb{G}_{T},p,q,g,e)\\leftarrow\\mathrm{CompGroupGen}(1^{\\lambda})</span>, <span class="math">N\\leftarrow pq</span>, <span class="math">g_{p}\\leftarrow g^{q}</span>, and <span class="math">r\\stackrel{{\\scriptstyle\\mathtt{B}}}{{\\leftarrow}}\\mathbb{Z}_{N}</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Construction 3.3 (BARG for NP from Subgroup Decision).</h6>

    <p class="text-gray-300">Take any integer <span class="math">m\\in\\mathbb{N}</span>. We construct a BARG with split verification for the language of circuit satisfiability as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup<span class="math">(1^{\\lambda},1^{m},1^{s})</span>: On input the security parameter <span class="math">\\lambda</span>, the number of instances <span class="math">m</span>, and the bound on the circuit size <span class="math">s</span>, the setup algorithm does the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">(\\mathbb{G},\\mathbb{G}_{T},p,q,g,e)\\leftarrow\\mathrm{GroupGen}(1^{\\lambda})</span> and let <span class="math">N=pq</span>, <span class="math">g_{p}\\leftarrow g^{q}</span>. In particular, <span class="math">g_{p}</span> generates a subgroup of order <span class="math">p</span> in <span class="math">\\mathbb{G}</span>. Let <span class="math">\\mathcal{G}=(\\mathbb{G},\\mathbb{G}_{T},N,g_{p},e)</span>.</li>

      <li>For each <span class="math">i\\in[m]</span>, sample <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\mathtt{B}}}{{\\leftarrow}}\\mathbb{Z}_{N}</span>. For each <span class="math">i\\in[m]</span>, let <span class="math">A_{i}\\leftarrow g_{p}^{\\alpha_{i}}</span>. Let <span class="math">A\\leftarrow\\prod_{i\\in[m]}A_{i}</span>.</li>

      <li>For each <span class="math">i,j\\in[m]</span> where <span class="math">i\\neq j</span>, compute <span class="math">B_{i,j}\\leftarrow g_{p}^{\\alpha_{i}\\alpha_{j}}</span>.</li>

      <li>Output the common reference string <span class="math">\\mathrm{crs}=\\big{(}\\mathcal{G},A,\\{A_{i}\\}_{i\\in[m]},\\{B_{i,j}\\}_{i\\neq j}\\big{)}</span>.</li>

      <li>Prove(crs, <span class="math">C</span>, <span class="math">(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span>, <span class="math">(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m})</span>): On input the common reference string <span class="math">\\mathrm{crs}=(\\mathcal{G},A,\\{A_{i}\\}_{i\\in[m]},\\{B_{i,j}\\}_{i\\neq j})</span>, the circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span>, instances <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and witnesses <span class="math">\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}\\in\\{0,1\\}^{h}</span>, define <span class="math">t</span> to be the number of wires in <span class="math">C</span> and <span class="math">s</span> to be the number of gates in <span class="math">C</span>. Then, for <span class="math">i\\in[m]</span> and <span class="math">j\\in[t]</span>, let <span class="math">w_{i,j}\\in\\{0,1\\}</span> be the value of wire <span class="math">j</span> in <span class="math">C(\\mathbf{x}_{i},\\mathbf{w}_{i})</span>. The prover proceeds as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encoding wire values: For each <span class="math">k\\in[t]</span>, let <span class="math">U_{k}=\\prod_{i\\in[m]}A_{i}^{w_{i,k}}</span>.</li>

      <li>Validity of wire assignments: For each <span class="math">k\\in[t]</span>, let <span class="math">V_{k}=\\prod_{i\\neq j}B_{i,j}^{(1-w_{i,k})\\,w_{j,k}}</span>.</li>

      <li>Validity of gate computation: For each NAND gate <span class="math">G_{\\ell}=(k_{1},k_{2},k_{3})\\in[t]^{3}</span> (where <span class="math">\\ell\\in[s]</span>), compute <span class="math">W_{\\ell}=\\prod_{i\\neq j}B_{i,j}^{(-\\omega_{i,k_{1}}\\,\\omega_{j,k_{2}}-\\omega_{j,k_{3}}}</span></li>

    </ul>

    <p class="text-gray-300">Finally, output the proof <span class="math">\\pi = \\left(\\{U_k,V_k\\}_{k\\in [t]},\\{W_\\ell \\}_{\\ell \\in [s]}\\right)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify(crs, <span class="math">C</span>, <span class="math">(\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi</span>): We decompose the verification algorithm into (GenVK, OnlineVerify):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenVK(crs, <span class="math">(\\mathbf{x}_1, \\ldots, \\mathbf{x}_m)</span>): On input the common reference string <span class="math">\\mathrm{crs} = (\\mathcal{G}, A, \\{A_i\\}_{i \\in [m]}, \\{B_{i,j}\\}_{i \\neq j})</span>, instances <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span>, the verification key generation algorithm computes <span class="math">U_k^<em> = \\prod_{i \\in [m]} A_i^{x_{i,k}}</span> for each <span class="math">k \\in [n]</span>, and outputs the verification key <span class="math">\\mathrm{vk} = (U_1^</em>, \\ldots, U_n^*)</span>.</li>

      <li>OnlineVerify(vk, <span class="math">C, \\pi</span>): On input the verification key <span class="math">\\mathrm{vk} = (U_1^<em>, \\ldots, U_n^</em>)</span>, a circuit <span class="math">C: \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span> and the proof <span class="math">\\pi = (\\{U_k, V_k\\}_{k \\in [t]}, \\{W_\\ell\\}_{\\ell \\in [s]})</span>, the verification algorithm checks the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of statement: For each input wire <span class="math">k \\in [n]</span>, <span class="math">U_k = U_k^*</span>.</li>

      <li>Validity of wire assignments: For each <span class="math">k \\in [t]</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(A, U_k) = e(g_p, V_k) e(U_k, U_k). \\tag{3.1}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of gate computation: For each gate <span class="math">G_\\ell = (k_1, k_2, k_3) \\in [t]^3</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(A, A) = e(U_{k_1}, U_{k_2}) e(A, U_{k_3}) e(g_p, W_\\ell). \\tag{3.2}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output satisfiability: The output encoding <span class="math">U_t</span> satisfies <span class="math">U_t = A</span>.</li>

    </ul>

    <p class="text-gray-300">The algorithm outputs 1 if all checks pass, and outputs 0 otherwise.</p>

    <p class="text-gray-300">The verification algorithm outputs OnlineVerify(GenVK(crs, <span class="math">(\\mathbf{x}_1, \\ldots, \\mathbf{x}_m))</span>, <span class="math">C, \\pi</span>).</p>

    <p class="text-gray-300"><strong>Theorem 3.4 (Completeness).</strong> Construction 3.3 is complete.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Take any circuit <span class="math">C: \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span>, instances <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0,1\\}^n</span> and witnesses <span class="math">\\mathbf{w}_1, \\ldots, \\mathbf{w}_m \\in \\{0,1\\}^h</span> such that <span class="math">C(\\mathbf{x}_i, \\mathbf{w}_i) = 1</span> for all <span class="math">i \\in [m]</span>. Let <span class="math">\\mathrm{crs} \\gets \\mathrm{Setup}(1^\\lambda, 1^m, 1^s)</span> and <span class="math">\\pi \\gets \\mathrm{Prove}(\\mathrm{crs}, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), (\\mathbf{w}_1, \\ldots, \\mathbf{w}_m))</span>. We show that <span class="math">\\mathrm{Verify}(\\mathrm{crs}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi)</span> outputs 1. Consider each of the verification relations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of statement: By construction of GenVK, <span class="math">U_k^<em> = \\prod_{i \\in [m]} A_i^{x_{i,k}}</span> for each <span class="math">k \\in [n]</span>. By construction of Prove, <span class="math">U_k = \\prod_{i \\in [m]} A_i^{w_{i,k}}</span>. By definition, the first <span class="math">n</span> wires in <span class="math">C</span> coincide with the wires to the statement, so <span class="math">w_{i,k} = x_{i,k}</span> for <span class="math">k \\in [n]</span>, and <span class="math">U_k = U_k^</em></span> for all <span class="math">k \\in [n]</span>.</li>

      <li>Validity of wire assignments: Take any <span class="math">k \\in [t]</span>. Then <span class="math">U_k = \\prod_{i \\in [m]} A_i^{w_{i,k}} = g_p^{\\sum_{i \\in [m]} \\alpha_i w_{i,k}}</span>. Now,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i \\in [m]} \\alpha_i\\right) \\left(\\sum_{j \\in [m]} \\alpha_j w_{j,k}\\right) = \\sum_{i \\in [m]} \\alpha_i^2 w_{i,k} + \\sum_{i \\neq j} \\alpha_i \\alpha_j w_{j,k},</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{i \\in [m]} \\alpha_i w_{i,k}\\right) \\left(\\sum_{j \\in [m]} \\alpha_j w_{j,k}\\right) = \\sum_{i \\in [m]} \\alpha_i^2 w_{i,k} + \\sum_{i \\neq j} \\alpha_i \\alpha_j w_{i,k} w_{j,k},</span></div>

    <p class="text-gray-300">using the fact that <span class="math">w_{i,k} \\in \\{0,1\\}</span> so <span class="math">w_{i,k}^2 = w_{i,k}</span>. Finally <span class="math">V_k = \\prod_{i \\neq j} B_{i,j}^{(1 - w_{i,k})w_{j,k}} = g_p^{\\sum_{i \\neq j} \\alpha_i \\alpha_j (1 - w_{i,k})w_{j,k}}</span>. Thus, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e(g_p, V_k) e(U_k, U_k) &amp;amp;= e(g_p, g_p)^{\\sum_{i \\neq j} \\alpha_i \\alpha_j (1 - w_{i,k}) w_{j,k} + \\sum_{i \\in [m]} \\alpha_i^2 w_{i,k} + \\sum_{i \\neq j} \\alpha_i \\alpha_j w_{i,k} w_{j,k}} \\\\ &amp;amp;= e(g_p, g_p)^{\\sum_{i \\in [m]} \\alpha_i^2 w_{i,k} + \\sum_{i \\neq j} \\alpha_i \\alpha_j w_{j,k}} \\\\ &amp;amp;= e(A, U_k). \\end{aligned}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of gate computation: Take any gate  <span class="math">G_{\\ell} = (k_{1}, k_{2}, k_{3}) \\in [t]^{3}</span> . Consider first the exponents for the terms  <span class="math">e(U_{k_1}, U_{k_2})</span> ,  <span class="math">e(A, U_{k_3})</span> , and  <span class="math">e(A, A)</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\sum_ {i \\in [ m ]} \\alpha_ {i} w _ {i, k _ {1}}\\right) \\left(\\sum_ {j \\in [ m ]} \\alpha_ {j} w _ {j, k _ {2}}\\right) = \\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} w _ {i, k _ {1}} w _ {i, k _ {2}} + \\sum_ {i \\neq j} \\alpha_ {i} \\alpha_ {j} w _ {i, k _ {1}} w _ {j, k _ {2}} \\\\ \\left(\\sum_ {i \\in [ m ]} \\alpha_ {i}\\right) \\left(\\sum_ {j \\in [ m ]} \\alpha_ {j} w _ {j, k _ {3}}\\right) = \\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} w _ {i, k _ {3}} + \\sum_ {i \\neq j} \\alpha_ {i} \\alpha_ {j} w _ {j, k _ {3}} \\\\ \\left(\\sum_ {i \\in [ m ]} \\alpha_ {i}\\right) \\left(\\sum_ {j \\in [ m ]} \\alpha_ {j}\\right) = \\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} + \\sum_ {i \\neq j} \\alpha_ {i} \\alpha_ {j}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By definition  <span class="math">w_{i,k_3} = \\mathrm{NAND}(w_{i,k_1},w_{i,k_2})</span> . This means that for each  <span class="math">i\\in [m]</span> , either  <span class="math">(w_{i,k_1}w_{i,k_2} = 1</span>  and  <span class="math">w_{i,k_3} = 0</span> ) or  <span class="math">(w_{i,k_1}w_{i,k_2} = 0</span>  and  <span class="math">w_{i,k_3} = 1</span> ). This means that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} (w _ {i, k _ {1}} w _ {i, k _ {2}} + w _ {i, k _ {3}}) = \\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2}.</span></div>

    <p class="text-gray-300">Combining the above relations in the exponent, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\frac {e (A , A)}{e \\left(U _ {k _ {1}} , U _ {k _ {2}}\\right) e \\left(A , U _ {k _ {3}}\\right)} = \\frac {e \\left(g _ {p} , g _ {p}\\right) ^ {\\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} + \\sum_ {i \\neq j} \\alpha_ {i} \\alpha_ {j}}}{e \\left(g _ {p} , g _ {p}\\right) ^ {\\sum_ {i \\in [ m ]} \\alpha_ {i} ^ {2} + \\sum_ {i \\neq j} \\alpha_ {i} \\alpha_ {j} \\left(w _ {i , k _ {1}} w _ {j , k _ {2}} + w _ {j , k _ {3}}\\right)}} \\\\ = \\prod_ {i \\neq j} e (g _ {p}, B _ {i, j}) ^ {1 - w _ {i, k _ {1}} w _ {j, k _ {2}} - w _ {j, k _ {3}}} \\\\ = e \\left(g _ {p}, W _ {\\ell}\\right). \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output satisfiability: Since  <span class="math">C(\\mathbf{x}_i, \\mathbf{w}_i) = 1</span> , it follows that  <span class="math">w_{i,t} = 1</span>  for all  <span class="math">i \\in [m]</span> . By definition,  <span class="math">U_t = \\prod_{i \\in [m]} A_i^{w_{i,t}} = \\prod_{i \\in [m]} A_i = A</span> .</li>

    </ul>

    <p class="text-gray-300">Theorem 3.5 (Somewhere Argument of Knowledge). Suppose the subgroup decision assumption holds with respect to CompGroupGen. Then, Construction 3.3 is a somewhere argument of knowledge.</p>

    <p class="text-gray-300">Proof. We start by defining the trapdoor setup and extraction algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TrapSetup  <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, i^{*})</span> : The trapdoor algorithm uses the following procedure (we highlight in green the differences in the common reference string components between TrapSetup and Setup):</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">(\\mathbb{G},\\mathbb{G}_T,p,q,g,e)\\gets \\mathrm{GroupGen}(1^\\lambda)</span>  and let  <span class="math">N = pq</span> <span class="math">g_{p}\\gets g^{q}</span>  . Let  <span class="math">\\mathcal{G} = (\\mathbb{G},\\mathbb{G}_T,N,g_p,e)</span></li>

      <li>For each  <span class="math">i\\in [m]</span> , sample  <span class="math">\\alpha_{i}\\stackrel {\\mathrm{R}}{\\leftarrow}\\mathbb{Z}_{N}</span> . For each  <span class="math">i\\neq i^{<em>}</span> , let  <span class="math">A_{i}\\gets g_{p}^{\\alpha_{i}}</span> . Let  <span class="math">A_{i^{</em>}}\\gets g^{\\alpha_{i^{<em>}}}</span> . Let  <span class="math">A\\gets A_{i^{</em>}}\\prod_{i\\neq i^{*}}A_{i}</span></li>

      <li>For each  <span class="math">i,j\\in [m]</span>  where  <span class="math">i\\neq j</span>  and  <span class="math">i,j\\neq i^{<em>}</span> , compute  <span class="math">B_{i,j}\\gets g_p^{\\alpha_i\\alpha_j}</span> . Compute  <span class="math">B_{i^{</em>},j}\\gets A_{i^{<em>}}^{\\alpha_j}</span>  and  <span class="math">B_{i,i^{</em>}}\\gets A_{i^{<em>}}^{\\alpha_i}</span>  for all  <span class="math">i,j\\neq i^{</em>}</span> .</li>

      <li>Output the common reference string  <span class="math">\\mathrm{crs}^* = \\left(\\mathcal{G}, A, \\{A_i\\}_{i \\in [m]}, \\{B_{i,j}\\}_{i \\neq j}\\right)</span>  and the trapdoor  <span class="math">\\mathrm{td} = g_q \\gets g^p</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract  <span class="math">(\\mathrm{td}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi)</span> : On input the trapdoor  <span class="math">\\mathrm{td} = g_q</span> , the Boolean circuit  <span class="math">C \\colon \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span> , statements  <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span> , and the proof  <span class="math">\\pi = \\left( \\{U_k, V_k\\}_{k \\in [t]}, \\{W_\\ell\\}_{\\ell \\in [s]} \\right)</span> , the extraction algorithm sets  <span class="math">w_k^<em> = 0</span>  if  <span class="math">e(g_q, U_k) = 1</span>  and  <span class="math">w_k^</em> = 1</span>  otherwise for each  <span class="math">k = n + 1, \\ldots, n + h</span> . It outputs  <span class="math">\\mathbf{w}^<em> = (w_{n+1}^</em>, \\ldots, w_{n+h}^*)</span> .</li>

    </ul>

    <p class="text-gray-300">We now show the CRS indistinguishability and somewhere extractable in trapdoor mode properties.</p>

    <p class="text-gray-300">Lemma 3.6 (CRS Indistinguishability). If the subgroup decision assumption holds with respect to CompGroupGen, then Construction 3.3 satisfies CRS indistinguishability.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any polynomial <span class="math">m=m(\\lambda),s=s(\\lambda)</span>. We proceed via a hybrid argument:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_{0}</span>: This is the real distribution. At the beginning of the security game, the adversary chooses an index <span class="math">i^{*}\\in[m]</span>. The challenger then constructs the common reference string by running <span class="math">\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s})</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Run}\\ (\\mathbb{G},\\mathbb{G}_{T},p,q,g,e)\\leftarrow\\mathrm{GroupGen}(1^{\\lambda})</span> and let <span class="math">N=pq</span>, <span class="math">g_{p}\\leftarrow g^{q}</span>. Let <span class="math">\\mathcal{G}=(\\mathbb{G},\\mathbb{G}_{T},N,g_{p},e)</span>.</li>

      <li>For each <span class="math">i\\in[m]</span>, sample <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\tt R}}{{\\leftarrow}}\\mathbb{Z}_{N}</span>. For each <span class="math">i\\in[m]</span>, let <span class="math">A_{i}\\leftarrow g_{p}^{\\alpha_{i}}</span>. Let <span class="math">A\\leftarrow\\prod_{i\\in[m]}A_{i}</span>.</li>

      <li>For each <span class="math">i,j\\in[m]</span> where <span class="math">i\\neq j</span>, compute <span class="math">B_{i,j}\\leftarrow g_{p}^{\\alpha_{i}\\alpha_{j}}</span>.</li>

      <li>Output the common reference string <span class="math">\\mathrm{crs}=\\big{(}\\mathcal{G},A,\\{A_{i}\\}_{i\\in[m]},\\{B_{i,j}\\}_{i\\neq j}\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">The challenger gives <span class="math">\\mathrm{crs}</span> to <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}\\in\\{0,1\\}</span>, which is the output of the experiment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_{1}</span>: Same as <span class="math">\\mathrm{Hyb}_{0}</span> except the challenger constructs <span class="math">A</span> and <span class="math">B_{i,j}</span> using the procedure from <span class="math">\\mathrm{TrapSetup}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[m]</span>, sample <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\tt R}}{{\\leftarrow}}\\mathbb{Z}_{N}</span>. For each <span class="math">i\\in[m]</span>, let <span class="math">A_{i}\\leftarrow g_{p}^{\\alpha_{i}}</span>. Let <span class="math">A\\leftarrow A_{i^{<em>}}\\prod_{i\\neq i^{</em>}}A_{i}</span>.</li>

      <li>For each <span class="math">i,j\\in[m]</span> where <span class="math">i\\neq j</span> and <span class="math">i,j\\neq i^{<em>}</span>, compute <span class="math">B_{i,j}\\leftarrow g_{p}^{\\alpha_{i}\\alpha_{j}}</span>. Compute <span class="math">B_{i^{</em>},j}\\leftarrow A_{i^{<em>}}^{\\alpha_{j}}</span> and <span class="math">B_{i,i^{</em>}}\\leftarrow A_{i^{<em>}}^{\\alpha_{j}}</span> for all <span class="math">i,j\\neq i^{</em>}</span>.</li>

      <li><span class="math">\\mathrm{Hyb}_{2}</span>: Same as <span class="math">\\mathrm{Hyb}_{1}</span> except the challenger samples <span class="math">A_{i^{<em>}}\\leftarrow g^{\\alpha_{i^{</em>}}}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[m]</span>, sample <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\tt R}}{{\\leftarrow}}\\mathbb{Z}_{N}</span>. For each <span class="math">i\\neq i^{<em>}</span>, let <span class="math">A_{i}\\leftarrow g_{p}^{\\alpha_{i}}</span>. Let <span class="math">A_{i^{</em>}}\\leftarrow g^{\\alpha_{i^{<em>}}}</span>. Let <span class="math">A\\leftarrow A_{i^{</em>}}\\prod_{i\\neq i^{*}}A_{i}</span>.</li>

      <li>For each <span class="math">i,j\\in[m]</span> where <span class="math">i\\neq j</span> and <span class="math">i,j\\neq i^{<em>}</span>, compute <span class="math">B_{i,j}\\leftarrow g_{p}^{\\alpha_{i}\\alpha_{j}}</span>. Compute <span class="math">B_{i^{</em>},j}\\leftarrow A_{i^{<em>}}^{\\alpha_{j}}</span> and <span class="math">B_{i,i^{</em>}}\\leftarrow A_{i^{<em>}}^{\\alpha_{j}}</span> for all <span class="math">i,j\\neq i^{</em>}</span>.</li>

    </ul>

    <p class="text-gray-300">In this experiment, <span class="math">\\mathrm{crs}</span> is distributed according to <span class="math">\\mathrm{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{*})</span>.</p>

    <p class="text-gray-300">For an index <span class="math">i</span>, we write <span class="math">\\mathrm{Hyb}_{i}(\\mathcal{A})</span> to denote the output of experiment <span class="math">\\mathrm{Hyb}_{i}</span> with algorithm <span class="math">\\mathcal{A}</span>. We show that the output distributions each adjacent pair of experiments are computationally indistinguishable (or identical).</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Claim 3.7.</h6>

    <p class="text-gray-300">For all adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\mathrm{Pr}[\\mathrm{Hyb}_{0}(\\mathcal{A})=1]=\\mathrm{Pr}[\\mathrm{Hyb}_{1}(\\mathcal{A})=1]</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The difference between <span class="math">\\mathrm{Hyb}_{0}</span> and <span class="math">\\mathrm{Hyb}_{1}</span> is purely syntactic. In <span class="math">\\mathrm{Hyb}_{1}</span>, <span class="math">A_{i}=A_{i^{*}}\\prod_{i\\neq i}A_{i}=\\prod_{i\\in[m]}A_{i}</span>, which matches the distribution in <span class="math">\\mathrm{Hyb}_{0}</span>. Similarly, in <span class="math">\\mathrm{Hyb}_{1}</span>,</p>

    <p class="text-gray-300"><span class="math">B_{i^{<em>},j}=A_{i^{</em>}}^{\\alpha_{j}}=g^{\\alpha_{i^{<em>}}\\alpha_{j}}\\quad\\text{and}\\quad B_{i,i^{</em>}}=A_{i^{<em>}}^{\\alpha_{i}}=g^{\\alpha_{i^{</em>}}\\alpha_{i}},</span></p>

    <p class="text-gray-300">which is precisely the distribution of <span class="math">B_{i^{<em>},j}</span> and <span class="math">B_{i,i^{</em>}}</span> in <span class="math">\\mathrm{Hyb}_{0}</span> for all <span class="math">i,j\\neq i^{<em>}</span>. Finally <span class="math">B_{i,j}</span> for <span class="math">i\\neq j</span> and <span class="math">i,j\\neq i^{</em>}</span> are identically distributed in the two experiments. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Claim 3.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose the subgroup decision assumption holds with respect to <span class="math">\\mathrm{GroupGen}</span>. Then, for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, $\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathrm{Pr}[\\mathrm{Hyb}_{1}(\\mathcal{A})=1]-\\mathrm{Pr}[\\mathrm{Hyb}_{2}(\\mathcal{A})=1]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose there exists an efficient adversary <span class="math">\\mathcal{A}</span> such that $\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathrm{Pr}[\\mathrm{Hyb}_{1}(\\mathcal{A})=1]-\\mathrm{Pr}[\\mathrm{Hyb}_{2}(\\mathcal{A})=1]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\varepsilon<span class="math"> for some non-negligible </span>\\varepsilon<span class="math">. We use </span>\\mathcal{A}<span class="math"> to construct an adversary </span>\\mathcal{B}$ for the subgroup decision problem:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the beginning of the game, algorithm <span class="math">\\mathcal{B}</span> receives the group description <span class="math">\\mathcal{G}=(\\mathbb{G},\\mathbb{G}_{T},N,g_{p},e)</span> and the challenge <span class="math">Z\\in\\mathbb{G}</span> from the subgroup decision challenger.</li>

      <li>For <span class="math">i\\neq i^{<em>}</span>, algorithm <span class="math">\\mathcal{B}</span> samples <span class="math">\\alpha_{i}\\stackrel{{\\scriptstyle\\tt R}}{{\\leftarrow}}\\mathbb{Z}_{N}</span> and sets <span class="math">A_{i}\\leftarrow g_{p}^{\\alpha_{i}}</span>. It sets <span class="math">A_{i^{</em>}}\\leftarrow Z</span> to be the challenge value. Next, it computes <span class="math">A\\leftarrow Z\\prod_{i\\neq i^{<em>}}A_{i}</span>. For <span class="math">i\\neq j</span> and <span class="math">i,j\\neq i^{</em>}</span>, algorithm <span class="math">\\mathcal{B}</span> computes <span class="math">B_{i,j}\\leftarrow g_{p}^{\\alpha_{i}\\alpha_{j}}</span>. For <span class="math">i,j\\neq i^{<em>}</span>, it computes <span class="math">B_{i^{</em>},j}\\leftarrow Z^{\\alpha_{j}}</span> and <span class="math">B_{i,i^{*}}\\leftarrow Z^{\\alpha_{i}}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{B}</span> gives <span class="math">\\mathrm{crs}=\\big{(}\\mathcal{G},A,\\{A_{i}\\}_{i\\in[m]},\\{B_{i,j}\\}_{i\\neq j}\\big{)}</span> to <span class="math">\\mathcal{A}</span> and outputs whatever <span class="math">\\mathcal{A}</span> outputs.</li>

    </ol>

    <p class="text-gray-300">Consider now the two possibilities:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">Z = g_{p}^{r}</span> in the subgroup decision game. Then, <span class="math">A_{i^{<em>}} = g_{p}^{r}</span> and algorithm <span class="math">\\mathcal{B}</span> perfectly simulates the distribution in <span class="math">\\mathrm{Hyb}_{1}</span>. In this case, algorithm <span class="math">\\mathcal{B}</span> outputs 1 with probability <span class="math">\\operatorname</em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1]</span>.</li>

      <li>Suppose <span class="math">Z = g^{r}</span> in the subgroup decision game. Then, <span class="math">A_{i^{<em>}} = g^{r}</span> and algorithm <span class="math">\\mathcal{B}</span> perfectly simulates the distribution in <span class="math">\\mathrm{Hyb}_2</span>. In this case, algorithm <span class="math">\\mathcal{B}</span> outputs 1 with probability <span class="math">\\operatorname</em>{Pr}[\\mathrm{Hyb}_2(\\mathcal{A}) = 1]</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The advantage of <span class="math">\\mathcal{B}</span> in the subgroup decision game is thus $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_2(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\varepsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Claims 3.7 and 3.8, CRS indistinguishability holds.</p>

    <p class="text-gray-300"><strong>Lemma 3.9 (Somewhere Extractable in Trapdoor Mode).</strong> <em>Construction 3.3 is somewhere extractable in trapdoor mode.</em></p>

    <p class="text-gray-300"><em>Proof.</em> Fix polynomials <span class="math">m = m(\\lambda)</span> and <span class="math">s = s(\\lambda)</span>. Let <span class="math">i^{<em>} \\gets \\mathcal{A}(1^{\\lambda}, 1^{m}, 1^{s})</span> and <span class="math">(\\mathrm{crs}^{</em>}, \\mathrm{td}) \\gets \\operatorname{TrapSetup}(1^{\\lambda}, 1^{m}, 1^{s}, i^{*})</span>. By construction,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r s} ^ {*} = \\left(\\mathcal {G}, A, \\left\\{A _ {i} \\right\\} _ {i \\in [ m ]}, \\left\\{B _ {i, j} \\right\\} _ {i \\neq j}\\right) \\quad \\text {and} \\quad \\operatorname {t d} = g _ {q},</span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{G} = (\\mathbb{G},\\mathbb{G}_T,N,g_p,e)</span>. Let <span class="math">N = pq</span> and <span class="math">g</span> be the generator of <span class="math">\\mathbb{G}</span> (i.e., <span class="math">g_{p}\\coloneqq g^{q}</span> and <span class="math">g_{q}\\coloneqq g^{p}</span>). Let <span class="math">\\mathbb{G}_p = \\langle g_p\\rangle</span> be the order-<span class="math">p</span> subgroup of <span class="math">\\mathbb{G}</span> generated by <span class="math">g_{p}</span>. Correspondingly, let <span class="math">\\mathbb{G}_q = \\langle g_q\\rangle</span> be the order-<span class="math">q</span> subgroup of <span class="math">\\mathbb{G}</span> generated by <span class="math">g_{q}</span>. By the Chinese Remainder Theorem, <span class="math">\\mathbb{G} \\cong \\mathbb{G}_p \\times \\mathbb{G}_q</span>.</p>

    <p class="text-gray-300">Let <span class="math">C\\colon \\{0,1\\}^n\\times \\{0,1\\}^h\\to \\{0,1\\}</span> be the Boolean circuit, <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_m\\in \\{0,1\\} ^n</span> be the statements, and <span class="math">\\pi = \\left(\\{U_k,V_k\\}_{k\\in [t]},\\{W_\\ell \\}_{\\ell \\in [s]}\\right)</span> be the proof the adversary outputs. Suppose <span class="math">\\mathrm{Verify}(\\mathrm{crs}^<em>,(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m),\\pi) = 1</span>. By construction of TrapSetup, we can write <span class="math">A_{i^{</em>}} = g^{\\alpha_{i^{<em>}}} = g_{p}^{\\alpha_{i^{</em>},p}}g_{q}^{\\alpha_{i^{<em>},q}}</span> for some <span class="math">\\alpha_{i^{</em>},p}\\in \\mathbb{Z}_p</span> and <span class="math">\\alpha_{i^{<em>},q}\\in \\mathbb{Z}_q</span>. Suppose that <span class="math">\\alpha_{i^{</em>},q}\\neq 0</span>. This holds with overwhelming probability since <span class="math">\\alpha_{i^{*}}\\stackrel {\\mathrm{n}}{\\leftarrow}\\mathbb{Z}_{N}</span>. Now the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">k \\in [t]</span>, either <span class="math">U_k \\in \\mathbb{G}_p</span> or <span class="math">U_k / g_q^{\\alpha_{i^<em>,q}} \\in \\mathbb{G}_p</span>. This follows from the wire validity checks. Specifically, suppose <span class="math">U_k = g_p^{\\beta_p} g_q^{\\beta_q}</span>. We can also write <span class="math">A = g_p^{\\sum_{i \\in [m]} \\alpha_i} g_q^{\\alpha_{i^</em>,q}}</span>. Since verification succeeds, it must be the case that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e (A, U _ {k}) = e \\left(g _ {p}, V _ {k}\\right) e \\left(U _ {k}, U _ {k}\\right).</span></div>

    <p class="text-gray-300">Consider the projection in the order-<span class="math">q</span> subgroup of <span class="math">\\mathbb{G}_T</span>. This relation requires that <span class="math">\\alpha_{i^<em>,q} \\cdot \\beta_q = \\beta_q^2</span>. This means that either <span class="math">\\beta_q = 0</span> (in which case <span class="math">U_k \\in \\mathbb{G}_p</span>) or <span class="math">\\beta_q = \\alpha_{i^</em>,q}</span> (in which case <span class="math">U_k / g_q^{\\alpha_{i^*,q}} \\in \\mathbb{G}_p</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">k \\in [t]</span>, if <span class="math">U_k \\in \\mathbb{G}_p</span>, then set <span class="math">\\xi_k = 0</span>. If <span class="math">U_k / g_q^{\\alpha_{i^<em>,q}} \\in \\mathbb{G}_p</span>, then set <span class="math">\\xi_k = 1</span>. Then, for all gates <span class="math">G_\\ell = (k_1, k_2, k_3) \\in [t]^3</span> in the circuit, <span class="math">\\xi_{k_3} = \\mathrm{NAND}(\\xi_{k_1}, \\xi_{k_2})</span>. This follows from the gate validity checks. In particular, if verification succeeds, then Eq. (3.2) holds. From the above analysis, we can write <span class="math">U_k = g_p^{\\beta_{k,p}} g_q^{\\xi_k \\alpha_{i^</em>,q}}</span> for all <span class="math">k \\in [t]</span> and some <span class="math">\\beta_{k,p} \\in \\mathbb{Z}_p</span>. Consider the projection of Eq. (3.2) into the order-<span class="math">q</span> subgroup of <span class="math">\\mathbb{G}_T</span>. This yields the relation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\alpha_ {i ^ {*}, q} ^ {2} = \\left(\\xi_ {k _ {1}} \\alpha_ {i ^ {*}, q}\\right) \\left(\\xi_ {k _ {2}} \\alpha_ {i ^ {*}, q}\\right) + \\alpha_ {i ^ {*}, q} \\left(\\xi_ {k _ {3}} \\alpha_ {i ^ {*}, q}\\right) = \\alpha_ {i ^ {*}, q} ^ {2} \\left(\\xi_ {k _ {1}} \\xi_ {k _ {2}} + \\xi_ {k _ {3}}\\right).</span></div>

    <p class="text-gray-300">Since <span class="math">\\alpha_{i^{*},q}\\neq 0</span>, this means that <span class="math">1 = \\xi_{k_1}\\xi_{k_2} + \\xi_{k_3}</span>, or equivalently, <span class="math">\\xi_{k_3} = 1 - \\xi_{k_1}\\xi_{k_2} = \\mathrm{NAND}(\\xi_{k_1},\\xi_{k_2})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{x}_{i^<em>} = (x_{i^</em>,1},\\ldots ,x_{i^<em>,n})</span>. For <span class="math">k\\in [n]</span>, <span class="math">\\xi_{k} = x_{i^{</em>},k}</span>.</li>

    </ul>

    <p class="text-gray-300">This follows from the statement validity check. Namely, for <span class="math">k \\in [n]</span>, the verifier checks that <span class="math">U_{k} = A_{i^{<em>}}^{x_{i^{</em>},k}} \\prod_{i \\neq i^{<em>}} A_{i}^{x_{i,k}}</span>. Since <span class="math">A_{i} \\in \\mathbb{G}_{p}</span> for <span class="math">i \\neq i^{</em>}</span>, it follows that if <span class="math">x_{i^{<em>},k} = 0</span>, then <span class="math">U_{k} \\in \\mathbb{G}_{p}</span> (and <span class="math">\\xi_{k} = 0 = x_{i^{</em>},k}</span>). Otherwise, if <span class="math">x_{i^{<em>},k} = 1</span>, then the component of <span class="math">U_{k}</span> in <span class="math">\\mathbb{G}_{q}</span> is exactly <span class="math">g_{q}^{\\alpha_{i^{</em>},q}}</span>, in which case <span class="math">\\xi_{k} = 1 = x_{i^{*},k}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally <span class="math">\\xi_{t} = 1</span>. This follows from the output satisfiability check. Namely, the verifier checks that <span class="math">U_{t} = A = g_{p}^{\\sum_{i \\in [m]} \\alpha_{i}} g_{q}^{\\alpha_{i^{*},q}}</span>. If the verifier accepts, then this relation holds and <span class="math">\\xi_{t} = 1</span>.</li>

    </ul>

    <p class="text-gray-300">The above properties show that <span class="math">\\xi_1, \\ldots, \\xi_t</span> is a valid assignment to the wires of <span class="math">C</span> on input <span class="math">\\mathbf{x}_{i^<em>}</span> and witness <span class="math">\\pmb{\\xi} = (\\xi_{n+1}, \\dots, \\xi_{n+h})</span>. Moreover, <span class="math">C(\\mathbf{x}_{i^</em>}, \\pmb{\\xi}) = \\xi_t = 1</span>.</p>

    <p class="text-gray-300">To complete the proof, let <span class="math">\\mathbf{w}^<em> \\gets \\text{Extract}(\\mathrm{td}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi)</span>. We claim that <span class="math">\\mathbf{w}^</em> = \\pmb{\\xi}</span>. In particular, for <span class="math">k \\in [h]</span>, if <span class="math">U_{n+k} \\in \\mathbb{G}_p</span>, then <span class="math">e(g_q, U_k) = 1</span> and <span class="math">w_k^<em> = 0 = \\xi_{n+k}</span>. Alternatively, if <span class="math">U_{n+k} / g_p^{\\alpha_{i^</em>,q}} \\in \\mathbb{G}_p</span>, then <span class="math">e(g_q, U_k) = e(g_q, g_q)^{\\alpha_{i^<em>,q}} \\neq 1</span>, so <span class="math">w_k^</em> = 1 = \\xi_{n+k}</span>. Thus, with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, either <span class="math">\\text{Verify}(\\mathrm{crs}^<em>, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi) = 0</span> or <span class="math">C(\\mathbf{x}, \\mathbf{w}^</em>) = 1</span>.</p>

    <p class="text-gray-300">By Lemmas 3.6 and 3.9, Construction 3.3 is a somewhere argument of knowledge.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 3.10 (Succinctness).</h6>

    <p class="text-gray-300">Construction 3.3 is succinct and satisfies split verification (Definition 2.9).</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any <span class="math">\\lambda,m,s\\in\\mathbb{N}</span> and consider a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>. Let <span class="math">t=\\operatorname{poly}(s)</span> be the number of wires in <span class="math">C</span>. We check each property:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: A proof <span class="math">\\pi</span> consists of <span class="math">2t+s</span> elements in <span class="math">\\mathbb{G}</span>, each of which can be represented in <span class="math">\\operatorname{poly}(\\lambda)</span> bits. Thus, the proof size satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(2t+s)\\cdot\\operatorname{poly}(\\lambda)=\\operatorname{poly}(\\lambda,s)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Verification key size: The size of the verification key <span class="math">\\operatorname{vk}</span> output by GenVK consists of <span class="math">n</span> group elements. Thus, $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\operatorname{vk}</td>

            <td class="px-3 py-2 border-b border-gray-700">=n\\cdot\\operatorname{poly}(\\lambda)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification key generation time: The algorithm GenVK performs <span class="math">nm</span> group operations. This takes time <span class="math">\\operatorname{poly}(\\lambda,m,n)</span>.</li>

      <li>Online verification time: The running time of the online verification algorithm <span class="math">\\operatorname{OnlineVerify}</span> is</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\underbrace{n\\cdot\\operatorname{poly}(\\lambda)}_{\\text{statement validity}}+\\underbrace{t\\cdot\\operatorname{poly}(\\lambda)}_{\\text{wire validity}}+\\underbrace{s\\cdot\\operatorname{poly}(\\lambda)}_{\\text{gate validity}}+\\underbrace{\\operatorname{poly}(\\lambda)}_{\\text{output validity}}=\\operatorname{poly}(\\lambda,s),</span></p>

    <p class="text-gray-300">since <span class="math">n,t=\\operatorname{poly}(s)</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Remark 3.11 (Variable Number of Instances).</h6>

    <p class="text-gray-300">As currently described, the prover and verifier algorithms in 3.3 takes exactly <span class="math">m</span> instances as input. However, the same scheme can also be used to prove any <span class="math">T\\leq m</span> instances (by ignoring components in the CRS). In this case, the proof size is unchanged, and the verification running time (assuming random read access to the CRS) is <span class="math">\\operatorname{poly}(\\lambda,n,T)+\\operatorname{poly}(\\lambda,s)</span>.</p>

    <h2 id="sec-56" class="text-2xl font-bold">4 BARG for <span class="math">\\mathsf{NP}</span> from <span class="math">k</span>-<span class="math">\\mathsf{Lin}</span> in Bilinear Groups</h2>

    <p class="text-gray-300">In this section, we show how to translate the ideas underlying 3.3 to work with asymmetric prime-order groups under the <span class="math">k</span>-<span class="math">\\mathsf{Lin}</span> assumption. We start by recalling the definition of a prime-order pairing group and the matrix Diffie-Hellman (MDDH) assumption <em>[EHK^{+}13]</em>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 4.1 (Prime-Order Bilinear Group).</h6>

    <p class="text-gray-300">A prime-order asymmetric group generator <span class="math">\\operatorname{GroupGen}</span> is an efficient algorithm that takes as input the security parameter <span class="math">1^{\\lambda}</span> and outputs a description <span class="math">\\mathcal{G}=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},p,g_{1},g_{2},e)</span> of two base groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with generators <span class="math">g_{1},g_{2}</span>, respectively, a target group <span class="math">\\mathbb{G}_{T}</span>, all of prime order <span class="math">p=2^{\\Theta(\\lambda)}</span>, and a non-degenerate bilinear map <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span>. We require that the group operation in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span> and the pairing operations to be efficiently computable.</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Notation.</h5>

    <p class="text-gray-300">When working with an asymmetric prime-order pairing group <span class="math">\\mathcal{G}=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},p,g_{1},g_{2},e)</span>, we use the implicit representation of group elements <em>[EHK^{+}13]</em>. Specifically, for a matrix <span class="math">\\mathbf{M}</span> over <span class="math">\\mathbb{Z}_{p}</span>, we write <span class="math">[\\mathbf{M}]_{1}:=g_{1}^{\\mathbf{M}}</span>, <span class="math">[\\mathbf{M}]_{2}:=g_{2}^{\\mathbf{M}}</span>, and <span class="math">[\\mathbf{M}]_{T}:=g_{T}^{\\mathbf{M}}</span>, where exponentiation is defined component-wise and <span class="math">g_{T}=e(g_{1},g_{2})</span>. Given matrices <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{B}</span> over <span class="math">\\mathbb{Z}_{p}</span>, we define the pairing operation <span class="math">e([\\mathbf{A}]_{1},[\\mathbf{B}]_{2}):=[\\mathbf{A}\\mathbf{B}]_{T}</span>. We also denote this by writing <span class="math">[\\mathbf{A}]_{1}\\cdot[\\mathbf{B}]_{2}:=e([\\mathbf{A}]_{1},[\\mathbf{B}]_{2})</span>. For matrices <span class="math">\\mathbf{A},\\mathbf{B},\\mathbf{C},\\mathbf{D}</span> over <span class="math">\\mathbb{Z}_{p}</span>, we write <span class="math">\\mathbf{A}[\\mathbf{B}]_{1}+[\\mathbf{C}]_{1}\\mathbf{D}:=[\\mathbf{A}\\mathbf{B}+\\mathbf{C}\\mathbf{D}]_{1}</span> to represent linear operations within <span class="math">\\mathbb{G}_{1}</span> (and analogously in <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span>). We now recall the <span class="math">k</span>-<span class="math">\\mathsf{Lin}</span> and matrix Diffie-Hellman assumptions. In the case of <span class="math">k</span>-<span class="math">\\mathsf{Lin}</span>, recall that the case of <span class="math">k=1</span> corresponds to the decisional Diffie-Hellman (DDH) assumption and the case <span class="math">k=2</span> corresponds to the decisional linear (DLIN) assumption <em>[x10, x23, x38]</em>. Finally, the symmetric external Diffie-Hellman (SXDH) assumption corresponds to DDH (i.e., <span class="math">1</span>-<span class="math">\\mathsf{Lin}</span>) holding in <em>both</em> <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition 4.2 (<span class="math">k</span>-Lin Assumption <em>[x1, x13, x26]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span>. The <span class="math">k</span>-Lin assumption holds in <span class="math">\\mathbb{G}_{1}</span> with respect to GroupGen if for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}(\\mathcal{G},[\\mathbf{M}]_{1},[\\mathbf{Mv}]_{1})=1]-\\Pr[\\mathcal{A}(\\mathcal{G},[\\mathbf{M}]_{1},[\\mathbf{u}]_{1})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{negl}(\\lambda),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathcal{G}\\leftarrow\\operatorname{GroupGen}(1^{\\lambda})</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}=\\left[\\frac{\\operatorname{diag}(\\mathbf{s})}{\\mathbf{1}^{\\mathsf{T}}}\\right]\\in\\mathbb{Z}_{p}^{(k+1)\\times k},</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{s}=(s_{1},\\ldots,s_{k})\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{k}</span>, <span class="math">\\operatorname{diag}(\\mathbf{s})\\in\\mathbb{Z}_{p}^{k\\times k}</span> is the diagonal matrix whose entries are <span class="math">s_{1},\\ldots,s_{k}</span>, <span class="math">\\mathbf{v}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{k}</span>, and <span class="math">\\mathbf{u}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{k+1}</span>. We define the <span class="math">k</span>-Lin assumption in <span class="math">\\mathbb{G}_{2}</span> with respect to GroupGen in an analogous manner.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 4.3 (Matrix Diffie-Hellman Assumption <em>[EHK^{+}13]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span>. The <span class="math">\\mathsf{MDDH}_{k}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> with respect to GroupGen if for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}(\\mathcal{G},[\\mathbf{M}]_{1},[\\mathbf{Mv}]_{1})=1]-\\Pr[\\mathcal{A}(\\mathcal{G},[\\mathbf{M}]_{1},[\\mathbf{u}]_{1})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{negl}(\\lambda),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathcal{G}\\leftarrow\\operatorname{GroupGen}(1^{\\lambda})</span>, <span class="math">\\mathbf{M}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{(k+1)\\times k}</span>, <span class="math">\\mathbf{v}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{k}</span> and <span class="math">\\mathbf{u}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{k+1}</span>. We define the <span class="math">\\mathsf{MDDH}_{k}</span> assumption in <span class="math">\\mathbb{G}_{2}</span> with respect to GroupGen in an analogous manner.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 4.4 (Matrix Diffie-Hellman <em>[EHK^{+}13]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span>. Suppose the <span class="math">k</span>-Lin assumption holds in <span class="math">\\mathbb{G}_{1}</span> (resp., <span class="math">\\mathbb{G}_{2}</span>) with respect to GroupGen. Then <span class="math">\\mathsf{MDDH}_{k}</span> holds in <span class="math">\\mathbb{G}_{1}</span> (resp., <span class="math">\\mathbb{G}_{2}</span>) with respect to GroupGen.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Construction overview.</h4>

    <p class="text-gray-300">Our BARG from asymmetric prime-order groups relies on a similar underlying principle as the construction from symmetric composite-order groups (Construction 3.3). Here, we summarize the key differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomizing cross-terms in the CRS. In the symmetric setting, we associated a single encoding <span class="math">A_{i}</span> with each instance. In the asymmetric setting, we need to encode the instance in <em>both</em> <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> in order to apply the pairing consistency checks. Thus, the prover now generates two commitments to the wire labels for each wire, one in <span class="math">\\mathbb{G}_{1}</span> and the other in <span class="math">\\mathbb{G}_{2}</span>. This introduces a new challenge when it comes to constructing the <em>cross-terms</em> <span class="math">B_{i,j}</span>, as it depends on the exponents associated with the encodings in <em>both</em> <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. Proving security would seemingly need to rely on a “bilateral” assumption over pairing groups where the assumption gives out elements with correlated exponents in <em>both</em> <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. To avoid this and base security on the vanilla <span class="math">k</span>-Lin assumption, we split the cross-terms into two shares, with one share in <span class="math">\\mathbb{G}_{1}</span> and the other in <span class="math">\\mathbb{G}_{2}</span>. The extra randomness in the cross terms allows for a simple simulation strategy in the security analysis (see Lemma 4.8).</li>

      <li>Simulating projective pairing using outer products. The key property we relied on in the soundness analysis of the composite-order construction is that the pairing is projecting. Namely, there exists a projection map on <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{T}</span> that map into the subgroup of order-<span class="math">q</span> in each respective group; moreover, this projection map <em>commutes</em> with the pairing. Then, if a relation like Eq. 3.1 or Eq. 3.2 holds in the target group, the projected relation formed by projecting the left-hand and right-hand sides into the order-<span class="math">q</span> subgroup also holds. As argued in Lemma 3.9, projecting into the order-<span class="math">q</span> subgroup allows us to isolate a single instance <span class="math">i^{<em>}</span>, in which case the verification checks ensure </em>statistically<em> soundness for instance <span class="math">i^{</em>}</span>. To obtain an analog of projective pairings in the prime order setting, we can replace the subgroups with subspaces of a vector space and define the pairing operation to be an outer (tensor) product of vectors <em>[x14, x21]</em>. As we show in Lemma 4.12, this enables a similar strategy to prove soundness.</li>

    </ul>

    <h6 id="sec-63" class="text-base font-medium mt-4">Construction 4.5 (BARG for NP from <span class="math">k</span>-Lin).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span> be an integer. We construct a BARG with split verification for the language of circuit satisfiability as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(1^{\\lambda},1^{m},1^{s})</span>: On input the security parameter <span class="math">\\lambda</span>, the number of instances <span class="math">m</span>, and the bound on the circuit size <span class="math">s</span>, the setup algorithm does the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Run}\\mathcal{G}=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},p,g_{1},g_{2},e)\\leftarrow\\operatorname{GroupGen}(1^{\\lambda})</span>. Sample matrices <span class="math">\\mathbf{M},\\hat{\\mathbf{M}}\\xleftarrow{\\text{\\tiny R}}\\mathbb{Z}_{p}^{(k+1)\\times k}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i \\in [m]</span>, sample <span class="math">\\alpha_i, \\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span> and compute <span class="math">\\mathbf{a}_i \\gets \\mathbf{M}\\alpha_i</span>, <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}}\\hat{\\alpha}_i</span>. Let <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span> and <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span>.</li>

      <li>For each <span class="math">i, j \\in [m]</span> where <span class="math">i \\neq j</span>, sample <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span> and let <span class="math">\\mathbf{B}_{i,j} \\gets \\mathbf{M}(\\boldsymbol{\\alpha}_i \\hat{\\boldsymbol{\\alpha}}_j^{\\mathrm{T}} + \\mathbf{R}_{i,j}) \\in \\mathbb{Z}_p^{(k+1) \\times k}</span> and <span class="math">\\hat{\\mathbf{B}}_{i,j} \\gets -\\hat{\\mathbf{M}}\\mathbf{R}_{i,j}^{\\mathrm{T}} \\in \\mathbb{Z}_p^{(k+1) \\times k}</span>.</li>

      <li>Output the common reference string <span class="math">\\operatorname{crs} = \\left(\\mathcal{G}, [\\mathbf{M}]_1, [\\hat{\\mathbf{M}}]_2, [\\mathbf{a}]_1, [\\hat{\\mathbf{a}}]_2, \\{[\\mathbf{a}_i]_1, [\\hat{\\mathbf{a}}_i]_2\\}_{i \\in [m]}, \\{[\\mathbf{B}_{i,j}]_1, [\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i \\neq j}\\right)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove <span class="math">(\\operatorname{crs}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), (\\mathbf{w}_1, \\ldots, \\mathbf{w}_m))</span>: On input the common reference string</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{crs} = \\left(\\mathcal{G}, [\\mathbf{M}]_1, [\\hat{\\mathbf{M}}]_2, [\\mathbf{a}]_1, [\\hat{\\mathbf{a}}]_2, \\{[\\mathbf{a}_i]_1, [\\hat{\\mathbf{a}}_i]_2\\}_{i \\in [m]}, \\{[\\mathbf{B}_{i,j}]_1, [\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i \\neq j}\\right),</span></div>

    <p class="text-gray-300">the circuit <span class="math">C\\colon \\{0,1\\}^n\\to \\{0,1\\}^h\\to \\{0,1\\}</span>, instances <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_m\\in \\{0,1\\}^n</span>, and witnesses <span class="math">\\mathbf{w}_1,\\dots ,\\mathbf{w}_m\\in \\{0,1\\}^h</span>, define <span class="math">t</span> to be the number of wires in <span class="math">C</span> and <span class="math">s</span> to be the number of gates in <span class="math">C</span>. Then, for <span class="math">i\\in [m]</span> and <span class="math">j\\in [t]</span>, let <span class="math">w_{i,j}\\in \\{0,1\\}</span> be the value of wire <span class="math">j</span> in <span class="math">C(\\mathbf{x}_i,\\mathbf{w}_i)</span>. The prover then proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encoding the wire values: For each wire <span class="math">d \\in [t]</span>, let</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{u}_d ]_1 \\leftarrow \\sum_{i \\in [m]} w_{i,d} [ \\mathbf{a}_i ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{u}}_d ]_2 \\leftarrow \\sum_{i \\in [m]} w_{i,d} [ \\hat{\\mathbf{a}}_i ]_2.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of witness wires: For each <span class="math">d \\in \\{n + 1, \\dots, n + h\\}</span>, compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{V}_{d,1} ]_1 = \\sum_{i \\neq j} (1 - w_{i,d}) w_{j,d} [ \\mathbf{B}_{i,j} ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{V}}_{d,1} ]_2 = \\sum_{i \\neq j} (1 - w_{i,d}) w_{j,d} [ \\hat{\\mathbf{B}}_{i,j} ]_2,</span></div>

    <p class="text-gray-300">as well as</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{V}_{d,2} ]_1 = \\sum_{i \\neq j} (1 - w_{j,d}) w_{i,d} [ \\mathbf{B}_{i,j} ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{V}}_{d,2} ]_2 = \\sum_{i \\neq j} (1 - w_{j,d}) w_{i,d} [ \\hat{\\mathbf{B}}_{i,j} ]_2,</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of gate computation: For each NAND gate <span class="math">G_{\\ell} = (d_1, d_2, d_3) \\in [t]^3</span> (where <span class="math">\\ell \\in [s]</span>), compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{W}_{\\ell,1} ]_1 = \\sum_{i \\neq j} (1 - w_{i,d_1} w_{j,d_2} - w_{j,d_3}) [ \\mathbf{B}_{i,j} ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{W}}_{\\ell,1} ]_2 = \\sum_{i \\neq j} (1 - w_{i,d_1} w_{j,d_2} - w_{j,d_3}) [ \\hat{\\mathbf{B}}_{i,j} ]_2</span></div>

    <p class="text-gray-300">as well as</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{W}_{\\ell,2} ]_1 = \\sum_{i \\neq j} (1 - w_{i,d_1} w_{j,d_2} - w_{i,d_3}) [ \\mathbf{B}_{i,j} ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{W}}_{\\ell,2} ]_2 = \\sum_{i \\neq j} (1 - w_{i,d_1} w_{j,d_2} - w_{i,d_3}) [ \\hat{\\mathbf{B}}_{i,j} ]_2</span></div>

    <p class="text-gray-300">Finally, output the proof</p>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left(\\left\\{\\left[ \\mathbf{u}_d \\right] _ {1}, \\left[ \\hat {\\mathbf{u}} _ {d} \\right] _ {2} \\right\\} _ {d \\in [ t ]}, \\left\\{\\left[ \\mathbf{V}_{n + d,i} \\right] _ {1}, \\left[ \\hat {\\mathbf{V}} _ {n + d,i} \\right] _ {2} \\right\\} _ {d \\in [ h ], i \\in \\{1, 2 \\}}, \\left\\{\\left[ \\mathbf{W} _ {\\ell , i} \\right] _ {1}, \\left[ \\hat {\\mathbf{W}} _ {\\ell , i} \\right] _ {2} \\right\\} _ {\\ell \\in [ s ], i \\in \\{1, 2 \\}}\\right).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify <span class="math">(\\operatorname{crs}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi)</span>: We decompose the verification algorithm into (GenVK, OnlineVerify):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenVK(crs, <span class="math">(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m)</span>): On input the common reference string</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{crs} = \\left(\\mathcal{G}, [\\mathbf{M}]_1, [\\hat{\\mathbf{M}}]_2, [\\mathbf{a}]_1, [\\hat{\\mathbf{a}}]_2, \\{[\\mathbf{a}_i]_1, [\\hat{\\mathbf{a}}_i]_2\\}_{i \\in [m]}, \\{[\\mathbf{B}_{i,j}]_1, [\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i \\neq j}\\right)</span></div>

    <p class="text-gray-300">and instances <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span>, the verification key generation algorithm computes</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf{u}_d^* ]_1 = \\sum_{i \\in [m]} x_{i,d} [ \\mathbf{a}_i ]_1 \\quad \\text{and} \\quad [ \\hat{\\mathbf{u}}_d^* ]_2 = \\sum_{i \\in [m]} x_{i,d} [ \\hat{\\mathbf{a}}_i ]_2.</span></div>

    <p class="text-gray-300">for each <span class="math">d \\in [n]</span> and outputs the verification key <span class="math">\\mathrm{vk} = \\left\\{[\\mathbf{u}_d^<em>]_1, [\\hat{\\mathbf{u}}_d^</em>]_2\\right\\}_{d \\in [n]}</span>.</p>

    <p class="text-gray-300">20</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OnlineVerify(vk, <span class="math">C, \\pi</span>): On input the verification key <span class="math">\\mathsf{vk} = \\left\\{[\\mathbf{u}_d^<em>]_1, [\\hat{\\mathbf{u}}_d^</em>]_2\\right\\}_{d \\in [n]}</span>, the circuit <span class="math">C: \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span>, and the proof</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left(\\left\\{\\left[ \\mathbf {u} _ {d} \\right] _ {1}, \\left[ \\hat {\\mathbf {u}} _ {d} \\right] _ {2} \\right\\} _ {d \\in [ t ]}, \\left\\{\\left[ \\mathbf {V} _ {n + d, i} \\right] _ {1}, \\left[ \\hat {\\mathbf {V}} _ {n + d, i} \\right] _ {2} \\right\\} _ {d \\in [ h ], i \\in \\{1, 2 \\}}, \\left\\{\\left[ \\mathbf {W} _ {\\ell , i} \\right] _ {1}, \\left[ \\hat {\\mathbf {W}} _ {\\ell , i} \\right] _ {2} \\right\\} _ {\\ell \\in [ s ], i \\in \\{1, 2 \\}}\\right),</span></div>

    <p class="text-gray-300">the verification algorithm checks the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of statement: For each statement wire <span class="math">d \\in [n]</span>, check that <span class="math">[\\mathbf{u}_d]_1 = [\\mathbf{u}_d^<em>]_1</span> and <span class="math">[\\hat{\\mathbf{u}}_d]_2 = [\\hat{\\mathbf{u}}_d^</em>]_2</span>.</li>

      <li>Validity of witness wires: For each witness wire <span class="math">d \\in \\{n + 1, \\dots, n + h\\}</span>, check that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {a} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d} ^ {\\mathrm {T}} ] _ {2} = \\left([ \\mathbf {u} _ {d} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {M} ] _ {1} \\cdot [ \\hat {\\mathbf {V}} _ {d, 1} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {V} _ {d, 1} ] _ {1} \\cdot [ \\hat {\\mathbf {M}} ^ {\\mathrm {T}} ] _ {2}\\right)</span></div>

    <p class="text-gray-300">and that</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {u} _ {d} ] _ {1} \\cdot [ \\hat {\\mathbf {a}} ^ {\\mathrm {T}} ] _ {2} = ([ \\mathbf {u} _ {d} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d} ^ {\\mathrm {T}} ] _ {2}) + ([ \\mathbf {M} ] _ {1} \\cdot [ \\hat {\\mathbf {V}} _ {d, 2} ^ {\\mathrm {T}} ] _ {2}) + ([ \\mathbf {V} _ {d, 2} ] _ {1} \\cdot [ \\hat {\\mathbf {M}} ^ {\\mathrm {T}} ] _ {2}).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of gate computation: For each gate <span class="math">G_{\\ell} = (d_1, d_2, d_3) \\in [t]^3</span>, check that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {a} ] _ {1} \\cdot [ \\hat {\\mathbf {a}} ^ {\\mathrm {T}} ] _ {2} = \\left([ \\mathbf {u} _ {d _ {1}} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d _ {2}} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {a} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d _ {3}} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {M} ] _ {1} \\cdot [ \\hat {\\mathbf {W}} _ {\\ell , 1} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {W} _ {\\ell , 1} ] _ {1} \\cdot [ \\hat {\\mathbf {M}} ^ {\\mathrm {T}} ] _ {2}\\right),</span></div>

    <p class="text-gray-300">and that</p>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {a} ] _ {1} \\cdot [ \\hat {\\mathbf {a}} ^ {\\mathrm {T}} ] _ {2} = \\left([ \\mathbf {u} _ {d _ {1}} ] _ {1} \\cdot [ \\hat {\\mathbf {u}} _ {d _ {2}} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {u} _ {d _ {3}} ] _ {1} \\cdot [ \\hat {\\mathbf {a}} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {M} ] _ {1} \\cdot [ \\hat {\\mathbf {W}} _ {\\ell , 2} ^ {\\mathrm {T}} ] _ {2}\\right) + \\left([ \\mathbf {W} _ {\\ell , 2} ] _ {1} \\cdot [ \\hat {\\mathbf {M}} ^ {\\mathrm {T}} ] _ {2}\\right).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output satisfiability: Finally, the verifier checks that <span class="math">[\\mathbf{u}_t]_1 = [\\mathbf{a}]_1</span> and <span class="math">[\\hat{\\mathbf{u}}_t]_2 = [\\hat{\\mathbf{a}}]_2</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 4.6 (Completeness). Construction 4.5 is complete.</p>

    <p class="text-gray-300">Proof. Take any <span class="math">\\lambda, m, s \\in \\mathbb{N}</span>, and let <span class="math">C: \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span> be a Boolean circuit of size at most <span class="math">s</span>. Take statements <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0,1\\}^n</span> and witnesses <span class="math">\\mathbf{w}_1, \\ldots, \\mathbf{w}_m \\in \\{0,1\\}^h</span> where <span class="math">C(\\mathbf{x}_i, \\mathbf{w}_i) = 1</span> for all <span class="math">i \\in [m]</span>. Let <span class="math">\\operatorname{crs} \\leftarrow \\operatorname{Setup}(1^\\lambda, 1^m, 1^s)</span> and <span class="math">\\pi \\leftarrow \\operatorname{Prove}(\\operatorname{crs}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), (\\mathbf{w}_1, \\ldots, \\mathbf{w}_m))</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {c r s} = \\left(\\mathcal {G}, [ \\mathbf {M} ] _ {1}, [ \\hat {\\mathbf {M}} ] _ {2}, [ \\mathbf {a} ] _ {1}, [ \\hat {\\mathbf {a}} ] _ {2}, \\left\\{\\left[ \\mathbf {a} _ {i} \\right] _ {1}, \\left[ \\hat {\\mathbf {a}} _ {i} \\right] _ {2} \\right\\} _ {i \\in [ m ]}, \\left\\{\\left[ \\mathbf {B} _ {i, j} \\right] _ {1}, \\left[ \\hat {\\mathbf {B}} _ {i, j} \\right] _ {2} \\right\\} _ {i \\neq j}\\right) \\\\ \\pi = \\left(\\left\\{\\left[ \\mathbf {u} _ {d} \\right] _ {1}, \\left[ \\hat {\\mathbf {u}} _ {d} \\right] _ {2} \\right\\} _ {d \\in [ t ]}, \\left\\{\\left[ \\mathbf {V} _ {n + d, i} \\right] _ {1}, \\left[ \\hat {\\mathbf {V}} _ {n + d, i} \\right] _ {2} \\right\\} _ {d \\in [ h ], i \\in \\{1, 2 \\}}, \\left\\{\\left[ \\mathbf {W} _ {\\ell , i} \\right] _ {1}, \\left[ \\hat {\\mathbf {W}} _ {\\ell , i} \\right] _ {2} \\right\\} _ {\\ell \\in [ s ], i \\in \\{1, 2 \\}}\\right) \\end{array}</span></div>

    <p class="text-gray-300">For <span class="math">i \\in [m]</span> and <span class="math">j \\in [t]</span>, let <span class="math">w_{i,j} \\in \\{0,1\\}</span> denote the value of wire <span class="math">j</span> in <span class="math">C(\\mathbf{x}_i, \\mathbf{w}_i)</span>. First, observe that for all <span class="math">i \\neq j</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M} \\hat {\\mathbf {B}} _ {i, j} ^ {\\mathrm {T}} + \\mathbf {B} _ {i, j} \\hat {\\mathbf {M}} ^ {\\mathrm {T}} = - \\mathbf {M} \\mathbf {R} _ {i, j} \\hat {\\mathbf {M}} ^ {\\mathrm {T}} + \\mathbf {M} \\left(\\boldsymbol {\\alpha} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathrm {T}} + \\mathbf {R} _ {i, j}\\right) \\hat {\\mathbf {M}} ^ {\\mathrm {T}} = \\mathbf {M} \\boldsymbol {\\alpha} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathrm {T}} \\hat {\\mathbf {M}} ^ {\\mathrm {T}} = \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}}. \\tag {4.1}</span></div>

    <p class="text-gray-300">We show that each of the verification checks pass:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of statement: The honest prover computes <span class="math">\\mathbf{u}_d = \\sum_{i\\in [m]}w_{i,d}\\mathbf{a}_i</span> for all <span class="math">d\\in [t]</span>. Since the first <span class="math">n</span> wires of the circuit corresponds to the statement, we have <span class="math">w_{i,d} = x_{i,d}</span> for all <span class="math">d\\in [n]</span> and the check passes. Similarly, <span class="math">\\hat{\\mathbf{u}}_d = \\sum_{i\\in [m]}w_{i,d}\\hat{\\mathbf{a}}_i = \\sum_{i\\in [m]}x_{i,d}\\hat{\\mathbf{a}}_i</span>.</li>

      <li>Validity of witness wires: By construction of <span class="math">\\mathbf{V}_{d,1}</span>, <span class="math">\\hat{\\mathbf{V}}_{d,1}</span> and appealing to Eq. (4.1),</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M} \\hat {\\mathbf {V}} _ {d, 1} ^ {\\mathrm {T}} + \\mathbf {V} _ {d, 1} \\hat {\\mathbf {M}} ^ {\\mathrm {T}} = \\sum_ {i \\neq j} (1 - w _ {i, d}) w _ {j, d} (\\mathbf {M} \\hat {\\mathbf {B}} _ {i, j} ^ {\\mathrm {T}} + \\mathbf {B} _ {i, j} \\hat {\\mathbf {M}} ^ {\\mathrm {T}}) = \\sum_ {i \\neq j} (w _ {j, d} - w _ {i, d} w _ {j, d}) \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}}.</span></div>

    <p class="text-gray-300">Similarly, by construction of <span class="math">\\mathbf{u}_d</span>, <span class="math">\\hat{\\mathbf{u}}_d</span>, and <span class="math">\\mathbf{a}</span>, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {u} _ {d} \\hat {\\mathbf {u}} _ {d} ^ {\\mathrm {T}} = \\sum_ {i, j \\in [ m ]} w _ {i, d} w _ {j, d} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}} = \\sum_ {i \\in [ m ]} w _ {i, d} ^ {2} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {i} ^ {\\mathrm {T}} + \\sum_ {i \\neq j} w _ {i, d} w _ {j, d} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}} \\\\ \\mathbf {a} \\hat {\\mathbf {u}} _ {d} ^ {\\mathrm {T}} = \\sum_ {i, j \\in [ m ]} w _ {j, d} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}} = \\sum_ {i \\in [ m ]} w _ {i, d} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {i} ^ {\\mathrm {T}} + \\sum_ {i \\neq j} w _ {j, d} \\mathbf {a} _ {i} \\hat {\\mathbf {a}} _ {j} ^ {\\mathrm {T}} \\end{array}</span></div>

    <p class="text-gray-300">Since <span class="math">w_{i,d}\\in\\{0,1\\}</span>, we have that <span class="math">w_{i,d}^{2}=w_{i,d}</span>. Combining the above relations,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{d}\\hat{\\mathbf{u}}_{d}^{\\mathsf{T}}+\\mathbf{M}\\hat{\\mathbf{V}}_{d,1}^{\\mathsf{T}}+\\mathbf{V}_{d,1}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{j,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\mathbf{a}\\hat{\\mathbf{u}}_{d}^{\\mathsf{T}},</span></p>

    <p class="text-gray-300">and the first verification check passes. Validity of the second verification check follows by an analogous calculation. Namely,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}\\hat{\\mathbf{V}}_{d,2}^{\\mathsf{T}}+\\mathbf{V}_{d,2}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\neq j}(1-w_{j,d})w_{i,d}(\\mathbf{M}\\hat{\\mathbf{B}}_{i,j}^{\\mathsf{T}}+\\mathbf{B}_{i,j}\\hat{\\mathbf{M}}^{\\mathsf{T}})=\\sum_{i\\neq j}(w_{i,d}-w_{i,d}w_{j,d})\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{d}\\hat{\\mathbf{a}}^{\\mathsf{T}}=\\sum_{i,j\\in[m]}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}},</span></p>

    <p class="text-gray-300">from which we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{d}\\hat{\\mathbf{u}}_{d}^{\\mathsf{T}}+\\mathbf{M}\\hat{\\mathbf{V}}_{d,2}^{\\mathsf{T}}+\\mathbf{V}_{d,2}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{i,d}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\mathbf{u}_{d}\\hat{\\mathbf{a}}^{\\mathsf{T}}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of gate computation: Similar to the previous case, we expand each term in the verification relation and apply Eq. 4.1 to obtain</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{M}\\hat{\\mathbf{W}}_{\\ell,1}^{\\mathsf{T}}+\\mathbf{W}_{\\ell,1}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\neq j}(1-w_{i,d_{1}}w_{j,d_{2}}-w_{j,d_{3}})(\\mathbf{M}\\hat{\\mathbf{B}}_{i,j}^{\\mathsf{T}}+\\mathbf{B}_{i,j}\\hat{\\mathbf{M}}^{\\mathsf{T}})=\\sum_{i\\neq j}(1-w_{i,d_{1}}w_{j,d_{2}}-w_{j,d_{3}})\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{d_{1}}\\hat{\\mathbf{u}}_{d_{2}}^{\\mathsf{T}}=\\sum_{i,j\\in[m]}w_{i,d_{1}}w_{j,d_{2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d_{1}}w_{i,d_{2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{i,d_{1}}w_{j,d_{2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}</span> <span class="math">\\mathbf{a}\\hat{\\mathbf{u}}_{d_{3}}^{\\mathsf{T}}=\\sum_{i,j\\in[m]}w_{j,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{j,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}</span> <span class="math">\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}=\\sum_{i,j\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\sum_{i\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}.</span></p>

    <p class="text-gray-300">By definition, <span class="math">w_{i,d_{3}}=\\textsc{NAND}(w_{i,d_{1}},w_{i,d_{2}})</span> for all <span class="math">i\\in[m]</span>. In particular, this means that <span class="math">w_{i,d_{3}}=1-w_{i,d_{1}}w_{i,d_{2}}</span>, or equivalently, <span class="math">w_{i,d_{1}}w_{i,d_{2}}+w_{i,d_{3}}=1</span>. Substituting into the above relations,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{d_{1}}\\hat{\\mathbf{u}}_{d_{2}}^{\\mathsf{T}}+\\mathbf{a}\\hat{\\mathbf{u}}_{d_{3}}^{\\mathsf{T}}+\\mathbf{M}\\hat{\\mathbf{W}}_{\\ell,1}^{\\mathsf{T}}+\\mathbf{W}_{\\ell,1}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}.</span></p>

    <p class="text-gray-300">For the second validation check, we expand as above to obtain</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}\\hat{\\mathbf{W}}_{\\ell,2}^{\\mathsf{T}}+\\mathbf{W}_{\\ell,2}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\neq j}(1-w_{i,d_{1}}w_{j,d_{2}}-w_{i,d_{3}})(\\mathbf{M}\\hat{\\mathbf{B}}_{i,j}^{\\mathsf{T}}+\\mathbf{B}_{i,j}\\hat{\\mathbf{M}}^{\\mathsf{T}})=\\sum_{i\\neq j}(1-w_{i,d_{1}}w_{j,d_{2}}-w_{i,d_{3}})\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{d_{3}}\\hat{\\mathbf{a}}^{\\mathsf{T}}=\\sum_{i,j\\in[m]}w_{i,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\sum_{i\\in[m]}w_{i,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}w_{i,d_{3}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}.</span></p>

    <p class="text-gray-300">Combining the relations, we see that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{d_{1}}\\hat{\\mathbf{u}}_{d_{2}}^{\\mathsf{T}}+\\mathbf{u}_{d_{3}}\\hat{\\mathbf{a}}^{\\mathsf{T}}+\\mathbf{M}\\hat{\\mathbf{W}}_{\\ell,2}^{\\mathsf{T}}+\\mathbf{W}_{\\ell,2}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}+\\sum_{i\\neq j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j}^{\\mathsf{T}}=\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of output: Since <span class="math">C(\\mathbf{x}_{i},\\mathbf{w}_{i})=1</span>, it follows that <span class="math">w_{i,t}=1</span> for all <span class="math">i\\in[m]</span>. This means that <span class="math">\\mathbf{u}_{t}=\\sum_{i\\in[m]}\\mathbf{a}_{i}=\\mathbf{a}</span> and <span class="math">\\hat{\\mathbf{u}}_{t}=\\sum_{i\\in[m]}\\hat{\\mathbf{a}}_{i}=\\hat{\\mathbf{a}}</span>.</li>

    </ul>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 4.7 (Somewhere Argument of Knowledge).</h6>

    <p class="text-gray-300">Take any positive integer <span class="math">k\\in\\mathbb{N}</span>. If the <span class="math">k</span>-<span class="math">\\operatorname{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to <span class="math">\\operatorname{GroupGen}</span>, then 4.5 is a somewhere argument of knowledge.</p>

    <p class="text-gray-300">Proof. We start by defining the trapdoor setup and extraction algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TrapSetup  <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, i^{*})</span> : The trapdoor algorithm uses the following procedure (we highlight in green the differences in the common reference string between TrapSetup and Setup):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{G} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, g_1, g_2, e) \\gets \\mathrm{GroupGen}(1^\\lambda)</span> . Sample matrices  <span class="math">\\mathbf{M}, \\hat{\\mathbf{M}} \\gets \\mathbb{Z}_p^{(k+1) \\times k}</span> .</li>

      <li>For  <span class="math">i \\neq i^*</span> , sample  <span class="math">\\alpha_i, \\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and let  <span class="math">\\mathbf{a}_i \\gets \\mathbf{M}\\alpha_i</span> ,  <span class="math">\\hat{\\mathbf{a}}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\hat{\\mathbf{M}}\\hat{\\alpha}_i</span> . Let  <span class="math">\\mathbf{0} \\neq \\mathbf{\\tau} \\in \\mathbb{Z}_p^{k+1}</span>  be any non-zero vector such that  <span class="math">\\mathbf{\\tau}^\\top \\mathbf{M} = \\mathbf{0}</span> . Since  <span class="math">\\mathbf{M}</span>  has rank at most  <span class="math">k</span> , such a  <span class="math">\\mathbf{\\tau}</span>  always exists and can be efficiently computed.</li>

      <li>Sample  <span class="math">\\mathbf{a}_{i^<em>}, \\hat{\\mathbf{a}}_{i^</em>} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k+1}</span> . Let  <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span>  and  <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span> .</li>

      <li>For each  <span class="math">i, j \\in [m]</span>  where  <span class="math">i \\neq j</span> , sample  <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span> . Construct  <span class="math">\\mathbf{B}_{i,j}</span>  and  <span class="math">\\hat{\\mathbf{B}}_{i,j}</span>  for  <span class="math">i \\neq j</span>  as follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\top} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\top} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\top} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\top} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the common reference string  <span class="math">\\mathrm{crs}^* = \\left(\\mathcal{G},[\\mathbf{M}]_1,\\hat{\\mathbf{M}} ]_2,\\mathbf{a}]_1,\\hat{\\mathbf{a}} ]_2,\\{\\mathbf{a}_i\\}_{1},\\hat{\\mathbf{a}}_i\\}_{2}\\right)</span>  and the trapdoor  <span class="math">\\mathrm{td} = \\pmb {\\tau}\\in \\mathbb{Z}_p^{k + 1}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract  <span class="math">(\\mathrm{td}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi)</span> : On input the trapdoor  <span class="math">\\mathrm{td} = \\pmb{\\tau} \\in \\mathbb{Z}_p^{k+1}</span> , the Boolean circuit  <span class="math">C: \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span> , statements  <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span> , and the proof</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left(\\left\\{\\left[ \\mathbf {u} _ {d} \\right] _ {1}, \\left[ \\hat {\\mathbf {u}} _ {d} \\right] _ {2} \\right\\} _ {d \\in [ t ]}, \\left\\{\\left[ \\mathbf {V} _ {n + d, i} \\right] _ {1}, \\left[ \\hat {\\mathbf {V}} _ {n + d, i} \\right] _ {2} \\right\\} _ {d \\in [ h ], i \\in \\{1, 2 \\}}, \\left\\{\\left[ \\mathbf {W} _ {\\ell , i} \\right] _ {1}, \\left[ \\hat {\\mathbf {W}} _ {\\ell , i} \\right] _ {2} \\right\\} _ {\\ell \\in [ s ], i \\in \\{1, 2 \\}}\\right),</span></div>

    <p class="text-gray-300">the extraction algorithm computes  <span class="math">\\pmb{\\tau}^{\\top}[\\mathbf{u}_d]_1</span> . It sets  <span class="math">w_{d}^{<em>} = 0</span>  if  <span class="math">\\pmb{\\tau}^{\\top}[\\mathbf{u}]_{1} = [0]_{1}</span> , and  <span class="math">w_{d}^{</em>} = 1</span>  otherwise for each  <span class="math">d = n + 1, \\ldots, n + h</span> . It outputs  <span class="math">\\mathbf{w}^{<em>} = (w_{n + 1}^{</em>}, \\ldots, w_{n + h}^{*})</span> .</p>

    <p class="text-gray-300">We now show the CRS indistinguishability and somewhere extractable in trapdoor mode properties.</p>

    <p class="text-gray-300">Lemma 4.8 (CRS Indistinguishability). If the  <span class="math">k</span> -Lin assumption holds in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  with respect to GroupGen, then Construction 4.5 satisfies CRS indistinguishability.</p>

    <p class="text-gray-300">Proof. Take any polynomial  <span class="math">m = m(\\lambda)</span> ,  <span class="math">s = s(\\lambda)</span> . We now proceed via a simple hybrid argument:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_0</span> : This is the real distribution. At the beginning of the security game, the adversary chooses an index  <span class="math">i^* \\in [m]</span> . The challenger then constructs the common reference string by running Setup  <span class="math">(1^\\lambda, 1^m, 1^s)</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">\\mathcal{G} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, g_1, g_2, e) \\gets \\mathrm{GroupGen}(1^\\lambda)</span> . Sample matrices  <span class="math">\\mathbf{M}, \\hat{\\mathbf{M}} \\gets \\mathbb{Z}_p^{(k+1) \\times k}</span> .</li>

      <li>For each  <span class="math">i \\in [m]</span> , sample  <span class="math">\\alpha_i, \\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and compute  <span class="math">\\mathbf{a}_i \\gets \\mathbf{M}\\alpha_i</span> ,  <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}}\\hat{\\alpha}_i</span> . Let  <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span>  and  <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span> .</li>

      <li>For each  <span class="math">i, j \\in [m]</span>  where  <span class="math">i \\neq j</span> , sample  <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span>  and let  <span class="math">\\mathbf{B}_{i,j} \\gets \\mathbf{M}(\\boldsymbol{\\alpha}_i \\hat{\\boldsymbol{\\alpha}}_j^{\\top} + \\mathbf{R}_{i,j}) \\in \\mathbb{Z}_p^{(k+1) \\times k}</span>  and  <span class="math">\\hat{\\mathbf{B}}_{i,j} \\gets -\\hat{\\mathbf{M}}\\mathbf{R}_{i,j}^{\\top} \\in \\mathbb{Z}_p^{(k+1) \\times k}</span> .</li>

      <li>Set  <span class="math">\\operatorname{crs} = \\left( \\mathcal{G}, [\\mathbf{M}]_1, [\\hat{\\mathbf{M}}]_2, [\\mathbf{a}]_1, [\\hat{\\mathbf{a}}]_2, \\{[\\mathbf{a}_i]_1, [\\hat{\\mathbf{a}}_i]_2\\}_{i \\in [m]}, \\{[\\mathbf{B}_{i,j}]_1, [\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i \\neq j} \\right)</span> .</li>

    </ul>

    <p class="text-gray-300">The challenger gives  <span class="math">\\operatorname{crs}</span>  to  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{A}</span>  outputs a bit  <span class="math">b&#x27; \\in \\{0,1\\}</span> , which is the output of the experiment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_1</span> : Same as  <span class="math">\\mathrm{Hyb}_0</span>  except the challenger constructs  <span class="math">\\mathbf{B}_{i,j}</span>  and  <span class="math">\\hat{\\mathbf{B}}_{i,j}</span>  as in TrapSetup:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [m]</span> , sample  <span class="math">\\alpha_i, \\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and compute  <span class="math">\\mathbf{a}_i \\gets \\mathbf{M}\\alpha_i</span> ,  <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}}\\hat{\\alpha}_i</span> . Let  <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span>  and  <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span> .</li>

      <li>For each  <span class="math">i, j \\in [m]</span>  where  <span class="math">i \\neq j</span> , sample  <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span>  and compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\top} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\top} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\top} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\top} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_2</span>: Same as <span class="math">\\mathrm{Hyb}_1</span> except the challenger samples <span class="math">\\mathbf{a}_{i^*} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k+1}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i \\in [m]</span>, sample <span class="math">\\alpha_i, \\hat{\\alpha}_i \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^k</span>. For <span class="math">i \\neq i^<em></span>, let <span class="math">\\mathbf{a}_i \\gets \\mathbf{M} \\alpha_i</span> and sample <span class="math">\\mathbf{a}_{i^</em>} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k+1}</span>. For all <span class="math">i \\in [m]</span>, let <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}} \\hat{\\alpha}_i</span>. Let <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span> and <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span>.</li>

      <li>For each <span class="math">i, j \\in [m]</span> where <span class="math">i \\neq j</span>, sample <span class="math">\\mathbf{R}_{i,j} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k \\times k}</span> and compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathsf {T}} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathsf {T}} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_3</span>: Same as <span class="math">\\mathrm{Hyb}_2</span> except the challenger sample <span class="math">\\hat{\\mathbf{a}}_{i^*} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k+1}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\neq i^<em></span>, sample <span class="math">\\alpha_i, \\hat{\\alpha}_i \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^k</span> and let <span class="math">\\mathbf{a}_i \\gets \\mathbf{M} \\alpha_i</span>, <span class="math">\\hat{\\mathbf{a}}_i \\xleftarrow{\\mathbb{R}} \\hat{\\mathbf{M}} \\hat{\\alpha}_i</span>. Sample <span class="math">\\mathbf{a}_{i^</em>}</span>, <span class="math">\\hat{\\mathbf{a}}_{i^*} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k+1}</span>. Let <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span> and <span class="math">\\hat{\\mathbf{a}} \\gets \\sum_{i \\in [m]} \\hat{\\mathbf{a}}_i</span>.</li>

      <li>For each <span class="math">i, j \\in [m]</span> where <span class="math">i \\neq j</span>, sample <span class="math">\\mathbf{R}_{i,j} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k \\times k}</span> and compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathsf {T}} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathsf {T}} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">In this experiment, crs is distributed according to TrapSetup <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, i^{*})</span>.</p>

    <p class="text-gray-300">For an adversary <span class="math">\\mathcal{A}</span>, we write <span class="math">\\mathrm{Hyb}_i(\\mathcal{A})</span> to denote the output of experiment <span class="math">\\mathrm{Hyb}_i</span> with algorithm <span class="math">\\mathcal{A}</span>. We now show that each adjacent pair of hybrid experiments are computationally indistinguishable (or identical). In the following analysis, we use the fact that the <span class="math">k</span>-Lin assumption implies the <span class="math">\\mathrm{MDDH}_k</span> assumption (see Theorem 4.4). We will use the <span class="math">\\mathrm{MDDH}_k</span> assumption in our analysis below.</p>

    <p class="text-gray-300"><strong>Claim 4.9.</strong> For all adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\operatorname<em>{Pr}[\\mathrm{Hyb}_0(\\mathcal{A}) = 1] = \\operatorname</em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> This is just a syntactic relabeling. We consider the two cases <span class="math">j = i^{<em>}</span> and <span class="math">j \\neq i^{</em>}</span> separately:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">j \\neq i^{*}</span>. In <span class="math">\\mathrm{Hyb}_0</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\mathbf {M} \\left(\\boldsymbol {\\alpha} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {R} _ {i, j}\\right) = \\left(\\mathbf {M} \\boldsymbol {\\alpha} _ {i}\\right) \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {M R} _ {i, j} = \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {M R} _ {i, j}.</span></div>

    <p class="text-gray-300">Thus <span class="math">\\mathbf{B}_{i,j}</span> is identically distributed in <span class="math">\\mathrm{Hyb}_0</span> and <span class="math">\\mathrm{Hyb}_1</span>. In both experiments, <span class="math">\\hat{\\mathbf{B}}_{i,j} = -\\hat{\\mathbf{M}}\\mathbf{R}_{i,j}^{\\top}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">j = i^{<em>}</span>. Consider the distribution of <span class="math">\\mathbf{B}_{i,i^{</em>}}</span> and <span class="math">\\hat{\\mathbf{B}}_{i,i^{<em>}}</span> in <span class="math">\\mathrm{Hyb}_0</span> and <span class="math">\\mathrm{Hyb}_1</span> for <span class="math">i \\neq i^{</em>}</span>. In <span class="math">\\mathrm{Hyb}_0</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, i ^ {*}} = \\mathbf {M} \\left(\\boldsymbol {\\alpha} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {i ^ {*}} ^ {\\mathsf {T}} + \\mathbf {R} _ {i, i ^ {*}}\\right) \\quad \\text{and} \\quad \\hat {\\mathbf {B}} _ {i, i ^ {*}} = - \\hat {\\mathbf {M}} \\mathbf {R} _ {i, i ^ {*}} ^ {\\mathsf {T}},</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{R}_{i,i^<em>} \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k \\times k}</span>. Suppose we instead sampled <span class="math">\\mathbf{R}_{i,i^</em>}</span> as <span class="math">\\mathbf{R}_{i,i^<em>}^</em> - \\boldsymbol{\\alpha}_i \\hat{\\boldsymbol{\\alpha}}_{i^<em>}^{\\top}</span> where <span class="math">\\mathbf{R}_{i,i^</em>}^<em> \\xleftarrow{\\mathbb{R}} \\mathbb{Z}_p^{k \\times k}</span>. Certainly, <span class="math">\\mathbf{R}_{i,i^</em>}</span> is still uniform over <span class="math">\\mathbb{Z}_p^{k \\times k}</span>. Substituting into the above expressions, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, i ^ {*}} = \\mathbf {M} \\left(\\boldsymbol {\\alpha} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {i ^ {*}} ^ {\\mathsf {T}} + \\mathbf {R} _ {i, i ^ {*}}\\right) = \\mathbf {M R} _ {i, i ^ {*}} ^ {*}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\mathbf {B}} _ {i, i ^ {*}} = - \\hat {\\mathbf {M}} \\mathbf {R} _ {i, i ^ {*}} ^ {\\mathsf {T}} = - \\hat {\\mathbf {M}} (\\mathbf {R} _ {i, i ^ {*}} ^ {*}) ^ {\\mathsf {T}} + \\hat {\\mathbf {M}} \\hat {\\boldsymbol {\\alpha}} _ {i ^ {*}} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}} = - \\hat {\\mathbf {M}} (\\mathbf {R} _ {i, i ^ {*}} ^ {*}) ^ {\\mathsf {T}} + \\hat {\\mathbf {a}} _ {i ^ {*}} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}},</span></div>

    <p class="text-gray-300">which is precisely the distribution of <span class="math">\\mathbf{B}_{i,i^<em>}</span> and <span class="math">\\hat{\\mathbf{B}}_{i,i^</em>}</span> in <span class="math">\\mathrm{Hyb}_1</span>. Thus, the adversary's view in <span class="math">\\mathrm{Hyb}_0</span> and <span class="math">\\mathrm{Hyb}_1</span> is identically distributed and the claim follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 4.10.</strong> Suppose the <span class="math">\\mathrm{MDDH}_k</span> assumption holds in the group <span class="math">\\mathbb{G}_1</span>. Then, for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda \\in \\mathbb{N}</span>, $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_2(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose there exists an efficient adversary  <span class="math">\\mathcal{A}</span>  such that  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\operatorname{Hyb}_1(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\operatorname{Hyb}_2(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\varepsilon<span class="math">  for some non-negligible  </span>\\varepsilon<span class="math"> . We use  </span>\\mathcal{A}<span class="math">  to construct an algorithm  </span>\\mathcal{B}<span class="math">  for the  </span>\\mathrm{MDDH}_k<span class="math">  assumption in  </span>\\mathbb{G}_1$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  receives the group description  <span class="math">\\mathcal{G}</span> , the matrix  <span class="math">[\\mathbf{M}]_1 \\in \\mathbb{G}_1^{(k+1)\\times k}</span>  and a challenge  <span class="math">[\\mathbf{z}]_1 \\in \\mathbb{G}_1^{k+1}</span>  from the  <span class="math">\\mathrm{MDDH}_k</span>  challenger.</li>

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  starts running  <span class="math">\\mathcal{A}</span>  to obtain the challenge index  <span class="math">i^{*} \\in [m]</span> .</li>

      <li>For all  <span class="math">i \\in [m]</span> , algorithm  <span class="math">\\mathcal{B}</span>  samples  <span class="math">\\alpha_{i} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_{p}^{k}</span> . For  <span class="math">i \\neq i^{<em>}</span> , it sets  <span class="math">[\\mathbf{a}_i]_1 \\gets [\\mathbf{M}]_1 \\alpha_i</span>  and it sets  <span class="math">[\\mathbf{a}_{i^</em>}]_1 \\gets [\\mathbf{z}]_1</span> . Next, it samples  <span class="math">\\hat{\\mathbf{M}} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_{p}^{(k+1)\\times k}</span> ,  <span class="math">\\hat{\\alpha}_{i} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_{p}^{k}</span>  and  <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}} \\hat{\\alpha}_i</span>  for all  <span class="math">i \\in [m]</span> .</li>

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  sets  <span class="math">[\\mathbf{a}]_1\\gets \\sum_{i\\in [m]}[\\mathbf{a}_i]_1</span>  and  <span class="math">\\hat{\\mathbf{a}}\\gets \\sum_{i\\in [m]}\\hat{\\mathbf{a}}_i</span> . Then, for  <span class="math">i\\neq j</span> , it samples  <span class="math">\\mathbf{R}_{i,j}\\stackrel {\\mathrm{R}}{\\leftarrow}\\mathbb{Z}_p^{k\\times k}</span>  and computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">[ \\mathbf {B} _ {i, j} ] _ {1} = \\left\\{ \\begin{array}{l l} [ \\mathbf {a} _ {i} ] _ {1} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + [ \\mathbf {M} ] _ {1} \\mathbf {R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ [ \\mathbf {M} ] _ {1} \\mathbf {R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M}} \\mathbf {R} _ {i, j} ^ {\\mathsf {T}} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M}} \\mathbf {R} _ {i, j} ^ {\\mathsf {T}} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Importantly, algorithm  <span class="math">\\mathcal{B}</span>  only computes  <span class="math">[\\mathbf{B}_{i,j}]_1</span>  and  <span class="math">\\hat{\\mathbf{B}}_{i,j}</span>  where  <span class="math">i\\neq j</span> . It does not need to compute  <span class="math">\\hat{\\mathbf{B}}_{i^{<em>},i^{</em>}}</span>  which would depend on the (non-existent) value  <span class="math">\\alpha_{i^*}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It sets  <span class="math">\\mathrm{crs} = \\left(\\mathcal{G},[\\mathbf{M}]_1,[\\hat{\\mathbf{M}}]_2,[\\mathbf{a}]_1,[\\hat{\\mathbf{a}}]_2,\\{[\\mathbf{a}_i]_1,[\\hat{\\mathbf{a}}_i]_2\\}_{i\\in [m]},\\{[\\mathbf{B}_{i,j}]_1,[\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i\\neq j}\\right)</span>  and gives  <span class="math">\\mathrm{crs}</span>  to  <span class="math">\\mathcal{A}</span> . Finally, it outputs whatever  <span class="math">\\mathcal{A}</span>  outputs.</li>

    </ol>

    <p class="text-gray-300">Using the above procedure, algorithm  <span class="math">\\mathcal{B}</span>  is able to construct all of the components of crs from the encodings  <span class="math">[\\mathbf{M}]_1</span>  and  <span class="math">[\\mathbf{z}]_1</span> . If  <span class="math">\\mathbf{z} = \\mathbf{M}\\mathbf{v}</span>  for some  <span class="math">\\mathbf{v} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span> , then crs is distributed as in  <span class="math">\\mathrm{Hyb}_1</span> . Conversely, if  <span class="math">\\mathbf{z} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span> , then crs is distributed as in  <span class="math">\\mathrm{Hyb}_2</span> . Hence,  <span class="math">\\mathcal{B}</span>  breaks  <span class="math">\\mathrm{MDDH}_k</span>  with the same advantage  <span class="math">\\varepsilon</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 4.11. Suppose the  <span class="math">\\mathrm{MDDH}_k</span>  assumption holds in group  <span class="math">\\mathbb{G}_2</span> . Then, for all efficient adversaries  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}</span> ,  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_2(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_3(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. This follows by a similar argument as in the proof of Claim 4.10. Suppose there exists an efficient adversary  <span class="math">\\mathcal{A}</span>  where  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_2(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_3(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\varepsilon<span class="math">  for some non-negligible  </span>\\varepsilon<span class="math"> . We use  </span>\\mathcal{A}<span class="math">  to construct an adversary  </span>\\mathcal{B}<span class="math">  for the  </span>\\mathrm{MDDH}_k<span class="math">  assumption in  </span>\\mathbb{G}_2$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  receives the group description  <span class="math">\\mathcal{G}</span> , the matrix  <span class="math">[\\hat{\\mathbf{M}}]_2 \\in \\mathbb{G}_2^{(k+1)\\times k}</span>  and a challenge  <span class="math">[\\hat{\\mathbf{z}}]_2 \\in \\mathbb{G}_2^{k+1}</span>  from the  <span class="math">\\mathrm{MDDH}_k</span>  challenger.</li>

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  starts running  <span class="math">\\mathcal{A}</span>  to obtain the challenge index  <span class="math">i^{*} \\in [m]</span> .</li>

      <li>It samples  <span class="math">\\mathbf{M} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{(k+1) \\times k}</span> . For  <span class="math">i \\neq i^<em></span> , it samples  <span class="math">\\alpha_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and sets  <span class="math">\\mathbf{a}_i \\gets \\mathbf{M} \\alpha_i</span> . It samples  <span class="math">\\mathbf{a}_{i^</em>} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span> .</li>

      <li>For  <span class="math">i \\neq i^<em></span> , it samples  <span class="math">\\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and sets  <span class="math">[\\hat{\\mathbf{a}}_i]_2 \\gets [\\hat{\\mathbf{M}}]_2 \\hat{\\alpha}_i</span> . It sets  <span class="math">[\\hat{\\mathbf{a}}_{i^</em>}]_2 \\gets [\\hat{\\mathbf{z}}]_2</span> .</li>

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [m]} \\mathbf{a}_i</span>  and  <span class="math">[\\hat{\\mathbf{a}}]_2 \\gets \\sum_{i \\in [m]} [\\hat{\\mathbf{a}}_i]_2</span> .</li>

      <li>For  <span class="math">i \\neq j</span> , it samples  <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span>  and computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathsf {T}} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad [ \\hat {\\mathbf {B}} _ {i, j} ] _ {2} = \\left\\{ \\begin{array}{l l} - [ \\hat {\\mathbf {M}} ] _ {2} \\mathbf {R} _ {i, j} ^ {\\mathsf {T}} &amp;amp; j \\neq i ^ {*} \\\\ - [ \\hat {\\mathbf {M}} ] _ {2} \\mathbf {R} _ {i, j} ^ {\\mathsf {T}} + [ \\hat {\\mathbf {a}} _ {j} ] _ {2} \\boldsymbol {\\alpha} _ {i} ^ {\\mathsf {T}} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Importantly, algorithm  <span class="math">\\mathcal{B}</span>  only needs to compute  <span class="math">[\\hat{\\mathbf{B}}_{i,j}]_2</span>  where  <span class="math">i\\neq j</span> . It does not need to compute  <span class="math">[\\hat{\\mathbf{B}}_{i^{<em>},i^{</em>}}]_{2}</span>  which would depend on the (non-existent) value  <span class="math">\\alpha_{i^*}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It sets  <span class="math">\\mathrm{crs} = \\left(\\mathcal{G},[\\mathbf{M}]_1,[\\hat{\\mathbf{M}}]_2,[\\mathbf{a}]_1,[\\hat{\\mathbf{a}}]_2,\\{[\\mathbf{a}_i]_1,[\\hat{\\mathbf{a}}_i]_2\\}_{i\\in [m]},\\{[\\mathbf{B}_{i,j}]_1,[\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i\\neq j}\\right)</span>  and gives  <span class="math">\\mathrm{crs}</span>  to  <span class="math">\\mathcal{A}</span> . Finally,  <span class="math">\\mathcal{B}</span>  outputs whatever  <span class="math">\\mathcal{A}</span>  outputs.</li>

    </ol>

    <p class="text-gray-300">Using the above procedure, algorithm <span class="math">\\mathcal{B}</span> is able to construct all of the components of <span class="math">\\mathrm{crs}</span> from the encodings <span class="math">[\\mathbf{M}]_{2}</span> and <span class="math">[\\mathbf{z}]_{2}</span>. If <span class="math">\\mathbf{z}=\\mathbf{M}\\mathbf{v}</span> for some <span class="math">\\mathbf{v}\\stackrel{{\\scriptstyle\\tt n}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k}</span>, then <span class="math">\\mathrm{crs}</span> is distributed as in <span class="math">\\mathrm{Hyb}_{2}</span>. Conversely, if <span class="math">\\mathbf{z}\\stackrel{{\\scriptstyle\\tt n}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k}</span>, then <span class="math">\\mathrm{crs}</span> is distributed as in <span class="math">\\mathrm{Hyb}_{3}</span>. Hence, <span class="math">\\mathcal{B}</span> breaks <span class="math">\\mathrm{MDDH}_{k}</span> with the same advantage <span class="math">\\varepsilon</span>. ∎</p>

    <p class="text-gray-300">Combining 4.9 to 4.11, we conclude that under the <span class="math">\\mathrm{MDDH}_{k}</span> assumption, CRS indistinguishability holds. Since <span class="math">k</span>-Lin implies <span class="math">\\mathrm{MDDH}_{k}</span> (Theorem 4.4), the same result holds under <span class="math">k</span>-Lin. ∎</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 4.12 (Somewhere Extractable in Trapdoor Mode).</h6>

    <p class="text-gray-300">For all constants <span class="math">k\\in\\mathbb{N}</span>, 4.12 is somewhere sound in trapdoor mode.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any polynomial <span class="math">m=m(\\lambda)</span> and <span class="math">s=s(\\lambda)</span>. Let <span class="math">i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{m},1^{s})</span> and <span class="math">(\\mathrm{crs}^{</em>},\\mathrm{td})\\leftarrow\\mathrm{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{*})</span>. By construction,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{crs}^{*}=\\left(\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2},\\{[{\\mathbf{a}}_{i}]_{1},[{\\hat{\\mathbf{a}}}_{i}]_{2}\\}_{i\\in[m]},\\{[{\\mathbf{B}}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\right)\\quad\\text{and}\\quad\\mathrm{td}=\\mathbf{\\tau},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{M},\\hat{\\mathbf{M}}\\stackrel{{\\scriptstyle\\tt n}}{{\\leftarrow}}\\mathbb{Z}_{p}^{(k+1)\\times k}</span>, <span class="math">\\mathbf{a}_{i^{<em>}},\\hat{\\mathbf{a}}_{i^{</em>}}\\stackrel{{\\scriptstyle\\tt n}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k+1}</span>, and for <span class="math">i\\neq i^{*}</span>, <span class="math">\\mathbf{a}_{i}=\\mathbf{M}\\bm{\\alpha}_{i}</span>, <span class="math">\\hat{\\mathbf{a}}_{i}=\\hat{\\mathbf{M}}\\hat{\\bm{\\alpha}}_{i}</span> where <span class="math">\\bm{\\alpha}_{i},\\hat{\\bm{\\alpha}}_{i}\\stackrel{{\\scriptstyle\\tt n}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k}</span>. We start by proving the following claim that will be useful in our analysis:</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Claim 4.13.</h6>

    <p class="text-gray-300">With probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>, the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every vector <span class="math">\\mathbf{v}\\in\\mathbb{Z}_{p}^{k+1}</span>, there exists <span class="math">s,\\hat{s}\\in\\mathbb{Z}_{p}</span> and <span class="math">\\mathbf{t},\\hat{\\mathbf{t}}\\in\\mathbb{Z}_{p}^{k}</span> such that <span class="math">\\mathbf{v}=s\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}</span> and <span class="math">\\mathbf{v}=\\hat{s}\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\mathbf{t}}</span>. In particular, <span class="math">\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}\\neq\\mathbf{0}</span>.</li>

      <li>Every matrix <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{p}^{(k+1)\\times(k+1)}</span> can be uniquely written as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{A}=s\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}+\\sum_{i\\in[k]}t_{i}\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{m}}_{i}^{\\intercal}+\\sum_{i\\in[k]}u_{i}\\mathbf{m}_{i}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}+\\sum_{i,j\\in[k]}v_{i,j}\\mathbf{m}_{i}\\hat{\\mathbf{m}}_{j}^{\\intercal}.</span></p>

    <p class="text-gray-300">where <span class="math">s,t_{i},u_{i},v_{i,j}\\in\\mathbb{Z}_{p}</span>, <span class="math">\\mathbf{m}_{1},\\dots,\\mathbf{m}_{k}</span> are the columns of <span class="math">\\mathbf{M}</span>, and <span class="math">\\hat{\\mathbf{m}}_{1},\\dots,\\hat{\\mathbf{m}}_{k}</span> are the columns of <span class="math">\\hat{\\mathbf{M}}</span>. Moreover, we define the projection operator <span class="math">\\mathrm{proj}(\\mathbf{A})\\mapsto s\\mathbf{a}_{i^{<em>}}\\mathbf{a}_{i^{</em>}}^{\\intercal}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{p}^{(k+1)\\times(k+1)}</span> and suppose that there exists <span class="math">s\\in\\mathbb{Z}_{p}</span> and <span class="math">\\mathbf{t}_{1},\\mathbf{t}_{2},\\mathbf{z}_{1},\\mathbf{z}_{2}\\in\\mathbb{Z}_{p}^{k}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{A}=s\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}+\\mathbf{a}_{i^{<em>}}\\mathbf{t}_{1}^{\\intercal}\\hat{\\mathbf{M}}^{\\intercal}+\\mathbf{M}\\mathbf{t}_{2}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}+\\mathbf{M}\\mathbf{z}_{1}\\mathbf{z}_{2}^{\\intercal}\\hat{\\mathbf{M}}^{\\intercal}.</span></p>

    <p class="text-gray-300">Then, <span class="math">\\mathrm{proj}(\\mathbf{A})=s\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">\\mathbf{V}\\in\\mathbb{Z}_{p}^{(k+1)\\times k}</span>, <span class="math">\\mathrm{proj}(\\mathbf{M}\\mathbf{V}^{\\intercal})=0=\\mathrm{proj}(\\mathbf{V}\\hat{\\mathbf{M}}^{\\intercal})</span>.</li>

    </ol>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show each statement separately:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This statement is equivalent to saying that the matrices <span class="math">\\mathbf{M}^{\\prime}=[\\mathbf{a}_{i^{<em>}}\\mid\\mathbf{M}]</span> and <span class="math">\\hat{\\mathbf{M}}^{\\prime}=[\\hat{\\mathbf{a}}_{i^{</em>}}\\mid\\hat{\\mathbf{M}}]\\in\\mathbb{Z}_{p}^{(k+1)\\times(k+1)}</span> are full rank. By construction, the distribution of <span class="math">\\mathbf{M}^{\\prime}</span> and <span class="math">\\hat{\\mathbf{M}}^{\\prime}</span> is uniform over <span class="math">\\mathbb{Z}_{p}^{(k+1)\\times(k+1)}</span>. By the Schwartz-Zippel lemma, the determinant of <span class="math">\\mathbf{M}^{\\prime}</span> and <span class="math">\\hat{\\mathbf{M}}^{\\prime}</span> is non-zero with probability at least <span class="math">1-(k+1)/p=\\mathrm{negl}(\\lambda)</span>.</li>

      <li>Define <span class="math">\\mathbf{M}^{\\prime}=[\\mathbf{a}_{i^{<em>}}\\mid\\mathbf{M}]</span> and <span class="math">\\hat{\\mathbf{M}}^{\\prime}=[\\hat{\\mathbf{a}}_{i^{</em>}}\\mid\\hat{\\mathbf{M}}]</span> as before, and consider <span class="math">\\mathbf{M}^{\\prime}\\otimes\\hat{\\mathbf{M}}^{\\prime}\\in\\mathbb{Z}_{p}^{(k+1)^{2}\\times(k+1)^{2}}</span>. Since <span class="math">\\mathbf{M}^{\\prime}</span> and <span class="math">\\hat{\\mathbf{M}}^{\\prime}</span> are invertible with overwhelming probability, the matrix <span class="math">\\mathbf{M}^{\\prime}\\otimes\\hat{\\mathbf{M}}^{\\prime}</span> is also invertible (with inverse <span class="math">(\\mathbf{M}^{\\prime})^{-1}\\otimes(\\hat{\\mathbf{M}}^{\\prime})^{-1}</span>). Thus, the columns of <span class="math">\\mathbf{M}^{\\prime}\\otimes\\hat{\\mathbf{M}}^{\\prime}</span> form a basis for <span class="math">\\mathbb{Z}_{p}^{(k+1)^{2}}</span>. Suppose we rearrange each column of <span class="math">\\mathbf{M}^{\\prime}\\otimes\\hat{\\mathbf{M}}^{\\prime}</span> into a <span class="math">(k+1)</span>-by-<span class="math">(k+1)</span> matrix in row-major order. This yields the following collection of matrices:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal},\\quad\\{\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{m}}_{i}^{\\intercal}\\}_{i\\in[k]},\\quad\\{\\mathbf{m}_{i}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\intercal}\\}_{i\\in[k]}\\quad\\{\\mathbf{m}_{i}\\hat{\\mathbf{m}}_{j}^{\\intercal}\\}_{i,j\\in[k]}.</span> (4.2)</p>

    <p class="text-gray-300">Since the columns of <span class="math">\\mathbf{M}^{\\prime}\\otimes\\hat{\\mathbf{M}}^{\\prime}</span> form a basis for <span class="math">\\mathbb{Z}_{p}^{(k+1)^{2}}</span>, the matrices in Eq. 4.2 form a basis for <span class="math">\\mathbb{Z}_{p}^{(k+1)\\times(k+1)}</span>, and the claim follows.</p>

    <p class="text-gray-300">(iii) We express  <span class="math">\\mathbf{A}</span>  as a linear combination of the basis vectors in Eq. (4.2):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} = s \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\mathbf {a} _ {i ^ {*}} \\sum_ {i \\in [ k ]} t _ {1, i} \\hat {\\mathbf {m}} _ {i} ^ {\\top} + \\sum_ {i \\in [ k ]} t _ {2, i} \\mathbf {m} _ {i} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\left(\\sum_ {i \\in [ k ]} z _ {1, i} \\mathbf {m} _ {i}\\right) \\left(\\sum_ {j \\in [ k ]} z _ {2, j} \\hat {\\mathbf {m}} _ {j} ^ {\\top}\\right) \\\\ = s \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\sum_ {i \\in [ k ]} t _ {1, i} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {m}} _ {i} ^ {\\top} + \\sum_ {i \\in [ k ]} t _ {2, i} \\mathbf {m} _ {i} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\sum_ {i, j \\in [ k ]} z _ {1, i} z _ {2, j} \\mathbf {m} _ {i} \\hat {\\mathbf {m}} _ {j} ^ {\\top}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By definition,  <span class="math">\\mathrm{proj}(\\mathbf{A}) = s\\mathbf{a}_{i^<em>}\\hat{\\mathbf{a}}_{i^</em>}</span> .</p>

    <p class="text-gray-300">(iv) By Property (i), we can write  <span class="math">\\mathbf{V} = \\hat{\\mathbf{a}}_{i^*}\\hat{\\mathbf{s}}^\\top +\\hat{\\mathbf{M}}\\hat{\\mathbf{T}}</span>  where  <span class="math">\\hat{\\mathbf{s}}\\in \\mathbb{Z}_p^k</span>  and  <span class="math">\\hat{\\mathbf{T}}\\in \\mathbb{Z}_p^{k\\times k}</span> . We can further decompose  <span class="math">\\hat{\\mathbf{T}} = \\sum_{i,j\\in [k]}\\hat{t}_{i,j}\\mathbf{e}_i\\mathbf{e}_j^\\top</span>  where  <span class="math">\\hat{t}_{i,j}</span>  is the  <span class="math">(i,j)^{\\mathrm{th}}</span>  component of  <span class="math">\\hat{\\mathbf{T}}</span>  and  <span class="math">\\mathbf{e}_i\\in \\mathbb{Z}_p^k</span>  denotes the  <span class="math">i^{\\mathrm{th}}</span>  canonical basis vector. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {M V} ^ {\\top} = \\mathbf {M} \\hat {\\mathbf {s}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\mathbf {M} \\hat {\\mathbf {T}} ^ {\\top} \\hat {\\mathbf {M}} ^ {\\top} = \\mathbf {M} \\hat {\\mathbf {s}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top} + \\sum_ {i, j \\in [ k ]} \\hat {t} _ {i, j} \\mathbf {M} \\mathbf {e} _ {j} \\mathbf {e} _ {i} ^ {\\top} \\hat {\\mathbf {M}} ^ {\\top}.</span></div>

    <p class="text-gray-300">By Property (iii),  <span class="math">\\mathrm{proj}(\\mathbf{M}\\mathbf{V}^{\\top}) = 0</span> . For  <span class="math">\\mathrm{proj}(\\mathbf{V}\\hat{\\mathbf{M}}^{\\top})</span> , we again appeal to Property (i) and write  <span class="math">\\mathbf{V} = \\mathbf{a}_{i^{*}}\\mathbf{s}^{\\top} + \\mathbf{M}\\mathbf{T}</span>  for some  <span class="math">\\mathbf{s} \\in \\mathbb{Z}_p^k</span>  and  <span class="math">\\mathbf{T} \\in \\mathbb{Z}_p^{k \\times k}</span> . By an analogous computation, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {V} \\hat {\\mathbf {M}} ^ {\\top} = \\mathbf {a} _ {i ^ {*}} \\mathbf {s} ^ {\\top} \\hat {\\mathbf {M}} ^ {\\top} + \\sum_ {i, j \\in [ k ]} t _ {i, j} \\mathbf {M} \\mathbf {e} _ {i} \\mathbf {e} _ {j} ^ {\\top} \\hat {\\mathbf {M}} ^ {\\top}.</span></div>

    <p class="text-gray-300">Again by Property (iii),  <span class="math">\\mathrm{proj}(\\mathbf{V}\\hat{\\mathbf{M}}^{\\top}) = 0</span></p>

    <p class="text-gray-300">Returning to the proof of Lemma 4.12, let  <span class="math">C\\colon \\{0,1\\} ^n\\times \\{0,1\\} ^h\\to \\{0,1\\}</span>  be the Boolean circuit,  <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_m\\in \\{0,1\\} ^n</span>  be the set of statements, and</p>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left(\\left\\{\\left[ \\mathbf {u} _ {d} \\right] _ {1}, \\left[ \\hat {\\mathbf {u}} _ {d} \\right] _ {2} \\right\\} _ {d \\in [ t ]}, \\left\\{\\left[ \\mathbf {V} _ {n + d, i} \\right] _ {1}, \\left[ \\hat {\\mathbf {V}} _ {n + d, i} \\right] _ {2} \\right\\} _ {d \\in [ h ], i \\in \\{1, 2 \\}}, \\left\\{\\left[ \\mathbf {W} _ {\\ell , i} \\right] _ {1}, \\left[ \\hat {\\mathbf {W}} _ {\\ell , i} \\right] _ {2} \\right\\} _ {\\ell \\in [ s ], i \\in \\{1, 2 \\}}\\right)</span></div>

    <p class="text-gray-300">be the proof the adversary outputs. Suppose  <span class="math">\\mathrm{Verify}(\\mathrm{crs}^*, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi) = 1</span> . We now show the following claim:</p>

    <p class="text-gray-300">Claim 4.14. Suppose  <span class="math">\\mathrm{Verify}(\\mathrm{crs}^<em>, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), \\pi) = 1</span> . Then, for all  <span class="math">d \\in [t]</span> , there exists  <span class="math">\\mathbf{t}_d, \\hat{\\mathbf{t}}_d \\in \\mathbb{Z}_p^k</span>  and  <span class="math">\\xi_d \\in \\{0,1\\}</span>  such that  <span class="math">\\mathbf{u}_d = \\xi_d \\mathbf{a}_{i^</em>} + \\mathbf{M} \\mathbf{t}_d</span>  and  <span class="math">\\hat{\\mathbf{u}}_d = \\xi_d \\hat{\\mathbf{a}}_{i^<em>} + \\hat{\\mathbf{M}} \\hat{\\mathbf{t}}_d</span> . Moreover,  <span class="math">\\mathbf{x}_{i^</em>} = (\\xi_1, \\ldots, \\xi_n)</span> ,  <span class="math">\\xi_t = 1</span> , and for each gate  <span class="math">G_t = (d_1, d_2, d_3) \\in [t]^3</span> ,  <span class="math">\\xi_d = N A N D(\\xi_{d_1}, \\xi_{d_2})</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\pmb{\\beta} = \\sum_{i\\neq i^{<em>}}\\pmb{\\alpha}_{i}</span>  and  <span class="math">\\hat{\\pmb{\\beta}} = \\sum_{i\\neq i^{</em>}}\\hat{\\pmb{\\alpha}}_{i}</span> . By construction,  <span class="math">\\mathbf{a} = \\sum_{i\\in [m]}\\mathbf{a}_i = \\mathbf{a}_{i^<em>} + \\sum_{i\\neq i^</em>}\\mathbf{M}\\pmb{\\alpha}_i = \\mathbf{a}_{i^<em>} + \\mathbf{M}\\pmb{\\beta}</span> . Similarly,  <span class="math">\\hat{\\mathbf{a}} = \\sum_{i\\in [m]}\\hat{\\mathbf{a}}_i = \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}}\\hat{\\pmb{\\beta}}</span> . We now show the claim for each wire  <span class="math">d\\in [t]</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The claim holds for all statement wires  <span class="math">d \\in [n]</span> . Since Verify outputs 1,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} _ {d} = \\sum_ {i \\in [ m ]} x _ {i, d} \\mathbf {a} _ {i} = x _ {i ^ {*}, d} \\mathbf {a} _ {i ^ {*}} + \\sum_ {i \\neq i ^ {*}} x _ {i, d} \\mathbf {M} \\boldsymbol {\\alpha} _ {i} = x _ {i ^ {*}, d} \\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\left(\\sum_ {i \\neq i ^ {*}} x _ {i, d} \\boldsymbol {\\alpha} _ {i}\\right).</span></div>

    <p class="text-gray-300">Thus  <span class="math">\\mathbf{u}_d</span>  has the desired form. Correspondingly, we can write  <span class="math">\\hat{\\mathbf{u}}_d = x_{i^<em>,d}\\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}}\\sum_{i\\neq i^*}x_{i,d}\\hat{\\boldsymbol{\\alpha}}_i</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider a witness wire  <span class="math">d \\in \\{n + 1, \\dots, n + h\\}</span> . By Claim 4.13 (i), we can write  <span class="math">\\mathbf{u}_d = \\xi_d \\mathbf{a}_{i^<em>} + \\mathbf{M} \\mathbf{t}_d</span> , and  <span class="math">\\hat{\\mathbf{u}}_d = \\hat{\\xi}_d \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}} \\hat{\\mathbf{t}}_d</span> , for some  <span class="math">\\xi_d, \\hat{\\xi}_d \\in \\mathbb{Z}_p</span>  and  <span class="math">\\mathbf{t}_d, \\hat{\\mathbf{t}}_d \\in \\mathbb{Z}_p^k</span> . Our goal is to show  <span class="math">\\xi_d = \\hat{\\xi}_d \\in \\{0, 1\\}</span> . Consider the following terms from the verification relations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {a} \\hat {\\mathbf {u}} _ {d} ^ {\\top} = (\\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\boldsymbol {\\beta}) (\\hat {\\xi} _ {d} \\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\mathbf {t}} _ {d}) ^ {\\top} \\\\ \\mathbf {u} _ {d} \\hat {\\mathbf {a}} ^ {\\top} = (\\xi_ {d} \\mathbf {a} _ {i ^ {*}} + \\mathbf {M t} _ {d}) (\\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\boldsymbol {\\beta}}) ^ {\\top} \\\\ \\mathbf {u} _ {d} \\hat {\\mathbf {u}} _ {d} ^ {\\top} = (\\xi_ {d} \\mathbf {a} _ {i ^ {*}} + \\mathbf {M t} _ {d}) (\\hat {\\xi} _ {d} \\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\mathbf {t}} _ {d}) ^ {\\top} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since Verify outputs 1, both verification relations are satisfied. The same must hold for their projections. By Claim 4.13 (iii), (iv), the following relations must hold:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\underbrace {\\operatorname {p r o j} (\\mathbf {a} \\hat {\\mathbf {u}} _ {d} ^ {\\mathsf {T}})}_{\\hat {\\xi} _ {d} \\cdot \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d} \\hat {\\mathbf {u}} _ {d} ^ {\\mathsf {T}})}_{\\xi_ {d} \\hat {\\xi} _ {d} \\cdot \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {V}} _ {d , 1} ^ {\\mathsf {T}})}_{0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {V} _ {d , 1} \\hat {\\mathbf {M}} ^ {\\mathsf {T}})}_{0} \\\\ \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d} \\hat {\\mathbf {a}} ^ {\\mathsf {T}})}_{\\xi_ {d} \\cdot \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d} \\hat {\\mathbf {u}} _ {d} ^ {\\mathsf {T}})}_{\\xi_ {d} \\hat {\\xi} _ {d} \\cdot \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {V}} _ {d , 2} ^ {\\mathsf {T}})}_{0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {V} _ {d , 2} \\hat {\\mathbf {M}} ^ {\\mathsf {T}})}_{0}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By Claim 4.13 (i),  <span class="math">\\mathbf{a}_{i^<em>}\\hat{\\mathbf{a}}_{i^</em>}^\\top \\neq \\mathbf{0}</span> , and we conclude that  <span class="math">\\hat{\\xi}_d = \\xi_d\\hat{\\xi}_d = \\xi_d</span> . This implies  <span class="math">\\hat{\\xi}_d = \\xi_d = \\xi_d^2</span> , and so  <span class="math">\\xi_d = \\hat{\\xi}_d \\in \\{0,1\\}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider a wire that is the output of some gate  <span class="math">G_{\\ell} = (d_1, d_2, d_3) \\in [t]^3</span> , and suppose moreover that the claim holds for  <span class="math">d_1, d_2</span> : namely,  <span class="math">\\mathbf{u}_{d_1} = \\xi_{d_1} \\mathbf{a}_{i^<em>} + \\mathbf{M} \\mathbf{t}_{d_1}</span> ,  <span class="math">\\hat{\\mathbf{u}}_{d_1} = \\xi_{d_1} \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}} \\hat{\\mathbf{t}}_{d_1}</span> ,  <span class="math">\\mathbf{u}_{d_2} = \\xi_{d_2} \\mathbf{a}_{i^<em>} + \\mathbf{M} \\mathbf{t}_{d_2}</span> , and  <span class="math">\\hat{\\mathbf{u}}_{d_2} = \\xi_{d_2} \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}} \\hat{\\mathbf{t}}_{d_2}</span>  for  <span class="math">\\xi_{d_1}, \\xi_{d_2} \\in \\{0, 1\\}</span>  and  <span class="math">\\mathbf{t}_{d_1}, \\mathbf{t}_{d_2}, \\hat{\\mathbf{t}}_{d_1}, \\hat{\\mathbf{t}}_{d_2} \\in \\mathbb{Z}_p^k</span> . By Claim 4.13 (iii), (iv), we can write  <span class="math">\\mathbf{u}_{d_1} = \\xi_{d_1} \\mathbf{a}_{i^<em>} + \\mathbf{M} \\mathbf{t}_{d_1}</span>  and  <span class="math">\\hat{\\mathbf{u}}_{d_1} = \\hat{\\xi}_{d_1} \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}} \\hat{\\mathbf{t}}_{d_1}</span>  for some  <span class="math">\\xi_{d_1}, \\hat{\\xi}_{d_1} \\in \\mathbb{Z}_p</span>  and  <span class="math">\\mathbf{t}_{d_1}, \\hat{\\mathbf{t}}_{d_1} \\in \\mathbb{Z}_p^k</span> . Our goal is to show that  <span class="math">\\xi_{d_1} = \\hat{\\xi}_{d_1} \\in \\{0, 1\\}</span>  and moreover,  <span class="math">\\xi_{d_1} = \\mathrm{NAND}(\\xi_{d_1}, \\xi_{d_2})</span> . Similar to the previous case, we consider the terms in the two verification relations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {a} \\hat {\\mathbf {a}} ^ {\\mathsf {T}} = (\\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\boldsymbol {\\beta}) (\\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\boldsymbol {\\beta}}) ^ {\\mathsf {T}} \\\\ \\mathbf {u} _ {d _ {1}} \\hat {\\mathbf {u}} _ {d _ {2}} ^ {\\mathsf {T}} = (\\xi_ {d _ {1}} \\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\mathbf {t} _ {d _ {1}}) (\\xi_ {d _ {2}} \\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\mathbf {t}} _ {d _ {2}}) ^ {\\mathsf {T}} \\\\ \\mathbf {a} \\hat {\\mathbf {u}} _ {d _ {3}} ^ {\\mathsf {T}} = (\\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\boldsymbol {\\beta}) (\\hat {\\xi} _ {d _ {3}} \\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\mathbf {t}} _ {d _ {3}}) ^ {\\mathsf {T}} \\\\ \\mathbf {u} _ {d _ {3}} \\hat {\\mathbf {a}} ^ {\\mathsf {T}} = (\\xi_ {d _ {3}} \\mathbf {a} _ {i ^ {*}} + \\mathbf {M} \\mathbf {t} _ {d _ {3}}) (\\hat {\\mathbf {a}} _ {i ^ {*}} + \\hat {\\mathbf {M}} \\hat {\\boldsymbol {\\beta}}) ^ {\\mathsf {T}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We apply the projection operator to the two verification relations and by Claim 4.13 (iii), (iv),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\underbrace {\\operatorname {p r o j} (\\mathbf {a} \\hat {\\mathbf {a}} ^ {\\mathsf {T}})}_{\\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d _ {1}} \\hat {\\mathbf {u}} _ {d _ {2}} ^ {\\mathsf {T}})}_{\\xi_ {d _ {1}} \\xi_ {d _ {2}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {a} \\hat {\\mathbf {u}} _ {d _ {3}} ^ {\\mathsf {T}})}_{\\hat {\\xi} _ {d _ {3}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {W}} _ {\\ell , 1} ^ {\\mathsf {T}})}_{0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {W} _ {\\ell , 1} \\hat {\\mathbf {M}} ^ {\\mathsf {T}})}_{0} \\\\ \\underbrace {\\operatorname {p r o j} (\\mathbf {a} \\hat {\\mathbf {a}} ^ {\\mathsf {T}})}_{\\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d _ {1}} \\hat {\\mathbf {u}} _ {d _ {2}} ^ {\\mathsf {T}})}_{\\xi_ {d _ {1}} \\xi_ {d _ {2}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {d _ {3}} \\hat {\\mathbf {a}} ^ {\\mathsf {T}})}_{\\xi_ {d _ {3}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\mathsf {T}}} + \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {W}} _ {\\ell , 2} ^ {\\mathsf {T}})}_{0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {W} _ {\\ell , 2} \\hat {\\mathbf {M}} ^ {\\mathsf {T}})}_{0}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">If both relations hold, we conclude</p>

    <div class="my-4 text-center"><span class="math-block">1 = \\xi_ {d _ {1}} \\xi_ {d _ {2}} + \\hat {\\xi} _ {d _ {3}} = \\xi_ {d _ {1}} \\xi_ {d _ {2}} + \\xi_ {d _ {3}}.</span></div>

    <p class="text-gray-300">This means  <span class="math">\\xi_{d_3} = \\hat{\\xi}_{d_3} = 1 - \\xi_{d_1}\\xi_{d_2} = \\mathrm{NAND}(\\xi_{d_1},\\xi_{d_2})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the output wire, the output satisfiability check requires that  <span class="math">\\mathbf{u}_t = \\mathbf{a} = \\mathbf{a}_{i^<em>} + \\mathbf{M}\\boldsymbol{\\beta}</span>  and  <span class="math">\\hat{\\mathbf{u}}_t = \\hat{\\mathbf{a}} = \\hat{\\mathbf{a}}_{i^</em>} + \\hat{\\mathbf{M}}\\hat{\\boldsymbol{\\beta}}</span> . This means that  <span class="math">\\xi_t = \\hat{\\xi}_t = 1</span> .</li>

    </ul>

    <p class="text-gray-300">The first two cases show that the claim holds for all input wires  <span class="math">d \\in [n + h]</span> . The final case shows that if the claim holds for the input wires to a gate, then it holds for the output wire. Inductively applying the argument to the gates of the circuit in topological order, we conclude that the claim holds for all  <span class="math">d \\in [t]</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\xi_1, \\ldots, \\xi_t \\in \\{0, 1\\}</span>  be the bits from Claim 4.14. By Claim 4.14,  <span class="math">\\mathbf{x}_{i^<em>} = (\\xi_1, \\ldots, \\xi_n)</span> , and for all gates  <span class="math">G = (d_1, d_2, d_3) \\in [t]^3</span> ,  <span class="math">\\xi_{d_3} = \\mathrm{NAND}(\\xi_{d_1}, \\xi_{d_2})</span> . Thus,  <span class="math">\\xi_1, \\ldots, \\xi_t</span>  is a set of valid wire assignments for the computation  <span class="math">C(\\mathbf{x}_{i^</em>}, \\boldsymbol{\\xi})</span>  where  <span class="math">\\boldsymbol{\\xi} = (\\xi_{n+1}, \\ldots, \\xi_{n+h})</span> . Since the output wire  <span class="math">\\xi_t = 1</span> , this means that  <span class="math">C(\\mathbf{x}_{i^*}, \\boldsymbol{\\xi}) = 1</span> .</p>

    <p class="text-gray-300">To complete the proof, let  <span class="math">\\mathbf{w}^{<em>}\\gets</span>  Extract  <span class="math">(\\mathrm{td},C,(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m),\\pi)</span>  . We claim that  <span class="math">\\mathbf{w}^{</em>} = \\pmb{\\xi}</span>  . By Claim 4.14,  <span class="math">\\mathbf{u}_d =</span> <span class="math">\\xi_d\\mathbf{a}_{i^<em>} + \\mathbf{M}\\mathbf{t}_d</span>  . Then,  <span class="math">\\tau^{\\mathrm{T}}\\mathbf{u}_d = \\xi_d\\tau^{\\mathrm{T}}\\mathbf{a}_{i^</em>} + \\tau^{\\mathrm{T}}\\mathbf{M}\\mathbf{t}_d = \\xi_d\\tau^{\\mathrm{T}}\\mathbf{a}_{i^<em>}</span>  since  <span class="math">\\tau^{\\mathrm{T}}\\mathbf{M} = \\mathbf{0}</span>  . Moreover, since  <span class="math">\\mathbf{a}_{i^</em>}</span>  is uniform over  <span class="math">\\mathbb{Z}_p^{k + 1}</span>  and independent of  <span class="math">\\pmb{\\tau}</span>  , it follows that  <span class="math">\\tau^{\\mathrm{T}}\\mathbf{a}_{i^{<em>}}\\neq 0</span>  with probability  <span class="math">1 - 1 / p = 1 - \\mathrm{negl}(\\lambda)</span>  . Thus, if  <span class="math">\\xi_{n + d} = 0</span>  , then  <span class="math">w_{d}^{</em>} = 0 = \\xi_{n + d}</span>  and if  <span class="math">\\xi_{n + d} = 1</span>  , then  <span class="math">w_{d}^{<em>} = 1 = \\xi_{n + d}</span>  . Thus,  <span class="math">\\mathbf{w}^{</em>} = (\\xi_{n + 1},\\ldots ,\\xi_{n + h}) = \\pmb{\\xi}</span>  . Thus, with probability  <span class="math">1 - \\mathrm{negl}(\\lambda)</span>  , either Verify  <span class="math">(\\mathrm{crs}^<em>,C,(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m),\\pi) = 0</span>  or  <span class="math">C(\\mathbf{x},\\mathbf{w}^{</em>}) = 1</span>  . The claim follows.</p>

    <p class="text-gray-300">By Lemmas 4.8 and 4.12, Construction 4.5 is a somewhere argument of knowledge.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 4.15 (Succinctness).</h6>

    <p class="text-gray-300">For all constants <span class="math">k\\in\\mathbb{N}</span>, Construction 4.5 is succinct and satisfies split verification (Definition 2.9).</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any <span class="math">\\lambda,m,s\\in\\mathbb{N}</span> and consider a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>. Let <span class="math">t=\\operatorname{poly}(s)</span> be the number of wires in <span class="math">C</span>. We check each property:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: A proof <span class="math">\\pi</span> consists of <span class="math">t(k+1)+2hk(k+1)+2sk(k+1)</span> elements in each of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. Each group element can be represented in <span class="math">\\operatorname{poly}(\\lambda)</span> bits. Since <span class="math">k</span> is constant and <span class="math">h\\leq t=\\operatorname{poly}(s)</span>, the overall proof size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(\\lambda,s)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Verification key size: The size of the verification key vk outputs by GenVK consists of <span class="math">n(k+1)</span> elements in each of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. For constant <span class="math">k</span>, $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\operatorname{vk}</td>

            <td class="px-3 py-2 border-b border-gray-700">=n\\cdot\\operatorname{poly}(\\lambda)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification key generation time: The algorithm GenVK performs <span class="math">2mn(k+1)</span> group operations, which requires time <span class="math">\\operatorname{poly}(\\lambda,m,n)</span>.</li>

      <li>Online verification time: The running time of the online verification algorithm OnlineVerify is bounded by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\underbrace{nk\\cdot\\operatorname{poly}(\\lambda)}_{\\text{statement validity}}+\\underbrace{hk^{3}\\cdot\\operatorname{poly}(\\lambda)}_{\\text{wire validity}}+\\underbrace{sk^{3}\\cdot\\operatorname{poly}(\\lambda)}_{\\text{gate validity}}+\\underbrace{k\\cdot\\operatorname{poly}(\\lambda)}_{\\text{output validity}}=\\operatorname{poly}(\\lambda,s),</span></p>

    <p class="text-gray-300">since <span class="math">n\\leq s</span>, <span class="math">h\\leq t=\\operatorname{poly}(s)</span>, and <span class="math">k\\in\\mathbb{N}</span> is a constant. ∎</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Remark 4.16 (Verifying General Quadratic Relations).</h6>

    <p class="text-gray-300">The technique underlying the wire validity and gate consistency checks in 4.5 readily extends to gates that compute arbitrary quadratic predicates on their inputs. For instance, this includes standard Boolean gates such as AND, OR, and XOR gates as well as gates with more than two input wires. Consider a binary-valued gate predicate of the form</p>

    <p class="text-gray-300"><span class="math">w_{\\ell}=\\gamma+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}w_{i_{\\rho}}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}w_{j_{\\rho,1}}w_{j_{\\rho,2}}\\in\\{0,1\\},</span> (4.3)</p>

    <p class="text-gray-300">where <span class="math">\\ell\\in[t]</span> is the index of the output wire, <span class="math">i_{\\rho},j_{\\rho,1},j_{\\rho,2}\\in[t]</span> are indices of the input wires, and <span class="math">\\gamma,\\delta_{\\rho},\\hat{\\delta}_{\\rho}\\in\\mathbb{Z}</span> are fixed coefficients associated with the gate. To support gates of this type, we adapt 4.5 as follows. As in 4.5, let <span class="math">[\\mathbf{u}_{d}]_{1},[\\hat{\\mathbf{u}}_{d}]_{2}</span> be vector commitments to the values <span class="math">(w_{1,d},\\dots,w_{m,d})</span> of wire <span class="math">d</span> across the <span class="math">m</span> instances. To check the above relation is satisfied, the prover computes</p>

    <p class="text-gray-300"><span class="math">\\zeta_{i,j}=\\gamma+\\delta_{\\rho}w_{i,i_{\\rho}}+\\hat{\\delta}_{\\rho}w_{i,j_{\\rho,1}}w_{j,j_{\\rho,2}}-w_{i,\\ell}\\quad\\text{and}\\quad[\\mathbf{W}_{1}]_{1}=\\sum_{i\\neq j}\\zeta_{i,j}[\\mathbf{B}_{i,j}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{W}}_{1}]_{2}=\\sum_{i\\neq j}\\zeta_{i,j}[\\hat{\\mathbf{B}}_{i,j}]_{2},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\zeta_{i,j}^{<em>}=\\gamma+\\delta_{\\rho}w_{i,i_{\\rho}}+\\hat{\\delta}_{\\rho}w_{i,j_{\\rho,1}}w_{j,j_{\\rho,2}}-w_{j,\\ell}\\quad\\text{and}\\quad[\\mathbf{W}_{2}]_{1}=\\sum_{i\\neq j}\\zeta_{i,j}^{</em>}[\\mathbf{B}_{i,j}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{W}}_{2}]_{2}=\\sum_{i\\neq j}\\zeta_{i,j}^{*}[\\hat{\\mathbf{B}}_{i,j}]_{2}.</span></p>

    <p class="text-gray-300">To check that the gate is satisfied, the verifier checks</p>

    <p class="text-gray-300"><span class="math">\\gamma[\\mathbf{a}]_{1}\\cdot[\\hat{\\mathbf{a}}^{\\mathsf{T}}]_{2}+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}[\\mathbf{u}_{i_{\\rho}}]_{1}\\cdot[\\hat{\\mathbf{a}}^{\\mathsf{T}}]_{2}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}[\\mathbf{u}_{j_{\\rho,1}}]_{1}\\cdot[\\hat{\\mathbf{u}}_{j_{\\rho,2}}^{\\mathsf{T}}]-[\\mathbf{u}_{\\ell}]_{1}\\cdot[\\hat{\\mathbf{a}}^{\\mathsf{T}}]_{2}=[\\mathbf{M}]_{1}\\cdot[\\hat{\\mathbf{W}}_{1}^{\\mathsf{T}}]_{2}+[\\mathbf{W}_{1}]_{1}\\cdot[\\hat{\\mathbf{M}}^{\\mathsf{T}}]_{2},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\gamma[\\mathbf{a}]_{1}\\cdot[\\hat{\\mathbf{a}}^{\\mathsf{T}}]_{2}+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}[\\mathbf{u}_{i_{\\rho}}]_{1}\\cdot[\\hat{\\mathbf{a}}^{\\mathsf{T}}]_{2}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}[\\mathbf{u}_{j_{\\rho,1}}]_{1}\\cdot[\\hat{\\mathbf{u}}_{j_{\\rho,2}}^{\\mathsf{T}}]-[\\mathbf{a}]_{1}\\cdot[\\hat{\\mathbf{u}}_{\\ell}^{\\mathsf{T}}]_{2}=[\\mathbf{M}]_{1}\\cdot[\\hat{\\mathbf{W}}_{2}^{\\mathsf{T}}]_{2}+[\\mathbf{W}_{2}]_{1}\\cdot[\\hat{\\mathbf{M}}^{\\mathsf{T}}]_{2}.</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">ompleteness.</p>

    <p class="text-gray-300">To argue completeness, consider each term in the first verification relation:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=\\sum_{i,j\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}=\\sum_{i\\in[m]}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{i}+\\sum_{i\\neq j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}</span> <span class="math">\\mathbf{u}_{i_{\\rho}}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=\\sum_{i,j\\in[m]}w_{i,i_{\\rho}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}=\\sum_{i\\in[m]}w_{i,i_{\\rho}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{i}+\\sum_{i\\neq j}w_{i,i_{\\rho}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}</span> <span class="math">\\mathbf{u}_{j_{\\rho,1}}\\hat{\\mathbf{u}}^{\\mathsf{T}}_{j_{\\rho,2}}</span> <span class="math">=\\sum_{i,j\\in[m]}w_{i,j_{\\rho,1}}w_{j,j_{\\rho,2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}=\\sum_{i\\in[m]}w_{i,j_{\\rho,1}}w_{i,j_{\\rho,2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{i}+\\sum_{i\\neq j}w_{i,j_{\\rho,1}}w_{j,j_{\\rho,2}}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}</span> <span class="math">\\mathbf{u}_{\\ell}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=\\sum_{i,j\\in[m]}w_{i,\\ell}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}=\\sum_{i\\in[m]}w_{i,\\ell}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{i}+\\sum_{i\\neq j}w_{i,\\ell}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}</span></p>

    <p class="text-gray-300">Then, the first verification relation becomes</p>

    <p class="text-gray-300"><span class="math">\\gamma\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}\\mathbf{u}_{i_{\\rho}}\\hat{\\mathbf{a}}^{\\mathsf{T}}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}\\mathbf{u}_{j_{\\rho,1}}\\hat{\\mathbf{u}}_{j_{\\rho,2}}-\\mathbf{u}_{\\ell}\\hat{\\mathbf{a}}^{\\mathsf{T}}=\\sum_{i\\in[m]}Z_{i}\\mathbf{a}_{i}\\mathbf{a}^{\\mathsf{T}}_{i}+\\sum_{i\\neq j}Z_{i,j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j},</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">Z_{i}</span> <span class="math">=\\gamma+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}w_{i,i_{\\rho}}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}w_{i,j_{\\rho,1}}w_{i,j_{\\rho,2}}-w_{i,\\ell}</span> <span class="math">Z_{i,j}</span> <span class="math">=\\gamma+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}w_{i,i_{\\rho}}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}w_{i,j_{\\rho,1}}w_{j,j_{\\rho,2}}-w_{i,\\ell}=\\zeta_{i,j}.</span></p>

    <p class="text-gray-300">If Eq. (4.3) holds for all <span class="math">m</span> instances, then <span class="math">Z_{i}=0</span> for all <span class="math">i\\in[\\ell]</span> and we are only left with <span class="math">\\sum_{i\\neq j}Z_{i,j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}</span>. By construction, the right-hand side of the first verification relation is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}\\hat{\\mathbf{W}}^{\\mathsf{T}}_{1}+\\mathbf{W}_{1}\\hat{\\mathbf{M}}^{\\mathsf{T}}=\\sum_{i\\neq j}\\zeta_{i,j}(\\mathbf{M}\\hat{\\mathbf{B}}^{\\mathsf{T}}_{i,j}+\\mathbf{B}_{i,j}\\hat{\\mathbf{M}}^{\\mathsf{T}})=\\sum_{i\\neq j}\\zeta_{i,j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}^{\\mathsf{T}}_{j}=\\sum_{i\\neq j}Z_{i,j}\\mathbf{a}_{i}\\hat{\\mathbf{a}}_{j},</span></p>

    <p class="text-gray-300">using the relation from Eq. (4.1). Thus, the first verification relation holds. A similar calculation applies to the second verification relation and completeness follows.</p>

    <h5 id="sec-72" class="text-base font-semibold mt-4">Somewhere argument of knowledge.</h5>

    <p class="text-gray-300">The somewhere argument of knowledge property follows analogously as the proof of Theorem 4.7. Since we did not need to modify the CRS to support general gates, CRS indistinguishability holds. It suffices to show that the scheme is somewhere extractable in trapdoor mode. The proof of Lemma 4.12 uses an inductive strategy where we show that as long as the commitments to the input wires of a gate is well-formed, then the commitment to the output wire respects the gate constraint. Specifically, for each input wire <span class="math">d</span> to the gate, suppose that <span class="math">\\mathbf{u}_{d}=\\xi_{d}\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}_{d}</span> and <span class="math">\\hat{\\mathbf{u}}_{d}=\\xi_{d}\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\mathbf{t}}_{d}</span> for some <span class="math">\\xi_{d}\\in\\{0,1\\}</span> and <span class="math">\\mathbf{t}_{d},\\hat{\\mathbf{t}}_{d}\\in\\mathbb{Z}_{p}^{k}</span>. By Claim 4.13 (iii), (iv), the commitments <span class="math">\\mathbf{u}_{\\ell}</span> and <span class="math">\\hat{\\mathbf{u}}_{\\ell}</span> to the output wires can be written as <span class="math">\\mathbf{u}_{\\ell}=\\xi_{\\ell}\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}_{\\ell}</span> and <span class="math">\\hat{\\mathbf{u}}_{\\ell}=\\hat{\\xi}_{\\ell}\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\mathbf{t}}_{\\ell}</span> for some <span class="math">\\xi_{\\ell},\\hat{\\xi}_{\\ell}\\in\\mathbb{Z}_{p}</span> and <span class="math">\\mathbf{t}_{\\ell},\\hat{\\mathbf{t}}_{\\ell}\\in\\mathbb{Z}_{p}^{k}</span>. Our goal is to show that <span class="math">\\xi_{\\ell}=\\hat{\\xi}_{\\ell}</span> and moreover, <span class="math">\\xi_{\\ell}=\\gamma+\\sum_{\\rho\\in[T_{1}]}\\delta_{\\rho}\\xi_{i_{\\rho}}+\\sum_{\\rho\\in[T_{2}]}\\hat{\\delta}_{\\rho}\\xi_{j_{\\rho,1}}\\xi_{j_{\\rho,2}}\\in\\{0,1\\}</span>. Following the identical strategy as in the proof of Lemma 4.12, we consider the terms in the verification relations:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{a}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=(\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\boldsymbol{\\beta})(\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\boldsymbol{\\beta}})^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{i_{\\rho}}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=(\\xi_{i_{\\rho}}\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}_{i_{\\rho}})(\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\boldsymbol{\\beta}})^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{j_{\\rho,1}}\\hat{\\mathbf{u}}^{\\mathsf{T}}_{j_{\\rho,2}}</span> <span class="math">=(\\xi_{j_{\\rho,1}}\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}_{j_{\\rho,1}})(\\xi_{j_{\\rho,2}}\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\mathbf{t}}_{j_{\\rho,2}})^{\\mathsf{T}}</span> <span class="math">\\mathbf{u}_{\\ell}\\hat{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=(\\xi_{\\ell}\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}_{\\ell})(\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\boldsymbol{\\beta}})^{\\mathsf{T}}</span> <span class="math">\\mathbf{a}\\hat{\\mathbf{u}}^{\\mathsf{T}}_{\\ell}</span> <span class="math">=(\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\boldsymbol{\\beta})(\\hat{\\xi}_{\\ell}\\hat{\\mathbf{a}}_{i^{</em>}}+\\hat{\\mathbf{M}}\\hat{\\mathbf{t}}_{\\ell})^{\\mathsf{T}}.</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We apply the projection operator to the two verification relations and by Claim 4.13 (iii), (iv),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\underbrace {\\operatorname {p r o j} (\\gamma \\mathbf {a} \\hat {\\mathbf {a}} ^ {\\top})} _ {\\gamma \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} + \\underbrace {\\sum_ {\\rho \\in [ T _ {1} ]} \\operatorname {p r o j} (\\delta_ {\\rho} \\mathbf {u} _ {i _ {\\rho}} \\hat {\\mathbf {a}} ^ {\\top})} _ {\\sum_ {\\rho = [ T _ {1} ]} \\delta_ {\\rho} \\xi_ {i _ {\\rho}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} + \\underbrace {\\sum_ {\\rho \\in [ T _ {2} ]} \\operatorname {p r o j} (\\hat {\\delta} _ {\\rho} \\mathbf {u} _ {j _ {\\rho , 1}} \\hat {\\mathbf {u}} _ {j _ {\\rho , 2}} ^ {\\top})} _ {\\sum_ {\\rho = [ T _ {2} ]} \\hat {\\delta} _ {\\rho} \\xi_ {j _ {\\rho , 1}} \\xi_ {j _ {\\rho , 2}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} - \\underbrace {\\operatorname {p r o j} (\\mathbf {u} _ {\\ell} \\hat {\\mathbf {a}} ^ {\\top})} _ {\\xi_ {\\ell} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {W}} _ {1} ^ {\\top})} _ {0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {W} _ {1} \\hat {\\mathbf {M}} ^ {\\top})} _ {0} \\\\ \\underbrace {\\operatorname {p r o j} (\\gamma \\mathbf {a} \\hat {\\mathbf {a}} ^ {\\top})} _ {\\gamma \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} + \\underbrace {\\sum_ {\\rho \\in [ T _ {1} ]} \\operatorname {p r o j} (\\delta_ {\\rho} \\mathbf {u} _ {i _ {\\rho}} \\hat {\\mathbf {a}} ^ {\\top})} _ {\\sum_ {\\rho = [ T _ {1} ]} \\delta_ {\\rho} \\xi_ {i _ {\\rho}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} + \\underbrace {\\sum_ {\\rho \\in [ T _ {2} ]} \\operatorname {p r o j} (\\hat {\\delta} _ {\\rho} \\mathbf {u} _ {j _ {\\rho , 1}} \\hat {\\mathbf {u}} _ {j _ {\\rho , 2}} ^ {\\top})} _ {\\sum_ {\\rho = [ T _ {2} ]} \\hat {\\delta} _ {\\rho} \\xi_ {j _ {\\rho , 1}} \\xi_ {j _ {\\rho , 2}} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} - \\underbrace {\\operatorname {p r o j} (\\mathbf {a} \\hat {\\mathbf {u}} _ {\\ell} ^ {\\top})} _ {\\hat {\\xi} _ {\\ell} \\mathbf {a} _ {i ^ {*}} \\hat {\\mathbf {a}} _ {i ^ {*}} ^ {\\top}} = \\underbrace {\\operatorname {p r o j} (\\mathbf {M} \\hat {\\mathbf {W}} _ {2} ^ {\\top})} _ {0} + \\underbrace {\\operatorname {p r o j} (\\mathbf {W} _ {2} \\hat {\\mathbf {M}} ^ {\\top})} _ {0}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In combination, this means that</p>

    <div class="my-4 text-center"><span class="math-block">\\xi_ {\\ell} = \\gamma + \\sum_ {\\rho \\in [ T _ {1} ]} \\delta_ {\\rho} \\xi_ {i _ {\\rho}} + \\sum_ {\\rho \\in [ T _ {2} ]} \\hat {\\delta} _ {\\rho} \\xi_ {j _ {\\rho , 1}} \\xi_ {j _ {\\rho , 2}} = \\xi_ {\\ell}.</span></div>

    <p class="text-gray-300">Since Eq. (4.3) is a binary-valued predicate and the input assignments  <span class="math">\\xi_{i_{\\rho}}, \\xi_{j_{\\rho,1}}, \\xi_{j_{\\rho,2}} \\in \\{0,1\\}</span>  by the inductive hypothesis, this means that  <span class="math">\\xi_{\\ell} \\in \\{0,1\\}</span> . By the same argument as in the proof of Lemma 4.12, we conclude that the extracted wire assignment  <span class="math">(\\xi_1, \\ldots, \\xi_t)</span>  satisfies the gate constraint Eq. (4.3).</p>

    <p class="text-gray-300">In this section, we describe how to recursively compose succinct batch arguments for NP with a long CRS to obtain a BARG with a short CRS (i.e., with size that is sublinear in the number of instances). The bootstrapping construction applies to any BARG with a split verification procedure (Definition 2.9). We refer to Section 1.2.2 for an overview of the construction.</p>

    <p class="text-gray-300"><strong>Construction 5.1 (BARG Bootstrapping).</strong> Let  <span class="math">B \\in \\mathbb{N}</span>  be a batch size parameter. Let  <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)} = (\\mathrm{BARG}_0.\\mathrm{Setup}, \\mathrm{BARG}_0.\\mathrm{Prove}, \\mathrm{BARG}_0.\\mathrm{GenVK}, \\mathrm{BARG}_0.\\mathrm{OnlineVerify})</span>  be a batch argument with split verification. We construct a new BARG with split verification as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda}, 1^{m}, 1^{s})</span> : On input the security parameter  <span class="math">\\lambda</span> , the number of instances  <span class="math">m</span> , and a bound on the circuit size  <span class="math">s</span> , the setup algorithm proceeds as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\mathrm{crs}_{\\mathrm{base}} \\gets \\mathrm{BARG}_0.\\mathrm{Setup}(1^\\lambda, 1^B, 1^s)</span> .</li>

      <li>Let  <span class="math">\\ell_{\\pi} = \\ell_{\\pi}(\\lambda, B, s)</span>  and  <span class="math">\\ell_{\\mathrm{vk}} = \\ell_{\\mathrm{vk}}(\\lambda, B, s)</span>  be the length of the proofs  <span class="math">\\pi</span>  and verification keys vk output by  <span class="math">\\mathrm{BARG}_0</span> . Prove  <span class="math">(\\mathrm{crs}_{\\mathrm{base}}, \\cdot, \\cdot, \\cdot)</span>  and  <span class="math">\\mathrm{BARG}_0</span> . GenVK  <span class="math">(\\mathrm{crs}_{\\mathrm{base}}, \\cdot)</span> , respectively.</li>

      <li>Define the Boolean circuit  <span class="math">C_{\\mathrm{top}} \\colon \\{0,1\\}^{\\ell_{\\mathrm{vk}}} \\times \\{0,1\\}^{\\ell_{\\pi}} \\to \\{0,1\\}</span>  as  <span class="math">C_{\\mathrm{top}}(\\mathrm{vk},\\pi) \\coloneqq \\mathrm{BARG}_0</span> . OnlineVerify(vk,  <span class="math">C,\\pi</span> ). Let  <span class="math">s_{\\mathrm{top}}</span>  be a bound on the size of the circuit  <span class="math">C_{\\mathrm{top}}</span> .</li>

      <li>Sample  <span class="math">\\mathrm{crs}_{\\mathrm{top}} \\gets \\mathrm{BARG}_0.\\mathrm{Setup}(1^\\lambda, 1^{m/B}, 1^{s_{\\mathrm{top}}})</span>  and output  <span class="math">\\mathrm{crs} = (\\mathrm{crs}_{\\mathrm{base}}, \\mathrm{crs}_{\\mathrm{top}})</span> .</li>

    </ul>

    <p class="text-gray-300">We will require that  <span class="math">B \\leq m</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove  <span class="math">(\\mathrm{crs}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), (\\mathbf{w}_1, \\ldots, \\mathbf{w}_m))</span> : On input  <span class="math">\\mathrm{crs} = (\\mathrm{crs}_{\\mathrm{base}}, \\mathrm{crs}_{\\mathrm{top}})</span> , the Boolean circuit  <span class="math">C \\colon \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span> , statements  <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span> , and witnesses  <span class="math">\\mathbf{w}_1, \\ldots, \\mathbf{w}_m \\in \\{0, 1\\}^h</span> , the prove algorithm proceeds as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [m / B]</span> , compute  <span class="math">\\pi_i \\gets \\mathrm{BARG}_0</span> . Prove  <span class="math">(\\mathrm{crs}_{\\mathrm{base}}, C, (\\mathbf{x}_{(i - 1)B + 1}, \\ldots, x_{iB}), (\\mathbf{w}_{(i - 1)B + 1}, \\ldots, \\mathbf{w}_{iB}))</span> .</li>

      <li>Output the proof  <span class="math">\\pi \\gets \\mathrm{BARG}_0</span> . Prove  <span class="math">(\\mathrm{crs}_{\\mathrm{top}}, C_{\\mathrm{top}}, (\\mathrm{vk}_1, \\ldots, \\mathrm{vk}_{m/B}), (\\pi_1, \\ldots, \\pi_{m/B}))</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenVK(crs,  <span class="math">(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m))</span>  : On input the common reference string crs  <span class="math">= (\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span>  and statements  <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_m\\in</span> <span class="math">\\{0,1\\} ^n</span>  , the verification key generation algorithm proceeds as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [m / B]</span> , compute  <span class="math">\\mathrm{vk}_i \\gets \\mathrm{BARG}_0</span> . GenVK(crsbase,  <span class="math">(\\mathbf{x}_{(i - 1)B + 1},\\dots ,\\mathbf{x}_{iB})</span> ).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute and output vk <span class="math">\\leftarrow</span> BARG_{0}.GenVK(crs<span class="math">{}_{\\text{top}}</span>, (vk<span class="math">{}_{1}</span>, <span class="math">\\dots</span>, vk_{m/B}$)).</li>

      <li>OnlineVerify(vk, <span class="math">C</span>, <span class="math">\\pi</span>): On input a verification key vk and a proof <span class="math">\\pi</span>, output BARG_{0}.OnlineVerify(vk, <span class="math">C_{\\text{top}}</span>, <span class="math">\\pi</span>).</li>

    </ul>

    <h6 id="sec-74" class="text-base font-medium mt-4">Theorem 5.2 (Completeness).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\text{BARG}}^{(0)}</span> is complete, then Construction 5.1 is also complete.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows by construction. ∎</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Theorem 5.3 (Somewhere Argument of Knowledge).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\text{BARG}}^{(0)}</span> is a somewhere argument of knowledge, then Construction 5.1 is also a somewhere argument of knowledge.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We start by defining the trapdoor setup and extraction algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TrapSetup(<span class="math">1^{\\lambda}</span>, <span class="math">1^{m}</span>, <span class="math">1^{s}</span>, <span class="math">i^{<em>}</span>): Write <span class="math">i^{</em>}=(i^{<em>}_{\\text{top}}-1)B+i^{</em>}_{\\text{base}}</span> where <span class="math">i^{<em>}_{\\text{top}}\\in[m/B]</span> and <span class="math">i^{</em>}_{\\text{base}}\\in[B]</span>. The trapdoor setup algorithm samples the CRS components using the corresponding trapdoor setup algorithms:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">(\\text{crs}^{<em>}_{\\text{base}}</span>, <span class="math">\\text{td}_{\\text{base}})</span> <span class="math">\\leftarrow</span> BARG_{0}.TrapSetup(<span class="math">1^{\\lambda}</span>, <span class="math">1^{B}</span>, <span class="math">1^{s}</span>, <span class="math">i^{</em>}_{\\text{base}}</span>).</li>

      <li>Sample <span class="math">(\\text{crs}^{<em>}_{\\text{top}}</span>, <span class="math">\\text{td}_{\\text{top}})</span> <span class="math">\\leftarrow</span> BARG_{0}.TrapSetup(<span class="math">1^{\\lambda}</span>, <span class="math">1^{m/B}</span>, <span class="math">1^{s_{\\text{top}}}</span>, <span class="math">i^{</em>}_{\\text{top}}</span>).</li>

      <li>Output <span class="math">\\text{crs}^{<em>}=(\\text{crs}^{</em>}_{\\text{base}}</span>, <span class="math">\\text{crs}^{<em>}_{\\text{top}})</span> and the trapdoor <span class="math">\\text{td}=(\\text{crs}_{\\text{top}}</span>, <span class="math">i^{</em>}_{\\text{top}}</span>, <span class="math">\\text{td}_{\\text{base}}</span>, <span class="math">\\text{td}_{\\text{top}})</span>.</li>

      <li>Extract(<span class="math">\\text{td},C</span>, <span class="math">(\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m})</span>, <span class="math">\\pi</span>): On input the trapdoor <span class="math">\\text{td}=(\\text{crs}_{\\text{top}}</span>, <span class="math">i^{*}_{\\text{top}}</span>, <span class="math">\\text{td}_{\\text{base}}</span>, <span class="math">\\text{td}_{\\text{top}})</span>, the circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\rightarrow\\{0,1\\}</span>, statements <span class="math">\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span> and a proof <span class="math">\\pi</span>, proceed as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[m/B]</span>, compute <span class="math">\\text{vk}^{<em>}_{i}\\leftarrow\\text{BARG}_{0}.\\text{GenVK}(\\text{crs}^{</em>}_{\\text{top}}</span>, <span class="math">(\\mathbf{x}_{(i-1)B+1},\\dots,\\mathbf{x}_{iB})</span>).</li>

      <li>Compute <span class="math">\\pi_{\\text{base}}\\leftarrow\\text{BARG}_{0}.\\text{Extract}(\\text{td}_{\\text{top}},C_{\\text{top}},(\\text{vk}^{<em>}_{1},\\dots,\\text{vk}^{</em>}_{m/B})</span>, <span class="math">\\pi</span>),</li>

      <li>Output <span class="math">\\text{BARG}_{0}.\\text{Extract}\\big{(}\\text{td}_{\\text{base}},C,(\\mathbf{x}_{(i^{<em>}_{\\text{top}}-1)B+1},\\dots,\\mathbf{x}_{i^{</em>}_{\\text{top}}B})</span>, <span class="math">\\pi_{\\text{base}}\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">We now show the CRS indistinguishability and somewhere extractable in trapdoor mode properties.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 5.4 (CRS Indistinguishability).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\text{BARG}}^{(0)}</span> is a somewhere argument of knowledge (specifically, it satisfies CRS indistinguishability), then Construction 5.1 satisfies CRS indistinguishability.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This is immediate by a standard hybrid argument. Namely, the CRS in Construction 5.1 consists of two independent common reference strings for <span class="math">\\Pi_{\\text{BARG}}^{(0)}</span>. ∎</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 5.5 (Somewhere Extractable in Trapdoor Mode).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\text{BARG}}^{(0)}</span> is a somewhere argument of knowledge (specifically, if it is somewhere extractable in trapdoor mode), then Construction 5.1 is somewhere extractable in trapdoor mode.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any polynomial <span class="math">m=m(\\lambda)</span> and <span class="math">s=s(\\lambda)</span>. Let <span class="math">i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{m},1^{s})</span> and write <span class="math">i^{</em>}=(i^{<em>}_{\\text{top}}-1)B+i^{</em>}_{\\text{base}}</span> where <span class="math">i^{<em>}_{\\text{top}}\\in[m/B]</span> and <span class="math">i^{</em>}_{\\text{base}}\\in[B]</span>. Let <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\rightarrow\\{0,1\\}</span> be the Boolean circuit, <span class="math">\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span> be the set of statements, and <span class="math">\\pi</span> be the proof output by the adversary. Let <span class="math">(\\text{crs}^{<em>},\\text{td})\\leftarrow\\text{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{</em>})</span> and <span class="math">\\text{vk}^{<em>}\\leftarrow\\text{GenVK}(\\text{crs}^{</em>},(\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m}))</span>. Then <span class="math">\\text{crs}^{<em>}=(\\text{crs}^{</em>}_{\\text{base}},\\text{crs}^{*}_{\\text{top}})</span> and <span class="math">\\text{td}=(\\text{td}_{\\text{base}},\\text{td}_{\\text{top}})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\text{crs}^{<em>}_{\\text{base}}</span>, <span class="math">\\text{td}_{\\text{base}})\\leftarrow\\text{BARG}_{0}.\\text{TrapSetup}(1^{\\lambda},1^{B},1^{s},i^{</em>}_{\\text{base}})</span>;</li>

      <li><span class="math">(\\text{crs}^{<em>}_{\\text{top}}</span>, <span class="math">\\text{td}_{\\text{top}})\\leftarrow\\text{BARG}_{0}.\\text{TrapSetup}(1^{\\lambda},1^{m/B},1^{s_{\\text{top}}},i^{</em>}_{\\text{top}})</span>;</li>

      <li><span class="math">\\text{vk}^{<em>}_{i}\\leftarrow\\text{BARG}_{0}.\\text{GenVK}\\big{(}\\text{crs}^{</em>}_{\\text{base}},(\\mathbf{x}_{(i-1)B+1},\\dots,\\mathbf{x}_{iB})\\big{)}</span> for each <span class="math">i\\in[m/B]</span>; and</li>

      <li><span class="math">\\text{vk}^{<em>}\\leftarrow\\text{BARG}_{0}.\\text{GenVK}\\big{(}\\text{crs}^{</em>}_{\\text{top}},(\\text{vk}^{<em>}_{1},\\dots,\\text{vk}^{</em>}_{m/B})\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">Suppose OnlineVerify(<span class="math">\\text{vk}^{<em>},C,\\pi</span>) = 1. Let <span class="math">\\pi_{\\text{base}}\\leftarrow\\text{BARG}_{0}.\\text{Extract}(\\text{td}_{\\text{top}},C_{\\text{top}},(\\text{vk}^{</em>}_{1},\\dots,\\text{vk}^{<em>}_{m/B})</span>, <span class="math">\\pi</span>) be the extracted proof and let <span class="math">\\mathbf{w}^{</em>}\\leftarrow\\text{BARG}_{0}.\\text{Extract}\\big{(}\\text{td}_{\\text{base}},C,(\\mathbf{x}_{(i^{<em>}_{\\text{top}}-1)B+1},\\dots,\\mathbf{x}_{i^{</em>}_{\\text{top}}B})</span>, <span class="math">\\pi_{\\text{base}}\\big{)}</span> be the extracted witness. We proceed via a sequence of claims:</p>

    <p class="text-gray-300">Claim 5.6.</p>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span> is a somewhere extractable argument of knowledge, then there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathrm{BARG}_{0}.\\mathrm{OnlineVerify}\\Big{(}\\mathrm{vk}_{\\mathrm{i}^{\\prime}_{\\mathrm{top}}}^{*},C,\\pi_{\\mathrm{base}}\\Big{)}=1\\right]=1-\\mathrm{negl}(\\lambda).</span></p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First <span class="math">(\\mathrm{crs}_{\\mathrm{top}}^{<em>},\\mathrm{td}_{\\mathrm{top}})</span> is sampled using <span class="math">\\mathrm{BARG}_{0}.\\mathrm{TrapSetup}</span> with index <span class="math">i_{\\mathrm{top}}^{</em>}</span>. If <span class="math">\\mathrm{BARG}_{0}.\\mathrm{OnlineVerify}(\\mathrm{vk}^{<em>},C_{\\mathrm{top}},\\pi)=1</span> with <span class="math">\\mathrm{vk}^{</em>}\\leftarrow\\mathrm{BARG}_{0}.\\mathrm{GenVK}(\\mathrm{crs}_{\\mathrm{top}}^{<em>},(\\mathrm{vk}_{1}^{</em>},\\ldots,\\mathrm{vk}_{m/B}^{<em>}))</span>, then <span class="math">C_{\\mathrm{top}}\\big{(}\\mathrm{vk}_{\\mathrm{i}^{\\prime}_{\\mathrm{top}}}^{</em>},\\pi_{\\mathrm{base}}\\big{)}=1</span> with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>. Otherwise, we have an adversary that breaks somewhere extractability of <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span>. By definition of <span class="math">C_{\\mathrm{top}}</span>, this means <span class="math">\\mathrm{BARG}_{0}.\\mathrm{OnlineVerify}\\big{(}\\mathrm{vk}_{\\mathrm{i}^{\\prime}_{\\mathrm{top}}}^{*},C,\\pi_{\\mathrm{base}}\\big{)}=1</span>. ∎</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Claim 5.7.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span> is a somewhere extractable argument of knowledge, then there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\Pr[C(\\mathbf{x}_{i^{<em>}},\\mathbf{w}^{</em>})=1]=1-\\mathrm{negl}(\\lambda)</span>.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows from the fact that <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{td}_{\\mathrm{base}})</span> is sampled using <span class="math">\\mathrm{BARG}_{0}.\\mathrm{TrapSetup}</span> with index <span class="math">i_{\\mathrm{base}}^{<em>}</span>. By Claim 5.6, with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>, <span class="math">\\mathrm{BARG}_{0}.\\mathrm{OnlineVerify}\\big{(}\\mathrm{vk}_{\\mathrm{i}^{\\prime}_{\\mathrm{top}}}^{</em>},C,\\pi_{\\mathrm{base}}\\big{)}=1</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mathrm{vk}_{\\mathrm{i}^{\\prime}_{\\mathrm{top}}}^{<em>}\\leftarrow\\mathrm{BARG}_{0}.\\mathrm{GenVK}(\\mathrm{crs}_{\\mathrm{base}}^{</em>},(\\mathbf{x}_{(i_{\\mathrm{top}}^{<em>}-1)B+1},\\ldots,\\mathbf{x}_{i_{\\mathrm{top}}^{</em>}B}^{*})).</span></p>

    <p class="text-gray-300">Somewhere extractability of <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span> then implies that with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>,</p>

    <p class="text-gray-300"><span class="math">C(\\mathbf{x}_{(i_{\\mathrm{top}}^{<em>}-1)B+i_{\\mathrm{base}}^{</em>}},\\mathbf{w}^{<em>})=C(\\mathbf{x}_{i^{</em>}},\\mathbf{w}^{*})=1.</span> ∎</p>

    <p class="text-gray-300">Combining Claims 5.6 and 5.7, we conclude that with probability <span class="math">1-\\mathrm{negl}(\\lambda)</span>, the extracted witness <span class="math">\\mathbf{w}^{<em>}</span> satisfies <span class="math">C(\\mathbf{x}_{i^{</em>}},\\mathbf{w}^{*})=1</span> and the claim follows. ∎</p>

    <p class="text-gray-300">The somewhere argument of knowledge property now follows from Lemmas 5.4 and 5.5. ∎</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Theorem 5.8 (Succinctness).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span> is a succinct BARG with split verification and CRS size <span class="math">\\ell_{0}(\\lambda,m,s)=m^{d}\\cdot\\mathrm{poly}(\\lambda,s)</span>, for some constant <span class="math">d\\in\\mathbb{N}</span>. Then Construction 5.1 is a succinct BARG with split verification and CRS size</p>

    <p class="text-gray-300"><span class="math">\\ell(\\lambda,m,s,B)=B^{d}\\cdot\\mathrm{poly}(\\lambda,s)+(m/B)^{d}\\cdot\\mathrm{poly}(\\lambda,\\log m,s).</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">\\ell_{0}(\\lambda,m,s)=m^{d}\\cdot\\mathrm{poly}(\\lambda)</span>, then <span class="math">\\ell(\\lambda,m,s,B)=(B^{d}+(m/B)^{d})\\cdot\\mathrm{poly}(\\lambda)</span>.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We verify each of the required properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS size: The CRS in 5.1 consists of two common reference strings <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span> for <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span>. The size of <span class="math">\\mathrm{crs}_{\\mathrm{base}}</span> is <span class="math">\\ell_{0}(\\lambda,B,s)</span> and the size of <span class="math">\\mathrm{crs}_{\\mathrm{top}}</span> is <span class="math">\\ell_{0}(\\lambda,m/B,s^{\\prime})</span> where <span class="math">s^{\\prime}</span> is a bound on the size of the circuit <span class="math">C_{\\mathrm{top}}</span> computing <span class="math">\\mathrm{BARG}_{0}.\\mathrm{OnlineVerify}(\\mathrm{vk},\\cdot)</span> where <span class="math">\\mathrm{vk}\\leftarrow\\mathrm{BARG}_{0}.\\mathrm{GenVK}(\\mathrm{crs}_{\\mathrm{base}},\\cdot)</span>. By succinctness of <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span>, the size <span class="math">s_{\\mathrm{top}}</span> of <span class="math">C_{\\mathrm{top}}</span> is bounded by some polynomial <span class="math">\\mathrm{poly}(\\lambda,\\log m,s)</span>. Thus,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\ell(\\lambda,m,s,B)=B^{d}\\cdot\\mathrm{poly}(\\lambda,s)+(m/B)^{d}\\cdot\\mathrm{poly}(\\lambda,\\log m,s),</span></p>

    <p class="text-gray-300">as required. When <span class="math">\\ell_{0}</span> is independent of <span class="math">s</span>, the same is true for <span class="math">\\ell</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: The proof <span class="math">\\pi</span> in 5.1 consists of a proof for <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span> instantiated with <span class="math">m/B</span> instances and circuits of size at most <span class="math">s_{\\mathrm{top}}=\\mathrm{poly}(\\lambda,\\log m,s)</span>. Thus, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{poly}(\\lambda,\\log(m/B),s_{\\mathrm{top}})=\\mathrm{poly}(\\lambda,\\log m,s)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification key generation time: The verification key generation algorithm GenVK consists of two main components:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, it runs <span class="math">m/B</span> copies of <span class="math">\\mathrm{BARG}_{0}.\\mathrm{GenVK}</span> with <span class="math">B</span> instances (of length <span class="math">n</span>) and circuits of size at most <span class="math">s</span>. By succinctness of <span class="math">\\Pi_{\\mathrm{BARG}}^{(0)}</span>, each copy runs in time <span class="math">\\mathrm{poly}(\\lambda,B,n)</span>, so generating <span class="math">\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{m/B}</span> requires time <span class="math">m/B\\cdot\\mathrm{poly}(\\lambda,B,n)=\\mathrm{poly}(\\lambda,m,n)</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, it runs <span class="math">\\text{BARG}_{0}</span>.GenVK with <span class="math">m/B</span> instances (of length <span class="math">\\ell_{\\text{vk}}</span> where <span class="math">\\ell_{\\text{vk}}</span> is a bound on the length of the verification keys <span class="math">\\text{vk}_{i}</span>) and circuits of size at most <span class="math">s_{\\text{top}}</span>. Again by succinctness of <span class="math">\\Pi^{(0)}_{\\text{BARG}}</span>, <span class="math">\\ell_{\\text{vk}}\\leq\\text{poly}(\\lambda,\\log m,n)</span>. Thus, this step requires time <span class="math">\\text{poly}(\\lambda,m/B,\\ell_{\\text{vk}})=\\text{poly}(\\lambda,m,n)</span>.</li>

    </ul>

    <p class="text-gray-300">Since both steps complete in time <span class="math">\\text{poly}(\\lambda,m,n)</span>, the claim holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Verification key size: The verification key vk in 5.1 consists of a single verification key for <span class="math">\\Pi^{(0)}_{\\text{BARG}}</span> with <span class="math">m/B</span> instances and circuits of size at most <span class="math">s_{\\text{top}}</span>. By succinctness of <span class="math">\\Pi^{(0)}_{\\text{BARG}}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\text{poly}(\\lambda,\\log(m/B),s_{\\text{top}})=\\text{poly}(\\lambda,\\log m,s)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Online verification time: The verification algorithm in 5.1 simply runs <span class="math">\\text{BARG}_{0}</span>.OnlineVerify with <span class="math">m/B</span> instances and a circuit of size <span class="math">s_{\\text{top}}</span>. By succinctness of <span class="math">\\Pi^{(0)}_{\\text{BARG}}</span>, the running time is at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{poly}(\\lambda,\\log(m/B),s_{\\text{top}})=\\text{poly}(\\lambda,\\log m,s).\\qed</span></p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Corollary 5.9 (BARG for NP with Short CRS).</h6>

    <p class="text-gray-300">Suppose there exists a batch argument for NP with split verification and a CRS of size <span class="math">\\text{poly}(\\lambda,m,s)</span>, where <span class="math">m</span> is the number of instances and <span class="math">s</span> is the circuit size. Then, for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a batch argument for NP with split verification and a CRS of size <span class="math">m^{\\varepsilon}\\cdot\\text{poly}(\\lambda,s)</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi^{(0)}_{\\text{BARG}}</span> be the BARG with CRS size at most <span class="math">m^{d}\\cdot\\text{poly}(\\lambda,s)</span> for some constant <span class="math">d\\in\\mathbb{N}</span>. Let <span class="math">k=\\lceil\\log(2d/\\varepsilon)\\rceil\\in\\mathbb{N}</span>. For <span class="math">i\\in[k]</span>, let <span class="math">\\Pi^{(i)}_{\\text{BARG}}</span> be the BARG formed by applying 5.1 to <span class="math">\\Pi^{(i-1)}_{\\text{BARG}}</span> with <span class="math">B=\\sqrt{m}</span>. Let <span class="math">\\ell_{i}</span> denote the length of the CRS in <span class="math">\\Pi^{(i)}_{\\text{BARG}}</span>. Since <span class="math">\\ell_{0}(\\lambda,m,s)=m^{d}\\cdot\\text{poly}(\\lambda,s)</span>, we can inductively apply 5.8 to show that</p>

    <p class="text-gray-300"><span class="math">\\ell_{i}(\\lambda,m,s)=m^{d/2^{i}}\\cdot\\text{poly}(\\lambda,\\log m,s).</span></p>

    <p class="text-gray-300">Substituting <span class="math">k=\\lceil\\log(2d/\\varepsilon)\\rceil</span> into the above, we have that</p>

    <p class="text-gray-300"><span class="math">\\ell_{k}(\\lambda,m,s)\\leq m^{\\varepsilon/2}\\cdot\\text{poly}(\\lambda,\\log m,s)&lt;m^{\\varepsilon}\\cdot\\text{poly}(\\lambda,s),</span></p>

    <p class="text-gray-300">since <span class="math">2d/\\varepsilon</span> is a constant. The other succinctness requirements are preserved since we compose a constant number of times. ∎</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Corollary 5.10 (BARG for NP with Short CRS from Pairings).</h6>

    <p class="text-gray-300">For any constant <span class="math">k\\geq 1</span>, if the <span class="math">k</span>-<span class="math">\\operatorname{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to a prime-order group generator <span class="math">\\operatorname{GroupGen}</span> (or, alternatively, if the subgroup decision assumption holds with respect to a composite-order group generator <span class="math">\\operatorname{CompGroupGen}</span>), then for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a BARG for NP with split verification and a CRS of size <span class="math">m^{\\varepsilon}\\cdot\\text{poly}(\\lambda)</span>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows by combining 4.5 (alternatively, 3.3) with 5.9. Note that the CRS in 5.10 is independent of the circuit size <span class="math">s</span> (Theorem 3.10 and 4.15). ∎</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Remark 5.11 (Bootstrapping Tradeoffs).</h6>

    <p class="text-gray-300">The bootstrapping construction from 5.1 and 5.10 is best viewed as a way to reduce the CRS size dependence on the number of instances <span class="math">m</span> (e.g., from <span class="math">m^{2}</span> to <span class="math">m^{\\varepsilon}</span>) in exchange for a higher dependence on the security parameter <span class="math">\\lambda</span>. In general, the dependence on the security parameter scales exponentially with the depth of the composition. This is also the reason we are limited to constant-depth composition. Recursive composition yields a similar blowup (with respect to <span class="math">\\lambda</span>) in the proof size, verification key size, and verification time.</p>

    <h2 id="sec-92" class="text-2xl font-bold">6 Delegation for RAM Programs</h2>

    <p class="text-gray-300">In this section, we show how our techniques for constructing BARGs for NP can be leveraged to obtain delegation schemes for RAM programs. We obtain the delegation scheme by invoking the generic compiler by Choudhuri et al. <em>[x10]</em> which combines a BARG for index languages with a somewhere extractable commitment scheme. Choudhuri et al. showed that the Hubácek-Wichs somewhere statistically binding (SSB) hash function <em>[x14]</em> is</p>

    <p class="text-gray-300">already a somewhere extractable commitment, thus obtaining an instantiation from LWE. However, the SSB hash function from DDH <em>[x20]</em> does not satisfy the stronger extractability requirement. In this section (Section 6.2), we show that our techniques for constructing BARGs can be combined with any SSB hash function to obtain a somewhere extractable commitment with a long CRS. We then describe an analogous bootstrapping procedure to reduce the CRS size (Section 6.3). Finally, we combine our somewhere extractable commitment with the BARG for index languages (Corollary 5.10 and Remark 2.10) to obtain a RAM delegation scheme (Corollaries 6.28 and 6.30).</p>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">6.1 Somewhere Extractable Commitments</h3>

    <p class="text-gray-300">We begin by recalling the concept of a somewhere statistically binding (SSB) hash function <em>[x13]</em> and the closely-related notion of a somewhere extractable commitments from Choudhuri et al. <em>[x10]</em>.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Definition 6.1 (Somewhere Statistically Binding Hash Function <em>[x13, x20]</em>).</h6>

    <p class="text-gray-300">A somewhere statistically binding (SSB) hash function with block length <span class="math">\\ell_{\\text{blk}}</span>, output length <span class="math">\\ell_{\\text{hash}}</span>, and opening length <span class="math">\\ell_{\\text{open}}</span> is a tuple of efficient algorithms <span class="math">\\Pi_{\\text{SSB}}=(\\text{Setup},\\text{Hash},\\text{Open},\\text{Verify})</span> with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\text{Setup}(1^{\\lambda},1^{\\ell_{\\text{blk}}},N,i^{<em>})\\to\\text{hk}</span>: On input the security parameter <span class="math">\\lambda</span>, the block size <span class="math">\\ell_{\\text{blk}}</span>, the message length <span class="math">N\\leq 2^{\\lambda}</span>, and an index <span class="math">i^{</em>}\\in[N]</span>, the setup algorithm outputs a hashing key <span class="math">\\text{hk}</span>. Both <span class="math">N</span> and <span class="math">i^{<em>}</span> are encoded in </em>binary*; in particular, this means that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{hk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\ell_{\\text{blk}},\\log N)<span class="math">. We let </span>\\Sigma=\\{0,1\\}^{\\ell_{\\text{blk}}}$ denote the block alphabet.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Hash}(\\text{hk},\\mathbf{x})\\to h</span>: On input the hash key <span class="math">\\text{hk}</span> and a message <span class="math">\\mathbf{x}\\in\\Sigma^{N}</span>, the hash algorithm <em>deterministically</em> outputs a hash <span class="math">h\\in\\{0,1\\}^{\\ell_{\\text{hash}}}</span>.</li>

      <li><span class="math">\\text{Open}(\\text{hk},\\mathbf{x},i)\\to\\pi_{i}</span>: On input the hash key <span class="math">\\text{hk}</span>, an input <span class="math">\\mathbf{x}\\in\\Sigma^{N}</span> and an index <span class="math">i\\in[L]</span>, the open algorithm outputs an opening <span class="math">\\pi_{i}\\in\\{0,1\\}^{\\ell_{\\text{open}}}</span>.</li>

      <li><span class="math">\\text{Verify}(\\text{hk},h,i,x_{i},\\pi_{i})\\to b</span>: On input the hash key <span class="math">\\text{hk}</span>, a hash value <span class="math">h\\in\\{0,1\\}^{\\ell_{\\text{hash}}}</span>, an index <span class="math">i\\in[N]</span>, a value <span class="math">x_{i}\\in\\Sigma</span>, and an opening <span class="math">\\pi_{i}\\in\\{0,1\\}^{\\ell_{\\text{open}}}</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span> indicating whether it accepts or rejects.</li>

    </ul>

    <p class="text-gray-300">We require the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For all security parameters <span class="math">\\lambda\\in\\mathbb{N}</span>, all block sizes <span class="math">\\ell_{\\text{blk}}=\\ell_{\\text{blk}}(\\lambda)</span>, all integers <span class="math">N\\leq 2^{\\lambda}</span>, all indices <span class="math">i,i^{*}\\in[N]</span>, and any <span class="math">\\mathbf{x}\\in\\Sigma^{N}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{Verify}(\\text{hk},h,i,x_{i},\\pi_{i})=1:\\quad\\begin{array}[]{c}\\text{hk}\\leftarrow\\text{Setup}(1^{\\lambda},1^{\\ell_{\\text{blk}}},N,i^{*});\\\\ h\\leftarrow\\text{Hash}(\\text{hk},\\mathbf{x});\\pi_{i}\\leftarrow\\text{Open}(\\text{hk},\\mathbf{x},i)\\end{array}\\right]=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Index hiding: For a bit <span class="math">b\\in\\{0,1\\}</span> and an adversary <span class="math">\\mathcal{A}</span>, define the index hiding game <span class="math">\\text{ExptIH}_{\\mathcal{A}}(\\lambda,b)</span> as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda})</span> chooses an integer <span class="math">N</span> and two indices <span class="math">i_{0},i_{1}\\in[N]</span>.</li>

      <li>The challenger sets <span class="math">\\text{hk}\\leftarrow\\text{Setup}(1^{\\lambda},1^{\\ell_{\\text{blk}}},N,i_{b})</span>, and gives <span class="math">\\text{hk}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}\\in\\{0,1\\}</span>, which is also the output of the experiment.</li>

    </ol>

    <p class="text-gray-300">We require that for all polynomials <span class="math">\\ell_{\\text{blk}}=\\ell_{\\text{blk}}(\\lambda)</span> and all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{ExptIH}_{\\mathcal{A}}(\\lambda,0)=1]-\\Pr[\\text{ExptIH}_{\\mathcal{A}}(\\lambda,1)=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere statistically binding: We say that a hash key <span class="math">\\text{hk}</span> is statistically binding for an index <span class="math">i^{<em>}\\in[N]</span> if there does not exist <span class="math">h\\in\\{0,1\\}^{\\ell_{\\text{hash}}}</span>, <span class="math">x\\neq x^{\\prime}\\in\\Sigma</span>, and <span class="math">\\pi,\\pi^{\\prime}</span> where <span class="math">\\text{Verify}(\\text{hk},h,i^{</em>},x,\\pi)=1=\\text{Verify}(\\text{hk},h,i^{*},x^{\\prime},\\pi^{\\prime})</span>. We require that for all polynomials <span class="math">\\ell_{\\text{blk}}=\\ell_{\\text{blk}}(\\lambda)</span> and all <span class="math">N\\leq 2^{\\lambda}</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span> and all <span class="math">i\\in[N]</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{hk is statistically binding for index </span>i<span class="math"> : hk}\\leftarrow\\text{Setup}(1^{\\lambda},1^{\\ell_{\\text{blk}}},N,i)]=1-\\text{negl}(\\lambda).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: The hash length <span class="math">\\ell_{\\text{hash}}</span>, and opening length <span class="math">\\ell_{\\text{open}}</span> are all fixed polynomials in the security parameter <span class="math">\\lambda</span> and the block size <span class="math">\\ell_{\\text{blk}}</span> (and independent of <span class="math">N</span>).</li>

    </ul>

    <h6 id="sec-95" class="text-base font-medium mt-4">Definition 6.2 (Somewhere Extractable Commitment <em>[x10, adapted]</em>).</h6>

    <p class="text-gray-300">A somewhere extractable commitment scheme with block size <span class="math">\\ell_{\\text{blk}}</span> and locality <span class="math">L</span> is a tuple of efficient algorithms <span class="math">\\Pi_{\\text{SECom}}=({\\text{Setup}},{\\text{Commit}},{\\text{Open}},{\\text{Verify}})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">{\\text{Setup}}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L})\\to({\\text{crs}},{\\text{vk}})</span>: On input the security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, the block size <span class="math">\\ell_{\\text{blk}}</span>, the number of blocks <span class="math">N</span>, and the locality parameter <span class="math">L</span>, the setup algorithm outputs a common reference string <span class="math">{\\text{crs}}</span> and a verification key <span class="math">{\\text{vk}}</span>.</li>

      <li><span class="math">{\\text{Commit}}({\\text{crs}},{\\mathbf{v}})\\to(c,\\tau)</span>: On input the common reference string <span class="math">{\\text{crs}}</span>, and a vector <span class="math">{\\mathbf{v}}\\in(\\{0,1\\}^{\\ell_{\\text{blk}}})^{N}</span>, the commit algorithm outputs a commitment <span class="math">c</span> and a state <span class="math">\\tau</span>.</li>

      <li><span class="math">{\\text{Open}}({\\text{crs}},\\tau,i)\\to\\pi_{i}</span>: On input the common reference string <span class="math">{\\text{crs}}</span>, the commitment state <span class="math">\\tau</span>, and an index <span class="math">i</span>, the open algorithm outputs a local opening <span class="math">\\pi_{i}</span>.</li>

      <li><span class="math">{\\text{Verify}}({\\text{vk}},c,i,v,\\pi)\\to b</span>: On input the verification key <span class="math">{\\text{vk}}</span>, the commitment <span class="math">c</span>, an index <span class="math">i\\in[N]</span>, a block <span class="math">v\\in\\{0,1\\}^{\\ell_{\\text{blk}}}</span>, and a proof <span class="math">\\pi</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, <span class="math">\\Pi_{\\text{SECom}}</span> should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For all security parameters <span class="math">\\lambda</span>, block sizes <span class="math">\\ell_{\\text{blk}}</span>, message lengths <span class="math">N</span>, locality parameters <span class="math">L</span>, messages <span class="math">{\\mathbf{v}}=(v_{1},\\ldots,v_{N})\\in(\\{0,1\\}^{\\ell_{\\text{blk}}})^{N}</span>, and indices <span class="math">i\\in[N]</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[{\\text{Verify}}({\\text{vk}},c,i,v_{i},\\pi_{i})=1:\\begin{array}[]{c}({\\text{crs}},{\\text{vk}})\\leftarrow{\\text{Setup}}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L});\\\\ (c,\\tau)\\leftarrow{\\text{Commit}}({\\text{crs}},{\\mathbf{v}});\\pi_{i}\\leftarrow{\\text{Open}}({\\text{crs}},\\tau,i)\\end{array}\\right]=1. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere extractable: There exists a pair of efficient algorithms (<span class="math">{\\text{TrapSetup}},{\\text{Extract}}</span>) with the following properties:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">{\\text{TrapSetup}}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L},S)\\to({\\text{crs}}^{<em>},{\\text{vk}}^{</em>},\\text{td})</span>: On input the security parameter <span class="math">\\lambda</span>, the block size <span class="math">\\ell_{\\text{blk}}</span>, the number of blocks <span class="math">N</span>, the locality parameter <span class="math">L</span>, and a set <span class="math">S\\subseteq[N]</span>, the trapdoor setup algorithm outputs a common reference string <span class="math">{\\text{crs}}^{<em>}</span>, verification key <span class="math">{\\text{vk}}^{</em>}</span>, and an extraction trapdoor <span class="math">{\\text{td}}</span>.</li>

      <li><span class="math">{\\text{Extract}}({\\text{td}},c,i)\\to{\\mathbf{v}}</span>: On input the extraction trapdoor <span class="math">{\\text{td}}</span>, a commitment <span class="math">c</span>, and an index <span class="math">i\\in[N]</span>, the extraction algorithm either outputs a block <span class="math">{\\mathbf{v}}\\in\\{0,1\\}^{\\ell_{\\text{blk}}}</span> or a special symbol <span class="math">{\\mathbf{v}}=\\bot</span>. The extraction algorithm is <em>deterministic</em>.</li>

    </ul>

    <p class="text-gray-300">We moreover require the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS indistinguishability: For integers <span class="math">\\ell_{\\text{blk}},N,L\\in\\mathbb{N}</span>, a bit <span class="math">b\\in\\{0,1\\}</span>, and an adversary <span class="math">\\mathcal{A}</span>, define the CRS indistinguishability experiment <span class="math">{\\text{ExptCRS}}_{\\mathcal{A}}(\\lambda,\\ell_{\\text{blk}},N,L,b)</span> as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L})</span> chooses a set <span class="math">S\\subseteq[N]</span> of size at most <span class="math">L</span>.</li>

      <li>If <span class="math">b=0</span>, the challenger samples <span class="math">({\\text{crs}},{\\text{vk}})\\leftarrow{\\text{Setup}}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L})</span>. If <span class="math">b=1</span>, it samples <span class="math">({\\text{crs}},{\\text{vk}},{\\text{td}})\\leftarrow{\\text{TrapSetup}}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L},S)</span>. It gives <span class="math">({\\text{crs}},{\\text{vk}})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b^{\\prime}\\in\\{0,1\\}</span>, which is also the output of the experiment.</li>

    </ol>

    <p class="text-gray-300">We require that for all efficient adversaries <span class="math">\\mathcal{A}</span>, all polynomials <span class="math">\\ell_{\\text{blk}}=\\ell_{\\text{blk}}(\\lambda)</span>, <span class="math">N=N(\\lambda)</span>, and <span class="math">L=L(\\lambda)</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Pr[{\\text{ExptCRS}}_{\\mathcal{A}}(\\lambda,\\ell_{\\text{blk}},N,L,0)=1]}-{\\Pr[{\\text{ExptCRS}}_{\\mathcal{A}}(\\lambda,\\ell_{\\text{blk}},N,L,1)=1]}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere extractable in trapdoor mode: For integers <span class="math">\\ell_{\\text{blk}},N,L\\in\\mathbb{N}</span> and an adversary <span class="math">\\mathcal{A}</span>, define the somewhere extractability game as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda},1^{\\ell_{\\text{blk}}},1^{N},1^{L})</span> chooses a set <span class="math">S\\subseteq[N]</span> of size at most <span class="math">L</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger samples <span class="math">(\\mathrm{crs}^{<em>},\\mathrm{vk}^{</em>},\\mathrm{td})\\leftarrow\\mathrm{Tr}\\mathrm{a}p\\mathrm{Setup}(1^{\\lambda},1^{\\ell_{\\mathrm{blk}}},1^{N},1^{L},S)</span> and gives <span class="math">(\\mathrm{crs}^{<em>},\\mathrm{vk}^{</em>})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a commitment <span class="math">c</span>, a set of blocks <span class="math">\\{v_{i}\\}_{i\\in S}</span>, and a set of openings <span class="math">\\{\\pi_{i}\\}_{i\\in S}</span>.</li>

      <li>The output of the experiment is <span class="math">b=1</span> if there exists <span class="math">i\\in S</span> such that <span class="math">\\mathrm{Verify}(\\mathrm{vk}^{*},c,i,v_{i},\\pi_{i})=1</span> and <span class="math">\\mathrm{Extract}(\\mathrm{td},c,i)\\neq v_{i}</span>. Otherwise, the output is <span class="math">b=0</span>.</li>

    </ol>

    <p class="text-gray-300">We require that for all adversaries <span class="math">\\mathcal{A}</span>, all polynomials <span class="math">\\ell_{\\mathrm{blk}}=\\ell_{\\mathrm{blk}}(\\lambda)</span>, <span class="math">N=N(\\lambda)</span>, and <span class="math">L=L(\\lambda)</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathrm{Pr}[b=1]=\\mathrm{negl}(\\lambda)</span> in the above experiment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: There exists a universal polynomial <span class="math">\\mathrm{poly}(\\cdot,\\cdot,\\cdot,\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\ell_{\\mathrm{blk}}=\\ell_{\\mathrm{blk}}(\\lambda)</span>, <span class="math">N=N(\\lambda)</span>, <span class="math">L=L(\\lambda)</span>, vectors <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{N})\\in(\\{0,1\\}^{\\ell_{\\mathrm{blk}}})^{N}</span>, indices <span class="math">i\\in[N]</span>, all pairs <span class="math">(\\mathrm{crs},\\mathrm{vk})</span> in the support of <span class="math">\\mathrm{Setup}(1^{\\lambda},1^{\\ell_{\\mathrm{blk}}},1^{N},1^{L})</span>, all pairs <span class="math">(c,\\tau)</span> in the support <span class="math">\\mathrm{Commit}(\\mathrm{crs},\\mathbf{v})</span>, and all openings <span class="math">\\pi_{i}</span> in the support of <span class="math">\\mathrm{Open}(\\mathrm{crs},\\tau,i)</span>, the following properties hold:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct verification key: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},L,\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Succinct local opening: $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\pi_{i}</td>

            <td class="px-3 py-2 border-b border-gray-700">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},L,\\log N)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification: The running time of <span class="math">\\mathrm{Verify}(\\mathrm{vk},c,i,v_{i},\\pi_{i})</span> is <span class="math">\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},L,\\log N)</span>. This is implied by the previous properties. Namely, the length of the input to <span class="math">\\mathrm{Verify}</span> is <span class="math">\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},L,\\log N)</span>, succinct verification holds as long as the running time of <span class="math">\\mathrm{Verify}</span> is polynomial in its input length (i.e., it is an efficient algorithm).</li>

    </ul>

    <h6 id="sec-96" class="text-base font-medium mt-4">Remark 6.3 (Fixed Parameter Variants <em>[x20]</em>).</h6>

    <p class="text-gray-300">Definition 6.1 allows for a flexible input length <span class="math">N</span> and block size <span class="math">\\ell_{\\mathrm{blk}}</span>, and these parameters are provided as input to the Setup algorithm. As described in <em>Okamoto et al. [x20, §2]</em>, we can also consider variants of Definition 6.1 with a <em>fixed</em> input length <span class="math">N</span> and/or a fixed block size <span class="math">\\ell_{\\mathrm{blk}}</span>. Analogously, we can consider variants of Definition 6.2 with a fixed locality parameter <span class="math">L</span> and/or a fixed block size <span class="math">\\ell_{\\mathrm{blk}}</span>.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Remark 6.4 (Separating the Verification Key from CRS).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the definition of somewhere extractable commitments of <em>Choudhuri et al. [x1]</em>, Setup is required to output a single <em>succinct</em> CRS that is used by the <span class="math">\\mathrm{Commit}</span>, <span class="math">\\mathrm{Open}</span>, and <span class="math">\\mathrm{Verify}</span> algorithms. In this work, we consider a relaxed notion where <span class="math">\\mathrm{Setup}</span> outputs a common reference string <span class="math">\\mathrm{crs}</span> for generating and opening commitments and a separate (but still public) verification key is used to check openings. Importantly, for the primary application to delegation for RAM programs <em>[x1]</em>, it is necessary that the size of the verification key and the running time of the verification algorithm be <em>succinct</em>. Less critical is the size of the CRS: namely, if we combine a somewhere extractable commitment scheme with a long CRS (e.g., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},L,N)$) with a BARG for index languages, then we obtain a delegation scheme for RAM programs where the CRS size is long (scales polynomially with the running time of the RAM program). However, both the <em>proof size</em> and the <em>verification cost</em> still scale <em>polylogarithmically</em> with the running time of the RAM program. This is conceptually similar to the notion of a preprocessing succinct argument for NP <em>[x12, x15, x1, x11, x13]</em>, where the CRS is long, but the online verification costs (as measured in the proof size and the verification complexity) is succinct.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-98" class="text-base font-medium mt-4">Remark 6.5 (Extending the Block Size and Locality).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> be a somewhere extractable commitment scheme with block size <span class="math">1</span>. We can extend this to obtain a somewhere extractable commitment scheme <span class="math">\\Pi_{\\mathrm{SECom}}</span> with arbitrary (polynomial) block size <span class="math">\\ell_{\\mathrm{blk}}</span> by concatenating <span class="math">\\ell_{\\mathrm{blk}}</span> copies of the base scheme <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>. Specifically, a commitment <span class="math">c</span> to a vector <span class="math">\\mathbf{v}\\in(\\{0,1\\}^{\\ell_{\\mathrm{blk}}})^{N}</span> consists of <span class="math">\\ell_{\\mathrm{blk}}</span> commitments <span class="math">(c_{1},\\ldots,c_{\\ell_{\\mathrm{blk}}})</span> under the base scheme, where the <span class="math">j^{\\mathrm{th}}</span> commitment <span class="math">c_{j}</span> is a commitment to the <span class="math">j^{\\mathrm{th}}</span> bit of each block <span class="math">(v_{1,j},\\ldots,v_{N,j})</span>. An opening to block <span class="math">i\\in[N]</span> consists of openings <span class="math">(\\pi_{1},\\ldots,\\pi_{\\ell_{\\mathrm{blk}}})</span> where <span class="math">\\pi_{j}</span> is an opening of <span class="math">c_{j}</span> to bit <span class="math">v_{i,j}</span>. The size of the verification key, commitment, and opening increase by a factor of <span class="math">\\ell_{\\mathrm{blk}}</span> over that of the base scheme, which satisfies the required succinctness requirements.</p>

    <p class="text-gray-300">A similar approach suffices for extending a somewhere extractable commitment scheme with locality parameter <span class="math">1</span> (and arbitrary block size) to one with arbitrary (polynomial) locality parameter <span class="math">L</span>. Very briefly, the somewhere extractable commitment with locality parameter <span class="math">L</span> consists of <span class="math">L</span> <em>independent</em> copies of the base scheme. Let <span class="math">(\\mathrm{crs}_{1},\\mathrm{vk}_{1}),\\ldots,(\\mathrm{crs}_{L},\\mathrm{vk}_{L})</span> denote the common reference strings and verification keys associated with the <span class="math">L</span> independent copies of the base scheme. A commitment to a vector <span class="math">\\mathbf{v}\\in(\\{0,1\\}^{\\ell_{\\mathrm{blk}}})^{n}</span> consists of <span class="math">L</span> commitments <span class="math">c_{1},\\ldots,c_{L}</span> where <span class="math">c_{i}</span> is a commitment to <span class="math">\\mathbf{v}</span> with respect to <span class="math">(\\mathrm{crs}_{i},\\mathrm{vk}_{i})</span>. To open the commitment <span class="math">(c_{1},\\ldots,c_{L})</span>, the committer provides <span class="math">L</span> openings <span class="math">\\pi_{1},\\ldots,\\pi_{L}</span>, and the verifier accepts only if all of the <span class="math">L</span> copies accept. To sample a trapdoor CRS for</p>

    <p class="text-gray-300"><span class="math">j_{1},\\ldots,j_{L}\\in[N]</span>, we sample <span class="math">(\\operatorname{crs}_{i}^{<em>},\\operatorname{vk}_{i}^{</em>},\\operatorname{td}_{i})\\leftarrow\\operatorname{TrapSetup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{N},1^{L},\\{j_{i}\\})</span> for each <span class="math">i\\in[L]</span>. Namely, the <span class="math">i^{\\mathrm{th}}</span> commitment enables extraction of block <span class="math">j_{i}</span> of the message. CRS indistinguishability and somewhere extractability follow by a standard hybrid argument. Extending from <span class="math">1</span>-locality to <span class="math">L</span>-locality increases the length of the verification key, commitment, and local opening by a factor of <span class="math">L</span>.</p>

    <h3 id="sec-99" class="text-xl font-semibold mt-8">6.2 Somewhere Extractable Commitments from Pairings</h3>

    <p class="text-gray-300">We show how to construct a somewhere extractable commitment scheme with block size <span class="math">t_{\\mathrm{blk}}=1</span> and locality parameter <span class="math">L=1</span> by adapting the techniques we used to construct a BARG (see 4.5). We can extend to larger block sizes and locality parameters by concatenation (see 6.5). In particular, the commitment scheme the prover uses to commit to the wire values naturally supports succinct local openings. Somewhere extractability in turn follows from a similar proof strategy as the proof of 4.7. We can view our construction as a non-hiding version of the Catalano-Fiore vector commitment scheme <em>[x10]</em> (which also publishes cross-terms in the CRS to support succinct local openings) that satisfies a somewhere extractable property. The original Catalano-Fiore scheme does not support extraction on any index.</p>

    <p class="text-gray-300">The one remaining issue is that the resulting verification key scales linearly with the length of the vector. However, we observe that verifying an opening to an index <span class="math">i^{<em>}\\in[N]</span> only requires knowledge of a constant number of group elements from the verification key. We can then use the optimization suggested by Catalano and Fiore of moving the verification key into the proving key, and having the prover provide the verification component as part of the commitment opening. Of course, we now need to ensure robustness against a dishonest prover. The approach in Catalano and Fiore is to include signatures to authenticate the verification components, and the verifier would first check the signature before validating the commitment opening. In our setting, we require that the commitment be statistically binding (indeed, extractable) at a particular index; to realize this, we replace the signature with an SSB hash over the verification components. By sampling the SSB hash key to bind at index <span class="math">i^{</em>}</span>, the prover is forced to provide the correct verification component for index <span class="math">i^{*}</span>. We give the full construction and analysis below.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Construction 6.6 (Somewhere Extractable Commitment from Pairings).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span> and let <span class="math">\\Pi_{\\mathrm{SSB}}=(\\mathrm{SSB}.{\\mathrm{Setup}},\\mathrm{SSB}.{\\mathrm{Hash}},\\mathrm{SSB}.{\\mathrm{Open}},\\mathrm{SSB}.{\\mathrm{Verify}})</span> be a somewhere statistically binding hash function. We construct a somewhere extractable commitment with a fixed block size <span class="math">t_{\\mathrm{blk}}=1</span> and a fixed locality parameter <span class="math">L=1</span> (see 6.3).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Setup}(1^{\\lambda},1^{N})</span>: On input the security parameter <span class="math">\\lambda</span> and the message length <span class="math">N</span>, the setup algorithm does the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Run}\\ \\mathcal{G}=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},p,g_{1},g_{2},e)\\leftarrow\\mathrm{GroupGen}(1^{\\lambda})</span>. Sample matrices <span class="math">\\mathbf{M},\\hat{\\mathbf{M}}\\stackrel{{\\scriptstyle\\mathtt{R}}}{{\\leftarrow}}\\mathbb{Z}_{p}^{(k+1)\\times k}</span>.</li>

      <li>For each <span class="math">i\\in[N]</span>, sample <span class="math">\\bm{\\alpha}_{i},\\hat{\\bm{\\alpha}}_{i}\\stackrel{{\\scriptstyle\\mathtt{R}}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k}</span> and compute <span class="math">\\mathbf{a}_{i}\\leftarrow\\mathbf{M}\\bm{\\alpha}_{i}</span>, <span class="math">\\hat{\\mathbf{a}}_{i}\\leftarrow\\hat{\\mathbf{M}}\\hat{\\bm{\\alpha}}_{i}</span>. Let <span class="math">\\mathbf{a}\\leftarrow\\sum_{i\\in[N]}\\mathbf{a}_{i}</span>.</li>

      <li>For each <span class="math">i,j\\in[N]</span> where <span class="math">i\\neq j</span>, sample <span class="math">\\mathbf{R}_{i,j}\\stackrel{{\\scriptstyle\\mathtt{R}}}{{\\leftarrow}}\\mathbb{Z}_{p}^{k\\times k}</span> and let <span class="math">\\mathbf{B}_{i,j}\\leftarrow\\mathbf{M}(\\bm{\\alpha}_{i}\\hat{\\bm{\\alpha}}_{j}^{\\intercal}+\\mathbf{R}_{i,j})\\in\\mathbb{Z}_{p}^{(k+1)\\times k}</span> and <span class="math">\\hat{\\mathbf{B}}_{i,j}\\leftarrow-\\hat{\\mathbf{M}}\\mathbf{R}_{i,j}^{\\intercal}\\in\\mathbb{Z}_{p}^{(k+1)\\times k}</span>.</li>

      <li>Let <span class="math">t_{\\mathrm{blk}}(\\lambda)</span> be a bound on the number of bits needed to represent an element of <span class="math">\\mathbb{G}_{2}^{k+1}</span>. Sample a hash key <span class="math">\\mathrm{hk}\\leftarrow\\mathrm{SSB}.{\\mathrm{Setup}}(1^{\\lambda},1^{t_{\\mathrm{blk}}},N,1)</span> and compute <span class="math">h\\leftarrow\\mathrm{SSB}.{\\mathrm{Hash}}(\\mathrm{hk},([\\hat{\\mathbf{a}}_{1}]_{2},\\ldots,[\\hat{\\mathbf{a}}_{N}]_{2}))</span>.</li>

      <li>Output the verification key <span class="math">\\operatorname{vk}=\\big{(}\\mathcal{G},\\mathrm{hk},h,[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1})</span> and the common reference string <span class="math">\\operatorname{crs}=\\big{(}\\operatorname{vk},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[N]},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}</span>.</li>

      <li><span class="math">\\mathrm{Commit}(\\operatorname{crs},\\mathbf{v})</span>: On input <span class="math">\\operatorname{crs}=\\big{(}\\mathcal{G},\\mathrm{hk},h,[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[N]},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}</span> and a vector <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{N})\\in\\{0,1\\}^{N}</span>, the commit algorithm computes <span class="math">[\\mathbf{u}]_{1}\\leftarrow\\sum_{i\\in[N]}v_{i}[\\mathbf{a}_{i}]_{1}</span>. It outputs the commitment <span class="math">c=[\\mathbf{u}]_{1}</span> and the state <span class="math">\\tau=\\mathbf{v}</span>).</li>

      <li><span class="math">\\mathrm{Open}(\\operatorname{crs},\\tau,i)</span>: On input <span class="math">\\operatorname{crs}=\\big{(}\\mathcal{G},\\mathrm{hk},h,[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[N]},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}</span>, the state <span class="math">\\tau=\\mathbf{v}\\in\\{0,1\\}^{N}</span>, and the index <span class="math">i\\in[N]</span>, the open algorithm first computes <span class="math">\\pi_{\\mathrm{SSB}}\\leftarrow\\mathrm{Open}(\\mathrm{hk},([\\hat{\\mathbf{a}}_{1}]_{2},\\ldots,[\\hat{\\mathbf{a}}_{N}]_{2}),i)</span>. Next, it computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{W}]_{1}=\\sum_{j\\neq i}(v_{j}-v_{i})[\\mathbf{B}_{j,i}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{W}}]_{2}=\\sum_{j\\neq i}(v_{j}-v_{i})[\\hat{\\mathbf{B}}_{j,i}]_{2}.</span></p>

    <p class="text-gray-300">It outputs the opening <span class="math">\\pi = ([\\hat{\\mathbf{a}}_i]_2,\\pi_{\\mathrm{SSB}},[\\mathbf{W}]_1,[\\hat{\\mathbf{W}}]_2)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify(vk, c, i, v, <span class="math">\\pi</span>): On input the verification key vk = (G, hk, h, [M]1, [M]2, [a]1), commitment <span class="math">c = [\\mathbf{u}]_1</span>, index <span class="math">i \\in [N]</span>, bit <span class="math">v \\in \\{0,1\\}</span>, and an opening <span class="math">\\pi = ([\\hat{\\mathbf{a}}]_2, \\pi_{\\mathrm{SSB}}, [\\mathbf{W}]_1, [\\hat{\\mathbf{W}}]_2)</span>, the verification algorithm accepts if the following two properties hold:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SSB.Verify(hk, h, i, [a], π_SSB) = 1.</li>

      <li>[u]1 · [a^T]2 = (v[a]1 · [a^T]2) + ([M]1 · [W^T]2) + ([W]1 · [M^T]2).</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 6.7 (Correctness).</strong> If Π_SSB is correct, then Construction 6.6 is correct.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Fix a security parameter <span class="math">\\lambda</span> and message length <span class="math">N</span>. Take any vector <span class="math">\\mathbf{v} = (v_{1},\\ldots ,v_{N})\\in \\{0,1\\}^{N}</span> and index <span class="math">i^{<em>}\\in [N]</span>. Let <span class="math">(\\mathrm{crs},\\mathrm{vk})\\gets \\mathrm{Setup}(1^{\\lambda},1^{N})</span>, <span class="math">(c,\\tau)\\gets \\mathrm{Commit}(\\mathrm{crs},\\mathbf{v})</span> and <span class="math">\\pi_{i^</em>}\\gets \\mathrm{Open}(\\mathrm{crs},\\tau ,i^*)</span>. By construction, we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{vk} = \\left(\\mathcal{G}, \\mathrm{hk}, h, [\\mathbf{M}]_1, [\\hat{\\mathbf{M}}]_2, [\\mathbf{a}]_1\\right) \\quad \\text{and} \\quad \\mathrm{crs} = \\left(\\mathrm{vk}, \\left\\{[\\mathbf{a}_i]_1, [\\hat{\\mathbf{a}}_i]_2\\right\\}_{i \\in [N]}, \\left\\{[\\mathbf{B}_{i,j}]_1, [\\hat{\\mathbf{B}}_{i,j}]_2\\right\\}_{i \\neq j}\\right),</span></div>

    <p class="text-gray-300"><span class="math">c = [\\mathbf{u}]_1</span> and <span class="math">\\pi_{i^<em>} = ([\\hat{\\mathbf{a}}_i]_2,\\pi_{\\mathrm{SSB}},[\\mathbf{W}]_1,[\\hat{\\mathbf{W}}]_2)</span>. Consider each of the verification relations in <span class="math">\\mathrm{Verify}(\\mathrm{vk},c,i^{</em>},v_{i^{<em>}},\\pi_{i^{</em>}})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By construction, the hash key hk is generated using SSB.Setup, <span class="math">h</span> is a hash of <span class="math">([\\hat{\\mathbf{a}}_1]_2,\\dots ,[\\hat{\\mathbf{a}}_N]_2)</span>, and <span class="math">\\pi_{\\mathrm{SSB}}</span> is an opening of <span class="math">h</span> to <span class="math">[\\hat{\\mathbf{a}}_{i^<em>}]_2</span> at index <span class="math">i^</em></span>. Correctness of <span class="math">\\Pi_{\\mathrm{SSB}}</span> implies that SSB.Verify(hk, <span class="math">h, i^<em></span> , <span class="math">[\\hat{\\mathbf{a}}_{i^</em>}]_2, \\pi_{\\mathrm{SSB}}) = 1</span>.</li>

      <li>By construction, <span class="math">\\mathbf{u} = \\sum_{i\\in [N]}v_i[\\mathbf{a}_i]_1</span>. Thus, we can write</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{u} \\hat{\\mathbf{a}}_{i^*}^{\\top} = \\sum_{i \\in [N]} v_i \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top} = v_{i^*} \\mathbf{a}_{i^*} \\hat{\\mathbf{a}}_{i^*}^{\\top} + \\sum_{i \\neq i^*} v_i \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top}</span></div>

    <div class="my-4 text-center"><span class="math-block">v_{i^*} \\mathbf{a} \\hat{\\mathbf{a}}_{i^*}^{\\top} = \\sum_{i \\in [N]} v_{i^*} \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top} = v_{i^*} \\mathbf{a}_{i^*} \\hat{\\mathbf{a}}_{i^*}^{\\top} + \\sum_{i \\neq i^*} v_{i^*} \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top}</span></div>

    <p class="text-gray-300">Next, by the same calculation as Eq. (4.1) from the proof of Theorem 4.6, for all <span class="math">i \\neq j</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{M} \\hat{\\mathbf{B}}_{i,j}^{\\top} + \\mathbf{B}_{i,j} \\hat{\\mathbf{M}}^{\\top} = - \\mathbf{M} \\mathbf{R}_{i,j} \\hat{\\mathbf{M}}^{\\top} + \\mathbf{M} (\\boldsymbol{\\alpha}_i \\hat{\\boldsymbol{\\alpha}}_j^{\\top} + \\mathbf{R}_{i,j}) \\hat{\\mathbf{M}}^{\\top} = \\mathbf{M} \\boldsymbol{\\alpha}_i \\hat{\\boldsymbol{\\alpha}}_j^{\\top} \\hat{\\mathbf{M}}^{\\top} = \\mathbf{a}_i \\hat{\\mathbf{a}}_j^{\\top}.</span></div>

    <p class="text-gray-300">In particular, this means that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{M} \\hat{\\mathbf{W}}^{\\top} + \\mathbf{W} \\hat{\\mathbf{M}}^{\\top} = \\sum_{i \\neq i^*} (v_i - v_{i^*}) (\\mathbf{M} \\hat{\\mathbf{B}}_{i,i^*}^{\\top} + \\mathbf{B}_{i,i^*} \\hat{\\mathbf{M}}^{\\top}) = \\sum_{i \\neq i^*} (v_i - v_{i^*}) \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top}.</span></div>

    <p class="text-gray-300">Combining the above relations, we have</p>

    <div class="my-4 text-center"><span class="math-block">v_{i^*} \\mathbf{a} \\hat{\\mathbf{a}}_{i^*}^{\\top} + \\mathbf{M} \\hat{\\mathbf{W}}^{\\top} + \\hat{\\mathbf{W}} \\hat{\\mathbf{M}}^{\\top} = v_{i^*} \\mathbf{a}_{i^*} \\hat{\\mathbf{a}}_{i^*}^{\\top} + \\sum_{i \\neq i^*} (v_{i^*} + v_i - v_{i^*}) \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top} = v_{i^*} \\mathbf{a}_{i^*} \\hat{\\mathbf{a}}_{i^*}^{\\top} + \\sum_{i \\neq i^*} v_i \\mathbf{a}_i \\hat{\\mathbf{a}}_{i^*}^{\\top} = \\mathbf{u} \\hat{\\mathbf{a}}_{i^*}^{\\top}.</span></div>

    <p class="text-gray-300">Thus, the verifier accepts.</p>

    <p class="text-gray-300"><strong>Theorem 6.8 (Somewhere Extractable).</strong> If the <span class="math">k</span>-Lin assumption holds in <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> with respect to GroupGen and <span class="math">\\Pi_{\\mathrm{SSB}}</span> is a somewhere statistically binding hash function, then Construction 6.6 is somewhere extractable.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We start by defining the trapdoor setup and extraction algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TrapSetup <span class="math">(1^{\\lambda}, 1^{N}, i^{<em>})</span>: On input the security parameter <span class="math">\\lambda</span>, message length <span class="math">N</span>, and index <span class="math">i^{</em>} \\in [N]</span> (recall that we are considering the special case of locality <span class="math">L = 1</span> so the set <span class="math">S</span> contains just a single index <span class="math">i^{*}</span>), the trapdoor setup algorithm samples the common reference string and verification key using the following procedure (we highlight the differences from Setup in green):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathcal{G} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, g_1, g_2, e) \\gets \\mathrm{GroupGen}(1^{\\lambda})</span>. Sample matrices <span class="math">\\mathbf{M}, \\hat{\\mathbf{M}} \\gets \\mathbb{Z}_p^{(k+1) \\times k}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\neq i^*</span> , sample  <span class="math">\\alpha_i, \\hat{\\alpha}_i \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^k</span>  and let  <span class="math">\\mathbf{a}_i \\gets \\mathbf{M}\\alpha_i</span> ,  <span class="math">\\hat{\\mathbf{a}}_i \\gets \\hat{\\mathbf{M}}\\hat{\\alpha}_i</span> . Let  <span class="math">\\mathbf{0} \\neq \\mathbf{z} \\in \\mathbb{Z}_p^{k+1}</span>  be any non-zero vector such that  <span class="math">\\mathbf{z}^{\\mathrm{T}}\\mathbf{M} = \\mathbf{0}</span> . Since  <span class="math">\\mathbf{M}</span>  has rank at most  <span class="math">k</span> , such a  <span class="math">\\mathbf{z}</span>  always exists and can be efficiently computed.</li>

      <li>Sample  <span class="math">\\mathbf{a}_{i^<em>}, \\hat{\\mathbf{a}}_{i^</em>} \\gets \\mathbb{Z}_p^{k+1}</span> . Let  <span class="math">\\mathbf{a} \\gets \\sum_{i \\in [N]} \\mathbf{a}_i</span> .</li>

      <li>For each  <span class="math">i, j \\in [N]</span>  where  <span class="math">i \\neq j</span> , sample  <span class="math">\\mathbf{R}_{i,j} \\stackrel{\\mathrm{R}}{\\leftarrow} \\mathbb{Z}_p^{k \\times k}</span> . Construct  <span class="math">\\mathbf{B}_{i,j}</span>  and  <span class="math">\\hat{\\mathbf{B}}_{i,j}</span>  for  <span class="math">i \\neq j</span>  as follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} _ {i, j} = \\left\\{ \\begin{array}{l l} \\mathbf {a} _ {i} \\hat {\\boldsymbol {\\alpha}} _ {j} ^ {\\mathrm {T}} + \\mathbf {M R} _ {i, j} &amp;amp; j \\neq i ^ {*} \\\\ \\mathbf {M R} _ {i, j} &amp;amp; j = i ^ {*} \\end{array} \\right. \\quad \\hat {\\mathbf {B}} _ {i, j} = \\left\\{ \\begin{array}{l l} - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathrm {T}} &amp;amp; j \\neq i ^ {*} \\\\ - \\hat {\\mathbf {M R}} _ {i, j} ^ {\\mathrm {T}} + \\hat {\\mathbf {a}} _ {j} \\boldsymbol {\\alpha} _ {i} ^ {\\mathrm {T}} &amp;amp; j = i ^ {*}. \\end{array} \\right.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\ell_{\\mathrm{blk}}(\\lambda)</span>  be a bound on the number of bits needed to represent an element of  <span class="math">\\mathbb{G}_2^{k+1}</span> . Sample a hash key  <span class="math">\\mathrm{hk} \\gets \\mathrm{SSB.Setup}(1^{\\lambda}, 1^{\\ell_{\\mathrm{blk}}}, N, i^{*})</span>  and compute  <span class="math">h \\gets \\mathrm{SSB.Hash}(\\mathrm{hk}, ([\\hat{\\mathbf{a}}_1]_2, \\dots, [\\hat{\\mathbf{a}}_N]_2))</span> .</li>

      <li>Output the verification key  <span class="math">\\mathrm{vk}^<em> = (\\mathcal{G},\\mathrm{hk},h,[\\mathbf{M}]_1,[\\hat{\\mathbf{M}}]_2,[\\mathbf{a}]_1)</span> , the common reference string  <span class="math">\\mathrm{crs}^</em> = (\\mathrm{vk}^<em>,\\{[\\mathbf{a}_i]_1,[\\hat{\\mathbf{a}}_i]_2\\}_{i\\in [N]},\\{[\\mathbf{B}_{i,j}]_1,[\\hat{\\mathbf{B}}_{i,j}]_2\\}_{i\\neq j})</span> , and the trapdoor  <span class="math">\\mathrm{td} = (i^{</em>},\\mathbf{z})</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract  <span class="math">(\\mathrm{td}, c, i) \\to v</span> : On input the extraction trapdoor  <span class="math">\\mathrm{td} = (i^{<em>}, \\mathbf{z})</span> , a commitment  <span class="math">c = [\\mathbf{u}]_{1}</span> , and an index  <span class="math">i</span> , the extraction algorithm outputs  <span class="math">\\perp</span>  if  <span class="math">i \\neq i^{</em>}</span> . If  <span class="math">i = i^{*}</span> , then extraction algorithm outputs 0 if  <span class="math">\\mathbf{z}^{\\mathrm{T}}[\\mathbf{u}]_{1} = 0</span>  and 1 otherwise.</li>

    </ul>

    <p class="text-gray-300">We now show the CRS indistinguishability and somewhere extractability properties.</p>

    <p class="text-gray-300">Lemma 6.9 (CRS Indistinguishability). If the  <span class="math">k</span> -Lin assumption holds in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  with respect to GroupGen and  <span class="math">\\Pi_{\\mathrm{SSB}}</span>  satisfies index hiding, then Construction 4.5 satisfies CRS indistinguishability.</p>

    <p class="text-gray-300">Proof. Take any message length  <span class="math">N = N(\\lambda)</span> . We proceed via a hybrid argument:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_0</span> : This is the real distribution  <span class="math">\\mathrm{ExptCRS}_{\\mathcal{A}}(\\lambda, N, 0)</span> . Specifically, at the beginning of the security game, the adversary  <span class="math">\\mathcal{A}</span>  chooses an index  <span class="math">i^* \\in [N]</span> . The challenger then samples  <span class="math">(\\mathrm{crs}, \\mathrm{vk}) \\gets \\mathrm{Setup}(1^\\lambda, 1^N)</span>  and gives  <span class="math">(\\mathrm{crs}, \\mathrm{vk})</span>  to  <span class="math">\\mathcal{A}</span> . Algorithm  <span class="math">\\mathcal{A}</span>  then outputs a bit  <span class="math">b&#x27; \\in \\{0, 1\\}</span>  which is the output of the experiment.</li>

      <li><span class="math">\\mathrm{Hyb}_1</span> : Same as  <span class="math">\\mathrm{Hyb}_0</span>  except the challenger samples the hash key  <span class="math">\\mathrm{hk}</span>  using the procedure in TrapSetup:  <span class="math">\\mathrm{hk} \\gets \\mathrm{SSB.Setup}(1^\\lambda, 1^{\\ell_{\\mathrm{blk}}}, N, i^*)</span> . All of the other components of crs and vk are sampled as in  <span class="math">\\mathrm{Hyb}_0</span> .</li>

      <li><span class="math">\\mathrm{Hyb}_2</span> : This is the trapdoor distribution  <span class="math">\\mathrm{ExptCRS}_{\\mathcal{A}}(\\lambda, N, 1)</span> . Namely, the challenger samples  <span class="math">\\mathbf{a}_{i^<em>}, \\hat{\\mathbf{a}}_{i^</em>} \\gets \\mathbb{Z}_p^{k+1}</span>  and defines matrices  <span class="math">\\mathbf{B}_{i,j}, \\hat{\\mathbf{B}}_{i,j}</span>  according to the specification of TrapSetup.</li>

    </ul>

    <p class="text-gray-300">For an adversary  <span class="math">\\mathcal{A}</span> , we write  <span class="math">\\mathrm{Hyb}_i(\\mathcal{A})</span>  to denote the output of experiment  <span class="math">\\mathrm{Hyb}_i(\\mathcal{A})</span>  with algorithm  <span class="math">\\mathcal{A}</span> . We now show that each adjacent pair of hybrid experiments are computationally indistinguishable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 6.10. If  <span class="math">\\Pi_{\\mathrm{SSB}}</span>  satisfies index hiding, then for all efficient adversaries  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}</span> ,  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_0(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. This is immediate by index hiding since the only difference between  <span class="math">\\mathrm{Hyb}_0</span>  and  <span class="math">\\mathrm{Hyb}_1</span>  is that  <span class="math">\\mathrm{hk}</span>  binds to index 0 in  <span class="math">\\mathrm{Hyb}_0</span>  and to index  <span class="math">i^*</span>  in  <span class="math">\\mathrm{Hyb}_1</span> . More formally, suppose there exists an efficient algorithm  <span class="math">\\mathcal{A}</span>  such that  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathrm{Hyb}_0(\\mathcal{A}) = 1] - \\operatorname</em>{Pr}[\\mathrm{Hyb}_1(\\mathcal{A}) = 1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\varepsilon<span class="math">  for some non-negligible  </span>\\varepsilon<span class="math"> . We use  </span>\\mathcal{A}<span class="math">  to construct an algorithm  </span>\\mathcal{B}<span class="math">  that breaks index hiding of  </span>\\Pi_{\\mathrm{SSB}}<span class="math">  (for block size  </span>\\ell_{\\mathrm{blk}}$ ):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm  <span class="math">\\mathcal{B}</span>  starts running  <span class="math">\\mathcal{A}</span>  to obtain an index  <span class="math">i^{<em>} \\in [N]</span> . It sends indices 0 and  <span class="math">i^{</em>}</span>  as its challenge pair to the index hiding challenger.</li>

      <li>The index hiding challenger replies to  <span class="math">\\mathcal{B}</span>  with a hash key  <span class="math">\\mathrm{hk}</span> . Algorithm  <span class="math">\\mathcal{B}</span>  samples the other components of crs and vk exactly as described in  <span class="math">\\mathrm{Hyb}_0</span>  and  <span class="math">\\mathrm{Hyb}_1</span> . It gives crs and vk to  <span class="math">\\mathcal{A}</span>  and outputs whatever  <span class="math">\\mathcal{A}</span>  outputs.</li>

    </ol>

    <p class="text-gray-300">By construction, if  <span class="math">\\mathrm{hk}</span>  binds to index 0, then  <span class="math">\\mathcal{B}</span>  perfectly simulates  <span class="math">\\mathrm{Hyb}_0</span> , and if  <span class="math">\\mathrm{hk}</span>  binds to index  <span class="math">i^*</span> , then  <span class="math">\\mathcal{B}</span>  perfectly simulates  <span class="math">\\mathrm{Hyb}_1</span> . Thus, algorithm  <span class="math">\\mathcal{B}</span>  breaks index hiding with the same advantage  <span class="math">\\varepsilon</span> .</p>

    <p class="text-gray-300">Claim 6.11.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the <span class="math">k</span>-<span class="math">\\operatorname{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to <span class="math">\\operatorname{GroupGen}</span>, then for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\operatorname{Hyb}_{1}(\\mathcal{A})=1]-\\Pr[\\operatorname{Hyb}_{2}(\\mathcal{A})=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, the hash key <span class="math">\\mathsf{hk}</span> is identically distributed in the two experiments and independent of the group elements in the CRS and verification key. The hash value <span class="math">h</span> is a deterministic function of <span class="math">\\mathsf{hk}</span> and the group elements appearing in the CRS. Thus, it suffices to argue that the distribution of group elements in the CRS and verification key is computationally indistinguishable between <span class="math">\\operatorname{Hyb}_{1}</span> and <span class="math">\\operatorname{Hyb}_{2}</span>. This now follows by the same argument as the proof of Lemma 4.8. In particular, the group elements in the CRS and verification key of 6.6 are exactly the same as those in 4.5; this is also true for the distribution of the trapdoor CRS and verification key of the two schemes. ∎</p>

    <p class="text-gray-300">CRS indistinguishability now follows by a standard hybrid argument. ∎</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Lemma 6.12 (Somewhere Extractable in Trapdoor Mode).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\operatorname{SSB}}</span> is correct and somewhere statistically binding, then 6.6 satisfies extraction correctness.</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any polynomial <span class="math">N=N(\\lambda)</span>. Take any adversary <span class="math">\\mathcal{A}</span> for the somewhere extractability game and let <span class="math">i^{<em>}\\in[N]</span> be the index chosen by <span class="math">\\mathcal{A}</span>. Let <span class="math">(\\operatorname{crs}^{</em>},\\operatorname{vk}^{<em>},\\operatorname{td})\\leftarrow\\operatorname{TrapSetup}(1^{\\lambda},1^{N},i^{</em>})</span>. We write</p>

    <p class="text-gray-300"><span class="math">\\operatorname{vk}^{<em>}=\\big{(}\\mathcal{G},\\mathsf{hk},h,[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1})\\quad\\text{and}\\quad\\operatorname{crs}^{</em>}=\\big{(}\\operatorname{vk}^{*},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[N]},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}.</span></p>

    <p class="text-gray-300">Let <span class="math">c=[\\mathbf{u}]_{1}</span>, <span class="math">v\\in\\{0,1\\}</span>, and <span class="math">\\pi=([\\tilde{\\mathbf{a}}]_{2},\\pi_{\\operatorname{SSB}},[\\mathbf{W}]_{1},[\\hat{\\mathbf{W}}]_{2})</span> be the commitment, value, and opening, respectively, chosen by <span class="math">\\mathcal{A}</span>. Suppose <span class="math">\\operatorname{Verify}(\\operatorname{vk}^{<em>},c,i^{</em>},v,\\pi)=1</span>. Let <span class="math">v^{\\prime}\\leftarrow\\operatorname{Extract}(\\operatorname{td},c,i^{<em>})</span>. We claim that <span class="math">v=v^{\\prime}</span>. We first show that under the somewhere statistically binding property of <span class="math">\\Pi_{\\operatorname{SSB}}</span>, <span class="math">\\tilde{\\mathbf{a}}=\\hat{\\mathbf{a}}_{i^{</em>}}</span> with overwhelming property.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Claim 6.13.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\Pi_{\\operatorname{SSB}}</span> is correct and somewhere statistically binding. Then, there exists a negligible function <span class="math">\\operatorname{negl}(\\lambda)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\Pr[\\tilde{\\mathbf{a}}\\neq\\hat{\\mathbf{a}}_{i^{*}}]=\\operatorname{negl}(\\lambda)</span>, where the probability is taken over the random coins of <span class="math">\\operatorname{TrapSetup}</span>.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">\\operatorname{Verify}(\\operatorname{vk}^{<em>},c,i^{</em>},v,\\pi)=1</span>, this means that <span class="math">\\operatorname{SSB.Verify}(\\mathsf{hk},h,i^{<em>},[\\tilde{\\mathbf{a}}]_{2},\\pi_{\\operatorname{SSB}})=1</span>. By construction of <span class="math">\\operatorname{TrapSetup}</span>, <span class="math">\\mathsf{hk}</span> is generated using <span class="math">\\operatorname{SSB.Setup}</span> and moreover, <span class="math">h</span> is the hash of <span class="math">([\\hat{\\mathbf{a}}_{1}]_{2},\\ldots,[\\hat{\\mathbf{a}}_{N}]_{2})</span> under <span class="math">\\mathsf{hk}</span>. Let <span class="math">\\pi_{i^{</em>}}\\leftarrow\\operatorname{SSB.Open}(\\mathsf{hk},([\\tilde{\\mathbf{a}}_{1}]_{2},\\ldots,[\\hat{\\mathbf{a}}_{N}]_{2}),i^{<em>})</span>. Since <span class="math">\\Pi_{\\operatorname{SSB}}</span> is correct, this means that <span class="math">\\operatorname{SSB.Verify}(\\mathsf{hk},h,i^{</em>},[\\hat{\\mathbf{a}}_{i^{<em>}}]_{2},\\pi_{i^{</em>}})=1</span>. Then, if <span class="math">\\tilde{\\mathbf{a}}\\neq\\hat{\\mathbf{a}}_{i^{<em>}}</span>, we conclude that <span class="math">\\mathsf{hk}</span> is </em>not<em> statistically binding at index <span class="math">i^{</em>}</span>. Since <span class="math">\\Pi_{\\operatorname{SSB}}</span> is somewhere statistically binding, this event can only happen with negligible probability. ∎</p>

    <p class="text-gray-300">The rest of the proof now follows a similar structure as the proof of Lemma 4.12. In particular, the group elements in <span class="math">\\operatorname{crs}^{<em>}</span> and <span class="math">\\operatorname{vk}^{</em>}</span> are distributed exactly as in the trapdoor setup algorithm from the proof of Theorem 4.7. As demonstrated in 6.13, <span class="math">\\tilde{\\mathbf{a}}=\\hat{\\mathbf{a}}_{i^{<em>}}</span> with overwhelming probability. Moreover, by 4.13 (i), we can write <span class="math">\\mathbf{u}=\\xi\\mathbf{a}_{i^{</em>}}+\\mathbf{M}\\mathbf{t}</span> for some <span class="math">\\xi\\in\\mathbb{Z}_{p}</span> and <span class="math">\\mathbf{t}\\in\\mathbb{Z}_{p}^{k}</span>. In addition, let <span class="math">\\bm{\\beta}=\\sum_{i\\neq i^{<em>}}\\bm{\\alpha}_{i}</span>. Then <span class="math">\\mathbf{a}=\\sum_{i\\in[m]}\\mathbf{a}_{i}=\\mathbf{a}_{i^{</em>}}+\\sum_{i\\neq i^{<em>}}\\mathbf{M}\\bm{\\alpha}_{i}=\\mathbf{a}_{i^{</em>}}+\\mathbf{M}\\bm{\\beta}</span>. Now, we write</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}\\tilde{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=\\mathbf{u}\\hat{\\mathbf{a}}_{i^{<em>}}^{\\mathsf{T}}=\\xi\\mathbf{a}_{i^{</em>}}\\hat{\\mathbf{a}}_{i^{<em>}}^{\\mathsf{T}}+\\mathbf{M}\\mathbf{t}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\mathsf{T}}</span> <span class="math">\\mathbf{a}\\tilde{\\mathbf{a}}^{\\mathsf{T}}</span> <span class="math">=\\mathbf{a}\\hat{\\mathbf{a}}_{i}^{\\mathsf{T}}=(\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\bm{\\beta})\\hat{\\mathbf{a}}_{i^{</em>}}^{\\mathsf{T}}=\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\mathsf{T}}+\\mathbf{M}\\bm{\\beta}\\hat{\\mathbf{a}}_{i^{*}}^{\\mathsf{T}}.</span></p>

    <p class="text-gray-300">We now consider the verification relations under the projection operator from 4.13 (ii). By 4.13 (iii), (iv), we can write</p>

    <p class="text-gray-300"><span class="math">\\underbrace{\\operatorname{proj}(\\mathbf{u}\\tilde{\\mathbf{a}}^{\\mathsf{T}})}_{\\xi\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}}=\\underbrace{\\operatorname{proj}(v\\mathbf{a}\\tilde{\\mathbf{a}}^{\\mathsf{T}})}_{v\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}}+\\underbrace{\\operatorname{proj}(\\mathbf{M}\\hat{\\mathbf{W}}^{\\mathsf{T}})}_{0}+\\underbrace{\\operatorname{proj}(\\mathbf{W}\\hat{\\mathbf{M}}^{\\mathsf{T}})}_{0}.</span></p>

    <p class="text-gray-300">By 4.13 (i), <span class="math">\\mathbf{a}_{i^{<em>}}\\hat{\\mathbf{a}}_{i^{</em>}}^{\\mathsf{T}}\\neq\\mathbf{0}</span> with overwhelming probability, so we conclude that <span class="math">\\xi=v</span>. This means that <span class="math">\\mathbf{u}=v\\mathbf{a}_{i^{<em>}}+\\mathbf{M}\\mathbf{t}</span>. Consider now the value of <span class="math">v^{\\prime}</span> output by <span class="math">\\operatorname{Extract}(\\operatorname{td},[\\mathbf{u}]_{1},i^{</em>})</span> where <span class="math">\\operatorname{td}=(i^{<em>},\\mathbf{z})</span>. By construction, <span class="math">\\mathbf{z}\\neq\\mathbf{0}</span> and <span class="math">\\mathbf{z}^{\\mathsf{T}}\\mathbf{M}=\\mathbf{0}</span>. Next, <span class="math">\\mathbf{a}_{i^{</em>}}</span> is uniform over <span class="math">\\mathbb{Z}_{p}^{k+1}</span> and independent of <span class="math">\\mathbf{z}</span>, so with overwhelming probability, <span class="math">\\mathbf{z}^{\\mathsf{T}}\\mathbf{a}_{i^{*}}\\neq 0</span>. This means that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{z}^{\\mathsf{T}}\\mathbf{u}=v\\mathbf{z}^{\\mathsf{T}}\\mathbf{a}_{i^{<em>}}+\\mathbf{z}^{\\mathsf{T}}\\mathbf{M}\\mathbf{t}=v\\mathbf{z}^{\\mathsf{T}}\\mathbf{a}_{i^{</em>}}.</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\mathbf{z}^{\\mathsf{T}}\\mathbf{u}</span> is zero if and only if <span class="math">v=0</span>. By definition of <span class="math">\\operatorname{Extract}</span>, <span class="math">v^{\\prime}=v</span>, as required. ∎</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Theorem 6.14 (Succinctness).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span> be a constant. If <span class="math">\\Pi_{\\mathrm{SSB}}</span> is succinct, then 6.6 is succinct.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any security parameter <span class="math">\\lambda</span>, message length <span class="math">N</span>, vector <span class="math">\\mathbf{v}\\in\\{0,1\\}^{N}</span>, and index <span class="math">i\\in[N]</span>. Suppose we sample <span class="math">(\\mathrm{crs},\\mathrm{vk})\\leftarrow\\mathrm{Setup}(1^{\\lambda},1^{N})</span>, <span class="math">(c,\\tau)\\leftarrow\\mathrm{Commit}(\\mathrm{crs},\\mathbf{v})</span> and <span class="math">\\pi_{i}\\leftarrow\\mathrm{Open}(\\mathrm{crs},\\tau,i)</span>. By construction, we can write <span class="math">\\mathrm{vk}=(\\mathcal{G},\\mathrm{hk},h,\\mathbf{[M]}_{1},\\mathbf{[M]}_{2},\\mathbf{[a]}_{1})</span>, <span class="math">c=[\\mathbf{u}]_{1}</span> and <span class="math">\\pi_{i}=([\\hat{\\mathbf{a}}_{i}]_{2},\\pi_{\\mathrm{SSB}},\\mathbf{[W]}_{1},\\mathbf{[W]}_{2})</span>. We consider each of the requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification key: The description <span class="math">\\mathcal{G}</span> output by <span class="math">\\mathrm{GroupGen}(1^{\\lambda})</span> has length <span class="math">\\mathrm{poly}(\\lambda)</span>. Moreover, the number of bits needed to encode elements of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> are also <span class="math">\\mathrm{poly}(\\lambda)</span>. For constant <span class="math">k</span>, the encodings <span class="math">\\mathbf{[M]}_{1}</span> and <span class="math">\\mathbf{[M]}_{2}</span> and <span class="math">\\mathbf{[a]}_{1}</span> each contain of a constant number of group elements, and can be represented using <span class="math">\\mathrm{poly}(\\lambda)</span> bits.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, the hash key <span class="math">\\mathrm{hk}</span> output by <span class="math">\\mathrm{SSB.Hash}</span> has size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{hk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)<span class="math">. As noted above, </span>\\ell_{\\mathrm{blk}}=\\mathrm{poly}(\\lambda)<span class="math"> so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{hk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log N)<span class="math">. By succinctness of </span>\\Pi_{\\mathrm{SSB}}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})=\\mathrm{poly}(\\lambda)<span class="math">. Putting everything together, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log N)$, as required.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Succinct opening: For constant <span class="math">k</span>, the components <span class="math">[\\hat{\\mathbf{a}}_{i}]_{2}</span>, <span class="math">[\\mathbf{W}]_{1}</span>, and <span class="math">[\\hat{\\mathbf{W}}]_{2}</span> in <span class="math">\\pi_{i}</span> contain a constant number of group elements: <span class="math">k(k+1)</span> elements in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">(k+1)^{2}</span> elements in <span class="math">\\mathbb{G}_{2}</span>. By succinctness of <span class="math">\\Pi_{\\mathrm{SSB}}</span>, $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\pi_{\\mathrm{SSB}}</td>

            <td class="px-3 py-2 border-b border-gray-700">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})=\\mathrm{poly}(\\lambda)<span class="math">. Thus, </span></td>

            <td class="px-3 py-2 border-b border-gray-700">\\pi_{i}</td>

            <td class="px-3 py-2 border-b border-gray-700">=\\mathrm{poly}(\\lambda)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification: Verify is an efficient algorithm (i.e., its running time is polynomial in its input length), so succinct verification follows by the previous properties. ∎</li>

    </ul>

    <p class="text-gray-300">Combining 6.7, 6.8 and 6.14, we obtain the following corollary:</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Corollary 6.15 (Somewhere Extractable Commitment).</h6>

    <p class="text-gray-300">If the <span class="math">k</span>-<span class="math">\\mathrm{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to <span class="math">\\mathrm{GroupGen}</span> (for any constant <span class="math">k\\geq 1</span>), and <span class="math">\\Pi_{\\mathrm{SSB}}</span> is a somewhere statistically binding hash function, then 6.6 is a somewhere extractable commitment scheme with block size <span class="math">1</span>, locality <span class="math">1</span>, and CRS size <span class="math">N^{2}\\cdot\\mathrm{poly}(\\lambda,\\log N)</span>, where <span class="math">N</span> is the message length.</p>

    <h3 id="sec-109" class="text-xl font-semibold mt-8">6.3 Somewhere Extractable Commitments with a Short CRS</h3>

    <p class="text-gray-300">The size of the CRS in 5 has size <span class="math">N^{2}\\cdot\\mathrm{poly}(\\lambda,\\log N)</span>, where <span class="math">N</span> is the bit-length of the input. In this section, we show that a similar type of bootstrapping procedure as that described in Section 5 for the case of BARGs can be used to obtain a somewhere extractable commitment scheme with a CRS whose size is <em>sublinear</em> in <span class="math">N</span>. Specifically, for any constant <span class="math">\\varepsilon&gt;0</span>, we construct a somewhere extractable commitment with CRS size <span class="math">N^{\\varepsilon}\\cdot\\mathrm{poly}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to the bootstrapping procedure from Section 5, we start by describing a two-tiered construction. For a batch size <span class="math">B</span>, we break the input vector <span class="math">\\mathbf{v}\\in\\{0,1\\}^{N}</span> into <span class="math">N/B</span> blocks <span class="math">\\mathbf{v}_{1},\\ldots,\\mathbf{v}_{N/B}\\in\\{0,1\\}^{B}</span>, each of length <span class="math">B</span>. Let <span class="math">c_{i}</span> be a commitment to the <span class="math">i^{\\mathrm{th}}</span> block <span class="math">\\mathbf{v}_{i}</span>. Next, we construct a commitment to the vector <span class="math">(c_{1},\\ldots,c_{N/B})</span> to obtain a commitment <span class="math">c_{\\mathrm{top}}</span>. To open a commitment at a particular index <span class="math">i\\in[N]</span>, we first write <span class="math">i=B(i_{\\mathrm{top}}-1)+i_{\\mathrm{base}}</span> where <span class="math">i_{\\mathrm{top}}\\in[N/B]</span> and <span class="math">i_{\\mathrm{base}}\\in[B]</span>. Then, we open <span class="math">c_{\\mathrm{top}}</span> to <span class="math">c_{i_{\\mathrm{top}}}</span> (at index <span class="math">i_{\\mathrm{top}}</span>) and open <span class="math">c_{i_{\\mathrm{top}}}</span> at index <span class="math">i_{\\mathrm{base}}</span>. It is not difficult to see that if the base commitment scheme satisfies succinctness, then the two-tiered scheme is also succinct. Moreover, since the commitments in the base scheme are succinct ($</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log B)<span class="math">), the two-tiered scheme only needs to commit to vectors of length </span>B<span class="math"> and </span>N/B\\cdot\\mathrm{poly}(\\lambda,\\log B)<span class="math">. By setting the batch size to </span>B=\\sqrt{N}<span class="math">, we effectively reduce the size of the CRS from </span>N^{2}\\cdot\\mathrm{poly}(\\lambda,\\log N)<span class="math"> to </span>N\\cdot\\mathrm{poly}(\\lambda,\\log N)<span class="math">. By recursively composing (a constant number of times), we obtain a somewhere extractable commitment with CRS size </span>N^{\\varepsilon}<span class="math"> for any constant </span>\\varepsilon>0$. We give the full construction below:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-110" class="text-base font-medium mt-4">Construction 6.16 (Somewhere Extractable Commitment Bootstrapping).</h6>

    <p class="text-gray-300">Let <span class="math">B\\in\\mathbb{N}</span> be a batch size parameter. Let <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}=(\\mathrm{SECom}_{0}.\\mathrm{Setup},\\mathrm{SECom}_{0}.\\mathrm{Commit},\\mathrm{SECom}_{0}.\\mathrm{Open},\\mathrm{SECom}_{0}.\\mathrm{Verify})</span> be a somewhere extractable commitment scheme with locality <span class="math">L=1</span>. We construct a new somewhere extractable commitment scheme with locality <span class="math">L=1</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Setup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{N})</span>: On input the security parameter <span class="math">\\lambda</span>, the block size <span class="math">t_{\\mathrm{blk}}</span>, and the number of blocks <span class="math">N</span>, the setup algorithm does the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{base}})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Setup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{B})</span>.</li>

      <li>Let <span class="math">t_{c}^{\\prime}=t_{c}^{\\prime}(\\lambda,t_{\\mathrm{blk}},B)</span> be the length of the commitments output by <span class="math">\\mathrm{SECom}_{0}.\\mathrm{Commit}(\\mathrm{crs}_{\\mathrm{base}},\\cdot)</span>.</li>

      <li>Sample <span class="math">(\\mathrm{crs}_{\\mathrm{top}},\\mathrm{vk}_{\\mathrm{top}})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Setup}(1^{\\lambda},1^{t_{c}},</span> <span class="math">1^{N/B})</span>.</li>

      <li>Output <span class="math">\\mathrm{crs}=(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span> and <span class="math">\\mathrm{vk}=(\\mathrm{vk}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{top}})</span>.</li>

    </ul>

    <p class="text-gray-300">We will require that <span class="math">B\\leq N</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Commit}(\\mathrm{crs},\\mathbf{v})</span>: On input <span class="math">\\mathrm{crs}=(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span> and a vector <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{N})</span>, the commit algorithm proceeds as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[N/B]</span>, compute a commitment <span class="math">(c_{i},\\tau_{i})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Commit}(\\mathrm{crs}_{\\mathrm{base}},(v_{(i-1)B+1},\\ldots,v_{iB}))</span>.</li>

      <li>Compute <span class="math">(c_{\\mathrm{top}},\\tau_{\\mathrm{top}})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Commit}(\\mathrm{crs}_{\\mathrm{top}},(c_{1},\\ldots,c_{N/B}))</span>.</li>

      <li>Output the commitment <span class="math">c=c_{\\mathrm{top}}</span> and the state <span class="math">\\tau=(c_{1},\\ldots,c_{N/B},\\tau_{1},\\ldots,\\tau_{N/B},\\tau_{\\mathrm{top}})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Open}(\\mathrm{crs},\\tau,i)</span>: On input <span class="math">\\mathrm{crs}=(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span>, a state <span class="math">\\tau=(c_{1},\\ldots,c_{N/B},\\tau_{1},\\ldots,\\tau_{N/B},\\tau_{\\mathrm{top}})</span>, and an index <span class="math">i=B(i_{\\mathrm{top}}-1)+i_{\\mathrm{base}}</span> where <span class="math">i_{\\mathrm{top}}\\in[N/B]</span> and <span class="math">i_{\\mathrm{base}}\\in[B]</span>, the open algorithm computes openings <span class="math">\\pi_{\\mathrm{top}}\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Open}(\\mathrm{crs}_{\\mathrm{top}},\\tau_{\\mathrm{top}},i_{\\mathrm{top}})</span> and <span class="math">\\pi_{\\mathrm{base}}\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{Open}(\\mathrm{crs}_{\\mathrm{base}},\\tau_{i_{\\mathrm{top}}},i_{\\mathrm{base}})</span> and outputs <span class="math">\\pi=(c_{i_{\\mathrm{top}}},\\pi_{\\mathrm{top}},\\pi_{\\mathrm{base}})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Verify}(\\mathrm{vk},c,i,v,\\pi)</span>: On input the verification key <span class="math">\\mathrm{vk}=(\\mathrm{vk}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{top}})</span>, a commitment <span class="math">c=c_{\\mathrm{top}}</span>, an index <span class="math">i\\in[N]</span>, a value <span class="math">v\\in\\{0,1\\}^{t_{\\mathrm{blk}}}</span>, and a proof <span class="math">\\pi=(c^{\\prime},\\pi_{\\mathrm{top}},\\pi_{\\mathrm{base}})</span>, the verification algorithm writes <span class="math">i=B(i_{\\mathrm{top}}-1)+i_{\\mathrm{base}}</span> where <span class="math">i_{\\mathrm{top}}\\in[N/B]</span> and <span class="math">i_{\\mathrm{base}}\\in[B]</span>. The algorithm accepts (with output 1) if all of the following properties hold:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{SECom}_{0}.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{top}},c_{\\mathrm{top}},i_{\\mathrm{top}},c^{\\prime},\\pi_{\\mathrm{top}})=1</span>; and</li>

      <li><span class="math">\\mathrm{SECom}_{0}.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{base}},c^{\\prime},i_{\\mathrm{base}},v,\\pi_{\\mathrm{base}})=1</span>.</li>

    </ul>

    <p class="text-gray-300">Otherwise, the verification algorithm outputs 0.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Theorem 6.17 (Correctness).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is correct, then 6.6 is correct.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness follows by construction. Concretely, take any security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and polynomials <span class="math">t_{\\mathrm{blk}}=t_{\\mathrm{blk}}(\\lambda)</span>, <span class="math">N=N(\\lambda)</span>. Take any vector <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{N})\\in(\\{0,1\\}^{t_{\\mathrm{blk}}})^{N}</span> and index <span class="math">i\\in[N]</span>. Write <span class="math">i=B(i_{\\mathrm{top}}-1)+i_{\\mathrm{base}}</span> where <span class="math">i_{\\mathrm{top}}\\in[N/B]</span> and <span class="math">i_{\\mathrm{base}}\\in[B]</span>. Let <span class="math">(\\mathrm{crs},\\mathrm{vk})\\leftarrow\\mathrm{Setup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{N})</span>, <span class="math">(c,\\tau)\\leftarrow\\mathrm{Commit}(\\mathrm{crs},\\mathbf{v})</span>, <span class="math">\\pi\\leftarrow\\mathrm{Open}(\\mathrm{crs},\\tau,i)</span>. We can write <span class="math">\\mathrm{crs}=(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}})</span>, <span class="math">\\mathrm{vk}=(\\mathrm{vk}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{top}})</span>, <span class="math">\\tau=(c_{1},\\ldots,c_{N/B},\\tau_{1},\\ldots,\\tau_{N/B},\\tau_{\\mathrm{top}})</span>, and <span class="math">\\pi=(c_{i_{\\mathrm{top}}},\\pi_{\\mathrm{top}},\\pi_{\\mathrm{base}})</span>. We show that both verification relations in <span class="math">\\mathrm{Verify}(\\mathrm{vk},c,i,v_{i},\\pi)</span> hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">c_{\\mathrm{top}}</span> is a commitment to <span class="math">(c_{1},\\ldots,c_{N/B})</span> with respect to <span class="math">(\\mathrm{crs}_{\\mathrm{top}},\\mathrm{vk}_{\\mathrm{top}})</span> and <span class="math">\\pi_{\\mathrm{top}}</span> is an opening of <span class="math">c_{\\mathrm{top}}</span> to index <span class="math">i_{\\mathrm{top}}</span>. By correctness of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>, <span class="math">\\mathrm{SECom}_{0}.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{top}},c_{\\mathrm{top}},i_{\\mathrm{top}},c_{i_{\\mathrm{top}}},\\pi_{\\mathrm{top}})=1</span>.</li>

      <li>Next, <span class="math">c_{i_{\\mathrm{top}}}</span> is a commitment to <span class="math">(v_{(i_{\\mathrm{top}}-1)B+1},\\ldots,v_{i_{\\mathrm{top}}B})</span> with respect to <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{base}})</span> and <span class="math">\\pi_{\\mathrm{base}}</span> is an opening of <span class="math">c_{i_{\\mathrm{top}}}</span> to index <span class="math">i_{\\mathrm{base}}</span>. By definition, <span class="math">v_{(i_{\\mathrm{top}}-1)B+i_{\\mathrm{base}}}=v_{i}</span>, so <span class="math">\\mathrm{SECom}_{0}.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{base}},c_{\\mathrm{base}},i_{\\mathrm{base}},v_{i},\\pi_{\\mathrm{base}})=1</span>. ∎</li>

    </ul>

    <h6 id="sec-113" class="text-base font-medium mt-4">Theorem 6.18 (Somewhere Extractable).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is somewhere extractable, then 6.16 is somewhere extractable.</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We start by defining the trapdoor setup and extraction algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{TrapSetup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{N},i^{<em>})</span>: On input the security parameter <span class="math">\\lambda</span>, block length <span class="math">t_{\\mathrm{blk}}</span>, the number of blocks <span class="math">N</span>, and an index <span class="math">i^{</em>}\\in[N]</span>, the trapdoor setup algorithm writes <span class="math">i^{<em>}=B(i_{\\mathrm{top}}^{</em>}-1)+i_{\\mathrm{base}}^{*}</span> and then samples the following:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{crs}_{\\mathrm{base}}^{<em>},\\mathrm{vk}_{\\mathrm{base}}^{</em>},\\mathrm{td}_{\\mathrm{base}})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{TrapSetup}(1^{\\lambda},1^{t_{\\mathrm{blk}}},1^{B},i_{\\mathrm{base}}^{*})</span>; and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{crs}_{\\mathrm{top}}^{<em>},\\mathrm{vk}_{\\mathrm{top}}^{</em>},\\mathrm{td}_{\\mathrm{top}})\\leftarrow\\mathrm{SECom}_{0}.\\mathrm{TrapSetup}(1^{\\lambda},1^{t_{e}},1^{N/B},i_{\\mathrm{top}}^{*}).</span></li>

    </ul>

    <p class="text-gray-300">It outputs <span class="math">\\mathrm{crs}^{<em>} = (\\mathrm{crs}_{\\mathrm{base}}^{</em>},\\mathrm{crs}_{\\mathrm{top}}^{<em>}),\\ \\mathrm{vk}^{</em>} = (\\mathrm{vk}_{\\mathrm{base}}^{<em>},\\mathrm{vk}_{\\mathrm{top}}^{</em>}),</span> and <span class="math">\\mathrm{td} = (i^{*},\\mathrm{td}_{\\mathrm{base}},\\mathrm{td}_{\\mathrm{top}}).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract(td, c, i): On input the trapdoor <span class="math">\\mathrm{td} = (i^{<em>}, \\mathrm{td}_{\\mathrm{base}}, \\mathrm{td}_{\\mathrm{top}})</span>, a commitment <span class="math">c</span> and an index <span class="math">i \\in [N]</span>, if <span class="math">i \\neq i^{</em>}</span>, the extraction algorithm outputs <span class="math">\\perp</span>. Otherwise, it computes <span class="math">c_{\\mathrm{base}} \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{top}}, c, i_{\\mathrm{top}}^<em>)</span> and outputs <span class="math">v \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{base}}, c_{\\mathrm{base}}, i_{\\mathrm{base}}^</em>)</span> where <span class="math">i^{<em>} = B(i_{\\mathrm{top}}^{</em>} - 1) + i_{\\mathrm{base}}^{*}</span>.</li>

    </ul>

    <p class="text-gray-300">We now show that the CRS indistinguishability and somewhere extractability properties hold:</p>

    <p class="text-gray-300"><strong>Lemma 6.19 (CRS Indistinguishability).</strong> If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> satisfies CRS indistinguishability, then Construction 6.16 also satisfies CRS indistinguishability.</p>

    <p class="text-gray-300"><strong>Proof.</strong> This follows by a standard hybrid argument. First, <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{base}})</span> and <span class="math">(\\mathrm{crs}_{\\mathrm{top}},\\mathrm{vk}_{\\mathrm{top}})</span> are sampled independently in <strong>Construction 6.16</strong>, as is the case in the trapdoor setup algorithm. In the real setup, <span class="math">(\\mathrm{crs}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{base}})</span> is sampled by computing <span class="math">\\mathrm{SECom}_0.\\mathrm{Setup}(1^\\lambda,1^{t_{\\mathrm{blk}}},1^B)</span> and in the trapdoor setup algorithm, they are sampled by computing <span class="math">\\mathrm{SECom}_0.\\mathrm{TrapSetup}(1^\\lambda,1^{t_{\\mathrm{blk}}},1^B,i_{\\mathrm{base}}^*)</span>. These two distributions are computationally indistinguishable by CRS indistinguishability of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>. A similar argument applies to the distribution of <span class="math">(\\mathrm{crs}_{\\mathrm{top}},\\mathrm{vk}_{\\mathrm{top}})</span>.</p>

    <p class="text-gray-300"><strong>Lemma 6.20 (Somewhere Extractable in Trapdoor Mode).</strong> If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is somewhere extractable in trapdoor mode, then Construction 6.16 is somewhere extractable in trapdoor mode.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Fix polynomials <span class="math">t_{\\mathrm{blk}} = t_{\\mathrm{blk}}(\\lambda)</span> and <span class="math">N = N(\\lambda)</span>. Let <span class="math">i^{<em>} \\in [N]</span> be the index chosen by the adversary. Let <span class="math">(\\mathrm{crs}^{</em>}, \\mathrm{vk}^{<em>}, \\mathrm{td}) \\gets \\mathrm{TrapSetup}(1^{\\lambda}, 1^{t_{\\mathrm{blk}}}, 1^{N}, i^{</em>})</span>. We write <span class="math">\\mathrm{vk}^{<em>} = (\\mathrm{vk}_{\\mathrm{base}}^{</em>}, \\mathrm{vk}_{\\mathrm{top}}^{<em>})</span> and <span class="math">i^{</em>} = B(i_{\\mathrm{top}}^{<em>} - 1) + i_{\\mathrm{base}}^{</em>}</span>. Take any commitment <span class="math">c</span>, string <span class="math">v \\in \\{0, 1\\}^{t_{\\mathrm{blk}}}</span>, and proof <span class="math">\\pi = (c&#x27;, \\pi_{\\mathrm{top}}, \\pi_{\\mathrm{base}})</span>. Suppose that <span class="math">\\mathrm{Verify}(\\mathrm{vk}^{<em>}, c, i^{</em>}, v, \\pi) = 1</span>. Let <span class="math">c_{\\mathrm{base}} \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{top}}, c, i_{\\mathrm{top}}^{<em>})</span> and <span class="math">v&#x27; \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{base}}, c_{\\mathrm{base}}, i_{\\mathrm{base}}^{</em>})</span>. It suffices to show that with overwhelming probability, <span class="math">v = v&#x27;</span>. Since <span class="math">\\mathrm{Verify}(\\mathrm{vk}^{<em>}, c, i^{</em>}, v, \\pi)</span> outputs 1, we have that <span class="math">\\mathrm{SECom}_0.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{top}}^{<em>}, c, i_{\\mathrm{top}}^{</em>}, c&#x27;, \\pi_{\\mathrm{top}}) = 1</span> and <span class="math">\\mathrm{SECom}_0.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{base}}^{<em>}, c&#x27;, i_{\\mathrm{base}}^{</em>}, v, \\pi_{\\mathrm{base}}) = 1</span>.</p>

    <p class="text-gray-300"><strong>Claim 6.21.</strong> If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is somewhere extractable in trapdoor mode, then there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda \\in \\mathbb{N}</span>, <span class="math">\\operatorname*{Pr}[c&#x27; = c_{\\mathrm{base}}] = 1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose there is an adversary <span class="math">\\mathcal{A}</span> that outputs <span class="math">c, v, \\pi = (c&#x27;, \\pi_{\\mathrm{top}}, \\pi_{\\mathrm{base}})</span> where <span class="math">c&#x27; \\neq c_{\\mathrm{base}}</span> and <span class="math">\\mathrm{Verify}(\\mathrm{vk}^<em>, c, i^</em>, v, \\pi) = 1</span>. By construction of <span class="math">\\mathrm{Verify}</span>, this means that <span class="math">\\mathrm{SECom}_0.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{top}}^<em>, c, i_{\\mathrm{top}}^</em>, c&#x27;, \\pi_{\\mathrm{top}}) = 1</span>. We use <span class="math">\\mathcal{A}</span> to construct an algorithm <span class="math">\\mathcal{B}</span> that breaks the somewhere extractability property of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> with the same advantage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{B}</span> runs <span class="math">\\mathcal{A}</span> to obtain an index <span class="math">i^{<em>} \\in [N]</span>. It writes <span class="math">i^{</em>} = B(i_{\\mathrm{top}}^{<em>} - 1) + i_{\\mathrm{base}}^{</em>}</span>, gives <span class="math">i_{\\mathrm{top}}^{<em>}</span> to its challenger, and receives <span class="math">(\\mathrm{crs}_{\\mathrm{top}}^{</em>}, \\mathrm{vk}_{\\mathrm{top}}^{*})</span> from its challenger.</li>

      <li>Algorithm <span class="math">\\mathcal{B}</span> samples <span class="math">(\\mathrm{crs}_{\\mathrm{base}}^{<em>}, \\mathrm{vk}_{\\mathrm{base}}^{</em>}, \\mathrm{td}_{\\mathrm{base}}) \\gets \\mathrm{SECom}_0.\\mathrm{TrapSetup}(1^\\lambda, 1^{t_{\\mathrm{blk}}}, 1^B, i_{\\mathrm{base}}^<em>)</span>. It constructs and gives <span class="math">\\mathrm{crs}^</em> = (\\mathrm{crs}_{\\mathrm{base}}^<em>, \\mathrm{crs}_{\\mathrm{top}}^</em>)</span> and <span class="math">\\mathrm{vk}^<em> = (\\mathrm{vk}_{\\mathrm{base}}^</em>, \\mathrm{vk}_{\\mathrm{top}}^*)</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a commitment <span class="math">c</span>, a string <span class="math">v \\in \\{0,1\\}^{t_{\\mathrm{blk}}}</span> and a proof <span class="math">\\pi = (c&#x27;, \\pi_{\\mathrm{top}}, \\pi_{\\mathrm{base}})</span>. Algorithm <span class="math">\\mathcal{B}</span> outputs <span class="math">c, c&#x27;</span>, and <span class="math">\\pi_{\\mathrm{top}}</span>.</li>

    </ol>

    <p class="text-gray-300">By construction, algorithm <span class="math">\\mathcal{B}</span> perfectly simulates the view of <span class="math">\\mathcal{A}</span> in the somewhere extractability game. Thus, if <span class="math">\\mathcal{A}</span> succeeds with advantage <span class="math">\\varepsilon</span>, then with the same probability <span class="math">\\varepsilon</span>, <span class="math">\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{top}}^{<em>}, c, i_{\\mathrm{top}}^{</em>}, c&#x27;, \\pi_{\\mathrm{top}}) = 1</span> and <span class="math">c&#x27; \\neq c_{\\mathrm{base}}</span> where <span class="math">c_{\\mathrm{base}} \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{top}}, c, i_{\\mathrm{top}}^{*})</span>. Thus, <span class="math">\\mathcal{B}</span> breaks somewhere extractability of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> with advantage <span class="math">\\varepsilon</span>.</p>

    <p class="text-gray-300"><strong>Claim 6.22.</strong> If <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is somewhere extractable in trapdoor mode, then there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda \\in \\mathbb{N}</span>, <span class="math">\\operatorname*{Pr}[v = v&#x27;] = 1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By assumption, <span class="math">\\mathrm{SECom}_0.\\mathrm{Verify}(\\mathrm{vk}_{\\mathrm{base}}^<em>, c&#x27;, i_{\\mathrm{base}}^</em>, v, \\pi_{\\mathrm{base}}) = 1</span> and <span class="math">v&#x27; \\gets \\mathrm{SECom}_0.\\mathrm{Extract}(\\mathrm{td}_{\\mathrm{base}}, c_{\\mathrm{base}}, i_{\\mathrm{base}}^<em>)</span>. By Claim 6.21, <span class="math">c&#x27; = c_{\\mathrm{base}}</span> with overwhelming probability. Since <span class="math">(\\mathrm{crs}_{\\mathrm{base}}^</em>, \\mathrm{vk}_{\\mathrm{base}}^<em> \\mathrm{td}_{\\mathrm{base}})</span> is sampled using <span class="math">\\mathrm{SECom}_0.\\mathrm{TrapSetup}</span> with index <span class="math">i_{\\mathrm{base}}^</em></span>, we can appeal to a similar argument as used in the proof of Claim 6.21 to conclude that <span class="math">v = v&#x27;</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">Combining Claims 6.21 and 6.22, we have that the extracted block <span class="math">v^{\\prime}\\in\\{0,1\\}^{\\ell_{\\mathrm{blk}}}</span> matches the claimed block <span class="math">v\\in\\{0,1\\}^{\\ell_{\\mathrm{blk}}}</span> with overwhelming probability and the claim follows. ∎</p>

    <p class="text-gray-300">The claim now follows by combining Lemmas 6.19 and 6.20. ∎</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Theorem 6.23 (Succinctness).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> is a succinct somewhere extractable commitment with CRS size <span class="math">\\ell_{0}(\\lambda,\\ell_{\\mathrm{blk}},N)=N^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})</span> for some constant <span class="math">d\\in\\mathbb{N}</span>. Then Construction 6.16 is a succinct somewhere extractable commitment with CRS size</p>

    <p class="text-gray-300"><span class="math">\\ell(\\lambda,\\ell_{\\mathrm{blk}},N,B)=B^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})+(N/B)^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N).</span></p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show that each of the properties are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS size: The CRS in 6.16 consists of two common reference strings (<span class="math">\\mathrm{crs}_{\\mathrm{base}},\\mathrm{crs}_{\\mathrm{top}}</span>) for <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>. The size of <span class="math">\\mathrm{crs}_{\\mathrm{base}}</span> is <span class="math">\\ell_{0}(\\lambda,\\ell_{\\mathrm{blk}},B)</span> and the size of <span class="math">\\mathrm{crs}_{\\mathrm{top}}</span> is <span class="math">\\ell_{0}(\\lambda,\\ell_{c},N/B)</span>. By succinctness of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>, we have that <span class="math">\\ell_{c}(\\lambda,\\ell_{\\mathrm{blk}},B)=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log B)</span>. Thus,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\ell(\\lambda,\\ell_{\\mathrm{blk}},N,B)=B^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})+(N/B)^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N).</span> ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct verification key: The verification key <span class="math">\\mathrm{vk}</span> in 6.16 consists of two verification keys (<span class="math">\\mathrm{vk}_{\\mathrm{base}},\\mathrm{vk}_{\\mathrm{top}}</span>) for <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>. By succinctness of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>, we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}_{\\mathrm{base}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log B)<span class="math"> and </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}_{\\mathrm{top}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{c},\\log N/B)=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)<span class="math">. Thus, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct commitment: The commitment consists of a single commitment under <span class="math">\\mathrm{crs}_{\\mathrm{top}}</span>, which has size <span class="math">\\mathrm{poly}(\\lambda,\\ell_{c},\\log N/B)=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct opening: An opening (<span class="math">c_{\\mathrm{base}},\\pi_{\\mathrm{top}},\\pi_{\\mathrm{base}}</span>) consists of a commitment <span class="math">c</span> under <span class="math">\\mathrm{crs}_{\\mathrm{base}}</span> and two openings <span class="math">\\pi_{\\mathrm{top}}</span> and <span class="math">\\pi_{\\mathrm{base}}</span> under <span class="math">\\mathrm{crs}_{\\mathrm{top}}</span> and <span class="math">\\mathrm{crs}_{\\mathrm{base}}</span>, respectively. By succinctness of <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\mathrm{base}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{base}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log B)<span class="math"> and </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{top}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\ell_{c},\\log(N/B))=\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)<span class="math">. The overall opening size is then </span>\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification: The verification algorithm reduces to two invocations of the verification algorithm for <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> which run in time <span class="math">\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log B)</span> and <span class="math">\\mathrm{poly}(\\lambda,\\ell_{c},\\log(N/B))</span>. The total running time is thus <span class="math">\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)</span>.</li>

    </ul>

    <h6 id="sec-117" class="text-base font-medium mt-4">Corollary 6.24 (Somewhere Extractable Commitment with Short CRS).</h6>

    <p class="text-gray-300">Suppose there exists a somewhere extractable commitment with locality <span class="math">1</span> and commitment size <span class="math">\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},N)</span>, where <span class="math">\\ell_{\\mathrm{blk}}</span> is the block size and <span class="math">N</span> is the number of blocks. Then, for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a somewhere extractable commitment with locality <span class="math">1</span> and a CRS of size <span class="math">N^{\\varepsilon}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})</span>.</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathrm{SECom}}^{(0)}</span> be a somewhere extractable commitment scheme with locality <span class="math">1</span> and a CRS of size bounded by <span class="math">N^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})</span> for some constant <span class="math">d\\in\\mathbb{N}</span>. Let <span class="math">k=\\lceil\\log(2d/\\varepsilon)\\rceil\\in\\mathbb{N}</span>. For <span class="math">i\\in[k]</span>, let <span class="math">\\Pi_{\\mathrm{SECom}}^{(i)}</span> be the somewhere extractable commitment with locality <span class="math">1</span> formed by applying 6.16 to <span class="math">\\Pi_{\\mathrm{SECom}}^{(i-1)}</span> with <span class="math">B=\\sqrt{N}</span>. Let <span class="math">\\ell_{i}</span> denote the length of the CRS in <span class="math">\\Pi_{\\mathrm{SECom}}^{(i)}</span>. Since <span class="math">\\ell_{0}(\\lambda,\\ell_{\\mathrm{blk}},N)=N^{d}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})</span>, we can inductively apply Theorem 6.23 to write</p>

    <p class="text-gray-300"><span class="math">\\ell_{i}(\\lambda,\\ell_{\\mathrm{blk}},N)=N^{d/2^{i}}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N).</span></p>

    <p class="text-gray-300">Substituting <span class="math">k=\\lceil\\log(2d/\\varepsilon)\\rceil</span> into the above, we have that</p>

    <p class="text-gray-300"><span class="math">\\ell_{k}(\\lambda,\\ell_{\\mathrm{blk}},N)=N^{\\varepsilon/2}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}},\\log N)&lt;N^{\\varepsilon}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}}),</span></p>

    <p class="text-gray-300">since <span class="math">2d/\\varepsilon</span> is a constant. The other succinctness requirements are preserved since we compose a constant number of times. ∎</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Corollary 6.25 (Somewhere Extractable Commitment with Short CRS).</h6>

    <p class="text-gray-300">If the <span class="math">k</span>-<span class="math">\\mathrm{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to <span class="math">\\mathrm{GroupGen}</span> (for any constant <span class="math">k\\geq 1</span>), and if there exists a somewhere statistically binding hash function, then for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a somewhere extractable commitment scheme with locality <span class="math">1</span> and CRS size <span class="math">N^{\\varepsilon}\\cdot\\mathrm{poly}(\\lambda,\\ell_{\\mathrm{blk}})</span> where <span class="math">\\ell_{\\mathrm{blk}}</span> is the block size and <span class="math">N</span> is the number of blocks in the input.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows by instantiating 6.24 with 6.15 (along with Remark 6.5). ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6.4 Delegation for RAM Programs</p>

    <p class="text-gray-300">In this section, we recall the definition of delegation for RAM machines from the works of <em>[x13, x10]</em>. We refer to Kalai et al. <em>[x13, Remark 3.6]</em> for comparisons with earlier definitions of RAM delegation <em>[x14, x3]</em>. Our description here is adapted from that in <em>[x13]</em>. A RAM machine <span class="math">\\mathcal{R}</span> with word size <span class="math">\\ell</span> is modeled as a deterministic machine with random access to a memory of size <span class="math">2^{\\ell}</span> bits and a local state of size <span class="math">O(\\ell)</span>. On each step of the RAM computation, the machine either reads or writes to a single word in memory and then updates its local state. We refer to the combination of the machine’s local state and the memory as its configuration <span class="math">\\operatorname{cf}</span>. For ease of exposition, we assume that the machine has no input or output other than its initial memory and local state configuration, and moreover, we set the word size <span class="math">\\ell=\\lambda</span> to the security parameter. For a RAM machine <span class="math">\\mathcal{R}</span>, we define the language <span class="math">\\mathcal{L}_{\\mathcal{R}}</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathcal{R}}\\coloneqq\\{(\\ell,\\operatorname{cf},\\operatorname{cf}^{\\prime},T)\\mid\\mathcal{R}\\text{ with word size }\\ell\\text{ transitions from }\\operatorname{cf}\\text{ to }\\operatorname{cf}^{\\prime}\\text{ in }T\\text{ steps}\\}.</span></p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Definition 6.26 (Delegation for RAM Programs <em>[x13, x10, adapted]</em>).</h6>

    <p class="text-gray-300">A publicly-verifiable non-interactive delegation scheme for a RAM program <span class="math">\\mathcal{R}</span> with setup time <span class="math">T_{S}=T_{S}(\\lambda,T)</span> and proof length <span class="math">\\ell_{\\pi}=\\ell_{\\pi}(\\lambda,T)</span> is a tuple of efficient algorithms <span class="math">\\Pi_{\\text{RAM}}=(\\text{Setup},\\text{Digest},\\text{Prove},\\text{Verify})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(1^{\\lambda},1^{T})\\to(\\text{pk},\\text{vk},\\text{dk})</span>: On input the security parameter <span class="math">\\lambda</span>, a time bound <span class="math">T</span>, the setup algorithm outputs a prover key pk, a verification key vk, and a digest key dk.</li>

      <li><span class="math">\\text{Digest}(\\text{dk},\\text{cf})\\to\\text{h}</span>: On input the digest key dk and a configuration <span class="math">\\operatorname{cf}</span>, the digest algorithm outputs a hash h. This algorithm is deterministic.</li>

      <li><span class="math">\\text{Prove}(\\text{pk},\\text{cf},\\text{cf}^{\\prime})\\to\\pi</span>: On input the prover key pk, an initial configuration <span class="math">\\operatorname{cf}</span> and a final configuration <span class="math">\\operatorname{cf}^{\\prime}</span>, the prove algorithm outputs a proof <span class="math">\\pi</span>. This algorithm is deterministic.</li>

      <li><span class="math">\\text{Verify}(\\text{vk},\\text{h},\\text{h}^{\\prime},\\pi)\\to b</span>: On input the verification key vk, a pair of digests h, h^{′}, and a proof <span class="math">\\pi</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>. This algorithm is deterministic.</li>

    </ul>

    <p class="text-gray-300">We require that <span class="math">\\Pi_{\\text{RAM}}</span> satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For every <span class="math">\\lambda,T\\in\\mathbb{N}</span> where <span class="math">T\\leq 2^{\\lambda}</span> and <span class="math">\\operatorname{cf},\\operatorname{cf}^{\\prime}\\in\\{0,1\\}^{*}</span> where <span class="math">(\\lambda,\\operatorname{cf},\\operatorname{cf}^{\\prime},T)\\in\\mathcal{L}_{\\mathcal{R}}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Verify}(\\text{vk},\\text{h},\\text{h}^{\\prime},\\pi)=1]=1,</span></p>

    <p class="text-gray-300">where <span class="math">(\\text{pk},\\text{vk},\\text{dk})\\leftarrow\\text{Setup}(1^{\\lambda},1^{T})</span>, <span class="math">\\text{h}\\leftarrow\\text{Digest}(\\text{dk},\\text{cf})</span>, <span class="math">\\text{h}^{\\prime}\\leftarrow\\text{Digest}(\\text{dk},\\text{cf}^{\\prime})</span>, and <span class="math">\\pi\\leftarrow\\text{Prove}(\\text{pk},\\text{cf},\\text{cf}^{\\prime})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficiency: In the completeness experiment above, we require the following hold:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The setup algorithm runs in time <span class="math">T_{S}(\\lambda,T)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The digest algorithm on configuration <span class="math">\\operatorname{cf}</span> runs in time $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{cf}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\text{poly}(\\lambda)<span class="math"> and outputs a digest of size </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier runs in time <span class="math">O(\\ell_{\\pi})+\\text{poly}(\\lambda)</span>.</li>

      <li>Collision Resistance: For every efficient adversary <span class="math">\\mathcal{A}</span> and every polynomial <span class="math">T=T(\\lambda)</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\operatorname{cf}\\neq\\operatorname{cf}^{\\prime}\\wedge\\text{Digest}(\\text{dk},\\operatorname{cf})=\\text{Digest}(\\text{dk},\\operatorname{cf}^{\\prime}):\\begin{array}[]{c}(\\text{pk},\\text{vk},\\text{dk})\\leftarrow\\text{Setup}(1^{\\lambda},1^{T});\\cr(\\text{cf},\\text{cf}^{\\prime})\\leftarrow\\mathcal{A}(\\text{pk},\\text{vk},\\text{dk}).\\end{array}\\right]=\\text{negl}(\\lambda).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: For every efficient adversary <span class="math">\\mathcal{A}</span> and every polynomial <span class="math">T=T(\\lambda)</span>, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\begin{array}[]{c}\\text{Verify}(\\text{vk},\\text{h},\\text{h}^{\\prime},\\pi)=1\\wedge\\cr(\\lambda,\\text{cf},\\text{cf}^{\\prime},T)\\in\\mathcal{L}_{\\mathcal{R}}\\wedge\\cr\\text{h}=\\text{Digest}(\\text{dk},\\text{cf})\\wedge\\cr\\text{h}^{\\prime}\\neq\\text{Digest}(\\text{dk},\\text{cf}^{\\prime})\\end{array}:\\begin{array}[]{c}(\\text{pk},\\text{vk},\\text{dk})\\leftarrow\\text{Setup}(1^{\\lambda},1^{T});\\cr(\\text{cf},\\text{cf}^{\\prime},\\text{h},\\text{h}^{\\prime},\\pi)\\leftarrow\\mathcal{A}(\\text{pk},\\text{vk},\\text{dk})\\end{array}\\right]=\\text{negl}(\\lambda).</span></p>

    <h4 id="sec-122" class="text-lg font-semibold mt-6">Construction and instantiation.</h4>

    <p class="text-gray-300">Choudhuri et al. <em>[x10]</em> showed how to construct a delegation scheme for RAM programs from a variant of a somewhere extractable commitment scheme that supports “no-signaling” extraction <em>[x12]</em> together with a non-interactive batch argument for an index language (Remark 2.10). As shown by González and Zacharakis (see also <em>[x10, Theorem 13]</em>), a no-signaling somewhere extractable commitment scheme with locality <span class="math">L</span> can be constructed using <span class="math">L</span> copies of a vanilla somewhat extractable commitment scheme with locality <span class="math">1</span> (e.g., from Corollary 6.25). We summarize this instantiation in the following theorem:</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Theorem 6.27 (Delegation for RAM Programs <em>[x10]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose there exists a somewhere extractable commitment scheme with block size <span class="math">\\ell_{\\text{blk}}=1</span>, locality <span class="math">L=1</span>, and a batch non-interactive argument for index languages. Then, there exists a delegation scheme for RAM programs with setup time <span class="math">T_{S}=\\text{poly}(\\lambda,T)</span> and proof length <span class="math">\\ell_{\\pi}=\\text{poly}(\\lambda,\\log T)</span>. Moreover, the size of the digest key is <span class="math">\\text{poly}(\\lambda)</span> and the size of the proving key is $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{crs}_{\\text{indexBARG}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{crs}_{\\text{SECom}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot\\text{poly}(\\lambda)<span class="math">, where </span>\\text{crs}_{\\text{indexBARG}}<span class="math"> denotes the length of the CRS for the index BARG (with </span>m=\\text{poly}(T)<span class="math"> instances and </span>s=\\text{poly}(\\lambda)<span class="math">-size circuits) and </span>\\text{crs}_{\\text{SECom}}<span class="math"> denotes the lengths of the CRS for the somewhere extractable commitment scheme (with message length </span>N=\\text{poly}(\\lambda,T)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can instantiate Theorem 6.27 with our batch non-interactive argument for index languages (Corollary 5.10 and Remark 2.10) together with our somewhere extractable commitment scheme (Corollary 6.25). This yields a delegation scheme for RAM programs from the <span class="math">k</span>-Lin assumption over asymmetric prime-order groups in conjunction with an SSB hash function. We can moreover instantiate the SSB hash function using the DDH-based construction of Okamoto et al. <em>[x20]</em>, which yields a delegation scheme for RAM programs from the <span class="math">1</span>-Lin (i.e., SXDH) assumption on prime-order pairing groups. We state these corollaries formally below:</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Corollary 6.28 (Delegation for RAM Programs).</h6>

    <p class="text-gray-300">If the <span class="math">k</span>-Lin assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to GroupGen (for any constant <span class="math">k\\geq 1</span>), and there exists a somewhere statistically binding hash function, then for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a delegation scheme for RAM programs with setup time <span class="math">T_{S}=\\text{poly}(\\lambda,T)</span>, proof length <span class="math">\\ell_{\\pi}=\\text{poly}(\\lambda,\\log T)</span>, digest key size <span class="math">\\text{poly}(\\lambda)</span>, and proving key size <span class="math">T^{\\varepsilon}\\cdot\\text{poly}(\\lambda)</span>.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Theorem 6.29 (SSB Hash Functions from DDH <em>[x20]</em>).</h6>

    <p class="text-gray-300">Suppose the DDH assumption holds with respect to a group generator GroupGen. Then, there exists a SSB hash function for any polynomial block length <span class="math">\\ell_{\\text{blk}}=\\ell_{\\text{blk}}(\\lambda)</span>.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Corollary 6.30 (Delegation for RAM Programs from SXDH).</h6>

    <p class="text-gray-300">If the SXDH assumption holds with respect to GroupGen, then for every constant <span class="math">\\varepsilon&gt;0</span>, there exists a delegation scheme for RAM programs with setup time <span class="math">T_{S}=\\text{poly}(\\lambda,T)</span>, proof length <span class="math">\\ell_{\\pi}=\\text{poly}(\\lambda,\\log T)</span>, digest key size <span class="math">\\text{poly}(\\lambda)</span>, and proving key size <span class="math">T^{\\varepsilon}\\cdot\\text{poly}(\\lambda)</span>.</p>

    <h2 id="sec-127" class="text-2xl font-bold">7 Aggregate Signatures from BARGs</h2>

    <p class="text-gray-300">In this section, we describe the straightforward approach of constructing aggregate signatures from BARGs for NP, and show that we can argue security so long as the BARG is a somewhere argument of knowledge. Importantly, security does not require that the BARG be fully extractable. We start by recalling the definition of a standard digital signature scheme and an aggregate signature scheme:</p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Definition 7.1 (Digital Signature).</h6>

    <p class="text-gray-300">A digital signature scheme with message space <span class="math">\\mathcal{M}</span> is a tuple of efficient algorithms <span class="math">\\Pi_{\\text{Sig}}=(\\text{KeyGen},\\text{Sign},\\text{Verify})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{KeyGen}(1^{\\lambda})\\to(\\text{sk},\\text{vk})</span>: On input the security parameter <span class="math">\\lambda</span>, the key-generation algorithm outputs a signing key sk and a verification key vk.</li>

      <li><span class="math">\\text{Sign}(\\text{sk},\\mu)\\to\\sigma</span>: On input the signing key sk and a message <span class="math">\\mu\\in\\mathcal{M}</span>, the signing algorithm outputs a signature <span class="math">\\sigma</span>.</li>

      <li><span class="math">\\text{Verify}(\\text{vk},\\mu,\\sigma)\\to b</span>: On input the verification key vk, a message <span class="math">\\mu\\in\\mathcal{M}</span>, and a signature <span class="math">\\sigma</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Moreover, the above algorithms should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For all security parameters <span class="math">\\lambda\\in\\mathbb{N}</span> and messages <span class="math">\\mu\\in\\mathcal{M}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Verify}(\\text{vk},\\mu,\\sigma)=1:(\\text{sk},\\text{vk})\\leftarrow\\text{KeyGen}(1^{\\lambda});\\sigma\\leftarrow\\text{Sign}(\\text{sk},\\mu)]=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unforgeability: Define the signature unforgeability game between an adversary <span class="math">\\mathcal{A}</span> and a challenger as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger samples <span class="math">(\\text{sk},\\text{vk})\\leftarrow\\text{KeyGen}(1^{\\lambda})</span> and gives <span class="math">\\text{vk}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>The adversary can now make signing queries on messages <span class="math">\\mu\\in\\mathcal{M}</span> of its choosing. On each query <span class="math">\\mu</span>, the challenger replies with <span class="math">\\text{Sign}(\\text{sk},\\mu)</span>.</li>

      <li>At the end of the game, the adversary outputs a message-signature pair <span class="math">(\\mu^{<em>},\\sigma^{</em>})</span>. The output of the game is <span class="math">1</span> if <span class="math">\\text{Verify}(\\text{vk},\\mu^{<em>},\\sigma^{</em>})=1</span> and the adversary did not make a signing query on <span class="math">\\mu^{*}</span>. Otherwise, the output is <span class="math">0</span>.</li>

    </ul>

    <p class="text-gray-300">We say <span class="math">\\Pi_{\\text{Sig}}</span> is unforgeable if for all efficient adversaries, there exists a negligible function <span class="math">\\text{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\Pr[b=1]=\\text{negl}(\\lambda)</span> in the above unforgeability game.</p>

    <h6 id="sec-129" class="text-base font-medium mt-4">Definition 7.2 (Aggregate Signature <em>[x10, adapted]</em>).</h6>

    <p class="text-gray-300">A bounded aggregate signature scheme with message space <span class="math">\\mathcal{M}</span> is a tuple of efficient algorithms <span class="math">\\Pi_{\\text{AggSig}}=(\\text{Setup},\\text{KeyGen},\\text{Sign},\\text{Verify},\\text{Aggregate},\\text{AggVerify})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(1^{\\lambda},1^{m})\\rightarrow\\text{pp}</span>: On input the security parameter <span class="math">\\lambda</span> and an aggregation bound <span class="math">m</span>, the setup algorithm outputs the public parameters <span class="math">\\text{pp}</span>.</li>

      <li><span class="math">\\text{KeyGen}(\\text{pp})\\rightarrow(\\text{sk},\\text{vk})</span>: On input the public parameters <span class="math">\\text{pp}</span>, the key-generation algorithm outputs a signing key <span class="math">\\text{sk}</span> and a verification key <span class="math">\\text{vk}</span>.</li>

      <li><span class="math">\\text{Sign}(\\text{pp},\\text{sk},\\mu)\\rightarrow\\sigma</span>: On input the public parameters <span class="math">\\text{pp}</span>, the signing key <span class="math">\\text{sk}</span>, and a message <span class="math">\\mu\\in\\mathcal{M}</span>, the signing algorithm outputs a signature <span class="math">\\sigma</span>.</li>

      <li><span class="math">\\text{Verify}(\\text{pp},\\text{vk},\\mu,\\sigma)\\rightarrow b</span>: On input the public parameters <span class="math">\\text{pp}</span>, the verification key <span class="math">\\text{vk}</span>, a message <span class="math">\\mu\\in\\mathcal{M}</span>, and a signature <span class="math">\\sigma</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

      <li><span class="math">\\text{Aggregate}(\\text{pp},\\{(\\text{vk}_{i},\\mu_{i},\\sigma_{i})\\}_{i\\in[T]})\\rightarrow\\sigma_{\\text{agg}}</span>: On input the public parameters <span class="math">\\text{pp}</span>, and a collection of up to <span class="math">T\\leq m</span> verification keys <span class="math">\\text{vk}_{i}</span>, messages <span class="math">\\mu_{i}</span>, and signatures <span class="math">\\sigma_{i}</span>, the aggregation algorithm outputs an aggregate signature <span class="math">\\sigma_{\\text{agg}}</span>.</li>

      <li><span class="math">\\text{AggVerify}(\\text{pp},(\\text{vk}_{1},\\ldots,\\text{vk}_{T}),(\\mu_{1},\\ldots,\\mu_{T}),\\sigma_{\\text{agg}})\\rightarrow b</span>: On input the public parameters <span class="math">\\text{pp}</span>, a collection of <span class="math">T\\leq m</span> verification keys <span class="math">\\text{vk}_{i}</span> and messages <span class="math">\\mu_{i}</span>, and an aggregate signature <span class="math">\\sigma_{\\text{agg}}</span>, the aggregate verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, the above algorithms should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For all security parameters <span class="math">\\lambda\\in\\mathbb{N}</span>, all values <span class="math">m\\in\\mathbb{N}</span>, all messages <span class="math">\\mu\\in\\mathcal{M}</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\text{Verify}(\\text{pp},\\text{vk},\\mu,\\sigma)=1:\\begin{array}[]{c}\\text{pp}\\leftarrow\\text{Setup}(1^{\\lambda},1^{m});\\\\ (\\text{sk},\\text{vk})\\leftarrow\\text{KeyGen}(\\text{pp});\\sigma\\leftarrow\\text{Sign}(\\text{pp},\\text{sk},\\mu)\\end{array}\\right]=1. \\]</p>

    <p class="text-gray-300">In addition, for all public parameters <span class="math">\\text{pp}</span> in the support of <span class="math">\\text{Setup}(1^{\\lambda},1^{m})</span> and all collections <span class="math">\\{(\\text{vk}_{i},\\mu_{i},\\sigma_{i})\\}_{i\\in[T]}</span> where <span class="math">T\\leq m</span> and <span class="math">\\text{Verify}(\\text{pp},\\text{vk}_{i},\\mu_{i},\\sigma_{i})=1</span> for all <span class="math">i\\in[T]</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{AggVerify}(\\text{pp},(\\text{vk}_{1},\\ldots,\\text{vk}_{T}),(\\mu_{1},\\ldots,\\mu_{T}),\\sigma_{\\text{agg}})=1:\\sigma_{\\text{agg}}\\leftarrow\\text{Aggregate}(\\text{pp},\\{(\\text{vk}_{i},\\mu_{i},\\sigma_{i})\\}_{i\\in[T]})\\right]=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficiency: There exists a fixed polynomial <span class="math">\\text{poly}(\\cdot,\\cdot)</span> such that in the completeness experiment above, the size of the aggregate signature <span class="math">\\sigma_{\\text{agg}}</span> satisfies <span class="math">\\left[\\sigma_{\\text{agg}}\\right]=\\text{poly}(\\lambda,\\log T)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unforgeability: Define the signature unforgeability game between an adversary <span class="math">\\mathcal{A}</span> and a challenger as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger samples <span class="math">\\mathrm{pp}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{m})</span> and <span class="math">(\\mathrm{vk}^{<em>},\\mathrm{sk}^{</em>})\\leftarrow\\mathrm{KeyGen}(\\mathrm{pp})</span> and gives <span class="math">\\mathrm{pp}</span> and <span class="math">\\mathrm{vk}^{*}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>The adversary can now make signing queries on messages <span class="math">\\mu\\in\\mathcal{M}</span> of its choosing. On each query <span class="math">\\mu</span>, the challenger replies with <span class="math">\\mathrm{Sign}(\\mathrm{pp},\\mathrm{sk}^{*},\\mu)</span>.</li>

      <li>At the end of the game the adversary outputs a tuple of verification keys <span class="math">(\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T})</span>, a tuple of messages <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> with <span class="math">T\\leq m</span>, and a signature <span class="math">\\sigma^{*}</span>.</li>

      <li>The output of the game is <span class="math">1</span> if there exists an index <span class="math">i^{<em>}\\in[T]</span> where <span class="math">\\mathrm{vk}_{i^{</em>}}=\\mathrm{vk}^{<em>}</span>, algorithm <span class="math">\\mathcal{A}</span> did not make a signing query on <span class="math">\\mu_{i^{</em>}}</span>, and <span class="math">\\mathrm{AggVerify}(\\mathrm{pp},(\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T}),(\\mu_{1},\\ldots,\\mu_{T}),\\sigma^{*})=1</span>. Otherwise, the output is <span class="math">0</span>.</li>

    </ul>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{\\mathrm{AggSig}}</span> is unforgeable if for all efficient adversaries <span class="math">\\mathcal{A}</span> and all polynomials <span class="math">m=m(\\lambda)</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\Pr[b=1]=\\mathrm{negl}(\\lambda)</span> in the above unforgeability game.</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Construction 7.3 (Aggregate Signature from BARGs for NP).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathrm{Sig}}=(\\mathrm{Sig.}\\mathrm{KeyGen},\\mathrm{Sig.}\\mathrm{Sign},\\mathrm{Sig.}\\mathrm{Verify})</span> be a digital signature scheme, and let <span class="math">\\Pi_{\\mathrm{BARG}}=(\\mathrm{BARG.}\\mathrm{Setup},\\mathrm{BARG.}\\mathrm{Prove},\\mathrm{BARG.}\\mathrm{Verify})</span> be a <span class="math">\\mathrm{BARG}</span> for <span class="math">\\mathrm{NP}</span>. We require that <span class="math">\\Pi_{\\mathrm{BARG}}</span> supports proving and verifying a variable number <span class="math">T</span> of instances provided that <span class="math">T\\leq m</span> where <span class="math">m</span> is the bound on the total number of instances (see Remark 3.11). We construct a bounded aggregate signature scheme as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Setup}(1^{\\lambda},1^{m})</span>: On input the security parameter <span class="math">\\lambda</span> and the aggregation bound <span class="math">m</span>, let <span class="math">s=s(\\lambda)</span> be the size of the circuit that computes <span class="math">\\mathrm{Sig.}\\mathrm{Verify}</span>. Sample <span class="math">\\mathrm{crs}_{\\mathrm{BARG}}\\leftarrow\\mathrm{BARG.}\\mathrm{Setup}(1^{\\lambda},1^{m},1^{s})</span> and output <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span>.</li>

      <li><span class="math">\\mathrm{KeyGen}(\\mathrm{pp})</span>: On input the public parameters <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span>, output <span class="math">(\\mathrm{sk},\\mathrm{vk})\\leftarrow\\mathrm{Sig.}\\mathrm{KeyGen}(1^{\\lambda})</span>.</li>

      <li><span class="math">\\mathrm{Sign}(\\mathrm{pp},\\mathrm{sk},\\mu)</span>: On input the public parameters <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span>, the signing key <span class="math">\\mathrm{sk}</span>, and the message <span class="math">\\mu\\in\\mathcal{M}</span>, output <span class="math">\\sigma\\leftarrow\\mathrm{Sig.}\\mathrm{Sign}(\\mathrm{sk},\\mu)</span>.</li>

      <li><span class="math">\\mathrm{Verify}(\\mathrm{pp},\\mathrm{vk},\\mu,\\sigma)</span>: On input the public parameters <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span>, the verification key <span class="math">\\mathrm{vk}</span>, the message <span class="math">\\mu\\in\\mathcal{M}</span>, and the signature <span class="math">\\sigma</span>, output <span class="math">\\mathrm{Sig.}\\mathrm{Verify}(\\mathrm{vk},\\mu,\\sigma)</span>.</li>

      <li>Aggregate(pp, <span class="math">\\{(\\mathrm{vk}_{i},\\mu_{i},\\sigma_{i})\\}_{i\\in[T]}</span>): On input the public parameters <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span> and a collection of tuples <span class="math">\\{(\\mathrm{vk}_{i},\\mu_{i},\\sigma_{i})\\}_{i\\in[T]}</span>, the aggregation algorithm computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi\\leftarrow\\mathrm{BARG.}\\mathrm{Prove}(\\mathrm{crs}_{\\mathrm{BARG}},C_{\\mathrm{Ver}},((\\mathrm{vk}_{1},\\mu_{1}),\\ldots,(\\mathrm{vk}_{T},\\mu_{T})),(\\sigma_{1},\\ldots,\\sigma_{T})),</span></p>

    <p class="text-gray-300">where <span class="math">C_{\\mathrm{Ver}}</span> is the Boolean circuit that computes <span class="math">C_{\\mathrm{Ver}}((\\mathrm{vk},\\mu),\\sigma)\\coloneqq\\mathrm{Sig.}\\mathrm{Verify}(\\mathrm{vk},\\mu,\\sigma)</span>. The aggregated signature is the proof <span class="math">\\sigma_{\\mathrm{agg}}=\\pi</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{AggVerify}(\\mathrm{pp},(\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T}),(\\mu_{1},\\ldots,\\mu_{T}),\\sigma_{\\mathrm{agg}})</span>: On input the public parameters <span class="math">\\mathrm{pp}=(1^{\\lambda},\\mathrm{crs}_{\\mathrm{BARG}})</span>, verification keys <span class="math">\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T}</span>, messages <span class="math">\\mu_{1},\\ldots,\\mu_{T}\\in\\mathcal{M}</span>, and a signature <span class="math">\\sigma_{\\mathrm{agg}}</span>, output</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{BARG.}\\mathrm{Verify}(\\mathrm{crs}_{\\mathrm{BARG}},C_{\\mathrm{Ver}},((\\mathrm{vk}_{1},\\mu_{1}),\\ldots,(\\mathrm{vk}_{T},\\mu_{T})),\\sigma_{\\mathrm{agg}}).</span></p>

    <h6 id="sec-131" class="text-base font-medium mt-4">Theorem 7.4 (Completeness).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{Sig}}</span> is correct and <span class="math">\\Pi_{\\mathrm{BARG}}</span> is complete, then Construction 7.3 is correct.</p>

    <h6 id="sec-132" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows by construction. ∎</p>

    <h6 id="sec-133" class="text-base font-medium mt-4">Theorem 7.5 (Efficiency).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{BARG}}</span> is succinct, then Construction 7.3 is efficient.</p>

    <h6 id="sec-134" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The aggregate signature in 7.3 is a <span class="math">\\mathrm{BARG}</span> proof. Succinctness of the <span class="math">\\mathrm{BARG}</span> ensures that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{\\mathrm{agg}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{poly}(\\lambda,\\log m,s)=\\mathrm{poly}(\\lambda,\\log m)<span class="math">, since </span>s=s(\\lambda)<span class="math"> is the size of the verification circuit </span>C_{\\mathrm{Ver}}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-135" class="text-base font-medium mt-4">Theorem 7.6 (Unforgeability).</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{BARG}}</span> is a somewhere argument of knowledge and <span class="math">\\Pi_{\\mathrm{Sig}}</span> is unforgeable, then 7.3 is unforgeable.</p>

    <h6 id="sec-136" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We proceed using a hybrid argument:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{0}</span>: This is the real signature unforgeability game:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the beginning of the game, the challenger samples <span class="math">\\mathsf{crs}_{\\mathsf{BARG}}\\leftarrow\\mathsf{BARG}.Setup(1^{\\lambda},1^{m},1^{s})</span> and sets <span class="math">\\mathsf{pp}=(1^{\\lambda},\\mathsf{crs}_{\\mathsf{BARG}})</span>. It also samples <span class="math">(\\mathsf{vk},\\mathsf{sk})\\leftarrow\\mathsf{Sig}.KeyGen(1^{\\lambda})</span>, and gives <span class="math">\\mathsf{pp},\\mathsf{vk}</span> to the adversary <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> can then make signing queries on messages <span class="math">\\mu\\in\\mathcal{M}</span> and the challenger replies with <span class="math">\\sigma\\leftarrow\\mathsf{Sig}.Sign(\\mathsf{sk},\\mu)</span>.</li>

      <li>At the end of the game the adversary outputs a tuple of verification keys <span class="math">(\\mathsf{vk}_{1},\\ldots,\\mathsf{vk}_{T})</span>, a tuple of messages <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> with <span class="math">T\\leq m</span>, and a signature <span class="math">\\sigma^{*}</span>.</li>

      <li>The output of the experiment is <span class="math">1</span> if there exists an index <span class="math">i^{<em>}\\in[T]</span> where <span class="math">\\mathsf{vk}_{i^{</em>}}=\\mathsf{vk}^{<em>}</span>, algorithm <span class="math">\\mathcal{A}</span> did not make a signing query on <span class="math">\\mu_{i^{</em>}}</span>, and <span class="math">\\mathsf{BARG}.Verify(\\mathsf{crs}_{\\mathsf{BARG}},C_{\\mathsf{Ver}},((\\mathsf{vk}_{1},\\mu_{1}),\\ldots,(\\mathsf{vk}_{T},\\mu_{T})),\\sigma^{*})=1</span>. Otherwise, the output is <span class="math">0</span>.</li>

      <li><span class="math">\\mathsf{Hyb}_{1}</span>: In this experiment, the challenger starts by guessing an index <span class="math">j^{<em>}\\stackrel{{\\scriptstyle\\mathsf{B}}}{{\\leftarrow}}[m]</span>. The rest of the experiment then proceeds as in <span class="math">\\mathsf{Hyb}_{0}</span>. After the adversary outputs <span class="math">(\\mathsf{vk}_{1},\\ldots,\\mathsf{vk}_{T})</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> and <span class="math">\\sigma^{</em>}</span>, the output of the experiment is <span class="math">1</span> if <span class="math">\\mathsf{vk}_{j^{<em>}}=\\mathsf{vk}^{</em>}</span>, algorithm <span class="math">\\mathcal{A}</span> did not make a signing query on <span class="math">\\mu_{j^{*}}</span>, and</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{BARG}.Verify(\\mathsf{crs}_{\\mathsf{BARG}},C_{\\mathsf{Ver}},((\\mathsf{vk}_{1},\\mu_{1}),\\ldots,(\\mathsf{vk}_{T},\\mu_{T})),\\sigma^{*})=1.</span></p>

    <p class="text-gray-300">Otherwise, the output is <span class="math">0</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{2}</span>: Same as <span class="math">\\mathsf{Hyb}_{1}</span>, except the challenger uses the <span class="math">\\mathsf{BARG}</span> trapdoor sampling algorithm to sample <span class="math">\\mathsf{crs}_{\\mathsf{BARG}}</span>. In particular, after sampling <span class="math">j^{<em>}\\stackrel{{\\scriptstyle\\mathsf{B}}}{{\\leftarrow}}[m]</span>, the challenger samples <span class="math">(\\mathsf{crs}_{\\mathsf{BARG}},\\mathsf{td}_{\\mathsf{BARG}})\\leftarrow\\mathsf{BARG}.TrapSetup(1^{\\lambda},1^{m},1^{s},j^{</em>})</span>. Everything else is the same as in <span class="math">\\mathsf{Hyb}_{1}</span>.</li>

      <li><span class="math">\\mathsf{Hyb}_{3}</span>: Same as <span class="math">\\mathsf{Hyb}_{2}</span> except at the end of the experiment, the challenger additionally computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\hat{\\sigma}\\leftarrow\\mathsf{BARG}.Extract(\\mathsf{td}_{\\mathsf{BARG}},C_{\\mathsf{Ver}},((\\mathsf{vk}_{1},\\mu_{1}),\\ldots,(\\mathsf{vk}_{T},\\mu_{T})),\\sigma^{*}).</span></p>

    <p class="text-gray-300">If <span class="math">C_{\\mathsf{Ver}}(\\mathsf{vk}_{j^{<em>}},\\mu_{j^{</em>}},\\hat{\\sigma})\\neq 1</span>, then the output of the game is <span class="math">0</span>. Otherwise, the output is the same as in <span class="math">\\mathsf{Hyb}_{2}</span>.</p>

    <p class="text-gray-300">For an adversary <span class="math">\\mathcal{A}</span>, we write <span class="math">\\mathsf{Hyb}_{i}(\\mathcal{A})</span> to denote the output of an execution of experiment <span class="math">\\mathsf{Hyb}_{i}</span> with adversary <span class="math">\\mathcal{A}</span>. Our goal is to show that for all efficient adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\Pr[\\mathsf{Hyb}_{0}(\\mathcal{A})=1]=\\mathsf{negl}(\\lambda)</span>.</p>

    <h6 id="sec-137" class="text-base font-medium mt-4">Lemma 7.7.</h6>

    <p class="text-gray-300">For all adversaries <span class="math">\\mathcal{A}</span>, we have that <span class="math">\\Pr[\\mathsf{Hyb}_{1}(\\mathcal{A})=1]\\geq\\frac{1}{m}\\Pr[\\mathsf{Hyb}_{0}(\\mathcal{A})=1]</span>.</p>

    <h6 id="sec-138" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By construction, the views of the adversary in <span class="math">\\mathsf{Hyb}_{0}</span> and <span class="math">\\mathsf{Hyb}_{1}</span> are identical. The only difference is in how the output of the experiment is computed. Suppose <span class="math">\\Pr[\\mathsf{Hyb}_{0}(\\mathcal{A})=1]=\\varepsilon</span>. Then, with probability <span class="math">\\varepsilon</span>, algorithm <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\mathsf{vk}_{1},\\ldots,\\mathsf{vk}_{T})</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> and <span class="math">\\sigma^{<em>}</span> where there exists an index <span class="math">i^{</em>}\\in[T]</span> satisfying the listed properties with probability at least <span class="math">\\varepsilon</span>. This is also the case in <span class="math">\\mathsf{Hyb}_{1}</span>. Here, if <span class="math">j^{<em>}=i^{</em>}</span>, then the output in <span class="math">\\mathsf{Hyb}_{1}(\\mathcal{A})</span> is also <span class="math">1</span>. Since <span class="math">j^{*}</span> is uniform, this happens with probability at least <span class="math">\\varepsilon/m</span> and the lemma holds. ∎</p>

    <h6 id="sec-139" class="text-base font-medium mt-4">Lemma 7.8.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathsf{BARG}}</span> is a somewhere argument of knowledge (specifically, the CRS indistinguishability property holds), then for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{Hyb}_{1}(\\mathcal{A})=1]-\\Pr[\\mathsf{Hyb}_{2}(\\mathcal{A})=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-140" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This is immediate by CRS indistinguishability. Namely, the only difference between <span class="math">\\mathsf{Hyb}_{1}</span> and <span class="math">\\mathsf{Hyb}_{2}</span> is that the challenger samples <span class="math">\\mathsf{crs}_{\\mathsf{BARG}}</span> using <span class="math">\\mathsf{BARG}.Setup(1^{\\lambda},1^{m},1^{s})</span> in <span class="math">\\mathsf{Hyb}_{1}</span> and <span class="math">\\mathsf{BARG}.TrapSetup(1^{\\lambda},1^{m},1^{s},j^{*})</span> in <span class="math">\\mathsf{Hyb}_{2}</span>. By CRS indistinguishability, these two distributions are computationally indistinguishable. Moreover, the output bit in <span class="math">\\mathsf{Hyb}_{1}</span> and <span class="math">\\mathsf{Hyb}_{2}</span> can be efficiently computed from <span class="math">\\mathsf{crs}_{\\mathsf{BARG}}</span> and the adversary’s output. ∎</p>

    <h6 id="sec-141" class="text-base font-medium mt-4">Lemma 7.9.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathsf{BARG}}</span> is a somewhere argument of knowledge (specifically, the extractability in trapdoor mode property holds), then for all adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{Hyb}_{3}(\\mathcal{A})=1]-\\Pr[\\mathsf{Hyb}_{2}(\\mathcal{A})=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-142" class="text-base font-medium mt-4">Proof.</h6>

    <h6 id="sec-143" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The only difference between <span class="math">\\mathrm{Hyb}_{2}</span> and <span class="math">\\mathrm{Hyb}_{3}</span> is the extra check the challenger performs in <span class="math">\\mathrm{Hyb}_{3}</span>. Namely, in order for <span class="math">\\mathrm{Hyb}_{2}</span> to output <span class="math">1</span>, but <span class="math">\\mathrm{Hyb}_{3}</span> to output <span class="math">0</span>, it must be the case that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{BARG.Verify(crs_{BARG},C_{Ver},((vk_{1},\\mu_{1}),\\ldots,(vk_{T},\\mu_{T}))},\\sigma^{*})=1</span>; and</li>

      <li><span class="math">C_{\\mathrm{Ver}}(\\mathrm{vk}_{j^{<em>}},\\mu_{j^{</em>}},\\hat{\\sigma})\\neq 1</span> where <span class="math">\\hat{\\sigma}\\leftarrow\\mathrm{BARG.Extract(td_{BARG},C_{Ver},((vk_{1},\\mu_{1}),\\ldots,(vk_{T},\\mu_{T}))},\\sigma^{*})</span>.</li>

    </ul>

    <p class="text-gray-300">In <span class="math">\\mathrm{Hyb}_{2}</span> and <span class="math">\\mathrm{Hyb}_{3}</span>, <span class="math">\\mathrm{crs_{BARG}}</span> is sampled using <span class="math">\\mathrm{BARG.TrapSetup}(1^{\\lambda},1^{m},1^{s},j^{*})</span>, so any adversary <span class="math">\\mathcal{A}</span> that produces an output that successfully triggers both of the above conditions with advantage <span class="math">\\varepsilon</span> also breaks somewhere extractability in trapdoor mode property with identical advantage. ∎</p>

    <h6 id="sec-144" class="text-base font-medium mt-4">Lemma 7.10.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi_{\\mathrm{Sig}}</span> is unforgeable, then for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathrm{Pr}[\\mathrm{Hyb}_{3}(\\mathcal{A})=1]=\\mathrm{negl}(\\lambda)</span>.</p>

    <h6 id="sec-145" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose there exists an efficient algorithm <span class="math">\\mathcal{A}</span> where <span class="math">\\mathrm{Pr}[\\mathrm{Hyb}_{3}(\\mathcal{A})=1]=\\varepsilon</span> for some non-negligible <span class="math">\\varepsilon</span>. We use <span class="math">\\mathcal{A}</span> to build an algorithm <span class="math">\\mathcal{B}</span> that breaks unforgeability of <span class="math">\\Pi_{\\mathrm{Sig}}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{B}</span> receives the verification key <span class="math">\\mathrm{vk}^{*}</span> from its challenger.</li>

      <li>Algorithm <span class="math">\\mathcal{B}</span> starts by sampling <span class="math">j^{<em>}\\stackrel{{\\scriptstyle\\mathtt{B}}}{{\\leftarrow}}[m]</span> and <span class="math">(\\mathrm{crs_{BARG}},\\mathrm{td_{BARG}})\\leftarrow\\mathrm{BARG.TrapSetup}(1^{\\lambda},1^{m},1^{s},j^{</em>})</span>. It sets <span class="math">\\mathrm{pp}\\leftarrow(1^{\\lambda},\\mathrm{crs_{BARG}})</span> and gives <span class="math">\\mathrm{pp}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Whenever algorithm <span class="math">\\mathcal{A}</span> makes a signing query on a message <span class="math">\\mu\\in\\mathcal{M}</span>, algorithm <span class="math">\\mathcal{B}</span> makes a signing query on <span class="math">\\mu</span> and obtains a signature <span class="math">\\sigma</span>. It replies to <span class="math">\\mathcal{A}</span> with the signature <span class="math">\\sigma</span>.</li>

      <li>At the end of the game, algorithm <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T})</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> and <span class="math">\\sigma^{<em>}</span>. Algorithm <span class="math">\\mathcal{B}</span> checks that <span class="math">\\mathrm{vk}_{j^{</em>}}=\\mathrm{vk}^{<em>}</span>, algorithm <span class="math">\\mathcal{A}</span> did not issue a signing query on <span class="math">\\mu_{j^{</em>}}</span>, and that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{BARG.Verify(crs_{BARG},C_{Ver},((vk_{1},\\mu_{1}),\\ldots,(vk_{T},\\mu_{T}))},\\sigma^{*})=1.</span></p>

    <p class="text-gray-300">If any checks do not pass, algorithm <span class="math">\\mathcal{B}</span> aborts with output <span class="math">\\bot</span>. Otherwise, it computes</p>

    <p class="text-gray-300"><span class="math">\\hat{\\sigma}\\leftarrow\\mathrm{BARG.Extract(td_{BARG},C_{Ver},((vk_{1},\\mu_{1}),\\ldots,(vk_{T},\\mu_{T}))},\\sigma^{*})</span></p>

    <p class="text-gray-300">and outputs <span class="math">\\mu_{j^{*}},\\hat{\\sigma}</span> as its forgery.</p>

    <p class="text-gray-300">By construction, algorithm <span class="math">\\mathcal{B}</span> perfectly simulates an execution of <span class="math">\\mathrm{Hyb}_{3}</span> for <span class="math">\\mathcal{A}</span>. Thus, with probability at least <span class="math">\\varepsilon</span>, algorithm <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\mathrm{vk}_{1},\\ldots,\\mathrm{vk}_{T})</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{T})</span> and <span class="math">\\sigma^{<em>}</span> where <span class="math">\\mathrm{vk}_{j^{</em>}}=\\mathrm{vk}^{<em>}</span>, the adversary never queried the signing oracle on <span class="math">\\mu_{j^{</em>}}</span>, and <span class="math">C_{\\mathrm{Ver}}(\\mathrm{vk}_{j^{<em>}},\\mu_{j^{</em>}},\\hat{\\sigma})=1</span>. Since <span class="math">C_{\\mathrm{Ver}}</span> is the verification circuit, this means that <span class="math">\\hat{\\sigma}</span> is a valid signature on <span class="math">\\mu_{j^{*}}</span>, and so algorithm <span class="math">\\mathcal{B}</span> succeeds with the same advantage <span class="math">\\varepsilon</span>. ∎</p>

    <p class="text-gray-300">By Lemmas 7.8 to 7.10, we have that for all efficient adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\mathrm{Pr}[\\mathrm{Hyb}_{1}(\\mathcal{A})=1]=\\mathrm{negl}(\\lambda)</span>. By Lemma 7.7, this means that <span class="math">\\mathrm{Pr}[\\mathrm{Hyb}_{0}(\\mathcal{A})=1]\\leq m\\cdot\\mathrm{Pr}[\\mathrm{Hyb}_{1}(\\mathcal{A})=1]=\\mathrm{negl}(\\lambda)</span> since <span class="math">m=\\mathrm{poly}(\\lambda)</span>. ∎</p>

    <h6 id="sec-146" class="text-base font-medium mt-4">Corollary 7.11 (Bounded Aggregate Signature from Pairings).</h6>

    <p class="text-gray-300">For any constant <span class="math">k\\geq 1</span>, if the <span class="math">k</span>-<span class="math">\\mathrm{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to a prime-order group generator <span class="math">\\mathrm{GroupGen}</span> (or alternatively, if the subgroup decision assumption holds with respect to a composite-order group generator <span class="math">\\mathrm{CompGroupGen}</span>), then for all constants <span class="math">\\varepsilon&gt;0</span>, there exists an bounded aggregate signature scheme with public parameter size <span class="math">m^{\\varepsilon}\\cdot\\mathrm{poly}(\\lambda)</span>, where <span class="math">m</span> is the aggregation bound.</p>

    <h3 id="sec-147" class="text-xl font-semibold mt-8">Acknowledgments</h3>

    <p class="text-gray-300">B. Waters is supported by NSF CNS-1908611, a Simons Investigator award, and the Packard Foundation Fellowship. D. J. Wu is supported by NSF CNS-1917414, CNS-2045180, a Microsoft Research Faculty Fellowship, and a Google Research Scholar award.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGH10] Jae Hyun Ahn, Matthew Green, and Susan Hohenberger. Synchronized aggregate signatures: new definitions, constructions and applications. In ACM CCS, 2010.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., 2018, 2018.</li>

      <li>[BBS04] Dan Boneh, Xavier Boyen, and Hovav Shacham. Short group signatures. In CRYPTO, 2004.</li>

      <li>[BCC^{+}17] Nir Bitansky, Ran Canetti, Alessandro Chiesa, Shafi Goldwasser, Huijia Lin, Aviad Rubinstein, and Eran Tromer. The hunting of the SNARK. J. Cryptol., 30(4), 2017.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In ITCS, 2012.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In STOC, 2013.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC, 2013.</li>

      <li>[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In STOC, 2014.</li>

      <li>[BGLS03] Dan Boneh, Craig Gentry, Ben Lynn, and Hovav Shacham. Aggregate and verifiably encrypted signatures from bilinear maps. In EUROCRYPT, 2003.</li>

      <li>[BGN05] Dan Boneh, Eu-Jin Goh, and Kobbi Nissim. Evaluating 2-DNF formulas on ciphertexts. In TCC, 2005.</li>

      <li>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai. Non-interactive delegation and batch NP verification from standard computational assumptions. In STOC, 2017.</li>

      <li>[BISW17] Dan Boneh, Yuval Ishai, Amit Sahai, and David J. Wu. Lattice-based SNARGs and their application to more efficient obfuscation. In EUROCRYPT, 2017.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In STOC, 2019.</li>

      <li>[CF13] Dario Catalano and Dario Fiore. Vector commitments and their applications. In PKC, 2013.</li>

      <li>[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited (preliminary version). In STOC, 1998.</li>

      <li>[CHM^{+}20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In EUROCRYPT, 2020.</li>

      <li>[CJJ21a] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. Non-interactive batch arguments for NP from standard assumptions. In CRYPTO, 2021.</li>

      <li>[CJJ21b] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. SNARGs for P from LWE. In FOCS, 2021.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In EUROCRYPT, 2020.</li>

      <li>[DFH12] Ivan Damgård, Sebastian Faust, and Carmit Hazay. Secure two-party computation with low communication. In TCC, 2012.</li>

    </ul>

    <p class="text-gray-300">[EHK^{+}13] Alex Escala, Gottfried Herold, Eike Kiltz, Carla Ràfols, and Jorge L. Villar. An algebraic framework for Diffie-Hellman assumptions. In CRYPTO, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FHPS13] Eduarda S. V. Freire, Dennis Hofheinz, Kenneth G. Paterson, and Christoph Striecks. Programmable hash functions in the multilinear setting. In CRYPTO, 2013.</li>

      <li>[Fre10] David Mandell Freeman. Converting pairing-based cryptosystems from composite-order groups to prime-order groups. In EUROCRYPT, 2010.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, 1986.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In EUROCRYPT, 2013.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In STOC, 2008.</li>

      <li>[GOS06] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In EUROCRYPT, 2006.</li>

      <li>[GR06] Craig Gentry and Zulfikar Ramzan. Identity-based aggregate signatures. In PKC, 2006.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, 2010.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT, 2016.</li>

      <li>[GS08] Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In EUROCRYPT, 2008.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC, 2011.</li>

      <li>[GZ21] Alonso González and Alexandros Zacharakis. Succinct publicly verifiable computation. In TCC, 2021.</li>

      <li>[HJKS22] James Hulett, Ruta Jawale, Dakshita Khurana, and Akshayaram Srinivasan. Snargs for P from sub-exponential DDH and QR. In EUROCRYPT, 2022.</li>

      <li>[HK07] Dennis Hofheinz and Eike Kiltz. Secure hybrid encryption from weakened key encapsulation. In CRYPTO, 2007.</li>

      <li>[HKW15] Susan Hohenberger, Venkata Koppula, and Brent Waters. Universal signature aggregators. In EUROCRYPT, 2015.</li>

      <li>[HW15] Pavel Hubácek and Daniel Wichs. On the communication complexity of secure function evaluation with long output. In ITCS, 2015.</li>

      <li>[HW18] Susan Hohenberger and Brent Waters. Synchronized aggregate signatures from the RSA assumption. In EUROCRYPT, 2018.</li>

      <li>[JJ21] Abhishek Jain and Zhengzhong Jin. Non-interactive zero knowledge from sub-exponential DDH. In EUROCRYPT, 2021.</li>

      <li>[JKKZ21] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Yun Zhang. SNARGs for bounded depth computations and PPAD hardness from sub-exponential LWE. In STOC, 2021.</li>

      <li>[KP16] Yael Tauman Kalai and Omer Paneth. Delegating RAM computations. In TCC, 2016.</li>

      <li>[KPY19] Yael Tauman Kalai, Omer Paneth, and Lisa Yang. How to delegate computations publicly. In STOC, 2019.</li>

    </ul>

    <p class="text-gray-300">[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In STOC, 2013.</p>

    <p class="text-gray-300">[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. How to delegate computations: the power of no-signaling proofs. In STOC, 2014.</p>

    <p class="text-gray-300">[KVZ21] Yael Tauman Kalai, Vinod Vaikuntanathan, and Rachel Yun Zhang. Somewhere statistical soundness, post-quantum security, and SNARGs. In TCC, 2021.</p>

    <p class="text-gray-300">[LFKN90] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In FOCS, 1990.</p>

    <p class="text-gray-300">[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In ASIACRYPT, 2013.</p>

    <p class="text-gray-300">[LMRS04] Anna Lysyanskaya, Silvio Micali, Leonid Reyzin, and Hovav Shacham. Sequential aggregate signatures from trapdoor permutations. In EUROCRYPT, 2004.</p>

    <p class="text-gray-300">[LOS*06] Steve Lu, Rafail Ostrovsky, Amit Sahai, Hovav Shacham, and Brent Waters. Sequential aggregate signatures and multisignatures without random oracles. In EUROCRYPT, 2006.</p>

    <p class="text-gray-300">[LP21] Helger Lipmaa and Kateryna Pavlyk. Gentry-Wichs is tight: a falsifiable non-adaptively sound SNARG. In ASIACRYPT, 2021.</p>

    <p class="text-gray-300">[LPWW20] Benoît Libert, Alain Passelègue, Hoeteck Wee, and David J. Wu. New constructions of statistical NIZKs: Dual-mode DV-NIZKs and more. In EUROCRYPT, 2020.</p>

    <p class="text-gray-300">[Mic95] Silvio Micali. Computationally-sound proofs. In Proceedings of the Annual European Summer Meeting of the Association of Symbolic Logic, 1995.</p>

    <p class="text-gray-300">[Nao03] Moni Naor. On cryptographic assumptions and challenges. In CRYPTO, 2003.</p>

    <p class="text-gray-300">[OPWW15] Tatsuaki Okamoto, Krzysztof Pietrzak, Brent Waters, and Daniel Wichs. New realizations of somewhere statistically binding hashing and positional accumulators. In ASIACRYPT, 2015.</p>

    <p class="text-gray-300">[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, 2013.</p>

    <p class="text-gray-300">[PS19] Chris Peikert and Sina Shiehian. Noninteractive zero knowledge for NP from (plain) learning with errors. In CRYPTO, 2019.</p>

    <p class="text-gray-300">[RR20] Guy N. Rothblum and Ron D. Rothblum. Batch verification and proofs of proximity with polylog overhead. In TCC, 2020.</p>

    <p class="text-gray-300">[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In STOC, 2016.</p>

    <p class="text-gray-300">[RRR18] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Efficient batch verification for UP. In CCC, 2018.</p>

    <p class="text-gray-300">[RS09] Markus Rückert and Dominique Schröder. Aggregate and verifiably encrypted signatures from multilinear maps without random oracles. In ISA, 2009.</p>

    <p class="text-gray-300">[Set20] Srinath T. V. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In CRYPTO, 2020.</p>

    <p class="text-gray-300">[Sha90] Adi Shamir. IP=PSPACE. In FOCS, 1990.</p>

    <p class="text-gray-300">[Sha07] Hovav Shacham. A Cramer-Shoup encryption scheme from the linear assumption and from progressively weaker linear variants. IACR Cryptol. ePrint Arch., 2007.</p>

    <p class="text-gray-300">54</p>

    <p class="text-gray-300">[SW14] Amit Sahai and Brent Waters. How to use indistinguishability obfuscation: deniable encryption, and more. In STOC, 2014.</p>

    <p class="text-gray-300">[Wic22] Daniel Wichs, 2022. Personal communication.</p>

    <p class="text-gray-300">As discussed in Section 1.2.2, it is straightforward to generalize our BARG constructions (Constructions 3.3 and 4.5) to achieve better efficiency when the statements  <span class="math">(\\mathbf{x}_1,\\dots ,\\mathbf{x}_m)</span>  admit a more compact representation. For instance, when using BARGs to construct delegation schemes [CJJ21b, KVZ21], the underlying statements indeed have a succinct description. In our setting, we show how to achieve better efficiency when some of the bits of the statements  <span class="math">\\mathbf{x}_1,\\ldots ,\\mathbf{x}_m</span>  are a priori fixed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. For a bit string  <span class="math">\\mathbf{x} \\in \\{0,1\\}^n</span>  and a set  <span class="math">S \\subseteq [n]</span> , we write  $\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  to denote the subset of bits indexed by  </span>S<span class="math"> :  </span>\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S := (x_i \\mid i \\in S) \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition A.1 (Batch Circuit Satisfiability with Constraints). Let  <span class="math">C \\colon \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span>  be a Boolean circuit and  <span class="math">m \\in \\mathbb{N}</span>  be the number of instances. A fixed-wire constraint  <span class="math">\\varphi</span>  for  <span class="math">C</span>  is a pair  <span class="math">(j,\\sigma)</span>  where  <span class="math">j \\in [n]</span>  is an index and  <span class="math">\\sigma = (\\sigma_1,\\dots,\\sigma_m) \\in \\{0,1\\}^m</span>  is an assignment. We say that a tuple of statements  <span class="math">(\\mathbf{x}_1,\\dots,\\mathbf{x}_m)</span>  satisfies  <span class="math">\\varphi</span>  if  <span class="math">\\mathbf{x}_{i,j} = \\sigma_i</span>  for all  <span class="math">i \\in [m]</span> ; we denote this by writing  <span class="math">\\varphi(\\mathbf{x}_1,\\dots,\\mathbf{x}_m) = 1</span> . We will say that a set of constraints  <span class="math">\\Phi</span>  is admissible if it contains at most one constraint for each index  <span class="math">j</span> . Unless otherwise noted, we will only consider admissible sets of constraints. For an admissible set of constraints  <span class="math">\\Phi</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} _ {\\text {B a t c h C S A T}, m, \\Phi} = \\left\\{\\left(C, \\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {m}\\right) \\mid \\left(C, \\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {m}\\right) \\in \\mathcal {L} _ {\\text {B a t c h C S A T}, m} \\text {a n d} \\forall \\varphi \\in \\Phi : \\varphi \\left(\\mathbf {x} _ {1}, \\dots , \\mathbf {x} _ {m}\\right) = 1 \\right\\}</span></div>

    <p class="text-gray-300">to be the batch circuit satisfiability language with fixed-wire constraints. For a collection of fixed-wire constraints  <span class="math">\\Phi = \\{(j,\\sigma)\\mid j\\in [n],\\sigma \\in \\{0,1\\} ^m\\}</span> , we define  <span class="math">A_{\\Phi}\\coloneqq \\{\\sigma \\in \\{0,1\\} ^m\\mid \\exists j:(j,\\sigma)\\in \\Phi \\}</span>  to be the set of assignments associated with  <span class="math">\\Phi</span>  and we define  <span class="math">S_{\\Phi}\\coloneqq \\{j\\in [n]\\mid \\exists \\sigma :(j,\\sigma)\\in \\Phi \\}</span>  to be the set of indices fixed by  <span class="math">\\Phi</span> .</p>

    <p class="text-gray-300">Definition A.2 (Batch Argument with Fixed Wires). A non-interactive batch argument for circuit satisfiability with fixed-wire constraints is a tuple of three efficient algorithms  <span class="math">\\Pi_{\\mathrm{BARG}} = (\\mathrm{Setup}, \\mathrm{Prove}, \\mathrm{Verify})</span>  with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, A) \\to (\\mathrm{crs}, \\mathrm{vk}, \\mathrm{D})</span> : On input the security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> , the number of instances  <span class="math">m \\in \\mathbb{N}</span> , a bound on the circuit size  <span class="math">s \\in \\mathbb{N}</span> , and a collection of fixed-wire assignments  <span class="math">A \\subseteq \\{0, 1\\}^{m}</span> , the setup algorithm outputs a common reference string crs, a verification key vk, and a dictionary  <span class="math">\\mathrm{D} \\colon A \\to \\mathcal{E}</span>  that associates each  <span class="math">\\sigma \\in A</span>  with an encoding from some set  <span class="math">\\mathcal{E}</span>  of encodings.</li>

      <li>Prove(crs, D, C,  <span class="math">\\Phi</span> ,  <span class="math">(\\mathbf{x}_1, \\ldots, \\mathbf{x}_m)</span> ,  <span class="math">(\\mathbf{w}_1, \\ldots, \\mathbf{w}_m)) \\to \\pi</span> : On input the common reference string crs, a dictionary D, a Boolean circuit  <span class="math">C: \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}</span> , a set of fixed-wire constraints  <span class="math">\\Phi</span> , statements  <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span> , and witnesses  <span class="math">\\mathbf{w}_1, \\ldots, \\mathbf{w}_m \\in \\{0, 1\\}^h</span> , the prove algorithm outputs a proof  <span class="math">\\pi</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Verify(vk, C,  $(\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S, \\ldots, \\mathbf{x}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S)<span class="math"> ,  </span>\\{(i, \\mathrm{enc}_i)\\}_{i \\in [n] \\setminus S}<span class="math"> ,  </span>\\pi) \\to b<span class="math"> : On input the verification key vk, a Boolean circuit  </span>C: \\{0, 1\\}^n \\times \\{0, 1\\}^h \\to \\{0, 1\\}<span class="math"> , a collection of statements  </span>\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S, \\ldots, \\mathbf{x}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\in \\{0, 1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  restricted to some set  </span>S \\subseteq [n]<span class="math"> , and a collection of encodings  </span>(i, \\mathrm{enc}_i)^{10}<span class="math">  for the indices  </span>[n] \\setminus S<span class="math"> , and a proof  </span>\\pi<span class="math"> , the verification algorithm outputs a bit  </span>b \\in \\{0, 1\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say  <span class="math">\\Pi_{\\mathrm{BARG}}</span>  is a non-interactive batch argument with fully fixed wires if Verify only takes vk,  <span class="math">C</span> ,  <span class="math">\\{(i,\\mathrm{enc}_i)\\}_{i\\in [n]}</span>  and  <span class="math">\\pi</span>  as input (i.e., the set  <span class="math">S</span>  of non-fixed wires is  <span class="math">S = \\emptyset</span> ).</p>

    <p class="text-gray-300">Definition A.3 (Completeness). A BARG with fixed-wire constraints  <span class="math">\\Pi_{\\mathrm{BARG}} = (\\mathrm{Setup}, \\mathrm{Prove}, \\mathrm{Verify})</span>  is complete if for all  <span class="math">\\lambda, m, s \\in \\mathbb{N}</span> , all Boolean circuits  <span class="math">C: \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span>  of size at most  <span class="math">s</span> , all sets of fixed-wire assignments  <span class="math">A \\subseteq \\{0,1\\}^m</span> , all admissible sets of fixed-wire constraints  <span class="math">\\Phi</span>  whose assignments  <span class="math">A_\\Phi \\subseteq A</span>  are contained</p>

    <p class="text-gray-300">in <span class="math">A</span>, all statements <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_m \\in \\{0, 1\\}^n</span>, all witnesses <span class="math">\\mathbf{w}_1, \\ldots, \\mathbf{w}_m \\in \\{0, 1\\}^h</span> where <span class="math">C(\\mathbf{x}_i, \\mathbf{w}_i) = 1</span> for all <span class="math">i \\in [m]</span> and <span class="math">\\varphi(\\mathbf{x}_1, \\ldots, \\mathbf{x}_m) = 1</span> for all <span class="math">\\varphi \\in \\Phi</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\text{Verify}(\\mathrm{vk}, C, (\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}, \\dots, \\mathbf{x}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}), \\{(j, \\mathrm{D}[\\sigma_j])\\}_{(j, \\sigma_j) \\in \\Phi}, \\pi) = 1, \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">S_{\\Phi} \\subseteq [n]</span> is the set of indices fixed by <span class="math">\\Phi</span>, <span class="math">\\tilde{S}_{\\Phi} = [n] \\setminus S_{\\Phi}</span> is the set of unfixed indices, and we sample (crs, vk, D) <span class="math">\\leftarrow</span> Setup <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, A)</span>, and <span class="math">\\pi \\gets \\text{Prove}(\\text{crs}, \\mathrm{D}, C, (\\mathbf{x}_1, \\ldots, \\mathbf{x}_m), (\\mathbf{w}_1, \\ldots, \\mathbf{w}_m))</span>.</p>

    <p class="text-gray-300"><strong>Definition A.4 (Somewhere Argument of Knowledge).</strong> A BARG with fixed-wire constraints <span class="math">\\Pi_{\\mathrm{BARG}} = (\\mathrm{Setup}, \\mathrm{Prove}, \\mathrm{Verify})</span> is a somewhere argument of knowledge if there exists a pair of efficient algorithms (TrapSetup, Extract) with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>TrapSetup <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, i^{<em>}, A) \\to (\\mathrm{crs}^{</em>}, \\mathrm{vk}^{<em>}, \\mathrm{D}^{</em>}, \\mathrm{td})</span>: On input the security parameter <span class="math">\\lambda \\in \\mathbb{N}</span>, the number of instances <span class="math">m \\in \\mathbb{N}</span>, the size of the circuit <span class="math">s \\in \\mathbb{N}</span>, an index <span class="math">i^{<em>} \\in [m]</span>, and a collection of fixed-wire assignments <span class="math">A \\subseteq \\{0, 1\\}^{m}</span>, the trapdoor setup algorithm outputs a common reference string <span class="math">\\mathrm{crs}^{</em>}</span>, a verification key <span class="math">\\mathrm{vk}^{<em>}</span>, a dictionary <span class="math">\\mathrm{D}^{</em>}</span>, and an extraction trapdoor <span class="math">\\mathrm{td}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Extract $(\\mathrm{td}, C, (\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S, \\ldots, \\mathbf{x}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S), \\{(i, \\mathrm{enc}_i^<em>)\\}_{i \\in [n] \\setminus S}, \\pi) \\to \\mathbf{w}^</em><span class="math">: On input the trapdoor </span>\\mathrm{td}<span class="math">, a collection of statements </span>\\mathbf{x}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S, \\ldots, \\mathbf{x}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S \\in \\{0, 1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> restricted to some set </span>S \\subseteq [n]<span class="math">, a collection of encodings </span>(i, \\mathrm{enc}_i^<em>)<span class="math"> for the indices </span>[n] \\setminus S<span class="math">, and a proof </span>\\pi<span class="math">, the extraction algorithm outputs a witness </span>\\mathbf{w}^</em> \\in \\{0, 1\\}^h$. The extraction algorithm is deterministic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We require (TrapSetup, Extract) to satisfy the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>CRS indistinguishability</strong>: For integers <span class="math">m \\in \\mathbb{N}</span>, <span class="math">s \\in \\mathbb{N}</span>, a bit <span class="math">b \\in \\{0,1\\}</span>, and an adversary <span class="math">\\mathcal{A}</span>, define the CRS indistinguishability experiment <span class="math">\\mathrm{ExptCRS}_{\\mathcal{A}}(\\lambda, m, s, b)</span> as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda}, 1^{m}, 1^{s})</span> outputs a collection of fixed-wire assignments <span class="math">A \\subseteq \\{0, 1\\}^{m}</span> and an index <span class="math">i^{*} \\in [m]</span>.</li>

      <li>If <span class="math">b = 0</span>, the challenger computes and gives (crs, vk, D) <span class="math">\\leftarrow</span> Setup <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, A)</span> to <span class="math">\\mathcal{A}</span>. If <span class="math">b = 1</span>, the challenger computes <span class="math">(\\mathrm{crs}^{<em>}, \\mathrm{vk}^{</em>}, \\mathrm{D}^{<em>}, \\mathrm{td}) \\leftarrow</span> TrapSetup <span class="math">(1^{\\lambda}, 1^{m}, 1^{s}, i^{</em>}, A)</span> and gives <span class="math">(\\mathrm{crs}^{<em>}, \\mathrm{vk}^{</em>}, \\mathrm{D}^{*})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{A}</span> outputs a bit <span class="math">b&#x27; \\in \\{0, 1\\}</span>, which is the output of the experiment.</li>

    </ol>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{\\mathrm{BARG}}</span> satisfies CRS indistinguishability if for every efficient adversary <span class="math">\\mathcal{A}</span> and every polynomial <span class="math">m = m(\\lambda)</span>, <span class="math">s = s(\\lambda)</span>, there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for all <span class="math">\\lambda \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\operatorname{ExptCRS}_{\\mathcal{A}} (\\lambda, m, s, 0) = 1 \\right] - \\Pr \\left[ \\operatorname{ExptCRS}_{\\mathcal{A}} (\\lambda, m, s, 1) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Somewhere extractable in trapdoor mode</strong>: Define the somewhere extractable security game between an adversary <span class="math">\\mathcal{A}</span> and a challenger as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{A}(1^{\\lambda}, 1^{m}, 1^{s})</span> outputs an index <span class="math">i^{*} \\in [m]</span> and a set of fixed-wire assignments <span class="math">A \\subseteq \\{0, 1\\}^{m}</span>.</li>

      <li>The challenger samples <span class="math">(\\mathrm{crs}^{<em>}, \\mathrm{vk}^{</em>}, \\mathrm{D}^{<em>}, \\mathrm{td}) \\leftarrow \\mathrm{TrapSetup}(1^{\\lambda}, 1^{m}, 1^{s}, i^{</em>}, A)</span> and gives <span class="math">\\mathrm{crs}^{<em>}, \\mathrm{vk}^{</em>}, \\mathrm{D}^{*}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Algorithm <span class="math">\\mathcal{A}</span> outputs a Boolean circuit <span class="math">C\\colon \\{0,1\\}^n\\times \\{0,1\\}^h\\to \\{0,1\\}</span> of size at most <span class="math">s</span>, an admissible set of fixed-wire constraints <span class="math">\\Phi</span> whose assignments <span class="math">A_{\\Phi}\\subseteq A</span> are contained in <span class="math">A</span>, a set of statements $\\hat{\\mathbf{x}}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}},\\ldots ,\\hat{\\mathbf{x}}_m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}\\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\Phi}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> restricted to the set of indices </span>\\tilde{S}_{\\Phi} = [n]\\setminus S_{\\Phi}<span class="math"> not fixed by </span>\\Phi<span class="math">, and a proof </span>\\pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger computes <span class="math">\\mathbf{w}^{<em>}\\gets \\mathrm{Extract}(\\mathrm{td},C,\\mathrm{D}^{</em>},\\{(j,\\mathrm{D}^{*}[\\sigma_{j}])\\}_{(j,\\sigma_{j})\\in \\Phi},\\pi)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">i \\in [m]</span>, define $\\mathbf{x}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}} = \\hat{\\mathbf{x}}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}<span class="math">. For indices </span>j \\in S_{\\Phi}<span class="math"> fixed by </span>\\Phi<span class="math">, let </span>x_{i,j} = a_{j,i}<span class="math"> where </span>(j, (a_{j,1}, \\ldots, a_{j,m})) \\in \\Phi<span class="math">. The output of the game is </span>b = 1$ if the following conditions hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Verify $(\\mathrm{vk}^{*}, C, (\\hat{\\mathbf{x}}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}, \\ldots, \\hat{\\mathbf{x}}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}_{\\Phi}}), \\{(j, \\mathrm{D}^{*}[\\sigma_{j}])\\}_{(j, \\sigma_{j}) \\in \\Phi}, \\pi) = 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C(\\mathbf{x}_{i^<em>}, \\mathbf{w}^</em>) \\neq 1</span>.</li>

    </ul>

    <p class="text-gray-300">56</p>

    <p class="text-gray-300">We say <span class="math">\\Pi_{\\text{BARG}}</span> is somewhere extractable in trapdoor mode if for all efficient adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\operatorname{negl}(\\cdot)</span> such that <span class="math">\\Pr[b=1]=\\operatorname{negl}(\\lambda)</span> in the somewhere extractable game.</p>

    <p class="text-gray-300">In the case of a BARG with fully fixed wires, we additionally restrict the adversary <span class="math">\\mathcal{A}</span> to choosing admissible sets of fixed-wire constraint <span class="math">\\Phi</span> where <span class="math">S_{\\Phi}=[n]</span> (i.e., <span class="math">\\Phi</span> fixes all input wires to <span class="math">C</span>).</p>

    <h6 id="sec-149" class="text-base font-medium mt-4">Definition A.5 (Succinctness).</h6>

    <p class="text-gray-300">A BARG with fixed-wire constraints <span class="math">\\Pi_{\\text{BARG}}=({\\rm Setup},\\text{Prove},\\text{Verify})</span> is succinct if there exists a fixed polynomial <span class="math">\\operatorname{poly}(\\cdot,\\cdot,\\cdot)</span> such that for all <span class="math">\\lambda,m,s\\in\\mathbb{N}</span>, all sets of fixed-wire assignments <span class="math">A\\subseteq\\{0,1\\}^{m}</span>, all <span class="math">(\\operatorname{crs},\\operatorname{vk},\\operatorname{D})</span> in the support of <span class="math">{\\rm Setup}(1^{\\lambda},1^{m},1^{s},A)</span>, all Boolean circuits <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span>, and all sets of fixed-wire constraints <span class="math">\\Phi</span>, the following properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct proofs: The proof <span class="math">\\pi</span> output by <span class="math">\\text{Prove}(\\operatorname{crs},\\operatorname{D},C,\\cdot,\\cdot,\\cdot)</span> satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(\\lambda,\\log m,s)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinct verification key: We require</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{\\operatorname{D}[\\bm{\\sigma}]\\}_{\\bm{\\sigma}\\in A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(\\lambda,m,n)+\\operatorname{poly}(\\lambda,\\log m,s)+\\operatorname{poly}(\\lambda,\\log m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the setting of fully fixed wires, we require</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{\\operatorname{D}[\\bm{\\sigma}]\\}_{\\bm{\\sigma}\\in A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(\\lambda,\\log m,s)+\\operatorname{poly}(\\lambda,\\log m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-150" class="text-base font-medium mt-4">Remark A.6 (Special Cases of BARGs with Fixed-Wire Constraints).</h6>

    <p class="text-gray-300">We describe two important special cases of BARGs with fixed-wire constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BARG for NP: When there are no fixed-wire assignments <span class="math">A=\\varnothing</span> or constraints <span class="math">\\Phi=\\varnothing</span>, Definition A.2 is equivalent to a standard BARG for NP (Definition 2.2).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- BARG for index languages: The special case of an index BARG (Remark 2.10) on <span class="math">m</span> instances corresponds to a BARG with fully fixed wires where the set of fixed-wire assignments <span class="math">A</span> input to <span class="math">{\\rm Setup}</span> has size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n=O(\\log m)<span class="math">. The verification key </span>\\operatorname{vk}_{\\text{indexBARG}}<span class="math"> for the index BARG would be the verification key for the BARG with fixed wires together with the encodings of the assignments in </span>A<span class="math">. In this case, succinctness (Definition A.5) requires that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{vk}_{\\text{indexBARG}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(\\lambda,\\log m,s)<span class="math"> and similarly, that the verification time is </span>\\operatorname{poly}(\\lambda,\\log m,s)$. This matches the succinctness requirement for index BARGs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-151" class="text-base font-medium mt-4">Construction A.7 (BARG for NP with Fixed Wires from <span class="math">k</span>-Lin).</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\mathbb{N}</span> be an integer. We show how to adapt Construction 4.5 to construct a BARG for the language of circuit satisfiability that supports fixed wires as follows. For ease of exposition, we do not describe <span class="math">\\text{Verify}</span> with split verification (Definition 2.9), but it is straightforward to modify the scheme to support it.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">{\\rm Setup}(1^{\\lambda},1^{m},1^{s},A)</span>: On input the security parameter <span class="math">\\lambda</span>, the number of instances <span class="math">m</span>, the bound on the circuit size <span class="math">s</span>, and the set of fixed-wire assignments <span class="math">A\\subseteq\\{0,1\\}^{m}</span>, the setup algorithm constructs the verification key <span class="math">\\operatorname{vk}=\\big{(}\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[m]}\\big{)}</span> and the common reference string <span class="math">\\operatorname{crs}=\\big{(}\\operatorname{vk},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}</span> exactly as in Construction 4.5. Then, for each <span class="math">\\bm{\\sigma}=(\\sigma_{1},\\ldots,\\sigma_{m})\\in A</span>, compute encodings</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{u}_{\\bm{\\sigma}}]_{1}\\leftarrow\\sum_{i\\in[m]}\\sigma_{i}[\\mathbf{a}_{i}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{u}}_{\\bm{\\sigma}}]_{2}\\leftarrow\\sum_{i\\in[m]}\\sigma_{i}[\\hat{\\mathbf{a}}_{i}]_{2}.</span></p>

    <p class="text-gray-300">The setup algorithm outputs <span class="math">\\operatorname{crs}</span>, <span class="math">\\operatorname{vk}</span>, and the dictionary <span class="math">\\operatorname{D}</span> where <span class="math">\\operatorname{D}[\\bm{\\sigma}]\\mapsto([\\mathbf{u}_{\\bm{\\sigma}}]_{1},[\\hat{\\mathbf{u}}_{\\bm{\\sigma}}]_{2})</span></p>

    <p class="text-gray-300">To obtain a BARG with fully fixed wires, <span class="math">{\\rm Setup}</span> removes the encodings of <span class="math">[\\mathbf{a}_{i}]_{1}</span> and <span class="math">[\\hat{\\mathbf{a}}_{i}]_{2}</span> from the verification key. Namely, it sets</p>

    <p class="text-gray-300"><span class="math">\\operatorname{vk}^{\\prime}=\\big{(}\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2}\\big{)}.</span></p>

    <p class="text-gray-300">It outputs <span class="math">\\operatorname{crs}</span>, <span class="math">\\operatorname{vk}^{\\prime}</span>, and <span class="math">\\operatorname{D}</span>. Note that <span class="math">{\\rm Setup}</span> outputs the same <span class="math">\\operatorname{crs}</span> as Construction 4.5.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove(crs, D, <span class="math">C</span>, <span class="math">(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m})</span>, <span class="math">(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m})</span>): On input the common reference string crs, a dictionary D of encodings, the circuit <span class="math">C\\colon\\{0,1\\}^{n}\\to\\{0,1\\}^{h}\\to\\{0,1\\}</span>, instances <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{m}\\in\\{0,1\\}^{n}</span>, and witnesses <span class="math">\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{m}\\in\\{0,1\\}^{h}</span>, the prover proceeds constructs <span class="math">\\pi</span> using the same procedure as in 4.5.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Verify(vk, <span class="math">C</span>, $(\\mathbf{x}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S},\\ldots,\\mathbf{x}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S})<span class="math">, </span>\\{(i,\\mathrm{enc}_{i})\\}_{i\\in[n]\\setminus S},\\pi)\\to b$: On input the verification key</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{vk}=\\big{(}\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[m]}\\big{)},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span>, a set of instances $(\\mathbf{x}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S},\\ldots,\\mathbf{x}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S})\\in\\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> restricted to the set </span>S<span class="math">, a collection of encodings </span>\\{(i,\\mathrm{enc}_{i})\\}_{i\\in[n]\\setminus S}$, and the proof</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\pi=\\big{(}\\{[\\mathbf{u}_{d}]_{1},[\\hat{\\mathbf{u}}_{d}]_{2}\\}_{d\\in[\\ell]},\\{[\\mathbf{V}_{n+d,i}]_{1},[\\hat{\\mathbf{V}}_{n+d,i}]_{2}\\}_{d\\in[h],i\\in\\{1,2\\}},\\{[\\mathbf{W}_{\\ell,i}]_{1},[\\hat{\\mathbf{W}}_{\\ell,i}]_{2}\\}_{\\ell\\in[s],i\\in\\{1,2\\}}\\big{)}.</span></p>

    <p class="text-gray-300">the verification algorithm starts by checking the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validity of statement: For each statement wire <span class="math">d\\in[n]</span>, if <span class="math">d\\in S</span>, then the verifier checks that</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{u}_{d}]_{1}=\\sum_{i\\in[m]}x_{i,d}[\\mathbf{a}_{i}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{u}}_{d}]_{2}=\\sum_{i\\in[m]}x_{i,d}[\\hat{\\mathbf{a}}_{i}]_{2},</span></p>

    <p class="text-gray-300">exactly as in 4.5. For statement wires <span class="math">d\\in[n]\\setminus S</span>, the verifier looks up the encoding <span class="math">(i,\\mathrm{enc}_{i})</span> and checks that <span class="math">([\\mathbf{u}_{d}]_{1},[\\hat{\\mathbf{u}}_{d}]_{2})=\\mathrm{enc}_{d}</span>.</p>

    <p class="text-gray-300">The verifier performs the remaining checks exactly as described in the 4.7.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1 is a somewhere argument of knowledge</p>

    <h6 id="sec-152" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">The difference between 4.5 and 4.7 is complete.</p>

    <h6 id="sec-153" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">The difference between 4.5 and 4.7 is that instead of having the prover and verifier compute encodings of the fixed wires, those encodings are precomputed and provided as input to Prove and Verify. Completeness follows by an analogous argument as in the proof of 4.6. ∎</p>

    <h6 id="sec-154" class="text-base font-medium mt-4">Theorem A.9 (Somewhere Argument of Knowledge).</h6>

    <p class="text-gray-300">Take any positive integer <span class="math">k\\in\\mathbb{N}</span>. If the <span class="math">k</span>-<span class="math">\\mathrm{Lin}</span> assumption holds in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> with respect to <span class="math">\\mathrm{GroupGen}</span>, then 4.7 is a somewhere argument of knowledge</p>

    <h6 id="sec-155" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">The argument follows by a similar argument as in the proof of 4.7. For completeness, we describe the <span class="math">\\mathrm{TrapSetup}</span> and <span class="math">\\mathrm{Extract}</span> algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{TrapSetup}(1^{\\lambda},1^{m},1^{s},i^{<em>})</span>: The <span class="math">\\mathrm{TrapSetup}</span> algorithm samples <span class="math">\\mathrm{vk}^{</em>}=\\big{(}\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2},\\{[\\mathbf{a}_{i}]_{1},[\\hat{\\mathbf{a}}_{i}]_{2}\\}_{i\\in[m]}\\big{)}</span>, <span class="math">\\mathrm{crs}^{<em>}=\\big{(}\\mathrm{vk}^{</em>},\\{[\\mathbf{B}_{i,j}]_{1},[\\hat{\\mathbf{B}}_{i,j}]_{2}\\}_{i\\neq j}\\big{)}</span>, and <span class="math">\\mathrm{td}=\\mathbf{\\tau}\\in\\mathbb{Z}_{p}^{k+1}</span> using exactly the same procedure as <span class="math">\\mathrm{TrapSetup}</span> in the proof of 4.7. Then, for each <span class="math">\\bm{\\sigma}=(\\sigma_{1},\\ldots,\\sigma_{m})\\in A</span>, it computes encodings</li>

    </ul>

    <p class="text-gray-300"><span class="math">[\\mathbf{u}_{\\bm{\\sigma}}]_{1}\\leftarrow\\sum_{i\\in[m]}\\sigma_{i}[\\mathbf{a}_{i}]_{1}\\quad\\text{and}\\quad[\\hat{\\mathbf{u}}_{\\bm{\\sigma}}]_{2}\\leftarrow\\sum_{i\\in[m]}\\sigma_{i}[\\hat{\\mathbf{a}}_{i}]_{2}.</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathrm{D}^{<em>}</span> be the dictionary that maps <span class="math">\\mathrm{D}^{</em>}[\\bm{\\sigma}]\\mapsto([\\mathbf{u}_{\\bm{\\sigma}}]_{1},[\\hat{\\mathbf{u}}_{\\bm{\\sigma}}]_{2})</span> for all <span class="math">\\bm{\\sigma}\\in A</span>. The trapdoor setup algorithm outputs <span class="math">\\mathrm{crs}^{<em>}</span>, <span class="math">\\mathrm{vk}^{</em>}</span>, <span class="math">\\mathrm{D}^{*}</span>, and <span class="math">\\mathrm{td}</span>.</p>

    <p class="text-gray-300">In the case of a BARG with fully fixed wires, <span class="math">\\mathrm{TrapSetup}</span> removes the encodings of <span class="math">[\\mathbf{a}_{i}]_{1}</span> and <span class="math">[\\hat{\\mathbf{a}}_{i}]_{2}</span> from <span class="math">\\mathrm{vk}^{<em>}</span>. Namely, it now sets <span class="math">\\mathrm{vk}^{</em>}=\\big{(}\\mathcal{G},[\\mathbf{M}]_{1},[\\hat{\\mathbf{M}}]_{2},[\\mathbf{a}]_{1},[\\hat{\\mathbf{a}}]_{2}\\big{)}</span>. The other components <span class="math">\\mathrm{crs}^{<em>}</span>, <span class="math">\\mathrm{D}^{</em>}</span>, <span class="math">\\mathrm{td}</span> are unchanged.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathrm{Extract}(\\mathrm{td},C,(\\mathbf{x}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S},\\ldots,\\mathbf{x}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S}),\\{(i,\\mathrm{enc}_{i}^{*})\\}_{i\\in[n]\\setminus S},\\pi)<span class="math">: The extraction algorithm is the same as </span>\\mathrm{Extract}<span class="math"> in the proof of 4.7 (which only depends on </span>\\mathrm{td}<span class="math"> and </span>\\pi$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now sketch the arguments for the CRS indistinguishability and somewhere extractability in trapdoor mode properties. Both follow by the corresponding argument from the proof of 4.7.</p>

    <p class="text-gray-300">CRS indistinguishability: This follows by the same argument as in the proof of Lemma 4.8. Namely, Lemma 4.8 shows that <span class="math">\\operatorname{crs}^{<em>}</span> output by <span class="math">\\mathsf{TrapSetup}</span> is computationally indistinguishable from <span class="math">\\operatorname{crs}</span> output by <span class="math">\\mathsf{Setup}</span> in 4.5. These are the exact same components in the common reference string and verification key in 4.7. Next, the encodings in the dictionary <span class="math">\\mathrm{D}^{</em>}</span> and <span class="math">\\mathrm{D}</span> are public (and efficiently-computable) functions of the elements in <span class="math">\\operatorname{crs}^{<em>}</span> and <span class="math">\\operatorname{crs}</span>, respectively. Thus, the tuple <span class="math">(\\operatorname{crs}^{</em>},\\mathrm{vk}^{<em>},\\mathrm{D}^{</em>})</span> output by <span class="math">\\mathsf{TrapSetup}</span> (for any index <span class="math">i^{*}\\in[m]</span>) and <span class="math">(\\operatorname{crs},\\mathrm{vk},\\mathrm{D})</span> output by <span class="math">\\mathsf{Setup}</span> in 4.7 are computationally indistinguishable.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere extractable in trapdoor mode: Since the structure of <span class="math">\\pi</span> in 4.7 and 4.5 is identical, this property follows by the same argument as in the proof of Lemma 4.12. More precisely, we can show that an adversary that breaks the somewhere extractability property for 4.7 implies a corresponding adversary that breaks the same property for 4.5. We provide a brief sketch here:</li>

    </ul>

    <p class="text-gray-300">Suppose there exists an adversary <span class="math">\\mathcal{A}</span> that wins the somewhere extractable game with non-negligible probability <span class="math">\\varepsilon</span>. We use <span class="math">\\mathcal{A}</span> to construct an adversary <span class="math">\\mathcal{B}</span> that wins the somewhere extractable game for 4.5 with the same probability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{B}</span> runs <span class="math">\\mathcal{A}</span> to obtain an index <span class="math">i^{*}\\in[m]</span> and a set of fixed-wire assignments <span class="math">A\\subseteq\\{0,1\\}^{m}</span>.</li>

      <li>Algorithm <span class="math">\\mathcal{B}</span> submits <span class="math">i^{<em>}</span> to its challenger and receives <span class="math">\\operatorname{crs}^{</em>}</span> from the challenger. It forms <span class="math">\\mathrm{vk}^{<em>}</span> from <span class="math">\\operatorname{crs}^{</em>}</span> (which consists of a subset of the components of <span class="math">\\operatorname{crs}^{<em>}</span>). Algorithm <span class="math">\\mathcal{B}</span> computes <span class="math">\\mathrm{D}^{</em>}</span> as described in <span class="math">\\mathsf{TrapSetup}</span> (which only depends on components in <span class="math">\\operatorname{crs}^{<em>}</span>). Algorithm <span class="math">\\mathcal{B}</span> gives <span class="math">\\operatorname{crs}^{</em>},\\mathrm{vk}^{<em>},\\mathrm{D}^{</em>}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Algorithm <span class="math">\\mathcal{A}</span> outputs a Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span>, a set of fixed-wire constraints <span class="math">\\Phi</span>, a set of statements $\\hat{\\mathbf{x}}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\hat{S}_{\\Phi}},\\dots,\\hat{\\mathbf{x}}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\hat{S}_{\\Phi}}\\in\\{0,1\\}^{\\hat{S}_{\\Phi}}<span class="math"> restricted to the set </span>\\hat{S}_{\\Phi}=[n]\\setminus S_{\\Phi}<span class="math">, and a proof </span>\\pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithm <span class="math">\\mathcal{B}</span> outputs the circuit <span class="math">C</span>, statements <span class="math">(\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m})</span> and the proof <span class="math">\\pi</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By construction, if $\\mathsf{Verify}(\\mathrm{vk}^{*},C,(\\hat{\\mathbf{x}}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\hat{S}_{\\Phi}},\\dots,\\hat{\\mathbf{x}}_{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\hat{S}_{\\Phi}}),\\{(j,\\mathrm{D}^{*}[\\sigma_{j}])\\}_{(j,\\sigma_{j})\\in\\Phi},\\pi)=1<span class="math">, then </span>\\big{(}C,(\\mathbf{x}_{1},\\dots,\\mathbf{x}_{m}),\\pi\\big{)}<span class="math"> verifies under the same procedure in 4.5. Moreover, the extraction algorithm </span>\\mathsf{Extract}<span class="math"> is identical to the corresponding algorithm in the proof of Lemma 4.12. Thus, algorithm </span>\\mathcal{B}<span class="math"> succeeds with the same advantage as </span>\\mathcal{A}$ and the claim holds. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-156" class="text-base font-medium mt-4">Theorem A.10 (Succinctness).</h6>

    <p class="text-gray-300">For all constants <span class="math">k\\in\\mathbb{N}</span>, 4.5 is succinct.</p>

    <h6 id="sec-157" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Take any <span class="math">\\lambda,m,s\\in\\mathbb{N}</span> and any set of fixed-wire assignments <span class="math">A\\subseteq\\{0,1\\}^{m}</span>. Take any Boolean circuit <span class="math">C\\colon\\{0,1\\}^{n}\\times\\{0,1\\}^{h}\\to\\{0,1\\}</span> of size at most <span class="math">s</span> and any set of fixed-wire constraints. We check each property individually:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: By construction, the size of the proof is the same as in 4.5. By 4.15, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,s)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{\\mathrm{D}[\\sigma]\\}_{\\sigma\\in A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,m)+\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the fully fixed wire setting, the verification key consists of the group description <span class="math">\\mathcal{G}</span> along with <span class="math">(k+1)^{2}</span> elements in each of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. In this case, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda)$, and so</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{\\mathrm{D}[\\sigma]\\}_{\\sigma\\in A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification time: The verification procedure in 4.7 is a slimmed-down version of the procedure from 4.5 where some of the statement validity checks are replaced with direct equality checks against the provided encodings. The claim follows by a similar analysis. In particular, in the fully-fixed setting, the verifier does not need to perform any statement-validity check, which yields an overall verification time of <span class="math">\\mathrm{poly}(\\lambda,s)</span> in this setting.</li>

    </ul>`;
---

<BaseLayout title="Batch Arguments for NP and More from Standard Bilinear Group... (2022/336)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/336
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
