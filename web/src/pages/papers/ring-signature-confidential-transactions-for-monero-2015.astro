---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1098';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Ring Signature Confidential Transactions for Monero';
const AUTHORS_HTML = 'Shen Noether';

const CONTENT = `    <h2 id="sec-2" class="text-2xl font-bold">SHEN NOETHER- MONERO RESEARCH LABS</h2>

    <p class="text-gray-300">ABSTRACT. This article introduces a method of hiding transaction amounts in the strongly decentralized anonymous cryptocurrency Monero. Similar to Bitcoin, Monero is a cryptocurrency which is distributed through a proof of work "mining" process. The original Monero protocol was based on CryptoNote, which uses ring signatures and one-time keys to hide the destination and origin of transactions. Recently the technique of using a commitment scheme to hide the amount of a transaction has been discussed and implemented by Bitcoin Core Developer Gregory Maxwell. In this article, a new type of ring signature, A Multi-layered Linkable Spontaneous Anonymous Group signature is described which allows for hidden amounts, origins and destinations of transactions with reasonable efficiency and verifiable, trustless coin generation. The author would like to note that early drafts of this were publicized in the Monero Community and on the bitcoin research irc channel. Blockchain hashed drafts are available in [Noe15].</p>

    <h2 id="sec-3" class="text-2xl font-bold">Contents</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Introduction 2</li>

    </ol>

    <p class="text-gray-300">1.1. Spontaneous (Ad Hoc) Ring Signatures in CryptoCurrencies 2 1.2. Ring CT for Monero 5 1.3. Strongly Decentralized Anonymous Payment Schemes 6 1.4. Acknowledgements 6</p>

    <p class="text-gray-300">RING CONFIDENTIAL TRANSACTIONS</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multilayered Linkable Spontaneous Ad-Hoc Group Signatures 7</li>

    </ol>

    <p class="text-gray-300">2.1. LWW signatures vs FS signatures 7 2.2. MLSAG Description 10 2.3. MLSAG Security Model 12 2.4. MLSAG Unforgeability 13 2.5. MLSAG Linkability 16 2.6. MLSAG Anonymity 17</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Background on Confidential Transactions 20</li>

    </ol>

    <p class="text-gray-300">3.1. Confidential Transactions in Bitcoin 20 3.2. Modification for Ring Signatures 20</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ring CT For Monero Protocol 23</li>

    </ol>

    <p class="text-gray-300">4.1. Protocol Description 23 4.2. Conversion from Visible Denominations to Commitments 25 4.3. Transaction Fees 25</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Aggregate Schnorr Range Proofs 26</li>

    </ol>

    <p class="text-gray-300">5.1. Representing Amounts 29</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ring CT Demo Code 30</li>

      <li>Conclusion 33</li>

    </ol>

    <p class="text-gray-300">References 33</p>

    <p class="text-gray-300">1.1. Spontaneous (Ad Hoc) Ring Signatures in CryptoCurrencies. Recall that in Bitcoin each transaction is signed by the owner of</p>

    <p class="text-gray-300">the coins being sent and these signatures verify that the owner is allowed to send the coins. This is entirely analogous to the signing of a check from your bank.</p>

    <p class="text-gray-300">CryptoNote <em>[x13]</em> and Ring Coin <em>[x1]</em> advanced this idea by using “ring signatures” which were originally described in <em>[x15]</em> as a “digital signature that specifies a group of possible signers such that the verifier can’t tell which member actually produced the signature.” The idea therefore is to have the origin pubkey of a transaction hidden in a group of pubkeys all of which contain the same amount of coins, so that no one can tell which user actually sent the coins.</p>

    <p class="text-gray-300">The original CryptoNote protocol as described in <em>[x13]</em> implements a slight modification of this to prevent double spends. Namely in <em>[x13]</em> a “traceable ring signature,” which is a slight modification of those described in <em>[x5]</em> is employed. This type of ring signature has the benefit of not allowing the owner of a coin to sign two different ring signatures with the same pubkey without being noticed on the blockchain. The obvious reason for this is to prevent “double-spending” which, in Bitcoin, refers to spending a coin twice. Ring coin <em>[x1, x2]</em> uses a more efficient linkable ring signature which is a slight modification of the Linkable Spontaneous Anonymous Group signatures described in <em>[x11]</em>.</p>

    <p class="text-gray-300">One benefit of using the above types of ring signatures over other anonymizing techniques, such as CoinJoin <em>[x12]</em> or using coin mixing services, is that they allow for “spontaneous” mixing. With CoinJoin or coin mixers, it is similarly possible to hide the originator of a given</p>

    <p class="text-gray-300">transaction, however these techniques in practice need some sort of centralized group manager, such as a centralized CoinJoin server, where transactions are combined by a trusted party. In the case that the trusted party is compromised, the anonymity of the transaction is also compromised.</p>

    <p class="text-gray-300">Some coins such as Dashcoin <em>[x10]</em>, attempt to negate this by using a larger number of trusted mixers (in this case masternodes) but this number is still much smaller than the users of the coin. In contrast, with a spontaneous ring signature, transactions can be created by the owner of a given pubkey (this is the spontaneous, or “ad-hoc” property) without relying on any trusted server, and thus providing for safer anonymity.</p>

    <p class="text-gray-300">One possible attack against the original CryptoNote or ring-coin protocol <em>[x27, x3]</em> is blockchain analysis based on the amounts sent in a given transaction. For example, if an adversary knows that .9 coins have been sent at a certain time, then they may be able to narrow down the possibilities of the sender by looking for transactions containing .9 coins. This is somewhat negated by the use of the one-time keys used in <em>[x27]</em> since the sender can include a number of change addresses in a transaction, thus obfuscating the amount which has been sent with a type of “knapsack mixing.” However this technique has the downside that it can create a large amount of “dust” transactions on the blockchain, i.e. transactions of small amounts that take up proportionately more space than their importance. Additionally, the receiver of the coins may have to “sweep” all this dust when they want to send it,</p>

    <p class="text-gray-300">possibly allowing for a smart adversary to keep track of which keys go together in some manner. Furthermore, it is easy to establish an upper and lower bound on the amounts sent.</p>

    <p class="text-gray-300">Another downside to the original CryptoNote set-up is that it requires a given pair of <span class="math">(P,A)</span> of pubkey <span class="math">P</span> and amount <span class="math">A</span> to be used in a ring signature with other pubkeys having the same amount. For less common amounts, this means there may be a smaller number of potential pairs <span class="math">(P^{\\prime},A^{\\prime})</span> available on the blockchain with <span class="math">A^{\\prime}=A</span> to ring signature with. Thus, in the original CryptoNote protocol, the potential anonymity set is perhaps smaller than may be desired. Analysis of the above weaknesses is covered in <em>[x1]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2. Ring CT for Monero</h3>

    <p class="text-gray-300">An obvious way to negate the downsides of the CryptNote protocol, as described in the previous section, would be to implement hidden amounts for any transaction. In this paper, I describe a modification to the Monero protocol, a proof-of-work cryptocurrency extending the original CryptoNote protocol, which allows the amounts sent in a transaction to be hidden. This modification is based on the Confidential Transactions <em>[x12]</em> which are used on the lightning side-chain in Bitcoin, except it allows for their use in ring signatures. Therefore, the modification is given the obvious name of Ring Confidential Transactions for Monero.</p>

    <p class="text-gray-300">In order to preserve the property that coins cannot be double spent, a generalization of the LSAG’s of <em>[x13]</em> is described, a Multilayered Linkable Spontaneous Anonymous Group Signature (MLSAG)</p>

    <p class="text-gray-300">which allows for combining Confidential Transactions with a ring signature in such a way that using multiple inputs and outputs is possible, anonymity is preserved, and double-spending is prevented.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3. Strongly Decentralized Anonymous Payment Schemes</h3>

    <p class="text-gray-300">The Ring CT protocol allows hidden amounts, origins, and destinations for transactions which is somewhat similar to Zerocash <em>[BSCG+14]</em>. One possible differentiator is that the use of proof of work for coin generation is possible with Ring CT as opposed to in ZeroCash, where it seems all coins must be pregenerated by a trusted group.</p>

    <p class="text-gray-300">Note that one of the biggest innovations in Bitcoin <em>[Nak08]</em>, was the decentralized distribution model allowing anyone willing to put their computing power to work to participate in the generation of the currency. Some of the benefits of this type of proof-of-work include trustless incentives for securing the network and stronger decentralization (for example, to protect against poison-pill type attacks).</p>

    <p class="text-gray-300">One final obvious benefit of the proof-of-work coin generation is it makes Ring CT immune to a powerful actor somehow acquiring all the pieces of the master key used in coin generation. Since there is an obvious large incentive (the ability to generate free money ) to acquire all pieces of the trusted generation key, this is fairly important.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.4. Acknowledgements</h3>

    <p class="text-gray-300">I would like to thank Monero team for lots of help and discussion in the creation of this paper and the Monero and Bitcoin Community for support and discussion. With respect to</p>

    <p class="text-gray-300">disclosure, the author received several donations totalling between 2 and 3 bitcoins from the Monero community in gratitude for his work on this research.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2. Multilayered Linkable Spontaneous Ad-Hoc Group Signatures</h2>

    <p class="text-gray-300">In this section, I define the Multilayered Linkable Spontaneous Anonymous Group signatures (MLSAG) used by the the Ring CT protocol. Note that I define these as a general signature, and not necessarily in their use case for Ring Confidential Transactions. An MLSAG is essentially similar to the LSAG’s described in <em>[x11]</em>, but rather than having a ring signature on a set of <span class="math">n</span> keys, instead, an MLSAG is a ring signature on a set of <span class="math">n</span> key-vectors.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A key-vector is just a collection <span class="math">\\overline{y}=(y_{1},...,y_{r})</span> of public keys with corresponding private keys <span class="math">\\overline{x}=(x_{1},...,x_{r})</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1. LWW signatures vs FS signatures</h3>

    <p class="text-gray-300">The ring signatures used in Monero and the original CryptoNote protocol are derived from the traceable ring signatures of <em>[x5]</em>. The CryptoNote <em>[x17]</em> ring signatures come with a “key-image” which means that a signer can only sign one ring on the block-chain with a given public and private key pair or else their transaction will be marked as invalid. Because of this, one-time keys are used in CryptoNote, which further helps anonymity.</p>

    <p class="text-gray-300">In <em>[x1]</em>, Adam Back noticed that the Linkable Spontaneous Anonymous Group (LSAG) signatures of <em>[x11]</em> can be modified to give a more efficient linkable ring signature producing the same effect as the</p>

    <p class="text-gray-300">RING CONFIDENTIAL TRANSACTIONS</p>

    <p class="text-gray-300">[FS07] ring signatures. This modification reduces the storage cost on the blockchain essentially in half.</p>

    <p class="text-gray-300">First I recall almost verbatim the modification given in [Bac15]:</p>

    <p class="text-gray-300">Keygen: Find a number of public keys <span class="math">P_{i}, i = 0,1,\\dots,n</span> and a secret index <span class="math">j</span> such that <span class="math">xG = P_{j}</span> where <span class="math">G</span> is the ed25519 base-point and <span class="math">x</span> is the signers spend key. Let <span class="math">I = xH_{p}(P_{j})</span> where <span class="math">H_{p}</span> is a hash function returning a point. Let <span class="math">\\mathfrak{m}</span> be a given message.</p>

    <p class="text-gray-300">SIGN: Let <span class="math">\\alpha, s_i</span>, <span class="math">i \\neq j</span>, <span class="math">i \\in \\{1, \\dots, n\\}</span> be random values in <span class="math">\\mathbb{Z}_q</span> (the ed25519 base field).</p>

    <p class="text-gray-300">Compute</p>

    <div class="my-4 text-center"><span class="math-block">L _ {j} = \\alpha G</span></div>

    <div class="my-4 text-center"><span class="math-block">R _ {j} = \\alpha H _ {p} (P _ {j})</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {j + 1} = h \\left(\\mathfrak {m}, L _ {j}, R _ {j}\\right)</span></div>

    <p class="text-gray-300">where <span class="math">h</span> is a hash function returning a value in <span class="math">\\mathbb{Z}_q</span>. Now, working successively in <span class="math">j</span> modulo <span class="math">n</span>, define</p>

    <div class="my-4 text-center"><span class="math-block">L _ {j + 1} = s _ {j + 1} G + c _ {j + 1} P _ {j + 1}</span></div>

    <div class="my-4 text-center"><span class="math-block">R _ {j + 1} = s _ {j + 1} H _ {p} \\left(P _ {j + 1}\\right) + c _ {j + 1} \\cdot I</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {j + 2} = h \\left(\\mathfrak {m}, L _ {j + 1}, R _ {j + 1}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\dots</span></div>

    <div class="my-4 text-center"><span class="math-block">L _ {j - 1} = s _ {j - 1} G + c _ {j - 1} P _ {j - 1}</span></div>

    <p class="text-gray-300">2In practice <span class="math">H_{p}(P) = Keccak(P)\\cdot G</span> where <span class="math">G</span> is the ed25519 basepoint, although note that for the commitment scheme I will use toPoint(Keccak(P)), hashing successively until Keccak(P) returns a multiple of the basepoint.</p>

    <p class="text-gray-300"><span class="math">R_{j-1}=s_{j-1}H_{p}\\left(P_{j-1}\\right)+c_{j-1}\\cdot I</span> <span class="math">c_{j}=h\\left(\\mathfrak{m},L_{j-1},\\ R_{j-1}\\right)</span></p>

    <p class="text-gray-300">so that <span class="math">c_{1},...,c_{n}</span> are defined.</p>

    <p class="text-gray-300">Let <span class="math">s_{j}=\\alpha-c_{j}\\cdot x_{j}\\ mod\\ l</span>, (<span class="math">l</span> being the ed25519 curve order) hence <span class="math">\\alpha=s_{j}+c_{j}x_{j}\\ mod\\ l</span> so that</p>

    <p class="text-gray-300"><span class="math">L_{j}=\\alpha G=s_{j}G+c_{j}x_{j}G=s_{j}G+c_{j}P_{j}</span> <span class="math">R_{j}=\\alpha H_{p}\\left(P_{j}\\right)=s_{j}H_{p}\\left(P_{j}\\right)+c_{j}I</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">c_{j+1}=h\\left(\\mathfrak{m},\\ L_{j},\\ R_{j}\\right)</span></p>

    <p class="text-gray-300">and thus, given a single <span class="math">c_{i}</span> value, the <span class="math">P_{j}</span> values, the key image <span class="math">I</span>, and all the <span class="math">s_{j}</span> values, all the other <span class="math">c_{k},\\ k\\neq i</span> can be recovered by an observer. The signature therefore becomes:</p>

    <p class="text-gray-300"><span class="math">\\sigma=(I,c_{1},s_{1},...,s_{n})</span></p>

    <p class="text-gray-300">which represents a space savings over <em>[x13, 4.4]</em> where the ring signature would instead look like:</p>

    <p class="text-gray-300"><span class="math">\\sigma=(I,c_{1},...,c_{n},s_{1},...,s_{n})</span></p>

    <p class="text-gray-300">Verification proceeds as follows. An observer computes <span class="math">L_{i},R_{i}</span>, and <span class="math">c_{i}</span> for all <span class="math">i</span> and checks that <span class="math">c_{n+1}=c_{1}</span>. Then the verifier checks that</p>

    <p class="text-gray-300"><span class="math">c_{i+1}=h\\left(\\mathfrak{m},L_{i},R_{i}\\right)</span></p>

    <p class="text-gray-300">for all <span class="math">i\\mod n</span></p>

    <p class="text-gray-300">LINK: Signatures with duplicate key images <span class="math">I</span> are rejected.</p>

    <p class="text-gray-300">Note that proofs of unforgeability, anonymity, and linkability hold for the above protocol which are only insignificant modifications to the proofs given in <em>[x12]</em>. I will give a more generalized version of these proofs for the MLSAG’s.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.2. MLSAG Description</h3>

    <p class="text-gray-300">For the Ring CT protocol, which will be described in section 4, I require a generalization of the Back LSAG signatures described in the previous section which allows for key-vectors (Definition 1) rather than just keys.</p>

    <p class="text-gray-300">Suppose that each signer of a (generalized) ring containing <span class="math">n</span> members has exactly <span class="math">m</span> keys <span class="math">\\left\\{P_{i}^{j}\\right\\}_{j=1,...,m}^{i=1,...,n}</span>. The intent of the MLSAG ring signature is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To prove that one of the <span class="math">n</span> signers knows the secret keys to their entire key vector.</li>

      <li>To enforce that if the signer uses any one of their <span class="math">m</span> signing keys in another MLSAG signature, then the two rings are linked, and the second such MLSAG signature (ordered by the Monero block chain) is discarded.</li>

    </ul>

    <p class="text-gray-300">The algorithm proceeds as follows: Let <span class="math">\\mathfrak{m}</span> be a given message. Let <span class="math">\\pi</span> be a secret index corresponding to the signer of the generalized ring. For <span class="math">j=1,...,m</span>, let <span class="math">I_{j}=x_{j}H\\left(P_{\\pi}^{j}\\right)</span>, and for <span class="math">j=1,...,m</span>, <span class="math">i=1,...,\\hat{\\pi},...n</span></p>

    <p class="text-gray-300">(where <span class="math">\\hat{\\pi}</span> means omit the index <span class="math">\\pi</span>) let <span class="math">s_{i}^{j}</span> be some random scalars (elements of <span class="math">\\mathbb{Z}_{q}</span>). Now, in a manner analogous to subsection 2.1, define</p>

    <p class="text-gray-300"><span class="math">L^{j}_{\\pi}=\\alpha_{j}G</span> <span class="math">R^{j}_{\\pi}=\\alpha_{j}H\\left(P^{j}_{\\pi}\\right)</span></p>

    <p class="text-gray-300">for random scalars <span class="math">\\alpha_{j}</span> and <span class="math">j=1,...,m</span>. Now, again analogously to section 2.1, set:</p>

    <p class="text-gray-300"><span class="math">c_{\\pi+1}=H\\left(\\mathfrak{m},L^{1}_{\\pi},R^{1}_{\\pi},...,L^{m}_{\\pi},R^{m}_{\\pi}\\right).</span> <span class="math">L^{j}_{\\pi+1}=s^{j}_{\\pi+1}G+c_{\\pi+1}P^{j}_{\\pi+1}</span> <span class="math">R^{j}_{\\pi+1}=s^{j}_{\\pi+1}H\\left(P^{j}_{\\pi+1}\\right)+c_{\\pi+1}I_{j}</span></p>

    <p class="text-gray-300">and repeat this, incrementing <span class="math">i</span> modulo <span class="math">n</span> until we arrive at</p>

    <p class="text-gray-300"><span class="math">L^{j}_{\\pi-1}=s^{j}_{i-1}G+c_{i-1}P^{j}_{i-1}</span> <span class="math">R^{j}_{\\pi-1}=s^{j}_{i-1}H\\left(P^{j}_{i-1}\\right)+c_{i-1}\\cdot I_{j}</span> <span class="math">c_{\\pi}=H\\left(\\mathfrak{m},L^{1}_{\\pi-1},R^{1}_{\\pi-1},...,L^{m}_{\\pi-1},R^{m}_{\\pi-1}\\right).</span></p>

    <p class="text-gray-300">Finally, solve for each <span class="math">s^{j}_{\\pi}</span> using <span class="math">\\alpha_{j}=s^{j}_{\\pi}+c_{\\pi}x_{j}\\mod\\ell</span>. The signature is then given as <span class="math">(I_{1},...,I_{m},c_{1},s^{1}_{1},...,s^{m}_{1},s^{1}_{2},...,s^{m}_{2},...,s^{1}_{n},...,s^{m}_{n})</span>, so the complexity is <span class="math">O\\left(m\\left(n+1\\right)\\right).</span> Verification proceeds by regenerating all the <span class="math">L^{j}_{i},R^{j}_{i}</span> starting from <span class="math">i=1</span> as in section 2.1 (which is the special case that <span class="math">m=1</span>) and verifying the hash <span class="math">c_{n+1}=c_{1}.</span> If these are being used in a blockchain setting such as Monero, signatures with key images <span class="math">I_{j}</span></p>

    <p class="text-gray-300">which have already appeared are then rejected. One can easily show, in a manner similar to <em>[x10]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The probability of a signer generating a valid signature without knowing all “<span class="math">m</span>” private keys belonging to their key vector for index <span class="math">\\pi</span> is negligible.</li>

      <li>The probability of a signer not signing for any key of index <span class="math">\\pi</span> is negligible. (In other words, the key images in the signature necessarily all come from index <span class="math">\\pi</span>.)</li>

      <li>If a signer signs two rings using at least one of the same public keys, then the two rings are linked.</li>

    </ul>

    <p class="text-gray-300">I expand on these points below with security proofs.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3. MLSAG Security Model</h3>

    <p class="text-gray-300">An MLSAG will satisfy the following three properties of Unforgeability, Linkability, and Signer Ambiguity which are very similar to the definitions given in <em>[x10]</em>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">(Unforgeability) An MLSAG signature scheme is unforgeable if for any probabilistic polynomial time (PPT) algorithm <span class="math">\\mathcal{A}</span> with signing oracle <span class="math">\\mathcal{SO}</span> producing valid signatures, given a list of <span class="math">n</span> public key vectors chosen by <span class="math">\\mathcal{A}</span>, then <span class="math">\\mathcal{A}</span> can only with negligible probability produce a valid signature when <span class="math">\\mathcal{A}</span> does not know one of the corresponding private key vectors.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">In the following definition, note that I include rejecting duplicate key images as part of the verification criteria for the MLSAG, which gives a slightly different Linkability definition than the one in <em>[x10]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">(Linkability) Let <span class="math">L</span> be the set of all public keys in a given setting (e.g. in a given blockchain). An MLSAG signature scheme on <span class="math">L</span> is key-image linked if the probability of a PPT adversary <span class="math">\\mathcal{A}</span> creating two signatures <span class="math">\\sigma,\\sigma^{\\prime}</span> signed with respect to key-vectors <span class="math">\\overline{y}</span> and <span class="math">\\overline{y}^{\\prime}</span> each containing the same public key <span class="math">y_{i}=y_{i}^{\\prime}</span> in <span class="math">L</span> and each verifying without being marked duplicate, is negligible.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">(Signer Ambiguity ) An MLSAG signature scheme is said to be signer ambiguous if given any verifying signature <span class="math">\\sigma</span> on key-vectors <span class="math">(\\overline{y}_{1},...,\\overline{y}_{n})</span> and any set of <span class="math">t</span> private keys, none of the same index, nor of the secret index, then the probability of guessing the secret key is less than <span class="math">\\frac{1}{n-t}+\\frac{1}{Q(k)}</span></p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.4. MLSAG Unforgeability</h3>

    <p class="text-gray-300">This follows similarly to <em>[x10, Theorem 1]</em>. Let <span class="math">H_{1}</span> and <span class="math">H_{2}</span> random oracles, and <span class="math">\\mathcal{SO}</span> be a signing oracle which returns valid MLSAG signatures. Assume there is a probabilistic polynomial time (PPT) adversary <span class="math">\\mathcal{A}</span> with the ability to forge an MLSAG from a list of key vectors <span class="math">L</span> with non-negligible probability</p>

    <p class="text-gray-300"><span class="math">Pr\\left(\\mathcal{A}\\left(\\mathcal{L}\\right)\\rightarrow\\left(m,\\sigma\\right):Ver\\left(L,m,\\sigma\\right)=True\\right)&gt;\\frac{1}{Q_{1}\\left(k\\right)}</span></p>

    <p class="text-gray-300">where <span class="math">Q_{1}</span> is a polynomial inputting a security parameter <span class="math">k</span> and where <span class="math">\\left(m,\\sigma\\right)</span> is not one of the signatures returned by <span class="math">\\mathcal{SO}</span>. Assume that <span class="math">\\mathcal{A}</span> makes no more than <span class="math">q_{H}+nq_{S}</span> (with <span class="math">n</span> the number of keys in <span class="math">\\mathcal{L}</span>) queries to the signing oracles <span class="math">H_{1},H_{2}</span> and <span class="math">\\mathcal{SO}</span> respectively. The oracles <span class="math">H_{1}</span> and <span class="math">H_{2}</span> are assumed independent and random and are consistent given duplicate queries. The signing oracle <span class="math">\\mathcal{SO}</span> is also allowed to query <span class="math">H_{1}</span></p>

    <p class="text-gray-300"><span class="math">H_{2}</span>. Given <span class="math">\\mathcal{A}</span>, I will show it is possible to create a PPT adversary <span class="math">\\mathcal{M}</span> which uses <span class="math">\\mathcal{A}</span> to find the discrete logarithm of one of the keys in <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">If <span class="math">L</span> is a set of key vectors <span class="math">\\{\\overline{y_{1}},...,\\overline{y_{n}}\\}</span> each of size <span class="math">r</span>, (i.e. <span class="math">\\overline{y_{i}}=(y_{1}^{i},...,y_{r}^{i})</span> with <span class="math">y_{1},...,y_{r}</span> public keys) then a forged signature</p>

    <p class="text-gray-300"><span class="math">\\sigma=(c_{1},s_{1},...,s_{n},y_{0})</span></p>

    <p class="text-gray-300">produced by <span class="math">\\mathcal{A}</span> must satisfy</p>

    <p class="text-gray-300"><span class="math">c_{i+1}=H\\left(\\mathfrak{m},L_{i}^{1},R_{i}^{1},...,L_{i}^{m},R_{i}^{m}\\right)</span></p>

    <p class="text-gray-300">where the <span class="math">i</span> are taken mod <span class="math">n</span>, and the <span class="math">L_{i}^{j}</span>, <span class="math">R_{i}^{j}</span> are defined as in section 2.2. The new adversary <span class="math">\\mathcal{M}</span> may call <span class="math">\\mathcal{A}</span> to forge signatures a polynomial number of times and will record each Turing script <span class="math">\\mathcal{T}</span> whether or not the forgery is successful.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300"><em>[x14, Lemma 1]</em> Let <span class="math">\\mathcal{M}</span> invoke <span class="math">\\mathcal{A}</span> to obtain a transcript <span class="math">\\mathcal{T}</span>. If <span class="math">\\mathcal{T}</span> is successful, then <span class="math">\\mathcal{M}</span> rewinds <span class="math">\\mathcal{T}</span> to a header <span class="math">H</span> and re-simulates <span class="math">\\mathcal{A}</span> to obtain transcript <span class="math">\\mathcal{T}^{\\prime}</span> . If <span class="math">\\Pr\\left(\\mathcal{T}\\text{ succeeds}\\right)=\\epsilon</span> , then <span class="math">\\Pr\\left(\\mathcal{T}^{\\prime}\\text{ succeeds}\\right)=\\epsilon</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows easily from the cited Theorem. ∎</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">The probability that an adversary <span class="math">\\mathcal{A}</span> forges a verifying MLSAG signature is negligible under the discrete logarithm assumption.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">I follow the notation introduced above. Similarly to <em>[x14, Theorem 1]</em>, since the probability of guessing the output of a random oracle is negligible, therefore, for each successful forgery <span class="math">\\mathcal{A}</span> complete</p>

    <p class="text-gray-300">with transcript <span class="math">\\mathcal{T}</span>, there are <span class="math">m_{\\mathcal{T}}</span> queries to <span class="math">H_{1}</span> matching the <span class="math">n</span> queries used to verify the signature. Thus let <span class="math">X_{i_{1}},...,X_{i_{m}}</span> denote these queries used in verification for the <span class="math">i^{th}</span> such forgery and let <span class="math">\\pi</span> be the index corresponding to the last such verification query for a given forgery</p>

    <p class="text-gray-300"><span class="math">X_{i_{m}}=H_{1}\\left(m,L^{1}_{\\pi-1},R^{1}_{\\pi-1},...,L^{m_{\\mathcal{T}}}_{\\pi-1},R^{m_{\\mathcal{T}}}_{\\pi-1}\\right).</span></p>

    <p class="text-gray-300">(Intuitively, <span class="math">\\pi</span> corresponds to what would be the secret index of the forged signature, since it corresponds to the last call to the random oracle for the given signature).</p>

    <p class="text-gray-300">An attempted forgery <span class="math">\\sigma</span> produced by <span class="math">\\mathcal{A}</span> is an <span class="math">(\\ell,\\pi)</span>-forgery if <span class="math">i_{1}=\\ell</span> and <span class="math">\\pi</span> is as above (so this forgery corresponds to queries <span class="math">\\ell</span> through <span class="math">\\ell+\\pi</span>). By assumption, there exists a pair <span class="math">(\\ell,\\pi)</span> such that the probability that the corresponding transcript <span class="math">\\mathcal{T}</span> gives a successful forgery, <span class="math">\\epsilon_{\\ell,\\pi}\\left(\\mathcal{T}\\right)</span>, satisfies</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\ell,\\pi}\\geq\\frac{1}{m_{\\mathcal{T}}\\left(q_{H}+m_{\\mathcal{T}}q_{S}\\right)}\\cdot\\frac{1}{Q_{1}\\left(k\\right)}\\geq\\frac{1}{n\\left(q_{H}+nq_{S}\\right)}\\cdot\\frac{1}{Q_{1}\\left(k\\right)}.</span></p>

    <p class="text-gray-300">Now, rewinding <span class="math">\\mathcal{T}</span> to just before the <span class="math">\\ell^{th}</span> query, and again attempting a forgery on the same set of keys, (and letting <span class="math">H_{1}</span> compute new coin flips for all of it’s succeeding queries) then by Lemma 6, it follows that the probability that <span class="math">\\mathcal{T}^{\\prime}</span> is also a successful forgery satisfies</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\ell,\\pi}\\left(\\mathcal{T}^{\\prime}\\right)\\geq\\frac{1}{n\\left(q_{H}+nq_{S}\\right)}\\cdot\\frac{1}{Q_{1}\\left(k\\right)}.</span></p>

    <p class="text-gray-300">Therefore, the probability that both <span class="math">\\mathcal{T}</span> and <span class="math">\\mathcal{T}^{\\prime}</span> correspond to verifying forgeries <span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span> is non-negligible:</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{l,\\pi}\\left(\\mathcal{T}\\ and\\ \\mathcal{T}^{\\prime}\\right)\\geq\\left(\\epsilon_{l,\\pi}\\left(\\mathcal{T}\\right)\\right)^{2}.</span></p>

    <p class="text-gray-300">As new coin-flips have been computed for the random oracle outputs of <span class="math">H_{1}</span>, it follows that with overwhelming probability there is <span class="math">j</span> such that <span class="math">s_{\\pi}^{j}\\neq s_{\\pi}^{\\prime j}</span> and <span class="math">c_{\\pi}\\neq c_{\\pi+1}</span>. Thus we can solve for the private key of index <span class="math">\\pi</span>:</p>

    <p class="text-gray-300"><span class="math">x_{\\pi}^{j}=\\frac{s_{\\pi}^{\\prime j}-s_{\\pi}^{j}}{c_{\\pi}-c_{\\pi}^{\\prime}}\\ mod\\ q</span></p>

    <p class="text-gray-300">which contradicts the discrete logarithm assumption. ∎</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.5. MLSAG Linkability</h3>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">(Key-Image Linkability) The probability that a PPT adversary <span class="math">\\mathcal{A}</span> can create two verifying (and unlinked in the given setting) signatures <span class="math">\\sigma,\\sigma^{\\prime}</span> signed with respect to key vectors <span class="math">\\overline{y}</span> and <span class="math">\\overline{y}^{\\prime}</span>respectively such that there exists a public key <span class="math">y</span> in both <span class="math">\\overline{y}</span> and <span class="math">\\overline{y}^{\\prime}</span> is negligible.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose to the contrary that <span class="math">\\mathcal{A}</span> has created two verifying signatures <span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span> both signed with respect to key vectors <span class="math">\\overline{y}</span> and <span class="math">\\overline{y}^{\\prime}</span> respectively such that there exists a public key <span class="math">y</span> in both <span class="math">\\overline{y}</span> and <span class="math">\\overline{y}^{\\prime}</span>. Let <span class="math">y</span> appear as element <span class="math">j</span> of <span class="math">\\overline{y}</span>, and as element <span class="math">j^{\\prime}</span> element of <span class="math">\\overline{y}^{\\prime}</span>. By Theorem 7, it holds with overwhelming probability that there exists indices <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> for the public keys in <span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span> respectively such that</p>

    <p class="text-gray-300"><span class="math">L_{\\pi}^{j}=s_{\\pi}^{j}G+c_{\\pi}y_{\\pi}^{j}</span> <span class="math">R_{\\pi}^{j}=s_{\\pi}^{j}H\\left(y_{\\pi}^{j}\\right)+c_{\\pi}I_{j}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">L^{j^{\\prime}}_{\\pi^{\\prime}}=s^{j^{\\prime}}_{\\pi^{\\prime}}G+c_{\\pi^{\\prime}}y^{j^{\\prime}}_{\\pi^{\\prime}}</span> <span class="math">R^{j^{\\prime}}_{\\pi^{\\prime}}=s^{j^{\\prime}}_{\\pi^{\\prime}}H\\left(y^{j^{\\prime}}_{\\pi^{\\prime}}\\right)+c_{\\pi^{\\prime}}I_{j^{\\prime}}</span></p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span class="math">log_{G}L^{j}_{\\pi}=log_{H\\left(y^{j}_{\\pi}\\right)}R^{j}_{\\pi}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">log_{G}L^{j^{\\prime}}_{\\pi^{\\prime}}=log_{H\\left(y^{j^{\\prime}}_{\\pi^{\\prime}}\\right)}R^{j^{\\prime}}_{\\pi^{\\prime}}</span></p>

    <p class="text-gray-300">Letting <span class="math">x</span> denote the private key of <span class="math">y</span>, <span class="math">y=xG</span>, then after solving the above for <span class="math">I_{j}</span> and <span class="math">I_{j^{\\prime}}</span> it follows that <span class="math">I_{j}=xH\\left(y^{j}_{\\pi}\\right)=xH\\left(y\\right)</span> and similarly <span class="math">I_{j^{\\prime}}=xH\\left(y\\right).</span> Thus the two signatures include <span class="math">I_{j}=I_{j^{\\prime}}</span>, and therefore, since duplicate key images are rejected, one of them must not verify. ∎</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.6. MLSAG Anonymity</h3>

    <p class="text-gray-300">To prove the anonymity of the above protocol in the random oracle model, let <span class="math">H_{1},H_{2}</span> be random oracles modeling discrete hash functions. Let <span class="math">\\mathcal{A}</span> be an adversary against anonymity. I construct an adversary <span class="math">\\mathcal{M}</span> against the Decisional Diffie Helman (DDH) assumption as follows. The DDH asumption says that given a tuple <span class="math">\\left(G,aG,bG,\\gamma G\\right)</span>, the probability of determining whether <span class="math">\\gamma G=abG</span> is negligible.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Ring CT protocol is signer-ambiguous under the Decisional Diffie-Helman assumption.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">(Similar proof to <em>[x10, Theorem 2]</em>) Assume that the Decisional Diffie-Helman problem is hard in the cyclic group generated by</p>

    <p class="text-gray-300"><span class="math">G</span> and suppose there exists a PPT adversary <span class="math">\\mathcal{A}</span> against signer ambiguity. Thus given a list <span class="math">L</span> of <span class="math">n</span> public key-vectors of length <span class="math">m</span>, a set of <span class="math">t</span> private keys <span class="math">\\mathcal{D}_{t}=\\{x_{1},...,x_{t}\\}</span>, a valid signature <span class="math">\\sigma</span> on <span class="math">L</span> signed by a user with respect to a key-vector <span class="math">\\overline{y}</span> such that the corresponding private key-vector <span class="math">\\overline{x}=(x_{1}^{\\pi},...,x_{m}^{\\pi})</span> satisfies <span class="math">x_{j}^{\\pi}\\notin\\mathcal{D}_{t}</span>, then <span class="math">\\mathcal{A}</span> can decide <span class="math">\\pi</span> with probability</p>

    <p class="text-gray-300"><span class="math">Pr\\left(\\mathcal{A}\\to\\pi\\right)&gt;\\frac{1}{n-t}+\\frac{1}{Q\\left(k\\right)}</span></p>

    <p class="text-gray-300">for some polynomial <span class="math">Q\\left(k\\right)</span>. I construct a PPT adversary <span class="math">\\mathcal{M}</span> which takes as inputs a tuple <span class="math">\\left(G,aG,bG,c_{i}G\\right)</span> where <span class="math">i\\in\\{0,1\\}</span> is randomly chosen (and not a priori known to <span class="math">\\mathcal{M}</span>), <span class="math">c_{1}=ab</span>, and <span class="math">c_{0}</span> is a random scalar, and outputs <span class="math">i</span> with probability</p>

    <p class="text-gray-300"><span class="math">Pr\\left(\\mathcal{M}\\left(G,aG,bG,c_{i}G\\right)\\to i\\right)\\geq\\frac{1}{2}+\\frac{1}{Q_{2}\\left(k\\right)}</span></p>

    <p class="text-gray-300">for some polynomial <span class="math">Q_{2}\\left(k\\right)</span>.</p>

    <p class="text-gray-300">Consider an algorithm SIMNIZKP (similar to the one defined in <em>[x10]</em>) which takes as input scalars <span class="math">a</span>, <span class="math">c</span> , a private key vector <span class="math">\\overline{x}</span>, a set of public key-vectors <span class="math">\\overline{y}_{i},i=1,...,m</span>, an index <span class="math">\\pi</span>, and a message <span class="math">\\mathfrak{m}</span> and acts on these as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate random scalars <span class="math">s_{1},...,s_{m}</span> and, a random scalar <span class="math">c_{\\pi}\\leftarrow H</span>.</li>

      <li>For <span class="math">j</span> indexing <span class="math">\\overline{x}</span>, set</li>

    </ol>

    <p class="text-gray-300"><span class="math">L_{\\pi}^{1}=aG</span> <span class="math">R_{\\pi}^{1}=cG</span></p>

    <p class="text-gray-300">and for all other <span class="math">j</span></p>

    <p class="text-gray-300"><span class="math">L_{\\pi}^{j}=s_{\\pi}^{j}G+c_{\\pi}y_{\\pi}^{j}</span></p>

    <p class="text-gray-300"><span class="math">R^{j}_{\\pi}=s^{j}_{\\pi}H\\left(y^{j}_{\\pi}\\right)+c_{\\pi}x^{j}H\\left(y^{j}_{\\pi}\\right)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a random output from the random oracle</li>

    </ol>

    <p class="text-gray-300"><span class="math">c_{\\pi+1}\\leftarrow H\\left(\\mathfrak{m},L^{1}_{\\pi},R^{1}_{\\pi},...,L^{m}_{\\pi},R^{m}_{\\pi}\\right).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i</span>, working mod <span class="math">m</span>, compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">L^{j}_{i}=s^{j}_{i}G+c_{i}y^{j}_{\\pi}</span> <span class="math">R^{j}_{i}=s^{j}_{i}H\\left(y^{j}_{i}\\right)+c_{i}x^{j}H\\left(y^{j}_{i}\\right)</span> <span class="math">c_{i+1}\\leftarrow H\\left(\\mathfrak{m},L^{1}_{i},R^{1}_{i},...,L^{m}_{i}+R^{m}_{i}\\right).</span></p>

    <p class="text-gray-300">and note that at the last step when <span class="math">i=\\pi-1</span>, then <span class="math">c_{i+1}</span> is already determined, to maintain consistency with the random oracle output.</p>

    <p class="text-gray-300">Note that regardless of whether <span class="math">\\overline{x}</span> is the actual private key corresponding to <span class="math">\\overline{y}</span>, due to the fact that consistency is maintained by the random oracles in subsequent calls, the above signature verifies. If <span class="math">\\overline{x}</span> is actually the private key-vector of <span class="math">\\overline{y}</span> , then there is no difference between SIMNIZKP and an actual signature.</p>

    <p class="text-gray-300">Finally, given a tuple <span class="math">(G,aG,bG,c_{i}G)</span> where <span class="math">a,b</span> are randomly selected scalars, with <span class="math">c_{1}=ab</span>, <span class="math">c_{0}</span> a random element, <span class="math">i\\in\\{0,1\\}</span>, <span class="math">\\mathcal{M}</span> takes the following steps to solve the Decisional Diffie Helman Problem with non-negligible probability. <span class="math">\\mathcal{M}</span> grabs a random <span class="math">\\gamma\\leftarrow H</span> from the random oracle and takes a private / public key-vector pair <span class="math">(\\overline{x},\\overline{y})</span>, and then computes <span class="math">s</span> such that <span class="math">a=s+\\gamma x</span>. Now <span class="math">\\mathcal{M}</span> performs SIMNIZKP with arbitrarily selected key-vectors <span class="math">\\left\\{\\overline{y_{i}}\\right\\}_{i=1,...,n}</span> such that <span class="math">\\overline{y}=\\overline{y}_{\\pi}</span>, <span class="math">a\\rightarrow a</span>, <span class="math">c_{i}\\rightarrow c</span> some message <span class="math">\\mathfrak{m}</span>, and <span class="math">\\overline{x}\\rightarrow\\overline{x}</span>.</p>

    <p class="text-gray-300">If it is the case that <span class="math">i=1</span>, then <span class="math">c=ab</span>, then</p>

    <p class="text-gray-300"><span class="math">log_{G}aG=log_{bG}cG=a</span></p>

    <p class="text-gray-300">and due to the fact that <span class="math">\\mathcal{A}</span> is assumed to be able to find <span class="math">\\pi</span> with non-negligible probability, then there is a non-negligible probability over <span class="math">\\frac{1}{2}</span> that <span class="math">\\mathcal{A}</span> returns <span class="math">1</span> (upon which <span class="math">\\mathcal{M}</span> returns <span class="math">1</span>). If <span class="math">i=0</span>, then <span class="math">\\mathcal{A}</span> returns <span class="math">1</span> only with probability <span class="math">\\frac{1}{2}</span>, and so for some non-negligible probability over <span class="math">\\frac{1}{2}</span>, <span class="math">\\mathcal{M}</span> returns the same value as <span class="math">\\mathcal{A}</span>, and thus solves the Decisional Diffie-Helman problem for randomly chosen scalars with non-negligible probability over <span class="math">\\frac{1}{2}</span>, which is a contradiction. ∎</p>

    <h2 id="sec-28" class="text-2xl font-bold">3. Background on Confidential Transactions</h2>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">3.1. Confidential Transactions in Bitcoin</h3>

    <p class="text-gray-300">In <em>[x14]</em>, Greg Maxwell describes Confidential Transactions which are a way to send Bitcoin transactions with the amounts hidden. The basic idea is to use a Pedersen Commitment and the method is well described in the cited source. In this paper I make a slight modification the the Confidential Transactions machinery in that rather than taking the commitments to sum to zero, I instead sign for the commitment, to prove I know a private key. This is described in more detail in the next section.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.2. Modification for Ring Signatures</h3>

    <p class="text-gray-300">Let <span class="math">G</span> be the ed25519 base-point. Let</p>

    <p class="text-gray-300"><span class="math">H=toPoint\\left(cn\\_fast\\_hash\\left(G\\right)\\right)</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">Note that not every hash gives a point in the group of the basepoint (i.e. <span class="math">H=\\psi G</span> for some unknown <span class="math">\\psi</span>) (which is contrary to what happens in secp256k1, the curve used by Bitcoin). However, it seems that choosing the basepoint itself works (I previously used H(123456G) which seemed more secure to me, but the basepoint is certainly a more natural choice). Choosing <span class="math">H=\\gamma G</span> for some unknown <span class="math">\\gamma</span> is necessary so that all the usual elliptic curve math holds.</p>

    <p class="text-gray-300">Under the discrete logarithm assumption on ed25519, the probability of an adversary discovering <span class="math">\\gamma</span> is negligible. Define <span class="math">C\\left(a,x\\right)=xG+aH</span>, the commitment to the value <span class="math">a</span> with mask <span class="math">x</span>. Note that as long as <span class="math">log_{G}H</span> is unknown, and if <span class="math">a\\neq 0</span>, then <span class="math">log_{G}C\\left(a,x\\right)</span> is unknown. On the other hand, if <span class="math">a=0</span>, then <span class="math">log_{G}C\\left(a,x\\right)=x</span>, so it is possible to sign with sk-pk keypair <span class="math">\\left(x,C\\left(0,x\\right)\\right).</span></p>

    <p class="text-gray-300">In <em>[x13]</em>, there are input commitments, output commitments, and the network checks that</p>

    <p class="text-gray-300"><span class="math">\\sum Inputs=\\sum Outputs.</span></p>

    <p class="text-gray-300">However, this does not suffice in Monero: Since a given transaction contains multiple possible inputs <span class="math">P_{i},i=1,...,n</span>, only one of which belong to the sender, (see <em>[x15, 4.4]</em>), then if we are able to check the above equality, it must be possible for the network to see which <span class="math">P_{i}</span> belongs to the sender of the transaction. This is undesirable, since it removes the anonymity provided by the ring signatures. Thus instead, commitments for the inputs and outputs are created as follows (suppose first that there is only one input)</p>

    <p class="text-gray-300"><span class="math">C_{in}=x_{c}G+aH</span> <span class="math">C_{out-1}=y_{1}G+b_{1}H</span> <span class="math">C_{out-2}=y_{2}G+b_{2}H</span></p>

    <p class="text-gray-300">such that <span class="math">x_{c}=y_{1}+y_{2}+z</span>, <span class="math">x_{c}-y_{1}-y_{2}=z</span>, <span class="math">y_{i}</span> are mask values, <span class="math">z&gt;0</span> and <span class="math">a=b_{1}+b_{2}.</span> Here <span class="math">x_{c}</span> is a special private key the “amount key” known only to the sender, and to the person who sent them their coins, and must be different than their usual private key. In this case,</p>

    <p class="text-gray-300"><span class="math">C_{in}-\\sum_{i=1}^{2}C_{out-i}</span> <span class="math">=x_{c}G+aH-y_{1}G-b_{1}H-y_{2}G-b_{2}H</span> <span class="math">=zG.</span></p>

    <p class="text-gray-300">Thus, the above summation becomes a commitment to <span class="math">0</span>, with <span class="math">sk=z</span>, and <span class="math">pk=zG</span>, rather than an actual equation summing to zero. Note that <span class="math">z</span> is not computable to the originator of <span class="math">x_{c}</span>’s coins, unless they know both of the <span class="math">y_{1},y_{2}</span>, but even this can be simply mitigated by including an additional change address (the usual case is that the second commitment, with <span class="math">y_{2}</span> as mask, is sent to yourself as change).</p>

    <p class="text-gray-300">Since it is undesirable to show which input belongs to the sender, a ring signature consisting of all the input commitments <span class="math">C_{i},i=1,...,s,...,n</span> (where <span class="math">s</span> is the secret index of the commitment of the sender), adding the corresponding pubkey (so commitments and pubkeys are paired (<span class="math">C_{i},P_{i}</span>) only being allowed to be spent together) and subtracting <span class="math">\\sum C_{out}</span></p>

    <p class="text-gray-300">is created:</p>

    <p class="text-gray-300"><span class="math">\\left\\{P_{1}+C_{1,in}-\\sum_{j}C_{j,out},...,P_{s}+C_{s,in}-\\sum_{j}C_{j,out},...,P_{n}+C_{n,in}-\\sum_{j}C_{j,out}\\right\\}.</span></p>

    <p class="text-gray-300">This is a ring signature which can be signed since we know one of the private keys (namely <span class="math">z+x^{\\prime}</span> with <span class="math">z</span> as above and <span class="math">x^{\\prime}G=P_{s}</span>). In fact, since we know, for each <span class="math">i</span>, both the private key for <span class="math">P_{i}</span> and the private key for <span class="math">P_{i}+C_{i,in}-\\sum_{j}C_{j,out}</span>, we can perform a signature as in section 2.2. This precise details are described in Definition 10.</p>

    <p class="text-gray-300">As noted in <em>[x13]</em>, it is important to prove that the output amounts <span class="math">b_{1},...b_{n}</span> all lie in a range of positive values, e.g. <span class="math">(0,2^{16})</span>. This can be accomplished essentially the same way as in <em>[x13]</em> and is described in more detail in section 5.</p>

    <p class="text-gray-300">Finally, note that in the above, I have not made any mention of the tag-linkability property which is used in Monero and Cryptonote to prevent double-spends. The tag-linkability property here will result from combining the above discussion with the MLSAG signatures as described in Definition 10.</p>

    <h2 id="sec-31" class="text-2xl font-bold">4. Ring CT For Monero Protocol</h2>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.1. Protocol Description</h3>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">(Tag-Linkable Ring-CT with Multiple Inputs and One-time Keys)</p>

    <p class="text-gray-300">RING CONFIDENTIAL TRANSACTIONS</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\{(P_{\\pi}^{1}, C_{\\pi}^{1}), \\ldots, (P_{\\pi}^{m}, C_{\\pi}^{m})\\}</span>  be a collection of addresses / commitments with corresponding secret keys  <span class="math">x_{j}</span> ,  <span class="math">j = 1, \\ldots, m</span> .</li>

      <li>Find  <span class="math">q + 1</span>  collections  <span class="math">\\{(P_i^1, C_i^1), \\dots, (P_i^m, C_i^m)\\}</span> ,  <span class="math">i = 1, \\dots, q + 1</span>  which are not already tag linked in the sense of [FS07, page 6].</li>

      <li>Decide on a set of output addresses  <span class="math">(Q_{i}, C_{i,out})</span>  such that  <span class="math">\\sum_{j=1}^{m} C_{\\pi}^{j} - \\sum_{i} C_{i,out}</span>  is a commitment to zero.</li>

      <li>Let</li>

    </ul>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathfrak {R} := \\left\\{\\left\\{\\left(P _ {1} ^ {1}, C _ {1} ^ {1}\\right), \\dots , \\left(P _ {1} ^ {m}, C _ {1} ^ {m}\\right), \\left(\\sum_ {j} P _ {1} ^ {j} + \\sum_ {j = 1} ^ {m} C _ {1} ^ {j} - \\sum_ {i} C _ {i, o u t}\\right) \\right\\}, \\right. \\\\ \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\left. \\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\</p>

    <p class="text-gray-300">it is probably not necessary to include the key-image of the commitment entry of the above signature. Further size optimizations are likely possible.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.2. Conversion from Visible Denominations to Commitments</h3>

    <p class="text-gray-300">As Monero currently uses Blockchain visible scalars to represent amounts, it is important that there is a way to convert from visible amounts to commitments while preserving anonymity. In fact, this is not difficult. Given a pair <span class="math">(P,a)</span> where <span class="math">P</span> is a public key and <span class="math">a</span> represents an amount, this may be used as the input to a transaction as <span class="math">(P,aH)</span>, and it must be checked by the verifier that the input amount <span class="math">a</span> multiplied by the masking point <span class="math">H</span>, indeed gives <span class="math">aH</span>. Thus at the first step, the input amounts will not be hidden, but the outputs of this transaction can be hidden, and all the necessary relations outlined in section 4 hold. Note that a range proof is not necessary for such an input.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Remark 12.</h6>

    <p class="text-gray-300">The obvious benefit of this method of converting from visible amounts to commitments is that the amount of coins generated by the mining process is trustlessly verifiable. This is an advantage of the Ring CT protocol over payment schemes such as <em>[BSCG^{+}14]</em> which rely on a trusted setup phase.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.3. Transaction Fees</h3>

    <p class="text-gray-300">As Monero is strongly decentralized (i.e. proof of work) it is necessary to pay miners a transaction fee for each transaction. This helps with the network security to prevent blockchain bloat. These fees must be paid "unmasked" i.e. just as <span class="math">bH</span>, rather than <span class="math">xG+bH</span>, and for some standardized amount <span class="math">b</span> so that the miner</p>

    <p class="text-gray-300">can verify that <span class="math">b\\cdot H=bH</span> and thus there is enough money for the transaction fee while still having the equations in terms of <span class="math">H</span> so the necessary relations of section 4 hold.</p>

    <h2 id="sec-37" class="text-2xl font-bold">5. Aggregate Schnorr Range Proofs</h2>

    <p class="text-gray-300">In <em>[x13]</em>, the confidential transactions without ring signatures uses a type of ring signature based on <em>[x1]</em> called a Borromean ring signature, which helps to prove a committed value lies within a certain range. In this article, I will outline an alternative method, inspired by <em>[x10]</em>, which has the same space savings, but perhaps simpler security proofs. The motivation for this is as follows: Suppose that a given transaction has input commitments</p>

    <p class="text-gray-300"><span class="math">C_{in}=a_{in}G+10H</span></p>

    <p class="text-gray-300">and output commitments</p>

    <p class="text-gray-300"><span class="math">C_{out,1}=a_{out,1}G+5H,\\ C_{out,2}=a_{out,2}G+5H</span></p>

    <p class="text-gray-300">this scenario is valid as it is possible to sign for</p>

    <p class="text-gray-300"><span class="math">C_{in}-C_{out,1}-C_{out,2}=\\left(a_{in}-a_{out,1}-a_{out,2}\\right)G</span></p>

    <p class="text-gray-300">However, note that (without range proofs) it would be possible to alternatively set output commitments</p>

    <p class="text-gray-300"><span class="math">C_{out,1}=a_{out,1}G-H,\\ C_{out,2}=a_{out,2}G+11H</span></p>

    <p class="text-gray-300">as <span class="math">-1</span> is a very large number modulo the curve group order, free money has been created. It is therefore necessary to prove that the <span class="math">C_{out,i}</span> are commitments to values which are positive and lie in a restricted range <span class="math">[0,2^{n}]</span> for some <span class="math">n</span>. To do this, one decomposes each output value into binary:</p>

    <p class="text-gray-300"><span class="math">b=b_{0}2^{0}+b_{1}2^{1}+b_{2}2^{2}+\\cdots+b_{n}2^{n}</span></p>

    <p class="text-gray-300">and computes commitments <span class="math">C_{out,i}^{j}</span> to <span class="math">b_{j}\\cdot 2^{j}</span> and such that</p>

    <p class="text-gray-300"><span class="math">C_{out,i}^{1}+C_{out,i}^{2}+\\cdots+C_{out,i}^{n}=C_{out,i}</span></p>

    <p class="text-gray-300">Finally, using secret key <span class="math">b_{j}</span>, one computes a ring signature on</p>

    <p class="text-gray-300"><span class="math">(C_{out,i}^{j},C_{out,i}^{j}-2^{j}H)</span></p>

    <p class="text-gray-300">for all <span class="math">j</span> and provides the <span class="math">C_{out,i}^{j}</span> to the verifying parties (in this case, the miners).</p>

    <p class="text-gray-300">For space savings, one can either use a Borromean ring signature (as in <em>[x13]</em>) to combine all of these simple ring signatures, or a type of aggregate ring signature defined as follows:</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">5.0.1. Aggregate Schnorr Non-linkable Ring Signature (ASNL) Generation</h4>

    <p class="text-gray-300">Let <span class="math">(x_{i}^{j},P_{1}^{j},P_{2}^{j})</span> be a set of keys, <span class="math">j=1,...,n</span> with <span class="math">x_{i}^{j}</span> the secret key of <span class="math">P_{i}^{j}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">j</span>, let <span class="math">i^{\\prime}:=i+1</span> mod <span class="math">2</span>, set <span class="math">\\alpha_{j}</span> a random scalar, and compute <span class="math">L_{i}^{j}=\\alpha_{j}G</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">c_{i^{\\prime}}^{j}=H_{s}(L_{i}^{j})</span>, where <span class="math">H_{s}</span> is a cryptographic hash function returning a scalar, and after choosing <span class="math">s_{i^{\\prime}}^{j}</span> random, compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">L_{i^{\\prime}}^{j}=s_{i^{\\prime}}G+c_{i^{\\prime}}H.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">c_{i}=H_{s}(L_{i^{\\prime}}^{j})</span> and compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">s_{i}^{j}=\\alpha-c_{i}^{j}x_{i}\\ mod\\ \\ell</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">(L_{1}^{j},s_{2}^{j})</span> for all <span class="math">j</span> and <span class="math">s=\\sum_{j}s_{1}^{j}</span>.</li>

    </ul>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">5.0.2. Aggregate Schnorr Non-linkable Ring Signature (ASNL) Verification</h4>

    <p class="text-gray-300">Start with <span class="math">(P_{1}^{j},P_{2}^{j},L_{1}^{j},s_{2}^{j})</span> for <span class="math">j=1,...,n</span> and <span class="math">s</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">j</span>, compute <span class="math">c_{2}^{j}=H_{s}(L_{1}^{j})</span>, <span class="math">L_{2}^{j}=s_{2}^{j}G+c_{2}^{j}H</span>, and <span class="math">c_{1}^{j}=H_{s}(L_{2}^{j})</span>.</li>

      <li>If <span class="math">\\sum_{j=1}^{n}L_{1}^{j}=sG+(c_{1}^{j}+\\cdots+c_{n}^{j})H</span> then return <span class="math">0</span> for a valid signature. Otherwise return <span class="math">-1</span>.</li>

    </ul>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 13.</h6>

    <p class="text-gray-300">The Aggregate Schnorr Non-linkable ring signature is unforgeable under the discrete logarithm assumption.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">I sketch a proof in the case <span class="math">n=2</span>. The general case is similar. Suppose that an adversary <span class="math">\\mathcal{A}</span> is able to forge an ASNL signature on</p>

    <p class="text-gray-300"><span class="math">\\big{\\{}(x_{i}^{1},P_{1}^{1},P_{2}^{1}),(x_{i}^{2},P_{1}^{2},P_{2}^{2})\\big{\\}}</span></p>

    <p class="text-gray-300">with non-negligible probability while knowing at most one of the <span class="math">x_{i}^{j}</span> (suppose without loss of generality that <span class="math">\\mathcal{A}</span> knows <span class="math">x_{i}^{1}</span>). For any given such forgery:</p>

    <p class="text-gray-300"><span class="math">\\{s,(P_{1}^{j},P_{2}^{j},L_{1}^{j},s_{2}^{j})\\},\\ j=1,2,</span></p>

    <p class="text-gray-300">I solve the discrete logarithm of <span class="math">P_{1}^{2}</span> with non-negligible probability. Following the verification algorithm, let <span class="math">c_{1}^{j}=H_{s}\\left(s_{2}^{j}G+H_{s}(L_{1}^{j})H\\right)</span>. It must then be true that</p>

    <p class="text-gray-300"><span class="math">L_{1}^{1}+L_{1}^{2}=sG+\\left(c_{1}^{1}P_{1}^{1}+c_{1}^{2}P_{1}^{2}\\right).</span></p>

    <p class="text-gray-300">Supposing that <span class="math">L_{1}^{1}=aG</span> and <span class="math">L_{1}^{2}=bG</span> with <span class="math">a,b</span> known to <span class="math">\\mathcal{A}</span>, then</p>

    <p class="text-gray-300"><span class="math">aG+bG-sG-c_{1}^{1}P_{1}^{1}=c_{1}^{2}P_{1}^{2}</span></p>

    <p class="text-gray-300">so, as <span class="math">c_{1}^{2}</span> is determined by the verification protocol, it must be the case that <span class="math">\\mathcal{A}</span> knows the private key of <span class="math">P_{1}^{2}</span>,</p>

    <p class="text-gray-300"><span class="math">x_{1}^{2}:=\\frac{a+b-s-c_{1}^{1}x_{1}^{1}}{c_{1}^{2}}\\mod\\ell</span></p>

    <p class="text-gray-300">This contradicts the discrete logarithm assumption for the given group. ∎</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.1. Representing Amounts</h3>

    <p class="text-gray-300">Amounts in the Ring CT protocol be represented in essentially the same manner as in <em>[x13]</em>.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">5.1.1. Passing Amounts to Receiver</h4>

    <p class="text-gray-300">Now, given any output amount, <span class="math">b=b_{0}2^{0}+b_{1}2^{1}+\\cdots b_{n}2^{n}</span>, a sender computes a new private /public key pair and corresponding shared ECDH secret <span class="math">ss</span> and makes the following information available in their transaction:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C_{j}=a_{j}G+(b_{j}2^{j})H</span> where <span class="math">a_{i}</span> are some random numbers for <span class="math">j=0,...,n</span>.</li>

      <li>The data <span class="math">\\left\\{(L_{1}^{i},s_{2}^{j}),s\\right\\}</span>.</li>

      <li>ECDH public key and <span class="math">a+ss\\ mod\\ \\ell</span> where <span class="math">a=a_{0}+\\cdots+a_{n}</span>.</li>

    </ul>

    <p class="text-gray-300">The receiver then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computes their shared secret <span class="math">ss</span> and computes <span class="math">a</span> from <span class="math">a+ss\\ mod\\ \\ell</span>.</li>

      <li>Computes <span class="math">C=\\sum C_{i}</span>, computes <span class="math">C-aG=bH</span>, and finds <span class="math">b</span> by comparing to all <span class="math">bH</span> in the given range <span class="math">[0,2^{n}]</span>. (In practice this will be a quick 500 kilobyte lookup with <span class="math">n=14</span> as in the previous section. If on the other hand <span class="math">2^{32}</span> were to be chosen as the upper limit value, as in <em>[x14]</em>, the search would become computationally intensive).</li>

    </ul>

    <h2 id="sec-44" class="text-2xl font-bold">6. Ring CT Demo Code</h2>

    <p class="text-gray-300">In the repository at <em>[x15]</em> I have created a simple demonstration of the Ring Confidential Transactions protocol utilizing the MLSAG signatures of section 2 and the ASNL signatures of section 5:</p>

    <p class="text-gray-300">H_ct = RingCT.getHForCT()</p>

    <p class="text-gray-300">print("H", H_ct)</p>

    <p class="text-gray-300">sr, Pr = PaperWallet.skpkGen() #receivers private/ public</p>

    <p class="text-gray-300">se, pe, ss = ecdh.ecdhgen(Pr) #compute shared secret ss</p>

    <p class="text-gray-300">digits = 14 #in practice it will be 14</p>

    <p class="text-gray-300">print("inputs")</p>

    <p class="text-gray-300">Cia, L1a, s2a, sa, ska = RingCT.genRangeProof(10000, digits)</p>

    <p class="text-gray-300">print("outputs")</p>

    <p class="text-gray-300">Cib, L1b, s2b, sb, skb = RingCT.genRangeProof(7000, digits)</p>

    <p class="text-gray-300">Cic, L1c, s2c, sc, skc = RingCT.genRangeProof(3000, digits)</p>

    <p class="text-gray-300">print("verifying range proofs of outputs")</p>

    <p class="text-gray-300">RingCT.verRangeProof(Cib, L1b, s2b, sb) RingCT.verRangeProof(Cic, L1c, s2c, sc) x, P1 = PaperWallet.skpkGen() P2 = PaperWallet.pkGen() C2 = PaperWallet.pkGen()</p>

    <p class="text-gray-300">#some random commitment grabbed from the blockchain ind = 0 Ca = RingCT.sumCi(Cia) Cb = RingCT.sumCi(Cib) Cc = RingCT.sumCi(Cic) sk = [x, MiniNero.sc_sub_keys(ska, MiniNero.sc_add_keys(skb, skc))] pk = [[P1, P2], [MiniNero.subKeys(Ca, MiniNero.addKeys(Cb, Cc)), \\ MiniNero.subKeys(C2, MiniNero.addKeys(Cb, Cc)) ] ] II, cc, ssVal = MLSAG.MLSAG_Sign(pk, sk, ind) print("Sig verified?", MLSAG.MLSAG_Ver(pk, II, cc, ssVal) ) print("Finding received amount corresponding to Cib") RingCT.ComputeReceivedAmount(pe, sr, MiniNero.addScalars(ss, skb), Cib) print("Finding received amount corresponding to Cic") RingCT.ComputeReceivedAmount(pe, sr, MiniNero.addScalars(ss, skc), Cic)</p>

    <pre><code class="language-text">
Here is an example transaction with input $10,000$ and outputs $3,000$ and $7,000$.
</code></pre>

    <p class="text-gray-300">(’H’, ’61fe7f0f5a607a33427d01dd1fded5ffa03fae2e9df9ebccf2e0a2f5bd77a204’) inputs (’b, b in binary’, 10000, [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1])</p>

    <p class="text-gray-300">RING CONFIDENTIAL TRANSACTIONS</p>

    <p class="text-gray-300">Generating Aggregate Schnorr Non-linkable Ring Signature outputs (’b, b in binary’, 7000, [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0]) Generating Aggregate Schnorr Non-linkable Ring Signature (’b, b in binary’, 3000, [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0]) Generating Aggregate Schnorr Non-linkable Ring Signature verifying range proofs of outputs Verifying Aggregate Schnorr Non-linkable Ring Signature Verified Verifying Aggregate Schnorr Non-linkable Ring Signature Verified (’Generating MLSAG sig of dimensions ’, 2, ’x ’, 2) (’verifying MLSAG sig of dimensions ’, 2, ’x ’, 2) (’c’, [’80a3cfd06dd2862307cd75c2a1566f20cd743ddb0b9feb22d79dcbecb9023f42’, ’a9b7342ba7bf2f102505ca19dab734fde638916c0a29f5b30e49833ab51393ea’, ’80a3cfd06dd2862307cd75c2a1566f20cd743ddb0b9feb22d79dcbecb9023f42’]) (’sig verifies?’, True) (’Sig verified?’, True) Finding received amount corresponding to Cib (’received ’, 7000, ’a488ec68732fb551841c2c6dcc7ffac895d98ec7e9378275ed20ea12805fc18e’) Finding received amount corresponding to Cic (’received ’,3000, ’1b46626858e130a0f3884c74c9fdeabc4d812c519103ea16a35a3f82a3d0ed6d’)</p>

    <h2 id="sec-45" class="text-2xl font-bold">7. Conclusion</h2>

    <p class="text-gray-300">The Ring Confidential Transactions protocol provides a strongly decentralized cryptocurrency (i.e. there is no privileged party) which has provable security estimates regarding the hiding of amounts, origins and destinations. In addition, coin generation in the Ring Confidential Transactions protocol is trustless and verifiably secure. These five factors are a necessity of a cash-like crypto-currency such as Monero.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AMT15] Surae Noether Adam Mackenzie and Monero Core Team. Improving obfuscation in the cryptonote protocol, jan 2015.</li>

      <li>[AOS02] Masayuki Abe, Miyako Ohkubo, and Koutarou Suzuki. 1-out-of-n signatures from a variety of keys. Advances in Cryptology?Asiacrypt 2002, pages 415–432, 2002.</li>

      <li>[Bac13] Adam Back. Bitcoins with homomorphic value (validatable but encrypted). https://bitcointalk.org/index.php?topic=305791.0, 2013. [Online; accessed 1-May-2015].</li>

      <li>[Bac15] Adam Back. Ring signature efficiency. https://bitcointalk.org/index.php?topic=972541.msg10619684#msg10619684, 2015. [Online; accessed 1-May-2015].</li>

      <li>[BSCG^{+}14] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In Security and Privacy (SP), 2014 IEEE Symposium on, pages 459–474. IEEE, 2014.</li>

      <li>[DH14] Evan Duffield and Kyle Hagan. Darkcoin: Peertopeer cryptocurrency with anonymous blockchain transactions and an improved proofofwork system. 2014.</li>

    </ul>

    <p class="text-gray-300">[FS07] Eiichiro Fujisaki and Koutarou Suzuki. Traceable ring signature. In Public Key Cryptography–PKC 2007, pages 181–200. Springer, 2007.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Her05] Javier Herranz. Aggregate signatures. http://www.iiia.csic.es/~jherranz/papers/Nijmegen_seminar_aggregate.pdf, oct 2005.</li>

      <li>[LWW04] Joseph K Liu, Victor K Wei, and Duncan S Wong. Linkable spontaneous anonymous group signature for ad hoc groups. In Information Security and Privacy, pages 325–335. Springer, 2004.</li>

      <li>[Max13] Greg Maxwell. Coinjoin: Bitcoin privacy for the real world, august 2013. Bitcoin Forum. https://bitcointalk.org/index.php?topic=279249.0, 2013. [Online; accessed 1-July-2015].</li>

      <li>[Max15] Greg Maxwell. Confidential Transactions. https://people.xiph.org/~greg/confidential_values.txt, 2015. [Online; accessed 1-June-2015].</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Consulted, 1(2012):28, 2008.</li>

      <li>[Noe15] Shen Noether. Mininero. https://github.com/ShenNoether/MiniNero, 2015.</li>

      <li>[RST01] Ronald L Rivest, Adi Shamir, and Yael Tauman. How to leak a secret. In Advances in Cryptology???ASIACRYPT 2001, pages 552–565. Springer, 2001.</li>

      <li>[vS13] Nicolas van Saberhagen. Cryptonote v 2. 0. HYPERLINK https://cryptonote.org/whitepaper.pdf, 2013.</li>

    </ul>`;
---

<BaseLayout title="Ring Signature Confidential Transactions for Monero (2015/1098)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1098
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
