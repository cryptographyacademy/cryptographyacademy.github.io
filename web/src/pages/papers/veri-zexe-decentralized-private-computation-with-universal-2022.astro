---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/802';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'VERI-ZEXE: Decentralized Private Computation with Universal Setup';
const AUTHORS_HTML = 'Alex Luoyuan Xiong, Binyi Chen, Zhenfei Zhang, Benedikt Bünz, Ben Fisch, Fernando Krell, Philippe Camacho';

const CONTENT = `    <p class="text-gray-300">Alex Luoyuan Xiong^{1}, Binyi Chen^{2}, Zhenfei Zhang^{3}, Benedikt Bünz^{4}, Ben Fisch^{5}, Fernando Krell^{6}, and Philippe Camacho^{7} ^{1,2,3,4,5,6,7}Espresso Systems ^{1}National University of Singapore ^{4}Stanford University ^{5}Yale University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Traditional blockchain systems execute program state transitions <em>on-chain</em>, requiring each network node participating in state-machine replication to re-compute every step of the program when validating transactions. This limits both scalability and privacy. Recently, Bowe <em>et al.</em> introduced a primitive called <em>decentralized private computation</em> (DPC) and provided an instantiation called Zexe, which allows users to execute arbitrary computations <em>off-chain</em> without revealing the program logic to the network. Moreover, transaction validation takes only constant time, independent of the off-chain computation. However, Zexe required a separate trusted setup for each application, which is highly impractical. Prior attempts to remove this per-application setup incurred significant performance loss.</p>

    <p class="text-gray-300">We propose a new DPC instantiation VeriZexe that is highly efficient and requires only a single universal setup to support an arbitrary number of applications. Our benchmark improves the state-of-the-art by 9x in transaction generation time and by 3.4x in memory usage. Along the way, we also design efficient gadgets for variable-base multi-scalar multiplication and modular arithmetic within the Plonk constraint system, leading to a Plonk verifier gadget using only <span class="math">\\sim 21k</span> constraints.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300"><em>Distributed ledgers</em> are replicated state machines maintained by a network of potentially faulty nodes via a distributed consensus algorithm. The state machine might range from a specialized accounting system, as in Bitcoin <em>[48]</em>, to a Turing complete virtual machine, as in Ethereum <em>[56]</em>, where any user can instantiate a stateful program called a <em>smart contract</em>. These platforms are resilient to failures or even malicious behavior by a subset of the network nodes. This resilience enables a new class of applications in cryptocurrencies, governance, digital collectibles, and more. Unfortunately, privacy, which is paramount for many applications, is disregarded in ledger systems like Bitcoin and Ethereum.</p>

    <p class="text-gray-300">There is a rich literature of work attempting to improve privacy guarantees on distributed ledgers <em>[6, 17, 22, 23, 43, 49]</em>.The Zerocash protocol <em>[6]</em> is a privacy-preserving payment system that achieves user anonymity and amount confidentiality in transactions. Hawk <em>[43]</em> proposes a smart-contract framework that preserves program data privacy. Zether <em>[17]</em> enables confidential transactions among publicly known smart contracts and hides the identities of transacting parties within a small anonymity set. All of these prior designs, however, are either limited to a fixed functionality (e.g., payments) or lack function privacy, i.e. transactions do not hide which smart contract is being executed. Zexe <em>[14]</em> addresses this by proposing a new cryptographic primitive called <em>decentralized private computation</em> (DPC) scheme that achieves both data privacy and function privacy for arbitrary user-defined programs. The scheme hides from the network nodes both the states and the logic of the programs being called in each transaction. Users in DPC schemes execute computations offline and update the ledger by sending a transaction with a publicly verifiable cryptographic proof attached, attesting to the correctness of the computation.</p>

    <p class="text-gray-300">The core building block in a DPC construction is a <em>Succinct Non-interactive ARgument of Knowledge</em> (SNARK) proving system <em>[9]</em>. A SNARK system for a binary relation <span class="math">\\mathcal{R}</span> provides a prover algorithm <span class="math">\\mathcal{P}(x,w)</span> that on any valid <em>public inputs</em> and <em>private witness</em> pair <span class="math">(x,w)\\in\\mathcal{R}</span> outputs a valid and succinct proof <span class="math">\\pi</span>, and a verifier algorithm <span class="math">\\mathcal{V}(x,\\pi)</span> that always accepts valid proofs and rejects invalid proofs with overwhelming probability. A zkSNARK proof additionally guarantees the <em>zero-knowledge</em> property, thus leaking no information about the witness <span class="math">w</span>. We generally encode <span class="math">\\mathcal{R}</span> using “circuit" or various <em>constraint systems</em>, which outputs 1 on input <span class="math">(x,w)</span> if and only if <span class="math">(x,w)\\in\\mathcal{R}</span>. The SNARK system may also require a trusted setup procedure to generate a structured reference string (SRS), which is an input to both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. A SNARK system is <em>universal</em> if it has a single setup to generate a single SRS that can be reused for all circuits, and <em>non-universal</em> if it requires a new setup per circuit. The original Zexe <em>[14]</em> system uses a non-universal scheme <em>[36, 38]</em>, thus requiring</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Implementation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Universal Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transaction Generation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Original ZEXE [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">14.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">6.56 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">15 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.482 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkVM testnet-2</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">151.4 s</td>

            <td class="px-3 py-2 border-b border-gray-700">22.81 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">15 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.482 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VERIZEXE (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">6.61 GB</td>

            <td class="px-3 py-2 border-b border-gray-700">18 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4.138 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of three DPC implementations for 2-input-2-output transaction. Both verification time and proof size are constant and independent of transaction dimension (number of input and output records), whereas transaction generation time and memory usage grow with larger transaction dimensions. Details in § 4.</p>

    <p class="text-gray-300">a trusted setup for every application. As this is extraordinarily inconvenient in practice, the authors also suggest an alternative instantiation from universal SNARKs [24], which requires a one-time setup to support all future applications up to maximum circuit complexity. However, the performance of this alternative instantiation is significantly worse than the original protocol due to the higher complexity of the universal SNARK verification logic and the fact that ZEXE requires producing a proof for a circuit that encodes the SNARK verification logic. Specifically, its transaction generation speed is an order of magnitude slower than that in the original ZEXE. Hence we ask the following question:</p>

    <p class="text-gray-300">Problem 1. Can we obtain DPC with universal setup without sacrificing transaction generation speed?</p>

    <p class="text-gray-300">We answer the above question in the affirmative. The contributions of this paper are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VERIZEXE, a DPC scheme instantiation that supports both one-time universal system setup and efficient transaction generation comparable to ZEXE (see Table 1), while keeping constant on-chain verification cost independent of offline computation.</li>

      <li>Constraint designs for efficient variable-base MSM and modular arithmetics, leading to a PLONK verifier gadget taking only  <span class="math">\\sim 21k</span>  PLONK constraints <span class="math">^2</span>  which are of independent interests. <span class="math">^3</span></li>

      <li>Implementation (open-sourced <span class="math">^4</span> , written in Rust) and evaluation of VERIZEXE showing its practicality and most notably its 9x improvement on transaction generation time and 3.4x improvement on memory usage over the prior state-of-the-art.</li>

    </ul>

    <p class="text-gray-300">In a DPC scheme, the distributed ledger keeps track of records, the basic unit of data, each consisting of a data payload (state), a birth  <span class="math">\\Phi_{b}</span>  and death  <span class="math">\\Phi_{d}</span>  predicate governing the rules of its creation and consumption (program logic). A transaction, by consuming existing records and creating new records, represents the resulting state transition from some offline program execution. Execution correctness is captured in relation  <span class="math">\\mathcal{R}_e</span>  which enforces  <span class="math">⑧</span>  the existence and rightful ownership of the consumed records;  <span class="math">⑥</span>  valid openings of new record commitments and consumed records nullifiers; and  <span class="math">⑩</span>  satisfiability of death predicates of all consumed records and birth predicates of newly created records. For efficiency reason,  <span class="math">\\mathcal{R}_e</span>  is split into  <span class="math">\\mathcal{R}_{\\mathrm{ut}\\times \\circ}</span>  for condition  <span class="math">⑧</span>  and  <span class="math">⑥</span> , and  <span class="math">\\mathcal{R}_{\\Phi}</span>  for condition  <span class="math">⑩</span> .</p>

    <p class="text-gray-300">The life cycle of transactions starts with ① a user (or a group collectively) executing programs offline by assembling existing records, creating new records with updated payload, and generating two zkSNARK proofs (one for  <span class="math">\\mathcal{R}_{\\mathrm{ut}\\times \\circ}</span>  and one for  <span class="math">\\mathcal{R}_{\\Phi}</span> ) to testify the transaction validity. For  <span class="math">\\mathcal{R}_{\\Phi}</span> , users first generate several inner proofs each attesting to the satisfiability of one of the relevant predicates, then further generate a single outer proofs attesting the correctness of all inner proofs. Then ② users submit their transactions, containing unlinkable nullifiers of consumed records and hiding commitments of new records together with two zkSNARK proofs which reveal nothing about the program data or the predicates/programs involved, to ledger maintainers. Upon receiving transactions, ③ ledger maintainers verify SNARK proofs and update global states by inserting new record commitments and old record nullifiers into the ledger.</p>

    <p class="text-gray-300">A motivating use case is a permissionless multi-asset trading platform that minimizes front-running, censorship, and traffic analysis. Trades on public blockchains like Ethereum have no privacy, leading to front-running arbitrage by the miners [25], and deanonymization as a service. For blockchains with only data privacy, even though the exact amount and trading accounts are hidden, the programs the transaction is interacting with are still visible, which leaks the asset types involved in a trade. This metadata alone can result in preferential censorship by miners who want to block transactions of certain asset types, and traffic analysis with pattern association of side information off-chain which compromises privacy.</p>

    <p class="text-gray-300">Luckily, DPC-based blockchains would guarantee both data and function privacy of trading transactions, leaking no exploitable information to the miners or the public, thus greatly eliminating the previous issues.</p>

    <p class="text-gray-300">We refer to the original paper <em>[14]</em> for detailed definitions, security properties of the DPC model, and more example applications.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Our Techniques</h3>

    <p class="text-gray-300">Zexe <em>[14]</em> instantiates both the outer proof and the inner predicate proofs with SNARK schemes that require predicate-specific trusted setups. Instead, we propose the use of SNARKs with universal setup parameters that can be reused for all predicates. To make VeriZexe efficient we need to overcome several obstacles when encoding the verifier logic of a universal SNARK inside a circuit:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pairing checks: SNARKs that utilize pairing-based <em>Polynomial Commitment Scheme</em> (PCS) (such as KZG <em>[40]</em> and its variants <em>[24]</em>, see definitions in Appx. B.2) require some pairing operations in their verification logic, which is very expensive and requires a large number of constraints in a circuit.</li>

      <li>Multi-Scalar Multiplications: There are more variable-based MSM operations in the verification steps of universal SNARKs than their non-universal counterparts, which results in high circuit complexity with naïve implementation.</li>

      <li>Polynomial evaluations over non-native field: The predicate (inner) proofs and final outer proof are generated in different circuits over different finite fields, thus polynomial evaluations over the inner fields will be simulated in an outer circuit with a different field, which involves high overheads.</li>

      <li>Fiat-Shamir transform: Unrolling all the challenges generated by FS transform requires applying a hash function many times. However, commonly used hash functions are not SNARK friendly and result in high circuit costs.</li>

    </ul>

    <p class="text-gray-300">We present an overview of our techniques that drastically reduce the outer circuit complexity whose proof generation dominates transaction generation cost.</p>

    <p class="text-gray-300">Lightweight Verifier Circuit from Accumulation Scheme. Inspired by Halo <em>[16]</em>, we move out the expensive pairing check from the SNARK verifier circuit and delay the final proof verification step to ledger validators. Intuitively, the verification logic of universal SNARKs with pairing-based PCS culminates in producing <span class="math">2\\,\\mathbb{G}_{1}</span> points for the final bilinear pairing check. Instead of carrying out the full proof verification in the circuit, we output the <span class="math">2\\,\\mathbb{G}_{1}</span> points as public inputs and attach them to the transaction validity proof. To ensure these two points reveal no information about the underlying predicates, we further mask them by simultaneously applying a blinding factor on both points so that the masked points preserve the pairing check result. The actual pairing check will be executed by the ledger maintainer who receives the transaction validity proof and the two masked points.</p>

    <p class="text-gray-300">Instance Merging. As briefly explained, the outer circuit needs to verify <span class="math">m+n</span> universal SNARK proofs for <span class="math">m</span> death predicates and <span class="math">n</span> birth predicates in an <span class="math">m</span>-input-<span class="math">n</span>-output transaction (W.L.O.G. we assume <span class="math">m=n</span>). We halve the number of proofs the outer circuit needs to verify (from <span class="math">2m</span> to <span class="math">m</span>) by merging each pair of death predicate and birth predicate into a single larger predicate. The critical precondition for this technique to have positive net savings is that: verifying one proof for a merged statement twice as large requires significantly fewer constraints than verifying two proofs for two statements; which holds for SNARKs such as Plonk <em>[31]</em>.</p>

    <p class="text-gray-300">Assume that the original circuit size bound for birth/death predicates is <span class="math">N</span>, the merging technique simply left/right pad another <span class="math">N</span> dummy gates to birth/death predicate circuits respectively before arithmetizing them into polynomials that constitute the proving keys. The key observation is that with additive homomorphic polynomial commitment schemes (such as <em>[40]</em>), the commitment to the addition of two polynomials is simply the addition of their polynomial commitments.Therefore, by adding a pair of verification keys of any padded birth predicate and any padded death predicate, the verifier can obtain the verification key of the merged predicate and thus be able to verify the proof for the merged predicate.</p>

    <p class="text-gray-300">Notice that theoretically, one can merge more than two predicates, but in the DPC context, merging a pair of birth and death predicates hits the sweet spot of flexibility and efficiency improvement. This is because circuit/predicate key preprocessing happens beforehand in the offline phase, and instance merging-then-proving happens later in the online phase. For example, if we merge 3 predicates, then during the circuit key generation phase, we will have to decide which <span class="math">N</span>-out-of-<span class="math">3N</span> slots (in the merged circuit) should a particular predicate be assigned to, which restricts it from merging with other predicates that occupy the same <span class="math">N</span> slots. In contrast, our merging of a death and a birth predicate requires easy slot allocation and allows for arbitrary assembly of death/birth predicates in a transaction.</p>

    <p class="text-gray-300">Proof Batching. Instead of generating and verifying <span class="math">m</span> proofs separately, we exploit the proof batching technique to achieve a lower amortized cost. We leverage the fact that most universal SNARKs are cryptographically compiled from a <em>Polynomial Interactive Oracle Proof</em> (PIOP) using a PCS and</p>

    <p class="text-gray-300">many choices of PCS support batch opening which reduces opening proof size and amortizes verification cost. Thus, we present a generic compiler in § 3.3 to transform a PIOP-based SNARK into a batched prover and verifier for a list of NP relations. In the case of KZG-Plonk, batching <span class="math">\\ell</span> relations reduces the total proof size by <span class="math">5(\\ell-1)\\mathbb{G}_{1}</span> elements by sharing the same quotient polynomial and the same opening polynomials; reduces the number of MSM operation by <span class="math">7(\\ell-1)</span> and the number of pairing operation by <span class="math">(\\ell-1)</span>. Batching TurboPlonk with more selector polynomials and wire polynomials leads to even greater savings. Since both the MSM gadget and pairing gadget are expensive, we would noticeably reduce outer circuit complexity by batch verifying <span class="math">m</span> merged predicate.</p>

    <p class="text-gray-300">Next, we present techniques that are tailored for (customized) Plonk-based constraint systems that support lookup gates.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Variable-base MSM via Online Lookup Table.</h4>

    <p class="text-gray-300">Instead of naïvely enforcing variable-base MSM computation, we design a Pippenger-base MSM gadget and further reduce its complexity by relying on a special variant of lookup argument called <em>online lookup table argument</em>. Recall that Pippenger algorithm <em>[51]</em> reduces a <span class="math">b</span>-bit MSM into <span class="math">b/c</span> instances of <span class="math">c</span>-bit MSMs (<span class="math">c&lt;b</span>) and finally sums them together. When computing a <span class="math">c</span>-bit MSM, instead of unrolling the exact Pippenger algorithm in the circuit which is very expensive, we utilize a lookup table containing all resulting points from the scalar multiplications between the base point and all <span class="math">2^{c}-1</span> possible scalar values. With such a lookup table, any <span class="math">c</span>-bit scalar multiplication on this specific base point becomes a table query rather than an elliptic curve group operation. Given that these bases are unfixed, the lookup table cannot be pre-processed – table values are only known during the online proving phase. Such online lookup tables are already possible with <em>[30]</em> although their presentation is limited to preprocessed query tables whose values are known ahead of time. We provide detailed gadget descriptions and circuit sizes in § 3.4.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Polynomial Evaluation over Non-native Field.</h4>

    <p class="text-gray-300">To facilitate polynomial evaluation over a non-native field, we device efficient modular multiplication and modular addition gadgets by leveraging range check via lookup argument <em>[30]</em>. Compared to other modular arithmetic gadget designs, ours take advantage of (a) clever UltraPlonk constraint system design to do range-check with little to no additional circuit cost; (b) specialized use case of two-chain curves for depth-2 proof recursion (instead of cycling curves for deeper proof recursions), which allows us to safely assume finer-grained requirements on the sizes of two fields to make our circuit simpler. We provide detailed gadget descriptions in § 3.5.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">SNARK-friendly Symmetric Primitives.</h4>

    <p class="text-gray-300">To reduce the number of non-algebraic operations in the circuit, we instantiate symmetric primitives used such as commitment schemes, Pseudorandom Function (PRF), and Collision-resistant Hash (CRH) with SNARK-friendly candidates which are designed to work natively with finite fields involving mostly algebraic operations. We specify our concrete implementations in § 4.1, most of which are based on Rescue hash functions <em>[2]</em>. More importantly, we carefully design customized gates in our TurboPlonk (Def. 2) to optimize for these rescue operations. Our Fiat-Shamir transcript uses Sponge-based hash from Rescue permutation so that verifier challenge derivation is much cheaper in the circuit. We further designed an optimized predicate commitment gadget in § 3.6 to ensure two circuits over different fields are committing to the same list of predicates. Particularly, the number of non-native hash operations in our gadget does not grow with the number of predicates committed.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.4 Related Works</h3>

    <p class="text-gray-300">We refer readers to Section 1.2 in <em>[14]</em> for a comprehensive literature review on privacy-preserving computation on ledgers. Even though there are alternative private smart contract designs proposed afterwards <em>[4, 41, 52, 53, 54]</em> with different trade-offs and limitations, Zexe remains the only concrete construction of DPC to date. DPC schemes like Zexe and VeriZexe have both data privacy and function privacy while maintaining high expressiveness. (see Appx. A).</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Universal SNARKs.</h4>

    <p class="text-gray-300">Our construction makes heavy use of Universal SNARKs <em>[37]</em>, which strikes a good balance between efficiency and acceptable trust assumption. These systems support a universal and constantly <em>updatable</em> SRS <em>[37]</em> where anyone can contribute to the SRS in a verifiable way. As long as one of the contributors is honest, then no trap-door exists. SNARKs with fully transparent setups <em>[5, 18, 20]</em> usually have worse performance or a much larger proof size.</p>

    <p class="text-gray-300">We choose variants of Plonk <em>[31]</em> for our implementations primarily due to their performance, customizable gates, and importantly its support for lookup argument <em>[13, 30]</em> that some of our optimization techniques depend on. We provide a more detailed literature review of Universal SNARKs in Appx. A.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We denote <span class="math">[n]</span> as the set <span class="math">\\{1,\\ldots,n\\}\\subseteq\\mathbb{N}</span>, <span class="math">\\lambda\\in\\mathbb{N}</span> as the security parameter, <span class="math">\\mathsf{negl}(\\lambda)</span> as a <em>negligible</em> function in <span class="math">\\lambda</span> if it vanishes faster than the inverse of any polynomial in <span class="math">\\lambda</span>. A probability is overwhelming if it is <span class="math">1-\\mathsf{negl}(\\lambda)</span> for a negligible function <span class="math">\\mathsf{negl}(\\lambda)</span>. Further, we use <em>efficient algorithms</em> to refer to probabilistic polynomial time algorithms in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">We provide formal definitions and security properties of <em>Commitment Scheme</em>, <em>Polynomial Commitment Scheme</em> (PCS),</p>

    <p class="text-gray-300">indexed relation, (preprocessing) succinct non-interactive argument of knowledge (SNARK), and incrementally verifiable computation (IVC), in Appx. B.</p>

    <p class="text-gray-300">To tackle the challenges of efficiently instantiating the DPC scheme with universal SNARKs described in Sec. 1.3, we propose numerous optimization techniques many of which can be applied to protocols beyond DPC. With all optimizations applied, we expect to bring VERIZEXE to the realm of practicality. Detailed benchmark is reported in Sec. 4.</p>

    <p class="text-gray-300">We apply a technique called Accumulation Scheme (AS), originally introduced in [16] and later generalized in [19], to move the expensive pairing check out of the SNARK verifier circuit. While the technique is not new, we try to cast part of the transaction generation procedure into an incrementally verifiable computation (Appx. B) and show explicitly how accumulation schemes can improve the performance of ZEXE.</p>

    <p class="text-gray-300">The core observations are that (i) proving satisfiability of user-defined predicates can be modeled as a two-step IVC, and (ii) original ZEXE instantiated this IVC using SNARK composition. To obtain a more lightweight IVC prover, we construct this IVC using a SNARK with an accumulation scheme. The key observation is that the verification of many universal SNARKs under the PIOP+PCS paradigm is efficient except for the final polynomial opening check. And with the help of an AC for the PCS, these opening checks can be separated from the SNARK verifier logic and delayed to another decider algorithm executed much later.</p>

    <p class="text-gray-300">Modeling DPC executions as IVCs. As introduced in § 1.2, one of the proofs generated during transaction building is for the NP relation  <span class="math">\\mathcal{R}_{\\Phi}</span>  (for condition  <span class="math">\\odot</span> ). As shown in Fig. 1, the process of proving  <span class="math">\\mathcal{R}_{\\Phi}</span>  can be modeled as a two-step IVC. In the first step, users produce SNARK proofs certifying all relevant predicates are satisfied over some local data data of that transaction. To achieve function privacy, SNARK proofs for predicates-SAT are not directly posted on the ledger. Instead, an outer proof  <span class="math">\\pi_{\\Phi}</span>  is generated in the second step attesting to the correctness of these predicate proofs, by taking predicate proofs and their verification keys as secret witnesses and running the SNARK verifier inside the outer circuit. Finally, ledger maintainers run the IVC verifier to verify the outer proof which reveals nothing about the actual predicates involved in the transaction. To ensure consistency of records used in  <span class="math">\\mathcal{R}_{\\mathrm{utxo}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span> , commitments to the local data  <span class="math">\\mathrm{cm}_{\\mathrm{data}}</span>  and list of predicates  <span class="math">\\mathrm{cm}_{\\Phi}</span>  involved are returned as public</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Casting  <span class="math">\\mathcal{R}_{\\Phi}</span>  proving into a two-step IVC (with different step function at each step).</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: IVC from SNARK compositions (left) v.s. IVC from accumulation schemes (right). Blue boxes are SNARK prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  for the relation  <span class="math">\\mathcal{R}</span> , and orange boxes are accumulation prover  <span class="math">P</span> , verifier  <span class="math">\\mathcal{V}</span>  (more lightweight than a SNARK verifier) and decider  <span class="math">D</span> .  <span class="math">z_{1}, z_{2}, \\pi_{1}, \\pi_{2}</span>  in both schemes are the same as those in Fig. 1 where  <span class="math">F</span>  is the step function that calculates the predicate commitment  <span class="math">\\mathrm{cm}_{\\Phi}</span>  using Pedersen Commitment over the hashes of the predicate verifying keys. There are a few inputs dropped from the diagram for visual clarity, e.g. witness  <span class="math">w_{1}</span>  as an input to the IVC prover in both diagrams; SNARK verifying key  <span class="math">\\nu k_{\\mathcal{R}}</span>  for the SNARK verifier inside the IVC verifier on the right diagram.</p>

    <p class="text-gray-300">outputs. Note that when applying proof batching technique (see § 3.3), the IVC proof from the first step will be a single batched proof denoted as  <span class="math">\\pi_{\\oplus}</span>  instead of a list of predicate proofs.</p>

    <p class="text-gray-300">ZEXE: IVC from SNARK composition. Next, we explain how the original ZEXE instantiates this IVC using SNARK composition (see the left half of Fig. 2). For a general IVC, at each step, the prover will receive the state  <span class="math">z</span>  and an IVC proof  <span class="math">\\pi</span>  from the last computation step, compute the next state by applying the step function  <span class="math">F</span>  to get the new state  <span class="math">z&#x27;</span> , and create another IVC proof  <span class="math">\\pi&#x27;</span>  for the statement " <span class="math">F(z) = z&#x27; \\wedge V(z, \\pi) = 1</span> " where  <span class="math">V</span>  is a SNARK verifier. The fact that we have to embed the entire SNARK verifier logic inside the IVC prover's circuit is where the complexity comes from. For example, the pairing checks in KZG for any PIOP+KZG universal SNARK are very expensive in the circuit and will slow down the proof generation significantly.</p>

    <p class="text-gray-300">VERIZEXE: IVC from accumulation schemes. Finally, we give a high-level intuition on leveraging an accumulation scheme for SNARK to defer the heavy-lifting during the SNARK verification to the IVC verifier, thus liberating the IVC prover from a complex circuit (see the right half of Fig. 2). At each step, the IVC prover receives an additional accumulator  <span class="math">\\mathsf{acc}_i</span>  (think of the tuple  <span class="math">(\\mathsf{acc}_i,\\pi_i)</span>  as the new IVC</p>

    <p class="text-gray-300">proof), and eventually, the accumulator will be validated by a <em>decider</em> algorithm as part of the IVC verifier logic. The core idea is: at the second step, the IVC prover will receive the predicate proof <span class="math">\\pi_{\\oplus}</span> and an empty accumulator <span class="math">\\mathsf{acc}_{1}=\\bot</span>; then instead of verifying the predicate proof entirely, we partially verify it (<em>e.g</em>. compute everything except the pairing check in case of PIOP+KZG SNARKs); the expensive steps in verification are delayed to the IVC verifier via the accumulator (<em>e.g</em>. <span class="math">\\mathsf{acc}_{2}</span> would contain the final two <span class="math">\\mathbb{G}_{1}</span> elements used in KZG opening proof check). Informally, our accumulation prover will compute the group elements for PCS opening proof check, our accumulation verifier will ensure correct accumulations (<em>i.e</em>. correct derivation of the two <span class="math">\\mathbb{G}_{1}</span> elements in KZG), our IVC prover only embeds the accumulation verifier’s logic in its circuit which is much more lightweight than a SNARK verifier, and finally, our IVC verifier (transaction verification on-chain in Zexe) will run a SNARK verifier for <span class="math">\\pi_{2}:=\\pi_{\\Phi}</span> and a decider algorithm which completes the PCS opening proof check (<em>e.g</em>. the final pairing check in KZG).</p>

    <p class="text-gray-300">We emphasize that the accumulation must be zero-knowledge – the accumulator <span class="math">\\mathsf{acc}_{2}</span> and the proof <span class="math">\\pi_{V}</span> shouldn’t reveal anything about the predicates being accumulated. In the context of an AS for Plonk with KZG, this means the two <span class="math">\\mathbb{G}_{1}</span> elements for pairing must be randomly masked and the randomizer is an additional secret witness for the accumulation verifier. Note that authors of <em>[19]</em> already showed how to make accumulation schemes for inner-product-argument-based and pairing-based PCSs zero knowledge in their Appendix A and Section 8.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 Instance Merging</h3>

    <p class="text-gray-300">Recall that a transaction builder needs to generate predicate (inner) proofs for all death predicates of input records and birth predicates of output records. We describe a method to merge two proving instances (<em>e.g</em>. a birth predicate and a death predicate) into one by exploiting the algebraic nature of preprocessing in a SNARK (Appx. B) and the homomorphism of polynomial commitment schemes (Appx. B.2), thus halving the number of proofs the outer circuit needs to verify.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Technique.</h4>

    <p class="text-gray-300">In a SNARK based on polynomial IOP (such as <em>Algebraic Holographic Proof</em> (AHP) in Marlin, and <em>idealized low-degree protocol</em> in Plonk), the preprocessing of circuit involves an <em>arithmetization</em> process where constraints in an algebraic circuit (or equivalent computational models) are being transformed into constraints about polynomials. The resulting proving key <span class="math">\\mathsf{ipk}</span> usually contains these index polynomials and the verifying key <span class="math">\\mathsf{ivk}</span> contains the commitments to these index polynomials. During arithmetization, for a birth predicate circuit <span class="math">\\mathcal{C}_{1}</span> of size <span class="math">n</span>, we pad the circuit to size of <span class="math">2n</span>, with <span class="math">\\mathcal{C}_{1}</span> being right padded (last <span class="math">n</span> gates are dummy), and compute the proving key and verification key as usual; for a death predicate circuit <span class="math">\\mathcal{C}_{2}</span> of size <span class="math">n</span>, we perform similar operations but left pad the circuit (first <span class="math">n</span> gates are dummy). Subsequently, whenever we want to merge <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span>, we can construct a <em>merged</em> circuit of size <span class="math">2n</span> just by adding the two padded circuits while maintaining overall circuit satisfiability. The <em>merged</em> proving key can be easily obtained via the addition of two polynomials of the same degree, and the <em>merged</em> verification key (i.e. the commitments) can be similarly derived thanks to the additive homomorphism of PCS (such as KZG10 and its variants).</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Syntax.</h4>

    <p class="text-gray-300">We proceed to propose a slightly modified syntax for SNARKs that support instance merging. A <em>k-Mergeable SNARK</em> scheme</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SNARK}_{\\oplus}^{\\mathsf{k}}=(\\mathcal{G},\\mathcal{I},\\mathcal{M}_{\\mathsf{ipk}},\\mathcal{M}_{\\mathsf{ivk}},\\mathcal{M}_{\\mathsf{w}},\\mathcal{P},\\mathcal{V})</span></p>

    <p class="text-gray-300">supports merging <span class="math">k</span> <em>slotted</em> instances into one single merged instance, where a slotted instance is labeled with a <span class="math">\\mathsf{slot}\\in[k]</span>, and only a batch of non-overlapping instance <span class="math">\\{\\mathsf{slot}_{i}\\}</span> where <span class="math">\\mathsf{slot}_{i}\\neq\\mathsf{slot}_{j}</span> for any <span class="math">i\\neq j,i,j\\in[k]</span> can be merged together. For simplicity, we present the variant we will use to improve Zexe with <span class="math">k=2</span> which allows for the merging of a death and a birth predicates into one.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{srs}\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{G}(\\lambda,N)</span>: same as <span class="math">\\mathsf{SNARK}.\\mathcal{G}</span> except <span class="math">N=2n</span> where <span class="math">n</span> is the size bound for each instance.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">(\\mathsf{ipk}_{b},\\mathsf{ivk}_{b})\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{I}^{\\mathsf{srs}}(\\Phi_{b},b)</span>: Given circuit description <span class="math">\\Phi_{b}</span>, slot number <span class="math">b\\in[2]</span>, and oracle access to SRS <span class="math">\\mathsf{srs}</span>, it deterministically outputs the slotted proving key and verifying key <span class="math">(\\mathsf{ipk}_{b},\\mathsf{ivk}_{b})</span>. The relation for the merged instance is $\\mathcal{R}_{\\oplus}:=\\{(\\mathbb{x}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x}_{1},\\mathbb{w}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{w}_{1}):\\phi_{0}(\\mathbb{x}_{0},\\mathbb{w}_{0})=1\\wedge\\phi_{1}(\\mathbb{x}_{1},\\mathbb{w}_{1})=1\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{ipk}\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{M}_{\\mathsf{ipk}}(\\mathsf{ipk}_{0},\\mathsf{ipk}_{1})</span>: Given any two complementarily slotted proving keys <span class="math">\\mathsf{ipk}_{0},\\mathsf{ipk}_{1}</span>, it outputs a merged proving key <span class="math">\\mathsf{ipk}</span>.</li>

      <li><span class="math">\\mathsf{ivk}\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{M}_{\\mathsf{ivk}}(\\mathsf{ivk}_{0},\\mathsf{ivk}_{1})</span>: Given any two complementarily slotted verifying keys <span class="math">\\mathsf{ipk}_{0},\\mathsf{ipk}_{1}</span>, it outputs a merged verifying key <span class="math">\\mathsf{ivk}</span>.</li>

      <li><span class="math">\\mathbb{w}\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{M}_{\\mathbb{w}}(\\mathbb{w}_{0},\\mathbb{w}_{1})</span>: Given any two witnesses <span class="math">\\mathbb{w}_{0},\\mathbb{w}_{1}</span> corresponding to relations <span class="math">\\mathcal{R}_{\\Phi_{0}},\\mathcal{R}_{\\Phi_{1}}</span>, it outputs a merged witness <span class="math">\\mathbb{w}</span> for <span class="math">\\mathcal{R}_{\\oplus}</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{P}(\\mathsf{ipk},\\mathbb{x},\\mathbb{w})</span>: same as <span class="math">\\mathsf{SNARK}.\\mathcal{P}</span> except <span class="math">N=2n</span>.</li>

      <li><span class="math">b\\leftarrow\\mathsf{SNARK}_{\\oplus}.\\mathcal{V}(\\mathsf{ivk},\\mathbb{x},\\pi)</span>: same as <span class="math">\\mathsf{SNARK}.\\mathcal{V}</span> except <span class="math">N=2n</span>.</li>

    </ul>

    <p class="text-gray-300">We present a concrete construction of such a technique for Plonk in Appx. E.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Analysis.</h4>

    <p class="text-gray-300">A clear trade-off we make here is halving the number of proving instances by doubling the circuit size of each instance. Concretely in Zexe’s context, given an <span class="math">m</span>-input-<span class="math">m</span>-output transaction, we have <span class="math">2m</span> predicate proofs (<span class="math">m</span> death and <span class="math">m</span> birth) to be verified in the outer circuit, which is over a larger field with more expensive computation within it. Now by merging each pair of <span class="math">(\\Phi_{b,i},\\Phi_{d,i})_{i=1}^{m}\\mapsto[\\phi_{i}]_{i=1}^{m}</span>, we reduce the number of inner predicate proofs to <span class="math">m</span>, potentially lowering the outer circuit complexity. The concrete net saving is dependent on the choice of SNARK proof system for predicate circuits. Assume a circuit of size <span class="math">n</span>, the proof for the circuit satisfiability can be checked by a verifier gadget using <span class="math">C_{n}</span> constraints; while a verifier gadget for a circuit of size <span class="math">2n</span> takes <span class="math">C_{2n}=C_{n}+\\delta</span> constraints. Our instance merging techniques effectively reduce the outer circuit complexity from roughly <span class="math">2m\\cdot C_{n}</span> to <span class="math">m\\cdot C_{2n}</span>, which is a significant saving as long as <span class="math">\\delta\\ll C_{n}</span>. In the case of a Plonk verifier gadget, <span class="math">\\delta</span> is very small and attributed to a few additional modular arithmetic constraints from computing the polynomial evaluations that are dependent on the doubled evaluation domain size; whereas <span class="math">C_{n}</span> is orders of magnitude larger. Meanwhile, inevitably there is an additional cost associated with a larger circuit per inner instance. The only noticeable cost boils down to running polynomial interpolations using FFT over a domain size of <span class="math">2n</span> instead of <span class="math">n</span> during inner proof generation – effectively 2 FFT of the size <span class="math">n</span> v.s. 1 FFT over the size of <span class="math">2n</span>. Given that the running time of FFT is <span class="math">O(n\\cdot\\log(n))</span>, the increased cost is really negligible compared to the efficiency gain from a simpler outer circuit.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.3 Proof Batching</h3>

    <p class="text-gray-300">We describe a generic compiler that transforms a public-coin non-interactive argument that proves a single relation into an argument that batch proves a list of relations while preserving all security properties. Notice that one could trivially run multiple instances of the argument protocol independently in parallel. Our compiler below is non-trivial as it reduces the total communication complexity (thus the final proof size) and the total verification computation, which in turn ultimately reduces the overall verifier circuit complexity in Zexe compared to verifying them individually.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Syntax.</h4>

    <p class="text-gray-300">A SNARK that supports proof batching shares most of the syntax from SNARK except that the proving and verification algorithm now accepts a list of instances, witnesses, and proofs instead of one:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{\\oplus}\\leftarrow\\mathsf{SNARK}.\\mathcal{P}_{\\oplus}([\\mathsf{ipk}_{i}]_{i=1}^{\\ell},[\\pi_{i}]_{i=1}^{\\ell},[\\mathfrak{w}_{i}]_{i=1}^{\\ell})</span>: Given a list of <span class="math">\\ell</span> proving keys, instances and witnesses, it proves them in batch and outputs a proof <span class="math">\\pi_{\\oplus}</span>.</li>

      <li><span class="math">b\\leftarrow\\mathsf{SNARK}.\\mathcal{V}_{\\oplus}([\\mathsf{ivk}_{i}]_{i=1}^{\\ell},[\\pi_{i}]_{i=1}^{\\ell},\\pi_{\\oplus})</span>: Given a list of <span class="math">\\ell</span> verifying keys, instances and an aggregated proof, it outputs a success bit <span class="math">b</span>.</li>

    </ul>

    <p class="text-gray-300">We explain the high-level techniques below and present a concrete construction in Appx. E.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Technique.</h4>

    <p class="text-gray-300">Marlin presents a compiler that combines any public-coin AHP/PIOP for a relation <span class="math">\\mathcal{R}</span> and an extractable polynomial commitment scheme to obtain a public-coin pre-processing argument with universal SRS for the same relation (see Theorem 1 in <em>[24]</em>). The universal SNARKs we use also fit into this construction paradigm, and we summarize it schematically in Fig. 3. To extend the above paradigm and support batching, the core idea is to leverage the batch opening of PCS, which reduces opening proof size and amortizes verification costs. We observe that many existing PCSs have a linear combination scheme, and thus support batch openings of multiple polynomials at multiple points (proven in Theorem 3 of <em>[12]</em> on private aggregation scheme).</p>

    <p class="text-gray-300">Next, we summarize the general paradigm and its batching extension in Fig. 3. On the left side of Fig. 3 is an interactive argument between a Prover <span class="math">\\mathcal{P}</span> and a Verifier <span class="math">\\mathcal{V}</span> both of whom are running an information-theoretic PIOP as a sub-protocol. The prover starts by running the PIOP prover with the given instance <span class="math">\\pi</span> and witness <span class="math">\\mathfrak{w}</span>, where in each round it produces a polynomial <span class="math">p_{i}</span> to be committed into <span class="math">\\mathsf{cm}_{i}</span> and sent over to the verifier. Meanwhile, the verifier <span class="math">\\mathcal{V}</span> who internally runs the PIOP verifier randomly samples a coin <span class="math">r_{i}</span> in each round, and at the end of <span class="math">n</span>-th round, outputs a query set <span class="math">Q</span> containing algebraic queries such as “evaluate <span class="math">\\{p_{i}\\}</span> at point <span class="math">r_{j}</span>” or some polynomial identity testing. Upon receiving the queries, <span class="math">\\mathcal{P}</span> calculates the replies as a list of evaluated values <span class="math">[\\nu]</span> and returns to <span class="math">\\mathcal{V}</span> who will decide whether the replied values are acceptable. Additionally, <span class="math">\\mathcal{P}</span> has to prove that the replies to algebraic queries are consistent with committed polynomials by running <span class="math">\\mathsf{PCS.Eval}.\\mathcal{P}</span> as a sub-procedure whose opening proof will be verified by <span class="math">\\mathcal{V}</span> who runs <span class="math">\\mathsf{PCS.Eval}.\\mathcal{V}</span>.</p>

    <p class="text-gray-300">On the right side of Fig. 3 is an interactive argument, compiled from the one on the left, for a list of relations <span class="math">\\{\\mathcal{R}_{i}\\}_{i=1}^{\\ell}</span> with the same size bound. In <span class="math">j</span>-th round (<span class="math">j\\in[n]</span>), the <span class="math">i</span>-th PIOP prover (<span class="math">i\\in[\\ell]</span>), sends over the committed polynomial for that round <span class="math">\\{p_{i,j}\\}</span> and the PIOP verifier would replied with a random coin <span class="math">r_{j}</span> after it receives all polynomials from <span class="math">\\ell</span> PIOP provers. After <span class="math">n</span> rounds of polynomial commitments and coin flips, the PIOP verifier outputs a single query set <span class="math">Q</span> for all <span class="math">\\ell</span> relations, and the size of this set should be the same as that of a single PIOP run. Finally, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> run batch opening of PCS over all polynomials at those query points.</p>

    <p class="text-gray-300">Note that a strawman (yet non-trivial) compiler would run <span class="math">\\ell</span> PIOP instances in parallel, where the verifier produces <span class="math">\\ell</span> random challenges <span class="math">\\{r_{i,j}\\}_{j=0}^{n}</span> (in total <span class="math">\\ell\\cdot n</span> challenges) and <span class="math">\\ell</span> query set <span class="math">Q_{i}</span>. Subsequently the <span class="math">\\mathsf{PCS.Open}</span> will proceed to prove opening of polynomials <span class="math">\\left\\{\\{p_{i,j}\\}_{j=1}^{n}\\right\\}_{i=1}^{\\ell}</span> at different subsets in <span class="math">Q:=\\bigcup\\{Q_{i}\\}</span>. In contrast, our compiler utilizes the same random challenges (in total <span class="math">n</span>) and the same query set <span class="math">Q</span>, independent of the number of batched relations <span class="math">\\ell</span>, so that</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Generic compiler for batching PIOP-based SNARKs.</p>

    <p class="text-gray-300">the batched opening of PCS is even simpler. Intuitively our compiler preserves security since these random challenges are only sent after receiving the committed polynomials (for that round) from all of the  <span class="math">\\ell</span>  PIOP provers, and the query set is constructed after finishing the  <span class="math">n</span>  rounds of all PIOPs, thus there won't be any knowledge soundness compromise (although the knowledge extractor requires slight modifications).</p>

    <p class="text-gray-300">We generalize the lookup table argument in [30] by enabling a variant we call online lookup table to constrain MSM in the circuit more efficiently.</p>

    <p class="text-gray-300">Motivation. Recall that a  <span class="math">b</span> -bit multi-scalar multiplication (MSM) problem of size  <span class="math">n \\in \\mathbb{N}</span>  is to compute  <span class="math">Q = \\Sigma_{i \\in [n]} (s_i \\cdot P_i)</span>  where  <span class="math">s_i \\in [0, 2^b)</span>  are scalars,  <span class="math">P_i \\in \\mathbb{G}</span>  are bases,  <span class="math">\\cdot</span>  is scalar multiplication, and  <span class="math">+</span>  is group addition. When all bases are fixed and known in advance, we call such instance a fixed-base MSM (fMSM); otherwise variable-base MSM (vMSM).</p>

    <p class="text-gray-300">During verification of inner proofs in the outer circuit in ZEXE, there are some vMSM computations where the bases are commitments to witness polynomials inside proofs or commitments to preprocessed circuit descriptions inside verifying keys (note that verifying keys for user-defined predicates are dynamic). On a high level, we employ Pippenger-like [51] strategy by reducing a  <span class="math">b</span> -bit MSM into  <span class="math">b / c</span>  instances of  <span class="math">c</span> -bit MSMs ( <span class="math">c &amp;lt; b</span> ), and finally summing them together. Particularly, when computing a  <span class="math">c</span> -bit MSM, instead of unrolling the exact Pippenger algorithm in the circuit which is very expensive, we utilize a lookup table containing all resulting points</p>

    <p class="text-gray-300">from the scalar multiplications between the base point and all  <span class="math">2^{c} - 1</span>  possible scalar values. With such a lookup table, any  <span class="math">c</span> -bit scalar multiplication on this specific base point becomes a table query rather than an elliptic curve group operation. Given that these bases are unfixed, the lookup table cannot be pre-processed – table values are only known during the online proving phase which gives rise to our following technique.</p>

    <p class="text-gray-300">Pre-processed v.s. Online Lookup Table. PLOOKUP [30] presents a polynomial IOP (PIOP) protocol for checking values of a query table  <span class="math">f \\coloneqq (f_{1},\\ldots ,f_{n}) \\in \\mathbb{F}^{n}</span>  are contained in the values of a lookup table  <span class="math">t \\coloneqq (t_1,\\dots ,t_d) \\in \\mathbb{F}^d</span> . They further generalize the protocol to support vector lookup where each entry in the query table and lookup table is a vector (i.e.  <span class="math">f_{i},t_{i} \\in \\mathbb{F}^{w}</span> ); and to support multiple tables by adding an additional column for table index and concatenating multiple tables into one. However, the presentation in [30] only considers pre-processed lookup tables where values in the lookup tables are predefined and fixed. The key observation is that the PIOP protocol for lookup relations works regardless of how the query table and the lookup table are constructed – whether those values are known in advance or determined during the online phase of the protocol run. Intuitively, the PIOP for online lookup tables still preserves soundness because online columns constructed by the prover are committed first (sent to the verifier for oracle access), before any verifier-initiated checks are carried out.</p>

    <p class="text-gray-300">Optimized MSM Circuit. With the online lookup table in our toolbox, we proceed to present an optimized circuit for MSM.</p>

    <p class="text-gray-300">We denote an elliptic curve point addition gadget  <span class="math">\\odot_{\\mathrm{add}}</span>  point doubling gadget  <span class="math">\\odot_{\\mathrm{double}}</span> , linear combination gadget  <span class="math">\\odot_{\\mathrm{lc}}</span>  for  <span class="math">k</span>  terms, lookup gadget (for either filling entry in query or lookup table)  <span class="math">\\odot_{\\mathrm{lookup}}</span> . Then our overall circuit size (number of gates) is dominated by:</p>

    <p class="text-gray-300">Inputs: Base point variables:  <span class="math">[P_1, \\ldots, P_n]</span> , scalar variables:  <span class="math">[s_1, \\ldots, s_n]</span>  where scalar values  <span class="math">\\in [0, 2^b)</span> .</p>

    <p class="text-gray-300">Outputs: A point variable  <span class="math">Q = \\sum_{i\\in [n]}s_i\\cdot P_i</span></p>

    <p class="text-gray-300">Circuit: We break  <span class="math">b</span> -bit MSM into  <span class="math">m := b / c</span>  instances of  <span class="math">c</span> -bit MSM and finally summing over  <span class="math">m</span>  points.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in \\{1\\dots n\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">(2\\cdot P_{i},\\ldots ,(2^{c} - 1)\\cdot P_{i})</span>  using repeated point addition from  <span class="math">P_{i}</span> (b) Create online lookup table:  <span class="math">\\mathcal{T}_i = [(0,0_\\square),(1,P_i),(2,2\\cdot P_i),\\ldots ,(2^c -1,(2^c -1)\\cdot P_i)]</span> (c) Decompose  <span class="math">s_i</span>  into  <span class="math">m</span>  chunks of  <span class="math">c</span> -bit value  <span class="math">[s_{i,0},\\ldots ,s_{i,m - 1}]</span> , such that  <span class="math">s_i = \\sum_{j = 0}^{m - 1}s_{i,j}\\cdot 2^{cj}</span>  (we don't need to further range-check  <span class="math">s_{i,j}</span> , as it is implicitly constrained later in lookup gates).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">j = \\{0\\ldots m - 1\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) For  <span class="math">i = \\{0\\dots n\\}</span></p>

    <p class="text-gray-300">i. Create a point variable  <span class="math">Q_{i,j}</span>  for the value  <span class="math">s_{i,j} \\cdot P_i</span> . ii. Add an entry to query table  <span class="math">(s_{i,j},Q_{i,j})</span>  (lookup argument will check if  <span class="math">(s_{i,j},Q_{i,j})\\in \\mathcal{T}_i</span> ).</p>

    <p class="text-gray-300">(b) Compute window sum:  <span class="math">\\mathbf{wsum}_j = \\sum_{i\\in [n]}Q_{i,j}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">Q = \\sum_{j=0}^{m-1} \\mathbf{wsum}_j \\cdot 2^{cj}</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 4: Optimized variable-base MSM using online lookup tables.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">As a point of reference, with the TURBOPLONK circuit used to generate benchmark number in § 4, which supports linear combination of  <span class="math">k = 4</span>  terms using 1 gate, elliptic curve point addition and doubling using 2 gate, a lookup entry or query using 1 gate, a 256-bit vMSM of size 128 takes only around 34,516 gates with chosen chunk size  <span class="math">c = \\log (n) \\approx 5</span> . In contrast with the naive circuit implementation, the expected number of gates required is around  <span class="math">230,000^9</span>  – our optimized circuit is more than 6.5 factors smaller.</p>

    <p class="text-gray-300">Remark 1. Step 1b and 2(a)ii in Fig. 4 involves creating multiple online lookup tables and later querying from one of them. To achieve this, we implicitly apply the multiple table techniques presented in [30] by adding an extra domain separator column both in the merged lookup table and the merged query table. Furthermore, we note that in a TURBOPLONK constraint system, with 3 (preprocessed) selector polynomials (2 domain separator polynomials and 1 polynomial for the fixed scalar value in the online lookup table) and 5 wire polynomials (2 for point variables in the lookup table, 3 for the key-value tuple in the query table), we can do an entry creation for both the lookup table and query table in a single gate, thus reducing the total number of constraints required. (at the cost of longer proving and verifying keys).</p>

    <p class="text-gray-300">Specifically, instead of  <span class="math">(n\\cdot 2^{c} + m\\cdot n)\\odot_{\\mathrm{lookup}}</span>  , we could just use  <span class="math">\\max (n\\cdot 2^c,m\\cdot n)\\odot_{\\mathrm{lookup}}</span></p>

    <p class="text-gray-300">Inner proofs for predicate satisfiability and outer proofs for inner proof correctness are generated by circuits over different finite fields. Therefore, when running the inner proof verifier in the outer circuit, any polynomial evaluations would require modular arithmetics over a non-native field. In this section, we present efficient gadgets for two main building blocks: modular multiplications for evaluating each monomial and modular additions for summing over evaluations of all monomials. The stepping stone of our modular arithmetic gadgets is a range proof gadget that uses a lookup table introduced in [30].</p>

    <p class="text-gray-300">Let  <span class="math">p, q</span>  be the sizes of two fields where  <span class="math">p^2 &amp;gt; q &amp;gt; p</span> , we want to show how to emulate modular arithmetics over  <span class="math">\\mathbb{F}_p</span>  in a circuit over the field  <span class="math">\\mathbb{F}_q</span> . The common theme behind our design is enforcing: (a) an equivalent equation over integers expressing the congruence relation of the modular equation and (b) both sides of the equation won't overflow or underflow the native field size  <span class="math">q</span>  at any intermediate step. For example, to constrain modular operation  <span class="math">z&#x27; \\equiv x \\cdot y \\pmod{p}</span> , we ensure there exist witnesses  <span class="math">w</span>  such that (i)  <span class="math">z&#x27; + pw = xy</span>  over integers, and (ii) arithmetic operations that simulate computations of  <span class="math">z&#x27; + pw, xy</span>  never exceeds the range  <span class="math">[0, q)</span> .</p>

    <p class="text-gray-300">Assume that we already have a linear combination gadget  <span class="math">\\odot_{\\mathrm{lc}}</span>  for  <span class="math">k_{\\mathrm{lc}}</span>  terms, and a preprocessed range table (with size  <span class="math">K := 2^k</span> ) that enables us to constrain a variable  <span class="math">x</span>  to be in the range  <span class="math">[0, K)</span> . We start by constructing a more general range-check circuit and then build the modular addition/multiplication gadgets on top of it.</p>

    <p class="text-gray-300">Public Parameters:  <span class="math">K\\in [0,q),\\ell \\in \\mathbb{N}</span>  where  <span class="math">K^{\\ell} &amp;lt; q</span></p>

    <p class="text-gray-300">Input:  <span class="math">x\\in \\mathbb{F}_q</span></p>

    <p class="text-gray-300">Relation:  <span class="math">x\\in [0,K^{\\ell})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Create variables  <span class="math">x_0, \\ldots, x_{\\ell-1}</span>  and constrain  <span class="math">x = x_0 + K \\cdot x_1 + K^2 \\cdot x_2 + \\ldots + K^{\\ell-1} \\cdot x_{\\ell-1}</span> .</li>

      <li>Range check variables  <span class="math">x_0, \\ldots, x_{\\ell-1} \\in [0, K)</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 5: Range proof gadget.</p>

    <p class="text-gray-300">Range proofs. We present a range proof gadget with the circuit size:  <span class="math">n_{\\mathrm{range}}(\\ell) \\coloneqq \\left\\lceil \\frac{\\ell - 1}{k_{\\mathrm{lc}}} \\right\\rceil \\odot_{\\mathrm{lc}} + \\ell \\odot_{\\mathrm{rg}}</span> .</p>

    <p class="text-gray-300">Modular multiplications. Since we assume  <span class="math">p^2 &amp;gt; q</span> , we can't directly multiply  <span class="math">x, y \\in \\mathbb{F}_p</span>  in circuits over  <span class="math">\\mathbb{F}_q</span> . Instead we choose to break each  <span class="math">\\mathbb{F}_p</span>  element into two limbs with a splitting parameter  <span class="math">m</span>  such that  <span class="math">2^{2m} \\geq p</span> , so that we can represent any  <span class="math">x \\in \\mathbb{F}_p</span>  as  <span class="math">(x_0, x_1) \\in [0, 2^m)^2</span>  such that  <span class="math">x = x_0 + 2^m x_1</span> . With the range proof gadget for the range  <span class="math">[0, K^\\ell)</span>  in mind (where  <span class="math">K = 2^k</span> ), we recommend fixing  <span class="math">m</span>  by finding the minimum  <span class="math">\\ell \\in \\mathbb{N}</span>  such that  <span class="math">2^{2\\ell k} \\geq p</span>  (namely we denote  <span class="math">m := \\ell k</span> ).</p>

    <p class="text-gray-300">The intuition for proving  <span class="math">x \\cdot y = z</span>  (mod  <span class="math">p</span> ) is to find a witness  <span class="math">w \\in \\mathbb{F}_p</span>  such that  <span class="math">x \\cdot y = z + p \\cdot w</span>  holds over integers and that both sides won't overflow  <span class="math">\\mathbb{F}_q</span> . Specifically:</p>

    <p class="text-gray-300"><span class="math">(x_0 + 2^m \\cdot x_1) \\cdot (y_0 + 2^m \\cdot y_1) = z_0 + 2^m \\cdot z_1 + (w_0 + 2^m \\cdot w_1) \\cdot (p_0 + 2^m \\cdot p_1)</span></p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300"><span class="math">z_{0} + w_{0}\\cdot p_{0} - x_{0}\\cdot y_{0} + 2^{m}\\cdot (z_{1} + w_{0}\\cdot p_{1} + w_{1}\\cdot p_{0} - x_{0}\\cdot y_{1} - x_{1}\\cdot y_{0})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2^{2m} \\cdot (w_{1} \\cdot p_{1} - x_{1} \\cdot y_{1}) = 0</span></li>

    </ul>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300"><span class="math">\\left\\{ \\begin{array}{l} z_0 + w_0 \\cdot p_0 - x_0 \\cdot y_0 - 2^m \\cdot c_0&#x27; = 0 \\\\ z_1 + w_0 \\cdot p_1 + w_1 \\cdot p_0 - x_0 \\cdot y_1 - x_1 \\cdot y_0 + c_0&#x27; - 2^m \\cdot c_1&#x27; = 0 \\\\ w_1 \\cdot p_1 - x_1 \\cdot y_1 + c_1&#x27; = 0 \\end{array} \\right.</span></p>

    <p class="text-gray-300">for some  <span class="math">c_0&#x27;, c_1&#x27;</span>  carriers bounded by  <span class="math">-2^m \\leq c_0&#x27; &amp;lt; 2^{m+1}</span>  and  <span class="math">-2^{m+1} \\leq c_1&#x27; &amp;lt; 2^{m+2}</span> . We present the modular multiplication gadget in Fig. 6 with the following notes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To optimize gadget circuit size, we assume that the limbs of input  <span class="math">x, y</span>  are already in the range  <span class="math">[0, 2^m)</span>  without further checking.</li>

      <li>We shift the actual carriers  <span class="math">c_0&#x27;, c_1&#x27;</span>  to  <span class="math">c_0, c_1</span>  in order to have a positive range and upper-bounded by a power of  <span class="math">K</span>  to utilize our range proof gadget.</li>

      <li>Witness  <span class="math">w \\in \\mathbb{F}_p</span>  must exist since we assume both  <span class="math">x, y \\in \\mathbb{F}_p</span>  even though we only constrain them to range  <span class="math">[0, 2^{2m})</span>  which is bigger than  <span class="math">[0, p)</span> .</li>

    </ul>

    <p class="text-gray-300">10Since  <span class="math">z_0 + w_0\\cdot p_0\\in [0,2^m +2^{2m}),x_0\\cdot y_0\\in [0,2^{2m})</span>  , we know  <span class="math">\\frac{0 - 2^{2m}}{2^m} = -2^m\\leq c_0&#x27;\\leq \\frac{2^m + 2^{2m} - 0}{2^m} = 2^m +1 &amp;lt;   2^{m + 1}</span></p>

    <p class="text-gray-300">Similarly since  <span class="math">z_{1} + w_{0}\\cdot p_{1} + w_{1}\\cdot p_{0} + c_{0}^{\\prime}\\in [-2^{m},2^{m} + 2^{2m + 1} + 2^{m + 1}),x_{0}\\cdot y_{1} + x_{1}\\cdot y_{0}\\in [0,2^{2m + 1})</span>  , we know  <span class="math">\\frac{-2^m - 2^{2m + 1}}{2^m} = -1 - 2^{m + 1} &amp;lt;   - 2^{m + 1} &amp;lt;   c_1&#x27; &amp;lt;   \\frac{2^m + 2^{2m + 1} + 2^{m + 1} - 0}{2^m} &amp;lt;  2^{m + 2}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>predefined field sizes:  <span class="math">p^2 &amp;gt; q &amp;gt; p</span> .</li>

    </ul>

    <p class="text-gray-300">range of  <span class="math">\\odot_{\\mathrm{rg}}</span> :  <span class="math">K = 2^{k} \\in [0, q)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>splitting parameter  <span class="math">m</span>  such that  <span class="math">2^{2m} = 2^{2\\ell k} \\geq p</span>  for a minimum  <span class="math">\\ell \\in \\mathbb{N}</span></li>

      <li>limbs of prime  <span class="math">(p_0, p_1)</span>  such that  <span class="math">p = p_0 + 2^m \\cdot p_1</span></li>

      <li>additional requirement:  <span class="math">k \\geq 3 \\land q &amp;gt; 2^{2m + k + 1}</span></li>

    </ul>

    <p class="text-gray-300">Input:  <span class="math">(x_0, x_1), (y_0, y_1) \\in [0, 2^m)^2</span>  such that  <span class="math">x = x_0 + 2^m \\cdot x_1 \\in \\mathbb{F}_p, y = y_0 + 2^m \\cdot y_1 \\in \\mathbb{F}_p</span></p>

    <p class="text-gray-300">Witness:  <span class="math">(w_0, w_1), (z_0, z_1)</span></p>

    <p class="text-gray-300">Relation:  <span class="math">(x_0 + 2^m \\cdot x_1) \\cdot (y_0 + 2^m \\cdot y_1) = z_0 + 2^m \\cdot z_1 + (w_0 + 2^m \\cdot w_1) \\cdot (p_0 + 2^m \\cdot p_1)</span>  over integers</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Range check  <span class="math">w_0, w_1, z_0, z_1 \\in [0, 2^m)</span></li>

      <li>Compute carrier  <span class="math">c_0&#x27;</span>  and  <span class="math">c_0 = c_0&#x27; + 2^m</span> , range check  <span class="math">c_0 \\in [0, 2^{m+k})</span>  and constrain  <span class="math">z_0 + w_0 \\cdot p_0 = x_0 \\cdot y_0 + 2^m \\cdot (c_0 - 2^m)</span></li>

      <li>Compute carrier  <span class="math">c_1&#x27;</span>  and  <span class="math">c_1 = c_1&#x27; + 2^{m+1}</span> , range check  <span class="math">c_1 \\in [0, 2^{m+k})</span>  and constrain  <span class="math">z_1 + w_0 \\cdot p_1 + w_1 \\cdot p_0 + (c_0 - 2^m) = x_0 \\cdot y_1 + x_1 \\cdot y_0 + 2^m \\cdot (c_1 - 2^{m+1})</span></li>

      <li>Constrain  <span class="math">w_{1} \\cdot p_{1} + (c_{1} - 2^{m + 1}) = x_{1} \\cdot y_{1}</span></li>

    </ol>

    <p class="text-gray-300">Figure 6: Modular multiplication gadget. In circuit description, blue texts are actual circuit constraints whereas black normal text is computation outside the circuit.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover must set witness  <span class="math">z</span>  to be in the range  <span class="math">[0, p)</span>  in order to continue feeding  <span class="math">z</span>  as an input to the next modular multiplication gadget, even though another representation such as  <span class="math">z + p</span>  might still satisfy the current gadget. This is because our modular multiplication gate is only composable when the inputs are strictly within  <span class="math">[0, p)</span>  bound to guarantee the existence of witness  <span class="math">w \\in \\mathbb{F}_p</span> .</li>

    </ul>

    <p class="text-gray-300">Proposition 1. The modular multiplication gadget in Fig. 6 satisfies</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: Given public parameters, for any inputs and their valid witnesses, the circuit for the relation should always be satisfied.</li>

      <li>Soundness: Given public parameters, for any inputs and invalid witnesses, the circuit should never be satisfied.</li>

    </ul>

    <p class="text-gray-300">See the proofs in Appx. F.</p>

    <p class="text-gray-300">Using the ULTRAPLONK constraint system specified in Def. 3, the circuit size of the modular multiplication gadget is:  <span class="math">5 + 4 \\cdot n_{\\mathrm{range}}(\\ell) + 2 \\cdot n_{\\mathrm{range}}(\\ell + 1)</span>  ULTRAPLONK constraints. With  <span class="math">k = 15, k_{\\mathrm{lc}} = 4</span> , range-check of  <span class="math">[0, K)</span>  for free, and  <span class="math">\\mathbb{F}_q, \\mathbb{F}_p</span>  be the base field and scalar field of BLS12-377 curve, our gadget uses only 23 constraints.</p>

    <p class="text-gray-300">Remark 2 (On circuit complexity of range checks). In an ULTRAPLONK constraint system, by adding a dedicated input</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>predefined field sizes:  <span class="math">p^2 &amp;gt; q &amp;gt; p</span> .</li>

      <li>range of  <span class="math">\\odot_{\\mathrm{rg}}</span> :  <span class="math">K = 2^k \\in [0, q)</span></li>

      <li>splitting parameter  <span class="math">m</span>  such that  <span class="math">c \\cdot p \\geq 2^{2m} \\geq p</span>  for a minimum  <span class="math">c \\in \\mathbb{N}</span></li>

      <li>maximal number of summards allowed:  <span class="math">N &amp;lt; \\frac{K - 1}{c} + 1</span></li>

      <li>additional requirement:  <span class="math">\\frac{q}{p} &amp;gt; c + K</span></li>

    </ul>

    <p class="text-gray-300">Input:  <span class="math">x_{1},\\ldots ,x_{N}\\in [0,2^{2m})</span></p>

    <p class="text-gray-300">Witness:  <span class="math">w,y</span></p>

    <p class="text-gray-300">Relation:  <span class="math">y + p \\cdot w = x_{1} + \\ldots + x_{N}</span>  over integers</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Range check  <span class="math">y \\in [0, 2^{2m})</span> ,  <span class="math">w \\in [0, K)</span></li>

      <li>Constrain  <span class="math">y + p \\cdot w = x_{1} + \\ldots + x_{N}</span></li>

    </ol>

    <p class="text-gray-300">Figure 7: Modular addition gadget.</p>

    <p class="text-gray-300">wire to each gate (an additional wire polynomial), we can piggyback the range-checking of a variable on any existing gate instead of requiring a dedicated new gate. As long as the number of range checks is fewer than the total number of gates used for the rest of the proof relation, we don't have to increase circuit size, in which case we effectively support range checks "for free".</p>

    <p class="text-gray-300">Remark 3. While there are alternative designs for emulating non-native modular multiplication such as [28], those designs usually are more general and applicable for any  <span class="math">p, q</span>  even when  <span class="math">q &amp;lt; p</span> . In contrast, we have a specialized use case of two-chain curves for depth-2 proof recursion (instead of cycling curves for deeper proof recursions) in mind, therefore we can safely assume finer-grained requirements on  <span class="math">p, q</span>  to make our circuit more efficient.</p>

    <p class="text-gray-300">Modular additions. The intuition for proving  <span class="math">y = x_{1} + \\ldots + x_{N}</span>  (mod  <span class="math">p</span> ) is to find a witness  <span class="math">w \\in \\mathbb{F}_p</span>  such that  <span class="math">y + p \\cdot w = x_{1} + \\ldots + x_{N}</span>  over integers and that both sides won't overflow  <span class="math">\\mathbb{F}_q</span> . Assume we take the splitting parameter  <span class="math">m</span>  from the foregoing modular multiplication gadget, we present the modular addition gadget in Fig. 7.</p>

    <p class="text-gray-300">Proposition 2. The modular addition gadget in Fig. 7 satisfies completeness and soundness.</p>

    <p class="text-gray-300">See the proofs in Appx. F.</p>

    <p class="text-gray-300">The circuit size of our modular addition gadget is:  <span class="math">n_{\\mathrm{addmod}} = \\lceil \\frac{N}{k_{\\mathrm{lc}}} \\rceil \\odot_{\\mathrm{lc}} + 1 \\odot_{\\mathrm{rg}} + n_{\\mathrm{range}}(2m)</span> . With  <span class="math">k = 15, k_{\\mathrm{lc}} = 4</span> , range-check of  <span class="math">[0, K)</span>  for free, and  <span class="math">\\mathbb{F}_q, \\mathbb{F}_p</span>  be the base field and scalar field of BLS12-377 curve, our gadget uses only  <span class="math">\\lceil \\frac{N}{4} \\rceil + 6</span>  constraints for simulating an addition of  <span class="math">N</span>  terms.</p>

    <p class="text-gray-300">Recall that the circuit for relation  <span class="math">\\mathcal{R}_e</span> , which governs the rules of valid record creation and consumption, requires constraining some symmetric cryptographic primitives such as</p>

    <p class="text-gray-300">commitment schemes, pseudo-random functions (PRF), and collision-resistant hashes (CRH). However, some standard implementations of these primitives involve many non-algebraic operations (e.g. bit-wise XOR, rotate in SHA256) which take lots of gates to constrain in an algebraic circuit. There are two main ways to constrain these primitives inside the circuit more efficiently:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>precompute a lookup table containing legitimate (input, output) tuples <span class="math">^{12}</span>  and the prover argues the witnesses (input and output of intermediate, non-algebraic steps) belong to the table [30].</li>

      <li>use SNARK-friendly primitives specifically designed to work natively with finite field elements by using mostly algebraic computations (notably new hash functions: Rescue and Vision [2], Poseidon [34], MiMC [1]).</li>

    </ol>

    <p class="text-gray-300">Generally, the latter approach produces smaller circuits at the cost of reliance on newer, less time-tested designs which are often much slower outside the circuit due to a lack of hardware acceleration. The former approach may allow better candidates with better security bounds or relies on weaker cryptographic assumptions.</p>

    <p class="text-gray-300">Fiat-Shamir Transcript. Many SNARKs are made noninteractive by applying Fiat-Shamir transformation [27] on a public-coin interactive argument where random challenges sent from the verifier are deterministically simulated by hashing all previous transcripts between the prover and the verifier. The heuristic security of these SNARKs assumes these hash functions as random oracles. In practice, these random oracles are instantiated using Blake2s or the keccak permutation in SHA3, all of which incur high circuit complexity as their internals entail many non-algebraic operations. Since the verifier logic includes deriving the verifier challenges in the transcript which should be constrained in the outer circuit, we are motivated to use one of the techniques above to reduce its circuit complexity.</p>

    <p class="text-gray-300">As a point of reference, Halo2 [26] designed a highly optimized circuit for SHA256 using lookup table with an overall cost of 2099 TURBOPLONK constraints; whereas CAP protocol [44] designed a CRH gadget by using Rescue permutation in a sponge construction with only 148 TURBOPLONK constraints. Granted that the arithemtizations in those two TURBOPLONK designs are slightly different, such numbers can only be used for informal comparison. We decide to use a Rescue-based hash when constraining verifier challenges derivation from the transcripts for its better circuit efficiency, knowing that it is still a philosophical question whether these SNARK-friendly hashes suffice as random oracles.</p>

    <p class="text-gray-300">Predicate Commitments. To ensure that death/birth predicates involved in  <span class="math">\\mathcal{R}_{\\mathrm{ut}\\times \\mathrm{o}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span>  are consistent, [14] proposes to make the hiding commitment  <span class="math">\\mathsf{cm}_{\\Phi}</span>  to the predicates in a transaction as a public input for both circuits so that the verifier can check their equality. Concretely, the original ZEXE instantiates CRH with Pedersen hash, COM with Blake2s hash where the message is appended with a randomizer for the hiding property. The primary circuit cost comes from constraining non-algebraic Blake2s hash on a message size of  <span class="math">m + n + 1</span>  for an  <span class="math">m</span> -input- <span class="math">n</span> -output transaction.</p>

    <p class="text-gray-300">We emphasize that directly switching Blake2s to a SNARK-friendly hash is not immediately more advantageous, since we need to constrain this hash function in two different fields (over  <span class="math">\\mathbb{F}_r</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{ut}\\times \\mathrm{o}}</span>  and over  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">\\mathcal{R}_{\\Phi}</span> ), and constraining algebraic hashes over non-native fields is probably more expensive as it requires many range checks and modular arithmetics. Worse, the number of non-native operations grows linearly with the message size since longer messages require more invocations of the hash function.</p>

    <p class="text-gray-300">In Appx. G, we propose an efficient solution whose non-native operations do not grow regardless of the number of predicates committed.</p>

    <p class="text-gray-300">We implemented the DPC scheme and applied all optimizations (§ 3) except the predicate commitment technique. The resulting system is a ZEXE that only requires a one-time universal setup to produce the system parameter required for all future user-defined predicates which we affectionately call VERIZEXE. Our code base, written in Rust, follows the stack shown in Fig. 8: we utilized arkworks library [3] as the underlying algebra backend for finite fields, elliptic curves, and polynomial operations; necessary cryptographic primitives including zkSNARKs and their circuit constraints are built on top; finally, a VERIZEXE library that instantiates the DPC scheme using all building blocks below.</p>

    <p class="text-gray-300">We break down our concrete instantiations of cryptographic building blocks used to generate benchmarks in § 4.2 in Appx. H.</p>

    <p class="text-gray-300">Metrics and evaluation methodology. As an instantiation of the DPC scheme, our measurements focus on the resources required (including time, memory usage, and storage) during the execution of the three main algorithms of a DPC scheme (namely system setup, transaction generation, and verification). Particularly, the primary target of our optimization has been the circuit complexity of the NP relation  <span class="math">\\mathcal{R}_{\\Phi}</span>  (namely the outer circuit) whose SNARK proof generation dominates the cost of transaction generation – which directly affects the</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 8: Stack of libraries comprising VERIZEXE.</p>

    <p class="text-gray-300">usability and practicality of the final private computation system. To wit, we also provide microbenchmarks on the circuit costs of important cryptographic building blocks used. Note that we do not provide evaluations on dimensions or parts that our optimizations have mild or no effect on, such as the transaction size besides its validity proof size.</p>

    <p class="text-gray-300">All our reported data are measured on an AWS EC2 instance running Ubuntu 20.04. The server has 64 cores (AMD EPYC 7R13 at  <span class="math">2.65\\mathrm{GHz}</span> ) and 128 GB of RAM.</p>

    <p class="text-gray-300">General benchmark. We first compare our system against other DPC implementations on important metrics. To the best of our knowledge, the most efficient and actively maintained implementation is snarkVM by the Aleo team many of whom are the co-authors of [14]. While there are a few versions of DPC instantiations inside snarkVM, we focus on its testnet-1 (the same implementation in Section 9 of [14]) and testnet-2 versions (see Table 1). [13]</p>

    <p class="text-gray-300">Here we outline the technical difference between our system and snarkVM's. First, snarkVM chooses to verify SNARK proof for  <span class="math">\\mathcal{R}_{\\mathrm{ut}\\times 0}</span>  together with predicate SNARK proofs inside its outer circuit, thus producing only a single outer proof instead of the two proofs per transaction as described in Section 7 of the ZEXE paper. To ensure a fair comparison, we have modified their code to accurately reflect the original paper as our VERIZEXE does. SnarkVM testnet-1 uses GM17 [38] for birth/death predicates each of which requires a trusted setup. SnarkVM testnet-2 uses universal SNARK Marlin [24] for predicates and this will serve as the primary benchmark to gauge the improvements gained from our optimizations.</p>

    <p class="text-gray-300">As shown in Table 2, we achieve a  <span class="math">10.6 \\sim 11.8\\mathrm{x}</span>  improvement on outer proof generation, and a  <span class="math">9 \\sim 10\\mathrm{x}</span>  on overall</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tx. Dim.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">System Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transaction Generation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Time (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">SRS size (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">RΦ (outer circuit)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Time (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory (GB)</td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (KB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Constraints</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover (s)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">snarkVM testnet-2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 × 2</td>

            <td class="px-3 py-2 border-b border-gray-700">176.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5,254.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4,235,068</td>

            <td class="px-3 py-2 border-b border-gray-700">138.5</td>

            <td class="px-3 py-2 border-b border-gray-700">151.4</td>

            <td class="px-3 py-2 border-b border-gray-700">22.8</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">0.482</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 × 3</td>

            <td class="px-3 py-2 border-b border-gray-700">246.0</td>

            <td class="px-3 py-2 border-b border-gray-700">7,056.6</td>

            <td class="px-3 py-2 border-b border-gray-700">6,330,496</td>

            <td class="px-3 py-2 border-b border-gray-700">202.7</td>

            <td class="px-3 py-2 border-b border-gray-700">223.0</td>

            <td class="px-3 py-2 border-b border-gray-700">26.8</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">0.482</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 × 4</td>

            <td class="px-3 py-2 border-b border-gray-700">370.1</td>

            <td class="px-3 py-2 border-b border-gray-700">10,454.9</td>

            <td class="px-3 py-2 border-b border-gray-700">8,447,588</td>

            <td class="px-3 py-2 border-b border-gray-700">293.2</td>

            <td class="px-3 py-2 border-b border-gray-700">321.1</td>

            <td class="px-3 py-2 border-b border-gray-700">40.6</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">0.482</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VERIZEXE</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ULTRAPLONK</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 × 2</td>

            <td class="px-3 py-2 border-b border-gray-700">11.8</td>

            <td class="px-3 py-2 border-b border-gray-700">33.1</td>

            <td class="px-3 py-2 border-b border-gray-700">87,176</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9</td>

            <td class="px-3 py-2 border-b border-gray-700">6.6</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">4.138</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 × 3</td>

            <td class="px-3 py-2 border-b border-gray-700">18.4</td>

            <td class="px-3 py-2 border-b border-gray-700">66.2</td>

            <td class="px-3 py-2 border-b border-gray-700">126,076</td>

            <td class="px-3 py-2 border-b border-gray-700">24.7</td>

            <td class="px-3 py-2 border-b border-gray-700">29.2</td>

            <td class="px-3 py-2 border-b border-gray-700">8.8</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">4.138</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 × 4</td>

            <td class="px-3 py-2 border-b border-gray-700">19.1</td>

            <td class="px-3 py-2 border-b border-gray-700">66.2</td>

            <td class="px-3 py-2 border-b border-gray-700">141,492</td>

            <td class="px-3 py-2 border-b border-gray-700">24.8</td>

            <td class="px-3 py-2 border-b border-gray-700">32.4</td>

            <td class="px-3 py-2 border-b border-gray-700">9.3</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">4.138</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">transaction generation speed; the latter is the most important bottleneck and the determining factor of the usability of a DPC system. Notwithstanding the impossible task of directly comparing numbers of R1CS constraints to numbers of PLONK constraints, it is evident that our optimizations have kept the outer circuit complexity is relatively low which results in faster proof generations. We also observe a  <span class="math">3 \\sim 4.3\\mathrm{x}</span>  improvement in memory usage during transaction generation, this helps alleviates the hardware requirements for users.</p>

    <p class="text-gray-300">Astute readers may notice the non-linear slowdown in VERIZEXE's performance from  <span class="math">2 \\times 2</span>  to  <span class="math">3 \\times 3</span> . This is caused by the large number of range checks invoked by non-native rescue permutation pushing the evaluation domain size for FFT to a higher power-of-two, thus effectively increasing the cost across the board from universal SRS generation to proving key indexing to proving <span class="math">^{14}</span> .</p>

    <p class="text-gray-300">For the Setup algorithm, our VERIZEXE is also notably faster. We note that it is a one-time, universal setup for both candidates, thus it is arguably less important in practice. We do want to highlight another significant difference in SRS size - snarkVM has a much larger SRS since it requires storing preprocessed proving keys of the  <span class="math">\\mathcal{R}_{\\mathrm{utss}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span>  (outer) circuits (Groth16's trusted setups are circuit-dependent), whereas VERIZEXE only contains two universal SRS. We stress that SRS size matters in practice as they are the (partial) size of the system parameter a user needs to download from ledger maintainers when he first joins the system.</p>

    <p class="text-gray-300">Microbenchmarks. Since most of our techniques are attempts to reduce the outer circuit complexity, we now provide a microbenchmark on concrete circuit costs for major components in Table 3. Among them, one of the highlights is our PLONK verifier gadget only taking roughly  <span class="math">21\\mathrm{k}</span>  UL-</p>

    <p class="text-gray-300">Table 2: Performance comparison against the state-of-the-art DPC implementation across different transaction dimensions (e.g.  <span class="math">2 \\times 2</span>  means 2-input-2-output transaction). The "Prover" column refers to the prover time for the outer circuit whereas the "Time" column refers to the overall transaction generation time. snarkVM uses Groth16 for both  <span class="math">\\mathcal{R}_{\\mathrm{utss}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span> , Marlin for birth/death predicates; whereas VERIZEXE uses TURBOPLONK for both  <span class="math">\\mathcal{R}_{\\mathrm{utss}}</span>  and birth/death predicates, ULTRAPLONK for  <span class="math">\\mathcal{R}_{\\Phi}</span> . Notice that the SRS size for snarkVM contains the universal SRS of Marlin and preprocessed Groth16 proving keys of the inner and outer circuits; whereas that for VERIZEXE only contains two universal SRS, one for  <span class="math">\\mathcal{R}_{\\mathrm{utss}}</span>  and predicate circuits, the other for the outer circuit. Further note that the number of constraints reported for snarkVM are referring to R1CS constraints whereas the number for VERIZEXE are ULTRAPLONK constraints. All death and birth predicates require  <span class="math">2^{15}</span>  constraints in their respective constraint systems.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gadgets</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field of Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Constraints</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rescue Permutation</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">nr=388</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">np=148</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">non-native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">nnn=23,760*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CRH (input: Fℓ, output: Fδ)</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">( [ℓ/3] + k-1)·nr+4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">( [ℓ/3] + k-1)·np+4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commitment (input: Fℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">[ ℓ+1/3] · nr+4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">non-native over BW6</td>

            <td class="px-3 py-2 border-b border-gray-700">[ ℓ+1/3] · nnn+4*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRF (input: Fℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">[ ℓ/4] · nr+4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle Path (depth: ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">(5 + nr) · ℓ + nr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECC Add</td>

            <td class="px-3 py-2 border-b border-gray-700">native over both</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mod Add (input: Fℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">non-native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">[ ℓ/4] + 6*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mod Mul (input: Fℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">non-native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">23*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  PLONK Verifier |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 proof</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">native over BW</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20,232*</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">42,407*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">native over BW</td>

            <td class="px-3 py-2 border-b border-gray-700">53,735*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Number of PLONK constraints for major cryptographic building blocks and algebraic operations. These numbers are TURBOPLONK constraints (see Def. 2), unless annotated with  <span class="math">\\star</span>  which refers to ULTRAPLONK constraints (see Def. 3). Furthermore, we denote the scalar field of BLS12-377 as  <span class="math">\\mathbb{F}_r</span> , and the scalar field of BW6-761 as  <span class="math">\\mathbb{F}_p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Inner Proofs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Outer Proof</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prover (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory (GB)</td>

            <td class="px-3 py-2 border-b border-gray-700">Prover (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory (GB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Phone</td>

            <td class="px-3 py-2 border-b border-gray-700">46.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">270.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Laptop</td>

            <td class="px-3 py-2 border-b border-gray-700">5.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">32.2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">5.0</td>

            <td class="px-3 py-2 border-b border-gray-700">12.7</td>

            <td class="px-3 py-2 border-b border-gray-700">6.6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Proof generation time and memory usages for 2x2-transactions across different hardware environments. The first row simulates a phone environment with 4 CPU, 8GB RAM at  <span class="math">2.3\\mathrm{GHz}</span> . The second row simulates a customer-grade laptop environment with 16 CPU, 32GB RAM at  <span class="math">2.5\\mathrm{GHz}</span> . The third row simulates a powerful server environment with 64 CPU, 128GB RAM at  <span class="math">2.95\\mathrm{GHz}</span> .</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 9: Circuit complexity for variable-based MSM.</p>

    <p class="text-gray-300">TRAPLONK constraints for verifying a single TURBOPLONK proof. This is made possible primarily thanks to highly efficient modular arithmetic gates (see § 3.5) for polynomial evaluation over non-native field and compact variable-based MSM gadget (see § 3.4). To illustrate the improvement attributed to our Pippenger-based vMSM gadget relying on the online lookup table technique, we provide a benchmark against a naive implementation in Fig. 9.</p>

    <p class="text-gray-300">Practicality. With significant improvements in memory usage, DPC transaction generations are possible on consumer-grade laptops or even on phones for the first time. As illustrated in Table 4, there is a general trade-off between prover time and peak memory usage – more cores enable higher parallelism which leads to faster proof generation at the cost of higher memory usage partially due to the overhead from multi-threading management.</p>

    <p class="text-gray-300">Another observation is that inner proofs generations are easily manageable even for lower-resource hardware whereas the outer-proof generation is much more demanding. In quest of a balance between privacy and speed, resource-limited devices could produce inner proofs on-device, preserving the data privacy (all record states), and outsource the outer proof to a more powerful server, leaking only the predicates used in this transaction and nothing else. Note that the final transaction is still completely private to the world, we only sacrifice function privacy to the server. Alternatively, one could also use Delegable DPC (Sec.5 of [14]) which enables delegation of the entire transaction generation to untrusted workers who will learn about all transaction details but never produce valid transactions with invalid witnesses or without user's authorization. Our open-sourced VERIZEXE implementation supports Delegable DPC.</p>

    <p class="text-gray-300">Threat Model and Security Proof. We emphasize that VERIZEXE is a concrete efficient construction of the DPC</p>

    <p class="text-gray-300">scheme, thus inherits all of its threat models, security properties, and DPC model level security proof. As long as our instantiations of cryptographic building blocks satisfy the necessary properties, then the ideal functionalities and security goals of DPC will be achieved.</p>

    <p class="text-gray-300">The extra cryptographic assumptions, compared to [14], are Rescue permutation in Appx. H as a secure Pseudorandom Permutation and Rescue-based Hash as a random oracle.</p>

    <p class="text-gray-300">Furthermore, our ULTRAPLONK are constraint system designs, not modifications to the underlying PLONK PIOP. The knowledge soundness error is proportional to the maximum degree of each gate times the number of gates. In our case, the maximum degree is 6 v.s. 2 in vanilla PLONK circuit; over the 256-bit field, the security difference is negligible (from Schwartz-Zippel lemma)</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I, 2016.</li>

      <li>[2] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. IACR Trans. Symmetric Cryptol., 2020:1–45, 2020.</li>

      <li>[3] arkworks contributors. arkworks zksnark ecosystem. https://arkworks.rs, 2022.</li>

      <li>[4] Aritra Banerjee, Michael Clear, and Hitesh Tewari. zkhawk: Practical private smart contracts from mpc-based hawk. 2021 3rd Conference on Blockchain Research & Applications for Innovative Networks and Services (BRAINS), pages 245–248, 2021.</li>

      <li>[5] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., 2018.</li>

      <li>[6] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474, 2014.</li>

      <li>[7] Daniel Bernstein. Pippenger’s exponentiation algorithm, 01 2002. https://cr.yp.to/papers/pippenger-20020118-retypeset20220327.pdf.</li>

      <li>[8] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Sponge functions. In ECRYPT hash workshop. Citeseer, 2007.</li>

      <li>[9] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ITCS ’12. Association for Computing Machinery, 2012.</li>

      <li>[10] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC, 2012.</li>

      <li>[11] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In Proceedings of the Twentieth Annual ACM Symposium on Theory of Computing, STOC ’88. Association for Computing Machinery, 1988.</li>

      <li>[12] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo infinite: Proof-carrying data from additive polynomial commitments. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology – CRYPTO 2021, pages 649–680, Cham, 2021. Springer International Publishing.</li>

      <li>[13] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune Kristian Jakobsen, and Mary Maller. Nearly linear-time zero-knowledge proofs for correct program execution. In IACR Cryptol. ePrint Arch., 2018.</li>

      <li>[14] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, and Howard Wu. Zexe: Enabling decentralized private computation. In 2020 IEEE Symposium on Security and Privacy (SP), pages 947–964, 2020.</li>

      <li>[15] Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zksnark. In Financial Cryptography and Data Security - FC 2018 International Workshops, BITCOIN, VOTING, and WTSC, Nieuwpoort, Curaçao, March 2, 2018, Revised Selected Papers, Lecture Notes in Computer Science, 2018.</li>

      <li>[16] Sean Bowe, Jack Grigg, and Daira Hopwood. Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://ia.cr/2019/1021.</li>

      <li>[17] Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and Dan Boneh. Zether: Towards privacy in a smart contract world. In Joseph Bonneau and Nadia Heninger, editors, Financial Cryptography and Data Security, pages 423–443, Cham, 2020.</li>

      <li>[18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. 2018 IEEE Symposium on Security and Privacy (SP), pages 315–334, 2018.</li>

      <li>[19] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. IACR Cryptol. ePrint Arch., 2020:499, 2020.</li>

      <li>[20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent snarks from dark compilers. In 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10–14, 2020, Proceedings, volume 12105 of Lecture Notes in Computer Science. Springer, 2020.</li>

      <li>[21] Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: A toolbox for more efficient universal and updatable zksnarks and commit-and-prove extensions. In Advances in Cryptology - ASIACRYPT 2021 - 27th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 6-10, 2021, Proceedings, Part III, 2021.</li>

      <li>[22] Ethan Cecchetti, Fan Zhang, Yan Ji, Ahmed E. Kosba, Ari Juels, and Elaine Shi. Solidus: Confidential distributed ledger transactions via pvorm. Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, 2017.</li>

      <li>[23] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He, Nicholas Hynes, Noah M. Johnson, Ari Juels, Andrew K. Miller, and Dawn Xiaodong Song. Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contracts. 2019 IEEE European Symposium on Security and Privacy (EuroS&P), pages 185–200, 2019.</li>

      <li>[24] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 738–768. Springer, Cham, 2020.</li>

      <li>[25] Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov, Lorenz Breidenbach, and Ari Juels. Flash boys 2.0: Front-running, transaction reordering, and consensus instability in decentralized exchanges. CoRR, abs/1904.05234, 2019.</li>

      <li>[26] The halo2 book. https://zcash.github.io/halo2/index.html. Accessed: 2022-04-26.</li>

      <li>[27] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, Advances in Cryptology — CRYPTO’ 86, pages 186–194, Berlin, Heidelberg, 1987. Springer Berlin Heidelberg.</li>

      <li>[28] Ariel Gabizon. Aztec emulated field and group operations. https://hackmd.io/LoEG5nRHQe-PvstVaD51Yw. Accessed: 2022-04-26.</li>

      <li>[29] Ariel Gabizon, Zac Williamson, and Tom Walton-Pocock. Aztec yellow paper. https://hackmd.io/@aztec-network/ByzgNxBfd. Accessed: 2022-09-26.</li>

      <li>[30] Ariel Gabizon and Zachary J Williamson. plookup: A simplified polynomial protocol for lookup tables. IACR Cryptol. ePrint Arch., 2020:315, 2020.</li>

      <li>[31] Ariel Gabizon, Zachary J Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint Arch., 2019:953, 2019.</li>

      <li>[32] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, Lecture Notes in Computer Science, 2013.</li>

    </ul>

    <p class="text-gray-300">[33] S Goldwasser, S Micali, and C Rackoff. The knowledge complexity of interactive proof-systems. In Proceedings of the Seventeenth Annual ACM Symposium on Theory of Computing, STOC ’85, New York, NY, USA, 1985. Association for Computing Machinery.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[34] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. In USENIX Security Symposium, 2021.</li>

      <li>[35] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, 2010.</li>

      <li>[36] Jens Groth. On the size of pairing-based non-interactive arguments. In Annual international conference on the theory and applications of cryptographic techniques, pages 305–326. Springer, 2016.</li>

      <li>[37] Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-snarks. In Hovav Shacham and Alexandra Boldyreva, editors, Advances in Cryptology – CRYPTO 2018, pages 698–728, Cham, 2018. Springer International Publishing.</li>

      <li>[38] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable snarks. In Jonathan Katz and Hovav Shacham, editors, Advances in Cryptology – CRYPTO 2017, pages 581–612, Cham, 2017. Springer International Publishing.</li>

      <li>[39] Youssef El Housni and Aurore Guillevic. Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition. IACR Cryptol. ePrint Arch., 2020:351, 2020.</li>

      <li>[40] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, Advances in Cryptology - ASIACRYPT 2010, pages 177–194, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.</li>

      <li>[41] Thomas Kerber, Aggelos Kiayias, and Markulf Kohlweiss. Kachina – foundations of private smart contracts. 2021 IEEE 34th Computer Security Foundations Symposium (CSF), pages 1–16, 2021.</li>

      <li>[42] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In Proceedings of the Twenty-Fourth Annual ACM Symposium on Theory of Computing, STOC ’92. Association for Computing Machinery, 1992.</li>

      <li>[43] Ahmed E. Kosba, Andrew K. Miller, Elaine Shi, Zikai Wen, and Charalampos Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. 2016 IEEE Symposium on Security and Privacy (SP), pages 839–858, 2016.</li>

      <li>[44] Fernando Krell, Binyi Chen, Philippe Camacho, and Alex Xiong. Configurable asset privacy: Specification. https://raw.githubusercontent.com/EspressoSystems/cap/master/cap-specification.pdf, 2021. Accessed: 2022-04-25.</li>

      <li>[45] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, CCS ’19, page 2111–2128, New York, NY, USA, 2019. Association for Computing Machinery.</li>

      <li>[46] Bart Mennink, Reza Reyhanitabar, and Damian Vizár. Security of full-state keyed sponge and duplex: Applications to authenticated encryption. In International Conference on the Theory and Application of Cryptology and Information Security, pages 465–489. Springer, 2015.</li>

      <li>[47] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 2000.</li>

      <li>[48] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, Dec 2008. Accessed: 2015-07-01.</li>

      <li>[49] Neha Narula, Willy Vasquez, and Madars Virza. zkledger: Privacy-preserving auditing for distributed ledgers. In IACR Cryptol. ePrint Arch., 2018.</li>

      <li>[50] Luke Pearson, Joshua Fitzgerald, Héctor Masip, Marta Bellés-Muñoz, and Jose Luis Muñoz-Tapia. Plonkup: Reconciling plonk with plookup. Cryptology ePrint Archive, Report 2022/086, 2022. https://ia.cr/2022/086.</li>

      <li>[51] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9(2):230–250, 1980.</li>

      <li>[52] Ravital Solomon and Ghada Almashaqbeh. smartfhe: Privacy-preserving smart contracts from fully homomorphic encryption. IACR Cryptol. ePrint Arch., 2021:133, 2021.</li>

      <li>[53] Samuel Steffen, Benjamin Bichsel, Roger Baumgartner, and Martin Vechev. Zeestar: Private smart contracts by homomorphic encryption and zero-knowledge proofs. In 2022 IEEE Symposium on Security and Privacy (SP), pages 1543–1543. IEEE Computer Society, 2022.</li>

      <li>[54] Samuel Steffen, Benjamin Bichsel, Mario Gersbach, Noa Melchior, Petar Tsankov, and Martin T. Vechev. zkay: Specifying and enforcing data privacy in smart contracts. Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, 2019.</li>

      <li>[55] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Proceedings of the 5th Conference on Theory of Cryptography, TCC’08, page 1–18, Berlin, Heidelberg, 2008. Springer-Verlag.</li>

      <li>[56] Gavin Wood et al. Ethereum: A secure decentralised generalised transaction ledger. Ethereum project yellow paper, 151(2014):1–32, 2014.</li>

    </ul>

    <h2 id="sec-33" class="text-2xl font-bold">Appendix A Related Work</h2>

    <p class="text-gray-300">Private Smart Contracts. Since the exciting work of Zexe <em>[14]</em>, there have been more works on privacy-preserving smart contracts. ZKay <em>[54]</em> observes the difficulty of expressing programs in low-level circuits correctly, and designs a high-level language to annotate private data with explicit ownership. Zkay provides a compiler transforming zkay contracts into Solidity contracts on Ethereum that leverages encryption for privacy and NIZK proofs for correctness. Unfortunately, transactions in Zkay cannot operate on “foreign values” (values owned by parties other than the caller), a limitation addressed by ZeeStar <em>[53]</em> which uses additive homomorphic encryption to allow the simple addition of foreign values. Zkay and ZeeStar lower the barrier for non-cryptographers to write contracts in higher-level language but have many restrictions and limited expressiveness.</p>

    <p class="text-gray-300">Meanwhile, zkHawk <em>[4]</em> extends Hawk <em>[43]</em> by replacing the minimal trusted manager who will learn the private inputs from users with an MPC protocol. To avoid running a SNARK prover in MPC which is prohibitively expensive, they simplify the Hawk framework by assuming a “freeze-compute-finalize” three-phase process for program execution. To enforce the correct payout of the original deposits from the “freeze” phase during the “finalize” phase or contract closure, zkHawk uses sigma protocols and homomorphic commitments, similar to techniques used in confidential transactions. While this model is perfect for applications like sealed bid auctions, it is arguably restricted since many applications run forever without a clear closure yet require frequent intermediate on-chain state commitments.</p>

    <p class="text-gray-300">SmartFHE [52] is the first to use fully-homomorphic encryption in the blockchain model and allow multi-user computation on-chain with hidden function inputs and outputs. Additionally, to mitigate concurrency issues, SmartFHE introduces account locking to freeze account balance or states from unintended updates when some private transactions are still in the mempool. Inevitably, the biggest obstacle is still the staggering cost of FHE for arbitrary computation.</p>

    <p class="text-gray-300">Kachina [41] provides a unified universal composable (UC) model on private smart contracts which claims to be an overarching framework to capture ZEXE, Hawk, Zether, and more while preserving their original privacy guarantees. One of the novelties of Kachina is introducing the concept of state oracle transcript and model read/write of private and public states as query/response from the local and public oracles. Transactions are further allowed to declare inter-dependencies, which together with the public oracle transcripts are supposed to help with the concurrency issue. However, it remains to be demonstrated how to achieve flexible composability of contracts and complex interactions among contracts in Kachina. Particularly, [41] did not offer concrete construction that improves ZEXE.</p>

    <p class="text-gray-300">In short, ZEXE remains the only concrete private smart contract construction to date that offers both data privacy and function privacy with rich expressiveness.</p>

    <p class="text-gray-300">Universal SNARKs. Zero-knowledge proof [33] allows a prover to convince a verifier of an NP statement without revealing any extra information. Subsequent works lead to non-interactive proofs [11] in the common reference string model and arguments with sublinear communication [42, 47] where malicious provers are computationally bounded. In the recent decade, a long line of work [9, 10, 32, 35, 36, 38] has focused on succinct non-interactive argument of knowledge (SNARK) with succinct proofs, sometimes of constant size, and fast verification. These SNARKs usually rely on some heavy offline pre-processing to generate a circuit-specific structured reference string (SRS) to facilitate faster online verification. Even though some constructions like Groth16 are highly efficient and widely deployed, sampling of the SRS would require a trusted setup for each circuit, instantiated using a secure multi-party ceremony [15] that takes months in practice, which is highly unsustainable. One way around this is using an argument system with a transparent setup depending on only uniformly random reference strings without any toxic trapdoor; however, they usually result in larger proof size [5] or non-succinct (linear) verification cost [18]. Another alternative is using a universal and updatable model [37] where a circuit-independent SRS is generated when the system boots up, and any party can update the SRS in a verifiable way; the trapdoor is unknown to all parties as long as at least one contributor is honest. Sonic [45] presents the first efficient universal SNARK construction, followed up by Marlin [24], Plonk [31], and Lunar [21] to further improve the efficiency</p>

    <p class="text-gray-300">of the proof system.</p>

    <p class="text-gray-300">Universal SNARKs strike a good balance between efficiency and acceptable trust assumption. We choose variants of Plonk for our implementations primarily due to its excellent performance, customizable gates, and importantly its support for lookup argument [13, 30] that some of our optimization techniques depend on.</p>

    <p class="text-gray-300">A commitment scheme COM = (COM.Setup, COM.Commit, COM.Open) is a triple of efficient algorithms where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}_{\\mathsf{COM}} \\stackrel{\\mathbb{S}}{\\leftarrow} \\mathsf{COM}. \\mathsf{Setup}(1^{\\lambda})</span>  generates a public parameter given the security parameter;</li>

      <li><span class="math">\\mathsf{cm} \\gets \\mathsf{COM}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{COM}}, m; r)</span>  produces a commitment  <span class="math">\\mathsf{cm}</span>  given the message from a message space to be committed ( <span class="math">m \\in \\mathcal{M}_{\\mathsf{pp}_{\\mathsf{COM}}}</span> ), and an explicit randomness  <span class="math">r \\stackrel{\\mathbb{S}}{\\leftarrow} \\mathcal{R}_{\\mathsf{pp}_{\\mathsf{COM}}}</span>  from the randomness space;</li>

      <li><span class="math">b \\gets \\mathsf{COM}. \\mathsf{Open}(\\mathsf{pp}_{\\mathsf{COM}}, \\mathsf{cm}, m, r)</span>  checks whether  <span class="math">(m, r)</span>  is an opening of the commitment  <span class="math">\\mathsf{cm}</span> , and outputs a bit  <span class="math">b \\in \\{0, 1\\}</span>  representing accept if  <span class="math">b = 1</span> , and reject otherwise.</li>

    </ul>

    <p class="text-gray-300">Informally, a commitment scheme is called binding if once a message is committed, it is infeasible to later open to a different message; and it is called hiding if the commitments of any two messages are indistinguishable from one another.</p>

    <p class="text-gray-300">Formally, COM is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computationally Binding if for all efficient adversaries  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span>  such that:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} _ {\\mathsf {C O M}} \\leftarrow \\mathsf {C O M}. \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ b _ {0} = b _ {1} \\neq 0 &amp;amp; (\\mathsf {c m}, x _ {0}, x _ {1}, r _ {0}, r _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {C O M}}) \\\\ \\wedge x _ {0} \\neq x _ {1} &amp;amp; b _ {0} \\leftarrow \\mathsf {C O M}. \\mathsf {O p e n} (\\mathsf {p p} _ {\\mathsf {C O M}}, \\mathsf {c m}, x _ {0}, r _ {0}) \\\\ &amp;amp; b _ {1} \\leftarrow \\mathsf {C O M}. \\mathsf {O p e n} (\\mathsf {p p} _ {\\mathsf {C O M}}, \\mathsf {c m}, x _ {1}, r _ {1}) \\end{array} \\right]</span></div>

    <p class="text-gray-300"><span class="math">\\leq \\mathrm{negl}(\\lambda)</span></p>

    <p class="text-gray-300">if  <span class="math">\\mathrm{negl}(\\lambda) = 0</span> , then we say the scheme is perfectly binding.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Statistically Hiding if for all unbounded adversaries  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <p class="text-gray-300">there exists a negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = \\hat {b} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {p p} _ {\\mathsf {C O M}} \\leftarrow \\mathsf {C O M . S e t u p} (1 ^ {\\lambda}); \\\\ b \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\}, r \\stackrel {{\\S}} {{\\leftarrow}} \\mathcal {R} _ {\\mathsf {p p} _ {\\mathsf {C O M}}}, \\\\ (x _ {0}, x _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {C O M}}) \\\\ \\mathsf {c m} \\leftarrow \\mathsf {C O M . C o m m i t} (\\mathsf {p p} _ {\\mathsf {C O M}}, x _ {b}; r) \\\\ \\hat {b} \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {C O M}}, \\mathsf {c m}) \\end{array} \\right] - \\frac {1}{2} \\right. \\right. \\right. \\leq \\operatorname {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">if  <span class="math">\\mathrm{negl}(\\lambda) = 0</span> , then we say the scheme is perfectly hiding.</p>

    <h2 id="sec-36" class="text-2xl font-bold">B.2 Polynomial Commitment Scheme</h2>

    <p class="text-gray-300">Introduced in [40], Polynomial Commitment Schemes (PCS) enables a prover to commit to a polynomial  <span class="math">f \\in \\mathbb{F}[X]</span> , and later open the commitment  <span class="math">c</span>  at any point  <span class="math">z \\in \\mathbb{F}</span>  by producing an evaluation proof  <span class="math">\\pi</span>  attesting that "the opened value is consistent with committed polynomial and  <span class="math">f(z) = y</span> ". A polynomial commitment scheme is a tuple of algorithms PCS = (Setup, Commit, Open, Eval) where (Setup, Commit, Open) is a binding commitment scheme for a message space  <span class="math">\\mathbb{F}[X]</span>  of polynomials over a finite field  <span class="math">\\mathbb{F}</span> , and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\bot, b) \\gets \\mathsf{PCS.Eval}(\\mathcal{P}(\\mathsf{pp}_{\\mathsf{PCS}}, f, r), \\mathcal{V}(\\mathsf{pp}_{\\mathsf{PCS}}, \\mathbf{cm}, z, y))</span>  is a public-coin interactive protocol between the prover  <span class="math">\\mathcal{P}</span>  who has a list of polynomials and opening hints  <span class="math">\\{f_i, r_i\\}_{i=1}^n</span> , where  <span class="math">f_i \\in \\mathbb{F}^{&amp;lt;d}[X]</span> ; and the verifier  <span class="math">\\mathcal{V}</span>  who has the common input  <span class="math">\\mathsf{pp}_{\\mathsf{PCS}}</span>  and a list of commitments, evaluation points, and their evaluations  <span class="math">\\{\\mathsf{cm}_i, z_i, y_i\\}_{i=1}^n</span>  where  <span class="math">(\\mathsf{cm}_i, z_i, y_i) \\in \\mathbb{G} \\times \\mathbb{F}^2</span> . The verifier outputs  <span class="math">b \\in \\{0, 1\\}</span>  and the prover has no output. The purpose of the protocol is to convince the verifier that for  <span class="math">\\forall i \\in [n]</span> ,  <span class="math">f_i(z_i) = y_i</span>  and  <span class="math">\\deg(f_i) &amp;lt; d</span> .</li>

    </ul>

    <p class="text-gray-300">A PCS is correct if for all degree bound  <span class="math">d \\in \\mathbb{N}</span>  and efficient adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} _ {\\mathsf {P C S}} \\leftarrow \\mathsf {P C S . S e t u p} (1 ^ {\\lambda}, d) \\\\ &amp;amp; (d, f, r, z) \\leftarrow \\mathcal {A} (\\mathsf {p p} _ {\\mathsf {P C S}}) \\\\ \\text {F o r} i \\in [ n ]: \\\\ \\mathsf {f} _ {1, i} \\big) _ {i = 1} ^ {n} &amp;amp; \\mathsf {c m} _ {i} \\leftarrow \\mathsf {P C S . C o m m i t} (\\mathsf {p p} _ {\\mathsf {P C S}}, f _ {i}; r _ {i}) \\\\ \\wedge b _ {2} = 1 &amp;amp; b _ {1, i} \\leftarrow \\mathsf {P C S . O p e n} (\\mathsf {p p} _ {\\mathsf {P C S}}, \\mathsf {c m} _ {i}, f _ {i}, r _ {i}) \\\\ &amp;amp; y _ {i} \\leftarrow f _ {i} (z _ {i}) \\\\ &amp;amp; (\\bot , b _ {2}) \\leftarrow \\mathsf {P C S . E v a l} \\left( \\begin{array}{c} \\mathcal {P} (\\mathsf {p p} _ {\\mathsf {P C S}}, f, r), \\\\ \\mathcal {V} (\\mathsf {p p} _ {\\mathsf {P C S}}, \\mathbf {c m}, z, y) \\end{array} \\right) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">A PCS has knowledge soundness if PCS.Eval has knowl-</p>

    <p class="text-gray-300">edge soundness as an interactive argument for  <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(\\mathsf{pp}_{\\mathrm{PCS}})</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {E v a l}} (\\mathsf {p p} _ {\\mathsf {P C S}}) = \\left\\{ \\begin{array}{c} (\\pi = (\\mathbf {c m}, z, y, d), \\mathbb {w} = (f, r)): \\\\ \\text {F o r} i \\in [ n ]: \\\\ f _ {i} \\in \\mathbb {F} [ x ] \\wedge \\deg (f _ {i}) &amp;lt;   d \\\\ \\wedge f _ {i} (z _ {i}) = y _ {i} \\\\ \\wedge \\mathsf {P C S . O p e n} (\\mathsf {p p} _ {\\mathsf {P C S}}, \\mathsf {c m} _ {i}, f _ {i}, r _ {i}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">Linearly Additive Homomorphism. A PCS is linearly additively homomorphic if it holds the following property: let  <span class="math">[C_i]_{i=1}^n</span>  commit to  <span class="math">[f_i]_{i=1}^n</span> , then  <span class="math">\\sum_{i=1}^n a_i \\circ C_i</span>  commits to  <span class="math">\\sum_{i=1}^n a_i \\cdot f_i</span>  for any  <span class="math">a_i \\in \\mathbb{F}</span> . Here, arithmetics operations for  <span class="math">f_i</span>  are over  <span class="math">\\mathbb{F}[X]</span> ; and  <span class="math">\\circ</span>  is the addition over the commitment space (e.g. it is the group addition in [40]).</p>

    <h2 id="sec-37" class="text-2xl font-bold">B.3 Indexed Relation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define an indexed relation  <span class="math">\\mathcal{R}</span>  as a set of  <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w})</span> , where  <span class="math">\\mathrm{i}</span>  is the index that describes the circuit;  <span class="math">\\mathrm{x}</span>  consists of the (public) instances that hold the assignments to a subset of wires; and  <span class="math">\\mathrm{w}</span>  is the witness that holds the assignments to the remaining wires in the circuit. The corresponding indexed language is defined as:  <span class="math">\\mathcal{L}(\\mathcal{R}):= \\{(\\mathrm{i},\\mathrm{x}):\\exists \\mathrm{w}</span>  s.t.  <span class="math">(\\mathrm{i},\\mathrm{x},\\mathrm{w})\\in \\mathcal{R}\\}</span> . We further denote  <span class="math">\\mathcal{R}_N</span>  for a relation with an upper-bounded circuit  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; N<span class="math">  where  </span>N\\in \\mathbb{N}<span class="math">  is the size bound. When there is no ambiguity, we use  </span>\\mathrm{i} = \\Phi<span class="math">  to represent the indexing of circuit for the relation:  </span>\\mathcal{R}_{\\Phi}:= \\{(\\mathrm{x},\\mathrm{w}):\\Phi (\\mathrm{x},\\mathrm{w}) = 1\\}<span class="math"> ; and refer to  </span>\\Phi$  as a predicate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-38" class="text-2xl font-bold">B.4 Pre-processing SNARK with Universal SRS</h2>

    <p class="text-gray-300">A (pre-processing) non-interactive argument of knowledge (NARK) is a tuple of efficient algorithms NARK =  <span class="math">(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{srs} \\gets \\mathsf{NARK}. \\mathcal{G}(\\lambda, N)</span>  is a probabilistic algorithm that generates a structured reference string  <span class="math">\\mathsf{srs}</span>  from the security parameter  <span class="math">\\lambda</span>  and a size bound  <span class="math">N</span>  for the circuit.</li>

      <li><span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) \\gets \\mathrm{NARK}. \\mathcal{I}^{\\mathrm{srs}}(\\mathrm{i})</span>  is a deterministic algorithm that, given a circuit description  <span class="math">\\mathrm{i}</span>  and oracle access to  <span class="math">\\mathrm{srs}</span> , generates an index proving key  <span class="math">\\mathrm{ipk}</span>  and index verifying key  <span class="math">\\mathrm{ivk}</span>  for this particular circuit.</li>

      <li><span class="math">\\pi \\gets \\mathsf{NARK}. \\mathcal{P}(\\mathrm{ipk}, \\mathrm{x}, \\mathrm{w})</span>  is a probabilistic prover algorithm that, given an index proving key  <span class="math">\\mathrm{ipk}</span>  corresponding to some relation  <span class="math">\\mathcal{R}_{\\Phi}</span> , an instance  <span class="math">\\mathrm{x}</span> , and a witness  <span class="math">\\mathrm{w}</span> , returns a NARK proof  <span class="math">\\pi</span> .</li>

      <li><span class="math">b \\gets \\mathsf{NARK}. \\mathcal{V}(\\mathrm{ivk}, \\mathrm{x}, \\pi)</span>  is a verifier algorithm that, given the index verifying key  <span class="math">\\mathrm{ivk}</span> , the instance  <span class="math">\\mathrm{x}</span> , and the proof  <span class="math">\\pi</span> , outputs a bit  <span class="math">b</span>  where  <span class="math">b = 1</span>  indicates successful verification,  <span class="math">b = 0</span>  otherwise.</li>

    </ul>

    <p class="text-gray-300">A NARK scheme  <span class="math">\\mathsf{NARK} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  for relation  <span class="math">\\mathcal{R}_{\\Phi}</span>  needs to the following properties to hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all size bound  <span class="math">N \\in \\mathbb{N}</span> , all adversaries  <span class="math">\\mathcal{A}</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathrm {x}, \\mathrm {w}) \\notin \\mathcal {R} _ {\\Phi} &amp;amp; \\text {s r s} \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {G} (\\lambda , N) \\\\ \\vee &amp;amp; (\\Phi , \\mathrm {x}, \\mathrm {w}) \\leftarrow \\mathcal {A} (\\mathrm {s r s}) \\\\ \\text {N A R K .} \\mathcal {V} (\\mathrm {i v k}, \\mathrm {x}, \\pi) = 1 &amp;amp; (\\mathrm {i v k}, \\mathrm {i p k}) \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {I} ^ {\\mathrm {s r s}} (\\Phi) \\\\ &amp;amp; \\pi \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {P} (\\mathrm {i p k}, \\mathrm {x}, \\mathrm {w}) \\end{array} \\right] \\\\ = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive Knowledge Soundness. For all  <span class="math">N \\in \\mathbb{N}</span> , all efficient adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  with state st, there exists a knowledge extractor  <span class="math">\\mathcal{E}^{\\mathcal{A}}</span>  with oracle access to  <span class="math">\\mathcal{A}</span> , such that:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathrm {x}, \\mathrm {w}) \\notin \\mathcal {R} _ {\\Phi} &amp;amp; \\text {s r s} \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {G} (\\lambda , N) \\\\ \\wedge &amp;amp; (\\Phi , \\mathrm {x}, \\mathrm {s t}) \\leftarrow \\mathcal {A} _ {1} (\\mathrm {s r s}) \\\\ \\text {N A R K .} \\mathcal {V} (\\mathrm {i v k}, \\mathrm {x}, \\pi) = 1 &amp;amp; (\\mathrm {i v k}, \\mathrm {i p k}) \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {I} ^ {\\mathrm {s r s}} (\\Phi) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {A} _ {2} (\\mathrm {s t}) \\\\ &amp;amp; \\mathrm {w} \\leftarrow \\mathcal {E} ^ {\\mathcal {A}} (\\mathrm {s r s}, \\Phi , \\mathrm {x}, \\mathrm {i p k}, \\mathrm {i v k}) \\end{array} \\right] \\\\ \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">A NARK scheme can additionally satisfy the following optional properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Statistical Zero-knowledge. For all  <span class="math">N \\in \\mathbb{N}</span> , all unbounded adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , there exists an efficient simulator <span class="math">^{15}</span> <span class="math">\\mathcal{S} = (\\mathcal{S}_1, \\mathcal{S}_2)</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} (\\mathrm {x}, \\mathrm {w}) \\in \\mathcal {R} _ {\\Phi} &amp;amp; \\text {s r s} \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {G} (1 ^ {\\lambda}, N) \\\\ \\wedge &amp;amp; (\\Phi , \\mathrm {x}, \\mathrm {w}, \\mathrm {s t}) \\leftarrow \\mathcal {A} _ {1} (\\mathrm {s r s}) \\\\ \\mathcal {A} _ {2} (\\mathrm {s t}, \\pi) = 1 &amp;amp; (\\mathrm {i v k}, \\mathrm {i p k}) \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\text {N A R K .} \\mathcal {I} ^ {\\mathrm {s r s}} (\\Phi) \\\\ &amp;amp; \\pi \\leftarrow \\text {N A R K .} \\mathcal {P} (\\mathrm {i p k}, \\mathrm {x}, \\mathrm {w}) \\end{array} \\right] \\\\ - \\Pr \\left[ \\begin{array}{c c} (\\mathrm {x}, \\mathrm {w}) \\in \\mathcal {R} _ {\\Phi} &amp;amp; (\\mathrm {s r s}, \\tau) \\stackrel {{\\mathrm {S}}} {{\\leftarrow}} \\mathcal {S} _ {1} (1 ^ {\\lambda}, N) \\\\ \\wedge &amp;amp; (\\Phi , \\mathrm {x}, \\mathrm {w}, \\mathrm {s t}) \\leftarrow \\mathcal {A} _ {1} (\\mathrm {s r s}) \\\\ \\mathcal {A} _ {2} (\\mathrm {s t}, \\pi) = 1 &amp;amp; \\pi \\leftarrow \\mathcal {S} _ {2} (\\tau , \\Phi , \\mathrm {x}) \\end{array} \\right] \\\\ \\leq \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness. A NARK scheme is said succinct (and thus denoted as SNARK) if there exists a universal polynomial poly (independent of relation  <span class="math">\\mathcal{R}_{\\Phi}</span> ) such that:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The indexer algorithm  <span class="math">\\mathsf{NARK}.\\mathcal{I}^{\\mathrm{srs}}</span>  runs in  $\\mathrm{poly}_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  time, namely, it is polynomial in the circuit size and independent from the public parameter srs size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 10: Incrementally Verifiable Computation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier NARK.  <span class="math">\\mathcal{V}</span>  runs in  $\\mathrm{poly}(\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time. Particularly if is independent from the size of the predicate  </span>\\Phi<span class="math">  (equivalently the circuit  </span>\\mathbb{1}$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, when the structured referenced string  <span class="math">\\mathrm{srs}</span>  is independent from all subsequent relations  <span class="math">\\mathcal{R}_N</span> , we refer to these NARKs as universal since their SRS can be universally applied to all relations of a bounded size  <span class="math">N</span> . Universal (S)NARKs are of tremendous interest because they obviate the requirement of a "circuit-specific"  <span class="math">\\mathrm{srs}</span>  and thus a dedicated setup ceremony for each relation. Usually, SNARK with universal  <span class="math">\\mathrm{srs}</span>  are also updateable [37], allowing anyone to efficiently update the SRS thus reducing the trust assumption on the setup ceremony during NARK.  <span class="math">\\mathcal{G}</span> .</p>

    <p class="text-gray-300">The notion of incrementally verifiable computation (IVC), introduced by Valiant [55], describes a machine that outputs the updated state in each step of computation, along with a proof attesting to the correctness of all historical computation steps. As shown in Fig. 10, an IVC starts with an initial state  <span class="math">z_0</span>  and takes  <span class="math">t</span>  steps to compute the function  <span class="math">F_0 \\circ F_1 \\circ \\ldots \\circ F_{t-1}</span>  and outputs the final state  <span class="math">z_t</span> . In each step, an IVC prover takes in the state  <span class="math">z_i</span> , some optional witness  <span class="math">w_i</span> , and integrity proof  <span class="math">\\pi_i</span>  from the last step, apply the computation  <span class="math">F_i</span>  and outputs the new state  <span class="math">z_{i+1}</span>  together with a new proof attesting correctness of  <span class="math">\\pi_i</span>  and correctness of state transitions  <span class="math">z_{i+1} = F_i(z_i)</span> . An IVC verifier can "jump in" at any step  <span class="math">i \\in [t]</span> , verify the  <span class="math">(z_i, \\pi_i)</span> , and be convinced that the state is correct since all historical computations are incrementally verified.</p>

    <p class="text-gray-300">For simpler presentation and W.L.O.G., we assume that  <span class="math">F = F_{0} = \\ldots = F_{t - 1}</span> . An IVC for a step function  <span class="math">F: \\mathcal{X} \\mapsto \\mathcal{X}</span>  is a tuple of efficient algorithms  <span class="math">\\mathrm{IVC} = (\\mathcal{P}_F, \\mathcal{V}_F)</span>  that follows these properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all inputs  <span class="math">z \\in \\mathcal{X}</span> , witnesses  <span class="math">w</span>  and proofs  <span class="math">\\pi</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ z ^ {\\prime} = F (z, w) \\wedge \\mathcal {V} _ {F} \\left(z ^ {\\prime}, \\pi^ {\\prime}\\right) = 1 \\mid \\left(z ^ {\\prime}, \\pi^ {\\prime}\\right) \\leftarrow \\mathcal {P} _ {F} (z, w, \\pi) \\right] = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness. For all efficient adversaries  <span class="math">\\mathcal{A}</span> , there exists an efficient knowledge extractor  <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> , such that:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {F} (z _ {t}, \\pi) = 0 &amp;amp; (z _ {t}, \\pi) \\leftarrow \\mathcal {A} \\\\ \\vee &amp;amp; \\left\\{z _ {i}, w _ {i} \\right\\} _ {i = 1} ^ {t - 1} \\leftarrow \\mathcal {E} _ {\\mathcal {A}} \\end{array} \\right] \\\\ \\geq 1 - \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">C Plonk Constraint Systems</p>

    <p class="text-gray-300">A Plonk (and its variants) constraint system over a finite field <span class="math">\\mathbb{F}</span> consists of many gates, each of which has a predefined number of wires where each wire is to be assigned with a value in the witness vector. Each gate implies an algebraic relation among all wire values and the exact relation is configurable via some selectors to collectively select the exact function applied, and a public input wire to be assigned with values of the public input of an NP relation. Value assignments for all wires are described using an index vector that connects each wire with a specific value in the witness vector. For an NP relation expressed in this constraint system, the index vector, the selectors and the field <span class="math">\\mathbb{F}</span> constitute the circuit description. Such constraint system is satisfied if and only if some “local constraints” (i.e. algebraic functions at each gate) are fulfilled and some “regional/global constraints” across different/all gates (e.g. all wire values respect the index vector connection) are fulfilled.</p>

    <p class="text-gray-300">We denote <span class="math">n,m,\\ell</span> the number of gates, length of witness vector, and the number of public inputs respectively. We adopt definitions of Plonk and its variants to indexed relations (defined in Appx. B.3) below.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 1 (Plonk indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{plonk}}</span> is the set of all triples:</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathbb{i}=(\\mathbb{F},n,m,\\ell,a,\\mathcal{Q}),\\mathbb{x}=(w_{j})_{j\\in[\\ell]},\\mathbb{w}=(w_{j})_{j\\in[\\ell+1,m]}\\big{)}</span></p>

    <p class="text-gray-300">where the index vector <span class="math">a\\in[m]^{3n}</span>, selectors are <span class="math">\\mathcal{Q}:=(q_{L},q_{R},q_{O},q_{M},q_{C})\\in(\\mathbb{F}^{n})^{5}</span>, such that <span class="math">\\forall i\\in[n]</span>,</p>

    <p class="text-gray-300"><span class="math">(q_{L})_{i}\\cdot w_{a_{i}}+(q_{R})_{i}\\cdot w_{a_{n+i}}+(q_{M})_{i}\\cdot w_{a_{i}}w_{a_{n+i}}+(q_{C})_{i}+\\mathsf{Pl}_{i}</span> <span class="math">=(q_{O})_{i}\\cdot w_{a_{2n+i}}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Pl}_{i}=w_{i}</span> for <span class="math">i\\in[\\ell]</span> and <span class="math">\\mathsf{Pl}_{i}=0</span> for <span class="math">i\\in[\\ell+1,n]</span>.</p>

    <p class="text-gray-300">Next, we propose a TurboPlonk constraint system that allows for customized gates beyond just addition and multiplication gate. However, we note that TurboPlonk proof system has a higher per-gate cost for proof generation and higher fan-in resulting in a slightly larger proof size and more polynomial to interpolate during proving. Fortunately, our design is extremely efficient for NP relations that involve heavy Rescue computation (e.g. Merkle proof verification in a Merkle tree instantiated with Rescue hash) and elliptic curve operations, since the total constraints required are significantly reduced, the overall efficiency will be improved.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 2 (TurboPlonk indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{tplonk}}</span> is the set of all triples:</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathbb{i}=(\\mathbb{F},n,m,\\ell,a,\\mathcal{Q}),\\mathbb{x}=(w_{j})_{j\\in[\\ell]},\\mathbb{w}=(w_{j})_{j\\in[\\ell+1,m]}\\big{)}</span></p>

    <p class="text-gray-300">where the index vector <span class="math">a\\in[m]^{5n}</span>, selectors are <span class="math">\\mathcal{Q}:=(q_{1},q_{2},q_{3},q_{4},q_{M_{1,2}},q_{M_{3,4}},q_{O},q_{C},q_{H_{1}},q_{H_{2}},q_{H_{3}},q_{H_{4}},q_{ecc})\\quad\\in\\mathbb{F}^{n\\times 13}</span>, such that <span class="math">\\forall i\\in[n]</span>,</p>

    <p class="text-gray-300"><span class="math">(q_{O})_{i}\\cdot w_{a_{4n+i}}</span> <span class="math">=(q_{1})_{i}\\cdot w_{a_{i}}+(q_{2})_{i}\\cdot w_{a_{n+i}}</span> <span class="math">+(q_{3})_{i}\\cdot w_{a_{2n+i}}+(q_{4})_{i}\\cdot w_{a_{3n+i}}</span> <span class="math">+(q_{M_{1,2}})_{i}\\cdot w_{a_{i}}w_{a_{n+i}}+(q_{M_{3,4}})_{i}\\cdot w_{a_{2n+i}}w_{a_{3n+i}}</span> <span class="math">+(q_{H_{1}})_{i}\\cdot w_{a_{i}}^{5}+(q_{H_{2}})_{i}\\cdot w_{a_{n+i}}^{5}</span> <span class="math">+(q_{H_{3}})_{i}\\cdot w_{a_{2n+i}}^{5}+(q_{H_{4}})_{i}\\cdot w_{a_{3n+i}}^{5}</span> <span class="math">+(q_{ecc})_{i}\\cdot w_{a_{i}}w_{a_{n+i}}w_{a_{2n+i}}w_{a_{3n+i}}w_{a_{4n+i}}</span> <span class="math">+(q_{C})_{i}+\\mathsf{Pl}_{i}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Pl}_{i}=w_{i}</span> for <span class="math">i\\in[\\ell]</span> and <span class="math">\\mathsf{Pl}_{i}=0</span> for <span class="math">i\\in[\\ell+1,n]</span>.</p>

    <p class="text-gray-300">Furthermore, to minimize the number of gates used for range proofs and multi-scalar multiplications, we integrate the techniques from Plookup <em>[30]</em> with the previous TurboPlonk constraint system and propose a customized UltraPlonk constraint system. The system is mainly used for outer-layer circuits, where we need to simulate non-native field arithmetics (whose circuit is dominated by range proofs), as well as the Pippenger-based multi-scalar multiplications (which require lookup over online key-value tables). The UltraPlonk constraint system extends TurboPlonk by further introducing the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To enable efficient range proofs, it introduces a preprocessed range table <span class="math">\\mathcal{T}_{\\text{rg}}\\in\\mathbb{F}^{n}</span>, an additional wire to each gate, and an index vector <span class="math">a_{\\text{rg}}\\in[m]^{n}</span>, such that for each <span class="math">i\\in[n]</span>, the witness value <span class="math">w_{(a_{\\text{rg}})_{i}}</span> is in the range table <span class="math">\\mathcal{T}_{\\text{rg}}</span>.</li>

      <li>To support multiple online lookup tables, each containing key-value tuples where the “keys” are scalars and the “values” are affine point variables (i.e. two variables for the <span class="math">x</span> and <span class="math">y</span> coordinates), it introduces the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A merged, preprocessed table <span class="math">\\mathcal{T}_{key}\\in\\mathbb{F}^{n}</span> containing predefined “keys” in the key-value entries across all sub-tables.</li>

      <li>A lookup selector <span class="math">q_{K}\\in\\mathbb{F}^{n}</span> to indicate whether a gate is performing online table entry insertion and query table insertion.</li>

      <li>Two domain separator selectors <span class="math">q_{lr},q_{qr}</span> for indicating the exact lookup sub-table and query sub-table an entry in the final merged table belongs to.</li>

    </ol>

    <p class="text-gray-300">More precisely, the <span class="math">i</span>-th entry in our merged online lookup table is a key-value tuple <span class="math">\\mathcal{T}_{i}:=(q_{K})_{i}\\cdot\\big{[}(q_{lr})_{i},(\\mathcal{T}_{key})_{i},w_{a_{3n+i}},w_{a_{4n+i}}\\big{]}</span>; the <span class="math">i</span>-th entry in our merged online query table is a key-value tuple <span class="math">\\mathcal{Q}_{i}:=(q_{K})_{i}\\cdot\\big{[}(q_{qr})_{i},w_{a_{i}},w_{a_{n+i}},w_{a_{2n+i}}\\big{]}</span>. The witness vector and</p>

    <p class="text-gray-300">index vector should satisfy that <span class="math">\\forall i\\in[n],\\mathcal{Q}_{i}\\in\\mathcal{T}:=(\\mathcal{T}_{j})_{j\\in[n]}</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 3 (UltraPlonk indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{uplonk}}</span> is the set of all triples <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})</span> where</p>

    <p class="text-gray-300"><span class="math">\\mathbb{i}</span> <span class="math">=(\\mathbb{F},n,m,\\ell,a,a_{\\text{rg}},\\mathcal{Q},\\mathcal{T}_{\\text{rg}},\\mathcal{T}_{\\text{key}})</span> <span class="math">\\mathbb{x}</span> <span class="math">=(w_{j})_{j\\in[\\ell]}</span> <span class="math">\\mathbb{w}</span> <span class="math">=(w_{j})_{j\\in[\\ell+1,m]}</span></p>

    <p class="text-gray-300">where the TurboPlonk index vector <span class="math">a\\in[m]^{5n}</span>, the index vector for the range wire: <span class="math">a_{\\text{rg}}\\in[m]^{n}</span>, selectors are: <span class="math">\\mathcal{Q}:=(q_{1},q_{2},q_{3},q_{4},q_{M_{1,2}},q_{M_{3,4}},q_{O},q_{C},q_{H_{1}},q_{H_{2}},q_{H_{3}},q_{H_{4}},q_{ecc},q_{K},q_{lt},q_{qt})\\in\\mathbb{F}^{n\\times 16}</span>, such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mathbb{F},n,m,\\ell,a,\\mathcal{Q}),\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}_{\\text{tplonk}}</span>.</li>

      <li><span class="math">\\forall i\\in[n]</span>, <span class="math">w_{(a_{\\text{rg}})_{i}}\\in\\mathcal{T}_{\\text{rg}}</span>.</li>

      <li><span class="math">\\forall i\\in[n]</span>, the query key-value tuple</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{Q}_{i}:=(q_{K})_{i}\\cdot\\big{[}(q_{qt})_{i},w_{a_{i}},w_{a_{n+i}},w_{a_{2n+i}}\\big{]}</span></p>

    <p class="text-gray-300">is in the lookup table</p>

    <p class="text-gray-300"><span class="math">\\mathcal{T}:=\\left\\{\\mathcal{T}_{j}=(q_{K})_{j}\\cdot\\Big{[}(q_{lt})_{j},(\\mathcal{T}_{\\text{key}})_{j},w_{a_{3n+j}},w_{a_{4n+j}}\\Big{]}\\right\\}_{j\\in[n]}</span></p>

    <p class="text-gray-300">Here <span class="math">a\\cdot b</span> denotes the element-wise multiplications between scalar <span class="math">a</span> and vector <span class="math">b</span>.</p>

    <h2 id="sec-43" class="text-2xl font-bold">Appendix D UltraPlonk Proof Systems</h2>

    <p class="text-gray-300">We present a Polynomial IOP for the UltraPlonk indexed relation <span class="math">\\mathcal{R}_{\\text{uplonk}}</span> (Def. 3) in Fig. 11 and follow notations similar to <em>[31]</em> and <em>[30]</em>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field of prime order <span class="math">p</span>, <span class="math">H\\subset\\mathbb{F}^{*}</span> the multiplicative subgroup containing the <span class="math">n</span>-th roots of unity where <span class="math">\\omega</span> is the generator of the subgroup, namely <span class="math">H:=\\{1,\\omega,\\omega^{2},\\ldots,\\omega^{n-1}\\}</span>. The Lagrange polynomial <span class="math">\\mathcal{L}_{i}(X)\\in\\mathbb{F}^{&lt;n}[X]</span> over <span class="math">H</span> is defined as <span class="math">\\mathcal{L}_{i}(X)=\\frac{\\omega^{i}(X^{n}-1)}{n(X-\\omega^{i})}</span> so that <span class="math">\\mathcal{L}_{i}(x)=1</span> when <span class="math">x=\\omega^{i}</span> and <span class="math">\\mathcal{L}_{i}(x)=0</span> elsewhere. The vanishing polynomial <span class="math">Z_{H}(X)</span> over <span class="math">H</span> is defined as <span class="math">Z_{H}(X)=(X-1)(X-\\omega)\\ldots(X-\\omega^{n-1})=X^{n}-1</span> so that <span class="math">\\forall x\\in H,Z_{H}(x)=0</span>.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">D.1 Witness transformation</h3>

    <p class="text-gray-300">Given an UltraPlonk indexed relation <span class="math">\\mathcal{R}_{\\text{uplonk}}:=\\big{(}\\mathbb{i},\\mathbb{x}=(w_{j})_{j\\in[\\ell]},\\mathbb{w}=(w_{j})_{j\\in[\\ell+1,m]}\\big{)}</span> with <span class="math">\\mathbb{i}=(\\mathbb{F},n,m,\\ell,a,a_{\\text{rg}},\\mathcal{Q},\\mathcal{T}_{\\text{rg}},\\mathcal{T}_{\\text{key}})</span>, we show how to transform the index vector <span class="math">a^{\\prime}=(a,a_{\\text{rg}})\\in[m]^{5n}\\times[m]^{n}</span> into a permutation: <span class="math">\\sigma:[6n]\\to[6n]</span> and transform <span class="math">\\mathcal{R}_{\\text{uplonk}}</span> into an equivalent relation: <span class="math">\\mathcal{R}^{\\prime}_{\\text{uplonk}}:=\\big{(}\\mathbb{i},\\mathbb{x}=(w^{\\prime}_{i})_{i\\in[\\ell]},\\mathbb{w}=(w^{\\prime}_{i})_{i\\in[\\ell+1,6n]}\\big{)}</span> with <span class="math">\\mathbb{i}=(\\mathbb{F},n,m,\\ell,\\sigma,\\mathcal{Q},\\mathcal{T}_{\\text{rg}},\\mathcal{T}_{\\text{key}})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define a partition <span class="math">\\mathcal{P}_{1},\\ldots,\\mathcal{P}_{m}</span> corresponding to <span class="math">m</span> values in the witness vector, such that for each <span class="math">j\\in[m]</span>: <span class="math">\\mathcal{P}_{j}=\\big{\\{}i\\in[6n]:a^{\\prime}_{i}=w_{j}\\big{\\}}</span>. Intuitively, <span class="math">\\mathcal{P}_{i}</span> is the set of gate wire identifiers whose assignments map to the same witness value <span class="math">w_{j}</span>.</li>

      <li>Define a permutation <span class="math">\\sigma:[6n]\\to[6n]</span> such that for each <span class="math">j\\in[m]</span>, the restriction of <span class="math">\\sigma</span> on input <span class="math">\\mathcal{P}_{j}</span> forms a cycle going over all elements in <span class="math">\\mathcal{P}_{j}</span>.</li>

      <li>Define a new instance-witness vector <span class="math">(w^{\\prime}_{i})_{i\\in[6n]}</span> such that for each <span class="math">j\\in[m]</span> and each <span class="math">i\\in\\mathcal{P}_{j}</span>, we have <span class="math">w^{\\prime}_{i}=w_{j}</span>. It is easy to see that this copy constraint holds if and only if <span class="math">\\forall i\\in[6n]</span>, <span class="math">w^{\\prime}_{i}=w^{\\prime}_{a(i)}</span>.</li>

    </ol>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">D.2 Polynomial Interpolation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">During arithmetization, we turn relations among some vectors indexed by gates into relations among some polynomials indexed by elements in a multiplicative subgroup <span class="math">H</span> – a process that involves polynomial interpolations. For vectors <span class="math">v=(v_{i})_{i\\in[n]}</span> of size <span class="math">n</span>, the same as the subgroup order, we interpolate using Lagrange polynomial and expressed as <span class="math">p_{v}(X)=\\sum_{i\\in[n]}\\mathcal{L}_{i}(X)\\cdot v_{i}\\in\\mathbb{F}^{&lt;n}[X]</span>. In practice, one should use (Inverse) Fast Fourier Transform (IFFT/FFT) to efficiently compute the coefficients of <span class="math">p_{v}(X)</span> from the data points <span class="math">(v_{i})_{i\\in[n]}</span>. For vectors of size <span class="math">kn</span> for some <span class="math">k\\in\\mathbb{N}</span>, we use <span class="math">k</span> polynomials over <span class="math">k</span> non-overlapping cosets of <span class="math">H</span> to interpolate all data points. In our case, we need to find <span class="math">\\{k_{i}\\}_{i\\in[6]}</span> such that <span class="math">k_{1}H,\\ldots,k_{6}H</span> are disjoint cosets of <span class="math">H</span> in order to interpolate polynomials from a vector of size <span class="math">6n</span>. We choose the cosets using the following algorithm: let $N\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be a global constant that is a multiple of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We pick </span>k_{1}=1<span class="math"> and pick random </span>k_{2},\\ldots k_{6}<span class="math"> such that </span>(k_{j}^{-1}\\cdot k_{i})^{N}\\neq 1<span class="math"> for every </span>i,j\\in[6],i\\neq j<span class="math"> because every elements </span>x\\in H<span class="math"> satisfies </span>x^{N}=1<span class="math">, and that: </span>aH=bH<span class="math"> if and only if </span>a^{-1}\\cdot b\\in H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-46" class="text-2xl font-bold">Appendix E Plonk with Merging, Batching and Accumulation</h2>

    <p class="text-gray-300">We present a scheme <span class="math">\\mathsf{Plonk}^{\\prime}</span> based on the vanilla Plonk in Def. 1 and that incorporates instance merging (§ 3.2), proof batching (§ 3.3), and lightweight verifier via accumulation scheme technique (§ 3.1). The presentation can be easily adapted to TurboPlonk which is what we use for inner predicate circuits in Zexe since it minimizes the circuit complexity of the outer proof. Details of <span class="math">\\mathsf{Plonk}^{\\prime}=(\\mathsf{Setup},\\mathsf{Index},\\mathsf{MergePK},\\mathsf{MergeVK},\\mathsf{MergeWit},\\mathsf{BatchProve},\\mathsf{BatchPartialVfy},\\mathsf{Decide})</span> are shown below.</p>

    <p class="text-gray-300">For generating a <span class="math">n_{\\text{pf}}</span>-input-<span class="math">n_{\\text{pf}}</span>-output transaction via <span class="math">\\mathsf{DPC}.\\mathsf{Execute}^{\\mathsf{L}}</span>, the user will take <span class="math">n_{\\text{pf}}</span> pair of input death predicate and output birth predicate <span class="math">(\\Phi_{d},\\Phi_{b})</span> and preprocess them via <span class="math">\\mathsf{Plonk}^{\\prime}.\\mathsf{Index}</span> to get proving keys and verification keys. The user then passes <span class="math">n_{\\text{pf}}</span> pair of proving keys, verification keys,</p>

    <p class="text-gray-300">The indexer  <span class="math">\\mathcal{I}</span>  takes as input an indexed instance  <span class="math">\\dot{\\mathbf{i}} = (\\mathbb{F},n,m,\\ell ,\\sigma ,\\mathcal{Q},\\mathcal{T}_{\\mathrm{rg}},\\mathcal{T}_{key})</span>  and outputs the following polynomial oracles:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The selector polynomials that interpolates selector vectors in  <span class="math">\\mathcal{Q}</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">q _ {1} (X) = \\sum_ {i \\in [ n ]} \\mathcal {L} _ {i} (X) \\cdot \\left(q _ {1}\\right) _ {i}, \\dots , q _ {q r} (X) = \\sum_ {i \\in [ n ]} \\mathcal {L} _ {i} (X) \\cdot \\left(q _ {q r}\\right) _ {i}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">\\sigma^{*} := \\sigma \\circ f_{\\sigma}: [6n] \\mapsto k_{1}H \\cup \\ldots \\cup k_{6}H</span> , where  <span class="math">f_{\\sigma} := i \\mapsto k_{1} \\cdot \\omega^{i}, \\ldots, 5n + i \\mapsto k_{6} \\cdot \\omega^{i} \\forall i \\in [n]</span> .</li>

    </ul>

    <p class="text-gray-300">The identity polynomials  <span class="math">S_{\\mathrm{ID}j}(X) = k_jX</span>  for each  <span class="math">j \\in [6]</span> , and the permutation polynomials  <span class="math">S_{\\sigma j}(X) = \\sum_{i \\in [n]} \\sigma^<em>((j - 1)n + i) \\cdot \\mathcal{L}_i(X)</span>  that encodes  <span class="math">\\sigma^</em></span>  for each  <span class="math">j \\in [6]</span> .</p>

    <p class="text-gray-300">The preprocessed table polynomials</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {T} _ {\\mathrm {r g}} (X) = \\sum_ {i \\in [ n ]} \\mathcal {L} _ {i} (X) \\cdot \\left(\\mathcal {T} _ {\\mathrm {r g}}\\right) _ {i}, \\mathcal {T} _ {k e y} (X) = \\sum_ {i \\in [ n ]} \\mathcal {L} _ {i} (X) \\cdot \\left(\\mathcal {T} _ {k e y}\\right) _ {i}.</span></div>

    <p class="text-gray-300">Prover Inputs: The prover  <span class="math">\\mathcal{P}</span>  takes as input the indexed relation  <span class="math">\\dot{\\mathbf{i}}</span> , the online public instance  <span class="math">\\mathbf{x} = (w_{i})_{i\\in [\\ell ]}</span> , and the online witness  <span class="math">\\mathbf{w} = (w_{i})_{i\\in [\\ell +1,6n]}</span> . (WLOG we assume  <span class="math">w_{6n} = 0</span> ,  <span class="math">(q_{K})_{n} = 0</span> .)</p>

    <p class="text-gray-300">Verifier Inputs: The verifier  <span class="math">\\mathcal{V}</span>  takes as input  <span class="math">\\mathbb{F}</span> , the online public instance  <span class="math">\\mathbf{x} = (w_{i})_{i\\in [\\ell ]}</span> , and the oracle access to polynomials the indexer generates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes the public input polynomial  <span class="math">\\mathsf{PI}(X) = \\sum_{i\\in [\\ell ]}\\mathcal{L}_i(X)\\cdot (w)_i</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes and sends  <span class="math">\\nu</span>  polynomials  <span class="math">f_{1}(X),\\ldots ,f_{6}(X)</span>  such that for every  <span class="math">i\\in [6],f_i(X)</span>  interpolates  <span class="math">(w_{(i - 1)n + 1},\\dots ,w_{in})</span>  over  <span class="math">H</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends  <span class="math">\\mathcal{P}</span>  a random challenge  <span class="math">\\tau \\in \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  computes the merged query polynomial:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {Q} ^ {*} (X) := f _ {6} (X) + \\tau \\cdot q _ {K} (X) \\cdot \\left(q _ {q r} (X) + \\tau \\cdot f _ {1} (X) + \\tau^ {2} \\cdot f _ {2} (X) + \\tau^ {3} \\cdot f _ {3} (X)\\right),</span></div>

    <p class="text-gray-300">and the merged lookup table polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {T} ^ {*} (X) := \\mathcal {T} _ {\\mathrm {r g}} (X) + \\tau \\cdot q _ {K} (X) \\cdot \\left(q _ {l i} (X) + \\tau \\cdot \\mathcal {T} _ {k e y} (X) + \\tau^ {2} \\cdot f _ {4} (X) + \\tau^ {3} \\cdot f _ {5} (X)\\right).</span></div>

    <p class="text-gray-300"><span class="math">(q^{<em>} = (\\mathcal{Q}^{</em>}(\\omega^{i}))_{i\\in [n]}</span>  is the merged query vector,  <span class="math">t^<em> = (\\mathcal{T}_</em>(\\omega^i))_{i\\in [n]}</span>  is the lookup table vector)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">s</span>  be the vector  <span class="math">(q^{<em>},t^{</em>})</span>  sorted by  <span class="math">t^*</span> . We represent  <span class="math">s</span>  by the vectors  <span class="math">h_1,h_2\\in \\mathbb{F}^n</span>  as follows:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">h _ {1} = \\left(s _ {1}, s _ {3}, \\dots , s _ {2 n - 1}\\right), \\quad h _ {2} = \\left(s _ {2}, s _ {4}, \\dots , s _ {2 n}\\right)</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  computes the sorted polynomial  <span class="math">h_1(X), h_2(X) \\in \\mathbb{F}^{&amp;lt;n}[X]</span>  and sends them to  <span class="math">\\mathcal{V}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">h _ {1} (X) = \\sum_ {i \\in [ n ]} s _ {2 i - 1} \\cdot \\mathcal {L} _ {i} (X), \\quad h _ {2} (X) = \\sum_ {i \\in [ n ]} s _ {2 i} \\cdot \\mathcal {L} _ {i} (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  sends random challenges  <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  computes Plonk permutation polynomial  <span class="math">z_{1}(X)</span>  and Plookup permutation polynomial  <span class="math">z_{2}(X)</span>  and sends to  <span class="math">\\nu</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z _ {1} (X) = \\mathcal {L} _ {1} (X) + \\sum_ {i = 1} ^ {n - 1} \\left(\\mathcal {L} _ {i + 1} (X) \\cdot \\prod_ {j = 1} ^ {i} \\prod_ {\\ell = 1} ^ {6} \\frac {w _ {(\\ell - 1) n + j} + \\beta k _ {\\ell} w ^ {j - 1} + \\gamma}{w _ {(\\ell - 1) n + j} + \\beta \\sigma^ {*} ((\\ell - 1) n + j) + \\gamma}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">z _ {2} (X) = \\mathcal {L} _ {1} (X) + \\sum_ {i = 1} ^ {n - 1} \\left(\\mathcal {L} _ {i + 1} (X) \\cdot \\prod_ {j = 1} ^ {i} \\frac {(1 + \\beta) (\\gamma + q _ {j} ^ {*}) (\\gamma (1 + \\beta) + t _ {j} ^ {*} + \\beta t _ {j + 1} ^ {*})}{(\\gamma (1 + \\beta) + s _ {2 j - 1} + \\beta s _ {2 j}) (\\gamma (1 + \\beta) + s _ {2 j} + \\beta s _ {2 j + 1})}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  computes a random challenge  <span class="math">\\alpha \\in \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  computes some intermediate polynomials:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {g a t e} (X) = q _ {1} (X) f _ {1} (X) + q _ {2} (X) f _ {2} (X) + q _ {3} (X) f _ {3} (X) + q _ {4} (X) f _ {4} (X) + q _ {M _ {1, 2}} (X) f _ {1} (X) f _ {2} (X) + q _ {M _ {3, 4}} (X) f _ {3} (X) f _ {4} (X) \\\\ + q _ {H _ {1}} (X) f _ {1} (X) ^ {5} + q _ {H _ {2}} (X) f _ {2} (X) ^ {5} + q _ {H _ {3}} (X) f _ {3} (X) ^ {5} + q _ {H _ {4}} (X) f _ {4} (X) ^ {5} + q _ {s c c} (X) f _ {1} (X) f _ {2} (X) f _ {3} (X) f _ {4} (X) f _ {5} (X) + q _ {C} (X) + \\mathsf {P I} (X) - q _ {O} (x) f _ {5} (X) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {z _ {1}, 1} = \\mathcal {L} _ {1} (X) \\cdot \\left(z _ {1} (X) - 1\\right), \\quad F _ {z _ {1}, 2} = z _ {1} (X) \\cdot \\left(\\prod_ {i = 1} ^ {6} f _ {i} (X) + \\beta S _ {\\mathrm {I D} i} (X) + \\gamma\\right) - z _ {1} (\\omega X) \\cdot \\left(\\prod_ {i = 1} ^ {6} f _ {i} (X) + \\beta S _ {\\sigma i} (X) + \\gamma\\right), \\quad F _ {z _ {2}, 1} = \\mathcal {L} _ {1} (X) \\cdot \\left(z _ {2} (X) - 1\\right) \\\\ F _ {z _ {2}, 2} = z _ {2} (X) \\cdot (1 + \\beta) (\\gamma + \\mathcal {Q} ^ {*} (X)) (\\gamma (1 + \\beta) + \\mathcal {T} ^ {*} (X) + \\beta \\mathcal {T} ^ {*} (X \\cdot \\omega)) - z _ {2} (\\omega X) \\cdot (\\gamma (1 + \\beta) + h _ {1} (X) + \\beta h _ {2} (X)) (\\gamma (1 + \\beta) + h _ {2} (X) + \\beta h _ {1} (X \\cdot \\omega)) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes polynomial</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F (X) := F _ {\\text {g a t e}} (X) + \\alpha F _ {z _ {1}, 1} (X) + \\alpha^ {2} F _ {z _ {1}, 2} (X) + \\alpha^ {3} F _ {z _ {2}, 1} (X) + \\alpha^ {4} F _ {z _ {2}, 2} (X)</span></div>

    <p class="text-gray-300">and sends  <span class="math">\\mathcal{V}</span>  the quotient polynomial  <span class="math">t(X)\\coloneqq \\frac{F(X)}{Z_H(X)}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  computes public input polynomial  <span class="math">\\mathsf{PI}(X)</span>  defined in online phase round 1.</li>

      <li><span class="math">\\mathcal{V}</span>  checks the polynomial identity</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F (X) \\stackrel {a} {=} t (X) Z _ {H} (X)</span></div>

    <p class="text-gray-300">where  <span class="math">F(X)</span>  is defined above in online phase round 4, and can be evaluated given oracle access to the indexer's preprocessed polynomials, polynomials sent by  <span class="math">\\mathcal{P}</span> , and the public input polynomial  <span class="math">\\mathsf{PI}(X)</span> .</p>

    <p class="text-gray-300">We note that the check is equivalent to checking  <span class="math">F(X) = 0, \\forall x \\in H</span> .</p>

    <p class="text-gray-300">Figure 11: A Polynomial IOP for the ULTRAPLONK constraint system</p>

    <p class="text-gray-300">and witnesses into MergePK, MergeVK, MergeWit to get  <span class="math">n_{\\mathrm{pf}}</span>  number of merged keys/witnesses. Subsequently, the user generates a batched inner predicate proof for all  <span class="math">2n_{\\mathrm{pf}}</span>  predicates via BatchProve whose correctness will be checked inside the outer circuit that embeds the logic in BatchPartialVfy. Finally, a ledger maintainer will check the outer proof and run Decide on the accumulator outputted by BatchPartialVfy to determine the validity of the transaction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs: security parameter  <span class="math">\\lambda</span> , and upper bound for merged-instance circuit  <span class="math">N = 2n</span>  (where  <span class="math">n</span>  is the size bound for a single instance)</li>

      <li>outputs: public parameter srs</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Setup of the [40] PCS to get srs :=  <span class="math">([1]_1, [x]_1, \\ldots, [x^{N+5}], [1]_2, [x]_2)</span> .</li>

    </ol>

    <p class="text-gray-300">Index(srs,  <span class="math">\\Phi ,b)\\to</span>  (ipk,ivk)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs:</li>

    </ul>

    <p class="text-gray-300">public parameter srs</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>predicate  <span class="math">\\Phi</span>  (whose circuit size is bounded by  <span class="math">n</span> )</li>

      <li>bit  <span class="math">b</span>  indicating whether  <span class="math">\\Phi</span>  is a birth or death predicate</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>outputs: circuit proving key ipk and verification key ivk</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute all selectors  <span class="math">\\mathcal{Q} \\in (\\mathbb{F}^n)^5</span>  and the wire permutation  <span class="math">\\sigma : [3n] \\mapsto [3n]</span>  from predicate  <span class="math">\\Phi</span>  (similar to the process in Appx. D.1).</li>

      <li>Find coset representatives  <span class="math">\\{k_1, k_2\\}</span>  such that  <span class="math">H, k_1H, k_2H \\subset \\mathbb{F}^*</span>  are non-overlapping cosets (similar to the process in Appx. D.2). Note  <span class="math">H = \\{1, \\omega, \\omega^2, \\dots, \\omega^N\\}</span>  is a multiplicative subgroup of size  <span class="math">N</span> .</li>

    </ol>

    <p class="text-gray-300">Derive  <span class="math">\\sigma^{*}</span>  as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ* [3n] → [3n] → [6n] / σ'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fσ' H ∪ k1H ∪ k2H</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">σ'(i) :=</td>

            <td class="px-3 py-2 border-b border-gray-700">σ(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 < σ(i) ≤ n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ(i) + n</td>

            <td class="px-3 py-2 border-b border-gray-700">n < σ(i) ≤ 2n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">σ(i) + 2n</td>

            <td class="px-3 py-2 border-b border-gray-700">2n < σ(i) ≤ 3n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">fσ'(i) :=</td>

            <td class="px-3 py-2 border-b border-gray-700">ωi</td>

            <td class="px-3 py-2 border-b border-gray-700">0 < σ'(i) ≤ N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">k1 · ωi</td>

            <td class="px-3 py-2 border-b border-gray-700">N < σ'(i) ≤ 2N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">k2 · ωi</td>

            <td class="px-3 py-2 border-b border-gray-700">2N < σ'(i) ≤ 3N</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">b = 0</span></li>

    </ol>

    <p class="text-gray-300">|  qL(X) = ∑i=1n (qL)i · Li(X)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  qR(X) = ∑i=1n (qR)i · Li(X)  |</p>

    <p class="text-gray-300">|  qO(X) = ∑i=1n (qO)i · Li(X)  |</p>

    <p class="text-gray-300">|  qM(X) = ∑i=1n (qM)i · Li(X)  |</p>

    <p class="text-gray-300">|  qC(X) = ∑i=1n (qC)i · Li(X)  |</p>

    <p class="text-gray-300">|  qC(X) = ∑i=1n (qC)i · Li(X)  |</p>

    <p class="text-gray-300">|  Sσ1(X) = ∑i=1n σ*(i) · Li(X)  |</p>

    <p class="text-gray-300">|  Sσ2(X) = ∑i=1n σ*(n+i) · Li(X)  |</p>

    <p class="text-gray-300">|  Sσ3(X) = ∑i=1n σ*(2n+i) · Li(X)  |</p>

    <p class="text-gray-300">If  <span class="math">b = 1</span></p>

    <p class="text-gray-300">|  qL(X) = ∑i=1n (qL)i · Ln+i(X)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  qR(X) = ∑i=1n (qR)i · Ln+i(X)  |</p>

    <p class="text-gray-300">|  qO(X) = ∑i=1n (qO)i · Ln+i(X)  |</p>

    <p class="text-gray-300">|  qM(X) = ∑i=1n (qM)i · Ln+i(X)  |</p>

    <p class="text-gray-300">|  qC(X) = ∑i=1n (qC)i · Ln+i(X)  |</p>

    <p class="text-gray-300">|  Sσ1(X) = ∑i=1n (σ*(i) + n) · Ln+i(X)  |</p>

    <p class="text-gray-300">|  Sσ2(X) = ∑i=1n (σ*(n+i) + n) · Ln+i(X)  |</p>

    <p class="text-gray-300">|  Sσ3(X) = ∑i=1n (σ*(2n+i) + n) · Ln+i(X)  |</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output proving key:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ipk} \\coloneqq (q_L(X), q_R(X), q_O(X), q_M(X), q_C(X), S_{\\sigma 1}(X), S_{\\sigma 2}(X), S_{\\sigma 3}(X))</span></p>

    <p class="text-gray-300">and verification key:</p>

    <p class="text-gray-300">ivk :=  <span class="math">([q_L]_1, [q_R]_1, [q_O]_1, [q_M]_1, [q_C]_1, [S_{\\sigma 1}]_1, [S_{\\sigma 2}]_1, [S_{\\sigma 3}]_1)</span></p>

    <p class="text-gray-300">MergePK(ipk  <span class="math">b</span>  ,ipk  <span class="math">d</span>  )  <span class="math">\\rightarrow</span>  ipk</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs: a birth predicate proving key  <span class="math">\\mathrm{ipk}_b</span>  and a death predicate proving key  <span class="math">\\mathrm{ipk}_d</span> .</li>

      <li>outputs: a merged proving key  <span class="math">\\mathrm{ipk}_{\\oplus}</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse two input proving keys:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ipk}_b\\coloneqq \\left(q_L^b (X),q_R^b (X),q_O^b (X),q_M^b (X),q_C^b (X),S_{\\sigma 1}^b (X),S_{\\sigma 2}^b (X),S_{\\sigma 3}^b (X)\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{ipk}_d\\coloneqq \\left(q_L^d (X),q_R^d (X),q_O^d (X),q_M^d (X),q_C^d (X),S_{\\sigma 1}^d (X),S_{\\sigma 2}^d (X),S_{\\sigma 3}^d (X)\\right)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Homomorphically add each element in the two verification keys:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">q _ {L} ^ {\\oplus} (X) = q _ {L} ^ {b} (X) + q _ {L} ^ {d} (X), \\dots , S _ {\\sigma 3} ^ {\\oplus} (X) = S _ {\\sigma 3} ^ {b} (X) + S _ {\\sigma 3} ^ {d} (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the merged verification key:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ipk}_{\\oplus}\\coloneqq \\left(\\begin{array}{c}q_{L}^{\\oplus}(X),q_{R}^{\\oplus}(X),q_{O}^{\\oplus}(X),q_{M}^{\\oplus}(X),q_{C}^{\\oplus}(X),\\\\S_{\\sigma 1}^{\\oplus}(X),S_{\\sigma 2}^{\\oplus}(X),S_{\\sigma 3}^{\\oplus}(X)\\end{array}\\right)</span></p>

    <p class="text-gray-300">MergeVK(ivk  <span class="math">b</span>  ,ivk  <span class="math">d</span>  )  <span class="math">\\rightarrow</span>  ivk</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs: a birth predicate verification key  <span class="math">\\mathrm{ivk}_b</span>  and a death predicate verification key  <span class="math">\\mathrm{ivk}_d</span> .</li>

      <li>outputs: a merged verification key  <span class="math">\\mathrm{ivk}_{\\oplus}</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse two input verification keys:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ivk}_b\\coloneqq \\left([q_L^b ]_1,[q_R^b ]_1,[q_O^b ]_1,[q_C^b ]_1,[S_{\\sigma 1}^b ]_1,[S_{\\sigma 2}^b ]_1,[S_{\\sigma 3}^b ]_1\\right)</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{ivk}_d\\coloneqq \\left([q_L^d ]_1,[q_R^d ]_1,[q_O^d ]_1,[q_M^d ]_1,[q_C^d ]_1,[S_{\\sigma 1}^d ]_1,[S_{\\sigma 2}^d ]_1,[S_{\\sigma 3}^d ]_1\\right)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Homomorphically add each element in the two proving keys:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">[ q _ {L} ^ {\\oplus} ] _ {1} = [ q _ {L} ^ {b} ] _ {1} + [ q _ {L} ^ {d} ] _ {1}, \\dots , [ S _ {\\sigma 3} ^ {\\oplus} ] _ {1} = [ S _ {\\sigma 3} ^ {b} ] _ {1} + [ S _ {\\sigma 3} ^ {d} ] _ {1}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the merged proving key:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{ivk}_{\\oplus}\\coloneqq \\left([q_L^{\\oplus}]_1,[q_R^{\\oplus}]_1,[q_O^{\\oplus}]_1,[q_C^{\\oplus}]_1,[S_{\\sigma 1}^{\\oplus}]_1,[S_{\\sigma 2}^{\\oplus}]_1,[S_{\\sigma 3}^{\\oplus}]_1\\right)</span></p>

    <p class="text-gray-300">MergeWit  <span class="math">(\\mathrm{w}_b,\\mathrm{w}_d)\\to \\mathrm{w}_{\\oplus}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs: birth predicate witness  <span class="math">\\mathbb{W}_b</span>  and death predicate witness  <span class="math">\\mathbb{W}_d</span></li>

      <li>outputs: merged witness  <span class="math">\\mathbb{W}_{\\oplus}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse birth and death witness  <span class="math">\\in \\mathbb{F}^{3n}</span>  (witness from the indexed relation is transformed as in Appx. D.1 first):</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {W} _ {b} = \\left(w _ {b, 1}, \\dots , w _ {b, 3 n}\\right), \\quad \\mathbb {W} _ {d} = \\left(w _ {d, 1}, \\dots , w _ {d, 3 n}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs merged witness  <span class="math">\\in \\mathbb{F}^{3N}</span>  where  <span class="math">N = 2n</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {W} _ {\\oplus} = \\left( \\begin{array}{c} w _ {b, 1}, \\ldots , w _ {b, n}, w _ {d, 1}, \\ldots , w _ {d, n}, \\\\ w _ {b, n + 1}, \\ldots , w _ {b, 2 n}, w _ {d, n + 1}, \\ldots , w _ {d, 2 n}, \\\\ w _ {b, 2 n + 1}, \\ldots , w _ {b, 3 n}, w _ {d, 2 n + 1}, \\ldots , w _ {d, 3 n} \\end{array} \\right)</span></div>

    <p class="text-gray-300">where the merged public instance is  <span class="math">\\mathbb{x}_{\\oplus} = (w_{b,1},\\ldots ,w_{b,\\ell},w_{d,1},\\ldots ,w_{d,\\ell})</span></p>

    <p class="text-gray-300">BatchProve(srs,  <span class="math">[\\mathbb{x}_{\\oplus ,i}]_{i = 1}^{n_{\\mathrm{pf}}},[\\mathbb{w}_{\\oplus ,i}]_{i = 1}^{n_{\\mathrm{pf}}},[\\mathrm{ipk}_{\\oplus ,i}]_{i = 1}^{n_{\\mathrm{pf}}})\\to \\pi_{\\odot}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public parameter srs</li>

      <li>list of merged instances, merged witnesses, and merged proving keys</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left[\\mathbb{x}_{\\oplus ,i}\\right]_{i = 1}^{n_{\\mathrm{pf}}}, \\left[\\mathbb{w}_{\\oplus ,i}\\right]_{i = 1}^{n_{\\mathrm{pf}}}, \\left[\\mathrm{ipk}_{\\oplus ,i}\\right]_{i = 1}^{n_{\\mathrm{pf}}}</span>  where  <span class="math">n_{\\mathrm{pf}}</span>  denotes the number of instances to be proven.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>outputs: a batched proof  <span class="math">\\pi_{\\odot}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [n_{\\mathrm{pf}}]</span> , compute wire polynomials  <span class="math">a_i(X), b_i(X), c_i(X)</span>  as in Round 1 of [31] <span class="math">^{18}</span> , and outputs  <span class="math">([a_i]_1, [b_i]_1, [c_i]_1)_{i \\in [n_{\\mathrm{pf}}]}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute permutation challenge  <span class="math">\\beta = H(\\text{transcript}, 0), \\gamma = H(\\text{transcript}, 1)</span> .</li>

      <li>For each  <span class="math">i \\in [n_{\\mathrm{pf}}]</span> , compute permutation polynomials  <span class="math">z_i(X)</span>  as in Round 2 of [31], and outputs  <span class="math">([z_i]_1)_{i \\in [n_{\\mathrm{pf}}]}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute quotient challenge  <span class="math">\\alpha = H(\\text{transcript})</span> .</li>

      <li>For each  <span class="math">i \\in [n_{\\mathrm{pf}}]</span> ,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse merged instance  <span class="math">\\mathbb{x}_{\\oplus ,i} = (x_i)_{i\\in [2\\ell ]}</span> , compute public input polynomial:  <span class="math">\\mathsf{Pl}_i(X) = \\sum_{i = 1}^{\\ell}(x_i\\cdot \\mathcal{L}_i(X) + x_{i + \\ell}\\cdot \\mathcal{L}_{n + i}(X))</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the following intermediate polynomials:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {\\text {g a t e}, i} (X) = a _ {i} (X) q _ {L} ^ {i} (X) + b _ {i} (X) q _ {R} ^ {i} (X) \\\\ + a _ {i} (X) b _ {i} (X) q _ {M} ^ {i} (X) + \\mathrm {P l} _ {i} (X) - c _ {i} (X) q _ {D} ^ {i} (X) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {\\sigma 1, i} (X) = \\left(a _ {i} (X) + \\beta X + \\gamma\\right) \\left(b _ {i} (X) + \\beta k _ {1} X + \\gamma\\right) \\\\ \\times \\left(c _ {i} (X) + \\beta k _ {2} X + \\gamma\\right) \\cdot z _ {i} (X) \\\\ - \\left(a _ {i} (X) + \\beta S _ {\\sigma 1} ^ {i} (X) + \\gamma\\right) \\left(b _ {i} (X) + \\beta S _ {\\sigma 2} ^ {i} (X) + \\gamma\\right) \\\\ \\times \\left(c _ {i} (X) + \\beta S _ {\\sigma 3} ^ {i} (X) + \\gamma\\right) \\cdot z _ {i} (\\omega X) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {\\sigma 2, i} (X) = \\left(z _ {i} (X) - 1\\right) \\cdot \\mathcal {L} _ {1} (X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Compute the batched quotient polynomial (note  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= N = 2n$ ):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t (X) = Z _ {H} ^ {- 1} (X) \\times \\\\ \\left(\\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} \\alpha^ {3 i - 3} \\left(F _ {\\text {g a t e}, i} (X) + \\alpha F _ {\\sigma 1, i} (X) + \\alpha^ {2} F _ {\\sigma 2, i} (X)\\right)\\right) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Split  <span class="math">t(X)</span>  into  <span class="math">t_1(X), t_2(X), t_3(X)</span>  as in Round 3 of [31], and outputs  <span class="math">([t_1]_1, [t_2]_1, [t_3]_1)</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute evaluation challenge  <span class="math">\\mathfrak{z} = H(\\text{transcript})</span> .</li>

      <li>For each  <span class="math">i \\in [n_{\\mathrm{pf}}]</span> , compute and output opening evaluations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\bar {a} _ {i} = a _ {i} (\\mathfrak {z}), \\bar {b} _ {i} = b _ {i} (\\mathfrak {z}), \\bar {c} _ {i} = c _ {i} (\\mathfrak {z}) \\\\ \\bar {s} _ {\\sigma_ {1}, i} = S _ {\\sigma 1} ^ {i} (\\mathfrak {z}), \\bar {s} _ {\\sigma_ {2}, i} = S _ {\\sigma 2} ^ {i} (\\mathfrak {z}), \\bar {z} _ {\\omega , i} = z _ {i} (\\mathfrak {z} \\omega) \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening challenge  <span class="math">\\nu = H(\\text{transcript})</span> .</li>

      <li>For each  <span class="math">i \\in [n_{\\mathrm{pf}}]</span> , compute the following intermediate polynomials:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Numerator polynomial of the quotient polynomial:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} r _ {i} (X) = \\bar {a} _ {i} q _ {L} ^ {i} (X) + \\bar {b} _ {i} q _ {R} ^ {i} (X) + \\bar {a} _ {i} \\bar {b} _ {i} q _ {M} ^ {i} (X) \\\\ + q _ {C} ^ {i} (X) + \\mathrm {P l} (\\mathfrak {z}) - \\bar {c} _ {i} q _ {D} ^ {i} (X) \\\\ + \\alpha \\cdot \\left[ (\\bar {a} _ {i} + \\beta \\mathfrak {z} + \\gamma) (\\bar {b} _ {i} + \\beta k _ {1} \\mathfrak {z} + \\gamma) (\\bar {c} _ {i} + \\beta k _ {2} \\mathfrak {z} + \\gamma) \\cdot z _ {i} (X) \\right. \\\\ - \\left(\\bar {a} _ {i} + \\beta \\bar {s} _ {\\sigma_ {1}, i} + \\gamma\\right) \\left(\\bar {b} _ {i} + \\beta \\bar {s} _ {\\sigma_ {2}, i} + \\gamma\\right) \\left(\\bar {a} _ {i} + \\beta \\bar {s} _ {\\sigma_ {3}, i} + \\gamma\\right) \\cdot \\bar {z} _ {\\omega , i} ] \\\\ + \\alpha^ {2} \\cdot \\left[ \\left(z _ {i} (X) - 1\\right) \\mathcal {L} _ {1} (\\mathfrak {z}) \\right] \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomials evaluated at evaluation point  <span class="math">\\mathfrak{z}</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">g _ {\\mathfrak {z}, i} (X) = \\left( \\begin{array}{l} v \\cdot (a _ {i} (X) - \\bar {a} _ {i}) \\\\ + v ^ {2} \\cdot (b _ {i} (X) - \\bar {b} _ {i}) \\\\ + v ^ {3} \\cdot (c _ {i} (X) - \\bar {c} _ {i}) \\\\ + v ^ {4} \\cdot (S _ {\\sigma 1} ^ {i} (X) - \\bar {s} _ {\\sigma_ {1}, i}) \\\\ + v ^ {5} \\cdot (S _ {\\sigma 2} ^ {i} (X) - \\bar {s} _ {\\sigma_ {2}, i}) \\end{array} \\right)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial(s) evaluated at evaluation point  <span class="math">\\mathfrak{z}\\omega</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">g _ {\\mathfrak {z} \\omega , i} (X) = z _ {i} (X) - \\bar {z} _ {\\omega , i}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the batched linearization polynomial:</li>

    </ul>

    <p class="text-gray-300">$$ \\begin{array}{l} r (X) = \\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} \\alpha^ {3 i - 3} \\cdot r _ {i} (X) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Z _ {H} (\\mathfrak {z}) \\cdot \\left(t _ {1} (X) + \\mathfrak {z} ^ {N} t _ {2} (X) + \\mathfrak {z} ^ {2 N} t _ {3} (X)\\right)</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the batched opening proof polynomials:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} W _ {\\mathfrak {z}} (X) = \\frac {r (X) + \\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} v ^ {6 i - 6} \\cdot g _ {\\mathfrak {z} , i}}{X - \\mathfrak {z}} \\\\ W _ {\\mathfrak {z} \\omega} (X) = \\frac {\\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} v ^ {i - 1} \\cdot g _ {\\mathfrak {z} \\omega , i}}{X - \\mathfrak {z} \\omega} \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs their commitments: <span class="math">[W_{\\mathfrak{z}}]_1, [W_{\\mathfrak{z}\\omega}]_1</span>.</li>

    </ul>

    <h2 id="sec-60" class="text-2xl font-bold">Final Round:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute multi-point evaluation challenge <span class="math">u = H(\\text{transcript})</span>.</li>

      <li>For each <span class="math">i \\in [n_{\\mathrm{pf}}]</span>, define: <span class="math">\\pi_i = ([a_i]_1, [b_i]_1, [c_i]_1, [z_i]_1, \\bar{a}_i, \\bar{b}_i, \\bar{c}_i, \\bar{s}_{\\sigma_1,i}, \\bar{s}_{\\sigma_2,i}, \\bar{z}_{\\omega,i})</span>, outputs batched proof:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\circledast} := \\left([ t _ {1} ] _ {1}, [ t _ {1} ] _ {2}, [ t _ {3} ] _ {1}, [ W _ {\\mathfrak {z}} ] _ {1}, [ W _ {\\mathfrak {z} \\omega} ] _ {1}, [ \\pi_ {i} ] _ {i \\in [ n _ {\\mathrm {p f}} ]}\\right).</span></div>

    <p class="text-gray-300">Remark 4. Since we only use Plonk' for the inner predicate proofs, we don't need it to be zero-knowledge, as long as the SNARK proof for the outer circuit is zero-knowledge, then we would satisfy the function privacy of ZEXE. Specifically, we don't need random blinding scalars for wire polynomials in Round 1 and permutation polynomials in Round 2 as in [31]. BatchPartialVfy(srs, <span class="math">[\\Xi_{\\odot,i}]_{i=1}^{n_{\\mathrm{pf}}}, [\\mathrm{ivk}_{\\odot,i}]_{i=1}^{n_{\\mathrm{pf}}}, \\pi_{\\odot}, s) \\to \\xi</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>public parameter srs</li>

      <li>list of merged instances, merged verification keys <span class="math">[\\Xi_{\\odot,i}]_{i=1}^{n_{\\mathrm{pf}}}, [\\mathrm{ivk}_{\\odot,i}]_{i=1}^{n_{\\mathrm{pf}}}</span></li>

      <li>the batched proof for all relations <span class="math">\\pi_{\\odot}</span></li>

      <li>masking randomness <span class="math">s \\in \\mathbb{F}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>outputs: an accumulator <span class="math">\\xi</span> containing two group elements to be checked in a pairing equation in Decider in the accumulation scheme.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validate all field elements and group elements in <span class="math">\\pi_{\\odot}</span>.</li>

      <li>Compute challenges <span class="math">\\alpha, \\beta, \\gamma, \\mathfrak{z}, v, u \\in \\mathbb{F}</span> as in the BatchProve from the common inputs, public inputs, and elements of <span class="math">\\pi_{\\odot}</span>.</li>

      <li>Compute:</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} [A ] _ {1} = [ W _ {\\mathfrak {z}} ] _ {1} + u [ W _ {\\mathfrak {z} \\omega} ] _ {1} \\\\ [ B ] _ {1} = \\mathfrak {z} [ W _ {\\mathfrak {z}} ] _ {1} + u _ {\\mathfrak {z}} \\omega [ W _ {\\mathfrak {z} \\omega} ] _ {1} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\underbrace {\\left[ r (X) + \\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} v ^ {6 i - 6} g _ {\\mathfrak {z} , i} (X) \\right] _ {1}} _ {1} + u \\left[ \\sum_ {i = 1} ^ {n _ {\\mathrm {p f}}} v ^ {i - 1} g _ {\\mathfrak {z} \\omega , i} (X) \\right] _ {1}</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mask both elements for hiding property:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">[ \\bar {A} ] _ {1} = [ A ] _ {1} + s [ x ] _ {1}, \\quad [ \\bar {B} ] _ {1} = [ B ] _ {1} + s [ 1 ] _ {1}</span></div>

    <p class="text-gray-300">where <span class="math">[x]_1, [1]_1</span> are in srs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs <span class="math">\\xi := \\left([\\bar{A}]_1, [\\bar{B}]_1\\right)</span>.</li>

    </ol>

    <p class="text-gray-300">Decide(srs, <span class="math">\\xi</span>) <span class="math">\\rightarrow</span> b</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs: public parameter srs and the accumulator (partial verification state) <span class="math">\\xi</span></li>

      <li>outputs: accept or reject bit <span class="math">b \\in \\{0,1\\}</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\xi := \\left([\\bar{A}]_1, [\\bar{B}]_1\\right)</span>, get <span class="math">[1]_2, [x]_2</span> from srs.</li>

      <li>Check <span class="math">e([\\bar{A}]_1, [1]_2) \\stackrel{?}{=} e([\\bar{B}]_1, [x]_2)</span>, if equal output <span class="math">b = 1</span>; output <span class="math">b = 0</span> otherwise.</li>

    </ol>

    <h2 id="sec-61" class="text-2xl font-bold">F Modular Arithmetic Gadgets: Security Proof</h2>

    <p class="text-gray-300">We proceed to provide detailed proof of the security properties of our modular arithmetic gadgets. Given a set of relevant public parameters (and prerequisite assumption about them), a circuit design (w.r.t. a relation) has completeness when for any inputs and their valid witnesses, the circuit should always be satisfied; soundness when for any inputs and invalid witnesses, the circuit should never be satisfied.</p>

    <p class="text-gray-300">Proof for Proposition 1. Soundness is straightforward since any invalid witnesses <span class="math">w_0, w_1, z_0, z_1 \\in \\mathbb{F}_q</span>, either they are out of bound <span class="math">\\in [2^m, q)</span> thus failed the first range check in the gadget, or they are values <span class="math">\\in [0, 2^m)</span> that breaks the equation 1 and by violating any one of equation 1b,1c,1d, the corresponding steps in the gadget will fail.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (x _ {0} + 2 ^ {m} \\cdot x _ {1}) \\cdot (y _ {0} + 2 ^ {m} \\cdot y _ {1}) \\quad (1) \\\\ = z _ {0} + 2 ^ {m} \\cdot z _ {1} + \\left(w _ {0} + 2 ^ {m} \\cdot w _ {1}\\right) \\cdot \\left(p _ {0} + 2 ^ {m} \\cdot p _ {1}\\right) \\quad (1a) \\\\ \\oplus \\\\ \\left\\{ \\begin{array}{l} z _ {0} + w _ {0} \\cdot p _ {0} - x _ {0} \\cdot y _ {0} - 2 ^ {m} \\cdot c _ {0} ^ {\\prime} = 0 \\quad (1b) \\\\ z _ {1} + w _ {0} \\cdot p _ {1} + w _ {1} \\cdot p _ {0} - x _ {0} \\cdot y _ {1} - x _ {1} \\cdot y _ {0} + c _ {0} ^ {\\prime} - 2 ^ {m} \\cdot c _ {1} ^ {\\prime} = 0 \\quad (1c) \\\\ w _ {1} \\cdot p _ {1} - x _ {1} \\cdot y _ {1} + c _ {1} ^ {\\prime} = 0 \\quad (1d) \\end{array} \\right. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">For completeness, we need to further argue that (i) calculations within the circuit won't overflow or underflow <span class="math">\\mathbb{F}_q</span> at all steps; and (ii) there exists at least one witness for any possible inputs.</p>

    <p class="text-gray-300">To see why (i) is true (with honest provers who follow the protocol and prepare witnesses and intermediate values like carriers <span class="math">c_0, c_1</span> properly):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In step 2, LHS is <span class="math">z_0 + w_0 \\cdot p_0 \\in [0, 2^m + 2^{2m}]</span>; RHS is <span class="math">x_0 \\cdot y_0 + 2^m \\cdot (c_0 - 2^m) \\in [0, 2^{2m} + 2^m \\cdot (2^{m+k} - 2^m)) \\in [0, 2^{2m+k})</span>. Since <span class="math">q &amp;gt; 2^{2m+k+1}</span>, both LHS and RHS won't overflow. Note that RHS <span class="math">\\geq 0</span> because <span class="math">c_0&#x27; \\geq -2^m</span> and <span class="math">c_0 = c_0&#x27; + 2^m</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In step 3, LHS is  <span class="math">z_{1} + w_{0} \\cdot p_{1} + w_{1} \\cdot p_{0} + (c_{0} - 2^{m}) \\in [0, 2^{m} + 2^{2m} \\cdot 2 + 2^{m+k} - 2^{m}) \\in [0, 2^{2m+1} + 2^{m+k})</span> ; RHS is  <span class="math">x_{0} \\cdot y_{1} + x_{1} \\cdot y_{0} + 2^{m} \\cdot (c_{1} - 2^{m+1}) \\in [0, 2^{2m} \\cdot 2 + 2^{m} \\cdot 2^{m+2}) \\in [0, 2^{2m+3})</span> . Since  <span class="math">q &amp;gt; 2^{2m+k+1} \\wedge K \\leq 3</span> , both LHS and RHS won't overflow.</li>

      <li>In step 4, LHS is  <span class="math">w_{1} \\cdot p_{1} + (c_{1} - 2^{m + 1}) \\in [0,2^{2m} + 2^{m + 2}) \\in [0,2^{2m + 1})</span> ; RHS is  <span class="math">x_{1} \\cdot y_{1} \\in [0,2^{2m})</span> . Clearly both sides won't overflow.</li>

    </ul>

    <p class="text-gray-300">To see why (ii) is true, we emphasize that inputs  <span class="math">x, y</span>  are assumed to be the canonical representation of  <span class="math">\\mathbb{F}_p</span>  (namely,  <span class="math">x, y \\in [0, p)</span> ). Since for  <span class="math">x \\cdot y = z + p \\cdot w</span>  (the actual relation is expressed limb-wise),  <span class="math">x \\cdot y \\in [0, p^2)</span>  and  <span class="math">p \\cdot w \\in [0, p \\cdot 2^{2m})</span> , given that  <span class="math">2^{2m} &amp;gt; p</span> , we know ensure existence of at least one  <span class="math">w \\in [0, 2^{2m})</span>  for any inputs  <span class="math">x, y</span> .</p>

    <p class="text-gray-300">Proof for Proposition 2. For soundness, it is straightforward, invalid witnesses  <span class="math">w, y</span>  are either out of proper range and failed the range check in the first step of the circuit, or they are in range but violate the relation  <span class="math">y + p \\cdot w = x_1 + \\ldots + x_N</span>  which will failed the second step.</p>

    <p class="text-gray-300">For completeness, we need to further argue that (i) calculations within the circuit won't overflow or underflow  <span class="math">\\mathbb{F}_q</span>  at all steps; and (ii) there exists at least one witness for any possible inputs.</p>

    <p class="text-gray-300">To see why (i) is true: given  <span class="math">N &amp;lt; \\frac{K - 1}{c} + 1, c \\cdot p \\geq 2^{2m} \\geq p, \\frac{q}{p} &amp;gt; c + K</span>  in step 2,</p>

    <p class="text-gray-300">LHS is  <span class="math">0 \\leq y + p \\cdot w &amp;lt; 2^{2m} + 2^{2m} \\cdot K &amp;lt; 2^{2m + k + 1}</span> ;</p>

    <p class="text-gray-300">RHS is  <span class="math">0 \\leq x_{1} + \\ldots + x_{N} &amp;lt; N \\cdot 2^{2m}) &amp;lt; \\left(\\frac{K}{c} + 1\\right) \\cdot 2^{2m} &amp;lt; \\left(\\frac{K}{c} + 1\\right) \\cdot c \\cdot p &amp;lt; (K + c) \\cdot p &amp;lt; q</span> . We can see both sides won't overflow  <span class="math">\\mathbb{F}_{q}</span> .</p>

    <p class="text-gray-300">To see why (ii) is true: since the tight upper bound of LHS is bigger than a loose upper bound of RHS:</p>

    <p class="text-gray-300"><span class="math">2^{2m} + K\\cdot p\\geq (K + c - 1)\\cdot p</span></p>

    <p class="text-gray-300"><span class="math">&amp;gt;(\\frac{K - 1}{c} +1)\\cdot cp &amp;gt; (\\frac{K - 1}{c} +1)\\cdot 2^{2m} &amp;gt; N\\cdot 2^{2m}</span></p>

    <p class="text-gray-300">there must exists some witnesses  <span class="math">w, y</span>  for any inputs.</p>

    <p class="text-gray-300">For efficiency reason, we split  <span class="math">\\mathcal{R}_e</span>  into two relations: an extended UTXO relation  <span class="math">\\mathcal{R}_{\\mathrm{utxo}}</span>  that checks the well-formedness of input and output records among other things, and a predicates satisfiability relation  <span class="math">\\mathcal{R}_{\\Phi}</span>  that checks inner proofs for death/birth predicates of the input/output records. The circuit for  <span class="math">\\mathcal{R}_{\\Phi}</span>  takes a list of inner proofs and their corresponding verification keys as secret witnesses and checks their validity. To ensure that death/birth predicates involved in  <span class="math">\\mathcal{R}_{\\mathrm{utxo}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span>  are consistent, [14] proposes to make the hiding commitment  <span class="math">\\mathrm{cm}_{\\Phi}</span>  to the predicates in a transaction as a public input for both circuits so that the verifier can check their equality (see</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 12: Relation snippet for predicate commitment in [14].</p>

    <p class="text-gray-300">Fig. 12). Furthermore, the authors suggest committing to the collision-resistant hashes of the predicate verification keys instead, to reduce the cost of computing  <span class="math">\\mathsf{cm}_{\\Phi}</span>  in the circuit.</p>

    <p class="text-gray-300">Concretely, the original ZEXE instantiates CRH with Pedersen hash, COM with Blake2s hash where the message is appended with a randomizer for the hiding property. The primary circuit cost comes from constraining non-algebraic Blake2s hash on a message size of  <span class="math">m + n + 1</span>  for an  <span class="math">m</span> -input- <span class="math">n</span> -output transaction. We emphasize that directly switching Blake2s to a SNARK-friendly hash is not immediately more advantageous, since we need to constrain this hash function in two different fields (over  <span class="math">\\mathbb{F}_r</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{utxo}}</span>  and over  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">\\mathcal{R}_{\\Phi}</span> ), and constraining algebraic hashes over non-native fields is probably more expensive as it requires many range checks and modular arithmetics. Worse, the number of non-native operations grows linearly with the message size since longer messages require more invocations of the hash function.</p>

    <p class="text-gray-300">We present an optimized circuit in Fig. 13. The high-level idea is to encode the list of predicate hashes/identifiers as the coefficients of a univariate polynomial and commit to these predicates by evaluating this polynomial at a binding point.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{HCOM}_1:\\mathbb{F}_r^{m + n}\\mapsto \\mathbb{F}_r,\\mathsf{HCOM}_2:\\mathbb{F}_p^{m + n}\\mapsto \\mathbb{F}_r</span>  be two hash-based commitment scheme with different message spaces but the same digest space. In practice, we can instantiate  <span class="math">\\mathsf{HCOM}_1,\\mathsf{HCOM}_2,\\mathsf{COM}</span>  with SNARK-friendly, hash</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 13: Relation snippet for optimized predicate commitment.</p>

    <p class="text-gray-300">based commitments, and use modular arithmetic gadgets introduced in § 3.5 during step 4 of the predicate commitment circuit in  <span class="math">\\mathcal{R}_{\\Phi}</span> .</p>

    <p class="text-gray-300">Remark 5. Compared to the naive solution of directly switching Blake2s to a SNARK-friendly hash, the main efficiency of our design in Fig. 13 comes from the fact that our non-native operations do not grow with message size (number of predicates committed). Because  <span class="math">\\mathrm{HCOM}_1</span> ,  <span class="math">\\mathrm{HCOM}_2</span>  computations, used to bind all predicate identifiers and whose costs increase linearly with the input message size, are over the native field of their respective circuits and involve no modular arithmetics; whereas the only step involving non-native operations (the COM. Commit in  <span class="math">\\mathcal{R}_{\\Phi}</span>  circuit) enjoys a fixed-size input, thus fixed cost, regardless of the number of predicates to be committed.</p>

    <p class="text-gray-300">Proposition 3. Assuming  <span class="math">\\mathrm{HCOM}_1, \\mathrm{HCOM}_2</span>  are random oracles, COM is a hiding commitment scheme, then the circuits in Fig. 13 ensure that the list of predicates being used in two circuits are consistent with overwhelming probability w.r.t.</p>

    <p class="text-gray-300">the randomly sampled binding factors  <span class="math">r_{\\Phi,1} \\in \\mathbb{F}_r, r_{\\Phi,2} \\in \\mathbb{F}_p</span> , and the predicate commitment randomness  <span class="math">r_{\\Phi} \\in \\mathbb{F}_r</span> , and that  <span class="math">\\mathrm{cm}_{\\Phi}, c_1, c_2</span>  reveals nothing about the predicates involved.</p>

    <p class="text-gray-300">informal proof. Since  <span class="math">\\mathsf{cm}_{\\Phi}, c_1, c_2</span>  are public inputs, we know  <span class="math">\\mathsf{cm}_{\\Phi}, c = c_1 + c_2</span>  are guaranteed to be equal across two circuits. If  <span class="math">\\mathcal{R}_{\\mathrm{utxo}}</span>  and  <span class="math">\\mathcal{R}_{\\Phi}</span>  commit to two different lists of predicates, then the two polynomials would be different:  <span class="math">p_{\\mathrm{utxo}}(X) \\neq p_{\\Phi}</span> . Given  <span class="math">\\mathsf{cm}_{\\Phi} = \\mathsf{COM}.Commit(\\mathsf{pp}_{\\mathsf{COM}}, p_{\\mathsf{utxo}}(c); r_{\\Phi}) = \\mathsf{COM}.Commit(\\mathsf{pp}_{\\mathsf{COM}}, p_{\\Phi}(c); r_{\\Phi})</span> , there are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p_{\\mathrm{utxo}}(c) \\neq p_{\\Phi}(c)</span> : this means we open  <span class="math">\\mathsf{cm}_{\\Phi}</span>  to two different messages which break the computational binding property of COM.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">p_{\\mathrm{utxo}}(c) = p_{\\Phi}(c)</span> : two different polynomials  <span class="math">\\in \\mathbb{F}_r^{&amp;lt;m+n-1}</span>  only evaluate to the same value at the same random point  <span class="math">c</span>  (generated from random oracles) with negligible probability of  $\\frac{m+n-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  based on the Schwartz-Zippel lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, we can conclude that the predicates are consistent across these two relations with overwhelming probability.</p>

    <p class="text-gray-300">Furthermore, since COM is hiding,  <span class="math">\\mathrm{HCOM}_1, \\mathrm{HCOM}_2</span>  are random oracles, with randomly sampled randomnesses  <span class="math">r_{\\Phi,1}, r_{\\Phi,2}, r_{\\Phi}</span> , we know that  <span class="math">\\mathrm{cm}_{\\Phi}, c_1, c_2</span>  reveals nothing about their committed messages.</p>

    <p class="text-gray-300">Elliptic Curves. We use two pairing-friendly elliptic curves  <span class="math">E_{\\mathrm{BLS}}, E_{\\mathrm{BW}}</span>  in a similar fashion as [14] to support one layer of proof composition, and one twisted edwards curve  <span class="math">E_{\\mathrm{Ed/BLS}}</span>  whose base field matches the prime order subgroup of  <span class="math">E_{\\mathrm{BLS}}</span> . Inner proofs are generated over the BLS12-377 curve (inner circuits are over its scalar fields), and outer proofs are generated over the BW6-761 curve [39] (outer circuits are over its scalar field which matches the base field of BLS12-377). Additionally, for some cryptographic primitives that require a DLP-hard group (e.g. transaction signing in delegable DPC), we use the twisted Edwards curve whose base field is the scalar field of the BLS12-377 curve.</p>

    <p class="text-gray-300">Pseudorandom Permutation. Many of our following primitives are built from an algebraic pseudorandom permutation using Rescue algorithm [2].</p>

    <p class="text-gray-300">The Rescue PRP is defined by a square matrix MDS of size  <span class="math">\\mathsf{w} \\times \\mathsf{w}</span>  (in our instantiation  <span class="math">\\mathsf{w} = 4</span> ), an initial constants vector IC, and a key-scheduling constant vector C and a keyscheduling matrix K. We set the number of rounds  <span class="math">\\mathsf{n}_{\\mathbf{r}} = 12</span> . For the S-box parameter  <span class="math">\\alpha</span> , we set  <span class="math">\\alpha = 11</span>  for BLS12-377's scalar field (used by the inner circuit) and  <span class="math">\\alpha = 5</span>  for BLS12-377's base field (used by the outer circuit). Note that during key scheduling, the key injection vectors can be preprocessed yielding a much faster generation of round keys. Formally, our</p>

    <p class="text-gray-300">Rescue instance works over a field <span class="math">\\mathbb{F}</span>, with keys and inputs of size 4 field elements: <span class="math">m^{\\prime}\\leftarrow\\mathsf{PRP}(k,m)</span> where <span class="math">k,m,m^{\\prime}\\in\\mathbb{F}^{4}</span>.</p>

    <p class="text-gray-300">For our PRF and hash function below, we need a fixed-key permutation as a building block rather than the full Rescue PRP. We build this by setting the key to the 0 vector: <span class="math">m^{\\prime}\\leftarrow\\mathsf{FixedKeyPRP}(m)=\\mathsf{PRP}([0,0,0,0],m)</span> where <span class="math">m,m^{\\prime}\\in\\mathbb{F}^{4}</span>.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Pseudorandom Function.</h4>

    <p class="text-gray-300">We build a sponge-based PRF from the fixed-key Rescue permutation. The construction follows the Full-State Keyed Sponge (FKS) paradigm (see Algorithm 1 in <em>[46]</em>) but here is simplified to output a single field element. The PRF takes a secret key <span class="math">k</span> of one field element, a message <span class="math">m</span> of fixed length: <span class="math">y\\leftarrow\\mathsf{PRF}_{n}(k,x)</span> where <span class="math">k,y\\in\\mathbb{F},x\\in\\mathbb{F}^{n}</span>.</p>

    <p class="text-gray-300">The Full-State Keyed Sponge construction works as follows: it set the initial state with zeroes and the key in the last slot. Then it divides the input into chunks of Rescue’s state size, and absorbs them sequentially by 1) adding the chunk to the state, and 2) calling the Rescue permutation to produce a new state. After the input has been absorbed, it outputs the first element of the state.</p>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">CRH.</h4>

    <p class="text-gray-300">We build our collision-resistant hash (CRH) using the Sponge construction <em>[8]</em> on top of our Rescue fixed-key permutation. In our instantiation of Rescue, the permutation state is of width 4: 3 slots for the rate and 1 for the capacity of the sponge construction. We provide two instantiations of the sponge-based CRH. The first one assumes the input length is multiple of the rate. The second one applies the following simple padding before calling the Sponge CRH: append the field element 1 to the input, then append zeroes as necessary until the length is multiple of the rate. In short, we have a family of CRH that supports <span class="math">H:\\mathbb{F}^{*}\\mapsto\\mathbb{F}</span> for an arbitrary number of field elements as the pre-image.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">Merkle Tree.</h4>

    <p class="text-gray-300">The append-only ledger <span class="math">L</span> is instantiated using a Merkle tree to accumulate all published record commitments and to generate membership proofs for old input records inside a transaction. Specifically, we implemented a ternary Merkle tree (branch factor is 3) using our Rescue-based CRH introduced above. Notice that the permutation in our hash function takes in 4 field elements, out of which the last one is reserved for padding to avoid prefixing attacks. Thus, a ternary Merkle tree is tailored for our hash function in terms of circuit constraints. Our Merkle tree is of fixed height, a parameter initialized during system setup, and it is incremental meaning it is possible to dynamically insert new leaves and update the Merkle root in time <span class="math">O(\\log M)</span> where <span class="math">M</span> is the maximum number of leaves allowed. For details on domain separation for different types of nodes in the prevention of prefixing attacks and other formal security proofs, please refer to Section 4.1.8 in <em>[44]</em>.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">Commitments.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We build a Rescue-based commitment scheme that takes in a message <span class="math">m\\in\\mathbb{F}^{n}</span> of some fixed length <span class="math">n</span> and a randomly sampled blinding factor <span class="math">s</span>, outputs a hiding commitment $c\\leftarrow\\mathsf{Commit}_{n}(s,m)=\\mathsf{CRH}(s\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0)<span class="math"> where 0 are padded zeros so that the total input to </span>\\mathsf{CRH}<span class="math"> is of multiples of its rate (i.e. 3), </span>\\mathsf{CRH}<span class="math"> is the first instantiation of rescue-based CRH introduced above, and </span>c\\in\\mathbb{F}$. Intuitively, the binding and hiding property of our commitment scheme is derived from the collision resistance and one-wayness of the rescue permutation respectively. We further note that we can safely pad zeros to the fixed-length input messages because any message input of mismatching length should be rejected.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">SNARK.</h4>

    <p class="text-gray-300">We instantiate the SNARKs using KZG-based Plonk <em>[31]</em>. Concretely, our predicate circuit and circuit for the relation <span class="math">\\mathcal{R}_{\\mathsf{utso}}</span> uses our TurboPlonk constraint system over <span class="math">E_{\\mathsf{BLS}}</span> (see Def. 2) with customized gates optimized for rescue-based statements; while our outer circuit for the relation <span class="math">\\mathcal{R}_{\\Phi}</span> uses our UltraPlonk constraint system over <span class="math">E_{\\mathsf{BW}}</span> (see Def. 3) with lookup table for efficient range proofs and variable-base MSM gadgets. We further extend the normal capability of a zkSNARK to support instance merging, proof batching and lightweight verifier gadget for our outer SNARK. Note that our inner circuits don’t need to be zero-knowledge, only the outer circuit requires zero-knowledge to reveal nothing about the predicate verification keys used in order to achieve the function privacy of a DPC scheme.</p>`;
---

<BaseLayout title="VERI-ZEXE: Decentralized Private Computation with Universal ... (2022/802)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/802
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
