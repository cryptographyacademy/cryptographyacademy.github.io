---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1731';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Arc: Accumulation for Reed--Solomon Codes';
const AUTHORS_HTML = 'Benedikt Bünz, Pratyush Mishra, Wilson Nguyen, William Wang';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz bb@nyu.edu New York University Pratyush Mishra prat@upenn.edu University of Pennsylvania Wilson Nguyen wdnguyen@stanford.edu Stanford University William Wang ww@priv.pub New York University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Proof-Carrying Data (PCD) is a foundational tool for ensuring the correctness of incremental distributed computations that has found numerous applications in theory and practice. The state-of-the-art PCD constructions are obtained via <em>accumulation</em> or <em>folding</em> schemes. Unfortunately, almost all known constructions of accumulation schemes rely on homomorphic vector commitments (VCs), which results in relatively high computational costs and insecurity in the face of quantum adversaries. A recent work of Bünz, Mishra, Nguyen, and Wang removes the dependence on homomorphic VCs by relying only on the random oracle model, but introduces a bound on the number of consecutive accumulation steps, which in turn bounds the depth of the PCD computation graph and greatly affects prover and verifier efficiency.</p>

    <p class="text-gray-300">In this work, we propose Arc, a novel hash-based accumulation scheme that overcomes this restriction and supports an unbounded number of accumulation steps. The core building block underlying Arc is a new accumulation scheme for claims about proximity of claimed codewords to the Reed–Solomon code. Our approach achieves near-optimal efficiency, requiring a small number of Merkle tree openings relative to the code rate, and avoids the efficiency loss associated with bounded accumulation depth. Unlike prior work, our scheme is also able to accumulate claims up to list-decoding radius, resulting in concrete efficiency improvements.</p>

    <p class="text-gray-300">We use this accumulation scheme to construct two distinct accumulation schemes, again relying solely on random oracles. The first approach accumulates RS proximity claims and can be used as an almost-drop-in replacement in existing PCD deployments based on IOP-based SNARKs. The second approach directly constructs an accumulation scheme for rank-1 constraint systems (and more generally polynomial constraint systems) that is simpler and more efficient than the former and prior approaches.</p>

    <p class="text-gray-300">We introduce the notion of Interactive Oracle Reductions (IORs) to enable a modular and simple security analysis. These extend prior notions of Reductions of Knowledge to the setting of IOPs.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our results  3 1.2 Related work  5</p>

    <p class="text-gray-300">2  Techniques  7 2.1 Accumulation for Reed–Solomon proximity claims  7 2.2 Accumulation for NP  9 2.3 Proof-carrying data from reductions  12</p>

    <p class="text-gray-300">3  Preliminaries  14 3.1 Relations  14 3.2 Reed–Solomon codes  15 3.3 Merkle trees  16</p>

    <p class="text-gray-300">4  Non-interactive reductions  18 4.1 IVC and PCD from non-interactive reductions  18</p>

    <p class="text-gray-300">5  Interactive oracle reductions  20 5.1 Definition  20 5.2 Round-by-round soundness  21 5.3 Non-interactive reductions from IORs  22</p>

    <p class="text-gray-300">6  Accumulation for Reed–Solomon proximity claims  24 6.1 Construction  25 6.2 Soundness analysis  26 6.3 Extensions and optimizations  27</p>

    <p class="text-gray-300">7  Accumulation for NP  28 7.1 Reduction from <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> to <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span>  29 7.2 Reduction from <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^s</span> to <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span>  30 7.3 Completeness and soundness of Construction  31</p>

    <p class="text-gray-300">Acknowledgments  35</p>

    <p class="text-gray-300">References  36</p>

    <p class="text-gray-300">A  Proof of Theorem 4.3  40 A.1 Accumulation schemes  40 A.2 Construction  41</p>

    <p class="text-gray-300">B  Proof of Theorem 5.9  47 B.1 State-restoration soundness  50 B.2 Replacing oracles with Merkle commitments  51 B.3 Fiat–Shamir transformation  56</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Proof-carrying data (PCD) <em>[x10]</em> is a powerful tool for proving the correctness of distributed computations that unfold incrementally. PCD has enabled numerous theoretical and practical applications, such as enforcing language semantics in distributed settings <em>[x11]</em>, complexity-preserving <em>[x3, x2]</em> and low-memory <em>[x24]</em> succinct arguments, verifiable MapReduce computations <em>[x11]</em>, image provenance <em>[x21]</em>, and consensus protocols and blockchains <em>[x23, x18, x12, x16]</em>.</p>

    <p class="text-gray-300">These applications have motivated numerous constructions of PCD <em>[x12, x3, x13, x1, x14]</em>. The state-of-the-art amongst these approaches relies on accumulation <em>[x3, x2]</em> or folding <em>[x14]</em> schemes. At a high level, these schemes enable a prover to efficiently accumulate arbitrary NP claims into a running ‘accumulator’, so that verifying the correctness of each accumulation step can be done cheaply, and furthermore the final accumulator can be checked in time that is independent of the number of accumulation steps. Prior work <em>[x3, x2]</em> shows how to construct PCD from any accumulation scheme for a <em>non</em>-succinct argument (NARK): at each step of the computation, the PCD prover invokes the accumulation prover to accumulate claims about prior steps, and then invokes the argument prover to assert that (a) the current step was performed correctly; and (b) prior claims were accumulated correctly. This PCD construction inherits efficiency and expressivity properties of the underlying accumulation scheme (and NARK), and recent work has made great progress in this regard: the latest schemes achieve, among other benefits, simple constructions that are easy to analyze and implement, low cost for verifying accumulation, and efficient support for claims that use custom gates <em>[x15]</em>. Unfortunately, existing schemes also suffer from some key drawbacks which we discuss next, categorized by how the schemes are constructed.</p>

    <p class="text-gray-300">Accumulation from homomorphic vector commitments. The vast majority of accumulation scheme constructions <em>[x2, x14, x15, x4, x16, x17]</em> use as a crucial building block homomorphic vector commitments. Unfortunately, all known constructions of the latter rely on one of two kinds of number-theoretic assumptions. The first kind relies on the hardness of the discrete logarithm problem in prime-order groups. This means that the accumulation prover must perform relatively expensive group operations, and furthermore leaves the schemes vulnerable to quantum attacks. The second kind attempts to fix the latter issue by relying on lattice assumptions <em>[x4, x10]</em>, but the resulting accumulation schemes still incur overhead due to their reliance on number-theoretic assumptions.</p>

    <p class="text-gray-300">Furthermore, both kinds of accumulation schemes cannot take advantage of recent advances in the design and implementation of SNARKs based on interactive oracle proofs (IOPs) <em>[x5]</em>, such as the ability to use small fields <em>[x16, x22, x13]</em> and reliance on only cryptographic hashes <em>[x5]</em>.</p>

    <p class="text-gray-300">Accumulation from homomorphism-checkers. To remedy this, a recent work <em>[x11]</em> constructs <em>hash-based</em> accumulation schemes that avoid public-key assumptions, achieve plausible post-quantum security, rely on minimal assumptions (just cryptographic hashes), and are able to take advantage of the aforementioned advances in IOP-based SNARKs. Unfortunately, their schemes only support a (small) bounded number of consecutive accumulation steps, and this in turn forces their PCD scheme to declare an <em>a priori</em> limit on the depth of the computation graph. Additionally, efficiency of the accumulation prover and verifier worsens as this bound increases; see Section 1.2 for details.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <p class="text-gray-300">In this work, we bypass the aforementioned limitations by constructing efficient hash-based accumulation schemes that support unbounded accumulation depth. At a high level, our schemes work by replacing</p>

    <p class="text-gray-300">homomorphic vector commitments with (non-homomorphic) Merkle tree commitments to Reed–Solomon encodings of the NP witnesses being accumulated. Making this high level sketch work requires us to develop a number of new techniques, which we describe next.</p>

    <p class="text-gray-300">New tool: accumulation for Reed–Solomon proximity claims. The key ingredient underlying the foregoing results is a new accumulation scheme for claims about the proximity of a claimed codeword to the Reed–Solomon (RS) code. Our construction makes crucial use of tools that were previously developed for reasoning about properties of Reed–Solomon codes in the context of succinct arguments <em>[x1, x2]</em>, and shows how to adapt these tools to the accumulation setting.</p>

    <p class="text-gray-300">In terms of efficiency, our accumulation scheme obtains essentially optimal parameters: asymptotically, for accumulating claims about proximity to the RS code of rate <span class="math">\\rho</span>, our scheme requires only <span class="math">\\frac{2\\lambda}{\\log(1/\\rho)}</span> Merkle tree openings, and we can get rid of the factor of <span class="math">2</span> when assuming common conjectures about list-decoding of RS codes <em>[x3, x2]</em>.</p>

    <p class="text-gray-300">In comparison, the accumulation verifier of the prior approach of Bünz et al. <em>[x4]</em>, which works for any code but only supports a bounded accumulation depth <span class="math">d</span>, requires <span class="math">O(d\\lambda)</span> Merkle tree openings; this is concretely less efficient than our scheme for any non-trivial depth. We are able to avoid this depth bound because the techniques underlying our scheme are <em>distance-preserving</em>: if the inputs are at most <span class="math">\\delta</span>-far from the RS code, then so is the output. In contrast, the approach of Bünz et al. <em>[x4]</em> is not distance-preserving: the output is only guaranteed to be <span class="math">\\delta+\\epsilon</span>-far from the RS code for some parameter <span class="math">\\epsilon</span>. Furthermore, unlike the approach of Bünz et al. <em>[x4]</em>, our scheme extends to list-decoding radius <span class="math">1-\\sqrt{\\rho}</span>, which enables further efficiency improvements.</p>

    <p class="text-gray-300">Reed–Solomon-based accumulation for NP. We leverage the foregoing RS proximity accumulation scheme to construct two different accumulation schemes for NP that rely solely on random oracles:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Accumulation for Polynomial IOPs: (Section 6)</em> The first approach relies on the observation that numerous prior SNARKs can be viewed as reducing checking NP witnesses to checking proximity of codewords to the Reed–Solomon (RS) code. In more detail, prior work <em>[x1]</em> shows that (the information-theoretic component of) many IOP-based SNARKs for an NP relation <span class="math">\\mathcal{R}</span> can be decomposed into three steps: a polynomial interactive oracle proof (PIOP) <em>[x7, x2]</em> for <span class="math">\\mathcal{R}</span> where the verifier checks that the prover’s messages (which are guaranteed to be low-degree polynomials) satisfy certain identities, a transformation from these identities to RS proximity claims <em>[x11, x2]</em>, and a low-degree test (LDT) that enforces these claims.</li>

    </ul>

    <p class="text-gray-300">We leverage this decomposition to construct an accumulation scheme for <span class="math">\\mathcal{R}</span>. Our scheme runs the first two steps (PIOP and transformation to RS proximity claims) like above, but then, instead of enforcing the proximity claims via the LDT, accumulates them via our accumulation scheme for RS proximity.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Accumulation for R1CS: (Section 7)</em> Our second approach builds on prior accumulation schemes <em>[x6, x10]</em> which reduce claims about an NP relation <span class="math">\\mathcal{R}</span> to claims about univariate polynomial identities. Our construction translates these claims into RS proximity claims and then invokes our accumulation scheme for the latter. In more detail, the accumulator in our construction now consists of two codewords: one that corresponds to the RS proximity accumulator and one that contains the accumulated witness to the polynomial identities. The construction maintains the essentially optimal properties of the underlying accumulation for proximity claims. The accumulation verifier checks only <span class="math">t=\\frac{2\\lambda}{\\log(1/\\rho)}</span> Merkle path openings per input, and the accumulation is distance-preserving (unlike the scheme of Bünz et al <em>[x4]</em>).</li>

    </ul>

    <p class="text-gray-300">In fact, one can key view (a part of) our scheme as performing the first round of the recent STIR interactive oracle proof of proximity [ACFY24], which means that it will always be more efficient than STIR.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">code</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IVC overhead per step</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IVC verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">max. IVC length</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PIOP + STIR [ACFY24]</td>

            <td class="px-3 py-2 border-b border-gray-700">RS</td>

            <td class="px-3 py-2 border-b border-gray-700">λ(k/log(1/ρ) + log(log n/log(1/ρ))</td>

            <td class="px-3 py-2 border-b border-gray-700">λ(k/log(1/ρ) + log(log n/log(1/ρ)) TMT</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BMNW24]</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

            <td class="px-3 py-2 border-b border-gray-700">d · λ/log(2/(1+ρ))</td>

            <td class="px-3 py-2 border-b border-gray-700">d · n</td>

            <td class="px-3 py-2 border-b border-gray-700">md</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this paper (PIOP-based)</td>

            <td class="px-3 py-2 border-b border-gray-700">RS</td>

            <td class="px-3 py-2 border-b border-gray-700">k · λ/log(1/ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">k · n</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this paper (direct)</td>

            <td class="px-3 py-2 border-b border-gray-700">RS</td>

            <td class="px-3 py-2 border-b border-gray-700">λ/log(1/ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of IVC schemes constructed from PCD over a tree of depth  <span class="math">d</span>  and arity  <span class="math">m</span> . All costs omit constant factors. All rows except [BMNW24] assume conjectures about proximity-gaps in the list-decoding radius. IVC overhead per step is measured in number of Merkle tree openings. Above  <span class="math">n</span>  is the size of the recursive circuit divided by the code rate  <span class="math">\\rho</span> , and  <span class="math">T_{\\mathrm{MT}}</span>  is the time it takes to verify a Merkle Tree opening over  <span class="math">n</span> -sized vectors. Finally,  <span class="math">k</span>  denotes the number of oracles queried by the PIOP verifier. The IVC verifier in the accumulation-based constructions can be outsourced using a SNARK, e.g., using STIR.</p>

    <p class="text-gray-300">The two approaches are useful in different settings. The first approach offers an easy path to improve the efficiency of existing PCD constructions rely on recursive composition of IOP-based SNARKs: simply replace the LDT with our RS proximity accumulation scheme. On the other hand, the second approach, by avoiding PIOPs, is able to attain a design that is simpler and more prover- and verifier- efficient than prior work, and is hence better for new systems.</p>

    <p class="text-gray-300">New model: interactive oracle reductions. Along the way, we formalize a new notion of interactive and probabilistic reduction protocols that we call interactive oracle reductions (IORs). Roughly, an IOR from relation  <span class="math">\\mathcal{R}_1</span>  to relation  <span class="math">\\mathcal{R}_2</span>  is an interactive protocol between a prover and a verifier that convinces the verifier that a claimed instance  <span class="math">\\mathbb{x}_1</span>  is in  <span class="math">\\mathcal{R}_1</span>  if and only if another instance  <span class="math">\\mathbb{x}_2</span>  is in  <span class="math">\\mathcal{R}_2</span> . IORs can be seen as the IOP analogues of reductions of knowledge [KP23]. We show how to compile IORs to non-interactive reductions by adapting the BCS transformation [BCS16].</p>

    <p class="text-gray-300">We show how to interpret accumulation schemes as applying IORs for specific pairs of relations, and this perspective allows us to construct accumulation schemes in a straightforward manner, and also significantly simplifies our security proofs.</p>

    <p class="text-gray-300">Bounded-depth accumulation. As noted in Section 1, the only prior hash-based accumulation scheme is that of Bunz et al [BMNW24]. Unlike our work, their scheme supports any (constant-distance) linear code, including those that enjoy linear-time encoding algorithms [Spi96; DI14; GLSTW23]. However, this benefit comes with a severe drawback: their scheme only supports a bounded number of consecutive accumulation steps. In more detail, they construct a family of accumulation schemes that are parameterized by a depth bound  <span class="math">d</span> . This bound affects the choice of the code (larger  <span class="math">d</span>  requires better code distance), and hence also prover efficiency (better distance results in worse rate and hence larger Merkle trees) and verifier efficiency (larger  <span class="math">d</span>  requires more Merkle tree openings). We also note that the PCD scheme constructed from their accumulation scheme inherits this depth bound, and, even worse, suffers from a concrete attack once the depth of the computation graph exceeds the bound.</p>

    <p class="text-gray-300">In contrast, because our scheme does not have a depth bound, we can fix (for each input size) a code with rate and distance that minimizes prover and verifier costs. For instance, we can arbitrarily choose rate  <span class="math">1/2</span>  to minimize prover costs, or rate  <span class="math">1/4</span>  or even  <span class="math">1/8</span>  to reduce verifier costs. We are also not vulnerable to</p>

    <p class="text-gray-300">the aforementioned attack.</p>

    <p class="text-gray-300"><em>[x1]</em> also introduce several optimizations for IOP-based-accumulation IVC constructions. These include batch committing to multiple input accumulators, in order to reduce the number of oracle queries. These optimization also apply to our constructions.</p>

    <p class="text-gray-300">Accumulation from hardness of discrete logarithms. As noted in Section 1, most existing accumulation schemes <em>[x2, x3, x4, x5, x6, x7, x8]</em> rely on the hardness of computing discrete logarithms over elliptic curve groups. This in turn requires the use of cryptographically large fields both to express the computation, which can incur overheads if the computation does not need such large fields (e.g., it performs arithmetic over small integers). Furthermore, efficient implementations require <em>cycles of elliptic curves</em>, which are tricky to use correctly in practice <em>[x10]</em>.</p>

    <p class="text-gray-300">Accumulation from lattice assumptions. Some recent works <em>[x4, x7]</em> construct plausibly post-quantum accumulation schemes from lattice-based assumptions such as SIS and Module-SIS. Unlike our work, they depend on additional assumptions beyond random oracles.</p>

    <p class="text-gray-300">PCD from IOP-based SNARKs. A number of recent works have constructed PCD directly from IOP-based SNARKs <em>[x11, x12]</em>. These works follow the standard methodology of constructing PCD from succinct arguments <em>[x5, x6]</em>: to prove a <span class="math">t</span>-step computation, the PCD prover invokes the prover for the underlying SNARK to assert that not only was the <span class="math">t</span>-th computation step performed correctly, but also that there exists a valid SNARK proof for the first <span class="math">t-1</span> steps.</p>

    <p class="text-gray-300">While these PCD schemes inherit the benefits of their underlying SNARKs (e.g., plausible post-quantum security, concretely efficient provers, reliance only on cryptographic hashes, etc.), they incur high asymptotic and concrete PCD overhead due to the need to express the SNARK verifier as an arithmetic circuit. This is problematic, as it lower-bounds the computations for which PCD is effective: for computations that are cheaper than the SNARK verifier, the PCD prover spends most of its time proving the latter instead of the actual computation.</p>

    <p class="text-gray-300">Asymptotically, even incorporating state-of-the-art improvements like STIR <em>[x1]</em> results in a verifier that requires <span class="math">O(\\log n+\\lambda\\log\\log n)</span> Merkle tree openings, whereas our accumulation-based approaches would require only <span class="math">O(\\lambda)</span> openings. Concretely, when instantiating the Merkle tree with an arithmetization-oriented hash function like Poseidon <em>[x13]</em>, Fractal’s verifier circuit is of size at least <span class="math">1.1</span> million gates <em>[x11]</em>. In contrast, using our direct approach to accumulate R1CS claims of <span class="math">2^{20}</span> constraints requires only roughly <span class="math">200,000</span> gates <em>without</em> standard optimizations used by Fractal like proof of work or tree caps, and without using high-degree custom gates which our construction supports cheaply. (We set the rate of the RS code to be <span class="math">1/16</span>, which results in <span class="math">128/\\log_{2}(1/(1/16))=32</span> Merkle tree openings.)</p>

    <p class="text-gray-300">PCD from other SNARKs. The earliest work on efficient constructions of PCD proceeded by recursive composition of pairing-based SNARKs <em>[x1]</em>. Like accumulation-based PCD that rely no prime-order groups (i.e., without pairings), these constructions also require a cycle of elliptic curves to attain efficient recursion. However, unlike the case for non-pairing curves, cycles of pairing-friendly curves are rare <em>[x10, x3]</em>, and current constructions that meet 128-bit security levels require arithmetic over 1000-bit prime fields <em>[x11]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We introduce interactive oracle reductions, a notion which extends interactive oracle proofs [BCS16; RRR16] to capture reductions, a framework recently introduced by Kothapalli and Parno [KP23].</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">In a reduction of knowledge, a prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  interact to reduce the claim that an instance  <span class="math">\\mathbf{z}</span>  is in a language  <span class="math">\\mathcal{L}(\\mathcal{R})</span>  into the claim that a new instance  <span class="math">\\mathbf{z}&#x27;</span>  is in a new language  <span class="math">\\mathcal{L}(\\mathcal{R}&#x27;)</span> . Moreover, if  <span class="math">\\mathcal{P}</span>  knows a new witness  <span class="math">\\mathbf{w}&#x27;</span>  with  <span class="math">(\\mathbf{z}&#x27;, \\mathbf{w}&#x27;) \\in \\mathcal{R}&#x27;</span> , then it must also know a witness  <span class="math">\\mathbf{w}</span>  with  <span class="math">(\\mathbf{z}, \\mathbf{w}) \\in \\mathcal{R}</span> . As an example, a folding scheme [BCLMS21; KST22; BC23; KS24] is a reduction from  <span class="math">\\mathcal{R} \\times \\mathcal{R}</span>  to  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">The language of reductions seems to, in spirit, capture the protocols we construct. However, reductions of knowledge as described by Kothapalli and Parno [KP23] do not capture (1) instances which contain oracle strings  <span class="math">y</span> ; and (2) verifiers having oracle access to prover messages  <span class="math">\\Pi</span> , which are features we need to analyze our protocols. Interactive Oracle Proofs of Proximity (IOPPs) [BCGRS17] roughly capture these features, but are not reductions: in an IOPP, the verifier simply outputs a bit and not a new instance.</p>

    <p class="text-gray-300">Therefore, we define an interactive oracle reduction for a relation  <span class="math">\\mathcal{R} \\coloneqq \\{(\\mathsf{z},\\mathsf{y},\\mathsf{w})\\}</span>  as an interactive protocol between a prover and a verifier, where the verifier is given access oracle access to instance strings  <span class="math">\\mathsf{y}</span>  and prover messages  <span class="math">\\Pi</span> . At the end of interaction, the prover outputs a new witness  <span class="math">\\mathsf{w}&#x27;</span>  and the verifier outputs a new instance  <span class="math">(\\mathsf{z}&#x27;,\\mathsf{y}&#x27;)</span> , where  <span class="math">\\mathsf{y}&#x27;</span>  is selected from either the input oracle strings or those sent by the prover. Informally, if this new tuple  <span class="math">(\\mathsf{z}&#x27;,\\mathsf{y}&#x27;,\\mathsf{w}&#x27;)</span>  belongs to  <span class="math">\\mathcal{R}&#x27;</span> , then the prover knows of a corresponding witness  <span class="math">\\mathsf{w}</span>  such that  <span class="math">(\\mathsf{z},\\mathsf{y},\\mathsf{w})</span>  belongs to  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">IORs, accumulation, and PCD. By adapting the BCS transformation [BCS16], we show that IORs can be compiled into non-interactive reductions in the random oracle model. We then prove that an accumulation scheme for a relation  <span class="math">\\mathcal{R}</span>  can be constructed from the following (non-interactive) components:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A reduction from  <span class="math">\\mathcal{R}</span>  to an intermediate relation  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span></li>

      <li>A many-to-one reduction from  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{<em>}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span> . Here,  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{</em>}</span>  is defined to be the multi-instance relation  <span class="math">\\{((\\mathsf{z}_1,\\ldots ,\\mathsf{z}_m),(\\mathsf{w}_1,\\ldots ,\\mathsf{w}_m)): \\forall i\\in [m],(\\mathsf{z}_i,\\mathsf{w}_i)\\in \\mathcal{R}_{\\mathrm{ACC}}\\}</span> .</li>

    </ol>

    <p class="text-gray-300">Assuming that  <span class="math">\\mathcal{R}</span>  is NP-complete, prior work [BCLMS21] has shown how to construct proof-carrying data from such an accumulation scheme.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{C} \\subset \\mathbb{F}^n</span>  be a Reed-Solomon code. Suppose we have two vectors  <span class="math">f_1, f_2 \\in \\mathbb{F}^n</span> . Our goal is to reduce the claim that  <span class="math">f_1</span>  and  <span class="math">f_2</span>  are  <span class="math">\\delta</span> -close to  <span class="math">\\mathcal{C}</span>  to the claim that a related vector  <span class="math">f</span>  is  <span class="math">\\delta</span> -close to  <span class="math">\\mathcal{C}</span> . For simplicity, we assume that  <span class="math">\\delta</span>  is at most the unique decoding radius of the code.</p>

    <p class="text-gray-300">A natural approach is to take  <span class="math">f</span>  to be a random linear combination of  <span class="math">f_{1}</span>  and  <span class="math">f_{2}</span> ; indeed, proximity gaps for Reed-Solomon codes [BCIKS23] tell us that if either  <span class="math">f_{1}</span>  or  <span class="math">f_{2}</span>  is  <span class="math">\\delta</span> -far, then  <span class="math">f := f_{1} + r \\cdot f_{2}</span>  will be  <span class="math">\\delta</span> -far with high probability. However, this fact alone does not give us a many-to-one reduction for proximity</p>

    <p class="text-gray-300">claims. The issue is that <span class="math">f</span> is a “virtual” object defined over two vectors; whenever the verifier queries <span class="math">f[i]</span>, it is implicitly querying <span class="math">f_{1}[i]</span> and <span class="math">f_{2}[i]</span>. This implies that the new claim doubles in size (concretely, <span class="math">2n+1</span> field elements). Ultimately, in order to realize accumulation, the size of the new claim must be independent of the number of old claims.</p>

    <p class="text-gray-300">Prior work. We first recall the approach taken in <em>[x1]</em>. After the verifier samples <span class="math">r</span>, the prover sends a <em>new</em> vector <span class="math">f</span> which is claimed to be <span class="math">f_{1}+r\\cdot f_{2}</span>. The verifier tests this by sampling a random location <span class="math">i\\in[n]</span> and checking that the vectors are consistent at the <span class="math">i</span>-th entry: <span class="math">f[i]=f_{1}[i]+r\\cdot f_{2}[i]</span>. By repeating this spot check <span class="math">\\frac{\\lambda}{-\\log(1-\\varepsilon)}</span> times, the verifier ensures that <span class="math">f</span> is <span class="math">\\varepsilon</span>-close to <span class="math">f_{1}+r\\cdot f_{2}</span> with high probability. Hence, if either <span class="math">f_{1}</span> or <span class="math">f_{2}</span> is <span class="math">\\delta</span>-far, then <span class="math">f</span> is <span class="math">(\\delta-\\varepsilon)</span>-far from the code. Although the size of the new claim is indeed independent of the number of old claims, this is not quite a many-to-one reduction. The issue is that the distance claim degrades from <span class="math">\\delta</span> to <span class="math">\\delta-\\varepsilon</span>. As a result, <em>[x1]</em> are only able to construct a <em>bounded-depth accumulation scheme</em>, where the number of steps must be a small constant fixed in advance.</p>

    <p class="text-gray-300">Background. Let <span class="math">\\mathcal{L}</span> be a subset of <span class="math">\\mathbb{F}</span> of size <span class="math">n</span>; this is referred to as the evaluation domain. The Reed–Solomon code <span class="math">\\mathsf{RS}[d]\\subset\\mathbb{F}^{n}</span> is the set of words <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span> where <span class="math">f</span> is consistent with a polynomial of degree less than <span class="math">d</span>. The <em>quotient</em> of a word <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span> relative to <span class="math">x,y\\in\\mathbb{F}</span> is defined to be <span class="math">\\mathsf{Quotient}(f,x,y)(X):=\\frac{f(X)-y}{X-x}</span>. We make the following observations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">f</span> is a codeword in <span class="math">\\mathsf{RS}[d]</span> with <span class="math">y=f(x)</span>, then <span class="math">\\mathsf{Quotient}(f,x,y)</span> is a codeword in <span class="math">\\mathsf{RS}[d-1]</span>. This is because <span class="math">x</span> is a root of <span class="math">g(X)-y</span>.</li>

      <li>If <span class="math">\\mathsf{Quotient}(f,x,y)</span> is <span class="math">\\delta</span>-close to a codeword <span class="math">w\\in\\mathsf{RS}[d-1]</span>, then <span class="math">f</span> is <span class="math">\\delta</span>-close to a codeword <span class="math">u\\in\\mathsf{RS}[d]</span> with <span class="math">u(x)=y</span>, namely <span class="math">u(X):=w(X)\\cdot(X-x)+y</span>.</li>

      <li>If <span class="math">f</span> is <span class="math">\\delta</span>-far from any codeword <span class="math">u\\in\\mathsf{RS}[d]</span> with <span class="math">u(x)=y</span>, then <span class="math">\\mathsf{Quotient}(f,x,y)</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d-1]</span>. This is essentially the contrapositive of Item 2.</li>

    </ol>

    <p class="text-gray-300">Quotients can be generalized to handle multiple points by defining</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Quotient}(f,(x_{1},y_{1}),\\ldots,(x_{t},y_{t})):=\\frac{f(X)-p(X)}{\\prod_{j=1}^{t}(X-x_{j})},</span></p>

    <p class="text-gray-300">where <span class="math">p</span> is the Lagrange interpolation of <span class="math">(x_{j},y_{j})_{j\\in[t]}</span>. If <span class="math">f</span> is <span class="math">\\delta</span>-far from any codeword <span class="math">u\\in\\mathsf{RS}[d]</span> with <span class="math">u(x_{j})=y_{j}</span> for all <span class="math">j</span>, then <span class="math">\\mathsf{Quotient}(f,(x_{1},y_{1}),\\ldots,(x_{t},y_{t}))</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d-t]</span>.</p>

    <p class="text-gray-300">This work. We give a many-to-one reduction for Reed–Solomon proximity claims which preserves distance; the resulting accumulation scheme therefore supports an unbounded number of steps. The protocol starts off in the same way as before:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier samples a random combination <span class="math">r\\leftarrow\\mathbb{F}</span>.</li>

      <li>Prover sends a new word <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span>. In the honest case, <span class="math">f:=f_{1}+r\\cdot f_{2}</span>.</li>

      <li>Verifier samples locations <span class="math">x_{1},\\ldots,x_{t}\\leftarrow\\mathcal{L}</span>.</li>

    </ol>

    <p class="text-gray-300">Where we depart is in how the new claim is formulated. The verifier computes <span class="math">y_{j}:=f_{1}(x_{j})+r\\cdot f_{2}(x_{j})</span> for each <span class="math">j</span>, and defines the quotient <span class="math">q:=\\mathsf{Quotient}(f,(x_{1},y_{1}),\\ldots,(x_{t},y_{t}))</span>. The new claim is that <span class="math">q</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[d-t]</span>. Observe that <span class="math">q</span> is defined over <span class="math">f</span> and a few (specifically, <span class="math">2t</span>) auxiliary field elements, and hence the size of the new claim is independent of the number of old claims.</p>

    <p class="text-gray-300">Suppose either <span class="math">f_{1}</span> or <span class="math">f_{2}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d]</span>. We show that <span class="math">q</span> will be <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d-t]</span> with high probability:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random combination <span class="math">f^{\\prime}:=f_{1}+r\\cdot f_{2}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d]</span> with high probability.</li>

      <li>Since <span class="math">\\delta</span> is at most the unique decoding radius, there is at most one codeword <span class="math">u\\in\\mathsf{RS}[d]</span> within <span class="math">\\delta</span> distance of <span class="math">f</span>. Fix <span class="math">u</span> if it exists. Since <span class="math">u</span> is <span class="math">\\delta</span>-far from <span class="math">f^{\\prime}</span>, there exists <span class="math">j</span> such that <span class="math">u(x_{j})\\neq f^{\\prime}(x_{j})=y_{j}</span> with probability at least <span class="math">1-(1-\\delta)^{t}</span>. Setting <span class="math">t:=\\frac{\\lambda}{-\\log(1-\\delta)}</span>, this is all but negligible.</li>

      <li>We conclude that <span class="math">f</span> is <span class="math">\\delta</span>-far from any codeword <span class="math">u</span> with <span class="math">u(x_{j})=y_{j}</span> for all <span class="math">j</span>, which implies that <span class="math">q</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[d-t]</span>.</li>

    </ol>

    <p class="text-gray-300">We are not quite done, because the new claim is about proximity to <span class="math">\\mathsf{RS}[d-t]</span>, rather than <span class="math">\\mathsf{RS}[d]</span>. Fortunately, there exist efficient degree correction procedures which allow the verifier to soundly reduce a proximity claim for <span class="math">\\mathsf{RS}[d-t]</span> into a proximity claim for <span class="math">\\mathsf{RS}[d]</span>.</p>

    <p class="text-gray-300">To summarize, we have described a reduction for Reed–Solomon proximity claims which satisfies two key properties. First, the size of the new claim is independent of the number of old claims; this is necessary for accumulation. Second, the reduction is distance-preserving; this is necessary for accumulating an unbounded number of times. Although we focused on combining two claims, our construction can easily be extended to combine many at once.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2.1 (informal).</h6>

    <p class="text-gray-300">Define the relation <span class="math">\\mathcal{R}_{\\texttt{RS}}</span> where <span class="math">(f,d)\\in\\mathcal{L}(\\mathcal{R}_{\\texttt{RS}})</span> if <span class="math">f</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[d]</span>. There exists a many-to-one reduction for <span class="math">\\mathcal{R}_{\\texttt{RS}}</span>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Moving to the list decoding radius.</h4>

    <p class="text-gray-300">Up to this point we have assumed that the distance parameter <span class="math">\\delta</span> is at most the unique decoding radius. We would ideally like to support larger <span class="math">\\delta</span>; this would translate to smaller <span class="math">t</span> and therefore improve query complexity. The key step in the analysis which fails if <span class="math">\\delta</span> were larger is Item 2; namely, there may be more than one codeword <span class="math">u</span> in the <span class="math">\\delta</span>-ball of <span class="math">f</span>. To resolve this, we leverage out-of-domain sampling <em>[x1]</em>. In more detail, after the prover sends the new word <span class="math">f</span>, the verifier samples an additional point <span class="math">x^{\\texttt{out}}\\in\\mathbb{F}</span>. The prover responds with a claimed evaluation <span class="math">y^{\\texttt{out}}</span>; assuming <span class="math">\\delta</span> is less than the list decoding radius, with high probability there exists a unique codeword <span class="math">u</span> in the <span class="math">\\delta</span>-ball satisfying <span class="math">u(x^{\\texttt{out}})=y^{\\texttt{out}}</span>. This point is additionally quotiented to obtain <span class="math">q</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Accumulation for NP</h3>

    <p class="text-gray-300">We describe a highly efficient accumulation scheme for R1CS circuit satisfiability. Recall that an R1CS circuit is defined by matrices <span class="math">A,B,C\\in\\mathbb{F}^{\\mathsf{M}\\times\\mathsf{N}}</span> and instance length <span class="math">\\mathsf{n}\\in\\mathbb{N}</span>. An instance <span class="math">x\\in\\mathbb{F}^{\\mathsf{n}}</span> is in the language if there exists a witness <span class="math">w\\in\\mathbb{F}^{\\mathsf{N}-\\mathsf{n}}</span> such that <span class="math">Az\\circ Bz=Cz</span> for <span class="math">z:=(x,w)\\in\\mathbb{F}^{\\mathsf{N}}</span>. Our goal is to accumulate instances of R1CS. Following the accumulation blueprint, it suffices to give (i) a reduction from R1CS to an intermediate relation <span class="math">\\mathcal{R}_{\\texttt{ACC}}</span>; and (ii) a many-to-one reduction for <span class="math">\\mathcal{R}_{\\texttt{ACC}}</span>.</p>

    <p class="text-gray-300">Informally, <span class="math">\\mathcal{R}_{\\texttt{ACC}}</span> encodes an “algebraic” proximity claim in the sense that <span class="math">f</span> must be <span class="math">\\delta</span>-close to a codeword <span class="math">u</span> which satisfies an algebraic constraint. Let <span class="math">d:=\\mathsf{N}-\\mathsf{n}</span>. Let <span class="math">P</span> be a multivariate polynomial in <span class="math">k+d</span> variables with total degree <span class="math">c</span>. For a codeword <span class="math">u\\in\\mathsf{RS}[d]</span>, let <span class="math">\\vec{u}\\in\\mathbb{F}^{d}</span> denote its decoding (concretely, its coefficient vector). For a scalar <span class="math">e\\in\\mathbb{F}</span>, vector <span class="math">v\\in\\mathbb{F}^{k}</span>, and word <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span>, we define <span class="math">(e,v,f)\\in\\mathcal{L}(\\mathcal{R}_{\\texttt{ACC}})</span> if <span class="math">f</span> is <span class="math">\\delta</span>-close to a codeword <span class="math">u\\in\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> such that <span class="math">P(v,\\vec{u})=e</span>; here, <span class="math">\\vec{u}\\in\\mathbb{F}^{d}</span> refers to the decoding of <span class="math">u</span>, i.e., its vector of coefficients. We assume that <span class="math">\\delta</span> is at most the unique decoding radius of the code.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">2.2.1 Reduction from R1CS to <span class="math">\\mathcal{R}_{\\texttt{ACC}}</span></h4>

    <p class="text-gray-300">For simplicity, assume that <span class="math">\\mathsf{M}</span> is a power of two and define <span class="math">\\mathsf{m}:=\\log\\mathsf{M}</span>. For each <span class="math">i=0,\\ldots,\\mathsf{M}-1-1</span>, define the multilinear polynomial <span class="math">\\mathsf{pow}_{i}(Y_{1},\\ldots,Y_{\\mathsf{m}})=Y_{1}^{b_{1}}\\cdots Y_{\\mathsf{m}}^{b_{\\mathsf{m}}}</span>, where <span class="math">b_{1},\\ldots,b_{\\mathsf{m}}</span> is the bit representation of</p>

    <p class="text-gray-300"><span class="math">i</span>. Observe that for all <span class="math">y\\in\\mathbb{F}</span>, <span class="math">\\mathsf{pow}_{i}(y,y^{2},y^{4},\\ldots,y^{2^{m-1}})=y^{i}</span>. <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> is defined with <span class="math">k:=\\mathsf{m}+\\mathsf{n}</span> and the polynomial</p>

    <p class="text-gray-300"><span class="math">P(Y_{1},\\ldots,Y_{\\mathsf{m}},Z_{1},\\ldots,Z_{\\mathsf{N}}):=\\sum_{i=1}^{\\mathsf{M}}\\mathsf{pow}_{i-1}(Y_{1},\\ldots,Y_{\\mathsf{m}})\\cdot(a_{i}^{T}\\vec{Z}\\cdot b_{i}^{T}\\vec{Z}-c_{i}^{T}\\vec{Z}),</span></p>

    <p class="text-gray-300">where <span class="math">a_{i}</span>, <span class="math">b_{i}</span>, <span class="math">c_{i}</span> are the <span class="math">i</span>-th rows of <span class="math">A</span>, <span class="math">B</span>, <span class="math">C</span>. Observe that <span class="math">P</span> total degree <span class="math">c:=\\mathsf{m}+2</span>. The reduction from R1CS to <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> is as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover sends a word <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span>. In the honest case, <span class="math">f</span> is the encoding of witness <span class="math">w</span>.</li>

      <li>Verifier samples a random scalar <span class="math">r\\leftarrow\\mathbb{F}</span>.</li>

      <li>The new claim is that <span class="math">(e,v,f)\\in\\mathcal{L}(\\mathcal{R}_{\\mathsf{ACC}})</span>, where <span class="math">e:=0</span> and <span class="math">v:=(r,r^{2},r^{4},\\ldots,r^{2^{m-1}},x)\\in\\mathbb{F}^{k}</span>.</li>

    </ol>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Soundness.</h4>

    <p class="text-gray-300">Suppose that <span class="math">x</span> is not a valid R1CS instance. We show that <span class="math">(e,v,f)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathsf{ACC}})</span> with high probability. Observe that since <span class="math">\\delta</span> is at most the unique decoding radius, there is at most one codeword <span class="math">u</span> within <span class="math">\\delta</span> distance of <span class="math">f</span>. Fix <span class="math">u</span> if it exists; otherwise, we immediately have <span class="math">(e,v,f)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathsf{ACC}})</span>. Define <span class="math">z:=(x,\\vec{u})</span>. Since <span class="math">x</span> is not a valid instance, there exists <span class="math">i\\in[\\mathsf{M}]</span> such that <span class="math">a_{i}^{T}z\\cdot b_{i}^{T}z\\neq c_{i}^{T}z</span>. Equivalently,</p>

    <p class="text-gray-300"><span class="math">F(X):=P(X,X^{2},X^{4},\\ldots,X^{2^{m-1}},z)=\\sum_{i=1}^{\\mathsf{M}}X^{i-1}\\cdot(a_{i}^{T}z\\cdot b_{i}^{T}z-c_{i}^{T}z)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a non-zero univariate polynomial of degree at most <span class="math">\\mathsf{N}-1</span>. Since <span class="math">r</span> is sampled uniformly, we have <span class="math">P(v,\\vec{u})=F(r)\\neq 0</span> with probability at least $1-\\frac{\\mathsf{N}-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. We conclude that </span>(e,v,f)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathsf{ACC}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.2.2 Many-to-one reduction for <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span></h4>

    <p class="text-gray-300">Suppose we have many instances <span class="math">(e_{1},v_{1},f_{1}),\\ldots,(e_{m},v_{m},f_{m})</span>. Our goal is to reduce the claim that <span class="math">(e_{i},v_{i},f_{i})\\in\\mathcal{R}_{\\mathsf{ACC}}</span> for all <span class="math">i</span> to the claim that <span class="math">(e,v,f)\\in\\mathcal{R}_{\\mathsf{ACC}}</span> for a new instance <span class="math">(e,v,f)</span>. Consider the reduction:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix a subset <span class="math">H=\\{a_{1},\\ldots,a_{m}\\}\\subset\\mathbb{F}</span>, and define <span class="math">V(X)=\\prod_{i=1}^{m}(X-a_{i})</span>, which vanishes on <span class="math">H</span>. Let <span class="math">L_{i}</span> denote the unique Lagrange polynomial of degree less than <span class="math">m</span> satisfying <span class="math">L_{i}(a_{i})=1</span> and <span class="math">L_{i}(a_{j})=0</span> for <span class="math">i\\neq j</span>. The prover sends a univariate polynomial <span class="math">Q</span> of degree at most <span class="math">c\\cdot(m-1)-m</span>. In the honest case, <span class="math">Q</span> is the unique polynomial which satisfies</li>

    </ol>

    <p class="text-gray-300"><span class="math">P\\left(\\sum_{i=1}^{m}L_{i}(X)\\cdot(v_{i},\\vec{f}_{i})\\right)-\\sum_{i=1}^{m}L_{i}(X)\\cdot e_{i}=Q(X)\\cdot V(X).</span></p>

    <p class="text-gray-300">This exists because the left side of the above equation vanishes on <span class="math">H</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier samples an evaluation point <span class="math">\\alpha\\leftarrow\\mathbb{F}</span>.</li>

      <li>Prover sends a new word <span class="math">f:\\mathcal{L}\\to\\mathbb{F}</span>. In the honest case, <span class="math">f:=\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot f_{i}</span>.</li>

      <li>Verifier samples locations <span class="math">x_{1},\\ldots,x_{t}\\leftarrow\\mathcal{L}</span>.</li>

      <li>Verifier computes <span class="math">e:=Q(\\alpha)\\cdot V(\\alpha)+\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot e_{i}</span> and <span class="math">v:=\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot v_{i}</span>.</li>

      <li>Verifier computes <span class="math">y_{j}:=\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot f_{i}(x_{j})</span> for each <span class="math">j\\in[t]</span>.</li>

      <li>We have the following new claims:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(e,v,f)\\in\\mathcal{R}_{\\mathsf{ACC}}</span>.</li>

    </ul>

    <p class="text-gray-300">8.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(f_{i},d)\\in\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span> for each <span class="math">i\\in[m]</span>.</li>

      <li><span class="math">(q,d-t)\\in\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span>, where <span class="math">q:=\\mathsf{Quotient}(f,(x_{1},y_{1}),\\ldots,(x_{t},y_{t}))</span>.</li>

    </ul>

    <p class="text-gray-300">This is not quite a many-to-one reduction for <span class="math">\\mathcal{R}_{\\mathtt{ACC}}</span>, since we also output several proximity claims. We resolve this by keeping track of <em>two instances</em>: one for <span class="math">\\mathcal{R}_{\\mathtt{ACC}}</span> and one for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span>. It suffices to construct a many-to-one reduction for <span class="math">\\mathcal{R}_{\\mathtt{ACC}}\\times\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span>, where the verifier (i) reduces <span class="math">m</span> instances for <span class="math">\\mathcal{R}_{\\mathtt{ACC}}</span> into one instance for <span class="math">\\mathcal{R}_{\\mathtt{ACC}}</span> and <span class="math">m+1</span> instances for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span>; and (ii) reduces <span class="math">2m+1</span> instances for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span> into one instance for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span> using Theorem 2.1.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">We show that if <span class="math">(e_{i},v_{i},f_{i})\\notin\\mathcal{R}_{\\mathtt{ACC}}</span> for some <span class="math">i</span>, then at least one of the new instances is invalid with high probability.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assume that <span class="math">f_{1},\\ldots,f_{m}</span> are <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[d]</span>; otherwise, the many-to-one reduction for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span> will output an invalid instance and we are done. In fact, the many-to-one reduction will only output a valid instance if there is <em>correlated agreement</em>: there exist codewords <span class="math">u_{1},\\ldots,u_{m}\\in\\mathsf{RS}[d]</span> such that <span class="math">f_{1},\\ldots,f_{m}</span> respectively agrees with <span class="math">u_{1},\\ldots,u_{m}</span> on the same <span class="math">1-\\delta</span> fraction of points. This is implied by proximity gaps for Reed–Solomon codes.</li>

      <li>We are guaranteed that there exists some <span class="math">i</span> such that <span class="math">P(v_{i},\\vec{u}_{i})\\neq e_{i}</span>. Observe that</li>

    </ol>

    <p class="text-gray-300"><span class="math">F(X):=P\\left(\\sum_{i=1}^{m}L_{i}(X)\\cdot(v_{i},\\vec{f}_{i})\\right)-Q(X)\\cdot V(X)-\\sum_{i=1}^{m}L_{i}(X)\\cdot e_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a non-zero polynomial of degree at most <span class="math">c\\cdot(m-1)</span>, since <span class="math">F(a_{i})=P(v_{i},\\vec{u}_{i})-e_{i}</span>. Define <span class="math">u^{\\prime}:=\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot u_{i}</span>. With probability $1-\\frac{c\\cdot(m-1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, </span>F(\\alpha)=P(v,\\vec{u}^{\\prime})\\neq e$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">f^{\\prime}:=\\sum_{i=1}^{m}L_{i}(\\alpha)\\cdot f_{i}</span>. By correlated agreement, <span class="math">u^{\\prime}</span> is <span class="math">\\delta</span>-close to <span class="math">f^{\\prime}</span>.</li>

      <li>Since <span class="math">\\delta</span> is at most the unique decoding radius, there exists at most one codeword <span class="math">u\\in\\mathsf{RS}[d]</span> within <span class="math">\\delta</span> distance of <span class="math">f</span>. Fix <span class="math">u</span> if it exists and assume that <span class="math">P(v,\\vec{u})=e</span>; otherwise, <span class="math">(e,v,f)\\not\\in\\mathcal{R}_{\\mathtt{ACC}}</span> and we are done.</li>

      <li>Since <span class="math">P(v,\\vec{u})\\neq P(v,\\vec{u}^{\\prime})</span>, we know that <span class="math">u\\neq u^{\\prime}</span>. Since the distance of the code is double the unique decoding radius, <span class="math">u</span> is <span class="math">2\\delta</span>-far from <span class="math">u^{\\prime}</span>. By a triangle inequality, <span class="math">u</span> is <span class="math">\\delta</span>-far from <span class="math">f^{\\prime}</span>.</li>

      <li>With probability at least <span class="math">1-(1-\\delta)^{t}</span>, there exists <span class="math">j</span> such that <span class="math">u(x_{j})\\neq f^{\\prime}(x_{j})=y_{j}</span>. Setting <span class="math">t:=\\frac{\\lambda}{-\\log(1-\\delta)}</span>, this is all but negligible.</li>

      <li>We conclude that <span class="math">f</span> is <span class="math">\\delta</span>-far from any codeword <span class="math">u</span> with <span class="math">u(x_{j})=y_{j}</span> for all <span class="math">j</span>, which implies that <span class="math">q</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d-t]</span>. With high probability, the many-to-one reduction for <span class="math">\\tilde{\\mathcal{R}}_{\\mathtt{RS}}</span> outputs an invalid instance.</li>

    </ol>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Moving to list decoding radius.</h5>

    <p class="text-gray-300">As in Section 2.1, we can upgrade <span class="math">\\delta</span> to be less than the list decoding radius. We use the same technique of out-of-domain samples to bind vectors to a unique codeword within the <span class="math">\\delta</span>-ball. For the construction, we need to send three separate out-of-domain samples. First, we bind each input <span class="math">f_{i}</span> to a unique codeword. Then, after the challenge <span class="math">\\alpha</span>, we bind the virtual polynomial <span class="math">f^{\\prime}</span>. Finally, we use an additional out-of-domain sample to bind <span class="math">f</span>. We discuss the necessity of these samples in more detail in Remark 7.15.</p>

    <p class="text-gray-300">Accumulation from Non-interactive Reductions. As we have seen, interactive oracle reductions and their compiled form, non-interactive reductions, capture natural notions of batching and generalize the existing frameworks of IOPPs and reductions of knowledge. In this work, we show that given a pair of non-interactive reductions matching a particular form, we can naturally construct a corresponding non-interactive argument and accumulation scheme for that non-interactive argument. We state this more clearly in the following informal theorem.</p>

    <p class="text-gray-300">Theorem 2.2 (informal). Let  <span class="math">\\mathcal{R}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span>  be indexed relations. Suppose that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  is a non-interactive reduction from  <span class="math">\\mathcal{R}</span>  to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> .</li>

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span>  is a non-interactive reduction from  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^{*}</span>  to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> .</li>

    </ul>

    <p class="text-gray-300">Then there exists a non-interactive argument ARG for  <span class="math">\\mathcal{R}</span>  and an accumulation scheme ACC for ARG.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">Intuitively, the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  casts a member  <span class="math">(\\mathbb{X},\\mathbb{W})</span>  of relation  <span class="math">\\mathcal{R}</span>  into a member (acc.  <span class="math">\\mathbb{X}</span> , acc.  <span class="math">\\mathbb{W}</span> ) in the accumulator relation  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . While the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span> , folds together multiple members (acc.  <span class="math">\\mathbb{X}</span> , acc.  <span class="math">\\mathbb{W}</span> ) of the accumulator relation into a single instance (acc.  <span class="math">\\mathbb{X}</span> , acc.  <span class="math">\\mathbb{W}</span> ). An initial observation is that the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  closely matches the shape of a non-interaction argument  <span class="math">\\mathsf{ARG} = (\\mathcal{P},\\mathcal{V})</span> . The argument prover and verifier can internally run the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  to derive a new accumulator instance and witness. The prover can send, along with the reduction proof, the new accumulator witness and the verifier can check if the new accumulator belongs to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . This immediately gives us an argument for relation  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">All that remains to be shown is how to construct an accumulation scheme for ARG. Naturally, the argument proof  <span class="math">\\pi</span>  can be partition into  <span class="math">(\\pi .\\mathbb{X},\\pi .\\mathbb{W})\\coloneqq (\\pi_{\\mathrm{CAST}},\\mathrm{acc}.w)</span> . By design, we now have that the accumulation predicate instance  <span class="math">(\\mathbb{X},\\pi .\\mathbb{X})</span>  is exactly the input to the reduction verifier  <span class="math">\\mathrm{RDX}_{\\mathrm{CAST}}</span> . Thus, given  <span class="math">m</span>  accumulator instances and  <span class="math">n</span>  predicate instances, the accumulation prover and verifier can symmetrically run  <span class="math">\\nu_{\\mathrm{CAST}}</span>  to derive  <span class="math">m + n</span>  accumulator instances.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Now, the accumulation prover can run the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span>  to derive the output accumulator acc  <span class="math">\\leftarrow</span>  (acc.x, acc.w) which folds together the  <span class="math">m + n</span>  accumulators and produce an accumulation proof pf  <span class="math">\\leftarrow \\pi_{\\mathsf{FOLD}}</span> . The accumulation verifier just has to check this new accumulator instance acc.x is identical to what is derived</p>

    <p class="text-gray-300">by running the reduction verifier <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span>. Finally, the accumulation decider just checks if an accumulator <span class="math">\\mathsf{acc}:=(\\mathsf{acc.}\\neq,\\mathsf{acc.}\\neq)</span> belongs to <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>. We treat this discussion formally in Theorem 4.3 and provide the corresponding argument <span class="math">\\mathsf{ARG}</span> and accumulation scheme <span class="math">\\mathsf{ACC}</span> in Construction A.4 and Construction A.6.</p>

    <p class="text-gray-300">From Reductions to Proof Carrying Data and IVC. What we just described is a method to construct accumulation from non-interactive reductions. In prior works <em>[x10, x11]</em>, accumulation schemes for non-interactive arguments can be transformed into IVC and PCD schemes, assuming the non-interactive argument is for an NP-complete relation and the circuit description of the accumulation verifier is succinct (Theorem 5.3 in <em>[x10]</em>). In our construction, these requirements translate to whether the relation <span class="math">\\mathcal{R}</span> is NP-complete and if the reduction verifiers <span class="math">\\mathcal{V}_{\\mathsf{CAST}}</span> and <span class="math">\\mathcal{V}_{\\mathsf{FOLD}}</span> are succinct.</p>

    <p class="text-gray-300">While the PCD construction naturally follows from prior work, the security analysis must be slightly tweaked when considering promise relations, which have both strict and relaxed relations, <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> and <span class="math">\\bar{\\mathcal{R}}_{\\mathsf{ACC}}</span> respectively. In particular, the knowledge soundness of both the argument <span class="math">\\mathsf{ARG}</span> and accumulation scheme <span class="math">\\mathsf{ACC}</span> hold with respect to a relaxed verifier and decider, <span class="math">\\tilde{\\mathcal{V}}</span> and <span class="math">\\tilde{\\mathsf{D}}</span>, which check that an accumulator belongs to the relaxed relation <span class="math">\\bar{\\mathcal{R}}_{\\mathsf{ACC}}</span>, while in the construction they check pairs belong to the strict relation <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>. We observe that the knowledge soundness proof of the PCD construction (Theorem 5.3 in <em>[x10]</em>) can be immediately adapted by replacing the verifier and decider with their relaxed variants. Alternatively, we can also adapt the proof in <em>[x12]</em> which shows how to construct PCD from bounded-depth accumulation. Unlike our work, which has one relaxed verifier and decider, they have a different relaxed verifier and decider for each recursive extraction, up to some depth-bound <span class="math">s\\in\\mathbb{N}</span>. In our setting, we would just maintain the same relaxed verifier and decider regardless of the extraction depth.</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Strings and words.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an alphabet <span class="math">\\Sigma</span>, a string <span class="math">s\\in\\Sigma^{*}</span> is a tuple of characters in the alphabet. For a finite set <span class="math">S</span>, a word <span class="math">w:S\\to\\Sigma</span> is a function mapping elements of <span class="math">S</span> to characters in <span class="math">\\Sigma</span>. These objects are somewhat interchangeable; a string <span class="math">s\\in\\Sigma^{n}</span> can be viewed as a word over the set of indices <span class="math">[n]</span>, and a word <span class="math">w:S\\to\\Sigma</span> can be viewed as a string of length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (assuming </span>S$ has a fixed ordering).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Restrictions.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a string <span class="math">s\\in\\Sigma^{n}</span> and subset of indices <span class="math">I\\subseteq[n]</span>, the restriction $s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}:I\\to\\Sigma<span class="math"> is defined to be </span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}(i)=s(i)<span class="math">. Alternatively, we can treat </span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> as a string of length </span>n<span class="math"> over an augmented alphabet </span>\\Sigma\\sqcup\\{\\bot\\}<span class="math">, where the </span>i<span class="math">-th character of </span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> is </span>s(i)<span class="math"> if </span>i\\in I<span class="math">, and </span>\\bot$ otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Hamming distance.</h4>

    <p class="text-gray-300">For an alphabet <span class="math">\\Sigma</span>, the relative Hamming distance between two strings <span class="math">s,s^{\\prime}:s\\in\\Sigma^{n}</span>, denoted <span class="math">\\Delta(s,s^{\\prime})</span>, is the number of locations where <span class="math">s</span> and <span class="math">s^{\\prime}</span> disagree, divided by <span class="math">n</span>. For a set of strings <span class="math">S\\in\\Sigma^{n}</span>, we define <span class="math">\\Delta(s,S):=\\min_{s^{\\prime}\\in S}\\Delta(s,s^{\\prime})</span>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Polynomials.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a field <span class="math">\\mathbb{F}</span>, let <span class="math">\\mathbb{F}^{&lt;d}[X]</span> denote the set of univariate polynomials over <span class="math">\\mathbb{F}</span> of degree less than <span class="math">d</span>. For a set <span class="math">S\\subset\\mathbb{F}</span>, the vanishing polynomial <span class="math">V_{S}(X):=\\prod_{a\\in S}(X-a)</span> is the unique non-zero polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero on </span>S<span class="math">. For an element </span>a\\in S<span class="math">, let </span>L_{a,S}<span class="math"> denote the unique Lagrange polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>L_{a,S}(a)=1<span class="math"> and </span>L_{a,S}(b)=0<span class="math"> for all </span>b\\in S\\setminus\\{a\\}<span class="math">. For a function </span>f:S\\to\\mathbb{F}<span class="math">, let </span>\\hat{f}<span class="math"> denote the unique extension polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>\\hat{f}(a)=f(a)<span class="math"> for all </span>a\\in S<span class="math">, i.e., </span>\\hat{f}(X):=\\sum_{a\\in S}f(a)\\cdot L_{a,S}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Polynomial quotients.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a field <span class="math">\\mathbb{F}</span>, polynomial <span class="math">p\\in\\mathbb{F}^{&lt;d}[X]</span>, and set <span class="math">S\\subset\\mathbb{F}</span>, the polynomial quotient $\\mathsf{PolyQuotient}(p,S)\\in\\mathbb{F}^{<d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]$ is defined to be</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{PolyQuotient}(p,S)(x):=\\frac{p(x)-r(x)}{V_{S}(x)},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">r</span> is the unique polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>r(a)=p(a)<span class="math"> for all </span>a\\in S<span class="math"> (in other words, </span>r<span class="math"> is the extension of the restriction of </span>p<span class="math"> to </span>S$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Random oracles.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathcal{U}(\\lambda)</span> denote the uniform distribution of functions that map <span class="math">\\{0,1\\}^{<em>}</span> to <span class="math">\\{0,1\\}^{\\lambda}</span>. A </em>random oracle<em> is a function <span class="math">\\rho:\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\lambda}</span> sampled from <span class="math">\\mathcal{U}(\\lambda)</span>. Our constructions will often use multiple random oracles of varying output sizes; these can be derived from a single random oracle via <em>domain extension</em> and <em>output extension</em>. For more discussion, see <em>[x10, Section 2.6]</em>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Relations</h3>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Indexed relations.</h4>

    <p class="text-gray-300">An <em>indexed relation</em> <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">\\{(\\mathbb{I},\\mathbb{z},\\mathbb{w})\\}</span> where <span class="math">\\mathbb{I}</span> is the index, <span class="math">\\mathbb{z}</span> is the instance, and <span class="math">\\mathbb{w}</span> is the witness; the corresponding <em>indexed language</em> <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set of pairs <span class="math">(\\mathbb{I},\\mathbb{z})</span> for which there exists a witness <span class="math">\\mathbb{w}</span> such that <span class="math">(\\mathbb{I},\\mathbb{z},\\mathbb{w})\\in\\mathcal{R}</span>. For example, the indexed relation of satisfiable boolean circuits consists of triples where <span class="math">\\mathbb{I}</span> is the description of a boolean circuit, <span class="math">\\mathbb{z}</span> is a partial assignment to its input wires, and <span class="math">\\mathbb{w}</span> is an assignment to the remaining wires that makes the circuit output 1.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Parameterized relations and R1CS.</h4>

    <p class="text-gray-300">A <em>parameterized relation</em> <span class="math">\\mathcal{R}</span> over a (typically implicit) parameter space <span class="math">\\mathbb{P}</span> is a set of relations <span class="math">\\{\\mathcal{R}(\\mathbb{p}):\\mathbb{p}\\in\\mathbb{P}\\}</span>. The R1CS relation is parameterized by a finite field <span class="math">\\mathbb{F}</span>; <span class="math">\\mathcal{R}_{\\mathtt{R1CS}}(\\mathbb{F})</span> consists of triples <span class="math">(\\mathbb{I},\\mathbb{z},\\mathbb{w})=((A,B,C,n),x,w)</span> where <span class="math">A,B,C</span> are <span class="math">M\\times N</span> matrices over <span class="math">\\mathbb{F}</span>, <span class="math">x\\in\\mathbb{F}^{n}</span>, and <span class="math">w\\in\\mathbb{F}^{N-n}</span> such that <span class="math">Az\\circ Bz=Cz</span> for <span class="math">z:=(x,w)</span>.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Relations relative to a random oracle.</h4>

    <p class="text-gray-300">A <em>relation relative to a random oracle</em>, denoted <span class="math">\\mathcal{R}^{\\mathcal{U}}</span>, is a set of relations <span class="math">\\{\\mathcal{R}^{\\rho}:\\rho\\in\\mathrm{supp}(\\mathcal{U})\\}</span>, where <span class="math">\\mathrm{supp}(\\mathcal{U})</span> denotes <span class="math">\\bigcup_{\\lambda\\in\\mathbb{N}}\\mathrm{supp}(\\mathcal{U}(\\lambda))</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">Promise relations. Some proof systems exhibit a gap between completeness and soundness, i.e., completeness holds for a relation <span class="math">\\mathcal{R}</span>, but soundness only guarantees membership in a superset relation <span class="math">\\tilde{\\mathcal{R}} \\supseteq \\mathcal{R}</span>. In this case it is useful to describe <span class="math">\\mathcal{R}</span> as a promise relation, where soundness holds for the associated relaxed relation <span class="math">\\tilde{\\mathcal{R}}</span>.</p>

    <p class="text-gray-300">Putting it all together. A parameterized indexed promise relation <span class="math">\\mathcal{R}^{\\mathcal{U}}</span> (over parameter space <span class="math">\\mathbb{P}</span>, relative to a random oracle) is a set of indexed promise relations <span class="math">\\{(\\mathcal{R}^{\\rho}(\\mathbb{p}),\\tilde{\\mathcal{R}}^{\\rho}(\\mathbb{p})):\\mathbb{p}\\in \\mathbb{P},\\rho \\in \\operatorname {supp}(\\mathcal{U})\\}</span> such that <span class="math">\\mathcal{R}^{\\rho}(\\mathbb{p})\\subseteq \\tilde{\\mathcal{R}}^{\\rho}(\\mathbb{p})</span>. We say that <span class="math">\\mathcal{R}^{\\mathcal{U}}</span> is in <span class="math">\\mathsf{NP}^{\\mathcal{U}}</span> if and only if there exists a polynomial-time oracle Turing machine <span class="math">M</span> such that for every <span class="math">\\mathbb{p}\\in \\mathbb{P}</span> and <span class="math">\\rho \\in \\operatorname {supp}(\\mathcal{U})</span>, <span class="math">\\mathcal{R}^{\\rho}(\\mathbb{p}) = \\{(\\mathbb{I},\\mathbb{x},\\mathbb{w}):M^{\\rho}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\mathbb{w}) = 1\\}</span>.</p>

    <p class="text-gray-300">Multi-instance relations. Let <span class="math">\\mathcal{R}</span> be an indexed relation. The multi-instance relation is defined to be <span class="math">\\mathcal{R}^* := \\{(\\mathbb{I}, (\\mathbb{x}_1, \\ldots, \\mathbb{x}_m), (\\mathbb{w}_1, \\ldots, \\mathbb{w}_m)) : \\forall i \\in [m], (\\mathbb{I}, \\mathbb{x}_i, \\mathbb{w}_i) \\in \\mathcal{R}\\}</span>. This notion readily extends to the types of relations described above.</p>

    <h2 id="sec-27" class="text-2xl font-bold">3.2 Reed-Solomon codes</h2>

    <p class="text-gray-300">For a field <span class="math">\\mathbb{F}</span>, evaluation domain <span class="math">\\mathcal{L} \\subset \\mathbb{F}</span>, and degree <span class="math">d \\in \\mathbb{N}</span>, the Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]</span> is the set of words <span class="math">\\mathcal{L} \\to \\mathbb{F}</span> corresponding to polynomials of degree less than <span class="math">d</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d ] := \\{f: \\mathcal {L} \\to \\mathbb {F}: \\hat {f} \\in \\mathbb {F} ^ {&amp;lt;   d} [ X ] \\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The rate of <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> is $\\rho \\coloneqq d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For a codeword </span>f\\in \\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]<span class="math">, let </span>\\vec{f}\\in \\mathbb{F}^d<span class="math"> denote the coefficient vector of </span>\\hat{f}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-28" class="text-2xl font-bold">3.2.1 Rational constraints</h2>

    <p class="text-gray-300">Definition 3.1. A rational function <span class="math">\\mathfrak{c} = (p,q)</span> is a pair of arithmetic circuits, <span class="math">p:\\mathbb{F}^{k + 1}\\to \\mathbb{F}</span> and <span class="math">q:\\mathbb{F}\\rightarrow \\mathbb{F}</span>. For an interleaved word <span class="math">\\mathbf{f} = (f_1,\\dots ,f_k)</span>, <span class="math">f_{i}:\\mathcal{L}\\to \\mathbb{F}</span>, we define <span class="math">\\mathfrak{c}(\\mathbf{f}):\\mathcal{L}\\to \\mathbb{F}</span> to be</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {c} (\\mathbf {f}) (x) := \\frac {p (x , f _ {1} (x) , \\ldots , f _ {k} (x))}{q (x)}.</span></div>

    <p class="text-gray-300">A rational constraint consists of a rational function <span class="math">\\mathfrak{c}</span> and a degree bound <span class="math">d \\in \\mathbb{N}</span>. We say that the rational constraint is satisfied with respect to <span class="math">\\mathbf{f}</span> if <span class="math">\\mathfrak{c}(f) \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]</span>.</p>

    <h2 id="sec-29" class="text-2xl font-bold">3.2.2 List decoding</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 3.2. Let <span class="math">f: \\mathcal{L} \\to \\mathbb{F}</span> be a word, <span class="math">d \\in \\mathbb{N}</span> be a degree, and <span class="math">\\gamma \\in (0,1)</span> be a list decoding parameter. We define <span class="math">\\operatorname{List}(f,d,\\gamma) \\coloneqq \\{g \\in \\mathsf{RS}[\\mathbb{F},\\mathcal{L},d] : \\Delta(f,g) \\leq \\gamma\\}</span> to be the set of codewords that are <span class="math">\\gamma</span>-close to <span class="math">f</span>. A Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> is <span class="math">(\\gamma,\\ell)</span>-list decodable if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{List}(f,d,\\gamma)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell<span class="math"> for any word </span>f: \\mathcal{L} \\to \\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 3.3 (Johnson bound). The Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> is <span class="math">(1 - \\sqrt{\\rho} -\\eta ,1 / (2\\eta \\sqrt{\\rho}))</span>-list-decodable for any choice of <span class="math">\\eta \\in (0,1 - \\sqrt{\\rho})</span>, where <span class="math">\\rho</span> is the rate of the code.</p>

    <p class="text-gray-300">Lemma 3.4 ([ACFY24, Lemma 4.5]). Let <span class="math">f: \\mathcal{L} \\to \\mathbb{F}</span> be a word, <span class="math">d \\in \\mathbb{N}</span> be a degree, <span class="math">s \\in \\mathbb{N}</span> be a repetition parameter, and <span class="math">\\gamma \\in (0,1)</span> be a distance parameter. Suppose that <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> is <span class="math">(\\gamma,\\ell)</span>-list decodable. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_ {x _ {1}, \\dots , x _ {s} \\leftarrow \\mathbb {F} \\backslash \\mathcal {L}} [ \\exists u, u ^ {\\prime} \\in \\operatorname {L i s t} (f, d, \\gamma), u \\neq u ^ {\\prime}, \\forall i \\in [ s ], \\hat {u} (x _ {i}) = \\hat {u} ^ {\\prime} (x _ {i}) ] \\\\ \\leq \\left(\\frac {\\ell}{2}\\right) \\cdot \\left(\\frac {d - 1}{\\mathbb {F} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {s} \\leq \\frac {\\ell^ {2}}{2} \\cdot \\left(\\frac {d - 1}{\\mathbb {F} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {s}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">4 Alternatively, a promise relation can be defined as a pair <span class="math">(\\mathcal{R}_{\\mathrm{YES}},\\mathcal{R}_{\\mathrm{NO}})</span>, where completeness holds for <span class="math">\\mathcal{R}_{\\mathrm{YES}}</span> and soundness holds for the complement of <span class="math">\\mathcal{R}_{\\mathrm{NO}}</span>.</p>

    <p class="text-gray-300">16</p>

    <h2 id="sec-30" class="text-2xl font-bold">3.2.3 Quotients</h2>

    <p class="text-gray-300"><strong>Definition 3.5</strong> ([ACFY24, Definition 4.2]). Let <span class="math">f: \\mathcal{L} \\to \\mathbb{F}</span> be a word, <span class="math">S \\subset \\mathbb{F}</span> be a set, <span class="math">\\operatorname{Ans}: S \\to \\mathbb{F}</span> be a function, and <span class="math">\\operatorname{Fill}: S \\cap \\mathcal{L} \\to \\mathbb{F}</span> be a function. We define <span class="math">\\operatorname{Quotient}(f, S, \\operatorname{Ans}, \\operatorname{Fill}): \\mathcal{L} \\to \\mathbb{F}</span> to be</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Quotient}(f, S, \\operatorname{Ans}, \\operatorname{Fill})(x) := \\begin{cases} \\operatorname{Fill}(x) &amp;amp; x \\in S \\\\ \\frac{f(x) - \\operatorname{Ans}(x)}{V_S(x)} &amp;amp; x \\notin S. \\end{cases}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.6</strong> ([ACFY24, Lemma 4.4]). Let <span class="math">f: \\mathcal{L} \\to \\mathbb{F}</span> be a word, <span class="math">d \\in \\mathbb{N}</span> be a degree, <span class="math">\\delta \\in (0,1)</span> be a distance parameter, <span class="math">S \\subset \\mathbb{F}</span> be a subset with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; d<span class="math">, and </span>\\operatorname{Ans}: S \\to \\mathbb{F}<span class="math"> be a function. Suppose that for every </span>u \\in \\operatorname{List}(f,d,\\delta)<span class="math">, there exists </span>x \\in S<span class="math"> such that with </span>\\hat{u}(x) \\neq \\operatorname{Ans}(x)<span class="math">. Then for any choice of </span>\\operatorname{Fill}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(\\operatorname{Quotient}(f, S, \\operatorname{Ans}, \\operatorname{Fill}), \\operatorname{RS}[\\mathbb{F}, \\mathcal{L}, d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]) &gt; \\delta -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S \\cap \\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-31" class="text-2xl font-bold">3.2.4 Proximity gaps</h2>

    <p class="text-gray-300"><strong>Definition 3.7</strong> ([BCIKS23]). Let <span class="math">\\mathbb{F}</span> be a field, <span class="math">d \\in \\mathbb{N}</span> be a degree, <span class="math">\\rho \\in (0,1)</span> be a rate, <span class="math">\\delta \\in (0,1 - \\sqrt{\\rho})</span> be a distance parameter, and <span class="math">m \\in \\mathbb{N}</span> be an arity. The proximity error is defined to be</p>

    <p class="text-gray-300">$$ \\varepsilon_{\\mathrm{prox}}(\\mathbb{F}, d, \\rho, \\delta, m) := \\begin{cases}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{(m-1) \\cdot d}{\\rho \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &amp; \\delta \\in \\left(0, \\frac{1 - \\rho}{2}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{cases} $$</p>

    <p class="text-gray-300"><strong>Definition 3.8</strong> ([ACFY24, Definition 4.11]). Let <span class="math">d_{\\max} \\in \\mathbb{N}</span> be a target degree, <span class="math">r \\in \\mathbb{F}</span> be a field element, <span class="math">f_1, \\ldots, f_m: \\mathcal{L} \\to \\mathbb{F}</span> be words, and <span class="math">d_1, \\ldots, d_m \\in [d_{\\max}]</span> be degrees. We define <span class="math">\\mathrm{Combine}(d_{\\max}, r, (f_1, d_1), \\ldots, (f_m, d_m)): \\mathcal{L} \\to \\mathbb{F}</span> to be</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathrm{Combine}(d_{\\max}, r, (f_1, d_1), \\ldots, (f_m, d_m)) &amp;amp;(x) \\\\ &amp;amp; := \\sum_{i=1}^{m} r_i \\cdot f_i(x) \\cdot \\left( \\sum_{j=0}^{d_{\\max} - d_i} (rx)^j \\right) = \\begin{cases} \\sum_{i=1}^{m} r_i \\cdot f_i(x) \\cdot \\left( \\frac{1 - (rx)^{d_{\\max} - d_i + 1}}{1 - rx} \\right) &amp;amp; rx \\neq 1 \\\\ \\sum_{i=1}^{m} r_i \\cdot f_i(x) \\cdot (d_{\\max} - d_i + 1) &amp;amp; rx = 1. \\end{cases} \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.9</strong> ([ACFY24, Lemma 4.13]). Let <span class="math">d_{\\max} \\in \\mathbb{N}</span> be a target degree, <span class="math">f_1, \\ldots, f_m: \\mathcal{L} \\to \\mathbb{F}</span> be words, <span class="math">d_1, \\ldots, d_m \\in [d_{\\max}]</span> be degrees, and $\\delta \\in (0, 1 - \\sqrt{\\rho} - 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> be a distance parameter, where </span>\\rho := d^*/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. If</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Pr_{r \\leftarrow \\mathbb{F}} \\left[ \\Delta(\\mathrm{Combine}(d_{\\max}, r, (f_1, d_1), \\ldots, (f_m, d_m)), \\mathrm{RS}[\\mathbb{F}, \\mathcal{L}, d_{\\max}]) \\leq \\delta \\right] \\\\ &amp;amp;= \\varepsilon_{\\mathrm{prox}}\\left( d_{\\max}, \\rho, \\delta, m \\cdot (d_{\\max} + 1) - \\sum_{i=1}^{m} d_i \\right), \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then there exists a subset <span class="math">S \\subseteq \\mathcal{L}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (1 - \\delta) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that for all </span>i \\in [m]<span class="math">, there exists a codeword </span>u \\in \\mathrm{RS}[\\mathbb{F}, \\mathcal{L}, d_i]<span class="math"> such that </span>u<span class="math"> agrees with </span>f_i<span class="math"> on </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-32" class="text-2xl font-bold">3.3 Merkle trees</h2>

    <p class="text-gray-300">We recall the definition of Merkle commitments along with some useful security properties from [CY24, Section 18]. The Merkle commitment scheme is a tuple of deterministic polynomial-time oracle algorithms <span class="math">\\mathsf{MT} = (\\mathsf{MT}. \\mathsf{Commit}, \\mathsf{MT}. \\mathsf{Open}, \\mathsf{MT}. \\mathsf{Check})</span> implicitly parameterized by an output size <span class="math">\\sigma \\in \\mathbb{N}</span>, alphabet <span class="math">\\Sigma</span>, and string length <span class="math">\\ell \\in \\mathbb{N}</span>. All algorithms receive query access to a random oracle <span class="math">\\rho_{\\mathsf{MT}} \\in \\mathcal{U}(\\sigma)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MT.Commit receives as input a string <span class="math">m \\in \\Sigma^{\\ell}</span>. It outputs a commitment <span class="math">\\mathsf{cm} \\in \\{0,1\\}^{\\sigma}</span> and a trapdoor <span class="math">\\mathsf{td} \\in \\{0,1\\}^{O(\\sigma \\ell)}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- MT.Open receives as input a trapdoor <span class="math">\\mathsf{td}</span> and subset <span class="math">I \\subseteq [\\ell]</span>. It outputs an opening proof $\\mathsf{pf} \\in \\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\sigma \\log \\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MT.Check receives as input a commitment <span class="math">\\mathsf{cm}</span>, restriction <span class="math">a \\in \\Sigma^I</span>, and opening proof <span class="math">\\mathsf{pf}</span>. It outputs a bit indicating whether or not the opening proof authenticates the restriction with respect to the commitment.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 3.10 (MT is complete).</strong> For every (unbounded) adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf{MT. Check}^{\\rho_{\\mathsf{MT}}}(\\mathsf{cm}, m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}, \\mathsf{pf}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\rho_{\\mathsf{MT}} \\leftarrow \\mathcal{U}(\\sigma) \\\\ (m, I) \\leftarrow \\mathcal{A}^{\\rho_{\\mathsf{MT}}} \\\\ (\\mathsf{cm}, \\mathsf{td}) := \\mathsf{MT. Commit}^{\\rho_{\\mathsf{MT}}}(\\mathsf{td}, I) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Lemma 3.11 (MT is multi-extractable).</strong> There exists a deterministic polynomial-time algorithm MT.MultiExtract such that for every query bound <span class="math">t \\in \\mathbb{N}</span>, <span class="math">t</span>-query adversary <span class="math">\\mathcal{A}</span>, and <span class="math">k \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\exists i \\in [k]: &amp;amp; \\rho_{\\mathsf{MT}} \\leftarrow \\mathcal{U}(\\sigma) \\\\ \\mathsf{MT. Check}^{\\rho_{\\mathsf{MT}}}(\\mathsf{cm}_i, I_i, a_i, \\mathsf{pf}_i) = 1 &amp;amp; (\\mathsf{cm}_i, I_i, a_i, \\mathsf{pf}_i)_{i \\in [k]} \\xleftarrow{\\mathsf{tr}} \\mathcal{A}^{\\rho_{\\mathsf{MT}}} \\\\ m_i[I_i] \\neq a_i &amp;amp; (m_i, \\mathsf{td}_i)_{i \\in [k]} := \\mathsf{MT. MultiExtract}^{\\rho_{\\mathsf{MT}}}((\\mathsf{cm}_i)_{i \\in [k]}, \\mathsf{tr}) \\\\ &amp;amp; \\forall i \\in [k], \\mathsf{pf}_i := \\mathsf{MT. Open}^{\\rho_{\\mathsf{MT}}}(\\mathsf{td}_i, I_i) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_{\\mathsf{MT}}(t, \\sigma, \\ell, k) := \\frac{3}{2} \\cdot \\frac{t^2}{2^{\\sigma}} + \\frac{k \\cdot (\\log \\ell + 1) \\cdot 3t}{2^{\\sigma}}.</span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}_1^{\\mathcal{U}}</span>  and  <span class="math">\\mathcal{R}_2^{\\mathcal{U}}</span>  be parameterized indexed promise relations (relative to a random oracle). A (preprocessing) non-interactive reduction from  <span class="math">\\mathcal{R}_1</span>  to  <span class="math">\\mathcal{R}_2</span>  in the random oracle model is a tuple of polynomial-time algorithms  <span class="math">\\mathrm{RDX} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> , of which  <span class="math">\\mathcal{I}</span> ,  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{V}</span>  have access to the same random oracle, with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The generator  <span class="math">\\mathcal{G}</span>  receives as input a security parameter  <span class="math">\\lambda</span>  (in unary) and outputs public parameters  <span class="math">\\mathsf{pp}</span> .</li>

      <li>The indexer  <span class="math">\\mathcal{I}</span>  is a deterministic algorithm which receives as input public parameters  <span class="math">\\mathsf{pp}</span>  and index  <span class="math">\\mathbb{I}</span> , and outputs a proving key  <span class="math">\\mathsf{pk}</span> , verification key  <span class="math">\\mathsf{vk}</span> , and new index  <span class="math">\\mathbb{I}&#x27;</span> .</li>

      <li>The prover  <span class="math">\\mathcal{P}</span>  receives as input proving key  <span class="math">\\mathsf{pk}</span> , an instance  <span class="math">\\mathbf{x}</span> , and witness  <span class="math">\\mathbf{w}</span> , and outputs a proof  <span class="math">\\pi</span>  and new witness  <span class="math">\\mathbf{w}&#x27;</span> .</li>

      <li>The verifier  <span class="math">\\mathcal{V}</span>  is a deterministic algorithm which receives as input verification key  <span class="math">\\mathsf{vk}</span> , instance  <span class="math">\\mathbf{x}</span> , and proof  <span class="math">\\pi</span> , and outputs a new instance  <span class="math">\\mathbf{x}&#x27;</span> .</li>

    </ul>

    <p class="text-gray-300">Completeness. RDX is complete if the following holds. For every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} _ {1} ^ {\\rho} (\\mathsf {p p}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {x} ^ {\\prime}, \\mathbb {w} ^ {\\prime}) \\in \\mathcal {R} _ {2} ^ {\\rho} (\\mathsf {p p}) &amp;amp; (\\mathsf {p k}, \\mathsf {v k}, \\mathbb {I} ^ {\\prime}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; (\\pi , \\mathbb {w} ^ {\\prime}) \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathsf {p k}, \\mathbb {x}, \\mathbb {w}) \\\\ &amp;amp; \\mathbb {x} ^ {\\prime} \\leftarrow \\mathcal {V} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Straightline knowledge soundness. RDX is straightline knowledge sound (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if the following holds. There exists a deterministic polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that for every (non-uniform) polynomial-time adversary  <span class="math">\\tilde{\\mathcal{P}}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {x} ^ {\\prime}, \\mathbb {w} ^ {\\prime}) \\in \\tilde {\\mathcal {R}} _ {2} ^ {\\rho} (\\mathsf {p p}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (1 ^ {\\lambda}) \\\\ (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} _ {1} ^ {\\rho} (\\mathsf {p p}) &amp;amp; (\\mathbb {I}, \\mathbb {x}, \\pi , \\mathbb {w} ^ {\\prime}; \\mathsf {t r}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {a i}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}, \\mathbb {I} ^ {\\prime}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; \\mathbb {x} ^ {\\prime} \\leftarrow \\mathcal {V} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) \\\\ &amp;amp; \\mathbb {w} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathbb {I}, \\mathbb {x}, \\pi , \\mathbb {w} ^ {\\prime}, \\mathsf {a i}, \\mathsf {t r}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Remark 4.1. We have defined non-interactive reductions for indexed relations in full generality (parameterized, relative to a random oracle, and relaxed soundness). Sometimes, full generality is not required; for example, suppose  <span class="math">\\mathcal{R}</span>  is a parameterized indexed relation. Then soundness should hold for the same relation  <span class="math">\\mathcal{R}</span> , and the random oracle is not considered when testing membership in  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">We construct a non-interactive argument ARG (Definition A.2) for a relation  <span class="math">\\mathcal{R}</span>  and a corresponding accumulation scheme ACC for ARG (Definition A.3) from two non-interactive reductions,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>, a non-interactive reduction from <span class="math">\\mathcal{R}</span> to some relation <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>, and</li>

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span>, a non-interactive reduction from <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^{*}</span> to <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>,</li>

    </ul>

    <p class="text-gray-300">all of which are in the random oracle model. Crucially, to construct Proof-Carrying Data (PCD), prior work <em>[BCMS20, BCLMS21, COS20]</em> requires a non-interactive argument for an NP-complete relation and an accumulation scheme for that argument in <em>the standard model</em>. However, these works only provide secure constructions of such non-interactive arguments and accumulation schemes in the random oracle model. By heuristically instantiating the random oracle with an appropriate hash function, they obtain non-interactive arguments and corresponding accumulation schemes in the standard model with conjectured security (sometimes referred to as <em>heuristic security</em>). This is a well-known limitation of the random oracle methodology <em>[CGH04, GK03]</em>. We can follow the same approach to obtain a non-interactive argument and accumulation scheme in the standard model. Furthermore, these prior works also require that the accumulation verifier is succinct (sublinear, Theorem 5.3 in <em>[BCLMS21]</em>) such that the corresponding circuit description does not increase in size after each recursive step. If the reduction verifier of <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span> and <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span> are succinct, then our constructions will trivially satisfy this requirement. What follows is our formal theorem about the transformation from non-interactive reductions to arguments and accumulation. For brevity, we defer the explicit constructions to Appendix A.2; see Section 2.3 for a high-level overview.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}^{\\mathcal{U}}</span> be a parameterized indexed promise relation. The corresponding <em>multi-instance relation</em> <span class="math">(\\mathcal{R}^{*})^{\\mathcal{U}}</span> is defined to be</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{*}(\\mathbb{p})^{\\rho}:=\\{(\\mathbb{I},(\\mathbb{z}_{1},\\ldots,\\mathbb{z}_{m}),(\\mathbb{w}_{1},\\ldots,\\mathbb{w}_{m})):\\forall i\\in[m],(\\mathbb{I},\\mathbb{z}_{i},\\mathbb{w}_{i})\\in\\mathcal{R}(\\mathbb{p})^{\\rho}\\}.</span></p>

    <p class="text-gray-300">The relaxed relation <span class="math">\\tilde{\\mathcal{R}}^{<em>}(\\mathbb{p})</span> is defined analogously. A </em>many-to-one reduction<em> is a non-interactive reduction from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}^{</em>}</span> which preserves the index: given an index <span class="math">\\mathbb{I}</span>, the indexer <span class="math">\\mathcal{I}</span> outputs the new index <span class="math">\\mathbb{I}^{\\prime}:=\\mathbb{I}</span> (this requirement is necessary for repeatedly composing many-to-one reductions).</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 4.3.</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that the following holds. Let <span class="math">\\mathcal{R}</span> be a parameterized indexed relation. Let <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^{\\mathcal{U}}</span> be a parameterized indexed promise relation in <span class="math">\\mathsf{NP}^{\\mathcal{U}}</span> with the same parameter space as <span class="math">\\mathcal{R}</span>. Suppose we are given the following non-interactive reductions in the random oracle model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}=(\\mathcal{G}_{\\mathsf{CAST}},\\mathcal{I}_{\\mathsf{CAST}},\\mathcal{P}_{\\mathsf{CAST}},\\mathcal{V}_{\\mathsf{CAST}})</span>, a reduction from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>.</li>

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}=(\\mathcal{G}_{\\mathsf{FOLD}},\\mathcal{I}_{\\mathsf{FOLD}},\\mathcal{P}_{\\mathsf{FOLD}},\\mathcal{V}_{\\mathsf{FOLD}})</span>, a many-to-one reduction from <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^{*}</span> to <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> with the same generator algorithm as <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span> (i.e., <span class="math">\\mathcal{G}_{\\mathsf{FOLD}}\\equiv\\mathcal{G}_{\\mathsf{CAST}}</span>).</li>

    </ul>

    <p class="text-gray-300">Then <span class="math">\\mathrm{T}[\\mathsf{RDX}_{\\mathsf{CAST}},\\mathsf{RDX}_{\\mathsf{FOLD}},\\mathcal{R}_{\\mathsf{ACC}}]=(\\mathsf{ARG},\\mathsf{ACC})</span>, where <span class="math">\\mathsf{ARG}</span> is a non-interactive argument for <span class="math">\\mathcal{R}</span> and <span class="math">\\mathsf{ACC}</span> is an accumulation scheme for <span class="math">\\mathsf{ARG}</span>, both in the random oracle model.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We defer the proof to Appendix A. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Interactive oracle reductions</p>

    <p class="text-gray-300">We define <em>interactive oracle reductions</em> (IORs), an information-theoretic proof system that adapts interactive oracle proofs to the language of reductions. Intuitively, an IOR is an interactive reduction where the verifier has oracle access to the prover’s messages and reads a small number of locations to output the new instance. The key novelty, however, is that an IOR verifier may also want to output claims about proof strings <em>without fully reading them</em>.</p>

    <p class="text-gray-300">Formally, we consider <em>indexed oracle relations</em> where the instance is split into a <em>short instance</em> <span class="math">\\vx</span> and a tuple of <em>instance strings</em> <span class="math">\\vec{y}=(\\vy_{1},\\ldots,\\vy_{n})</span> written over some alphabet <span class="math">\\Sigma</span>. For notational convenience, we write <span class="math">(\\mathbb{I},\\vx,\\vec{y},\\vw)\\in\\mathcal{R}</span> to denote membership in an indexed oracle relation. In the relaxed relation <span class="math">\\tilde{\\mathcal{R}}</span>, we allow instance strings to written over an augmented alphabet <span class="math">\\Sigma\\sqcup\\{\\bot\\}</span>; this will be useful when compiling IORs.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.1 Definition</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}^{\\prime}</span> be indexed oracle promise relations. A (public-coin, holographic) interactive oracle reduction from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}^{\\prime}</span> is a tuple of polynomial-time algorithms <span class="math">\\mathsf{IOR}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The indexer <span class="math">\\mathbf{I}</span> is a deterministic algorithm which receives as input an index <span class="math">\\mathbb{I}</span> (for <span class="math">\\mathcal{R}</span>). It outputs a <em>short index</em> <span class="math">\\iota</span>, <em>index string</em> <span class="math">\\mathbb{I}</span>, and new index <span class="math">\\mathbb{I}^{\\prime}</span> (for <span class="math">\\mathcal{R}^{\\prime}</span>).</li>

      <li>The prover <span class="math">\\mathbf{P}</span> is an interactive algorithm which receives as input the index <span class="math">\\mathbb{I}</span>, short instance <span class="math">\\vx</span>, instance strings <span class="math">\\vec{y}</span>, and witness <span class="math">\\vw</span>. It engages in <span class="math">\\mathsf{k}</span> rounds of interaction. In the <span class="math">i</span>-th round, it sends a proof string <span class="math">\\Pi_{i}</span>, then receives a challenge <span class="math">r_{i}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> is an interactive algorithm which receives as input the short index <span class="math">\\iota</span>, short instance <span class="math">\\vx</span>, oracle access to index string <span class="math">\\mathbb{I}</span>, and oracle access to instance strings <span class="math">\\vec{y}</span>. It engages in <span class="math">\\mathsf{k}</span> rounds of interaction. In each round, it receives oracle access to a proof string <span class="math">\\Pi_{i}</span>, then sends a uniformly random challenge <span class="math">r_{i}</span>. At the end of the protocol, it outputs a new instance <span class="math">(\\vx^{\\prime},\\vec{y}^{\\prime})</span>; the new instance oracles are chosen from the old instance oracles or proof oracles received during the interactive protocol.</li>

    </ul>

    <p class="text-gray-300">Without loss of generality, the verifier is split into two phases. In the <em>interaction phase</em>, it samples challenges and sends them to the prover. In the <em>query phase</em>, it queries the index, instance, and proof oracles. The verifier’s output is a deterministic function of its input and the transcript, which we denote</p>

    <p class="text-gray-300"><span class="math">(\\vx^{\\prime},\\vec{y}^{\\prime}):=\\mathbf{V}^{\\mathbb{I},\\vec{y},\\vec{\\Pi}}(\\iota,\\vx,\\vec{r}).</span></p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300"><span class="math">\\mathsf{IOR}</span> is complete if the following holds. For any <span class="math">(\\mathbb{I},\\vx,\\vec{y},\\vw)\\in\\mathcal{R}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[(\\mathbb{I}^{\\prime},\\vx^{\\prime},\\vec{y}^{\\prime},\\vw^{\\prime})\\in\\mathcal{R}^{\\prime}\\ \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ \\begin{array}[]{l}(\\iota,\\mathbb{I},\\mathbb{I}^{\\prime})\\leftarrow\\mathbf{I}(\\mathbb{I})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\vw^{\\prime},(\\vx^{\\prime},\\vec{y}^{\\prime}))\\leftarrow\\langle\\mathbf{P}(\\mathbb{I},\\vx,\\vec{y},\\vw),\\mathbf{V}^{\\mathbb{I},\\vec{y}}(\\iota,\\vx)\\rangle\\end{array}\\ \\right]=1. \\]</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300"><span class="math">\\mathsf{IOR}</span> has soundness error <span class="math">\\varepsilon</span> if the following holds. For any <span class="math">(\\mathbb{I},\\vx,\\vec{y})\\not\\in\\mathcal{L}(\\mathcal{R})</span> and adversary <span class="math">\\tilde{\\mathbf{P}}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[(\\mathbb{I}^{\\prime},\\vx^{\\prime},\\vec{y}^{\\prime},\\vw^{\\prime})\\in\\mathcal{R}^{\\prime}\\ \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ \\begin{array}[]{l}(\\iota,\\mathbb{I},\\mathbb{I}^{\\prime})\\leftarrow\\mathbf{I}(\\mathbb{I})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\vw^{\\prime},(\\vx^{\\prime},\\vec{y}^{\\prime}))\\leftarrow\\langle\\tilde{\\mathbf{P}},\\mathbf{V}^{\\mathbb{I},\\vec{y}}(\\iota,\\vx)\\rangle\\end{array}\\ \\right]\\leq\\varepsilon(\\mathbb{I},\\vx). \\]</p>

    <h5 id="sec-41" class="text-base font-semibold mt-4">Efficiency measures.</h5>

    <p class="text-gray-300">We consider the following efficiency measures (these may be functions of the short index and short instance).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alphabet: <span class="math">\\Sigma</span> is the set of symbols used to write the index, instance, and proof strings.</li>

      <li>Round complexity: <span class="math">k</span> is the number of back-and-forth interactions in the protocol.</li>

      <li>Proof length: <span class="math">L^{\\Sigma}</span> is the length of the index string, <span class="math">L^{\\gamma}_{j}</span> is the length of the <span class="math">j</span>-th instance string, and <span class="math">L^{\\rho}_{i}</span> is the length of the <span class="math">i</span>-th proof string. Let <span class="math">L_{\\max}</span> denote the maximum string length.</li>

      <li>Query complexity: the verifier reads <span class="math">q^{\\Sigma}</span> locations from the index string, <span class="math">q^{\\gamma}_{j}</span> locations from the <span class="math">j</span>-th instance string, and <span class="math">q^{\\rho}_{i}</span> locations from the <span class="math">i</span>-th proof string. Let <span class="math">q</span> denote the total number of queries.</li>

      <li>Randomness: <span class="math">r_{i}</span> is the number of bits in the <span class="math">i</span>-th challenge sent by the verifier.</li>

    </ul>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">Parameterized reductions.</h3>

    <p class="text-gray-300">We often parameterize reductions, e.g., by a security parameter. Formally, the prover and indexer will additionally receive as input some parameters <span class="math">\\mathtt{p}</span>. Completeness must hold for any choice of parameters, and the soundness error is allowed to be a function of the parameters (in addition to the index and short instance).</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 5.1 (non-oracle messages).</h6>

    <p class="text-gray-300">In our constructions, the prover sometimes sends non-oracle messages in the sense that the verifier reads the entire message (and hence oracle access is unnecessary). We do not include this in the IOR definition, but it is straightforward to do so. As an efficiency measure, let <span class="math">s</span> denote the total size (in bits) of the non-oracle messages.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 5.2 (oracle selection).</h6>

    <p class="text-gray-300">When the verifier outputs new instance oracles <span class="math">\\vec{y}^{\\prime}=(\\mathsf{y}^{\\prime}_{1},\\ldots,\\mathsf{y}^{\\prime}_{\\mathsf{n}^{\\prime}})</span>, this should not blow up its runtime or query complexity. We can formalize this by having the verifier output a tuple of indices <span class="math">\\vec{s}=(s_{1},\\ldots,s_{\\mathsf{n}^{\\prime}})</span>, <span class="math">s_{j}\\in[\\mathsf{n}+\\mathsf{k}]</span>, which “select” from the old instance and proof oracles. In particular, the <span class="math">j</span>-th new instance string will be <span class="math">\\mathsf{y}^{\\prime}_{j}:=\\mathsf{Select}(\\vec{y},\\Pi,s_{j})</span>, where</p>

    <p class="text-gray-300">\\[ \\mathsf{Select}(\\vec{y},\\vec{\\Pi},s):=\\begin{cases}\\mathsf{y}_{s}&1\\leq s\\leq\\mathsf{n}\\\\ \\Pi_{s-\\mathsf{n}}&\\mathsf{n}<s\\leq\\mathsf{n}+\\mathsf{k}.\\end{cases} \\]</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.2 Round-by-round soundness</h3>

    <p class="text-gray-300">We define round-by-round soundness and knowledge. These are stronger notions of soundness that allow us to transform IORs into non-interactive reductions.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 5.3.</h6>

    <p class="text-gray-300">A state function for <span class="math">\\mathsf{IOR}</span> is a function <span class="math">\\mathsf{State}</span> for which the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Empty transcript: <span class="math">\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\varnothing)=0</span> unconditionally, where <span class="math">\\varnothing</span> denotes the empty transcript.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover moves: If <span class="math">\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\tau)=0</span> for a partial transcript <span class="math">\\tau=(\\Pi_{1},r_{i},\\ldots,\\Pi_{i-1},r_{i-1})</span>, <span class="math">i\\in[\\mathsf{k}]</span>, where the prover is about to move, then for any prover message <span class="math">\\Pi_{i}\\in L_{\\mathsf{p},i}</span>, $\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{i})=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Full transcript: If <span class="math">\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\tau)=0</span> for a full transcript <span class="math">\\tau=(\\Pi_{1},r_{1},\\ldots,\\Pi_{\\mathsf{k}},r_{\\mathsf{k}})</span>, then the verifier outputs <span class="math">(\\mathtt{z}^{\\prime},\\vec{y}^{\\prime}):=\\mathbf{V}^{\\mathbb{I},\\vec{y},\\vec{\\Pi}}(\\iota,\\mathtt{z},\\vec{r})</span> such that <span class="math">(\\mathbb{I}^{\\prime},\\mathtt{z}^{\\prime},\\vec{y}^{\\prime})\\not\\in\\mathcal{L}(\\tilde{\\mathcal{R}}^{\\prime})</span> (where <span class="math">(\\iota,\\mathbb{I},\\mathbb{I}^{\\prime}):=\\mathbf{I}(\\mathtt{p},\\mathbb{I})</span>).</li>

    </ul>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 5.4.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{IOR}</span> has round-by-round soundness error <span class="math">\\varepsilon_{\\mathtt{rbr}}</span> if there exists a state function <span class="math">\\mathsf{State}</span> such that the following holds. If <span class="math">\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\tau)=0</span> for <span class="math">(\\mathbb{I},\\mathtt{z},\\vec{y})\\not\\in\\mathcal{L}(\\mathcal{R})</span> and a partial transcript <span class="math">\\tau=(\\Pi_{1},r_{1},\\ldots,\\Pi_{i})</span>, <span class="math">i\\in[\\mathsf{k}]</span>, where the verifier is about to move, then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r_{i}\\leftarrow\\{0,1\\}^{r_{i}}}[\\mathsf{State}(\\mathtt{p},\\mathbb{I},\\mathtt{z},\\vec{y},\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})=1]\\leq\\varepsilon_{\\mathtt{rbr}}(\\mathtt{p},\\mathbb{I},\\mathtt{z}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 5.5. IOR has round-by-round knowledge error <span class="math">\\kappa_{\\mathsf{rbr}}</span> if there exists a state function State and polynomial-time extractor <span class="math">\\mathbf{E}</span> such that the following holds. If <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\tau)=0</span> for a partial transcript <span class="math">\\tau=(\\Pi_{1},r_{1},\\ldots,\\Pi_{i})</span>, <span class="math">i\\in[\\mathsf{k}]</span>, where the verifier is about to move, then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r_{i}\\leftarrow\\{0,1\\}^{r_{i}}}[\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})=1]>\\kappa_{\\mathsf{rbr}}(\\mathbb{p},\\mathbb{I},\\mathbb{z})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">implies the following. For any transcript continuation <span class="math">(\\Pi_{i+1},\\ldots,\\Pi_{m},\\mathbb{w}^{\\prime})</span>, the extractor outputs <span class="math">\\mathbb{w}\\leftarrow\\mathbf{E}(\\mathbb{p},\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\vec{\\Pi},\\mathbb{w}^{\\prime})</span> such that <span class="math">(\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\mathbb{w})\\in\\tilde{\\mathcal{R}}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 5.6 (limitations of round-by-round knowledge).</h6>

    <p class="text-gray-300">Definition 5.5 is unsatisfactory in the sense that the extractor cannot meaningfully take advantage of the new witness to extract the old witness. It nevertheless suffices because in our constructions, either (a) the prover sends the witness in one shot; or (b) the relation has empty witnesses (hence, round-by-round soundness trivially implies round-by-round knowledge).</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">5.3 Non-interactive reductions from IORs</h3>

    <p class="text-gray-300">We show how to transform IORs into non-interactive reductions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Definition 5.7 we define committed relations. Informally, given an oracle relation <span class="math">\\mathcal{R}</span>, the committed relation <span class="math">\\mathsf{Com}[\\mathcal{R}]</span> replaces instance strings with Merkle commitments and adds trapdoors Merkle authentication paths to the witness.</li>

      <li>In Definition 5.8 we define monotone relations. This is a minor technical detail which is required for the transformation to preserve soundness; informally, it ensures that a cheating non-interactive prover cannot gain an advantage by withholding Merkle authentication paths from the new witness. All relations considered in this work are monotone.</li>

      <li>In Theorem 5.9 we give a formal theorem statement for transforming IORs into non-interactive reductions. This is essentially the BCS transformation (with preprocessing), except we also need to handle instance oracles.</li>

    </ul>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 5.7.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be an indexed oracle promise relation and <span class="math">S</span> be a parameterized set. The <em>committed relation</em> <span class="math">\\mathsf{Com}[\\mathcal{R},S]=\\mathcal{S}^{\\mathcal{U}}</span> is the parameterized indexed promise relation (relative to a random oracle) defined below.</p>

    <p class="text-gray-300">\\[ \\mathcal{S}^{\\rho}(\\mathbb{p}):=\\left\\{(\\mathbb{I},(\\mathbb{z},\\mathsf{cn}\\!,\\!,\\!(\\mathbb{w},\\vec{\\gamma},\\mathsf{td}\\!)):\\begin{array}[]{l}(\\mathbb{I},\\mathbb{z})\\in S(\\mathbb{p})\\\\ (\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\mathbb{w})\\in\\mathcal{R}(\\mathbb{p})\\\\ \\forall j\\in[\\mathsf{n}],\\mathsf{MT}.{\\mathsf{Commit}}^{\\rho_{\\mathsf{MT}}}(\\mathbb{y}_{j})=(\\mathsf{cm}_{j},\\mathsf{td}_{j})\\end{array}\\right\\} \\] \\[ \\tilde{\\mathcal{S}}^{\\rho}(\\mathbb{p}):=\\left\\{(\\mathbb{I},\\mathbb{z},\\mathsf{cn}\\!,\\!(\\mathbb{w},\\vec{\\gamma},\\mathsf{td}\\!)):\\begin{array}[]{l}(\\mathbb{I},\\mathbb{z})\\in S(\\mathbb{p})\\\\ (\\mathbb{I},\\mathbb{z},\\vec{\\gamma},\\mathbb{w})\\in\\tilde{\\mathcal{R}}(\\mathbb{p})\\\\ \\forall j\\in[\\mathsf{n}]:\\\\ \\mathsf{pf}_{j}:=\\mathsf{MT}.{\\mathsf{Open}}^{\\rho_{\\mathsf{MT}}}(\\mathsf{td}_{j},\\mathsf{Dom}\\,\\mathbb{y}_{j})\\\\ \\mathsf{MT}.{\\mathsf{Check}}^{\\rho_{\\mathsf{MT}}}(\\mathsf{cm}_{j},\\mathbb{y}_{j},\\mathsf{pf}_{j})=1\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Above, <span class="math">\\rho_{\\mathsf{MT}}</span> is a random oracle in <span class="math">\\mathcal{U}(\\sigma)</span> derived from <span class="math">\\rho</span>. Observe that if <span class="math">\\mathcal{R}</span> is in <span class="math">\\mathsf{NP}</span> and <span class="math">S</span> is efficiently computable, then <span class="math">\\mathcal{S}^{\\mathcal{U}}</span> is in <span class="math">\\mathsf{NP}^{\\mathcal{U}}</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 5.8. We say that an indexed oracle promise relation <span class="math">\\mathcal{R}</span> is monotone if the relaxed relation <span class="math">\\tilde{\\mathcal{R}}</span> satisfies the following property. Suppose <span class="math">(\\mathbb{I},\\mathbb{x},\\vec{y}) \\notin \\mathcal{L}(\\tilde{\\mathcal{R}})</span> with <span class="math">\\mathbb{y}_j: I_j \\to \\Sigma</span> (recall that a string written over <span class="math">\\Sigma \\sqcup \\{\\bot\\}</span> can be interpreted as a restriction to a subset of indices). Then $(\\mathbb{I},\\mathbb{x}, (\\mathbb{y}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{A_1}, \\ldots, \\mathbb{y}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{A_n})) \\notin \\mathcal{L}(\\tilde{\\mathcal{R}})<span class="math"> for all subsets </span>A_1, \\ldots, A_n<span class="math"> with </span>A_j \\subseteq I_j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 5.9. There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that the following holds. Let <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}&#x27;</span> be indexed promise relations (with strings). Let <span class="math">S</span> and <span class="math">S&#x27;</span> be efficiently computable sets parameterized by <span class="math">\\lambda \\in \\mathbb{N}</span>. Let <span class="math">\\mathrm{IOR}</span> be an interactive oracle reduction (also parameterized by <span class="math">\\lambda</span>) from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}&#x27;</span> such that the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IOR has round-by-round knowledge error <span class="math">\\kappa_{\\mathrm{rbr}}</span> such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\max_{\\substack{\\mathbb{I},\\mathbb{x}\\in S(\\lambda)\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda)}}\\kappa_{\\mathrm{rbr}}(\\lambda ,\\mathbb{I},\\mathbb{x}) = \\operatorname {negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every parameter <span class="math">\\lambda \\in \\mathbb{N}</span> and index <span class="math">\\mathbb{I} \\in S(\\lambda)</span>, the IOR indexer outputs a new index <span class="math">\\mathbb{I}&#x27; \\in S&#x27;(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">Then <span class="math">\\mathrm{T}[\\mathrm{IOR}]</span> is a non-interactive reduction from <span class="math">\\mathrm{Com}[\\mathcal{R}, S]</span> to <span class="math">\\mathrm{Com}[\\mathcal{R}&#x27;, S&#x27;]</span> with the following efficiency measures:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: $O(\\lambda \\cdot \\mathsf{k} + \\mathsf{s} + \\mathsf{q} \\cdot (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\lambda \\cdot \\log \\mathsf{L}_{\\max}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier complexity: IOR verifier, plus <span class="math">O(\\mathsf{k} + \\mathsf{q} \\cdot \\log \\mathsf{L}_{\\max})</span> queries to the random oracle.</li>

    </ul>

    <p class="text-gray-300">Proof. We defer the proof to Appendix B.</p>

    <p class="text-gray-300">We describe a many-to-one reduction for Reed-Solomon proximity claims. Intuitively, a proximity claim consists of a rational constraint  <span class="math">(\\mathfrak{c},d)</span>  and interleaved word  <span class="math">\\mathbf{f} = (f_1,\\dots ,f_k)</span>  such that  <span class="math">\\mathfrak{c}(\\mathbf{f})</span>  is  <span class="math">\\delta</span> -close to  <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> . For completeness, we require that  <span class="math">\\mathfrak{c}(\\mathbf{f})</span>  is an exact codeword.</p>

    <p class="text-gray-300">Definition 6.1 (Reed-Solomon proximity relation). The index consists of the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Description of a finite field  <span class="math">\\mathbb{F}</span>  and evaluation domain  <span class="math">\\mathcal{L} \\subset \\mathbb{F}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Maximum degree parameter  <span class="math">d_{\\max} \\in \\mathbb{N}</span> ,  $d_{\\max} &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Define  </span>\\rho := (d_{\\max} + 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to be the rate of the corresponding Reed-Solomon code  </span>\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d_{\\max}]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Distance parameter  <span class="math">\\delta \\in (0,1)</span> .</li>

    </ul>

    <p class="text-gray-300">The instance is a rational constraint  <span class="math">(\\mathfrak{c},d)</span> , where  <span class="math">d\\leq d_{\\max}</span> . The instance oracles  <span class="math">\\mathbf{f} = (f_1,\\dots ,f_k)</span>  are words  <span class="math">f_{i}:\\mathcal{L}\\to \\mathbb{F}</span> , collectively interpreted as an interleaved word in  <span class="math">(\\mathbb{F}^k)^\\mathcal{L}</span> . The witness is empty. We define the indexed promise relation  <span class="math">\\mathcal{R}_{\\mathrm{RS}}</span>  below.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {R S}} := \\left\\{\\left(\\mathbb {I}, (\\mathfrak {c}, d), \\mathbf {f}, \\bot\\right): \\mathfrak {c} (\\mathbf {f}) \\in \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d ] \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\mathcal {R}} _ {\\mathrm {R S}} := \\left\\{\\left(\\mathbb {I}, (\\mathfrak {c}, d), \\mathbf {f}, \\bot\\right): \\Delta \\left(\\mathfrak {c} (\\mathbf {f}), \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d ]\\right) \\leq \\delta \\right\\}</span></div>

    <p class="text-gray-300">Theorem 6.2. Consider a security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> . Assume the index and instance are such that the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda} \\cdot 10^{7} \\cdot m \\cdot d_{\\max}^{3} \\cdot \\rho^{-3.5}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then Construction 6.3, when instantiated with parameters  <span class="math">s = 1</span>  and  <span class="math">t = \\frac{\\lambda}{-\\log(1 - \\delta)}</span> , is an interactive oracle reduction from  <span class="math">\\mathcal{R}_{\\mathrm{RS}}^*</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{RS}}</span>  with round-by-round soundness error  <span class="math">2^{-\\lambda}</span>  and the following efficiency measures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alphabet:  <span class="math">\\mathbb{F}</span> .</li>

      <li>Round complexity: 3. The verifier sends the first message.</li>

      <li>Query complexity:  <span class="math">t \\cdot \\sum_{i=1}^{m} k_i</span> , where  <span class="math">k_i</span>  is the number of oracles in the  <span class="math">i</span> -th instance.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof length:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ t + 1$  field elements.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Verifier time:  $O\\left( {t \\cdot  {\\sum }_{i = 1}^{m}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">{\\mathfrak{c}}_{i}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right)$  field operations.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the size of the new instance is independent of the size of the old instance.</p>

    <p class="text-gray-300">Proof. Follows from instantiating Construction 6.3 with  <span class="math">s \\coloneqq 1</span>  and  <span class="math">t \\coloneqq \\frac{\\lambda}{-\\log(1 - \\delta)}</span> , by Lemma 6.4 and Lemma 6.5.</p>

    <p class="text-gray-300">Soundness. We analyze the soundness error given the defined size of  <span class="math">\\mathbb{F}</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For  <span class="math">d_j \\geq 1</span>  we have that  $\\varepsilon_{\\mathrm{prox}}(d_{\\max}, \\rho, \\delta, m \\cdot (d_{\\max} + 1) - \\sum_{j=1}^{m} d_j) \\leq \\varepsilon_{\\mathrm{prox}}(d_{\\max}, \\rho, \\delta, m \\cdot d_{\\max}) \\leq \\frac{m \\cdot d_{\\max}^3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (\\frac{\\sqrt{\\rho}}{10})^\\tau}$  (Lemma 3.7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell \\leq \\frac{1}{2 \\cdot \\frac{\\sqrt{\\rho}}{20} \\cdot \\sqrt{\\rho}} = \\frac{1}{\\rho / 10}</span>  (By Theorem 3.3)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\varepsilon_{\\mathrm{ood}} = \\frac{\\ell^2}{2} \\cdot \\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda} \\cdot 100 \\cdot d_{\\max} \\cdot \\rho^{-2}<span class="math">  we have that  </span>\\varepsilon_{\\mathrm{odd}} \\leq 2^{-\\lambda}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(1 - \\delta)^{t} \\leq (1 - \\delta)^{\\frac{\\lambda}{-\\log(1 - \\delta)}} = 2^{-\\lambda}</span></li>

    </ul>

    <p class="text-gray-300">Since the RBR-soundness error is the max of these errors, we have that, for the chosen parameters, it is bound by  <span class="math">2^{-\\lambda}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The protocol has 3 rounds, 3 prover and 3 verifier messages. The number of oracle queries is  <span class="math">t = \\frac{\\lambda}{-\\log(1 - \\delta)}</span> . The total proof lengths consists of one oracle of length  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and one  </span>\\mathbb{F}<span class="math">  elements, along with Fill of size  </span>t = \\frac{\\lambda}{-\\log(1 - \\delta)}<span class="math"> . The prover&#x27;s runtime is dominated by the computation of  </span>f<span class="math"> , which takes  </span>O(m \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{c}_f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O(m \\cdot t \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  field operations, as well as the computation of Fill. Computing Fill can be done using an FFT and takes  </span>O(d_{\\max} \\cdot \\log d_{\\max})<span class="math">  field operations. See Section 6.3 for an optimization that can significantly reduce the number of FFT operations in a repeated invocation of the accumulation scheme. The verifier needs to evaluate  </span>f'<span class="math">  at  </span>t<span class="math">  positions. Each evaluation requires  </span>O(m \\cdot t)<span class="math">  field operation. The overall runtime is  </span>O(m \\cdot t^2)$  field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe an interactive oracle reduction from  <span class="math">\\mathcal{R}_{\\mathrm{RS}}^{*}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{RS}}</span></p>

    <p class="text-gray-300"><strong>Construction 6.3.</strong> The prover and indexer are parameterized by  <span class="math">\\mathbb{P} = (s,t)</span> , where  <span class="math">s,t\\in \\mathbb{N}</span>  are the out-of-domain and in-domain repetition parameters. On input index  <span class="math">\\mathbb{I}</span> , the indexer  <span class="math">\\mathbf{I}</span>  outputs short index  <span class="math">\\iota \\coloneqq (\\mathbb{I},s,t)</span>  and new index  <span class="math">\\mathbb{I}&#x27;\\coloneqq \\mathbb{I}</span> ; there is no index oracle string. On input instance  <span class="math">\\mathbb{X} = (\\mathfrak{c}_i,d_i)_{i\\in [m]}</span>  and instance oracles  <span class="math">\\vec{\\mathbf{y}} = (\\mathbf{f}_i)_{i\\in [m]}</span> , the prover  <span class="math">\\mathbf{P}(\\mathbb{P},\\mathbb{I},\\mathbb{X},\\vec{\\mathbf{y}})</span>  and verifier  <span class="math">\\mathbf{V}^{\\vec{\\mathbf{y}}}(\\iota ,\\mathbb{X})</span>  engage in the following protocol.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span>  sends  <span class="math">r\\gets \\mathbb{F}</span></li>

      <li><span class="math">\\mathbf{P}</span>  sends  <span class="math">f:\\mathcal{L}\\to \\mathbb{F}</span> . In the honest case,  <span class="math">\\hat{f} := \\mathrm{Combine}(d_{\\max},r,(\\mathfrak{c}_i(\\mathbf{f}_i),d_i)_{i\\in [m]})</span></li>

      <li><span class="math">\\mathbf{V}</span>  sends  <span class="math">x_{1}^{\\mathrm{out}},\\ldots ,x_{s}^{\\mathrm{out}}\\gets \\mathbb{F}\\setminus \\mathcal{L}</span></li>

      <li><span class="math">\\mathbf{P}</span>  sends  <span class="math">y_{1},\\ldots ,y_{s}\\in \\mathbb{F}</span> . In the honest case,  <span class="math">y_{j}\\coloneqq \\hat{f} (x_{j}^{\\mathrm{out}})</span> .</li>

      <li><span class="math">\\mathbf{V}</span>  sends  <span class="math">x_{1}^{\\mathrm{in}},\\ldots ,x_{t}^{\\mathrm{in}}\\gets \\mathcal{L}</span> . Define  <span class="math">S\\coloneqq \\{x_1^{\\mathrm{out}},\\dots,x_s^{\\mathrm{out}},x_1^{\\mathrm{in}},\\dots,x_t^{\\mathrm{in}}\\}</span> .</li>

      <li><span class="math">\\mathbf{P}</span>  sends Fill:  <span class="math">\\{x_j^{\\mathrm{in}}\\}_{j\\in [t]}\\to \\mathbb{F}</span> . In the honest case, Fill := PolyQuotient  <span class="math">(\\hat{f},S)</span> , restricted to  <span class="math">\\{x_j^{\\mathrm{in}}\\}_{j\\in [t]}</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the virtual function  <span class="math">f&#x27; \\coloneqq \\operatorname{Combine}(d_{\\max}, r, (\\mathfrak{c}_i(\\mathbf{f}_i), d_i)_{i \\in [m]})</span> .</li>

      <li>Define  <span class="math">\\mathsf{Ans}: S \\to \\mathbb{F}</span>  such that  <span class="math">\\mathsf{Ans}(x_j^{\\mathrm{out}}) := y_j</span>  and  <span class="math">\\mathsf{Ans}(x_j^{\\mathrm{in}}) := f&#x27;(x_j^{\\mathrm{in}})</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Define the rational function  <span class="math">\\mathfrak{c} := \\operatorname{Quotient}(\\cdot, S, \\operatorname{Ans}, \\operatorname{Fill})</span>  and degree constraint  $d := d_{\\max} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span>  outputs the new instance  <span class="math">\\mathbb{X}&#x27; := (\\mathfrak{c}, d)</span>  and instance oracle  <span class="math">\\mathbb{Y}&#x27; := f</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Since each  <span class="math">\\mathfrak{c}_i(\\mathbf{f}_i)</span>  is a codeword in  <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_i]</span> , the combination  <span class="math">f^{\\prime}</span>  is a codeword in  <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}]</span> . The prover computes  <span class="math">f = f^{\\prime}</span> , so  <span class="math">\\hat{f}</span>  is a polynomial of degree at most  <span class="math">d_{\\max}</span>  and  <span class="math">\\mathsf{PolyQuotient}(\\hat{f},S)</span>  is a polynomial of degree at most  $d_{\\max} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Moreover,  </span>\\hat{f}<span class="math">  agrees with  </span>\\mathsf{Ans}<span class="math">  on  </span>S<span class="math"> ; this is because the prover computes the out-of-domain responses honestly, and  </span>f<span class="math">  agrees with  </span>f^{\\prime}$  (which is virtually computed by the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">erifier). Finally, <span class="math">\\text{Quotient}(f,S,\\text{Ans},\\text{Fill})</span> is precisely the evaluations of <span class="math">\\text{PolyQuotient}(\\hat{f},S)</span> over <span class="math">\\mathcal{L}</span>; this is because the prover computes the hole fills honestly. We conclude that <span class="math">\\text{Quotient}(f,S,\\text{Ans},\\text{Fill})</span> is a codeword in $\\text{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">6.2 Soundness analysis</h3>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 6.5.</h6>

    <p class="text-gray-300">Construction 6.3 has round-by-round soundness error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\text{rbr}}(\\mathbb{p},\\mathbb{I},\\mathbb{x}):=\\max\\left(\\varepsilon_{\\text{prox}}\\left(d_{\\max},\\rho,\\delta,m\\cdot(d_{\\max}+1)-\\sum_{i=1}^{m}d_{i}\\right),\\varepsilon_{\\text{ood}}(d_{\\max},\\ell,s),(1-\\delta)^{t}\\right),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\ell</span> is such that <span class="math">\\text{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}]</span> is $(\\delta+t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell)$-list decodable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define $\\gamma:=\\delta+t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We describe a state function </span>\\mathsf{State}$ as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Combined function.</em> We assign <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},r)=1</span> if and only if <span class="math">\\Delta(f^{\\prime},\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}])\\leq\\delta</span>.</li>

      <li><em>Out-of-domain samples.</em> We assign <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f,(x_{j}^{\\text{out}})_{j\\in[s]}))=1</span> if and only if at least one of the following holds:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Delta(f^{\\prime},\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}])\\leq\\delta</span>.</li>

      <li>There exist distinct codewords <span class="math">u,u^{\\prime}\\in\\mathsf{List}(f,d_{\\max},\\gamma)</span> with <span class="math">\\hat{u}(x_{i}^{\\text{out}})=\\hat{u}^{\\prime}(x_{i}^{\\text{out}})</span> for all <span class="math">i\\in[s]</span>.</li>

      <li><em>In-domain queries.</em> We assign <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f,(x_{j}^{\\text{out}})_{j\\in[s]},(y_{j})_{j\\in[s]},(x_{j}^{\\text{in}})_{j\\in[t]}))=1</span> if and only if there exists a codeword <span class="math">u\\in\\mathsf{List}(f,d_{\\max},\\gamma)</span> which agrees with <span class="math">\\mathsf{Ans}</span> over <span class="math">S</span>.</li>

    </ol>

    <p class="text-gray-300">We analyze the round-by-round soundness errors of <span class="math">\\mathsf{State}</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},\\varnothing)=0</span> and <span class="math">(\\mathbb{I},\\mathbb{x},\\vec{y})\\not\\in\\mathcal{L}(\\mathcal{R})</span>. Since the instance is not in the language, there exists <span class="math">i\\in[m]</span> such that <span class="math">\\Delta(\\mathfrak{c}_{i}(\\mathbf{f}_{i}),\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{i}])&gt;\\delta</span>. Applying Lemma 3.9, we find that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{r}[\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},r)=1]\\leq\\varepsilon_{\\text{prox}}\\left(d_{\\max},\\rho,\\delta,m\\cdot(d_{\\max}+1)-\\sum_{i=1}^{m}d_{i}\\right).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f))=0</span>. Clearly, Item 2(a) cannot hold, so it suffices to bound the probability that Item 2(b) holds. Applying Lemma 3.4, we find that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{x_{1}^{\\text{out}},\\ldots,x_{s}^{\\text{out}}}[\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f,(x_{j}^{\\text{out}})_{j\\in[s]}))=1]\\leq\\varepsilon_{\\text{ood}}(d_{\\max},\\ell,s).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f,(x_{j}^{\\text{out}})_{j\\in[s]},(y_{j})_{j\\in[s]}))=0</span>. Then there exists at most one codeword <span class="math">u\\in\\mathsf{List}(f,d_{\\max},\\gamma)</span> which agrees with <span class="math">\\mathsf{Ans}</span> at the out-of-domain samples <span class="math">\\{x_{j}^{\\text{out}}\\}_{j\\in[s]}</span>. In order for <span class="math">\\mathsf{State}</span> to transition to <span class="math">1</span>, <span class="math">u</span> must exist and moreover agree with <span class="math">f^{\\prime}</span> at the in-domain queries <span class="math">\\{x_{j}^{\\text{in}}\\}_{j\\in[t]}</span>. But since <span class="math">f^{\\prime}</span> is <span class="math">\\delta</span>-far from the code, we conclude that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{x_{1}^{\\text{in}},\\ldots,x_{t}^{\\text{in}}}[\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},(r,f,(x_{j}^{\\text{out}})_{j\\in[s]},(y_{j})_{j\\in[s]},(x_{j}^{\\text{in}})_{j\\in[t]}))=1]\\leq(1-\\delta)^{t}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we show that <span class="math">\\mathsf{State}</span> is consistent with the verifier’s decision (this is necessary since the protocol ends on a prover message). In particular, let <span class="math">\\tau=(r,f,(x_{j}^{\\text{out}})_{j\\in[s]},(y_{j})_{j\\in[s]},(x_{j}^{\\text{in}})_{j\\in[t]})</span> be a partial transcript containing all but the prover’s final message and suppose that <span class="math">\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},\\tau)=0</span>. By the definition of a state function, it must be the case that $\\mathsf{State}(\\mathbb{p},\\mathbb{I},\\mathbb{x},\\vec{y},\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Fill})=0<span class="math"> for any prover message </span>\\text{Fill}<span class="math">. Since this is a full transcript, we must show that the verifier outputs a bad instance, i.e., </span>\\Delta(\\text{Quotient}(f,S,\\text{Ans},\\text{Fill}),\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">])>\\delta$. This follows from Lemma 3.6. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6.3 Extensions and optimizations</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Delaying FFTs.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A computationally expensive step for the prover is computing <span class="math">\\mathsf{Fill}</span>. Generally, this requires <span class="math">t</span> evaluations of the polynomial, e.g., using an FFT in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Note that the rest of </span>g<span class="math"> can be computed by evaluating the quotient directly. This can be done in time </span>O(t\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The FFT is particularly expensive if the alphabet of input codewords is some smaller base field </span>\\mathbb{F}<span class="math">, but the challenge space is over a larger extension field </span>\\mathbb{F}^{k}<span class="math">. In this case, the alphabet for </span>g<span class="math">, and thus the domain of the FFT, will be </span>\\mathbb{F}^{k}<span class="math">. Given this, we want to delay the FFT for multiple accumulation steps. To do this, the prover can send </span>0<span class="math"> output values for </span>\\mathsf{Fill}<span class="math">. Note that </span>g<span class="math">, now is </span>\\frac{t}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> far from the code. Let’s refer to these </span>t$ locations as holes. Whenever the verifier queries any of the holes, the prover aborts and then recommits to the actual codeword. This now requires running an FFT. We now argue that the prover only needs to abort and recommit every once in a while for reasonable parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume there are <span class="math">w</span> holes. The probability that the verifier does not query a hole on a single query is $1-\\frac{w}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> or </span>(1-\\frac{w}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{t}\\approx e^{-\\frac{t\\cdot w}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math"> for </span>t<span class="math"> queries. After </span>k<span class="math"> steps, each with </span>t<span class="math"> queries, there should be at most </span>k\\cdot t<span class="math"> holes. Thus, the probability that after </span>k<span class="math"> steps, no hole has been queried is lower bounded by </span>\\prod_{i=1}^{k}(1-\\frac{i\\cdot t}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{t}\\approx e^{-\\sum_{i=1}^{k}\\frac{i\\cdot t^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\approx e^{-\\frac{k^{2}\\cdot t^{2}}{2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">. As long as </span>\\frac{k^{2}\\cdot t^{2}}{2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 1/2<span class="math">, i.e. </span>k<\\frac{\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{t}<span class="math"> the probability of querying even a single hole after </span>k<span class="math"> rounds can be upper bounded by </span>1-e^{-1/2}\\approx 40\\%<span class="math">. For </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{26}<span class="math"> and </span>t=80<span class="math">, this implies that with high probability, the FFT needs to be run only every 100 steps or more. To run the FFT efficiently, the prover maintains a representation of the polynomials as evaluation over </span>\\mathcal{L}^{\\prime}\\subset\\mathbb{F}\\setminus\\mathcal{L}<span class="math">. This ensures that there will never be holes within </span>\\mathcal{L}^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Conjectured security.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Theorem 6.2, we prove that Construction 6.3 is secure for instances up to <span class="math">\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)</span> for a small value of <span class="math">\\eta</span>. The constraint directly influences <span class="math">t</span>, the key efficiency parameter in the protocol as the query complexity <span class="math">t=\\frac{\\lambda}{-\\log(1-\\delta)}\\approx\\frac{2\\cdot\\lambda}{\\log(1/\\rho)}</span>. The constraint on <span class="math">\\delta</span> is related to the Johnson bound (Theorem 3.3), which proves that there is only a polynomial (in <span class="math">1/\\eta</span> and <span class="math">1/\\rho</span>) number of codewords in a <span class="math">(1-\\sqrt{\\rho}-\\eta)</span> radius of any string. Prior work <em>[x1, x2, x3, x1]</em>, as well as practical implementations, have taken a conjecture that even within a <span class="math">(1-\\rho-\\eta^{\\prime})</span>-radius of any string, there exists only a polynomial (in <span class="math">1/\\rho,1/\\eta</span>) number of codewords, and that the proximity gap lemma (Lemma 3.7) holds up to <span class="math">1-\\delta-\\eta^{\\prime}</span>. For small <span class="math">\\eta^{\\prime}</span> this results in <span class="math">t\\approx\\frac{\\lambda}{\\log(1/\\rho)}</span>, i.e saving roughly a factor of 2. The conjecture also enables reducing the field size. If we set <span class="math">s=2</span> and use the Conjecture 5.6 from <em>[x1]</em>, we can set the field size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}\\cdot\\frac{(m-1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(\\eta^{\\prime})}<span class="math">, and achieve round-by-round soundness </span>2^{-\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7 Accumulation for NP</p>

    <p class="text-gray-300">We construct an accumulation scheme for R1CS relations.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathtt {R 1 C S}} (\\mathbb {F}) := \\left\\{ \\begin{array}{l l} \\big ((A, B, C \\in \\mathbb {F} ^ {M \\times N}, M, N), &amp;amp; \\text {For} z := (x, w) \\in \\mathbb {F} ^ {N}, \\\\ (x \\in \\mathbb {F} ^ {n}, w \\in \\mathbb {F} ^ {N - n}), &amp;amp; A z \\circ B z = C z \\\\ \\bot , \\bot \\big) &amp;amp; \\end{array} \\right.</span></div>

    <p class="text-gray-300">Consider the polynomial over a field  <span class="math">\\mathbb{F}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {P} (Y _ {1}, \\ldots , Y _ {m}, Z _ {1}, \\ldots , Z _ {N}) := \\sum_ {i = 1} ^ {M} \\mathsf {e q} ((i - 1), Y _ {1}, \\ldots , Y _ {m}) \\cdot (a _ {i} ^ {T} \\vec {Z} \\cdot b _ {i} ^ {T} \\vec {Z} - c _ {i} ^ {T} \\vec {Z}),</span></div>

    <p class="text-gray-300">for multi-linear  <span class="math">\\mathsf{eq}(i,Y_1,\\ldots ,Y_m) = \\left\\{ \\begin{array}{ll}1 &amp;amp; \\vec{Y}\\in \\{0,1\\} ^m\\wedge i = \\sum_{i = 1}^{m}2^{i - 1}\\cdot Y_i\\\\ 0 &amp;amp; \\vec{Y}\\in \\{0,1\\} ^m\\wedge i\\neq \\sum_{i = 1}^{m}2^{i - 1}\\cdot Y_i \\end{array} \\right.</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {P} (Y _ {1}, \\dots , Y _ {m}, \\vec {Z}) = 0 \\in \\mathbb {F}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if and only if for  $\\vec{Z} = x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w((A,B,C,M,N),x,w)\\in \\mathcal{R}_{\\mathrm{R1CS}}(\\mathbb{F})<span class="math"> . Let  </span>d_P = \\log m + 2<span class="math">  be the total degree of  </span>\\hat{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We first construct a reduction from  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}(\\mathbb{F})</span>  to an accumulator relation which we define below. The accumulator consists of two oracle strings and constraints on these oracle strings. The first oracle string is equivalent to the oracle in the proximity claim accumulator. The second oracle string, in the honest case, corresponds to the accumulated R1CS witness. We, then, show how to reduce multiple instances of this accumulator relation into one.</p>

    <p class="text-gray-300"><strong>Accumulator relation.</strong> The accumulator relation is defined as follows. The index  <span class="math">\\mathbb{I}</span>  consists of the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Description of a finite field  <span class="math">\\mathbb{F}</span>  and evaluation domain  <span class="math">\\mathcal{L} \\subset \\mathbb{F}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Maximum degree parameter  $d_{\\max} \\in \\mathbb{N}, d_{\\max} &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Define  </span>\\rho := \\frac{d_{\\max} + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  to be the rate of the corresponding Reed-Solomon code RS[F, L, dmax].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Distance parameter  <span class="math">\\delta \\in (0,1)</span> .</li>

      <li>A second distance parameter  <span class="math">\\gamma \\in (0,1)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The instance consists of two rational constraints of degree  <span class="math">d_{f} = d_{\\max} - t - 2</span>  and  <span class="math">d_{g} = d_{\\max} - t - 1</span> , as well as  <span class="math">v \\in \\mathbb{F}^k</span>  and error term  <span class="math">e \\in \\mathbb{F}</span> ,  <span class="math">\\mathsf{z} = (v, e, \\mathsf{c}_f, \\mathsf{c}_g)</span> . There are two instance oracle strings  $f, g \\in \\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . There is no witness. We formally define the promise relation  </span>\\mathcal{R}_{\\mathrm{ACC}}$  below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathcal {R} _ {\\mathsf {A C C}} (\\mathbb {P}) := \\left\\{ \\begin{array}{c c} &amp; f \\in \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d _ {\\max } ] \\\\ (\\mathbb {I}, (v, e, \\mathfrak {c} _ {f}, \\mathfrak {c} _ {g}), (f, g), \\bot): &amp; \\mathfrak {c} _ {f} (f) \\in \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d _ {f} ] \\\\ &amp; \\mathfrak {c} _ {g} (g) \\in \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d _ {g} ] \\\\ &amp; \\hat {P} (v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {f}) = e \\end{array} \\right\\} \\\\ \\tilde {\\mathcal {R}} _ {\\mathsf {A C C}} (\\mathbb {P}) := \\left\\{ \\begin{array}{c c} &amp; \\Delta (\\mathfrak {c} _ {g} (g), \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d _ {g} ]) \\leq \\delta \\\\ (\\mathbb {I}, (v, e, \\mathfrak {c} _ {f}, \\mathfrak {c} _ {g}), (f, g), \\bot): &amp; \\exists u \\in \\mathsf {L i s t} (f, d _ {\\max }, \\gamma), \\hat {P} (v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u) = e \\\\ &amp; \\wedge \\\\ &amp; \\mathfrak {c} _ {f} (u) \\in \\mathsf {R S} [ \\mathbb {F}, \\mathcal {L}, d _ {\\max } - t - 2 ] \\end{array} \\right\\} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">7.1 Reduction from <span class="math">\\mathcal{R}_{\\texttt{R1CS}}</span> to <span class="math">\\mathcal{R}_{\\texttt{ACC}}</span></p>

    <p class="text-gray-300">Theorem 7.1 (knowledge soundness of accumulation). Consider a security parameter <span class="math">\\lambda \\in \\mathbb{N}</span>. Assume the index and instance are such that the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda} \\cdot \\frac{10}{\\rho} \\cdot m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta \\in (0, 1 - 1.05 \\cdot \\sqrt{\\rho})</span>.</li>

      <li><span class="math">\\gamma = \\delta</span>.</li>

    </ul>

    <p class="text-gray-300">Then Construction 7.2 is an interactive oracle reduction (parameterized by <span class="math">\\lambda</span> with round-by-round knowledge error <span class="math">2^{-\\lambda}</span> and the following efficiency measures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alphabet: <span class="math">\\mathbb{F}</span>.</li>

      <li>Round complexity: 1</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof length: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query complexity: 0</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Set <span class="math">\\eta \\geq \\sqrt{\\rho} / 20</span>, the Johnson bound (Theorem 3.3), gives us that <span class="math">\\ell \\leq 1 / (2\\eta \\sqrt{\\rho})</span>, i.e. <span class="math">\\ell &amp;lt; \\frac{10}{\\rho}</span>. This implies that $\\kappa_{\\mathrm{rbr}} \\leq \\ell \\cdot m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{-\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Construction 7.2.</strong></p>

    <p class="text-gray-300"><strong>Interaction phase.</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends <span class="math">f: \\mathcal{L} \\to \\mathbb{F}</span>. In the honest case, <span class="math">\\hat{f} \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d_{\\max}]</span> is the encoding of <span class="math">w \\in \\mathbb{F}^{N - n}</span>.</li>

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">r_1, \\ldots, r_m \\gets \\mathbb{F}</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Output phase.</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the vector <span class="math">\\vec{v} := (r_1, \\ldots, r_m, x_1, \\ldots, x_n)</span>.</li>

      <li><span class="math">\\mathbf{V}</span> outputs the new instance <span class="math">(v, 0, \\bot, \\bot)</span> and new instance string <span class="math">(f, [0])</span>.</li>

    </ol>

    <h2 id="sec-61" class="text-2xl font-bold">7.1.1 Soundness analysis</h2>

    <p class="text-gray-300">Lemma 7.3. Construction 7.2 is complete and is round-by-round knowledge sound with knowledge error <span class="math">\\kappa_{\\mathrm{rbr}} = \\frac{\\ell \\cdot m}{\\mathbb{F}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Completeness is immediate. Given any transcript the extractor <span class="math">\\mathbf{E}</span> decodes the first message <span class="math">f</span> to <span class="math">\\operatorname{List}(f, d_{\\max}, \\gamma)</span> and finds a <span class="math">u \\in \\operatorname{List}(f, d_{\\max}, \\gamma)</span> such that <span class="math">\\hat{P}(Y_1, \\ldots, Y_m, \\vec{z}) = 0</span> for $\\vec{z} = \\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If such a </span>u<span class="math"> exists, </span>\\mathbf{E}<span class="math"> outputs </span>u$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We analyze the round-by-round knowledge error of State as follows. Suppose that <span class="math">\\text{State}(\\mathbb{P}, \\mathbb{I}, \\vec{x}, f) = 0</span>. Then, for all codewords <span class="math">u</span> in <span class="math">\\text{List}(f, d_{\\max}, \\gamma)</span>, <span class="math">\\hat{P}(Y_1, \\ldots, Y_m, \\vec{x}, u) \\neq 0</span>. Since <span class="math">\\hat{P}</span> is a multi-linear <span class="math">m</span>-variate non-zero polynomial, we find that by the Schwartz-Zippel lemma $\\operatorname{Pr}_{\\vec{r}}[\\hat{P}(\\vec{r}, \\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{u})] \\leq \\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and thus taking a union bound over all </span>\\ell<span class="math"> polynomials in </span>\\text{List}(f, d_{\\max}, \\gamma)$ we find that,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}_{\\vec{r} \\leftarrow \\mathbb{F}^m}[\\text{State}(\\mathbb{P}, \\mathbb{I}, \\vec{x}, (f, \\vec{r}))] \\leq \\frac{\\ell \\cdot m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the probability is greater than this, then $\\hat{P}(\\vec{r}, \\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{u})<span class="math"> must be a zero-polynomial for some </span>u<span class="math"> in the list decoding radius and </span>\\mathbf{E}<span class="math"> outputs a valid witness to </span>(\\mathbb{I}, \\vec{x}) \\in \\mathcal{L}(\\mathcal{R}_{\\texttt{R1CS}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">7.2 Reduction from <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{*}</span> to <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span></p>

    <p class="text-gray-300">Theorem 7.4 (Security of accumulation). Consider a security parameter <span class="math">\\lambda \\in \\mathbb{N}</span>. Assume the index and instance are such that the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda} \\cdot 10^{7} \\cdot m \\cdot d_{P} \\cdot d_{\\max}^{2} \\cdot 3t \\cdot \\rho^{-3.5}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $\\gamma = \\delta + \\frac{\\lambda}{-\\log(1 - \\delta) \\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{L}</td>

            <td class="px-3 py-2 border-b border-gray-700">}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then Construction 7.5, when instantiated with <span class="math">s = 1</span> and <span class="math">t = \\frac{\\lambda}{-\\log(1 - \\delta)}</span>, is an interactive oracle reduction (parameterized by <span class="math">\\lambda</span>) with round-by-round soundness error <span class="math">2^{-\\lambda}</span> and the following efficiency measures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alphabet: <span class="math">\\mathbb{F}</span>.</li>

      <li>Round complexity: 5</li>

      <li>Query complexity: <span class="math">6 \\leq t \\leq \\frac{\\lambda}{-\\log(1 - \\delta)}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof length: $2 \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ t + m + 1)$ field elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Soundness. We analyze the soundness error given the defined size of <span class="math">\\mathbb{F}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\varepsilon_{\\mathrm{prox}}(d_{\\max}, \\rho, \\delta, m \\cdot (2t + 6)) = \\frac{m \\cdot 3 \\cdot t \\cdot d_{\\max}^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\frac{\\sqrt{\\rho}}{10})^7} \\leq 2^{-\\lambda}<span class="math"> (Plugging in the value for </span>\\mathbb{F}$).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Assuming that $d_{\\max} &lt;</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{L}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">/ 2<span class="math">, we get </span>\\varepsilon_{\\mathrm{ood}} \\leq m \\cdot \\frac{100}{\\rho^2} \\cdot \\frac{d_{\\max}}{\\mathbb{F}}$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Since $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq 2^{\\lambda} \\cdot m \\cdot 100 \\cdot d_{\\max} \\cdot \\rho^{-2}<span class="math"> we have that </span>\\varepsilon_{\\mathrm{ood}} \\leq 2^{-\\lambda}$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">\\varepsilon_{\\mathrm{acc}} = \\frac{(m - 1) \\cdot d_P}{\\mathbb{F}} \\leq 2^{-\\lambda}</span> for $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq m \\cdot d_P \\cdot 2^{\\lambda}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(1 - \\delta)^{t} \\leq (1 - \\delta)^{\\frac{\\lambda}{-\\log(1 - \\delta)}} = 2^{-\\lambda}</span>.</li>

    </ul>

    <p class="text-gray-300">Since the round-by-round-soundness error is the maximum of these errors, we have that, for the chosen parameters, it is bounded above by <span class="math">2^{-\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The protocol has 5 rounds, 6 prover and 5 verifier messages. The number of oracle queries is <span class="math">t = \\frac{\\lambda}{-\\log(1 - \\delta)}</span> to <span class="math">f</span> and <span class="math">g</span> which can be send as one interleaved codeword over <span class="math">\\mathbb{F}^2</span>. The total proof length consists of two oracles of length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, each as well as </span>2m + 2<span class="math"> out of domain responses, along with two Fills of size </span>t = \\frac{\\lambda}{-\\log(1 - \\delta)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Construction 7.5. We describe an interactive oracle reduction from <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{*}</span> to <span class="math">\\mathcal{R}_{\\mathrm{ACC}}</span>. On input index <span class="math">\\mathbb{I}</span>, the indexer <span class="math">\\mathbf{I}</span> outputs short index <span class="math">\\iota \\coloneqq \\mathbb{I}</span>; there is no index oracle string. The prover and verifier are additionally parameterized by <span class="math">\\mathbb{P} = (s, t)</span>, where <span class="math">s, t \\in \\mathbb{N}</span> are the out-of-domain and in-domain repetition parameters, respectively. On input instance <span class="math">\\mathbb{X} = (v, e, \\mathfrak{c}_{f,i}, \\mathfrak{c}_{g,i})_{i \\in [m]}</span> and instance oracles <span class="math">\\vec{\\mathbf{y}} = (f_i, g_i)_{i \\in [m]}</span>, the prover <span class="math">\\mathbf{P}(\\mathbb{P}, \\mathbb{I}, \\mathbb{X}, \\vec{\\mathbf{y}})</span> and verifier <span class="math">\\mathbf{V}^{\\vec{\\mathbf{y}}}(\\mathbb{P}, \\mathbb{I}, \\mathbb{X})</span> engage in the following protocol.</p>

    <p class="text-gray-300">Interaction phase. Let <span class="math">H \\subset \\mathbb{F}</span> be an arbitrary sized <span class="math">m</span> subset of <span class="math">\\mathbb{F}</span>, and <span class="math">\\hat{L}_i(X) \\forall i \\in [m]</span>, the corresponding Lagrange polynomials, and <span class="math">\\hat{V}_H(X)</span>, the vanishing polynomial on <span class="math">H</span>. Define <span class="math">d_f = d_{\\max} - t - 2</span> and <span class="math">d_g = d_{\\max} - t - 1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends <span class="math">\\hat{q}(X) \\in \\mathbb{F}[X]</span>, a degree <span class="math">d_P \\cdot (m - 1) - m</span> polynomial.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the honest case $\\hat{q}(X) \\cdot \\hat{V}_H(X) + \\sum_{i=1}^{m} \\hat{L}_i(X) \\cdot e_i = \\hat{P}(\\sum_{i=1}^{m} \\hat{L}_i(X) \\cdot (v_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{f}_i))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">x^{(1)} \\gets (\\mathbb{F} \\setminus \\mathcal{L})^s</span></li>

      <li><span class="math">\\mathbf{P}</span> sends <span class="math">y_{i}^{(1)} \\in \\mathbb{F}^{s}</span> for all <span class="math">i \\in [m]</span>. In the honest case <span class="math">y_{i}^{(1)} \\coloneqq \\hat{f}_{i}(x^{(1)})</span>. <span class="math">^a</span></li>

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">\\alpha \\in \\mathbb{F}</span> and <span class="math">x^{(2)} \\in (\\mathbb{F} \\setminus \\mathcal{L})^s</span></li>

    </ol>

    <p class="text-gray-300">30</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span>  sends  <span class="math">y_{i}^{(2)}\\in \\mathbb{F}^{s}</span>  for all  <span class="math">i\\in [m]</span> . In the honest case  <span class="math">y_{i}^{(2)}\\coloneqq \\hat{f}_{i}(x^{(2)})</span></li>

      <li>For all  <span class="math">i\\in [m]</span>  , let  <span class="math">\\mathfrak{c}_{f_i&#x27;}\\coloneqq \\mathrm{Quotient}(\\cdot ,\\{x^{(1)},x^{(2)}\\} ,\\mathrm{Ans}_i&#x27;,\\bot)</span>  for  <span class="math">\\mathrm{Ans}_i&#x27;(x^{(1)}) = y_i^{(1)}\\wedge \\mathrm{Ans}_i&#x27;(x^{(2)}) = y_i^{(2)}</span></li>

      <li>V sends  <span class="math">r\\gets \\mathbb{F}</span></li>

      <li><span class="math">\\mathbf{P}</span>  sends  <span class="math">f,g:\\mathcal{L}\\to \\mathbb{F}</span>  In the honest case,  <span class="math">\\hat{f} := \\sum_{i = 1}^{m}\\hat{L}_{i}(\\alpha)\\cdot \\hat{f}_{i}</span>  and  <span class="math">\\hat{g} := \\mathrm{Combine}(d_{\\max},r,((\\mathfrak{c}_{f,i}(\\hat{f}_i),d_f),(\\mathfrak{c}_{f,i}&#x27;(\\hat{f}_i),d_{\\max} - 2),(\\mathfrak{c}_{g,i}(\\hat{g}_i),d_g))_{i\\in [m]})</span></li>

      <li>V sends  <span class="math">x^{(3)}\\in \\mathbb{F}^s</span></li>

      <li><span class="math">\\mathbf{P}</span>  sends  <span class="math">y^{((3),g)}, y^{((3),f)} \\in \\mathbb{F}^s</span> . In the honest case  <span class="math">y_i^{((3),g)} \\coloneqq \\hat{g}(x_i^{((3),g)}) \\forall i \\in [s]</span>  and  <span class="math">y_i^{((3),f)} \\coloneqq \\hat{f}(x_i^{((3),f)})</span> .</li>

      <li>V sends  <span class="math">x^{\\mathrm{in}}\\gets \\mathbb{F}^t</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12.  <span class="math">\\mathbf{P}</span>  sends  <span class="math">\\mathrm{Fill}_f: S_f \\to \\mathbb{F}</span> , where  <span class="math">S_f := \\{x^{\\mathrm{in}}, x^{(2)}, x^{(3)}\\}</span> . In the honest case,  $\\mathrm{Fill}_f := \\mathrm{PolyQuotient}(\\hat{f}, S_f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x^{\\mathrm{in}}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">v \\coloneqq \\sum_{i=1}^{m} \\hat{L}_i(\\alpha) \\cdot v_i</span></li>

      <li>Define  <span class="math">e\\coloneqq \\hat{V}_H(\\alpha)\\cdot \\hat{q} (\\alpha) + \\sum_{i = 1}^{m}\\hat{L}_{i}(\\alpha)\\cdot e_{i}.</span></li>

      <li>Define the virtual functions</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g&#x27; := \\operatorname{Combine}(d_{\\max}, r, ((\\mathfrak{c}_{f,i}(\\hat{f}_i), d_f), (\\mathfrak{c}_{f,i}&#x27;(\\hat{f}_i), d_{\\max} - 2), (\\mathfrak{c}_{g,i}(\\hat{g}_i), d_g))_{i \\in [m]})</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">f^{\\prime}\\coloneqq \\sum_{i = 1}^{m}\\hat{L}_{i}(\\alpha)\\cdot f_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">\\mathsf{Ans}_f: S_f \\to \\mathbb{F}</span>  such that</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Ans}_f(x^{(2)}) := \\sum_{i=1}^m \\hat{L}_i(\\alpha) \\cdot y_i^{(2)}</span></li>

      <li><span class="math">\\operatorname{Ans}_f(x^{((3),f)}) \\coloneqq y^{((3),f)}</span></li>

      <li><span class="math">\\operatorname{Ans}_f(x^{\\mathrm{in}}) := f&#x27;(x^{\\mathrm{in}})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the rational constraint  <span class="math">\\mathfrak{c}_f\\coloneqq \\mathrm{Quotient}(\\cdot ,S_f,\\mathrm{Ans}_f,\\mathrm{Fill}_f)</span></li>

      <li>Define  <span class="math">\\mathsf{Ans}_g: S_g \\to \\mathbb{F}</span>  such that  <span class="math">\\mathsf{Ans}_g(x^{(3)}) := y^{((3),g)}</span>  and  <span class="math">\\mathsf{Ans}_g(x^{\\mathrm{in}}) := g&#x27;(x^{\\mathrm{in}})</span> .</li>

      <li>Define the rational constraint  <span class="math">\\mathfrak{c}_g\\coloneqq \\mathrm{Quotient}(\\cdot ,S_g,\\mathrm{Ans}_g,\\mathrm{Fill}_g)</span></li>

      <li><span class="math">\\mathbf{V}</span>  outputs new instance  <span class="math">(v, e, \\mathfrak{c}_f, \\mathfrak{c}_g)</span>  and new instance strings  <span class="math">(f, g)</span> .</li>

    </ol>

    <p class="text-gray-300">Proof. Since  <span class="math">f_{i}, \\mathfrak{c}_{f,i}(f_{i})</span>  and  <span class="math">\\mathfrak{c}_{g,i}(g_i)</span>  are codewords, and all in-domain and out-of-domain query responses correspond to these codewords, we have that both  <span class="math">g</span>  and  <span class="math">f</span> , the outputs of Combine and a random linear combination are codewords as well. Further we have that  <span class="math">\\hat{P}(v_{i}, f_{i}) = e_{i}</span> .  <span class="math">\\hat{P}</span>  is a degree  <span class="math">d_{P}</span>  polynomial. Therefore,  <span class="math">\\hat{P}(\\sum_{i=1}^{m} \\hat{L}_{i}(X)(v_{i}, f_{i})) - \\sum_{i=1}^{m} \\hat{L}_{i}(X)e_{i}</span>  is 0 on all of  <span class="math">H</span> . Therefore, there exists a degree  <span class="math">m \\cdot (d_{P} - 1) - m</span>  polynomial  <span class="math">\\hat{q}(X)</span>  such that  <span class="math">\\hat{P}(\\sum_{i=1}^{m} \\hat{L}_{i}(X)(v_{i}, f_{i})) - \\sum_{i=1}^{m} \\hat{L}_{i}(X)e_{i} = \\hat{q}(X) \\cdot \\hat{V}_{H}(X)</span> . This implies that  <span class="math">\\hat{P}(v, f) = e</span> .</p>

    <p class="text-gray-300">Lemma 7.7. Construction 7.5 has a round-by-round soundness error</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\kappa_ {\\mathrm {r b r}} = \\max \\left(\\varepsilon_ {\\mathrm {p r o x}} (d _ {\\mathrm {m a x}}, \\rho , \\delta , m \\cdot (2 t + 6), m \\cdot \\frac {\\ell^ {2}}{2} \\cdot \\left(\\frac {d _ {\\mathrm {m a x}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathcal {L}}\\right) ^ {s}, \\frac {(m - 1) \\cdot d _ {P}}{\\mathbb {F}}, (1 - \\delta) ^ {t}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We denote by  <span class="math">\\tau_{i}</span>  the index, the instance and the transcript up to the  <span class="math">i</span> -th verifier message, so that  <span class="math">\\tau_0 = (\\mathbb{P},\\mathbb{I},\\vec{\\mathbf{z}})</span> . We define the following doom sets.  <span class="math">D_{i}</span>  is the doom set after the  <span class="math">i</span> -th verifier message. We will show that  <span class="math">\\tau_0\\in D_0</span>  implies that there exists an  <span class="math">i</span>  such that  <span class="math">(\\mathbb{I},\\mathbb{z}_i)\\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{ACC}})</span>  with all but negligible probability for all sets. Concretely, we show that the probability  $\\operatorname*{Pr}_{c_j}[\\tau_{j - 1}\\in D_{j - 1}\\wedge \\tau_j = (\\tau_{j - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j)\\notin D_j]\\leq \\kappa_{\\mathrm{rbr}}^{(j)}<span class="math">  for round-by-round errors  </span>\\kappa_{\\mathrm{rbr}}^{(1)},\\ldots ,\\kappa_{\\mathrm{rbr}}^{(6)}<span class="math"> . The overall round-by-round error will be the maximum of these per-round errors. Let  </span>\\gamma = \\delta +t /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>d_{f} = d_{\\max} - t - 2<span class="math">  and  </span>d_{g} = d_{\\max} - t - 1$ . Then the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_0 = D_0^f \\cup D_0^g</span>  for</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">D_0^f = \\{\\exists i</span>  s.t.  $\\forall u\\in \\mathsf{List}(f_i,d_{\\max},\\gamma):\\mathfrak{c}_{f,i}(u)\\notin \\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_f]\\lor \\hat{P} (v_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u)\\neq e_i\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_0^g = \\{\\exists i</span>  s.t.  <span class="math">\\forall u\\in \\mathsf{List}(g_i,d_{\\max},\\gamma):\\mathfrak{c}_{g,i}(u)\\notin \\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_g]\\}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_{1} = D_{1}^{f}\\cup D_{1}^{g}</span>  for</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_1^f = D_0^f \\cap \\{\\forall i, \\forall (u, u&#x27;) \\in \\operatorname{List}(f_i, d_{\\max}, \\gamma) : u(x^{(1)}) \\neq u&#x27;(x^{(1)}) \\lor u = u&#x27;\\}</span></li>

      <li><span class="math">D_1^g = D_0^g</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 7.8 ( <span class="math">D_0</span>  to  <span class="math">D_1</span> ). Let  <span class="math">\\operatorname{Pr}_{x^{(1)}}[\\tau_0 \\in D_0 \\land (\\tau_0, x^{(1)}) \\notin D_1] \\leq \\kappa_{\\mathrm{rbr}}^{(1)}</span> . If  <span class="math">\\tau_0 \\in D_0</span>  and  <span class="math">(\\tau, y^{(1)}) \\notin D_1</span> , then there exists an  <span class="math">i</span>  such that two polynomials in the list decoding radius of  <span class="math">f_i</span>  are equal at  <span class="math">x^{(1)}</span> . The probability that two degree  <span class="math">d_{\\max}</span>  polynomials are equal at  <span class="math">s</span>  points in  <span class="math">\\mathbb{F} \\setminus \\mathcal{L}</span>  is bounded by  $\\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^s<span class="math"> . A union bound over all  </span>\\binom{\\ell}{2}<span class="math">  points in  </span>\\operatorname{List}(f_i, d_{\\max}, \\gamma)<span class="math">  and over  </span>i<span class="math">  yields that  </span>\\kappa_{\\mathrm{rbr}}^{(1)} = m \\cdot \\frac{\\ell^2}{2} \\cdot \\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_{2} = D_{2}^{f,\\mathrm{far}} \\cup D_{2}^{f,\\mathrm{ACC}} \\cup D_{2}^{g}</span>  for  <span class="math">D_{2}^{g} = D_{1}^{g}</span>  and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_2^{f,\\mathrm{far}} = \\{\\exists i \\forall u \\in \\operatorname{List}(f_i, d_{\\max}, \\gamma) : \\mathfrak{c}_{f,i}(u) \\notin \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d_f] \\lor u(x^{(1)}) \\neq y_i\\}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $D_2^{f,\\mathrm{ACC}} = \\left\\{ \\begin{array}{c} \\hat{P}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i=1}^m \\hat{L}_i(\\alpha) \\cdot u_i) \\neq \\sum_{i=1}^m \\hat{L}_i(\\alpha) \\cdot e_i + \\hat{q}(\\alpha) \\cdot \\hat{V}(\\alpha) \\\\ \\text{for unique } u_i \\in \\operatorname{List}(f_i, d_{\\max}, \\gamma) : \\mathfrak{c}_{f,i}(u_i) \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d_f] \\wedge u_i(x^{(1)}) = y_i^{(1)} \\end{array} \\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 7.9 ( <span class="math">D_{1}</span>  to  <span class="math">D_{2}</span> ). Let  <span class="math">\\operatorname{Pr}_{\\alpha}[\\tau_{1} \\in D_{1} \\land (\\tau_{1}, \\alpha) \\notin D_{2}] \\leq \\kappa_{\\mathrm{rbr}}^{(2)}</span> , and let  <span class="math">u_{i} \\in \\operatorname{List}(f_{i}, d_{\\max}, \\gamma)</span>  be the unique polynomial such that  $\\mathfrak{c}_{f,i}(u_{i}) \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d_{\\max} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{c}_{f,i}(u_{i})]<span class="math"> , and  </span>u_{i}(x^{(1)}) = y_{i}<span class="math"> . If such a  </span>u_{i}<span class="math">  does not exist then  </span>(\\tau_{1}, \\alpha) \\in D_{2}^{f}<span class="math"> , if any two  </span>u_{i}<span class="math">  agree on  </span>x^{(1)}<span class="math">  then  </span>\\tau_{1} \\notin D_{1}^{f}<span class="math">  so  </span>\\tau_{1} \\in D_{1}^{g} = D_{2}^{g}<span class="math"> . Let  </span>u' := \\sum_{i=1}^{m} \\hat{L}_{i}(\\alpha) u_{i}<span class="math"> . Note that by assumption  </span>\\exists i<span class="math"> , s.t.  </span>\\hat{P}(v_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{i}) \\neq e_{i}<span class="math"> . The probability over  </span>\\alpha<span class="math">  that  </span>\\hat{P}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u') = \\hat{q}(\\alpha) \\cdot \\hat{V}(\\alpha) + \\sum_{i=1}^{m} \\hat{L}_{i}(\\alpha) \\cdot e_{i}<span class="math"> , is equivalent to two  </span>d_{P} \\cdot (m-1)<span class="math">  polynomials agreeing on a random point. This probability is bounded by  </span>\\kappa_{\\mathrm{rbr}}^{(2)} = \\frac{d_{P} \\cdot (m-1)}{\\mathbb{F}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_{3} = D_{3}^{f,\\mathrm{ACC}} \\cup D_{3}^{f,\\mathrm{far}} \\cup D_{3}^{g}</span>  for  <span class="math">D_{3}^{g} = D_{2}^{g}, D_{3}^{f,\\mathrm{far}} = D_{2}^{f,\\mathrm{far}}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $D_3^{f,\\mathrm{ACC}} = \\{\\forall u\\in \\mathsf{List}(f',d_{\\max},\\gamma):u(x^{(2)})\\neq \\sum_{i = 1}^{m}\\hat{L}_{i}(\\alpha)\\cdot y_{i}^{(2)}\\lor \\hat{P} (v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u)\\neq e\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 7.10 (<span class="math">D_{2}</span> to <span class="math">D_{3}</span>). Let <span class="math">\\operatorname{Pr}_{x^{(2)}}[\\tau_{2} \\in D_{2} \\land (\\tau_{2}, x^{2}) \\notin D_{3}] \\leq \\kappa_{\\mathrm{rbr}}^{(3)}</span>. Either there exists an <span class="math">i</span> such that all polynomials in the list decoding radius of <span class="math">f_{i}</span> do not satisfy the constraints <span class="math">\\mathfrak{c}_{f,i}</span> or <span class="math">\\mathfrak{c}_{f,i}^{\\prime}</span> or we have for all <span class="math">u</span> one of the following two cases:</p>

    <p class="text-gray-300"><span class="math">u = u&#x27;</span>. In this case <span class="math">P(u) = P(u&#x27;) \\neq e</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">u \\neq u&#x27;</span>. The probability that <span class="math">u</span> and <span class="math">u&#x27;</span> agree on <span class="math">x^{(2)}</span> is bounded by $\\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathcal{L}}\\right)^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Taking a union bound over all <span class="math">\\ell</span> polynomials in <span class="math">\\operatorname{List}[f&#x27;, d_{\\max}, \\gamma]</span> we get $\\kappa_{\\mathrm{rbr}}^{(3)} = \\ell \\cdot \\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\mathcal{L}}\\right)^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_4 = D_4^f \\cup D_4^g</span> for</li>

      <li><span class="math">D_4^f = D_3^{f,\\mathrm{ACC}}</span></li>

      <li><span class="math">D_4^g = \\{\\Delta (g&#x27;,\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d_{\\max}]) &amp;gt; \\delta \\}</span></li>

    </ul>

    <p class="text-gray-300">Claim 7.11 ( <span class="math">D_{3}</span> to <span class="math">D_{4}</span> ). <span class="math">\\operatorname{Pr}_r[\\tau_3 \\in D_3 \\land (\\tau_3, r) \\notin D_4] \\leq \\kappa_{\\mathrm{rbr}}^{(4)}</span>. If <span class="math">\\tau_3 \\in D_3^{f,\\mathrm{far}}</span> or <span class="math">\\tau_3 \\in D_3^g</span> then for some <span class="math">i \\in [m]</span> one of the constraints <span class="math">\\mathfrak{c}_{f,i}</span>, <span class="math">\\mathfrak{c}_{f,i}&#x27;</span> or <span class="math">\\mathfrak{c}_{g_i}</span> won't be satisfied, i.e. the quotiented codeword is far from the code. We can ergo bound the probability that the resulting combined <span class="math">g&#x27;</span> is close to the code, using the proximity-gap Lemma 3.9. For this recall that <span class="math">d_f = d_{\\max} - t - 2</span> and <span class="math">d_g = d_{\\max} - t - 1</span>. Since <span class="math">3m(d_{\\max} + 1) - \\sum_{i=1}^{m}(d_f + d_g + d_{\\max} - 2) = m \\cdot (2t + 6)</span> by <span class="math">\\kappa_{\\mathrm{rbr}}^{(4)} = \\varepsilon_{\\mathrm{prox}}(d_{\\max}, \\rho, \\delta, m \\cdot (2t + 6))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_5 = D_5^f \\cup D_5^g</span> for</li>

      <li><span class="math">D_5^f = D_4^f \\cap \\{\\forall (u, u&#x27;) \\in \\operatorname{List}(f, d_{\\max}, \\gamma) : u(x^{(3)}) \\neq u&#x27;(x^{(3)}) \\vee u = u&#x27;\\}</span></li>

      <li><span class="math">D_5^g = D_4^g \\cap \\{\\forall (u, u&#x27;) \\in \\operatorname{List}(g, d_{\\max}, \\gamma) : u(x^{(3)}) \\neq u&#x27;(x^{(3)}) \\vee u = u&#x27;\\}</span></li>

    </ul>

    <p class="text-gray-300">Claim 7.12 (From <span class="math">D_4</span> to <span class="math">D_5</span> ). <span class="math">\\operatorname{Pr}_{x^{(3)}}[\\tau_4 \\in D_4 \\land (\\tau_4, x^{(3)}) \\notin D_5] \\leq \\kappa_{\\mathrm{rbr}}^{(5)}</span>. We compute the probability over <span class="math">y^{(3)}</span> that <span class="math">\\tau_4 \\in D_4</span> implies <span class="math">(\\tau_4, x^{(3)}) \\notin D_5</span>. This is the case if two polynomials in the list decoding radius of <span class="math">g</span> or <span class="math">f</span> are equal at independently chosen <span class="math">s</span> points <span class="math">x^{(3)} \\in \\mathbb{F} \\setminus \\mathcal{L}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume <span class="math">\\tau_4 \\in D_4^f</span>. Using a union bound over all pairs in the list decoding radius, we get that the probability that <span class="math">\\tau_4, x^{(3)} \\notin D_5^f</span> is bounded by $\\frac{\\ell^2}{2} \\cdot \\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^s$. This is a necessary condition to escape the doomset and thus suffices as an upper bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Otherwise, i.e. <span class="math">\\tau_4 \\in D_5^g</span>. Using the same union bound, we get the bound on the probability that <span class="math">\\tau_4, x^{(3)} \\notin D_5^g</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overall the probability is bounded by the max of the two cases, i.e. $\\kappa_{\\mathrm{rbr}}^{(5)} = \\frac{\\ell^2}{2} \\cdot \\left(\\frac{d_{\\max}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_6 = D_6^f \\cup D_6^g</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $D_6^f = \\{\\forall u \\in \\operatorname{List}(f, d_{\\max}, \\gamma) : \\mathfrak{c}_f(u) \\notin \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]) \\vee \\hat{P}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u) \\neq e\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_6^g = \\{\\forall u \\in \\operatorname{List}(g, d_{\\max}, \\gamma) : \\Delta(\\mathfrak{c}_g(u), \\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]) &amp;gt; \\delta\\}</span></li>

    </ul>

    <p class="text-gray-300">Claim 7.13 (From <span class="math">D_5</span> to <span class="math">D_6</span> ). <span class="math">\\operatorname{Pr}_{x^{\\mathrm{in}}}[\\tau_5 \\in D_5 \\land (\\tau_5, x^{\\mathrm{in}}) \\notin D_6] \\leq \\kappa_{\\mathrm{rbr}}^{(6)}</span>.</p>

    <p class="text-gray-300"><span class="math">\\tau_5 \\in D_5^g</span>. If <span class="math">\\tau_5 \\in D_5^g</span> then there exists at most one codeword <span class="math">u \\in \\operatorname{List}(g, d_{\\max}, \\gamma)</span> such that <span class="math">u(x^{(3)}) = y^{((3), g)}</span>. Additionally <span class="math">\\Delta(u, g&#x27;) \\geq \\delta</span>. The probability that <span class="math">g&#x27;</span> and <span class="math">u</span> agree on <span class="math">x^{\\mathrm{in}}</span> is bounded by <span class="math">(1 - \\delta)^t</span>. If they do not agree than <span class="math">\\mathfrak{c}_g(g)</span> is at least <span class="math">\\delta</span> far from <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]</span> by Lemma 3.6.</p>

    <p class="text-gray-300">Else, i.e. <span class="math">\\tau_5 \\in D_5^f</span>. Let <span class="math">u&#x27;</span> be the unique polynomial in <span class="math">\\operatorname{List}(f&#x27;, d_{\\max}, \\gamma)</span> such that <span class="math">u&#x27;(x^{(2)}) = \\sum_{i=1}^{m} \\hat{L}_i(\\alpha) \\cdot y_i^{(2)}</span>. Let <span class="math">u</span> be the unique polynomial in <span class="math">\\operatorname{List}(f, d_{\\max}, \\gamma)</span> such that <span class="math">u(x^{(3)}) = y^{((3), f)}</span>. If no such polynomial exists then <span class="math">\\mathfrak{c}_f(f)</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F}, \\mathcal{L}, d]</span>. Otherwise, we have one of three cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u\\not\\in\\mathrm{List}(f^{\\prime},d_{\\mathtt{max}},\\gamma)</span>. In this case <span class="math">\\Delta(u,f)&gt;\\gamma&gt;\\delta</span> and the probability that <span class="math">u</span> and <span class="math">f^{\\prime}</span> agree on <span class="math">x^{\\mathtt{in}}</span> is bounded by <span class="math">(1-\\delta)^{t}</span>. If not then <span class="math">\\mathfrak{c}_{f}(f)</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span>.</li>

      <li><span class="math">u\\in\\mathrm{List}(f^{\\prime},d_{\\mathtt{max}},\\gamma)</span> and <span class="math">u(x^{(2)})\\neq\\sum_{i=1}^{m}\\hat{L}_{i}(\\alpha)\\cdot y_{i}^{(2)}</span>. In this case <span class="math">\\mathfrak{c}_{f}(u)\\not\\in\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span> by Lemma 3.6, and thus <span class="math">\\mathfrak{c}_{f}(f)</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{L},d]</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">u=u^{\\prime}</span> and <span class="math">u(x^{(2)})=\\sum_{i=1}^{m}\\hat{L}_{i}(\\alpha)\\cdot y_{i}^{(2)}</span>. Then, by assumption $\\hat{P}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u)\\neq e$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The error is the max of both cases, i.e., <span class="math">\\kappa^{(6)}_{\\mathtt{rbr}}=(1-\\delta)^{t}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\tau_{6}\\in D_{6}\\implies(\\mathbb{I},(v,e,\\mathfrak{c}_{f},\\mathfrak{c}_{g}))\\not\\in\\mathcal{L}(\\mathcal{R}_{\\mathtt{ACC}})</span>.</p>

    <p class="text-gray-300">The overall round-by-round soundness error is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\kappa_{\\mathtt{rbr}}=\\max_{i\\in[6]}(\\kappa^{(i)}_{\\mathtt{rbr}})=\\left(\\varepsilon_{\\mathtt{prox}}(d_{\\mathtt{max}},\\rho,\\delta,m\\cdot(2t+6)),m\\cdot\\frac{\\ell^{2}}{2}\\cdot(\\frac{d_{\\mathtt{max}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\mathcal{L}})^{s},\\frac{(m-1)\\cdot d_{P}}{\\mathbb{F}},(1-\\delta)^{t}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 7.14 (Extension to arbitrary <span class="math">\\hat{P}</span>).</h6>

    <p class="text-gray-300">Our construction is written for a polynomial <span class="math">\\hat{P}</span> that encodes R1CS, but we note that, like ProtoStar <em>[x10]</em>, it directly applies to more general <span class="math">\\hat{P}</span>, including ones that perform higher-degree checks like those required for encoding a customizable constraint system <em>[x27]</em> or high-degree Plonk checks <em>[x11]</em>. This is beneficial because higher degree relations are more expressive and have smaller witnesses; indeed, recent works <em>[x30, x16]</em> have shown the concrete benefit of using degree <span class="math">5</span> to <span class="math">7</span> constraints, and so supporting them can significantly reduce the cost of committing to a new witness. However, this is traded off with a larger <span class="math">\\hat{q}(X)</span> (linear in the degree). The protocol does not need to change in order to accommodate different <span class="math">\\hat{P}</span>. The only difference is that <span class="math">\\hat{q}(X)</span> is now a higher degree, <span class="math">(d_{P}-1)\\cdot m-m</span>, polynomial, and that the soundness contains a <span class="math">\\frac{d_{P}\\cdot m}{\\mathbb{F}}</span> term. As long as <span class="math">\\mathbb{F}&gt;d_{P}\\cdot m\\cdot 2^{\\lambda}</span>, the soundness error remains <span class="math">2^{-\\lambda}</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Remark 7.15 (Number of out-of-domain samples).</h6>

    <p class="text-gray-300">Note that the protocol requires three rounds of out-of-domain samples. We give a brief intuitive explanation for these samples and in what scenarios the first can be omitted. The first round binds the prover to use a unique polynomial <span class="math">u_{i}</span> within the list-decoding radius of each <span class="math">f_{i}</span>. This is important as otherwise there could be up to <span class="math">\\ell^{m}</span> possible combination of codewords within the list-decoding radiuses. This is used, when bounding the probability over <span class="math">\\alpha</span> that <span class="math">P(\\sum_{i=1}^{m}\\hat{L}_{i}(\\alpha)\\cdot u_{i})=e</span>. The second out-of-domain challenge, after the choice of <span class="math">\\alpha</span>, connects <span class="math">f^{\\prime}</span> to <span class="math">u^{\\prime}=\\sum_{i=1}^{m}\\hat{L}_{i}(\\alpha)\\cdot u_{i}</span>, i.e. a prover can only succeed if <span class="math">u^{\\prime}</span> is in the list-decoding radius of <span class="math">f^{\\prime}</span>. The final out-of-domain challenge forces the prover to use a unique polynomial in <span class="math">f</span>. An astute reader will notice that in accumulation, <span class="math">f</span> becomes an input <span class="math">f_{i}</span> to the next round reduction-of-knowledge. This means that we ensure that the prover uses a unique polynomial within the list decoding radius of <span class="math">f</span>, twice: Once at the beginning of the reduction and once at the end. This seems superfluous. However, in accumulation, we cannot guarantee that the accumulator was generated in a particular way, e.g., is the output of a previous accumulation step. For completely arbitrary inputs, we cannot guarantee that there is a unique polynomial corresponding to the constraint within the decoding radius of the input. In many practical applications, however, one can safely skip the first round of out-of-domain samples as long as the application checks that input accumulators are the output of an accumulation procedure. This is the case in IVC and PCD.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Remark 7.16 (Conjectured security and delaying FFTs).</h6>

    <p class="text-gray-300">The optimizations described in Section 6.3, equally apply to Construction 7.5. Importantly, under a commonly taken coding conjecture <span class="math">t</span>, the number of queries</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">can be reduced from roughly <span class="math">t\\approx\\frac{2\\lambda}{\\log(1/\\rho)}</span> to <span class="math">t\\approx\\frac{\\lambda}{\\log(1/\\rho)}</span>. Additionally, it is possible to delay FFTs by not computing and sending Fill values until the code is queried at one of the holes. At that point, the prover can run an FFT and compute a codeword without holes. This should at most happpen every $\\frac{\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{t}$ steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-68" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This work was supported by Alpen Labs, Chaincode Labs, and the Sui Foundation.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACFY24] G. Arnon, A. Chiesa, G. Fenzi, and E. Yogev. “STIR: Reed-Solomon Proximity Testing with Fewer Queries”. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ’24. 2024, pp. 380–413.</li>

      <li>[BBHR18] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. “Fast Reed-Solomon Interactive Oracle Proofs of Proximity”. In: Proceedings of the 45th International Colloquium on Automata, Languages, and Programming. ICALP ’18. 2018, 14:1–14:17.</li>

      <li>[BC23] B. Bünz and B. Chen. “Protostar: Generic Efficient Accumulation/Folding for Special-Sound Protocols”. In: Proceedings of the 29th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’23. 2023, pp. 77–110.</li>

      <li>[BC24] D. Boneh and B. Chen. “LatticeFold: A Lattice-based Folding Scheme and its Applications to Succinct Proof Systems”. Cryptology ePrint Archive, Report 2024/257. 2024.</li>

      <li>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCG24] E. Boyle, R. Cohen, and A. Goel. “Breaking the <span class="math">O(\\sqrt{n})</span>-Bit Barrier: Byzantine Agreement with Polylog Bits Per Party”. In: Journal of Cryptology 37.1 (2024), p. 2.</li>

      <li>[BCGRS17] E. Ben-Sasson, A. Chiesa, A. Gabizon, M. Riabzev, and N. Spooner. “Interactive Oracle Proofs with Constant Rate and Query Complexity”. In: Proceedings of the 44th International Colloquium on Automata, Languages and Programming. ICALP ’17. 2017, 40:1–40:15.</li>

      <li>[BCIKS23] E. Ben-Sasson, D. Carmon, Y. Ishai, S. Kopparty, and S. Saraf. “Proximity Gaps for Reed-Solomon Codes”. In: Journal of the ACM 70.5 (2023), 31:1–31:57.</li>

      <li>[BCLMS21] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021, pp. 681–710.</li>

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. “Proof-Carrying Data from Accumulation Schemes”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020.</li>

      <li>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. 2014, pp. 276–294.</li>

      <li>[BCTV17] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge Via Cycles of Elliptic Curves”. In: Algorithmica 79.4 (2017), pp. 1102–1160.</li>

      <li>[BDFG21] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021.</li>

      <li>[BFS20] B. Bünz, B. Fisch, and A. Szepieniec. “Transparent SNARKs from DARK Compilers”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 677–706.</li>

      <li>[BGH19] S. Bowe, J. Grigg, and D. Hopwood. “Halo: Recursive Proof Composition without a Trusted Setup”. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BGKS20] E. Ben-Sasson, L. Goldberg, S. Kopparty, and S. Saraf. “DEEP-FRI: Sampling Outside the Box Improves Soundness”. In: Proceedings of the 11th Innovations in Theoretical Computer Science Conference. ITCS ’20. 2020, 5:1–5:32.</li>

    </ul>

    <p class="text-gray-300">[BJS23] M. Bellés-Muñoz, J. Jiménez Urroz, and J. Silva. “Revisiting Cycles of Pairing-Friendly Elliptic Curves”. In: Proceedings of the 43rd Annual International Cryptology Conference. CRYPTO ’23. 2023, pp. 3–37.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BMNW24] B. Bünz, P. Mishra, W. Nguyen, and W. Wang. “Accumulation without Homomorphism”. Cryptology ePrint Archive, Report 2024/474. 2024.</li>

      <li>[BMRS20] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro. “Coda: Decentralized Cryptocurrency at Scale”. Cryptology ePrint Archive, Report 2020/352. 2020.</li>

      <li>[CBBZ23] B. Chen, B. Bünz, D. Boneh, and Z. Zhang. “HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates”. In: Proceedings of the 42nd Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’23. 2023, pp. 499–530.</li>

      <li>[CCDW20] W. Chen, A. Chiesa, E. Dauterman, and N. P. Ward. “Reducing Participation Costs via Incremental Verification for Ledger Systems”. Cryptology ePrint Archive, Report 2020/1522. 2020.</li>

      <li>[CCW19] A. Chiesa, L. Chua, and M. Weidner. “On Cycles of Pairing-Friendly Elliptic Curves”. In: SIAM Journal on Applied Algebra and Geometry 3.2 (2019), pp. 175–192.</li>

      <li>[CGH04] R. Canetti, O. Goldreich, and S. Halevi. “The random oracle methodology, revisited”. In: Journal of the ACM 51.4 (2004), pp. 557–594.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[COS20] A. Chiesa, D. Ojha, and N. Spooner. “Fractal: Post-Quantum and Transparent Recursive Proofs from Holography”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[CT10] A. Chiesa and E. Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: Proceedings of the 1st Symposium on Innovations in Computer Science. ICS ’10. 2010, pp. 310–331.</li>

      <li>[CTV13] S. Chong, E. Tromer, and J. A. Vaughan. “Enforcing Language Semantics Using Proof-Carrying Data”. Cryptology ePrint Archive, Report 2013/513. 2013.</li>

      <li>[CTV15] A. Chiesa, E. Tromer, and M. Virza. “Cluster Computing in Zero Knowledge”. In: Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[CY24] A. Chiesa and E. Yogev. Building Cryptographic Proofs from Hash Functions. 2024.</li>

      <li>[DI14] E. Druk and Y. Ishai. “Linear-Time Encodable Codes Meeting the Gilbert-Varshamov Bound and Their Cryptographic Applications”. In: Proceedings of the 5th Innovations in Theoretical Computer Science Conference. ITCS ’14. 2014, pp. 169–182.</li>

      <li>[DMS24] M. Dellepere, P. Mishra, and A. Shirzad. “Garuda and Pari: Faster and Smaller SNARKs via Equifﬁcient Polynomial Commitments”. Cryptology ePrint Archive, Report 2024/1245. 2024.</li>

      <li>[DP23] B. E. Diamond and J. Posen. “Succinct Arguments over Towers of Binary Fields”. Cryptology ePrint Archive, Report 2023/1784. 2023.</li>

      <li>[EG23] L. Eagen and A. Gabizon. “ProtoGalaxy: Efficient ProtoStar-style folding of multiple instances”. Cryptology ePrint Archive, Report 2023/1106. 2023.</li>

      <li>[FKNP24] G. Fenzi, C. Knabenhans, N. K. Nguyen, and D. T. Pham. “Lova: Lattice-Based Folding Scheme from Unstructured Lattices”. In: Proceedings of the 30th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’24. 2024.</li>

      <li>[GK03] S. Goldwasser and Y. T. Kalai. “On the (In)security of the Fiat-Shamir Paradigm”. In: Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science. FOCS ’03. 2003, pp. 102–113.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GKRRS21] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. “Poseidon: A New Hash Function for Zero-Knowledge Proof Systems”. In: Proceedings of the 30th USENIX Security Symposium. USENIX Security ’21. 2021, pp. 519–535.</li>

      <li>[GLSTW23] A. Golovnev, J. Lee, S. T. V. Setty, J. Thaler, and R. S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: Proceedings of the 43rd Annual International Cryptology Conference. CRYPTO ’23. 2023, pp. 193–226.</li>

      <li>[Gui] A. Guillevic. “Pairing-friendly curves”.</li>

      <li>[GW19] A. Gabizon and Z. J. Williamson. “The Turbo-Plonk Program Syntax for Specifying Snark Programs”. In: ZKProof Workshop 3. 2019.</li>

      <li>[HLP24] U. Haböck, D. Levit, and S. Papini. “Circle STARKs”. Cryptology ePrint Archive, Report 2024/278. 2024.</li>

      <li>[KB20] A. Kattis and J. Bonneau. “Proof of Necessary Work: Succinct State Verification with Fairness Guarantees”. Cryptology ePrint Archive, Report 2020/190. 2020.</li>

      <li>[KP23] A. Kothapalli and B. Parno. “Algebraic Reductions of Knowledge”. In: Proceedings of the 43rd Annual International Cryptology Conference. CRYPTO ’23. 2023, pp. 669–701.</li>

      <li>[KPV19] A. Kattis, K. Panarin, and A. Vlasov. “RedShift: Transparent SNARKs from List Polynomial Commitments”. Cryptology ePrint Archive, Report 2019/1400. 2019.</li>

      <li>[KS23] A. Kothapalli and S. Setty. “CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves”. Cryptology ePrint Archive, Report 2023/1192. Aug. 2023.</li>

      <li>[KS24] A. Kothapalli and S. T. V. Setty. “HyperNova: Recursive Arguments for Customizable Constraint Systems”. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ’24. 2024, pp. 345–379.</li>

      <li>[KST22] A. Kothapalli, S. T. V. Setty, and I. Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: Proceedings of the 42nd Annual International Cryptology Conference. CRYPTO ’22. 2022, pp. 359–388.</li>

      <li>[Mina] O(1) Labs. “Mina Cryptocurrency”. minaprotocol.org. 2020.</li>

      <li>[NBS23] W. D. Nguyen, D. Boneh, and S. T. V. Setty. “Revisiting the Nova Proof System on a Cycle of Curves”. In: Proceedings of the 5th Conference on Advances in Financial Technologies. AFT ’23. 2023, 18:1–18:22.</li>

      <li>[NDCTB24] W. D. Nguyen, T. Datta, B. Chen, N. Tyagi, and D. Boneh. “Mangrove: A Scalable Framework for Folding-Based SNARKs”. In: Proceedings of the 44th Annual International Cryptology Conference. CRYPTO ’24. 2024, pp. 308–344.</li>

      <li>[NT16] A. Naveh and E. Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&P ’16. 2016, pp. 255–271.</li>

      <li>[Pol] Polygon Zero Team. “Plonky2: Fast Recursive Arguments with PLONK and FRI”.</li>

      <li>[RRR16] O. Reingold, R. Rothblum, and G. Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[Spi96] D. A. Spielman. “Linear-time encodable and decodable error-correcting codes”. In: IEEE Transactions on Information Theory 42.6 (1996), pp. 1723–1731.</li>

      <li>[STW23] S. Setty, J. Thaler, and R. Wahby. “Customizable constraint systems for succinct arguments”. Cryptology ePrint Archive, Report 2023/552. 2023.</li>

    </ul>

    <p class="text-gray-300">[Xio+23] A. L. Xiong, B. Chen, Z. Zhang, B. Bünz, B. Fisch, F. Krell, and P. Camacho. “VeriZexe: Decentralized Private Computation with Universal Setup”. In: Proceedings of the 32nd USENIX Security Symposium. USENIX Security ’23. 2023, pp. 4445–4462.</p>

    <p class="text-gray-300">Theorem 4.3. There exists a polynomial-time transformation  <span class="math">\\mathrm{T}</span>  such that the following holds. Let  <span class="math">\\mathcal{R}</span>  be a parameterized indexed relation. Let  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{\\mathcal{U}}</span>  be a parameterized indexed promise relation in  <span class="math">\\mathsf{NP}^{\\mathcal{U}}</span>  with the same parameter space as  <span class="math">\\mathcal{R}</span> . Suppose we are given the following non-interactive reductions in the random oracle model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{CAST}} = (\\mathcal{G}_{\\mathsf{CAST}},\\mathcal{I}_{\\mathsf{CAST}},\\mathcal{P}_{\\mathsf{CAST}},\\mathcal{V}_{\\mathsf{CAST}})</span> , a reduction from  <span class="math">\\mathcal{R}</span>  to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> .</li>

      <li><span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}} = (\\mathcal{G}_{\\mathsf{FOLD}}, \\mathcal{I}_{\\mathsf{FOLD}}, \\mathcal{P}_{\\mathsf{FOLD}}, \\mathcal{V}_{\\mathsf{FOLD}})</span> , a many-to-one reduction from  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^*</span>  to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>  with the same generator algorithm as  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  (i.e.,  <span class="math">\\mathcal{G}_{\\mathsf{FOLD}} \\equiv \\mathcal{G}_{\\mathsf{CAST}}</span> ).</li>

    </ul>

    <p class="text-gray-300">Then  <span class="math">\\mathrm{T}[\\mathrm{RDX}_{\\mathrm{CAST}},\\mathrm{RDX}_{\\mathrm{FOLD}},\\mathcal{R}_{\\mathrm{ACC}}] = (\\mathrm{ARG},\\mathrm{ACC})</span> , where ARG is a non-interactive argument for  <span class="math">\\mathcal{R}</span>  and ACC is an accumulation scheme for ARG, both in the random oracle model.</p>

    <p class="text-gray-300">Proof. Follows immediately from Lemma A.5 and Lemma A.7.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Here, we include the definition of non-interactive arguments and accumulation schemes. The construction of PCD from our follows exactly as in [BCLMS21]. However, unlike in [BCLMS21], our definitions include a relaxed version of the verifier and decider, which are used in the corresponding knowledge soundness definitions. Theorem 5.3 in [BCLMS21], the generic construction of PCD, follows almost immediately from our definitions. Essentially, it suffices to replace the verifier and decider in the knowledge soundness proof with their relaxed variants. This is similar to how recent work [BMNW24] builds proof-carrying data from bounded-depth accumulation. However, here in our setting, there is only one relaxed verifier and decider rather than up to  <span class="math">s</span>  for some bound  <span class="math">s \\in \\mathbb{N}</span> ; hence, the generic construction and proof follows almost immediately.</p>

    <p class="text-gray-300">Definition A.2. A (preprocessing) non-interactive argument in the random oracle model is a tuple of polynomial time algorithms  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V},\\tilde{\\mathcal{V}})</span>  that satisfy the following properties.</p>

    <p class="text-gray-300">Completeness. ARG is complete if the following holds. For every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} ^ {\\rho} (\\mathsf {p p}) &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) = 1 &amp;amp; (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathsf {p k}, \\mathbb {x}, \\mathbb {w}) \\end{array} \\right] = 1,</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathcal {V} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\tilde {\\mathcal {V}} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) = 1 &amp;amp; (\\mathbb {I}, \\mathbb {x}, \\pi) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Knowledge soundness. ARG is knowledge sound (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if the following holds. There exists a deterministic polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that for every (non-uniform)</p>

    <p class="text-gray-300">polynomial-time adversary  <span class="math">\\tilde{\\mathcal{P}}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\tilde {\\mathcal {V}} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x}, \\pi) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} ^ {\\rho} (\\mathsf {p p}) &amp;amp; \\mathsf {a i} \\leftarrow \\mathcal {D} (1 ^ {\\lambda}) \\\\ &amp;amp; (\\mathbb {I}, \\mathbb {x}, \\pi ; \\mathsf {t r}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {a i}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; \\mathsf {w} \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathbb {I}, \\mathbb {x}, \\pi , \\mathsf {a i}, \\mathsf {t r}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition A.3. Let  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V},\\tilde{\\mathcal{V}})</span>  be a non-interactive argument in the random oracle model for index relation  <span class="math">\\mathcal{R}^{\\rho}</span>  such that the proofs have a canonical partition into pairs  <span class="math">\\pi \\coloneqq (\\pi .\\mathbb{x},\\pi .\\mathbb{w})</span></p>

    <p class="text-gray-300">An accumulation scheme for ACC for ARG in the random oracle model is a tuple of polynomial-time algorithms  <span class="math">\\mathsf{ACC} = (\\mathcal{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D},\\tilde{\\mathrm{D}})</span> , which shares the same generator algorithm as ARG. An accumulation scheme must satisfy the following properties.</p>

    <p class="text-gray-300">Completeness. ACC is complete if the following holds. For every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall i \\in [ n ], \\mathcal {V} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x} _ {i}, \\pi_ {i}) = 1 \\wedge &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall j \\in [ m ], \\mathrm {D} (\\mathsf {d k}, \\mathsf {a c c} _ {j}) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\left(\\left[ \\begin{array}{c} \\mathsf {a v k}, \\left[ \\mathbb {x} _ {i}, \\pi_ {i}. \\mathbb {x} \\right] _ {i \\in [ m ]}, \\\\ \\mathsf {a v k}, \\left[ \\mathbb {x} _ {i}, \\pi_ {i}. \\mathbb {x} \\right] _ {i \\in [ m ]}, \\\\ \\mathsf {a c c} _ {i}. \\mathbb {x} \\end{array} \\right] _ {i \\in [ m ]}, \\mathsf {a c c}. \\mathbb {x}, \\mathsf {p f}\\right) = 1 \\\\ \\wedge \\mathrm {D} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; \\left(\\left[ \\begin{array}{c} \\mathsf {a c c} _ {i}, \\pi_ {i}, \\mathbb {x}, \\pi_ {i}. \\mathbb {w} \\end{array} \\right] _ {i \\in [ n ]}, [ \\mathsf {a c c} _ {j} ] _ {j \\in [ m ]}\\right) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ &amp;amp; (\\mathsf {a c c}, \\mathsf {p f}) \\leftarrow \\mathrm {P} ^ {\\rho} \\left(\\mathsf {a p k}, \\left[ \\mathbb {x} _ {i}, \\pi_ {i} \\right] _ {i \\in [ n ]}, [ \\mathsf {a c c} _ {j} ] _ {j \\in [ m ]}\\right) \\end{array} \\right] = 1, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {D} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ \\tilde {\\mathrm {D}} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; (\\mathbb {I}, \\mathsf {a c c}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">where each accumulator has a canonical partition into pairs  <span class="math">\\mathsf{acc} \\coloneqq (\\mathsf{acc}.x, \\mathsf{acc}.w)</span> .</p>

    <p class="text-gray-300">Knowledge soundness. ACC is knowledge sound (with respect to auxiliary input distribution  <span class="math">\\mathcal{D}</span> ) if there exists a deterministic polynomial-time extractor  <span class="math">\\mathrm{E}</span>  such that for every (non-uniform) polynomial-time adversary  <span class="math">\\tilde{\\mathrm{P}}</span> , the following holds</p>

    <p class="text-gray-300">$$ \\Pr \\left[ \\begin{array}{c c} &amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {V} \\left(\\left. \\begin{array}{c} \\mathsf {a v k}, \\left[ \\mathbb {x} _ {i}, \\pi_ {i}. \\mathbb {x} \\right] _ {i \\in [ n ]}, \\\\ \\mathsf {a c c} _ {i}. \\mathbb {x} \\end{array} \\right] _ {i \\in [ m ]}, \\mathsf {a c c}. \\mathbb {x}, \\mathsf {p f}\\right) = 1 \\\\ \\wedge \\tilde {\\mathrm {D}} (\\mathsf {d k}, \\mathsf {a c c}) = 1 \\\\ \\wedge &amp; \\exists i \\in [ n ], \\tilde {\\mathcal {V}} ^ {\\rho} (\\mathsf {v k}, \\mathbb {x} _ {i}, \\pi_ {i}) \\neq 1 \\\\ \\vee \\exists j \\in [ m ], \\tilde {\\mathrm {D}} (\\mathsf {d k}, \\mathsf {a c c} _ {j}) \\neq 1 \\end{array} \\right] \\begin{array}{c} \\left. \\begin{array}{c} \\left(\\left[ \\begin{array}{c} \\mathbb {x} _ {i}, \\pi_ {i}. \\mathbb {x} \\end{array} \\right] _ {i \\in [ n ]}, \\\\ \\left[ \\mathsf {a c c} _ {i}. \\mathbb {x} \\right] _ {i \\in [ m ]}, \\mathsf {a c c}, \\mathsf {p f}\\right) ; \\mathsf {t r}\\right) \\leftarrow \\tilde {\\mathrm {P}} ^ {\\rho} (\\mathsf {p p}, \\mathsf {a i}) \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {I}) \\\\ \\left(\\left[ \\pi_ {i}. \\mathbb {w} \\right] _ {i \\in [ n ]}, \\left[ \\mathsf {a c c} _ {j}. \\mathbb {w} \\right] _ {j \\in [ m ]}\\right) \\\\ \\left. \\left. \\left. \\left. \\left[ \\left[ \\begin{array}{c} \\pi_ {i}. \\mathbb {w} \\right] _ {i \\in [ n ]}, \\left[ \\mathsf {a c c} _ {j}. \\mathbb {w} \\right] _ {j \\in [ m ]}\\right) \\right. \\right. \\right. \\right. \\\\ &amp; \\left. \\left. \\left. \\left. \\left. \\left[ \\left[ \\begin{array}{c} \\pi_ {i}. \\mathbb {w} \\right] _ {i \\in [ n ]}, \\left[ \\mathsf {a c c} _ {i}. \\mathbb {x} \\right] _ {i \\in [ m ]}, \\mathsf {a c c}, \\mathsf {p f}\\right) \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right. \\right.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  to reduce the claim about  <span class="math">\\mathcal{R}</span>  to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . Now, the prover can simply include the output witness  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>  as a part of the argument proof. To be specific, the argument proof will simply consist of both the reduction proof  <span class="math">\\pi_{\\mathsf{CAST}}</span>  and the output witness acc.  <span class="math">\\mathcal{W}</span>  for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . The argument verifier simply derives the corresponding output instance acc.  <span class="math">\\mathcal{X}</span>  using  <span class="math">\\pi_{\\mathsf{CAST}}</span>  and checks the output instance-witness pair belongs to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> .</p>

    <p class="text-gray-300"><strong>Construction A.4.</strong> We define  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V},\\tilde{\\mathcal{V}})</span>  as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda})</span>  : Output  <span class="math">\\mathsf{pp}\\gets \\mathcal{G}_{\\mathrm{CAST}}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathsf{CAST}},\\mathsf{vk}_{\\mathsf{CAST}},\\mathbb{I}^{\\prime})\\gets \\mathcal{I}_{\\mathsf{CAST}}^{\\rho}(\\mathsf{pp},\\mathbb{I}).</span></li>

      <li>Output  <span class="math">(\\mathsf{pk},\\mathsf{vk}):= \\big(\\mathsf{pk}_{\\mathsf{CAST}},(\\mathsf{vk}_{\\mathsf{CAST}},\\mathbb{I}^{\\prime},\\mathsf{pp})\\big)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{P}^{\\rho}(\\mathsf{pk},\\mathbb{x},\\mathbb{w})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w})\\gets \\mathcal{P}_{\\mathrm{CAST}}^{\\rho}(\\mathrm{pk},\\mathbb{x},\\mathbb{w}).</span></li>

      <li>Assign  <span class="math">(\\pi .\\mathbb{x},\\pi .\\mathbb{w}):= (\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w})</span></li>

      <li>Output  <span class="math">\\pi \\coloneqq (\\pi .\\mathbb{x},\\pi .\\mathbb{w})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}^{\\rho}\\big(\\mathsf{vk}:= (\\mathsf{vk}_{\\mathsf{CAST}},\\mathbb{I}&#x27;,\\mathsf{pp}),\\mathbb{x},\\pi := (\\pi_{\\mathsf{CAST}},\\mathsf{acc.}\\mathbb{w})\\big)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute acc.  <span class="math">\\mathbb{x}\\gets \\mathcal{V}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{x},\\pi_{\\mathrm{CAST}})</span></li>

      <li>Check that  <span class="math">(\\mathbb{I}&#x27;,\\mathrm{acc.}\\mathbb{x},\\mathrm{acc.}\\mathbb{w})\\in \\mathcal{R}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{V}}^{\\rho}\\big(\\mathsf{vk}:= (\\mathsf{vk}_{\\mathsf{CAST}},\\mathbb{I}&#x27;,\\mathsf{pp}),\\mathbb{x},\\pi := (\\pi_{\\mathsf{CAST}},\\mathsf{acc.}\\mathbb{w})\\big)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute acc.  <span class="math">\\mathbb{x}\\gets \\mathcal{V}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{x},\\pi_{\\mathrm{CAST}})</span></li>

      <li>Check that  <span class="math">(\\mathbb{I}&#x27;,\\mathrm{acc.}\\mathbb{x},\\mathrm{acc.}\\mathbb{w})\\in \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span></li>

    </ol>

    <p class="text-gray-300"><strong>Lemma A.5.</strong> Construction A.4 (ARG) is a non-interactive argument for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Proof. Since ARG is a trivial wrapper around the non-interactive reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span> , the algorithms remain polynomial-time.</p>

    <p class="text-gray-300">Completeness. Since ARG is a trivial wrapper around the non-interactive reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span> , completeness follows immediately from the completeness of  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  and the fact that  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}^{\\rho}(\\mathsf{pp}) \\subseteq \\tilde{\\mathcal{R}}_{\\mathsf{ACC}}^{\\rho}(\\mathsf{pp})</span> .</p>

    <p class="text-gray-300">Knowledge soundness. Consider an arbitrary polynomial-time adversary  <span class="math">\\tilde{\\mathcal{P}}</span> . We construct an adversary  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{CAST}}</span>  against the non-interactive reduction  <span class="math">\\mathrm{RDX}_{\\mathrm{CAST}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathsf{ai})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathbb{I},\\mathbb{x},\\pi ,\\pi ;\\mathrm{tr})\\gets \\tilde{\\mathcal{P}} (\\mathsf{pp},\\mathsf{ai})</span></li>

      <li>Assign  <span class="math">(\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w}):= \\pi</span></li>

      <li>Output  <span class="math">(\\mathbb{I},\\mathbb{x},\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w};\\mathrm{tr})</span></li>

    </ol>

    <p class="text-gray-300">By the knowledge soundness of the non-interactive reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span> , there exists a corresponding extractor  <span class="math">\\mathcal{E}_{\\mathsf{CAST}}</span> . We construct an extractor for ARG as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathsf{pp},\\mathbb{I},\\mathbb{x},\\pi ,\\mathsf{ai},\\mathsf{tr})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assign  <span class="math">(\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w}):= \\pi</span></li>

      <li>Compute  <span class="math">\\mathbb{W}\\gets \\mathcal{E}_{\\mathrm{CAST}}(\\mathsf{pp},\\mathbb{I},\\mathbb{x},\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w},\\mathrm{ai},\\mathrm{tr})</span></li>

      <li>Output  <span class="math">\\mathbb{W}</span></li>

    </ol>

    <p class="text-gray-300">By the construction of the relaxed argument verifier  <span class="math">\\tilde{\\mathcal{V}}^{\\rho}</span> , knowledge soundness of RDX, and Remark 4.1, we have that</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left[\\begin{array}{c c}\\tilde{\\mathcal{V}}^{\\rho}(\\mathsf{vk},\\mathbb{x},\\pi) = 1&amp;\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ \\wedge &amp;amp; \\mathsf{pp}\\leftarrow \\mathcal{G}(1^{\\lambda})\\\\ \\mathbb{I}(\\mathbb{I},\\mathbb{x},\\mathbb{w})\\notin \\mathcal{R}^{\\rho}(\\mathsf{pp})&amp;amp; \\mathsf{ai}\\leftarrow \\mathcal{D}(1^{\\lambda})\\\\ &amp;amp; (\\mathbb{I},\\mathbb{x},\\pi ;\\mathsf{tr})\\leftarrow \\tilde{\\mathcal{P}}^{\\rho}(\\mathsf{pp},\\mathsf{ai})\\\\ &amp;amp; (\\mathsf{pk},\\mathsf{vk})\\leftarrow \\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ &amp;amp; \\mathbb{w}\\leftarrow \\mathcal{E}(\\mathsf{pp},\\mathbb{I},\\mathbb{x},\\pi ,\\mathsf{ai},\\mathsf{tr}) \\end{array}\\right]</span></p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname*{Pr}\\left[\\begin{array}{c c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ \\mathsf{pp}\\leftarrow \\mathcal{G}(1^{\\lambda})\\\\ \\mathsf{ai}\\leftarrow \\mathcal{D}(1^{\\lambda})\\\\ (\\mathbb{I},\\mathbb{x},\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w};\\mathrm{tr})\\leftarrow \\tilde{\\mathcal{P}}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathsf{ai})\\\\ (\\mathsf{pk}_{\\mathrm{CAST}},\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{I}^{\\prime})\\leftarrow \\mathcal{I}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ \\mathrm{acc.}\\mathbb{x}\\leftarrow \\mathcal{V}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{x},\\pi_{\\mathrm{CAST}})\\\\ \\mathbb{w}\\leftarrow \\mathcal{E}_{\\mathrm{CAST}}(\\mathsf{pp},\\mathbb{I},\\mathbb{x},\\pi_{\\mathrm{CAST}},\\mathrm{acc.}\\mathbb{w},\\mathsf{ai},\\mathsf{tr})\\end{array}\\right]\\leq \\mathrm{negl}(\\lambda).</span></p>

    <p class="text-gray-300">ACC Construction. The accumulation scheme (Construction A.6) for ARG (Construction A.4) can similarly be viewed as a simple wrapper around the non-interactive reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span> . The first step is to cast the argument verifier claims to claims for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . This is done by simply calling  <span class="math">\\mathcal{V}_{\\mathsf{CAST}}^{\\rho}</span> , which is used in the argument verifier to generate an instance  <span class="math">\\mathsf{acc}.\\mathbb{x}</span>  for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . Now that we have  <span class="math">m + n</span>  claims for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> , the prover and verifier both execute the reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span>  which exactly reduces  <span class="math">m + n</span>  claims for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>  to a single claim for  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . The accumulation proof pf is simply the reduction proof  <span class="math">\\pi_{\\mathsf{FOLD}}</span>  for  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span> , and the output accumulator is the output instance-witness pair in  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span> . The decider (relaxed decider) just check this pair belongs to  <span class="math">\\mathcal{R}_{\\mathsf{ACC}}</span>  ( <span class="math">\\tilde{\\mathcal{R}}_{\\mathsf{ACC}}</span> ).</p>

    <p class="text-gray-300"><strong>Construction A.6.</strong> We define  <span class="math">\\mathsf{ACC} = (\\mathcal{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D},\\tilde{\\mathrm{D}})</span>  as follows. The generator algorithm,  <span class="math">\\mathcal{G}</span> , is defined in Construction A.4.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathrm{CAST}},\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{I}^{\\prime})\\gets \\mathcal{I}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathbb{I}).</span></li>

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathsf{FOLD}},\\mathsf{vk}_{\\mathsf{FOLD}},\\mathbb{I}^{\\prime})\\gets \\mathcal{I}_{\\mathsf{FOLD}}^{\\rho}(\\mathsf{pp},\\mathbb{I}^{\\prime}).</span></li>

      <li>Output  <span class="math">\\mathsf{apk} := (\\mathsf{vk}_{\\mathsf{CAST}}, \\mathsf{pk}_{\\mathsf{FOLD}}, \\mathsf{vk}_{\\mathsf{FOLD}})</span> ,  <span class="math">\\mathsf{avk} := (\\mathsf{vk}_{\\mathsf{CAST}}, \\mathsf{vk}_{\\mathsf{FOLD}})</span> , and  <span class="math">\\mathsf{dk} := (\\mathbb{I}&#x27;, \\mathsf{pp})</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{P}^{\\rho}\\big(\\mathsf{apk}:= (\\mathsf{vk}_{\\mathsf{CAST}},\\mathsf{pk}_{\\mathsf{FOLD}},\\mathsf{vk}_{\\mathsf{FOLD}}),(\\mathsf{z}_i,\\pi_i)_{i\\in [n]},(\\mathsf{acc}_i)_{i\\in [m]}\\big):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i = 1,\\dots ,n</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">\\mathsf{acc}_{(m + i)}. \\mathbb{x} \\gets \\mathcal{V}_{\\mathsf{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathsf{CAST}}, \\mathbb{x}_i, \\pi_i.\\mathbb{x})</span>  and assign  <span class="math">\\mathsf{acc}_{(m + i)}.\\mathbb{w} := \\pi.\\mathbb{w}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\pi_{\\mathrm{FOLD}},\\mathrm{acc.}\\mathbb{w})\\gets \\mathcal{P}_{\\mathrm{FOLD}}^{\\rho}\\big(\\mathrm{pk}_{\\mathrm{FOLD}},(\\mathrm{acc}_i.\\mathbb{x})_{i\\in [m + n]},(\\mathrm{acc}_i.\\mathbb{w})_{i\\in [m + n]}\\big).</span></li>

      <li>Compute  <span class="math">\\mathsf{acc}.\\mathbb{x}\\gets \\mathcal{V}_{\\mathsf{FOLD}}^{\\rho}(\\mathsf{vk}_{\\mathsf{FOLD}},</span> <span class="math">(\\mathsf{acc}_i.\\mathbb{x})_{i\\in [m + n]},\\pi_{\\mathsf{FOLD}})</span></li>

      <li>Output  <span class="math">\\mathsf{acc} \\gets (\\mathsf{acc}. \\mathbb{x}, \\mathsf{acc}. \\mathbb{w})</span>  and  <span class="math">\\mathsf{pf} \\gets \\pi_{\\mathsf{FOLD}}</span> .</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{\\rho}\\big(\\mathsf{avk}:= (\\mathsf{vk}_{\\mathsf{CAST}},\\mathsf{vk}_{\\mathsf{FOLD}}),(\\mathsf{z}_i,\\pi_i.\\mathsf{z})_{i\\in [n]},(\\mathsf{acc}_i.\\mathsf{z})_{i\\in [m]},\\mathsf{acc}.\\mathsf{z},\\mathsf{pf}\\big):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i = 1,\\dots ,n</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">\\mathsf{acc}_{(m + i)}.\\mathbb{x}\\gets \\mathcal{V}_{\\mathsf{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathsf{CAST}},\\mathbb{x}_i,\\pi_i.\\mathbb{x}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">\\mathsf{acc}.\\mathbb{x} = \\mathcal{V}_{\\mathsf{FOLD}}^{\\rho}(\\mathsf{vk}_{\\mathsf{FOLD}},</span> <span class="math">(\\mathsf{acc}_i.\\mathbb{x})_{i\\in [m + n]},\\mathsf{pf})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{D}^{\\rho}(\\mathrm{dk} = (\\mathbb{I}&#x27;,\\mathrm{pp}),\\mathrm{acc})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">(\\mathbb{I}&#x27;,\\mathrm{acc}.\\mathbb{x},\\mathrm{acc}.\\mathbb{w})\\in \\mathcal{R}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathrm{D}}^{\\rho}(\\mathrm{dk} = (\\mathbb{I}&#x27;,\\mathrm{pp}),\\mathrm{acc})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">(\\mathbb{I}&#x27;,\\mathrm{acc}.\\mathbb{x},\\mathrm{acc}.\\mathbb{w})\\in \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span></li>

    </ol>

    <p class="text-gray-300">Proof. Since ACC is a trivial wrapper around  <span class="math">\\mathsf{RDX}_{\\mathsf{CAST}}</span>  and  <span class="math">\\mathsf{RDX}_{\\mathsf{ACC}}</span> , the algorithms remain polynomial-time.</p>

    <p class="text-gray-300">Completeness. By construction of  <span class="math">\\mathcal{V}^{\\rho}</span>  and  <span class="math">\\mathrm{D}^{\\rho}</span> , if  <span class="math">\\forall i\\in [n]</span> ,  <span class="math">\\mathcal{V}^{\\rho}(\\mathsf{vk},\\mathbb{x}_i,\\pi_i) = 1</span>  and  <span class="math">\\forall j\\in [m]</span> ,  <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc}_j) = 1</span> , then  <span class="math">[\\mathrm{acc}_i.\\mathbb{x},\\mathrm{acc}_i.\\mathbb{w}]_{i\\in [m + n]}\\in \\mathcal{R}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span> . Thus, since ACC is a trivial wrapper around  <span class="math">\\mathrm{RDX}_{\\mathrm{ACC}}</span> , completeness follows immediately from the completeness of  <span class="math">\\mathrm{RDX}_{\\mathrm{ACC}}</span>  and the fact that  <span class="math">\\mathcal{R}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})\\subseteq \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho}(\\mathrm{pp})</span> .</p>

    <p class="text-gray-300">Knowledge Soundness. Consider an arbitrary polynomial-time adversary  <span class="math">\\tilde{\\mathrm{P}}</span> . We construct an adversary  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{FOLD}}</span>  against the non-interactive reduction  <span class="math">\\mathrm{RDX}_{\\mathrm{FOLD}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{FOLD}}^{\\rho}(\\mathrm{pp},\\mathrm{ai})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathbb{I},\\left[\\mathbb{X}_i,\\pi_i.\\mathbb{X}\\right]_{i\\in [n]},[\\mathrm{acc}_i.\\mathbb{X}]_{i\\in [m]},\\mathrm{acc},\\mathrm{pf};\\mathrm{tr})\\gets \\tilde{\\mathrm{P}}^{\\rho}(\\mathrm{pp},\\mathrm{ai}).</span></li>

      <li>Assign  <span class="math">(\\mathrm{acc}.\\mathbb{X},\\mathrm{acc}.\\mathbb{W}):= \\mathrm{acc}</span>  and  <span class="math">\\pi_{\\mathrm{FOLD}}\\coloneqq \\mathrm{pf}</span></li>

      <li>Compute  <span class="math">(\\mathsf{pk}_{\\mathrm{CAST}},\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{I}^{\\prime})\\gets \\mathcal{I}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathbb{I}).</span></li>

      <li>For each  <span class="math">i = 1,\\dots ,n</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">\\mathsf{acc}_{(m + i)}.\\mathbb{X}\\gets \\mathcal{V}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{X}_i,\\pi_i.\\mathbb{X}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(\\mathbb{I}&#x27;, [\\mathrm{acc}_i.\\mathbb{X}]_{i \\in [m + n]}, \\pi_{\\mathrm{FOLD}}, \\mathrm{acc}.\\mathbb{W}; \\mathrm{tr})</span></li>

    </ol>

    <p class="text-gray-300">By the knowledge soundness of the non-interactive reduction  <span class="math">\\mathsf{RDX}_{\\mathsf{FOLD}}</span> , there exists a corresponding extractor  <span class="math">\\mathcal{E}_{\\mathsf{FOLD}}</span> . We construct an extractor for ACC as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{E}\\big(\\mathrm{pp},\\mathbb{I}^{\\prime},\\left[\\mathbb{X}_i,\\pi_i.\\mathbb{X}\\right]_{i\\in [n]},[\\mathrm{acc}_i.\\mathbb{X}]_{i\\in [m]},\\mathrm{acc},\\mathrm{pf},\\mathrm{ai};\\mathrm{tr}\\big):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assign  <span class="math">(\\mathrm{acc}.\\mathbb{X},\\mathrm{acc}.\\mathbb{W}):= \\mathrm{acc}</span>  and  <span class="math">\\pi_{\\mathrm{FOLD}}\\coloneqq \\mathrm{pf}</span></li>

      <li>Compute  <span class="math">[\\mathrm{acc}_i.\\mathbb{W}]_{i\\in [m + n]}\\gets \\mathcal{E}_{\\mathrm{FOLD}}(\\mathrm{pp},\\mathbb{I}&#x27;,[\\mathrm{acc}_i.\\mathbb{X}]_{i\\in [m + n]},\\pi_{\\mathrm{FOLD}},\\mathrm{acc}.\\mathbb{W},\\mathrm{ai},\\mathrm{tr}).</span></li>

      <li>Assign  <span class="math">[\\pi_i.\\mathbb{W}]_{i\\in [n]}\\coloneqq [\\mathrm{acc}_i.\\mathbb{W}]_{i\\in [m + 1]}^{m + n}</span></li>

      <li>Output  <span class="math">\\left([ \\pi_i. \\mathbb{W} ]_{i \\in [n]}, [ \\mathrm{acc}_j. \\mathbb{W} ]_{j \\in [m]}\\right)</span> .</li>

    </ol>

    <p class="text-gray-300">By construction of the relaxed argument verifier  <span class="math">\\tilde{\\mathcal{V}}</span>  and relaxed decider  <span class="math">\\tilde{\\mathrm{D}}</span> , construction of the accumulation verifier  <span class="math">\\mathrm{V}</span>  and  <span class="math">\\tilde{\\mathrm{P}}_{\\mathrm{FOLD}}</span> , and by knowledge soundness of  <span class="math">\\mathrm{RDX}_{\\mathrm{FOLD}}</span> , we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V\\(\\left( \\begin{array}{c}\\text{avk},[\\mathbf{z}_i,\\pi_i.\\mathbf{x}]_{i\\in[n]},\\\\ [acc_i.\\mathbf{x}]_{i\\in[m]},acc.\\mathbf{x},pf\\end{array} \\right)=1\\) \\(\\wedge \\tilde{\\mathrm{D}} (\\mathrm{dk},\\mathrm{acc})=1\\) \\(\\wedge\\) \\(\\exists i\\in [n],\\tilde{\\mathcal{V}}^{\\rho}(\\mathsf{vk},\\mathbf{z}_i,\\pi_i)\\neq 1\\) \\(\\vee \\exists j\\in [m],\\tilde{\\mathrm{D}} (\\mathrm{dk},\\mathrm{acc}_j)\\neq 1\\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\begin{array}{c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ \\mathsf{pp}\\leftarrow \\mathcal{G}(1^{\\lambda})\\\\ \\mathsf{ai}\\leftarrow \\mathcal{D}(1^{\\lambda})\\\\ \\left( \\begin{array}{c}\\mathbb{I},[\\mathbf{z}_i,\\pi_i.\\mathbf{x}]_{i\\in[n]},\\\\ [acc_i.\\mathbf{x}]_{i\\in[m]},acc,pf\\\\ (\\mathsf{pk},\\mathsf{vk})\\leftarrow \\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ (\\mathsf{apk},\\mathsf{avk},\\mathsf{dk})\\leftarrow \\mathsf{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ \\left([\\pi_i.\\mathbf{w}]_{i\\in[n]},[\\mathbf{acc}_j.\\mathbf{w}]_{j\\in[m]}\\right)\\\\ \\leftarrow \\mathrm{E}\\left( \\begin{array}{c}\\mathsf{pp},\\mathbb{I},[\\mathbf{z}_i,\\pi_i.\\mathbf{x}]_{i\\in[n]},\\\\ [acc_i.\\mathbf{x}]_{i\\in[m]},acc,pf\\\\ \\end{array} ,ai;tr\\right)\\end{array}\\)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≤Pr</td>

            <td class="px-3 py-2 border-b border-gray-700">V\\(\\left( \\begin{array}{c}\\text{avk},[\\mathbf{z}_i,\\pi_i.\\mathbf{x}]_{i\\in[n]},\\\\ [acc_i.\\mathbf{x}]_{i\\in[m]},acc.\\mathbf{x},pf\\end{array} \\right)=1\\) \\(\\wedge \\tilde{\\mathrm{D}} (\\mathrm{dk},\\mathrm{acc})=1\\) \\(\\wedge\\) \\([(l',acc_i.x,acc_i.w)]_{i\\in[m+n]}\\notin \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho,m+n}(\\mathsf{pp})\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\(\\begin{array}{c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ \\mathsf{pp}\\leftarrow \\mathcal{G}(1^{\\lambda})\\\\ \\mathsf{ai}\\leftarrow \\mathcal{D}(1^{\\lambda})\\\\ \\left( \\begin{array}{c}\\mathbb{I},[\\mathbf{z}_i,\\pi_i.x]_{i\\in[n]},\\\\ [acc_i.x]_{i\\in[m]},acc,pf\\\\ (\\mathsf{pk},\\mathsf{vk})\\leftarrow \\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ (\\mathsf{apk},\\mathsf{avk},\\mathsf{dk})\\leftarrow \\mathsf{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ (\\mathsf{pk}_{\\mathrm{CAST}},\\mathsf{vk}_{\\mathrm{CAST}},\\mathbb{I}')\\leftarrow \\mathcal{I}_{\\mathrm{CAST}}^{\\rho}(\\mathsf{pp},\\mathbb{I})\\\\ \\forall i\\in [n],acc_{(m+i)}.x\\leftarrow V_{\\mathrm{CAST}}^{\\rho}(\\mathsf{vk}_{\\mathrm{CAST}},\\mathbf{z}_i,\\pi_i.x)\\\\ \\left([acc_{(m+i)}.w]_{i\\in[n]},[acc_j.w]_{j\\in[m]}\\right)\\\\ \\leftarrow \\mathrm{E}\\left( \\begin{array}{c}\\mathsf{pp},\\mathbb{I},[\\mathbf{z}_i,\\pi_i.x]_{i\\in[n]},\\\\ [acc_i.x]_{i\\in[m]},acc,pf\\\\ \\end{array} ,ai;tr\\right)\\end{array}\\)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≤Pr</td>

            <td class="px-3 py-2 border-b border-gray-700">\\(\\left( l',acc.x,acc.w \\right) \\in \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho}(\\mathsf{pp})\\) \\(\\wedge\\) \\([(l',acc_i.x,acc_i.w)]_{i\\in[m+n]} \\notin \\tilde{\\mathcal{R}}_{\\mathrm{ACC}}^{\\rho,m+n}(\\mathsf{pp})\\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\(\\begin{array}{c}\\rho \\leftarrow \\mathcal{U}(\\lambda)\\\\ \\mathsf{pp}\\leftarrow \\mathcal{G}(1^{\\lambda})\\\\ \\mathsf{ai}\\leftarrow \\mathcal{D}(1^{\\lambda})\\\\ \\left( \\begin{array}{c}\\mathbb{I}',[\\mathbf{acc}_i.x]_{i\\in[m+n]},\\\\ \\pi_{\\mathrm{FOLD}},acc.w\\\\ (\\mathsf{pk}_{\\mathrm{FOLD}},\\mathsf{vk}_{\\mathrm{FOLD}},\\mathbb{I}')\\leftarrow \\mathcal{I}_{\\mathrm{FOLD}}^{\\rho}(\\mathsf{pp},\\mathbb{I}')\\\\ \\mathrm{acc}.x\\leftarrow V_{\\mathrm{FOLD}}^{\\rho}(\\mathsf{vk}_{\\mathrm{FOLD}},[\\mathbf{acc}_i.x]_{i\\in[m+n]},\\pi_{\\mathrm{FOLD}})\\\\ [acc_i.w]_{i\\in[m+n]}\\leftarrow \\mathcal{E}_{\\mathrm{FOLD}}\\left( \\begin{array}{c}\\mathsf{pp},\\mathbb{I}',[\\mathbf{acc}_i.x]_{i\\in[m+n]},\\\\ \\pi_{\\mathrm{FOLD}},acc.w,ai,tr\\\\ \\end{array} \\right)\\end{array}\\)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq \\mathrm{negl}(\\lambda)</span></p>

    <p class="text-gray-300">B Proof of Theorem 5.9</p>

    <p class="text-gray-300">We first recall Theorem 5.9 and give a full description of the transformation <span class="math">\\mathrm{T}</span> in Construction B.2. To prove knowledge soundness, we follow the modular approach outlined in <em>[x10, Section 26.1.2]</em>. In more detail, we decompose <span class="math">\\mathrm{T}=\\mathsf{FS}\\circ\\mathrm{T}_{\\mathsf{i}}</span> into two transformations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{T}_{\\mathsf{i}}</span> takes an interactive oracle reduction from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}^{\\prime}</span> and returns an <em>interactive reduction</em> (in the ROM) from <span class="math">\\mathsf{Com}[\\mathcal{R}]</span> to <span class="math">\\mathsf{Com}[\\mathcal{R}^{\\prime}]</span>. In Appendix B.2 we show that if <span class="math">\\mathsf{IOR}</span> is state-restoration knowledge sound, then so is the interactive reduction.</li>

      <li>The Fiat–Shamir transformation <span class="math">\\mathsf{FS}</span> takes an interactive reduction (in the ROM) and returns a non-interactive reduction (in the ROM) between the same relations. In Appendix B.3 we show that if the interactive reduction is state-restoration knowledge sound, then the non-interactive reduction is knowledge sound.</li>

    </ul>

    <h6 id="sec-73" class="text-base font-medium mt-4">Theorem 5.9.</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that the following holds. Let <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}^{\\prime}</span> be indexed promise relations (with strings). Let <span class="math">S</span> and <span class="math">S^{\\prime}</span> be efficiently computable sets parameterized by <span class="math">\\lambda\\in\\mathbb{N}</span>. Let <span class="math">\\mathsf{IOR}</span> be an interactive oracle reduction (also parameterized by <span class="math">\\lambda</span>) from <span class="math">\\mathcal{R}</span> to <span class="math">\\mathcal{R}^{\\prime}</span> such that the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{IOR}</span> has round-by-round knowledge error <span class="math">\\kappa_{\\mathsf{rbr}}</span> such that</li>

    </ul>

    <p class="text-gray-300">\\[ \\max_{\\begin{subarray}{c}\\mathbb{I},\\mathsf{z}\\in S(\\lambda)\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda)\\end{subarray}}\\kappa_{\\mathsf{rbr}}(\\lambda,\\mathbb{I},\\mathsf{z})=\\mathrm{negl}(\\lambda). \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and index <span class="math">\\mathbb{I}\\in S(\\lambda)</span>, the IOR indexer outputs a new index <span class="math">\\mathbb{I}^{\\prime}\\in S^{\\prime}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">Then <span class="math">\\mathrm{T}[\\mathsf{IOR}]</span> is a non-interactive reduction from <span class="math">\\mathsf{Com}[\\mathcal{R},S]</span> to <span class="math">\\mathsf{Com}[\\mathcal{R}^{\\prime},S^{\\prime}]</span> with the following efficiency measures:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size: $O(\\lambda\\cdot\\mathsf{k}+\\mathsf{s}+\\mathsf{q}\\cdot(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\lambda\\cdot\\log\\mathsf{L}_{\\mathsf{max}}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier complexity: IOR verifier, plus <span class="math">O(\\mathsf{k}+\\mathsf{q}\\cdot\\log\\mathsf{L}_{\\mathsf{max}})</span> queries to the random oracle.</li>

    </ul>

    <h6 id="sec-74" class="text-base font-medium mt-4">Construction B.2.</h6>

    <p class="text-gray-300">Given <span class="math">\\mathsf{IOR}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>, <span class="math">\\mathrm{T}[\\mathsf{IOR}]=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> is defined as follows. We use domain separation to split the random oracle <span class="math">\\rho</span> into a Merkle tree oracle <span class="math">\\rho_{\\mathsf{MT}}</span> and Fiat–Shamir oracle <span class="math">\\rho_{\\mathsf{FS}}</span>. The Fiat–Shamir oracle is further split into oracles for each of the verifier’s challenges: <span class="math">\\rho_{\\mathsf{FS}}=(\\rho_{i})_{i\\in[\\mathsf{k}]}</span>, <span class="math">\\rho_{i}\\sim\\mathcal{U}(\\mathsf{r}_{i})</span>. Without loss of generality, assume that the verifier’s challenges are at least <span class="math">\\lambda</span> bits.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathsf{pp}=1^{\\lambda}</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{I})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the IOR indexer <span class="math">(\\iota,\\mathbb{I}):=\\mathbf{I}(1^{\\lambda},\\mathbb{I})</span>.</li>

      <li>Commit to the index string <span class="math">(\\mathsf{icm},\\mathsf{itd})\\leftarrow\\mathsf{MT.Commit}^{\\rho_{\\mathsf{MT}}}(\\mathbb{I})</span>.</li>

      <li>Output <span class="math">\\mathsf{pk}:=(\\mathsf{pp},\\mathbb{I},\\iota,\\mathbb{I},\\mathsf{icm},\\mathsf{itd})</span> and <span class="math">\\mathsf{vk}:=(\\iota,\\mathsf{icm})</span>.</li>

    </ol>

    <h2 id="sec-75" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300"><span class="math">\\mathcal{P}^{\\rho}(\\mathsf{pk},(\\mathsf{z},\\mathsf{cm}),(\\mathsf{w},\\vec{\\mathsf{y}},\\mathsf{td}))</span>  ：</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,\\dots ,k</span></li>

    </ol>

    <p class="text-gray-300">(a) Compute the  <span class="math">i</span> -th proof string</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf {s t} _ {i}, \\Pi_ {i}) \\leftarrow \\left\\{ \\begin{array}{l l} \\mathbf {P} (1 ^ {\\lambda}, \\mathbb {I}, \\mathsf {z}, \\vec {\\mathsf {y}}, \\mathsf {w}) &amp;amp; i = 1 \\\\ \\mathbf {P} (\\mathsf {s t} _ {i - 1}, r _ {i - 1}) &amp;amp; i &amp;gt; 1 \\end{array} \\right.</span></div>

    <p class="text-gray-300">(b) Commit to the  <span class="math">i</span> -th proof string  <span class="math">(\\mathsf{pcm}_i, \\mathsf{ptd}_i) \\gets \\mathsf{MT}. \\mathsf{Commit}^{\\rho_{\\mathrm{MT}}}(\\Pi_i)</span> . (c) Derive the  <span class="math">i</span> -th challenge</p>

    <div class="my-4 text-center"><span class="math-block">r _ {i} := \\left\\{ \\begin{array}{l l} \\rho_ {1} (\\iota , \\mathsf {i c m}, \\mathsf {z}, \\mathsf {c m} _ {1}, \\ldots , \\mathsf {c m} _ {\\mathsf {n}}, \\mathsf {p c m} _ {1}) &amp;amp; i = 1 \\\\ \\rho_ {i} (r _ {i - 1}, \\mathsf {p c m} _ {i}) &amp;amp; i &amp;gt; 1 \\end{array} \\right.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the IOR prover's output  <span class="math">\\mathsf{w}^{\\prime}\\gets \\mathbf{P}(\\mathsf{st}_{\\mathbf{k}},r_{\\mathbf{k}})</span></li>

      <li>Compute the IOR verifier's output  <span class="math">(\\mathbf{z}&#x27;,\\vec{s})\\gets \\mathbf{V}^{\\mathbb{I},\\vec{\\mathbf{y}},\\vec{\\Pi}}(\\iota ,\\mathbf{z},\\vec{r})</span>  . Record the queries made by the IOR verifier to the index, instance, and proof strings.</li>

      <li>Select new instance strings and trapdoors: for  <span class="math">j = 1, \\dots, n&#x27;</span> , let  <span class="math">\\mathbf{y}_j&#x27; := \\operatorname{Select}(\\vec{\\mathbf{y}}, \\vec{\\Pi}, s_j)</span>  and  <span class="math">\\mathrm{td}_j&#x27; := \\operatorname{Select}(\\vec{\\mathrm{td}}, \\vec{\\mathrm{ptd}}, s_j)</span> .</li>

      <li>Set answers and compute opening proofs:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Let  $\\mathsf{ans}_1\\coloneqq \\mathbb{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q^{\\mathbb{I}}}<span class="math">  and  </span>\\mathsf{pf}_1\\coloneqq \\mathsf{MT}.\\mathsf{Open}(\\mathsf{itd},Q^{\\mathbb{I}})<span class="math"> , where  </span>Q^{\\mathbb{I}}<span class="math">  denotes the set of queries made by the IOR verifier to the index string  </span>\\mathbb{I}$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(c) For  <span class="math">i = 1, \\ldots, m</span> , let  $\\mathsf{ans}_{1 + n + i} := \\Pi_i</td>

            <td class="px-3 py-2 border-b border-gray-700">_{Q_i^{\\mathfrak{p}}}<span class="math">  and  </span>\\mathsf{pf}_{1 + n + i} := \\mathsf{MT}. \\mathsf{Open}(\\mathsf{td}, Q_i^{\\mathfrak{p}})<span class="math"> , where  </span>Q_i^{\\mathfrak{p}}<span class="math">  denotes the set of queries made by the IOR verifier to the  </span>i<span class="math"> -th proof string  </span>\\Pi_i$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\pi := (\\mathsf{p}\\vec{\\mathsf{cm}},\\mathsf{a}\\vec{\\mathsf{ns}},\\mathsf{p}\\vec{\\mathsf{f}})</span>  and  <span class="math">(\\mathsf{w}^{\\prime},\\vec{\\mathsf{y}}^{\\prime},\\mathsf{td}^{\\prime})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}^{\\rho}(\\mathsf{vk},(\\mathsf{z},\\mathsf{cm}),\\pi)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check opening proofs:</li>

    </ol>

    <p class="text-gray-300">(a) If MT.Check <span class="math">^{\\rho_{\\mathrm{MT}}}</span>  (icm, ans1, pf1) rejects, output  <span class="math">\\perp</span> . (b) For  <span class="math">j = 1,\\dots ,\\mathsf{n}</span>  , if MT.Check  <span class="math">\\rho_{\\mathrm{MT}}(\\mathsf{cm}_j,\\mathsf{ans}_{1 + j},\\mathsf{pf}_{1 + j})</span>  rejects, output  <span class="math">\\perp</span> (c) For  <span class="math">i = 1,\\dots ,\\mathsf{k}</span>  , if MT.Check  <span class="math">\\rho_{\\mathrm{MT}}(\\mathsf{pcm}_i,\\mathsf{ans}_{1 + n + i},\\mathsf{pf}_{1 + n + i})</span>  rejects, output  <span class="math">\\perp</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,\\dots ,\\mathsf{k}</span>  : derive the  <span class="math">i</span>  -th challenge</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">r _ {i} := \\left\\{ \\begin{array}{l l} \\rho_ {1} (\\iota , \\mathsf {i c m}, \\mathsf {z}, \\mathsf {c m} _ {1}, \\ldots , \\mathsf {c m} _ {\\mathsf {n}}, \\mathsf {p c m} _ {1}) &amp;amp; i = 1 \\\\ \\rho_ {i} (r _ {i - 1}, \\mathsf {p c m} _ {i}) &amp;amp; i &amp;gt; 1 \\end{array} \\right.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the IOR verifier's output  <span class="math">(\\mathbf{z}&#x27;,\\vec{s})\\gets \\mathbf{V}^{\\mathrm{a}\\vec{\\mathrm{ns}}}(\\iota ,\\mathbf{z},\\vec{r})</span></li>

      <li>Select new commitments: for  <span class="math">j = 1, \\dots, n&#x27;</span> , let  <span class="math">\\mathsf{cm}_j&#x27; := \\mathsf{Select}(\\mathsf{cm}, \\mathsf{p}\\vec{\\mathsf{cm}}, s_j)</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output</li>

    </ol>

    <p class="text-gray-300">(\\mathbf{z}',\\mathsf{cm}')</p>

    <p class="text-gray-300">Proof of Theorem 5.9. Let  <span class="math">\\mathbf{E}</span>  be the IOR state-restoration extractor,  <span class="math">\\mathcal{E}_{\\mathrm{i}}\\coloneqq \\mathcal{E}_{\\mathrm{i}}[\\mathbf{E}]</span>  be the IR state-restoration extractor from Lemma B.6, and  <span class="math">\\mathcal{E}\\coloneqq \\mathcal{E}[\\mathcal{E}_{\\mathrm{i}}]</span>  be the non-interactive reduction extractor from Lemma B.9; these are all straightline extractors. Let  <span class="math">\\tilde{\\mathcal{P}}</span>  be a non-interactive reduction prover which outputs at most  <span class="math">n</span>  bits, makes at most  <span class="math">t_{\\mathrm{MT}}</span>  queries to  <span class="math">\\rho_{\\mathrm{MT}}</span> , and makes at most  <span class="math">t_{\\mathrm{FS}}</span>  queries to  <span class="math">\\rho_{\\mathrm{FS}}</span> . Let  <span class="math">\\bar{\\mathbf{x}} = (\\mathbf{z},\\mathbf{c}\\bar{\\mathbf{m}})</span>  and  <span class="math">\\bar{\\omega} = (\\omega ,\\vec{\\gamma},\\mathrm{td})</span>  denote an instance and witness in the committed relations. The knowledge error of  <span class="math">\\tilde{\\mathcal{P}}</span>  is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ := Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄, ω) ∉ Com[ˆR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S]ρ(pp)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ := U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  pp ← G(1λ)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥', x̄', ω') ∈ Com[ˆR'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S']ρ(pp)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄, π, ω') ←tr Pρ(pp)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ω := E(∥, x̄, π, ω', tr)  |</p>

    <p class="text-gray-300">|   |   |  (pk, vk, ∥') := Iρ(pp, ∥) x̄' := Vρ(vk, x̄, π)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since committed relations do not access  <span class="math">\\rho_{\\mathrm{FS}}</span> , it will be convenient to define the relations relative to  <span class="math">\\rho_{\\mathrm{MT}}</span>  and explicitly sample the individual oracles. Define  $Z := \\{(\\mathbb{I}, \\bar{\\mathbf{x}} = (\\mathbf{z}, \\mathbf{c}\\bar{\\mathbf{m}}): (\\mathbb{I}, \\mathbf{z}) \\in S(\\lambda),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n\\}$ . Rewriting, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ ≤ Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄) ∈ Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ρFS← U(λ)  |</p>

    <p class="text-gray-300">|   |   |  ρ := (ρMT, ρFS)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄, ω) ∉ Com[ˆR]ρMT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄, π, ω') ← Pρ</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  (pk, vk, ∥') := Iρ(1λ, ∥)  |</p>

    <p class="text-gray-300">|   |   |  x̄' := Vρ(vk, x̄, π)  |</p>

    <p class="text-gray-300">From Lemma B.9, we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ ≤ Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄) ∈ Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ρSR← U(λ)  |</p>

    <p class="text-gray-300">|   |   |  (∥, x̄, ω) ∉ Com[ˆR]ρMT  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥', x̄', ω') ∈ Com[ˆR']ρMT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, x̄, α, ω', r̂) ←tr GameIR(ρSR, P̂i[ˆP]ρMT)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ω := E1(∥, x̄, α, ω', tr)  |</p>

    <p class="text-gray-300">|   |   |  (pk, vk, ∥') := I1(1λ, ∥) x' := V1ρMT(vk, x, α, r̂)  |</p>

    <p class="text-gray-300">From Lemma B.6, we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ ≤ Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∥</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≤ n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ρSR← U(λ)  |</p>

    <p class="text-gray-300">|   |   |  (∥, z, ŷ, Π, w', r̂) ←tr GameIOR(ρSR, P̂[P̂i[P̂]]ρMT)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥, z, ŷ, ω) ∉ R̂</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ω := E(∥, z, ŷ, Π, w', tr)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  (z', ŷ') := V1,ŷ,Π(ι, z, r̂)  |</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\kappa_ {\\mathrm {M T}} (\\lambda , t _ {\\mathrm {M T}}, \\mathsf {L} _ {\\max }, 1 + \\mathsf {n} + \\mathsf {k}) + \\frac {t _ {\\mathrm {F S}} ^ {2}}{2 ^ {\\lambda}}.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Observe that  <span class="math">\\tilde{\\mathbf{P}}[\\tilde{\\mathcal{P}}_{\\downarrow}[\\tilde{\\mathcal{P}}]]</span>  makes at most  <span class="math">t_{\\mathrm{FS}}</span>  moves. By straightline state-restoration knowledge soundness of IOR, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa \\leq \\kappa_ {\\mathsf {S R}} (\\lambda , t _ {\\mathsf {F S}}, n) + \\kappa_ {\\mathsf {M T}} (\\lambda , t _ {\\mathsf {M T}}, \\mathsf {L} _ {\\mathsf {s a x}}, 1 + \\mathsf {n} + \\mathsf {k}) + \\frac {t _ {\\mathsf {F S}} ^ {2}}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">Setting  <span class="math">n = \\mathrm{poly}(\\lambda)</span> ,  <span class="math">t_{\\mathrm{FS}} = \\mathrm{poly}(\\lambda)</span> , and  <span class="math">t_{\\mathrm{MT}} = \\mathrm{poly}(\\lambda)</span> ,  <span class="math">\\mathsf{n} = \\mathrm{poly}(\\lambda)</span> , and  <span class="math">\\mathsf{k} = \\mathrm{poly}(\\lambda)</span> , we get  <span class="math">\\kappa = \\mathrm{negl}(\\lambda)</span> .</p>

    <h2 id="sec-76" class="text-2xl font-bold">B.1 State-restoration soundness</h2>

    <p class="text-gray-300">We define state-restoration soundness for IORs, and show that round-by-round knowledge soundness implies state-restoration soundness.</p>

    <p class="text-gray-300"><strong>Definition B.3.</strong> The IOR state restoration game Game <span class="math">_{\\text{IOR}}</span>  with functions  <span class="math">\\rho = (\\rho_i)_{i \\in [\\mathsf{k}]}</span>  and adversary  <span class="math">\\tilde{\\mathbf{P}}</span>  is defined below.</p>

    <p class="text-gray-300"><strong>Game <span class="math">_{\\text{IOR}}</span> <span class="math">(\\rho, \\tilde{\\mathbf{P}})</span></strong>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Repeat the following until  <span class="math">\\tilde{\\mathbf{P}}</span>  exists the loop:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\tilde{\\mathbf{P}}</span>  sends a move  <span class="math">(\\mathbb{I},\\mathbb{z},\\vec{y},(\\Pi_1,\\dots ,\\Pi_i))</span>  with  <span class="math">i\\in [\\mathsf{k}]</span> (b) Set  <span class="math">r_i \\coloneqq \\rho_i(\\mathbb{I},\\mathbb{z},\\vec{y},(\\Pi_1,\\dots ,\\Pi_i))</span> (c) Return  <span class="math">r_i</span>  to  <span class="math">\\tilde{\\mathbf{P}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{\\mathbf{P}}</span>  outputs  <span class="math">(\\mathbb{I},\\mathbb{z},\\vec{y},(\\Pi_1,\\dots ,\\Pi_k),\\mathsf{w}&#x27;,(A_1,\\dots ,A_{n&#x27;}))</span></li>

      <li>For each  <span class="math">i = 1,\\dots ,\\mathsf{k}</span>  set  <span class="math">r_i\\coloneqq \\rho_i(\\mathbb{I},\\mathbb{z},(\\Pi_1,\\ldots ,\\Pi_i))</span></li>

      <li>Output  <span class="math">(\\mathbb{I},\\mathbb{z},(\\Pi_i)_{i\\in [\\mathsf{k}]},\\mathsf{w}&#x27;,(A_j)_{j\\in [\\mathsf{n}&#x27;]},(r_i)_{i\\in [\\mathsf{k}]}.</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">\\operatorname{tr}</span>  denote the list of move-response pairs performed in the loop. We use the following notation to describe an execution of the state-restoration game:</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb {I}, \\mathbb {z}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\vec {A}, \\vec {r}) \\stackrel {{\\mathrm {t r}}} {{\\leftarrow}} \\operatorname {G a m e} _ {\\mathrm {I O R}} (\\rho , \\tilde {\\mathbf {P}}).</span></div>

    <p class="text-gray-300"><strong>Definition B.4.</strong> IOR has straightline state-restoration knowledge error  <span class="math">\\kappa_{\\mathrm{sr}}</span>  if the following holds. There exists a polynomial-time extractor  <span class="math">\\mathbf{E}</span>  such that for every move budget  <span class="math">t \\in \\mathbb{N}</span> ,  <span class="math">t</span> -move deterministic adversary  <span class="math">\\tilde{\\mathbf{P}}</span> , parameters  <span class="math">\\mathbb{P}</span> , and set  <span class="math">S</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {P r} \\left[ \\begin{array}{c c} &amp; \\rho = (\\rho_ {i}) _ {i \\in [ \\mathsf {k} ]} \\leftarrow \\mathcal {U} ((r _ {i}) _ {i \\in [ \\mathsf {k} ]}) \\\\ (\\mathbb {I}, \\mathbb {z}) \\in S &amp; (\\mathbb {I}, \\mathbb {z}, \\vec {y}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\vec {A}, \\vec {r}) \\xleftarrow {\\mathrm {t r}} \\mathsf {G a m e} _ {\\mathsf {I O R}} (\\rho , \\tilde {\\mathbf {P}}) \\\\ (\\mathbb {I}, \\mathbb {z}, \\vec {y}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} &amp; (\\iota , \\mathbb {I}, \\mathbb {I} ^ {\\prime}) := \\mathbf {I} (\\mathbb {p}, \\mathbb {I}) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {z} ^ {\\prime}, \\vec {y} ^ {<em>}, \\mathbb {w} ^ {\\prime}) \\in \\tilde {\\mathcal {R}} ^ {\\prime} &amp; (\\mathbb {z} ^ {\\prime}, \\vec {s}) := \\mathbf {V} ^ {\\mathbb {I}, \\vec {y}, \\vec {\\Pi}} (\\iota , \\mathbb {z}, \\vec {r}) \\\\ &amp; \\forall j \\in [ \\mathsf {n} ^ {\\prime} ], \\mathsf {y} _ {j} ^ {</em>} := \\mathsf {S e l e c t} (\\vec {y}, \\vec {\\Pi}, s _ {j})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {A _ {j}} \\\\ &amp; \\mathbb {w} \\leftarrow \\mathbf {E} (\\mathbb {p}, \\mathbb {I}, \\mathbb {z}, \\vec {y}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\vec {A}, \\mathsf {t r}) \\end{array} \\right] \\leq \\kappa_ {\\mathsf {s r}} (t, \\mathbb {p}, S).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Theorem B.5.</strong> Suppose that  <span class="math">\\mathcal{R}&#x27;</span>  is monotone. If IOR has round-by-round knowledge error  <span class="math">\\kappa_{\\mathrm{rbr}}</span> , then IOR has straightline state-restoration knowledge error</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_ {\\mathbf {s r}} (t, \\mathbb {p}, S) := \\max  _ {(\\mathbb {I}, \\mathbb {z}) \\in S} (t + \\mathrm {k}) \\cdot \\kappa_ {\\mathbf {r b r}} (\\mathbb {p}, \\mathbb {I}, \\mathbb {z}). \\tag {B.1}</span></div>

    <p class="text-gray-300">Proof. Since  <span class="math">\\mathcal{R}&#x27;</span>  is monotone, the adversary's restrictions  <span class="math">\\vec{A}</span>  cannot improve its advantage. It therefore suffices to bound the following probability:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho = (\\rho_ {i}) _ {i \\in [ k ]} \\leftarrow \\mathcal {U} ((r _ {i}) _ {i \\in [ k ]}) \\\\ (\\mathbb {I}, \\mathbb {z}) \\in S &amp;amp; (\\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\vec {r}) \\xleftarrow {\\mathrm {t r}} \\mathsf {G a m e} _ {\\mathsf {I O R}} (\\rho , \\tilde {\\mathbf {P}}) \\\\ (\\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} &amp;amp; (\\iota , \\mathbb {I}, \\mathbb {I} ^ {\\prime}) := \\mathbf {I} (\\mathbb {p}, \\mathbb {I}) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {z} ^ {\\prime}, \\vec {\\gamma} ^ {\\prime}, \\mathbb {w} ^ {\\prime}) \\in \\tilde {\\mathcal {R}} ^ {\\prime} &amp;amp; (\\mathbb {z} ^ {\\prime}, \\vec {\\gamma} ^ {\\prime}) := \\mathbf {V} ^ {\\mathbb {I}, \\vec {\\gamma}, \\vec {\\Pi}} (\\iota , \\mathbb {z}, \\vec {r}) \\\\ &amp;amp; \\mathbb {w} \\leftarrow \\mathbf {E} (\\mathbb {p}, \\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\mathrm {t r}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Rearranging, we find that this is identical to the state-restoration knowledge error of an IOP where the prover sends the new witness as an additional message and the verifier performs all of the highlighted steps:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho = (\\rho_ {i}) _ {i \\in [ k ]} \\leftarrow \\mathcal {U} ((r _ {i}) _ {i \\in [ k ]}) \\\\ (\\mathbb {I}, \\mathbb {z}) \\in S &amp;amp; (\\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} \\\\ (\\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} &amp;amp; (\\iota , \\mathbb {I}, \\mathbb {I} ^ {\\prime}) := \\mathbf {I} (\\mathbb {p}, \\mathbb {I}) \\\\ b = 1 &amp;amp; (\\mathbb {z} ^ {\\prime}, \\vec {\\gamma} ^ {\\prime}) := \\mathbf {V} ^ {\\mathbb {I}, \\vec {\\gamma}, \\vec {\\Pi}} (\\iota , \\mathbb {z}, \\vec {r}) \\\\ &amp;amp; b := (\\mathbb {I} ^ {\\prime}, \\mathbb {z} ^ {\\prime}, \\vec {\\gamma} ^ {\\prime}, \\mathbb {w} ^ {\\prime}) \\in \\tilde {\\mathcal {R}} ^ {\\prime} \\\\ &amp;amp; \\mathbb {w} \\leftarrow \\mathbf {E} (\\mathbb {p}, \\mathbb {I}, \\mathbb {z}, \\vec {\\gamma}, \\vec {\\Pi}, \\mathbb {w} ^ {\\prime}, \\mathrm {t r}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">Observe that the round-by-round knowledge error of this IOP is precisely  <span class="math">\\kappa_{\\mathrm{rbr}}</span> . We conclude by appealing to [CY24, Theorem 31.2.1], which relates IOP state-restoration knowledge to IOP round-by-round knowledge precisely as in Equation (B.1).</p>

    <p class="text-gray-300">Lemma B.6. Let  <span class="math">\\mathbf{E}</span>  be an IOR state-restoration straightline extractor. There exists an IOR state-restoration prover  <span class="math">\\tilde{\\mathbf{P}}[\\cdot]</span>  and deterministic polynomial-time IR state-restoration straightline extractor  <span class="math">\\mathcal{E}_1 \\coloneqq \\mathcal{E}_1[\\mathbf{E}]</span>  such that, for every  <span class="math">t_\\mathbb{S}</span> -move IR state-restoration prover  <span class="math">\\tilde{\\mathcal{P}}_1</span>  that makes at most  <span class="math">t_{\\mathrm{MT}}</span>  queries to  <span class="math">\\rho_{\\mathrm{MT}}</span> ,  <span class="math">\\tilde{\\mathbf{P}}[\\tilde{\\mathcal{P}}_1]</span>  makes at</p>

    <p class="text-gray-300">most  <span class="math">t_{\\S}</span>  moves and the following holds for any set  <span class="math">Z</span>  ..</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho_ {\\mathrm {M T}} \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I}, \\mathbb {z}) \\in Z &amp;amp; \\rho_ {\\mathrm {S R}} \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I}, (\\mathbb {z}, \\mathrm {c m}), (\\mathbb {w}, \\vec {\\mathrm {y}}, \\mathrm {t d})) \\in \\operatorname {C o m} [ \\tilde {\\mathcal {R}} ] ^ {\\rho_ {\\mathrm {M T}}} &amp;amp; (\\mathbb {I}, (\\mathbb {z}, \\mathrm {c m}), \\vec {\\alpha}, (\\mathbb {w}, \\vec {\\mathrm {y}}, \\mathrm {t d} ^ {\\prime}), \\vec {r}) \\\\ (\\mathbb {I} ^ {\\prime}, (\\mathbb {z} ^ {\\prime}, \\mathrm {c m} ^ {\\prime}), (\\mathbb {w} ^ {\\prime}, \\vec {\\mathrm {y}} ^ {\\prime}, \\mathrm {t d} ^ {\\prime})) \\in \\operatorname {C o m} [ \\tilde {\\mathcal {R}} ^ {\\prime} ] ^ {\\rho_ {\\mathrm {M T}}} &amp;amp; \\xleftarrow {\\text {t r}} \\operatorname {G a m e} _ {\\mathrm {I R}} (\\rho_ {\\mathrm {S R}}, \\tilde {\\mathcal {P}} _ {\\mathrm {i}} ^ {\\rho_ {\\mathrm {M T}}}) \\\\ &amp;amp; (\\mathbb {w}, \\vec {\\mathrm {y}}, \\vec {\\mathrm {t d}}) := \\mathcal {E} _ {\\mathrm {i}} (\\mathbb {I}, (\\mathbb {z}, \\mathrm {c m}), \\vec {\\alpha}, (\\mathbb {w} ^ {\\prime}, \\vec {\\mathrm {y}} ^ {\\prime}, \\vec {\\mathrm {t d}} ^ {\\prime}), \\mathrm {t r}) \\\\ &amp;amp; (\\mathrm {p k}, \\mathrm {v k}, \\mathbb {I} ^ {\\prime}) := \\mathcal {I} _ {\\mathrm {i}} (1 ^ {\\lambda}, \\mathbb {I}) \\\\ &amp;amp; (\\mathbb {z} ^ {\\prime}, \\mathrm {c m} ^ {\\prime}) := \\mathcal {V} _ {\\mathrm {i}} ^ {\\rho_ {\\mathrm {M T}}} (\\mathrm {v k}, (\\mathbb {z}, \\mathrm {c m}), \\vec {\\alpha}, \\vec {r}) \\end{array} \\right] \\tag {B.2} \\\\ \\leq \\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho_ {\\mathrm {M T}} \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I}, \\mathbb {z}) \\in Z &amp;amp; \\rho_ {\\mathrm {S R}} \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {z}, \\vec {\\mathrm {y}}, \\mathbb {w}) \\notin \\tilde {\\mathcal {R}} &amp;amp; (\\mathbb {I}, \\mathbb {z}, \\vec {\\mathrm {y}}, \\vec {\\mathrm {t d}}, \\mathbb {w} ^ {\\prime}, \\vec {r}) \\xleftarrow {\\text {t r}} \\operatorname {G a m e} _ {\\mathrm {I O R}} (\\rho_ {\\mathrm {S R}}, \\tilde {\\mathbf {P}} [ \\tilde {\\mathcal {P}} _ {\\mathrm {i}} ] ^ {\\rho_ {\\mathrm {M T}}}) \\\\ (\\mathbb {I} ^ {\\prime}, \\mathbb {z} ^ {\\prime}, \\vec {\\mathrm {y}} ^ {\\prime}, \\mathbb {w} ^ {\\prime}) \\in \\tilde {\\mathcal {R}} ^ {\\prime} &amp;amp; \\mathbb {w} := \\mathbf {E} (\\mathbb {I}, \\mathbb {z}, \\vec {\\mathrm {y}}, \\vec {\\mathrm {t d}}, \\mathbb {w} ^ {\\prime}, \\operatorname {t r}) \\\\ &amp;amp; (\\iota , \\mathbb {I}, \\mathbb {I} ^ {\\prime}) := \\mathbf {I} (1 ^ {\\lambda}, \\mathbb {I}) \\\\ &amp;amp; (\\mathbb {z} ^ {\\prime}, \\vec {\\mathrm {y}} ^ {\\prime}) := \\mathbf {V} ^ {\\mathbb {I}, \\vec {\\mathrm {y}}, \\vec {\\mathrm {t d}}} (\\iota , \\mathbb {z}, \\vec {r}) \\end{array} \\right] \\\\ + \\kappa_ {\\mathrm {M T}} (\\lambda , t _ {\\mathrm {M T}}, L _ {\\max }, 1 + n + k). \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Construction B.7.</strong> Given a state-restoration prover  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span>  for  <span class="math">\\mathrm{T_i[IOR]}</span> , the state-restoration prover  <span class="math">\\tilde{\\mathbf{P}} [\\tilde{\\mathcal{P}}_{\\mathrm{i}}]</span>  for IOR is defined as follows.</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathbf{P}} [\\tilde{\\mathcal{P}}_{\\mathrm{i}}]^{\\rho_{\\mathrm{MT}}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize an empty query-answer trace  <span class="math">\\mathrm{tr}_{\\mathrm{MT}}</span></li>

      <li>Simulate  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span>  while answering its queries:</li>

    </ol>

    <p class="text-gray-300">(a) When  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span>  makes a query to the oracle  <span class="math">\\rho_{\\mathrm{MT}}</span> , answer according to  <span class="math">\\rho_{\\mathrm{MT}}</span>  and append the query-answer pair to  <span class="math">\\mathrm{tr}_{\\mathrm{MT}}</span> . (b) When  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span>  sends a move  <span class="math">(\\mathbb{I},(\\mathbb{z},\\mathbb{c}\\tilde{\\mathfrak{m}}),(\\mathsf{pcm}_1,\\ldots ,\\mathsf{pcm}_i))</span>  with  <span class="math">i\\in [\\mathbf{k}]</span> :</p>

    <p class="text-gray-300">i. Let  <span class="math">\\mathrm{tr} \\subset \\mathrm{tr}_{\\mathrm{MT}}</span>  be the query-answer pairs for  <span class="math">\\rho_{\\mathrm{MT}}</span>  since the previous move (or the beginning if this is the first move). ii. Extract commitment openings:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\left(y _ {1}, t d _ {1}\\right), \\dots , \\left(y _ {n}, t d _ {n}\\right), \\left(\\Pi_ {1}, p t d _ {1}\\right), \\dots , \\left(\\Pi_ {i}, p t d _ {i}\\right)\\right) \\\\ := \\text {M T . M u l t i E x t r a c t} \\left(\\left(\\mathrm {c m} _ {1}, \\dots , \\mathrm {c m} _ {n}, \\mathrm {p c m} _ {1}, \\dots , \\mathrm {p c m} _ {i}\\right), \\mathrm {t r}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">iii. Send the move  <span class="math">(\\mathbb{I},\\mathbb{z},\\vec{\\mathrm{y}},\\Pi_1,\\dots ,\\Pi_i)</span>  for the IOR state-restoration game. iv. Receive the challenge  <span class="math">r_i</span>  from the game. v. Return  <span class="math">r_i</span>  to  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally,  <span class="math">\\tilde{\\mathcal{P}}_{\\mathrm{i}}</span>  halts and outputs  <span class="math">(\\mathbb{I},(\\mathbb{z},\\mathbb{c}\\tilde{\\mathfrak{m}}),(\\mathsf{pcm}_1,\\ldots ,\\mathsf{pcm}_k,(\\mathrm{a}\\tilde{\\mathfrak{n}}\\mathrm{s},\\tilde{\\mathsf{p}}\\tilde{\\mathsf{f}})),(\\mathbb{w}^{\\prime},\\vec{\\mathrm{y}}^{\\prime},\\mathrm{td}^{\\prime}))</span></li>

      <li>Let  <span class="math">\\mathrm{tr} \\subset \\mathrm{tr}_{\\mathrm{MT}}</span>  be the query-answer pairs for  <span class="math">\\rho_{\\mathrm{MT}}</span>  since the last move while simulating  <span class="math">\\tilde{\\mathcal{P}}_1</span> .</li>

      <li>Extract commitment openings:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\left(y _ {1}, t d _ {1}\\right), \\dots , \\left(y _ {n}, t d _ {n}\\right), \\left(\\Pi_ {1}, p t d _ {1}\\right), \\dots , \\left(\\Pi_ {k}, p t d _ {k}\\right)\\right) \\\\ := \\text {M T . M u l t i E x t r a c t} \\left(\\left(\\mathrm {c m} _ {1}, \\dots , \\mathrm {c m} _ {n}, \\mathrm {p c m} _ {1}, \\mathrm {p c m} _ {k}\\right), \\mathrm {t r}\\right) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j = 1, \\ldots, n&#x27;</span> , set the restriction  <span class="math">A_j \\coloneqq \\operatorname{Dom} y_j&#x27;</span> .</li>

      <li>Output  <span class="math">(\\mathbb{I},\\mathbb{z},\\vec{y},\\vec{\\Pi},\\mathbb{w}^{\\prime},\\vec{A})</span> . Also, implicitly output  <span class="math">\\vec{\\mathrm{cm}}</span> ,  <span class="math">\\vec{\\mathrm{pcm}}</span> , ans,  <span class="math">\\vec{\\mathrm{pf}}</span> ,  <span class="math">\\vec{\\mathrm{y}}^{\\prime}</span> ,  <span class="math">\\vec{\\mathrm{td}}^{\\prime}</span>  (these are only used in the analysis).</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_1(\\mathbb{I},(\\mathbb{z},\\vec{\\mathrm{cm}}),(\\mathrm{pcm}_1,\\dots ,\\mathrm{pcm}_k,(\\vec{\\mathrm{ans}},\\vec{\\mathrm{pf}})),(\\mathbb{w}&#x27;,\\vec{\\mathrm{y}}&#x27;,\\vec{\\mathrm{td}}&#x27;),\\mathrm{tr})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Split the prover's trace tr into an IR state-restoration game trace  <span class="math">\\mathrm{tr}_{\\mathrm{IR}}</span>  and oracle trace  <span class="math">\\mathrm{tr}_{\\mathrm{MT}}</span> .</li>

      <li>Set  <span class="math">\\mathrm{tr}_{\\mathrm{IOR}} := \\mathrm{IORTrace}(\\mathrm{tr}_{\\mathrm{IR}}, \\mathrm{tr}_{\\mathrm{MT}})</span> , where IORTrace is the deterministic algorithm which computes the IOR state-restoration trace corresponding to  <span class="math">\\tilde{\\mathbf{P}}[\\tilde{\\mathcal{P}}_1]</span> , as defined in Construction B.7.</li>

      <li>Extract commitment openings:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\left(\\mathrm{y}_{1}, \\mathrm{td}_{1}\\right), \\ldots, \\left(\\mathrm{y}_{n}, \\mathrm{td}_{n}\\right), \\left(\\Pi_{1}, \\mathrm{ptd}_{1}\\right), \\ldots, \\left(\\Pi_{k}, \\mathrm{ptd}_{k}\\right))</span></p>

    <p class="text-gray-300"><span class="math">\\coloneqq \\mathsf{MT.MultiExtract}((\\mathsf{cm}_1,\\ldots ,\\mathsf{cm}_n,\\mathsf{pcm}_1,\\mathsf{pcm}_k),\\mathsf{tr}_{\\mathsf{MT}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the IOR state-restoration extractor:  <span class="math">\\mathbb{W} := \\mathbf{E}(\\mathbb{I}, \\mathbb{z}, \\vec{\\mathbb{y}}, \\vec{\\Pi}, \\mathbb{w}&#x27;, \\mathrm{tr}_{\\mathrm{IOR}})</span> .</li>

      <li>Output  <span class="math">(\\mathbb{W},\\vec{\\mathbb{y}},\\vec{\\mathrm{td}})</span></li>

    </ol>

    <p class="text-gray-300">Proof of Lemma B.6. Define the random variable  <span class="math">X</span>  as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (I, z, y, b, trIOR, trMT, r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ρSR← U(λ)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(I, (z, cm), pcm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ans, pf), (w', y', td'), r')</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ←trIR, trMT GameIR(ρSR, P1ρMT)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(yj, tdj)j=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Πi, ptdj)k=1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  (pk, vk) := I1ρMT(1λ, I)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(z', cm') := V1ρMT(vk, (z, cm), pcm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ans, pf), r')</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  b := (I, (z', cm'), (w, y', td')) ∈ Com[R2]ρMT  |</p>

    <p class="text-gray-300">|   |  trIOR := IORTrace(trIR, trMT)  |</p>

    <p class="text-gray-300">Define the random variable  <span class="math">Y</span>  as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (I, x, y, b, trIOR, trMT, r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ρ← U(λ)  |</p>

    <p class="text-gray-300">|   |  (I, x, y, Π, w', A, r; cm, pcm, anis, pf, y', td')  |</p>

    <p class="text-gray-300">|   |  ←trIOR,trMT GameIOR(ρ, P[P1]ρMT)  |</p>

    <p class="text-gray-300">|   |  (ι, I) := I(1λ, I)  |</p>

    <p class="text-gray-300">|   |  (x', s) := V1,y,Π(ι, x, r)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀j ∈ [n'], y* := Select(y, Π, sj)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aj</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  b1 := (I, x', y*, w') ∈ R2  |</p>

    <p class="text-gray-300">|   |  (icm, itd) := MT.CommitρMT(I)  |</p>

    <p class="text-gray-300">|   |  b2 := CheckAllρMT(icm, cm, pcm, anis, pf)  |</p>

    <p class="text-gray-300">|   |  ∀j ∈ [n'], cm' := Select(cm, pcm, sj)  |</p>

    <p class="text-gray-300">|  b3 := ∧n'j=1 MT.VerifyρMT(cm', y', td')  |   |</p>

    <p class="text-gray-300">|  b := b1 ∧ b2 ∧ b3  |   |</p>

    <p class="text-gray-300">It suffices to show that  <span class="math">X</span>  and  <span class="math">Y</span>  are  <span class="math">\\kappa_{\\mathrm{MT}}(\\ldots)</span> -statistically close. Unwrapping  <span class="math">\\mathcal{I}_1, \\mathcal{V}_1</span> , and  <span class="math">\\operatorname{Com}[\\tilde{\\mathcal{R}}_2]</span>  in the definition of  <span class="math">X</span> , we get the following (differences from Equation (B.3) are highlighted):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (I, x, y, b, trIOR, trMT, r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT← U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ρ← U(λ)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(I, (x, cm), pcm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(anis, pf), r, (w', y', td'))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ←trIR,trMT GameIR(ρ, P1ρMT)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(yj, tdj)j=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Πi, ptdi)k i=1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  (ι, I) := I(1λ, I)  |</p>

    <p class="text-gray-300">|   |  (icm, itd) := MT.CommitρMT(I)  |</p>

    <p class="text-gray-300">|   |  b2 := CheckAllρMT(icm, cm, pcm, anis, pf)  |</p>

    <p class="text-gray-300">|   |  (x', s) := Vanis(ι, x, r)  |</p>

    <p class="text-gray-300">|   |  ∀j ∈ [n'], cm' := Select(cm, pcm, sj)  |</p>

    <p class="text-gray-300">|   |  b1 := (I, x', y', w') ∈ R2  |</p>

    <p class="text-gray-300">|   |  b3 := ∧n'j=1 MT.VerifyρMT(cm', y', td')  |</p>

    <p class="text-gray-300">|  b := b1 ∧ b2 ∧ b3  |   |</p>

    <p class="text-gray-300">|  trIOR := IORTrace(trIR, trMT)  |   |</p>

    <p class="text-gray-300">Define the event  <span class="math">E</span>  as follows (differences from Equation (B.4) are highlighted):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">¬(b2 ∧ b3) ∨ II</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dom ans1 = ans1 ∧n yj</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dom ans1+j = ans1+j ∧k i=1 Πi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dom ans1+n+i = ans1+n+i ∧n' yj = yj'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT←U(λ) ρ←U(λ) (Π, (z, cm), pcm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(anis, pf), r, (w', y', td'))←trMT GameIR(ρ, P1ρMT) (yj, tdj)n=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Πi, ptdi)n=1 := MT.MultiExtract(cm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pcm), trMT) (ι, Π) := I(1λ, Π) (icm, itd) := MT.CommitρMT(Π) b2 := CheckAllρMT(icm, cm, pcm, anis, pf) (z', s) := Vanis(ι, z, r) ∀j ∈ [n'], cmj' := Select(cm, pcm, sj) b3 := ∧n' MT.VerifyρMT(cmj', yj', tdj') ∀j ∈ [n'], yj' := Select(y, Π, sj)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dom yj'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that  $(X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E)$  is equivalent to the following distribution (differences from Equation (B.4) are highlighted):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{ (Π, z, y, b, trIOR, trMT, r) conditioned on E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT←U(λ) ρ←U(λ) (Π, (z, cm), pcm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(anis, pf), r, (w', y', td'))←trIR,trMT GameIR(ρ, P1ρMT) (yj, tdj)n=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Πi, ptdi)n=1 := MT.MultiExtract(cm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pcm), trMT) (ι, Π) := I(1λ, Π) (icm, itd) := MT.CommitρMT(Π) b2 := CheckAllρMT(icm, cm, pcm, anis, pf) (z', s) := V1,y,Π (ι, z, r) ∀j ∈ [n'], yj' := Select(y, Π, sj)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dom yj' ∀j ∈ [n'], cmj' := Select(cm, pcm, sj) b1 := (Π, z', y*, w') ∈ R2(φ) b3 := ∧n' MT.VerifyρMT(cmj', yj', tdj') b := b1 ∧ b2 ∧ b3 trIOR := IORTrace(trIR, trMT)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This is equivalent to the following distribution (differences from Equation (B.5) are highlighted):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥,z,γ,b,trIOR,trMT,τ) conditioned on E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT←U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ρ←U(λ)  |</p>

    <p class="text-gray-300">|   |  (∥,z,γ,Π,ω',A,τ;cm,pcm,anis,pf,γ',td')  |</p>

    <p class="text-gray-300">|   |  ←trIOR,trMT GameIOR(ρ, P[P1]ρMT)  |</p>

    <p class="text-gray-300">|   |  (ε,Π) := I(1λ,Π)  |</p>

    <p class="text-gray-300">|   |  (icm,itd) := MT.CommitρMT(Π)  |</p>

    <p class="text-gray-300">|   |  b2 := CheckAllρMT(icm,cm,pcm,anis,pf)  |</p>

    <p class="text-gray-300">|   |  (z',s) := V1,γ,Π(ε,z,τ)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀j ∈ [n'], yj* := Select(γ,Π, sj)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aj</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ∀j ∈ [n'], cm' := Select(cm,pcm, sj)  |</p>

    <p class="text-gray-300">|   |  b1 := (∥,z,γ+,ω') ∈ R2(∑)  |</p>

    <p class="text-gray-300">|   |  b3 := ∧n'j=1MT.VerifyρMT(cm',y',td')  |</p>

    <p class="text-gray-300">|   |  b := b1 ∧ b2 ∧ b3  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Some rearranging shows that this is identical to the definition of  $(Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E)<span class="math"> . It remains to give an upper bound for the probability of  </span>\\overline{E}<span class="math"> . From Lemma 3.11, we get  </span>\\kappa_{\\mathrm{MT}}(\\lambda, t_{\\mathrm{MT}}, L_{\\max}, 1 + n + k)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma B.9. Let  <span class="math">\\mathcal{E}_1</span>  be an IR state-restoration straightline extractor. There exists an IR state-restoration prover  <span class="math">\\tilde{\\mathcal{P}}_1[\\cdot]</span>  such that the following holds and a non-interactive reduction straightline extractor  <span class="math">\\mathcal{E} := \\mathcal{E}[\\mathcal{E}_1]</span>  such that, for every non-interactive reduction prover  <span class="math">\\tilde{\\mathcal{P}}</span>  that makes at most  <span class="math">t_{\\mathrm{MT}}</span>  queries to  <span class="math">\\rho_{\\mathrm{MT}}</span>  and  <span class="math">t_{\\mathrm{FS}}</span>  queries to  <span class="math">\\rho_{\\mathrm{FS}}</span> ,  <span class="math">\\tilde{\\mathcal{P}}_1[\\tilde{\\mathcal{P}}]</span>  makes at most  <span class="math">t_{\\mathrm{FS}}</span>  moves and the following holds for any set  <span class="math">Z</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥,z) ∈ Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT←U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  ρFS←U(λ)  |</p>

    <p class="text-gray-300">|   |   |  ρ := (ρMT, ρFS)  |</p>

    <p class="text-gray-300">|   |  (∥,z,π,ω') ← Prρ |   |</p>

    <p class="text-gray-300">|   |  (∥,z,π,ω') ← Fρρ |   |</p>

    <p class="text-gray-300">|   |  (∥,z,π,ω') ← Fρρ |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥,z',ω') ∈ Com[R']ρMT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ω := E(∥,z,π,ω,tr)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  (pk, vk, l') := Iρ(1λ, l) |   |</p>

    <p class="text-gray-300">|   |  z' := Vρ(vk, z, π) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(∥,z',ω') ∈ Com[R']ρMT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρMT←U(λ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  (∥,z,α,ω',τ) ←Tr GameIR(ρSR, P1[P]ρMT)  |</p>

    <p class="text-gray-300">|   |   |  ω := E1(∥,z,α,ω',tr)  |</p>

    <p class="text-gray-300">|   |   |  (pk, vk, l') := I1(1λ, l)  |</p>

    <p class="text-gray-300">|   |   |  z' := V1ρMT(vk, z, α, τ)  |</p>

    <p class="text-gray-300">Proof. This is a straightforward adaptation of [CY24, Theorem 16.1.1], which transforms interactive proofs (or arguments) into non-interactive arguments. Observe that any reduction can be viewed as an argument where the prover additionally sends the new witness and the verifier additionally tests membership in the</p>

    <p class="text-gray-300">new relation. From this perspective, the experiment on the right side of Equation (B.6) is equivalent to the state-restoration experiment for an interactive argument, and the experiment on the left side is equivalent to the knowledge soundness experiment for the Fiat–Shamir transformation of the interactive argument.</p>

    <p class="text-gray-300">There are a few minor technical differences which we address here. First, we give the interactive prover <span class="math">\\tilde{\\mathcal{P}}_{\\downarrow}</span> access to a random oracle <span class="math">\\rho_{\\mathsf{MT}}</span>; this is justified since the reduction only makes black-box use of <span class="math">\\tilde{\\mathcal{P}}_{\\downarrow}</span>. Second, the relations <span class="math">\\mathcal{R},\\mathcal{R}^{\\prime}</span> are defined relative to <span class="math">\\rho_{\\mathsf{MT}}</span> and we additionally test membership in an arbitrary set <span class="math">Z</span>; this is justified since the distributions of index, instance, and witness in the experiments are statistically close <em>[x13, Lemma 16.3.3]</em>. ∎</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Arc: Accumulation for Reed--Solomon Codes (2024/1731)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1731
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
