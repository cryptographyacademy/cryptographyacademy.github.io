---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1143';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Rescue-Prime: a Standard Specification (SoK)';
const AUTHORS_HTML = 'Alan Szepieniec, Tomer Ashur, Siemen Dhooghe';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This document provides a simple standard specification for the Rescue-Prime family of arithmetization-oriented hash functions.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> arithmetization-oriented &middot; hash &middot; rescue &middot; standard</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A large number of projects are being developed and deployed that rely on the evaluation of a hash function inside of a cryptographic protocol such as a multiparty computation or a zero-knowledge proof system. The common strategy employed by both types of protocols is to represent a computation as a series of native finite field operations, a process called arithmetization. The complexity of the resulting protocol is linked to that of the arithmetic representation. Consequently, there is a high demand for hash functions with an efficient arithmetization &mdash; arithmetization-oriented hash functions.</p>

    <p class="text-gray-300">We consider one particular family of arithmetization-oriented hash functions called Rescue, first introduced as part of the Marvellous<a href="#page-0-0">4</a> universe <a href="#page-13-0">[2]</a>. In the time since the publication of the first electronic preprint, the paper's scope has been proven needlessly broad on two counts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The advanced cryptographic protocols almost universally prefer prime fields over binary extension fields. As a result, the Rescue family has received much more attention than its binary field (and equally Marvellous) counterpart, Vision.</li>
      <li>The original paper specifies the Vision and Rescue hash functions in multiple steps in order to offer more flexibility with regards to the exact symmetric primitive required. However, the demand for arithmetization-oriented hash functions dwarfs the demand for alternative symmetric constructions with similar properties. In light of this imbalance, the flexibility is unnecessary and the stepwise derivation convoluted.</li>
    </ul>

    <p class="text-gray-300"><sup>4</sup> No idea why it is spelled with two L's.</p>

    <p class="text-gray-300">The complexity arising from this broad focus is compounded by the paper's target audience. It is written primarily for symmetric key cryptanalysts and cipher designers who must be led by the hand and in tiny steps to the understanding that their hard-won knowledge and intuition about traditional cipher design and analysis needs adaptation in order to apply to arithmetization-oriented ciphers. Rather than merely specifying the new proposals, the paper surveys the field in order to identify differences and pitfalls before proceeding to formulate (candidates for) sound design principles. When the ciphers finally are specified, this specification is overshadowed by an elaborate security analysis and performance benchmark justifying the proposals' existence by driving home once again the alternate target for optimization &mdash; arithmetic complexity, not hardware or software complexity.</p>

    <p class="text-gray-300">In the mist of this discussion, the instructions for implementers are lost.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 This Document</h3>

    <p class="text-gray-300">This document specifies the arithmetization-oriented hash function Rescue-Prime, which is based on the original Rescue proposal <a href="#page-13-0">[2]</a>. The hash function is presented in an easy-to-digest format. The target audience consists of implementers rather than cryptanalysts. We can therefore omit discussions that distract from the matter at hand.</p>

    <p class="text-gray-300">No scientific novelty is claimed. Rather, the contribution consists in making existing knowledge more accessible to a wider audience. This document should be read through the lens of a standards document or a systematization of knowledge.</p>

    <p class="text-gray-300">That being said, we do make use of the opportunity to apply three simplifications to the construction. The motivation for these changes is segregated from the specification itself.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We change the derivation of round constants.</li>
      <li>We reduce the security margin from 100% to 50%.</li>
      <li>We flip the order of S-Boxes.</li>
    </ul>

    <p class="text-gray-300">The resulting families of permutations and hash functions are technically dissimilar from their analogues in the original proposal. To draw a clear distinction between all objects, we introduce new names for the primitives specified here. Rescue-XLIX (pronounced Rescue Forty Nine) refers to the permutation that incorporates these changes. Rescue-Prime refers to the hash function obtained by instantiating the sponge construction with this permutation.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Not in This Document</h3>

    <p class="text-gray-300">This document targets brevity and clarity. As a result, any discussion on the following questions is omitted.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The Vision and Rescue block ciphers, as well as the Vision hash function.</li>
      <li>How to arithmetize Rescue-Prime.</li>
      <li>Other symmetric-key primitives derived from Rescue-XLIX.</li>
      <li>Security arguments.</li>
    </ul>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Specification of Rescue-Prime</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Parameters</h3>

    <p class="text-gray-300">A member of the Rescue-Prime family of hash functions is fully determined by a tuple of primary parameters  <span class="math">(p, m, c_q, s)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>p determines the prime field  <span class="math">\\mathbb{F}_p</span>  over which the operations are defined. p must be a prime number with a binary expansion of at least 32 bits.</li>
      <li>m determines the state width of the hash function. Phrased differently, in the evaluation of the function, the state is fully determined by m&gt;1 field elements.</li>
      <li><span class="math">-c_p</span>  is the <em>capacity</em> of the arithmetic sponge. The complement,  <span class="math">r_p=m-c_p</span>  is the <em>rate</em> of the arithmetic sponge which determines the number of field elements that are absorbed between invocations of the Rescue-XLIX permutation.</li>
      <li><span class="math">-\\ 80 \\le s \\le 512</span>  is the target security level, measured in bits.</li>
    </ul>

    <p class="text-gray-300">Furthermore, there are parameters that depend entirely on the tuple of primary parameters but are included in the parameter list for convenience.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\alpha</span>  and  <span class="math">\\alpha^{-1}</span>  are the exponents in the power maps in the S-boxes. These parameters are set to guarantee that  <span class="math">(x^{\\alpha})^{\\alpha^{-1}} = x</span>  for all  <span class="math">x \\in \\mathbb{F}_p</span> .</li>
      <li><span class="math">-M \\in \\mathbb{F}_p^{m \\times m}</span>  is an  <span class="math">m \\times m</span>  MDS matrix.</li>
      <li><span class="math">-N \\in \\mathbb{N}</span>  is the number of rounds. A single Rescue-XLIX permutation consists of N iterations of a simpler base permutation called a <em>round</em>.</li>
    </ul>

    <p class="text-gray-300">Lastly, there are an additional 2mN field elements  <span class="math">\\{C_i\\}_{i=0}^{2mN-1}</span>  called the round constants. These serve to individualize each round of the permutation. We provide a way to derive them pseudorandomly in Section 2.4.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The Rescue-Prime Hash Function</h3>

    <p class="text-gray-300">The Rescue-Prime hash function sends arbitrary-length sequences of field elements to  <span class="math">r_p</span>  field elements:</p>

    <p class="text-gray-300"><span class="math">$f_{\\mathbf{R}&#x27;}: \\mathbb{F}_p^* \\to \\mathbb{F}_p^{r_p}</span>$
.</p>

    <p class="text-gray-300">It is obtained by employing the Rescue-XLIX permutation in a sponge construction. The resulting sponge function sends arbitrary-length sequences to infinite-length sequences of field elements:</p>

    <p class="text-gray-300"><span class="math">$f_{\\mathbf{R}&#x27;\\text{-sponge}}: \\mathbb{F}_p^* \\to \\mathbb{F}_p^*</span>$
.</p>

    <p class="text-gray-300">Rescue-Prime results from truncating this sponge function. Specifically, the first  <span class="math">r_p</span>  elements are retained and the rest is ignored.</p>

    <p class="text-gray-300">The evaluation of the sponge function involves a permutation  <span class="math">f_{\\mathbf{R}^{\\mathrm{XLIX}}}: \\mathbb{F}_p^m \\to \\mathbb{F}_p^m</span> , a register of m field elements called the state, and two phases. The state is initially set to the all-zero sequence  <span class="math">\\mathbf{0} \\in \\mathbb{F}_p^m</span> .</p>

    <p class="text-gray-300">In the absorbing phase, the following iteration is repeated: the next r<sup>p</sup> elements from the input sequence are added to the r<sup>p</sup> top elements of the state, after which the permutation fRXLIX is applied to the state. This loop runs until all the input elements have been absorbed.</p>

    <p class="text-gray-300">In the squeezing phase, the top r<sup>p</sup> elements of the state are output. In theory, the permutation fRXLIX can be applied to the state iteratively to produce an arbitrarily long sequence of output elements. However, this specification restricts the number of output elements to at most rp.</p>

    <p class="text-gray-300">Fig. <a href="#page-3-0">1</a> illustrates the computation. Algorithm <a href="#page-4-0">1</a> captures this procedure with SageMath code.</p>

    <p class="text-gray-300">    <img src="_page_3_Picture_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. The Rescue-Prime hash function with two absorbing iterations.</p>

    <p class="text-gray-300">Padding A sponge function operating on arbitrary-length inputs requires a padding rule. To pad the input, append a single 1 &isin; F<sup>p</sup> and as many 0 &isin; F<sup>p</sup> elements as required to make the number of input elements a multiple of rp. A wrapper adding this padding is provided in Alg. <a href="#page-4-1">2.</a></p>

    <p class="text-gray-300">Truncation and generic security For some applications only n &lt; r<sup>p</sup> field elements are required. The most straightforward way to obtain them is to truncate the output of Rescue-Prime.</p>

    <p class="text-gray-300">In general, the security proof for sponge constructions assumes that the underlying permutation is uniformly sampled from the set of all permutations on the state space. The discussion in Section <a href="#page-4-2">2.3</a> is aimed to ensure that the Rescue-XLIX permutation is indistinguishable from a random permutation, thus satisfying the prerequisite for the security proof. When this is the case, a sponge-based hash function whose output is truncated to n &le; r<sup>p</sup> field elements, generically affords at least log<sup>2</sup> &radic;<sup>p</sup> &middot; min(n, cp) bits of security against finding collisions, preimages, and second-preimages.</p>

    <p class="text-gray-300">Algorithm 1 Obtaining the Rescue-Prime hash function (without padding) from the Rescue-XLIX permutation</p>

    <pre><code class="language-text">def rescue_prime_hash ( parameters , input_sequence ) :
 p , m , capacity , security_level , alpha , alphainv , N , MDS ,
     round_constants = parameters
 rate = m - capacity
 Fp = FiniteField ( p )
 assert len( input_sequence ) % rate == 0
 # initialize state to all zeros
 state = matrix ([[ Fp (0) ] for i in range ( m ) ])
 # absorbing
 absorb_index = 0
 while absorb_index &lt; len( input_sequence ) :
      for i in range (0 , rate ) :
          state [i ,0] += input_sequence [ absorb_index ]
          absorb_index += 1
      state = rescue_XLIX_permutation ( parameters , state )
 # squeezing
 output_sequence = []
 for i in range (0 , rate ) :
      output_sequence . append ( state [i ,0])
 return output_sequence
</code></pre>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Algorithm 2 The Rescue-Prime hash function, with padding.</h3>

    <pre><code class="language-text">def rescue_prime_wrapper ( parameters , input_sequence ) :
 p , m , capacity , security_level , alpha , alphainv , N , MDS ,
     round_constants = parameters
 rate = m - capacity
 Fp = FiniteField ( p )
 padded_input = input_sequence + [ Fp (1) ]
 while len( padded_input ) % rate != 0:
      padded_input . append ( Fp (0) )
 return rescue_prime_hash ( parameters , padded_input )
</code></pre>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 The Rescue-XLIX Permutation</h3>

    <p class="text-gray-300">The Rescue-XLIX permutation fRXLIX consists of N iterations of the Rescue-XLIX round function. A single round consists of the following components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S-box layer: apply the power map  <span class="math">(\\cdot)^{\\alpha}</span>  to each element of the state.</li>
      <li>Linear layer: apply the MDS matrix to the state, through matrix-vector multiplication.</li>
      <li>Constants injection: add the next m constants from the list of round constants  <span class="math">\\{C_i\\}_{i=0}^{2mN-1}</span>  into the state.</li>
      <li>Inverse S-box layer: apply the inverse power map  <span class="math">(\\cdot)^{\\alpha^{-1}}</span>  to each element of the state.</li>
      <li>Linear layer: apply the MDS matrix to the state, through matrix-vector multiplication.</li>
      <li>Constants injection: add the next m constants from the list of round constants  <span class="math">\\{C_i\\}_{i=0}^{2mN-1}</span>  into the state.</li>
    </ul>

    <p class="text-gray-300">A diagram of a single round is provided in Fig. 2. SageMath code for the full permutation (N rounds) is given in Alg. 3.</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 2.</strong> Round i of the Rescue-XLIX permutation, with m=3.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Selecting the Parameters</h3>

    <p class="text-gray-300">Selecting the MDS Matrix. Let g be the smallest primitive element of  <span class="math">\\mathbb{F}_p</span> . Typically g=2 is fine, but for some choices of p, g only generates a subgroup of  <span class="math">\\mathbb{F}_p \\setminus \\{0\\}</span> ,  <span class="math">\\times</span> . To test whether a candidate g is primitive, raise it to all factors of p-1 and verify that the result is not 1.</p>

    <p class="text-gray-300">Build a Vandermonde matrix  <span class="math">V \\in \\mathbb{F}_p^{m \\times 2m}</span>  by setting the (i, j)th element to  <span class="math">\\mathbf{g}^{ij}</span> , with both indices starting from zero. The rows of V form a basis for a maximum distance separable (MDS) code. To obtain a generator matrix for this code, bring V into reduced row-echelon form. At this point, V has the shape  <span class="math">(I|M^{\\mathsf{T}})</span> , where M is the sought-after MDS matrix.</p>

    <p class="text-gray-300">Selecting the Round Constants Let |p| denote the number of bits in the binary representation of p. Generate a string of  <span class="math">(\\lceil \\frac{|p|}{8} \\rceil + 1) \\times 2mN</span>  bytes using SHAKE-256 to expand the ASCII string &quot;Rescue-XLIX(%i,%i,%i,%i)&quot; where</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Algorithm 3 The Rescue-XLIX permutation</h4>

    <pre><code class="language-text">def rescue_XLIX_permutation ( parameters , state ) :
 p , m , capacity , security_level , alpha , alphainv , N , MDS ,
     round_constants = parameters
 Fp = state [0 ,0]. parent ()
 for i in range ( N ) :
      # S-box
      for j in range ( m ) :
           state [j ,0] = state [j ,0]^ alpha
      # mds
      state = MDS * state
      # constants
      for j in range ( m ) :
           state [j ,0] += round_constants [ i *2* m + j ]
      # inverse S-box
      for j in range ( m ) :
           state [j ,0] = state [j ,0]^ alphainv
      # mds
      state = MDS * state
      # constants
      for j in range ( m ) :
           state [j ,0] += round_constants [ i *2* m + m + j ]
 return state
</code></pre>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">Algorithm 4 Generating the MDS matrix</h3>

    <pre><code class="language-text">def get_mds_matrix ( p , m ) :
 # get a primitive element
 Fp = FiniteField ( p )
 g = Fp (2)
 while g . multiplicative_order () != p -1:
      g = g + 1
 # get a systematic generator matrix for the code
 V = matrix ([[ g ^( i * j ) for j in range (0 , 2* m ) ] for i in
     range (0 , m ) ])
 V_ech = V . echelon_form ()
 # the MDS matrix is the transpose of the right half of
     this matrix
 MDS = V_ech [: , m :]. transpose ()
 return MDS
</code></pre>

    <p class="text-gray-300">the %i wild cards represent the decimal expansions of the primary parameters  <span class="math">p,m,c_p,s,</span>  respectively.</p>

    <p class="text-gray-300">Next, build the list of constants one by one. To do this, iterate over all 2mN chunks of  <span class="math">(\\lceil \\frac{|p|}{8} \\rceil + 1)</span>  bytes from this string and cast the chunk into an integer using least significant byte first encoding. Reducing this integer modulo p gives the next element of the list of constants.</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6"><strong>Algorithm 5</strong> Generating the round constants</h4>

    <pre><code class="language-text">{\\tt def} get_round_constants( p, m, capacity, security_level, N ):
 # generate pseudorandom bytes
 bytes_per_int = ceil(len(bin(p)[2:]) / 8) + 1
 num_bytes = bytes_per_int * 2 * m * N
 seed_string = &quot;Rescue-XLIX(%i,%i,%i,%i)&quot; % (p, m,
    capacity, security_level)
 byte_string = SHAKE256(bytes(seed_string, &quot;ascii&quot;),
    num_bytes)
 # process byte string in chunks
 round_constants = []
 Fp = FiniteField(p)
 for i in range(2*m*N):
     chunk = byte_string[bytes_per_int*i : bytes_per_int*(
     integer = sum(256^j * ZZ(chunk[j]) for j in range(len
         (chunk)))
     round_constants.append(Fp(integer % p))
 return round_constants
</code></pre>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Computing <span class="math">\\alpha</span> and <span class="math">\\alpha^{-1}</span></h3>

    <p class="text-gray-300">The parameter  <span class="math">\\alpha</span>  is defined as the smallest integer that is coprime with p-1, and  <span class="math">\\alpha^{-1}</span>  is defined as its multiplicative inverse in the ring  <span class="math">\\mathbb{Z}/\\langle p-1\\rangle</span> . For fields satisfying  <span class="math">\\gcd(p-1,3)=1</span> , we have  <span class="math">\\alpha=3</span>  and  <span class="math">\\alpha^{-1}=\\frac{2p-1}{3}</span> . However, for other fields  <span class="math">\\alpha</span>  must be larger and  <span class="math">\\alpha^{-1}</span>  must be computed with the extended Euclidean algorithm. Algorithm 6 shows how to compute these parameters.</p>

    <p class="text-gray-300">Choosing the Number of Rounds For  <span class="math">|p| \\geq 32</span>  and  <span class="math">80 \\leq s \\leq 512</span> , the Gr&ouml;bner basis attack performs best and should be used to set the number of rounds. Let  <span class="math">d_{con} = 0.5(\\alpha - 1)m(N - 1) + 2</span>  and  <span class="math">v = m(N - 1) + r_p</span> . The complexity of a Gr&ouml;bner basis attack is at least  <span class="math">\\binom{d_{con}+v}{v}^2</span>  field operations. Set  <span class="math">\\ell_1</span></p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Algorithm 6 Computing &alpha; and &alpha; &minus;1</h4>

    <pre><code class="language-text">def get_alphas ( p ) :
 for alpha in range (3 , p ) :
      if gcd ( alpha , p -1) == 1:
           break
 g , alphainv , garbage = xgcd ( alpha , p -1)
 return ( alpha , ( alphainv % (p -1) ) )
</code></pre>

    <p class="text-gray-300">to the smallest positive value for N that makes this binomial expression larger than 2<sup>s</sup> , or formally</p>

    <p class="text-gray-300"><span class="math">$\\ell_1 = \\min_N \\quad \\text{subject to} \\, \\left( \\frac{d_{con} + v}{v} \\right)^2 &gt; 2^s \\, \\, .</span>$</p>

    <p class="text-gray-300">Additionally, account for a sanity factor of at least 5 rounds and a security margin of 50%. This makes the number of rounds equal to</p>

    <p class="text-gray-300"><span class="math">$N = \\lceil 1.5 \\cdot \\max(5, \\ell_1) \\rceil.</span>$</p>

    <p class="text-gray-300">Algorithm <a href="#page-8-1">7</a> shows provides SageMath code for determining the number of rounds.</p>

    <h3 id="sec-misc-6" class="text-xl font-semibold mt-8">Algorithm 7 Calculating the number of rounds</h3>

    <pre><code class="language-text">def get_number_of_rounds ( p , m , capacity , security_level ,
 alpha ) :
 # get number of rounds for Groebner basis attack
 rate = m - capacity
 dcon = lambda N : floor (0.5 * ( alpha -1) * m * (N -1) + 2)
 v = lambda N : m *( N -1) + rate
 target = 2^ security_level
 for l1 in range (1 , 25) :
      if binomial ( v ( l1 ) + dcon ( l1 ) , v ( l1 ) ) ^2 &gt; target :
          break
 # set a minimum value for sanity and add 50%
 return ceil (1.5 * max (5 , l1 ) )
</code></pre>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Motivation for Changes from the Original Publication</h2>

    <p class="text-gray-300">Rescue-XLIX departs from the original specification of Rescue <a href="#page-13-0">[2]</a> in three ways.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Flipped Order of S-boxes</h3>

    <p class="text-gray-300">In Rescue, the first step of each round involves the &alpha; <sup>&minus;</sup><sup>1</sup> power map, and the second step uses &alpha;. In Rescue-XLIX, this order is reversed. As a result, the arithmetization technique the original publication called folding &mdash; representing two steps as a single set of equations without increasing their degree and omitting intermediate state variables &mdash; now applies across the entire cipher and does not require special care for the very first and last steps.</p>

    <p class="text-gray-300">Conceptually, the new variant can be thought of as adding a single step to the front and to the back. The number of equations and variables in a Gr&uml;obner basis attack does not change as a result of this addition, because the same improved arithmetization is available to the attacker. However, the shape of the equations at the very first and last steps are different.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Simplified Specification of Round Constants</h3>

    <p class="text-gray-300">The specification of the round constants for the original version of Rescue is rather convoluted. It specifies the round constants for the block cipher's key schedule using an affine relation determined by SHAKE-256. By setting the key to zero, the sub-keys are fixed, and these are the round constants that are used in the hash function.</p>

    <p class="text-gray-300">The specification of the round constants for Rescue-XLIX is much more straightforward. In principle, uniformly random round constants suffice. However, we chose to use SHAKE-256 to expand a seed phrase and derive the constants from the resulting byte stream. This achieves two goals:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It establishes that the designers did not select these round constants because they hide a secret trapdoor, an approach known as nothing-up-my-sleeve.</li>
      <li>It provides a single standard way to instantiate Rescue-Prime that different projects and implementations can agree on. After all, this paper provides a reference standard.</li>
    </ul>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Reduced Security Margin</h3>

    <p class="text-gray-300">The original specification of Rescue had a 100% security margin. A reasonable amount of time has passed since the publication of the preprint. In the intervening time multiple projects have chosen to use Rescue <a href="#page-15-0">[9,</a><a href="#page-14-0">6,</a><a href="#page-15-1">10]</a>, several studies of the security of arithmetization-oriented hash functions and Rescue in particular have appeared <a href="#page-14-1">[4,</a><a href="#page-13-1">3,</a><a href="#page-15-2">7</a><a href="#page-15-3">,8,</a><a href="#page-14-2">5]</a>, and even a bountiful competition has run its course <a href="#page-13-2">[1]</a>. None of these endeavors have exposed any weaknesses in the construction. We therefore determine that it is timely and fitting to reduce the security margin to 50%.</p>

    <p class="text-gray-300">Following Section <a href="#page-2-0">2</a> is the simplest and most straightforward way to generate a safe instance of Rescue-Prime. However, certain special cases may warrant deviation from the standard approach. In this section we outline directions for such deviations and assign a confidence score to the security claim of the resulting variant. We stress that we highly recommend whenever possible to follow the specification in Section <a href="#page-2-0">2</a> and to seek an expert's help before deciding to deviate.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Small Fields and High Security</h3>

    <p class="text-gray-300">Section <a href="#page-2-0">2</a> mandated that binary expansion of p is at least 32-bit long and offered a formula for a safe number of rounds when the security level is between 80 bits and 512 bits. This ensures that resistance against Gr&uml;obner basis attacks is the decisive factor in setting the number of rounds.</p>

    <p class="text-gray-300">However, the original publication allows for fields as small as 4-bit long. In some cases, when both the field size p and the state size m are small compared to the required security, differential cryptanalysis may outperform Gr&uml;obner basis attacks.</p>

    <p class="text-gray-300">In this case, the number of rounds should take into account the maximal number of rounds that can be attacked by a differential attack:</p>

    <p class="text-gray-300"><span class="math">$\\ell_0 = \\frac{2s}{\\log_2(p^{m+1}) - \\log_2((\\alpha-1)^{m+1})} = \\frac{2s}{(m+1)(\\log_2(p) - \\log_2(\\alpha-1))} \\enspace .</span>$</p>

    <p class="text-gray-300">The number of rounds is then set to N = d1.5&middot;max(5, <code>0, </code>1)e. Algorithm <a href="#page-10-0">8</a> shows how to derive this number of rounds in this case.</p>

    <p class="text-gray-300">Algorithm 8 Calculating the number of rounds for high-security/small-field instances</p>

    <pre><code class="language-text">def get_number_of_rounds1 ( p , m , capacity , security_level ,
 alpha ) :
 # get number of rounds for Groebner basis attack
 rate = m - capacity
 dcon = lambda N : floor (0.5 * ( alpha -1) * m * (N -1) + 2)
 v = lambda N : m *( N -1) + rate
 target = 2^ security_level
 for l1 in range (1 , 25) :
      if binomial ( v ( l1 ) + dcon ( l1 ) , v ( l1 ) ) ^2 &gt; target :
          break
 # get number of rounds for differential attack
 l0 = 2* security_level / ( log (1.0* p ^( m +1) , 2.0) - log
     (1.0*( alpha - 1) ^( m +1) , 2.0) )
 # take minimum of numbers , sanity factor , and add 50%
 return ceil (1.5 * max (5 , l0 , l1 ) )
</code></pre>

    <p class="text-gray-300">Many of the parameter choices where differential attacks are relevant, are artificial. In order to generate a practical generic security level for the sponge construction, a small field must be paired with a large state size, or vice versa. In other words, at most one of {m, |p|} can be small, practically speaking.</p>

    <p class="text-gray-300">Selection of the MDS Matrix is unaffected by this decision.</p>

    <p class="text-gray-300">Selection the Round Constants is unaffected by this decision.</p>

    <p class="text-gray-300">Confidence Level is medium-high. This variant was explicitly covered in the generic security argument of the original publication. However, most of the focus so far was on more natural settings.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Alternate MDS Matrices</h3>

    <p class="text-gray-300">There are cases where better performance is afforded by optimizing the MDS with respect to some design criterion. Section <a href="#page-5-2">2.4</a> specifies Vandermonde matrices as the standard way to generate the MDS matrix. However the original publication did not limit the choice of MDS to any specific type and argues its security with respect to any MDS matrix. The decision to be more restrictive merely simplifies the standard specification and is not known to have any security implications for algorithms following the Marvellous design strategy.</p>

    <p class="text-gray-300">Choosing the MDS matrix: any MDS matrix can be used.</p>

    <p class="text-gray-300">The number of rounds is unaffected by this decision.</p>

    <p class="text-gray-300">Selection the Round Constants is unaffected by this decision.</p>

    <p class="text-gray-300">Confidence Level is high. This variant was explicitly covered in the generic security argument of the original publication.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Omission of the Padding Rule</h3>

    <p class="text-gray-300">A padding rule is required when the sponge function is used to absorb inputs of arbitrary length. If the length of the input is fixed and known in advance (when building a Merkle tree, for instance) the padding can be omitted.</p>

    <p class="text-gray-300">The number of rounds is unaffected by this decision.</p>

    <p class="text-gray-300">Selection of the MDS matrix is unaffected by this decision.</p>

    <p class="text-gray-300">Selection the Round Constants is unaffected by this decision.</p>

    <p class="text-gray-300">Confidence Level is medium-high. This is a well known property of sponge constructions and is independent of Rescue-Prime.</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Algebraically Dependent Round Constants</h3>

    <p class="text-gray-300">The point in injecting round constants is to ensure that every round is unique, thereby foiling attacks that exploit a repetitive structure of the cipher. In some applications it is cumbersome to specify 2mN unstructured round constants, and it would be convenient to derive some of the round constants from the others. We sketch two ways to do this.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Select  <span class="math">C_i</span> ,  <span class="math">i \\equiv 0 \\mod m</span>  at random and set  <span class="math">C_{i+j} = C_i^{j+1}</span> , for 0 &lt; j &lt; m. The  <span class="math">C_i</span>  should be selected uniformly at random but with rejection sampling to ensure that  <span class="math">C_i</span>  generates the entire group  <span class="math">\\mathbb{F}_p \\setminus \\{0\\}, \\times</span> .</li>
      <li>Select  <span class="math">(C_0, \\ldots, C_{m-1})</span>  uniformly at random along with an invertible matrix  <span class="math">A \\in \\mathbb{F}_p^{m \\times m}</span>  and an offset vector  <span class="math">\\mathbf{b} \\in \\mathbb{F}_p^m</span> . Then derive  <span class="math">(C_{im}, \\ldots, C_{(i+1)m-1})^\\mathsf{T} = A(C_{(i-1)m}, \\ldots, C_{im-1})^\\mathsf{T} + \\mathbf{b}</span> , for  <span class="math">1 \\le i &lt; 2N</span> .</li>
    </ul>

    <p class="text-gray-300">The number of rounds is unaffected by this decision.</p>

    <p class="text-gray-300">Selection of the MDS matrix is unaffected by this decision.</p>

    <p class="text-gray-300">Confidence Level is high. Consult an expert to avoid pitfalls.</p>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">4.5 Permitting <span class="math">n &gt; r_p</span></h3>

    <p class="text-gray-300">Doubly-extendable cryptographic (DEC) functions Such function allow to absorb a sequence of arbitrary length and and output a sequence of arbitrary length (up to the security bound). Hash functions are a private case of DEC functions with a fixed length input.</p>

    <p class="text-gray-300">The Rescue-Prime hash function specified in Section 2 restricts the squeezing phase to a single iteration, and defines the output length as  <span class="math">n \\leq r_p</span> . Algorithm 9 (resp., Algorithm 10) modifies Algorithm 2 (resp., Algorithm 1) for the case of a DEC functions.</p>

    <p class="text-gray-300">The number of rounds is unaffected by this decision.</p>

    <p class="text-gray-300">Selection of the MDS matrix is unaffected by this decision.</p>

    <p class="text-gray-300"><strong>Selection the Round Constants</strong> is high. This variant was explicitly covered in the generic security argument of the original publication.</p>

    <p class="text-gray-300">Algorithm 9 Obtaining Rescue-Prime Doubly-extendable cryptographic function from the Rescue-Prime sponge</p>

    <pre><code class="language-text">def rescue_prime_DEC ( parameters , input_sequence ,
 output_length ) :
 p , m , capacity , security_level , alpha , alphainv , N , MDS ,
     round_constants = parameters
 rate = m - capacity
 Fp = FiniteField ( p )
 padded_input = input_sequence + [ Fp (1) ]
 while len( padded_input ) % rate != 0:
      padded_input . append ( Fp (0) )
 return rescue_prime_sponge ( parameters , padded_input ,
     output_length )
</code></pre>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Conclusion</h2>

    <p class="text-gray-300">We close with a note on the utility of conclusions, making use of the opportunity provided by a clear example of when there isn't any. The purpose of a conclusion is not to summarize a body of text (that would be an insult to the reader!) but rather to cast new and more light on the knowledge conveyed therein. It serves to interpret the results, and to suggest improved thought patterns appropriate for the context at hand.</p>

    <p class="text-gray-300">This document does not introduce new results or even new knowledge. Readers looking for a better way to think about arithmetization-oriented ciphers are referred to the original Marvellous paper <a href="#page-13-0">[2]</a>. There is nothing left to say in this conclusion; goodbye.</p>

    <p class="text-gray-300">Acknowledgments Alan Szepieniec is supported by the Nervos Foundation. Tomer Ashur is an FWO post-doctoral fellow under Grant Number 12ZH420N. Siemen Dhooghe is supported by a Ph.D. Fellowship from the Research Foundation - Flanders (FWO).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. STARK-friendly hash challenge, <a href="https://starkware.co/developers-community/hash-challenge/" target="_blank" rel="noopener noreferrer">https://starkware.co/developers-community/</a> <a href="https://starkware.co/developers-community/hash-challenge/" target="_blank" rel="noopener noreferrer">hash-challenge/</a>, accessed: 2020-09-09</li>
      <li>2. Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. IACR Cryptol. ePrint Arch. 2019, 426 (2019), <a href="https://eprint.iacr.org/2019/426" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/426</a></li>
      <li>3. Ben-Sasson, E., Goldberg, L., Levit, D.: STARK friendly hash - survey and recommendation. IACR Cryptol. ePrint Arch. 2020, 948 (2020), <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">iacr.org/2020/948</a></li>
    </ul>

    <p class="text-gray-300">Algorithm 10 Obtaining the Rescue-Prime sponge from the Rescue-XLIX permutation</p>

    <pre><code class="language-text">def rescue_prime_sponge ( parameters , input_sequence ,
output_length ) :
 p , m , capacity , security_level , alpha , alphainv , N , MDS ,
     round_constants = parameters
 rate = m - capacity
 Fp = FiniteField ( p )
 assert len( input_sequence ) % rate == 0
 # initialize state to all zeros
 state = matrix ([[ Fp (0) ] for i in range ( m ) ])
 # absorbing
 absorb_index = 0
 while absorb_index &lt; len( input_sequence ) :
     for i in range (0 , rate ) :
          state [i ,0] += input_sequence [ absorb_index ]
          absorb_index += 1
     state = rescue_XLIX_permutation ( parameters , state )
 # squeezing
 output_sequence = []
 squeeze_index = 0
 while squeeze_index &lt; output_length :
     for i in range (0 , rate ) :
          output_sequence . append ( state [i ,0])
          squeeze_index += 1
     if squeeze_index &lt; output_length :
          state = rescue_XLIX_permutation ( parameters , state
              )
 return output_sequence [: output_length ]
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">4. Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., Wiemer, F.: Out of oddity - new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO, Part III. Lecture Notes in Computer Science, vol. 12172, pp. 299&ndash;328. Springer (2020), <a href="https://doi.org/10.1007/978-3-030-56877-1_11" target="_blank" rel="noopener noreferrer">https://doi.org/</a> <a href="https://doi.org/10.1007/978-3-030-56877-1_11" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-56877-1\\_11</a></p></li>
      <li><p class="text-gray-300">5. Beyne, T., Canteaut, A., Leander, G., Naya-Plasencia, M., Perrin, L., Wiemer, F.: Report on the security of the Rescue hash function (2020), <a href="https://starkware.co/wp-content/uploads/2020/06/report.pdf" target="_blank" rel="noopener noreferrer">https://starkware.</a> <a href="https://starkware.co/wp-content/uploads/2020/06/report.pdf" target="_blank" rel="noopener noreferrer">co/wp-content/uploads/2020/06/report.pdf</a></p></li>
      <li><p class="text-gray-300">6. Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof composition without a trusted setup. IACR Cryptol. ePrint Arch. 2019, 1021 (2019), <a href="https://eprint.iacr.org/2019/1021" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2019/1021" target="_blank" rel="noopener noreferrer">iacr.org/2019/1021</a></p></li>
      <li><p class="text-gray-300">7. Canteaut, A., Beyne, T., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Plasencia, M.N., Perrin, L., Sasaki, Y., Todo, Y., Wiemer, F.: Report on the security of STARK-friendly hash functions (version 2.0) (2020), <a href="https://starkware.co/wp-content/uploads/2020/03/reportv2.pdf" target="_blank" rel="noopener noreferrer">https://starkware.</a> <a href="https://starkware.co/wp-content/uploads/2020/03/reportv2.pdf" target="_blank" rel="noopener noreferrer">co/wp-content/uploads/2020/03/reportv2.pdf</a></p></li>
      <li><p class="text-gray-300">8. Keller, N., Rosemarin, A.: Mind the middle layer: The HADES design strategy revisited. IACR Cryptol. ePrint Arch. 2020, 179 (2020), <a href="https://eprint.iacr.org/2020/179" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2020/179" target="_blank" rel="noopener noreferrer">org/2020/179</a></p></li>
      <li><p class="text-gray-300">9. StarkWare: EthSTARK, <a href="https://github.com/starkware-libs/ethSTARK" target="_blank" rel="noopener noreferrer">https://github.com/starkware-libs/ethSTARK</a>, accessed: 2020-09-09</p></li>
      <li><p class="text-gray-300">10. Threadbare, B.: Distaff, <a href="https://github.com/GuildOfWeavers/distaff" target="_blank" rel="noopener noreferrer">https://github.com/GuildOfWeavers/distaff</a></p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Rescue-Prime: a Standard Specification (SoK) (2020/1143)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1143
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">This Document</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Not in This Document</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Specification of Rescue-Prime</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Parameters</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The Rescue-Prime Hash Function</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">The Rescue-XLIX Permutation</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Selecting the Parameters</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Computing \alpha and \alpha^&#123;-1&#125;</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Motivation for Changes from the Original Publication</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Flipped Order of S-boxes</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Simplified Specification of Round Constants</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Reduced Security Margin</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Deviations from the Rescue-Prime Standard Specification</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Small Fields and High Security</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Alternate MDS Matrices</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Omission of the Padding Rule</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Algebraically Dependent Round Constants</a></li>
            <li><a href="#sec-4.5" class="hover:text-white">Permitting n &gt; r_p</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="rescue-prime-a-standard-specification-sok-2020" />
  </article>
</BaseLayout>
