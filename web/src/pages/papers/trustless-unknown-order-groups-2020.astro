---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/196';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Trustless unknown-order groups';
const AUTHORS_HTML = 'Samuel Dobson, Steven D.  Galbraith, Benjamin Smith';

const CONTENT = `    <p class="text-gray-300">Trustless unknown-order groups</p>

    <p class="text-gray-300">Samuel Dobson^{1}, Steven Galbraith^{1}, Benjamin Smith^{2}</p>

    <p class="text-gray-300">^{1}University of Auckland, New Zealand ^{2}Inria and Laboratoire d’Informatique (LIX), CNRS, École polytechnique, Institut Polytechnique de Paris, Palaiseau, France</p>

    <p class="text-gray-300">Abstract Groups whose order is computationally hard to compute have important applications including time-lock puzzles, verifiable delay functions, and accumulators. Many applications require trustless setup: that is, not even the group’s constructor knows its order. We argue that the impact of Sutherland’s generic group-order algorithm has been overlooked in this context, and that current parameters do not meet claimed security levels. We propose updated parameters, and a model for security levels capturing the subtlety of trustless setup. The most popular trustless unknown-order group candidates are ideal class groups of imaginary quadratic fields; we show how to compress class-group elements from <span class="math">\\approx 2\\log_{2}(N)</span> to <span class="math">\\approx\\frac{3}{2}\\log_{2}(N)</span> bits, where <span class="math">N</span> is the order. Finally, we analyse Brent’s proposal of Jacobians of hyperelliptic curves as unknown-order groups. Counter-intuitively, while polynomial-time order-computation algorithms for hyperelliptic Jacobians exist in theory, we conjecture that genus-<span class="math">3</span> Jacobians offer shorter keylengths than class groups in practice.</p>

    <p class="text-gray-300">Keywords: Unknown order groups, ideal class groups, hyperelliptic curves</p>

    <p class="text-gray-300">2010 Mathematics Subject Classification: 94A60, 11Y40</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 INTRODUCTION</h2>

    <p class="text-gray-300">Interest in groups of unknown order has been fuelled in recent years by applications such as delay functions <em>[11]</em>, accumulators <em>[12]</em>, and zero-knowledge proofs of knowledge <em>[16]</em>. As the name suggests, a group <span class="math">G</span> has unknown order if it has a compact representation, but it is infeasible for anyone to compute the order of <span class="math">G</span> efficiently without access to any secret information used to construct <span class="math">G</span>. In the case of trustless setup, the order should not even be known to the creator(s) of the group. Some use-cases may require additional properties, such as the low order or the adaptive root assumptions. In order to be useful, group operations in <span class="math">G</span> should be efficiently computable; elements of <span class="math">G</span> should have a compact representation; and it should be possible to efficiently sample random elements of <span class="math">G</span>.</p>

    <p class="text-gray-300">Previously, there have been two proposals for concrete unknown-order groups: RSA groups <em>[53]</em>, and ideal class groups of imaginary quadratic fields <em>[47, 15]</em>. Brent briefly suggested hyperelliptic Jacobians as unknown-order groups <em>[13]</em>; but unlike RSA and class groups, Jacobians have received little further attention.</p>

    <p class="text-gray-300">RSA groups are groups of the form <span class="math">(\\mathbb{Z}/N\\mathbb{Z})^{\\times}</span>, where <span class="math">N=pq</span> is the product of two primes. Computing the order of <span class="math">(\\mathbb{Z}/N\\mathbb{Z})^{\\times}</span> is equivalent to factoring <span class="math">N</span>. A trusted party can efficiently generate an RSA modulus that resists all known attacks (including Sutherland’s algorithm). Sander <em>[55]</em> gave an algorithm to trustlessly generate a modulus <span class="math">N</span> such that (with very high probability) <span class="math">N</span> has two large factors—he calls this an RSA-UFO (unknown factorisation object). However, to match even the lower security of 1024-bit RSA moduli, RSA-UFOs need “bit length (much) greater than 40,000 bits”; this is far too large to be efficient in most unknown-order group applications.</p>

    <p class="text-gray-300">Class groups, on the other hand, can be generated without trusted setup, and so have received a lot of recent attention (see e.g. <em>[47, 65, 12]</em>). Buchmann and Hamdy <em>[14]</em> suggested that 1665-bit discriminants (<span class="math">\\approx</span> 833-bit orders) provide security equivalent to 3072-bit RSA (i.e., 128-bit security); more recently, Biasse, Jacobson Jr., and Silvester <em>[9]</em> claim that 1827-bit discriminants (<span class="math">\\approx</span> 914-bit orders) are required to reach the same security level.</p>

    <p class="text-gray-300">But the usual notions of security level are not appropriate when evaluating class-group security for applications such as accumulators, where the group is fixed. The computational assumptions underlying security are not defined for a fixed group, and there is no random self-reduction to show that all instances have the same security. We argue that much larger group sizes are needed for secure unknown-order groups in applications where the group is fixed for many users and used for a long period of time.</p>

    <p class="text-gray-300">Precisely, we propose a new security model for unknown-order groups, depending on two parameters <span class="math">(\\lambda,\\rho)</span>.</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Gen}</span> be an algorithm outputting groups. We say that <span class="math">\\mathsf{Gen}</span> reaches security level <span class="math">(\\lambda,\\rho)</span> if with probability <span class="math">1-1/2^{\\rho}</span> over the outputs of <span class="math">\\mathsf{Gen}</span>, any algorithm <span class="math">\\mathcal{A}</span> given an output <span class="math">G</span> of <span class="math">\\mathsf{Gen}</span> requires at least <span class="math">2^{\\lambda}</span> bit operations to succeed in computing <span class="math">\\#G</span> with probability close to 1.</p>

    <p class="text-gray-300">A similar concept of security is implicit in <em>[4]</em>, which considers the security of cryptosystems depending on a prime system parameter <span class="math">p</span> provided by a possibly malicious party, when in practice the users only verify the primality of <span class="math">p</span>—and thus ensure the security level of the system—up to a certain probability (if at all). One</p>

    <p class="text-gray-300">recommendation of <em>[4]</em> is that users “ensure that composite numbers are wrongly identified as being prime with probability at most <span class="math">2^{-128}</span>”, corresponding to <span class="math">\\rho=128</span>.</p>

    <p class="text-gray-300">In our context, the probabilistic nature of security is not due to malicious parties, or unreliable verification, but rather to a fundamental mathematical fact: the distribution of random Abelian group orders. Our security definition is motivated by Sutherland’s generic group order algorithm <em>[59]</em>, whose runtime depends on the (unknown) order itself, rather than the supposed size of the order.</p>

    <p class="text-gray-300">The relevance of Sutherland’s algorithm to cryptographic unknown-order groups seems to have been overlooked, but in §3.2 we show that it attacks some class groups with parameters that are widely considered secure. For example: Sutherland’s algorithm can compute the order of a class group with 1827-bit discriminant (i.e., 914-bit group order) in <span class="math">\\approx 2^{59}</span> operations with probability <span class="math">\\approx 2^{-58}</span>, or in <span class="math">\\approx 2^{114}</span> operations with probability <span class="math">\\approx 2^{-20}</span>. The problem is that among class groups with prime discriminants of a given size, there is a set of weak instances <em>depending on the order</em>. A randomly-generated group is only vulnerable with small probability; but since the order is unknown, we cannot check for vulnerability without simply attempting to run the algorithm for the given time (in contrast, in the RSA setting with trusted setup, the group order is known to its generator, who can thus easily choose a group that is not vulnerable). For these reasons, we consider that 1827-bit discriminants (and even the 2048-bit discriminants suggested in <em>[12, 16]</em>) do not meet the requirements for 128-bit security.</p>

    <p class="text-gray-300">We propose new group sizes in response, depending on <span class="math">(\\lambda,\\rho)</span>. A paranoid choice, <span class="math">(\\lambda,\\rho)=(128,128)</span>, requires group sizes of around 3400 bits. A more realistic (but still cautious) choice, <span class="math">(\\lambda,\\rho)=(128,55)</span>, requires 1900-bit group sizes (and so 3800-bit discriminants; more than double the previous suggestion). Table 2 gives sizes of group orders for various combinations of <span class="math">(\\lambda,\\rho)</span>. An alternative would be to use multiple smaller groups in parallel, however we believe this approach is less efficient than working in a single larger group.</p>

    <p class="text-gray-300">Our second major result is a more compact representation of class group elements. Inspired by a signature-compression method of Bleichenbacher <em>[10]</em>, in §3.3 we compress elements of class groups to 3/4 the size of the usual representation—a particularly welcome saving in the light of our updated, much larger class group parameters.</p>

    <p class="text-gray-300">Our third and more speculative contribution, in §4, is an analysis of Brent’s proposal of subgroups of Jacobians of hyperelliptic genus-3 curves as a source of unknown-order groups with trustless setup. We find that Jacobians offer a distinct advantage over class groups at the same security level: the element representation size is smaller (2/3 the size if our new class group compression algorithm is used; if not, 1/2 the size), since point compression for curves is optimal. Using Jacobians also allows us to take advantage of the wealth of algorithms for group operations and exponentiation that have been developed and implemented for hyperelliptic discrete-log-based cryptography, which may be more efficient than their class-group equivalents (though the lack of recent competitive implementations makes it difficult to compare Jacobians and class groups in terms of real-world speed).</p>

    <p class="text-gray-300">We acknowledge that there are, in theory, polynomial-time algorithms to compute the group order of hyperelliptic Jacobians <em>[51, 32]</em>. However, there is evidence that these algorithms are already impractical for discrete-log-based cryptographic group orders of around 256-bits, let alone the much larger group orders that we have in mind. While curves of any genus <span class="math">\\geq 2</span> might be considered, we suggest that genus-3 curves are the best choice: their point-counting algorithms are already very complex, and their DLP is harder relative to higher-genus curves. Naturally, if Schoof-type algorithms for genus 3 could be made efficient over large prime fields, then these groups would become insecure—but at least we have provided motivation for such work.</p>

    <p class="text-gray-300">Some unknown-order group protocols make stronger assumptions: for example, that finding elements of a given order is hard, or that extracting roots of a given element is hard. In §5 we consider the problem of constructing points of known order in class groups and Jacobians, and explain how we might work with Jacobians when the low-order or adaptive root assumptions are imposed.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Acknowledgements.</h4>

    <p class="text-gray-300">We thank Dan Boneh, Benjamin Wesolowski, Steve Thakur, and Jonathan Lee for their valuable comments, feedback and suggestions on an earlier version of this work. We also thank Edward Chen, Luca De Feo, and Jean Kieffer for beneficial discussion, and the anonymous reviewers for their feedback and comments.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">Recall that <span class="math">\\widetilde{O}(x)=O((\\log x)^{c}\\cdot x)</span> for some constant <span class="math">c</span>, and for subexponential algorithms, <span class="math">L_{x}(\\alpha)=\\exp\\left[(1+o(1))(\\log x)^{\\alpha}(\\log\\log x)^{1-\\alpha}\\right]</span> for <span class="math">0\\leq\\alpha\\leq 1</span>.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 SUTHERLAND’S ALGORITHM: THE SECURITY OF GENERIC GROUPS</h2>

    <p class="text-gray-300">Sutherland’s <em>primorial-steps</em> algorithm <em>[59, Algorithm 4.2]</em> computes the order of an element in a generic group; it can be used to probabilistically determine the exponent of a group. Remarkably, it runs in <span class="math">O(\\sqrt{N/\\log\\log N})=o(\\sqrt{N})</span> time (where <span class="math">N</span> is the group order) in the worst case, but in fact the expected runtime depends heavily on the multiplicative structure of <span class="math">N</span>. The algorithm runs particularly quickly when <span class="math">N</span> is smooth, which we do not expect (or desire!) in unknown-order groups; but it also poses a significant threat to a larger class of groups.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sutherland's algorithm is based on Shanks' baby-step giant-step (BSGS) algorithm, but one can also use Pollard rho. Suppose we wish to compute the order of  <span class="math">\\alpha</span> . Instead of computing consecutive powers of  <span class="math">\\alpha</span>  in the baby-steps, we compute a new element  <span class="math">\\beta = \\alpha^{E}</span>  such that the order of  <span class="math">\\beta</span>  is coprime to all primes  <span class="math">2, 3, \\ldots, p_{n} \\leq L</span>  for a chosen bound  <span class="math">L</span> , by taking  <span class="math">E</span>  to be the product of the  <span class="math">p_{i}</span> , each raised to an appropriate exponent  <span class="math">\\lfloor \\log_{p_i}(M) \\rfloor</span>  (where  <span class="math">M</span>  is an upper bound of the group order). The baby-steps are then all powers of  <span class="math">\\beta</span>  with exponents coprime to  <span class="math">P_{n}</span> , and the giant-step exponents are multiples of  <span class="math">P_{n}</span> , where  <span class="math">P_{n} = \\prod_{i=1}^{n} p_{i}</span> . As in BSGS, a collision allows  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to be learnt, which then allows  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  to be computed very efficiently.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Sutherland shows that if the order  <span class="math">N</span>  of  <span class="math">\\alpha</span>  is uniformly distributed over  <span class="math">[1, M]</span>  (for sufficiently large  <span class="math">M</span> ) and  <span class="math">L = M^{1 / u}</span> , then this is an  <span class="math">O(M^{1 / u})</span>  time and space algorithm that successfully computes  <span class="math">N</span>  with probability  <span class="math">P \\geq G(1 / u, 2 / u)</span>  [59, Proposition 4.7]. Here  <span class="math">G(r, s)</span>  is the semismooth probability function</p>

    <div class="my-4 text-center"><span class="math-block">G (r, s) = \\lim  _ {x \\rightarrow \\infty} \\psi (x, x ^ {s}, x ^ {r}) / x</span></div>

    <p class="text-gray-300">for  <span class="math">0 &amp;lt; r &amp;lt; s &amp;lt; 1</span> , where  <span class="math">\\psi(x, y, z)</span>  is the number of integers up to  <span class="math">x</span>  semismooth with respect to  <span class="math">y</span>  and  <span class="math">z</span>  (that is, all prime factors less than  <span class="math">y</span> , with at most one greater than  <span class="math">z</span> ).</p>

    <p class="text-gray-300">Table 1: Asymptotic semismoothness probabilities from [59] and [6]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(1/u,2/u)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(1/u,2/u)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(1/u,2/u)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9488</td>

            <td class="px-3 py-2 border-b border-gray-700">5.0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4473</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

            <td class="px-3 py-2 border-b border-gray-700">4.255e-12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5038</td>

            <td class="px-3 py-2 border-b border-gray-700">6.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.092e-03</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">6.534e-19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4473</td>

            <td class="px-3 py-2 border-b border-gray-700">10.0</td>

            <td class="px-3 py-2 border-b border-gray-700">5.382e-09</td>

            <td class="px-3 py-2 border-b border-gray-700">20.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.416e-26</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each choice of  <span class="math">\\rho</span>  (corresponding to the probability that a weak group is generated), one must determine  <span class="math">u</span>  such that  <span class="math">1 / 2^{\\rho} \\approx G(1 / u, 2 / u)</span> . It then follows that the group size should be at least  <span class="math">u\\lambda</span>  bits so that a  <span class="math">1 / u</span> -th root attack requires at least  <span class="math">2^{\\lambda}</span>  operations. Table 1 gives some numerically computed values for  <span class="math">G(1 / u, 2 / u)</span>  from [6] and [59]. Using the method of Banks and Shparlinski [7] to approximate the density of semismooth numbers, we calculate that for a success probability of less than  <span class="math">2^{-100}</span> , we should take  <span class="math">u = 22.5</span> ; for  <span class="math">2^{-128}</span> , we should take  <span class="math">u = 26.5</span> .</p>

    <p class="text-gray-300">As we mentioned in the introduction, taking  <span class="math">(\\lambda, \\rho) = (128, 55)</span>  leads to  <span class="math">\\approx 1920</span> -bit group orders, because  <span class="math">\\rho = 55</span>  corresponds to  <span class="math">u = 15</span> , and  <span class="math">15 \\cdot 128 = 1920</span> . A more conservative choice would be  <span class="math">(\\lambda, \\rho) = (128, 128)</span> , corresponding to  <span class="math">u \\approx 26.5</span>  and implying 3392-bit groups. Table 2 gives sizes of group orders for various combinations of  <span class="math">(\\lambda, \\rho)</span> . Once again we stress that our setting is different to the usual world of security levels. We are dealing with a fixed class of weak instances of the computational problem.</p>

    <p class="text-gray-300">Table 2: Group size (bits) for various attack success probabilities  <span class="math">{2}^{-\\rho }</span>  and running costs  <span class="math">{2}^{\\lambda }</span></p>

    <p class="text-gray-300">|   | ρ  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λ</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">660</td>

            <td class="px-3 py-2 border-b border-gray-700">825</td>

            <td class="px-3 py-2 border-b border-gray-700">880</td>

            <td class="px-3 py-2 border-b border-gray-700">1045</td>

            <td class="px-3 py-2 border-b border-gray-700">1265</td>

            <td class="px-3 py-2 border-b border-gray-700">1430</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

            <td class="px-3 py-2 border-b border-gray-700">1200</td>

            <td class="px-3 py-2 border-b border-gray-700">1280</td>

            <td class="px-3 py-2 border-b border-gray-700">1520</td>

            <td class="px-3 py-2 border-b border-gray-700">1840</td>

            <td class="px-3 py-2 border-b border-gray-700">2080</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">1200</td>

            <td class="px-3 py-2 border-b border-gray-700">1500</td>

            <td class="px-3 py-2 border-b border-gray-700">1600</td>

            <td class="px-3 py-2 border-b border-gray-700">1900</td>

            <td class="px-3 py-2 border-b border-gray-700">2300</td>

            <td class="px-3 py-2 border-b border-gray-700">2600</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">1536</td>

            <td class="px-3 py-2 border-b border-gray-700">1920</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">2432</td>

            <td class="px-3 py-2 border-b border-gray-700">2944</td>

            <td class="px-3 py-2 border-b border-gray-700">3392</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We remark that Sutherland's algorithm is less of a threat to unknown order groups with trusted setup. For example, if there is an authority that can be trusted to generate an RSA modulus  <span class="math">N = pq</span>  where  <span class="math">p</span>  and  <span class="math">q</span>  are safe primes, then the order of  <span class="math">\\mathbb{Z}_N^\\infty</span>  cannot be computed using Sutherland's approach.</p>

    <p class="text-gray-300">In this section we reconsider ideal class groups as a source of trustless unknown-order groups. We briefly recall the relevant background on class groups in §3.1; detailed references include [19] and [24]. We then reconsider class-group security in §3.2, and give a new compression algorithm for class group elements in §3.3.</p>

    <p class="text-gray-300">An imaginary quadratic field is an algebraic extension</p>

    <div class="my-4 text-center"><span class="math-block">K = \\mathbb {Q} (\\sqrt {d}) = \\{a + b \\sqrt {d} \\mid a, b \\in \\mathbb {Q} \\}</span></div>

    <p class="text-gray-300"><span class="math">d&lt;0</span> is a square-free integer. The discriminant <span class="math">\\Delta</span> of <span class="math">K</span> is <span class="math">d</span> if <span class="math">d\\equiv 1\\pmod{4}</span>, or <span class="math">4d</span> otherwise (so <span class="math">\\Delta\\equiv 0,1\\pmod{4}</span>). The ring of integers <span class="math">\\mathcal{O}_{K}</span> is <span class="math">\\mathbb{Z}[\\omega]</span>, where <span class="math">\\omega=\\frac{1}{2}(1+\\sqrt{d})</span> when <span class="math">d\\equiv 1\\pmod{4}</span> and <span class="math">\\omega=\\sqrt{d}</span> otherwise.</p>

    <p class="text-gray-300">The ideal class group is the quotient <span class="math">Cl(\\mathcal{O}_{K})=J_{K}/P_{K}</span>, where <span class="math">J_{K}</span> is the (Abelian) group of non-zero fractional ideals of <span class="math">\\mathcal{O}_{K}</span>, and <span class="math">P_{K}&lt;J_{K}</span> is the subgroup of non-zero principal fractional ideals. In practice, we represent <span class="math">Cl(\\mathcal{O}_{K})</span> using the isomorphic form class group <span class="math">Cl(\\Delta)</span> of binary quadratic forms of discriminant <span class="math">\\Delta</span> (the discriminant of <span class="math">K</span>). We let <span class="math">(a,b,c)</span> denote the binary quadratic form</p>

    <p class="text-gray-300"><span class="math">(a,b,c)=ax^{2}+bxy+cy^{2}\\in\\mathbb{Z}[x,y]\\quad\\text{with}\\quad b^{2}-4ac=\\Delta\\,.</span></p>

    <p class="text-gray-300">We can represent this form using only two coefficients <span class="math">(a,b)</span>, because <span class="math">c</span> is uniquely determined by <span class="math">c=(b^{2}-\\Delta)/4a</span>. A form <span class="math">(a,b)</span> is positive definite if <span class="math">a&gt;0</span>. As with ideal classes, there is an equivalence relation on quadratic forms: <span class="math">f</span> and <span class="math">g</span> are equivalent if <span class="math">f(x,y)=g(\\alpha x+\\beta y,\\gamma x+\\delta y)</span> for some <span class="math">\\alpha</span>, <span class="math">\\beta</span>, <span class="math">\\gamma</span>, and <span class="math">\\delta</span> in <span class="math">\\mathbb{Z}</span> with <span class="math">\\alpha\\delta-\\beta\\gamma=1</span> (that is, if they are in the same orbit under <span class="math">\\text{SL}_{2}(\\mathbb{Z})</span>). Equivalent forms always have the same discriminant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We represent each equivalence class in <span class="math">Cl(\\Delta)</span> using the unique reduced form in the class. A form <span class="math">(a,b,c)</span> is reduced if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq a\\leq c<span class="math">; and if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=a<span class="math"> or </span>a=c<span class="math">, then </span>b\\geq 0<span class="math">. Lagrange, and later Gauss and then Zagier, gave algorithms to find the equivalent reduced form for any binary quadratic form. The identity in </span>Cl(\\Delta)<span class="math"> is the equivalence class of the form </span>(1,0,-k)<span class="math"> if </span>\\Delta=4k<span class="math">, or </span>(1,1,k)<span class="math"> if </span>\\Delta=4k+1<span class="math">. The group law in </span>Cl(\\Delta)$, known as composition of forms, is due to Gauss; this does not usually output a reduced form, so reduction is an additional step. We shall not give these algorithms here, but refer the reader to <em>[19]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The order of <span class="math">Cl(\\mathcal{O}_{K})</span> is the class number of <span class="math">K</span>, denoted <span class="math">h(\\Delta)</span>. It follows from the Brauer–Siegel theorem (see <em>[39]</em>) that for sufficiently large negative discriminants, on average the class number satisfies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log h(\\Delta)\\sim\\log\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\quad\\text{as}\\quad\\Delta\\to-\\infty$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can therefore conservatively assume $\\approx\\frac{1}{2}\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-bit group sizes for cryptographic-sized negative discriminants.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The use of class groups in cryptography was first suggested by Buchmann and Williams <em>[15]</em>. Hafner and McCurley <em>[38]</em> gave a sub-exponential $L_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1/2)<span class="math"> algorithm for computing the order of </span>Cl(\\Delta)<span class="math">. Thus, the order of a class group </span>Cl(\\Delta)<span class="math"> of negative prime discriminant </span>\\Delta\\equiv 1\\pmod{4}<span class="math"> is believed to be difficult to compute, if </span>\\Delta<span class="math"> is sufficiently large. Lipmaa <em>[47]</em> proposed that </span>Cl(\\Delta)<span class="math"> can be used as a group of unknown order without trusted setup, simply by selecting a suitably large </span>\\Delta<span class="math"> and choosing an element in </span>Cl(\\Delta)<span class="math"> to be treated as a generator (it is not possible to know if it generates the whole of </span>Cl(\\Delta)$, or just a subgroup; we discuss this further below).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.2 THE SECURITY OF IDEAL CLASS GROUPS</h3>

    <p class="text-gray-300">Until now, cryptographic class group parameters have mainly been proposed with an eye to resisting subexponential algorithms for computing orders of quadratic imaginary class groups. In this section we re-assess the security these parameters in the light of Sutherland’s algorithm, and propose new (much larger) parameter sizes targeting the 128-bit security level.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hafner and McCurley gave their $L_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1/2)<span class="math"> algorithm to compute the order of quadratic imaginary class groups in 1989 <em>[38]</em>; Buchmann extended this to compute the group structure and discrete logarithms. See Biasse et al. <em>[9]</em> for a more up-to-date evaluation of the security of ideal class groups. The important thing to note is that these algorithms all have the same subexponential complexity </span>L_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1/2)<span class="math">, depending essentially on the size of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. In contrast, Sutherland’s algorithm has exponential worst-case runtime, but performs much faster with a non-negligible probability depending on the structure of the class group—a factor that Hafner–McCurley cannot exploit. When computing the order of a random class group, therefore, the small probability that Sutherland’s algorithm outperforms Hafner–McCurley must be taken into account.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The cryptographic parameter sizes in <em>[39]</em> and <em>[14]</em> both suppose that Hafner–McCurley is the best known algorithm. Concretely, it is suggested that a 1665-bit negative fundamental discriminant, which means an approximately 833-bit group order (cf. Eq. (1)), should provide 128-bit security. Biasse, Jacobson Jr., and Silvester <em>[9]</em> improve on previous attacks and suggest 1827-bit discriminants (which implies <span class="math">\\approx 914</span>-bit orders) are needed to achieve 128-bit security. These estimates have been quoted in more recent works, including <em>[16]</em> which estimates that 1600-bit discriminants provide 120-bit security, and <em>[12]</em> which proposes a slightly more conservative discriminant size of 2048 bits for 128-bit security.</p>

    <p class="text-gray-300">Suppose we try to compute the order of a random class group with 1827-bit fundamental negative discriminant using Sutherland’s algorithm. Sutherland’s algorithm has some important practical speedups when specialized from generic groups to class groups—for example, class group element negation is practically free, so time and memory can be reduced by a factor of <span class="math">\\sqrt{2}</span> (see <em>[59, Remark 3.1]</em>)—but these improvements do not significantly impact security levels. The performance of Sutherland’s algorithm on a given quadratic imaginary class group depends entirely on the class number.</p>

    <p class="text-gray-300">Hamdy and Möller <em>[39]</em> show that imaginary class numbers are more frequently smooth (although not significantly so) than uniformly random integers of the same size. We may therefore conservatively approximate the smoothness probability of random class group orders as being that of random integers. With the results of §2, the probability that a random class group with 1827-bit fundamental negative discriminant has less than 128 bits of security (<span class="math">u=7.1</span>) is at least <span class="math">2^{-14.3}</span>, and the chance it has less than 64-bit security is <span class="math">2^{-50}</span>. If a system is using a fixed class group as an accumulator, then we need to ask if these probabilities of weakness are acceptable. We claim that such groups do not satisfy Definition 1 for <span class="math">(\\lambda,\\rho)=(128,128)</span>, and so the security is weaker at these discriminant sizes than was previously thought.</p>

    <p class="text-gray-300">Bach and Peralta <em>[6]</em> give <span class="math">G(1/u,2/u)</span> for <span class="math">u=20</span> as <span class="math">2.415504\\times 10^{-26}\\approx 2^{-85}</span>. Thus, even for 85-bit security, we require 3400-bit discriminants. Using Banks and Shparlinski <em>[7]</em>’s method of approximating <span class="math">G(1/u,2/u)</span>, we estimate that for 100-bit security with respect to Sutherland’s algorithm, a discriminant of around 4500 bits would be required. For 128-bit security, <span class="math">u=26.5</span> gives <span class="math">G(1/u,2/u)\\approx 2^{-128}</span>, which implies a group order <span class="math">N\\approx 2^{128\\times 26.5}=2^{3392}</span>, and hence we estimate that <span class="math">\\Delta</span> should be approximately 6784 bits. We emphasize that <span class="math">G(1/u,2/u)</span> is only a lower bound for the success probability of Sutherland’s algorithm, but this should still serve at least as a guideline.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.3 COMPRESSING IDEAL CLASS GROUP ELEMENTS</h3>

    <p class="text-gray-300">Bleichenbacher <em>[10]</em> proposed a beautiful algorithm to compress Rabin signatures. His method can also be used to compress elements in ideal class groups. As far as we know, this simple observation has not yet been made in the literature.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.3.1 BLEICHENBACHER’S RABIN SIGNATURE COMPRESSION ALGORITHM</h4>

    <p class="text-gray-300">A Rabin signature on a message <span class="math">m</span> under the public key <span class="math">N</span> (an RSA modulus) is an integer <span class="math">\\sigma</span> such that</p>

    <p class="text-gray-300"><span class="math">\\sigma^{2}\\equiv m\\pmod{N}\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Normally <span class="math">\\sigma</span> is the same size as <span class="math">N</span>, but Bleichenbacher showed how to bring this down to <span class="math">\\sqrt{N}</span>. The continued fraction algorithm (or the Euclidean algorithm) can be used to compute integers <span class="math">s</span> and <span class="math">t</span> with <span class="math">0\\leq s&lt;\\sqrt{N}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{N}<span class="math"> such that </span>\\sigma t\\equiv s\\pmod{N}<span class="math">: see Algorithm 1 and Lemma 1 below. The compressed signature is </span>t<span class="math">. Given </span>m<span class="math"> and </span>t<span class="math">, let </span>x=mt^{2}\\bmod N<span class="math">; then </span>s^{2}\\equiv x\\pmod{N}<span class="math">, but </span>0\\leq s<\\sqrt{N}<span class="math">, so we can recover </span>s<span class="math"> from </span>m<span class="math"> and </span>t<span class="math"> by taking the integer square root of </span>x<span class="math">; and then it is trivial to recover </span>\\sigma\\equiv s/t\\pmod{N}<span class="math"> (note that if </span>t<span class="math"> is not invertible modulo </span>N<span class="math">, then we have found a factor of </span>N<span class="math">, and the signature scheme is broken). We may therefore replace </span>\\sigma<span class="math"> with </span>t<span class="math">, which has half the bitlength of </span>\\sigma$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input: Integers <span class="math">a&gt;b&gt;0</span> Output: Integers <span class="math">s</span> in <span class="math">[0,\\sqrt{a})</span> and <span class="math">t</span> in <span class="math">[-\\sqrt{a},\\sqrt{a}]</span> such that <span class="math">s\\equiv bt\\pmod{a}</span> 1 <span class="math">(s,s^{\\prime},t,t^{\\prime},u,u^{\\prime})\\leftarrow(b,a,1,0,0,1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 while <span class="math">s\\geq\\sqrt{a}</span> do // Invariants: $0\\leq s<s^{\\prime},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ s=au+bt,\\ s^{\\prime}=au^{\\prime}+bt^{\\prime}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3 <span class="math">q\\leftarrow s^{\\prime}\\operatorname{div}s</span> // Euclidean division without remainder 4 <span class="math">(s,s^{\\prime},t,t^{\\prime},u,u^{\\prime})\\leftarrow(s^{\\prime}-qs,s,t^{\\prime}-qt,t,u^{\\prime}-qu,u)</span> 5 return <span class="math">(s,t)</span></p>

    <p class="text-gray-300">Algorithm 1 PartialXGCD.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 1. Given integers <span class="math">a&gt;b&gt;0</span>, Algorithm 1 returns <span class="math">(s,t)</span> such that <span class="math">s\\equiv bt\\pmod{a}</span>, <span class="math">0\\leq s&lt;\\sqrt{a}</span>, and $0<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{a}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 1 is a truncated version of the extended Euclidean algorithm, stopping when <span class="math">s&lt;\\sqrt{a}</span> rather than <span class="math">s=0</span>. The invariants <span class="math">s^{\\prime}&gt;s\\geq 0</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>s=au+bt<span class="math">, and </span>s^{\\prime}=au^{\\prime}+bt^{\\prime}<span class="math"> are easily verified; in particular, </span>s\\equiv bt\\pmod{a}<span class="math">. From </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the fact that </span>t<span class="math"> is initialized to 1, we immediately get that </span>t\\neq 0<span class="math">. Another invariant, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s^{\\prime}t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq a<span class="math">, is proven in <em>[29, Lemma 2.3.3]</em>. Since </span>s<span class="math"> takes a sequence of strictly decreasing values, at some point </span>0\\leq s<\\sqrt{a}<span class="math"> and </span>s^{\\prime}\\geq\\sqrt{a}<span class="math">; this is where the loop terminates. It remains to show that at this point, we also have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{a}<span class="math">: but this follows from the invariant </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s^{\\prime}t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq a<span class="math"> and </span>s^{\\prime}\\geq\\sqrt{a}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">3.3.2 AN IMPROVED CLASS GROUP ELEMENT COMPRESSION ALGORITHM</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose we have a reduced form <span class="math">(a,b,c)</span> in <span class="math">Cl(\\Delta)</span>. Since <span class="math">b^{2}-4ac=\\Delta</span> is a known constant, it suffices to store <span class="math">(a,b)</span>. Since the form is reduced, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq a<\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, so the pair </span>(a,b)<span class="math"> can be encoded in approximately </span>\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ bits: this is the traditional “compressed” representation of a class group element.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">But we can do better. Since <span class="math">b^{2}-4ac=\\Delta</span>, we have</p>

    <p class="text-gray-300"><span class="math">b^{2}\\equiv\\Delta\\pmod{a}</span></p>

    <p class="text-gray-300">—a relation reminiscent of the Rabin signature verification equation. The situation is not exactly the same—<span class="math">a</span> is not an RSA modulus, and <span class="math">b</span> is in <span class="math">(-a,a]</span> rather than <span class="math">[0,a)</span>—but it is not difficult to adapt signature compression to class group element compression, encoding the coefficient <span class="math">b</span> in half the space.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we reduce to the case where <span class="math">b\\geq 0</span>: we store the sign of <span class="math">b</span> as <span class="math">\\epsilon=1</span> if <span class="math">b&lt;0</span>, and <span class="math">0</span> otherwise, and replace <span class="math">b</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We will treat the special cases </span>a=b<span class="math"> and </span>b=0<span class="math"> later; in the meantime, we may suppose that </span>0<b<a<span class="math">. Using Algorithm 1, we compute integers </span>s<span class="math"> and </span>t<span class="math"> such that </span>bt\\equiv s\\pmod{a}<span class="math">, </span>0\\leq s<\\sqrt{a}<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{a}$; then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">s^{2}\\equiv\\Delta t^{2}\\pmod{a}\\,.</span></p>

    <p class="text-gray-300">Given <span class="math">a</span> and <span class="math">t</span>, we can compute <span class="math">x=\\Delta t^{2}\\bmod{a}</span>, and then <span class="math">x=s^{2}</span> as integers because <span class="math">0\\leq s^{2}&lt;a</span>; so <span class="math">s</span> can be recovered as the exact (positive) integer square root. Now <span class="math">bt\\equiv s\\pmod{a}</span>, and the Bleichenbacher approach suggests compressing <span class="math">b</span> to <span class="math">t</span> and recovering <span class="math">b</span> as <span class="math">s/t\\pmod{a}</span>; but since <span class="math">a</span> is not an RSA modulus, we may—and often do—have <span class="math">\\gcd(a,t)\\neq 1</span>, and then <span class="math">t</span> cannot be inverted modulo <span class="math">a</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To fix this, we compress <span class="math">(a,b)</span> to <span class="math">(a^{\\prime},g,t^{\\prime},b_{0},\\epsilon)</span>, where <span class="math">g=\\gcd(a,t)</span>, <span class="math">a^{\\prime}=a/g</span>, <span class="math">t^{\\prime}=t/g</span>, $b_{0}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mod f<span class="math">. Here, </span>f\\geq g<span class="math"> is the smallest integer such that </span>\\operatorname{lcm}(f,a^{\\prime})\\geq a<span class="math">, and </span>\\epsilon<span class="math"> and </span>t<span class="math"> are defined as above. The reason for this choice of </span>f<span class="math"> is that since </span>b<span class="math"> is an integer satisfying </span>0<b<a<span class="math">, it is not necessary to compute </span>b<span class="math"> by computing </span>b\\pmod{a}<span class="math">. Instead, we can recover </span>b\\pmod{N}<span class="math"> for any integer </span>N\\geq a<span class="math">. Here we use </span>N=\\operatorname{lcm}(f,a^{\\prime})<span class="math">, where we ensure </span>N\\geq a<span class="math">, and this </span>f<span class="math"> is deterministically computable by the decompression algorithm. This avoids a failure to recover </span>b<span class="math"> uniquely, in the case that </span>a^{\\prime}<span class="math"> and </span>g<span class="math"> share common factors, if we had simply used </span>f=g<span class="math">. Roughly, because two random numbers are coprime with probability </span>6/\\pi^{2}<span class="math"> <em>[22]</em>, then we expect </span>f<span class="math"> to only be a small additive factor higher than </span>g<span class="math">, and therefore that </span>\\log_{2}f\\approx\\log_{2}g<span class="math">. Concretely, we compressed more than 30 million random class group elements of 3845-bit discriminants using an implementation in python, and found that </span>f-g<span class="math"> had an average value of 0.1234, and a maximum value of 16, after all these attempts. These numbers did not appear to grow with the size of </span>\\Delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To decompress, we compute <span class="math">a=a^{\\prime}g</span>, <span class="math">t=t^{\\prime}g</span>, <span class="math">x=t^{2}\\Delta\\bmod{a}</span>, and <span class="math">s=\\sqrt{x}</span>. Let <span class="math">b^{\\prime}\\equiv s^{\\prime}/t^{\\prime}\\pmod{a^{\\prime}}</span>, where <span class="math">s^{\\prime}=s/g</span>; note that <span class="math">s</span> is always divisible by <span class="math">g</span> since both <span class="math">a</span> and <span class="math">t</span> are, via the invariant <span class="math">s=au+bt</span> in Algorithm 1. Then <span class="math">b^{\\prime}\\equiv b\\pmod{a^{\\prime}}</span>, and we can compute <span class="math">b</span> uniquely from <span class="math">b\\equiv b_{0}\\pmod{f}</span> and <span class="math">b\\equiv b^{\\prime}\\pmod{a^{\\prime}}</span> using the Chinese Remainder Theorem, since <span class="math">b&lt;\\operatorname{lcm}(f,a^{\\prime})</span>. If <span class="math">\\epsilon=1</span> then we correct the sign, replacing <span class="math">b</span> with <span class="math">-b</span>; and after computing <span class="math">c</span> (if required) as <span class="math">(b^{2}-\\Delta)/(4a)</span>, we are done.</p>

    <p class="text-gray-300">For the special case <span class="math">a=b</span>, we exceptionally let <span class="math">t=0</span>; this is not ambiguous, because <span class="math">t=0</span> cannot occur in any other case. The compressed form is then <span class="math">(a^{\\prime},g,t^{\\prime},b_{0},\\epsilon)=(1,a,0,0,0)</span>. When <span class="math">b=0</span>, we compress to <span class="math">(a,0,0,0,0)</span>. Again, this is unambiguous: no other element of <span class="math">CI(\\Delta)</span> compresses to this value.</p>

    <p class="text-gray-300">Algorithms 2 and 3 make the compression and decompression procedures completely explicit. Note that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log_{2}a^{\\prime}+\\log_{2}g=\\log_{2}a\\approx\\log_{2}\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log_{2}t^{\\prime}+\\log_{2}b_{0}\\leq\\log_{2}t^{\\prime}+\\log_{2}f\\approx\\log_{2}t\\approx\\tfrac{1}{2}\\log_{2}\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2 therefore compresses the form <span class="math">(a,b,c)</span> to a $\\tfrac{3}{4}\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-bit representation, three-quarters of the size of the traditional </span>(a,b)$. When a party receives a compressed group element it is necessary for them to execute Algorithm 3 before performing group operations on the element.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-13" class="text-2xl font-bold">4 HYPERELLIPTIC JACOBIANS AS UNKNOWN-ORDER GROUPS</h2>

    <p class="text-gray-300">We now revisit Brent’s proposal of hyperelliptic Jacobians as a concrete source of unknown-order groups, focusing on genus <span class="math">g=3</span>. Hyperelliptic Jacobians can be seen as the ideal class groups of quadratic function fields. We will argue that even despite the existence of theoretical polynomial-time point-counting algorithms, these Jacobians may still present a more efficient alternative to class groups at the same security levels.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 HYPERELLIPTIC CURVES</h3>

    <p class="text-gray-300">We briefly recall the relevant background here; details can be found in <em>[48]</em> and <em>[29]</em>. The reader familiar with hyperelliptic curves may skip this section.</p>

    <p class="text-gray-300">Let <span class="math">q</span> be an odd prime power. A hyperelliptic curve <span class="math">C</span> of genus <span class="math">g&gt;1</span> over <span class="math">\\mathbb{F}_{q}</span> is defined by an equation <span class="math">y^{2}=f(s)</span>, where <span class="math">f</span> is a monic, squarefree polynomial of degree <span class="math">2g+1</span> over <span class="math">k</span>. A (finite) point on <span class="math">C</span> is a tuple <span class="math">(x,y)</span> in <span class="math">\\overline{\\mathbb{F}}_{q}^{2}</span> satisfying the defining equation of <span class="math">C</span>; there is also a unique point at infinity, denoted <span class="math">\\infty</span>.</p>

    <p class="text-gray-300">|  Algorithm 2: Element compression for Cl(Δ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: A reduced form (a,b,c) in Cl(Δ) (c may be omitted)  |   |</p>

    <p class="text-gray-300">|  Output: A compressed form (a',g,t',b0,ε)  |   |</p>

    <p class="text-gray-300">|  1 if b = 0 then return (a,0,0,0,0)  |   |</p>

    <p class="text-gray-300">|  2 if a = b then return (1,a,0,0,0)  |   |</p>

    <p class="text-gray-300">|  3 ε←{1 if b < 0 |   |</p>

    <p class="text-gray-300">|  0 otherwise |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4 b ←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6 g ← gcd(a,t) |   |</p>

    <p class="text-gray-300">|  7 (a',t') ← (a/g,t/g) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 f ←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9 while lcm(f,a') < a do |   |</p>

    <p class="text-gray-300">|  10 f ← f + 1 |   |</p>

    <p class="text-gray-300">|  11 b0 ← b mod f |   |</p>

    <p class="text-gray-300">|  12 return (a',g,t',b0,ε) |   |</p>

    <p class="text-gray-300">|  Algorithm 3: Element decompression for Cl(Δ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: A compressed form (a', g, t', b0, ε) and Δ  |   |</p>

    <p class="text-gray-300">|  Output: A reduced form (a, b, c) in Cl(Δ) (c may be omitted)  |   |</p>

    <p class="text-gray-300">|  1 if (g, t', b0, ε) = (0, 0, 0, 0) then return (a', 0, -Δ/(4a'))  |   |</p>

    <p class="text-gray-300">|  2 if t' = 0 then return (g, g, (g2 - Δ)/(4g))  |   |</p>

    <p class="text-gray-300">|  3 (a, t) ← (g · a', g · t')  |   |</p>

    <p class="text-gray-300">|  4 x ← t2Δ mod a  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5 s ← √x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// Integer square root</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7 b' ← s' · t-1 (mod a')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 f ←</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9 while lcm(f, a') < a do  |   |</p>

    <p class="text-gray-300">|  10 f ← f + 1  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11 b ← CRT((b', a'), (b0, f))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">// b ≡ b' (mod a') and b ≡ b0 (mod f)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  12 if ε = 1 then  |   |</p>

    <p class="text-gray-300">|  13 b ← -b  |   |</p>

    <p class="text-gray-300">|  14 return (a, b, (b2 - Δ))  |   |</p>

    <p class="text-gray-300">A divisor on  <span class="math">C</span>  is a formal sum of points  <span class="math">D = \\sum m_P P</span>  where  <span class="math">m_P = 0</span>  for all but finitely many  <span class="math">P</span> . The degree of a divisor is  <span class="math">\\deg D = \\sum m_P</span> . The divisors form a group  <span class="math">\\mathrm{Div}(C)</span> , and the divisors of degree zero form a proper subgroup  <span class="math">\\mathrm{Div}^0(C)</span>  of  <span class="math">\\mathrm{Div}(C)</span> . We let  <span class="math">\\mathcal{P}(C)</span>  denote the set of principal divisors of  <span class="math">C</span> : that is, divisors of the form  <span class="math">(\\gamma) = \\sum_{P \\in C} \\operatorname{ord}_P(\\gamma)P</span>  for some  <span class="math">\\gamma</span>  in the function field  <span class="math">\\overline{\\mathbb{P}}_q(C) = \\overline{\\mathbb{P}}_q(x)[y] / (y^2 - f(x))</span>  (here  <span class="math">\\operatorname{ord}_P(\\gamma)</span>  is the order of vanishing of  <span class="math">\\gamma</span>  at  <span class="math">P</span> ). Principal divisors have degree 0, so  <span class="math">\\mathcal{P}(C) \\subset \\mathrm{Div}^0(C)</span> ; the Jacobian is the quotient group</p>

    <div class="my-4 text-center"><span class="math-block">J _ {C} \\cong \\operatorname {D i v} ^ {0} (C) / \\mathcal {P} (C) \\tag {2}</span></div>

    <p class="text-gray-300">(also known as the degree-0 Picard group, denoted by  <span class="math">\\operatorname{Pic}^0(C)</span> ).</p>

    <p class="text-gray-300">We compute with elements of  <span class="math">J_{C}</span>  using the Mumford representation [49]. Each divisor class contains a unique reduced divisor in the form  <span class="math">P_{1} + \\dots + P_{r} - r\\infty</span>  (with the  <span class="math">P_{i}</span>  not necessarily distinct) with  <span class="math">r \\leq g</span>  and  <span class="math">P_{i} \\neq \\tilde{P}_{j}</span>  for all  <span class="math">i \\neq j</span> . The reduced divisors correspond to pairs of polynomials  <span class="math">\\langle u(x), v(x) \\rangle</span> , where  <span class="math">u</span>  is monic,  <span class="math">\\deg v &amp;lt; \\deg u \\leq g</span>  and  <span class="math">v^{2} \\equiv f \\pmod{u}</span> . The roots of  <span class="math">u(x)</span>  are the  <span class="math">x</span> -coordinates of the points in the support of the divisor. The divisor classes defined over  <span class="math">\\mathbb{F}_q</span> —that is, such that  <span class="math">u</span>  and  <span class="math">v</span>  have coefficients in  <span class="math">\\mathbb{F}_q</span> —form a finite group, denoted  <span class="math">J_{C}(\\mathbb{F}_{q})</span> . The Hasse-Weil bound tells us that  <span class="math">\\# J_{C} \\sim q^{g}</span> ; more precisely,</p>

    <div class="my-4 text-center"><span class="math-block">(\\sqrt {q} - 1) ^ {2 g} \\leq \\# J _ {C} (\\mathbb {F} _ {q}) \\leq (\\sqrt {q} + 1) ^ {2 g}.</span></div>

    <p class="text-gray-300">The group law on  <span class="math">J_{C}(\\mathbb{F}_{q})</span>  can be computed using Cantor's algorithm [17] (see also [23]). Efficient explicit formulae exist for  <span class="math">g = 2</span>  (see [45]) and  <span class="math">g = 3</span>  (see [27]).</p>

    <p class="text-gray-300">4.2 THE SECURITY OF HYPERELLIPTIC JACOBIANS</p>

    <p class="text-gray-300">Let <span class="math">C</span> be a hyperelliptic curve of genus <span class="math">g</span> over <span class="math">\\mathbb{F}_{q}</span>, where <span class="math">q=p^{n}</span>, and <span class="math">J_{C}</span> its Jacobian. Recall that <span class="math">\\#J_{C}(\\mathbb{F}_{q})\\approx q^{3}</span>. For <span class="math">J_{C}(\\mathbb{F}_{q})</span> to be useful as an unknown-order group, calculating <span class="math">\\#J_{C}(\\mathbb{F}_{q})</span> should be infeasible. Besides generic algorithms, two classes of algorithms specific to hyperelliptic Jacobians are relevant here: point-counting and discrete-log algorithms.</p>

    <p class="text-gray-300">As a base-line, <span class="math">C</span> must be chosen such that <span class="math">J_{C}(\\mathbb{F}_{q})</span> resists Sutherland’s algorithm with acceptable probability, as in §2. Sutherland’s algorithm has some important practical optimizations when specialized to hyperelliptic Jacobians—for example, we can exploit the fact that negation is effectively free to decrease storage and runtime by a factor of up to <span class="math">\\sqrt{2}</span> (see <em>[59, Remark 3.1]</em>), and even if a Jacobian is not directly vulnerable to Sutherland’s algorithm, its order may be deduced from that of vulnerable twists, as in <em>[60]</em>—but these improvements do not significantly impact security levels.</p>

    <p class="text-gray-300">To reach acceptable security levels against Sutherland’s algorithm using genus 3 curves then <span class="math">q</span> must be subexponentially large. Looking at Table 2, the cautious <span class="math">(\\lambda,\\rho)=(128,55)</span> level requires 1920-bit groups, or <span class="math">q\\approx 2^{640}</span>; the paranoid <span class="math">(128,128)</span> level requires 3392-bit groups, or <span class="math">q\\approx 2^{1131}</span>. Fields of this size also address the concerns of Lee <em>[46]</em>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">4.2.1 POINT-COUNTING ALGORITHMS</h4>

    <p class="text-gray-300">Computing <span class="math">\\#J_{C}(\\mathbb{F}_{q})</span> is a classic problem (called “point counting”) in algorithmic number theory: the goal is to compute the zeta function of <span class="math">C</span>, from which we immediately get <span class="math">\\#J_{C}(\\mathbb{F}_{q})</span>. The many dedicated point-counting algorithms fall naturally into two broad classes: <span class="math">p</span>-adic algorithms and <span class="math">\\ell</span>-adic “Schoof-type” algorithms. The <span class="math">p</span>-adic algorithms (notably Kedlaya’s algorithm <em>[42]</em> and its descendants <em>[40]</em>) have complexity polynomial with respect to <span class="math">g</span> and <span class="math">n</span>, but exponential in <span class="math">\\log p</span>. Taking <span class="math">q=p</span>, we can ignore these algorithms.</p>

    <p class="text-gray-300">Schoof-type algorithms compute <span class="math">\\#J_{C}(\\mathbb{F}_{q})</span> in polynomial time for fixed <span class="math">g</span>. Indeed, from a theoretical point of view, the existence of Schoof-type algorithms may make the use of hyperelliptic Jacobians as unknown-order groups seem perverse. But Schoof-type algorithms are totally impractical over large prime fields, even in genus as small as 3. To understand why, we need to look at how they operate.</p>

    <p class="text-gray-300">First, consider the case of elliptic curves (<span class="math">g=1</span>). Schoof’s ground-breaking <span class="math">\\widetilde{O}(\\log^{5}q)</span> algorithm <em>[56]</em>, the first polynomial-time point-counting algorithm for elliptic curves, computes the characteristic polynomial of Frobenius for a series of small prime <span class="math">\\ell</span>, using polynomial arithmetic modulo the division polynomials <span class="math">\\Psi_{\\ell}</span>, before combining the results with the Chinese Remainder Theorem to compute the zeta function. Its successor, the Schoof–Elkies–Atkin (SEA) algorithm <em>[57]</em>, runs in time <span class="math">\\widetilde{O}(\\log^{4}q)</span>, and has made elliptic-curve point counting routine.</p>

    <p class="text-gray-300">Pila generalised Schoof’s algorithm to higher-dimensional Abelian varieties <em>[51]</em>, including all Jacobians of curves. Pila’s algorithm is polynomial-time in <span class="math">p</span> and <span class="math">n</span>, but badly exponential in <span class="math">g</span>; as far as we know, it has never been implemented. The task gets a little simpler when we specialize from general Abelian varieties to hyperelliptic Jacobians. The crucial objects are the analogue of the division polynomials: these are multivariate division ideals vanishing on coordinates of points in torsion subgroups (in this sense, <span class="math">\\Psi_{\\ell}</span> generates the <span class="math">\\ell</span>-division ideal in genus <span class="math">g=1</span>). Cantor constructs generators for the <span class="math">\\ell</span>-division ideal in <em>[18]</em> (see also <em>[20]</em>); in genus 3, the degrees of Cantor’s <span class="math">\\ell</span>-division polynomials are bounded by <span class="math">O(\\ell^{2})</span> (see <em>[1]</em>).</p>

    <p class="text-gray-300">Schoof-type point-counting is already challenging in genus 2. Several genus-2 algorithms have been implemented and analysed, beginning with Gaudry and Harley <em>[32]</em> and Gaudry and Schost <em>[35]</em>. Pitcher’s PhD thesis <em>[52]</em> gave a genus-2 algorithm with complexity <span class="math">O((\\log q)^{7})</span>. Gaudry and Schost <em>[36]</em> used an improved algorithm, with a mixture of Pitcher’s approach and exponential birthday-paradox algorithms, to find a curve of secure order over the 127-bit Mersenne prime field <span class="math">\\mathbb{F}_{2^{127}-1}</span>. In their experiments, they claimed around 1,000 CPU hours on average to compute the order of a random genus-2 curve over this 127-bit field. Computing <span class="math">\\ell</span>-division ideals and analysing the action of Frobenius on them can become impractical for even moderately small <span class="math">\\ell</span>: the computations mentioned above, with an 8 GB limit on RAM, used primes <span class="math">\\ell\\leq 31</span> (the earlier <em>[35]</em> used <span class="math">\\ell</span> up to 19). They also used small prime powers <span class="math">\\ell^{k}=2^{16}</span>, <span class="math">3^{6}</span>, <span class="math">5^{4}</span>, and <span class="math">7^{2}</span>. These <span class="math">\\ell</span> and <span class="math">\\ell^{k}</span> are not sufficient to determine the group order; to finish the order computation, they used one- or two-dimensional random walks (a low-memory square-root algorithm: see <em>[34]</em> for details). We underline the fact that finishing this point-counting computation is a situation where in practice, an exponential algorithm is more practical than a polynomial-time one!</p>

    <p class="text-gray-300">We have found no practical work for general genus-2 curves going beyond <span class="math">\\ell=31</span> in the literature. Abelard’s PhD thesis <em>[1]</em> discusses the feasibility of continuing with larger <span class="math">\\ell</span>. With time complexity <span class="math">\\widetilde{O}(\\ell^{6}\\log q)</span> and space complexity <span class="math">\\widetilde{O}(\\ell^{4}\\log q)</span>, running time becomes more of an issue than memory: for 192-bit <span class="math">q</span>, the computation for <span class="math">\\ell=53</span> could take around 1000 CPU-days, yet still leave a search space of <span class="math">\\approx 2^{95}</span> elements in the exponential “collision” step of the algorithm.</p>

    <p class="text-gray-300">This practical work has not been extended to genus 3. The main obstruction is the complexity of computing with division ideals. Some theoretical analysis and projected complexities appear in <em>[2]</em>. Some first steps have been made for the very special class of genus-3 Jacobians with known and efficiently computable real multiplication endomorphisms in <em>[3]</em>, following the analogous genus-2 algorithm in <em>[33]</em>, but this approach does not apply to general genus-3 hyperelliptic Jacobians.</p>

    <p class="text-gray-300">Concretely, taking <span class="math">q\\sim 2^{100}</span> in genus 3 would appear sufficient to resist point counting on most curves <span class="math">C</span>, and result in <span class="math">\\#J_{C}(\\mathbb{F}_{q})\\sim 2^{300}</span>; the much larger group and field sizes required to resist Sutherland’s algorithm render point counting irrelevant as an attack.</p>

    <p class="text-gray-300">The upshot is that while point-counting for <em>fixed</em> genus <span class="math">g&gt;2</span> is polynomial-time in theory, it remains impractical—even infeasible—in the real world. This is already true of the relatively small field sizes relevant to discrete-logarithm-based cryptography; it is even more so for the much larger, subexponential-sized fields required to protect against Sutherland’s algorithm in the unknown-order setting.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Some work has been done on generating genus-2 and genus-3 Jacobians with a known number of points using CM theory, for applications in DLP-based cryptography, notably by Weng <em>[63, 64]</em> (see also e.g. <em>[36]</em> and <em>[41]</em>). Obviously, these curve-generation methods must be avoided for unknown-order applications.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">One might hope that progress in computing higher-genus modular polynomials might yield a SEA analogue improving substantially on pure Schoof-style point counting. However, any SEA analogue in genus <span class="math">g&gt;3</span> would actually be <em>slower</em> than pure Schoof. Indeed, the number of isogenies splitting <span class="math">[\\ell]</span> (and hence the degree of the ideal that a SEA analogue would use at the prime <span class="math">\\ell</span>) is in <span class="math">O(\\ell^{g(g+1)/2})</span>; this exceeds the degree of the <span class="math">\\ell</span>-division ideal, which is in <span class="math">O(\\ell^{2g})</span>. Even for <span class="math">g=3</span>, the asymptotic complexity of SEA is no better than that of Schoof.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">4.2.2 DISCRETE LOGARITHM ALGORITHMS</h4>

    <p class="text-gray-300">If the DLP can be efficiently solved in a subgroup <span class="math">\\langle G\\rangle\\subset J_{C}(\\mathbb{F}_{q})</span>, the order of <span class="math">\\langle G\\rangle</span> can also be efficiently computed: if <span class="math">xG=\\mathcal{O}</span>, where is the cryptographic subgroup, then <span class="math">x</span> is (a multiple of) the order. Suppose, then, that we want to solve the DLP in <span class="math">J_{C}(\\mathbb{F}_{q})</span>, where <span class="math">C</span> is a curve of genus <span class="math">g</span> over <span class="math">\\mathbb{F}_{q}</span>. Gaudry et al. <em>[37]</em> and Nagao <em>[50]</em> present algorithms for small <span class="math">g</span> running in time <span class="math">\\widetilde{O}(q^{2-2/g})</span>, improving on the <span class="math">O(q^{2})</span> algorithm of <em>[31]</em>, and the single-large-prime algorithm of <em>[62]</em>. This has better performance for genus 3 than square-root algorithms like Pollard Rho, which has expected runtime in <span class="math">\\widetilde{O}(q^{3/2})</span>; but in genus 2, Pollard Rho is more efficient, in <span class="math">\\widetilde{O}(q)</span>. Avanzi, Thériault, and Wang <em>[5]</em> further discuss security in these cases.</p>

    <p class="text-gray-300">Smith <em>[58]</em> gives a method of transferring the DLP from hyperelliptic to non-hyperelliptic genus-3 Jacobians that applies to 18.57% of genus-3 curves; Diem’s algorithm <em>[25]</em> can then be used to solve the DLP in time <span class="math">\\widetilde{O}(q)</span>. Laine and Lauter <em>[43]</em> examine and improve on Diem’s attack (including analysis of the logarithmic factors, which they estimate to be <span class="math">O(\\log^{2}q)</span>), but the memory requirement for their attack is high at <span class="math">\\widetilde{O}(q^{3/4})</span>. The practical results from <em>[43]</em> suggest that even for <span class="math">q\\sim 2^{100}</span>, discrete logarithms require around <span class="math">2^{113}</span> field multiplications and <span class="math">1.2\\times 10^{14}</span>TB of memory, assuming the reduction of <em>[58]</em> applies; if not, the algorithm of <em>[37]</em> would require on the order of <span class="math">2^{133}</span> operations. Genus-3 hyperelliptic curves avoiding isogeny-based attacks are constructed in <em>[44]</em>.</p>

    <p class="text-gray-300">As <span class="math">g</span> tends to infinity, there exist subexponential attacks on the DLP using index calculus (for example, <em>[26]</em>); but these have no impact for fixed genus 2 and 3.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.3 GENERATING HYPERELLIPTIC JACOBIANS OF UNKNOWN ORDER</h3>

    <p class="text-gray-300">Algorithm 4 (Gen) takes security parameters <span class="math">(\\lambda,\\rho)</span> (as in Definition 1), and outputs a generator <span class="math">P</span> for a group <span class="math">G</span> such that Sutherland’s algorithm running in time <span class="math">2^{\\lambda}</span> succeeds in computing <span class="math">\\#G</span> with probability less than <span class="math">1/2^{\\rho}</span>. The group <span class="math">G</span> is realized as (a subgroup of) a genus-3 hyperelliptic Jacobian. Having chosen a suitable prime <span class="math">p</span> as a function of <span class="math">(\\lambda,\\rho)</span>, the algorithm samples a uniformly random monic irreducible degree-7 polynomial <span class="math">f(x)</span> in <span class="math">\\mathbb{F}_{p}[x]</span> and polynomials <span class="math">u</span> and <span class="math">v</span> such that <span class="math">\\langle u,v\\rangle</span> is the Mumford representation of a divisor class <span class="math">P</span> in <span class="math">J_{C}(\\mathbb{F}_{p})</span>, where <span class="math">C</span> is the curve defined by <span class="math">y^{2}=f(x)</span>. Being random, <span class="math">P</span> generates a large-order subgroup of <span class="math">J_{C}(\\mathbb{F}_{p})</span> with high probability.</p>

    <p class="text-gray-300">Taking <span class="math">f</span> to be random makes the probability that <span class="math">C</span> is a “weak” curve overwhelmingly small. The order of a random Jacobian should have a large prime factor, protecting against Pohlig–Hellman; the largest prime factor should not divide <span class="math">q^{k}-1</span> for small <span class="math">k</span>, protecting against MOV-type attacks <em>[28]</em>; and the group order should be prime to <span class="math">p=\\text{char}(\\mathbb{F}_{q})</span> to avoid “anomalous curve” attacks <em>[54]</em>. Randomly-sampled Jacobians do not have special endomorphisms, such as the efficiently-computable real multiplication exploited for faster point counting in <em>[3]</em>, because these special classes of curves form positive-codimensional subspaces of the moduli space. Recent work of Thakur <em>[61]</em> further discusses classes of curves to avoid. The security of random ideal class groups as groups of unknown order depends on similar assumptions and heuristics <em>[21]</em>.</p>

    <p class="text-gray-300">Taking <span class="math">f</span> irreducible over <span class="math">\\mathbb{F}_{p}</span> ensures that <span class="math">J_{C}(\\mathbb{F}_{p})</span> has no points of order 2. As we will see in §5, it may be possible to construct points of small odd order. We could try this for a few small primes <span class="math">\\ell</span> to eliminate <span class="math">C</span> with small</p>

    <p class="text-gray-300">factors in  <span class="math">\\# J_{C}(\\mathbb{F}_{p})</span> , but this makes no significant difference to the probability of semismoothness of  <span class="math">\\# J_{C}(\\mathbb{F}_{p})</span> , and thus to Sutherland's algorithm. Our simulations showed that rejecting random group orders divisible by the first few primes decreased the semismoothness probability by less than a factor of 2.</p>

    <p class="text-gray-300">| Algorithm 4: Gen. Constructs a random unknown-order (subgroup of a) genus-3 hyperelliptic Jacobian. |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: (λ,ρ) |</p>

    <p class="text-gray-300">| Output: A prime p, a hyperelliptic genus-3 curve C/ Fp, and P ∈ JC such that ⟨P⟩ has unknown order. |</p>

    <p class="text-gray-300">| 1 Determine n such that a random genus-3 curve over an n-bit prime field has λ-bits of security with probability 1 - 1/2ρ |</p>

    <p class="text-gray-300">| 2 p ← a random n-bit prime |</p>

    <p class="text-gray-300">| 3 Sample random u(x) = x3 + u2x2 + u1x + u0 in Fp[x] |</p>

    <p class="text-gray-300">| 4 Sample random v(x) = v2x2 + v1x + v0 in Fp[x] |</p>

    <p class="text-gray-300">| 5 repeat |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sample random w(x) = x4 + w3x3 + w2x2 + w1x + w0 in Fp[x]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 8 until gcd(f(x), f'(x)) = 1 and f is irreducible |</p>

    <p class="text-gray-300">| 9 P ← ⟨u, v⟩ |</p>

    <p class="text-gray-300">| 10 return (p, C, P) where C is the hyperelliptic curve y2 = f(x) over Fp |</p>

    <p class="text-gray-300">To ensure that not even the constructor of  <span class="math">C</span>  knows  <span class="math">\\# J_{C}(\\mathbb{F}_{p})</span> , and that  <span class="math">C</span>  and  <span class="math">P = \\langle u, v \\rangle</span>  were indeed generated randomly, we suggest that  <span class="math">u, v</span> , and  <span class="math">w</span>  be chosen by deterministic "nothing up my sleeve"-type process. For example, the coefficients of  <span class="math">f</span>  might be taken from the hash of a certain string. Suppose this process were manipulated by taking multiple "seeds", and testing each resulting curve for weakness. If the probability of encountering a weak curve among random curves is  <span class="math">\\delta</span> , and testing for weakness costs  <span class="math">2^{n}</span>  operations, then a malicious actor requires around  <span class="math">\\delta^{-1}2^{n}</span>  operations to generate a weak  <span class="math">C</span> . A sceptical verifier, on the other hand, must only test the proposed  <span class="math">C</span>  just once to detect cheating, at a cost of just  <span class="math">2^{n}</span>  operations. This imbalance of the cost of cheating versus verifying is a deterrent for attackers, regardless of the weakness in question.</p>

    <p class="text-gray-300">Now the order of the Jacobian  <span class="math">J_{C}(\\mathbb{F}_{p})</span>  (and the subgroup generated by  <span class="math">P</span> ) cannot feasibly be computed, not even by the party who constructed the curve: we have achieved trustless setup. This group can then be used in cryptographic constructions including accumulators and VDFs. Overall, the generation of a new hyperelliptic curve is relatively cheap. Therefore, just as in the case of class groups, it should be feasible to generate a new group of unknown order for each new instance of an accumulator or VDF if desired.</p>

    <p class="text-gray-300">Elements of  <span class="math">J_{C}(\\mathbb{F}_{q})</span>  are represented as pairs of polynomials  <span class="math">\\langle u, v \\rangle</span>  with  <span class="math">\\deg v &amp;lt; \\deg u \\leq g</span> , so elements can be stored concretely with 6 elements of  <span class="math">\\mathbb{F}_{q}</span> , and further compressed to just 3  <span class="math">\\mathbb{F}_{q}</span> -elements and 3 extra bits using the method of [41]. For  <span class="math">(\\lambda, \\rho) = (128, 55)</span> , with  <span class="math">\\approx 640</span> -bit fields, this means that group elements can be stored in  <span class="math">\\approx 1920</span>  bits; elements of a class group of equivalent security require  <span class="math">\\approx 2860</span>  bits with the compression of §3.3 (or  <span class="math">\\approx 3840</span>  bits without it). Moving to the more paranoid security level of  <span class="math">(\\lambda, \\rho) = (128, 128)</span> , hyperelliptic Jacobian elements require  <span class="math">\\approx 3392</span>  bits while class-group elements require  <span class="math">\\approx 5088</span>  bits (or  <span class="math">\\approx 6784</span>  bits without the compression of §3.3). We therefore claim that genus-3 Jacobians offer more compact elements than class groups at the same security level.</p>

    <p class="text-gray-300">We now briefly consider the problem of constructing points of known order in groups of unknown order. This will give us an idea of how to work with Jacobians when the low-order or adaptive root assumptions are imposed.</p>

    <p class="text-gray-300">Common additional requirements on unknown-order groups include</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the low-order assumption: finding an element  <span class="math">P</span>  of a given order  <span class="math">s</span>  in  <span class="math">G</span>  is hard (see [11, Def. 1]); and</li>

      <li>the adaptive root assumption: extracting roots of a given element—that is, given  <span class="math">Q</span>  and  <span class="math">s</span> , find  <span class="math">P</span>  such that  <span class="math">Q = [s]P</span>  in  <span class="math">G</span> —is hard (see [11, Def. 2] and [65]).</li>

    </ul>

    <p class="text-gray-300">These assumptions only make sense if the adversary must solve arbitrary instances in a randomly-sampled <span class="math">G</span>; it is not possible to define security for a fixed <span class="math">G</span>. Example 1 describes Wesolowski’s Proof of Exponentiation (PoE), a protocol which requires these assumptions.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Example 1 (PoE).</h6>

    <p class="text-gray-300">Let <span class="math">G</span> be a group, chosen according to security parameter <span class="math">\\lambda</span>. The Proof of Exponentiation takes as input <span class="math">u</span> and <span class="math">w</span> in <span class="math">G</span> and <span class="math">x</span> in <span class="math">\\mathbb{Z}</span>, and aims to prove that <span class="math">u^{x}=w</span> in significantly less time than it takes to compute <span class="math">u^{x}</span>. It proceeds interactively as follows (although it can be made non-interactive: see <em>[65]</em>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends a random prime <span class="math">\\ell\\in\\text{Primes}(\\lambda)</span> to Prover.</li>

      <li>Prover computes <span class="math">q=\\lfloor x/\\ell\\rfloor</span> and <span class="math">Q=u^{q}</span>, and sends <span class="math">Q</span> to Verifier.</li>

      <li>Verifier computes <span class="math">r=x</span> mod <span class="math">\\ell</span>, and accepts if <span class="math">Q^{\\ell}u^{r}=w</span></li>

    </ol>

    <p class="text-gray-300">To see why the security of this protocol requires the low-order assumption, suppose we know an element <span class="math">\\epsilon</span> of order <span class="math">2</span> in <span class="math">G</span> (for example, if <span class="math">G</span> is an RSA group, then we can take <span class="math">\\epsilon=-1</span>). Then for any valid proof that <span class="math">u^{x}=w</span>, we can easily generate a false proof of the contradictory statement <span class="math">u^{x}=\\epsilon w</span>, by replacing <span class="math">Q</span> with <span class="math">Q^{\\prime}=\\epsilon Q</span> in the proof. Since <span class="math">\\ell</span> is odd, <span class="math">(Q^{\\prime})^{\\ell}u^{r}=\\epsilon Q^{\\ell}u^{r}=\\epsilon w</span> holds despite the fact that <span class="math">u^{x}\\neq\\epsilon w</span>. This is why when using RSA groups, it is important to use the quotient <span class="math">(\\mathbb{Z}/N\\mathbb{Z})^{*}/\\langle\\pm 1\\rangle</span> to eliminate this element.</p>

    <p class="text-gray-300">Suppose we are given an algorithm <span class="math">\\mathsf{Gen}</span> constructing unknown-order groups reaching the <span class="math">(\\lambda,\\rho)</span> security level. If we can specify a set <span class="math">\\mathcal{S}</span> containing the integers <span class="math">s</span> such that we can construct elements of order <span class="math">s</span> or extract <span class="math">s</span>-th roots in groups <span class="math">G</span> output by <span class="math">\\mathsf{Gen}</span> in <span class="math">&lt;2^{\\lambda}</span> operations with probability <span class="math">&gt;2^{-\\rho}</span>, then the low-order and adaptive-root assumptions hold in the subgroup</p>

    <p class="text-gray-300"><span class="math">[S]G=\\{[S]P\\mid P\\in G\\}\\qquad\\text{where}\\qquad S:=\\operatorname{lcm}(\\mathcal{S})~{}.</span> (3)</p>

    <p class="text-gray-300">We will propose conservative choices for <span class="math">\\mathcal{S}</span> for concrete groups below. In the meantime, to give some concrete intuition, if we take <span class="math">\\mathcal{S}=\\{1,\\ldots,60\\}</span> then <span class="math">S</span> is an <span class="math">84</span>-bit integer, so multiplication by <span class="math">S</span> is efficient.</p>

    <p class="text-gray-300">The operation of protocols such as accumulators in <span class="math">[S]G</span> is standard, but some protocols may need modification: for example, proofs may require an extra check that an element is indeed in the group. The issue here is that given a point <span class="math">Q</span> in <span class="math">G</span>, testing subgroup membership <span class="math">Q\\in[S]G</span> is not easy. However, the original point <span class="math">Q</span> is effectively a proof that <span class="math">[S]Q</span> is in <span class="math">[S]G</span>, because this can be easily verified; so <span class="math">Q</span> should be sent instead of <span class="math">[S]Q</span> in cryptographic protocols, and the verifier can perform the multiplication by <span class="math">S</span> themselves.</p>

    <p class="text-gray-300">Using <span class="math">[S]G</span> in place of <span class="math">G</span> has an impact on efficiency, due to the extra scalar multiplications required. This impact is highly protocol-dependent, but in most cases only a few extra multiplications should be needed. To give a specific example, we revisit the PoE from Example 1 in Example 2. The verifier only needs to perform one extra multiplication-by-<span class="math">S</span> during verification when working in <span class="math">[S]G</span> instead of <span class="math">G</span>. We suggest that this is efficient enough for practical use, and that other protocols using the adaptive root assumption can be modified in a similar way.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Example 2 (PoE in <span class="math">[S]G</span>).</h6>

    <p class="text-gray-300">We begin the PoE protocol with input <span class="math">U\\in G</span>, <span class="math">W\\in[S]G</span>, and <span class="math">x\\in\\mathbb{Z}</span>. The claim to be proven is that <span class="math">[x][S]U=W</span> in <span class="math">[S]G</span>. The protocol proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier selects a random <span class="math">\\ell</span> from <span class="math">\\text{Primes}(\\lambda)\\setminus\\mathcal{S}</span> and sends <span class="math">\\ell</span> to Prover.</li>

      <li>Prover computes <span class="math">q=\\lfloor x/\\ell\\rfloor</span>, computes <span class="math">Q=[q]U</span> in <span class="math">G</span> and sends <span class="math">Q</span> to Verifier.</li>

      <li>Verifier computes <span class="math">r=x</span> mod <span class="math">\\ell</span>, and accepts if <span class="math">Q</span> is in <span class="math">G</span> and <span class="math"><a href="[\\ell]Q+[r]U">S</a>=W</span>.</li>

    </ol>

    <p class="text-gray-300">The security of this protocol depends on the choice of <span class="math">\\mathcal{S}</span>. Given a valid proof of <span class="math">[x][S]U=W</span>, in order to falsely prove <span class="math">[x][S]U=W+P</span>, the prover must compute <span class="math">[1/\\ell]P</span> for the <span class="math">\\ell</span> chosen by the verifier. This may be possible if the order of <span class="math">P</span> is known, but this is supposed to be infeasible because <span class="math">\\ell</span> is not in <span class="math">\\mathcal{S}</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">The impact of finding small-order elements is highly domain-specific. For example, in the VDF of <em>[65, 11]</em>, even if points of known order can be found, forging a false PoE still requires knowing the true result of the exponentiation—and hence still requires computing the output of the VDF. Relying on a PoE would thus break the requirement that the VDF output is unique, but it would still provide assurance of the delay. For accumulators, we need an analogue of the strong RSA assumption rather than the adaptive root assumption: it should be hard to find chosen prime roots of an element (recall that the membership witness of <span class="math">\\ell</span> in <span class="math">A</span> is the <span class="math">\\ell</span>-th root of <span class="math">A</span>). This case can be addressed differently, by simply disallowing the accumulation of small primes <span class="math">\\ell</span> dividing elements of <span class="math">\\mathcal{S}</span>. Finding <span class="math">\\ell</span>-th roots with <span class="math">\\ell</span> not in <span class="math">\\mathcal{S}</span> is supposed to be infeasible, so here we do not need to use <span class="math">[S]G</span>.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.2 ELEMENTS OF KNOWN ORDER IN CLASS GROUPS AND JACOBIANS</h3>

    <p class="text-gray-300">For class groups, it is well-known that the factorization of <span class="math">\\Delta</span> reveals the <span class="math">2</span>-torsion structure of <span class="math">Cl(\\Delta)</span>, and even allows the explicit construction of elements of order <span class="math">2</span>. Similarly, for Jacobians, if <span class="math">C/\\mathbb{F}_{q}</span> is defined by <span class="math">y^{2}=f(x)</span>, then the factorization of <span class="math">f(x)</span> reveals the <span class="math">2</span>-torsion structure of <span class="math">J_{C}(\\mathbb{F}_{q})</span>, and lets us construct explicit points of</p>

    <p class="text-gray-300">order <span class="math">2</span>. This motivates the restriction to negative prime <span class="math">\\Delta</span> when using <span class="math">Cl(\\Delta)</span> as an unknown-order group, and our restriction to irreducible <span class="math">f</span> in Algorithm 4.</p>

    <p class="text-gray-300">Belabas, Kleinjung, Sanso, and Wesolowski <em>[8]</em> give several constructions of special discriminants <span class="math">\\Delta</span> together with a known ideal of small odd order in <span class="math">Cl(\\Delta)</span>. Similarly, we can construct hyperelliptic Jacobians equipped with a point of small order, as in Example 3.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Example 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be an odd prime, and set <span class="math">g=(\\ell-1)/2</span>. Choose a polynomial <span class="math">c(x)</span> over <span class="math">\\mathbb{F}_{q}</span> of degree <span class="math">\\leq g</span> such that <span class="math">f(x):=x^{\\ell}+c(x)^{2}</span> is squarefree. Then <span class="math">C:y^{2}=f(x)</span> is a hyperelliptic curve of genus <span class="math">g</span>, and the divisor <span class="math">D=(0,c(0))-(\\infty)</span> represents a nontrivial element of order <span class="math">\\ell</span> in <span class="math">J_{C}(\\mathbb{F}_{q})</span> (because <span class="math">\\ell D</span> is the principal divisor of the function <span class="math">y-c(x)</span>). Taking <span class="math">\\ell=7</span> gives a family of genus-3 Jacobians with a known element of order <span class="math">7</span>.</p>

    <p class="text-gray-300">These discriminants and curves generally do not occur when <span class="math">\\Delta</span> or <span class="math">f</span> is chosen in a “nothing-up-my-sleeve” way. In any case, the risk of choosing groups with constructible small-order elements can be eliminated by using a smooth cofactor <span class="math">S</span>.</p>

    <p class="text-gray-300">There are three curve-specific methods for constructing elements of known small order, or deducing information about small divisors of the order of a given element, which do not apply to class groups. The first is to use the division ideals. This is practical for small primes like <span class="math">2</span>, <span class="math">3</span>, and <span class="math">5</span> (reinforcing the need for the cofactor <span class="math">S</span> above). However, if we assume that there exists no feasible Schoof-type algorithm for counting points on genus <span class="math">3</span> curves, then we implicitly assume that it is infeasible to construct <span class="math">\\ell</span>-division ideals for <span class="math">\\ell</span> larger than some bound that is polynomial with respect to the security parameters.</p>

    <p class="text-gray-300">The second method is to use repeated divisions by <span class="math">2</span> in <span class="math">J_{C}(\\mathbb{F}_{q})</span> to construct points of order <span class="math">2^{k}</span> for arbitrarily large <span class="math">k</span>. Since <span class="math">2^{k}</span> is coprime to all odd primes <span class="math">\\ell</span>, this allows malicious provers to easily find <span class="math">\\ell</span>-th roots for these points (that is, given a point <span class="math">Q</span>, find <span class="math">P</span> such that <span class="math">[\\ell]P=Q</span>). But repeated division by <span class="math">2</span> in <span class="math">J_{C}(\\mathbb{F}_{q})</span> requires the repeated extraction of square roots in <span class="math">\\mathbb{F}_{p}</span>, which quickly requires repeated quadratic field extensions and the field computations blow-up exponentially. Using hyperelliptic curves in the form <span class="math">y^{2}=f(x)</span> with <span class="math">f(x)</span> irreducible ensures that the required square roots do not exist in <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Similarly, we might calculate repeated divisions by very small odd primes. Using the group <span class="math">[S]J_{C}(\\mathbb{F}_{q})</span> will kill off powers of these small primes dividing the group order. It could also be possible to simply test for these repeated divisions during the curve generation procedure, allowing parties to check for small factors of the group order—and then kill these off with a tailored choice of <span class="math">S</span>. It is an interesting open problem to generate an easily verifiable proof that a Jacobian does not have any points of low order.</p>

    <p class="text-gray-300">The third method involves the Tate pairing. Let <span class="math">C</span> be a hyperelliptic curve over <span class="math">\\mathbb{F}_{q}</span>, let <span class="math">\\ell</span> be a prime (coprime to <span class="math">q</span>), and let <span class="math">k</span> be the smallest positive integer such that <span class="math">\\ell\\mid q^{k}-1</span>. The reduced <span class="math">\\ell</span>-Tate pairing is a bilinear mapping</p>

    <p class="text-gray-300"><span class="math">t_{\\ell}:J_{C}[\\ell]\\times J_{C}(\\mathbb{F}_{q^{k}})/\\ell J_{C}(\\mathbb{F}_{q^{k}})\\longrightarrow\\mu_{\\ell}\\subset\\mathbb{F}_{q^{k}}^{\\times}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">\\mu_{\\ell}</span> is the group of <span class="math">\\ell</span>-th roots of unity (see <em>[30]</em> for background on pairings on hyperelliptic curves). If we can find points of known order <span class="math">\\ell</span>, then the <span class="math">\\ell</span>-Tate pairing can give information about the <span class="math">\\ell</span>-divisibility of other points.</p>

    <p class="text-gray-300">Suppose we can find a point <span class="math">Q</span> in <span class="math">J_{C}(\\mathbb{F}_{q^{k}})</span> of small known prime order <span class="math">\\ell</span>. Then for any point <span class="math">P</span> in <span class="math">J_{C}(\\mathbb{F}_{q})</span>, we can efficiently compute <span class="math">t_{\\ell}(Q,P)</span> in <span class="math">\\mu_{\\ell}</span> (assuming <span class="math">k</span> is only polynomially large in <span class="math">\\log q</span>). Now, if <span class="math">\\ell\\not\\uparrow\\operatorname{Ord}(P)</span>, then <span class="math">P=\\ell P^{\\prime}</span> for some <span class="math">P^{\\prime}</span>, so <span class="math">t_{\\ell}(Q,P)=1</span>. By the contrapositive, if <span class="math">t_{\\ell}(Q,P)\\neq 1</span>, then <span class="math">\\ell</span> divides the order of <span class="math">P</span>.</p>

    <p class="text-gray-300">Unfortunately, the converse is not so simple: <span class="math">t_{\\ell}(Q,P)=1</span> for a single point <span class="math">Q</span> of order <span class="math">\\ell</span> does not imply <span class="math">\\ell\\not\\uparrow\\operatorname{Ord}(P)</span>. Instead, it must be shown that <span class="math">t_{\\ell}(Q,P)=1</span> for all <span class="math">Q</span> in <span class="math">J_{C}[\\ell]</span>. Thus, we require a basis <span class="math">\\{Q_{1},\\ldots,Q_{2g}\\}</span> of <span class="math">J_{C}[\\ell]</span> which we can test: if <span class="math">t_{\\ell}(Q_{i},P)=1</span> for <span class="math">1\\leq i\\leq 2g</span>, then the bilinearity of the Tate pairing implies <span class="math">t_{\\ell}(Q,P)</span> for all <span class="math">Q</span> in <span class="math">J_{C}[\\ell]</span>, and hence that <span class="math">\\gcd(\\operatorname{Ord}(P),\\ell)=1</span>.</p>

    <p class="text-gray-300">The utility of this approach is limited by the difficulty of constructing points of order <span class="math">\\ell</span>, but also by the field extension degree <span class="math">k</span> (since the coordinates of <span class="math">Q</span> and the value of <span class="math">t_{\\ell}(Q,P)</span> are in <span class="math">\\mathbb{F}_{q^{k}}</span>); and <span class="math">k</span>, being the order of <span class="math">q</span> modulo <span class="math">\\ell</span>, tends to blow up with <span class="math">\\ell</span>. If <span class="math">q</span> is well-chosen, then in practice we can learn very little information about the orders of random points in <span class="math">J_{C}(\\mathbb{F}_{q})</span>, or any information at all for points in <span class="math">[S]J_{C}(\\mathbb{F}_{q})</span> for a suitable <span class="math">S</span>. For the Jacobian case, we conjecture that <span class="math">\\mathcal{S}=\\{1,\\ldots,60\\}</span> is sufficient for a <span class="math">(128,128)</span> security level, based on the discussion in §4.2.1. For class groups, <span class="math">\\mathcal{S}</span> can either be empty in the case of a prime discriminant, or <span class="math">\\mathcal{S}=\\{2\\}</span> if a non-prime discriminant is used.</p>

    <h2 id="sec-27" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Simon Abelard. “Counting points on hyperelliptic curves in large characteristic: algorithms and complexity”. PhD thesis. Université de Lorraine, 2018. url: https://tel.archives-ouvertes.fr/tel-01876314.</li>

      <li>[2] Simon Abelard, Perrick Gaudry, and Pierre-Jean Spaenlehauer. “Improved complexity bounds for counting points on hyperelliptic curves”. In: Foundations of Computational Mathematics 19.3 (2019), pp. 591–621.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[3] Simon Abelard, Pierrick Gaudry, and Pierre-Jean Spaenlehauer. “Counting points on genus-3 hyperelliptic curves with explicit real multiplication”. In: ANTS-XIII. Proceedings of the Thirteenth Algorithmic Number Theory Symposium. Ed. by Renate Scheidler and Jonathan Sorenson. Vol. 2. The Open Book Series 1. Mathematical Sciences Publishers, 2019, pp. 1–19. doi: 10.2140/obs.2019.2.1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] Martin R. Albrecht, Jake Massimo, Kenneth G. Paterson, and Juraj Somorovsky. “Prime and Prejudice: Primality Testing Under Adversarial Conditions”. In: Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018, Toronto, ON, Canada, October 15-19, 2018. Ed. by David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang. ACM, 2018, pp. 281–298. doi: 10.1145/3243734.3243787.</li>

      <li>[5] Roberto Avanzi, Nicolas Thériault, and Zheng Wang. “Rethinking low genus hyperelliptic Jacobian arithmetic over binary fields: Interplay of field arithmetic and explicit formulae”. In: Journal of Mathematical Cryptology 2.3 (2008), pp. 227–255.</li>

      <li>[6] Eric Bach and René Peralta. “Asymptotic semismoothness probabilities”. In: Mathematics of computation 65.216 (1996), pp. 1701–1715.</li>

      <li>[7] William D. Banks and Igor E. Shparlinski. “Integers with a large smooth divisor”. In: Integers 7.A17 (2007), pp. 1–11.</li>

      <li>[8] Karim Belabas, Thorsten Kleinjung, Antonio Sanso, and Benjamin Wesolowski. A note on the low order assumption in class group of an imaginary quadratic number fields. Cryptology ePrint Archive, Report 2020/1310. https://eprint.iacr.org/2020/1310. 2020.</li>

      <li>[9] Jean-François Biasse, Michael J. Jacobson Jr., and Alan K. Silvester. “Security Estimates for Quadratic Field Based Cryptosystems”. In: Information Security and Privacy – ACISP 2010. Ed. by Ron Steinfeld and Philip Hawkes. Vol. 6168. Lecture Notes in Computer Science. Springer, 2010, pp. 233–247. doi: 10.1007/978-3-642-14081-5_15.</li>

      <li>[10] Daniel Bleichenbacher. “Compressing Rabin Signatures”. In: Topics in Cryptology – CT-RSA 2004. Ed. by Tatsuaki Okamoto. Vol. 2964. Lecture Notes in Computer Science. Springer, 2004, pp. 126–128. doi: 10.1007/978-3-540-24660-2_10.</li>

      <li>[11] Dan Boneh, Benedikt Bünz, and Ben Fisch. A Survey of Two Verifiable Delay Functions. Cryptology ePrint Archive, Report 2018/712. https://eprint.iacr.org/2018/712. 2018.</li>

      <li>[12] Dan Boneh, Benedikt Bünz, and Ben Fisch. “Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains”. In: Advances in Cryptology – CRYPTO 2019. Ed. by Alexandra Boldyreva and Daniele Micciancio. Vol. 11692. Lecture Notes in Computer Science. Springer, 2019, pp. 561–586. isbn: 978-3-030-26948-7.</li>

      <li>[13] Richard P. Brent. Public Key Cryptography with a Group of Unknown Order. Tech. rep. Oxford University, 2000.</li>

      <li>[14] Johannes Buchmann and Safuat Hamdy. “A Survey on IQ Cryptography”. In: Public Key Cryptography and Computational Number Theory. Proceedings of the International Conference organized by the Stefan Banach International Mathematical Center Warsaw, Poland, September 11-15, 2000. Ed. by Kazimierz Alster, Jerzy Urbanowicz, and Hugh C. Williams. De Gruyter Proceedings in Mathematics. De Gruyter, 2001, pp. 1–15. doi: 10.1515/9783110881035.</li>

      <li>[15] Johannes Buchmann and Hugh C. Williams. “A key-exchange system based on imaginary quadratic fields”. In: Journal of Cryptology 1.2 (June 1988), pp. 107–118. issn: 1432-1378. doi: 10.1007/BF02351719.</li>

      <li>[16] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. “Transparent SNARKs from DARK Compilers”. In: Advances in Cryptology – EUROCRYPT 2020. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. Lecture Notes in Computer Science. Springer, 2020. doi: 10.1007/978-3-030-45721-1_24.</li>

      <li>[17] David G. Cantor. “Computing in the Jacobian of a hyperelliptic curve”. In: Mathematics of Computation 48.177 (1987), pp. 95–101.</li>

      <li>[18] David G. Cantor. “On the analogue of the division polynomials for hyperelliptic curves.” In: Journal für die reine und angewandte Mathematik 447 (1994), pp. 91–146. url: http://eudml.org/doc/153593.</li>

      <li>[19] Henri Cohen. A Course in Computational Algebraic Number Theory. Vol. 138. Graduate Texts in Mathematics. Springer, 2010. doi: 10.1007/978-3-662-02945-9.</li>

      <li>[20] Henri Cohen, Gerhard Frey, Roberto Avanzi, Christophe Doche, Tanja Lange, Kim Nguyen, and Frederik Vercauteren. Handbook of elliptic and hyperelliptic curve cryptography. Chapman and Hall/CRC, 2005.</li>

    </ul>

    <p class="text-gray-300">[21] Henri Cohen and Hendrik W. Lenstra. “Heuristics on class groups of number fields”. In: Number Theory Noordwijkerhout 1983. Ed. by Hendrik Jager. Vol. 1068. Lecture Noetes in Mathematics. Springer, 1984, pp. 33–62.</p>

    <p class="text-gray-300">[22] George E. Collins and Jeremy R. Johnson. “The Probability of Relative Primality of Gaussian Integers”. In: Symbolic and Algebraic Computation, International Symposium ISSAC’88, Rome, Italy, July 4-8, 1988, Proceedings. Vol. 358. Lecture Notes in Computer Science. Springer, 1988, pp. 252–258. DOI: 10.1007/3-540-51084-2\\_23. URL: https://doi.org/10.1007/3-540-51084-2%5C_23.</p>

    <p class="text-gray-300">[23] Craig Costello and Kristin Lauter. “Group Law Computations on Jacobians of Hyperelliptic Curves”. In: Selected Areas in Cryptography – SAC 2011. Ed. by Ali Miri and Serge Vaudenay. Vol. 7118. Lecture Notes in Computer Science. Springer, 2012, pp. 92–117. DOI: 10.1007/978-3-642-28496-0_6.</p>

    <p class="text-gray-300">[24] David A. Cox. <em>Primes of the Form <span class="math">x^2 + ny^2</span>: Fermat, Class Field Theory, and Complex Multiplication</em>. Monographs and textbooks in pure and applied mathematics. Wiley, 1989. ISBN: 9780471506546. URL: https://books.google.co.nz/books?id=pSMLAQAAIAAJ.</p>

    <p class="text-gray-300">[25] Claus Diem. “An Index Calculus Algorithm for Plane Curves of Small Degree”. In: Algorithmic Number Theory – ANTS 2006. Ed. by Florian Hess, Sebastian Pauli, and Michael Pohst. Vol. 4076. Lecture Notes in Computer Science. Springer, 2006, pp. 543–557. DOI: 10.1007/11792086_38.</p>

    <p class="text-gray-300">[26] Andreas Enge. “Computing Discrete Logarithms in High-genus Hyperelliptic Jacobians in Provably Subexponential Time”. In: Mathematics of Computation 71.238 (Apr. 2002), pp. 729–742. DOI: 10.1090/S0025-5718-01-01363-1.</p>

    <p class="text-gray-300">[27] Xinxin Fan, Thomas Wollinger, and Guang Gong. “Efficient explicit formulae for genus 3 hyperelliptic curve cryptosystems over binary fields”. In: IET Information Security 1.2 (2007), pp. 65–81.</p>

    <p class="text-gray-300">[28] Gerhard Frey and Hans-Georg Rück. “A Remark Concerning M-divisibility and the Discrete Logarithm in the Divisor Class Group of Curves”. In: Math. Comput. 62.206 (Apr. 1994), pp. 865–874. ISSN: 0025-5718. DOI: 10.2307/2153546.</p>

    <p class="text-gray-300">[29] Steven D. Galbraith. Mathematics of Public Key Cryptography. 1st edition. Cambridge University Press, 2012. DOI: 10.1017/CBO9781139012843.</p>

    <p class="text-gray-300">[30] Steven D. Galbraith, Florian Hess, and Frederik Vercauteren. “Hyperelliptic Pairings”. In: Pairing-Based Cryptography – Pairing 2007. Ed. by Tsuyoshi Takagi, Tatsuaki Okamoto, Eiji Okamoto, and Takeshi Okamoto. Vol. 4575. Lecture Notes in Computer Science. Springer, 2007, pp. 108–131. ISBN: 978-3-540-73489-5.</p>

    <p class="text-gray-300">[31] Pierrick Gaudry. “An Algorithm for Solving the Discrete Log Problem on Hyperelliptic Curves”. In: Advances in Cryptology – EUROCRYPT 2000. Ed. by Bart Preneel. Vol. 1807. Lecture Notes in Computer Science. Springer, 2000, pp. 19–34. DOI: 10.1007/3-540-45539-6_2.</p>

    <p class="text-gray-300">[32] Pierrick Gaudry and Robert Harley. “Counting Points on Hyperelliptic Curves over Finite Fields”. In: Algorithmic Number Theory – ANTS 2000. Ed. by Wieb Bosma. Vol. 1838. Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2000, pp. 313–332. DOI: 10.1007/10722028_18.</p>

    <p class="text-gray-300">[33] Pierrick Gaudry, David Kohel, and Benjamin Smith. “Counting Points on Genus 2 Curves with Real Multiplication”. In: Advances in Cryptology – ASIACRYPT 2011 (Seoul, South Korea). Ed. by Dong Hoon Lee and Xiaoyun Wang. Vol. 7073. Lecture Notes in Computer Science. Heidelberg: Springer, 2011, pp. 504–519. DOI: 10.1007/978-3-642-25385-0_27.</p>

    <p class="text-gray-300">[34] Pierrick Gaudry and Éric Schost. “A Low-Memory Parallel Version of Matsuo, Chao, and Tsujii’s Algorithm”. In: Algorithmic Number Theory – ANTS 2004. Ed. by Duncan Buell. Vol. 3076. Lecture Notes in Computer Science. Springer, 2004, pp. 208–222. DOI: 10.1007/978-3-540-24847-7_15.</p>

    <p class="text-gray-300">[35] Pierrick Gaudry and Éric Schost. “Construction of Secure Random Curves of Genus 2 over Prime Fields”. In: Advances in Cryptology – EUROCRYPT 2004. Ed. by Christian Cachin and Jan L. Camenisch. Vol. 3027. Lecture Notes in Computer Science. Springer, 2004, pp. 239–256. DOI: 10.1007/978-3-540-24676-3_15.</p>

    <p class="text-gray-300">[36] Pierrick Gaudry and Éric Schost. “Genus 2 point counting over prime fields”. In: Journal of Symbolic Computation 47.4 (2012), pp. 368–400.</p>

    <p class="text-gray-300">[37] Pierrick Gaudry, Emmanuel Thomé, Nicolas Thériault, and Claus Diem. “A Double Large Prime Variation for Small Genus Hyperelliptic Index Calculus”. In: Mathematics of Computation 76.257 (2007), pp. 475–492.</p>

    <p class="text-gray-300">[38] James Lee Hafner and Kevin S. McCurley. “A rigorous subexponential algorithm for computation of class groups”. In: Journal of the American Mathematical Society 2.4 (1989), pp. 837–850.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">[39] Safuat Hamdy and Bodo Möller. "Security of Cryptosystems Based on Class Groups of Imaginary Quadratic Orders". In: Advances in Cryptology – ASIACRYPT 2000. Ed. by Tatsuaki Okamoto. Vol. 1976. Lecture Notes in Computer Science. Springer, 2000, pp. 234–247. doi: 10.1007/3-540-44448-3_18.</p>

    <p class="text-gray-300">[40] David Harvey. "Kedlaya's Algorithm in Larger Characteristic". In: International Mathematics Research Notices 2007 (Jan. 2007). doi: 10.1093/imrn/rnm095.</p>

    <p class="text-gray-300">[41] Florian Hess, Gadiel Seroussi, and Nigel P. Smart. “Two topics in hyperelliptic cryptography”. In: Selected Areas in Cryptography – SAC 2000. Ed. by Douglas R. Stinson and Stafford Tavares. Vol. 2259. Lecture Notes in Computer Science. Springer, 2001, pp. 181–189.</p>

    <p class="text-gray-300">[42] Kiran S. Kedlaya. "Counting points on hyperelliptic curves using Monsky-Washnitzer cohomology". In: Journal of the Ramanujan Mathematical Society 16 (2001), pp. 323–338.</p>

    <p class="text-gray-300">[43] Kim Laine and Kristin Lauter. "Time-memory trade-offs for index calculus in genus 3". In: Journal of Mathematical Cryptology 9.2 (2015), pp. 95–114.</p>

    <p class="text-gray-300">[44] Kim H. M. Laine. "Security of Genus 3 Curves in Cryptography". PhD thesis. University of California, Berkeley, 2015.</p>

    <p class="text-gray-300">[45] Tanja Lange. "Formulae for Arithmetic on Genus 2 Hyperelliptic Curves". In: Applicable Algebra in Engineering, Communication and Computing 15.5 (Feb. 2005), pp. 295–328. doi: 10.1007/s00200-004-0154-8.</p>

    <p class="text-gray-300">[46] Jonathan Lee. The security of Groups of Unknown Order based on Jacobians of Hyperelliptic Curves. Cryptology ePrint Archive, Report 2020/289. https://eprint.iacr.org/2020/289. 2020.</p>

    <p class="text-gray-300">[47] Helger Lipmaa. "Secure Accumulators from Euclidean Rings without Trusted Setup". In: Applied Cryptography and Network Security – ACNS 2012. Ed. by Feng Bao, Pierangela Samarati, and Jianying Zhou. Vol. 7341. Lecture Notes in Computer Science. Springer, 2012, pp. 224–240. doi: 10.1007/978-3-642-31284-7_14.</p>

    <p class="text-gray-300">[48] Alfred Menezes, Yi-Hong Wu, and Robert J. Zuccherato. An Elementary Introduction to Hyperelliptic Curves. Appendix in Algebraic Aspects of Cryptography by Neal Koblitz, Springer-Verlag, 1998, pages 155–178. 1996.</p>

    <p class="text-gray-300">[49] David Mumford. Tata Lectures on Theta II. Birkhäuser, Jan. 2007, pp. 207–213. doi: 10.1007/978-0-8176-4578-6_13.</p>

    <p class="text-gray-300">[50] Koh-ichi Nagao. Improvement of Thériault Algorithm of Index Calculus for Jacobian of Hyperelliptic Curves of Small Genus. Cryptology ePrint Archive, Report 2004/161. https://eprint.iacr.org/2004/161. 2004.</p>

    <p class="text-gray-300">[51] Jonathan Pila. "Frobenius maps of Abelian varieties and finding roots of unity in finite fields". In: Mathematics of Computation 55.192 (1990), pp. 745–763.</p>

    <p class="text-gray-300">[52] Nicole L. Pitcher. "Efficient point-counting on genus-2 hyperelliptic curves". PhD thesis. University of Illinois at Chicago, 2009, p. 124. ISBN: 9781109242188.</p>

    <p class="text-gray-300">[53] Ronald L. Rivest, Adi Shamir, and David A. Wagner. Time-lock puzzles and timed-release crypto. Technical Report MIT/LCS/TR-684. 1996.</p>

    <p class="text-gray-300">[54] Hans-Georg Rück. "On the Discrete Logarithm in the Divisor Class Group of Curves". In: Math. Comput. 68.226 (Apr. 1999), pp. 805–806. ISSN: 0025-5718. DOI: 10.1090/S0025-5718-99-01043-1.</p>

    <p class="text-gray-300">[55] Tomas Sander. "Efficient Accumulators without Trapdoor Extended Abstract". In: Information and Communication Security – ICICS 1999. Ed. by Vijay Varadharajan and Yi Mu. Vol. 1726. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, 1999, pp. 252–262. DOI: 10.1007/978-3-540-47942-0_21.</p>

    <p class="text-gray-300">[56] René Schoof. "Elliptic curves over finite fields and the computation of square roots mod <span class="math">p</span>". In: Mathematics of Computation 44.170 (1985), pp. 483–494.</p>

    <p class="text-gray-300">[57] René Schoof. "Counting points on elliptic curves over finite fields". In: Journal de Théorie des Nombres de Bordeaux 7.1 (1995), pp. 219–254. URL: http://www.numdam.org/item/JTNB_1995__7_1_219_0/.</p>

    <p class="text-gray-300">[58] Benjamin Smith. "Isogenies and the Discrete Logarithm Problem in Jacobians of Genus 3 Hyperelliptic Curves," in: Journal of Cryptology 22.4 (Oct. 2009), pp. 505–529. ISSN: 1432-1378. DOI: 10.1007/s00145-009-9038-1.</p>

    <p class="text-gray-300">[59] Andrew V. Sutherland. "Order computations in generic groups". PhD thesis. Massachusetts Institute of Technology, 2007.</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">[60] Andrew V. Sutherland. “A generic approach to searching for Jacobians”. In: <em>Mathematics of Computation</em> 78.265 (2009), pp. 485–507.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[61] Steve Thakur. <em>Constructing hidden order groups using genus three Jacobians</em>. Cryptology ePrint Archive, Report 2020/348. https://eprint.iacr.org/2020/348. 2020.</li>

      <li>[62] Nicolas Thériault. “Index Calculus Attack for Hyperelliptic Curves of Small Genus”. In: <em>Advances in Cryptology – ASIACRYPT 2003</em>. Ed. by Chi-Sung Laih. Vol. 2894. Lecture Notes in Computer Science. Springer, 2003, pp. 75–92. doi: 10.1007/978-3-540-40061-5_5.</li>

      <li>[63] Annegret Weng. “A class of hyperelliptic CM-curves of genus three”. In: <em>Journal of the Ramanujan Mathematical Society</em> 16.4 (Jan. 2001), pp. 339–372.</li>

      <li>[64] Annegret Weng. “Constructing hyperelliptic curves of genus 2 suitable for cryptography”. In: <em>Mathematics of Computation</em> 72.241 (2003), pp. 435–458.</li>

      <li>[65] Benjamin Wesolowski. “Efficient Verifiable Delay Functions”. In: <em>Advances in Cryptology – EUROCRYPT 2019</em>. Ed. by Yuval Ishai and Vincent Rijmen. Vol. 11478. Lecture Notes in Computer Science. Springer, 2019, pp. 379–407. doi: 101007/978-3-030-17659-4_13.</li>

    </ul>`;
---

<BaseLayout title="Trustless unknown-order groups (2020/196)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/196
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
