---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/397';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Feistel Structures for MPC, and More';
const AUTHORS_HTML = 'Martin R.  Albrecht, Lorenzo Grassi, Leo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, Markus Schofnegger';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We study approaches to generalized Feistel constructions with low-degree round functions with a focus on x -&gt; x^3 . Besides known constructions, we also provide a new balanced Feistel construction with improved diffusion properties. This then allows us to propose more efficient generalizations of the MiMC design (Asiacrypt&rsquo;16), which we in turn evaluate in three application areas. Whereas MiMC was not competitive at all in a recently proposed new class of PQ-secure signature schemes, our new construction leads to about 30 times smaller signatures than MiMC. In MPC use cases, where MiMC outperforms all other competitors, we observe improvements in throughput by a factor of more than 4 and simultaneously a 5-fold reduction of preprocessing effort, albeit at the cost of a higher latency. Another use case where MiMC already outperforms other designs, in the area of SNARKs, sees modest improvements. Additionally, this use case benefits from the flexibility to use smaller fields.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Feistel &middot; Multiplicative Complexity &middot; Algebraic Attack &middot; Secure Multiparty Computation (MPC) &middot; PQ-secure Signature Scheme &middot; SNARKs</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Description of Generalized MiMC</h2>

    <p class="text-gray-300"><strong>Notation.</strong> In a Feistel network,  <span class="math">X_{i-1}</span>  denotes the input to the branch i, where  <span class="math">1 \\leq i \\leq t</span> .  <span class="math">X_{t-1}</span>  and  <span class="math">X_0</span>  denote the inputs to the leftmost and rightmost branches respectively.  <span class="math">X_i \\in \\mathbb{F}</span>  for a finite field  <span class="math">\\mathbb{F}</span> . The block size (in bits) of the keyed Feistel permutation is denoted by N, while  <span class="math">n = \\lceil \\log_2 |\\mathbb{F}| \\rceil</span>  denotes the branch size (in bits). We write  <span class="math">\\mathbb{F}_p</span>  for the finite prime field of order p. We write  <span class="math">\\mathbb{F}_{2^q}</span>  for any finite field of order  <span class="math">2^q</span> . The bit size of the key of a block cipher is denoted by  <span class="math">\\kappa</span> . In particular, through the paper we work with two different cases (depending on the practical implementation), denoted as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the <em>univariate</em> case, for which the key-size is  <span class="math">\\kappa = n = \\lceil \\log_2 |\\mathbb{F}| \\rceil</span> ;</li>
      <li>the multivariate case, for which the key-size is  <span class="math">\\kappa = N = n \\cdot t = \\lceil \\log_2 |\\mathbb{F}| \\rceil \\cdot t</span> .</li>
    </ul>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The Block Cipher GMiMC</h3>

    <p class="text-gray-300">We construct &quot;Generalized Feistel MiMC&quot; (GMiMC) variants from several generalized (unbalanced and balanced) Feistel networks, e.g., with contracting round function (CRF),</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: One round of a t-branch unbalanced Feistel network (UFN) with a contracting round function (CRF).</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: One round of a t-branch unbalanced Feistel network (UFN) with an expanding round function (ERF).</p>

    <p class="text-gray-300">expanding round function (ERF), Nyberg's GFN and a new structure which we call Multi-Rotating (MR). Each of the following constructions is a keyed permutation over  <span class="math">\\mathbb{F}_{2^n}</span>  or  <span class="math">\\mathbb{F}_p</span> . The three main parameters of the block ciphers are denoted by  <span class="math">[\\kappa, t, n]</span> . For example, GMiMC<sub>crf</sub>[4n, 4, n] denotes the permutation GMiMC with CRF which has branch size n, key size 4n and number of branches 4. The numbers of rounds for all constructions are given in Table 3. The key schedule is linear and equal for all the proposed designs, and it is discussed in the following. All round constants are chosen randomly and fixed.</p>

    <p class="text-gray-300">The following constructions are defined over  <span class="math">\\mathbb{F}_{2^n}</span> . The description over  <span class="math">\\mathbb{F}_p</span>  is obtained by replacing the XOR-sum  <span class="math">\\oplus</span>  with the corresponding sum + modulo p.</p>

      <h4 id="sec-2.1.1" class="text-lg font-semibold mt-6">2.1.1 GMiMC<sub>crf</sub></h4>

    <p class="text-gray-300">An unbalanced Feistel network (UFN) with a contracting round function (CRF) can be written as</p>

    <p class="text-gray-300"><span class="math">$(X_{t-1}, X_{t-2}, \\dots, X_0) \\leftarrow (X_{t-2}, X_{t-3}, \\dots, X_{t-1} \\oplus F(X_{t-2}, \\dots, X_0))</span>$</p>

    <p class="text-gray-300">where  <span class="math">X_i</span>  is the input to the <em>i</em>-th branch of the Feistel network and  <span class="math">F(\\cdot)</span>  is a key-dependent function in round j, cf. Figure 1. In GMiMC<sub>crf</sub> we define the j-th round function as</p>

    <p class="text-gray-300"><span class="math">$F(x_{t-2},\\ldots,x_0) := \\left(\\bigoplus_i x_i \\oplus k_j \\oplus c_j\\right)^3</span>$</p>

    <p class="text-gray-300">where  <span class="math">c_j</span>  and  <span class="math">k_j</span>  are respectively the round constant and the key of the round j (for  <span class="math">1 \\le j \\le r</span> ).</p>

      <h4 id="sec-2.1.2" class="text-lg font-semibold mt-6">2.1.2 GMiMC<sub>erf</sub></h4>

    <p class="text-gray-300">An unbalanced Feistel network with an expanding round function (ERF) can be written as</p>

    <p class="text-gray-300"><span class="math">$(X_{t-1}, X_{t-2}, \\dots, X_0) \\leftarrow (X_{t-2} \\oplus F(X_{t-1}), \\dots, X_0 \\oplus F(X_{t-1}), X_{t-1})</span>$</p>

    <p class="text-gray-300">    <img src="_page_5_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: One round of a 4-branch Nyberg Generalized Feistel Network (GFN).</p>

    <p class="text-gray-300">where <em>X<sup>i</sup></em> is the input to the <em>i</em>-th branch of the Feistel network and <em>F</em>(&middot;) is a key-dependent function in round <em>j</em>, cf. Figure <a href="#page-4-1">2.</a> In GMiMCerf the <em>j</em>-th round function is defined as</p>

    <p class="text-gray-300"><span class="math">$F(x) \\coloneqq (x \\oplus k_j \\oplus c_j)^3</span>$</p>

    <p class="text-gray-300">where <em>k<sup>j</sup></em> and <em>c<sup>j</sup></em> are as in GMiMCcrf.</p>

      <h4 id="sec-2.1.3" class="text-lg font-semibold mt-6"><strong>2.1.3 GMiMCNyb</strong></h4>

    <p class="text-gray-300">A generalized Feistel network was proposed in <a href="#page-35-8">[60]</a> for an even number of branches and can be written as</p>

    <p class="text-gray-300"><span class="math">$(X_{t-1},\\ldots,X_1,X_0) \\leftarrow (X_{t-2} \\oplus F_0(X_{t-1}),X_{t-3},\\ldots,X_0 \\oplus F_{t/2}(X_1),X_{t-1})</span>$</p>

    <p class="text-gray-300">Each <em>Fi</em>(&middot;) in the <em>j</em>-th round of GMiMCNyb is defined as</p>

    <p class="text-gray-300"><span class="math">$F_i(x) := (x \\oplus k_{i+j\\cdot t/2} \\oplus c_{i+j\\cdot t/2})^3,</span>$</p>

    <p class="text-gray-300">where <em>ci</em>+<em>j</em>&middot;<em>t/</em><sup>2</sup> are distinct constants in round <em>j</em> and <em>ki</em>+<em>j</em>&middot;<em>t/</em><sup>2</sup> are round keys, cf. Figure <a href="#page-5-0">3.</a></p>

      <h4 id="sec-2.1.4" class="text-lg font-semibold mt-6"><strong>2.1.4 GMiMCmrf</strong></h4>

    <p class="text-gray-300">In <a href="#page-35-4">[74]</a>, Suzaki and Minematsu introduced new variants of the GFN structure where the linear mixing applied after the Feistel functions is a complex permutation rather than a simple rotation. This allowed them to build GFNs operating on <em>t</em> = 2<em><sup>b</sup></em> branches such that full diffusion is achieved in 2<em>b</em> rounds rather than the 2<em>t</em> rounds needed by a Nyberg-style construction. They later used this approach to build the lightweight block cipher Twine <a href="#page-35-5">[75]</a>.</p>

    <p class="text-gray-300">When the number of branches is not a power of 2, the authors of <a href="#page-33-1">[30]</a> proposed a computer search that can find optimal permutations when the number of branches is not too large, typically lower than 30.</p>

    <p class="text-gray-300">Here, we introduce the Multi-Rotating structure for generalized Feistel networks, which provides full diffusion as quickly as a Twine-like structure without the constraint that the number of branches is a power of 2 or lower than a certain threshold. It is also conceptually much simpler and thus easier in practice to apply to a larger number of branches. These improvements come at the cost of the use of a <em>different mixing layer in each round</em> which, to the best of our knowledge, has not been considered for a Feistel or generalized Feistel structure so far. However, we note that previously, the Serpent designers (of SPN type) considered using different mixing layers in each round in their design. In particular, they considered using a different linear transformation for even and odd rounds (see <a href="#page-32-5">[20,</a> App. A.6]), before settling for their current design.</p>

    <p class="text-gray-300">To introduce the Multi-Rotating Feistel network structure, we first give a general expression of its round function. A <em>rotated Feistel round</em> is a permutation R<em><sup>s</sup></em> parameterized by a rotation amount <em>s</em> which operates on an even number of branches and works as</p>

    <p class="text-gray-300">    <img src="_page_6_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: One round  <span class="math">\\mathcal{R}_s</span>  of an 8-branch Multi-Rotating Feistel network with a rotation by s=2.</p>

    <p class="text-gray-300">follows:</p>

    <p class="text-gray-300"><span class="math">$(X_{t-1},\\ldots,X_0) \\leftarrow (X_{t/2-1} + F_{-s}(X_{t-1-g(s,0)}), X_{t/2-1} \\oplus F_{1-s}(X_{t-1-g(s,1)}), \\ldots, X_0 \\oplus F_{t/2-1-s}(X_{t-1-g(s,t/2-1)}), X_{t-1},\\ldots,X_{t/2})</span>$</p>

    <p class="text-gray-300">where the index of the function  <span class="math">F(\\cdot)</span>  is taken modulo t/2 and  <span class="math">g(s,i) = s+i \\mod t/2</span> . This process is summarized in Figure 4. Like in  <span class="math">GMiMC_{Nyb}</span> , each  <span class="math">F_i</span>  in the j-th round of  <span class="math">GMiMC_{mf}</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$F_i(x) := \\left( x \\oplus k_{i+j\\cdot t/2} \\oplus c_{i+j\\cdot t/2} \\right)^3,</span>$</p>

    <p class="text-gray-300">where  <span class="math">c_{i+j\\cdot t/2}</span>  are distinct constants in round j and  <span class="math">k_{i+j\\cdot t/2}</span>  are round keys. By iterating such rounds  <span class="math">\\mathcal{R}_s</span>  for varying values of s we obtain a block cipher. An instance of such an r-round block cipher is specified using the sequence  <span class="math">\\{s_0, ..., s_{r-1}\\}</span>  of the r rotation amounts used. As explained in Appendix B, it is possible to build a GFN with optimal diffusion by choosing the sequence  <span class="math">\\{s_j\\}_{j &lt; r}</span>  carefully.</p>

    <p class="text-gray-300">We build a GMiMC<sub>mrf</sub> instance operating on t branches using a sequence of rotations  <span class="math">\\{s_j\\}_{0 \\le j \\le r}</span>  where</p>

    <p class="text-gray-300">
<span class="math">$s_{2\\ell} = 0</span>$
, and  <span class="math">s_{2\\ell+1} = 2^{\\ell \\pmod{\\lceil \\log_2(t/2) \\rceil}}</span> . (1)</p>

    <p class="text-gray-300">For instance, if t=32, then  <span class="math">\\log_2(t/2)=4</span>  and this sequence can be written as  <span class="math">\\{0,1,0,2,0,4,0,8,0,1,0,2,0,4,0,8,0,1,\\ldots\\}</span> , i.e. it consists in as many repetitions as needed of the pattern  <span class="math">\\{0,1,0,2,0,4,0,8\\}</span>  of length  <span class="math">2\\log_2(t/2)=8</span> .</p>

    <p class="text-gray-300">To better understand the security of  <span class="math">GMiMC_{mrf}</span> , we now investigate its diffusion. We borrow our definition of diffusion from [74]: if a variable y intervenes in the expression of an internal state word X then we say that X depends on y. If all output words of a (round-reduced) block cipher depend on all input words, we say that this primitive provides full diffusion.</p>

    <p class="text-gray-300">The diffusion provided by  <span class="math">GMiMC_{mrf}</span>  using the sequence of rotations from Equation (1) is quantified by the following Theorem, proved in Appendix B.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let  <span class="math">X_j^i</span>  denote the word with index j at the input of round i, so that for example  <span class="math">X_j^0</span>  denotes a plaintext word. Consider a GMiMC<sub>mrf</sub> instance operating on t branches with the rotation sequence in Equation 1. If  <span class="math">i \\geq 2\\lceil \\log_2(t) \\rceil</span> , then  <span class="math">X_j^i</span>  depends on  <span class="math">X_{j&#x27;}^0</span>  for any j, j'. The same is true in the backwards direction. In other words, GMiMC<sub>mrf</sub> provides full diffusion after  <span class="math">2\\lceil \\log_2(t) \\rceil</span>  rounds.</p>

    <p class="text-gray-300">For the following, we denote by  <span class="math">\\Lambda(t)</span>  the minimum number of rounds to achieve full diffusion, that is  <span class="math">\\Lambda(t) = 2\\lceil \\log_2(t) \\rceil</span> .</p>

    <p class="text-gray-300"><strong>Possible Variants.</strong> Before going on, we refer to Appendix A for possible variants of the GMiMC family of ciphers, e.g. using a round function defined by a different power exponent. As for MiMC (see Section 5 of [4]), it turns out that the power exponent 3 is an optimal choice also for the GMiMC family of ciphers.</p>

      <h4 id="sec-2.1.5" class="text-lg font-semibold mt-6">2.1.5 Key Schedule</h4>

    <p class="text-gray-300">When |k| = n (i.e. the univariate case), then  <span class="math">k_i = k \\ \\forall i</span> . The key schedule for the multivariate case  <span class="math">|k| = t \\times n</span>  is a little more complicated. Let  <span class="math">k = k_0 ||k_1|| \\dots ||k_{t-1}||</span> , and let M be a  <span class="math">t \\times t</span>  matrix with elements in  <span class="math">\\mathbb{F}_{2^n}</span>  or  <span class="math">\\mathbb{F}_p</span>  that satisfies the following condition:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M is invertible, that is there exists  <span class="math">M^{-1}</span> ;</li>
      <li>for each  <span class="math">1 \\le i \\le \\lceil R/t \\rceil</span>  where R is the number of rounds, then</li>
    </ul>

    <p class="text-gray-300"><span class="math">$M^{i}[j,l] \\equiv (\\underbrace{M \\times M \\times .... \\times M}_{i\\text{-th times}})[j,l] \\neq 0</span>$</p>

    <p class="text-gray-300">for all  <span class="math">0 \\le j, l &lt; t</span> , where X[j, l] denotes the coefficient in row j and column l of the matrix X.</p>

    <p class="text-gray-300">For each  <span class="math">1 \\le i \\le \\lceil R/t \\rceil</span>  let</p>

    <p class="text-gray-300"><span class="math">$[k_{i\\cdot t}||k_{i\\cdot t+1}||\\dots||k_{(i+1)\\cdot t-2}||k_{(i+1)\\cdot t-1}|^T = M \\times [k_{(i-1)\\cdot t}||k_{(i-1)\\cdot t+1}||\\dots||k_{i\\cdot t-2}||k_{i\\cdot t-1}|^T.</span>$</p>

    <p class="text-gray-300">The second condition on M guarantees that each subkey depends linearly on all the first t subkeys. This fact has an important consequence. Consider GMiMC<sub>crf</sub> and/or GMiMC<sub>erf</sub> instantiated with a key schedule that uses the subkeys cyclically, i.e.  <span class="math">k_{i,j} = \\hat{k}_{j \\cdot t/2 + i \\pmod{t}}</span> . If the attacker guesses t-1 subkeys, then she can potentially skip both the first and the last t-1 rounds. Instead, in the case in which each subkey depends linearly on all the first t subkeys, this strategy simply does not apply. As a result, the proposed key schedule allows to save a certain number of rounds (approximately t-1) w.r.t. a key schedule that uses the subkeys cyclically. Similar argumentation - but on a smaller scale - holds for  <span class="math">GMiMC_{Nyb}</span>  and  <span class="math">GMiMC_{mrf}</span> .</p>

    <p class="text-gray-300">Remark - Round Constants. As for MiMC, we remark that also the key-schedule of GMiMC consists of a round-constant addition. This is &quot;hidden&quot; in the definition of each round function  <span class="math">F_i(\\cdot)</span> , e.g.  <span class="math">F_i(\\cdot) = (\\cdot \\oplus k \\oplus c_i)^3</span>  for a random round-constant  <span class="math">c_i</span> . We highlight that it is possible to define an equivalent key-schedule where the round-constant addition is already included in the key-schedule, e.g.  <span class="math">\\hat{k}_i := k_i \\oplus c_i</span>  where  <span class="math">k_i</span>  is defined by the previous kev-schedule.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 <strong>Hash Function</strong></h3>

    <p class="text-gray-300">To construct the hash function GMiMCHash, we use one of the structures, e.g. the GMiMC<sub>erf</sub>, with fixed subkeys<sup>2</sup>, e.g.  <span class="math">0^{n \\cdot R}</span> , where R is the number of rounds. Denoting the fixed key permutation as  <span class="math">\\mathrm{GMiMC}_{\\mathsf{erf}}^{\\pi}[\\kappa,t,n]</span> ,  <span class="math">\\mathrm{GMiMCHash}</span>  is constructed by instantiating a sponge construction [17] with  <span class="math">\\mathrm{GMiMC}_{\\mathsf{erf}}^{\\pi}[\\kappa,t,\\log_2 p]</span> . The number of rounds of the permutation GMiMC is chosen according to Table 1 - univariate case  <span class="math">2^{\\kappa} \\simeq 2^n \\simeq p</span> .</p>

    <p class="text-gray-300">When the internal permutation  <span class="math">\\mathcal{P}</span>  of an N-bit sponge function (composed of c-bit capacity and r-bit bitrate -N=c+r) is modeled as a randomly chosen permutation, it has been proven by Bertoni et al. [17] to be indifferentiable from a random oracle up to</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{1}&lt;/sup&gt;</span> If no matrix exists that satisfies the following condition, then one must choose a matrix M for which the total number of zero coefficients for each  <span class="math">M^i</span>  is minimum.</p>

    <p class="text-gray-300"><sup>2</sup>We emphasize that no key schedule is required in this case, since there is no secret-key material.</p>

    <p class="text-gray-300"></p>

    <p class="text-gray-300"><span class="math">2^{c/2}</span>  calls to  <span class="math">\\mathcal{P}</span> . In other words, a sponge with a capacity of c provides  <span class="math">2^{c/2}</span>  collision and  <span class="math">2^{c/2}</span>  (second) preimage resistance. Given a permutation of size N and a desired security level s, we can hash r = N - 2s bits per call to the permutation.</p>

    <p class="text-gray-300">As usual, the message is first padded according to the sponge specification so that the number of message blocks is a multiple of r, where r is the rate in sponge mode. For GMiMCHash-l we use a GMiMC permutation where  <span class="math">N=n\\cdot t=4\\cdot l+1</span>  and  <span class="math">s=2\\cdot l</span> . For GMiMCHash-256 we thus use a GMiMC permutation with  <span class="math">N=n\\cdot t=1024</span>  or 1025. The rate and the capacity are chosen as 512 and 513 respectively. This choice allows for processing the same amount of input bits as SHA-256 (512 bits) while at the same time offering collision security nd preimage security of 256 bits. We highlight that while we could use any of the GMiMC constructions, GMiMC<sub>erf</sub> turns out to be the most efficient choice in several settings as shown in Section 7.2.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Security Analysis</h2>

    <p class="text-gray-300">As for any new design, it is paramount to present a concrete security analysis. In the following, we provide an in-depth analysis of the security of the GMiMC family of block ciphers. In particular, for each proposal we consider the maximum number of rounds that can be attacked by the attacks currently present in the literature.</p>

    <p class="text-gray-300"><strong>Important Remark.</strong> Due to our target applications, here we limit ourselves to provide the number of rounds to guarantee security <strong>only</strong> in the following two scenarios:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>GMiMC instantiated over  <span class="math">\\mathbb{F}_p</span>  such that the size of the prime is 128 bit or more (used for applications like SNARKs and MPC);</li>
      <li>GMiMC instantiated over  <span class="math">\\mathbb{F}_{2^n}</span>  in the low-data scenario (used for application like PQ-Signature Scheme).</li>
    </ul>

    <p class="text-gray-300">We stress that this choice is motivated by the fact that we focus on the scenario that are useful for our applications. Thus, even if GMiMC can be instantiated over  <span class="math">\\mathbb{F}_{2^n}</span> , we do not provide the number of rounds to guarantee security in this scenario.</p>

    <p class="text-gray-300">Before going on, we remark that many (almost all) attacks work in the same way in  <span class="math">\\mathbb{F}_p</span>  and in  <span class="math">\\mathbb{F}_{2^n}</span> . One of the few exception to this fact is the higher-order differential attack. More details on this fact are given in the following.</p>

    <p class="text-gray-300">Security Analysis &ndash; GMiMC instantiated over  <span class="math">\\mathbb{F}_p</span> . Almost all the attacks are independent of the fact whether (a) the size of the key is equal to the branch size  <span class="math">\\kappa=n</span>  (equivalently,  <span class="math">2^{\\kappa} \\simeq p</span>  for the  <span class="math">\\mathbb{F}_p</span>  case) or (b) equal to  <span class="math">\\kappa=N=t\\cdot n</span>  (equivalently,  <span class="math">2^{\\kappa}\\simeq p^t</span>  for the  <span class="math">\\mathbb{F}_p</span>  case). Table 1 and Table 2 summarize the minimum number of rounds required to guarantee the security against several possible attacks respectively in the first and in the second case - we assume t&gt;2 in both cases. The number of rounds of GMiMC is then chosen in order to provide security to all possible attack vectors.</p>

    <p class="text-gray-300">Since the cryptanalysis strategy of the four proposals are very similar, in Sect. 3 the following we give a complete analysis only for  <span class="math">GMiMC_{crf}</span> , while we refer to Appendix C&ndash;D for the analysis of the other proposals. Starting from the results proposed in the following section, in Section 6 we list the minimum number of rounds for each construction, together with some useful observations for the possible applications like MPC, SNARKs and post-quantum signature schemes.</p>

    <p class="text-gray-300"><em>Note:</em> given the number of rounds of a distinguisher that is independent of the secret key, we decided to add 2 rounds - in order to prevent key-guessing attack - for the univariate case. For the multivariate case, we decided to add (t+1) rounds - in order to prevent</p>

    <p class="text-gray-300">Table 1: Minimum number of rounds required to provide security of GMiMC instantiated over  <span class="math">\\mathbb{F}_p</span>  against the corresponding attacks when  <span class="math">2^{\\kappa} \\simeq 2^n \\simeq p</span>  &mdash; no restriction on data complexity - and t &gt; 2. We recall that  <span class="math">\\Lambda(t) := 2\\lceil \\log_2(t) \\rceil</span> . For simplicity,  <span class="math">2 \\cdot \\log_3(2) = 1.262</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathrm{GMiMC}_{crf}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathrm{GMiMC}_{erf}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[1.262 \\cdot \\log_2(p) - 4\\log_3(\\log_2(p))] + 2t</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[1.262 \\cdot \\log_2(p) - 4 \\cdot \\log_3(\\log_2(p))] + 2t - 2</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interpolation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[1.262 \\cdot \\log_2(p)] + 4t - 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + 2t</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Higher Order (in <span class="math">\\mathbb{F}_p</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 + 4t + \\lceil 2\\log_3(t) \\rceil</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 + 2t + \\lceil 2\\log_3(t) \\rceil</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Trunc.) Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 + \\left[ (t^2 + t) \\times \\frac{\\log_2(p)}{2(\\log_2(p) - 1)} \\right]</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 + \\left\\lceil (t^2 + t) \\times \\frac{\\log_2(p)}{2(\\log_2(p) - 1)} \\right\\rceil</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Diff.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3t-1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{1}{2t}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{Nyb}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{mrf}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[1.262 \\cdot \\log_2(p) - 4\\log_3(\\log_2(p))] + t + 2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) - 4 \\cdot \\log_3(\\log_2(p)) \\rceil + \\Lambda(t) + 4</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interpolation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + t + 2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + 2\\Lambda(t) + 4</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Higher Order (in <span class="math">\\mathbb{F}_p</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2+t+\\lceil 2\\log_3(t)\\rceil</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 + 2\\Lambda(t) + \\lceil 2\\log_3(t) \\rceil</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Trunc.) Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3t+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3\\Lambda\\left(t\\right)+2</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Diff.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\Lambda(t)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Minimum number of rounds required to guarantee the security of GMiMC instantiated over  <span class="math">\\mathbb{F}_p</span>  against the corresponding attacks when  <span class="math">2^\\kappa \\simeq 2^N \\simeq p^t</span>  - no restriction on data complexity - and t&gt;2. We recall that  <span class="math">\\Lambda(t) \\coloneqq 2\\lceil \\log_2(t) \\rceil</span> . For simplicity,  <span class="math">2 \\cdot \\log_3(2) = 1.262</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">.03( )</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{crf}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{erf}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Guess + GCD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) - 4 \\log_3(\\log_2(p)) \\rceil + 3t - 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) - 4 \\cdot \\log_3(\\log_2(p)) \\rceil + 3t - 3</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interpolation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + 5t - 4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + 3t - 2</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gr&ouml;bner Basis</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 0.631 \\cdot \\log_2(p) + 2\\log_3(t) \\rceil + 4t - 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 0.631 \\cdot \\log_2(p) + 2\\log_3(t) \\rceil + 4t - 5</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Higher Order (in <span class="math">\\mathbb{F}_p</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + 5t + \\lceil 2\\log_3(t) \\rceil</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + 3t + \\lceil 2\\log_3(t) \\rceil</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(Trunc.) \\ \\ Differential</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + t + \\left[ (t^2 + t) \\times \\frac{\\log_2(p)}{2(\\log_2(p) - 1)} \\right]</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 + t + \\left[ (t^2 + t) \\times \\frac{\\log_2(p)}{2(\\log_2(p) - 1)} \\right]</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Diff.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4t-2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3t-1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&quot;Generic&quot; Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5t-3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4t-2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{Nyb}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{mrf}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Guess + GCD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\left\\lceil 1.262 \\cdot \\log_2(p) - 4\\log_3(\\log_2(p)) \\right\\rceil + t + 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) - 4 \\cdot \\log_3(\\log_2(p)) \\rceil + \\Lambda\\left(t\\right) + 5</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interpolation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + t + 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil 1.262 \\cdot \\log_2(p) \\rceil + 2\\Lambda(t) + 5</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gr&ouml;bner Basis</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[0.631 \\cdot \\log_2(p) + 2\\log_3(t)] + t + 2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\left\\lceil 0.631 \\cdot \\log_2(p) + 2\\log_3(t) \\right\\rceil + \\Lambda\\left(t\\right) + 2</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Higher Order (in <span class="math">\\mathbb{F}_p</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3 + t + \\lceil 2 \\log_3(t) \\rceil</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3 + 2\\Lambda(t) + \\lceil 2\\log_3(t) \\rceil</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Trunc.) Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3t+3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3\\Lambda\\left(t\\right)+3</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Diff.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2t+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\Lambda(t) + 1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&quot;Generic&quot; Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">key-guessing attack - for  <span class="math">GMiMC_{crf}</span>  and  <span class="math">GMiMC_{erf}</span> , and 3 rounds - in order to prevent key-guessing attack - for  <span class="math">GMiMC_{Nyb}</span>  and  <span class="math">GMiMC_{mrf}</span> . This choice is supported by the definition of the key-schedule, in particular by the fact that each subkey depends linearly on all the first t subkeys (we refer to the previous section for details).</p>

    <p class="text-gray-300">Security Analysis &ndash; GMiMCHash instantiated over  <span class="math">\\mathbb{F}_p</span> . For the hash function GMiMCHash case, the number of rounds of the inner permutation is chosen according to the corresponding univariate case (referring to Table 1). This is due to the following considerations. First, as we just recalled in the previous section, when the internal permutation  <span class="math">\\mathcal{P}</span>  of an N=c+r bit sponge function is modeled as a randomly chosen permutation, the sponge hash function is indifferentiable from a random oracle up to  <span class="math">2^{c/2}</span>  calls to  <span class="math">\\mathcal{P}</span> . The numbers of rounds of the univariate case is sufficient to guarantee security against any (secret-/known-/chosen-) distinguisher which is independent of the key. Equivalently, this means that such</p>

    <p class="text-gray-300">number of rounds guarantee that P does not present any non-random/structural property (among the ones known in the literature<a href="#page-10-0">3</a> ). It follows that the previous assumption is satisfied. These and the fact that every key-recovery attack is meaningless in the hash scenario support our choice to consider the univariate case in order to determine the number of rounds of the inner permutation.</p>

    <p class="text-gray-300">Before going on, we remark that the fact that P presents a non-random/structural property does not imply an attack on the hash sponge function instantiated by P. To have a concrete example, consider Keccak (SHA-3). A zero-sum distinguisher can be set up for the <em>full</em> 24-round internal permutation that defines it - see for example <a href="#page-32-7">[26,</a> <a href="#page-34-6">43]</a>. In other words, the internal permutation that defines Keccak presents a non-random property, that is it does not look like a pseudo-random permutation<a href="#page-10-1">4</a> . On the other hands, the best practical collision attack cover (&quot;only&quot;) up to 6 rounds Keccak <a href="#page-35-9">[66]</a>, which is still far from threatening the security of the full 24-round Keccak family.</p>

    <p class="text-gray-300"><strong>Security Analysis &ndash; GMiMC instantiated over</strong> F<strong>2***<sup>n</sup>* **in the low-data scenario.</strong> For some practical applications considered in the following, we also consider the case in which the attacker has a limited access to data (e.g. 1 or 2 (plaintext, ciphertext) pairs). The security analysis for this particular case is proposed in Sect. <a href="#page-19-0">5.</a> As we are going to show, due to the fact that the attacker can have access to few (plaintext, ciphertext) pairs, only few attacks (e.g. the GCD one) apply to this case. We remark that all the attacks that we are going to consider in this scenario work in the same way in F2<em><sup>n</sup></em> and F<em>p</em>. As a result, we mainly re-use the results proposed in the Sect. <a href="#page-10-2">4.</a></p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>4 Security Analysis &ndash; GMiMC instantiated over</strong> F<em><sup>p</sup></em></h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8"><strong>4.1 Algebraic Attacks</strong></h3>

    <p class="text-gray-300">In this section, we consider algebraic attacks against GMiMC. These attacks are particularly relevant to applications which only make a limited number of (plaintext, ciphertext) pairs available to the attacker.</p>

    <p class="text-gray-300">A key datum for all these attacks is the degree reached in each of our constructions after <em>r</em> rounds. Here we propose an analysis for the case of GMiMCcrf (similar for all other constructions).</p>

    <p class="text-gray-300"><strong>Grow of the Degree of GMiMCcrf.</strong> Consider the <em>t</em>-branch, univariate case for GMiMCcrf and denote the branches by (<em>Xt</em>&minus;1<em>, . . . , X</em>2<em>, X</em>1<em>, X</em>0). Given a known plaintext, the degree <em>d<sup>i</sup></em> of the key in the branch <em>X<sup>i</sup></em> for <em>i</em> = 0<em>, . . . , t</em> &minus; 1 after <em>r</em> rounds is</p>

    <p class="text-gray-300"><span class="math">$d_i = \\begin{cases} 3^{r-i} &amp; \\text{if } r &gt; i, \\\\ 0 &amp; \\text{otherwise.} \\end{cases}</span>$
(2)</p>

    <p class="text-gray-300">Note that <em>dt</em>&minus;<sup>1</sup> = min<em><sup>i</sup> d<sup>i</sup></em> .</p>

    <p class="text-gray-300">Considering the <em>t</em>-branch multivariate case, the degrees of the <em>t</em> keys growth differently in the <em>t</em> multivariate polynomials corresponding to the <em>t</em> branches of the Feistel network. In round <em>r</em>, the polynomial of the leftmost branch has the least degrees, which are given by</p>

    <p class="text-gray-300">
<span class="math">$d_{i,j} = \\begin{cases} 3^{r-(i-1)-j} &amp; \\text{if } r &gt; i+j-1, \\\\ 0 &amp; \\text{otherwise.} \\end{cases}</span>$
(3)</p>

    <p class="text-gray-300"><sup>3</sup>That is, we do not exclude that a non-random property can be discovered in the future.</p>

    <p class="text-gray-300"><sup>4</sup>We also refer to <a href="#page-32-8">[16]</a> for a detailed discussion about this topic.</p>

    <p class="text-gray-300">where <em>j</em> = <em>t</em> &minus; 1 denotes the leftmost branch and the degree of variable <em>k<sup>i</sup></em> in branch <em>j</em> is <em>di,j</em> . For all (algebraic) attacks in the following, we only care of the minimum degree:</p>

    <p class="text-gray-300"><span class="math">$d_{t-1,t-1} = \\min_{i} \\min_{j} d_{i,j} = 3^{r-2t+2},</span>$</p>

    <p class="text-gray-300">where 0 &le; <em>i</em> &le; <em>t</em> &minus; 1 and 0 &le; <em>j &lt; t</em>.</p>

    <p class="text-gray-300">Finally, the degree of each word of the plaintext in the <em>t</em>-branch is given by formula <a href="#page-10-3">(3)</a> both for the univariate and multivariate cases.</p>

      <h4 id="sec-4.1.1" class="text-lg font-semibold mt-6"><strong>4.1.1 Greatest Common Divisors</strong></h4>

    <p class="text-gray-300">As for the original MiMC <a href="#page-31-3">[4]</a>, an attack strategy is to compute Greatest Common Divisors (GCD). In particular, given more than one known (plaintext, ciphertext) pair or working on the output of different branches of a single known (plaintext, ciphertext) pair (as described in the following), one can construct their polynomial representations and compute their polynomial GCD to recover a multiple of the key<a href="#page-11-0">5</a> . Note that this is a known-plaintext attack, and not a chosen-plaintext one.</p>

    <p class="text-gray-300"><em>Since interpolation attack is more efficient than GCD attack (from the attacker point of view)</em>, we refer to Section <a href="#page-20-0">5.1</a> and Appendix <a href="#page-41-0">C.4</a> for all details about GCD attack. For each GMiMC family of block ciphers, we refer to Table <a href="#page-9-0">1</a> for the minimum number of rounds that ensure security against the GCD attack.</p>

    <p class="text-gray-300">Before going on, we remark that this is one of the few attacks that applies in the low-data scenario, considered in one of the following applications (i.e. post-quantum signatures). More details on this fact are given in the following.</p>

      <h4 id="sec-4.1.2" class="text-lg font-semibold mt-6"><strong>4.1.2 Gr&ouml;bner Bases</strong></h4>

    <p class="text-gray-300">The natural generalization of GCDs to the multivariate case is the notion of a Gr&ouml;bner basis <a href="#page-33-10">[34]</a>. The attack proceeds like the GCD attack with the final GCD computation replaced by a Gr&ouml;bner basis computation. Due to the Feistel structure, we highlight that it is possible to construct multivariate &quot;meet-in-the-middle&quot; polynomials &ndash; we denote their degree as <em>d<sup>i</sup></em> in this subsection and define <em>d</em> = min<em><sup>i</sup> d<sup>i</sup></em> .</p>

    <p class="text-gray-300"><strong>Complexity</strong> For generic systems, the complexity of computing a Gr&ouml;bner basis for a system of N polynomials in V variables is</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\begin{pmatrix} \\mathfrak{V} + D_{reg} \\\\ D_{reg} \\end{pmatrix}^{\\omega}\\right) \\tag{4}</span>$</p>

    <p class="text-gray-300">operations over the base field F <a href="#page-32-9">[19]</a>, where <em>Dreg</em> is the <em>degree of regularity</em> and 2 &le; <em>&omega; &lt;</em> 3 is the linear algebra constant. We note that the memory requirement of these algorithms is of the same order as running time. The degree of regularity depends on the degrees of the polynomials <em>d</em> and the number of polynomials N. When V = N, we have a simple closed form <a href="#page-31-8">[12]</a></p>

    <p class="text-gray-300"><span class="math">$D_{reg} = 1 + \\sum_{i=0}^{\\mathfrak{N}-1} (d_i - 1),</span>$</p>

    <p class="text-gray-300">where <em>d<sup>i</sup></em> is the degree of the <em>i</em>-th polynomial <em>f<sup>i</sup></em> in the polynomial system we are trying to solve. In the over-determined case, i.e., V <em>&lt;</em> N, the degree of regularity can be estimated by developing the Hilbert series of an ideal generated by generic polynomials h<em>f</em>0<em>, . . . , f</em>N&minus;1i</p>

    <p class="text-gray-300">Improving the computational complexity of this attack using more pairs is an open problem. However, since the cost is dominated by the size of the polynomials involved, it is not clear that significant improvements are possible.</p>

    <p class="text-gray-300">of degrees  <span class="math">d_i</span> . We stress that this analysis presumes that the polynomials considered here behave like generic systems, which is in accordance with our practical experiments. Closed form formulas for  <span class="math">D_{reg}</span>  are known for some special cases, but not in general.</p>

    <p class="text-gray-300">In particular, each plaintext/ciphertext pair &ndash; denoted by  <span class="math">p, c \\in (\\mathbb{F}_{2^n})^t</span>  where  <span class="math">p \\equiv (p_0, ..., p_{t-1})</span>  and  <span class="math">c \\equiv (c_0, ..., c_{t-1})</span>  &ndash; gives a system of t equations</p>

    <p class="text-gray-300"><span class="math">$\\forall i = 0, ..., t - 1:</span>$
<span class="math">c_i = f_i(p_0, ..., p_{t-1}, k_0, ..., k_{t-1})</span></p>

    <p class="text-gray-300">in t variables  <span class="math">k_0, ..., k_{t-1}</span>  (note that the key-schedule is linear), where  <span class="math">f_i</span>  are functions of degree d. The introduction of new intermediate variables to reduce the degree of the involved polynomials does not lead to a reduced solving time as this increases the number of variables.</p>

    <p class="text-gray-300">On the other hand, depending on parameter choices, the hybrid approach [18, 19] which combines exhaustive search with Gr&ouml;bner basis computations may lead to a somewhat reduced cost. Following [18, 19], guessing  <span class="math">\\varphi \\leq t</span>  components of the key leads to a complexity of  <span class="math">\\mathcal{O}\\left(p^{\\varphi} \\cdot \\binom{\\mathfrak{I}-\\varphi+D&#x27;_{reg}}{D&#x27;_{reg}}\\right)^{\\omega}</span> , where  <span class="math">D&#x27;_{reg} \\leq D_{reg}</span>  is the degree of regularity for the system of equation after substituting  <span class="math">\\varphi</span>  variables with their guesses. Noting, though, that guessing a variable in a monomial reduces its degree and that guesses only affect a subset of rows in the Macaulay matrix, we will more conservatively assume an overall cost of</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(p^{\\varphi} \\cdot \\begin{pmatrix} \\mathfrak{V} - \\varphi + D&#x27;_{reg} - 1 \\\\ D&#x27;_{reg} - 1 \\end{pmatrix}^{\\omega}\\right). \\tag{5}</span>$</p>

    <p class="text-gray-300">Many known pairs Each new (plaintext, ciphertext) pair provides a new polynomial while keeping the number of unknowns  <span class="math">\\mathfrak{V}=t</span>  constant. Thus, given that there are  <span class="math">\\binom{t+d}{d}</span>  monomials of degree less than or equal to d in t unknowns, we may simply collect  <span class="math">\\binom{t+d}{d}</span>  polynomials from the same number of known (plaintext, ciphertext) pairs. In this over-determined case (that is, number of equations  <span class="math">n_e</span>  bigger than number of variables  <span class="math">n_v</span> ), there is no closed formula to compute  <span class="math">D_{reg}</span> . By definition, the degree of regularity is defined as the index of the first non-positive coefficient in</p>

    <p class="text-gray-300"><span class="math">$H(z) = \\frac{\\prod_{i=1}^{n_e} (1 - z^{d_i})}{(1 - z)^{n_v}} = \\frac{(1 - z^{3^r})^{n_e}}{(1 - z)^{n_v}} = (1 - z^{3^r})^{n_e - n_v} \\cdot (1 + z + z^2)^{n_v},</span>$</p>

    <p class="text-gray-300">where  <span class="math">n_e</span>  is the number of equations,  <span class="math">n_v</span>  is the number of variables, and  <span class="math">d_i = 3^r</span>  is the degree of the <em>i</em>-th equation. By simple observation, the index of the first non-positive coefficient can not be smaller than  <span class="math">d = 3^r</span> , since  <span class="math">(1 + z + z^2)^{n_v}</span>  contains only positive terms. Thus, the overall complexity becomes  <span class="math">\\mathcal{O}(\\binom{t+d}{d})^{\\omega}</span>  with the hidden constant  <span class="math">\\geq 1</span> . Following the method above, we expect  <span class="math">D&#x27;_{reg} = D_{reg} - 1 = d - 1</span>  for the hybrid approach. Plugging the (MiMT) degrees from the previous sections into d then produces the expected overall solving time.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>crf</sub> (Case:  <span class="math">2^{\\kappa} \\simeq p^t</span> ). To prevent the Gr&ouml;bner basis attack, the minimum number of rounds r must satisfy  <span class="math">p^{\\varphi} \\cdot \\binom{t-\\varphi+d-1}{d-1}^{\\omega} \\geq p^t</span> , for all  <span class="math">\\varphi \\in \\{0,\\ldots,t-2\\}</span>  and where the degree d is a function of the number of rounds r, that is, d=d(r). For our parameter choices, this expression is minimized for  <span class="math">\\varphi=0</span> . We thus require</p>

    <p class="text-gray-300"><span class="math">$\\binom{t+d}{d}^{\\omega} = \\binom{t+3^{r-2t+2}}{3^{r-2t+2}}^{\\omega} \\approx p^t.</span>$</p>

    <p class="text-gray-300">Since</p>

    <p class="text-gray-300"><span class="math">$\\binom{t+d}{d} = \\frac{(d+t)!}{d! \\cdot t!} \\ge \\frac{\\prod_{i=1}^{t} (d+i)}{t^t} \\ge (d/t)^t,</span>$</p>

    <p class="text-gray-300">where  <span class="math">n! \\le n^n</span>  for each  <span class="math">n \\ge 1</span> , and, setting  <span class="math">\\omega = 2</span> , we obtain  <span class="math">2t \\log_2(d/t) = 2t \\log_2(3^{r-2t+2}/t) \\approx \\log_2(p) t</span>  or</p>

    <p class="text-gray-300"><span class="math">$r = 2t + \\lceil 1/2 \\log_2(p) \\cdot \\log_3 2 - 2 + \\log_3 t \\rceil</span>$</p>

    <p class="text-gray-300">. To thwart Meet-in-the-Middle attacks, this value is doubled.</p>

    <p class="text-gray-300">To conclude, we emphasize that we use  <span class="math">d(r) = 3^{r-2t+2}</span>  in order to compute the previous number of rounds. Since  <span class="math">3^{r-2t+2}</span>  is the minimum of the degrees of the variables, it is plausible that a lower number of rounds is sufficient to protect against Gr&ouml;bner basis attacks. Also, we reiterate that these attacks require roughly the same amount of memory as elementary operations. The same consideration holds for the other ciphers of the GMiMC family.</p>

      <h4 id="sec-4.1.3" class="text-lg font-semibold mt-6">4.1.3 Interpolation Attack</h4>

    <p class="text-gray-300">As for the original MiMC, one of the most powerful attacks against the GMiMC family is the interpolation attack, introduced by Jakobsen and Knudsen [49] in 1997. The strategy of the attack is to construct a polynomial corresponding to the encryption function without knowledge of the secret key. If an adversary can construct such a polynomial then for any given plaintext the corresponding ciphertext can be produced without knowledge of the secret key.</p>

    <p class="text-gray-300">Let  <span class="math">E_k: \\mathbb{F}_q \\to \\mathbb{F}_q</span>  be an encryption function. For a randomly fixed key k, the polynomial P(x) representing  <span class="math">E_k(x)</span>  &ndash; where x is the indeterminate corresponding to the plaintext &ndash; can be constructed using the  <span class="math">Vandermonde\\ matrix^6</span>  - cost approximately of  <span class="math">\\mathcal{O}(m^2)</span>  - or the Lagrange's theorem<sup>7</sup> - cost approximately of  <span class="math">\\mathcal{O}(m \\cdot \\log m)</span> , where m is the number of monomials.</p>

    <p class="text-gray-300">This method can be extended to a key-recovery attack. The attack proceeds by simply guessing the key of the final round, decrypting the ciphertexts and constructing the polynomial for r-1 rounds. With one extra (plaintext, ciphertext) pair, the attacker checks whether the polynomial is correct.</p>

    <p class="text-gray-300">Each output branch of a (balanced or unbalanced) Feistel network can be represented as a multivariate polynomial where the variables are the inputs to each branch. If the maximum degree of a single variate monomial in one of these output polynomials is low, then an attacker can exploit this property to mount an attack on the block cipher.</p>

    <p class="text-gray-300">Using this idea, we first briefly describe at high level generic attack(s) on the GMiMC block ciphers, focusing on a t-branch Feistel network. Let us denote the t input branches as  <span class="math">x_{t-1},...,x_1</span>  and  <span class="math">x_0</span>  from left to right. Suppose the polynomials over the field representing the output branches are denoted by  <span class="math">P_i \\in \\mathbb{F}_{2^n}[X]</span>  (i=0,1,...,t-1) and  <span class="math">d_i</span>  denotes the degree of the polynomial  <span class="math">P_i</span> . Working as in [49], the number of monomials of such polynomial is well approximated by  <span class="math">\\prod_{i=0}^{t-1} (d_i+1)</span> . It follows that if the condition</p>

    <p class="text-gray-300"><span class="math">$\\prod_{i=0}^{t-1} (d_i + 1) \\approx 2^N \\simeq p^t</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>The interpolation polynomial  <span class="math">P(x) = a_t x^t + a_{t-1} x^{t-1} + ... + a_1 x + a_0</span>  interpolates the data points  <span class="math">(x_i, y_i)</span>  in the sense that  <span class="math">P(x_i) = y_i</span>  for all  <span class="math">i \\in \\{0, 1, ..., t\\}</span> , where  <span class="math">E_k(x_i) = y_i</span>  for each i. By substituting the first equation in here, one gets a system of linear equations in the coefficients  <span class="math">a_j</span> . By solving this system for  <span class="math">a_j</span> , one can construct the interpolant polynomial P(x). If one re-writes this system in a matrix-vector form, the matrix defined by the terms  <span class="math">\\{x_i^j\\}_{0 \\le i,j \\le t}</span>  is commonly referred to as a Vandermonde matrix, and the cost to invert a  <span class="math">(t+1) \\times (t+1)</span>  Vandermonde matrix (i.e. to construct the interpolation polynomial) is  <span class="math">\\mathcal{O}(t^2)</span> .</p>

    <p class="text-gray-300"><sup>7</sup> If the polynomial has degree d, we can find it using Lagrange's formula  <span class="math">P(x) = \\sum_{i=0}^{d} y_i \\cdot \\prod_{0 \\le j \\le d, i \\ne j} \\frac{x - x_j}{x_i - x_j}</span> , where  <span class="math">E_k(x_i) = y_i</span>  for  <span class="math">i = 0, 1, \\ldots d</span> .</p>

    <p class="text-gray-300">is fulfilled, then the attacker requires the full code-book in order to construct the interpolation polynomial<a href="#page-14-0">8</a> . As a result, such polynomial can not be used for a key-recovery attack or for a forgery attack.</p>

    <p class="text-gray-300"><strong>GMiMCcrf.</strong> As we have just seen in <a href="#page-10-3">(3)</a>, the minimum degree of the output polynomials for each branch (after <em>r</em> rounds) is lower bounded by 3 <em><sup>r</sup></em>&minus;2<em>t</em>+2. Due to the previous discussion, GMiMCcrf is secure against interpolation attack if (3<em><sup>r</sup></em>&minus;2<em>t</em>+2) <em><sup>t</sup></em> &asymp; 2 <em>N</em> ' <em>p t</em> . Hence,</p>

    <p class="text-gray-300"><span class="math">$r \\geq \\frac{\\log_2(p)}{\\log_2 3} + (2t-2)</span>$</p>

    <p class="text-gray-300">rounds will be secure against the above-mentioned attacks. Conservatively, 2<em>r</em> + 2 rounds will be secure against meet-in-the-middle attacks/distinguishers for the case 2 <em>&kappa;</em> ' <em>p</em>, while 2<em>r</em> + <em>t</em> + 1 rounds will be secure against meet-in-the-middle attacks/distinguishers for the case 2 <em>&kappa;</em> ' <em>p t</em> .</p>

    <p class="text-gray-300"><strong>Remark - Interpolation and Forgery Attack.</strong> One may ask if a similar attack is meaningful in the case of a permutation or/and in the case in which there is no secret material (e.g. known-/chosen-key distinguisher).</p>

    <p class="text-gray-300">Here P denotes a permutation or a cipher with a fixed known/chosen key. Assume it is possible to construct the interpolation polynomial <em>without</em> using the full code-book. In this case, such a polynomial can be exploited to set up a <em>forgery attack</em> on the permutation P, which is instead not possible for a (pseudo-)random permutation.</p>

    <p class="text-gray-300">This fact can have a <em>potential</em> consequence/effect in the case in which such permutation P is used to set up an hash function based on the sponge construction. As proved in <a href="#page-32-6">[17]</a>, when the internal permutation P of an <em>N</em> = <em>c</em> + <em>r</em> bit sponge function is modeled as a randomly chosen permutation, the sponge hash function is indifferentiable from a random oracle up to 2 <em>c/</em>2 calls to P. If the previous forgery (interpolation) attack can be used to distinguish P from a randomly chosen permutation (that is, to highlight a non-random property of P), then the result proposed in <a href="#page-32-6">[17]</a> does not apply to such a sponge function instantiated by P.</p>

    <p class="text-gray-300">In conclusion, in order to avoid such a distinguisher, it is sufficient that the number of rounds of the inner permutation GMiMC - instantiated with a fixed key - of the sponge construction is equal to the number of rounds necessary to prevent the interpolation attack discussed in this section (equivalently, the number of rounds necessary to ensure that the internal permutation has maximum degree).</p>

      <h4 id="sec-4.1.4" class="text-lg font-semibold mt-6"><strong>4.1.4 Higher-Order Differential</strong></h4>

    <p class="text-gray-300">Let L A be an affine space. Higher-order differential attacks <a href="#page-34-7">[53]</a> exploit the fact that <em><sup>x</sup></em>&isin;A <em>P</em>(<em>x</em>) = 0 if the dimension of A is higher than the degree of <em>P</em>(&middot;). In other words, a higher-order differential attack can be mounted by choosing an affine space &mdash; like A of dimension <em>d</em> + 1 (or, equivalently, of size 2 <em><sup>d</sup></em>+1) if <em>P</em> has degree at most <em>d</em>. To thwart higher-order differential attacks, the number of rounds must be chosen in order to ensure that the algebraic degree of the GMiMC family of block ciphers is bigger than the biggest subspace in F.</p>

    <p class="text-gray-300"><strong>Higher-Order Differential in</strong> F<em><sup>p</sup></em> <strong>versus Higher-Order Differential in</strong> F<strong>2***<sup>N</sup>* **.</strong> Due to the strategy exploited by the higher-order differential attack, there is a crucial difference between the cases F2<em><sup>N</sup></em> and F<em>p</em>.</p>

    <p class="text-gray-300"><sup>8</sup>Due to the cost to construct the interpolation polynomial (approximately O (<em>m</em> log <em>m</em>) where <em>m</em> is the number of monomials), we emphasize that the cost of such attack is higher than the cost of a brute-force attack if condition <a href="#page-13-2">(4.1.3)</a> is satisfied)</p>

    <p class="text-gray-300">As we have just seen, given a function  <span class="math">f(\\cdot)</span>  of degree d, the sum over the outputs of the function applied to all elements of a vector space  <span class="math">\\mathcal{V}</span>  of dimension  <span class="math">\\geq d+1</span>  is zero. The crucial point here is that the previous result holds if  <span class="math">\\mathcal{V}</span>  is a (sub)space, and not only a generic set of elements. While  <span class="math">\\mathbb{F}_{2^m}</span>  is always a subspace of  <span class="math">\\mathbb{F}_{2^n}</span>  for each  <span class="math">m \\leq n</span> , the only subspaces of  <span class="math">\\mathbb{F}_p</span>  are  <span class="math">\\{0\\}</span>  and  <span class="math">\\mathbb{F}_p</span> . It follows that the biggest subspace of  <span class="math">(\\mathbb{F}_p)^t</span>  has dimension t, with respect to the biggest subspace of  <span class="math">(\\mathbb{F}_{2^n})^t</span> , which has dimension  <span class="math">n \\cdot t = N</span> .</p>

    <p class="text-gray-300">This fact has an important impact on the higher-order differential attack: if a cipher is instantiated over  <span class="math">\\mathbb{F}_p</span> , then a lower degree (and hence a smaller number of rounds) is sufficient to protect it from the higher-order differential attack with respect to the number of rounds required for the  <span class="math">\\mathbb{F}_{2^N}</span>  case. In particular, it is sufficient that both the encryption and the decryption functions have degree at most t, w.r.t. degree N for the  <span class="math">\\mathbb{F}_p</span>  case.</p>

    <p class="text-gray-300"><strong>Higher-Order Differential on GMiMC instantiated over</strong>  <span class="math">\\mathbb{F}_p</span> . Due to the analysis proposed in 4.1.3, the minimum degree of GMiMC<sub>crf</sub> after r &gt; 2t-1 rounds is (at least)  <span class="math">3^{r-2t}</span> . The condition  <span class="math">3^{r-2t} \\ge t</span>  is satisfied by  <span class="math">r \\ge 2t + \\log_3(t)</span> . Finally, we add 2 rounds to avoid key-guessing attack for the univariate case and t+1 rounds for the multivariate case.</p>

    <p class="text-gray-300">We refer to App. C.2 for all details about the other constructions.</p>

    <p class="text-gray-300"><strong>Higher-Order Differential on GMiMC instantiated over</strong>  <span class="math">\\mathbb{F}_{2^n}</span>  <strong>&ndash; Some Remarks.</strong> Since we do not require GMiMC instantiated over  <span class="math">\\mathbb{F}_{2^n}</span>  for our target applications, we stress that we do not provide any claim about the minimum number of rounds necessary to protect GMiMC w.r.t. an higher-order differential over  <span class="math">\\mathbb{F}_{2^n}</span> . For completeness, here we briefly discuss this case.</p>

    <p class="text-gray-300">In order to choose the number of rounds, one has to estimate the growth of the degree. First of all, since the degree of the round function in its algebraic representation in  <span class="math">\\mathbb{F}_{2^n}</span>  is only 2, the algebraic degree of one round is 2 as well. Clearly, the algebraic degree of the cipher after r rounds is bounded from above by  <span class="math">2^r</span> . However, a better and more realistic upper bound can be evaluated by using the division property [76], introduced by Todo at Eurocrypt 2015. As a main result, it turns out that the degree of the function &ndash; when it is iterated &ndash; grows in a much smoother way than expected when it approaches the number of variables. For instance, the degree of the composition of two functions  <span class="math">G \\circ F(\\cdot)</span>  can always be upper-bounded by  <span class="math">\\deg(G \\circ F) \\leq \\deg(G) \\cdot \\deg(F)</span> . This trivial bound, however, is often very little representative of the true degree of the permutation, in particular if we are trying to estimate the degree after a high number of rounds. An analogous result for SPN ciphers was previously found by e.g. Boura et al. [26].</p>

    <p class="text-gray-300">While the (just cited) results proposed by Boura et al.work for SPN ciphers, no equivalent results is given in the literature for Feistel constructions. Moreover, division property is a useful tool to study the growth of the degree when one considers a single cipher instantiated by fixed parameters n and t (or a &quot;small&quot; number of them), but it does not provide a generic formula that can work for any possible choice of parameters n and t. However, due to the scope of this work, the choice of the parameters depends on the performance of the practical applications, and it cannot be done in advance. In conclusion, a future open problem would be to determine a tight bound for the growth of the degree for a generic Feistel construction, as the one provided in [26].</p>

    <p class="text-gray-300"><strong>Zero-Sum Partitions and Sponge GMiMCHash.</strong> Here we briefly discuss how to apply the previous analysis in the case of a sponge construction instantiated by one of the GMiMC structures, e.g. the GMiMC<sub>erf</sub>, with a fixed key, e.g.  <span class="math">0^{\\kappa}</span> . Since the key is fixed,</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>Note that the attacker works at word level (i.e. with element of  <span class="math">\\mathbb{F}_p</span> ) in the case of an higher order differential attack instantiated over  <span class="math">\\mathbb{F}_p</span> . Instead, for the case  <span class="math">\\mathbb{F}_{2^n}</span> , the attacker can work both at word level (i.e. with element of  <span class="math">\\mathbb{F}_{2^n}</span> ) or at bit level (i.e. with element of  <span class="math">\\mathbb{F}_2</span> ).</p>

    <p class="text-gray-300">the previous key-recovery attacks are meaningless. On the other hand, previous analysis about the degree of GMiMC can be applied also in this scenario.</p>

    <p class="text-gray-300">As showed in [17] and recalled in Section 2.2, when the internal permutation  <span class="math">\\mathcal{P}</span>  of a sponge function is modeled as a randomly chosen permutation, then the sponge construction is indifferentiable from a random oracle up to  <span class="math">2^{c/2}</span>  calls to  <span class="math">\\mathcal{P}</span> . To apply such result, we require that GMiMC does not present any non-random/structural property.</p>

    <p class="text-gray-300">A possible distinguisher that can be set up in order to distinguish the permutation  <span class="math">GMiMC^{\\pi}</span>  from a (pseudo-)random one is the one based on the <em>zero-sum partition</em>.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (Zero-sum Partition [25]). Let P be a permutation from  <span class="math">\\mathbb{F}_{2^n}</span>  to  <span class="math">\\mathbb{F}_{2^n}</span> . A zero-sum partition for P of size  <span class="math">K = 2^k \\nleq 2^n</span>  is a collection of  <span class="math">2^k</span>  disjoint sets  <span class="math">\\{X_1, X_2, ..., X_k\\}</span>  sets with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">X_i = \\{x_1^i, ..., x_{2n-k}^i\\} \\subset \\mathbb{F}_{2n}</span>  for each i = 1, ..., k and  <span class="math">\\bigcup_{i=1}^{2^{n-k}} X_i = \\mathbb{F}_{2n}</span> ;</li>
      <li>for each  <span class="math">i = 1, ..., 2^k</span> , the set  <span class="math">X_i</span>  satisfies zero-sum [11]</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\bigoplus_{j=1}^{2^k} x_j^i = \\bigoplus_{j=1}^{2^k} P(x_j^i) = 0.</span>$</p>

    <p class="text-gray-300">A similar definition works also in the case of  <span class="math">(\\mathbb{F}_p)^t</span> . Remember that if f is a k-degree function on  <span class="math">\\mathbb{F}_{2^n}</span> , then  <span class="math">\\bigoplus_{v \\in V \\oplus a} f(v) = 0</span>  for any (k+1)-dimension subspace  <span class="math">V \\subseteq \\mathbb{F}_{2^n}</span> , where  <span class="math">V \\oplus a</span>  is an arbitrary coset of a space V.</p>

    <p class="text-gray-300">To avoid this distinguisher, it is sufficient that to double the number of rounds of the permutation  <span class="math">GMiMC^{\\pi}</span>  - that is, GMiMC instantiated with a fixed key - given before necessary to prevent the higher-order differential attack discussed in the previous section. If this is not the case, a zero-sum partition on  <span class="math">GMiMC^{\\pi}</span>  can be mounted.</p>

    <p class="text-gray-300">For completeness, we recall that, while it is known how to construct a zero-sum<sup>10</sup> for a random permutation (see [11, 16] for details), there is no way &ndash; to the best of our knowledge &ndash; to construct a zero-sum partition for a random permutation without using a brute-force approach. In conclusion, in the case in which GMiMC is instantiated with a lower number of rounds than the one determined by the higher-order differential attack, the permutation GMiMC  <span class="math">^{\\pi}</span>  does not look like a pseudo-random one.</p>

    <p class="text-gray-300">Finally, we remark that a similar approach based on zero-sum partitions is largely used in the literature to set up attack or to investigate the security of (the inner permutation of) sponge hash functions (see e.g. Keccak [11, 25, 44], PHOTON [78], ...).</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Statistical Attacks</h3>

    <p class="text-gray-300">Here we consider statistical attacks against GMiMC. Unlike the algebraic analysis above, statistical attacks do not explicitly consider the number of variables involved in the output polynomials representing the (reduced-round) cipher.</p>

    <p class="text-gray-300">Moreover, all statistical attacks that we are going to analyze work in the same way both for the case in which GMiMC is instantiated over  <span class="math">\\mathbb{F}_p</span>  or/and over  <span class="math">\\mathbb{F}_{2^n}</span> . For this reason, in the following we do <em>not</em> study separately the two scenario.</p>

      <h4 id="sec-4.2.1" class="text-lg font-semibold mt-6">4.2.1 Classical and Truncated Differential Cryptanalysis</h4>

    <p class="text-gray-300">Differential cryptanalysis and its variations are the most widely used techniques to analyze symmetric-key primitives. The differential probability of any function over the finite field  <span class="math">\\mathbb{F}_{2^n}</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\alpha \\to \\beta] := |\\{x : f(x) + f(x + \\alpha) = \\beta\\}|/2^{n}.</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;10</sup>We remark that for a zero-sum, it is sufficient to find a <em>single</em> set  <span class="math">Z \\equiv \\{z_i\\}_i</span>  s.t.  <span class="math">\\bigoplus_i z_i = \\bigoplus_i P(z_i) = 0</span> .</p>

    <p class="text-gray-300">It is well known that the function  <span class="math">f(x) = x^3</span>  is Almost Perfect Non-linear (APN) [61] and, thus, has optimal differential probability over a prime field or  <span class="math">\\mathbb{F}_{2^n}</span> . For this function the probability is bounded above by  <span class="math">2/2^n</span>  or  <span class="math">2/|\\mathbb{F}_p|</span> . In the following, we provide the minimum number of rounds to guarantee security against this attack focusing on GMiMC<sub>crf</sub> (the analysis for the other cases is similar and it is given in App. D). A variant of classical differential cryptanalysis is the truncated differential one [53], in which the attacker can predict only part of the difference between pairs of texts.</p>

    <p class="text-gray-300">As largely done in the literature, we assume that the cipher is secure against differential attack if any (truncated) differential characteristic has probability lower than  <span class="math">2^{-N}</span> .</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>crf</sub>. In order to find the minimum number of rounds to protect the cipher against differential attack, we look for the best possible (truncated) differential characteristic. Consider an input difference<sup>11</sup> of the form  <span class="math">(0, \\ldots, 0, \\Delta_I, \\Delta_I)</span>  where  <span class="math">\\Delta_I \\neq 0</span> . It is straightforward to observe that such input difference does not active any S-Box in the first  <span class="math">r_0 = t - 2</span>  rounds (since the input difference is always zero), that is the output difference after  <span class="math">r_0</span>  rounds is  <span class="math">(\\Delta_I, \\Delta_I, 0, \\ldots, 0)</span> . After  <span class="math">r_1 = t - 1</span>  round, we get an output difference of the form  <span class="math">(\\Delta_I, 0, \\ldots, 0, \\Delta_I \\oplus f^{r_1}(\\Delta_I))</span> , where  <span class="math">f^{r_1}(\\cdot)</span>  denotes the  <span class="math">r_1</span> -th round function. Observe that  <span class="math">\\Delta_I \\oplus f^{r_1}(\\Delta_I) = 0</span>  with prob.  <span class="math">2^{-n+1}</span> . Indeed, since an active (cubic) S-Box maps its non-zero input difference to  <span class="math">2^{n-1}</span>  possible output differences each one with prob.  <span class="math">2^{-n+1}</span> , it follows that  <span class="math">f^{r_1}(\\Delta_I) = \\Delta_I</span>  with probability  <span class="math">2^{-n+1}</span> . Assume  <span class="math">f^{r_1}(\\Delta_I) = \\Delta_I</span> . After  <span class="math">r_2 = t</span>  rounds, we get an output difference of the form  <span class="math">(0, \\ldots, 0, \\Delta_I)</span> , while after  <span class="math">r_3 = t + 1</span>  rounds, we get an output difference of the form  <span class="math">(0, \\ldots, 0, \\Delta_I, f^{r_3}(\\Delta_I))</span> . Due to the previous consideration,  <span class="math">f^{r_3}(\\Delta_I) = \\Delta_I</span>  with prob.  <span class="math">2^{-n+1}</span> .</p>

    <p class="text-gray-300">As a result, the following (truncated) characteristic over t+1 rounds</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, \\Delta_I, \\Delta_I) \\xrightarrow[\\text{prob. } 1]{R^{t-2}(\\cdot)} (\\Delta_I, \\Delta_I, 0, \\dots, 0) \\xrightarrow[\\text{prob. } \\leq 2^{-n+1}]{R(\\cdot)} (\\Delta_I, 0, \\dots, 0) \\xrightarrow[\\text{prob. } 1]{R(\\cdot)} (0, \\dots, 0, \\Delta_I) \\xrightarrow[\\text{prob. } \\leq 2^{-n+1}]{R(\\cdot)} (0, \\dots, 0, \\Delta_I, \\Delta_I)</span>$</p>

    <p class="text-gray-300">has an overall probability equal to  <span class="math">2^{-2n+2}</span> . Before going on, note that any other input difference active at least one S-Box in the first t-2 rounds. In other words, it seems not possible to find a longer (truncated) characteristic with lower probability.</p>

    <p class="text-gray-300">By iterating this (truncated) characteristic, it is possible to construct a (truncated) differential characteristic over  <span class="math">s\\cdot (t+1)</span>  with probability at most  <span class="math">(2^{-2n+2})^s</span> . By simple computation,  <span class="math">(2^{-2n+2})^s \\leq 2^{-N}</span>  if and only if  <span class="math">(2n-2)\\cdot s \\geq N</span> , that is  <span class="math">s \\geq \\lceil \\frac{N}{2n-2} \\rceil</span> . As a result,  <span class="math">2+t\\cdot (t+1)\\cdot \\lceil \\frac{n}{2(n-1)} \\rceil</span>  rounds are sufficient to provide security in the univariate case, while  <span class="math">1+t+t\\cdot (t+1)\\cdot \\lceil \\frac{n}{2(n-1)} \\rceil</span>  rounds are sufficient to provide security in the multivariate case.</p>

      <h4 id="sec-4.2.2" class="text-lg font-semibold mt-6">4.2.2 Impossible Differential Cryptanalysis</h4>

    <p class="text-gray-300">Impossible differential cryptanalysis was introduced by Biham et al. [21] and Knudsen [54]. This cryptanalytic technique exploits differentials occurring with probability 0. It has been very successful against FNs and led to the best cryptanalysis against well known FN-based block ciphers like CLEFIA and CAMELLIA [27].</p>

    <p class="text-gray-300">The approach used in the following - and largely exploited in the literature - to construct impossible differential is to combine two (truncated) differentials with prob. 1 that collide in the middle.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>Here we work for simplicity in  <span class="math">\\mathbb{F}_{2^n}</span> . The same result applies immediately to  <span class="math">\\mathbb{F}_p</span>  by considering an input difference of the form  <span class="math">(0,\\ldots,0,\\Delta_I,-\\Delta_I)</span>  where  <span class="math">\\Delta_I\\neq 0</span> .</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>crf</sub>. As first thing we look for a probability-one truncated differential in order to construct impossible differentials for GMiMC<sub>crf</sub>. A probability-one differential for a maximum of t-1 rounds of this UFN with t branches is described as follows:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha,\\alpha) \\to (0,\\ldots,0,\\alpha,\\alpha,0) \\to \\ldots \\to (\\alpha,\\alpha,0,\\ldots,0).</span>$</p>

    <p class="text-gray-300">A truncated differential with probability 1 exists for (t-1) + (t-1) = 2t - 2 rounds. This is described as follows:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha,\\alpha) \\xrightarrow{t-1 \\text{ rounds}} (\\alpha,\\alpha,0,\\ldots,0) \\xrightarrow{t-1 \\text{ rounds}} (0,*,\\ldots,*).</span>$</p>

    <p class="text-gray-300">This will allow us to attack 3t-3 rounds of the cipher, exploiting the differential just given on 2t-2 rounds and noting that  <span class="math">(\\beta,0,\\ldots,0) \\xrightarrow{t-1 \\text{ rounds}} (0,*,\\ldots,*)</span>  with probability 1. As a result, the (3t-3)-rounds impossible differential used for the attack is given by</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha) \\xrightarrow[\\text{prob. } 1]{R^{2t-2}(\\cdot)} (0,*,\\ldots,*) \\neq (\\beta,0,\\ldots,0) \\xleftarrow[\\text{prob. } 1]{R^{t-1}(\\cdot)} (0,*,\\ldots,*)</span>$</p>

    <p class="text-gray-300">for  <span class="math">\\alpha, \\beta \\neq 0</span> . Hence, the number of iterations to protect the cipher against such an attack must be at least [(2t-2)+(t-1)]+2=3t-1 for the case  <span class="math">\\kappa=n</span> . For the case  <span class="math">\\kappa=t\\cdot n</span> , the number of rounds must be at least [(2t-2)+(t-1)]+t+1=4t-2.</p>

      <h4 id="sec-4.2.3" class="text-lg font-semibold mt-6">4.2.3 Linear Cryptanalysis</h4>

    <p class="text-gray-300">Similar to differential attacks, linear attacks [56] pose no threat to the GMiMC family of block ciphers <em>instantiated</em> with the same number of rounds previously defined for differential cryptanalysis. This follows from the fact that the cubic function is <em>almost bent</em>, which means that its maximum square correlation is limited to  <span class="math">2^{-n+1}</span>  (see [1] for details). As a result, it offers the best possible resistance against linear cryptanalysis much like an APN function provides optimal resistance against differential cryptanalysis.</p>

      <h4 id="sec-4.2.4" class="text-lg font-semibold mt-6">4.2.4 &quot;Generic&quot; (MitM) Attacks</h4>

    <p class="text-gray-300">Recently, [47] proposed generic attacks on unbalanced Feistel ciphers based on the meetin-the-middle technique in the case in which the key size is the same as the block size, i.e,  <span class="math">\\kappa=t\\,n</span> . In particular, that work analyzes two general classes of unbalanced Feistel structures, namely contracting Feistel networks and expanding Feistel networks. In both of the cases, they consider the practical scenario where the round functions are keyless and known to the adversary. Such results improved the ones proposed in [65] for Feistel networks with contracting or expanding round functions. In the following, we apply such results on GMiMC<sub>crf</sub> and GMiMC<sub>erf</sub>.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>crf</sub>. Recently, in [47] an improved analysis was shown for the additive input to the Feistel function. This analysis considers the round function F with input  <span class="math">x_1 \\oplus \\cdots \\oplus x_{t-1} \\oplus k_i</span>  and implies that 5t-4 rounds of the GMiMC<sub>crf</sub> construction can be attacked when the key size is the same as the block size<sup>12</sup>, i.e,  <span class="math">\\kappa = t \\cdot n</span> . This attack has a data complexity of  <span class="math">2^{\\frac{7N}{8}}</span>  chosen plaintexts.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub> For unbalanced Feistel networks with expanding round functions generic attacks were shown [47] for 4t-2 rounds. The attack has a data complexity of  <span class="math">2^{N-n}</span>  chosen plaintexts.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{12}&lt;/sup&gt;</span> For completeness, we mention that according to the same analysis proposed in [47], for a fixed number of branches, if the key size is increased, then more rounds can be attacked. However, this case is not considered in our work.</p>

      <h4 id="sec-4.2.5" class="text-lg font-semibold mt-6">4.2.5 Other Attacks</h4>

    <p class="text-gray-300">We claim that GMiMC instantiated using the number of rounds of the univariate case <sup>13</sup> is secure in the known- and chosen-key model. In particular, such permutation is used in order to construct the hash function using the sponge construction. We recall that the (required) indifferentiable of the internal permutation of a sponge function from a random oracle - for a fixed key - is equivalent to the security of GMiMC in the known-and chosen-key model.</p>

    <p class="text-gray-300">Finally we explicitly state that we do not have claims in related-key model as we do not consider it to be relevant for the intended use case.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Quantum Improvements</h3>

    <p class="text-gray-300">In a post-quantum setting, the cost of exhaustive key search is square rooted by Grovers' algorithm. Statistical attacks remain unchanged (except perhaps their computational part). The quantum interpolation attack gives no significant advantage to the adversary since the attack requires d/2 queries, where d is the degree of the polynomial [33]. It is not clear that Grover's algorithm can help to improve the GCD attack. The attack cost  <span class="math">\\mathcal{O}(d \\cdot \\log^2 d)</span>  operations on inputs of size d. Thus, even with the square root reduction the attacker will still need to write the inputs of size d as classically; a similar argument holds for Gr&ouml;bner basis attacks.</p>

    <p class="text-gray-300">Finally, since we are here interested in post-quantum security of classical schemes and not in the security of symmetric primitives running on a quantum computer themselves, better attacks are known using Simon's algorithm [41].</p>

    <p class="text-gray-300">For some practical applications considered in the following, we also consider the case in which the attacker has a limited access to data (e.g. 1 or 2 (plaintext, ciphertext) pairs). Here we consider this particular case. Due to the limited access to data, not all attacks work in this scenario. In particular, among all attacks present in the literature, only two of them apply for the case of low-data complexity, which are the GCD attack and its generalization as a Gr&ouml;bner Basis attack. We emphasize that statistical attacks &ndash; like differential, linear, . . . &ndash; and other algebraic attacks &ndash; like interpolation and higher-order differential &ndash; are not competitive in this setting.</p>

    <p class="text-gray-300"><strong>Gr&ouml;bner Basis Analysis &ndash; Case:</strong>  <span class="math">\\kappa = t \\cdot n</span> . As explained in Section 4.1.2, the complexity of computing a Gr&ouml;bner basis for a system of  <span class="math">\\mathfrak{N}</span>  polynomials in  <span class="math">\\mathfrak{V}</span>  variables is of  <span class="math">\\binom{D_{reg} + \\mathfrak{V}}{D_{reg}}</span>  operations over the base field  <span class="math">\\mathbb{F}</span>  [19], where  <span class="math">D_{reg}</span>  is the degree of regularity. As already pointed out, closed-form formulas for  <span class="math">D_{reg}</span>  are known only for some special cases (e.g. when  <span class="math">\\mathfrak{V} = \\mathfrak{N}</span> ), but not in general.</p>

    <p class="text-gray-300">In the low-data scenario, we use the SageMath code [73] in Appendix G to estimate  <span class="math">D_{reg}</span> , and so the complexity of the Gr&ouml;bner Basis attack on GMiMC. In the low-data case, this analysis shows that in general the Gr&ouml;bner basis attack does not outperform the GCD attack that we are going to recall.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup>The number of rounds in this case is given considering the number of rounds of any possible distinguisher - which is independent of the secret key - in the MitM scenario plus a secure margin. Since the key is fixed in the known- and chosen-key model, this number of rounds provides the security in these scenarios.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Security Analysis &mdash; GCD Attacks</h3>

    <p class="text-gray-300">Since the GCD attack is one of the few attacks that work in the low-data scenario, here we recall the idea of such an attack.</p>

    <p class="text-gray-300">Given more than one known (plaintext, ciphertext) pair or working on the output of each branches of a single known (plaintext, ciphertext) pair (as described below), one can construct their polynomial representation. The idea of the GCD attack is simply to compute their polynomial Greatest Common Divisors (GCD) to recover a multiple of the key.</p>

    <p class="text-gray-300">Two-pair case. Denote by E(k,x) the encryption of x under key k. For a pair  <span class="math">(x,y) \\in \\mathbb{F}_{2^N}</span> , E(K,x)-y denotes a univariate polynomial in  <span class="math">\\mathbb{F}_q[K]</span>  corresponding to (x,y). Note that in our case the polynomial E(K,x)-y can be constructed conceptually easily from the encryption process, but writing down E(K,x)-y becomes computationally expensive as the number of rounds increases. Indeed, writing down E(K,x)-y requires not only large computational resources but also an exponential (in x) amount of memory.</p>

    <p class="text-gray-300">Consider now two such polynomials  <span class="math">E(K, p^1) - c^1</span>  and  <span class="math">E(K, p^2) - c^2</span> , with  <span class="math">c^i = E(k, p^i)</span>  for i = 1, 2 and for a fixed but unknown key k. It is clear that these polynomials share (K - k) as a factor. Indeed, with high probability the greatest common divisor will be (K - k). Thus, by computing the GCD of the two polynomials, we can find the value of k.</p>

    <p class="text-gray-300"><strong>One-pair case.</strong> Since we are working with a Feistel construction, we can also set up a GCD computation among the branches of the Feistel cipher. In other words, let  <span class="math">p := (p_{t-1}, \\ldots, p_1, p_0)</span>  and  <span class="math">c := (c_{t-1}, \\ldots, c_1, c_0)</span> . For each component, the attacker constructs the interpolation polynomial</p>

    <p class="text-gray-300"><span class="math">$c_i = E_i(K, (p_{t-1}, \\dots, p_1, p_0)) \\quad \\forall i = 0, \\dots, t-1,</span>$</p>

    <p class="text-gray-300">where K is the secret variable. The analysis then proceeds as above, working on different words of the same texts (instead of working on different texts). Thus, it is possible to perform the GCD among the branches also in the case in which the attacker knows only 1 (plaintext, ciphertext) pair.</p>

    <p class="text-gray-300">Meet-in-the-Middle. Due to the Feistel structure, a Meet-in-the-Middle variant of the GCD attack can be performed. That is, instead of constructing polynomials expressing ciphertexts as polynomials in the plaintext and the key, we can construct two polynomials  <span class="math">G&#x27;(K,x_i)</span>  and  <span class="math">G&#x27;&#x27;(K,y_i)</span>  expressing the state in round r/2 as a polynomial in the key and the plaintext or ciphertext respectively. Then, considering  <span class="math">G&#x27;(K,x_0) - G&#x27;&#x27;(K,y_0)</span>  and  <span class="math">G&#x27;(K,x_1) - G&#x27;&#x27;(K,y_1)</span> , we can apply a GCD attack on polynomials with lower degree than before (approximately half). Hence, the number of rounds must be double to thwart this variant of the attack.</p>

    <p class="text-gray-300"><strong>Complexity.</strong> It is well-known that the complexity for finding the GCD of two polynomials of degree d is  <span class="math">\\mathcal{O}(M(d)\\log_2 d)</span> , where M(d) is the cost of multiplying two degree-d polynomials. The best (known) complexity for M(d) is  <span class="math">\\mathcal{O}(d\\log_2 d)</span>  using an FFT. Thus, we expect a GCD computation to cost  <span class="math">\\mathcal{O}\\left(d\\log_2^2 d\\right)</span> , where the hidden constant is greater than 1. In order to estimate the computational cost of such an attack, we have to estimate the degree of K in E(K,x)-y, which depends on the number of rounds r. To derive an estimate for the required number of rounds, we will target</p>

    <p class="text-gray-300"><span class="math">$d\\log_2^2 d \\approx 2^{\\kappa} = 2^n,\\tag{6}</span>$</p>

    <p class="text-gray-300">where  <span class="math">2^{\\kappa}</span>  denotes the computational cost of a brute-force attack and  <span class="math">\\kappa = n</span>  denotes the number of key bits.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>crf</sub>. Case:  <span class="math">\\kappa = n</span> . The condition  <span class="math">3^{r-t+1} \\log^2(3^{r-t+1}) \\approx 2^n</span>  is fulfilled when  <span class="math">r \\simeq t-1+n \\cdot \\log_3 2 - 2\\log_3 n</span> . Thus, the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = \\left\\lceil 2t + 2n \\cdot \\log_3 2 - 4 \\cdot \\log_3 n \\right\\rceil</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant.</p>

    <p class="text-gray-300">Multivariate Case:  <span class="math">\\kappa=t\\cdot n</span> . To extend these attacks to the multivariate case, i.e.  <span class="math">\\kappa=t\\cdot n</span> , the attacker may guess  <span class="math">(t-1)\\cdot n</span>  bits of the key, and then perform the previous GCD attack on a univariate polynomial. We note, however, that in the multivariate case we are targeting a complexity of  <span class="math">2^{t\\,n}</span>  operations and are performing  <span class="math">2^{(t-1)\\,n}</span>  GCD computations. Thus, each GCD computation has a &quot;budget&quot; of  <span class="math">2^n</span>  operations. On the other hand, guessing permits to shave off up to (t-1) rounds. Thus, the number of rounds required in the multivariate case is slightly higher than in the univariate case. Of course, this trade-off changes when  <span class="math">2^{tn}\\gg 2^{\\lambda}</span> , where  <span class="math">\\lambda</span>  is the targeted security level.</p>

    <p class="text-gray-300">As a result, the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = 3t + \\left\\lceil 2n \\cdot \\log_3 2 - 4 \\cdot \\log_3 n - 1 \\right\\rceil</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant. For each GMiMC family of block ciphers, we refer to Table 1 for the minimum number of rounds that ensure security against the GCD attack.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Parameter-Space Exploration</h2>

    <p class="text-gray-300">We compare the effects of different parameters in our Feistel-based constructions with block size N. In Table 3 we compare several parameters of the generalized constructions.</p>

    <p class="text-gray-300">To simplify the notations, we denote the number of rounds necessary to protect the cipher from Interpolation attack, Gr&ouml;bner basis attack, Higher-Order differential attack and (Truncated) Differential attack respectively by  <span class="math">R_{\\rm Int}</span> ,  <span class="math">R_{\\rm Gr&ouml;bner}</span> ,  <span class="math">R_{\\rm HighOrd}</span> ,  <span class="math">R_{\\rm TDiff}</span> . Moreover, let  <span class="math">\\Lambda(t) := 2\\lceil \\log_2(t) \\rceil</span> .</p>

    <p class="text-gray-300">For the following, we denote by  <span class="math">\\alpha</span>  the number of multiplication that must be performed to compute  <span class="math">x^3</span>  for an arbitrary x, i.e.  <span class="math">\\alpha = 1</span>  for  <span class="math">x \\in \\mathbb{F}_{2^n}</span>  (where  <span class="math">x^2</span>  is linear in  <span class="math">\\mathbb{F}_{2^n}</span> ) and  <span class="math">\\alpha = 2</span>  for  <span class="math">x \\in \\mathbb{F}_p</span>  (for prime p).</p>

    <p class="text-gray-300"><span class="math">GMiMC_{crf}</span>  vs  <span class="math">GMiMC_{erf}</span> .  <span class="math">GMiMC_{crf}</span>  and  <span class="math">GMiMC_{erf}</span>  are quite similar &mdash; only one multiplication is performed at each round. By our analysis, it turns out that  <span class="math">GMiMC_{erf}</span>  is always more efficient than  <span class="math">GMiMC_{crf}</span> , since it always requires a lower number of rounds to be secure. For this reason, we only consider  <span class="math">GMiMC_{erf}</span>  for the following practical applications.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{GMiMC_{Nyb}}</span>  vs  <span class="math">\\mathbf{GMiMC_{mrf}}</span> .  <span class="math">\\mathbf{GMiMC_{Nyb}}</span>  and  <span class="math">\\mathbf{GMiMC_{mrf}}</span>  are quite similar &mdash; t/2 multiplications are performed at each round. By our previous analysis, it turns out that  <span class="math">\\mathbf{GMiMC_{mrf}}</span>  is always more efficient than  <span class="math">\\mathbf{GMiMC_{Nyb}}</span> , since it always requires a lower number of rounds to be secure. For this reason, we only consider  <span class="math">\\mathbf{GMiMC_{mrf}}</span>  for the following practical applications.</p>

    <p class="text-gray-300"><strong>Remark.</strong> As pointed out in the introduction, Feistel MiMC requires approximately double the number of rounds of MiMC. However, we found that the number of rounds does not grow linearly with the number of branches. For a concrete example, the cases of GMiMC<sub>erf</sub> with  <span class="math">t \\cdot \\log_2 p \\approx 256</span>  and  <span class="math">t \\cdot \\log_2 p \\approx 1024</span>  fixed are depicted in Fig. 5 and Fig. 7.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;14</sup>Note that the solution of  <span class="math">y = x \\cdot \\log^2(x)</span>  is well approximated by  <span class="math">x = y/\\log^2(y)</span> .</p>

    <p class="text-gray-300">Table 3: Comparing the parameters of the GMiMC keyed permutation in different modes - no restriction on data complexity. For simplicity, we use the notation n and N to denote respectively the cases  <span class="math">\\log_2 p</span>  and  <span class="math">t \\cdot \\log_2 p</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Branches</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">round (R)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">#mult</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#\\text{mult} \\cdot  \\mathbb{F} </span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">EM [4]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n \\equiv N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\log_3(2) \\cdot n + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N \\cdot \\alpha \\cdot R</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Feistel [4] Feistel</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N N</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot \\log_3(2) \\cdot n + 1</span> <span class="math">\\left\\lceil 2 \\cdot \\log_3(2) \\cdot n \\right\\rceil + 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{\\frac{N}{2} \\cdot \\alpha \\cdot R}{\\frac{N}{2} \\cdot \\alpha \\cdot R}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\operatorname{GMiMC}_{crf}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">t \\ge 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n <span class="math">N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\max \\left\\{ R_{\\text{Int}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\}</span> <span class="math">\\max \\left\\{ R_{\\text{Int}}, R_{\\text{Gr\\&quot;{o}bner}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha \\cdot R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{N}{t} \\cdot \\alpha \\cdot R</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{erf}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">t \\ge 3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n <span class="math">N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{split} &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\\\ &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{Gr\\&quot;obner}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\end{split}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha \\cdot R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{N}{t} \\cdot \\alpha \\cdot R</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{Nyb}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">t=2t&#x27;\\geq 4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n <span class="math">N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{split} &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\\\ &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{Gr\\&quot;obner}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\end{split}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{t}{2} \\cdot \\alpha \\cdot R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{N}{2} \\cdot \\alpha \\cdot R</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{GMiMC}_{mrf}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">t=2t&#x27;\\geq 4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n \\ N</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{split} &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\\\ &amp; \\max \\left\\{ R_{\\text{Int}}, R_{\\text{Gr\\&quot;{o}bner}}, R_{\\text{HighOrd}}, R_{\\text{TDiff}} \\right\\} \\end{split}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{t}{2} \\cdot \\alpha \\cdot R</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{N}{2} \\cdot \\alpha \\cdot R</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">It is possible to observe the minimum number of rounds is obtained by choosing the number of branches t not too &quot;small&quot; and not too &quot;big&quot; (e.g.  <span class="math">6 \\le t \\le 18</span> ). As a result, for this range of values of t, GMiMC<sub>erf</sub> results to be as competitive as MiMC or even more for the applications that we have in mind. Similar results can be obtained for other values of  <span class="math">t \\cdot \\log_2 p</span>  and for all other GMiMC ciphers proposed here (we focus on GMiMC<sub>erf</sub> since it results to be the most competitive one for the practical applications that we are studying in this paper).</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 MPC/SNARK/PQ Signature Applications</h3>

    <p class="text-gray-300">In this section, we are interested to optimize the two GMiMC ciphers previously selected with respect to different metrics:</p>

    <p class="text-gray-300"><strong>SNARK:</strong> minimize total number of &quot;operations&quot; (i.e. sum, multiplication with/without constant, square, ...) &ndash; case  <span class="math">\\kappa = \\log_2 p</span>  (we recall that SNARK applications use the hash function GMiMCHash, where the number of rounds of the inner permutation is given by the univariate case);</p>

    <p class="text-gray-300"><strong>PQ Signature:</strong> minimize total number of multiplications  <span class="math">\\times</span>  field size &ndash; case  <span class="math">\\kappa = N</span>  in low-data scenario;</p>

    <p class="text-gray-300"><strong>MPC:</strong> motivated by real life applications, our goal is to reduce the total runtime. The main bottleneck of a protocol ran on top of SPDZ-framework is the triple generation mechanism which is given by the number of (parallel) multiplications. Hence the goal is to minimize/optimize both the total number of operations (as for SNARKs) and the total number of (parallel) multiplications (where note that the two metrics coincide for  <span class="math">GMiMC_{crf}</span>  and  <span class="math">GMiMC_{erf}</span> ).</p>

    <p class="text-gray-300">    <img src="_page_23_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: Number of Branches <em>versus</em> Number of Rounds &ndash; GMiMCerf with <em>t</em> &middot; log<sup>2</sup> <em>p</em> &asymp; 256 fixed.</p>

    <p class="text-gray-300">    <img src="_page_23_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 6: Number of Branches <em>versus</em> Number of Rounds &ndash; GMiMCerf with <em>t</em>&middot;log<sup>2</sup> <em>p</em> &asymp; 1024 fixed.</p>

    <p class="text-gray-300">    <img src="_page_23_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 7: Number of Branches <em>versus</em> Number of Rounds <em>of different attacks</em> &ndash; GMiMCerf with <em>t</em> &middot; log<sup>2</sup> <em>p</em> &asymp; 1024 fixed. &quot;Statistical Attacks&quot; include Truncated diff., Impossible Diff. and Linear Diff. &quot;Algebraic Attacks&quot; include GCD attack, Interpolation attack, Gr&ouml;bner Basis and Higher-Order Diff.</p>

    <p class="text-gray-300"><strong>Remark.</strong> We remark that computing  <span class="math">x^3</span>  requires 2 multiplications in  <span class="math">\\mathbb{F}_p</span>  and a single multiplication in  <span class="math">\\mathbb{F}_{2^n}</span>  (since  <span class="math">x^2</span>  is linear in  <span class="math">\\mathbb{F}_{2^n}</span> ).</p>

    <p class="text-gray-300">Focusing on  <span class="math">\\mathbb{F}_{2^n}</span> , the cost of performing one multiplication in  <span class="math">\\mathbb{F}_{2^n}</span>  using a fast Fourier transform is approximately  <span class="math">\\mathcal{O}(n \\cdot \\log n)</span>  bit-wise XORs (that is, approximately  <span class="math">\\beta \\cdot n \\cdot \\log n</span>  for some constant  <span class="math">\\beta</span> ), while the cost of one addition is n bit-wise XORs. As a result, a good approximation of this number is given by</p>

    <p class="text-gray-300">number of rounds
<span class="math">$\\times \\left( A + \\frac{N}{\\beta \\cdot n \\cdot \\log(n)} \\right)</span>$
, (7)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$GMiMC_{crf}, GMiMC_{erf} : A = 1</span>$
and  <span class="math">GMiMC_{Nvb}, GMiMC_{mrf} : A = t/2</span></p>

    <p class="text-gray-300">since for each round  <span class="math">\\mathcal{A}</span>  multiplication(s) and (approximately)  <span class="math">n \\cdot t</span>  bit-wise XOR-sums are performed - remember that (1st) a single multiplication is necessary to compute  <span class="math">x^3</span>  in  <span class="math">\\mathbb{F}_{2^n}</span>  and (2nd) the ratio between the cost of 1 multiplication and 1 addition is  <span class="math">1/\\log(n)</span> . It follows that when the total number of multiplications is higher than the total number of additions (e.g. MiMC, GMiMC<sub>Nyb</sub> or GMiMC<sub>mrf</sub>), it is reasonable to approximate the total number of operations by the total number of multiplications. When the total number of additions is much higher than the total number of multiplications, one must take care of both these two numbers to compute the total cost. Finally, in the PQ signature case, we primarily consider the total number of multiplications (and not of generic operations), since this metric determines both the signature size and the number of pseudo-randomly generated field elements required for signing.</p>

    <p class="text-gray-300">Similar results can be obtained as well also for the case  <span class="math">\\mathbb{F}_p</span> . Here the cost of 1 multiplication can be approximated as  <span class="math">O(\\log_b(p)^2)</span>  word sum-operations (that is, approximately  <span class="math">\\beta \\cdot \\log_b(p)^2</span>  for some constant<sup>15</sup>  <span class="math">\\beta</span> ) where b is the word size of the processor [58]. Thus a good approximation for the total number of operations for the case  <span class="math">\\mathbb{F}_p</span>  is given by</p>

    <p class="text-gray-300">number of rounds
<span class="math">$\\times \\left(2 \\cdot \\mathcal{A} + \\frac{t}{\\beta \\cdot [\\log_2(p)]^2}\\right)</span>$
, (8)</p>

    <p class="text-gray-300">where  <span class="math">p \\approx 2^n</span> ,  <span class="math">\\mathcal{A}</span>  is defined as before, and the factor 2 counts for the two multiplications required to compute cubes in  <span class="math">\\mathbb{F}_p</span>  (instead of a single one).</p>

      <h4 id="sec-6.1.1" class="text-lg font-semibold mt-6">6.1.1 SNARK &mdash; Number of &quot;Operations&quot;</h4>

    <p class="text-gray-300">First of all, for SNARKs applications we only consider the case  <span class="math">\\mathbb{F}_p</span> . The reason of this choice is the fact that we cannot use the property that squaring is linear in  <span class="math">\\mathbb{F}_{2^n}</span>  for a more efficient implementation in this setting, since the cubes have to be represented as rank-1 constraint (see Section 7.2 for more details). We remark that similar consideration has been made for MiMC when used for SNARK applications (see [4, Section 6.1]).</p>

    <p class="text-gray-300">Having said that and focusing only on the case  <span class="math">\\kappa = n</span> , for the following it is interesting to observe that for each N fixed, it is possible to minimize the total number of &quot;operations&quot; by adjusting the parameters t and n. Both for the case of GMiMC<sub>mrf</sub> and GMiMC<sub>erf</sub>, this number corresponds to the total number of multiplications. In GMiMC<sub>erf</sub>, a good approximation of this number is given by formula (8).</p>

    <p class="text-gray-300">Focusing on the case N=1024 - used in the following application, it turns out that GMiMC<sub>erf</sub> is more efficient in this setting. Consider e.g. the case  <span class="math">\\mathbb{F}_p</span> . As showed in Fig. 8, it turns out that the best choice for GMiMC<sub>erf</sub> is n=103 and t=10. The number</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{15}&lt;/sup&gt;</span>  For our practical implementation of the the SNARKs application in Section 7.2, the value of  <span class="math">\\beta</span>  is well approximated by  <span class="math">\\beta\\approx 1.75/32^2</span>  based on the multiplication and reduction algorithms used by NTL. This number is consistent with the complexity discussion of Karatsuba multiplication and Barrett reduction and Schoolbook multiplication for small fields, respectively, in [58, Chapter 5].</p>

    <p class="text-gray-300">    <img src="_page_25_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 8: SNARK in F<em><sup>p</sup></em> - Comparison of the number of operations for GMiMCerf and GMiMCmrf for different values of <em>p</em> (<em>N</em> = log<sup>2</sup> <em>p</em> &middot; <em>t</em> = 1024).</p>

    <p class="text-gray-300">of total operations for this choice of parameters is &asymp; 403. In GMiMCmrf, the number of multiplications is given by <em>R</em> &times; <em>t</em> (where <em>R</em> is the number of rounds and 2 &times; (<em>t/</em>2) = <em>t</em> multiplications in F<em><sup>p</sup></em> are performed in each round), which means that the total number of operations is (at least)</p>

    <p class="text-gray-300"><span class="math">$\\max \\left\\{ 1.262 \\cdot N + 4t + 2t \\cdot \\log_2(t), 4 + 4t^2 + 4t \\cdot \\log_2(N), 2t + \\frac{6t \\cdot n \\cdot \\log_2 t}{n-1} \\right\\} \\ge 1.262 \\cdot N \\approx 1293,</span>$</p>

    <p class="text-gray-300">that is approximately three times more. As a result, for the case <em>N</em> = 1024, GMiMCerf is (much) more efficient than GMiMCmrf.</p>

      <h4 id="sec-6.1.2" class="text-lg font-semibold mt-6"><strong>6.1.2 PQ Signatures &mdash; Number of Multiplications &times; Field Size (Low-Data Scenario)</strong></h4>

    <p class="text-gray-300">Focusing only on the case <em>&kappa;</em> = <em>N</em> = <em>t</em> &middot; <em>n</em> in F2<em><sup>n</sup></em> (analogous for F<em>p</em>), for the following it is interesting to observe that for <em>N</em> fixed, it is possible to minimize the product &quot;numbers of multiplications &times; branch size&quot; by adjusting the parameters <em>t</em> and <em>n</em>. This metric is the most interesting one, since it determines both the signature size and the size of the random tapes. Remember that the PQ signature is implemented in the low-data scenario only (which means that e.g. the differential attack does not apply). We give the best choice of <em>t</em> and <em>n</em> for this metric:</p>

    <p class="text-gray-300"><strong>GMiMCerf</strong> With respect to the general scenario, in this case there is no closed-form formula to compute the number of rounds necessary to guarantee security. Combining the results provided by the GCD attack and the one provided by the SageMath code given in Appendix <a href="#page-49-0">G</a> (in order to estimate Gr&ouml;bner Basis attack), the number of rounds to provide security is<a href="#page-25-1">16</a> <em>R</em> &ge; 1<em>.</em>262 &middot; <em>n</em> &minus; 4 &middot; log<sup>3</sup> (<em>n</em>) +3<em>t</em> + 3 and the best choice is</p>

    <p class="text-gray-300"><span class="math">$n = 3,</span>$
<span class="math">R \\cdot n \\ge \\lceil 1.262 \\cdot n^2 - 4 \\cdot \\log_3(n) \\cdot n \\rceil + 3N + 3n \\ge 3N + 9,</span></p>

    <p class="text-gray-300">where note that the number of multiplications is equal to the number of rounds in F2<em><sup>n</sup></em> (while it is double in F<em>p</em>).</p>

    <p class="text-gray-300"><strong>GMiMCmrf</strong> Since the number of multiplications in F2<em><sup>n</sup></em> is given by <em>R</em> &middot; <em>t/</em>2, it follows that<a href="#page-25-2">17</a></p>

    <p class="text-gray-300"><span class="math">$R \\cdot \\frac{t}{2} \\cdot n \\geq \\left\\lceil 0.631 \\cdot N \\cdot n \\right\\rceil + N \\cdot \\Lambda \\left( t \\right) + \\frac{N}{2},</span>$</p>

    <p class="text-gray-300">which is higher than the corresponding number for GMiMCerf. Indeed, since &Lambda;(<em>x</em>) = 2 log<sup>2</sup> (<em>x</em>), the best choice is to minimize <em>n</em> (that is, to choose <em>n</em> = 3). It follows</p>

    <p class="text-gray-300"><sup>16</sup>More details on the number of rounds in this scenario are provided in Appendix <a href="#page-47-0">F.</a></p>

    <p class="text-gray-300"><sup>17</sup>We use the number of rounds provided by the GCD attack for the given estimation. Note that the real number of rounds is not lower than the number of rounds of the GCD attack.</p>

    <p class="text-gray-300">that <em>R</em> &middot; <em>t</em> 2 &middot; <em>n</em> &ge; <em>N</em> &middot; (2<em>.</em>4 + 2 log<sup>2</sup> (<em>N/</em>3)) = O(<em>N</em> log(<em>N</em>)) (<em>vs</em> O(<em>N</em>) for the case of GMiMCerf).</p>

    <p class="text-gray-300">In more detail, for
<span class="math">$n = 3</span>$
:  <span class="math">\\underbrace{N \\cdot (2.4 + 2\\log_2(N/3))}_{\\text{GMiMC}_{\\text{mf}}} \\ge \\underbrace{3N + 9}_{\\text{GMiMC}_{\\text{erf}}}</span>  for each  <span class="math">N \\ge 7</span> .</p>

    <p class="text-gray-300">As a result, it follows that GMiMCerf is more efficient in this setting (analogous for F<em>p</em>).</p>

      <h4 id="sec-6.1.3" class="text-lg font-semibold mt-6"><strong>6.1.3 MPC &mdash; Number of (parallel) Multiplications</strong></h4>

    <p class="text-gray-300">As for SNARKs applications, <em>also for MPC applications we only consider the case</em> F<em>p</em>.</p>

    <p class="text-gray-300">In MPC the number of communication rounds is equal to the number of multiplications - that is <em>&alpha;</em> &middot; <em>R</em> where <em>&alpha;</em> and <em>R</em> are defined as before - for all the proposed designs. In particular, note that for GMiMCNyb and GMiMCmrf the <em>t/</em>2 multiplications can all be executed in parallel. On the other hand, these parallel multiplications are not &quot;costless&quot;: the effect of these <em>t/</em>2 multiplications per round is reflected in the throughput metric.</p>

    <p class="text-gray-300">When <em>n</em> is fixed, GMiMCmrf requires a lower number of rounds (for both encryption and MPC communications) than GMiMCerf. However, GMiMCmrf has significantly less throughput (Section <a href="#page-26-0">7.1)</a> compared to GMiMCerf due to a lower number of multiplications.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>7 Application and Implementation</strong></h2>

    <p class="text-gray-300">In this section we present various implementation results.</p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8"><strong>7.1 MPC Setting</strong></h3>

    <p class="text-gray-300">We have benchmarked the protocols using the SPDZ framework, which provides active security against multiple malicious parties <a href="#page-34-12">[52]</a>. To compute a circuit with secret shared inputs in SPDZ, there are two generic phases. The first step is to produce random Beaver triples, also called the pre processing phase, which is independent of the inputs and can be done in advance. The second step is the online phase, which consumes a triple whenever there is a multiplication between shared values. Additions of secret values and scalar multiplications are (almost) for free in SPDZ. The protocols ran across two computers with Intel i7-4790 CPUs at 3.60GHz and 16GB of RAM connected via a 1 GB/s LAN network and an average round-trip time of 0.3 ms (see Table <a href="#page-27-1">4)</a>. In our setting, both keys and messages are secretly shared among the two parties and each experiment was averaged among five executions with at least 1000 block cipher calls.</p>

    <p class="text-gray-300">For a complete measurement of an MPC protocol, one needs to have in mind both preprocessing and online phases. The pre-processing phase cost is determined by the number of shared multiplications. Performance of the online phase is given by the multiplicative depth of the circuit to be evaluated as well as the number of openings (whenever a party reveals a secret value). For the online phase we give measurements in terms of <em>latency</em> and <em>throughput</em>. Latency indicates the minimum time spent for computing one encrypted F<em><sup>p</sup></em> block, whereas throughput shows the maximum F<em><sup>p</sup></em> objects that can be encrypted in parallel per second. Since the only non-linear operation we use in our block ciphers is <em>x</em> 7&rarr; <em>x</em> 3 , this is done with three openings and two Beaver triples (for details see <a href="#page-35-3">[67]</a>). We instantiate each block cipher with 4 and 16 input blocks/branches, where each block lies in F<em><sup>p</sup></em> and <em>p</em> &asymp; 2 <sup>128</sup>. Note that for GMiMC constructions in MPC we have used an <em>n</em>-bit key. For a fair comparison with previous evaluations of MiMC in SPDZ, the online phase runs on a single thread.</p>

    <p class="text-gray-300">The preprocessing column denotes the amount of time required to generate the triples for a single block cipher evaluation (4 or 16 encrypted blocks) in a two party SPDZ protocol. The figures for this column were estimated using the recent protocol by Keller et al. <a href="#page-34-13">[51]</a></p>

    <p class="text-gray-300">Table 4: Two-party costs for MiMC and GMiMC over a LAN network. Protocols ran across two computers with commodity hardware connected via a 1 GB/s LAN network and an average round-trip time of 0.3 ms.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Mode</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Online cost</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prep/block(ms)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">#Branch<br>/ #Block</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MPC)<br>Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Openings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Latency<br>(ms)/Fp</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Throughput<br>Fp/s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCcrf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">178</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">534</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.65</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15026</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.96</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCerf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">172</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">516</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15669</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.86</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCNyb</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">169</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">507</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9131</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.63</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCmrf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">175</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">525</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.62</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8194</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.83</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 blocks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">876</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9965</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.86</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCcrf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">238</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">714</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39247</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.99</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCerf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">208</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">624</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.06</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49006</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.86</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCNyb</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">181</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">543</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.88</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8605</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.03</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCmrf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">183</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">549</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.02</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 blocks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3504</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10780</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.86</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">which is the fastest known protocol for SPDZ triples. We used the LowGear protocol with computational security 128 and 64 bit statistical security.</p>

    <p class="text-gray-300">Experiments (Table <a href="#page-27-1">4)</a> show that GMiMCcrf and GMiMCerf have a very fast preprocessing phase because they perform a low number of multiplications. A big advantage of these two is how well they scale in terms of triples used, since they require one multiplication per cipher iteration. This is in contrast with MiMC, where increasing the number of blocks to be encrypted by a factor of <em>c</em> results in <em>c</em> times more multiplications. We stress that these two constructions are first to our knowledge which avoid the linear increase of pre-processing data with the number of blocks. To give an example of this behavior consider the case of 16 blocks for the preprocessing column (Table <a href="#page-27-1">4)</a> for GMiMCerf is 5<em>.</em>5 times smaller than MiMC: 0<em>.</em>86ms vs. 4<em>.</em>86ms.</p>

    <p class="text-gray-300">Perhaps unexpectedly, GMiMCcrf and GMiMCerf have a higher online throughput compared to the rest of the variants, although they result in a larger number of rounds. The reason is that fewer openings - or multiplications in our case - means less data sent between the parties so we can batch more executions in parallel. Thus in a LAN network the number of rounds has a minor impact.</p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8"><strong>7.2 SNARKs</strong></h3>

    <p class="text-gray-300">The rank-1 constraints in SNARK is defined <a href="#page-32-14">[14]</a> as a system of bilinear equations over a field F. The number of <em>rank-1 constraints</em> for a function contributes to the efficiency of the SNARK algorithm <a href="#page-31-3">[4]</a>. In this setting we count the number of multiplications required to generate the values of <em>witness variables</em> <a href="#page-32-14">[14]</a>.</p>

    <p class="text-gray-300"><strong>GMiMCcrf</strong> The rank-1 constraints are as follows:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=0}^{t-1} X_i + U + k_r + C_r = 0, \\ U \\cdot U = Y, \\ U \\cdot Y + X_{t-1} = Z,</span>$</p>

    <p class="text-gray-300">Table 5: Comparison of MiMC with GMiMCerf (with different numbers of branches) in SNARK in F<em><sup>p</sup></em> when the block size is 1024 bits.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">MiMC [4]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">GMiMCerf</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(p), R)<br>(t, log2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(1, 1024, 646)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(2, 513, 647)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4, 256, 332)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(8, 128, 178)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(16, 64, 141)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">constraint generation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.553 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.077 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.735 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.732 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.057 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">witness generation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.079 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.639 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.388 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.296 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.449 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">total time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.632 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.716 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.123 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.028 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.507 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">#additions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">646</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1293</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">996</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1246</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2115</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">#multiplications</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1293</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1293</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">664</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">356</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">282</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">where <em>k<sup>r</sup></em> and <em>C<sup>r</sup></em> are round keys and round constants respectively. For GMiMCcrf Hash the round keys are constant. The number of multiplication for GMiMCcrf Hash is 2 per round. Therefore the total number of multiplications is 2<em>R</em> where <em>R</em> is the number of rounds in the block cipher GMiMCcrf. Each round also requires <em>t</em> &minus; 1 field additions.</p>

    <p class="text-gray-300"><strong>GMiMCerf</strong> The rank-1 constraints can be constructed from the following equations:</p>

    <p class="text-gray-300"><span class="math">$X_{t-1} + U + k_r + C_r = 0, \\ U \\cdot U = Y, \\ U \\cdot Y + X_i = Z_i \\text{ for } 0 \\le i \\le t-2,</span>$</p>

    <p class="text-gray-300">where <em>k<sup>r</sup></em> and <em>C<sup>r</sup></em> are round keys and round constants respectively. For GMiMCerfHash the round keys are constant. The number of multiplications and additions are 2 and <em>t</em> &minus; 1 per round respectively. Note that GMiMCerf has <em>t</em> &minus; 1 rank-1 constraints per round whereas GMiMCcrf has 2 constraints.</p>

    <p class="text-gray-300"><strong>GMiMCNyb</strong> For the keyed permutation the rank-1 constraints are as follows:</p>

    <p class="text-gray-300"><span class="math">$X_i + U_i + k_{i,r} + C_{i,r} = 0, U_i \\cdot U_i = Y_i, U_i \\cdot Y_i + X_{i+t-1} = Z_i,</span>$</p>

    <p class="text-gray-300">where <em>Ci,r</em> is the round constant to the <em>i</em>-th function in round <em>r</em>. Note that in each round there are <em>t/</em>2 functions in the Nyberg mode and for each function we get the above-mentioned constraints. For GMiMCNybHash the round keys are constants. The number of multiplications per round is 2 &middot; <em>t/</em>2 = <em>t</em>. Hence the total number of multiplications is <em>t</em> &middot; <em>R</em>.</p>

    <p class="text-gray-300"><strong>GMiMCmrf</strong> This constructions also uses <em>t/</em>2 different functions per round and the constraints for it can be obtained in a similar way.</p>

    <p class="text-gray-300">We have implemented the GMiMCcrf and GMiMCerf in a SNARK setting using NTL <a href="#page-35-15">[71]</a> for the GMiMC permutation and hash function. We compared the performance with MiMC. For <em>N</em> &asymp; 1024-bit (prime) block size GMiMCerf[<em>N, t, n</em>], where <em>t</em> = 8, shows some improvement over MiMC-1025. For hashing a single message block, GMiMCHash-256 is more than 1<em>.</em>2 times faster than MiMCHash-256 and is significantly (<em>&gt;</em> 12 times) faster than SHA-256. We stress that in comparison with MiMCHash the primary advantage of GMiMCerfHash is that it can be used over 256 bit or smaller field size. For all the field operations we have used the NTL together with the gf2x library. All the computations were performed on a system having an Intel Core i7-4790 with 3.6 GHz processor with 16 GB memory. We took the average time over &asymp; 2000 iterations.</p>

    <p class="text-gray-300">Note that the number of constraints for GMiMCHash-256 with fixed key permutation is only one more than the number of constraints for GMiMCerf. Hence the time taken by the hash function and the permutation with fixed key are the same (in Table <a href="#page-28-0">5)</a>.</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8"><strong>7.3 Post-Quantum Signatures</strong></h3>

    <p class="text-gray-300">Picnic <a href="#page-33-5">[31]</a> is a new class of digital signature schemes which derive their security entirely from the security of symmetric-key primitives, have extremely small key pairs, and are highly parameterizable. The construction is based on a one-way function <em>f</em>, where for the secret key <em>x</em> the image <em>y</em> = <em>f</em>(<em>x</em>) is published as the public key. A signature on a message is then obtained from a non-interactive zero-knowledge proof of the relation <em>y</em> = <em>f</em>(<em>x</em>), that incorporates the message in the challenge generation. This proof uses ZKB++, a &Sigma;-protocol for statements over general circuits made non-interactive. When instantiating <em>f</em> with LowMC <a href="#page-31-5">[5,</a> <a href="#page-31-11">3]</a>, trying to reduce the signature size by reducing the number of multiplication gates comes at the cost of a more expensive linear layer, which leads to a runtime vs. signature size trade-off. Since the security proofs in <a href="#page-33-5">[31]</a> only require a block cipher with a reduced data complexity of 1, the overall performance can be greatly improved as this fact allows to choose LowMC instances with less rounds. For the 128-bit PQ security level (i.e., 256-bit block size and key size) a good trade-off can be found by using 10 S-Boxes and 38 rounds, resulting in a view size of 1140 bits.</p>

    <p class="text-gray-300">We implemented the signature scheme using GMiMCerf with key size and block size of &asymp; 256 bits to build the one-way function. We consider instances with a data complexity of 1. The reduction steps of the modular multiplications were accelerated by using special prime moduli and irreducible polynomials of special form for prime fields and binary fields, respectively: generalized Mersenne primes <a href="#page-35-16">[72]</a> were used for prime fields and trinomials and pentanomials with middle terms close to each other <a href="#page-35-17">[69]</a> were used for binary fields.</p>

    <p class="text-gray-300">In Table <a href="#page-30-0">6,</a> we compare the circuit runtimes (i.e., runtimes without protocol overheads such as pseudo-random number sampling and the computation of commitments) of MiMC and GMiMCerf with different numbers of branches benchmarked on an Intel Core i7- 4790 with 3.6 GHz. We also include the view size required per repetition of ZKB++, and numbers for one two instances of LowMC using optimizations for the round key computations and linear layer <a href="#page-33-13">[40]</a>. Measuring only the circuit runtimes allows us to obtain a more accurate comparison in terms of computation time and view size, which are both directly related to the total runtime of the protocol and to the final signature size, respectively. Furthermore, the time required for pseudo-random number sampling &ndash; the dominating cost of the protocol overhead &ndash; is also reduced by making the view size smaller.</p>

    <p class="text-gray-300">Instantiations using F2<em><sup>n</sup></em> tend to perform better than the comparable parameterizations in F<em><sup>p</sup></em> for mainly two reasons: in F2<em><sup>n</sup></em> additions do not require reductions, the cubing operation can be implemented with only one multiplication. In any case, even for very small fields with the smallest view sizes but slower signing and verification, GMiMCerf performs significantly better in terms of view size and runtime than MiMC. Compared to LowMC, choosing an instance over F<sup>2</sup> <sup>3</sup> allows us to beat the smallest signatures sizes obtainable using LowMC with one S-Box by 306 bits in terms of view size. We also note that both signing and verification times are smaller when using instances providing a good trade-off (i.e., setting <em>n</em> = 17 or <em>n</em> = 33), and view sizes can be kept small too by using the fact that squaring is linear in binary fields.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Ring Signatures</strong></h4>

    <p class="text-gray-300">Continuing the work on signatures, ring signature scheme solely relying only on symmetrickey primitives can be constructed by proving an authentication path in a Merkle tree in zero-knowledge <a href="#page-33-6">[39,</a> <a href="#page-32-3">23]</a>. Hence collision-resistant hash functions with low multiplicative complexity are of interest for this application and requires a cipher also secure in the full data setting, so we consider GMiMCerf over F<em>p</em>.</p>

    <p class="text-gray-300">MiMC based hashes incur a view size of more than a million bits per hash function evaluation, which is larger than a LowMC based hash by a factor of about 1000. With GMiMC we can change the field size and are thus able to obtain much better numbers.</p>

    <p class="text-gray-300">Table 6: Comparison of MiMC with GMiMCerf and LowMC <a href="#page-31-5">[5]</a> when the block size is &asymp; 256 bits in the context of ZKB++. In LowMC-(<em>N, m, R</em>), <em>N</em> denotes the block size, <em>m</em> is the number of S-Boxes, and <em>R</em> denotes the number of rounds. Runtimes given for <em>Sign</em> and <em>Verify</em> are for the circuit computations only.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(n, t, R)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sign</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">View size</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC [4]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(256, 1, 162)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">333.97 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">166.28 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83456 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(272, 1, 172)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">92.45 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46.32 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94112 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCerf over Fp</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3, 86, 261)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">97.32 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72.06 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1566 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(4, 64, 196)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62.35 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.16 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1568 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(16, 16, 62)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.59 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.13 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1984 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(32, 8, 55)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.95 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.05 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3520 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(64, 4, 81)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.78 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.85 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10368 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(136, 2, 163)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67.51 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35.21 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44336 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMiMCerf over F2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(3, 86, 261)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.06 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.76 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">783 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(17, 16, 63)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.73 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.30 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1071 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(33, 8, 56)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.34 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.29 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1848 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-(256, 10, 38)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.74 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.52 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1140 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-(256, 1, 363)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.55 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.12 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1089 bits</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">When aiming for the same security level (<em>N</em> &asymp; 256) with GMiMCerf and using the Davies-Meyer transformation, which is sufficient for this application<a href="#page-30-1">18</a>, we achieve a very competitive view size in comparison to of 5184 bits with <em>n</em> = 32 for one hash function evaluation. Additionally the GMiMC based hash comes close to a LowMC based hash, with its view sizes being larger by a factor of &le; 5 (with <em>n</em> = 32), and significantly outperforms any MiMC based instantiation.</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>8 Discussion</strong></h2>

    <p class="text-gray-300">One key take-away of this work is that, when it comes to building structures in symmetric cryptography with low multiplicative complexity, balanced Feistel networks are not the best strategy. We provided a new and optimal (in some sense) variant of the GFN and yet we still cannot beat the ERF variant.</p>

    <p class="text-gray-300">This observation is surprising, and thus interesting: Unbalanced Feistel networks, which appeared no later than the late 1980s, do not have a great track record in the academic literature and in recent designs. As an illustration, consider that among all the lightweight block cipher designs listed on the CryptoLux lightweight block cipher wiki<a href="#page-30-2">19</a>, 7 are Type-II GFNs and 10 are balanced Feistel networks, whereas <em>none</em> is of the UFN or ERF type.</p>

    <p class="text-gray-300">And yet exactly those types turn out to be the best in our setting. We can even make a parallel with MiMC itself: Its structure is strongly related and building up on a design from the mid 1990s, which in recent textbooks <a href="#page-34-14">[55,</a> Section 8.4] was even shown as an example of how not to design a cipher. Despite this fact, it has turned out to be very good in many applications where multiplicative complexity matters. It may well be that the same is true with our work: Cryptographers had lost interest in the UBF or never considered it a reasonable option and yet it is the best in several of our specific use cases.</p>

    <p class="text-gray-300"><sup>18</sup>See <a href="#page-32-3">[23]</a> for a more detailed comparison of the various hash function constructions for this application.</p>

    <p class="text-gray-300"><sup>19</sup><a href="https://www.cryptolux.org/index.php/Lightweight_Block_Ciphers" target="_blank" rel="noopener noreferrer">https://www.cryptolux.org/index.php/Lightweight\\_Block\\_Ciphers</a></p>

    <p class="text-gray-300">This of course raises one question: What are other known but out-of-fashion structures which might be very suitable for MPC, SNARKs, PQ signatures or related applications?</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] M. A. Abdelraheem, M. &Aring;gren, P. Beelen, and G. Leander, &quot;On the distribution of linear biases: Three instructive examples,&quot; in <em>CRYPTO 2012</em>, ser. LNCS, R. Safavi-Naini and R. Canetti, Eds., vol. 7417. Springer, Heidelberg, Aug. 2012, pp. 50&ndash;67.</p></li>
      <li><p class="text-gray-300">[2] S. Agrawal, P. Mohassel, P. Mukherjee, and P. Rindal, &quot;Dise: Distributed symmetrickey encryption,&quot; Cryptology ePrint Archive, Report 2018/727, 2018, accepted at CCS 2018 - <a href="https://eprint.iacr.org/2018/727" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/727.</a></p></li>
      <li><p class="text-gray-300">[3] M. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner, &quot;Ciphers for MPC and FHE,&quot; Cryptology ePrint Archive, Report 2016/687, 2016, <a href="http://eprint.iacr.org/2016/687" target="_blank" rel="noopener noreferrer">http://eprint.</a> <a href="http://eprint.iacr.org/2016/687" target="_blank" rel="noopener noreferrer">iacr.org/2016/687.</a></p></li>
      <li><p class="text-gray-300">[4] M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen, &quot;MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity,&quot; in <em>ASIACRYPT 2016, Part I</em>, ser. LNCS, J. H. Cheon and T. Takagi, Eds., vol. 10031. Springer, Heidelberg, Dec. 2016, pp. 191&ndash;219.</p></li>
      <li><p class="text-gray-300">[5] M. R. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner, &quot;Ciphers for MPC and FHE,&quot; in <em>EUROCRYPT 2015, Part I</em>, ser. LNCS, E. Oswald and M. Fischlin, Eds., vol. 9056. Springer, Heidelberg, Apr. 2015, pp. 430&ndash;454.</p></li>
      <li><p class="text-gray-300">[6] A. Aly, M. Keller, E. Orsini, D. Rotaru, P. Scholl, N. Smart, and T. Wood, &quot;Scalemamba v1.3 : Documentation,&quot; 2018, <a href="https://homes.esat.kuleuven.be/~nsmart/SCALE/" target="_blank" rel="noopener noreferrer">https://homes.esat.kuleuven.be/~nsmart/</a> <a href="https://homes.esat.kuleuven.be/~nsmart/SCALE/" target="_blank" rel="noopener noreferrer">SCALE/.</a></p></li>
      <li><p class="text-gray-300">[7] N. Analytics, &quot;MP-SPDZ,&quot; 2019, <a href="https://github.com/n1analytics/MP-SPDZ" target="_blank" rel="noopener noreferrer">https://github.com/n1analytics/MP-SPDZ.</a></p></li>
      <li><p class="text-gray-300">[8] B. Applebaum, N. Haramaty, Y. Ishai, E. Kushilevitz, and V. Vaikuntanathan, &quot;Low-Complexity Cryptographic Hash Functions,&quot; in <em>8th Innovations in Theoretical Computer Science Conference &ndash; ITCS 2017</em>, ser. LIPIcs, vol. 67. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2017, pp. 7:1&ndash;7:31.</p></li>
      <li><p class="text-gray-300">[9] B. Applebaum, Y. Ishai, and E. Kushilevitz, &quot;Cryptography in NC0,&quot; <em>SIAM J. Comput.</em>, vol. 36, no. 4, pp. 845&ndash;888, 2006.</p></li>
      <li><p class="text-gray-300">[10] D. W. Archer, D. Bogdanov, L. Kamm, Y. Lindell, K. Nielsen, J. I. Pagter, N. P. Smart, and R. N. Wright, &quot;From keys to databases &ndash; real-world applications of secure multi-party computation,&quot; Cryptology ePrint Archive, Report 2018/450, 2018, <a href="https://eprint.iacr.org/2018/450" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/450.</a></p></li>
      <li><p class="text-gray-300">[11] J.-P. Aumasson and W. Meier, &quot;Zero-sum distinguishers for reduced Keccak-f and for the core functions of Luffa and Hamsi,&quot; 2009, presented at the Rump Session of Cryptographic Hardware and Embedded Systems - CHES 2009, <a href="https://131002.net/data/papers/AM09.pdf" target="_blank" rel="noopener noreferrer">https://131002.net/</a> <a href="https://131002.net/data/papers/AM09.pdf" target="_blank" rel="noopener noreferrer">data/papers/AM09.pdf.</a></p></li>
      <li><p class="text-gray-300">[12] M. Bardet, J. Faugere, B. Salvy, and B. Yang, &quot;Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems,&quot; in <em>The Effective Methods in Algebraic Geometry Conference (MEGA)</em>, 2005, pp. 1&ndash;14.</p></li>
      <li><p class="text-gray-300">[13] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza, &quot;Zerocash: Decentralized anonymous payments from bitcoin,&quot; in <em>2014 IEEE Symposium on Security and Privacy</em>. IEEE Computer Society Press, May 2014, pp. 459&ndash;474.</p></li>
      <li><p class="text-gray-300">[14] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza, &quot;SNARKs for C: Verifying program executions succinctly and in zero knowledge,&quot; in <em>CRYPTO 2013, Part II</em>, ser. LNCS, R. Canetti and J. A. Garay, Eds., vol. 8043. Springer, Heidelberg, Aug. 2013, pp. 90&ndash;108.</p></li>
      <li><p class="text-gray-300">[15] R. Bendlin, I. Damg&aring;rd, C. Orlandi, and S. Zakarias, &quot;Semi-homomorphic encryption and multiparty computation,&quot; in <em>EUROCRYPT 2011</em>, ser. LNCS, K. G. Paterson, Ed., vol. 6632. Springer, Heidelberg, May 2011, pp. 169&ndash;188.</p></li>
      <li><p class="text-gray-300">[16] G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche, &quot;Note on zero-sum distinguishers of Keccak-f,&quot; <a href="http://keccak.noekeon.org/NoteZeroSum.pdf" target="_blank" rel="noopener noreferrer">http://keccak.noekeon.org/NoteZeroSum.pdf.</a></p></li>
      <li><p class="text-gray-300">[17] &mdash;&mdash;, &quot;On the indifferentiability of the sponge construction,&quot; in <em>EUROCRYPT 2008</em>, ser. LNCS, N. P. Smart, Ed., vol. 4965. Springer, Heidelberg, Apr. 2008, pp. 181&ndash;197.</p></li>
      <li><p class="text-gray-300">[18] L. Bettale, J.-C. Faugere, and L. Perret, &quot;Hybrid approach for solving multivariate systems over finite fields,&quot; <em>Journal of Mathematical Cryptology</em>, vol. 3, no. 3, pp. 177&ndash;197, 2009.</p></li>
      <li><p class="text-gray-300">[19] L. Bettale, J. Faug&egrave;re, and L. Perret, &quot;Solving polynomial systems over finite fields: improved analysis of the hybrid approach,&quot; in <em>International Symposium on Symbolic and Algebraic Computation, ISSAC'12</em>. ACM, 2012, pp. 67&ndash;74.</p></li>
      <li><p class="text-gray-300">[20] E. Biham, R. Anderson, and L. Knudsen, &quot;Serpent: A new block cipher proposal,&quot; in <em>FSE 1998</em>, 1998, pp. 222&ndash;238.</p></li>
      <li><p class="text-gray-300">[21] E. Biham, A. Biryukov, and A. Shamir, &quot;Cryptanalysis of Skipjack reduced to 31 rounds using impossible differentials,&quot; in <em>EUROCRYPT'99</em>, ser. LNCS, J. Stern, Ed., vol. 1592. Springer, Heidelberg, May 1999, pp. 12&ndash;23.</p></li>
      <li><p class="text-gray-300">[22] D. Bogdanov, S. Laur, and J. Willemson, &quot;Sharemind: A framework for fast privacypreserving computations,&quot; in <em>ESORICS 2008</em>, ser. LNCS, S. Jajodia and J. L&oacute;pez, Eds., vol. 5283. Springer, Heidelberg, Oct. 2008, pp. 192&ndash;206.</p></li>
      <li><p class="text-gray-300">[23] D. Boneh, S. Eskandarian, and B. Fisch, &quot;Post-quantum group signatures from symmetric primitives,&quot; <em>IACR Cryptology ePrint Archive</em>, vol. 2018, p. 261, 2018.</p></li>
      <li><p class="text-gray-300">[24] D. Boneh, Y. Ishai, A. Passel&egrave;gue, A. Sahai, and D. J. Wu, &quot;Exploring crypto dark matter,&quot; in <em>Theory of Cryptography Conference</em>. Springer, 2018, pp. 699&ndash;729.</p></li>
      <li><p class="text-gray-300">[25] C. Boura and A. Canteaut, &quot;A zero-sum property for the keccak-f permutation with 18 rounds,&quot; in <em>ISIT</em>. IEEE, 2010, pp. 2488&ndash;2492.</p></li>
      <li><p class="text-gray-300">[26] C. Boura, A. Canteaut, and C. D. Canni&egrave;re, &quot;Higher-Order Differential Properties of Keccak and <em>Luffa</em>,&quot; in <em>Fast Software Encryption - FSE 2011</em>, ser. LNCS, vol. 6733. Springer, 2011, pp. 252&ndash;269.</p></li>
      <li><p class="text-gray-300">[27] C. Boura, M. Naya-Plasencia, and V. Suder, &quot;Scrutinizing and improving impossible differential attacks: Applications to CLEFIA, Camellia, LBlock and Simon,&quot; in <em>ASIACRYPT 2014, Part I</em>, ser. LNCS, P. Sarkar and T. Iwata, Eds., vol. 8873. Springer, Heidelberg, Dec. 2014, pp. 179&ndash;199.</p></li>
      <li><p class="text-gray-300">[28] J. Boyar, R. Peralta, and D. Pochuev, &quot;On the multiplicative complexity of Boolean functions over the basis (cap, +, 1),&quot; <em>Theor. Comput. Sci.</em>, 2000.</p></li>
      <li><p class="text-gray-300">[29] A. Canteaut, S. Carpov, C. Fontaine, T. Lepoint, M. Naya-Plasencia, P. Paillier, and R. Sirdey, &quot;Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression,&quot; in <em>FSE 2016</em>, ser. LNCS, T. Peyrin, Ed., vol. 9783. Springer, Heidelberg, Mar. 2016, pp. 313&ndash;333.</p></li>
      <li><p class="text-gray-300">[30] V. Cauchois, C. Gomez, and G. Thomas, &quot;General diffusion analysis: How to find optimal permutations for generalized type-ii feistel schemes,&quot; <em>IACR Transactions on Symmetric Cryptology</em>, vol. 2019, no. 1, pp. 264&ndash;301, Mar. 2019. [Online]. Available: <a href="https://tosc.iacr.org/index.php/ToSC/article/view/7404" target="_blank" rel="noopener noreferrer">https://tosc.iacr.org/index.php/ToSC/article/view/7404</a></p></li>
      <li><p class="text-gray-300">[31] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher, C. Rechberger, D. Slamanig, and G. Zaverucha, &quot;Post-quantum zero-knowledge and signatures from symmetric-key primitives,&quot; in <em>ACM CCS 17</em>, B. M. Thuraisingham, D. Evans, T. Malkin, and D. Xu, Eds. ACM Press, Oct. / Nov. 2017, pp. 1825&ndash;1842.</p></li>
      <li><p class="text-gray-300">[32] &mdash;&mdash;, &quot;The Picnic Signature Algorithm Specification,&quot; 2017, <a href="https://github.com/Microsoft/Picnic/blob/master/spec.pdf" target="_blank" rel="noopener noreferrer">https://github.com/</a> <a href="https://github.com/Microsoft/Picnic/blob/master/spec.pdf" target="_blank" rel="noopener noreferrer">Microsoft/Picnic/blob/master/spec.pdf.</a></p></li>
      <li><p class="text-gray-300">[33] A. M. Childs, W. van Dam, S. Hung, and I. E. Shparlinski, &quot;Optimal quantum algorithm for polynomial interpolation,&quot; in <em>ICALP</em>, ser. LIPIcs, vol. 55. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2016, pp. 16:1&ndash;16:13.</p></li>
      <li><p class="text-gray-300">[34] D. A. Cox, J. Little, and D. O'Shea, <em>Ideals, varieties, and algorithms - an introduction to computational algebraic geometry and commutative algebra (2. ed.)</em>, ser. Undergraduate texts in mathematics. Springer, 1997.</p></li>
      <li><p class="text-gray-300">[35] J. Daemen, M. Peeters, G. Van Assche, and V. Rijmen, &quot;Nessie Proposal: NOEKEON,&quot; 2000, <a href="http://gro.noekeon.org/Noekeon-spec.pdf" target="_blank" rel="noopener noreferrer">http://gro.noekeon.org/Noekeon-spec.pdf.</a></p></li>
      <li><p class="text-gray-300">[36] I. Damg&aring;rd, M. Geisler, M. Kr&oslash;igaard, and J. B. Nielsen, &quot;Asynchronous multiparty computation: Theory and implementation,&quot; in <em>PKC 2009</em>, ser. LNCS, S. Jarecki and G. Tsudik, Eds., vol. 5443. Springer, Heidelberg, Mar. 2009, pp. 160&ndash;179.</p></li>
      <li><p class="text-gray-300">[37] I. Damg&aring;rd, V. Pastro, N. P. Smart, and S. Zakarias, &quot;Multiparty computation from somewhat homomorphic encryption,&quot; in <em>CRYPTO 2012</em>, ser. LNCS, R. Safavi-Naini and R. Canetti, Eds., vol. 7417. Springer, Heidelberg, Aug. 2012, pp. 643&ndash;662.</p></li>
      <li><p class="text-gray-300">[38] D. Derler, S. Ramacher, and D. Slamanig, &quot;Generic double-authentication preventing signatures and a post-quantum instantiation,&quot; in <em>ProvSec 2018</em>, ser. LNCS, J. Baek, W. Susilo, and J. Kim, Eds., vol. 11192. Springer, Heidelberg, Oct. 2018, pp. 258&ndash;276.</p></li>
      <li><p class="text-gray-300">[39] &mdash;&mdash;, &quot;Post-Quantum Zero-Knowledge Proofs for Accumulators with Applications to Ring Signatures from Symmetric-Key Primitives,&quot; in <em>Post-Quantum Cryptography &ndash; PQCrypto 2018</em>, ser. LNCS, vol. 10786. Springer, 2018, pp. 419&ndash;440.</p></li>
      <li><p class="text-gray-300">[40] I. Dinur, D. Kales, A. Promitzer, S. Ramacher, and C. Rechberger, &quot;Linear equivalence of block ciphers with partial non-linear layers: Application to lowmc,&quot; in <em>EUROCRYPT</em>, 2019, (accepted).</p></li>
      <li><p class="text-gray-300">[41] X. Dong, Z. Li, and X. Wang, &quot;Quantum cryptanalysis on some generalized Feistel schemes,&quot; Cryptology ePrint Archive, Report 2017/1249, 2017, <a href="https://eprint.iacr.org/2017/1249" target="_blank" rel="noopener noreferrer">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2017/1249" target="_blank" rel="noopener noreferrer">org/2017/1249.</a></p></li>
      <li><p class="text-gray-300">[42] Y. Dor&ouml;z, A. Shahverdi, T. Eisenbarth, and B. Sunar, &quot;Toward practical homomorphic evaluation of block ciphers using prince,&quot; in <em>FC 2014 Workshops</em>, ser. LNCS, R. B&ouml;hme, M. Brenner, T. Moore, and M. Smith, Eds., vol. 8438. Springer, Heidelberg, Mar. 2014, pp. 208&ndash;220.</p></li>
      <li><p class="text-gray-300">[43] M. Duan and X. Lai, &quot;Improved zero-sum distinguisher for full round Keccak-f permutation,&quot; <em>Chinese Science Bulletin</em>, vol. 57, no. 6, pp. 694&ndash;697, 2012.</p></li>
      <li><p class="text-gray-300">[44] &mdash;&mdash;, &quot;Improved zero-sum distinguisher for full round Keccak-<em>f</em> permutation,&quot; <em>Chinese Science Bulletin</em>, vol. 57, no. 6, pp. 694&ndash;697, 2012.</p></li>
      <li><p class="text-gray-300">[45] L. Grassi, C. Rechberger, D. Rotaru, P. Scholl, and N. P. Smart, &quot;MPC-friendly symmetric key primitives,&quot; in <em>ACM CCS 16</em>, E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. Myers, and S. Halevi, Eds. ACM Press, Oct. 2016, pp. 430&ndash;443.</p></li>
      <li><p class="text-gray-300">[46] V. Grosso, G. Leurent, F.-X. Standaert, and K. Varici, &quot;LS-designs: Bitslice encryption for efficient masked software implementations,&quot; in <em>FSE 2014</em>, ser. LNCS, C. Cid and C. Rechberger, Eds., vol. 8540. Springer, Heidelberg, Mar. 2015, pp. 18&ndash;37.</p></li>
      <li><p class="text-gray-300">[47] J. Guo, J. Jean, I. Nikolic, and Y. Sasaki, &quot;Meet-in-the-middle attacks on classes of contracting and expanding Feistel constructions,&quot; <em>IACR Trans. Symm. Cryptol.</em>, vol. 2016, no. 2, pp. 307&ndash;337, 2016, <a href="http://tosc.iacr.org/index.php/ToSC/article/view/576" target="_blank" rel="noopener noreferrer">http://tosc.iacr.org/index.php/ToSC/article/view/576.</a></p></li>
      <li><p class="text-gray-300">[48] D. Hankerson, A. J. Menezes, and S. Vanstone, <em>Guide to Elliptic Curve Cryptography</em>. Secaucus, NJ, USA: Springer-Verlag New York, Inc., 2003.</p></li>
      <li><p class="text-gray-300">[49] T. Jakobsen and L. R. Knudsen, &quot;The interpolation attack on block ciphers,&quot; in <em>FSE'97</em>, ser. LNCS, E. Biham, Ed., vol. 1267. Springer, Heidelberg, Jan. 1997, pp. 28&ndash;40.</p></li>
      <li><p class="text-gray-300">[50] J. Katz, V. Kolesnikov, and X. Wang, &quot;Improved non-interactive zero knowledge with applications to post-quantum signatures,&quot; in <em>ACM CCS 18</em>, D. Lie, M. Mannan, M. Backes, and X. Wang, Eds. ACM Press, Oct. 2018, pp. 525&ndash;537.</p></li>
      <li><p class="text-gray-300">[51] M. Keller, V. Pastro, and D. Rotaru, &quot;Overdrive: Making SPDZ Great Again,&quot; in <em>Advances in Cryptology &ndash; EUROCRYPT 2018</em>, ser. LNCS, vol. 10822. Springer, 2018, pp. 158&ndash;189.</p></li>
      <li><p class="text-gray-300">[52] M. Keller, P. Scholl, and N. P. Smart, &quot;An architecture for practical actively secure MPC with dishonest majority,&quot; in <em>ACM CCS 13</em>, A.-R. Sadeghi, V. D. Gligor, and M. Yung, Eds. ACM Press, Nov. 2013, pp. 549&ndash;560.</p></li>
      <li><p class="text-gray-300">[53] L. R. Knudsen, &quot;Truncated and higher order differentials,&quot; in <em>FSE'94</em>, ser. LNCS, B. Preneel, Ed., vol. 1008. Springer, Heidelberg, Dec. 1995, pp. 196&ndash;211.</p></li>
      <li><p class="text-gray-300">[54] &mdash;&mdash;, &quot;DEAL - A 128-bit Block Cipher,&quot; <em>Technical Report, Department of Informatics, Bergen, Norway</em>, 1998.</p></li>
      <li><p class="text-gray-300">[55] L. R. Knudsen and M. J. B. Robshaw, <em>The Block Cipher Companion</em>. Springer Publishing Company, Incorporated, 2011.</p></li>
      <li><p class="text-gray-300">[56] M. Matsui, &quot;Linear cryptanalysis method for DES cipher,&quot; in <em>EUROCRYPT'93</em>, ser. LNCS, T. Helleseth, Ed., vol. 765. Springer, Heidelberg, May 1994, pp. 386&ndash;397.</p></li>
      <li><p class="text-gray-300">[57] P. M&eacute;aux, A. Journault, F.-X. Standaert, and C. Carlet, &quot;Towards stream ciphers for efficient FHE with low-noise ciphertexts,&quot; in <em>EUROCRYPT 2016, Part I</em>, ser. LNCS, M. Fischlin and J.-S. Coron, Eds., vol. 9665. Springer, Heidelberg, May 2016, pp. 311&ndash;343.</p></li>
      <li><p class="text-gray-300">[58] N. E. Mrabet and M. Joye, <em>Guide to Pairing-Based Cryptography</em>. Chapman &amp; Hall/CRC, 2016.</p></li>
      <li><p class="text-gray-300">[59] M. Naehrig, K. E. Lauter, and V. Vaikuntanathan, &quot;Can homomorphic encryption be practical?&quot; in <em>Proceedings of the 3rd ACM Cloud Computing Security Workshop, CCSW 2011</em>, 2011, pp. 113&ndash;124.</p></li>
      <li><p class="text-gray-300">[60] K. Nyberg, &quot;Generalized Feistel networks,&quot; in <em>ASIACRYPT'96</em>, ser. LNCS, K. Kim and T. Matsumoto, Eds., vol. 1163. Springer, Heidelberg, Nov. 1996, pp. 91&ndash;104.</p></li>
      <li><p class="text-gray-300">[61] K. Nyberg and L. R. Knudsen, &quot;Provable Security Against Differential Cryptanalysis,&quot; in <em>Advances in Cryptology - CRYPTO 1992</em>, ser. LNCS, vol. 740. Springer, 1992, pp. 566&ndash;574.</p></li>
      <li><p class="text-gray-300">[62] &mdash;&mdash;, &quot;Provable security against a differential attack,&quot; <em>Journal of Cryptology</em>, vol. 8, no. 1, pp. 27&ndash;37, Dec. 1995.</p></li>
      <li><p class="text-gray-300">[63] I. S. M. S. Overview., <a href="https://gist.github.com/maxvt/bb49a6c7243163b8120625fc8ae3f3cd" target="_blank" rel="noopener noreferrer">&quot;https://gist.github.com/maxvt/</a> <a href="https://gist.github.com/maxvt/bb49a6c7243163b8120625fc8ae3f3cd" target="_blank" rel="noopener noreferrer">bb49a6c7243163b8120625fc8ae3f3cd.</a>&quot;</p></li>
      <li><p class="text-gray-300">[64] Partisia, <a href="https://partisia.com/" target="_blank" rel="noopener noreferrer">&quot;https://partisia.com/.&quot;</a></p></li>
      <li><p class="text-gray-300">[65] J. Patarin, V. Nachef, and C. Berbain, &quot;Generic attacks on unbalanced Feistel schemes with contracting functions,&quot; in <em>ASIACRYPT 2006</em>, ser. LNCS, X. Lai and K. Chen, Eds., vol. 4284. Springer, Heidelberg, Dec. 2006, pp. 396&ndash;411.</p></li>
      <li><p class="text-gray-300">[66] K. Qiao, L. Song, M. Liu, and J. Guo, &quot;New Collision Attacks on Round-Reduced Keccak,&quot; in <em>Advances in Cryptology &ndash; EUROCRYPT 2017</em>, ser. LNCS, vol. 10212, 2017, pp. 216&ndash;243.</p></li>
      <li><p class="text-gray-300">[67] D. Rotaru, N. P. Smart, and M. Stam, &quot;Modes of operation suitable for computing on encrypted data,&quot; <em>IACR Trans. Symm. Cryptol.</em>, vol. 2017, no. 3, pp. 294&ndash;324, 2017.</p></li>
      <li><p class="text-gray-300">[68] R. Safavi-Naini and R. Canetti, Eds., <em>CRYPTO 2012</em>, ser. LNCS, vol. 7417. Springer, Heidelberg, Aug. 2012.</p></li>
      <li><p class="text-gray-300">[69] M. Scott, &quot;Optimal irreducible polynomials for GF(2<em><sup>m</sup></em>) arithmetic,&quot; Cryptology ePrint Archive, Report 2007/192, 2007, <a href="http://eprint.iacr.org/2007/192" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2007/192.</a></p></li>
      <li><p class="text-gray-300">[70] Sepior, <a href="https://sepior.com/" target="_blank" rel="noopener noreferrer">&quot;https://sepior.com/.</a>&quot;</p></li>
      <li><p class="text-gray-300">[71] V. Shoup, &quot;Number Theory Library 5.5.2 (NTL),&quot; <a href="http://www.shoup.net/ntl/" target="_blank" rel="noopener noreferrer">http://www.shoup.net/ntl/.</a></p></li>
      <li><p class="text-gray-300">[72] J. A. Solinas, &quot;Generalized mersenne numbers,&quot; NSA, Tech. Rep., 1999.</p></li>
      <li><p class="text-gray-300">[73] W. Stein <em>et al.</em>, <em>Sage Mathematics Software Version 8.0</em>, The Sage Development Team, 2017, <a href="http://www.sagemath.org" target="_blank" rel="noopener noreferrer">http://www.sagemath.org.</a></p></li>
      <li><p class="text-gray-300">[74] T. Suzaki and K. Minematsu, &quot;Improving the generalized Feistel,&quot; in <em>FSE 2010</em>, ser. LNCS, S. Hong and T. Iwata, Eds., vol. 6147. Springer, Heidelberg, Feb. 2010, pp. 19&ndash;39.</p></li>
      <li><p class="text-gray-300">[75] T. Suzaki, K. Minematsu, S. Morioka, and E. Kobayashi, &quot;twine : A lightweight block cipher for multiple platforms,&quot; in <em>SAC 2012</em>, ser. LNCS, L. R. Knudsen and H. Wu, Eds., vol. 7707. Springer, Heidelberg, Aug. 2013, pp. 339&ndash;354.</p></li>
      <li><p class="text-gray-300">[76] Y. Todo, &quot;Structural Evaluation by Generalized Integral Property,&quot; in <em>Advances in Cryptology - EUROCRYPT 2015</em>, ser. LNCS, vol. 9056. Springer, 2015, pp. 287&ndash;314.</p></li>
      <li><p class="text-gray-300">[77] Unbound, <a href="https://www.unboundtech.com/" target="_blank" rel="noopener noreferrer">&quot;https://www.unboundtech.com/.&quot;</a></p></li>
      <li><p class="text-gray-300">[78] Q. Wang, L. Grassi, and C. Rechberger, &quot;Zero-Sum Partitions of PHOTON Permutations,&quot; in <em>Topics in Cryptology - CT-RSA 2018</em>, ser. LNCS, vol. 10808, 2018, pp. 279&ndash;299.</p></li>
    </ul>

    <h2 id="sec-misc-2" class="text-2xl font-bold"><strong>Appendices</strong></h2>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>A Variants of the GMiMC family of ciphers</strong></h2>

    <p class="text-gray-300">In this section, we briefly discuss different variants of GMiMC and we also explain some possible choices of the round function. Since the analysis is very similar to the one proposed in <a href="#page-31-3">[4]</a>, we refer to that paper for all the details and we limit ourselves here to recall the main points.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8"><strong>A.1 A Permutation Round Function</strong></h3>

    <p class="text-gray-300">The four GMiMC ciphers proposed in this paper are all based on the Feistel construction. As is well known, a Feistel construction has the nice property that decryption can easily be realized by using the encryption function with reversed order of round constants and subkeys. In other words, the same round functions are used for both encryption and decryption, that is, it is not necessary that the round function is a permutation. On the other hand, we have chosen to deal with a permutation round function in order to prevent attacks due to internal collisions.</p>

    <p class="text-gray-300">For example, because of internal collisions in the round function, a truncated trail with only one active branch per round would be possible. This would be particularly undesirable in GMiMCerf. Indeed, the difference in a given branch may propagate to the others only every <em>t</em> rounds. If this difference hits an inner collision of the round function, the attacker can extend their trail by another <em>t</em> &minus; 1 rounds for free.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8"><strong>A.2 Different Round Functions</strong></h3>

    <p class="text-gray-300">As for MiMC and considering the case F2<em><sup>n</sup></em> , one may also consider a round function of the form</p>

    <p class="text-gray-300"><span class="math">$F(x) = (x \\oplus k \\oplus c)^d</span>$</p>

    <p class="text-gray-300">for generic exponents <em>d</em>.</p>

    <p class="text-gray-300">First of all, we recall that <em>d</em> must be different from a power of 2 in order to introduce non-linearity in the cipher<a href="#page-37-2">20</a>. Referring to the analysis proposed in MiMC, the best choices for exponents <em>d</em> seem to be <em>d</em> = 2<em><sup>r</sup></em> &minus; 1 for integer <em>r</em>. It is simple to observe that the degree of the encryption function increases faster when <em>d</em> increases. It follows that the number of rounds can be reduced if one chooses <em>d &gt;</em> 3. On the other hand, since the number of multiplications for each round increases (one round requires approximately d<em>r/</em>2e multiplications to compute <em>x d</em> for <em>d</em> = 2<em><sup>r</sup></em> &minus; 1, as shown in detail in <a href="#page-31-3">[4]</a>), the total number of multiplications does not change. In conclusion, the choice of an exponent of the form 2 <em><sup>r</sup></em> &minus; 1 different from 3 seems not to offer any advantage.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B Diffusion in GMiMCmrf</strong></h2>

    <p class="text-gray-300">In this section, we investigate the diffusion provided by GMiMCmrf. Diffusion is very fast in such a structure &mdash; much like in a GFN with a complex branch permutation as investigated in <a href="#page-35-4">[74]</a> and used for example to build the lightweight block cipher Twine <a href="#page-35-5">[75]</a>. In particular, the number of rounds needed to achieve full diffusion increases with the logarithm of the number of branches rather than linearly, as would be the case if a constant rotation were used.</p>

    <p class="text-gray-300">In this section, we prove that the number of rounds needed to achieve full diffusion for a <em>t</em>-branch Multi-Rotating Feistel network is equal to 2 log<sup>2</sup> <em>t</em> &minus; 1, i.e., we prove Theorem <a href="#page-6-2">1.</a></p>

    <p class="text-gray-300"><sup>20</sup>Remember that the square operation is linear in each field F2<em><sup>n</sup></em> .</p>

    <p class="text-gray-300">We use slightly different notations in this part. The internal state is denoted by  <span class="math">V_j^i</span>  for  <span class="math">0 \\le j &lt; t/2</span>  and for  <span class="math">-1 \\le i</span> , where  <span class="math">V^i</span>  corresponds to the words that are input to the non-linear part of the round function in round i. The plaintext therefore consists of  <span class="math">V^0||V^{-1} = V_0^0||...||V_{t/2-1}^0||V_0^{-1}||...||V_{t/2-1}^{-1}</span> , the input of round i is  <span class="math">V^i||V^{i-1}</span> , and the output of round i is  <span class="math">V^{i+1}||V^i</span> . This is summarized in Figure 9.</p>

    <p class="text-gray-300">    <img src="_page_38_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 9: The notations used to study the Multi-Rotating Feistel network.</p>

    <p class="text-gray-300">It is easy to track the propagation of  <span class="math">V_0^0</span>  and  <span class="math">V_0^{-1}</span>  throughout the rounds. In Figure 10a, we show the subsets  <span class="math">I^i</span>  of  <span class="math">\\{0,...,t/2-1\\}</span>  which correspond to the indices j such that  <span class="math">V_j^i</span>  depends on  <span class="math">V_0^0</span> . Note that  <span class="math">I^i</span>  can be obtained via the simple induction</p>

    <p class="text-gray-300"><span class="math">$I^{i+1} = I^{i-1} \\cup (s_i + I^i)</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">s_i + I^i</span>  is the set obtained by adding  <span class="math">s_i</span>  (modulo t/2) to all elements in  <span class="math">I^i</span> . In Figure 10b, we show the same quantity except that we consider words which depend on  <span class="math">V_0^{-1}</span>  rather than  <span class="math">V_0^0</span> .</p>

    <p class="text-gray-300">Using the expression of  <span class="math">s_i</span> , we deduce that  <span class="math">I^{2\\ell+1} = I^{2\\ell-1} \\cup (2^\\ell + I^{2\\ell})</span> , which we rewrite using that  <span class="math">I^{2\\ell} = I^{2\\ell-2} \\cup (0 + I^{2\\ell-1})</span>  to obtain</p>

    <p class="text-gray-300"><span class="math">$I^{2i+1} = I^{2\\ell-1} \\cup (2^{\\ell} + (I^{2\\ell-2} \\cup I^{2\\ell-1})) \\subseteq I^{2\\ell-1} \\cup (2^{\\ell} + I^{2\\ell-1})</span>$
.</p>

    <p class="text-gray-300">As a consequence, if  <span class="math">j \\in I^{2\\ell-1}</span> , then both j and  <span class="math">j+2^\\ell</span>  are in  <span class="math">I^{2\\ell+1}</span> . A simple induction shows that if  <span class="math">j \\in I^1</span> , then  <span class="math">I^{2\\lceil \\log(t/2) \\rceil+1}</span>  contains  <span class="math">j+\\sum_{i=0}^{\\lceil \\log(t/2) \\rceil} \\alpha_i 2^i</span>  for all binary sequences  <span class="math">\\{\\alpha_i\\}_{0 \\geq i}</span> . Thus, all elements of  <span class="math">\\{0,...,t/2-1\\}</span>  are in  <span class="math">I^{2\\lceil \\log(t/2) \\rceil+1}</span> . The same argument holds if the sets  <span class="math">I^i</span>  track the propagation of  <span class="math">V_0^{-1}</span>  instead.</p>

    <p class="text-gray-300">As a consequence,  <span class="math">2\\lceil \\log(t/2) \\rceil + 2 = 2\\lceil \\log_2(t) \\rceil</span>  rounds provide full diffusion.</p>

    <p class="text-gray-300">Note that this argument does not actually require that  <span class="math">s_{2\\ell+1} = 2^{\\ell} \\mod \\lceil \\log_2(t/2) \\rceil</span> , merely that the exponents of the non-zero rotation amounts are all distinct in each subsequence of length  <span class="math">2\\lceil \\log_2(t/2) \\rceil</span> . This is the case when these exponents are incremented one by one (as in our construction), but it is also the case if they are decremented one by one instead. This last situation is equivalent to running our Multi-Rotating Feistel network structure backwards, meaning that its inverse has the same diffusion properties.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Security Analysis</h2>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8">C.1 Interpolation Attack</h3>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub>. Working as in Sect. 4.1.3, the minimum degree of the output polynomials for each branch is lower bounded by  <span class="math">3^{r-(t-1)}</span>  (after  <span class="math">r \\ge t</span>  rounds). Due to the argumentation proposed in Sect. 4.1.3, GMiMC<sub>erf</sub> is secure against interpolation attack if</p>

    <p class="text-gray-300"><span class="math">$(3^{r-(t-1)})^t \\approx 2^N \\simeq p^t.</span>$</p>

    <p class="text-gray-300">Hence,  <span class="math">r \\approx \\frac{\\log_2(p)}{\\log_2 3} + (t-1)</span>  rounds will be secure against the above-mentioned attacks. Conservatively, 2r+2 rounds will be secure against meet-in-the-middle attacks/distinguishers for the case  <span class="math">2^\\kappa \\simeq p</span> , while 2r+t+1 rounds will be secure against meet-in-the-middle attacks/distinguishers for the case  <span class="math">2^\\kappa \\simeq p^t</span> .</p>

    <p class="text-gray-300">    <img src="_page_39_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 10: Diffusion in GMiMC<sub>mrf</sub>.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>Nyb</sub>. Let  <span class="math">t=2\\cdot t&#x27;</span> . We use a set of (plaintext, ciphertext) pairs to do the interpolation analysis. Working as before, after r&gt;2 rounds, the minimum degree of the output polynomials will be  <span class="math">3^{r-1}=d_j</span>  for some branch j (even j). In order to get the maximum degree  <span class="math">3^{r-1}=p</span> , the number of rounds must satisfy  <span class="math">r\\approx\\frac{\\log_2(p)}{\\log_23}+1</span> . For securing the cipher against MITM-type attacks/distinguishers, we use 2r rounds. Finally, we add t rounds to provide full diffusion and avoid key-guessing.</p>

    <p class="text-gray-300">In the case  <span class="math">2^{\\kappa} = p^t</span> , we have to add 1 more round in order to prevent the combination of the interpolation attack and the brute-force one.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>mrf</sub>. As explained in Appendix B, after  <span class="math">r=1+\\Lambda\\left(t\\right)+\\lceil\\log_{2}(p)/\\log_{2}(3)\\rceil</span>  rounds, all output branches have a maximum degree in all input branches and all key words. Thus, as for n-bit security, using  <span class="math">R=2r=2+2\\Lambda\\left(t\\right)+2\\lceil\\log_{2}(p)/\\log_{2}(3)\\rceil</span>  rounds is sufficient for GMiMC<sub>mrf</sub> to provide  <span class="math">\\log_{2}(p)</span>  bits of security against interpolation attacks.</p>

    <p class="text-gray-300">In the case  <span class="math">2^{\\kappa} = p^t</span> , we have to add 1 more round in order to prevent the combination of the interpolation attack and the brute-force one.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Higher-Order Differential in <span class="math">\\mathbb{F}_p</span></h3>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub>. Using the same analysis proposed in Sect. 4.1.4 and due to the analysis proposed in App. C.1, the minimum degree of GMiMC<sub>erf</sub> after r &gt; t rounds is (at least)  <span class="math">3^{r-t}</span> . The condition  <span class="math">3^{r-t} \\ge t</span>  is satisfied by  <span class="math">r \\ge t + \\log_3(t)</span> . In order to avoid distinguishers on GMiMCHash, we simply double this number of rounds. Finally, we add 2 rounds in order to avoid key-guessing attack for the univariate case and t+1 rounds for the multivariate case.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>Nyb</sub>. Using the same analysis proposed in Sect. 4.1.4 and due to the analysis proposed in App. C.1, the minimum degree of GMiMC<sub>Nyb</sub> after r &gt; t rounds is (at least)  <span class="math">3^{r-1}</span> . The condition  <span class="math">3^{r-1} \\ge t</span>  is satisfied by  <span class="math">r \\ge 1 + \\log_3(t)</span> . In order to avoid distinguishers on GMiMCHash, we simply double this number of rounds. Finally, we add t rounds in order to avoid key-guessing attack for the univariate case and in order to provide full diffusion. One more round is added for the multivariate case.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>mrf</sub>. Using the same analysis proposed in Sect. 4.1.4 and due to the analysis proposed in App. C.1, the minimum degree of GMiMC<sub>erf</sub> after  <span class="math">r &gt; \\Lambda(t)</span>  rounds is (at least)  <span class="math">3^{r-\\Lambda(t)}</span> . The condition  <span class="math">3^{r-\\Lambda(t)} \\ge t</span>  is satisfied by  <span class="math">r \\ge \\Lambda(t) + \\log_3(t)</span> . In order to avoid distinguishers on GMiMCHash, we simply double this number of rounds. Finally, we add 2 rounds in order to avoid key-guessing attack for the univariate case and 3 rounds for the multivariate case.</p>

      <h3 id="app-c.3" class="text-xl font-semibold mt-8">C.3 Gr&ouml;bner Basis Analysis</h3>

    <p class="text-gray-300">To prevent the Gr&ouml;bner basis attack, the minimum number of rounds r must satisfy</p>

    <p class="text-gray-300"><span class="math">$2^{\\kappa \\, n} \\cdot \\binom{t-\\kappa+d-1}{d-1}^{\\omega} \\ge 2^{t \\, n}</span>$</p>

    <p class="text-gray-300">for all  <span class="math">\\kappa \\in \\{0, \\dots, t-2\\}</span>  and where the degree d is a function of the number of rounds r, that is, d = d(r). For our parameter choices, this expression is minimized for  <span class="math">\\kappa = 0</span> .</p>

    <p class="text-gray-300">As explained in the main text, in the following we limit ourselves to consider only the case  <span class="math">2^{\\kappa} = p^t</span>  (for the case  <span class="math">2^{\\kappa} = p</span> , the Gr&ouml;bner basis attack is equivalent to a GCD attack).</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub>. After  <span class="math">r \\geq t</span>  rounds<sup>21</sup>, the minimum degree of a variable in the output polynomials is  <span class="math">3^{r-t}</span> .</p>

    <p class="text-gray-300">To prevent the Gr&ouml;bner basis attack, we require</p>

    <p class="text-gray-300"><span class="math">$\\binom{t+d}{d}^{\\omega} = \\binom{t+3^{r-t}}{3^{r-t}}^{\\omega} \\approx p^t.</span>$</p>

    <p class="text-gray-300">Using Stirling's approximation of the binomial when  <span class="math">t \\ll d</span> , we approximate  <span class="math">\\binom{t+d}{d}</span>  by  <span class="math">(d/t)^t = 2^{t \\log_2(d/t)}</span>  and, setting  <span class="math">\\omega := 2</span> , obtain</p>

    <p class="text-gray-300"><span class="math">$2t \\log_2(d/t) = 2t \\log_2(3^{r-t}/t) \\approx \\log_2(p) \\cdot t \\text{ or } r = [t + 1/2 \\log_2(p) \\cdot \\log_3 2 + \\log_3 t].</span>$</p>

    <p class="text-gray-300">Due to the same argumentation given in Section C.4, this number of rounds must be incremented by a factor of t-3, that is, the minimum number of rounds is approximately given by  <span class="math">r = \\lceil 2t + 1/2 \\log_2(p) \\cdot \\log_3 2 + \\log_3 t - 3 \\rceil</span> . To thwart Meet-in-the-Middle attacks, this value is doubled.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{GMiMC}_{\\mathsf{Nyb}}</span> . To prevent the Gr&ouml;bner basis attack, we require</p>

    <p class="text-gray-300"><span class="math">$\\binom{t+d}{d}^{\\omega} = \\binom{t+3^{r-1}}{3^{r-1}}^{\\omega} \\approx p^t.</span>$</p>

    <p class="text-gray-300">Using Stirling's approximation of the binomial when  <span class="math">t \\ll d</span> , we approximate  <span class="math">\\binom{t+d}{d}</span>  by  <span class="math">(d/t)^t = 2^{t \\log_2(d/t)}</span>  and, setting  <span class="math">\\omega := 2</span> , obtain</p>

    <p class="text-gray-300"><span class="math">$2t\\log_2(d/t) = 2t\\log_2(3^{r-1}/t) \\approx \\log_2(p) \\cdot t \\qquad \\text{ or } \\qquad r = \\left\\lceil 1 + \\frac{\\log_3 2}{2}\\log_2(p) + \\log_3 t \\right\\rceil.</span>$</p>

    <p class="text-gray-300">To thwart Meet-in-the-Middle attacks, this value is doubled. Moreover, t rounds are added to guarantee full diffusion.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;21</sup>For our goal, we do not need all the details regarding the degree for r &lt; t.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>mrf</sub>. The minimum degree of a variable  <span class="math">K_i</span>  (for some  <span class="math">0 \\le i \\le t - 1</span> ) in the output polynomials is  <span class="math">3^{r-\\Lambda(t)}</span>  after  <span class="math">r(&gt;\\Lambda(t))</span>  rounds (where we recall that the number of branches t is even).</p>

    <p class="text-gray-300">To prevent the Gr&ouml;bner basis attack, we require</p>

    <p class="text-gray-300"><span class="math">$\\binom{t+d}{d}^{\\omega} = \\binom{t+3^{r-\\Lambda(t)}}{3^{r-\\Lambda(t)}}^{\\omega} \\approx p^t.</span>$</p>

    <p class="text-gray-300">Using Stirling's approximation of the binomial when  <span class="math">t \\ll d</span> , we approximate  <span class="math">\\binom{t+d}{d}</span>  by  <span class="math">(d/t)^t = 2^{t \\log_2(d/t)}</span>  and, setting  <span class="math">\\omega := 2</span> , obtain</p>

    <p class="text-gray-300"><span class="math">$2t\\log_2(d/t) = 2t\\log_2(3^{r-\\Lambda(t)}/t) \\approx \\log_2(p) \\cdot t \\text{ or } r = \\left\\lceil \\Lambda\\left(t\\right) + \\frac{1}{2}\\log_2(p) \\cdot \\log_3 2 + \\log_3 t \\right\\rceil.</span>$</p>

    <p class="text-gray-300">To thwart Meet-in-the-Middle attacks, this value is doubled.</p>

      <h3 id="app-c.4" class="text-xl font-semibold mt-8">C.4 GCD Attacks in <span class="math">\\mathbb{F}_{2^n}</span> &ndash; Low-Data Scenario</h3>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub>. Case:  <span class="math">\\kappa = n</span> . The degree  <span class="math">d_i</span>  of  <span class="math">X_i</span>  for i = 0, ..., t-1 after r rounds is</p>

    <p class="text-gray-300"><span class="math">$d_i = \\begin{cases} 3^r &amp; \\text{if } r &gt; 0 \\text{ and } i \\neq t - 1, \\\\ 3^{r-1} &amp; \\text{if } r &gt; 1 \\text{ and } i = t - 1, \\\\ 0 &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">Note that  <span class="math">d_{t-1} = \\min_i d_i</span> . The condition  <span class="math">3^{r-1} \\log^2(3^{r-1}) \\approx 2^n</span>  is fulfilled when  <span class="math">r \\simeq 1 + n \\cdot \\log_3 2 - 2 \\log_3(n)</span> .</p>

    <p class="text-gray-300">Consideration. In order to compute the final number of rounds for GMiMC<sub>erf</sub>, one must take care of another attack. Let  <span class="math">X_i^r</span>  be the output of the <em>i</em>-th branch after r rounds. Assume  <span class="math">t \\geq 3</span>  and consider the output of two branches, e.g. the output of the branches in position 1 &mdash; denoted by  <span class="math">X_1^r</span>  &mdash; and 2 &mdash; denoted by  <span class="math">X_2^r</span> . By definition</p>

    <p class="text-gray-300"><span class="math">$X_i^r = X_{i-1}^{r-1} \\oplus (X_t^{r-1} \\oplus k \\oplus c)^3,</span>$</p>

    <p class="text-gray-300">where  <span class="math">i=1,2,\\,k</span>  is the secret key (remember that we are working in the case  <span class="math">\\kappa=n</span> ) and c is the round constant. Note that  <span class="math">X_j^s</span>  is a function of the key k, that is,  <span class="math">X_j^s=X_j^s(k)</span> . It is simple to observe that</p>

    <p class="text-gray-300"><span class="math">$X_1^r \\oplus X_2^r = X_0^{r-1} \\oplus (X_t^{r-1} \\oplus k \\oplus c)^3 \\oplus X_1^{r-1} \\oplus (X_t^{r-1} \\oplus k \\oplus c)^3 = X_0^{r-1} \\oplus X_1^{r-1},</span>$</p>

    <p class="text-gray-300">that is,  <span class="math">X_1^r \\oplus X_2^r</span>  is still a function of k, but the degree of such a function is lower than the degree of the functions that define  <span class="math">X_1^r</span>  and  <span class="math">X_2^r</span> .</p>

    <p class="text-gray-300">Moreover, observe that if GCD(f(k),g(k)) = GCD(h(k),g(k)), then also GCD(f(k),g(k)) = GCD(h(k),g(k)) = GCD(h(k),g(k)) = GCD(f(k)+h(k),g(k)). Thus, instead of computing the GCD between two (randomly chosen) outputs of GMiMC<sub>erf</sub>, the best choice for the attacker &mdash; due to previous considerations &mdash; is to compute  <span class="math">GCD(X_{t-1} \\oplus X_{t-2}, X_{t-2} \\oplus X_{t-3})</span> . To prevent this attack, it is sufficient to increment the number of rounds by t-3, that is,  <span class="math">r \\simeq t + n \\cdot \\log_3 2 - 2\\log_3(n) - 2</span> .</p>

    <p class="text-gray-300"><span class="math">$(X_{t-1}^{(j+1)}, X_{t-2}^{(j+1)}, \\dots, X_0^{(j+1)}) \\leftarrow (X_{t-2}^{(j)} + F_{t-2}(X_{t-1}^{(j)}), \\dots, X_0^{(j)} + F_0(X_{t-1}^{(j)}), X_{t-1}^{(j)}),</span>$</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{22}&lt;/sup&gt;</span>  For completeness, we mention another possible strategy to prevent this attack. Instead of incrementing the number of rounds, one possibility is to use a different constant for each branch of each round. In other words, consider GMiMC<sub>erf</sub> as defined in Section 2.1 for the case  <span class="math">\\kappa=n</span>  (a similar argument holds also for the case  <span class="math">\\kappa=t\\cdot n</span> ). The expanding round function (ERF) can be re-written as</p>

    <p class="text-gray-300">As a result, the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = \\left\\lceil 2n \\cdot \\log_3 2 - 4 \\cdot \\log_3(n) + 2t - 2 \\right\\rceil</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant<a href="#page-42-0">23</a> .</p>

    <p class="text-gray-300"><em>Case: &kappa;</em> = <em>t</em> &middot; <em>n.</em> The idea, once again, is simply to guess the first <em>t</em> &minus; 1 round keys (i.e., (<em>t</em> &minus; 1) &middot; <em>n</em> bits of the key) and to apply the (univariate) GCD attack described previously. Using the previous strategy, it turns out that the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = \\lceil 2n \\cdot \\log_3 2 - 4 \\cdot \\log_3(n) + 3t - 3 \\rceil</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant.</p>

    <p class="text-gray-300"><strong>GMiMCNyb.</strong> <em>Case: &kappa;</em> = <em>n.</em> Consider the <em>t</em>-branch case with <em>t</em> = 2 &middot; <em>t</em> 0 . Since we are working in the univariate case, all the functions <em>F<sup>i</sup></em> are equal, i.e., <em>F</em><sup>1</sup> = <em>F</em><sup>2</sup> = &middot; &middot; &middot; = <em>Ft</em>, and they all depend on the same key. The degree <em>d<sup>i</sup></em> of <em>X<sup>i</sup></em> for <em>i</em> = 0<em>, . . . , t</em> &minus; 1 after <em>r</em> &ge; 2 rounds is</p>

    <p class="text-gray-300"><span class="math">$d_i = \\begin{cases} 3^{r-1} &amp; \\text{if } i \\text{ even } (i \\mod 2 = 0) \\\\ 3^r &amp; \\text{if } i \\text{ odd } (i \\mod 2 = 1) \\end{cases}</span>$</p>

    <p class="text-gray-300">As a result, the minimum degree after <em>r</em> &ge; 2 rounds is 3 <em>r</em>&minus;1 . The condition 3 <em>r</em>&minus;1 log<sup>2</sup> (3<em>r</em>&minus;<sup>1</sup> ) &asymp; 2 <em><sup>n</sup></em> is fulfilled when <em>r</em> ' 1 + <em>n</em> &middot; log<sup>3</sup> 2 &minus; 2 log<sup>3</sup> (<em>n</em>). Thus, the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = [2 + t + 2n \\cdot \\log_3 2 - 4\\log_3(n)]</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant, and to avoid key-guessing attack (we actually add <em>t</em> rounds in order to guarantee full diffusion).</p>

    <p class="text-gray-300"><em>Case: &kappa;</em> = <em>t</em> &middot; <em>n.</em> Using the previous strategy and guessing the first <em>t</em> &minus; 1 round keys (which corresponds to skipping one round), it turns out that the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = \\left\\lceil 3 + t + 2n \\cdot \\log_3 2 - 4\\log_3(n) \\right\\rceil</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant.</p>

    <p class="text-gray-300"><strong>GMiMCmrf.</strong> <em>Case: &kappa;</em> = <em>n.</em> After &Lambda;(<em>t</em>) + 1 = 2dlog<sup>2</sup> (<em>t</em>)e + 1 rounds, each word in the internal state depends on all words in the input and on all words in the key &mdash; even if it has only one word. As a consequence, the degree in both input variables and key variables of each output branch is at least equal to 3 <em><sup>r</sup></em>&minus;(&Lambda;(<em>t</em>)+1), where <em>r</em> is the total number of rounds of the structure. As a consequence, to be sure that each branch has the highest degree in both input and key variables, it is necessary to keep iterating the (2&Lambda;(<em>t</em>) + 2) round Multi-Rotating Feistel network with rotation sequence <em>s</em> = {0<em>,</em> 1<em>,</em> 0<em>,</em> 2<em>,</em> 0<em>,</em> 4<em>, ...</em>} until</p>

    <p class="text-gray-300">where the round function is defined as</p>

    <p class="text-gray-300"><span class="math">$F_i(x) := (x + k + c_j)^3</span>$
, and</p>

    <p class="text-gray-300">where the random constants <em>c<sup>i</sup></em> are different for each branch.</p>

    <p class="text-gray-300">This strategy allows to prevent the given attack without increasing the number of rounds. On the other hand, since our final goal is to minimize the total number of multiplications, this strategy is less efficient than the one proposed in the main text. Indeed, let <em>r</em> <sup>0</sup> = 1 + <em>n</em> &middot; log<sup>3</sup> 2 &minus; 2 log<sup>3</sup> (<em>n</em>). The strategy proposed in the main text requires <em>r</em> <sup>0</sup> + (<em>t</em> &minus; 3) multiplications, while the one just given requires <em>r</em> 0 &middot; (<em>t</em> &minus; 1) multiplications, where <em>r</em> <sup>0</sup> + (<em>t</em> &minus; 3) <em>&lt; r</em><sup>0</sup> &middot; (<em>t</em> &minus; 1) for each <em>t</em> &ge; 3 (and <em>r</em> <sup>0</sup> &ge; 1).</p>

    <p class="text-gray-300"><sup>23</sup>We note that this attack crucially depends on separating monomials per round. In particular, if the degree of the target polynomial 2 <em><sup>n</sup></em>, then this condition does not hold as modular reductions modulo <em>x</em> 2 &minus; 1 happen.</p>

    <p class="text-gray-300"><span class="math">3^{r-\\Lambda(t)-1} \\ge 2^n-2</span> , which is true if  <span class="math">r &gt; \\left\\lceil \\frac{n}{\\log_2(3)} \\right\\rceil + \\Lambda(t) + 1 - 2\\log_3(n)</span> . To thwart the Meet-in-the-Middle variant:</p>

    <p class="text-gray-300"><span class="math">$r \\geq 2 \\left\\lceil \\frac{n}{\\log_2(3)} \\right\\rceil + 2 \\cdot \\Lambda(t) + 4 - 4 \\log_3(n).</span>$</p>

    <p class="text-gray-300">Case:  <span class="math">\\kappa = t \\cdot n</span> . Using the previous strategy and guessing the first t-1 round-keys (which corresponds to skipping one round), it turns out that the number of rounds must be approximately</p>

    <p class="text-gray-300"><span class="math">$r = 2 \\left\\lceil \\frac{n}{\\log_2(3)} \\right\\rceil + 2 \\cdot \\Lambda(t) + 5 - 4 \\log_3(n)</span>$</p>

    <p class="text-gray-300">to thwart the Meet-in-the-Middle variant.</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Security Analysis &mdash; Statistical Attacks</h2>

    <p class="text-gray-300">Unlike the algebraic analysis above, statistical attacks do not explicitly consider the number of the variables involved in the output polynomials representing the (reduced-round) cipher.</p>

      <h3 id="app-d.1" class="text-xl font-semibold mt-8">D.1 Classical and Truncated Differential Cryptanalysis</h3>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>erf</sub>. In order to find the minimum number of rounds to protect the cipher against differential attack, we look for the best possible (truncated) differential characteristic. Consider an input difference of the form  <span class="math">(0, \\ldots, 0, \\Delta_I)</span>  where  <span class="math">\\Delta_I \\neq 0</span> . It is straightforward to observe that such input difference does not active any S-Box in the first  <span class="math">r_0 = t - 1</span>  rounds (since the input difference is always zero), that is the output difference after  <span class="math">r_0</span>  rounds is  <span class="math">(\\Delta_I, 0, 0, \\ldots, 0)</span> . After  <span class="math">r_1 = t</span>  round, we get an output difference of the form  <span class="math">(f^{r_1}(\\Delta_I), \\ldots, f^{r_1}(\\Delta_I), \\Delta_I)</span> , where  <span class="math">f^{r_1}(\\cdot)</span>  denotes the  <span class="math">r_1</span> -th round function. Observe that  <span class="math">\\Delta_I = f^{r_1}(\\Delta_I)</span>  with prob.  <span class="math">2^{-n+1}</span> . Indeed, since an active (cubic) S-Box maps its non-zero input difference to  <span class="math">2^{n-1}</span>  possible output differences each one with prob.  <span class="math">2^{-n+1}</span> , it follows that  <span class="math">f^{r_1}(\\Delta_I) = \\Delta_I</span>  with probability  <span class="math">2^{-n+1}</span> . Assume  <span class="math">f^{r_1}(\\Delta_I) = \\Delta_I</span> , that is an output difference of the form  <span class="math">(\\Delta_I, \\ldots, \\Delta_I)</span> . After  <span class="math">r_2 = t + 1</span>  rounds, we get an output difference of the form  <span class="math">(\\Delta_I \\oplus f^{r_2}(\\Delta_I), \\ldots, \\Delta_I \\oplus f^{r_2}(\\Delta_I), \\Delta_I)</span> . Due to the previous consideration,  <span class="math">f^{r_2}(\\Delta_I) = \\Delta_I</span>  with prob.  <span class="math">2^{-n+1}</span> .</p>

    <p class="text-gray-300">As a result, the following (truncated) characteristic over t+1 rounds</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, 0, \\Delta_I) \\xrightarrow[\\text{prob.}]{R^{t-1}(\\cdot)} (\\Delta_I, 0, 0, \\dots, 0) \\xrightarrow[\\text{prob.} \\leq 2^{-n+1}]{R(\\cdot)} (\\Delta_I, \\Delta_I, \\dots, \\Delta_I) \\xrightarrow[\\text{prob.} \\leq 2^{-n+1}]{R(\\cdot)} (0, \\dots, 0, \\Delta_I)</span>$</p>

    <p class="text-gray-300">has an overall probability equal to  <span class="math">2^{-2n+2}</span> . Before going on, note that any other input difference active at least one S-Box in the first t-1 rounds. In other words, it seems not possible to find a longer characteristic with lower probability.</p>

    <p class="text-gray-300">By iterating this (truncated) characteristic, it is possible to construct a differential characteristic over  <span class="math">s \\cdot (t+1)</span>  with probability at most  <span class="math">(2^{-2n+2})^s</span> . By simple computation,  <span class="math">(2^{-2n+2})^s \\leq 2^{-N}</span>  if and only if  <span class="math">(2n-2) \\cdot s \\geq N</span> , that is  <span class="math">s \\geq \\lceil \\frac{N}{2n-2} \\rceil</span> . As a result,  <span class="math">2+t\\cdot (t+1)\\cdot \\lceil \\frac{n}{2(n-1)} \\rceil</span>  rounds are sufficient to provide security in the univariate case, while  <span class="math">1+t+t\\cdot (t+1)\\cdot \\lceil \\frac{n}{2(n-1)} \\rceil</span>  rounds are sufficient to provide security in the multivariate case.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>Nyb</sub>. First of all, note that any input difference of the form  <span class="math">(0, \\Delta_I, 0, \\dots, \\Delta_I)</span> , where  <span class="math">\\Delta_I \\neq 0</span> , does not activate any S-Box in the first round. Working as in the previous</p>

    <p class="text-gray-300">case, it is possible to prove that the following (truncated) characteristic over 3t/2 = 3t' rounds (where t = 2t')</p>

    <p class="text-gray-300"><span class="math">$(\\Delta, 0, \\dots, 0) \\xrightarrow{R^{3t&#x27;}(\\cdot)} (\\Delta&#x27;, 0, \\dots, 0)</span>$</p>

    <p class="text-gray-300">has probability  <span class="math">2^{(t-1)\\cdot(-n+1)}</span> , where in general  <span class="math">\\Delta \\neq \\Delta&#x27;</span> .</p>

    <p class="text-gray-300">By iterating this characteristic, it is possible to construct a differential characteristic over  <span class="math">s\\cdot(3t&#x27;)</span>  with probability at most  <span class="math">(2^{(t-1)\\cdot(-n+1)})^s</span> . As a result,  <span class="math">(2^{(t-1)\\cdot(-n+1)})^s\\leq 2^{-N}</span>  if and only if  <span class="math">(t-1)\\cdot(n-1)\\cdot s\\geq 2N</span> , that is  <span class="math">s\\geq 2</span>  (since  <span class="math">N\\geq 2(n+t-1)</span>  due to the fact that  <span class="math">n\\cdot(t-2)\\geq 2(t-1)</span>  for each  <span class="math">n\\geq 3</span> ). As a result, 2+3t rounds are sufficient to provide security in the univariate case, while 3+3t rounds are sufficient to provide security in the multivariate case.</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>mrf</sub>. Using the same argumentation provide before for GMiMC<sub>Nyb</sub>, it follows that  <span class="math">2 + 3\\Lambda t</span>  rounds are sufficient to provide security in the univariate case, while  <span class="math">3 + 3\\Lambda t</span>  rounds are sufficient to provide security in the multivariate case.</p>

    <p class="text-gray-300">For the following, we also prove the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> There cannot be any truncated differential trail covering  <span class="math">i \\geq 4</span>  rounds of the GMiMC<sub>mrf</sub> instance with less than i active S-Boxes.</p>

    <p class="text-gray-300"><em>Proof.</em> We simply observe that any truncated trail involving 1 active branch will activate at least 4 S-Boxes over the next 4 rounds.</p>

    <p class="text-gray-300">Figure 11 illustrates the case where the unique active branch is an input of the Feistel function. We consider, without loss of generality, the case where this branch has index 0, and we track the set  <span class="math">A^i</span>  of the indices j such that the branch with index j which is input to the Feistel functions is active.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">i=2\\ell</span>  This case is illustrated in Figure 11a. This truncated trail propagates with probability 1 for 3 rounds, activating 4 S-Boxes along the way. During the third round, one cancellation may occur so that 1 or 2 S-Boxes are active in the fourth round. In total, 5 or 6 S-Boxes are active.</li>
      <li><span class="math">i=2\\ell+1</span>  This case is illustrated in Figure 11b. This truncated trail propagates with probability 1 for 4 rounds, activating 7 S-Boxes along the way.</li>
    </ul>

    <p class="text-gray-300">We now consider the case where the unique active branch is not input to a Feistel function in the first round, so that we can skip one round without any active S-Box.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">i=2\\ell</span>  This case is illustrated in Figure 12a. This truncated trail propagates with probability 1 for 3 rounds, activating 3 S-Boxes along the way. During the third round, one cancellation may occur so that 1 or 2 S-Boxes are active in the fourth round. In total, 4 or 5 S-Boxes are active.</li>
      <li><span class="math">i = 2\\ell + 1</span>  This case is illustrated in Figure 12b. This truncated trail propagates with probability 1 for 4 rounds, activating 4 S-Boxes along the way.</li>
    </ul>

    <p class="text-gray-300">As we have seen, each of the 4 possible cases where a unique branch is active in the input yields at least 4 active S-Boxes during the next 4 rounds. It is thus impossible to cover  <span class="math">i \\geq 4</span>  rounds without activating at least i S-Boxes.</p>

    <p class="text-gray-300">In practice, as shown in Section 6, the bound on q is smaller than the one needed to prevent GCD attacks unless t is very large and n very small. As a result and working as in the GMiMC<sub>Nyb</sub> case, a truncated differential with probability 1 exists for  <span class="math">\\Lambda(t) = 2\\log_2(t)</span>  rounds.</p>

    <p class="text-gray-300">    <img src="_page_45_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 11: Truncated differentials in GMiMCmrf with 1 active branch (on the left) in the input.</p>

    <p class="text-gray-300">    <img src="_page_45_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 12: Truncated differentials in GMiMCmrf with 1 active branch (on the left) in the input.</p>

      <h3 id="app-d.2" class="text-xl font-semibold mt-8"><strong>D.2 Impossible Differential Cryptanalysis</strong></h3>

    <p class="text-gray-300">As done in Section <a href="#page-16-1">4.2,</a> we construct an impossible differential by combining two (truncated) differentials that do not match in the middle.</p>

    <p class="text-gray-300"><strong>GMiMCerf.</strong> A probability-one differential exists for a maximum of <em>t</em> &minus; 1 rounds of the cipher, which is given as follows:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha)\\to(0,\\ldots,0,\\alpha,0)\\to\\ldots(\\alpha,0,\\ldots,0).</span>$</p>

    <p class="text-gray-300">This differential can be extended to a probability-one truncated differential for t rounds as follows:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha) \\xrightarrow{t-1 \\text{ rounds}} (\\alpha,0,\\ldots,0) \\xrightarrow{1 \\text{ round}} (*,*,\\ldots,*,\\alpha).</span>$</p>

    <p class="text-gray-300">This probability-one differential allows us to construct an impossible differential for 2t-2 rounds, as depicted below:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha) \\xrightarrow[\\text{prob. } 1]{R^{t-1}(\\cdot)} (\\alpha,0,\\ldots,0) \\neq (0,\\ldots,0,\\beta) \\xleftarrow[\\text{prob. } 1]{R^{t-1}(\\cdot)} (\\beta,0,\\ldots,0)</span>$</p>

    <p class="text-gray-300">for  <span class="math">\\alpha, \\beta \\neq 0</span> . Conservatively, 2t rounds will be secure against meet-in-the-middle attacks/distinguishers for the case  <span class="math">\\kappa = n</span> , while (2t-2) + (t+1) = 3t-1 rounds will be secure against meet-in-the-middle attacks/distinguishers for the case  <span class="math">\\kappa = t \\cdot n</span> .</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>Nyb</sub> There exists a probability-one truncated differential for a maximum of t-1 rounds of this construction (with t=2t' branches). This is described as follows:</p>

    <p class="text-gray-300"><span class="math">$(0,\\alpha,0,...,0) \\to (\\alpha,0,0,...,0) \\to (*,0,...,0,\\alpha) \\to (*,0,...,0,\\alpha,*) \\to ... \\to (*,0,*,...,*)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha \\neq 0</span> .</p>

    <p class="text-gray-300">Using the probability-one truncated differentials similarly as described above, we can construct impossible differentials for  <span class="math">GMiMC_{Nyb}</span> . This will allow us to attack 2(t-1) rounds of the cipher. Hence, the number of iterations to protect the cipher against such attacks must be at least 2t for the case  <span class="math">\\kappa = n</span> , and 2t + 1 for the case  <span class="math">\\kappa = t \\cdot n</span> .</p>

    <p class="text-gray-300"><strong>GMiMC</strong><sub>mrf</sub>. As shown in Theorem 1, one call to GMiMC<sub>mrf</sub> with rotation sequence  <span class="math">\\{0, 1, 0, 2, 0, 4, ...\\}</span>  provides full diffusion after  <span class="math">\\Lambda(t) = 2\\log_2(t)</span>  rounds. The same holds if one works in the decryption mode of GMiMC<sub>mrf</sub>.</p>

    <p class="text-gray-300">As a result, using the probability-one truncated differentials described above, we can construct impossible differentials for GMiMC<sub>Nyb</sub> that cover  <span class="math">2 \\cdot (\\Lambda(t) - 1)</span>  rounds of the cipher. Hence, the number of iterations to protect the cipher against such attacks must be at least  <span class="math">2 \\cdot \\Lambda(t)</span>  for the case  <span class="math">\\kappa = n</span> , and  <span class="math">2 \\cdot \\Lambda(t) + 1</span>  for the case  <span class="math">\\kappa = t \\cdot n</span> .</p>

    </section>

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>E</strong> Field Arithmetic</h2>

    <p class="text-gray-300">Here we present an example of how Generalized Mersenne primes (or Solinas primes) are used to implement the signature scheme. Let  <span class="math">p_{64}=2^{64}-2^8-1</span>  be the prime number used for modular arithmetic in a 64-bit prime field. Note that  <span class="math">\\gcd(p_{64}-1,3)=1</span> , which is a requirement in order for  <span class="math">f(x)=x^3</span>  to be a permutation. The idea of the reduction method is based on the fact that  <span class="math">p_{64}</span>  can be represented as  <span class="math">f(t)=t^8-t-1</span> , where  <span class="math">t=2^8</span> . By calculating the residues of  <span class="math">t^{15}, t^{14}, \\ldots, t^8 \\pmod{f(t)}</span>  and storing their coefficients as rows in a  <span class="math">(n\\times n)</span> -matrix X where n=8, following holds for  <span class="math">i=0,1,\\ldots,7</span> :</p>

    <p class="text-gray-300"><span class="math">$t^{8+i} \\equiv \\sum_{j=0}^{7} (X[i,j] \\times t^j) \\pmod{f(t)}.</span>$</p>

    <p class="text-gray-300">Now let  <span class="math">r = (r_{15}||r_{14}||...||r_0)</span>  be the result of a multiplication of two 64-bit integers, where each  <span class="math">r_i</span>  is a 8-bit quantity. Then</p>

    <p class="text-gray-300"><span class="math">$r = \\sum_{i=0}^{15} (r_i \\times t^i) \\equiv \\sum_{i=0}^{7} (z_i \\times t^i) \\pmod{f(t)}, \\text{ where}</span>$
<span class="math">$(z_0 \\dots z_7) = (r_0 \\dots r_7) + (r_8 \\dots r_{15}) \\cdot X.</span>$</p>

    <p class="text-gray-300">With  <span class="math">p_{64} = t^8 - t - 1</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=0}^{15} (r_i \\times 2^{8i}) \\equiv \\sum_{i=0}^{7} (z_i \\times 2^{8i}) \\pmod{p_{64}}.</span>$</p>

    <p class="text-gray-300">This method uses  <span class="math">(log_2(t))</span> -bit parts of r and in order to reduce the number of steps, in most cases it is wise to choose f(t) such that the number of bits is maximized. A more detailed description of how these equations are used to achieve a constant-time reduction algorithm for a specific prime number is given in [72].</p>

    <p class="text-gray-300">For example, let  <span class="math">p_{65}(z) = z^{65} + z^4 + z^3 + z + 1</span>  be the irreducible polynomial used for computations in a 65-bit binary field. The degree of  <span class="math">p_{65}</span>  is odd, which again makes  <span class="math">f(x) = x^3</span>  a permutation. Given a (2k-1)-bit product r of two k-bit polynomials, where k = 65, following equations hold:</p>

    <p class="text-gray-300"><span class="math">$z^{65} \\equiv z^4 + z^3 + z + 1 \\pmod{p_{65}(z)},</span>$</p>

    <p class="text-gray-300"><span class="math">$z^{66} \\equiv z^5 + z^4 + z^2 + z \\pmod{p_{65}(z)},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vdots</span>$</p>

    <p class="text-gray-300"><span class="math">$z^{128} \\equiv z^{67} + z^{66} + z^{64} + z^{63} \\pmod{p_{65}(z)}.</span>$</p>

    <p class="text-gray-300">The coefficients of  <span class="math">z^{65}, z^{66}, \\ldots, z^{128}</span>  are stored in the most significant 64 bits of the product and can be reduced by adding them consecutively to bits 4, 3, 1, and 0 of r. Reduction is performed one word at a time, starting from the most significant word, which means that some of r's most significant 64 bits need to be added to themselves first. This method is further described in [48], where examples are given for reduction polynomials recommended by NIST.</p>

    </section>

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">F <span class="math">\\operatorname{GMiMC}_{erf}</span> - Number of Rounds in <em>Low-Data Scenario</em></h2>

    <p class="text-gray-300">In Section 6, we propose the formula</p>

    <p class="text-gray-300"><span class="math">$r \\ge \\lceil 1.262 \\cdot n - 4 \\cdot \\log_3(n) \\rceil + 3t + 3</span>$</p>

    <p class="text-gray-300">in order to compute the number of rounds of  <span class="math">GMiMC_{erf}</span>  in the low-data scenario. Here we give more argumentation about this fact. We emphasize that we focus on PQ signature applications, and that the previous formula has been derived by combining the results provided by the GCD attack and the one provided by the SageMath code provided in Appendix G (in order to estimate Gr&ouml;bner Basis attack)<sup>24</sup>.</p>

    <p class="text-gray-300">Our results are summarized in the previous table, where we highlight the minimum number of rounds in order to protect GMiMC<sub>erf</sub> against the GCD attack, the Gr&ouml;bner Basis attack and against a generic attack (using the previous formula). Since we consider GMiMC<sub>erf</sub> for PQ signature applications in the low-data scenario for N=128,192,256, we limit ourselves to focus on these cases and we highlight the parameter &quot;Total Number of Multiplications ( <span class="math">\\equiv</span>  number of rounds r) &times; Field Size ( <span class="math">\\equiv</span>  branch size n)&quot;. We emphasize that this parameter is minimal when the branch size n is minimized (that is, n=3).</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{24}&lt;/sup&gt;</span> The results provided by the Sage function proposed in Appendix G are only based on the degree of the considered function. For the particular case of GMiMC<sub>erf</sub>, it is crucial to add 2t-6 rounds due to the attack described in detail in Appendix C.4.</p>

    <p class="text-gray-300">Table 7: <em>Number of rounds for</em> GMiMCerf <em>in the low-data scenario. n</em> denotes the branch size, <em>t</em> denotes the number of branches (<em>N</em> = <em>n</em> &times; <em>t</em>), &quot;<em>r</em> (GCD)&quot; denotes the minimum number of rounds to guarantee security against the GCD attack, &quot;<em>r</em> (Gr&ouml;bner)&quot; denotes the minimum number of rounds to guarantee security against the Gr&ouml;bner Basis Attack, and &quot;Number of Rounds r&quot; denotes the minimum number of rounds to provide security against any attack. For PQ signature applications, we also highlight the parameter &quot;Total Number of Multiplications &times; Field Size&quot;, and we emphasize the minimum value for each <em>N</em>.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">N</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r (GCD)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r (Gr&ouml;bner)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number of Rounds r</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r &times; t</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">132</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">396</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">78</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">82</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">410</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">414</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">195</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">585</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">117</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">121</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">605</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">657</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">258</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">261</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">783</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">154</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">156</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">846</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="app-g" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>G Low-Data Gr&ouml;bner Basis Attack</strong></h2>

    <p class="text-gray-300">The following SageMath code returns the complexity of the Gr&ouml;bner Basis attack on GMiMC. Such a function is especially used in the low-data attacks in order to estimate <em>Dreg</em>.</p>

    <pre><code class="language-text">Parameter estimation for Groebner basis attacks on GMiMC
# Nicked from LWE Estimator
from collections import OrderedDict
class Cost :
    Algorithms costs .
    def __init__ ( self , data = None , ** kwds ):
         : param data : we call &#x27;&#x27; OrderedDict ( data ) &#x27;&#x27;
         if data is None :
              self . data = OrderedDict ()
         else :
              self . data = OrderedDict ( data )
         for k , v in kwds . iteritems ():
              self . data [k] = v
    def str ( self , keyword_width = None , newline = None , round_bound =2048 , compact = False ):
         format_strings = {u&quot; beta &quot;: u&quot;%s: %4d&quot;, u&quot;d&quot;: u&quot;%s: %4d&quot;,
                              &quot;b&quot;: &quot;%s: %3d&quot;, &quot;t1&quot;: &quot;%s: %3d&quot;, &quot;t2&quot;: &quot;%s: %3d&quot;,
                              &quot;l&quot;: &quot;%s: %3d&quot;, &quot; ncod &quot;: &quot;%s: %3d&quot;, &quot; ntop &quot;: &quot;%s: %3d&quot;, &quot; ntest &quot;: &quot;%s: %3d&quot;}
         d = self . data
         s = []
         for k in d:
              v = d [k]
              kk = k
              if keyword_width :
                  fmt = u&quot; %%% ds&quot; % keyword_width
                  kk = fmt % kk
              if not newline and k in format_strings :
                  s. append ( format_strings [k ]%( kk , v ))
              elif ZZ (1)/ round_bound &lt; v &lt; round_bound or v == 0 or ZZ ( -1)/ round_bound &gt; v &gt; - round_bound :
                  try :
                       if compact :
                            s. append (u&quot;%s: %d&quot; % (kk , ZZ (v )))
                       else :
                            s. append (u&quot;%s: %8d&quot; % ( kk , ZZ (v )))
                  except TypeError :
                       if v &lt; 2.0 and v &gt;= 0.0:
                            if compact :
                                s. append (u&quot;%s: %.6f&quot; % (kk , v ))
                            else :
                                s. append (u&quot;%s: %8.6 f&quot; % (kk , v ))
                       else :
                            if compact :
                                s. append (u&quot;%s: %.3 f&quot; % (kk , v ))
                            else :
                                s. append (u&quot;%s: %8.3 f&quot; % (kk , v ))
              else :
                  t = u&quot;%s2 ^%.1 f&quot; % (&quot;-&quot; if v &lt; 0 else &quot;&quot;, log ( abs (v) , 2). n ())
                  if compact :
                       s. append (u&quot;%s: %s&quot; % ( kk , t ))
                  else :
                       s. append (u&quot;%s: %8s&quot; % (kk , t ))
         if not newline :
              if compact :
                  return u&quot;, &quot;. join ( s)
              else :
                  return u&quot;, &quot;. join (s)
         else :
              return u&quot;\\n&quot;. join (s)
    def reorder ( self , first ):
         keys = list ( self . data )
         for key in first :
              keys . pop ( keys . index ( key ))
         keys = list ( first ) + keys
         r = OrderedDict ()
         for key in keys :
              r[ key ] = self . data [ key ]
         return Cost (r)
    def filter ( self , keys ):
         r = OrderedDict ()
         for key in keys :
              r[ key ] = self . data [ key ]
         return Cost (r)
    def repeat ( self , times , select = None , lll = None ):
         # TODO review this list
</code></pre>

    <pre><code class="language-text">do_repeat = {
              u&quot; rop &quot;: True ,
              u&quot; red &quot;: True ,
              u&quot; babai &quot;: True ,
              u&quot; babai_op &quot;: True ,
              u&quot; epsilon &quot;: False ,
              u&quot; mem &quot;: False ,
              u&quot; delta_0 &quot;: False ,
              u&quot; beta &quot;: False ,
              u&quot;k&quot;: False ,
              u&quot; D_reg &quot;: False ,
              u&quot;t&quot;: False ,
              u&quot;m&quot;: True ,
              u&quot;d&quot;: False ,
              u&quot;|v|&quot;: False ,
              u&quot; amplify &quot;: False ,
              u&quot; repeat &quot;: False , # we deal with it below
              u&quot;c&quot;: False ,
         if lll and self [&quot; red &quot;] != self [&quot; rop &quot;]:
              raise ValueError (&quot; Amplification via LLL was requested but &#x27;red &#x27; != &#x27;rop &#x27;&quot;)
         if select is not None :
              for key in select :
                   do_repeat [ key ] = select [ key ]
         ret = OrderedDict ()
         for key in self . data :
              try :
                   if do_repeat [ key ]:
                       if lll and key in (&quot; red &quot;, &quot; rop &quot;):
                            ret [ key ] = self [ key ] + times * lll
                       else :
                            ret [ key ] = times * self [ key ]
                   else :
                       ret [ key ] = self . data [ key ]
              except KeyError :
                   raise NotImplementedError (u&quot;You found a bug , this function does not know about &#x27;%s&#x27; but should .&quot;% key )
         ret [u&quot; repeat &quot;] = times * ret . get (&quot; repeat &quot;, 1)
         return Cost ( ret )
    def __rmul__ ( self , times ):
         return self . repeat ( times )
    def combine ( self , right , base = None ):
         &quot;&quot;&quot; Combine &#x27;&#x27;left &#x27; &#x27; and &#x27;&#x27;right &#x27; &#x27;.
         : param left : cost dictionary
         : param right : cost dictionary
         : param base : add entries to &#x27;&#x27;base &#x27;&#x27;
         if base is None :
              cost = Cost ()
         else :
              cost = base
         for key in self . data :
              cost [ key ] = self . data [ key ]
         for key in right :
              cost [ key ] = right . data [ key ]
         return Cost ( cost )
    def __add__ ( self , other ):
         return self . combine ( self , other )
    def __getitem__ ( self , key ):
         return self . data [ key ]
    def __setitem__ ( self , key , value ):
         self . data [ key ] = value
    def __iter__ ( self ):
         return iter ( self . data )
    def values ( self ):
         return self . data . values ()
    def __str__ ( self ):
         return self . str ( compact = True )
    def __repr__ ( self ):
         return self . str ( newline = True , keyword_width =12)
# Parameter estimation
@cached_function
def have_magma ():
    try :
         magma (1)
         return True
    except TypeError :
         return False
def degree_of_regularity (n , D ):
    Degree of regularity estimation .
    : param n: number of variables &#x27;n &gt; 0&#x27;
</code></pre>

    <pre><code class="language-text">: param D: tuple of &#x27;(d,m)&#x27; pairs where &#x27;m&#x27; is number polynomials and &#x27;d&#x27; is a degree
    : param omega : linear algebra exponent , i.e. matrix - multiplication costs &#x27;O(n^ omega )&#x27; operations .
    m = sum ( m_ for D_ , m_ in D)
    if m &lt;= n:
         # regular sequence case
         # Theorem 3 in http :// magali . bardet . free .fr/ Publis / bardet_et_all_MEGA05 . pdf .
         return sum ( m_ *( D_ -1) for D_ , m_ in D) + 1
    prec = 8192
    if have_magma ():
         R = magma . PowerSeriesRing (QQ , prec )
         z = R . gen (1)
         coeff = lambda f , d: f. Coefficient (d ) # noqa
    else :
         R = PowerSeriesRing (QQ , &quot;z&quot;, prec )
         z = R . gen ()
         coeff = lambda f , d: f[d] # noqa
    s = 1
    for d , m in D:
         s *= (1 - z ** d )** m
    s = s / (1 - z )** n
    for dreg in range ( prec ):
         if coeff (s , dreg ) &lt; 0:
             return dreg
    else :
         return prec
def gb_cost (n , dreg , omega =2):
    Estimate the complexity of computing a Groebner basis .
    : param n: number of variables &#x27;n &gt; 0&#x27;
    : param dreg : presumed degree of semi - regularity
    : param omega : linear algebra exponent , i.e. matrix - multiplication costs &#x27;O(n^ omega )&#x27; operations .
    return binomial ( n + dreg , dreg )** omega
def estimate (n , l , t , d , m = Infinity , omega =2 , target_security_level = None ):
    &quot;&quot;&quot; Estimate cost of breaking GMiMC using GBs.
    : param n: bit - size of base field
    : param l: number of elements in the key , the key size - n*l
    : param t: number of branches in the Feistel network
    : param d: degree of *meet -in -the - middle * polynomials
    : param m: number of known pairs &gt;= 1
    : param omega : linear algebra constant
    best = None
    for kappa in range (l )[:: -1]:
         if m is Infinity or l - kappa &lt;= 1:
             dreg = min (d , 2** n)
         else :
             dreg = degree_of_regularity (l - kappa , (( d , m*t ) ,(2** n ,l )))
         if kappa :
             dreg -= 1
         current = Cost ()
         if l - kappa &gt; 1:
             current [&quot; rop &quot;] = 2**( n* kappa ) * gb_cost (l - kappa , dreg , omega )
         elif l - kappa == 1:
             current [&quot; rop &quot;] = 2**( n* kappa ) * d* log (d ,2)**2
         else :
             current [&quot; rop &quot;] = 2**( n* kappa ) * d # guessing
         current [&quot; kappa &quot;] = kappa
         current [&quot;d&quot;] = d
         current [&quot;D_{reg}&quot;] = dreg
         if get_verbose () &gt;= 2:
             print current . str ()
         if best is None or current [&quot; rop &quot;] &lt; best [&quot; rop &quot;]:
             best = current
         if target_security_level and best [&quot; rop &quot;] &lt; 2** target_security_level :
             break
    return best
def estimate_erf (n , t , r , l= None , m =1 , omega =2 , target_security_level = None ):
    if l is None :
         l = t
    if (r //2 - t ) &gt;= 0:
         d = ZZ (3)**( r //2 - t)
    else :
         d = 1
    ret = estimate (n=n , l =l , t=t , d=d , m=m , omega = omega , target_security_level = target_security_level )
    ret [&quot;n&quot;] = n
    ret [&quot;t&quot;] = t
    ret [&quot;r&quot;] = r
    ret [&quot;n*r&quot;] = n*r
    return ret
def find_r_est (n , t , security_level , m =1 , omega =2):
    for r in range (2* t +2 , 2* t +32 , 2):
</code></pre>

    <pre><code class="language-text">current = estimate_erf ( n=n , t=t , r =r , m=m , omega =2 , target_security_level = security_level )
         if get_verbose () &gt;= 1:
             print current . str ()
         if current [&quot; rop &quot;] &gt; 2** security_level :
             return current
# N = 128 ( low data ) , assuming one pair
print find_r_est (n=3 , t=43 , security_level =128)
print find_r_est (n=5 , t=26 , security_level =128)
print find_r_est (n=9 , t=15 , security_level =128)
# print find_r_est (n=17 , t=8 , security_level =128)
# print find_r_est (n=33 , t=4 , security_level =128)
print find_r_est (n=3 , t=64 , security_level =192)
print find_r_est (n=5 , t=39 , security_level =192)
print find_r_est (n=9 , t=22 , security_level =192)
print find_r_est (n=17 , t=12 , security_level =192)
print find_r_est (n=33 , t=6 , security_level =192)
print find_r_est (n=3 , t=86 , security_level =256)
print find_r_est (n=5 , t=52 , security_level =256)
print find_r_est (n=9 , t=29 , security_level =256)
print find_r_est (n=17 , t=16 , security_level =256)
print find_r_est (n=33 , t=8 , security_level =256)
# Experimental Verification
class GMiMC ( object ):
    def __init__ ( self , q , l , t , r , rf , s =0 x1337 ):
         : param q: order of base field
         : param l: number of elements in the key
         : param t: number of branches
         : param r: number of rounds
         : param rf: round function
         : param s: seed used to generate round constants
         self .K = GF (q , &quot;a&quot;)
         self .R = PolynomialRing ( self .K , l , &quot;k&quot;)
         self . kv = self .R. gens ()
         self .l , self .t , self .r = l , t , r
         self . rf = rf
         with seed ( s ):
             if rf in ( GMiMC . crf , GMiMC . erf ):
                  self .c = tuple ([ self . K. random_element () for _ in range ( self .r )])
             elif rf in ( GMiMC . nyb , GMiMC . mrf ):
                  self .c = tuple ([ tuple ([ self .K. random_element () for _ in range ( self .t //2)]) for _ in range ( self .r )])
             else :
                  raise ValueError
    @staticmethod
    def crf ( state , k , c , i , final = False , reverse = False ):
         l = len (k)
         state = list ( state )
         state [0] += ( sum ( state [1:]) + k [i%l ] + c[i ])**3
         if not final and not reverse :
             state = vector ( state [1:] + [ state [0]])
         elif not final and reverse :
             state = vector ([ state [ -1]] + state [: -1])
         else :
             state = vector ( state )
         return state
    @staticmethod
    def erf (x , k , c ):
         R = parent (x [0])
         raise NotImplementedError
    @staticmethod
    def nyb ( state , k , c , j , final = False , reverse = False ):
         l = len (k)
         state = list ( state )
         t = len ( state )
         for i in range (t //2):
             state [i] += ( state [t -i -1] + k [( j *( t //2) + i )% l] + c [j ][ i ])**3
         if not final and not reverse :
             state = vector ([ state [ -1]] + state [: -1])
         elif not final and reverse :
             state = vector ( state [1:] + [ state [0]])
         else :
             state = vector ( state )
         return state
    @staticmethod
</code></pre>

    <pre><code class="language-text">def mrf (x , k , c ):
         R = parent (x [0])
         raise NotImplementedError
    def __call__ ( self , p , k ):
         l = len ( self . kv )
         state = p
         for i in range ( self .r ):
              state = self . rf ( state , k , self .c , i , final =( i == self .r -1))
         return state
    def polynomial_system ( self , m =2):
         k = vector ([ self .K. random_element () for i in range ( self .R. ngens ())])
         r2 = self .r //2
         F = []
         field = []
         for k_ in self . kv :
              field . append ( k_ ** self .K. order () - k_ )
         for i in range (m ):
              p = vector ( self .K , [ self .K. random_element () for i in range ( self .t )])
              c = self (p , k )
              lhs = p
              for i in range ( r2 ):
                   lhs = self . rf ( lhs , self .kv , self .c , i)
                   lhs = vector ([ f. reduce ( field ) for f in lhs ])
              rhs = c
              for i in range (r2 , self .r )[:: -1]:
                   rhs = self . rf ( rhs , self .kv , self .c , i , final =( i == r2 ), reverse = True )
                   rhs = vector ([ f. reduce ( field ) for f in rhs ])
              F. extend ( list ( rhs - lhs ))
         F. extend ( field )
         return Sequence ( F)
def gb_experiment (q , l , t , r , rf , m , s =0 x1337 ):
    gmimc = GMiMC (q=q , l =l , t=t , r=r , rf = GMiMC . nyb , s=s)
    F = gmimc . polynomial_system ( m=m)
    print &quot;# polynomials : %3d&quot;% len (F) ,
    print &quot;, degrees :&quot;,
    for i in range (F. maximal_degree ()):
         c = len ([ f for f in F if f. degree () == i +1])
         if c:
              print &quot;%d: %d,&quot;%( i +1 , c),
    print &quot;D_{reg }: %2d&quot;%( F. ideal (). degree_of_semi_regularity ())
    F = F . ideal (). interreduced_basis ()
    print &quot;# polynomials : %3d&quot;% len (F) ,
    print &quot;, degrees :&quot;,
    for i in range (F. maximal_degree ()):
         c = len ([ f for f in F if f. degree () == i +1])
         if c:
              print &quot;%d: %d,&quot;%( i +1 , c),
    print &quot;D_{reg }: %2d&quot;%( F. ideal (). degree_of_semi_regularity ())
    return F
</code></pre>

    </section>
`;
---

<BaseLayout title="Feistel Structures for MPC, and More (2019/397)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/397
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Description of Generalized MiMC</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The Block Cipher GMiMC</a></li>
            <li><a href="#sec-2.1.1" class="hover:text-white">GMiMC&lt;sub&gt;crf&lt;/sub&gt;</a></li>
            <li><a href="#sec-2.1.2" class="hover:text-white">GMiMC&lt;sub&gt;erf&lt;/sub&gt;</a></li>
            <li><a href="#sec-2.1.3" class="hover:text-white">GMiMCNyb</a></li>
            <li><a href="#sec-2.1.4" class="hover:text-white">GMiMCmrf</a></li>
            <li><a href="#sec-2.1.5" class="hover:text-white">Key Schedule</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Hash Function</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Security Analysis</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Security Analysis &ndash; GMiMC instantiated over Fp</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Algebraic Attacks</a></li>
            <li><a href="#sec-4.1.1" class="hover:text-white">Greatest Common Divisors</a></li>
            <li><a href="#sec-4.1.2" class="hover:text-white">Gr&ouml;bner Bases</a></li>
            <li><a href="#sec-4.1.3" class="hover:text-white">Interpolation Attack</a></li>
            <li><a href="#sec-4.1.4" class="hover:text-white">Higher-Order Differential</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Statistical Attacks</a></li>
            <li><a href="#sec-4.2.1" class="hover:text-white">Classical and Truncated Differential Cryptanalysis</a></li>
            <li><a href="#sec-4.2.2" class="hover:text-white">Impossible Differential Cryptanalysis</a></li>
            <li><a href="#sec-4.2.3" class="hover:text-white">Linear Cryptanalysis</a></li>
            <li><a href="#sec-4.2.4" class="hover:text-white">&quot;Generic&quot; (MitM) Attacks</a></li>
            <li><a href="#sec-4.2.5" class="hover:text-white">Other Attacks</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Quantum Improvements</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Security Analysis &ndash; GMiMC instantiated over \mathbb&#123;F&#125;_&#123;2^n&#125; in the Low-Data Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Security Analysis &mdash; GCD Attacks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Parameter-Space Exploration</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">MPC/SNARK/PQ Signature Applications</a></li>
            <li><a href="#sec-6.1.1" class="hover:text-white">SNARK &mdash; Number of &quot;Operations&quot;</a></li>
            <li><a href="#sec-6.1.2" class="hover:text-white">PQ Signatures &mdash; Number of Multiplications &times; Field Size (Low-Data Scenario)</a></li>
            <li><a href="#sec-6.1.3" class="hover:text-white">MPC &mdash; Number of (parallel) Multiplications</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">Application and Implementation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">MPC Setting</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">SNARKs</a></li>
            <li><a href="#sec-7.3" class="hover:text-white">Post-Quantum Signatures</a></li>
          </ol>
        </li>
        <li><a href="#sec-8" class="hover:text-white">Discussion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Variants of the GMiMC family of ciphers</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">A Permutation Round Function</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Different Round Functions</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Diffusion in GMiMCmrf</a></li>
        <li>
          <a href="#app-c" class="hover:text-white">Security Analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Interpolation Attack</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Higher-Order Differential in \mathbb&#123;F&#125;_p</a></li>
            <li><a href="#app-c.3" class="hover:text-white">Gr&ouml;bner Basis Analysis</a></li>
            <li><a href="#app-c.4" class="hover:text-white">GCD Attacks in \mathbb&#123;F&#125;_&#123;2^n&#125; &ndash; Low-Data Scenario</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-d" class="hover:text-white">Security Analysis &mdash; Statistical Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-d.1" class="hover:text-white">Classical and Truncated Differential Cryptanalysis</a></li>
            <li><a href="#app-d.2" class="hover:text-white">Impossible Differential Cryptanalysis</a></li>
          </ol>
        </li>
        <li><a href="#app-e" class="hover:text-white">Field Arithmetic</a></li>
        <li><a href="#app-f" class="hover:text-white">\operatorname&#123;GMiMC&#125;_&#123;erf&#125; - Number of Rounds in Low-Data Scenario</a></li>
        <li><a href="#app-g" class="hover:text-white">Low-Data Gr&ouml;bner Basis Attack</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="5-security-analysis-gmimc-instantiated-over-in-the-low-data-2019" />
  </article>
</BaseLayout>
