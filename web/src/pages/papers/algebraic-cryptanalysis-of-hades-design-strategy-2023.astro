---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/537';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Algebraic Cryptanalysis of HADES Design Strategy: Application to POSEIDON and Poseidon2';
const AUTHORS_HTML = 'Tomer Ashur, Thomas Buschman, Mohammad Mahzoun';

const CONTENT = `    <p class="text-gray-300">Tomer Ashur1,<sup>2</sup> , Thomas Buschman<sup>3</sup> , and Mohammad Mahzoun<sup>4</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>1 3MI Labs, Leuven, Belgium <sup>2</sup> Polygon Research tomer@cryptomeria.tech <sup>3</sup> Eindhoven University of Technology t.buschman@student.tue.nl <sup>4</sup> Eindhoven University of Technology mail@mahzoun.me</p>
    </blockquote>

    <p class="text-gray-300">Abstract. Arithmetization-Oriented primitives are the building block of advanced cryptographic protocols such as Zero-Knowledge proof systems. One approach to designing such primitives is the HADES design strategy which aims to provide an efficient way to instantiate generalizing substitution-permutation networks to include partial S-box rounds. A notable instance of HADES, introduced by Grassi et al. at USENIX Security '21, is Poseidon. Because of its impressive efficiency and low arithmetic complexity, Poseidon is a popular choice among the designers of integrity-proof systems. An updated version of Poseidon, namely, Poseidon2 was published at AfricaCrypt '23 aiming to improve the efficiency of Poseidon by optimizing its linear operations. In this work, we show some caveats in the security argument of HADES against algebraic attacks and quantify the complexity of Gröbner basis attacks. We show that the complexity of the attack is lower than claimed with the direct implication that there are cases where the recommended number of rounds is insufficient for meeting the claimed security. Concretely, the complexity of a Gröbner basis attack for an instance of Poseidon with 1024 bits of security is 731.77 bits and the original security argument starts failing already at the 384-bit security level. Since the security of Poseidon2 is derived from the security of Poseidon, the same analysis applies to the instances of Poseidon2. The results were shared with the designers and the security arguments were updated accordingly.</p>

    <p class="text-gray-300">Keywords: HADES · Poseidon · Hash functions · Zero-Knowledge proof systems · Gröbner basis attacks</p>

    <p class="text-gray-300">Arithmetization-Oriented (AO) primitives are a common building block for advanced cryptographic protocols such as Zero-Knowledge (ZK) proofs, Multiparty Computation (MPC), and Fully Homomorphic Encryption (FHE). AO primitives are usually defined over a finite field of large order and designed to have a simple and efficient algebraic representation. Examples of such primitives are Rescue [\\[4\\]](#page-16-0), Rescue-Prime [\\[41\\]](#page-19-0), RPO [\\[6\\]](#page-16-1), and Chaghri [\\[7\\]](#page-16-2) which are designed based on the Marvellous design strategy [\\[4\\]](#page-16-0), Griffin [\\[26\\]](#page-18-0) and Anemoi [\\[14\\]](#page-17-0) which are Feistel-like designs, Poseidon [\\[29\\]](#page-18-1) and Poseidon2 [\\[30\\]](#page-18-2) based on HADES design strategy, and more examples such as MiMC [\\[2\\]](#page-16-3), LowMC [\\[3\\]](#page-16-4), Kreyvium [\\[15\\]](#page-17-1), FLIP [\\[38\\]](#page-19-1), Rasta [\\[21\\]](#page-18-3), Dasta [\\[33\\]](#page-19-2), Pasta [\\[22\\]](#page-18-4), Fasta [\\[17\\]](#page-17-2), Elisabeth [\\[18\\]](#page-17-3), Rubato [\\[32\\]](#page-19-3), Tip5 [\\[42\\]](#page-19-4), and XHash [\\[5\\]](#page-16-5) to name just a few.</p>

    <p class="text-gray-300">A promising approach for designing efficient AO primitives is the HADES design strategy. Poseidon and its successor Poseidon2 are the most important and widely used hash functions designed based on the HADES approach which are sponge functions [\\[10\\]](#page-17-4) instantiated by the Poseidon<sup>π</sup> and Poseidon2<sup>π</sup> permutations. Poseidon2, optimizes the linear layers of Poseidon to improve efficiency and mitigate the attack proposed in [\\[9\\]](#page-17-5).</p>

    <p class="text-gray-300">The HADES design strategy allows the designers to optimize the combination of substitution-permutation network (SPN) and Partial SPN [\\[25\\]](#page-18-5) (PSPN) to derive an efficient design while not jeopardizing security. In HADES, SPN is referred to as full layers and used to justify arguments for the primitive's resistance against statistical attacks using the wide trail strategy. Then, PSPN is referred to as partial rounds with the goal to not only improve the performance of the design but also in combination with full layers ensure resistance against algebraic attack. Indeed, it is claimed that both full and partial layers provide same resistance in case of algebraic attacks [\\[31\\]](#page-18-6).</p>

    <p class="text-gray-300">The security of the HADES approach is based on an extensive analysis of various techniques such as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Statistical attacks: Differential cryptanalysis, linear cryptanalysis.</li>

      <li>Algebraic attacks: Interpolations attacks [\\[34\\]](#page-19-5), Gröbner basis attacks [\\[19\\]](#page-17-6), Higher-Order differential attacks [\\[36\\]](#page-19-6), and Zero-Sum partitions attacks [\\[13\\]](#page-17-7).</li>

    </ul>

    <p class="text-gray-300">The security arguments of HADES and its instances were scrutinized by third-party cryptanalysts which presented security vulnerabilities exploiting the partial layers <a href="#page-17-8">\\[12,</a>[35\\]](#page-19-7). It has been observed that in some cases, the linear layer results in invariant subspaces in partial layers. Subsequently, the security arguments and suggested secure parameters were updated accordingly by imposing additional constraints on the choice of the linear layer in the partial layer. Later, [\\[9\\]](#page-17-5) showed how to bypass two full rounds as an auxiliary approach for mounting algebraic attacks but no parameter sets were yet shown to be vulnerable. Sauer designed an algebraic attack on Poseidon [\\[39\\]](#page-19-8) and showed that the resistance of Poseidon against Gröbner basis attacks is overstated. However, he did not provide any instance that is indeed vulnerable.</p>

    <p class="text-gray-300">Our contributions. We investigate the feasibility of Gröbner basis attacks against Poseidon and Poseidon2 as the most important instances of HADES. Our approach is to conduct a thorough security analysis against the CICO problem in the context of Gröber basis attacks, which are considered to be among the most promising algebraic attacks against AO designs [\\[1\\]](#page-16-6).<a href="#page-1-0">5</a></p>

    <p class="text-gray-300"><span id="page-1-0"></span><sup>5</sup> See also <a href="#page-18-1">\\[29,</a> Sec. 5.2]</p>

    <p class="text-gray-300">To estimate the complexity of Gröbner basis attacks, we approximate the solving degree by computing the Gröbner basis for toy parameters and extrapolate the solving degree. Extrapolation of the solving degree is a common approach in the cryptography community to compute the Gröbner basis complexity <a href="#page-16-0">\\[4</a><a href="#page-19-0">,41</a><a href="#page-16-1">,6,</a><a href="#page-19-4">42,</a><a href="#page-17-0">14</a>[,9\\]](#page-17-5). The solving degree shows that the polynomial system describing Poseidon is not regular, and using the degree of regularity to bound the solving degree results in over-estimation of the provided security [\\[39\\]](#page-19-8). Moreover, in the design of HADES, it is believed that partial rounds provide the same security resistance against algebraic attacks as full rounds.<a href="#page-2-0">6</a> We demonstrate that in cases where the state size is larger than two, partial rounds offer less resistance against Gröbner basis attacks than full rounds. To show the impact of our observations and as a proof of concept, we demonstrate an instance with 1024 bits of security which is broken by our approach; the complete parameter set can be found in Table <a href="#page-2-1">1.</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(p) α t r RF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CGB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3 24 8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">85 712.98</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-2-1"></span>Table 1. an instance of Poseidon hash function with security parameter λ, state size t, rate r, and (R<sup>F</sup> , R<sup>P</sup> ) the number of full and partial rounds, respectively. CGB is the complexity of the Gröbner basis attack.</p>

    <p class="text-gray-300">The proposed algebraic attacks suggest that the partial layers do not provide the expected level of security against algebraic attacks, requiring that the security argument be re-evaluated for instances following this design strategy.</p>

    <p class="text-gray-300">Additionally, we conducted a more thorough investigation into Poseidon's security argument with respect to the claimed resistance against algebraic attacks. We revealed three distinct flaws in these arguments, each of which has implications for the required number of rounds. First, we show a typo in the security argument against Gröbner basis attacks in the full round setting. Then, we show that the logical reasoning for the security argument against the Gröbner basis attack is not sound. Finally, we present an error in the symbolic computation of bounds that undermines security.</p>

    <p class="text-gray-300">Structure of the Paper. In Section <a href="#page-3-0">2,</a> the notations used throughout the paper and the required background materials are described. In Section <a href="#page-6-0">3,</a> an overview of Poseidon and Poseidon2 designs, their security arguments, and the flaws in the security arguments are outlined. In Section <a href="#page-11-0">4,</a> a Gröbner basis attack is proposed, and vulnerable instances are demonstrated. In Section <a href="#page-14-0">4.4,</a> we compare the complexity of computing the Gröbner basis and the running time of the algorithm and discuss that running time is usually faster than the suggested complexity. Finally, in Section <a href="#page-16-7">5,</a> the paper is summarized, the steps</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>6</sup> See <a href="#page-18-6">\\[31,</a> Sec. 2: "Crucial Points of the Hades Strategy"] later retracted in Version 121947 of <a href="#page-18-7">\\[27,</a> Sec. 2.2: "Interaction Between Full and Partial Rounds"].</p>

    <p class="text-gray-300">taken toward disclosure are outlined, and possible directions for future research are discussed.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2 Preliminaries</h4>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 Notations and Definitions</h4>

    <p class="text-gray-300">In this paper, we define  <span class="math">\\lambda</span>  as the security parameter. To show an inclusive range of numbers, we use  <span class="math">[a, b] = \\{a, \\dots, b\\}</span> . Vectors are denoted by bold capital letters such as  <span class="math">\\mathbf{X}, \\mathbf{Y}, \\mathbf{Z}, \\dots</span>  and the elements of the vector  <span class="math">\\mathbf{X}</span>  are denoted by  <span class="math">(x_1, \\dots, x_n)</span> . Matrices are denoted by calligraphic capital letters such as  <span class="math">\\mathcal{M}, \\mathcal{N}</span>  where  <span class="math">\\mathcal{M}_{i,j}</span>  is the  <span class="math">j^{th}</span>  element in the  <span class="math">i^{th}</span>  row.</p>

    <p class="text-gray-300"><strong>Definition 1 (Macaulay Matrix [37]).</strong> Let  <span class="math">\\mathcal{P} \\in K[x_1, ..., x_n]</span>  be a polynomial system with monomial ordering  <span class="math">\\prec</span> , the Macaulay matrix  <span class="math">\\mathcal{M}<a href="\\mathcal{P}">d</a></span>  of degree d is a matrix with coefficients in K, where  <span class="math">\\mathcal{M}[d]_{i,j}</span>  is the coefficient of the  <span class="math">j^{th}</span>  biggest monomial with respect to  <span class="math">\\prec</span>  in the  <span class="math">i^{th}</span>  polynomial in the extended system. For example, let  <span class="math">\\mathcal{P} = \\{P_1, P_2\\} = \\{x^2 + xy, y\\}</span> . Then  <span class="math">\\mathcal{M}<a href="\\mathcal{P}">2</a></span>  for degrevlex order is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{M}[2](\\mathcal{P}) = \\begin{pmatrix} x^2 &amp; xy &amp; y^2 &amp; x &amp; y &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} P_1 \\\\ P_2 \\\\ xP_2 \\\\ yP_2 \\end{pmatrix}.</span></div>

    <p class="text-gray-300"><strong>Definition 2</strong> (Linear Algebra Constant ( <span class="math">\\omega</span> ) [43]). In the rest of this paper,  <span class="math">2 &lt; \\omega \\leq 2.3716</span>  is defined as the linear algebra constant and is the complexity of matrix multiplication.</p>

    <p class="text-gray-300"><strong>Definition 3 (CICO resistance).</strong> A hash function  <span class="math">H: D_1 \\times D_2 \\to R_1 \\times R_2</span>  is CICO resistant if it is computationally infeasible to find  <span class="math">x \\in D_1</span>  and  <span class="math">y&#x27; \\in R_2</span>  such that  <span class="math">H(\\{x,x&#x27;\\}) = \\{y,y&#x27;\\}</span>  for given  <span class="math">x&#x27; \\in D_2, y \\in R_1</span> .</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.2 Multivariate polynomial systems</h4>

    <p class="text-gray-300">Let K be a field, the polynomial ring  <span class="math">K[x_1, \\ldots, x_n]</span>  is a set of all polynomials in the variables  <span class="math">x_1, \\ldots, x_n</span>  and coefficients in K. A polynomial system is a finite set of polynomials  <span class="math">P_1, \\ldots, P_m \\in K[x_1, \\ldots, x_n]</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} P_1(x_1, \\dots, x_n) = 0 \\\\ P_2(x_1, \\dots, x_n) = 0 \\\\ \\vdots \\\\ P_m(x_1, \\dots, x_n) = 0 \\end{cases}</span></div>

    <p class="text-gray-300">The polynomial systems typically describing AO hash functions span a zerodimensional ideal, meaning that the set containing all their solutions is finite. One can use Gröbner basis to solve multivariate polynomial systems. The steps to solve a multivariate polynomial system using one of the Gröbner basis algorithms are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Compute a Gröbner basis with respect to degrevlex term order.</li>

      <li>2. Convert the Gröbner basis to lex term order.</li>

      <li>3. Find the roots of the polynomial system by factoring univariate polynomials and extending the partial solutions.</li>

    </ul>

    <p class="text-gray-300">The primary motivation for first computing the Gröbner basis in degrevlex order is its lower complexity compared to other term orderings. Complexity of Step 1. The complexity of computing a Gröbner basis in degrevlex term order is upper bounded by [\\[11\\]](#page-17-9):</p>

    <div class="my-4 text-center"><span class="math-block">O\\left(\\binom{n+d_{sol}}{d_{sol}}^{\\omega}\\right),\\tag{1}</span></div>

    <p class="text-gray-300">where n is the number of variables in the multivariate polynomial system and dsol is the solving degree of the polynomial system [\\[20\\]](#page-18-8). Solving degree is defined as the highest degree of the polynomials involved in the computation of the Gröbner basis using the F5 algorithm. In the case of regular systems, the solving degree matches the Macaulay bound which is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">d_{sol} = \\sum_{i=1}^{m} (d_i - 1) + 1,</span></div>

    <p class="text-gray-300">where d<sup>i</sup> is the polynomial degree of P<sup>i</sup> for 1 ≤ i ≤ m.</p>

    <p class="text-gray-300">However, most of the AO primitives, when modeled as a polynomial system, are not regular systems <a href="#page-16-0">\\[4,</a><a href="#page-19-8">39,</a>[9\\]](#page-17-5), and in most of the cases, the solving degree grows slower than the Macaulay bound.</p>

    <p class="text-gray-300">To determine the solving degree, the current approach used in design and cryptanalysis is to compute the solving degrees of round-reduced versions of the system, and extrapolate a bound for it <a href="#page-16-0">\\[4</a><a href="#page-16-6">,1,</a><a href="#page-17-5">9,</a><a href="#page-19-8">39,</a>[14\\]](#page-17-0).</p>

    <p class="text-gray-300">Complexity of Step 2. The computed Gröbner basis in degrevlex order is usually complicated and not useful for solving the system. Therefore, it is converted to a Gröbner basis in lex order. The conversion is performed using the FGLM [\\[23\\]](#page-18-9) algorithm and the complexity is upper bounded by:</p>

    <p class="text-gray-300"><span class="math-block">O\\left(nD^3\\right)</span> ,</p>

    <p class="text-gray-300">where D is the degree of the zero-dimensional ideal. In some cases, this step can be performed more efficiently using the sparse FGLM [\\[24\\]](#page-18-10) algorithm which has asymptotic complexity of:</p>

    <div class="my-4 text-center"><span class="math-block">O(\\sqrt{6/n\\pi}D^{2+\\frac{n-1}{n}}). (2)</span></div>

    <p class="text-gray-300">Complexity of Step 3. When the ideal is zero-dimensional (as is the case for us), the Gröbner basis in the lex order contains a unique univariate polynomial that can be factored and is used to iteratively solve the entire system. When the unique univariate polynomial is factored, it results in a partial solution to the system. In an iterative process, partial solutions are substituted in other polynomials, and these are factored in a similar way until a full solution is obtained solving a univariate polynomial system of degree D defined over the finite field  <span class="math">\\mathbb{F}_p</span>  the Cantor/Zassenhaus [16] algorithm can be used with complexity [40]:</p>

    <div class="my-4 text-center"><span class="math-block">O(D^2(\\log D \\log \\log D)(\\log p + \\log D)).</span></div>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.3 The Sponge Construction</h4>

    <p class="text-gray-300">The Sponge construction [10] is a generic method for constructing a hash function from a fixed-length public permutation. Let  <span class="math">\\mathbb{F}_p</span>  be a finite field of order p and  <span class="math">f: \\mathbb{F}_p^n \\to \\mathbb{F}_p^n</span>  be a fixed-length transformation operating over a state of size n with elements in  <span class="math">\\mathbb{F}_p</span> . The sponge function F with rate r and capacity c where r+c=n, takes as input  <span class="math">\\mathbf{M}</span>  of arbitrary length, and after applying a padding function, generates the output  <span class="math">\\mathbf{H}</span> . The length of the padded input and the output of F is a multiple of r. The sponge function works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Let <strong>S</strong> be the state of the sponge function of length n = r + c.</li>

      <li>2. The state <strong>S</strong> is initialized to  <span class="math">(0, \\ldots, 0)</span> .</li>

      <li>3. Absorbing phase: The padded message  <span class="math">\\mathbf{M}</span>  is split into  <span class="math">\\chi</span>  blocks  <span class="math">\\mathbf{M}_1, \\mathbf{M}_2, \\dots, \\mathbf{M}_{\\chi}</span>  of length r. For each  <span class="math">i \\in 1, 2, \\dots, \\chi</span> , the  <span class="math">\\mathbf{M}_i</span>  is added to the first r blocks of  <span class="math">\\mathbf{S}</span>  and the function f is applied i.e.,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{S} = f(\\mathbf{S} + \\mathbf{M}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{0})$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Squeezing phase: once all blocks of the padded message have been absorbed, the squeezing phase starts to generate the output. In this phase, the function outputs blocks  <span class="math">\\mathbf{H}_1, \\ldots, \\mathbf{H}_{\\chi&#x27;}</span>  of length r and update the internal state  <span class="math">\\mathbf{S}</span>  by applying the function f.</li>

    </ol>

    <p class="text-gray-300">In Figure 1, a schematic construction of the sponge function is illustrated. To study more about sponge construction in the context of ZK-friendly hash functions, we refer to [8].</p>

    <p class="text-gray-300">Assuming that f is computationally indistinguishable from a random permutation, a sponge function with capacity of c elements offers  <span class="math">2^{\\log_2(p)c/2}</span>  bits of collision resistance and preimage resistance [10].</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">2.4 The HADES Design Strategy</h4>

    <p class="text-gray-300">The HADES design strategy is a paradigm for developing efficient and secure AO primitives. HADES uses two types of SPN networks, known as <em>full layers</em>—placed at the beginning and at the end of the permutation—and <em>partial layers</em>, placed in the middle. Each full round of HADES works as follows:</p>

    <p class="text-gray-300"><img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-6-1"></span>Fig. 1. A sponge function with rate r, capacity c, and internal permutation f.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Add round keys.</li>

      <li>2. Substitution (non-linear) layer applied to all the elements in the state.</li>

      <li>3. Permutation (linear) layer.</li>

    </ul>

    <p class="text-gray-300">Each partial round of HADES works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Add round keys.</li>

      <li>2. Substitution (non-linear) layer applied to specific elements, usually the first one, in the state.</li>

      <li>3. Permutation (linear) layer.</li>

    </ul>

    <p class="text-gray-300">In Figure <a href="#page-6-2">2</a> an overview of the HADES design strategy is depicted.</p>

    <p class="text-gray-300"><img src="_page_6_Figure_12.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-6-2"></span>Fig. 2. The SPN layer at the beginning and the end are full layers. The PSPN in the middle is the partial layer where the S-box only applies to the first element of the state.</p>

    <p class="text-gray-300">Let us denote the set of vectors over the finite field F<sup>p</sup> with arbitrary length with F ∗ p . Poseidon: F ∗ <sup>p</sup> → (F r p ) χ is a hash function operating over F<sup>p</sup> with output of χ ′ blocks of length r. It is constructed by using the Poseidon<sup> <span class="math">\\pi</span> </sup> permutation in the sponge construction with rate r and capacity c. Poseidon<sup> <span class="math">\\pi</span> </sup> is a permutation with a state size of t and consists of  <span class="math">R = R_F + R_P</span>  rounds, where  <span class="math">R_F = R_f + R_f</span>  rounds are full rounds with t S-boxes, and  <span class="math">R_P</span>  rounds are partial rounds with only one S-box applied to the first element of the state. The Poseidon<sup> <span class="math">\\pi</span> </sup> permutation is illustrated in Figure 3 and works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Add round constants:  <span class="math">ARC_{\\mathbf{C}} : \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span> ,  <span class="math">ARC_{\\mathbf{C}}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{C}</span> .</li>

      <li>2. Substitution layer:  <span class="math">S_{\\alpha} : \\mathbb{F}_p \\to \\mathbb{F}_p</span> ,  <span class="math">S_{\\alpha}(x) = x^{\\alpha}</span> , where the S-box is applied to the first element (in partial rounds), or all elements of the state (in full rounds).</li>

      <li>3. Linear layer:  <span class="math">L_{\\mathcal{M}}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span> ,  <span class="math">L_{\\mathcal{M}}(\\mathbf{X}) = \\mathcal{M} \\cdot \\mathbf{X}^{\\mathsf{T}}</span>  where  <span class="math">\\mathcal{M}</span>  is a MDS matrix.</li>

    </ul>

    <p class="text-gray-300">Where  <span class="math">\\mathcal{M}</span>  is a Cauchy matrix [44] and is defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{M}_{i,j} = \\frac{1}{x_i + y_j},</span></div>

    <p class="text-gray-300">for pairwise distinct  <span class="math">x_i</span>  and  <span class="math">y_j</span>  with the condition that  <span class="math">x_i + y_j \\neq 0</span>  for all  <span class="math">i, j \\in [1, t]</span> .</p>

    <p class="text-gray-300">To improve the efficiency of Poseidon, the authors designed Poseidon2. Poseidon2 uses different partial rounds and different linear layers. Posedion2 works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Initial linear layer:  <span class="math">L_{\\mathcal{M}&#x27;}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span> ,  <span class="math">L_{\\mathcal{M}&#x27;}(\\mathbf{X}) = \\mathcal{M}&#x27; \\cdot \\mathbf{X}^{\\mathsf{T}}</span>  where  <span class="math">\\mathcal{M}&#x27;</span>  is an MDS matrix.</li>

      <li>2. For R rounds:</li>

      <li>(a) Add round constants:  <span class="math">ARC_{\\mathbf{C}}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">ARC_{\\mathbf{C}}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{C}.</span></div>

    <p class="text-gray-300">In the case of partial rounds,  <span class="math">\\mathbf{C} = (c_1, 0, \\dots, 0)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(b) Substitution layer:  <span class="math">S_{\\alpha}: \\mathbb{F}_{p} \\to \\mathbb{F}_{p}</span> ,  <span class="math">S_{\\alpha}(x) = x^{\\alpha}</span> , where the S-box is applied to the first element (in partial rounds), or all elements of the state (in full rounds).</li>

      <li>(c) Linear layer:  <span class="math">L_{\\mathcal{M}} : \\mathbb{F}_p \\to \\mathbb{F}_p, \\ L_{\\mathcal{M}}(\\mathbf{X}) = \\mathcal{M} \\cdot \\mathbf{X}^{\\mathsf{T}}.</span></li>

    </ul>

    <p class="text-gray-300">Where  <span class="math">\\mathcal{M}</span>  is an MDS matrix. In case of full rounds,  <span class="math">\\mathcal{M} = \\mathcal{M}&#x27;</span>  and is same as the MDS matrices defined for Griffin- <span class="math">\\pi</span>  [26]. In case of partial rounds,  <span class="math">\\mathcal{M} = \\mathcal{M}&#x27;&#x27;</span>  is defined in [30, Section 5.2]. Figure 3 depicts how Poseidon and Poseidon2 work and the updated operations in Poseidon2 are denoted by dashed lines.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instances of Poseidon and Poseidon2 that provide  <span class="math">\\lambda</span>  bits of security, guarantee that any algorithm that finds collision or preimage requires a complexity of at least  <span class="math">2^{\\lambda}</span> . In the case of the CICO problem, as long as finding  $x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x' \\in D<span class="math">  using exhaustive search is not possible with complexity less than  </span>2^{\\lambda}<span class="math"> , any algorithm that finds such  </span>x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x' \\in D<span class="math">  requires a complexity of at least  </span>2^{\\lambda}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><img src="_page_8_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-8-0"></span>Fig. 3. Construction of Poseidon<sup>π</sup> (bottom), and Poseidon2<sup>π</sup> (top) permutations. The modified steps are shown with dashed line</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Security Claims for Poseidon and Poseidon2</h3>

    <p class="text-gray-300">The security of Poseidon is analyzed against various attacks in order to compute the reliable number of required rounds. The authors provided a script to facilitate the computation of the number of rounds<a href="#page-8-1">7</a> . In our analysis, we utilized this script to calculate the necessary number of rounds required to ensure the security of our chosen parameters. Currently, the scripts are updated after communicating the results with the authors.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Flaws in the Security Analysis of Poseidon</h3>

    <p class="text-gray-300">In addition to the flaw described in Section <a href="#page-11-0">4,</a> we identified three more minor flaws which, when combined, increase the likelihood of an attack to exist. In Section <a href="#page-8-2">3.2,</a> we demonstrate that using loose bounds in security arguments leads to incorrect conclusions. In Section <a href="#page-10-0">3.2,</a> we investigate the security argument against Gröbner basis attacks in the case of χ = 1, where the system is already a Gröbner basis in the full-permutation setting. We highlight a typo causing an underestimation of the required number of rounds. Finally, in Section <a href="#page-11-1">3.2,</a> we identify a flaw in the symbolic computations of round-level Gröbner basis analysis that led to an overclaiming of the security.</p>

    <p class="text-gray-300"><span id="page-8-2"></span>Improper Logic The argument for determining the number of rounds that is safe against a Gröbner basis attack can be summarized as follows <a href="#page-18-1">\\[29,</a> Section 5.5.2]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Compute the complexity of the attack as a function of the Poseidon parameters α, R<sup>F</sup> , R<sup>P</sup> , t, r, χ, λ.</li>

      <li>2. Optionally, derive an upper bound for the computed complexity that is easier to manipulate.</li>

      <li>3. Calculate the maximum number of rounds R<sup>∗</sup> F and R<sup>∗</sup> P that can be attacked given the parameters of Poseidon.</li>

    </ul>

    <p class="text-gray-300"><span id="page-8-1"></span><sup>7</sup> <https://extgit.iaik.tugraz.at/krypto/hadeshash></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assume that all values for R<sup>F</sup> , R<sup>P</sup> higher than R<sup>∗</sup> F , R<sup>∗</sup> P cannot be attacked and are secure.</li>

    </ol>

    <p class="text-gray-300">The problem arises due to Step 2, where a lower bound should be used. As a result, Step 4 concludes resistance against adversaries that Step 3 did not handle.</p>

    <p class="text-gray-300">Consider a simple example: let us assume that a sponge construction with rate r uses an N-round permutation; further, assume an attack with complexity 2 <sup>3</sup>N r. However, this expression may be challenging to work with (e.g., because 3 is odd and we wish to take a square root) so we attempt to simplify it by noting that 2 <sup>3</sup>N r ≤ 2 <sup>4</sup>N r, although this is not a tight upper bound. Using the argumentation shown above, we find N<sup>∗</sup> from:</p>

    <div class="my-4 text-center"><span class="math-block">2^{4N^*r} = 2^{\\lambda}.</span></div>

    <p class="text-gray-300">Solving for N<sup>∗</sup> yields</p>

    <div class="my-4 text-center"><span class="math-block">N^* = \\frac{\\lambda}{4r}.</span></div>

    <p class="text-gray-300">Consequently, for all 0 ≤ N ≤ N<sup>∗</sup> , a sponge function using the N-round permutation can be attacked. This is still a true statement. Using the above argumentation, it is then conjectured that the sponge function is safe from attacks for all N ≥ N<sup>∗</sup> = λ 4r . This is not a true statement as now using the proper expression to find a safe number of rounds Ns, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">2^{3N_s r} = 2^{\\lambda},</span></div>

    <p class="text-gray-300">and find:</p>

    <div class="my-4 text-center"><span class="math-block">N_s = \\frac{\\lambda}{3r}.</span></div>

    <p class="text-gray-300">Therefore, for all 0 ≤ N ≤ Ns, the sponge function can be attacked, and for all N > Ns, the sponge function is safe for the given security level. The problem is that for N<sup>∗</sup> ≤ N ≤ Ns, we argued that the sponge construction with N rounds is safe, while it is not the case. When using Step 3 and Step 4 outlined earlier, one should use a lower bound rather than an upper bound in Step 2, as it may result in an overestimation of the resistance of the sponge function against attacks.</p>

    <p class="text-gray-300">Similarly, the resistance of Poseidon against a round-level Gröbner basis attack is found to be (up to reasonable approximation) [\\[29\\]](#page-18-1):</p>

    <div class="my-4 text-center"><span class="math-block">C_{\\rm GB} = 2^{Cq - C&#x27;},</span></div>

    <p class="text-gray-300">with</p>

    <div class="my-4 text-center"><span class="math-block">C = 2\\log_2\\left(\\frac{\\alpha^{\\alpha}}{(\\alpha - 1)^{\\alpha - 1}}\\right)$$ $$C&#x27; = \\log_2\\left(\\frac{2\\pi(\\alpha - 1)q}{\\alpha}\\right)$$ $$q = (t - 1)R_F + R_P + \\chi</span></div>

    <p class="text-gray-300">That concludes Step 1. In Step 2, this approximation was upper-bounded by:</p>

    <p class="text-gray-300"><span id="page-10-2"></span><span id="page-10-1"></span> <span class="math-block">C_{GB} = 2^{C \\cdot q - C&#x27;} \\le 2^{C \\cdot q}, \\tag{3}</span></p>

    <p class="text-gray-300">Ultimately, resistance against the round-level attack is assumed as long as:</p>

    <div class="my-4 text-center"><span class="math-block">(t-1)R_F + R_P \\ge C^{-1}\\min\\{\\lambda, \\log_2(p)\\} - 1,\\tag{4}</span></div>

    <p class="text-gray-300">Since (3) is not a tight bound (4) necessarily underestimates the required number of round. The effect of this omission is more noticeable when  <span class="math">\\alpha</span> , state size t, and rate r grow.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><strong>Transcription Error Full-Permutation Equation</strong>. In the full round equation setting [29, Section C.2.2], a system of equations for the entire R rounds is derived by considering each input as a variable and applying the round functions to them. When the number of input variables  <span class="math">\\chi</span>  is the same as the number of output variables, the resulting system will consist of  <span class="math">\\chi</span>  equations in  <span class="math">\\chi</span>  variables, and the degree of each polynomial is upper-bounded by  <span class="math">D_{\\alpha}(R) = \\alpha^{R}</span> .</p>

    <p class="text-gray-300">When  <span class="math">\\chi=1</span> , the system consists of a single polynomial of degree at most  <span class="math">\\alpha^R</span>  in one variable, which is already a Gröbner basis in lex order. Therefore, the only step required to complete the attack is the factorization of the univariate polynomial. Per the security argument provided in [29, Section C.2.2], one should have:</p>

    <div class="my-4 text-center"><span class="math-block">\\log_2\\left(\\alpha^{\\omega R}\\right) \\geq \\log_2\\left(\\alpha^{2R}\\right) \\geq \\min\\{\\lambda, \\log_2(p)\\},</span></div>

    <p class="text-gray-300">which implies:</p>

    <div class="my-4 text-center"><span class="math-block">R \\geq \\left\\lceil \\frac{\\min\\{\\lambda, \\log_2(p)\\}}{2\\log_2\\alpha} \\right\\rceil = \\log_\\alpha(2) \\cdot \\min\\{\\frac{\\lambda}{\\mathbf{2}}, \\frac{\\log_2(p)}{2}\\},</span></div>

    <p class="text-gray-300">where  <span class="math">R = R_F + R_P</span> . Later, the designers in [29, Equation 11], write the constraint for the full round attack as:</p>

    <div class="my-4 text-center"><span class="math-block">R_F + R_P \\ge \\log_{\\alpha}(2) \\cdot \\min\\{\\frac{\\lambda}{3}, \\frac{\\log_2(p)}{2}\\},\\tag{5}</span></div>

    <p class="text-gray-300">where the denominator of the fraction  <span class="math">\\frac{\\lambda}{3}</span>  is 3 instead of 2. This mistake results in an overestimation of the security that the Poseidon permutation provides against Gröbner basis attacks in the case where  <span class="math">\\chi = 1</span> .</p>

    <p class="text-gray-300">As an example of how the mistake influences the number of rounds, the constraint in [29, Equation 5] would imply that 6 full rounds and 22 partial rounds are sufficient for  <span class="math">\\alpha=3, t=2, p\\approx 2^{1024}</span> , and a desired security level of 128 bits, whereas to gain that security level for these parameters, at least 35 partial rounds are required.</p>

    <p class="text-gray-300"><span id="page-11-1"></span>Symbolic Computation Error In <a href="#page-18-1">\\[29,</a> Section C.2.2] it is shown that for security level of λ, the maximum number of rounds that can be attacked using Gröbner basis is:</p>

    <p class="text-gray-300"><span id="page-11-2"></span> <span class="math-block">(t-1)R_F + R_P + \\chi \\le C^{-1} \\cdot \\min\\{\\lambda, \\log_2(p)\\chi\\},</span>  (6)</p>

    <p class="text-gray-300">with</p>

    <div class="my-4 text-center"><span class="math-block">C = 2\\log_2\\left(\\frac{\\alpha^{\\alpha}}{(\\alpha - 1)^{\\alpha - 1}}\\right).</span></div>

    <p class="text-gray-300">The designers argue that the maximal number of rounds that can be attacked is when χ = 1 <a href="#page-18-1">\\[29,</a> Section C.2.2] but this is not true. Rewriting <a href="#page-11-2">\\(6\\)</a>, we get</p>

    <div class="my-4 text-center"><span class="math-block">(t-1)R_F + R_P \\le C^{-1} \\cdot \\min\\{\\lambda - \\chi C, \\chi(\\log_2(p) - C)\\}.</span></div>

    <p class="text-gray-300">Here, the first argument of the minimum function is indeed maximized for χ = 1, but the last argument is maximized for χ = t−1 because λ−C is positive for the suggested parameters of Poseidon. Ultimately, security is conjectured if:</p>

    <div class="my-4 text-center"><span class="math-block">(t-1)R_F + R_P \\ge C^{-1} \\cdot \\min\\{\\lambda, \\log_2(p)\\} + t - 2,</span></div>

    <p class="text-gray-300">but if we address the algebra error, we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">(t-1)R_F + R_P \\ge C^{-1} \\cdot \\min\\{\\lambda + C(t-2), \\log_2(p)(t-1)\\}.</span></div>

    <p class="text-gray-300">Previously, the constraint for this kind of Gröbner basis attack appeared to be less restrictive than the other attacks, as it was subsumed by the constraints for the other kinds of Gröbner basis attacks <a href="#page-18-1">\\[29,</a> Equation 11]. However, once the error is addressed, this is no longer true. More importantly, there are parameter sets for which this constraint would require the highest number of partial rounds to be secure. For example, for α = 3, log<sup>2</sup> (p) ≈ 256, λ = 1536, R<sup>F</sup> = 8, t = 8, an interpolation attack would be thwarted if R<sup>P</sup> ≥ 158, a subspace attack would fail if R<sup>P</sup> ≥ 80, and a full-permutation attack requires R<sup>P</sup> ≥ 73, but a roundlevel Gröbner basis attack require R<sup>P</sup> ≥ 230 to achieve required resistance. Therefore, <a href="#page-18-1">\\[29,</a> Equation. 5] requires three constraints rather than two and this omission does affect the required number of rounds for some parameter sets.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 The Gröbner Basis Attack</h2>

    <p class="text-gray-300">The CICO resistance of Poseidon and Poseidon2 is analyzed using the Gröbner basis attacks in this section. To solve the CICO problem, we first model Poseidon and Poseidon2 as a system of multivariate polynomials with known output and unknown input and we solve the system to find the desired input.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.1 Poseidon: Polynomial Modeling</h3>

    <p class="text-gray-300">Poseidon is modeled for the case where α = 3, the number of input blocks of size r is χ = 1 and the underlying permutation is applied only once. In Poseidon, which is a sponge function, the first r elements of the input state of the permutation are absorbed from the input, and the next c elements are initialized to a constant value. Without loss of generality, we can assume that the last c element of the input state is initialized to 0.</p>

    <p class="text-gray-300">while it is possible to model Poseidon in various ways using algebraic relations describing them, the model that minimizes the complexity of the Gröbner basis attack is the preferred one.</p>

    <p class="text-gray-300">After a thorough analysis of various methods for polynomial modeling, we identified the approach used by Sauer [\\[39\\]](#page-19-8) that aims to minimize the solving degree of the system results in the lowest theoretical complexity.</p>

    <p class="text-gray-300">In the described polynomial system, C<sup>i</sup> = {ci,1, . . . , ci,t} denotes the round constants for round i ∈ {1, . . . , R}. X<sup>i</sup> = {xi,1, . . . , xi,t} are the variables that describe the state of the round i ∈ {0, . . . , R}, where X<sup>0</sup> = (x1, . . . , xr, 0, . . . , 0) is the input and X<sup>R</sup> = (H1, . . . , Hr, xR,r+1, . . . , xR,t) is the output. The first round of Poseidon before multiplication by M can be described as:</p>

    <p class="text-gray-300"><span class="math-block">x_{1,j} - (x_{0,j} + c_{1,j})^{\\alpha} = 0</span>   <span class="math">j \\in [1, r],</span></p>

    <p class="text-gray-300">that has 2r variables and r polynomials. The state after the first and second S-box layers is modeled as follows:</p>

    <div class="my-4 text-center"><span class="math-block">x_{2,j} - \\left( \\left( \\sum_{k=1}^{r} \\mathcal{M}_{j,k} \\cdot x_{1,k} + \\sum_{k=r+1}^{t} \\mathcal{M}_{j,k} \\cdot c_{1,k}^{\\alpha} \\right) + c_{2,j} \\right)^{\\alpha} = 0,</span></div>

    <p class="text-gray-300">where j ∈ [1, t]. The described polynomials add t new variables and t new polynomials to the system. The next R<sup>f</sup> full rounds (i.e., 3 ≤ i ≤ R<sup>f</sup> ) are modeled as:</p>

    <div class="my-4 text-center"><span class="math-block">x_{i,j} - \\left( \\left( \\sum_{k=1}^{t} \\mathcal{M}_{j,k} \\cdot x_{i-1,k} \\right) + c_{i,j} \\right)^{\\alpha} = 0 \\qquad j \\in [1,t],</span></div>

    <p class="text-gray-300">adding (R<sup>f</sup> − 2)t new variables and (R<sup>f</sup> − 2) new polynomials to the system. We introduce a variable Y to simplify the equations for partial rounds and it is initialized as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Y}^{\\mathsf{T}} = \\mathcal{M} \\cdot (x_{R_f,1}, \\dots, x_{R_f,t})^{\\mathsf{T}}.</span></div>

    <p class="text-gray-300">The partial rounds R<sup>f</sup> < i ≤ R<sup>f</sup> + R<sup>P</sup> are modeled as:</p>

    <div class="my-4 text-center"><span class="math-block">x_{i,1} - (y_1 + c_{i,1})^{\\alpha} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">y_j = \\mathcal{M}_{j,1} \\cdot x_{i,1} + \\sum_{k=2}^t \\mathcal{M}_{j,k} \\cdot (y_k + c_{i,k}) \\qquad j \\in [1, t],</span></div>

    <p class="text-gray-300">adding R<sup>P</sup> new variables and R<sup>P</sup> new polynomials to the system. The last R<sup>f</sup> rounds R<sup>f</sup> + R<sup>p</sup> < i ≤ R − 1 are modeled as:</p>

    <div class="my-4 text-center"><span class="math-block">x_{i,j} - (y_j + c_{i,j})^{\\alpha} = 0 \\qquad j \\in [1, t]$$ $$y_j = \\sum_{k=1}^t \\mathcal{M}_{j,k} \\cdot x_{i,k} \\qquad j \\in [1, t],</span></div>

    <p class="text-gray-300">that add (R<sup>f</sup> −1)t variables in (R<sup>f</sup> −1)t polynomials to the system. Finally, the last round is modeled as:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{k=1}^{t} \\mathcal{M}_{j,k}^{-1} \\cdot x_{R,k} - (y_j + c_{R,j})^{\\alpha} = 0 \\qquad j \\in [1, t].</span></div>

    <p class="text-gray-300">The last round adds c new variables and t polynomial to the system. The final system has r + (R<sup>F</sup> − 1)t + R<sup>P</sup> polynomials of degree α in r + (R<sup>F</sup> − 1)t + R<sup>P</sup> variables.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.2 Poseidon2: Polynomial Modeling</h3>

    <p class="text-gray-300">Poseidon and Poseidon2 differ in the linear layer, constant addition layer for partial rounds, and the initial round. The first round can be modeled as follows:</p>

    <p class="text-gray-300"><span class="math-block">x_{1,j} - \\left(\\sum_{k=1}^{t} \\mathcal{M}&#x27;&#x27;[j,k] \\cdot x_{0,k} + c_{1,j}\\right)^{\\alpha} = 0</span>   <span class="math">j \\in [1,r],</span></p>

    <p class="text-gray-300">The full rounds are modeled in the same way as in Section <a href="#page-12-0">4.1</a> with different coefficients coming from M′′. The partial rounds are modeled as follows:</p>

    <div class="my-4 text-center"><span class="math-block">x_{i,1} - (y_1 + c_{i,1})^{\\alpha} = 0</span></div>

    <p class="text-gray-300"><span class="math-block">y_j = \\mathcal{M}&#x27;_{j,1} \\cdot x_{i,1} + \\sum_{k=2}^t \\mathcal{M}&#x27;_{j,k} \\cdot (y_k)</span>   <span class="math">j \\in [1, t],</span></p>

    <p class="text-gray-300">where Y is defined in the same way as Section <a href="#page-12-0">4.1.</a> The final system, similar to Poseidon's system, has r + (R<sup>F</sup> −1)t+R<sup>P</sup> polynomials of degree α in r + (R<sup>F</sup> − 1)t + R<sup>P</sup> variables.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.3 Complexity of the Attack</h3>

    <p class="text-gray-300">Both Poseidon and Poseidon2 can be modeled as a sequence of polynomials that are not regular. Therefore, the Macaulay bound used in [\\[29\\]](#page-18-1) is a loose upper bound for the solving degree of the system. In order to extrapolate the solving degree, we run the attack for smaller parameters and derive a formula for the solving degree. We calculated the solving degree for more than 100 different parameter sets of Poseidon and Poseidon2, with state sizes up to five and rate up to four, using different values for α. Our experiments show that changing the value of α, does not affect the asymptotic growth of the solving degree when the number of rounds is increased. More precisely, the solving degree grows at the same rate independently of α in all the cases we analyzed (i.e., the derivative of the solving degree does not change). In addition, the field size seems to have no effect on the value or the growth of solving degrees. In the case of Poseidon2, the solving degree is the same as Poseidon's solving degree when R<sup>F</sup> > 2. Using the collected data, and the conjecture that the solving degree grows linearly as a function of a number of variables, we propose the following heuristic formula for the solving degree.</p>

    <div class="my-4 text-center"><span class="math-block">d_{sol} = r \\frac{R_F}{2} + 0.8R_P + \\alpha. (7)</span></div>

    <p class="text-gray-300">Our experiments show that partial rounds do not provide the same level of resistance against algebraic attacks as full rounds and the solving degree growth is a function of the rate instead of the state size.</p>

    <p class="text-gray-300"><img src="_page_14_Figure_5.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 4. Comparison of the claimed solving degree [\\[29\\]](#page-18-1) and the solving degree of the system describing Poseidon for different state sizes when R<sup>P</sup> = 0, and rate = 1. The solving degree growth is a linear function of the number of rounds and not the state size. The plot on the right shows the overestimation of the complexity of Poseidon in [?] and the complexity of this work.</p>

    <p class="text-gray-300">In Table <a href="#page-15-0">2,</a> we describe instances of Poseidon and Poseidon2 in which the complexity of a Gröbner basis attack is less than their claimed security level.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">4.4 Discussion on Complexity and Running time</h4>

    <p class="text-gray-300">In an attempt to optimize the polynomial system describing Poseidon from [\\[39\\]](#page-19-8), one can remove the variables corresponding to the output capacity which results</p>

    <p class="text-gray-300">|   |     |   |   |   |   |    |        | <span class="math">\\mathcal{C}_{\\text{SFGLM}}</span> |        |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |     |   |   |   |   |    |        | 705.67                       |        |</p>

    <p class="text-gray-300">|   |     |   |   |   |   |    |        | 615.40                       |        |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">İ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">384</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">47</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">351.56</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">593.25</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">400.61</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-15-0"></span><strong>Table 2.</strong> Examples of Poseidon and Poseidon2 hash functions with security parameter  <span class="math">\\lambda</span>  over the finite field  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">\\log_2(p) \\approx 128</span> .  <span class="math">\\mathcal{C}_{GB}</span>  is the complexity of computing the Gröbner basis in <em>degrevlex</em> order,  <span class="math">\\mathcal{C}_{SFGLM}</span>  is the asymptotic complexity of sparse FGLM, and  <span class="math">\\mathcal{C}_{Elim}</span>  is the complexity factoring univariate polynomials and recovering their roots.</p>

    <p class="text-gray-300">in a polynomial system with <strong>larger</strong> solving degree and fewer variables. Comparing the theoretical complexity of the attack of both systems shows that removing these variables makes the system harder to solve. However, computing the Gröbner basis for the system with fewer variables is more efficient in practice and has a noticeably lower running time than suggested by the theoretical complexity. For example, modeling an instance with  <span class="math">(R_F = 10, R_P = 2, t = 2, r = 1)</span>  using the first approach resulted in a complexity of  <span class="math">&gt; 2^{52}</span>  and the code did not terminate after 7 days.<sup>8</sup> On the other hand, when modeling the same instance using the second approach, the complexity for computing the Gröbner basis is  <span class="math">2^{63.3}</span>  and the code terminates after  <span class="math">2^{16.64}</span>  seconds. These two instances are described in Table 3.</p>

    <p class="text-gray-300"><span id="page-15-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Polynomial Modeling</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theoretical Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Expected Running Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Actual Running Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(field multiplications)</td>

            <td class="px-3 py-2 border-b border-gray-700">(seconds)</td>

            <td class="px-3 py-2 border-b border-gray-700">(seconds)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimize solving degree</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{52}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{18.42}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">> 2 <sup>19.2</sup></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Minimize variables</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{63.3}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{31.3}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{16.64}</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Table 3.</strong> POSEIDON instances with running time that does not match the expected complexity. The expected running time is computed using the number of basic CPU operations that can be done in 1 second on the host machine.</p>

    <p class="text-gray-300">A similar observation is made in [28] and the authors use  <span class="math">\\omega=1</span>  to ensure a security margin. An explanation for the faster running time is that the F4/F5 algorithms that are commonly used in computing the Gröbner basis do not work with the full Macaulay matrix, but rather smaller submatrices that are selected based on ad-hoc criteria. Moreover, the matrices are highly sparse, and therefore the running time of the algorithm is noticeably faster than what the complexity suggests. Therefore, using  <span class="math">\\omega=2</span>  in analyzing the security of the design may lead to an overestimation of the actual resources the attacker requires to break it.</p>

    <p class="text-gray-300"><span id="page-15-1"></span><sup>&</sup>lt;sup>8</sup> At this point it was killed by the cluster's scheduler.</p>

    <p class="text-gray-300">In this paper, we analyzed the security of Poseidon and Poseidon2 which are primitives based on the HADES design strategy. We studied Gröbner basis attacks, and showed that partial rounds are not providing the claimed resistance. Using Gröbner basis attacks, we break instances of Poseidon and Poseidon2 claiming 1024 bits of security using an attack whose complexity is upper bounded by 2 <sup>731</sup>.<sup>77</sup> and show that the original security argument does not hold for instances with as small as 384 bits of claimed security. Since the vulnerabilities presented in this paper are more pronounced in non-standard security levels we are not aware of any practical instance directly affected. However, we argued that the actual running time of the attack is significantly less than what is suggested by the complexity analysis and hence we encourage the potential users to consider in their risk assessment the ongoing erosion in the security of HADES instances.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-16-6"></span>1. Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of stark-friendly designs: Application to marvellous and mimc. In: Galbraith, S.D., Moriai, S. (eds.) Advances in Cryptology – ASIACRYPT 2019. pp. 371–397. Springer International Publishing, Cham (2019)</li>

      <li><span id="page-16-3"></span>2. Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In: Cheon, J.H., Takagi, T. (eds.) Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I. Lecture Notes in Computer Science, vol. 10031, pp. 191–219 (2016). <https://doi.org/10.1007/978-3-662-53887-6\\_7>, <a href="https://doi.org/10.1007/978-3-662-53887-6_7">https://doi.org/10.</a> <a href="https://doi.org/10.1007/978-3-662-53887-6_7">1007/978-3-662-53887-6\\\\_7</a></li>

      <li><span id="page-16-4"></span>3. Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for mpc and fhe. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology – EUROCRYPT 2015. pp. 430–454. Springer Berlin Heidelberg, Berlin, Heidelberg (2015)</li>

      <li><span id="page-16-0"></span>4. Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR Trans. Symmetric Cryptol. 2020(3), 1–45 (2020). <a href="https://doi.org/10.13154/tosc.v2020.i3.1-45">https://doi.org/10.13154/tosc.</a> <a href="https://doi.org/10.13154/tosc.v2020.i3.1-45">v2020.i3.1-45</a>, <https://doi.org/10.13154/tosc.v2020.i3.1-45></li>

      <li><span id="page-16-5"></span>5. Ashur, T., Kindi, A., Mahzoun, M.: Xhash8 and xhash12: Efficient stark-friendly hash functions. IACR Cryptol. ePrint Arch. p. 1045 (2023), <a href="https://eprint.iacr.org/2023/1045">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2023/1045">org/2023/1045</a></li>

      <li><span id="page-16-1"></span>6. Ashur, T., Kindi, A., Meier, W., Szepieniec, A., Threadbare, B.: Rescue-prime optimized. Cryptology ePrint Archive, Paper 2022/1577 (2022), <a href="https://eprint.iacr.org/2022/1577">https://eprint.</a> <a href="https://eprint.iacr.org/2022/1577">iacr.org/2022/1577</a>, <https://eprint.iacr.org/2022/1577></li>

      <li><span id="page-16-2"></span>7. Ashur, T., Mahzoun, M., Toprakhisar, D.: Chaghri - a fhe-friendly block cipher. In: Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. p. 139–150. CCS '22, Association for Computing Machin-</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ery, New York, NY, USA (2022). <https://doi.org/10.1145/3548606.3559364>, <https://doi.org/10.1145/3548606.3559364></li>

      <li><span id="page-17-11"></span>8. Aumasson, J., Khovratovich, D., Mennink, B., Quine, P.: Safe: Sponge api for field elements. Cryptology ePrint Archive, Paper 2023/522 (2023), <a href="https://eprint.iacr.org/2023/522">https://eprint.</a> <a href="https://eprint.iacr.org/2023/522">iacr.org/2023/522</a>, <https://eprint.iacr.org/2023/522></li>

      <li><span id="page-17-5"></span>9. Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Algebraic attacks against some arithmetization-oriented primitives. IACR Transactions on Symmetric Cryptology 2022(3), 73–101 (Sep 2022). <https://doi.org/10.46586/tosc.v2022.i3.73-101>, <https://tosc.iacr.org/index.php/ToSC/article/view/9850></li>

      <li><span id="page-17-4"></span>10. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the indifferentiability of the sponge construction. In: Smart, N. (ed.) Advances in Cryptology – EURO-CRYPT 2008. pp. 181–197. Springer Berlin Heidelberg, Berlin, Heidelberg (2008)</li>

      <li><span id="page-17-9"></span>11. Bettale, L., Faugère, J., Perret, L.: Solving polynomial systems over finite fields: improved analysis of the hybrid approach. In: van der Hoeven, J., van Hoeij, M. (eds.) International Symposium on Symbolic and Algebraic Computation, ISSAC'12, Grenoble, France - July 22 - 25, 2012. pp. 67–74. ACM (2012). <a href="https://doi.org/10.1145/2442829.2442843">https://doi.</a> <a href="https://doi.org/10.1145/2442829.2442843">org/10.1145/2442829.2442843</a>, <https://doi.org/10.1145/2442829.2442843></li>

      <li><span id="page-17-8"></span>12. Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., Wiemer, F.: Out of oddity – new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In: Micciancio, D., Ristenpart, T. (eds.) Advances in Cryptology – CRYPTO 2020. pp. 299–328. Springer International Publishing, Cham (2020)</li>

      <li><span id="page-17-7"></span>13. Boura, C., Canteaut, A., De Cannière, C.: Higher-order differential properties of keccak and luffa. In: Joux, A. (ed.) Fast Software Encryption. pp. 252–269. Springer Berlin Heidelberg, Berlin, Heidelberg (2011)</li>

      <li><span id="page-17-0"></span>14. Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions:anemoi permutations and jive compression mode. Cryptology ePrint Archive, Paper 2022/840 (2022), <https://eprint.iacr.org/2022/840>, <a href="https://eprint.iacr.org/2022/840">https:</a> <a href="https://eprint.iacr.org/2022/840">//eprint.iacr.org/2022/840</a></li>

      <li><span id="page-17-1"></span>15. Canteaut, A., Carpov, S., Fontaine, C., Lepoint, T., Naya-Plasencia, M., Paillier, P., Sirdey, R.: Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. Journal of Cryptology 31(3), 885–916 (Jul 2018). <https://doi.org/10.1007/s00145-017-9273-9>, <a href="https://doi.org/10.1007/s00145-017-9273-9">https://doi.org/</a> <a href="https://doi.org/10.1007/s00145-017-9273-9">10.1007/s00145-017-9273-9</a></li>

      <li><span id="page-17-10"></span>16. Cantor, D.G., Zassenhaus, H.: A new algorithm for factoring polynomials over finite fields. Mathematics of Computation 36(154), 587–592 (1981), <a href="http://www.jstor.org/stable/2007663">http://www.</a> <a href="http://www.jstor.org/stable/2007663">jstor.org/stable/2007663</a></li>

      <li><span id="page-17-2"></span>17. Cid, C., Indrøy, J.P., Raddum, H.: Fasta – a stream cipher for fast fhe evaluation. In: Galbraith, S.D. (ed.) Topics in Cryptology – CT-RSA 2022. pp. 451–483. Springer International Publishing, Cham (2022)</li>

      <li><span id="page-17-3"></span>18. Cosseron, O., Hoffmann, C., Méaux, P., Standaert, F.: Towards case-optimized hybrid homomorphic encryption - featuring the elisabeth stream cipher. In: Agrawal, S., Lin, D. (eds.) Advances in Cryptology - ASIACRYPT 2022 - 28th International Conference on the Theory and Application of Cryptology and Information Security, Taipei, Taiwan, December 5-9, 2022, Proceedings, Part III. Lecture Notes in Computer Science, vol. 13793, pp. 32–67. Springer (2022). <a href="https://doi.org/10.1007/978-3-031-22969-5\\_2">https://doi.org/10.</a> <a href="https://doi.org/10.1007/978-3-031-22969-5\\_2">1007/978-3-031-22969-5\\\\_2</a>, <a href="https://doi.org/10.1007/978-3-031-22969-5_2">https://doi.org/10.1007/978-3-031-22969-5\\\\_2</a></li>

      <li><span id="page-17-6"></span>19. Cox, D., Little, J., O'Shea, D.: Ideals, varieties, and algorithms. an introduction to computational algebraic geometry and commutative algebra (2007), <a href="https://link.springer.com/book/10.1007/978-0-387-35651-8">https://</a> <a href="https://link.springer.com/book/10.1007/978-0-387-35651-8">link.springer.com/book/10.1007/978-0-387-35651-8</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-18-8"></span>20. Ding, J., Schmidt, D.: Solving Degree and Degree of Regularity for Polynomial Systems over a Finite Fields, pp. 34–49. Springer Berlin Heidelberg, Berlin, Heidelberg (2013). <a href="https://doi.org/10.1007/978-3-642-42001-6_4">https://doi.org/10.1007/978-3-642-42001-6\\\\_4</a>, <a href="https://doi.org/10.1007/978-3-642-42001-6_4">https://doi.</a> <a href="https://doi.org/10.1007/978-3-642-42001-6_4">org/10.1007/978-3-642-42001-6\\\\_4</a></li>

      <li><span id="page-18-3"></span>21. Dobraunig, C., Eichlseder, M., Grassi, L., Lallemand, V., Leander, G., List, E., Mendel, F., Rechberger, C.: Rasta: A cipher with low anddepth and few ands per bit. In: Shacham, H., Boldyreva, A. (eds.) Advances in Cryptology – CRYPTO 2018. pp. 662–692. Springer International Publishing, Cham (2018)</li>

      <li><span id="page-18-4"></span>22. Dobraunig, C., Grassi, L., Helminger, L., Rechberger, C., Schofnegger, M., Walch, R.: Pasta: A case for hybrid homomorphic encryption. Cryptology ePrint Archive, Paper 2021/731 (2021), <https://eprint.iacr.org/2021/731>, <a href="https://eprint.iacr.org/2021/731">https://eprint.</a> <a href="https://eprint.iacr.org/2021/731">iacr.org/2021/731</a></li>

      <li><span id="page-18-9"></span>23. Faugère, J., Gianni, P., Lazard, D., Mora, T.: Efficient computation of zero-dimensional gröbner bases by change of ordering. Journal of Symbolic Computation 16(4), 329–344 (1993). <a href="https://doi.org/https://doi.org/10.1006/jsco.1993.1051">https://doi.org/https://doi.org/</a> <a href="https://doi.org/https://doi.org/10.1006/jsco.1993.1051">10.1006/jsco.1993.1051</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0747717183710515">https://www.sciencedirect.com/science/article/</a> <a href="https://www.sciencedirect.com/science/article/pii/S0747717183710515">pii/S0747717183710515</a></li>

      <li><span id="page-18-10"></span>24. Faugère, J.C., Mou, C.: Sparse fglm algorithms. Journal of Symbolic Computation 80, 538–569 (2017). <a href="https://doi.org/https://doi.org/10.1016/j.jsc.2016.07.025">https://doi.org/https://doi.org/10.</a> <a href="https://doi.org/https://doi.org/10.1016/j.jsc.2016.07.025">1016/j.jsc.2016.07.025</a>, <a href="https://www.sciencedirect.com/science/article/pii/S0747717116300700">https://www.sciencedirect.com/science/article/</a> <a href="https://www.sciencedirect.com/science/article/pii/S0747717116300700">pii/S0747717116300700</a></li>

      <li><span id="page-18-5"></span>25. Gérard, B., Grosso, V., Naya-Plasencia, M., Standaert, F.X.: Block ciphers that are easier to mask: How far can we go? In: Bertoni, G., Coron, J.S. (eds.) Cryptographic Hardware and Embedded Systems - CHES 2013. pp. 383–399. Springer Berlin Heidelberg, Berlin, Heidelberg (2013)</li>

      <li><span id="page-18-0"></span>26. Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: Horst meets fluid-spn: Griffin for zero-knowledge applications. Cryptology ePrint Archive, Paper 2022/403 (2022), <https://eprint.iacr.org/2022/403>, <a href="https://eprint.iacr.org/2022/403">https:</a> <a href="https://eprint.iacr.org/2022/403">//eprint.iacr.org/2022/403</a></li>

      <li><span id="page-18-7"></span>27. Grassi, L., Kales, D., Khovratovich, D., Roy, A., Rechberger, C., Schofnegger, M.: Starkad and poseidon: New hash functions for zero knowledge proof systems. IACR Cryptol. ePrint Arch. p. 458 (2019), <https://eprint.iacr.org/2019/458></li>

      <li><span id="page-18-11"></span>28. Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M., Walch, R.: Hash functions monolith for zk applications: May the speed of sha-3 be with you. Cryptology ePrint Archive, Paper 2023/1025 (2023), <a href="https://eprint.iacr.org/2023/1025">https://eprint.</a> <a href="https://eprint.iacr.org/2023/1025">iacr.org/2023/1025</a>, <https://eprint.iacr.org/2023/1025></li>

      <li><span id="page-18-1"></span>29. Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for Zero-Knowledge proof systems. In: 30th USENIX Security Symposium (USENIX Security 21). pp. 519–535. USENIX Association (Aug 2021), <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi">https://www.usenix.org/conference/usenixsecurity21/presentation/</a> <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/grassi">grassi</a></li>

      <li><span id="page-18-2"></span>30. Grassi, L., Khovratovich, D., Schofnegger, M.: Poseidon2: A faster version of the poseidon hash function. In: El Mrabet, N., De Feo, L., Duquesne, S. (eds.) Progress in Cryptology - AFRICACRYPT 2023. pp. 177–203. Springer Nature Switzerland, Cham (2023)</li>

      <li><span id="page-18-6"></span>31. Grassi, L., Lüftenegger, R., Rechberger, C., Rotaru, D., Schofnegger, M.: On a generalization of substitution-permutation networks: The HADES design strategy. In: Canteaut, A., Ishai, Y. (eds.) Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>II. Lecture Notes in Computer Science, vol. 12106, pp. 674–704. Springer (2020). <https://doi.org/10.1007/978-3-030-45724-2\\_23>, <a href="https://doi.org/10.1007/978-3-030-45724-2_23">https://doi.org/10.1007/</a> <a href="https://doi.org/10.1007/978-3-030-45724-2_23">978-3-030-45724-2\\\\_23</a></li>

      <li><span id="page-19-3"></span>32. Ha, J., Kim, S., Lee, B., Lee, J., Son, M.: Rubato: Noisy ciphers for approximate homomorphic encryption. In: Dunkelman, O., Dziembowski, S. (eds.) Advances in Cryptology – EUROCRYPT 2022. pp. 581–610. Springer International Publishing, Cham (2022)</li>

      <li><span id="page-19-2"></span>33. Hebborn, P., Leander, G.: Dasta - alternative linear layer for rasta. IACR Trans. Symmetric Cryptol. 2020(3), 46–86 (2020). <a href="https://doi.org/10.13154/tosc.v2020.i3.46-86">https://doi.org/10.13154/tosc.</a> <a href="https://doi.org/10.13154/tosc.v2020.i3.46-86">v2020.i3.46-86</a>, <https://doi.org/10.13154/tosc.v2020.i3.46-86></li>

      <li><span id="page-19-5"></span>34. Jakobsen, T., Knudsen, L.R.: The interpolation attack on block ciphers. In: Biham, E. (ed.) Fast Software Encryption. pp. 28–40. Springer Berlin Heidelberg, Berlin, Heidelberg (1997)</li>

      <li><span id="page-19-7"></span>35. Keller, N., Rosemarin, A.: Mind the middle layer: The hades design strategy revisited. In: Canteaut, A., Standaert, F.X. (eds.) Advances in Cryptology – EURO-CRYPT 2021. pp. 35–63. Springer International Publishing, Cham (2021)</li>

      <li><span id="page-19-6"></span>36. Knudsen, L.R.: Truncated and higher order differentials. In: Preneel, B. (ed.) Fast Software Encryption. pp. 196–211. Springer Berlin Heidelberg, Berlin, Heidelberg (1995)</li>

      <li><span id="page-19-9"></span>37. MacAulay, F.S.: Some formulæ in elimination. Proceedings of the London Mathematical Society s1-35(1), 3–27 (1902). <a href="https://doi.org/https://doi.org/10.1112/plms/s1-35.1.3">https://doi.org/https:</a> <a href="https://doi.org/https://doi.org/10.1112/plms/s1-35.1.3">//doi.org/10.1112/plms/s1-35.1.3</a>, <a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/plms/s1-35.1.3">https://londmathsoc.onlinelibrary.</a> <a href="https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/plms/s1-35.1.3">wiley.com/doi/abs/10.1112/plms/s1-35.1.3</a></li>

      <li><span id="page-19-1"></span>38. Méaux, P., Journault, A., Standaert, F.X., Carlet, C.: Towards stream ciphers for efficient fhe with low-noise ciphertexts. In: Fischlin, M., Coron, J.S. (eds.) Advances in Cryptology – EUROCRYPT 2016. pp. 311–343. Springer Berlin Heidelberg, Berlin, Heidelberg (2016)</li>

      <li><span id="page-19-8"></span>39. Sauer, J.F.: Gröbner basis-attacking a tiny sponge. Tech. rep., AS Discrete Mathematics (2021), <a href="https://asdm.gmbh/2021/06/28/gb_experiment_summary/">https://asdm.gmbh/2021/06/28/gb\\\\_experiment\\\\_summary/</a></li>

      <li><span id="page-19-11"></span>40. Shoup, V.: Factoring polynomials over finite fields: Asymptotic complexity vs. reality (1993)</li>

      <li><span id="page-19-0"></span>41. Szepieniec, A., Ashur, T., Dhooghe, S.: Rescue-prime: a standard specification (sok). IACR Cryptol. ePrint Arch. p. 1143 (2020), <a href="https://eprint.iacr.org/2020/1143">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2020/1143">2020/1143</a></li>

      <li><span id="page-19-4"></span>42. Szepieniec, A., Lemmens, A., Sauer, J.F., Threadbare, B., Al-Kindi: The tip5 hash function for recursive starks. Cryptology ePrint Archive, Paper 2023/107 (2023), <https://eprint.iacr.org/2023/107>, <https://eprint.iacr.org/2023/107></li>

      <li><span id="page-19-10"></span>43. Williams, V.V., Xu, Y., Xu, Z., Zhou, R.: New bounds for matrix multiplication: from alpha to omega (2023)</li>

      <li><span id="page-19-12"></span>44. Youssef, A., Mister, S., Tavares, S.: On the design of linear transformations for substitution permutation encryption networks pp. 40–48 (09 1997)</li>

    </ul>`;
---

<BaseLayout title="Algebraic Cryptanalysis of HADES Design Strategy: Applicatio... (2023/537)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/537
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="algebraic-cryptanalysis-of-hades-design-strategy-2023" />
  </article>
</BaseLayout>
