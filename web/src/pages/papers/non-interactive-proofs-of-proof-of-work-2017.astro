---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/963';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Non-Interactive Proofs of Proof-of-Work';
const AUTHORS_HTML = 'Aggelos Kiayias, Andrew Miller, Dionysis Zindros';

const CONTENT = `    <p class="text-gray-300">Aggelos Kiayias^{1} Andrew Miller^{2} Dionysis Zindros^{3}</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Open consensus protocols based on proof-of-work (PoW) mining are at the core of cryptocurrencies such Bitcoin and Ethereum, as well as many others. In this work, we construct a new primitive called Non-Interactive-Proofs-of-Proof-of-Work (NIPoPoWs) that can be adapted into existing PoW-based cryptocurrencies to improve their performance and extend their functionality. Unlike a traditional blockchain client which must verify the entire linearly-growing chain of PoWs, clients based on NIPoPoWs require resources only logarithmic in the length of the blockchain. NIPoPoWs are thus succinct proofs and require only a single message between the prover and the verifier of the transaction.</p>

    <p class="text-gray-300">With our construction we are able to prove a broad array of useful predicates in the context of cross PoW-based blockchain transfers of assets, including predicates about facts buried deep within a blockchain which is necessary for the basic application of accepting payments. We provide empirical validation for NIPoPoWs through an implementation and benchmark study, in the context of two new applications: First, we consider a multi-client blockchain that supports all proof-of-work currencies rather than just one, with up to 90% reduction in bandwidth. Second, we discuss a “cross-chain ICO” application that spans multiple independent blockchains. Using our experimental data, we provide concrete parameters for our scheme.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Today, Bitcoin and Ethereum remain the two largest proof-of-work cryptocurrencies by market cap. However, the ecosystem has grown diverse, with dozens of viable “altcoin” competitors. Given such an environment, it becomes increasingly important to be able to efficiently handle multiple blockchains by the same client and reliably transfer assets between them.</p>

    <p class="text-gray-300">The first objective requires optimizing the “SPV client” described in the original Bitcoin paper <em>[19]</em> which requires processing an amount of data growing linearly with the size of the blockchain.</p>

    <p class="text-gray-300">The second objective has received significant attention in the context of “cross-chain” applications, i.e., logical transactions that span multiple separate blockchains. Simple cross-chain transactions are feasible today: the most well-known is the atomic exchange <em>[14, 20]</em>, e.g., a trade of bitcoin for ether. However, more sophisticated applications <em>[6, 9, 16, 25, 27, 30]</em> could be enabled by a more efficient proof process, which would allow the blockchain of one cryptocurrency to embed a client of a separate cryptocurrency. This concept, initially popularized by a proposal by Back et al. <em>[2]</em> can be used to avoid a difficult upgrade process: a new blockchain with additional features, such as experimental opcodes, can be backed by deposits in the original bitcoin currency, obviating the need to transfer capital to the new cryptocurrency. As one example of cross-chain interfacing, we describe an initial coin offering (ICO) <em>[26]</em> which distributes tokens issued on one blockchain, but allows paying for them using coins in another blockchain.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our contributions</h3>

    <p class="text-gray-300">Our main technical contribution is the introduction and instantiation of a new cryptographic primitive called <em>Non-Interactive</em> Proofs of Proof-of-Work (NIPoPoW).</p>

    <p class="text-gray-300">We present a formal model and a provably secure instantiation of NIPoPoWs. Our contribution builds on previous work of the backbone model <em>[12]</em> in terms of modeling and <em>[15]</em> who introduced the concept of (interactive) Proofs of Proof-of-Work, which, in turn, are based on previous discussion of such concepts in the bitcoin forums <em>[18]</em>. In fact, we present an attack against the construction of <em>[15]</em> that can be mounted by an adversary with less than 50% of hashing power. As a result our construction is the first Proof of Proof-of-Work (regardless of interactivity) that is secure assuming honest majority. Furthermore, our solution is non-interactive making it the first protocol of this kind.</p>

    <p class="text-gray-300">Regarding to the predicates that are to be demonstrated, previous work allowed only proving that the <span class="math">k</span>-sized <em>suffix</em> of the currently adopted blockchain is as claimed. We generalize this notion to prove any <em>predicate</em> across a class of predicates which we call <em>infix sensitive</em>. This enables proving powerful statements pertaining to the blockchain such as the fact that a transaction took place, that a smart contract method ran with certain parameters, or that a payment was made into an account. The most basic application of such proofs, payment verification, require more general predicates than what is covered in previous work, and we enable these.</p>

    <p class="text-gray-300">We prove the proofs are optimistically succinct meaning that they are logarithmic in size in honest conditions. Improving previous work, we show that, in the optimistic model of no adversarial mining power, succinctness can be achieved for even <em>adversarially-generated</em> proofs by introducing the novel concept of <em>certificates of badness</em>. Our definition fills the gap in terms of security modeling and design that existed in previous proposals, e.g., the notion of cumulative “Dynamic Member Multisignature” <em>[2]</em>.</p>

    <p class="text-gray-300">We provide concrete parameterization and empirical analysis showing the savings of our approach versus existing clients. Using real data from the Bitcoin and other networks, we quantify the savings of NIPoPoWs over the previous techniques of constructing SPV verifiers. For a multi-blockchain client that receives 100 payments per day, we offer a 90% reduction in bandwidth compared to naïve SPV.</p>

    <p class="text-gray-300">In summary, we make the following contributions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We construct the first <em>provably secure</em> Proofs of Proof-of-Work.</li>

      <li>We make them <em>non-interactive</em>.</li>

      <li>We describe an <em>attack</em> against the previously known proof-of-proof-of-work construction.</li>

      <li>We extend proofs to prove <em>generic infix predicates</em> pertaining to transactions deep within the blockchain.</li>

      <li>We improve <em>succinctness</em> of previous proofs by weakening the optimality assumptions.</li>

      <li>We provide <em>experimental data</em> which measure the efficiency and security of our scheme as well as concrete parameters based on these experiments.</li>

    </ol>

    <h2 id="sec-5" class="text-2xl font-bold">2 Model and Definitions</h2>

    <p class="text-gray-300">Our model for describing our results is based on the standard “backbone” model for proof-of-work cryptocurrencies <em>[12]</em>, extended with the widely used Simplified Payment Verification (SPV) mode due to Nakamoto <em>[19]</em>. We consider three roles in our setting: lightweight <em>clients</em>, full <em>nodes</em>, and <em>miners</em>.</p>

    <p class="text-gray-300">Nodes and miners run the Bitcoin backbone protocol, maintaining a copy of the blockchain and committing new transactions they receive from clients. Clients do not store the entire blockchain, but instead connect to nodes for service and request up-to-date information about the blockchain, for example whether a particular payment has</p>

    <p class="text-gray-300">been finalized. Our main challenge is to design a protocol so that clients can sieve through the responses they receive from the network and reach a conclusion that should never disagree with the conclusion of a full node who is faced with the same objective and infers it from its local blockchain state.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Backbone model</h3>

    <p class="text-gray-300">The entities on the blockchain network are of 3 kinds: (1) miners, who try to mine new blocks on top of the longest known blockchain and broadcast them as soon as they are discovered (for simplicity we assume that difficulty is constant and thus the “longest chain rule” sufficiently describes honest miner behavior); (2) full nodes, who maintain the longest blockchain without mining and also act as the provers in the network; (3) verifiers or stateless clients, who connect to provers and ask for proofs in regards to which blockchain is the largest. The verifiers attempt to determine the value of a predicate on these chains.</p>

    <p class="text-gray-300">We model proof-of-work discovery attempts by using a random oracle <em>[4]</em> as in <em>[12]</em>. For clarity, we present our results in the backbone model <em>[12]</em>, although we suspect our results transfer easily to more refined models, such as Pass et al. <em>[21]</em>. More specifically, we remark that we assume a <em>synchronous</em> model in this paper. While we suspect our results carry over in a treatment in a <em>partially synchronous</em> model with <em>bounded delay</em>, this is left for future work.</p>

    <p class="text-gray-300">The random oracle produces <span class="math">\\kappa</span>-bit strings, where <span class="math">\\kappa</span> is the system’s security parameter. The network is synchronized into numbered rounds, which correspond to moments in time. <span class="math">n</span> denotes the total number of miners in the game, while <span class="math">t</span> denotes the total number of adversarial miners. Each miner is assumed to have equal mining power captured by the number of queries <span class="math">q</span> available per player to the random oracle, each query of which succeeds independently with probability <span class="math">p</span> (a successful query produces a block with valid proof-of-work). Mining pools and miners of different computing power can be captured by assuming multiple players combine their computing power. This is made explicit for the adversary, as they do not incur any network overhead to achieve communication between adversarial miners. On the contrary, honest players discovering a block must <em>diffuse</em> it (broadcast it) to the network at a given round and wait for it to be received by the rest of the honest players at the beginning of the next round. A round during which an honest block is diffused is called a <em>successful round</em>; if the number of honest blocks diffused is one, it is called <em>uniquely successful round</em>. We assume there is an honest majority, i.e., that <span class="math">t/n&lt;0.5</span> with a significant gap <em>[12]</em>. We further assume that the network is adversarial, but that there is no eclipsing attacks <em>[13]</em>. More specifically, we allow the adversary to reorder messages transmitted at a particular round, to inject new messages thereby capturing Sybil attacks <em>[10]</em>, but not to drop messages. Each honest miner maintains a local chain <span class="math">\\mathcal{C}</span> which they consider the current active blockchain. Upon receiving a different blockchain from the network, the current active blockchain is changed if the received blockchain is longer than the currently adopted one. Receiving a different blockchain of the same length as the currently adopted one does not change the adopted blockchain.</p>

    <p class="text-gray-300">Blockchain blocks are generated by including the following data in them: <span class="math">ctr</span>, the nonce used to achieve the proof-of-work; <span class="math">x</span> the Merkle tree <em>[17]</em> root of the transactions confirmed in this block; and <em>interlink</em> <em>[15]</em>, a vector containing pointers to previous blocks, including the id of the previous block. The <em>interlink</em> data structure contains pointers to more blocks than just the previous block. We will explain this further in Section 3. Given two hash functions <span class="math">H</span> and <span class="math">G</span> modelled as random oracles, the id of a block is defined as <span class="math">\\mathsf{id}=H(ctr,G(x,\\mathsf{interlink}))</span>. In bitcoin’s case, both <span class="math">H</span> and <span class="math">G</span> would be SHA256.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.2 The prover and verifier model</p>

    <p class="text-gray-300">In our protocol, the nodes include a proof along with their responses to clients. We need to assume that clients are able to connect to at least one correctly functioning node (i.e., that they cannot be eclipsed from the network <em>[1, 13]</em>). Each client makes the same request to every node, and by verifying the proofs the client identifies the correct response. Henceforth we will call clients verifiers and nodes provers. Note that in the interactive protocol from prior work <em>[15]</em>, the prover and verifier may engage in more than one round of message passing.</p>

    <p class="text-gray-300">The prover-verifier interaction is parameterized by a predicate (e.g. “the transaction <span class="math">t</span> is committed in the blockchain”). The predicates of interest in our context are predicates on the active blockchain. Some of the predicates are more suitable for succinct proofs than others. We focus our attention in stable predicates having the property that all honest miners share their view of them in a way that is updated in a predictable manner, with a truth-value that persists as the blockchain grows (an example of an unstable predicate is e.g., the least significant bit of the hash of last block). Following the work of <em>[12]</em>, we wait for <span class="math">k</span> blocks to bury a block before we consider it confirmed and thereby the predicates depending on it stable. <span class="math">k</span> is the common prefix security parameter, which in bitcoin folklore is often taken to be <span class="math">k=6</span>.</p>

    <p class="text-gray-300">In our setting, for a given predicate <span class="math">Q</span>, several provers (including adversarial ones) will generate proofs claiming potentially different truth values for <span class="math">Q</span> based on their claimed local longest chains. The verifier receives these proofs and accepts one of the proofs, determining the truth value of the predicate. We denote a blockchain proof protocol for a predicate <span class="math">Q</span> as a pair <span class="math">(P,V)</span> where <span class="math">P</span> is the prover and <span class="math">V</span> is the verifier. <span class="math">P</span> is a PPT algorithm that is spawned by a full node when they wish to produce a proof, accepts as input a full chain <span class="math">\\mathcal{C}</span> and produces a proof <span class="math">\\pi</span> as its output. <span class="math">V</span> is a PPT algorithm which is spawned at some round, receives a pair of proofs <span class="math">(\\pi_{A},\\pi_{B})</span> from both an honest party and the adversary and returns its decision <span class="math">d\\in\\{T,F\\}</span> before the next round and terminates. The honest miners produce proofs for <span class="math">V</span> using <span class="math">P</span>, while the adversary produces proofs following some arbitrary strategy. Before we introduce the security properties for blockchain proof protocols we introduce some necessary notation for blockchains.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Blockchain addressing</h3>

    <p class="text-gray-300">Our development makes use of several notation conventions for manipulating blockchain data structures, which we introduce here. Blockchains are finite block sequences obeying the blockchain property that in every block in the chain there exists a pointer to its previous block. A chain is anchored if its first block is genesis, denoted <span class="math">Gen</span>.</p>

    <p class="text-gray-300">For chain addressing we use Python brackets <span class="math">\\mathcal{C}[\\cdot]</span> as in <em>[22]</em>. A zero-based positive number in a bracket indicates the indexed block in the chain. A negative index indicates a block from the end, e.g., <span class="math">\\mathcal{C}[-1]</span> is the tip of the blockchain. A range <span class="math">\\mathcal{C}[i:j]</span> is a subarray starting from <span class="math">i</span> (inclusive) to j (exclusive).</p>

    <p class="text-gray-300">Given chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> and blocks <span class="math">A,Z</span> we concatenate them as <span class="math">\\mathcal{C}_{1}\\mathcal{C}_{2}</span> or <span class="math">\\mathcal{C}_{1}A</span>. <span class="math">\\mathcal{C}_{2}[0]</span> must point to <span class="math">\\mathcal{C}_{1}[-1]</span> and <span class="math">A</span> must point to <span class="math">\\mathcal{C}_{1}[-1]</span>. We denote <span class="math">\\mathcal{C}\\{A:Z\\}</span> the subarray of the chain from <span class="math">A</span> (inclusive) to <span class="math">Z</span> (exclusive). We can omit blocks or indices from either side of the range to take the chain to the beginning or end respectively.</p>

    <p class="text-gray-300">The id function returns the id of a block given its data, i.e., <span class="math">\\mathsf{id}=H(ctr,G(x,\\mathsf{interlink}))</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.4 Provable chain predicates</h3>

    <p class="text-gray-300">Our aim is to prove statements about the blockchain, such as “The transaction <span class="math">t</span> is included in the current blockchain.” We consider a general class of predicates that take on values</p>

    <p class="text-gray-300">true or false. Since a Bitcoin-like blockchain can experience delays and intermittent forks, not all honest parties will be in exact agreement about the entire chain. However, when all honest parties are in agreement about the truth value of the predicate, we will soon require in our security definition that the verifier also arrives at the same truth value.</p>

    <p class="text-gray-300">To aid the construction of our proofs, we focus on predicates that are monotonic; they start with the value false and, as the blockchain grows, can change their value to true but not back.</p>

    <p class="text-gray-300">Definition 1. (Monotonicity) A chain predicate  <span class="math">Q(\\mathcal{C})</span>  is monotonic if for all chains  <span class="math">\\mathcal{C}</span>  and for all blocks  <span class="math">B</span>  we have that  <span class="math">Q(\\mathcal{C}) \\Rightarrow Q(\\mathcal{C}B)</span> .</p>

    <p class="text-gray-300">Additionally, we require that our predicates only depend on the stable portion of the blockchain, blocks that are buried under  <span class="math">k</span>  subsequent blocks. This ensures that the value of the predicate will not change due to a blockchain reorganization.</p>

    <p class="text-gray-300">Definition 2. (Stability) Parameterized by  <span class="math">k \\in \\mathbb{N}</span> , a chain predicate  <span class="math">Q</span>  is  <span class="math">k</span> -stable if its value only depends on the prefix  <span class="math">\\mathcal{C}[: -k]</span> .</p>

    <p class="text-gray-300">We now define two desired properties of a non-interactive blockchain proof protocol, succinctness and security.</p>

    <p class="text-gray-300">Definition 3. (Security) A blockchain proof protocol  <span class="math">(P,V)</span>  about a predicate  <span class="math">Q</span>  is secure if for all environments and for all PPT adversaries  <span class="math">\\mathcal{A}</span>  and for all rounds  <span class="math">r\\geq \\eta k</span> , if  <span class="math">V</span>  receives a set of proofs  <span class="math">\\mathcal{P}</span>  at the beginning of round  <span class="math">r</span> , at least one of which has been generated by the honest prover  <span class="math">P</span> , then the output of  <span class="math">V</span>  at the end of round  <span class="math">r</span>  has the following constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the output of  <span class="math">V</span>  is false, then the evaluation of  <span class="math">Q(\\mathcal{C})</span>  for all honest parties must be false at the end of round  <span class="math">r - \\eta k</span> .</li>

      <li>If the output of  <span class="math">V</span>  is true, then the evaluation of  <span class="math">Q(\\mathcal{C})</span>  for all honest parties must be true at the end of round  <span class="math">r + \\eta k</span> .</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The truth value of a fixed predicate  <span class="math">Q</span>  about the blockchain, as seen from the point of view of 5 honest nodes, drawn on the vertical axis, over time, drawn as the horizontal axis. The truth value evolves over time starting as false at the beginning, indicated by a dashed red line. At some point in time  <span class="math">t_0</span> , the predicate is ready to be evaluated as true, indicated by the solid blue line. The various honest nodes each realize this independently over a period of  <span class="math">\\eta k</span>  duration, shaded in gray. The predicate remains false for everyone before  <span class="math">t_0</span>  and true for everyone after  <span class="math">t_0 + \\eta k</span> .</p>

    <p class="text-gray-300">Some explanation is needed for the rationale of the above definition. The parameter  <span class="math">\\eta</span>  is borrowed from the Backbone [12] work and indicates the rate at which new blocks</p>

    <p class="text-gray-300">are produced, i.e., the number of rounds needed on average to produce a block. If the scheme is secure, this means that the output of the verifier should match the output of a <em>potential honest full node</em>. However, in various executions, not all potential honest full node behaviors will be instantiated. Therefore, we require that, if the output of the proof verifier is <em>true</em> then, consistently with honest behavior, all other honest full nodes will converge to the value <em>true</em>. Conversely, if the output of the proof verifier is <em>false</em> then, consistently with honest behavior, all honest full nodes must not have indicated <em>true</em> sufficiently long in the past. The period <span class="math">\\eta k</span> is the period needed for obtaining sufficient confirmations (<span class="math">k</span>) in a blockchain system. A predicate’s value has the potential of being <em>true</em> as seen by an honest party starting at time <span class="math">t_{0}</span>. Before time <span class="math">t_{0}</span>, all honest parties agree that the predicate is <em>false</em>. It takes <span class="math">\\eta k</span> time for all parties to agree that the predicate is <em>true</em>, which is certain after time <span class="math">t_{0}+\\eta k</span>. The adversary may be able to convince the verifier that the predicate has any value during the period from <span class="math">t_{0}</span> to <span class="math">t_{0}+\\eta k</span>. However, our security definition mandates that before time <span class="math">t_{0}</span> the verifier will necessarily output <em>false</em> and after time <span class="math">t_{0}+\\eta k</span> the verifier will necessarily output <em>true</em>.</p>

    <p class="text-gray-300">Remark. The above security definition, which works in the synchronous model, strictly requires that all NIPoPoW proofs have all been generated at some round <span class="math">r</span>. In a partially synchronous setting, NIPoPoW proofs could be generated for a period of time of a certain length <span class="math">\\eta k</span>. Without loss of generality, it can be assumed that, in such a setting, the honest party <span class="math">P</span> generates the NIPoPoW proof at time <span class="math">r</span> while the adversary generates her proof at time <span class="math">r+\\eta k</span>, gaining some advantage. The security definition can be altered to allow for such a setting by requiring the truth value to alter only within the period <span class="math">r-2\\eta k</span> to <span class="math">r+2\\eta k</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">(Succinctness) A <em>blockchain proof protocol</em> <span class="math">(P,V)</span> about a predicate <span class="math">Q</span> is <em>succinct</em> if for all PPT provers <span class="math">\\mathcal{A}</span>, any proof <span class="math">\\pi</span> produced by <span class="math">\\mathcal{A}</span> at some round <span class="math">r</span>, the verifier <span class="math">V</span> only reads a <span class="math">O(polylog(r))</span>-sized portion of <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">It is easy to construct a <em>secure but not succinct</em> protocol for any computable predicate <span class="math">Q</span>: The prover provides the entire chain <span class="math">\\mathcal{C}</span> as a proof and the verifier simply selects the longest chain: by the <em>common-prefix property</em> of the backbone protocol (c.f. <em>[12]</em>), this is consistent with the view of every honest party (as long as <span class="math">Q</span> depends only on a <em>prefix</em> of the chain, as we explain in more detail shortly). In fact this is how widely-used cryptocurrency clients (including SPV clients) operate today.</p>

    <p class="text-gray-300">It is also easy to build <em>succinct but insecure</em> clients: The prover simply sends the predicate value directly. This is roughly what hosted wallets do <em>[5]</em>.</p>

    <p class="text-gray-300">The challenge we will solve is to provide a non-interactive protocol that at the same time achieves security and (optimistic) succinctness over a large class of useful predicates.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Consensus layer support</h2>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 The interlink pointers data structure</h3>

    <p class="text-gray-300">In order to construct our protocol, we rely on the same <em>interlink data structure</em> used by PoPoW <em>[15]</em>. This is an additional hash-based data structure that is proposed to include in the header of each block. The interlink data structure is a skip-list <em>[23]</em> that makes it efficient for a verifier to process a sparse subset of the blockchain, rather than only consecutive blocks.</p>

    <p class="text-gray-300">Valid blocks satisfy the proof-of-work condition: <span class="math">id\\leq T</span>, where <span class="math">T</span> is the mining target. Throughout this work, we make the simplifying assumption that <span class="math">T</span> is constant. Some blocks will achieve a lower id. If <span class="math">id\\leq\\frac{T}{2^{\\mu}}</span> we say that the block is of level <span class="math">\\mu</span>. All blocks</p>

    <p class="text-gray-300">are level 0. Blocks with level  <span class="math">\\mu</span>  are called  <span class="math">\\mu</span> -superblocks.  <span class="math">\\mu</span> -superblocks for  <span class="math">\\mu &amp;gt; 0</span>  are also  <span class="math">(\\mu - 1)</span> -superblocks. The level of a block is given as  <span class="math">\\mu = \\lfloor \\log (T) - \\log (\\mathrm{id}(\\mathsf{B})) \\rfloor</span>  and denoted level(B). By convention, for Gen we set  <span class="math">id = 0</span>  and  <span class="math">\\mu = \\infty</span> .</p>

    <p class="text-gray-300">Observe that in a blockchain protocol execution it is expected half of the blocks will be of level 1,  <span class="math">1/4</span>  of the blocks will be of level 2,  <span class="math">1/8</span>  will be of level 3 and  <span class="math">1/2^{\\mu}</span>  blocks will be of level  <span class="math">\\mu</span> . In expectation, the number of superblock levels of a chain  <span class="math">\\mathcal{C}</span>  will be  <span class="math">\\Theta(\\log(\\mathcal{C}))</span>  [15]. Figure 2 illustrates the blockchain superblocks starting from level 1 and going up to level 4 in case these blocks are distributed exactly according to expectation. Here, each level contains half the blocks of the level below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our protocol, the verifier must roughly scan along one level at a time. To enable this, instead of just the previous block, the interlink vector also points to the most recent preceding block of every level  <span class="math">\\mu</span> . Genesis is of infinite level and hence a pointer to it is included in every block at the first available index within the interlink data structure. The number of pointers that need to be included per block is in expectation  $\\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2 illustrates the blockchain superblocks starting from level 1 and going up to level 4 in case these blocks are distributed exactly according to expectation. Note that each level contains half the blocks of the level below.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. The hierarchical blockchain. Higher levels have achieved a lower target (higher difficulty) during mining.</p>

    <p class="text-gray-300">The algorithm for this construction is shown in Algorithm 1 and is borrowed from [15]. The interlink data structure turns the blockchain into a skiplist-like [23] data structure.</p>

    <p class="text-gray-300">The updateInterlink algorithm accepts a block  <span class="math">B&#x27;</span> , which already has an interlink data structure defined on it. The function evaluates the interlink data structure which needs to be included as part of the next block. It copies the existing interlink data structure and then modifies its entries from level 0 to level  <span class="math">(B&#x27;)</span>  to point to the block  <span class="math">B&#x27;</span> .</p>

    <p class="text-gray-300">Algorithm 1 updateInterlink 1: function updateInterlink  <span class="math">(B^{\\prime})</span> 2: interlink  <span class="math">\\leftarrow B^{\\prime}</span>  .interlink 3: for  <span class="math">\\mu = 0</span>  to level  <span class="math">(B^{\\prime})</span>  do 4: interlink  <span class="math">[\\mu ]\\gets id(B^{\\prime})</span> 5: end for 6: return interlink 7: end function</p>

    <p class="text-gray-300">Traversing the blockchain. As we have now extended blocks to contain multiple pointers to previous blocks, if certain blocks are omitted from a chain we will obtain a subchain, as long as the blockchain property that each block must contain a pointer to its previous block in the sequence is maintained.</p>

    <p class="text-gray-300">Blockchains are sequences, but it is more convenient to use set notation for some operations. Specifically, <span class="math">B\\in\\mathcal{C}</span>; <span class="math">\\mathcal{C}_{1}\\subseteq\\mathcal{C}_{2}</span> and <span class="math">\\emptyset</span> have the obvious meaning. <span class="math">\\mathcal{C}_{1}\\cup\\mathcal{C}_{2}</span> is the chain obtained by sorting the blocks contained in both <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> into a sequence (this may be not always defined). We will freely use set builder notation <span class="math">\\{B\\in\\mathcal{C}:p(B)\\}</span>. <span class="math">\\mathcal{C}_{1}\\cap\\mathcal{C}_{2}</span> is the chain <span class="math">\\{B:B\\in\\mathcal{C}_{1}\\wedge B\\in\\mathcal{C}_{2}\\}</span>. In all cases, the blockchain property must be maintained. The lowest common ancestor is <span class="math">\\mathsf{LCA}(\\mathcal{C}_{1},\\mathcal{C}_{2})=(\\mathcal{C}_{1}\\cap\\mathcal{C}_{2})[-1]</span>. If <span class="math">\\mathcal{C}_{1}[0]=\\mathcal{C}_{2}[0]</span> and <span class="math">\\mathcal{C}_{1}[-1]=\\mathcal{C}_{2}[-1]</span>, we say the chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> <em>span</em> the same block range.</p>

    <p class="text-gray-300">It will soon become clear that it is useful to construct a chain containing only the superblocks of another chain. Given <span class="math">\\mathcal{C}</span> and level <span class="math">\\mu</span>, the <em>upchain</em> <span class="math">\\mathcal{C}^{\\uparrow\\mu}</span> is defined as <span class="math">\\{B\\in\\mathcal{C}:level(B)\\geq\\mu\\}</span>. A chain containing only <span class="math">\\mu</span>-superblocks is called a <em><span class="math">\\mu</span>-superchain</em>. It is also useful, given a <span class="math">\\mu</span>-superchain <span class="math">\\mathcal{C}^{\\prime}</span> to go back to the regular chain <span class="math">\\mathcal{C}</span>. Given chains <span class="math">\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}</span>, the <em>downchain</em> <span class="math">\\mathcal{C}^{\\prime}\\downarrow_{\\mathcal{C}}</span> is defined as <span class="math">\\mathcal{C}[\\mathcal{C}^{\\prime}[0]:\\mathcal{C}^{\\prime}[-1]]</span>. <span class="math">\\mathcal{C}</span> is the <em>underlying chain</em> of <span class="math">\\mathcal{C}^{\\prime}</span>. The underlying chain is often implied by context, so we will simply write <span class="math">\\mathcal{C}^{\\prime}\\downarrow</span>. By the above definition, the <span class="math">\\mathcal{C}^{\\uparrow}</span> operator is absolute: <span class="math">(\\mathcal{C}^{\\uparrow\\mu})^{\\mu+i}=\\mathcal{C}^{\\uparrow\\mu+i}</span>. Given a set of consecutive rounds <span class="math">S=\\{r,r+1,\\cdots,r+j\\}\\subseteq\\mathbb{N}</span>, we define <span class="math">\\mathcal{C}^{S}=\\{B\\in\\mathcal{C}:B\\text{ was generated during }S\\}</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Non-interactive blockchain <em>suffix</em> proofs</h2>

    <p class="text-gray-300">In this section, we modify the PoPoW scheme introduced in KLS <em>[15]</em> to make it non-interactive. With foresight, we caution the reader that the non-interactive construction we present in this section is <em>insecure</em>, because the PoPoW scheme it is based on is also insecure. A very small patch will later allow us to modify our construction to achieve security.</p>

    <p class="text-gray-300">Their scheme only allowed proving <em>suffix predicates</em>, predicates that pertain to the suffix of the blockchain. We continue along those lines to give our NIPoPoW construction which allows proving certain predicates <span class="math">Q</span> of the chain <span class="math">\\mathcal{C}</span>. Among the predicates which are stable, in this section, we will limit ourselves to <em>suffix sensitive</em> predicates (similar to previous work which did not make this distinction explicit). We extend the protocol to support more flexible predicates (such as transaction inclusion, as needed for our applications) in Section 5.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 5 (Suffix sensitivity).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A chain predicate <span class="math">Q</span> is called <span class="math">k</span>-suffix sensitive if for all chains <span class="math">\\mathcal{C},\\mathcal{C}^{\\prime}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k<span class="math"> such that </span>\\mathcal{C}[-k:]=\\mathcal{C}^{\\prime}[-k:]<span class="math"> we have that </span>Q(\\mathcal{C})=Q(\\mathcal{C}^{\\prime})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Notice that if a predicate <span class="math">Q</span> is suffix-sensitive, then then its value must be determined only by the <span class="math">k</span>-suffix of the chain.</p>

    <p class="text-gray-300">Example. In general our applications will require predicates that are not suffix-sensitive. However, as an example, consider the predicate “an Ethereum contract at address <span class="math">C</span> has been initialized with code <span class="math">h</span> at least <span class="math">k</span> blocks ago” where <span class="math">h</span> does not invoke the selfdestruct opcode. This can be implemented in a suffix-sensitive way because, in Ethereum, each block includes a Merkle Trie over all of the contract codes <em>[8, 29]</em>, which cannot be changed after initialization. This predicate is thus also monotonic and <span class="math">k</span>-stable.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.1 Construction</h3>

    <p class="text-gray-300">We next present a generic form of the verifier first and the prover afterwards. The generic form of the verifier works with any practical suffix proof protocol. Therefore, we describe the generic verifier first before we talk about the specific instantiation of our protocol. The generic verifier is given access to call a protocol-specific proof comparison operator <span class="math">\\leq_{m}</span></p>

    <p class="text-gray-300">|  Algorithm 2 The Verify algorithm for the NIPoPoW protocol  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: function Verifym,k(P)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: ~π← (Gen)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Trivial anchored blockchain</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: if validChain(πχ) ∧</td>

            <td class="px-3 py-2 border-b border-gray-700">χ</td>

            <td class="px-3 py-2 border-b border-gray-700">= k ∧ π ≥m ~π then</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: ~π← π |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: ~χ← χ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Update current best</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: end if  |   |</p>

    <p class="text-gray-300">|  8: end for  |   |</p>

    <p class="text-gray-300">|  9: return Q(χ)  |   |</p>

    <p class="text-gray-300">|  10: end function  |   |</p>

    <p class="text-gray-300">we define. We begin the description of our protocol by first illustrating the generic verifier. Next, we describe the prover specific to our protocol. Finally, we show the instantiation of the  <span class="math">\\leq_{m}</span>  operator, which plugs into the generic verifier to make a concrete verifier for our protocol.</p>

    <p class="text-gray-300">The generic verifier. The Verify function of our NIPoPoW construction for suffix predicates is described in Algorithm 2. The verifier algorithm is parameterized by a chain predicate  <span class="math">Q</span>  and security parameters  <span class="math">k, m</span> ;  <span class="math">k</span>  pertains to the amount of proof-of-work needed to bury a block so that it is believed to remain stable (e.g.,  <span class="math">k = 6</span> );  <span class="math">m</span>  is a security parameter pertaining to the prefix of the proof, which connects the genesis block to the  <span class="math">k</span> -sized suffix. The verifier receives several proofs by different provers in a collection of proofs  <span class="math">\\mathcal{P}</span>  at least one of which will be honest. Iterating over these proofs, it extracts the best.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Each proof is a chain. For honest provers, these are subchains of the adopted chain. Proofs consist of two parts,  <span class="math">\\pi</span>  and  <span class="math">\\chi</span> ;  <span class="math">\\pi \\chi</span>  must be a valid chain;  <span class="math">\\chi</span>  is the proof suffix;  <span class="math">\\pi</span>  is the prefix. We require  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\chi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k<span class="math"> . For honest provers,  </span>\\chi<span class="math">  is the last  </span>k<span class="math">  blocks of the adopted chain, while  </span>\\pi<span class="math">  consists of a selected subset of blocks from the rest of their chain preceding  </span>\\chi$ . The method of choice of this subset will become clear soon.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier compares the proof prefixes provided to it by calling the  <span class="math">\\geq_{m}</span>  operator. We will get to the operator's definition shortly. Proofs are checked for validity before comparison by ensuring  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\chi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k<span class="math">  and calling validChain which checks if  </span>\\pi \\chi$  is an anchored blockchain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At each loop iteration, the verifier compares the next candidate proof prefix  <span class="math">\\pi</span>  against the currently best known proof prefix  <span class="math">\\tilde{\\pi}</span>  by calling  <span class="math">\\pi \\geq_{m} \\tilde{\\pi}</span> . If the candidate prefix is better than the currently best known proof prefix, then the currently known best prefix is updated by setting  <span class="math">\\tilde{\\pi} \\gets \\pi</span> . When the best known prefix is updated, the suffix  <span class="math">\\tilde{\\chi}</span>  associated with the best known prefix is also updated to match the suffix  <span class="math">\\chi</span>  of the candidate proof by setting  <span class="math">\\tilde{\\chi} \\gets \\chi</span> . While  <span class="math">\\tilde{\\chi}</span>  is needed for the final predicate evaluation, it is not used as part of any comparison, as it has the same size  <span class="math">k</span>  for all proofs. The best known proof prefix is initially set to (Gen), the trivial anchored chain containing only the genesis block. Any well-formed proof compares favourably against the trivial chain.</p>

    <p class="text-gray-300">After the end of the for loop, the verifier will have determined the best proof  <span class="math">(\\tilde{\\pi},\\tilde{\\chi})</span> . We will later prove that this proof will necessarily belong to an honest prover with overwhelming probability. Since the proof has been generated by an honest prover, it is associated with an underlying honestly adopted chain  <span class="math">\\mathcal{C}</span> . The verifier then extracts the value of the predicate  <span class="math">Q</span>  on the underlying chain. Note that, because the full chain is not available to the verifier, the verifier here must evaluate the predicate on the suffix. Because the predicate is suffix-sensitive, it is possible to do so. As a technical detail, we denote  <span class="math">\\tilde{Q}</span>  the</p>

    <p class="text-gray-300">predicate which accepts only a  <span class="math">k</span> -suffix of a blockchain and outputs the same value that  <span class="math">Q</span>  would have output if it had been evaluated on a chain with that suffix.</p>

    <p class="text-gray-300">Algorithm 3 The Prove algorithm for the NIPoPoW protocol 1: function  <span class="math">\\text{Prove}_{m,k,\\delta}(\\mathcal{C})</span> 2:  <span class="math">B \\gets \\mathcal{C}[0]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: for  $\\mu =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[-k].\\text{interlink}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  down to 0 do</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4:  <span class="math">\\alpha \\gets \\mathcal{C}[: -k]\\{B:\\} \\uparrow^{\\rho}</span> 5:  <span class="math">\\pi \\gets \\pi \\cup \\alpha; B \\gets \\alpha[-m]</span> 6: end for 7:  <span class="math">\\chi \\gets \\mathcal{C}[-k:]</span> 8: return  <span class="math">\\pi \\chi</span> 9: end function</p>

    <p class="text-gray-300">The concrete prover. The NIPoPoW prover construction is shown in Algorithm 3. The honest prover is supplied with an honestly adopted chain  <span class="math">\\mathcal{C}</span>  and security parameters  <span class="math">m, k, \\delta</span>  and returns proof  <span class="math">\\pi \\chi</span> , which is a chain. The suffix  <span class="math">\\chi</span>  is the last  <span class="math">k</span>  blocks of  <span class="math">\\mathcal{C}</span> . The prefix  <span class="math">\\pi</span>  is constructed by selecting various blocks from  <span class="math">\\mathcal{C}[: -k]</span>  and adding them to  <span class="math">\\pi</span> , which consists of a number of blocks for every level  <span class="math">\\mu</span> . At the highest possible level at which at least  <span class="math">m</span>  blocks exist, all these blocks are included. Then, inductively, for every superchain of level  <span class="math">\\mu</span>  that is included in the proof, the suffix of length  <span class="math">m</span>  is taken. Then the underlying superchain of level  <span class="math">\\mu - 1</span>  spanning the same blocks as that suffix is also included, until level 0 is reached. This underlying superchain will have  <span class="math">2m</span>  blocks in expectation and always at least  <span class="math">m</span>  blocks.</p>

    <p class="text-gray-300">The algorithm returns a chain  <span class="math">\\pi \\chi</span> . In this chain,  <span class="math">\\chi</span>  is the suffix of an honestly adopted blockchain containing the most recent  <span class="math">k</span>  blocks.  <span class="math">\\pi</span>  is a subchain of the underlying blockchain with the last  <span class="math">k</span>  blocks removed,  <span class="math">\\mathcal{C}[: -k]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In each iteration of the for loop, blocks of level  <span class="math">\\mu</span>  are considered, starting from the top-most level  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}[-k].\\text{interlink}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and descending down to level 0. When we take a  </span>\\mu<span class="math"> -superchain and are interested in its last  </span>m<span class="math">  blocks, we fill the same range of blocks with blocks from the superchain of level  </span>\\mu - 1<span class="math">  below. All the  </span>\\mu<span class="math"> -superblocks which are within this  </span>m<span class="math">  blocks range will also be  </span>(\\mu - 1)<span class="math"> -superblocks and so we do not want to keep them in the proof twice. Note that no check is necessary to make sure the top-most level has at least  </span>m<span class="math">  blocks, even though the verifier requires this. The reason is the following: Assume the blockchain has at least  </span>m<span class="math">  blocks in total. Then, when a superchain of level  </span>\\mu<span class="math">  has less than  </span>m<span class="math">  blocks in total, these blocks will all be necessarily included into the proof by a lower-level superchain  </span>\\mu - i<span class="math">  for some  </span>i &gt; 0<span class="math"> . Therefore, it does not hurt to add them to  </span>\\pi$  earlier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3 contains an example proof constructed for parameters  <span class="math">m = k = 3</span> . The top superchain level which contains at least  <span class="math">m</span>  blocks is level  <span class="math">\\mu = 3</span> . For the  <span class="math">m</span> -sized suffix of that level, 5 blocks of superblock level 2 are included for support spanning the same range. For the last 3 blocks of the level 2 superchain, blocks of level 1 are included for support.</p>

    <p class="text-gray-300">The concrete verifier. The  <span class="math">\\geq_{m}</span>  operator which performs the comparison of proofs is presented in Algorithm 4. It takes proofs  <span class="math">\\pi_{A}</span>  and  <span class="math">\\pi_{B}</span>  and returns true if the first proof is winning, or false if the second is winning. It first computes the LCA block  <span class="math">b</span>  between the proofs. As parties  <span class="math">A</span>  and  <span class="math">B</span>  agree that the blockchain is the same up to block  <span class="math">b</span> , arguments will then be taken for the diverging chains after  <span class="math">b</span> . The best possible argument from each player's proof is extracted by calling the best-arg <span class="math">_m</span>  function. We call the willingness of the verifier to allow each prover to be evaluated based on their best argument the</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. NIPoPoW prefix  <span class="math">\\pi</span>  for  <span class="math">m = 3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">principle of charity. To find the best argument of a proof  <span class="math">\\pi</span>  given  <span class="math">b</span> , best-arg <span class="math">_m</span>  collects all the  <span class="math">\\mu</span>  indices which point to superblock levels that contain valid arguments after block  <span class="math">b</span> . Argument validity requires that there are at least  <span class="math">m</span> <span class="math">\\mu</span> -superblocks following block  <span class="math">b</span> , which is captured by the comparison  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi \\uparrow^{\\mu}\\{b:\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math"> . 0 is always considered a valid level, regardless of how many blocks are present there. These level indices are collected into set  </span>M<span class="math"> . For each of these levels, the score of their respective argument is evaluated by weighting the number of blocks by the level as  </span>2^{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi \\uparrow^{\\mu}\\{b:\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The highest possible score across all levels is returned. Once the score of the best argument of both  </span>A<span class="math">  and  </span>B<span class="math">  is known, they are directly compared and the winner returned. An advantage is given to the first proof in case of a tie by using the  </span>\\geq<span class="math">  operator favouring  </span>A$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 4 The algorithm implementation for the  <span class="math">\\geq</span>  operator to compare two proofs in the NIPoPoW protocol parameterized with security parameter  <span class="math">m</span> . Returns True if the underlying chain of player  <span class="math">A</span>  is deemed longer than the underlying chain of player  <span class="math">B</span></p>

    <p class="text-gray-300">1: function best-argm(π,b)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2:  $M \\gets \\{\\mu :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi \\uparrow^{\\mu} \\{b : \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m\\} \\cup \\{0\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4: end function 5: operator  <span class="math">\\pi_A \\geq_m \\pi_B</span> 6:  <span class="math">b\\gets (\\pi_{\\mathcal{A}}\\cap \\pi_B)[-1]</span> 7: return best-argm(πA,b) ≥ best-argm(πB,b) 8: end operator</p>

    <p class="text-gray-300">In the previous section we have seen how to construct proofs for suffix predicates. As mentioned, the main purpose of this construction is to serve as a stepping stone for the construction of this section that presents a most useful class of proofs allow proving more general predicates that can depend on multiple blocks even buried deep within the blockchain.</p>

    <p class="text-gray-300">More specifically, the generalized prover for infix proofs allows proving any predicate  <span class="math">Q(\\mathcal{C})</span>  that depends on a number of blocks that can appear anywhere within the chain (except the  <span class="math">k</span>  suffix for stability). These blocks constitute a subset  <span class="math">\\mathcal{C}&#x27;</span>  of blocks, the witness, which may not necessarily be a stand-alone subchain. This allows proving powerful statements such as, for example, whether a transaction is confirmed. We define next formally the class of predicates that will be of interest.</p>

    <p class="text-gray-300">Definition 6 (Infix sensitivity). A chain predicate  <span class="math">Q_{d,k}</span>  is infix sensitive if it can be written in the form</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Q_{d,k}(\\mathcal{C})=\\begin{cases}\\textit{true, if }\\exists\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}[:-k]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq d\\wedge D(\\mathcal{C}^{\\prime})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\textit{false, otherwise}\\end{cases}$</p>

    <p class="text-gray-300">Where <span class="math">D</span> is an arbitrary computable predicate.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{C}^{\\prime}</span> is a blockset and may not necessarily be a blockchain. Furthermore, observe that for all block sets <span class="math">\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}</span> we have that <span class="math">Q(\\mathcal{C}^{\\prime})\\Rightarrow Q(\\mathcal{C})</span>. This will allow us to later argue that adding more blocks to a blockchain cannot invalidate its witness.</p>

    <p class="text-gray-300">Similarly to suffix-sensitive predicates, infix-sensitive predicates <span class="math">Q</span> can be evaluated very efficiently. Intuitively this is possible because of their localized nature and dependency on the <span class="math">D(\\cdot)</span> predicate which requires only a small number of blocks to conclude whether the predicate should be true.</p>

    <p class="text-gray-300">Example. We next show how to express the predicate that asks whether a certain transaction with id <span class="math">txid</span> has been confirmed as an infix sensitive predicate. We define the predicate <span class="math">D^{txid}</span> that receives a single block and tests whether a transaction with id <span class="math">txid</span> is included. The predicate <span class="math">Q_{1,k}^{txid}</span> is defined as in Definition 6 using the predicate <span class="math">D^{txid}</span> and the parameter <span class="math">k</span> which in this case determines the desired stability of the assertion that <span class="math">txid</span> is included (such as, for instance <span class="math">k=6</span>). Note in this case that auxiliary data will have to be supplied by the prover to aid the provability of <span class="math">D</span>. In particular, for example, the Merkle Tree proof-of-inclusion path to the Merkle Tree root of transactions will need to be included in the case of Bitcoin or the Merkle Patricia Trie proof-of-inclusion path to the Transaction Trie root will need to be included in the case of Ethereum, similar to an SPV proof. Both of these will be logarithmic in the number of transactions included in the block and, hence, constant with respect to the size of the blockchain. In case of a vendor awaiting transaction confirmation to ship a product, the proof that a certain transaction paid into a designated address for the particular order should be sufficient. Note that, in this scheme, it is impossible to determine whether the money has subsequently been spent by the vendor in a future block, and so can only be used by the vendor holding the respective secret keys.</p>

    <p class="text-gray-300">In the above example, note that if the verifier outputs false, this behavior will generally be inconclusive in the sense that the verifier could be outputting false either because the payment has not yet been confirmed or because the payment was never made. We can easily modify the scheme to allow the payer to claim that the payment was made at some particular block height <span class="math">\\ell</span>. The vendor can then bail out after a number of blocks <span class="math">\\ell</span> and conclude that the payment was never made. In order to do that formally, two different infix predicates must be evaluated by the NIPoPoW protocol. The first predicate <span class="math">Q_{1}</span> as above simply checks for transaction confirmation. The second predicate <span class="math">Q_{2}</span> attests to the size of the underlying blockchain and in particular returns true if the blockchain has grown beyond <span class="math">\\ell</span> blocks long. The payment is deemed successful if <span class="math">Q_{1}</span> outputs true and unsuccessful if <span class="math">Q_{2}</span> outputs true. While both predicates are false the result of the experiment is inconclusive. The predicate <span class="math">Q_{2}</span> can be implemented in blockchains which include a verified block depth in their block headers such as Ethereum. As always, the block whose header is checked for block depth must be a stable block in <span class="math">\\mathcal{C}[:-k]</span> to ensure that a malicious miner is not able to tamper with it.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 Construction</h3>

    <p class="text-gray-300">The construction of these proofs is shown in Algorithm 5. The infix prover accepts two parameters: The chain <span class="math">\\mathcal{C}</span> which is the full blockchain and <span class="math">\\mathcal{C}^{\\prime}</span> which is a sub-blockset of the blockchain whose blocks are of interest for the predicate in question. The prover calls the</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. An infix proof descend. Only blue blocks are included in the proof. Blue blocks of level 4 are part of  <span class="math">\\pi</span> , while the blue blocks of level 1 through 3 are produced by followDown to get to the block of level 0 which is part of  <span class="math">\\mathcal{C}&#x27;</span> .</p>

    <p class="text-gray-300">previous suffix prover to produce a proof as usual. Then, having the prefix  <span class="math">\\pi</span>  and suffix  <span class="math">\\chi</span>  of the suffix proof in hand, the infix prover adds a few auxiliary blocks to the prefix  <span class="math">\\pi</span> . The prover ensures that these auxiliary blocks form a chain with the rest of the proof  <span class="math">\\pi</span> . Such auxiliary blocks are collected as follows: For every block  <span class="math">B</span>  of the subchain  <span class="math">\\mathcal{C}&#x27;</span> , the immediate previous  <span class="math">(E&#x27;)</span>  and next  <span class="math">(E)</span>  blocks in  <span class="math">\\pi</span>  are found. Then, a chain of blocks  <span class="math">R</span>  which connects  <span class="math">E</span>  back to  <span class="math">B&#x27;</span>  is found by the algorithm followDown. If  <span class="math">E&#x27;</span>  is of level  <span class="math">\\mu</span> , there can be no other  <span class="math">\\mu</span> -superblock between  <span class="math">E&#x27;</span>  and  <span class="math">B&#x27;</span> , otherwise it would have been included in  <span class="math">\\pi</span> . Therefore,  <span class="math">B&#x27;</span>  already contains a pointer to  <span class="math">E&#x27;</span>  in its interlink, completing the chain.</p>

    <p class="text-gray-300">Algorithm 5 The Prove algorithm for infix proofs 1: function  <span class="math">\\text{Provelnfix}_{m,k}(\\mathcal{C}, \\mathcal{C}&#x27;, \\text{depth})</span> 2:  <span class="math">(\\pi, \\chi) \\gets \\text{Prove}_{m,k}(\\mathcal{C})</span> 3: for  <span class="math">B&#x27; \\in \\mathcal{C}&#x27;</span>  do 4: for  <span class="math">E \\in \\pi</span>  do 5: if depth  <span class="math">[E] \\geq \\text{depth}[B&#x27;]</span>  then 6:  <span class="math">R \\gets \\text{followDown}(E, B&#x27;, \\text{depth})</span> 7: aux  <span class="math">\\gets</span>  aux  <span class="math">\\cup R</span> 8: break 9: end if 10:  <span class="math">E&#x27; \\gets E</span> 11: end for 12: end for 13: return (aux  <span class="math">\\cup \\pi, \\chi</span> ) 14: end function</p>

    <p class="text-gray-300">The way to connect a superblock to a previous lower-level block is implemented in Algorithm 6. Block  <span class="math">B&#x27;</span>  cannot be of higher or equal level than  <span class="math">E</span> , otherwise it would be equal to  <span class="math">E</span>  and the followDown algorithm would return. The algorithm proceeds as follows: Starting at block  <span class="math">hi = E</span> , it tries to follow a pointer to as far as possible. If following the pointer surpasses  <span class="math">lo = B&#x27;</span> , then the following is aborted and a lower level is tried, which will cause a smaller step within the skiplist. If a pointer was followed without surpassing  <span class="math">B&#x27;</span> , the operation continues from the new block, until eventually  <span class="math">B&#x27;</span>  will be reached, which concludes the algorithm.</p>

    <p class="text-gray-300">Algorithm 6 The followDown function which produces the necessary blocks to connect a superblock  <span class="math">hi</span>  to a preceding regular block  <span class="math">lo</span> .</p>

    <pre><code class="language-txt">1: function followDown(hi, lo, depth)
2:  $B \\gets hi$ ; aux  $\\leftarrow []$ ;  $\\mu \\gets$  level(hi)
3: while  $B \\neq lo$  do
4:  $B&#x27; \\gets$  blockByld[B.interlink[μ]]
5: if depth[B&#x27;] &amp;lt; depth[lo] then
6:  $\\mu \\gets \\mu - 1$
7: else
8: aux  $\\leftarrow$  aux  $\\cup \\{B\\}$
9:  $B \\gets B&#x27;$
10: end if
11: end while
12: return aux
13: end function</code></pre>

    <p class="text-gray-300">An example of the output of followDown is shown in Figure 4. This is a portion of the proof shown at the point where the superblock levels are at level 4. A descend to level 0 was necessary so that a regular block would be included in the chain. The level 0 block can jump immediately back up to level 4 because it has a high-level pointer.</p>

    <p class="text-gray-300">The verification algorithm must then be modified as in Algorithm 7.</p>

    <p class="text-gray-300">The algorithm works by calling the suffix verifier. It also maintains a blockDAG collecting blocks from all proofs (it is a DAG because interlink can be adversarially defined). This DAG is maintained in the blockByld hashmap. Using it, ancestors uses simple graph search to extract the set of ancestor blocks of a block. In the final predicate evaluation, the set of ancestors of the best blockchain tip is passed to the predicate. The ancestors are included to avoid an adversary who presents an honest chain but skips the blocks of interest.</p>

    <p class="text-gray-300">Algorithm 7 The verify algorithm for the NIPoPoW infix protocol</p>

    <pre><code>1: function ancestors(B, blockByld)
2: if  $B = \\text{Gen}$  then
3: return  $\\{B\\}$
4: end if
5:  $\\mathcal{C} \\gets \\emptyset$
6: for  $B&#x27; \\in B$ .interlink do
7:  $\\mathcal{C} \\gets \\mathcal{C} \\cup \\text{ancestors}(B&#x27;)$
8: end for
9: return  $\\mathcal{C} \\cup \\{B\\}$
10: end function
11: function verify-infx $_{i,m,k}^{D}(\\mathcal{P})$
12: blockByld  $\\leftarrow \\emptyset$
13: for  $(\\pi, \\chi) \\in \\mathcal{P}$  do
14: for  $B \\in \\pi$  do
15: blockByld[B.id]  $\\leftarrow B$
16: end for
17: end for
18:  $\\tilde{\\pi} \\gets \\text{best } \\pi \\in \\mathcal{P}$  according to suffix verifier
19: return  $D(\\text{ancestors}(\\tilde{\\pi}[-1], \\text{blockByld}))$
20: end function

6 Superchain quality

In order to argue formally about the security properties of blockchains that are equipped with the interlink data structure we will introduce a new concept of *superchain quality*, which generalizes the chain quality property from the backbone model *[12]*. Superchain quality is a new contribution in this paper and is essential for identifying and overcoming the attack on PoPoW.

We first define a notion of “goodness” that bounds the deviation of superblocks of a certain level from their expected mean. Using this we then define superchain quality.

Intuitively, these definitions tell us that $\\mu$-superblocks occur approximately once every $2^{\\mu}$ blocks. Below, we make this notion more formal.

###### Definition 7 (Locally good superchain)

A superchain $\\mathcal{C}^{\\prime}$ of level $\\mu$ with underlying chain $\\mathcal{C}$ is said to be $\\mu$-locally-good with respect to security parameter $\\delta$, written local-good_{δ}($\\mathcal{C}^{\\prime},\\mathcal{C},\\mu$), if $|\\mathcal{C}^{\\prime}|&gt;(1-\\delta)2^{-\\mu}|\\mathcal{C}|$.

###### Definition 8 (Superchain quality)

The $(\\delta,m)$ superquality property $Q^{\\mu}_{seq}$ of a chain $\\mathcal{C}$ pertaining to level $\\mu$ with security parameters $\\delta\\in\\mathbb{R}$ and $m\\in\\mathbb{N}$ states that for all $m^{\\prime}\\geq m$, it holds that local-good_{δ}($C\\uparrow^{\\mu}$ $[-m^{\\prime}:],C\\uparrow^{\\mu}$ $[-m^{\\prime}:]\\downarrow,\\mu$). That is, all sufficiently large suffixes are locally good.

###### Definition 9 (Multilevel quality)

A $\\mu$-superchain $\\mathcal{C}^{\\prime}$ is said to have multilevel quality, written $\\mathrm{multi-good}_{\\delta,k_{1}}(\\mathcal{C},\\mathcal{C}^{\\prime},\\mu)$ with respect to an underlying chain $\\mathcal{C}=\\mathcal{C}^{\\prime}\\downarrow$ with security parameters $k_{1},\\delta$ if for all $\\mu^{\\prime}&lt;\\mu$ it holds that for any $\\mathcal{C}^{*}\\subseteq\\mathcal{C}$, if $|\\mathcal{C}^{*}\\uparrow^{\\mu^{\\prime}}\\mid\\geq k_{1}$, then $|\\mathcal{C}^{*}\\uparrow^{\\mu}\\mid\\geq(1-\\delta)2^{\\mu^{\\prime}-\\mu}|\\mathcal{C}^{*}\\uparrow^{\\mu^{\\prime}}\\mid$.

Putting the above together we conclude with the notion of a good superchain.

###### Definition 10 (Good superchain)

A $\\mu$-superchain $\\mathcal{C}^{\\prime}$ is said to be good, written $\\mathrm{good}_{\\delta,k_{1}}(\\mathcal{C},\\mathcal{C}^{\\prime},\\mu)$, with respect to an underlying chain $\\mathcal{C}=\\mathcal{C}^{\\prime}\\downarrow$ if it has both superquality and multilevel quality with parameters $(\\delta,m)$.

It is not hard to see that the above good statistical properties are attained with overwhelming probability by all chains that are generated in optimistic environments, i.e. if no adversary tries to violate them. This is proven formally in the appendix.

## 7 An attack

We now show that our above construction is insecure by illustrating an explicit attack against our scheme. We show that this attack is applicable in the same manner against our construction as it is applicable against the previous PoPoW work *[15]*. PoPoW serves as the starting point and inspiration for our protocol. The security proof is incorrect, and in fact the PoPoW protocol is susceptible to a double-spending attack within the model (i.e., that can be carried out by an attacker with less than 50% hash power). During the exposition of this attack, a patch for our construction, which will also lead to a correct generic security proof, will become clear.

We focus on illustrating why the PoPoW construction of previous work is insecure against an adversary controlling less than 50% of hashing power. The attack immediately carries over to our straw man construction introduced above, a vulnerability we will address in later sections. We proceed in two steps. We first show that a powerful attacker can break chain superquality with non-negligible probability. Then we construct a concrete

double spending attack based on this observation assuming an attacker of sufficiently high hashing power (but still below  $50\\%$ ). Note that maintaining chain superquality was not in the original security model; however, we show how the property affects the security of the underlying blockchain proofs.

# 7.1 Interactive proofs of proof-of-work

In PoPoW, the main algorithm of the verifier aims at distinguishing between two candidate proofs  $(\\pi_A,\\chi_A)$  and  $(\\pi_B,\\chi_B)$ . The honest prover, having adopted  $\\mathcal{C}_B$  during mining, initially produces the proof  $(\\pi_B,\\chi_B)$  as follows. First, the last  $k$  blocks are sent as  $\\chi_B = \\mathcal{C}_B[-k:]$ . Then for the first part of the chain,  $\\mathcal{C}_B[: - k]$ , the prover sets  $\\pi_B$  to be the  $\\mu$ -superchain spanning  $\\mathcal{C}_B$  for the largest  $\\mu$  such that  $|\\pi_B| = m$ , where  $m$  is the protocol&#x27;s security parameter. The verifier ensures that  $|\\pi_A|\\geq m,|\\pi_B|\\geq m$  so that the proofs are not shorter than  $m$  and then checks whether  $\\pi_A = \\pi_B$ ; if so, the decision is drawn immediately based on  $\\chi_A,\\chi_B$  without interaction. Otherwise, the verifier queries the provers for their claimed anchored superchains  $\\mathcal{C}_A\\uparrow^\\mu$ ,  $\\mathcal{C}_B\\uparrow^\\mu$  at some level  $\\mu$ . The verifier starts querying at the highest possible level  $\\mu$  and descends until level  $\\mu$  is sufficiently low such that  $b = LCA(\\pi_A\\uparrow^\\mu ,\\pi_B\\uparrow^\\mu)$  is  $m$  blocks from the tip of the chain for one of the proofs. That is, the querying stops at such  $\\mu$  when  $max(|\\pi_A\\uparrow^\\mu \\{b:\\} |,|\\pi_B\\uparrow^\\mu \\{b:\\} |)\\geq m$ . The winner is designated as the prover with the most blocks after  $b$  at that level; i.e.,  $A$ , if  $|\\pi_A\\uparrow^\\mu \\{b:\\} |\\geq |\\pi_B\\uparrow^\\mu \\{b:\\} |$ , and  $B$  otherwise. The communication overhead is reduced by only requesting blocks after the purported LCA. The security parameter  $m$  is chosen to ensure that the probability of the attacker producing a long superchain is negligible.

# 7.2 Attacking chain superquality

We construct an adversary  $\\mathcal{A}$  that breaks the superchain quality at level  $\\mu$ .  $\\mathcal{A}$  works as follows. Assume she wants to attack the honest party  $B$  in order to have him adopt chain  $\\mathcal{C}_B$  which has a bad distribution of superblocks, i.e. such that local goodness is violated in some sufficiently long subchain. She continuously determines the current chain  $\\mathcal{C}_B$  adopted by  $B$ . The adversary starts playing after  $|\\mathcal{C}_B| \\geq 2$ . If level  $(\\mathcal{C}_B[-1]) &amp;lt; \\mu$ , then  $\\mathcal{A}$  remains idle. However, if level  $(\\mathcal{C}_B[-1]) \\geq \\mu$ , then  $\\mathcal{A}$  attempts to mine an adversarial block  $b$  on top of  $\\mathcal{C}_B[-2]$ . If successful, she attempts to mine another block  $b&#x27;$  on top of  $b$ . If successful again, she broadcasts  $b$  and  $b&#x27;$ . The adversarial mining continues until  $B$  adopts a new chain, which can be due to two reasons: Either the adversary successfully mined  $b, b&#x27;$  on top of  $\\mathcal{C}_B[-2]$  and  $B$  adopts them; or one of the honest parties mined a block which was adopted by  $B$ . In either case, the adversary restarts the strategy by inspecting  $\\mathcal{C}[-1]$  and acting accordingly. An execution of this attack is illustrated in Figure 5.

![img-4.jpeg](img-4.jpeg)
Fig. 5. Superquality attack on prior work (PoPoW) [15]. The adversary performs a selfish-mining [11] attack (gray blocks) whenever any honest parties have recently mined a rare  $\\mu$ -superblock (black). The attack reduces the honest chain&#x27;s superquality, while the attacker&#x27;s private chain is unaffected.

Assume now that an honestly-generated  $\\mu$ -superblock was adopted by  $B$  at position  $\\mathcal{C}_B[i]$  at round  $r$ . We now examine the probability that  $\\mathcal{C}_B[i]$  will remain a  $\\mu$ -superblock in

the long run. Suppose $r^{\\prime}&amp;gt;r$ is the first round after $r$ during which a block is generated. $\\mathcal{A}$ will succeed in this attack with non-negligible probability and cause $B$ to abandon the $\\mu$-superblock from their adopted chain. Therefore, there exists $\\delta$ such that the adversary will be able to cause $\\delta$-variance with non-negligible probability in $m$. This suffices to show that superquality is violated.

As seen in the illustration, while the honest parties have generated several $\\mu$-superblocks, some of them are in blockchain forks which have been abandoned, causing a superquality harm.

### 7.3 A double-spending attack

Extending the above attack, we modify the superquality attacker into an attacker that causes a double spending attack in the PoPoW construction. We first give a sketch of the attack.

As before, $\\mathcal{A}$ targets the proofs generated by honest party $B$ by violating $\\mu$-superquality in $B$’s adopted chain. $\\mathcal{A}$ begins by remaining idle until a certain chosen block $b$. After block $b$ is produced, $\\mathcal{A}$ starts mining a secret chain which forks off from $b$ akin to a selfish mining attacker *[11]*. The adversary performs a normal spending transaction on the honestly adopted blockchain and has it confirmed in the block immediately following block $b$. She also produces a double spending transaction which she secretly confirms in her secret chain in the block immediately following $b$.

$\\mathcal{A}$ keeps extending her own secret chain as usual. However, whenever a $\\mu$-superblock is adopted by $B$, she temporarily pauses mining in her secret chain and devotes her mining power to harm the $\\mu$-superquality of $B$’s adopted chain. Intuitively, for large enough $\\mu$, the time spent trying to harm superquality will be limited, because the probability of a $\\mu$-superblock occurring will be small. Therefore, the adversary’s superchain quality will be larger than the honest parties’ superchain quality (which will be harmed by the adversary) and therefore, even though the adversary’s 0-chain will be shorter than the honest parties’ 0-chain, the adversary’s $\\mu$-superchain will be longer than the honest parties’ $\\mu$-superchain and thus will be favored by the verifier! The formal calculation of the probability of this attack succeeding is in the appendix. We note that actually, for appropriate choice of system parameters, the attack can be made to succeed with overwhelming probability.

## 8 Security

Based on the attack explored above, it is now easy to see that our construction can be patched in a straightforward manner to achieve security. In particular, since the manner in which the adversary was able to subvert the prover was by the violation of *goodness*, we can mandate that the prover only tries to use succinct proofs to prove claims about chains that are *good at every level*. In case goodness is violated, the prover simply falls back to providing the whole chain. This allows us to argue that the construction is secure by distinguishing two cases. In case goodness is violated, the honest prover will fall back to providing the whole chain, in which case security will be reduced to the security of the standard blockchain protocol choosing the longest 0-chain. In case goodness is not violated, we will argue that the adversary is unable to win in these comparisons.

The previous construction was designed to prevent Bahack-style attacks *[3]*, where the adversary constructs “lucky” high-difficulty superblocks without filling in the underlying proof-of-work in the lower levels. We now patch our protocol which, while retaining this

5 We thank Giorgos Panagiotakos, Peter Gaži, and Nikos Leonardos for their insights in this construction.

highlevel approach, adds a defence against the double-spending attack of Section 7. The attack is neutralized since our verifier is more permissive, allowing the prover to construct a proof that takes superquality &quot;goodness&quot; into account when comparing forks. The modified construction is shown in Algorithm 8. The algorithm has been modified to check the current portion of the subchain  $\\alpha$  for goodness prior to moving to the lower superchain level. If goodness is indeed maintained at the current level  $\\mu$ , the prover only tries to cover the span of the last  $m$  blocks of level  $\\mu$  at level  $\\mu - 1$ , as seen in Line 7. Otherwise, if goodness is violated at the part of the subchain  $\\alpha$  at level  $\\mu$ , then the prover completely ignores level  $\\mu$  and tries to use the lower level  $\\mu - 1$  to cover the whole span of  $\\alpha$ .

Algorithm 8 The goodness aware Prove algorithm for the NIPoPoW protocol
1: function Prove $_{\\text{mod}, b}$ (C)
2:  $B \\gets \\mathcal{C}[0]$  ▷ Genesis
3: for  $\\mu = |\\mathcal{C}[-k].$ interlink| down to 0 do
4:  $\\alpha \\gets \\mathcal{C}[: -k]\\{B:\\} \\uparrow^{\\rho}$
5:  $\\pi \\gets \\pi \\cup \\alpha$
6: if  $\\text{good}_{k,m}(\\mathcal{C}, \\alpha, \\mu)$  then
7:  $B \\gets \\alpha[-m]$
8: end if
9: end for
10:  $\\chi \\gets \\mathcal{C}[-k:]$
11: return  $\\pi \\chi$
12: end function

Only the concrete prover needs to be modified. The verifier and  $\\leq_{m}$  operator remain as defined previously.

To aid intuition, we will first give a sketch of the proof before giving the full technical proof.

Theorem 1 (Security). Assuming honest majority, the non-interactive proofs-of-proof-of-work construction for computable  $k$ -stable monotonic suffix-sensitive predicates is secure with overwhelming probability in  $\\kappa$ .

Proof (Sketch). Suppose an adversary produces a proof  $\\pi_{\\mathcal{A}}$  and an honest party produces a proof  $\\pi_B$  such that the two proofs cause the predicate  $Q$  to evaluate to different values, while at the same time all honest parties have agreed that the correct value is the one obtained by  $\\pi_B$ . Because of bitcoin&#x27;s security,  $\\mathcal{A}$  will be unable to make these claims for an actual underlying 0-level chain.

We now argue that the operator  $\\leq_{m}$  will signal in favour of the honest parties. Suppose  $b$  is the LCA block between  $\\pi_{\\mathcal{A}}$  and  $\\pi_B$ . If the chain forks at  $b$ , there can be no more adversarial blocks after  $b$  than honest blocks after  $b$ , provided there are at least  $k$  honest blocks (due to the Common Prefix property). We will now argue that, further, there can be no more disjoint  $\\mu_{\\mathcal{A}}$ -level superblocks than honest  $\\mu_B$ -level superblocks after  $b$ .

To see this, let  $b$  be an honest block generated at some round  $r_1$  and let the honest proof have been generated at some round  $r_3$ . Then take the sequence of consecutive rounds  $S = (r_1, \\dots, r_3)$ . Because the verifier requires at least  $m$  blocks from each of the provers, the adversary must have  $m \\mu_{\\mathcal{A}}$ -superblocks in  $\\pi_{\\mathcal{A}}\\{b : \\}$  which are not in  $\\pi_B\\{b : \\}$ . Therefore, using a negative binomial tail bound argument, we see that  $|S|$  must be long; intuitively, it takes a long time to produce a lot of blocks  $|\\pi_{\\mathcal{A}}\\{b : \\}|$ . Given that  $|S|$  is long and that the honest parties have more mining power, they must have been able to produce a longer

$\\pi_{B}\\{b:\\}$ argument (of course, this comparison will have the superchain lengths weighted by $2^{\\mu_{A}},2^{\\mu_{B}}$ respectively). To prove this, we use a binomial tail bound argument; intuitively, given a long time $|S|$, a lot of $\\mu_{B}$-superblocks $|\\pi_{B}\\{b:\\}|$ will have been honestly produced.

We therefore have a fixed value for the length of the adversarial argument, a negative binomial random variable for the number of rounds, and a binomial random variable for the length of the honest argument. By taking the expectations of the above random variables and applying a Chernoff bound, we see that the actual values will be close to their means with overwhelming probability, completing the proof. ∎

We formalize the above proof sketch in the Appendix.

## 9 Succinctness

We will illustrate why our construction is succinct in the honest setting. For techniques to make the construction succinct in broader adversarial settings, consult the appendix.

Having established security in the general case of the standard honest majority model, we now concentrate on establishing performance guarantees. We analyse the patched scheme we saw in Algorithm 8.

We first observe that full succinctness in the standard honest majority model is impossible to prove for our construction. To see why, recall that an adversary with sufficiently large mining power can significantly harm superquality as described in Section 7.2. By reducing superquality for a sufficiently low level $\\mu$, for example $\\mu=3$, the adversary can cause the honest prover to digress in their proofs from high-level superchains down to low-level superchains, causing a linear proof to be produced.

For instance, if superquality is harmed at $\\mu=3$, the prover will need to digress down to level $\\mu=2$ and include the whole $2$-superchain, which, in expectation, will be of size $|\\mathcal{C}|/2$.

Having established security in the general case of the standard honest majority model, we now concentrate our succinctness claims to the particular “optimistic” case where the adversary does not use their (minority) computational power or network power. Therefore, the superquality of the chain must be the same as a fully honestly-generated chain generated with no network adversary. Last, for now, we will not allow the adversary to produce any proofs; that is, all proofs consumed by the verifier are honestly-generated. This security assumption is akin to *[15]*. We will lift this last assumption shortly.

###### Theorem 2 (Number of levels).

The number of superblock levels which have at least $m$ blocks are at most $\\log(|S|)$, where $S$ is the set of all blocks produced, with overwhelming probability in $m$.

###### Proof.

Let $S$ be the set of all blocks successfully produced by the honest parties or the adversary. Each block id is generated by the random oracle, so $\\Pr[\\text{id}\\leq T2^{-\\mu}]=2^{-\\mu}$. These are independent Bernoulli trials. For each $B\\in S$, let $X_{B}^{\\mu}\\in\\{0,1\\}$ be the random variable indicating whether the block belongs to level $\\mu$ and let $D_{\\mu}$ indicate their sum, which is a Binomial distribution with parameters $(|S|,2^{-\\mu})$ and expectation $E[D_{\\mu}]=|S|2^{-\\mu}$.

For level $\\mu$ to exist in any valid proof, at least $m$ blocks of level $\\mu$ must have been produced by the honest parties or the adversary. We show that $m$ blocks of level $\\mu=\\log(|S|)$ are produced with negligible probability in $m$.

All of the $X^{\\mu}$ are independent. We apply a Binomial Chernoff bound to the sum. We have $\\Pr[D_{\\mu}\\geq(1+\\Delta)E[D_{\\mu}]]\\leq\\exp(-\\frac{\\Delta^{2}}{2+\\Delta}E[D_{\\mu}])$. But for this $\\mu$ we have that $E[D_{\\mu}]=1$. Therefore $\\Pr[D_{\\mu}\\geq 1+\\Delta]\\leq\\exp(-\\frac{\\Delta^{2}}{2+\\Delta})$. Requiring $1+\\Delta=m$, we get $\\Pr[D_{\\mu}\\geq m]\\leq\\exp(-\\frac{(m-1)^{2}}{m+1})$, which is negligible in $m$. ∎

The above theorem establishes that the number of superchains is small. What remains to be shown is that few blocks will be included at each superchain level.

###### Theorem 3 (Large upchain expansion).

Let $\\mathcal{C}$ be an honestly generated chain and let $\\mathcal{C}^{\\prime}=\\mathcal{C}\\uparrow^{\\mu-1}\\left[i:i+\\ell\\right]$ with $\\ell\\geq 4m$. Then $|\\mathcal{C}^{\\prime}\\uparrow^{\\mu}|\\geq m$ with overwhelming probability in $m$.

###### Proof.

Assume the $(\\mu-1)$-level superchain has $4m$ blocks. Because each block of level $\\mu-1$ was generated as a query to the random oracle, it constitutes an independent Bernoulli trial and the number of blocks in level $\\mu$, namely $\\pi\\uparrow^{\\mu}$, is a Binomial distribution with parameters $(4m,1/2)$. Clearly $\\Pr[|\\pi\\uparrow^{\\mu}|=m]\\leq\\Pr[|\\pi\\uparrow^{\\mu}|\\leq m]$. Observing that $E[\\pi\\uparrow^{\\mu}]=2m$ and applying a Chernoff bound, we get $\\Pr[|\\pi\\uparrow^{\\mu}|\\leq(1-\\frac{1}{2})2m]\\leq\\exp(-\\frac{(1/2)^{2}}{2}2m)$ which is negligible in $m$.

This probability bounds the probability of fewer than $m$ blocks occurring in the $\\mu$ level restriction of $(\\mu-1)$-level superchains of more than $4m$ blocks. ∎

###### Lemma 1 (Small downchain support).

Assume an honestly generated chain $\\mathcal{C}$ and let $\\mathcal{C}^{\\prime}=\\mathcal{C}\\uparrow^{\\mu}\\left[i:i+m\\right]$. Then $|\\mathcal{C}^{\\prime}\\downarrow\\uparrow^{\\mu-1}|\\leq 4m$ with overwhelming probability in $m$.

###### Proof.

Assume the $(\\mu-1)$-level superchain had at least $4m$ blocks. Then by Theorem 9 it follows that more than $m$ blocks exist in level $\\mu$ with overwhelming probability in $m$, which is a contradiction. ∎

This last theorem establishes the fact that the support of blocks needed under the $m$-sized chain suffix to move from one level to the one below is small. Based on this, we can establish our theorem on succinctness:

###### Theorem 4 (Optimistic succinctness).

If all players are honest and the network scheduling is random, non-interactive proofs-of-proof-of-work produced by honest provers are succinct with the number of blocks bounded by $4m\\log(|\\mathcal{C}|)$, with overwhelming probability in $m$.

###### Proof.

Assume $\\mathcal{C}$ is an honest parties’ chain. From Theorem 8, the number of levels in the NIPoPoW is at most $\\log(|\\mathcal{C}|)$ with overwhelming probability in $m$. First, observe that the count of blocks in the highest level will be less than $4m$ from Theorem 9; otherwise a higher superblock level would exist. From Corollary 5, we know that at all levels $\\mu$ the chain will be good. Therefore, for each $\\mu$ superchain $\\mathcal{C}$ the supporting $(\\mu-1)$-superchain will only need to span the $m$-long suffix of the $\\mu$-superchain above. For the $m$-long suffix of each superchain of level $\\mu$, the supporting superchain of level $\\mu-1$ will have at most $4m$ blocks from Lemma 9. Therefore the size of the proof is $4m\\log(|\\mathcal{C}|)$. ∎

In the above theorem, note the linear dependency between the round $r$ that a proof is generated and the length $|\\mathcal{C}|$ of the chain of each honest prover.

## 10 Implementation &amp; Parameters

We now discuss the size of NIPoPoW proofs and evaluate concrete parameters. Organizing the interlink data structure as a Merkle tree of $\\log(|\\mathcal{C}|)$ items, a proof-of-inclusion is provided in $\\log\\log(|\\mathcal{C}|)$ space; the proof need not include $0$-level pointers, must include the genesis block. The root of the tree can be proved to be included in the block header in $\\log(|\\overline{x}|)$ using the standard Merkle tree of transactions, where $\\overline{x}$ denotes the vector of all

transactions included in the particular block. This makes the proof size require  $\\log (|\\overline{x}|) + \\log \\log (|\\mathcal{C}|)$  hashes per block for a total of  $m(\\log (|\\mathcal{C}|) - \\log (m))(\\log (|\\overline{x}|) + \\log \\log (|\\mathcal{C}|))$  hashes. In addition,  $m(\\log (|\\mathcal{C}|) - \\log (m))$  headers and coinbase transactions are needed. As an example, given that currently in bitcoin  $|\\mathcal{C}| = 464,185$  and  $|\\overline{x}| = 2000$ , we have  $\\log (|\\mathcal{C}|) = 18, \\log \\log (|\\mathcal{C}|) = 5, \\log (|\\overline{x}|) = 11$ . For the  $k$ -suffix, only  $k$  headers are needed. We set  $k = 6$  and see that headers are 80 bytes and hashes 32 bytes. For the  $k$ -suffix as well as the  $2m$  0-blocks in  $\\pi$ , neither coinbase data nor prev ids are needed, limiting header size to 48 bytes. The root and leaves of the pointers tree can be omitted from coinbase when transmitting the proof. In fact, no block ids need to be transmitted. From these observations, we estimate our scheme&#x27;s proof sizes for various parameterizations of  $m$  in Table 1.

Concrete parameterization. To determine concrete values for security parameter  $m$ , we focus on a particular adversarial strategy and analyze its probability of success. The attack is an extension of the stochastic processes described in [19] and [24].

The experiment works as follows:  $m$  is fixed and some adversarial computational power percentage  $q$  of the total network computational power is chosen;  $k$  is chosen based on  $q$  according to Nakamoto [19]. The number of blocks  $y$  during which parallel mining will occur is also fixed. The experiment begins with the adversary and honest parties sharing a common blockchain which ends in block  $B$ . After  $B$  is mined, the adversary starts mining in secret and in parallel with the honest parties on her own private fork on top of  $B$ . She ignores the honest chain, so that the two chains remain disjoint after  $B$ . As soon as  $y$  blocks have been mined in total, the adversary attempts a double spend via a NIPoPoW by creating two conflicting transactions which are committed to an honest block and an adversarial block respectively on top of each current chain. Finally, the adversary mines  $k$  blocks on top of the double spending transaction within her private chain. After these  $k$  blocks have been mined, she publishes her private chain in an attempt to overcome the honest chain.

Table 1. Size of NIPoPoWs applied to Bitcoin today ( $\\approx$ 450k blocks) for various values of  $m$ , setting  $k = 6$ .

|  m | NIPOw | size | Blocks | Hashes  |
| --- | --- | --- | --- | --- |
|  6 | 70 kB |  | 108 | 1440  |
|  15 | 146 kB |  | 231 | 2925  |
|  30 | 270 kB |  | 426 | 5400  |
|  50 | 412 kB |  | 656 | 8250  |
|  100 | 750 kB |  | 1206 | 15000  |
|  127 | 952 kB |  | 1530 | 19050  |

We measure the probability of success of this attack. We experiment with various values of  $m$  for  $y = 100$ , indicating 100 blocks of secret parallel mining. We make the assumption that honest party communication is perfect and immediate. We ran 1,000,000 Monte Carlo executions of the experiment for each value of  $m$  from 1 to 30. We ran the simulation for values of computational power percentage  $q = 0.1$ ,  $q = 0.2$  and  $q = 0.3$ . The results are plotted in Figure 6.

Based on this data, we conclude that  $m = 5$  is sufficient to achieve a 0.001 probability of failure against an adversary with  $10\\%$  mining power. To secure against an adversary with more than  $30\\%$  mining power, a choice of  $m = 15$  is needed.

![img-5.jpeg](img-5.jpeg)
Fig. 6. Simulation results for a private mining attacker with  $k$  according to Nakamoto and parallel mining parameter  $y = 100$ . Probabilities in logarithmic scale. The horizontal line indicates the threshold probability of [19] is indicated by the horizontal line.

# 11 Evaluation &amp;amp; Applications

In this section we evaluate the cost of NIPoPoWs when used in realistic blockchain applications. First we simulated the resources savings resulting from the use of a NIPoPoW-based client compared to ordinary SPV. We model the arrival of payments in each cryptocoin as a Poisson process and assume that the market cap of a cryptocoin is a proxy for usage. Currently, a total of 731 cryptocurrencies are listed on coin market directories $^{7}$ . We narrow our focus to the 80 cryptocurrencies that have their own PoW blockchains (i.e., no PoS) with a market cap of over USD $100,000.

In Table 2 we show aggregate statistics about these 80 cryptocurrencies, grouped according to the their PoW puzzle. While the entire chain in Bitcoin only amounts to  $40\\mathrm{MB}$ , taken together, the 80 cryptocurrencies comprise 10 GB of proofs-of-work, and generate 10 MB more each day. In Table 3 we show the resulting bandwidth costs from simulating a period of 60 days with  $m = 24$ ,  $k = 6$ , with varying rates of payments received. For the naive SPV client, the total bandwidth cost is dominated by fetching the entire chain of headers, which the NIPoPoW client avoids. The marginal cost for naive SPV depends on the number of blocks generated per day, as well as the transaction inclusion proofs associated with each payment. The NIPoPoW based client provides the most savings when the number of transactions per day is smallest, reducing the necessary bandwidth per day (excluding the initial sync up) by  $90\\%$ .

Multi-blockchain wallets. An application of our technique is an efficient multi-cryptocoin client. Consider a merchant who wishes to accept payments in any cryptocoin, not just the popular ones. The naïve approach would be to install an SPV client for each known cryptocoin. This approach would entail downloading the header chain for each cryptocoin, and periodically syncing up by fetching any newly generated block headers. An alternative would be to use an online service supporting multiple currencies, but this introduces reliance on a third party (e.g. Jaxx and Coinomi rely on third party networks).

Table 2. Cost of header chains for all active PoW-based cryptocoins (collected from coinwarz.com)

|  Hash | Coins | Size today | Growth rate  |
| --- | --- | --- | --- |
|  Scrypt | 44 | 4.3 GB | 5.5 MB / day  |
|  SHA-256 | 15 | 1.4 GB | 937.0 kB / day  |
|  X11 | 5 | 581.1 MB | 556.3 kB / day  |
|  Quark | 3 | 647.9 MB | 518.4 kB / day  |
|  CryptoNight | 2 | 199.0 MB | 115.2 kB / day  |
|  EtHash | 2 | 588.6 MB | 921.6 kB / day  |
|  Groestl | 2 | 300.3 MB | 184.2 kB / day  |
|  NeoScrypt | 2 | 310.6 MB | 153.6 kB / day  |
|  Others | 5 | 266.2 MB | 311.1 kB / day  |
|  Total | 80 | 8.5 GB | 9.2 MB / day  |

Table 3. Simulated bandwidth of multi-blockchain clients after two months (Averaged over 10 trials each)

|  tx/day | Naive SPV Total (Daily) | NIPoPoW Total (Daily) | Savings  |
| --- | --- | --- | --- |
|  100 | 5.5 GB(5.5 MB) | 31.7 MB(507 kB) | 99% (91%)  |
|  500 | 5.5 GB(5.7 MB) | 68.2 MB(1.1 MB) | 99% (81%)  |
|  1000 | 5.5 GB(6.0 MB) | 99.1 MB(1.6 MB) | 98% (73%)  |
|  3000 | 5.6 GB(7.0 MB) | 192 MB (3.1 MB) | 97% (56%)  |

A NIPoPoW-based client would not download the entire header chain, but would instead only receive NIPoPoW proofs each time a payment is received. When a peer informs the client about a payment, they include a block index  $\\ell$  and NIPoPoW proof of transaction inclusion. The peer must then query all of their connected peers, requesting any better better proof for the same predicate. After waiting a short time period for a response, the client runs the verify-infix routine on all received proofs, and accepts the transaction if the output is true. Although initially such proofs must be relative genesis, the client may store the most recently-known ( $k$ -stable) blockchain for each cryptocoin, such that future payments can include NIPoPoW proofs relative to that. Thus for poplar cryptocoins, the NIPoPoW-based client downloads nearly every block header, like an ordinary SPV client; but for cryptocoins used infrequently, the NIPoPoW-based client can skip over most blocks.

Cross-chain ICOs. As an example use-case of our construction, we present the case of an ICO in which tokens are distributed in one blockchain, but funds are raised in another. It works as follows: There are two designated blockchains, the source and the destination blockchain. The source is the blockchain where the fund-raising will take place, while the destination is the blockchain where the newly issued tokens will be distributed and subsequently exchanged. The destination blockchain must be smart-contract-enabled in order to allow for the distribution of ERC-20-style [28] tokens. In addition, the smart contracts on the destination blockchain must allow for programming the verification of a NIPoPoW proof by including, for example, the appropriate hash functions. The source blockchain must be NIPoPoW-enabled via one of the mechanism described in the upgrade section. This setup allows the creation of NIPoPoWs about the source blockchain which will be included in the destination blockchain. For example, a source blockchain can be Litecoin and a destination blockchain Ethereum.

In order to run the ICO, the fund-raising entity first creates a designated account in the source blockchain in which funds will be deposited. It then creates the ERC-20-style smart contract in the destination blockchain. When someone wishes to participate in the ICO, they transfer funds into the designated account on the source blockchain. Once she has made the transfer and it becomes confirmed, the payer generates a NIPoPoW about the

transaction paying into the designated account. That NIPoPoW is then sent as a parameter to a method call on the ICO smart contract on the destination blockchain. The method call stores the proof and waits for a certain period of time for possible contestations, which can be accepted and compared using the $\\leq_{m}$ mechanism previously described. If no contesting proof is presented within the contestation period, the prover receives their respective ICO tokens on the target blockchain. In order for only the rightful owner to be able to receive the tokens, they are required to sign the destination address on the destination blockchain using the private key corresponding to their source account used to make the payment within the source blockchain.

Our Appendix is structured as follows. In Section A, we illustrate gradual deployment paths. One of our techniques allows adoption of our scheme without requiring miner consensus. We term this technique a *velvet fork* in contrast to the classical *soft* and *hard forks* which require approval by a majority of miners. This technique is a novel contribution and may be of independent interest for other blockchain protocols. Section B gives the lemmas and associated proofs showing how superchains are distributed. This provides the necessary tools to show that the construction is optimistically succinct. Section C contains the full formality of our attack against previous work, together with a proof that our attack succeeds with overwhelming probability, given the correct strategy and protocol parameters. Section D gives a formal proof of our security claims through a cryptographic reduction. Section E includes the remaining proofs that were omitted from the body of the paper with the goal of proving optimistic succinctness, a central result of our paper. It also proves succinctness in more adversarial settings, which is another novel contribution, as succinctness in any kind of adversarial setting has not been explored in previous work. We conclude with Section F which includes experimental data of our Solidity implementation for the ICO application.

## Appendix A Gradual Deployment Paths

Our construction requires an upgrade to the consensus layer. We envision that new cryptocurrencies will adopt our construction in order to support efficient light clients. However, existing cryptocurrencies could also benefit by adopting our construction as an upgrade. In this section we outline several possible upgrade paths. We also contribute a novel upgrade approach, a “velvet fork,” which allows for gradual deployment without harming unupgraded miners.

### A.1 Hard Forks and Soft Forks

The obvious way to upgrade a cryptocoin to support our protocol is a hard fork: the block header is modified to include the interlink structure, and the validation rules modified to require that new blocks (after a “flag day”) contain a correctly-formed interlink hash.

The safety of a hard fork is debated *[7]*, as they are not “forward compatible,”. NIPoPoWs can also be implemented by a soft fork. A soft fork construction requires including the interlink not in the block header, but in the coinbase transaction. It is enough to only store a hash of the interlink structure. The only requirement for the NIPoPoWs to work is that the PoW commits to all the pointers within the interlink so that the adversary cannot cause a chain reorganization. If we take that route, then each NIPoPoW will be required to present not only the block header, but also a proof-of-inclusion path within the Merkle tree of transactions proving that the coinbase transaction is indeed part of the block. Once that is established, the coinbase data can be presented, and the verifier will thereby know that the hash of the interlink data structure is correct. Given that in Bitcoin implementation there is a block size limit, observe that including such proofs-of-inclusion will only increase the NIPoPoW sizes by a constant factor per block, allowing for the communication complexity to remain polylogarithmic.

### A.2 Velvet Forks

We now describe a novel upgrade path that avoids the need for a fork at all. The key idea is that clients can make use of our scheme, even if only some blocks in the blockchain

include the interlink structure. Given that intuitively the changes we will propose require no rule modifications to the consensus layer, we call this technique a *velvet fork* .

We require upgraded miners to include the interlink data structure in the form of a new Merkle tree root hash in their coinbase data, similar to a soft fork. An unupgraded miner will ignore this data as comments. We further require the upgraded miners to accept all previously accepted blocks, regardless of whether they have included the interlink data structure or not. Even if the interlink data structure is included and contains invalid data, we require the upgraded miners to accept their containing blocks. Malformed interlink data could be simply of the wrong format, or the pointers could be pointing to superblocks of incorrect levels. Furthermore, the pointers could be pointing to superblocks of the correct level, but not to the most recent block. By requiring upgraded miners to accept all such blocks, we do not modify the set of accepted blocks. Therefore, the upgrade is simply a “recommendation” for miners and not an actual change in the consensus rules. Hence, while a hard fork makes new upgraded blocks invalid to unupgraded clients and a soft fork makes new unupgraded blocks invalid to upgraded clients, the velvet fork has the effect that blocks produced by either upgraded or unupgraded clients are valid for either. In reality, the blockchain is never forked. Only the codebase is upgraded, and the data on the blockchain is interpreted differently.

The reason this can work is because provers and verifiers of our protocol can check the validity of the claims of miners who make false interlink chain claims. An upgraded prover can check whether a block contains correct interlink data and use it. If a block does not contain correct interlink data, the prover can opt not to use those pointers in their proofs. The Verifier verifies all claims of the prover, so adversarial miners cannot cause harm by including invalid data. The one thing the Verifier cannot verify in terms of interlink claims is whether the claimed superblock of a given level is the most recent previous superblock of that level. However, an adversarial prover cannot make use of that to construct winning proofs, as they are only able to present shorter chains in that case. The honest prover can simply ignore such pointers as if they were not included at all.

The velvet prover works as usual, but additionally maintains a *realLink* data structure, which stores the *correct* interlink for each block. Whenever a new winning chain is received from the network, the prover checks it for blocks that it hasn’t seen before. For those blocks, it maintains its own realLink data structure which it updates accordingly to make sure it is correct regardless of what the interlink data structure of the received block claims.

The velvet $\\mathcal{C}\\uparrow$ operator shown in Algorithm 9 is implemented identically as before, except that instead of following the interlink pointer blindly it now calls the helper function *followUp*, shown in Algorithm 10. It accepts block $B$ and level $\\mu$ and creates a connection from $B$ back to the most recent preceding $\\mu$-superblock, by following the interlink pointer if it is correct. Otherwise, it follows the previd link which is available in all blocks, and tries to follow the interlink pointer again from there. Finally, the velvet prover shown in Algorithm 11 simply applies the velvet $\\mathcal{C}\\uparrow$ operator and includes the auxiliary connecting nodes within the final proof. No changes in the verifier are needed; note that in the case of infix proofs the index of the block is used by the verifier; if this information is not provided by the underlying blockchain headers, the index should be included in the interlink structure.

|  Algorithm 9 The modified constructInnerChain that allows for a velvet fork.  |   |
| --- | --- |
|  1: function constructInnerChain&#x27;(C, μ, b, realLink, blockById)  |   |
|  2: B ← C[-1]  |   |
|  3: aux ← [B]  |   |
|  4: π ← [B]  |   |
|  5: while B ≠ b do  |   |
|  6: (B, aux&#x27;) ← followUp(B, μ, realLink, blockById)  |   |
|  7: aux.append(aux&#x27;)  |   |
|  8: π.append(B)  |   |
|  9: end while  |   |
|  10: return π, aux  |   |
|  11: end function  |   |
|  Algorithm 10 followUp produces the blocks to connect two superblocks in velvet forks.  |   |
| --- | --- |
|  1: function followUp(B, μ, realLink, blockById)  |   |
|  2: aux ← [B]  |   |
|  3: while B ≠ Gen do  |   |
|  4: if B.interlink[μ] = realLink[id(B)][μ] then  |   |
|  5: id ← B.interlink[μ]  |   |
|  6: else | ▷ Invalid interlink  |
|  7: id ← B.interlink[0]  |   |
|  8: end if  |   |
|  9: B ← blockById[id]  |   |
|  10: aux ← aux ∪ {B}  |   |
|  11: if level(B) = μ then  |   |
|  12: return B, aux  |   |
|  13: end if  |   |
|  14: end while  |   |
|  15: return B, aux  |   |
|  16: end function  |   |
|  Algorithm 11 The Prove algorithm for the NIPoPoW protocol, modified for a velvet fork.  |   |
| --- | --- |
|  1: function Prove&#x27;m,k(C, realLink, blockById)  |   |
|  2: size← |C|-(k-1)  |   |
|  3: i← |C[size].interlink|  |   |
|  4: b← C[0] | ▷ Genesis block  |
|  5: Π← ∅  |   |
|  6: for μ = |realLink[C[-k-1]]| down to 0 do  |   |
|  7: π, aux ← constructInnerChain&#x27;  |   |
|  (C[: -k], μ, b, realLink, blockById)  |   |
|  8: if |π| ≥ m then  |   |
|  9: b← π[-m]  |   |
|  10: end if  |   |
|  11: Π← Π ∪ aux  |   |
|  12: end for  |   |
|  13: return Π  |   |
|  14: end function  |   |

Velvet NIPoPoWs preserve security. Additionally, if a constant minority of miners has upgraded their nodes, then succinctness is also preserved as there is only a constant factor penalty as proven in the following theorem.

###### Theorem 5.

Velvet non-interactive proofs-of-proof-of-work on honest chains by honest provers remain succinct as long as a constant percentage $g$ of miners has upgraded, with overwhelming probability.

###### Proof.

From Theorem 10 we know that the proofs $\\pi$ contain only a $O(polylog(m))$ amount of blocks. For each of these blocks, the velvet client needs to include a followUp tail of blocks. Assume a percentage $0&lt;g\\leq 1$ of miners have upgraded with NIPoPoW support. Then the question of whether each block in the honest chain is upgraded follows a Bernoulli distribution. If the velvet proof were to be larger than $\\Delta$ times the soft fork proof in the number of blocks included, then this would require at least one of the followUp tails to include at least $\\Delta$ sequential unupgraded blocks. But since the upgrade status of each block is independent, the probability of this occurring is $g^{\\Delta}$, which is negligible in $\\Delta$. ∎

The reason we were able to upgrade using a velvet fork was because the changes we made were helpful but verifiable by those looking at the chain. We would not have been able to pull off this upgrade without modifications to the consensus layer in the sense that the interlink data structure could not have been maintained somewhere independently of the blockchain: It is critical that the proof-of-work commits to the interlink data structure. Interestingly, the interlink data structure does not need to be part of coinbase and can be produced and included in regular transactions by users (such as OP_RETURN transactions). Thus, the miners can be completely oblivious to it, while users and provers make use of the feature. Interested users regularly create transactions containing the most recent interlink pointers so that they are included in the next block. If the transaction makes it to the next block, it can be used by the prover who keeps track of these. Otherwise, if it becomes part of a subsequent block, in which case some of the pointers it contains are invalid, it can be ignored or only partially used.

The necessary changes needed in the various construction algorithms in order to support a velvet fork are shown in Algorithm 9, Algorithm 10, and Algorithm 11. Algorithm 9 defines the innerChain method, which replaces the upchain/downchain abstraction that can be easily used in a fully upgraded chain.

The following theorem establishes the security of NIPoPoWs in velvet forks.

###### Theorem 5.

Velvet non-interactive proofs-of-proof-of-work on honest chains by honest provers remain succinct as long as a constant percentage $g$ of miners has upgraded, with overwhelming probability.

###### Proof.

From Theorem 10 we know that the proofs $\\pi$ contain only a $O(polylog(m))$ amount of blocks. For each of these blocks, the velvet client needs to include a followUp tail of blocks. Assume a percentage $0&lt;g\\leq 1$ of miners have upgraded with NIPoPoW support. Then the question of whether each block in the honest chain is upgraded follows a Bernoulli distribution. If the velvet proof were to be larger than $\\Delta$ times the soft fork proof in the number of blocks included, then this would require at least one of the followUp tails to include at least $\\Delta$ sequential unupgraded blocks. But since the upgrade status of each block is independent, the probability of this occurring is $g^{\\Delta}$, which is negligible in $\\Delta$. ∎

Supporting clients with different beliefs. The interlink format does not depend on parameters $m,k$. Therefore, it is not necessary to agree on a particular value of these parameters. Instead, the choice of $m$ and $k$ can be a user-configurable parameter to clients. Clients would send a particular $m$ and $k$ as part of their requirement to the prover.

B Superchain Quality Distributions

We now provide proofs that the definitions explored in Section 6 regarding the distributions of superchains are attained.

###### Lemma 2 (Local goodness).

Assume $\\mathcal{C}$ contains only honestly-generated blocks in an optimistic execution. For all levels $\\mu$, for all constant $\\delta&gt;0$, all continuous subchains $\\mathcal{C}^{\\prime}=\\mathcal{C}[i:j]$ with $|\\mathcal{C}^{\\prime}|\\geq m$ are locally good, $\\text{{local-good}}_{\\delta}(\\mathcal{C}^{\\prime},\\mathcal{C},\\mu)$, with overwhelming probability in $m$.

###### Proof.

Observing that for each honestly generated block the probability of being a $\\mu$-superblock for any level $\\mu$ follows an independent Bernoulli distribution, we can apply a Chernoff bound to show that the number of superblocks within a chain will be close to its expectation, which is what is required for local goodness. ∎

###### Lemma 3 (Multilevel quality).

For all $\\mu,0&lt;\\delta\\leq 0.5$, chain $\\mathcal{C}$ containing only honestly-generated blocks in an optimistic execution has $(\\delta,k_{1})$ multilevel quality at level $\\mu$ with overwhelming probability in $k_{1}$.

###### Proof.

Identical. ∎

###### Lemma 4 (Superquality).

For all $\\mu,\\delta&gt;0$, a chain $\\mathcal{C}$ adopted in an optimistic execution has $(\\delta,m)$-superquality at level $\\mu$ with overwhelming probability in $m$.

###### Proof.

Let $\\mathcal{C}^{\\prime}=\\mathcal{C}\\uparrow^{\\mu}$ and let $\\mathcal{C}^{*}=\\mathcal{C}^{\\prime}[-m^{\\prime}:]$ for some $m^{\\prime}\\geq m$. Then let $B\\in\\mathcal{C}^{*}\\downarrow$ and let $X_{B}$ be the random variable equal to $1$ if *level*$(B)\\geq\\mu$ and $0$ otherwise. $\\{X_{B}:B\\in\\mathcal{C}^{*}\\}$ are mutually independent Bernoulli random variables with expectation $E(X_{B})=2^{-\\mu}|\\mathcal{C}^{*}\\downarrow|$. Let $X=\\sum_{B\\in\\mathcal{C}^{*}\\downarrow}X_{B}$. Then $X$ follows a Binomial distribution with parameters $(m^{\\prime},2^{-\\mu})$ and note that $|\\mathcal{C}^{*}|=X$. Then $\\mathbb{E}(|\\mathcal{C}^{*}\\downarrow|)=2^{-\\mu}|\\mathcal{C}^{*}|$. Applying a Chernoff bound on $|\\mathcal{C}^{*}\\downarrow|$ we obtain $\\Pr[|\\mathcal{C}^{*}\\downarrow|\\leq(1-\\delta)2^{-\\mu}|\\mathcal{C}^{*}\\downarrow]\\leq\\exp(-\\delta^{2}2^{-\\mu-1}|\\mathcal{C}^{*}|)$. ∎

###### Lemma 5 (Optimistic superchain distribution).

For any level $\\mu$, and any $0&lt;\\delta&lt;0.5$, a chain $\\mathcal{C}$ containing only honestly-generated blocks adopted by an honest party in an execution with random network scheduling is $(\\delta,m)$-good at level $\\mu$ with overwhelming probability in $m$.

###### Proof.

This is a direct consequence of Lemma 4 and Lemma 3. ∎

## Appendix C Proof of attack on PoPoW

We now calculate the exact probability of success of the attack sketched in Section 7.

The attack is parameterized by parameters $r,\\mu$ which are picked by the adversary. $\\mu$ is the superblock level at which the adversary will produce a proof longer than the honest proof. The modified attack works as follows: Without loss of generality, fix block $b$ to be Genesis. The adversary always mines on the secret chain which forks off from genesis, unless a *superblock generation event* occurs. If a superblock generation event occurs, then the adversary pauses mining on the secret chain and attempts a *block suppression attack* on the honest chain. The adversary devotes exactly $r$ rounds to this suppression attack; then resumes mining on the secret chain. We show that, despite this simplification (of fixing $r$)

which is harmful to the adversary, the probability of a successful attack is non-negligible for certain values of the protocol parameters .

The adversary monitors the network for superblocks. Whenever an honest party diffuses an honestly-generated $\\mu$-superblock, at the end of a given round $r_{1}$, the adversary starts devoting their mining power to block suppression starting from the next round.

The block suppression attack works as follows. Let $b$ be the honestly generated $\\mu$-superblock which was diffused at the end of the previous round. If the round was not uniquely successful, let $b$ be any of the diffused honestly-generated $\\mu$-superblocks. Let $b$ be the tip of an honest chain $\\mathcal{C}_{B}$. The adversary first mines on top of $\\mathcal{C}_{B}[-2]$. If she is successful in mining a block $b^{\\prime}$, she continues extending the chain ending at $b^{\\prime}$ (to mine $b^{\\prime\\prime}$ and so on). The value $r$ is fixed, so the adversary devotes exactly $r$ rounds to this whole process; the adversary will keep mining on top of $\\mathcal{C}_{B}[-2]$ (or one of the adversarially-generated extensions of it) for exactly $r$ rounds, regardless of whether $b^{\\prime}$ or $b^{\\prime\\prime}$ have been found. At the same time, the honest parties will be mining on top of $b$ (or a competing block in the case of a non-uniquely successful round). Again, further successful block diffusion by the honest parties shall not affect that the adversary is going to spend exactly $r$ rounds for suppression. This attack will succeed with overwhelming probability for the right choice of protocol values.

###### Theorem 6 (Double-spending attack).

There exist parameters $p,n,t,q,\\mu,\\delta$, with $t\\leq(1-\\delta)(n-t)$, and a double spending attack against KLS PoPoW that succeeds with overwhelming probability.

###### Proof.

Recall that in the backbone notation $n$ denotes the total number of parties, $t$ denotes the number of adversarial parties, $q$ denotes the number of the random oracle queries allowed per party per round and $p$ is the probability that one random oracle query will be successful and remember that $p=T/2^{\\kappa}$ where $T$ is the mining target and $\\kappa$ is the security parameter (or hash function bit count). Then $f$ denotes the probability that a given round is successful and we have that $f=1-(1-p)^{q(n-t)}$. Recall further that a requirement of the backbone protocol is that the honest majority assumption is satisfied, that is that $t\\leq(1-\\delta)(n-t)$ were $\\delta\\geq 2f+3\\epsilon$, where $\\epsilon\\in(0,1)$ is an arbitrary small constant describing the quality of the concentration of the random variables.

Denote $\\alpha_{\\mathcal{A}}$ the secret chain generated by the adversary and $\\alpha_{B}$ the honest chain belonging to any honest party. We will show that for certain protocol values we have that $\\Pr[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|\\geq|\\alpha_{B}\\uparrow^{\\mu}|]$ is overwhelming.

Assume that, to the adversary’s harm and to simplify the analysis, the adversary plays at beginning of every round and does not perform adversarial scheduling. At the beginning of the round when it is the adversary’s turn to play, she has access to the blocks diffused during the previous round by the honest parties.

First, observe that at the beginning of each round, the adversary finds herself in one of two different situations: Either she has been forced into an $r$-round-long period of suppression, or she is not in that period. If she is within that period, she blindly performs the suppression attack without regard for the state of the world. If she is not within that period, then she must initially observe the blocks diffused at the end of the previous round by the honest parties. Call these rounds during which the diffused data must be examined by the adversary *decision rounds*. Let there be $\\omega$ decision rounds in total. In each such decision round, it is possible that the adversary discovers a diffused $\\mu$-superblock and therefore decides that a suppression attack must be performed starting with the current round. Call these rounds during which this discovery is made by the adversary *migration

![img-6.jpeg](img-6.jpeg)
Fig. 7. The double spending attack. The top chain fork is wholly adversarially mined, while the bottom is honestly adopted. Gray blocks are adversarially mined 0-blocks. Black blocks are  $\\mu$ -superblocks.

rounds. Let there be  $y$  migration rounds in total. The adversary devotes the migration round to performing the suppression attack as well as  $r - 1$  non-migration rounds after the migration round. Call these rounds, including the migration round, suppression rounds. In the rest of the decision rounds, the adversary will not find any  $\\mu$ -superblocks diffused. Call these secret chain rounds; these are rounds where the adversary devotes her queries to mining on the secret chain. Let there be  $x$  secret chain rounds. If the adversary devotes  $\\omega$  decision rounds to the attack in total, then clearly we have that  $\\omega = x + y$ . If the total number of rounds during which the attack is running is  $s$  then we also have that  $s = x + ry$ , because for each migration round there are  $r - 1$  non-decision rounds that follow.

We will analyze the honest and adversarial superchain lengths with respect to  $\\omega$ , which roughly corresponds to time (because note that  $\\omega \\geq s / r$ , and so  $\\omega$  is proportional to the number of rounds). Let us calculate the probability  $p_{SB}$  (&quot;superblock probability&quot;) that a decision round ends up being a migration round. Ignoring the negligible event that there will be random oracle collisions, we have that  $p_{SB} = (n - t)qp2^{-\\mu}$ .

Given this, note that the decision taken at the beginning of each decision round follows independent Bernoulli distributions with probability  $p_{SB}$ . Denote  $z_{i}$  the indicator random variable indicating whether the decision round was a migration round. Therefore we can readily calculate the expectations for the random variables  $x$  and  $y$ , as  $x = \\omega - y$ ,  $y = \\sum_{i=1}^{\\omega} z_{i}$ . We have  $E[x] = (1 - p_{SB})\\omega$  and  $E[y] = p_{SB}\\omega$ . Applying a Chernoff bound to the random variables  $x$  and  $y$ , we observe that they will attain values close to their mean for large  $\\omega$  and in particular  $\\operatorname{Pr}[y \\geq (1 + \\delta)E[y]] \\leq \\exp(-\\frac{\\delta^{2}}{3}E[y])$  and similarly  $\\operatorname{Pr}[x \\leq (1 - \\delta)E[x]] \\leq \\exp(-\\frac{\\delta^{2}}{2}E[x])$ , which are negligible in  $\\omega$ .

Given that there will be  $x$  secret chain rounds, we observe that the random variable indicating the length of the secret adversarial superchain follows the binomial distribution with  $xtq$  repetitions and probability  $p2^{-\\mu}$ . We can now calculate the expected secret chain length as  $E[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|] = xtqp2^{-\\mu}$ . Observe that in this probability we have given the adversary the intelligence to continue using her random oracle queries during a round even after a block has been found during a round and not to wait for the next round. Applying a Chernoff bound, we obtain that  $\\operatorname*{Pr}[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}| \\leq (1 - \\delta)E[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|]] \\leq \\exp(-\\frac{\\delta^{2}}{2}E[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|])$ , which is negligible in  $\\omega$  (because we know that with overwhelming probability  $x &amp;gt; (1 - \\delta)(1 - p_{SB})\\omega$ ).

It remains to calculate the behavior of the honest superchain. Suppose that a migration round occurs during which at least one superblock  $B$  is diffused. We will now calculate the probability  $p_{sup}$  that the adversary is able to suppress that block after  $r$  rounds by performing the suppression attack and cause all honest parties to adopt a chain not containing  $B$ .

One way for this to occur is if the adversary has generated exactly 2 shallow blocks (blocks which are not  $\\mu$ -superblocks) after exactly  $r$  rounds and the honest parties having generated exactly 0 blocks after exactly  $r$  rounds. This provides a lower bound for the probability, which is sufficient for our purposes. Call ADV-WIN the event where the adversary has generated exactly 2 shallow blocks after exactly  $r$  rounds since the diffusion

of $B$ and call HON-LOSE the event where the honest parties have generated exactly 0 blocks after exactly $r$ rounds since the diffusion of $B$.

The number of blocks generated by the adversary after the diffusion of $B$ follows the binomial distribution with $r$ repetitions and probability $p_{LB}$, where $p_{LB}$ denotes the probability that the adversary is able to produce a shallow block (“low block probability”) during a single round. We have that $p_{LB}=tqp(1-2^{-\\mu})$. To evaluate $\\Pr[\\text{ADV-WIN}]$, we evaluate the binomial distribution for 2 successes to obtain $\\Pr[\\text{ADV-WIN}]=\\frac{r(r-1)}{2}p_{LB}^{2}(1-p_{LB})^{r-2}$. The number of blocks generated by the honest parties after the diffusion of $B$ follows the binomial distribution with $r$ repetitions and probability $f$. To evaluate $\\Pr[\\text{HON-LOSE}]$, we evaluate the binomial distribution for 0 successes to obtain $\\Pr[\\text{HON-LOSE}]=(1-f)^{r}$. Note that this is an upper bound in the probability, in particular because there can be multiple blocks during a non-uniquely successful round during which a $\\mu$-superblock was generated.

Then observe that the two events ADV-WIN and HON-LOSE are independent and therefore $p_{sup}=\\Pr[\\text{ADV-WIN}]\\Pr[\\text{HON-LOSE}]=\\frac{r(r-1)}{2}p_{LB}^{2}(1-p_{LB})^{r-2}(1-f)^{r}$.

Now that we have evaluated $p_{sup}$, we will calculate the honest chain length in two chunks: The superblocks generated and adopted by the honest parties during secret chain rounds, $\\mathcal{C}_{1}$, and the superblocks generated and adopted by the honest parties during suppression rounds, $\\mathcal{C}_{2}$ (and note that these sets of blocks are not blockchains on their own).

$|\\mathcal{C}_{1}|$ is a random variable following the binomial distribution with $s(n-t)q$ repetitions and probability $p2^{-\\mu}(1-p_{sup})$. In the evaluation of this distribution, we give the honest parties the liberty to belong to a mining pool and share mining information within a round, an assumption which only makes matters for the adversary worse. We can now calculate the expected length of $\\mathcal{C}_{1}$ to find $E[|\\mathcal{C}_{1}|]=s(n-t)qp2^{-\\mu}(1-p_{sup})$. Applying a Chernoff bound, we find that $\\Pr[|\\mathcal{C}_{1}|\\geq(1+\\delta)E[|\\mathcal{C}_{1}|]]\\leq exp(-\\frac{\\delta^{2}}{3}E[|\\mathcal{C}_{1}|])$, which is negligible in $s$.

Finally, some additional $\\mu$-superblocks could have been generated by the honest parties while the adversary is spending $r$ rounds attempting to suppress a previous $\\mu$-superblock. These $\\mu$-superblocks will be adopted in the case the adversary fails to suppress the previous $\\mu$-superblock. As the adversary does not devote any decision rounds to these new $\\mu$-superblocks, they will never be suppressed if the previous $\\mu$-superblock is not suppressed. We collect these in the set $\\mathcal{C}_{2}$. To calculate $|\\mathcal{C}_{2}|$, observe that the number of unsuppressed $\\mu$-superblocks which caused an adversarial suppression period is $|\\mathcal{C}_{1}|$. For each of these blocks, the honest parties spend $r$ rounds attempting to form further $\\mu$-superblocks on top. The total number of such attemps is $r|\\mathcal{C}_{1}|$. Therefore, the number of further honestly generated $\\mu$-superblocks attained during the $|\\mathcal{C}_{1}|$ different $r$-round periods follows a binomial distribution with $|\\mathcal{C}_{1}|rq(n-t)$ repetitions and probability $p2^{-\\mu}$. Here we allow the honest parties to use repeated queries within a round even after a shallow success and to work in a pool to obtain an upper bound for the expectation. Therefore $E[|\\mathcal{C}_{2}|]=|\\mathcal{C}_{1}|rq(n-t)p2^{-\\mu}$ and applying a Chernoff bound we obtain that $\\Pr[|\\mathcal{C}_{2}|\\geq(1+\\delta)E[|\\mathcal{C}_{2}|]]\\leq exp(-\\frac{\\delta}{3}E[|\\mathcal{C}_{2}|])$, which is negligible in $s$ and has a quadratic error term. We deduce that $|\\mathcal{C}_{2}|$ will have a very small length compared to the rest of the honest chain, as it is a vanishing term in $\\mu$.

Concluding the calculation of the adversarial superchain, we get $E[|\\alpha_{B}\\uparrow^{\\mu}|]=E[|\\mathcal{C}_{1}|]+E[|\\mathcal{C}_{2}|]$.

Finally, it remains to show that there exist values $p,n,t,q,r,\\mu,\\delta$ such that a $E[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|]\\geq(1+\\delta)E[|\\alpha_{B}\\uparrow^{\\mu}|]$. Using the values $p=10^{-5},q=1,n=1000,t=489,\\mu=25,r=200$, we observe that the honest majority assumption is preserved. Replacing these values into the expectations formulae above, we obtain $E[|\\alpha_{\\mathcal{A}}\\uparrow^{\\mu}|]\\approx 1.457*10^{-10}*\\omega$ and $E[|\\alpha_{B}\\uparrow^{\\mu}|]\\approx 1.424*10^{-10}*\\omega$, which result to a constant gap $\\delta$. Because the adversarial chain grows linearly in $\\omega$, the adversary only has to wait sufficient rounds for obtaining $m$ blocks to

create a valid proof. Therefore, for these values, the adversary will be able to generate a convincing PoPoW at some level $\\mu$ which is longer than the honest parties’ proof, even when the adversary does not have a longer underlying blockchain. ∎

###### Remark.

It is worth isolating the mistake in the security proof from the interactive construction paper *[15]*. Suppose player $B$ is honest and player $\\mathcal{A}$ is adversarial and suppose $b$, the LCA block, was honestly generated and suppose that the superchain comparison happens at level $\\mu$. Their security proof then correctly argues that there will have been more honestly- than adversarially-generated $\\mu$-superblocks after block $b$. Nevertheless, we observe that the mere fact that there have been more honestly- than adversarially-generated $\\mu$-superblocks after $b$ does not imply that $|\\overline{\\pi}_{\\mathcal{A}}\\uparrow^{\\mu}\\ \\{b:\\}|\\leq|\\overline{\\pi}_{B}\\uparrow^{\\mu}\\ \\{b:\\}|$. The reason is that some of these superblocks could belong to blocktree forks that have been abandoned by $B$. Thus, the security conclusion does not follow. Regardless, their basic argument and construction is what we will use as a basis for constructing a system that is both provably secure and succinct under the same assumptions, albeit requiring a more complicated construction structure to obtain security.

## Appendix D Formal security treatment

Here, we give a formal treatment of the security proof which was sketched in Section 8.

Assume $t$ adversarial and $n$ total parties, each with $q$ PoW random oracle queries per round. We will call a query to the RO $\\mu$-successful if the RO returns a value $h$ such that $h\\leq 2^{-\\mu}T$.

We define boolean random variables $X^{\\mu}_{r}$, $Y^{\\mu}_{r}$ and $Z^{\\mu}_{r}$. Fix some round $r$, query index $j$ and adversarial party index $k$ (out of $t$). If at round $i$ an honest party obtains a PoW with $id&lt;2^{-\\mu}T$, set $X^{\\mu}_{r}=1$, otherwise $X^{\\mu}_{r}=0$. If at round $r$ exactly one honest party obtains a PoW with $id&lt;2^{-\\mu}T$, set $Y^{\\mu}_{r}=1$, otherwise $Y^{\\mu}_{r}=0$. If at round $r$ the $j$-th query of the $k$-th corrupted party is $\\mu$-successful, set $Z^{\\mu}_{ijk}=1$, otherwise $Z^{\\mu}_{ijk}=0$. Let $Z^{\\mu}_{r}=\\sum_{k=1}^{t}\\sum_{j=1}^{q}Z^{\\mu}_{ijk}$. For a set of rounds $S$, let $X^{\\mu}(S)=\\sum_{r\\in S}X_{r}$ and similarly define $Y^{\\mu}(S),Z^{\\mu}(S)$.

###### Definition 11 (Typical execution).

An execution of the protocol is $(\\epsilon,\\eta)$-typical if:

Block counts don’t deviate. For all $\\mu\\geq 0$ and any set $S$ of consecutive rounds with $|S|\\geq 2^{\\mu}\\eta\\kappa$, we have:

- $(1-\\epsilon)E[X^{\\mu}(S)]&lt;X^{\\mu}(S)&lt;(1+\\epsilon)E[X^{\\mu}(S)]$ and $(1-\\epsilon)E[Y^{\\mu}(S)]&lt;Y^{\\mu}(s)$.
- $Z^{\\mu}(S)&lt;(1+\\epsilon)E[Z^{\\mu}(S)]$.

Round count doesn’t deviate. Let $S$ be a set of consecutive rounds such that $Z^{\\mu}(S)\\geq k$ for some security parameter $k$. Then $|S|\\geq(1-\\epsilon)2^{\\mu}\\frac{k}{pqt}$ with overwhelming probability in $k$.

Chain regularity. No insertions, no copies, and no predictions *[12]* have occurred.

###### Theorem 7 (Typicality).

Executions are $(\\epsilon,\\eta)$-typical with overwhelming probability in $\\kappa$.

###### Proof.

Block counts and regularity. For the blocks count and regularity, we refer the reader to *[12]* for the full proof.

Round count. First, observe that $Z^{\\mu}_{ijk}\\sim\\mathsf{Bern}(2^{-\\mu}p)$ and these are jointly independent. Therefore $Z^{\\mu}_{S}\\sim\\mathsf{Bin}(tq|S|,2^{-\\mu}p)$ and $|S|\\sim\\mathsf{NB}(Z_{S},2^{-\\mu}p)$. So $\\mathbb{E}(|S|)=2^{\\mu}\\frac{Z_{S}}{pqt}$. Applying a tail bound to the negative binomial distribution, we obtain that $\\Pr[|S|&lt;(1-\\epsilon)\\mathbb{E}(|S|)]\\in\\Omega(\\epsilon^{2}m)$. ∎

The following lemma is at the heart of the security proof that will follow.

**Lemma 6.** Suppose $S$ is a set of consecutive rounds $r_1 \\ldots r_2$ and $\\mathcal{C}_B$ is a chain adopted by an honest party at round $r_2$ of a typical execution. Let $\\mathcal{C}_B^S = \\{b \\in \\mathcal{C}_B : b \\text{ was generated during } S\\}$. Let $\\mu_{\\mathcal{A}}, \\mu_B \\in \\mathbb{N}$. Suppose $\\mathcal{C}_B^S \\uparrow^{\\mu_B}$ is good. Suppose $\\mathcal{C}_{\\mathcal{A}}&#x27;$ is a $\\mu_{\\mathcal{A}}$-superchain containing only adversarially generated blocks generated during $S$ and suppose that $|\\mathcal{C}_{\\mathcal{A}}&#x27;| \\geq k$. Then $2^{\\mu_{\\mathcal{A}}} |\\mathcal{C}_{\\mathcal{A}}&#x27;| &amp;lt; \\frac{1}{3} 2^{\\mu_B} |\\mathcal{C}_B^S \\uparrow^{\\mu_B}|$.

**Proof.** From $|\\mathcal{C}_{\\mathcal{A}}^{\\prime}| \\geq k$ we know that $Z_{S} \\geq k$. Applying Theorem 7, we conclude that $|S| \\geq (1 - \\epsilon&#x27;) 2^{\\mu_{\\mathcal{A}}} \\frac{1}{pq!} |\\mathcal{C}_{\\mathcal{A}}^{\\prime}|$. Applying the chain growth theorem [12] we obtain that $|\\mathcal{C}_B^S| \\geq (1 - \\epsilon) f|S|$. But from the goodness of $\\mathcal{C}_B^S \\uparrow^{\\mu_B}$, we know that $|\\mathcal{C}_B^S \\uparrow^{\\mu_B}| \\geq (1 - \\delta) 2^{-\\mu_B} |\\mathcal{C}_B^S|$. Therefore $|\\mathcal{C}_B^S \\uparrow^{\\mu_B}| \\geq 2^{-\\mu_B} (1 - \\delta) (1 - \\epsilon) f(1 - \\epsilon&#x27;) 2^{\\mu_{\\mathcal{A}}} \\frac{1}{pq!} |\\mathcal{C}_{\\mathcal{A}}^{\\prime}|$ and so $2^{\\mu_{\\mathcal{A}}} |\\mathcal{C}_{\\mathcal{A}}^{\\prime}| &amp;lt; \\frac{pq!}{(1 - \\delta)(1 - \\epsilon&#x27;)(1 - \\epsilon) f} 2^{\\mu_B} |\\mathcal{C}_B^S \\uparrow^{\\mu_B}|$. $\\square$

**Definition 12 (Adequate level of honest proof).** Let $\\pi$ be an honestly generated proof constructed upon some adopted chain $\\mathcal{C}$ and let $b \\in \\pi$.

Then $\\mu&#x27;$ is defined as $\\mu&#x27; = \\max\\{\\mu : |\\pi\\{b:\\} \\uparrow^{\\mu}| \\geq \\max(m + 1, (1 - \\delta)2^{-\\mu}|\\pi\\{b:\\} \\uparrow^{\\mu_4}|)\\}$. We call $\\mu&#x27;$ the adequate level of proof $\\pi$ with respect to block $b$ with security parameters $\\delta$ and $m$. Note that the adequate level of a proof is a function of both the proof $\\pi$ and the chosen block $b$.

**Lemma 7.** Let $\\pi$ be some honest proof generated with security parameters $\\delta, m$. Let $\\mathcal{C}$ be the underlying chain, $b \\in \\mathcal{C}$ be any block and $\\mu&#x27;$ be the adequate level of the proof with respect to $b$ and the same security parameters.

Then $\\mathcal{C}\\{b:\\} \\uparrow^{\\mu&#x27;} = \\pi \\{b:\\} \\uparrow^{\\mu&#x27;}$.

**Proof.** $\\pi \\{b:\\} \\uparrow^{\\mu&#x27;} \\subseteq \\mathcal{C}\\{b:\\} \\uparrow^{\\mu&#x27;}$ is trivial. For the converse, we show that for all $\\mu^{*} &amp;gt; \\mu&#x27;$, we have that in the iteration of the Prove for loop with $\\mu = \\mu^{*}$, the block stored in variable $B$ precedes $b$ in $\\mathcal{C}$.

Suppose $\\mu = \\mu^{*}$ is the first for iteration during which the property is violated. This cannot be the first iteration, as there $B = \\mathcal{C}[0]$ and Genesis precedes all blocks. By induction hypothesis we see that during the iteration $\\mu = \\mu^{*} + 1$, $B$ preceded $b$. From the definition of $\\mu&#x27;$ we know that $\\mu&#x27;$ is the highest level for which $|\\pi\\{b:\\} \\uparrow^{\\mu&#x27;} [1:]| \\geq \\max(m, (1 - \\delta)2^{-\\mu&#x27;} |\\pi\\{b:\\} \\uparrow^{\\mu&#x27;} [1:]\\downarrow|)$.

Hence, this property cannot hold for $\\mu^{*} &amp;gt; \\mu^{\\prime}$ and therefore $|\\pi_B\\{b:\\} \\uparrow^{\\mu_B^*} [1:]| &amp;lt; m$ or $\\neg \\text{local-good}_{\\delta}(\\pi \\{b:\\} \\uparrow \\mu^{*} [1:], \\mathcal{C}, \\mu^{*})$.

In case local-good is violated, variable $B$ remains unmodified and the induction step holds. If local-good is not violated, then $|\\pi \\{b:\\} \\uparrow^{\\mu^{*}} [1:]| &amp;lt; m$ and so $\\pi \\uparrow^{\\mu^{*}} [-m]$ precedes $b$. $\\square$

**Lemma 8.** Suppose the verifier evaluates $\\pi_{\\mathcal{A}} \\geq \\pi_B$ in a protocol interaction where $B$ is honest and assume during the comparison that the compared level of the honest party is $\\mu_B$. Let $b = LCA(\\pi_{\\mathcal{A}}, \\pi_B)$ and let $\\mu_B&#x27;$ be the adequate level of $\\pi_B$ with respect to $b$. Then $\\mu_B&#x27; \\geq \\mu_B$.

**Proof.** Because $\\mu_B$ is the compared level of the honest party we have $2^{\\mu_B}|\\mathcal{C}\\{b:\\} \\uparrow^{\\mu_B}| &amp;gt; 2^{\\mu_B}|\\mathcal{C}\\{b:\\}|$. The proof is by contradiction. Suppose $\\mu_B&#x27; &amp;lt; \\mu_B$. By definition, $\\mu_B&#x27;$ is the maximum level such that $|\\pi_B\\{b:\\} \\uparrow^{\\mu}[1:]| \\geq \\max(m, (1 - \\delta)2^{-\\mu}|\\pi_B\\{b:\\} \\uparrow^{\\mu}[1:]\\downarrow|)$, therefore $\\mu_B$ does not satisfy this condition. But we know that $|\\pi_B\\{b:\\} \\uparrow^{\\mu_B}[1:]| \\geq m$ because $\\mu_B$ was selected by the Verifier. Therefore $2^{\\mu_B}|\\mathcal{C}_B\\{b:\\} \\uparrow^{\\mu_B}| &amp;lt; (1 - \\delta)|\\mathcal{C}\\{b:\\}|$. But $\\mu_B&#x27;$ satisfies goodness, so $2^{\\mu_B&#x27;}|\\mathcal{C}_B\\{b:\\} \\uparrow^{\\mu_B&#x27;} &amp;gt; (1 - \\delta)|\\mathcal{C}\\{b:\\}|$. From the last two equations, we obtain $(1 - \\delta)|\\mathcal{C}\\{b:\\}| &amp;gt; 2^{\\mu_B&#x27;}|\\mathcal{C}\\{b:\\} \\uparrow^{\\mu_B&#x27;}|$, which contradicts the previous equation. $\\square$

34

Theorem 1 (Security). Assuming honest majority, the non-interactive proofs-of-proof-of-work construction for computable $k$-stable monotonic suffix-sensitive predicates is secure with overwhelming probability in $\\kappa$.

Proof. By contradiction. Let $m = k_{1} + k_{2} + k_{3}$ and let $k_{1}, k_{2}, k_{3}$ be polynomial functions of $\\kappa$. Let $Q$ be a $k$-stable monotonic suffix-sensitive chain predicate. Assume NIPoPoWs on $Q$ is insecure. Then, during an execution at some round $r_{3}$, $Q(\\mathcal{C})$ is defined and the verifier $V$ disagrees with some honest participant. Assume the execution is typical. $V$ communicates with adversary $\\mathcal{A}$ and honest prover $B$. The verifier receives proofs $\\pi_{\\mathcal{A}}, \\pi_{B}$. Because $B$ is honest, $\\pi_{B}$ is a proof constructed based on underlying blockchain $\\mathcal{C}_{B}$ (with $\\pi_{B} \\subseteq \\mathcal{C}_{B}$) which $B$ has adopted during round $r_{3}$ at which $\\pi_{B}$ was generated. Furthermore, $\\pi_{\\mathcal{A}}$ was generated at round $r_{3}&#x27; \\leq r_{3}$.

The verifier outputs $\\neg Q(\\mathcal{C}_B)$, and so $\\mathsf{Verify}_{m,k}^{Q} = \\neg Q(\\mathcal{C}_B)$. Thus it is necessary that $\\pi_{\\mathcal{A}} \\geq \\pi_B$, otherwise, because $Q$ is suffix sensitive, $\\mathsf{Verify}^Q$ would have returned $Q(\\mathcal{C}_B)$. We now show that $\\pi_{\\mathcal{A}} \\geq \\pi_B$ is a negligible event.

Let $b = \\mathsf{LCA}(\\pi_{\\mathcal{A}}, \\pi_B)$ and let $b^*$ be the most recent honestly generated block in $\\mathcal{C}_B$ preceding $b$ (and note that $b^*$ necessarily exists because Genesis is honestly generated). Let the levels of comparison decided by the verifier be $\\mu_{\\mathcal{A}}$ and $\\mu_B$ respectively. Let $\\mu_B&#x27;$ be the adequate level of proof $\\pi_B$ with respect to block $b$. Call $\\alpha_{\\mathcal{A}} = \\pi_{\\mathcal{A}} \\uparrow^{\\mu_{\\mathcal{A}}} \\{b : \\}$ , $\\alpha_B&#x27; = \\pi_B \\uparrow^{\\mu_B&#x27;} \\{b : \\}$.

We now show three successive claims: First, $\\alpha_{\\mathcal{A}}$ and $\\alpha_B&#x27; \\downarrow$ are mostly disjoint. Second, $\\alpha_{\\mathcal{A}}$ contains mostly adversarially-generated blocks. And third, the adversary is able to produce this $\\alpha_{\\mathcal{A}}$ with negligible probability.

Claim 1a: If $\\mu_B&#x27; \\leq \\mu_{\\mathcal{A}}$ then $\\alpha_{\\mathcal{A}}[1:]$ and $\\alpha_B[1:] \\downarrow$ are completely disjoint.

Applying Lemma 7 to $\\mathcal{C}_B\\{b:\\} \\uparrow^{\\mu_B&#x27;}$ we see that $\\mathcal{C}_B\\{b:\\} \\uparrow^{\\mu_B&#x27;} = \\pi_B\\uparrow^{\\mu_B&#x27;}\\{b:\\}$ and so $\\pi_B\\uparrow^{\\mu_B&#x27;}\\{b:\\}[1:]\\cap \\pi_{\\mathcal{A}}\\uparrow^{\\mu_{\\mathcal{A}}}\\{b:\\}[1:] = \\emptyset$.

Claim 1b: If $\\mu_{\\mathcal{A}} &amp;lt; \\mu_B&#x27;$ then $|\\alpha_{\\mathcal{A}}[1:]\\cap \\alpha_B\\downarrow [1:]|\\leq 2^{\\mu_B&#x27; - \\mu_{\\mathcal{A}}}k_1$.

First, observe that, because the adversary is winning, therefore $|\\alpha_{\\mathcal{A}}| &amp;gt; 2^{\\mu_B&#x27; - \\mu_{\\mathcal{A}}}m$. Suppose for contradiction that $|\\alpha_{\\mathcal{A}}[1:]\\cap \\alpha_B\\downarrow [1:]| &amp;gt; 2^{\\mu_B&#x27; - \\mu_{\\mathcal{A}}}k_1$. This means there are indices $1\\leq i &amp;lt; j$ such that $|\\mathcal{C}_B\\uparrow^{\\mu_{\\mathcal{A}}}[i:j]| &amp;gt; 2^{\\mu_B&#x27; - \\mu_{\\mathcal{A}}}k_1$ but $|\\mathcal{C}_B\\uparrow^{\\mu_{\\mathcal{A}}}[i:j]\\downarrow \\uparrow^{\\mu_B&#x27;}| = 0$. But this contradicts the goodness of $\\mathcal{C}_B\\uparrow^{\\mu_B&#x27;}$. Therefore there are more than $2^{\\mu_B&#x27; - \\mu_{\\mathcal{A}}}(k_2 + k_3)$ blocks in $\\alpha_{\\mathcal{A}}$ that are not in $\\alpha_B$, and clearly also more than $k_2 + k_3$ blocks.

From Claim 1a and Claim 1b, we conclude that there are at least $k_{2} + k_{3}$ blocks after block $b$ in $\\alpha_{\\mathcal{A}}$ which do not exist in $\\alpha_{B}$. We now set $b_{2} = \\mathsf{LCA}(\\mathcal{C}_{B},\\alpha_{\\mathcal{A}})$.

Claim 2: At least $k_{3}$ superblocks of $\\alpha_{\\mathcal{A}}$ are adversarially generated.

We show this by showing that $\\alpha_{\\mathcal{A}}[k_2 + 1:]$ contains no honestly mined blocks. By contradiction, assume that the block $\\alpha_{\\mathcal{A}}[i]$ for some $i \\geq k_1 + k_2 + 1$ was honestly generated. This means that an honest party had adopted the chain $\\alpha_{\\mathcal{A}}[i - 1]$ at some round $r_2 \\leq r_3$. Because of the way the honest parties adopt chains, the superchain $\\alpha_{\\mathcal{A}}[: i - 1]$ has an underlying properly constructed 0-level anchored chain $\\mathcal{C}_{\\mathcal{A}}$ such that $\\mathcal{C}_{\\mathcal{A}} \\subseteq \\alpha_{\\mathcal{A}}[: i - 1]$. Let $j$ be the index of block $b_2$ within $\\mathcal{C}_{\\mathcal{A}}$. As $\\alpha_{\\mathcal{A}} \\subseteq \\mathcal{C}_{\\mathcal{A}}$, observe that $|\\mathcal{C}_{\\mathcal{A}}[j + 1:]| &amp;gt; i - 1 \\geq k_2 + k_1$. Therefore $\\mathcal{C}_{\\mathcal{A}}[: -(k_2 + k_1)] \\not\\preccurlyeq \\mathcal{C}_B$. But $\\mathcal{C}_{\\mathcal{A}}$ was adopted by an honest party at round $r_2$ which is prior to round $r_3$ during which $\\mathcal{C}_B$ was adopted by an honest party. This contradicts the Common Prefix [12] property with parameter $k_2$. It follows that with overwhelming probability in $k_2$, the $k_3 = m - k_2 - k_1$ last blocks of the adversarial proof have been adversarially mined.

Claim 3: $\\mathcal{A}$ is able to produce a $\\alpha_{\\mathcal{A}}$ that wins against $\\alpha_{B}$ with negligible probability.

Let $b&#x27;$ be the latest honestly generated block in $\\alpha_{\\mathcal{A}}$, or $b^*$ if no such block exists in $\\alpha_{\\mathcal{A}}$. Let $r_1$ be the round when $b^*$ was generated. Let $j$ be the index of $b^*$. Consider the set $S$ of consecutive rounds $r_1 \\ldots r_3$. Every block in $\\alpha_{\\mathcal{A}}[-k_3]$ has been adversarially generated

35

![img-7.jpeg](img-7.jpeg)
Fig. 8. Two competing proofs at different levels.

during  $S$  and  $|\\alpha_{\\mathcal{A}}[-k_3:]| = k_3$ .  $\\mathcal{C}_B$  is a chain adopted by an honest party at round  $r_3$  and filtering the blocks by the rounds during which they were generated to obtain  $\\mathcal{C}_B^S$ , we see that  $\\mathcal{C}_B^S = \\mathcal{C}_B\\{b^*:\\}$ . But chain  $\\mathcal{C}_B^S \\uparrow^{\\mu_B&#x27;}$  is good with respect to  $\\mathcal{C}_B^S$ . Applying Lemma 6, we obtain that with overwhelming probability  $2^{\\mu_{\\mathcal{A}}} |\\alpha_{\\mathcal{A}}\\{b&#x27;:\\}| &amp;lt; \\frac{1}{3} 2^{\\mu_B&#x27;} |\\mathcal{C}_B^S \\uparrow \\mu_B&#x27;$ .

But  $|\\alpha_{B}| \\geq |\\mathcal{C}_{B}^{S} \\uparrow \\mu_{B}^{\\prime}|$  and  $|\\alpha_{\\mathcal{A}}\\{b^{\\prime}:\\}| \\geq |\\alpha_{\\mathcal{A}}| - k_{2}$ , therefore  $2^{\\mu_{\\mathcal{A}}}|\\alpha_{\\mathcal{A}}| - k_{2} &amp;lt; \\frac{1}{3} 2^{\\mu_{B}^{\\prime}}|\\alpha_{B}|$ . But  $|\\alpha_{\\mathcal{A}}| - k_{2} \\geq k_{3}$ , therefore  $\\frac{1}{3} 2^{\\mu_{B}^{\\prime}}|\\alpha_{B}| &amp;gt; k_{3}$  and so  $2^{\\mu_{B}^{\\prime}}|\\alpha_{B}| &amp;gt; 3k_{3}$ . Taking  $k_{2} = k_{3}$ , we obtain  $2^{\\mu_{\\mathcal{A}}}|\\alpha_{\\mathcal{A}}| &amp;lt; \\frac{1}{3} 3k_{3} + k_{3} = 2k_{3} &amp;lt; 2^{\\mu_{B}^{\\prime}}|\\alpha_{B}|$ . But this contradicts the fact that  $\\pi_{\\mathcal{A}} \\geq \\pi_{A}$  and so the claim is proven.

Therefore we have proven that  $2^{\\mu_B&#x27;}|\\pi_B \\uparrow^{\\mu_B&#x27;}| &amp;gt; 2^{\\mu_A}|\\pi_A^{\\mu_A}|$ . From the definition of  $\\mu_B$ , we know that  $2^{\\mu_B}|\\pi_B \\uparrow^{\\mu_B}| \\geq 2^{\\mu_B&#x27;}|\\pi_B \\uparrow^{\\mu_B&#x27;}|$ , and therefore we conclude that  $2^{\\mu_B}|\\pi_B \\uparrow^{\\mu_B}| &amp;gt; 2^{\\mu_A}|\\pi_A \\uparrow^{\\mu_A}|$ .

Remark 1 (Variance attacks). The critical issue addressed by this security proof is to avoid Bahack-style attack [3] where the adversary constructs &quot;lucky&quot; high-difficulty superblocks without filling in the underlying proof-of-work in the lower levels. Observe that, while setting  $m = 1$  &quot;preserves&quot; the proof-of-work in the sense that expectations remain the same, the probability of an adversarial attack becomes approximately proportional to the adversary power if the adversary follows a suitable strategy (for a description of such a strategy, see the parameterization section). With higher values of  $m$ , the probability of an adversarial attack drops exponentially in  $m$ , even though they maintain constant computational power, and hence satisfy a strong notion of security.

Remark. Intuitively, the attack of Section 7 is neutralized, because our prover takes “goodness” of blockchains into account and the verifier does not compare proofs strictly at the same level.

Remark. We have explored security in the *synchronous* model. We remark that the same construction can work in a *partially synchronous* model by setting $k^{\\prime}=2k$, where $k^{\\prime}$ is the security parameter of the partially synchronous model and $k$ is the security parameter in the synchronous model. We leave the full treatment of this for future work.

### D.1 Infix security

We observe that now that we have proven the modified suffix construction secure, the security of infix proofs follows without any modifications in the infix construction. We formally state this in the following corollary.

###### Corollary 1.

Under honest majority, the infix NIPoPoW protocol $(P,V)$ is secure for all computable infix-sensitive $k$-stable monotonic predicates $Q$, except with negligible probability in $\\kappa$.

###### Proof.

Assume a typical execution. It suffices to show that the verifier will output the same value $Q(\\mathcal{C})$ as some honest prover. Assume honest prover $B$ has adopted a chain $\\mathcal{C}$ with $Q(\\mathcal{C})=v$ and has provided proof $\\pi_{B}$. By Theorem 1 and because the evaluation of $\\tilde{\\pi}$ is identical in the suffix-sensitive and in the infix-sensitive case, we deduce that $b=\\tilde{\\pi}[-1]$ will be an honestly adopted block. Furthermore, due to the Common Prefix property *[12]*, $b$ will belong to all honest parties’ chains and in the same position, as it is buried under $|\\tilde{\\chi}|=k$ blocks.

Because $Q$ is infix-sensitive, it will be defined using a witness predicate $D$. Because $Q$ is stable, we will have $\\exists\\mathcal{C}^{\\prime}\\subseteq\\mathcal{C}[:-k]:D(\\mathcal{C}^{\\prime})$. But $\\mathcal{C}^{\\prime}\\subseteq\\pi_{B}$. Let $S=\\mathsf{ancestors}(b)$ be the ancestors evaluated by the verifier. As $\\mathcal{C}^{\\prime}\\subseteq S$, therefore $Q(\\mathcal{C}^{\\prime})=Q(S)=v$. ∎

## Appendix E More on succinctness

### E.1 Proof of succinctness

We now prove the optimistic succinctness claims of Section 9.

###### Theorem 8 (Number of levels).

The number of superblock levels which have at least $m$ blocks are at most $\\log(|S|)$, where $S$ is the set of all blocks produced, with overwhelming probability in $m$.

###### Proof.

Let $S$ be the set of all blocks successfully produced by the honest parties or the adversary. Each block id is generated by the random oracle, so $\\Pr[\\text{id}\\leq T2^{-\\mu}]=2^{-\\mu}$. These are independent Bernoulli trials. For each $B\\in S$, let $X_{B}^{\\mu}\\in\\{0,1\\}$ be the random variable indicating whether the block belongs to level $\\mu$ and let $D_{\\mu}$ indicate their sum, which is a Binomial distribution with parameters $(|S|,2^{-\\mu})$ and expectation $E[D_{\\mu}]=|S|2^{-\\mu}$.

For level $\\mu$ to exist in any valid proof, at least $m$ blocks of level $\\mu$ must have been produced by the honest parties or the adversary. We show that $m$ blocks of level $\\mu=\\log(|S|)$ are produced with negligible probability in $m$.

All of the $X^{\\mu}$ are independent. We apply a Binomial Chernoff bound to the sum. We have $\\Pr[D_{\\mu}\\geq(1+\\Delta)E[D_{\\mu}]]\\leq\\exp(-\\frac{\\Delta^{2}}{2+\\Delta}E[D_{\\mu}])$. But for this $\\mu$ we have that $E[D_{\\mu}]=1$. Therefore $\\Pr[D_{\\mu}\\geq 1+\\Delta]\\leq\\exp(-\\frac{\\Delta^{2}}{2+\\Delta})$. Requiring $1+\\Delta=m$, we get $\\Pr[D_{\\mu}\\geq m]\\leq\\exp(-\\frac{(m-1)^{2}}{m+1})$, which is negligible in $m$. ∎

###

###### Theorem 9 (Large upchain expansion).

Let $\\mathcal{C}$ be an honestly generated chain and let $\\mathcal{C}^{\\prime}=\\mathcal{C}\\uparrow^{\\mu-1}\\ [i:i+\\ell]$ with $\\ell\\geq 4m$. Then $|\\mathcal{C}^{\\prime}\\uparrow^{\\mu}|\\geq m$ with overwhelming probability in $m$.

###### Proof.

Assume the $(\\mu-1)$-level superchain has $4m$ blocks. Because each block of level $\\mu-1$ was generated as a query to the random oracle, it constitutes an independent Bernoulli trial and the number of blocks in level $\\mu$, namely $\\pi\\uparrow^{\\mu}$, is a Binomial distribution with parameters $(4m,1/2)$. Clearly $\\Pr[|\\pi\\uparrow^{\\mu}|=m]\\leq\\Pr[|\\pi\\uparrow^{\\mu}|\\leq m]$. Observing that $E[\\pi\\uparrow^{\\mu}]=2m$ and applying a Chernoff bound, we get $\\Pr[|\\pi\\uparrow^{\\mu}|\\leq(1-\\frac{1}{2})2m]\\leq\\exp(-\\frac{(1/2)^{2}}{2}2m)$ which is negligible in $m$.

This probability bounds the probability of fewer than $m$ blocks occurring in the $\\mu$ level restriction of $(\\mu-1)$-level superchains of more than $4m$ blocks. ∎

###### Lemma 9 (Small downchain support).

Assume an honestly generated chain $\\mathcal{C}$ and let $\\mathcal{C}^{\\prime}=\\mathcal{C}\\uparrow^{\\mu}\\ [i:i+m]$. Then $|\\mathcal{C}^{\\prime}\\downarrow\\uparrow^{\\mu-1}|\\leq 4m$ with overwhelming probability in $m$.

###### Proof.

Assume the $(\\mu-1)$-level superchain had at least $4m$ blocks. Then by Theorem 9 it follows that more than $m$ blocks exist in level $\\mu$ with overwhelming probability in $m$, which is a contradiction. ∎

###### Theorem 10 (Optimistic succinctness).

If all players are honest and the network scheduling is random, non-interactive proofs-of-proof-of-work produced by honest provers are succinct with the number of blocks bounded by $4m\\log(|\\mathcal{C}|)$, with overwhelming probability in $m$.

###### Proof.

Assume $\\mathcal{C}$ is an honest parties’ chain. From Theorem 8, the number of levels in the NIPoPoW is at most $\\log(|\\mathcal{C}|)$ with overwhelming probability in $m$. First, observe that the count of blocks in the highest level will be less than $4m$ from Theorem 9; otherwise a higher superblock level would exist. From Corollary 5, we know that at all levels $\\mu$ the chain will be good. Therefore, for each $\\mu$ superchain $\\mathcal{C}$ the supporting $(\\mu-1)$-superchain will only need to span the $m$-long suffix of the $\\mu$-superchain above. For the $m$-long suffix of each superchain of level $\\mu$, the supporting superchain of level $\\mu-1$ will have at most $4m$ blocks from Lemma 9. Therefore the size of the proof is $4m\\log(|\\mathcal{C}|)$. ∎

### E.2 Succinctness of adversarial proofs

In the stronger adversarial setting, however, it is possible for the adversary to produce large dummy (incorrect) proofs that expand the verification time; security will not be hurt but it would take more time to complete verification. One may dismiss this as a trivial denial of service attack and have a resource bounded verifier simply stop if it is confronted with such a processing task. However, simply dismissing superpolylogarithmic proofs is an incorrect strategy, as honest provers can produce such longer proofs in case an adversarial miner harms the goodness of the blockchain.

It would therefore be useful for honest provers to have the ability to signal to the verifier that such time expansion is indeed necessary because of an attack on superchain quality, rather than because a malicious prover is simply sending long proofs that will eventually be rejected. With such signaling mechanism, a resource bounded verifier can distinguish between a denial of service attack that may be directed solely to it from a denial of service attack that is launched by an attacker that has the ability to interfere globally with superchain quality.

To facilitate the above signaling, we offer a simple generalization of our construction that achieves this. Our extended construction allows the verifier to stop processing input early, in a streaming fashion, thereby only requiring logarithmic communication complexity per proof received. To achieve this, observe that honest proofs need to be large only if there is a violation of goodness. However, goodness is not harmed when the chain is not under attack by the adversarial computational power or network. Therefore, we require the prover to produce a certificate of badness in case there is a violation of goodness in the blockchain. This certificate will always be logarithmic in size and must be sent prior to the rest of the proof by the prover to the verifier. Because the certificate will be logarithmic in size even in the case of an adversarial attack on the chain, the honest verifier can stop processing the certificate after a logarithmic time bound. If the certificate is claimed to be longer, the honest verifier can reject early by deciding that the prover is adversarial. Looking at the certificate, the honest verifier determines whether there is a possibility for a lack of goodness in the underlying chain. If there&#x27;s no adversarial computational power in use, the certificate is impossible to produce.

The certificates of badness are produced easily as follows. First, the honest verifier finds the maximum level max-  $\\mu$  at which there are at least  $m$  max-  $\\mu$ -superblocks and includes it in the certificate. Then, because there is a violation of goodness there must exist two levels  $\\mu &amp;lt; \\mu&#x27;$  such that  $2^{\\mu}|\\mathcal{C}\\uparrow^{\\mu}| &amp;gt; (1 + \\delta)2^{\\mu&#x27;}|\\mathcal{C}\\uparrow^{\\mu&#x27;}|$  in some part  $\\mathcal{C}$  of the honestly adopted chain. But  $\\mu&#x27; - \\mu \\leq \\max - \\mu$ . Therefore, there must exist two adjacent levels  $\\mu_1 &amp;lt; \\mu_2$  which break goodness but with error parameter  $(1 + \\delta)^{1 / \\max - \\mu}$ . In particular, it will hold that  $2^{\\mu_1}|\\mathcal{C}\\uparrow^{\\mu_1}| &amp;gt; (1 + \\delta)^{1 / \\max - \\mu}2^{\\mu_2}|\\mathcal{C}\\uparrow^{\\mu_2}|$ . This condition is direct for the prover to find and trivial for the verifier to check and completes the construction. Note that it is possible that a certificate of badness is produceable where two adjacent levels have more than  $(1 + \\delta)^{1 / \\max - \\mu}$  error even if there is no harm to global goodness; however, these certificates cannot be produced when no adversarial power is in use. The algorithm to do this is shown in Algorithm 12.

Algorithm 12 The badness prover which generates a succinct certificate of badness
1: function badness  $m,\\delta (\\mathcal{C})$
2:  $M\\gets \\{\\mu :|\\mathcal{C}\\uparrow^{\\mu}|\\geq m\\} \\setminus \\{0\\}$
3:  $\\rho \\leftarrow 1 / \\max (M)$
4: for  $\\mu \\in M$  do
5: for  $B\\in \\mathcal{C}\\uparrow^{\\mu}$  do
6:  $\\mathcal{C}&#x27;\\gets \\mathcal{C}\\uparrow^{\\mu}\\{B:\\} [:m]$
7: if  $|\\mathcal{C}&#x27;| = m$  then
8:  $\\triangleright$  Sliding m-sized window
9:  $\\mathcal{C}^*\\gets \\mathcal{C}&#x27;\\downarrow \\uparrow^{\\mu -1}$
10: if  $2|\\mathcal{C}&#x27;| &amp;lt;   (1 - \\delta)^{\\rho}|\\mathcal{C}^{*}|$  then
11: return  $\\mathcal{C}^*$  ▷ Chain is bad
12: end if
13: end if
14: end for
15: end for
16: return  $\\perp$  ▷ Chain is good
17: end function

Therefore, we augment the NIPoPoW construction as follows. The honest prover sends a tuple of two items. The first item is empty if the second item is polylogarithmic in the size of the chain; otherwise it is a certificate of badness. The second item is the NIPoPoW proof as in the previous construction. The verifier processes only the first polylogarithmic

number of bytes from the incoming proof. If within that portion a certificate of badness is found, it is checked for validity. If it is found to be valid, the whole proof is checked, regardless of size. If it is found to be invalid or no certificate has been provided, then the proof is rejected as invalid. We call the augmented construction certified NIPoPoWs.

###### Lemma 10 (Certified NIPoPoWs succinctness).

If all miners are honest and the network scheduling is random, certified non-interactive proofs-of-proof-of-work produced by the adversary are processed in polylogarithmic time in the size of the chain by honest verifiers, except with negligible probability in $m$.

###### Proof.

Because all miners are honest and the network scheduling is random, therefore certificates of badness exist with negligible probability in $m$. Conditioning on the event that certificates of badness do not exist, the honest verifier will reject the proof in polylogarithmic time. ∎

We also establish that the modified construction does not harm security below. Security is established in the general case where the adversary has minority mining power.

###### Theorem 11 (Certified NIPoPoWs security).

Assuming honest majority, certified non-interactive proofs-of-proof-of-work are secure, except with negligible probability in $\\kappa$.

###### Proof.

We distinguish two cases: Either goodness has been violated; or it has not been violated. Suppose that goodness has been violated. In that case, an honest prover will include a certificate of badness in their proof and their proof will be processed by an honest verifier.

In the case where goodness is not violated, all honest proofs will be logarithmic in size as established by Lemma 10. Therefore, all honest proofs will be processed by an honest verifier.

Under the condition that all honest proofs will be processed, the rest of the security argument follows immediately from Theorem 1. ∎

We note that, compared to previous work *[15]*, the adversarial model in which we have proven our succinctness is stronger in that the adversary is able to produce proofs.

### E.3 Infix succinctness

Having established the succinctness of the modified suffix construction, the succinctness of the infix construction follows in the next corollary.

###### Corollary 2.

The infix NIPoPoW protocol $(P,V)$ is succinct for all computable infix-sensitive $k$-stable predicates $Q$ in which the witness predicate $D$ depends on a *constant* number of blocks $d$.

###### Proof.

As long as the number of blocks on which the predicate depends is polylogarithmic $(&lt;d)$ with respect to the chain length, our proofs remain succinct. Specifically, the proof size for the suffix has exactly the same size. Then the part of the proof that is of interest is the output of the followDown algorithm. However, notice that this algorithm will on average produce as many blocks as the difference of levels between $B^{\\prime}$ and $E$, which is at most logarithmic in the chain size. Hence the proof sizes will be in expectation $(m+|\\mathcal{C}^{\\prime}|)\\log(|\\mathcal{C}|)$, which remains succinct if $|\\mathcal{C}^{\\prime}|\\in O(polylog(|\\mathcal{C}|))$. ∎

# F Cross-chain ICO evaluation

In order to support the cross-chain ICO application discussed in Section 11 and to present concrete data about the cost of executing NIPoPoW-style proofs, we implemented the NIPoPoW verifier algorithm as a Solidity smart contract $^{10}$ . The contract consists of two functions. The submit_nipopow function is used by the provers to provide their proof vectors. Instead of passing the block headers of the proof, the provers pass the hashes of the block headers and the hashes of the interlink vector. The reason is that the full data of the block header (especially the Merkle tree root) is only useful for the blocks of interest. Thus, we reduce the amount of data needed for the proof by a factor of 2. The rest of the parameters are used in the inclusion proof of the block. After confirming the validity of the proof, the compare_proofs function is called between the current and the best proof. If the current proof is better then it is assigned to the best proof in the contract&#x27;s storage. The gas costs are summarized in Table 4. The $USD column represents the current price of this much gas on Ethereum.

Table 4. Verifier contract functions

|  Function | Data | Gas cost | $USD  |
| --- | --- | --- | --- |
|  compare_proofs | ~8Kb | ~5M | $4  |
|  submit_nipopow | ~65Kb | ~40M | $32  |

# References

1. Maria Apostolaki, Aviv Zohar, and Laurent Vanbever. Hijacking bitcoin: Routing attacks on cryptocurrencies. In Security and Privacy (SP), 2017 IEEE Symposium on, pages 375-392. IEEE, 2017.
2. Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Poelstra, Jorge Timón, and Pieter Wuille. Enabling blockchain innovations with pegged sidechains. URL: http://www.opensciencereview.com/papers/123/enablingblockchain-innovations-with-pegged-sidechains, 2014.
3. Lear Bahack. Theoretical bitcoin attacks with less than half of the computational power (draft). arXiv preprint arXiv:1312.7013, 2013.
4. Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proceedings of the 1st ACM conference on Computer and communications security, pages 62-73. ACM, 1993.
5. Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A Kroll, and Edward W Felten. Sok: Research perspectives and challenges for bitcoin and cryptocurrencies. In Security and Privacy (SP), 2015 IEEE Symposium on, pages 104-121. IEEE, 2015.
6. Ethan Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains. PhD thesis, 2016.
7. Vitalik Buterin. Hard forks, soft forks, defaults and coercion, 2017.
8. Vitalik Buterin et al. A next-generation smart contract and decentralized application platform. white paper, 2014.
9. Johnny Dilley, Andrew Poelstra, Jonathan Wilkins, Marta Piekarska, Ben Gorlick, and Mark Friedenbach. Strong federations: An interoperable blockchain solution to centralized third party risks. CoRR, abs/1612.05491, 2016.
10. John R Douceur. The sybil attack. In International Workshop on Peer-to-Peer Systems, pages 251-260. Springer, 2002.
11. Ittay Eyal and Emin Gün Sirer. Majority is not enough: Bitcoin mining is vulnerable. In International conference on financial cryptography and data security, pages 436-454. Springer, 2014.
12. Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 281-310. Springer, 2015.

13] Ethan Heilman, Alison Kendler, Aviv Zohar, and Sharon Goldberg. Eclipse attacks on bitcoin’s peer-to-peer network. In USENIX Security Symposium, pages 129–144, 2015.
- [14] Maurice Herlihy. Atomic cross-chain swaps. arXiv preprint arXiv:1801.09515, 2018.
- [15] Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka. Proofs of proofs of work with sublinear complexity. In International Conference on Financial Cryptography and Data Security, pages 61–78. Springer, 2016.
- [16] Sergio Demian Lerner. Drivechains, sidechains and hybrid 2-way peg designs, 2016.
- [17] Ralph C Merkle. A digital signature based on a conventional encryption function. In Conference on the Theory and Application of Cryptographic Techniques, pages 369–378. Springer, 1987.
- [18] Andrew Miller. The high-value-hash highway, bitcoin forum post, 2012.
- [19] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.
- [20] Tier Nolan. Alt chains and atomic transfers. bitcointalk.org, May 2013.
- [21] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 643–673. Springer, 2017.
- [22] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. In Proceedings of the ACM Symposium on Principles of Distributed Computing, pages 315–324. ACM, 2017.
- [23] William Pugh. Skip lists: a probabilistic alternative to balanced trees. Communications of the ACM, 33(6):668–676, 1990.
- [24] Meni Rosenfeld. Analysis of hashrate-based double spending. arXiv preprint arXiv:1402.2009, 2014.
- [25] Paul Sztorc. Drivechain - the simple two way peg, November 2015. http://www.truthcoin.info/blog/drivechain/.
- [26] Jason Teutsch, Vitalik Buterin, and Christopher Brown. Interactive coin offerings. Available at: https://people.cs.uchicago.edu/~teutsch/papers/ico.pdf, 2017.
- [27] Stefan Thomas and Evan Schwartz. A protocol for interledger payments. https://interledger.org/interledger.pdf.
- [28] Fabian Vogelsteller and Vitalik Buterin. Erc-20 token standard. sept. 2017. URl: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-tokenstandard.md, 2015.
- [29] Gavin Wood. Ethereum: A secure decentralised generalised transaction ledger. Ethereum Project Yellow Paper, 151:1–32, 2014.
- [30] Gavin Wood. Polkadot: Vision for a heterogeneous multi-chain framework, 2016.
- [31] A Zamyatin, N Stifter, A Judmayer, P Schindler, E Weippl, and W Knottenbelt. (short paper) a wild velvet fork appears! inclusive blockchain protocol changes in practice.</code></pre>`;
---

<BaseLayout title="Non-Interactive Proofs of Proof-of-Work (2017/963)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/963
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
