---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/356';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Verifying Computations with State (Extended Version)';
const AUTHORS_HTML = 'Benjamin Braun, Ariel J.  Feldman, Zuocheng Ren, Srinath Setty, Andrew J.  Blumberg, Michael Walfish';

const CONTENT = `    <p class="text-gray-300">Benjamin Braun, Ariel J. Feldman<em>, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish The University of Texas at Austin </em>University of Pennsylvania</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">When a client outsources a job to a third party (e.g., the cloud), how can the client check the result, without reexecuting the computation? Recent work in <em>proof-based verifiable computation</em> has made significant progress on this problem by incorporating deep results from complexity theory and cryptography into built systems. However, these systems work within a stateless model: they exclude computations that interact with RAM or a disk, or for which the client does not have the full input.</p>

    <p class="text-gray-300">This paper describes Pantry, a built system that overcomes these limitations. Pantry composes proof-based verifiable computation with untrusted storage: the client expresses its computation in terms of digests that attest to state, and verifiably outsources <em>that</em> computation. Using Pantry, we extend verifiability to MapReduce jobs, simple database queries, and interactions with private state. Thus, Pantry takes another step toward practical proof-based verifiable computation for realistic applications.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">This paper addresses a fundamental problem in systems security: how can a local computer verify the correctness of a remote execution? (Checking that the given program was expressed correctly is a complementary concern, studied by the field of program verification.) Our focus on execution verification is motivated by large MapReduce jobs, remote database queries, and cloud computing more generally. In these scenarios, the causes of incorrect execution include corruption of input data in storage or transit, hardware faults, platform bugs, and misconfiguration. Unfortunately, the faults, and their effects, may not be visible as such. Indeed, when a job completes, after having processed petabytes of data, how can the client be sure that the output is correct [83]?</p>

    <p class="text-gray-300">The client could audit the output [60], but this technique fails if a problem happens outside the selected sample. The client could replicate the computation (using state machine replication [27], quorums [56], or outsourcing to two clouds [5, 26]), but this technique works only if replica faults are uncorrelated. The client could trust the remote hardware and use attestation [66, 69], but what if the hardware is faulty? The client could use a tailored solution [8, 16, 22, 32, 43, 64, 76, 79, 81], but such solutions are not available for all applications.</p>

    <p class="text-gray-300">Perhaps surprisingly, the client can receive a guarantee that covers the entire execution of the computation, that makes no assumptions about the performing platform (other than cryptographic hardness assumptions), and that applies generally. In <em>proof-based verifiable computation</em>, the performing computer (or <em>prover</em>) returns the results along with a <em>proof</em> that the client (or <em>verifier</em>) can efficiently and probabilistically check. If the entire computation was executed correctly, the client accepts, and if there is any error, the client rejects with high probability.</p>

    <p class="text-gray-300">These protocols are based on deep theoretical tools: probabilistically checkable proofs (PCPs) [6, 7], interactive proofs [9, 41, 42, 53, 75], and cryptography [18, 23, 35, 36, 47, 50]. This theory provides very</p>

    <p class="text-gray-300">*This is the full version of [25]. This version includes proofs (Appendices A–C), further experimental details (Appendices D–E), and minor improvements to the text.</p>

    <p class="text-gray-300">strong guarantees and is usually phrased as defending against an arbitrarily malicious prover. Note that maliciousness is not an accusation but rather a comprehensive model that includes benign malfunctions with unpredictable effects.</p>

    <p class="text-gray-300">Recent works have aimed to realize proof-based verifiable computation in built systems <em>[15, 28, 65, 70, 71, 72, 73, 78, 80]</em>. On the one hand, these systems appear to approach practicality. Some of them come with compilers that allow programmers to express computations in a high-level language <em>[15, 65, 71, 73, 80]</em>. And the best of them achieve reasonable client performance, provided that there are many identical computations (with potentially different inputs) over which to amortize overhead—a requirement met by typical data-parallel cloud computing applications.</p>

    <p class="text-gray-300">On the other hand, almost none of these systems admit a notion of state or storage: their compilation target is constraints, a generalization of circuits (§2). Given this “assembly language”, the computation cannot feasibly use memory, and the client must handle all of the input and output. Besides hindering programmability, these limitations are inconsistent with remotely stored inputs (as in MapReduce jobs, queries on remote databases, etc.); for example, verifying a large MapReduce job would require the client to materialize the entire dataset.</p>

    <p class="text-gray-300">This paper introduces Pantry, the first system to provide verifiable computation with state. To do so, Pantry marries machinery for verifying pure computations with techniques from untrusted storage <em>[21, 33, 52, 58]</em>. While this picture is folklore among theorists <em>[14, 18, 36, 46]</em>, the contributions of Pantry are to work out the details and build a system, specifically:</p>

    <p class="text-gray-300">(1) Pantry enhances state of the art systems (§2) for verifiable computation (Ginger <em>[73]</em>, Zaatar <em>[71]</em>, Pinocchio <em>[65]</em>) with a storage abstraction (§3). The programmer expresses a computation using a subset of C plus two new primitives—PutBlock and GetBlock—and the Pantry compiler produces appropriate constraints. These primitives name data blocks by a cryptographic digest, or hash, of their contents. Such blocks are used extensively in systems for untrusted storage <em>[33, 52]</em>; however, in Pantry, the verifier will not be fetching the blocks to check them. The key insight here is that there exist hash functions that are amenable to the constraint formalism.</p>

    <p class="text-gray-300">(2) Using PutBlock and GetBlock, we build a verifiable MapReduce framework (§4). The programmer writes Map and Reduce functions, much as in standard MapReduce frameworks. Here, however, input and output files are named by the digests of their contents.</p>

    <p class="text-gray-300">(3) We also use PutBlock and GetBlock (together with well-known techniques <em>[21, 58]</em>) to build higher-level storage abstractions: a RAM and a searchable tree (§5). We use the tree to build a database application that supports verifiable queries in a (small) subset of SQL. The notable aspects here are the placement of functionality and the result: the abstractions are exposed to the C programmer, they need not be built into the compiler, and operations on these abstractions happen verifiably even though the client does not have the state.</p>

    <p class="text-gray-300">(4) We compose PutBlock and GetBlock with a zero-knowledge variant of Pinocchio <em>[36, 65]</em>, to build applications in which the prover’s state is private: face matching, toll collection, etc. (§6).</p>

    <p class="text-gray-300">The components just described have awkward usage restrictions (the database is single-writer, iteration constructs need static upper bounds, etc.), due in part to the clumsiness of the constraint formalism. Worse, the measured cost (§8) of the implementation (§7) is very high: the prover’s overhead is tremendous, and the verifier incurs a similarly high per-computation setup cost, requiring many invocations to justify this expense.</p>

    <p class="text-gray-300">However, compared to prior systems for verifiable computation (§9), Pantry improves performance: by not handling inputs, the verifier saves CPU and network costs. This effect, together with Pantry’s enhanced expressiveness, expands the universe of applications for which verification makes sense (§10). MapReduce, for example, works over remote state, and is well-suited to amortizing the setup costs, since it</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1—Verifiable outsourcing in Zaatar and Pinocchio, assuming a single instance of a computation  <span class="math">\\Psi</span>  on input  <span class="math">x</span>  (amortization is depicted in Figure 2). Step ①:  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  compile  <span class="math">\\Psi</span>  from a high-level language to constraints  <span class="math">\\mathcal{C}</span> . Step ②:  <span class="math">\\mathcal{P}</span>  produces a satisfying assignment,  <span class="math">z</span> , to  <span class="math">\\mathcal{C}(X = x, Y = y)</span> . Step ③:  <span class="math">\\mathcal{P}</span>  uses complexity-theoretic and cryptographic machinery to convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">\\mathcal{P}</span>  holds a satisfying assignment.</p>

    <p class="text-gray-300">entails many identical computations. And the private state applications provide functionality that does not exist otherwise or previously required intricate custom protocols. In summary, Pantry extends proof-based verifiable computation to real applications of cloud computing (albeit at much smaller scales for now).</p>

    <p class="text-gray-300">We present Zaatar [71] and Pinocchio [65], and the underlying theory, in a unified framework. Similar frameworks appear in prior work [65, 71-73, 80], and aspects of our presentation are borrowed [71, §2][80, §2].</p>

    <p class="text-gray-300">A client, or verifier  <span class="math">\\mathcal{V}</span> , sends a program  <span class="math">\\Psi</span> , expressed in a high-level language, to a server, or prover  <span class="math">\\mathcal{P}</span> .  <span class="math">\\mathcal{V}</span>  sends input  <span class="math">x</span>  and receives output  <span class="math">y</span> , which is supposed to be  <span class="math">\\Psi(x)</span> .  <span class="math">\\mathcal{V}</span>  then engages  <span class="math">\\mathcal{P}</span>  in a protocol that allows  <span class="math">\\mathcal{V}</span>  to check whether  <span class="math">\\mathcal{P}</span>  executed correctly. This protocol assumes a computational bound on  <span class="math">\\mathcal{P}</span>  (e.g., that  <span class="math">\\mathcal{P}</span>  cannot break a cryptographic primitive). However, the protocol makes no other assumptions about  <span class="math">\\mathcal{P}</span> : its guarantees hold regardless of how or why  <span class="math">\\mathcal{P}</span>  malfunctions. These guarantees are probabilistic (over  <span class="math">\\mathcal{V}</span> 's random choices):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. If  <span class="math">y = \\Psi(x)</span> , then if  <span class="math">\\mathcal{P}</span>  follows the protocol,  <span class="math">\\operatorname*{Pr}\\{\\mathcal{V} \\text{ accepts}\\} = 1</span> .</li>

      <li>Soundness. If  <span class="math">y \\neq \\Psi(x)</span> , then  <span class="math">\\operatorname*{Pr}\\{V \\text{ rejects}\\} &amp;gt; 1 - \\epsilon</span> , where  <span class="math">\\epsilon</span>  can be made small.</li>

    </ul>

    <p class="text-gray-300">Given a specific computation  <span class="math">\\Psi</span> , we call each invocation of it an instance. The per-instance costs for  <span class="math">\\mathcal{V}</span>  are very low. However, in order to participate in the protocol,  <span class="math">\\mathcal{V}</span>  incurs a setup cost for each  <span class="math">\\Psi</span> , which amortizes over multiple instances, either over a batch [71] or indefinitely [65] (see Section 2.3).</p>

    <p class="text-gray-300">Verifiably outsourcing a computation happens in three steps, depicted in Figure 1. First, a compiler transforms the computation  <span class="math">\\Psi</span>  to an algebraic system of constraints. Next,  <span class="math">\\mathcal{P}</span>  produces a solution to these constraints that implies  <span class="math">y = \\Psi(x)</span> . Finally,  <span class="math">\\mathcal{P}</span>  convinces  <span class="math">\\mathcal{V}</span>  that it has produced such a solution, thereby establishing that  <span class="math">y = \\Psi(x)</span> . We now describe each step in detail; for the time being, we assume only one instance (§2.3 revisits).</p>

    <p class="text-gray-300">(1)  <span class="math">\\Psi</span>  is represented as constraints. The programmer begins by expressing a computation,  <span class="math">\\Psi</span> , in a subset of C or an equivalent high-level language (described in §2.4) and invoking a compiler [55, 65, 71, 73]. Here, we focus on the compilation target: a set of constraints [24, 73].</p>

    <p class="text-gray-300">In our context, a set of constraints  <span class="math">\\mathcal{C}</span>  is a system of equations in variables  <span class="math">(X,Y,Z)</span> , over a large finite field,  <span class="math">\\mathbb{F}</span> ; we choose  <span class="math">\\mathbb{F} = \\mathbb{F}_p</span>  (the integers mod a prime  <span class="math">p</span> ), where  <span class="math">p</span>  is large (e.g., 128 bits). Each constraint</p>

    <p class="text-gray-300">has total degree 2, so each summand in a constraint is either a variable or a product of two variables. Variables <span class="math">X</span> and <span class="math">Y</span> represent the input and output variables, respectively; for now, we assume one of each. Upper-case letters <span class="math">(X,Y,Z,\\ldots)</span> represent constraint variables; their lower-case counterparts <span class="math">(x,y,z,\\ldots)</span> represent concrete values taken by (or assigned to, or bound to) those variables.</p>

    <p class="text-gray-300">Also, let <span class="math">\\mathcal{C}(X{=}x)</span> mean <span class="math">\\mathcal{C}</span> with <span class="math">X</span> bound to <span class="math">x</span> (<span class="math">\\mathcal{V}</span>’s requested input); <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> indicates that in addition <span class="math">Y</span> is bound to <span class="math">y</span> (the purported output). Notice that <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is a set of constraints over the variables <span class="math">Z</span>. If for some <span class="math">z</span>, setting <span class="math">Z{=}z</span> makes all constraints in <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> hold simultaneously, then <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is said to be <em>satisfiable</em>, and <span class="math">z</span> is a <em>satisfying assignment</em>.</p>

    <p class="text-gray-300">For a given computation <span class="math">\\Psi</span>, a set of constraints <span class="math">\\mathcal{C}</span> is said to be <em>equivalent</em> to <span class="math">\\Psi</span> if: for all <span class="math">x,y</span>, we have <span class="math">y=\\Psi(x)</span> if and only if <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is satisfiable. As a simple example, the constraints <span class="math">\\mathcal{C}{=}\\{Z-X=0</span>, <span class="math">Z+1-Y=0\\}</span> are equivalent to add-1 <em>[24]</em>. Indeed, consider a pair <span class="math">(x,y)</span>. If <span class="math">y=x+1</span>, then there is a satisfying assignment to <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span>, namely <span class="math">Z{=}x</span>. However, if <span class="math">y\\neq x+1</span>, then <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is not satisfiable.</p>

    <p class="text-gray-300">(2) <span class="math">\\mathcal{P}</span> computes and identifies a satisfying assignment. <span class="math">\\mathcal{P}</span> “executes” <span class="math">\\Psi(x)</span> by identifying a satisfying assignment to the equivalent constraints <span class="math">\\mathcal{C}(X{=}x)</span>, and obtaining the output <span class="math">y</span> in the process. To do so, <span class="math">\\mathcal{P}</span> runs a constraint-solving routine that takes as input a compiler-produced list of annotated constraints. This routine goes constraint-by-constraint. A common case is that a constraint introduces a variable and can be written as an assignment to that new variable (e.g., <span class="math">\\{\\ldots</span>, <span class="math">Z_{4}=Z_{3}\\cdot(Z_{2}+Z_{1})</span>, <span class="math">Z_{5}=Z_{4}\\cdot Z_{2}</span>, <span class="math">\\ldots\\}</span>); the routine “solves” such constraints by evaluating their right-hand sides.</p>

    <p class="text-gray-300">Some constraints require additional work of <span class="math">\\mathcal{P}</span>. An example is the <span class="math">!*</span> test (this will give some intuition for the techniques in Section 3). Consider the following snippet:</p>

    <pre><code class="language-text">if (Z1 != Z2)
Z3 = 1;
else
Z3 = 0;</code></pre>

    <p class="text-gray-300">This compiles to the following constraints <em>[24]</em>:</p>

    <p class="text-gray-300">\\[ \\mathcal{C}_{!*}=\\left\\{\\begin{array}[]{rcl}M\\cdot(Z_{1}-Z_{2})-Z_{3}&=&0\\\\ (1-Z_{3})\\cdot(Z_{1}-Z_{2})&=&0\\end{array}\\right\\}. \\]</p>

    <p class="text-gray-300">Notice that the first constraint introduces <em>two</em> new variables (<span class="math">M,Z_{3}</span>), and thus there are multiple ways to satisfy this constraint. To choose values for these variables that also satisfy the second constraint, <span class="math">\\mathcal{P}</span>’s constraint-solving routine consults the constraints’ annotations. The relevant annotation tells <span class="math">\\mathcal{P}</span> that if <span class="math">Z_{1}\\neq Z_{2}</span>, then <span class="math">\\mathcal{P}</span> should set <span class="math">M</span> equal to the multiplicative inverse of <span class="math">Z_{1}-Z_{2}</span>, which <span class="math">\\mathcal{P}</span> computes outside of the constraint formalism. We call this “computing exogenously” (in theoretical terms, <span class="math">M</span> and <span class="math">Z_{3}</span> are “non-deterministic input”), and there is an analogy between the exogenous computation of <span class="math">M</span> and supplying values from storage in Section 3.</p>

    <p class="text-gray-300">(3) <span class="math">\\mathcal{P}</span> argues that it has a satisfying assignment. <span class="math">\\mathcal{P}</span> wants to prove to <span class="math">\\mathcal{V}</span> that it knows a satisfying assignment to <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span>; this would convince <span class="math">\\mathcal{V}</span> that the output <span class="math">y</span> is correct (and moreover that the computation, expressed in constraints, was executed correctly). Of course, there is a simple proof that a satisfying assignment exists: the satisfying assignment itself. However, <span class="math">\\mathcal{V}</span> could check this proof only by examining all of it, which would be as much work as executing the computation.</p>

    <p class="text-gray-300">Instead, Zaatar and Pinocchio apply the theory of PCPs <em>[6, 7]</em>, which implies that a classical proof—a satisfying assignment <span class="math">z</span>, in this case—can be <em>encoded</em> into a long string <span class="math">\\pi</span> in a way that allows <span class="math">\\mathcal{V}</span> to detect</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (a) Zaatar</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (b) Pinocchio Figure 2—Amortization in Zaatar [71] and Pinocchio [65]. Superscripts denote different instances. In Zaatar,  <span class="math">\\nu</span> 's work to formulate queries amortizes over a batch of  <span class="math">\\beta</span>  instances; in Pinocchio, analogous work amortizes over all future instances of the same computation (this is better). In both protocols, the  <span class="math">\\Psi \\rightarrow \\mathcal{C}</span>  step happens only once for each  <span class="math">\\Psi</span>  (not depicted).</p>

    <p class="text-gray-300">the proof's validity by (a) inspecting a small number of randomly-chosen locations in  <span class="math">\\pi</span> , and (b) applying efficient tests to the contents found at those locations. The details—what is in the encoding  <span class="math">\\pi</span> , how  <span class="math">\\mathcal{V}</span>  selects locations to inspect, what tests  <span class="math">\\mathcal{V}</span>  applies, and why all of this works—are beyond the scope of this paper.</p>

    <p class="text-gray-300">The protocols do not use PCPs alone: the encoded proof  <span class="math">\\pi</span>  is far larger than the number of steps in  <span class="math">\\Psi</span> , so making  <span class="math">\\mathcal{V}</span>  receive  <span class="math">\\pi</span>  would again defeat our purpose. To get around this issue, Zaatar and Pinocchio—and their theoretical progenitors—compose PCPs with cryptography, based on assumptions that  <span class="math">\\mathcal{P}</span>  cannot break certain primitives. There are two types of protocols; our compiler produces  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  binaries for both.</p>

    <p class="text-gray-300">First, Zaatar [71] instantiates an efficient argument [23, 47, 50, 72, 73]:  <span class="math">\\mathcal{V}</span>  extracts from  <span class="math">\\mathcal{P}</span>  a cryptographic commitment to  <span class="math">\\pi</span> , and then  <span class="math">\\mathcal{V}</span>  queries  <span class="math">\\mathcal{P}</span> , meaning that  <span class="math">\\mathcal{V}</span>  asks  <span class="math">\\mathcal{P}</span>  what values  <span class="math">\\pi</span>  contains at particular locations.  <span class="math">\\mathcal{V}</span>  uses PCPs to choose the locations and test the replies, and cryptography to ensure that  <span class="math">\\mathcal{P}</span> 's replies pass  <span class="math">\\mathcal{V}</span> 's tests only if  <span class="math">\\mathcal{P}</span> 's replies are consistent with a proof  <span class="math">\\pi</span>  that a satisfying assignment exists. The protocol details are given in prior works [71, §2][73, §2][72].</p>

    <p class="text-gray-300">The second variant is instantiated by Pinocchio [65] and known as a non-interactive argument [36, 37]:  <span class="math">\\mathcal{V}</span>  preencrypts queries and sends them to  <span class="math">\\mathcal{P}</span> . As in the first variant, the queries are chosen by PCP machinery and describe locations where  <span class="math">\\mathcal{V}</span>  wants to inspect an eventual  <span class="math">\\pi</span> . Here, however,  <span class="math">\\mathcal{P}</span>  replies to the queries without knowing which locations  <span class="math">\\mathcal{V}</span>  is querying. This process (hiding the queries, replying to them, testing the answers) relies on sophisticated cryptography layered atop the PCP machinery. The details are described elsewhere [20, 36, 65].</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span>  incurs a setup cost (to express which locations in  <span class="math">\\pi</span>  to query) for each computation  <span class="math">\\Psi</span>  and each input size. This cost amortizes differently in Zaatar and Pinocchio.</p>

    <p class="text-gray-300">In Zaatar, amortization happens over a batch: a set of  <span class="math">\\beta</span>  instances of the identical computation  <span class="math">\\Psi</span> , on different inputs (Figure 2(a)). Thus, Zaatar presumes parallelism: for  <span class="math">j \\in \\{1, \\dots, \\beta\\}</span> ,  <span class="math">\\mathcal{V}</span>  sends parallel inputs  <span class="math">x^{(j)}</span> ,  <span class="math">\\mathcal{P}</span>  returns parallel outputs  <span class="math">y^{(j)}</span> , and  <span class="math">\\mathcal{P}</span>  formulates parallel proofs  <span class="math">\\pi^{(j)}</span>  establishing that  <span class="math">y^{(j)} = \\Psi(x^{(j)})</span> . The synchronization requirement is that  <span class="math">V</span>  extract commitments to all  <span class="math">\\pi^{(j)}</span>  before issuing the queries (because queries are reused across the batch). Note that  <span class="math">\\mathcal{P}</span>  is an abstraction and could represent multiple machines (as in our MapReduce application in Section 4). Zaatar meets the completeness and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">naive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zaatar [71], Pinocchio [65]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V, setup</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">c2·(</td>

            <td class="px-3 py-2 border-b border-gray-700">Z</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V, runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">β·(T(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">) + c1</td>

            <td class="px-3 py-2 border-b border-gray-700">y</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">β·(c3 + c4·(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">y</td>

            <td class="px-3 py-2 border-b border-gray-700">))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P, runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">β·(c5·(</td>

            <td class="px-3 py-2 border-b border-gray-700">Z</td>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">) + c6·</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">·log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">T</span> : running time of computation as a function of input length. <span class="math">x,y</span>  : input and output of computation. <span class="math">\\beta</span>  : number of instances over which  <span class="math">\\mathcal{V}</span>  's setup cost amortizes <span class="math">c_{1}, c_{2}, \\ldots</span> : model costs of processing input/output, cryptographic primitives, PCP queries, etc.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 3—CPU costs of step (3) under Zaatar and Pinocchio, and under the naive approach: reexecute and compare. The amortization behavior is different for Zaatar and Pinocchio (see text). Also, the constants  <span class="math">(c_{2}, c_{3}, \\ldots)</span>  differ: Pinocchio's  <span class="math">c_{4}</span>  is lower while for the other constants, Zaatar's values are lower. Section 8.1 discusses these constants, the magnitudes of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , and the costs of step (2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">soundness properties given earlier (§2.1), with  <span class="math">\\epsilon &amp;lt; 1/10^6</span>  (see [71, Apdx. A.2]), and in addition provides soundness for the batch: if for any  <span class="math">j \\in \\{1, \\dots, \\beta\\}</span> ,  <span class="math">y^{(j)} \\neq \\Psi(x^{(j)})</span> , then  <span class="math">\\operatorname{Pr}\\{V \\text{ rejects the batch}\\} &amp;gt; 1 - \\epsilon</span> .</p>

    <p class="text-gray-300">In Pinocchio, query formulation by  <span class="math">\\mathcal{V}</span>  and installation on  <span class="math">\\mathcal{P}</span>  happen once per  <span class="math">\\Psi</span> , thereby amortizing over all future instances of the identical computation (Figure 2(b)). Pinocchio meets the completeness and soundness properties, with  <span class="math">\\epsilon &amp;lt; 1/2^{128}</span> . Pinocchio also has versions that provide zero-knowledge (the prover can keep private the contents of the satisfying assignment  <span class="math">z</span> ) and public verifiability [65]; the former provides a crucial foundation for Pantry's privacy-preserving applications ( <span class="math">\\S 6</span> ).</p>

    <p class="text-gray-300">Figure 3 depicts the protocols' CPU costs for step (3). A key performance goal is that  <span class="math">\\mathcal{V}</span>  should incur lower (amortized) CPU costs than the naive alternative: reexecuting the computation [35]. Performance is thus evaluated as follows [65, 71-73, 80]. (1) Are the per-instance costs for  <span class="math">\\mathcal{V}</span>  less than the running time of  <span class="math">\\Psi</span> , when  <span class="math">\\Psi</span>  is expressed in C and compiled to machine code? (Otherwise, the performance goal cannot be met.) (2) What is the cross-over point, meaning the number of instances past which  <span class="math">\\mathcal{V}</span>  expends less total CPU than the naive verifier? (3) What are the overheads of  <span class="math">\\mathcal{P}</span> , relative to normal execution?</p>

    <p class="text-gray-300">Rough answers are as follows (see also Section 8). For question (1), the answer is "sometimes; it depends on the computation". For (2), the cross-over points are tens of thousands or millions [71, §5.2], depending on the computation. For (3), the overheads are very high: factors of  <span class="math">10^{4}</span>  or  <span class="math">10^{5}</span>  are not uncommon.</p>

    <p class="text-gray-300">To briefly compare the performance of Zaatar and Pinocchio, Pinocchio has superior amortization behavior (see above) but higher proving and setup costs (and hence higher cross-over points), by constant factors.</p>

    <p class="text-gray-300">As context for Pantry, we now describe the language features and limitations of prior work [24, 65, 71, 73].</p>

    <p class="text-gray-300">Pre-Pantry, compilers accepted a C subset [65] (or the equivalent [55, 71, 73]) that includes functions, structs, typedefs, preprocessor definitions, if-else statements, explicit type conversion, and standard integer and bitwise operations. These compilers partially support pointers and loops: pointers and array indexes must be compile-time constants (ruling out a RAM abstraction), and likewise with the maximum number of loop iterations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When compiled, most operations introduce only a few new variables or constraints [71, §4]. There are four exceptions. The first two are inequalities and bitwise operations; these constructs separate numbers into their bits and glue them back together [24, 65, 73], requiring  $\\approx \\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  constraints and variables per operation. The other two are looping and if-else statements: loops are unrolled at compile time, and the costs of an if-else statement combine the costs of the then-block and the else-block [24].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Apart from the specifics of language constructs and costs, the pre-Pantry model of computation is severely limited, even hermetic: computations can interact with state neither as auxiliary input, nor during execution, nor as auxiliary output. Therefore, using Zaatar or Pinocchio requires <span class="math">\\mathcal{V}</span> to supply all inputs, receive all outputs, and eschew any notion of RAM, disk, or storage. These are the limitations addressed by Pantry.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Storage model and primitives in Pantry</h2>

    <p class="text-gray-300">The core of Pantry is two primitives, verifiable PutBlock and GetBlock, that extend the model above. This section describes the primitives; Sections 4–6 describe their use.</p>

    <p class="text-gray-300">To explain Pantry’s approach, we note that the interface to step (3) in Section 2.2 is a set of constraints and a purported satisfying assignment. Thus, a first cut attempt at incorporating state into verifiable computation would be to represent load and store operations with constraints explicitly. However, doing so naively would incur horrific expense: if memory is an array of variables, then load(addr) would require a separate constraint for each possible value of addr (assuming addr is not resolvable at compile-time). This approach would also require the input state to be available to the verifier <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">To overcome these problems, we want a model in which computations do not execute storage but can efficiently verify it. Given such a model, we could use constraints to represent computation (as we do now) as well as efficient <em>checks</em> of storage. But such a model is actually well-studied, in the context of untrusted storage: the state is represented by hash trees <em>[21, 58]</em>, often accompanied by a naming scheme in which data blocks are referenced by hashes of their contents <em>[33, 52]</em>.</p>

    <p class="text-gray-300">If we could efficiently represent the computation of the hash function as constraints, then we could extend the computational model in Section 2 with the semantics of untrusted storage. At that point, a satisfying assignment to the constraints would imply correct computation <em>and</em> correct interaction with state—and we could use step (3) from Section 2.2 to prove to <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> holds such an assignment. We now describe this approach.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1 Verifiable blocks: overview</h3>

    <p class="text-gray-300">The lowest level of storage is a block store; it consists of variable-length blocks of data, in which the blocks are named by collision-resistant hash functions (CRHFs) of those blocks. Letting <span class="math">H</span> denote a CRHF, a correct block store is a map</p>

    <p class="text-gray-300"><span class="math">S\\colon\\mathit{name}\\to\\mathit{block}\\cup\\bot,</span></p>

    <p class="text-gray-300">where if <span class="math">\\mathit{block}=S(\\mathit{name})</span>, then <span class="math">H(\\mathit{block})=\\mathit{name}</span>. In other words, <span class="math">S</span> implements the relation <span class="math">H^{-1}</span>. This naming scheme allows clients to use untrusted storage servers <em>[33, 52]</em>. The technique’s power is that given a name for data, the client can check that the returned block is correct, in the sense of being consistent with its name. Likewise, a client that creates new blocks can compute their names and use those names as references later in the computation.</p>

    <p class="text-gray-300">But unlike the scenario in prior work, our <span class="math">\\mathcal{V}</span> cannot actually check the contents of the blocks that it “retrieves” or impose the correct names of the blocks that it “stores”, as the entire computation is remote. Instead, <span class="math">\\mathcal{V}</span> represents its computations with constraints that <span class="math">\\mathcal{P}</span> can satisfy only if <span class="math">\\mathcal{P}</span> uses the right blocks. Another way to understand this approach is that <span class="math">\\mathcal{V}</span> uses the verification machinery to outsource the storage checks to <span class="math">\\mathcal{P}</span>; in fact, <span class="math">\\mathcal{P}</span> itself could be using an untrusted block store!</p>

    <p class="text-gray-300">We will show in later sections how to write general-purpose computations; for now, we illustrate the model with a simple example. Imagine that the computation takes as input the name of a block and returns the associated contents as output. The constraints are set up to be satisfiable if and only if the return value hashes to the requested name. In effect, <span class="math">\\mathcal{P}</span> is being asked to identify a preimage of <span class="math">H</span>, which</p>

    <p class="text-gray-300">GetBlock(name  <span class="math">n</span>  .. block  <span class="math">\\leftarrow</span>  read block with name  <span class="math">n</span>  in block store  <span class="math">S</span> assert  <span class="math">n = = H(block)</span> return block</p>

    <p class="text-gray-300">PutBlock(block):  <span class="math">n\\gets H(block)</span>  store  <span class="math">(n,block)</span>  in block store  <span class="math">S</span>  return  <span class="math">n</span></p>

    <p class="text-gray-300">Figure 4—Pseudocode for verifiable storage primitives. These primitives compile to constraints that enforce the required relation between  <span class="math">n</span>  and block; the constraints do not represent interactions with  <span class="math">S</span>  explicitly.</p>

    <p class="text-gray-300">(by the collision-resistance of  <span class="math">H</span> )  <span class="math">\\mathcal{P}</span>  can do only if it returns the actual block previously stored under the requested name.</p>

    <p class="text-gray-300">Pantry provides two primitives to the programmer:</p>

    <p class="text-gray-300">block = GetBlock(name);</p>

    <p class="text-gray-300">name = PutBlock(block);</p>

    <p class="text-gray-300">These primitives are detailed in Figure 4. Notice that in a correct execution,  <span class="math">H(\\text{block}) = \\text{name}</span> . Given this relation, and given the collision-resistance of  <span class="math">H</span> , the programmer receives from GetBlock and PutBlock a particular storage model:  <span class="math">S</span>  functions as write-once memory, where the addresses are in practice unique, and where an address certifies the data that it holds.</p>

    <p class="text-gray-300">Of course, how  <span class="math">S</span>  is implemented is unspecified here; the choice can be different for different kinds of storage (MapReduce, RAM, etc.). And, per the definition of  <span class="math">S</span> , block length can vary; for example, in the MapReduce application (§4), an entire file will be one block.</p>

    <p class="text-gray-300">To bootstrap, the client supplies one or more names as input, and it may receive one or more names as output, for use in further computations. These names are related to capabilities [44, 51]: with capabilities, a reference certifies to the system, by its existence, that the programmer is entitled to refer to a particular object; here, the reference itself certifies to the programmer that the system is providing the programmer with the correct object.</p>

    <p class="text-gray-300">We now describe the constraints that enforce the model. The code  <span class="math">\\mathtt{b} = \\mathtt{GetBlock}(\\mathtt{n})</span>  compiles to constraints  <span class="math">\\mathcal{C}_{H^{-1}}</span> , where: the input variable,  <span class="math">X</span> , represents the name; the output variable,  <span class="math">Y</span> , represents the block contents; and  <span class="math">\\mathcal{C}_{H^{-1}}(X = n, Y = b)</span>  is satisfiable if and only if  <span class="math">b \\in H^{-1}(n)</span>  (i.e.,  <span class="math">H(b) = n</span> ). The code  <span class="math">\\mathtt{n} = \\mathtt{PutBlock}(\\mathtt{b})</span>  compiles to the same constraints, except that the inputs and outputs are switched. Specifically, this line compiles to constraints  <span class="math">\\mathcal{C}_H</span> , where:  <span class="math">X</span>  represents the block contents,  <span class="math">Y</span>  represents the name, and  <span class="math">\\mathcal{C}_H(X = b, Y = n)</span>  is satisfiable if and only if  <span class="math">n = H(b)</span> .</p>

    <p class="text-gray-300">Of course,  <span class="math">\\mathcal{C}_H</span>  and  <span class="math">\\mathcal{C}_{H^{-1}}</span>  will usually appear inside a larger set of constraints, in which case the compiler relabels the inputs and outputs of  <span class="math">\\mathcal{C}_H</span>  and  <span class="math">\\mathcal{C}_{H^{-1}}</span>  to correspond to intermediate program variables. As an example, consider the following computation:</p>

    <pre><code class="language-txt">add(int x1, name x2) { block b = GetBlock(x2); /* assume that b is a field element */ return b + x1; }</code></pre>

    <p class="text-gray-300">The corresponding constraints are:</p>

    <pre><code class="language-txt">$\\mathcal{C} = \\{Y - B - X_1 = 0\\} \\cup \\mathcal{C}_{H^{-1}}(X = X_2,Y = B),$</code></pre>

    <p class="text-gray-300">where the notation  <span class="math">X = X_{2}</span>  and  <span class="math">Y = B</span>  means that, in  <span class="math">\\mathcal{C}_{H^{-1}}</span>  above, the appearances of  <span class="math">X</span>  are relabeled  <span class="math">X_{2}</span>  and the appearances of  <span class="math">Y</span>  are relabeled  <span class="math">B</span> . Notice that variable  <span class="math">B</span>  is unbound in  <span class="math">\\mathcal{C}(X_1 = x_1, X_2 = x_2, Y = y)</span> . To assign  <span class="math">B = b</span>  in a way that satisfies the constraints,  <span class="math">\\mathcal{P}</span>  must identify a concrete  <span class="math">b</span> , presumably from storage, such that  <span class="math">H(b) = x_{2}</span> .</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Costs.</h5>

    <p class="text-gray-300">The main cost of GetBlock and PutBlock is the set of constraints required to represent the hash function <span class="math">H</span> in <span class="math">\\mathcal{C}_{H}</span> and <span class="math">\\mathcal{C}_{H^{-1}}</span>. Unfortunately, widely-used functions (e.g., SHA-1) make heavy use of bitwise operations, which do not have compact representations as constraints (§2.4). Instead, we use an <em>algebraic</em> hash function, due to Ajtai <em>[4, 40]</em> and based on the hardness of approximation problems in lattices. The Ajtai function multiplies its input, represented as a bit vector, by a large matrix modulo an integer. This matrix-vector multiplication can be expressed concisely in constraints because constraints naturally encode sums of products (§2.2). Indeed, Ajtai requires approximately ten times fewer constraints than SHA-1 would. Nevertheless, Ajtai uses some bitwise operations (for modular arithmetic) and hence requires a substantial number of constraints (§8.1).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.3 Guarantees and non-guarantees</h3>

    <p class="text-gray-300">Appendices A and B describe the formal guarantees of Pantry; here we give an informal and heuristic explanation.</p>

    <p class="text-gray-300">Notice that the constraints do not capture the actual interaction with the block store <span class="math">S</span>; the prover <span class="math">\\mathcal{P}</span> is separately responsible for maintaining the map <span class="math">S</span>. What ensures that <span class="math">\\mathcal{P}</span> does so honestly? The high-level answer is the checks in the constraints plus the collision-resistance of <span class="math">H</span>.</p>

    <p class="text-gray-300">As an illustration, consider this code snippet:</p>

    <pre><code class="language-text">n = PutBlock(b);
b’ = GetBlock(n);</code></pre>

    <p class="text-gray-300">In a reasonable (sequential) computational model, a read of a memory location should return the value written at that location; since our names act as “locations”, a correct execution of the code above should have variables <span class="math">b</span> and <span class="math">b^{\\prime}</span> equal. But the program is compiled to constraints that include <span class="math">\\mathcal{C}_{H}</span> (for PutBlock) and <span class="math">\\mathcal{C}_{H^{-1}}</span> (for GetBlock), and these constraints could in principle be satisfied with <span class="math">b^{\\prime}\\neq b</span>, if <span class="math">H(b^{\\prime})=H(b)</span>. However, <span class="math">\\mathcal{P}</span> is prevented from supplying a spurious satisfying assignment because collision-resistance implies that identifying such a <span class="math">b</span> and <span class="math">b^{\\prime}</span> is computationally infeasible. That is, practically speaking, <span class="math">\\mathcal{P}</span> can satisfy the constraints only if it stores the actual block and then returns it.</p>

    <p class="text-gray-300">However, Pantry does not formally enforce <em>durability</em>: a malicious <span class="math">\\mathcal{P}</span> could discard blocks inside PutBlock yet still exhibit a satisfying assignment. Such a <span class="math">\\mathcal{P}</span> might be caught only when executing a subsequent computation (when <span class="math">\\mathcal{V}</span> issues a corresponding GetBlock, <span class="math">\\mathcal{P}</span> would be unable to satisfy the constraints), and at that point, it might be too late to get the data back. For a formal guarantee of durability, one can in principle use other machinery <em>[74]</em>. Also, Pantry (like its predecessors) does not enforce <em>availability</em>: <span class="math">\\mathcal{P}</span> could refuse to engage, or fail to supply a satisfying assignment, even if it knows one.</p>

    <p class="text-gray-300">What Pantry enforces is <em>integrity</em>, meaning that purported memory values (the blocks that are used in the computation) are consistent with their names, or else the computation does not verify.</p>

    <p class="text-gray-300">For this reason, if <span class="math">\\mathcal{V}</span>’s computation executes GetBlock(foo), and foo is an erroneous name in the sense that it does not represent the hash of any block previously stored, then <span class="math">\\mathcal{P}</span> has no way of providing a satisfying assignment. This is as it should be: the computation itself is erroneous (in this model, correct programs pass the assert in GetBlock; see Figure 4).</p>

    <p class="text-gray-300">A limitation of this model is that <span class="math">\\mathcal{P}</span> cannot prove to <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{V}</span> made such an error; to the argument step (step (3) in §2.2), this case looks like the one in which <span class="math">\\mathcal{P}</span> refuses to provide a satisfying assignment. While that might be disconcerting, Pantry’s goal is to establish that a remote execution is consistent with an expressed computation; program verification is a complementary concern (§1).</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Verifiable MapReduce</h2>

    <p class="text-gray-300">This section describes how Pantry provides verifiability for MapReduce jobs. We begin with a brief review of the standard MapReduce model *[30]</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 5—For verifiable MapReduce, Pantry regards the depicted functions, Mapper and Reducer, as separate computations. The two functions compile to separate constraints, and  <span class="math">\\mathcal{V}</span>  verifies in two batches: one for the mappers and one for the reducers.</p>

    <p class="text-gray-300">A MapReduce job consists of Map and Reduce functions, and input data structured as a list of key-value pairs; the output is a transformed list of key-value pairs. The programmer supplies the implementations of Map and Reduce; Map takes as input a list of key-value pairs and outputs another list of key-value pairs, and Reduce takes as input a list of values associated with a single key and outputs another list of values. The framework runs multiple instances of Map and Reduce as stand-alone processes, called mappers and reducers. The framework gives each mapper a chunk of the input data, shuffles the mappers' output, and supplies it to the reducers; each reducer's output contributes a chunk to the overall output of the job. A centralized module, which is part of the framework, drives the job (by assigning processes to machines, etc.).</p>

    <p class="text-gray-300">Overview of MapReduce in Pantry. The verifier  <span class="math">\\mathcal{V}</span>  is a machine that invokes a MapReduce job (for instance, the desktop machine of a cloud customer). The goal of Pantry's MapReduce is to assure  <span class="math">\\mathcal{V}</span>  that its job starts from the correct input data and executes correctly from there.</p>

    <p class="text-gray-300">The model here will be similar to the standard one outlined above, except that the input and output files will be verifiable blocks (§3): a file will be referenced by a collision-resistant hash, or digest, of its contents (from now on, we use "digest" and "name" interchangeably). In this model, invoking a MapReduce job requires  <span class="math">\\mathcal{V}</span>  to supply a list of digests, one for each input file; call this list  <span class="math">x</span> . Likewise,  <span class="math">\\mathcal{V}</span>  receives as output a list of digests,  <span class="math">y</span> .  <span class="math">\\mathcal{V}</span>  learns of the digests in  <span class="math">x</span>  either from a bootstrapping step (creating the data and keeping track of its digest, say) or as the output of a job; likewise,  <span class="math">\\mathcal{V}</span>  can use the digests in  <span class="math">y</span>  either to download (and verify the integrity of) the actual data or to feed another job. That is, these digests are self-certifying references to the data [33, 52].</p>

    <p class="text-gray-300">Given this model,  <span class="math">\\mathcal{V}</span>  will be guaranteed that the output digests  <span class="math">y</span>  are correct, meaning that the actual input data (the key-value pairs whose digests are  <span class="math">x</span> ), when transformed by  <span class="math">\\mathcal{V}</span> 's desired Map and Reduce functions, results in output data with digests  <span class="math">y</span> . But providing this guarantee requires an application of the verification machinery ( <span class="math">\\S 2 - \\S 3</span> ), which raises a design question: what exactly is the computation to be verified, and which machine(s) implement  <span class="math">\\mathcal{P}</span> ?</p>

    <p class="text-gray-300">Pantry's approach is as follows (we discuss the rationale later). The verifier regards the MapReduce job as two separate batch computations (§2.3), one for the map phase and one for the reduce phase. In these computations, each mapper and reducer is an instance, with a prover. In our design,  <span class="math">\\mathcal{V}</span>  handles an intermediate digest for every (mapper, reducer) pair.</p>

    <p class="text-gray-300">Mechanics. Pantry's MapReduce framework wraps Map and Reduce into functions Mapper and Reducer, which are depicted in Figure 5; the job is executed by multiple instances of each. For verification, Pantry's C-to-constraint compiler transforms these functions into constraints, and then each instance—</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">naive (local)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pantry</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  CPU costs  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V, setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c2·(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zmapper</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CMapper</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  network costs  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c7·(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zmapper</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CMapper</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tmapper: running time of a map instance</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M: # of mappers</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ch</td>

            <td class="px-3 py-2 border-b border-gray-700">: length of a mapper's input</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">: length of a digest</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6—Verification costs in Pantry's MapReduce and naive (local) verification, for the map phase; the reduce phase is similar. The CPU costs largely follow Figure 3; the main difference is that  <span class="math">\\mathcal{V}</span>  now handles only a digest of the inputs.  <span class="math">\\mathcal{P}</span> 's costs are omitted, but the substitutions are similar.</p>

    <p class="text-gray-300">playing the role of the prover—convinces  <span class="math">\\mathcal{V}</span>  that it knows a satisfying assignment to the corresponding constraints (§2.2, step (3)). Execution and verification can be decoupled, but under Zaatar, the complete execution of a phase (map or reduce) must happen before verification of that phase.</p>

    <p class="text-gray-300">We now give more detail, beginning with some notation. Let  <span class="math">M</span>  and  <span class="math">R</span>  be the number of mappers and reducers, and  <span class="math">C_{\\text{Mapper}}</span>  and  <span class="math">C_{\\text{Reducer}}</span>  the constraint representations of Mapper and Reducer. Also, recall that superscripts denote instances in a batch (§2.3).</p>

    <p class="text-gray-300">When the mappers execute, each instance  <span class="math">j \\in \\{1, \\dots, M\\}</span>  gets as its input,  <span class="math">x^{(j)}</span> , the digest of some data. The output of an instance, map_out <span class="math">^{(j)}</span> , is a vector of  <span class="math">R</span>  digests, one for each reducer that this mapper is "feeding"; the framework receives this output and forwards it to  <span class="math">\\mathcal{V}</span> . Verification convinces  <span class="math">\\mathcal{V}</span>  that each mapper  <span class="math">j</span>  knows a satisfying assignment to  <span class="math">C_{\\text{Mapper}}(X = x^{(j)}, Y = \\text{map\\_out}^{(j)})</span> , which establishes for  <span class="math">\\mathcal{V}</span>  that the mapper worked over the correct data, applied Map correctly, partitioned the transformed data over the reducers correctly, and—in outputting map_out <span class="math">^{(j)}</span> —named the transformed data correctly. Note that  <span class="math">\\{ \\text{map\\_out}^{(j)} \\}_{j = \\{1, \\dots, M\\}}</span>  are the  <span class="math">M \\cdot R</span>  intermediate digests mentioned above.</p>

    <p class="text-gray-300">The framework then supplies the inputs to the second phase, by shuffling the digests  <span class="math">\\{map\\_out^{(j)}\\}_{j = \\{1,\\dots ,M\\}}</span>  and regrouping them as  <span class="math">\\{reduce\\_in^{(j)}\\}_{j = \\{1,\\dots ,R\\}}</span> , where each reduce_in  <span class="math">(j)</span>  is a vector of  <span class="math">M</span>  digests, one for each mapper. ( <span class="math">\\mathcal{V}</span>  does this regrouping too, in order to know the reducers' inputs.)</p>

    <p class="text-gray-300">The framework then invokes the reducers, and the output of each reducer  <span class="math">j \\in \\{1, \\dots, R\\}</span>  is a single digest  <span class="math">y^{(j)}</span> . Verification convinces  <span class="math">\\mathcal{V}</span>  that each reducer  <span class="math">j</span>  knows a satisfying assignment to  <span class="math">C_{\\text{Reducer}}(X = \\text{reduce\\_in}^{(j)}, Y = y^{(j)})</span> . This establishes for  <span class="math">\\mathcal{V}</span>  that each reducer worked over the correct  <span class="math">M</span>  blocks, applied Reduce to them correctly, and produced the correct output digests.</p>

    <p class="text-gray-300">Analysis. Figure 6 compares the costs of the map phase under Pantry's MapReduce and the naive approach of verifying a job by downloading the inputs (perhaps checking them against digests) and locally executing the computation. A similar analysis applies to the reduce phase.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Both pre-Pantry and under Pantry, the verifier can save CPU cycles compared to the naive verifier provided that the per-instance verification cost is less than the cost to execute the instance. Pre-Pantry, this condition holds only if  $c_{3} + c_{4} \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) &lt; T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + c_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , implying that using the verification machinery makes sense only if the computation is superlinear in its input size (see Figure 3). Under Pantry, however, the analogous condition holds when  </span>c_{3} + c_{4} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (R + 1) &lt; T_{\\text{mapper}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ch</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , which can hold even when the computation is linear in its input. If this condition holds, then the CPU cross-over point (§2.3) occurs when  </span>M \\geq \\frac{c_{7} \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{\\text{mapper}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\text{Mapper}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{T_{\\text{mapper}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ch</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - c_{3} - c_{4} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot (R + 1)}$ , per Figure 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pantry also saves the verifier network costs. This happens when  $M \\geq \\frac{c_7 \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{\\text{mapper}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\text{Mapper}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ch</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- c_8 - R \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Notice that the floor on  </span>M<span class="math">  is proportional to the setup costs: the higher the setup costs, the more instances are needed to beat naive verification. Also, the floor moves inversely with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ch</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ : the larger the chunk size, the greater</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the expense incurred by the naive verifier in downloading the inputs.</p>

    <p class="text-gray-300">We emphasize that this analysis is predicated on a baseline that is favorable to Pantry. If the baseline were instead local execution and local storage (no remote party at all), then Pantry would never save network costs. However, the analyzed baseline corresponds to common uses of the cloud today: MapReduce jobs execute remotely because their inputs <em>are</em> remote, so downloading and uploading ought to be recognized as a cost. Another basis for comparison is Zaatar and Pinocchio: their verifiers handle all inputs and outputs, and thus cannot ever save network costs.</p>

    <p class="text-gray-300">Summarizing the analysis, a MapReduce application calls for Pantry if (a) verifiability is needed and (b) the computational cost of the job is high (so there is a CPU cross-over point), there is a lot of data (so there is a network cross-over point), or both.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Rationale and limitations.</h4>

    <p class="text-gray-300">Our design reflects awkward aspects of the framework. For example, because of the existence of setup costs (§2.3), we chose to have <span class="math">\\mathcal{V}</span> handle intermediate digests. In more detail, <span class="math">\\mathcal{V}</span> could avoid handling intermediate digests—it could verify the job’s output digests <span class="math">\\{y^{(j)}\\}</span> directly from the input digests <span class="math">\\{x^{(j)}\\}</span>—by verifying a single batch. But each instance would have to encompass constraints for one reducer and <span class="math">M</span> mappers, causing setup costs to be, undesirably, proportional to the <em>aggregate</em> mappers’ (instead of a single mapper’s) work. To further explain our choice, we note that quadratic intermediate state is not inherently disastrous: in standard MapReduce, the framework keeps <span class="math">O(M\\cdot R)</span> state <em>[30]</em>.</p>

    <p class="text-gray-300">Other limitations stem from the constraint model. For example, we eschew a general-purpose partitioning module in the mapper, as it would compile to a large number of constraints, increasing costs. Instead, the programmer must partition the output of Map into <span class="math">R</span> chunks, and must similarly read from <span class="math">M</span> inputs in Reduce—tasks that are hidden in standard MapReduce. Moreover, Map and Reduce face the expressiveness restrictions described earlier (§2.4); one consequence is that each mapper’s chunk size must be identical and fixed at compile time, and likewise with the reducers.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5 Verifiable data structures</h2>

    <p class="text-gray-300">This section describes Pantry’s higher-level storage abstractions: RAM, a searchable tree, and a simple database. As with MapReduce, we want to implement the abstractions as data structures in a subset of C, augmented with PutBlock and GetBlock (§3). To do so, we apply the technique of embedding in data blocks the names (or references or hashes—these concepts are equivalent here) of other blocks <em>[21, 33, 52, 54, 58]</em> (see also §9). In the resulting structure, the hashes are links—or pointers that authenticate what they point to. The starting hash (for instance, of the root of a tree) can authenticate any value in the structure; we review how this is done below. We can then incorporate the resulting abstractions into some larger C program, compile that program to constraints, and apply the argument step (§2.2) to those constraints.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 Verifiable RAM</h3>

    <p class="text-gray-300">Pantry’s verifiable RAM abstraction enables random access to contiguously-addressable, fixed-size memory cells. It exposes the following interface:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>value = Load(address, digest);
new_digest = Store(address, value, digest);</p>
    </blockquote>

    <p class="text-gray-300">Pseudocode for the implementation is in Figure 7.</p>

    <p class="text-gray-300">The high-level idea behind this pseudocode is that the digest commits to the full state of memory <em>[21, 58]</em>, in a way that we explain shortly. Then, a Load guarantees that the claim “<em>address</em> contains <em>value</em>” is consistent with <em>digest</em>. For Store, the guarantee is that <em>new_digest</em> captures the same memory state that <em>digest</em> does with the exception that <em>address</em> now holds <em>value</em>.</p>

    <p class="text-gray-300">Load(address  <span class="math">a</span> , digest  <span class="math">d</span> ):</p>

    <p class="text-gray-300"><span class="math">\\ell \\gets \\lceil \\log N\\rceil</span></p>

    <p class="text-gray-300"><span class="math">h\\gets d</span></p>

    <p class="text-gray-300">for  <span class="math">i = 1</span>  to  <span class="math">\\ell</span></p>

    <p class="text-gray-300">node  <span class="math">\\leftarrow</span>  GetBlock(h)</p>

    <p class="text-gray-300"><span class="math">x\\gets</span>  ith bit of  <span class="math">a</span></p>

    <p class="text-gray-300">if  <span class="math">x = 0</span></p>

    <p class="text-gray-300"><span class="math">h\\gets</span>  node.left</p>

    <p class="text-gray-300">else:</p>

    <p class="text-gray-300"><span class="math">h\\gets</span>  node.right</p>

    <p class="text-gray-300">node  <span class="math">\\leftarrow</span>  GetBlock(h)</p>

    <p class="text-gray-300">return node.value</p>

    <p class="text-gray-300">Store(address  <span class="math">a</span> , value  <span class="math">\\nu</span> , digest  <span class="math">d</span> ):</p>

    <p class="text-gray-300">path  <span class="math">\\leftarrow</span>  LoadPath(a,d)</p>

    <p class="text-gray-300"><span class="math">\\ell \\gets \\lceil \\log N\\rceil</span></p>

    <p class="text-gray-300">node  <span class="math">\\leftarrow</span>  path[ell]</p>

    <p class="text-gray-300">node.value  <span class="math">\\leftarrow v</span></p>

    <p class="text-gray-300"><span class="math">d^{\\prime}\\gets</span>  PutBlock(node)</p>

    <p class="text-gray-300">for  <span class="math">i = \\ell</span>  to 1:</p>

    <p class="text-gray-300">node  <span class="math">\\leftarrow</span>  path[i-1]</p>

    <p class="text-gray-300"><span class="math">x\\gets</span>  ith bit of  <span class="math">a</span></p>

    <p class="text-gray-300">if  <span class="math">x = 0</span></p>

    <p class="text-gray-300">node.left  <span class="math">\\leftarrow d^{\\prime}</span></p>

    <p class="text-gray-300">else:</p>

    <p class="text-gray-300">node.right  <span class="math">\\leftarrow d^{\\prime}</span></p>

    <p class="text-gray-300"><span class="math">d^{\\prime}\\gets</span>  PutBlock(node)</p>

    <p class="text-gray-300">return  <span class="math">d^{\\prime}</span></p>

    <p class="text-gray-300">Figure 7—RAM operations use verifiable blocks in a Merkle tree [21, 58].  <span class="math">N</span>  is the number of addresses in the memory.</p>

    <p class="text-gray-300">To explain how a digest  <span class="math">d</span>  can commit to memory, we briefly review Merkle trees [21, 58]. Every node is named by a collision-resistant hash (denoted  <span class="math">H</span> ) of its contents. An interior node's contents are the names (or hashes) of the node's left and right children. Each leaf node corresponds to a memory address, and contains the value currently held at the memory address. Then, the digest  <span class="math">d</span>  is the hash of the root node's contents. Indeed, if entity  <span class="math">A</span>  holds a digest  <span class="math">d</span> , and entity  <span class="math">B</span>  claims "the value at address  <span class="math">a</span>  is  <span class="math">\\nu</span> ", then  <span class="math">B</span>  could argue that claim to  <span class="math">A</span>  by exhibiting a witness-path: the purported name of  <span class="math">a</span> 's sibling, the purported name of their parent, and so on, to the root.  <span class="math">A</span>  could then check that the hash relationships hold and match  <span class="math">d</span> . For  <span class="math">B</span>  to succeed in a spurious claim, it would have to identify a collision in  <span class="math">H</span> .</p>

    <p class="text-gray-300">The pseudocode in Figure 7 is simply applying this idea: the verifiable blocks in Section 3 provide the required names-are-hashes referencing scheme, and the GetBlock invocations compile to constraints that force  <span class="math">\\mathcal{P}</span>  to exhibit a witness-path. Thus, using  <span class="math">\\mathcal{C}_{\\mathrm{Load}}</span>  to denote the constraints to which Load compiles,  <span class="math">\\mathcal{C}_{\\mathrm{Load}}(X = (a,d),Y = \\nu)</span>  can be satisfied only if the digest  <span class="math">d</span>  is consistent with address  <span class="math">a</span>  holding value  <span class="math">\\nu</span> , which is the guarantee that Load is supposed to be providing.</p>

    <p class="text-gray-300">How does  <span class="math">\\mathcal{P}</span>  identify a path through the tree? In principle, it could recompute the internal nodes on demand from the leaves. But for efficiency, our implementation caches the internal nodes to avoid recomputation.</p>

    <p class="text-gray-300">To invoke Load or Store, the program must begin with a digest; in Pantry,  <span class="math">\\mathcal{V}</span>  supplies this digest as part of the input to the computation. One way to bootstrap this is for  <span class="math">\\mathcal{V}</span>  to first create a small amount of state locally, then compute the digest directly, then send the data to  <span class="math">\\mathcal{P}</span> , and then use the verification machinery to track the changes in the digest. Of course, this requires that a computation's output include the new digest.</p>

    <p class="text-gray-300">This brings us to the implementation of Store, which takes as input one digest and returns a digest of the new state. Store begins by placing in local variables the contents of the nodes along the required path (LoadPath in Figure 7 is similar to Load and involves calls to GetBlock); this ensures continuity between the old state and the new digest. Store then updates this path by creating new verifiable blocks, starting with the block for address  <span class="math">a</span>  (which is a new verifiable block that contains a new value), to that block's parent, and so on, up to the root. Let  <span class="math">\\mathcal{C}_{\\mathrm{Store}}</span>  denote the constraints that Store compiles to. To satisfy  <span class="math">\\mathcal{C}_{\\mathrm{Store}}(X = (a,v,d),Y = d&#x27;)</span> ,  <span class="math">\\mathcal{P}</span>  must (1) exhibit a path through the tree, to  <span class="math">a</span> , that is consistent with  <span class="math">d</span> , and (2) compute a new digest that is consistent with the old path and with the memory update. Thus, the constraints enforce the guarantee that Store promises.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Costs.</h5>

    <p class="text-gray-300">We briefly describe the blowup from the constraint representation; Sections 2.2 and 4 show how this blowup feeds into the costs of <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span>. Letting <span class="math">N</span> denote the number of memory addresses, a Load or Store compiles to <span class="math">O(\\log N)</span> constraints and variables, with the constant mostly determined by the constraint representation of <span class="math">H</span> inside GetBlock and PutBlock (§3.2).</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.2 Search tree</h3>

    <p class="text-gray-300">We now consider a searchable tree; we wish to support efficient range searches over any keys for which the less-than comparison is defined. Specifically, we wish to support the following API:</p>

    <p class="text-gray-300">values = FindEquals(key, digest)</p>

    <p class="text-gray-300">values = FindRange(key_start, key_end, digest)</p>

    <p class="text-gray-300">new_digest = Insert(key, value, digest)</p>

    <p class="text-gray-300">new_digest = Remove(key, digest)</p>

    <p class="text-gray-300">To implement this interface, a first cut approach would be to use the general-purpose RAM abstraction (§5.1) to build a binary tree or B-tree out of pointers (memory addresses). Unfortunately, this approach is more expensive than we would like: since every pointer access in RAM costs <span class="math">O(\\log N)</span>, a search in a balanced tree of <span class="math">m</span> elements would cost <span class="math">O((\\log N)\\cdot(\\log m))</span>. Instead, we use an alternative construction, which illustrates a strategy applicable to a wide class of data structures.</p>

    <p class="text-gray-300">To get the per-operation cost down to <span class="math">O(\\log m)</span>, we build a searchable Merkle tree (this is different from the tree in §5.1). Each node in the tree contains a key, one or more values corresponding to that key, and pointers to (that is, hashes of) its children. The nodes are in sorted order, and the tree is a balanced (AVL) tree, so operations take time that is logarithmic in the number of keys stored.</p>

    <p class="text-gray-300">A search operation (FindEquals, FindRange) descends the tree, via a series of GetBlock calls. An update operation (Insert, Remove) first descends the tree to identify the node where the operation will be performed; then modifies that node (via PutBlock, thereby giving it a new name); and then updates the nodes along the path to the root (again via PutBlock), resulting in a new digest. As with RAM, these operations are expressed in C and compile to constraints; if <span class="math">\\mathcal{P}</span> satisfies the resulting constraints then, unless it has identified a collision in <span class="math">H</span>, it is returning the correct state (in the case of searches) and the correct digests (in the case of updates).</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.3 Verifiable database queries</h3>

    <p class="text-gray-300">The data structures described above enable us to implement a simple database that supports verifiable queries.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> specifies queries in a primitive SQL-like language, which supports the following non-transactional queries on single tables: select (the where predicates must refer to a single column), insert, update, delete, create, and drop. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> convert each query into C code that invokes the APIs from Sections 3.2 and 5.2, and is then compiled into constraints.</p>

    <p class="text-gray-300">The database itself has a simple design. Each row of every table is stored as a verifiable block, accessed through GetBlock/PutBlock (§3). These blocks are pointed to by one or more indexes, and there is a separate index for each column that the author of the computation wants to be searchable. Indexes are implemented as verifiable search trees (§5.2), and database queries are converted into a series of calls to the trees’ FindEquals, FindRange, Insert, and Remove operations.</p>

    <p class="text-gray-300">Because this database uses verifiable data structures and the code is compiled into constraints, we get strong integrity guarantees—with little programmer effort beyond implementing the data structures and queries.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.4 Compromises and limitations</h3>

    <p class="text-gray-300">A key compromise is that efficiency sometimes requires not using RAM and instead constructing data structures directly from verifiable pointers (§5.2, §5.3). One consequence is that the implementer of these</p>

    <p class="text-gray-300">data structures is directly exposed to the clumsiness of the constraint model (§2.4); for example, if the data structure implementation indexes into a small array at a variable offset, the code must loop through the set of possible indexes.</p>

    <p class="text-gray-300">The constraint model imposes several other limitations. First, because traversal loops have fixed bounds, data structures have a static size (a fixed depth for trees, etc.), regardless of the number of elements that they logically contain. (However, empty cells and nodes need not consume memory or disk.) For similar reasons, the number of results returned by the search API must be fixed at compile time. Third, as every operation on a data structure is compiled into a fixed number of constraints, <span class="math">\\mathcal{P}</span>’s running time to perform the operation is largely determined by the data structure’s static size.</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Private prover state</h2>

    <p class="text-gray-300">Pantry enables applications where the prover’s state is private. For example, the prover holds photographs (e.g., of suspects), the verifier (e.g., a surveillance camera) submits a photograph, and the prover indicates if there is a match. Using Pantry, the client is assured that the response is correct, but no information about the prover’s database leaks (beyond what the output implies).</p>

    <p class="text-gray-300">Pinocchio’s zero-knowledge (ZK) variant <em>[36, 65]</em> provides most of the solution. Here, step (3) of Section 2.2 persuades <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{P}</span> has a satisfying assignment to a set of constraints (as usual), but <span class="math">\\mathcal{P}</span> cryptographically hides the actual satisfying assignment. Since the contents of <span class="math">\\mathcal{P}</span>’s state appear in the satisfying assignment (§3), the ZK variant effectively hides <span class="math">\\mathcal{P}</span>’s state—almost. The wrinkle is that, under Pantry as so far described, <span class="math">\\mathcal{V}</span> would begin with a cryptographic digest of <span class="math">\\mathcal{P}</span>’s state (§5), and this digest itself leaks information (<span class="math">\\mathcal{V}</span> could conceivably guess <span class="math">\\mathcal{P}</span>’s state and use a digest to check the guess).</p>

    <p class="text-gray-300">Thus, we assume that <span class="math">\\mathcal{V}</span> begins with a cryptographic <em>commitment</em> <em>[39, §4.4.1]</em> to the prover’s state. A commitment binds the prover to its state in a way that permits verifiable queries against that state (as with the previously described digests) but also hides the state. Then, the computation to be verified takes as input a commitment (not a digest), begins by querying for values and checking that they are consistent with the commitment (as with digests), and then uses those values in the rest of the computation. To summarize, the commitment hides the prover’s beginning state from <span class="math">\\mathcal{V}</span>, and the ZK machinery hides the prover’s execution.</p>

    <p class="text-gray-300">To realize this approach, we want a commitment primitive that has a reasonably efficient representation in constraints. As a compromise, we instantiate a simple scheme using HMAC-SHA256 <em>[13]</em> (see Appendix C for details). Relative to the protocol of Pedersen <em>[67]</em>, our scheme makes a stronger cryptographic assumption but saves an order of magnitude in constraint size. Of course, this scheme uses SHA-256, so it is more expensive for us than Ajtai’s function (§3.2), but the expense is incurred only once per execution (§8.1).</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Applications.</h4>

    <p class="text-gray-300">We build (§7) and evaluate (§8) several applications of the machinery described above. The first is <em>face matching</em>, which implements the example at the start of this section. This example is inspired by previous work <em>[63]</em>, but that work provides privacy to both parties and verifiability to neither. The second is <em>tolling</em>; the prover is a car, the verifier is a toll collector, and the verifier checks the prover’s claim about what it owes for the billing period. This example is inspired by <em>[68]</em>, which requires a custom protocol, while we require only a simple C program (§7). The third application is <em>regression analysis</em> (again inspired by prior work that requires a custom protocol <em>[62]</em>); the prover holds a set of patient files, the verifier is an analyst seeking to fit a model to this data, and the computation returns the best-fit parameters. The details of our applications are in Appendix D.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7 Implementation details</p>

    <p class="text-gray-300">The Pantry implementation modifies the Ginger-Zaatar compiler <em>[24, 71, 73]</em>. The base compiler first transforms programs written in a high-level language (§2.4) into a list of assignment statements, producing a constraint or pseudoconstraint for each statement. The pseudoconstraints abstract operations that require multiple constraints (inequality comparisons, bitwise operations, etc.). Next, the compiler expands the pseudoconstraints and annotates the results (§2.2). The verifier and prover each consist of computation-independent routines that take a list of annotated constraints as input. <span class="math">\\mathcal{P}</span>’s routines solve the constraints and use the resulting satisfying assignment to respond to queries; <span class="math">\\mathcal{V}</span>’s routine selects queries according to the argument protocol and tests the replies (§2.2).</p>

    <p class="text-gray-300">Pantry adds several conveniences to the base compiler. Following Pinocchio <em>[65]</em>, the Pantry compiler accepts a subset of C (§2.4). More significantly, the compiler targets the Pinocchio and the Zaatar encodings, with a unified code base. The main work here was implementing Pinocchio’s pairing-based cryptography, for which we use a public library <em>[2, 17]</em>.</p>

    <p class="text-gray-300">To implement GetBlock and PutBlock (§3), Pantry includes new pseudoconstraints, which expand to <span class="math">\\mathcal{C}_{H^{-1}}</span> and <span class="math">\\mathcal{C}_{H}</span>, respectively. The associated annotations tell <span class="math">\\mathcal{P}</span> how to interact with storage <span class="math">S</span> (see Figure 4); we implement <span class="math">S</span> using the LevelDB key-value store <em>[3]</em>.</p>

    <p class="text-gray-300">The <span class="math">\\mathcal{C}_{H^{-1}}</span> and <span class="math">\\mathcal{C}_{H}</span> constraints implement <span class="math">H</span> as (a variable-length version of) the Ajtai <em>[4, 40]</em> hash function. Using the notation in <em>[40]</em>, this function hashes <span class="math">m</span> bits into <span class="math">n\\cdot\\log q</span> bits. Based on the analysis in <em>[59]</em>, we set these parameters as <span class="math">m</span>=7296, <span class="math">n</span>=64, and <span class="math">q</span>=2^{19}—resulting in a digest of 1216 bits—to achieve at least 180 bits of security. To support variable-length input, we use a prefix-free variant of the Merkle-Damgård transform <em>[49, Ch. 4.6.4]</em> that prepends the input with its length <em>[29]</em>.</p>

    <p class="text-gray-300">To implement GetBlock and PutBlock, we added to the compiler pipeline 2200 lines of Java (for parsing Pantry’s subset-of-C), 2100 lines of Go and 360 lines of Python (for expanding pseudoconstraints into constraints), and 300 lines of C++ (in the prover’s constraint solving module). The MapReduce framework (§4) requires 1500 lines of C++. The verifiable data structures (§5.1–§5.2) require 400 lines in Pantry’s subset-of-C. The main component in the database application (§5.3) is a query-to-C translator, which we implement with 2000 lines of Java, on top of Cassandra’s CQL parser <em>[1]</em>. Our private state applications (§6) are 60 lines for face matching, 80 lines for tolling, and 143 lines for regression analysis.</p>

    <h2 id="sec-24" class="text-2xl font-bold">8 Evaluation</h2>

    <p class="text-gray-300">Our evaluation answers two questions: (1) What are the overheads for the prover and verifier? and (2) What does the verifier gain from Pantry, versus alternatives? Given Pantry’s goals (§1–§2), these alternatives must be general-purpose and not make restrictive hypotheses about failure classes. This often means comparing to naive verifiers (§2.3). However, we would be the first to admit that tailored protocols (of the kind cited in the introduction; an example is <em>[76]</em>) or replication are likely to far outperform Pantry.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Applications and setup.</h4>

    <p class="text-gray-300">We experiment with a set of sample applications, listed in Figure 8. Additional parameters (for the cryptographic primitives in Zaatar and Pinocchio, etc.) are described in Appendix D.</p>

    <p class="text-gray-300">Our experiments use a local cluster of machines, each running Linux on an Intel Xeon processor E5 2680 2.7 GHz with 32GB of RAM and a 250GB 7.5K RPM SATA disk; they are connected by a 56 Gb/s InfiniBand network. Additionally, each machine has an access to a 14PB Lustre 2.1.3 parallel file system.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">8.1 Overhead and its sources</h3>

    <p class="text-gray-300">Pantry’s costs boil down to three sources of overhead:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The techniques of untrusted storage;</li>

      <li>The constraint representation of computations; and</li>

      <li>The argument step.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">computation (Ψ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(·)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dot product of two length-m vectors</td>

            <td class="px-3 py-2 border-b border-gray-700">MapReduce (Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">search m nucleotides for length-d substring</td>

            <td class="px-3 py-2 border-b border-gray-700">MapReduce (Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">m·d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nearest neigh. search of m length-d vectors</td>

            <td class="px-3 py-2 border-b border-gray-700">MapReduce (Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">m·d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">covariance matrix for m samples of dim. d</td>

            <td class="px-3 py-2 border-b border-gray-700">MapReduce (Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">m·d2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SELECT rows from a table with m rows</td>

            <td class="px-3 py-2 border-b border-gray-700">Database (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">log m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">INSERT a row into a table with m rows</td>

            <td class="px-3 py-2 border-b border-gray-700">Database (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">log m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">UPDATE a row in a table with m rows</td>

            <td class="px-3 py-2 border-b border-gray-700">Database (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">log m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">match against m 900-bit face fingerprints</td>

            <td class="px-3 py-2 border-b border-gray-700">Private state (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">compute toll bill for a maximum of m tolls</td>

            <td class="px-3 py-2 border-b border-gray-700">Private state (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">fit a linear model to m-many d-dim. records</td>

            <td class="px-3 py-2 border-b border-gray-700">Private state (P)</td>

            <td class="px-3 py-2 border-b border-gray-700">m·d2+d3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8—Sample applications in our experiments. The MapReduce applications uses Zaatar (Z); the other two categories use Pinocchio (P). In the MapReduce applications ( <span class="math">\\S 4</span> ), Map and Reduce are roughly 60 lines, combined. The DB queries are expressed in Pantry's query framework ( <span class="math">\\S 5.3</span> ,  <span class="math">\\S 7</span> ). The private state applications (details and code size) are described in  <span class="math">\\S 6</span>  and  <span class="math">\\S 7</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">number of constraints (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GetBlock or PutBlock; 1KB blocks</td>

            <td class="px-3 py-2 border-b border-gray-700">13,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GetBlock or PutBlock; 4KB blocks</td>

            <td class="px-3 py-2 border-b border-gray-700">47,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GetBlock or PutBlock; 16KB blocks</td>

            <td class="px-3 py-2 border-b border-gray-700">180,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Load (Store); 220 memory cells</td>

            <td class="px-3 py-2 border-b border-gray-700">93,000 (190,000)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Load (Store); 230 memory cells</td>

            <td class="px-3 py-2 border-b border-gray-700">140,000 (280,000)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 9—Cost of Pantry's storage primitives, in constraints (to the nearest 1000), for varying block size or memory size; the number of variables  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  is similar (not shown). PutBlock is the same as GetBlock ( </span>\\S 3.2<span class="math"> ). Store is shown in the same row as Load, and is twice as expensive ( </span>\\S 5.1$ ); the memory cell size here is 64 bits, and the intermediate Merkle nodes are 2432 bits. The costs scale linearly (in the block size) for GetBlock and logarithmically (in the memory size) for Load and Store.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Below, we investigate each of these overheads.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assess the cost of T1 in terms of the number of constraints and variables to which Pantry's primitives compile. (We will focus on the number of constraints,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , as the number of variables,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , scales linearly in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .) We use this metric because constraints are the computational model (and later, we will express actual running times in terms of constraint set size). Each constraint corresponds to a "register operation" (arithmetic, assignment, etc.), which provides an interpretation of our metric.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 9 shows the number of constraints to which GetBlock and PutBlock (§3) compile, varying the size of the block. The cost is ≈12 constraints per byte, or 50 constraints per 32-bit word; thus, in this model, reading a number is 50 times more expensive than adding—a ratio superior to the analogous comparison between hard disks and a CPU's register operations. On the other hand, disks benefit from sequential access whereas the costs of GetBlock and PutBlock scale linearly. Moreover, constraints will translate into active CPU costs (as we will cover below), whereas real disks leverage DMA.</p>

    <p class="text-gray-300">The preceding discussion presumes that each data item has its own name, or hash. If instead we want to give the programmer contiguously addressable random access memory (e.g., for a program's heap), we must use the RAM abstraction ( <span class="math">\\S 5.1</span> ). Unfortunately, as shown in Figure 9, a verifiable Load costs 93,000 constraints to read 64 bits of memory; the ratio here is not close to the analogous memory-vs-register comparison. Thus, GetBlock and PutBlock are best used to implement data structures built directly from verifiable blocks ( <span class="math">\\S 5.2 - \\S 5.3</span> ); as indicated above, the costs are manageable if the programmer interacts with them as if they lived on disk.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">computation (Ψ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">input size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">baseline</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(millions)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover (P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">③ verifier (V)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">storage</td>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">② solve</td>

            <td class="px-3 py-2 border-b border-gray-700">③ argue</td>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">setup</td>

            <td class="px-3 py-2 border-b border-gray-700">per-instance</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dot product</td>

            <td class="px-3 py-2 border-b border-gray-700">m=20k</td>

            <td class="px-3 py-2 border-b border-gray-700">10 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">4.5 min</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2 min</td>

            <td class="px-3 py-2 border-b border-gray-700">13 min</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">380 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nucleotide substr. search</td>

            <td class="px-3 py-2 border-b border-gray-700">m=600k, d=4</td>

            <td class="px-3 py-2 border-b border-gray-700">13 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">18 min</td>

            <td class="px-3 py-2 border-b border-gray-700">23 min</td>

            <td class="px-3 py-2 border-b border-gray-700">9.9 min</td>

            <td class="px-3 py-2 border-b border-gray-700">390 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nearest neigh. search</td>

            <td class="px-3 py-2 border-b border-gray-700">m=20k, d=10</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5 min</td>

            <td class="px-3 py-2 border-b border-gray-700">7 min</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5 min</td>

            <td class="px-3 py-2 border-b border-gray-700">4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">380 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">covariance matrix</td>

            <td class="px-3 py-2 border-b border-gray-700">m=2.5k, d=10</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3 min</td>

            <td class="px-3 py-2 border-b border-gray-700">380 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SELECT query</td>

            <td class="px-3 py-2 border-b border-gray-700">m=227 rows</td>

            <td class="px-3 py-2 border-b border-gray-700">90 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5 min</td>

            <td class="px-3 py-2 border-b border-gray-700">17 min</td>

            <td class="px-3 py-2 border-b border-gray-700">20 min</td>

            <td class="px-3 py-2 border-b border-gray-700">18 min</td>

            <td class="px-3 py-2 border-b border-gray-700">6.9 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">INSERT query</td>

            <td class="px-3 py-2 border-b border-gray-700">m=220 rows</td>

            <td class="px-3 py-2 border-b border-gray-700">89 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.3 min</td>

            <td class="px-3 py-2 border-b border-gray-700">31 min</td>

            <td class="px-3 py-2 border-b border-gray-700">37 min</td>

            <td class="px-3 py-2 border-b border-gray-700">34 min</td>

            <td class="px-3 py-2 border-b border-gray-700">13 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">UPDATE query</td>

            <td class="px-3 py-2 border-b border-gray-700">m=220 rows</td>

            <td class="px-3 py-2 border-b border-gray-700">64 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.4 min</td>

            <td class="px-3 py-2 border-b border-gray-700">31 min</td>

            <td class="px-3 py-2 border-b border-gray-700">37 min</td>

            <td class="px-3 py-2 border-b border-gray-700">34 min</td>

            <td class="px-3 py-2 border-b border-gray-700">14 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">face matching</td>

            <td class="px-3 py-2 border-b border-gray-700">m=128</td>

            <td class="px-3 py-2 border-b border-gray-700">100 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7*</td>

            <td class="px-3 py-2 border-b border-gray-700">27 s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.8 min</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2 min</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5 min</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">rolling</td>

            <td class="px-3 py-2 border-b border-gray-700">m=512</td>

            <td class="px-3 py-2 border-b border-gray-700">6.7 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5*</td>

            <td class="px-3 py-2 border-b border-gray-700">9.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.1 min</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3 min</td>

            <td class="px-3 py-2 border-b border-gray-700">5.2 min</td>

            <td class="px-3 py-2 border-b border-gray-700">6.2 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">regression analysis</td>

            <td class="px-3 py-2 border-b border-gray-700">m=1024, d=8</td>

            <td class="px-3 py-2 border-b border-gray-700">30 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7*</td>

            <td class="px-3 py-2 border-b border-gray-700">50 s</td>

            <td class="px-3 py-2 border-b border-gray-700">8.2 min</td>

            <td class="px-3 py-2 border-b border-gray-700">9.1 min</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7 min</td>

            <td class="px-3 py-2 border-b border-gray-700">6.2 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">*Includes 250k constraints for commitment (§6)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 10—Overheads in our sample applications at sample input sizes; for the four MapReduce applications, only the map phase is included. The input size represents a single instance. The baseline column represents the execution of a normally compiled C program. For MapReduce, the baseline is the naive verifier (§4), including a SHA-256 digest check for data integrity (§4); for the database queries, the baseline is a MySQL query; and for the private state apps, the baseline is normal execution (no verifiability). The quantity  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is not depicted but is roughly the same as  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  for each sample application. The remaining columns depict the running times (for a single instance; no amortization) of steps (2) and (3), as defined in §2.2; circled numbers refer to these steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Even so, storage constraints contribute heavily to the total constraint set size in our applications; the weight is clear from the two columns labeled  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  in Figure 10, which displays many of Pantry's costs for our sample experiments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This brings us to the next source of overhead: the fact that there are constraints (T2). Indeed, the costs of step (2) are due to the constraint representation. The final source of overhead is the argument step (T3), which—together with T2—determines the cost of step (3). We consider steps (2) and (3) in turn.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraint solving (step (2), §2.2) is a cost for  <span class="math">\\mathcal{P}</span> . We compute the ratio of solving time (Figure 10, the "solve" column) to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for each of our sample applications. This ratio ranges from 20 to  </span>160~\\mu \\mathrm{s}<span class="math">  per constraint, where tolling has the smallest ratio and UPDATE query has the largest. The computations with the largest ratios are those with the highest proportion of GetBlock and PutBlock calls: &quot;solving&quot; these requires computing the Ajtai function ( </span>\\S 3.2$ ), which invokes many large integer arithmetic operations. (Another source of overhead here is that GetBlock / PutBlock operations incur I/O costs associated with accessing the block store.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Arguing (step (3), §2.2) induces costs for  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> , which are depicted for our measured applications in Figure 10 (the columns labeled ③). These costs are largely determined by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , as indicated by the models given earlier (Figures 3 and 6). In these models, the largest constants are  </span>c_{2}, c_{3}, c_{5}<span class="math">  (representing cryptographic operations), and are on the order of  </span>100\\mu s<span class="math"> . Note that these models are chosen for simplicity; their predictions are within a factor of two of empirical results. The primary sources of variation are the structure of the constraints (treated in prior work [71, §4]) and the relative number of bitwise constraints (small values reduce the costs of some of the cryptographic steps). A model that is more faithful (but more involved) is in Appendix E, which also quantifies the constants  </span>\\{c_{i}\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The aforementioned costs can be understood by comparing to the cost of simply executing the computation (Figure 10, the "baseline" column). Both  <span class="math">\\mathcal{V}</span> 's setup work and  <span class="math">\\mathcal{P}</span> 's runtime work are orders of magnitude more than this baseline, in our sample applications. On top of these costs, the largest experiments (e.g., nucleotide substring search with  <span class="math">m = 600\\mathrm{k}</span> ,  <span class="math">d = 4</span> ) use roughly  <span class="math">75\\%</span>  of the available RAM in our machines (in the setup phase for  <span class="math">\\mathcal{V}</span>  and per-instance for  <span class="math">\\mathcal{P}</span> ).</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 11—The verifier's CPU and network costs (extrapolated) as a function of job size for the nucleotide substring application in Figures 8 and 10 (each mapper gets a chunk of 600k nucleotides; one reducer is allocated per ten mappers). All y-intercepts (fixed costs) and slopes (per-instance costs) are empirically determined, based on experiments that exhibit the depicted scaling with hundreds of machines. In the CPU (resp., network) graph, Pantry's y-intercept is roughly ten minutes (resp., 2.3 GB); meanwhile, the baseline's slope is tens of milliseconds per chunk (resp., 146.5 KB per chunk). Thus, 40,000–50,000 chunks are required for  <span class="math">\\nu</span>  to break even, corresponding to 24–30 billion nucleotides.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">Amidst the many appalling overheads in Figure 10, there is actually some encouraging news: the per-instance CPU costs for  <span class="math">\\nu</span>  are sometimes less than local execution (compare the "per-instance" and "baseline" columns). And though it is not depicted, an analogous thing happens for network costs. Given enough instances, then, the Pantry verifier could save resources relative to the naive verifier ( <span class="math">\\S 2.3</span> ). We investigate these and other benefits by taking a closer look at some of our sample applications.</p>

    <p class="text-gray-300">MapReduce. For the MapReduce examples, we want to determine the cross-over points (§2.3, §4) for CPU and network. We will focus on the nucleotide substring search example; results for the other applications are similar.</p>

    <p class="text-gray-300">We experiment within the limits of our testbed, and use the resulting data to extrapolate. A work unit will be 10 mappers (each with a chunk size of 600k nucleotides, per Figure 10) and one reducer; let  <span class="math">N</span>  denote the total job size, in number of input nucleotides. We experiment with  <span class="math">N = 6</span>  million (one work unit, 10 machines),  <span class="math">N = 60</span>  million (ten work units, 100 machines), and  <span class="math">N = 1.2</span>  billion (200 work units, 250 machines, each machine executing multiple workers sequentially). Across these (and smaller-scale) experiments, we observe little variation (std. deviations are within  <span class="math">10\\%</span>  of means, scaling is linear, etc.).</p>

    <p class="text-gray-300">Figure 11 reports the extrapolated resource costs for  <span class="math">\\nu</span> ; the CPU (resp., network) cross-over point is 29 billion nucleotides, or 48,340 mappers (resp., 24 billion nucleotides, or 40,000 mappers). While the chunk size is tiny—reflecting overheads ( <span class="math">\\S 8.1</span> )—the results are nevertheless encouraging. First, the baseline is stiff competition: it is linear-time, it runs as optimized machine code, and it uses SHA-256 (not Ajtai) for data integrity. Second, Pantry's  <span class="math">\\nu</span>  beats this baseline at a job size that is plausible: the human genome is roughly 3 billion nucleotides, so the cross-over point is  <span class="math">\\approx 10</span>  such genomes.</p>

    <p class="text-gray-300">DB queries. This class of applications has an additional overhead: storage at the prover, for the hash trees (§5.2). Below, we assess that cost, and ask about Pantry's ability to save resources for  <span class="math">\\nu</span> . What should the baseline be? In Figure 10, we present the running time of MySQL, which helps us gauge the prover's overhead. However, for a naive verifier to benefit from MySQL's optimized query execution while achieving verifiability, it would have to download the entire database and execute the query itself.</p>

    <p class="text-gray-300">Instead, our baseline will be reasonably network-efficient and avoid two sources of overhead in Pantry: constraints and the argument step. We assume a server that implements a hash-based block store [33, 52] (akin to the map  <span class="math">S</span>  in §3.1) and a verifier that runs the computation natively; where the program calls GetBlock and PutBlock, the verifier issues an RPC to the server. Since the computation is run natively rather than in constraints,  <span class="math">H</span>  is SHA-256 (§3.2). We have not yet built this alternative, so we estimate its network costs; we can do this since queries are highly constrained (§2.4, §5.4).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pantry</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block store (est.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  network costs  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup, kept as storage (argue step)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">430 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 MB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per-instance (input, output)</td>

            <td class="px-3 py-2 border-b border-gray-700">624 bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">620 bytes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  storage costs  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">data</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11.5 GB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11.5 GB</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 12—Resource costs of a SELECT query, under Pantry and estimates for an alternative based on an untrusted block store. The table has  <span class="math">2^{27}</span>  rows, each holding 92 bytes in 12 columns; the query allows 5 matching rows (§5.3, §5.4).</p>

    <p class="text-gray-300">Figure 12 depicts the comparison, for a SELECT query. This table indicates, first, that our implementation needs some work: the metadata is far larger than the data (for both Pantry and the alternative) due in part to unoptimized parameter choices (number of indexes, branching factor, etc.). Second, the effect of the size of Ajtai digests (versus SHA-256) is apparent in the metadata row. Nevertheless, despite these limitations, the Pantry verifier can amortize its network costs in the setup phase (because it does not incur the network cost of handling the verifiable blocks themselves); for this computation, the network cross-over point is 55,000 instances.</p>

    <p class="text-gray-300">Private state. For these applications, we do not ask about cross-over points because  <span class="math">\\mathcal{V}</span>  cannot naively re-execute the computation. Instead, we just report the costs, for our sample application of tolling; costs for the others are similar. The CPU costs are in Figure 10; the storage and network resources are given below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">private state</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5 KB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">network (setup) and storage (ongoing)</td>

            <td class="px-3 py-2 border-b border-gray-700">170 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">network (per-instance), for inputs/outputs</td>

            <td class="px-3 py-2 border-b border-gray-700">1 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">network (per-instance), for argument step</td>

            <td class="px-3 py-2 border-b border-gray-700">288 bytes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The storage overhead here is proportional to the size of the private state; the reason is as follows. The storage overhead reflects setup costs (see above), setup costs are proportional to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (see Figures 3 and 6),  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  include terms for GetBlock&#x27;s input ( </span>\\S 3.2<span class="math"> ), and GetBlock&#x27;s input is all of the state because there is no hash tree structure ( </span>\\S 5<span class="math"> ). Although the constant of proportionality is high (due to the argument step), the absolute quantities are not necessarily alarming: the tolling application does not involve much state, and an overhead of several hundred megabytes could fit comfortably on a mobile phone. Moreover, the per-instance network costs are very low, owing to Pinocchio&#x27;s machinery ( </span>\\S 2.2 - \\S 2.3$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Although verifiable computation has a decades-long history (see [65, 72, 80] for surveys), only recently have systems emerged that are both (a) general-purpose (i.e., not targeted to a class of functionality) and (b) rooted in powerful complexity theory and cryptography.</p>

    <p class="text-gray-300">One line of work [28, 77, 78] refines the Muggles interactive proof protocol [41], which is purely complexity-theoretic (no cryptography). As a consequence, the resulting systems are very efficient for the verifier and prover. However, they are restricted to straight-line computations (though this limitation has been partially relaxed [80]).</p>

    <p class="text-gray-300">Another line of work [70-73, 80] refines an efficient argument protocol (§2) due to Ishai et al. [47]. Zaatar [71] is the best-performing entry in this line; it leverages the remarkable encoding of GGPR [36] and handles general side-effect free computations [73].</p>

    <p class="text-gray-300">Pinocchio <em>[65]</em> applies both GGPR’s encoding and its cryptographic constructions <em>[36]</em>, and is the first implementation of a general-purpose non-interactive argument (it is a SNARG <em>[37]</em> and a SNARK <em>[18]</em>). It uses essentially the same computational model as Zaatar <em>[71, 73]</em>, and for systems working within this model, Pinocchio and Zaatar have the best performance in the literature (on different axes). The two are compared in §2.2 and §2.3.</p>

    <p class="text-gray-300">None of these three efforts handles computations over state. Pantry’s principal contribution is to extend the computational model of Pinocchio and Zaatar to do so, using ideas from untrusted storage. First, Pantry relies on Merkle trees <em>[58]</em> to authenticate a large untrusted memory, an idea used in theory <em>[21]</em> and in practice (for smartcards <em>[34]</em>, databases <em>[31, 54, 57]</em>, file systems <em>[38, 48]</em>, etc.). Second, Pantry names data blocks by their digests, and treats the digests as references for the purposes of building data structures (including Merkle trees); this idiom is due to the SFSRO <em>[33]</em> file system and used elsewhere (e.g., SUNDR <em>[52]</em>). One (rough) way to understand Pantry is that it verifiably outsources an SFSRO or SUNDR <em>client</em>. Of course, Pantry’s general approach is known <em>[14, 18, 36, 46]</em>. However, Pantry is the first realization of this strategy.</p>

    <p class="text-gray-300">A fourth project, appearing in parallel with Pantry, offers a different approach to state. BCGTV <em>[15]</em> use a promising circuit representation from <em>[14]</em> (a different instantiation of steps (1) and (2) in §2.2). Using insights from <em>[20, 36, 71]</em>, BCGTV combine their representation with a step (3) that is much like Pinocchio’s (like Pinocchio, BCGTV is a “SNARK with pre-preprocessing”). On the one hand, BCGTV achieve expressivity relative to Pantry, specifically data-dependent loops. On the other hand, they do not (at present) work with remote state (§4–§6). Furthermore, although a complete evaluation has not been done, their preliminary reported results indicate that performance is often orders of magnitude worse than Pantry. A detailed comparison is future work.</p>

    <h2 id="sec-29" class="text-2xl font-bold">10 Discussion, limitations, and conclusion</h2>

    <p class="text-gray-300">Pantry has many limitations. A number of these stem from the clumsiness of the constraint model (§2.4), which led to various compromises described earlier (§4, §5.4, §6). A further compromise is the assumption throughout that the verifier knows the digest of the remote state; this holds when the state is read-only or when there is one client. Future work is to handle multiple writers, perhaps by outsourcing <em>signature</em> (not just hash) checks.</p>

    <p class="text-gray-300">But the biggest limitation by far is costs—which are currently so high for the prover and the verifier’s setup phase (§8.1) that they limit our experiments (§8.2) to scales smaller than those of real applications (to put it mildly). This issue afflicts the entire research area (§9). Indeed, key challenges are to reduce the overhead of the argument protocol (which seems possible, as the costs stem from high constants, not unfavorable asymptotics); reduce the overhead of memory operations within the constraint model (evidence exists that this can be done <em>[14]</em>); and go beyond, or around, the constraint model.</p>

    <p class="text-gray-300">Nevertheless, Pantry dramatically expands the set of scenarios where verifiable computation makes sense. First, Pantry extends verifiability to computations that make indirect memory accesses (to RAM, disk, etc.). Second, because the verifier can supply digests of inputs, the per-instance CPU cost of verification can drop below the time cost to handle the actual inputs, thereby allowing the verifier to beat naive verification even when outsourcing <em>linear</em>-time computations (§4, §8.2). Third, Pantry can save network costs for the verifier versus the naive alternative (§4, §8.2). Thus, Pantry may be beneficial even if verification costs more CPU cycles than local execution—a case that defeats the goals (§2.3) of prior work <em>[65, 71, 72, 73, 80]</em>. Fourth, Pantry (with a major assist from Pinocchio) extends verifiability to a class of computations involving <em>private</em> remote state (§6).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The preceding paragraph describes when Pantry <em>could</em> be applicable, but we must also consider when it actually <em>is</em>. The answer depends on computation-specific factors: the cross-over points, one’s tolerance for prover overhead, and the details of the scenario. But data-parallel cloud computing (e.g., MapReduce) seems to fit the requirements: many instances of the same computation and an abundance of server CPU cycles. Moreover, a high price for the private state applications might be acceptable, since there is no naive alternative (§8.2).</p>

    <p class="text-gray-300">In conclusion, there is a great deal of work remaining to bring verifiable computation to practice, but Pantry is a significant step toward that goal.</p>

    <h2 id="sec-30" class="text-2xl font-bold">Appendix A Pantry’s correctness</h2>

    <p class="text-gray-300">This appendix and the next will establish Pantry’s correctness. These arguments mainly draw on existing techniques and folklore; we write them down here for completeness.</p>

    <p class="text-gray-300">We wish to establish that Pantry’s verifier <span class="math">\\mathcal{V}</span> accepts correct outputs <span class="math">y</span> and rejects incorrect ones with probability similar to that of Zaatar’s soundness (§2.1, §2.3). By the Completeness property of Zaatar <em>[71, Apdx. A]</em> and an equivalent property in Pinocchio <em>[36, 65]</em>, and the implementation of the prover <span class="math">\\mathcal{P}</span> (specifically, the use of the map <span class="math">S</span>), <span class="math">\\mathcal{V}</span> can be made to accept correct outputs with certainty. The more involved step is showing that <span class="math">\\mathcal{V}</span> rejects incorrect answers. One might think to apply the soundness property (§2.2), but this property is not enough: its technical guarantee is that <em>if no satisfying assignment exists</em>, then <span class="math">\\mathcal{V}</span> is likely to reject <em>[36, 65, 71]</em>. Meanwhile, <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> could be satisfiable, even if <span class="math">y</span> is incorrect in the context of steps 1 and 2 (§2.2). As a simple example, imagine that the computation <span class="math">\\Psi</span> is:</p>

    <pre><code class="language-text">name = PutBlock(x);
B = GetBlock(name);
if (B == x)
y = 1;
else
y = 0;
return y;</code></pre>

    <p class="text-gray-300">The correct answer here is <span class="math">y{=}1</span>. But <span class="math">y{=}0</span> also results in many satisfying assignments to <span class="math">\\mathcal{C}_{\\Psi}(X{=}x,Y{=}0)</span>; in particular, any setting of the <span class="math">B</span> variables for which <span class="math">H(B){=}H(x){=}name</span>, where <span class="math">B{\\neq}x</span>, will satisfy <span class="math">\\mathcal{C}_{\\Psi}(X{=}x,Y{=}0)</span>. Since soundness says nothing about what <span class="math">\\mathcal{V}</span> does when there <em>are</em> satisfying assignments, soundness cannot be used to argue that <span class="math">\\mathcal{V}</span> will reject <span class="math">y=0</span>.</p>

    <p class="text-gray-300">We need another property, called <em>proof of knowledge</em> (PoK). A formal definition is below; less formally, this property states that if <span class="math">\\mathcal{P}</span> can make <span class="math">\\mathcal{V}</span> accept a claimed output <span class="math">y</span> with non-negligible probability, then there is an efficient algorithm that can run <span class="math">\\mathcal{P}</span> to produce a satisfying assignment to <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span>. Even more informally, one can think of this property as stating that if <span class="math">\\mathcal{V}</span> accepts the interaction, then <span class="math">\\mathcal{P}</span> must have “known” an assignment.</p>

    <p class="text-gray-300">The power of the PoK property in our context is the following. If <span class="math">y</span> is an incorrect output and <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is satisfiable, <em>the only satisfying assignments contain memory consistency violations</em>; meanwhile, memory consistency violations imply hash collisions, and manufacturing such collisions is presumed to be hard. Therefore, no efficient algorithm can produce satisfying assignments of this adverse form, and hence (by the italicized assertion) no efficient algorithm can produce any satisfying assignments, and hence—here is where we use the PoK property—the prover cannot systematically make the verifier accept the corresponding output. Very informally, the prover must not “know” any adverse satisfying assignments, which, by the PoK property, implies that it cannot make the verifier accept them.</p>

    <p class="text-gray-300">In the rest of this appendix, we formally define a PoK property and use it to establish Pantry’s correctness; Appendix B proves that Pantry meets this property. We will restrict attention to the case that Pantry uses Zaatar; a similar analysis applies when Pantry uses Pinocchio.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">A.1 Setup and definition of proof-of-knowledge</h3>

    <p class="text-gray-300">Recall the Zaatar setup. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> are given a set of constraints <span class="math">\\mathcal{C}</span> (over variables <span class="math">X,Y,Z</span>), input <span class="math">x</span>, and output <span class="math">y</span>. <span class="math">\\mathcal{C}(X{=}x,Y{=}y)</span> is a set of constraints over variables <span class="math">Z=(Z_{1},\\ldots,Z_{n^{\\prime}})</span>; each <span class="math">Z_{i}\\in\\mathbb{F}</span>. <span class="math">\\mathcal{V}</span> and (a possibly incorrect <span class="math">\\mathcal{P}</span>) interact. If, after getting the purported output <span class="math">y</span>, <span class="math">\\mathcal{V}</span> accepts, we notate that as <span class="math">(\\mathcal{V},\\mathcal{P})(\\mathcal{C},x,y)=1</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition A.1 (Proof of knowledge (PoK).).</h6>

    <p class="text-gray-300">There exists a PPT <em>extractor algorithm</em> <span class="math">E</span> (which is presumed to have oracle access to the prover: it can run the prover by supplying arbitrary patterns) for which the following holds. For all <span class="math">\\mathcal{P}</span> and all polynomially-bounded <span class="math">(\\mathcal{C},x,y)</span>, if</p>

    <p class="text-gray-300"><span class="math">\\Pr\\{(\\mathcal{V},\\mathcal{P})(\\mathcal{C},x,y)=1\\}&gt;\\epsilon_{K}</span></p>

    <p class="text-gray-300">then</p>

    <p class="text-gray-300"><span class="math">\\Pr_{s}\\{E_{s}^{\\mathcal{P}}(\\mathcal{C},x,y)\\to z=z_{1},\\ldots,z_{n^{\\prime}},\\text{ such that }z\\text{ satisfies }\\mathcal{C}(X{=}x,Y{=}y)\\}&gt;\\epsilon_{K}^{\\prime},</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon_{K}^{\\prime}</span> is non-negligible. The first probability is taken over the random choices of the Zaatar protocol (specifically, the coin flips of the commit phase, the decommit phase, and the choice of PCP queries). The second probability is taken over <span class="math">s</span>, the random choices of the extractor algorithm <span class="math">E</span>.</p>

    <p class="text-gray-300">The next appendix proves that Zaatar has this property; for now, we take it as a given. As we will see below, the quantity <span class="math">\\epsilon_{K}</span> will wind up being Pantry’s actual error: it will upper-bound the probability that <span class="math">\\mathcal{V}</span> accepts an incorrect output. Sometimes this parameter is referred to as “knowledge error”, and we will be motivated to ensure that it is not much larger than the soundness error. Notice that we cannot make this parameter lower than the soundness error, since a protocol that has knowledge error of at most <span class="math">\\epsilon_{K}</span> has soundness error of at most <span class="math">\\epsilon_{K}</span> (that is, PoK implies soundness). This is because if no satisfying assignment exists at all, then of course the probability of producing one is zero (for all algorithms), which implies (by PoK) that <span class="math">\\mathcal{V}</span> rejects with probability at least <span class="math">1-\\epsilon_{K}</span>, which yields the soundness property.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">A.2 <span class="math">\\mathcal{V}</span> rejects incorrect outputs</h3>

    <p class="text-gray-300">This section considers only single executions; the next section generalizes to the case of state carried across program executions.</p>

    <p class="text-gray-300">We will use the PoK property (Defn. A.1) to establish that <span class="math">\\mathcal{V}</span> rejects semantically incorrect outputs <span class="math">y^{\\prime}</span> with high probability. In the context of a computation <span class="math">\\Psi</span>, the (unique) semantically correct output <span class="math">y</span> on input <span class="math">x</span> is the value or vector that results from following the logic of <span class="math">\\Psi</span> on input <span class="math">x</span>. This logic includes <em>program logic</em> and <em>storage consistency</em>. Program logic means, for example, that the result of an “add” operation should actually be the sum of the two numbers.</p>

    <p class="text-gray-300">Storage consistency is a typical definition: “reads should see writes”. In our context, this means that if the program “reads address <span class="math">n</span>” (that is, executes GetBlock with input <span class="math">n</span>), then the return value <span class="math">b</span> should be the “most recently written value to address <span class="math">n</span>” (that is, the program should have executed <span class="math">n=\\texttt{PutBlock}(b)</span>, and between that call and the GetBlock, there should be no intervening invocations <span class="math">n=\\texttt{PutBlock}(b^{\\prime})</span>, where <span class="math">b^{\\prime}\\neq b</span>). If an input <span class="math">x</span> would cause <span class="math">\\Psi</span> to issue a call GetBlock(<span class="math">n</span>) for which there was no preceding call <span class="math">n=\\texttt{PutBlock}(b)</span>, then there is no semantically correct output; in this situation, we sometimes say that the correct output is <span class="math">\\bot</span> and that <span class="math">x</span> itself as a semantically incorrect input.</p>

    <p class="text-gray-300">Of course, the preceding notions require an ordering on operations; this order follows from program order, and induces an ordering on the constraints that the Pantry compiler produces. In more detail, recall that for a high-level program <span class="math">\\Psi</span>, the Pantry compiler produces constraints <span class="math">\\mathcal{C}</span> that correspond to <span class="math">\\Psi</span>’s program logic: the program variables in <span class="math">\\Psi</span> appear in <span class="math">\\mathcal{C}</span>, and the equations in <span class="math">\\mathcal{C}</span> enforce program logic through the relations among the program variables. (The constraints <span class="math">\\mathcal{C}</span> are said to be <em>equivalent</em> to the computation <span class="math">\\Psi</span>.) An assignment <span class="math">w=(x,y,z)</span> to <span class="math">\\mathcal{C}</span> thus corresponds to a <em>transcript</em> for <span class="math">\\Psi</span>: a string consisting of the program <span class="math">\\Psi</span> with loops unrolled and with all variables <span class="math">(X,Y,Z_{1},Z_{2},\\ldots)</span> replaced with values <span class="math">(x,y,z_{1},z_{2},\\ldots)</span>. In what follows, we will move back and forth between the notion of transcript <span class="math">\\tau</span> and its corresponding assignment <span class="math">w_{\\tau}=(x,y,z)</span>.</p>

    <p class="text-gray-300">A <em>valid transcript</em> is one that obeys program semantics. Specifically, in a valid transcript <span class="math">\\tau</span>:</p>

    <p class="text-gray-300">All operations respect program logic. By the transcript-assignment equivalence, this property is equivalent to saying that the assignment <span class="math">w_{\\tau}=(x,y,z)</span> satisfies the constraints <span class="math">\\mathcal{C}</span>. Storage operations respect consistency. Specifically, if <span class="math">b=\\textsf{GetBlock}(n)</span> appears in <span class="math">\\tau</span>, then an operation <span class="math">n=\\textsf{PutBlock}(b)</span> appears earlier in <span class="math">\\tau</span> (with no intervening <span class="math">n=\\textsf{PutBlock}(b^{\\prime})</span>, where <span class="math">b^{\\prime}\\neq b</span>).</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Claim A.1.</h6>

    <p class="text-gray-300">For a computation <span class="math">\\Psi</span>, if <span class="math">y\\neq\\bot</span> is semantically correct on input <span class="math">x</span>, then there exists a valid transcript in which the input variables are set to <span class="math">x</span> and the output variables are set to <span class="math">y</span>. (Also, this transcript is unique in our present context.)</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The transcript is an unrolled program execution. So if the program <span class="math">\\Psi</span> would correctly produce <span class="math">y</span> from <span class="math">x</span>, then we can write down all of the operations that lead from <span class="math">x</span> to <span class="math">y</span>. This list will respect validity (properties P1 and P2), since validity admits those transcripts (and only those transcripts) that obey the semantics.</p>

    <p class="text-gray-300">The transcript is unique since each operation, when executed correctly, is deterministic. Note in particular that storage operations are deterministic: PutBlock operations are deterministic by construction (given an input block, PutBlock returns a digest of it), and the semantics given above specify the unique return value of a GetBlock invocation. ∎</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Claim A.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}</span> be Pantry’s verifier, operating on constraints <span class="math">\\mathcal{C}</span> and input <span class="math">x</span>. If <span class="math">y\\neq\\bot</span> is the semantically correct output, then for all provers <span class="math">\\mathcal{P}</span> and all <span class="math">y^{\\prime}\\neq y</span>, <span class="math">\\Pr\\{(\\mathcal{V},\\mathcal{P})(\\mathcal{C},x,y^{\\prime})=1\\}\\leq\\epsilon_{K}</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume otherwise. Then there exists a prover <span class="math">\\mathcal{P}^{\\prime}</span> and an incorrect answer <span class="math">y^{\\prime}</span> for which <span class="math">\\Pr\\{(\\mathcal{V},\\mathcal{P}^{\\prime})(\\mathcal{C},x,y^{\\prime})=1\\}&gt;\\epsilon_{K}</span>. By the PoK property (Defn A.1, Lemma B.1), there exists an extractor algorithm <span class="math">E^{\\mathcal{P}^{\\prime}}</span> that, with probability greater than <span class="math">\\epsilon_{K}^{\\prime}</span>, produces some assignment <span class="math">z^{\\prime}</span> such that <span class="math">(x,y^{\\prime},z^{\\prime})</span> satisfies <span class="math">\\mathcal{C}</span>; let <span class="math">\\tau^{\\prime}</span> be the transcript corresponding to the assignment <span class="math">w_{\\tau^{\\prime}}^{\\prime}=(x,y^{\\prime},z^{\\prime})</span>. Also, since <span class="math">y\\neq\\bot</span> is semantically correct, Claim A.1 implies that there exists a valid transcript <span class="math">\\tau</span> (while <span class="math">\\tau</span> is unique, we will not explicitly rely on that uniqueness below). By the validity of <span class="math">\\tau</span>, there is an assignment <span class="math">w_{\\tau}=(x,y,z)</span> that satisfies <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">Compare <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span>. Consider the first position in these strings where they disagree (they must disagree somewhere, for their outputs are different). We now make two claims about this point of divergence: (1) it must be a <span class="math">\\textsf{GetBlock}(n)</span> operation, and (2) the input to this operation must be the same in both <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span>.</p>

    <p class="text-gray-300">The reason for (1) is that if <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span> first disagreed on a different operation (either its inputs or outputs), they would agree up until that operation, and then disagree on a deterministic operation (all operations besides GetBlock are deterministic); hence, at least one of the two transcripts would be in violation of program logic, which would mean that at least one of <span class="math">w_{\\tau}</span> and <span class="math">w_{\\tau^{\\prime}}^{\\prime}</span> would not satisfy <span class="math">\\mathcal{C}</span>, which would contradict statements above. Similarly, to establish (2), observe that the constraints are constructed so that the input to GetBlock is deterministically produced from the computation’s input (<span class="math">x</span>) and the computation up to that point (and <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span> agree up to that point).</p>

    <p class="text-gray-300">From claims (1) and (2), the output of the GetBlock in <span class="math">\\tau</span> (call it <span class="math">b</span>) and in <span class="math">\\tau^{\\prime}</span> (call it <span class="math">b^{\\prime}</span>) are different; that is, <span class="math">b\\neq b^{\\prime}</span>. However, <span class="math">w</span> and <span class="math">w^{\\prime}</span> are both satisfying, so <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span> obey property P1. From the compilation of GetBlock into <span class="math">\\mathcal{C}_{H^{-1}}</span>, and the construction of <span class="math">\\mathcal{C}_{H^{-1}}</span>, per Section 3, we have <span class="math">n=H(b)</span> and <span class="math">n=H(b^{\\prime})</span>, where <span class="math">H</span> is a collision-resistant hash function (CRHF). Also, because <span class="math">\\tau</span> is valid, it obeys P2, which means that <span class="math">\\tau</span> contains an earlier instance of <span class="math">n=\\text{PutBlock}(b)</span>, where (by P1) <span class="math">H(b)=n</span>. But <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span> match through that earlier point in the transcript, which means that <span class="math">\\tau^{\\prime}</span> also contains <span class="math">n=\\text{PutBlock}(b)</span>. Thus, <span class="math">\\tau^{\\prime}</span> contains <span class="math">b</span> and <span class="math">b^{\\prime}</span>, with <span class="math">b^{\\prime}\\neq b</span> and <span class="math">H(b)=H(b^{\\prime})</span>.</p>

    <p class="text-gray-300">Therefore, an adversarial algorithm <span class="math">\\mathcal{A}</span> can produce a collision in <span class="math">H</span> as follows. <span class="math">\\mathcal{A}</span> runs <span class="math">E^{\\mathcal{P}^{\\prime}}</span> to get <span class="math">z^{\\prime}</span> (which succeeds with <span class="math">&gt;\\epsilon_{K}^{\\prime}</span> probability), forms <span class="math">w=(x,y^{\\prime},z^{\\prime})</span>, sorts <span class="math">w</span> by output digests, scans to find <span class="math">b</span> and <span class="math">b^{\\prime}</span>, and outputs them. This succeeds in producing a collision with probability <span class="math">&gt;\\epsilon_{K}^{\\prime}</span>, which contradicts the assumed collision-resistance of <span class="math">H</span>. ∎</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">A.3 Remote state</h3>

    <p class="text-gray-300">Arguing the correctness of Pantry’s MapReduce (§4), among other applications, requires allowing state to be carried across executions. To this end, we generalize the definitions above.</p>

    <p class="text-gray-300">We consider a model in which <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> interact sequentially: <span class="math">\\mathcal{V}</span> supplies input <span class="math">x_{0}</span> and specifies <span class="math">\\Psi_{0}</span> to <span class="math">\\mathcal{P}</span>, receiving output <span class="math">y_{0}</span>; next, <span class="math">\\mathcal{V}</span> supplies input <span class="math">x_{1}</span> and specifies <span class="math">\\Psi_{1}</span> to <span class="math">\\mathcal{P}</span>, receiving output <span class="math">y_{1}</span>, etc. Suppose that there are <span class="math">t+1</span> pairs in all: <span class="math">(x_{0},y_{0}),\\ldots,(x_{t},y_{t})</span>.</p>

    <p class="text-gray-300">We define the semantic correctness of <span class="math">y_{i}</span> inductively. Specifically, we say that <span class="math">y_{0}</span> is semantically correct if it meets the earlier description (i.e., if the correct operation of <span class="math">\\Psi_{0}</span> on input <span class="math">x_{0}</span> produces <span class="math">y_{0}</span>). For <span class="math">y_{i}</span>, where <span class="math">i&gt;0</span>, we say that <span class="math">y_{i}</span> is semantically correct if (a) all previous <span class="math">\\{(x_{j},y_{j})\\}_{j=0}^{i-1}</span> are semantically correct; (b) <span class="math">y_{i}</span> respects program logic on <span class="math">x_{i}</span>; and (c) if <span class="math">\\Psi_{i}</span> issues GetBlock(<span class="math">n</span>), then the return value should be the <span class="math">b</span> in the most recent <span class="math">n=\\texttt{PutBlock}(b)</span> call, as above; here, however, we are looking not only at the current execution but at the concatenated (valid) transcripts <span class="math">\\tau_{0},\\ldots,\\tau_{i-1}</span> together (these transcripts exist by the correctness of <span class="math">y_{0},\\ldots,y_{i-1}</span>).</p>

    <p class="text-gray-300">Label with <span class="math">\\mathcal{C}_{i}</span> the constraints that correspond to computation <span class="math">\\Psi_{i}</span>. We now make a claim that is analogous to Claim A.2:</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Claim A.3.</h6>

    <p class="text-gray-300">Consider a sequence of interactions between <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> that produces pairs <span class="math">(x_{0},\\hat{y}_{0}),\\ldots,(x_{t},\\hat{y}_{t})</span>, where for <span class="math">i\\in\\{0,\\ldots,t\\}</span>, the semantically correct output <span class="math">y_{i}</span> is not <span class="math">\\bot</span>. For all provers <span class="math">\\mathcal{P}</span>, and all <span class="math">i</span>, if <span class="math">\\hat{y}_{i}\\neq y_{i}</span>, then for some <span class="math">j\\leq i</span>, we have <span class="math">\\Pr\\{(\\mathcal{V},\\mathcal{P})(\\mathcal{C}_{j},x_{j},\\hat{y}_{j})=1\\}\\leq\\epsilon_{K}</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">(Sketch.) The proof is similar to that of Claim A.2. Let <span class="math">\\hat{y}_{i}</span> be the first semantically incorrect output in the sequence. Assume to the contrary that <span class="math">\\Pr\\{(\\mathcal{V},\\mathcal{P})(\\mathcal{C}_{j},x_{j},\\hat{y}_{j})=1\\}&gt;\\epsilon_{K}</span>, for all <span class="math">j\\in\\{0,\\ldots,i\\}</span>; by the PoK property, <span class="math">E</span> can produce, with probability greater than <span class="math">(\\epsilon_{K}^{\\prime})^{i+1}</span>, a list of assignments <span class="math">\\hat{z}_{0},\\ldots,\\hat{z}_{i}</span> (which satisfy the respective constraint sets, given the respective inputs and outputs). Let <span class="math">\\hat{\\tau}_{0},\\ldots,\\hat{\\tau}_{i}</span> be the corresponding transcripts, and concatenate these together to form one large aggregate transcript, <span class="math">\\hat{\\tau}_{<em>}</span>. There is a valid aggregate transcript <span class="math">\\tau_{</em>}</span> that differs from <span class="math">\\hat{\\tau}_{*}</span> in at least one location (because <span class="math">y_{i}\\neq\\hat{y}_{i}</span>).</p>

    <p class="text-gray-300">As in Claim A.2, the two transcripts must again diverge in a GetBlock operation (all other operations are deterministic; furthermore, the inputs <span class="math">\\{x_{0},\\ldots,x_{i}\\}</span> match in the two transcripts, and so do the outputs <span class="math">\\{\\hat{y}_{0},\\ldots,\\hat{y}_{i-1}\\}</span>, since <span class="math">\\hat{y}_{i}</span> is the first semantically incorrect output in the sequence). This implies that <span class="math">\\hat{\\tau}_{*}</span> contains a collision. An adversarial PPT algorithm can thus produce a collision with probability at least <span class="math">(\\epsilon_{K}^{\\prime})^{i+1}/t</span> (by guessing <span class="math">i</span>, running <span class="math">i</span> instances of the extractor <span class="math">E</span>, and sorting the resulting witnesses), in contradiction to the presumed collision-resistance of <span class="math">H</span>. ∎</p>

    <p class="text-gray-300">The preceding analysis can be extended to cover the data structures that we build using the GetBlock and PutBlock abstractions (§5). In the case of the verifiable RAM, this analysis is a mild variant of the arguments for online memory-checking given by Blum et al. <em>[21]</em>. That paper specifies a simple memory semantics (roughly, reads and writes are totally ordered and each read is matched by a preceding write),</p>

    <p class="text-gray-300">describes a Merkle tree-based on-line checking algorithm, and argues that in order to violate the memory semantics an adversary must fake some of the hash checks that validate a path through the Merkle tree. Inspection of our verifiable RAM design (Section 5.1, Figure 7) indicates that violation of the memory semantics would result in a violation of Claim A.2.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Discussion.</h4>

    <p class="text-gray-300">Notice that the preceding claims are conditional on <span class="math">\\mathcal{V}</span> supplying correct inputs (i.e., a condition for the claims is that there <em>are</em> correct outputs). In particular, if the verifier supplies a made-up digest as a reference to storage, the protocol provides no guarantees. In practice, this means that the onus is on the verifier to supply correct digests as input.</p>

    <p class="text-gray-300">Of course, if the verifier makes up a digest, then heuristically speaking, the prover will not be able to manufacture a satisfying assignment, since that would require inverting <span class="math">H</span>. In fact, if the verifier chooses a digest <span class="math">d</span> by random selection of <span class="math">b</span> and then setting <span class="math">d\\leftarrow H(b)</span>, then we can show that the prover cannot convince the verifier to accept with greater than the knowledge error <span class="math">\\epsilon_{K}</span> (this relies on the preimage-resistance, or one-wayness, of <span class="math">H</span>, which is Ajtai’s function <em>[4]</em>). By contrast, if the verifier chooses an input digest arbitrarily (perhaps in collusion with the prover!), then we cannot apply the preceding guarantees; however, cases where the verifier chooses a “wrong” digest for which it knows that the prover knows a preimage are elaborate exercises in shooting oneself in the foot.</p>

    <p class="text-gray-300">Finally, note that the security proof for remote state presumes that either the same verifier is participating across the sequence, or that there is a chain of trust linking them. This issue is handled somewhat better in the non-interactive “proof-carrying data” (PCD) framework <em>[19]</em>, where an extractor can produce a complete transcript, given a certificate. On the other hand, existing PCD protocols rely on non-falsifiable hypotheses.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix B Zaatar and proof-of-knowledge</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This appendix will establish that Zaatar meets a proof-of-knowledge (PoK) property. Recall from the prior appendix that we are motivated to ensure that the knowledge error, <span class="math">\\epsilon_{K}</span>, is not much larger than Zaatar’s soundness error, <span class="math">\\epsilon_{\\text{zaat}}</span>; as established elsewhere <em>[71, Apdx. A]</em>, <span class="math">\\epsilon_{\\text{zaat}}=\\epsilon_{\\text{pcp}}+\\epsilon_{c}</span>, where <span class="math">\\epsilon_{\\text{pcp}}</span> is the soundness error of the Zaatar PCP (approximately <span class="math">5\\cdot 10^{-7}</span>), and <span class="math">\\epsilon_{c}</span> is the error from the commitment protocol (for Zaatar, $\\epsilon_{c}\\approx 6000\\cdot\\sqrt[3]{1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma B.1.</h6>

    <p class="text-gray-300">The Zaatar argument protocol has the PoK property with <span class="math">\\epsilon_{K}=2\\cdot\\epsilon_{\\text{pcp}}+\\epsilon_{c}</span>, and <span class="math">\\epsilon_{K}^{\\prime}=\\left(\\epsilon_{\\text{pcp}}/2\\right)\\cdot\\left(1-n^{\\prime}\\cdot e^{-100}\\right).</span></p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof combines techniques from Barak and Goldreich (BG02) <em>[10]</em> and from the soundness proof of Pepper <em>[72, Apdx. B]</em> and IKO <em>[47]</em> (which is Pepper’s and Zaatar’s base). We will assume familiarity with the technical details of Zaatar, Pepper, and IKO, but not of BG02. At a very high level, all of these protocols consist of a commit phase (in which the verifier makes the prover commit to an oracle, which is supposed to be the PCP) and a decommit phase; in the latter phase, the verifier submits the PCP queries.</p>

    <p class="text-gray-300">The above works prove, loosely speaking, that at the end of the commit phase of the protocol, the prover is effectively bound to a particular (possibly inefficient) function <span class="math">f</span>, from queries to responses. We face several technical difficulties in the present context. One of them is that just because <span class="math">f</span> exists does not mean that it is easy to make the prover <em>respond</em> to queries. We will get around this issue by first showing that if there is a <span class="math">&gt;\\epsilon_{K}</span> probability of <span class="math">\\mathcal{V}</span> accepting, then it must be true that for almost all of the possible queries, the prover responds with non-negligible probability. Then, loosely speaking, the extraction procedure will amplify the non-negligible probability to be near-certain. This is done by pumping the prover: feeding it many different interactions. Another difficulty is that when the extractor performs this pumping, we have to be sure that values <em>other</em> than the correct one will be sufficiently</p>

    <p class="text-gray-300">infrequent that the pumping process won’t get confused; we get around this by reformulating the claims that the prover is bound to a function <span class="math">f</span>.</p>

    <p class="text-gray-300">The proof proceeds according to the following outline:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We will describe an extraction procedure, leaving a number of parameters unspecified.</li>

      <li>We will analyze the extraction procedure and in so doing fill in the parameters. The analysis is in several parts:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We will reformulate some of the analysis of the binding properties of Pepper <em>[72, Apdx. B]</em>.</li>

      <li>We will define notions <em>[10]</em> of queries being “strong” (or weak) and “clear” (or confounding); these notions are relative to a given commit phase. We hope that in a <em>useful</em> commit phase, the vast majority of queries are both strong and clear; furthermore, we hope that a non-negligible fraction of commit phases are useful.</li>

      <li>We will show that in useful commit phases, the function that the prover is bound to is a valid PCP oracle that encodes a satisfying assignment and has a soundness error identical to our usual.</li>

      <li>We will show that in useful commit phases, the overwhelming majority of queries are strong.</li>

      <li>We will show that in useful commit phases, the overwhelming majority of queries are clear.</li>

      <li>The above results will be used to upper-bound <span class="math">\\epsilon_{K}</span> and lower-bound <span class="math">\\epsilon_{K}^{\\prime}</span>.</li>

    </ul>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">B.1 Preliminaries</h3>

    <p class="text-gray-300">There are three sets of random coin flips in the Zaatar protocol: <span class="math">c</span> represents the random coin flips that determine the commit phase, <span class="math">d</span> represents the random coin flips that determine the decommit phase, and <span class="math">r</span> represents the random coin flips that determine the PCP queries. Often, we will assume that the coins for the commit phase have been flipped, and we will be working within a commit phase <span class="math">c</span>.</p>

    <p class="text-gray-300">Let <span class="math">A_{i}</span> be the prover’s response to the <span class="math">i</span>th query, independent of whether the decommitment succeeds; when <span class="math">A_{i}</span> depends on all three sources of randomness, we write <span class="math">A_{i}(c,d,r)</span>. A common case is that we will be interested in <span class="math">A_{i}</span>, within some commit phase (i.e., the commit coin flips will have already been determined); in that case, <span class="math">A_{i}</span> is a function of <span class="math">(d,r)</span> and can be written <span class="math">A_{i}(d,r)</span>.</p>

    <p class="text-gray-300"><em>Whether <span class="math">\\mathcal{V}</span> accepts</em> is a random variable that is a function of <span class="math">(c,d,r)</span>. Likewise, <em>whether <span class="math">\\mathcal{V}</span> decommits</em> (that is, whether the decommitment succeeds) is a random variable.</p>

    <p class="text-gray-300">Let <span class="math">Q_{1}(r),\\ldots,Q_{\\mu}(r)</span> represent the <span class="math">\\mu</span> PCP queries generated by a particular choice of the PCP verifier’s coin flips, <span class="math">r</span>. The <span class="math">Q_{i}</span> are random variables, but of course they do not depend on <span class="math">c</span> or <span class="math">d</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}_{\\text{pcp}}</span> denote Zaatar’s PCP verifier. We will refer to <span class="math">\\mathcal{V}_{\\text{pcp}}</span> as generating queries and <em>accepting</em> their replies. (This can be formalized/notated with a query generation procedure <span class="math">\\mathcal{Q}((\\mathcal{C},x,y),r,i)</span>, which, given the PCP coin flips, returns the <span class="math">i</span>th query. Similarly, we can write down a decision procedure <span class="math">\\mathcal{D}((\\mathcal{C},x,y),r,a_{1},\\ldots,a_{\\mu})</span> that returns 1 or 0. While the notation is borrowed from BG02 <em>[10]</em>, the formalization itself is standard in the PCP literature.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A PCP admits <em>reverse sampling</em> (as defined in BG02 <em>[10]</em>) if, given a PCP query <span class="math">q</span> and a position <span class="math">i</span>, it is possible to choose the other PCP queries according to the random coins <span class="math">r</span>, but holding <span class="math">q</span> in the <span class="math">i</span>th position. BG02 formalize this by saying that, given <span class="math">q,i</span>, there is an efficient algorithm that can randomly and uniformly sample from all <span class="math">r</span> such that <span class="math">\\mathcal{Q}((\\mathcal{C},x,y),r,i)=q</span>. In our context, it will be more helpful to think of the reverse sampling property as saying that for all <span class="math">q,i</span>, it is possible to efficiently sample according to the conditional distribution $\\{Q_{1}(r),\\ldots,Q_{\\mu}(r)\\}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q_{i}(r)=q}$. Zaatar’s PCP has the reverse sampling property.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">B.2 The extraction procedure</h3>

    <p class="text-gray-300">See Figure 13 for the extractor, <span class="math">E</span></p>

    <p class="text-gray-300">// Goal is to produce a witness  <span class="math">z</span>  that satisfies  <span class="math">\\mathcal{C}(X = x, Y = y)</span></p>

    <p class="text-gray-300">extract  <span class="math">(\\mathcal{P},\\mathcal{C},x,y)</span></p>

    <p class="text-gray-300">flip the "commit coins", and run the commit phase.</p>

    <p class="text-gray-300">// for the remainder of the procedure, we will be in this commit phase.</p>

    <p class="text-gray-300">for  <span class="math">t = 1,\\dots ,n^{\\prime}</span>  : // extract the  <span class="math">t</span> th witness element</p>

    <p class="text-gray-300">for  <span class="math">k = 1,\\ldots ,T_{1}</span></p>

    <p class="text-gray-300">choose  <span class="math">q_{r}\\in_{R}\\mathbb{F}^{n^{\\prime}}</span></p>

    <p class="text-gray-300"><span class="math">q_{s}\\gets q_{r} + e_{t}</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{1}\\gets</span>  extract_response  <span class="math">(q_r,\\mathcal{C},x,y)</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{2}\\gets</span>  extract_response  <span class="math">(q_{s},\\mathcal{C},x,y)</span></p>

    <p class="text-gray-300"><span class="math">z_{t}^{(k)}\\gets \\sigma_{2} - \\sigma_{1}</span></p>

    <p class="text-gray-300">if a majority of  <span class="math">\\{z_t^{(1)},\\ldots ,z_t^{(T_1)}\\}</span>  equal the same value  <span class="math">\\nu</span></p>

    <p class="text-gray-300"><span class="math">z_{t}\\gets v</span></p>

    <p class="text-gray-300">else:</p>

    <p class="text-gray-300">abort()</p>

    <p class="text-gray-300">output  <span class="math">z_{1},\\ldots ,z_{n}</span></p>

    <p class="text-gray-300">extract_response  <span class="math">(q,\\mathcal{C},x,y)</span></p>

    <p class="text-gray-300">for  <span class="math">i = 1,\\dots ,\\mu</span></p>

    <p class="text-gray-300">for  <span class="math">j = 1,\\dots ,T_{2}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>place  <span class="math">q</span>  in position  <span class="math">i</span> , and reverse sample to get full set of queries:  <span class="math">q_{1},\\ldots ,q_{\\mu}</span> . Here,  <span class="math">q_{i} = q</span> .</li>

      <li>run  <span class="math">\\mathcal{P}</span>  in the decommit phase, flipping decommit coins randomly.</li>

      <li>if decommit succeeds, save the  <span class="math">i</span> th response, labeling it  <span class="math">\\sigma^{(i,j)}</span></li>

    </ul>

    <p class="text-gray-300">if more than  <span class="math">(\\delta /3)\\cdot T_2</span>  of the saved  <span class="math">\\sigma^{(i, - )}</span>  are equal, store the value, calling it a candidate.</p>

    <p class="text-gray-300">if there is exactly one candidate value,  <span class="math">\\sigma</span> :</p>

    <p class="text-gray-300">return  <span class="math">\\sigma</span></p>

    <p class="text-gray-300">else:</p>

    <p class="text-gray-300">abort()</p>

    <p class="text-gray-300">Figure 13—Definition of knowledge extractor,  <span class="math">E</span> . It borrows techniques from the oracle recovery procedure of Barak and Goldreich [10]. For now,  <span class="math">\\delta, T_1, T_2</span>  are parameters.  <span class="math">e_t</span>  is the vector with a 1 in component  <span class="math">t</span>  and 0s elsewhere.</p>

    <p class="text-gray-300">Following IKO [47], Pepper's soundness analysis contains a binding game (Defn. B1 [72]); a commitment protocol is admissible if for all environments (loosely speaking, an environment encapsulates the process of producing PCP queries), the probability of the prover winning the binding game is negligible. The definition in IKO and Pepper is quantified over all deterministic environments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the present work, the binding game is now played inside an environment  <span class="math">\\mathcal{E}</span>  that (a) chooses a distinguished query  <span class="math">q</span>  and the positions  <span class="math">i</span>  and  <span class="math">i&#x27;</span>  deterministically (as previously), and (b) chooses the other queries  <span class="math">\\vec{q}</span>  and  <span class="math">\\vec{q&#x27;}</span>  randomly, according to a distribution of  <span class="math">\\mathcal{E}</span> 's choosing. The definition of " <span class="math">S^<em></span>  wins" is the same (outputting conflicting field values and successfully decommitting), and a protocol is now admissible if for all environments  <span class="math">\\mathcal{E}</span> , the probability of  <span class="math">S^</em></span>  winning is less than  $\\epsilon_B = 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where the probability now is taken over the coins  </span>r, r'$  that generate the two choices of queries as well as the three</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">phases of the binding game (commit phase, and two runs of the decommit phase).</p>

    <p class="text-gray-300">The new definition of admissible protocol (which quantifies over probabilistic environments) is, by averaging, equivalent to the old one (which quantifies over deterministic environments); IKO also observe this equivalence <em>[47]</em>. To see that meeting the old definition implies meeting the new one, observe that if the protocol doesn’t meet the new property in some environment <span class="math">\\mathcal{E}</span>, then there must (in <span class="math">\\mathcal{E}</span>) be an adverse <span class="math">\\vec{q}</span> and <span class="math">\\vec{q^{\\prime}}</span> for which <span class="math">S^{*}</span>’s probability of winning the old binding game is larger than <span class="math">\\epsilon_{B}</span>, contradicting the old definition.</p>

    <p class="text-gray-300">Next, we rerun some of the analysis in Pepper, under probabilistic environments. Define <span class="math">A_{c}(q,i,a)=\\Pr_{d,r}\\{A_{i}(d,r)=a\\mid Q_{i}(r)=q\\}</span>; this quantity is with respect to a particular commit phase <span class="math">c</span>, and answers the question, “given that <span class="math">q</span> is in the <span class="math">i</span>th position, if we reverse sample to get the other queries and flip the decommit coins, what is the probability that the <span class="math">i</span>th output is <span class="math">a</span>?”. Define <span class="math">\\textsf{Ext}(c,q,i)=\\argmax_{a\\in\\mathbb{F}}A_{c}(q,i,a)</span>. Also, define <span class="math">f_{c}(q)</span> to be <span class="math">\\textsf{Ext}(c,q,i^{<em>})</span>, for some distinguished <span class="math">i^{</em>}</span> (for example, <span class="math">i^{*}=1</span>).</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Claim B.2.</h6>

    <p class="text-gray-300">For all <span class="math">q\\in\\mathbb{F}^{n^{\\prime}}</span>, <span class="math">i\\in[\\mu]</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c}\\left\\{\\Pr_{d,r}\\left\\{\\left\\{A_{i}(c,d,r)\\neq f_{c}(q)\\right\\}\\text{ and decommit happens}\\mid Q_{i}(r)=q\\right\\}&lt;\\epsilon_{3}\\right\\}&gt;1-\\epsilon_{3},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\epsilon_{3}<6\\cdot\\sqrt[3]{1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">(Sketch.) This claim is similar to Claim B.4 in Pepper <em>[72]</em>. Essentially, wherever Pepper’s proofs for Claims B.3 and B.4 talk about “the probability over the decommit phase”, one should write “…over the decommit phase and choice of <span class="math">Q(r)</span>”. Also, the binding game that enforces the probabilities is of course over five (not three) sets of random coin flips. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Claim B.3 (Existence of <span class="math">f_{c}(\\cdot)</span> and commit error).</h6>

    <p class="text-gray-300">Define <span class="math">\\epsilon_{c}=2\\cdot\\mu\\cdot\\epsilon_{3}</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c,d,r}\\left\\{\\text{decommit happens and }\\cup_{i=1}^{\\mu}\\left\\{A_{i}(c,d,r)\\neq f_{c}(Q_{i}(r))\\right\\}\\right\\}&lt;\\epsilon_{c},</span></p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix <span class="math">i\\in[\\mu]</span>. Claim B.2 implies that</p>

    <p class="text-gray-300"><span class="math">\\forall q\\colon\\Pr_{c,d,r}\\left\\{\\left\\{A_{i}(c,d,r)\\neq f_{c}(q)\\right\\}\\text{ and decommit happens}\\mid Q_{i}(r)=q\\right\\}&lt;2\\epsilon_{3}.</span></p>

    <p class="text-gray-300">By an averaging argument, we get:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c,d,r}\\left\\{\\left\\{A_{i}(c,d,r)\\neq f_{c}(Q_{i}(r))\\right\\}\\text{ and decommit happens}\\right\\}&lt;2\\epsilon_{3}.</span></p>

    <p class="text-gray-300">A union bound over the <span class="math">\\mu</span> query positions implies the result. ∎</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">Notions of strong and clear</h3>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition B.1 (strong and weak queries).</h6>

    <p class="text-gray-300">Consider the event <span class="math">\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\}</span>; notice that whether this event holds is a function of the random coin flips <span class="math">(c,d,r)</span>. In commit view <span class="math">c</span>, a query <span class="math">q\\in\\mathbb{F}^{n^{\\prime}}</span> is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-strong if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\exists i\\colon\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\mid Q_{i}(r)=q\\right\\}\\geq\\delta.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-weak if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall i\\colon\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\mid Q_{i}(r)=q\\right\\}&lt;\\delta.</span></p>

    <p class="text-gray-300">This differs slightly from the Barak-Goldreich definition, which refers to strong and weak answers. The motivation for this definition is that if we can show most queries are strong (which we will be able to), then extract_response (in Figure 13) will produce <span class="math">f_{c}(q)</span> with non-negligible probability.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition B.2 (clear and confounding queries).</h6>

    <p class="text-gray-300">In commit view <span class="math">c</span>, a query <span class="math">q\\in\\mathbb{F}^{n^{\\prime}}</span> is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta/10</span>-clear if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall i\\colon\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ decommits and }\\{A_{i}(d,r)\\neq f_{c}(q)\\}\\mid Q_{i}(r)=q\\right\\}\\leq\\delta/10.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta/10</span>-confounding if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\exists i\\colon\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ decommits and }\\{A_{i}(d,r)\\neq f_{c}(q)\\}\\mid Q_{i}(r)=q\\right\\}&gt;\\delta/10.</span></p>

    <p class="text-gray-300">This, too, is different from the analogous Barak-Goldreich definition, since they do not talk about a specific function <span class="math">f_{c}(\\cdot)</span>. The motivation for this definition is that if we can show most queries are clear (which we will be able to), then extract_response (Figure 13) does not have to worry that a field element other than <span class="math">f_{c}(q)</span> shows up often enough to be confounding.</p>

    <p class="text-gray-300">When a query is both strong and clear, observe that the extract_response subroutine is likely to deliver a clear “signal.”</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Auspicious commit phases happen often enough</h4>

    <p class="text-gray-300">Define a commit phase as auspicious if, in that phase, <span class="math">\\Pr_{d,r}\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\}\\}&gt;(\\text{1/2})\\cdot\\epsilon</span>; an auspicious commit phase will not necessarily be useful, but auspiciousness is a precondition to usefulness (see Claim B.9 and the analysis that follows it).</p>

    <p class="text-gray-300">Recall the premise of the PoK property: <span class="math">\\Pr_{c,d,r}\\{\\mathcal{V}\\text{ accepts}\\}&gt;\\epsilon_{K}</span>. The next claim guarantees that, when this premise holds, auspicious commit phases happen with non-negligible probability.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Claim B.4 (Auspicious commit phases).</h6>

    <p class="text-gray-300">If <span class="math">\\Pr_{c,d,r}\\{\\mathcal{V}\\text{ accepts}\\}&gt;\\epsilon_{K}</span>, then</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c}\\left\\{\\Pr_{d,r}\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\}\\}&gt;(1/2)\\cdot\\epsilon\\right\\}&gt;(1/2)\\cdot\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\epsilon_{K}-\\epsilon_{c}</span>, and <span class="math">\\epsilon_{c}</span> was defined in Claim B.3.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From Claim B.3,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c,d,r}\\{\\mathcal{V}\\text{ decommits and }\\cup_{j=1}^{\\mu}\\{A_{j}(c,d,r)\\neq f_{c}(Q_{j}(r))\\}\\}&lt;\\epsilon_{c}.</span></p>

    <p class="text-gray-300">But accepting implies decommitting and not the other way around, so</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c,d,r}\\{\\mathcal{V}\\text{ accepts and }\\cup_{j=1}^{\\mu}\\{A_{j}(c,d,r)\\neq f_{c}(Q_{j}(r))\\}\\}&lt;\\epsilon_{c}.</span></p>

    <p class="text-gray-300">Combining the given with the inequality immediately above, we get:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c,d,r}\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\{A_{j}(c,d,r)=f_{c}(Q_{j}(r))\\}\\}&gt;\\epsilon_{K}-\\epsilon_{c}=\\epsilon.</span></p>

    <p class="text-gray-300">Standard counting or averaging implies the result. ∎</p>

    <p class="text-gray-300">Recall that <span class="math">\\mathcal{V}_{\\text{pcp}}</span> denotes the Zaatar PCP verifier. The next two claims state that with probability that cannot be neglected (a) <span class="math">\\mathcal{V}_{\\text{pcp}}</span> accepts (which implies that <span class="math">f_{c}(\\cdot)</span> is of the right form), and (b) all queries issued by <span class="math">\\mathcal{V}_{\\text{pcp}}</span> are, in the context of the argument protocol, <span class="math">\\delta</span>-strong.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">After auspicious commit phases, <span class="math">f_{c}(\\cdot)</span> is a valid PCP oracle</p>

    <p class="text-gray-300">Claim B.5 (<span class="math">\\mathcal{V}_{\\mathrm{pcp}}</span> accepts often). Assuming we are in an auspicious commit phase,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r}\\left\\{\\mathcal{V}_{\\mathrm{pcp}}\\text{ accepts }\\left(f_{c}(Q_{1}(r)),\\ldots,f_{c}(Q_{\\mu}(r))\\right)\\right\\}=(1/2)\\cdot\\epsilon.</span></p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In an auspicious commit phase</p>

    <p class="text-gray-300"><span class="math">(1/2)\\cdot\\epsilon&lt;\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{i=1}^{\\mu}\\left\\{A_{i}(d,r)=f_{c}(Q_{i}(r))\\right\\}\\right\\}.</span></p>

    <p class="text-gray-300">But if <span class="math">\\mathcal{V}</span> accepts on a particular set of coin flips, then <span class="math">\\mathcal{V}_{\\mathrm{pcp}}</span> must accept the same answers, since the latter is a precondition for the former. So we can bound the expression above:</p>

    <p class="text-gray-300"><span class="math">\\leq\\Pr_{d,r}\\left\\{\\mathcal{V}_{\\mathrm{pcp}}\\text{ accepts }\\left(A_{1}(d,r),\\ldots,A_{\\mu}(d,r)\\right)\\text{ and }\\cap_{i=1}^{\\mu}\\left\\{A_{i}(d,r)=f_{c}(Q_{i}(r))\\right\\}\\right\\}</span> <span class="math">\\leq\\Pr_{d,r}\\left\\{\\mathcal{V}_{\\mathrm{pcp}}\\text{ accepts }\\left(f_{c}(Q_{1}(r)),\\ldots,f_{c}(Q_{\\mu}(r))\\right)\\right\\}</span> <span class="math">=\\Pr_{r}\\left\\{\\mathcal{V}_{\\mathrm{pcp}}\\text{ accepts }\\left(f_{c}(Q_{1}(r)),\\ldots,f_{c}(Q_{\\mu}(r))\\right)\\right\\}.</span></p>

    <p class="text-gray-300">The second inequality holds because the event in its LHS is a restricted case of the event in its RHS. The equality holds because its LHS is independent of the <span class="math">d</span> coins. ∎</p>

    <p class="text-gray-300">Take <span class="math">\\epsilon/2=\\epsilon_{\\mathrm{pcp}}</span>, where <span class="math">\\epsilon_{\\mathrm{pcp}}</span> is Zaatar’s PCP soundness error. The claim above, together with the properties of Zaatar (soundness <em>[71, Lemma A.3]</em> and one other: see below), implies the following:</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Corollary B.6 (<span class="math">f_{c}(\\cdot)</span> is often a valid PCP oracle).</h6>

    <p class="text-gray-300">In auspicious commit phases, <span class="math">f_{c}(\\cdot)</span> is a well-formed Zaatar PCP oracle: it is 0.0294-close to a linear function that encodes a witness <span class="math">z</span> that satisfies <span class="math">\\mathcal{C}(X=x,Y=y)</span>.</p>

    <p class="text-gray-300">This corollary relies on a property of Zaatar’s PCP that is stronger than soundness: “well-formedness”. As stated, this property is (a shade) stronger than <em>PCP proof-of-knowledge (PCP PoK)</em>. PCP PoK <em>[10]</em> says that if <span class="math">\\mathcal{V}_{\\mathrm{pcp}}</span> accepts with greater than the soundness error, then not only is <span class="math">\\mathcal{C}</span> satisfiable (which is what the soundness property gives) but also there is an efficient algorithm that can extract a satisfying witness, given access to the PCP oracle. As Barak and Goldreich <em>[10]</em> observe, many PCPs have the PCP PoK property (Zaatar does too), but there are few (if any) proofs in the literature. The reason that our well-formedness property is slightly stronger than a PCP PoK property is that it actually specifies the form of the PCP (and any PCP meeting this form can, through self-correction, yield a witness).</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">After auspicious commit phases, most queries are strong</h3>

    <p class="text-gray-300">Claim B.7. Assuming we are in an auspicious commit phase,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r}\\{\\mathcal{V}_{\\mathrm{pcp}}\\text{ makes only }\\delta\\text{-strong queries}\\}&gt;\\epsilon/4,</span></p>

    <p class="text-gray-300">for <span class="math">\\delta=(1/4)\\epsilon/\\mu</span>.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix a query position <span class="math">i\\in[\\mu]</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\text{ and }Q_{i}(r)\\text{ is }\\delta\\text{-weak}\\right\\}</span> <span class="math">=\\sum_{q\\colon q\\text{ is }\\delta\\text{-weak}}\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\mid Q_{i}(r)=q\\right\\}\\cdot\\Pr_{r}\\left\\{Q_{i}(r)=q\\right\\}</span> <span class="math">=\\sum_{q\\colon q\\text{ is }\\delta\\text{-weak}}\\delta\\cdot\\Pr_{r}\\left\\{Q_{i}(r)=q\\right\\}&lt;\\delta</span></p>

    <p class="text-gray-300">for</p>

    <p class="text-gray-300">By the union bound over positions <span class="math">1,\\ldots,\\mu</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\text{ and any }Q_{j}(r)\\text{ is }\\delta\\text{-weak}\\right\\}&lt;\\mu\\cdot\\delta.</span></p>

    <p class="text-gray-300">Combining this with the definition of auspicious, we get</p>

    <p class="text-gray-300"><span class="math">(1/2)\\epsilon-\\mu\\cdot\\delta</span> <span class="math">&lt;\\Pr_{d,r}\\left\\{\\mathcal{V}\\text{ accepts and }\\cap_{j=1}^{\\mu}\\left\\{A_{j}(d,r)=f_{c}(Q_{j}(r))\\right\\}\\text{ and all of }Q_{1}(r),\\ldots,Q_{\\mu}(r)\\text{ are }\\delta\\text{-strong}\\right\\}</span> <span class="math">\\leq\\Pr_{d,r}\\left\\{\\text{all of }Q_{1}(r),\\ldots,Q_{\\mu}(r)\\text{ are }\\delta\\text{-strong}\\right\\}</span> <span class="math">=\\Pr_{r}\\left\\{\\text{all of }Q_{1}(r),\\ldots,Q_{\\mu}(r)\\text{ are }\\delta\\text{-strong}\\right\\}</span></p>

    <p class="text-gray-300">Substituting <span class="math">\\delta=(1/4)\\epsilon/\\mu</span> in the lower bound gives the result. ∎</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Corollary B.8 (Most queries are strong).</h6>

    <p class="text-gray-300">Recalling that <span class="math">\\mathcal{V}_{\\text{pcp}}</span> makes <span class="math">\\mu</span> PCP queries, if <span class="math">\\rho^{\\prime}</span> of these queries are <em>independently and uniformly random</em>, then (in auspicious commit phases) the fraction of total queries that is <span class="math">\\delta</span>-strong is greater than <span class="math">(\\epsilon/4)^{1/\\rho^{\\prime}}</span>.</p>

    <p class="text-gray-300">At this point, we are ready to argue that the overwhelming majority of queries are <span class="math">\\delta</span>-strong. Looking at Zaatar’s PCP, it has <span class="math">\\rho^{\\prime}=320</span> queries that hit <span class="math">\\pi_{z}</span> randomly. Furthermore, we took <span class="math">\\epsilon=2\\epsilon_{\\text{pcp}}\\approx 10^{-6}</span> (since <span class="math">\\epsilon_{\\text{pcp}}</span>, the soundness error of Zaatar’s PCP, is <span class="math">\\approx 5\\cdot 10^{-7}</span> <em>[71, Apdx. A]</em>). Thus, by Corollary B.8, after auspicious commit phases, the fraction of total queries that is <span class="math">\\delta</span>-strong is greater than <span class="math">(\\epsilon/4)^{1/320}&gt;0.95</span>.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">In most commit phases, most queries are not confounding</h4>

    <p class="text-gray-300">Recall that the notion of being <span class="math">\\delta</span>-confounding is a function of the commit phase. We will now show that in the vast majority of commit phases, the vast majority of <span class="math">q</span> are not <span class="math">\\epsilon_{3}</span>-confounding (<span class="math">\\epsilon_{3}</span> is from Claim B.2).</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Claim B.9 (Most queries are clear).</h6>

    <p class="text-gray-300">Letting <span class="math">\\Pr_{q}</span> denote a uniformly random choice of <span class="math">q</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c}\\left\\{\\Pr_{q}\\left\\{q\\text{ is }\\epsilon_{3}\\text{-confounding}\\right\\}&lt;1/20\\right\\}&gt;1-20\\mu\\epsilon_{3}</span></p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">G_{q,i}(c)</span> denote the event in commit phase <span class="math">c</span> that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{d,r}\\left\\{\\left\\{A_{i}(d,r)\\neq f_{c}(q)\\right\\}\\text{ and decommit happens }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">~{}Q_{i}(r)=q\\right\\}>\\epsilon_{3}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Once <span class="math">q</span> and <span class="math">i</span> have been fixed, this expression is either true or not in commit phase <span class="math">c</span>, and that is what the events <span class="math">G</span> will capture. Claim B.2 implies:</p>

    <p class="text-gray-300"><span class="math">\\forall q,i\\colon\\Pr_{c}\\left\\{G_{q,i}(c)\\right\\}&lt;\\epsilon_{3}.</span></p>

    <p class="text-gray-300">Applying a union bound over query positions, we get</p>

    <p class="text-gray-300"><span class="math">\\forall q\\colon\\Pr_{c}\\left\\{\\cup_{i=1}^{\\mu}G_{q,i}(c)\\right\\}&lt;\\mu\\epsilon_{3}.</span></p>

    <p class="text-gray-300">By definition of <span class="math">\\epsilon_{3}</span>-confounding</p>

    <p class="text-gray-300"><span class="math">\\forall q\\colon\\Pr_{c}\\left\\{q\\text{ is }\\epsilon_{3}\\text{-confounding}\\right\\}&lt;\\mu\\epsilon_{3}.</span></p>

    <p class="text-gray-300">Applying a standard averaging argument followed by a Markov bound</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c}\\left\\{\\Pr_{q}\\left\\{q\\text{ is }\\epsilon_{3}\\text{-confounding}\\right\\}&gt;1/20\\right\\}&lt;20\\mu\\epsilon_{3}</span></p>

    <p class="text-gray-300">The complementary probabilities and events to the ones immediately above imply the claim. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Completing the analysis</p>

    <p class="text-gray-300">We require</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{3}&lt;\\min\\left\\{\\frac{\\epsilon}{40\\mu},\\,\\frac{\\epsilon}{80\\mu}\\right\\}</span></p>

    <p class="text-gray-300">because:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first component in the min ensures that <span class="math">\\epsilon_{3}&lt;\\delta/10</span> (recall that <span class="math">\\delta=\\epsilon/(4\\mu)</span>). This bound gives us a gap (between <span class="math">\\delta</span> and <span class="math">\\delta/10</span>) that helps us pump the prover in the “inner extraction loop”.</li>

      <li>The second component will ensure that the fraction of useful commit phases is <span class="math">&gt;\\epsilon/2-20\\mu\\epsilon_{3}&gt;\\epsilon/4</span>, which we want, to ensure that <span class="math">\\epsilon_{K}^{\\prime}</span> (in the definition of PoK) is non-negligible.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We must verify that the upper bound on <span class="math">\\epsilon_{3}</span> holds. Recall that $\\epsilon_{3}<6\\cdot\\sqrt[3]{1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (from Claim B.2) and </span>\\epsilon=2\\epsilon_{\\mathrm{pcp}}\\approx 10^{-6}<span class="math"> (see Corollaries B.6 and B.8); also, </span>\\mu<span class="math"> is almost exactly 1000. Fortunately, at the field size that Pantry works with (128 bits), </span>6\\cdot\\sqrt[3]{1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\epsilon/(80\\mu)$, so the bound holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Analyzing the steps of the extractor. By Claim B.4, if the PoK premise (<span class="math">\\Pr\\{\\mathcal{V}\\text{ accepts}\\}&gt;\\epsilon_{K}</span>) holds, the choice of commit phase in the extractor is useful with probability <span class="math">&gt;\\epsilon/2-(20\\mu\\epsilon_{3})&gt;\\epsilon/4</span>; this is a commit phase that is both auspicious and bounds the fraction of <span class="math">\\epsilon_{3}</span>-confounding queries, in the sense of Claim B.9. From now on, we assume such a useful commit phase. By Corollary B.6, <span class="math">f_{c}(\\cdot)</span> is <span class="math">\\delta^{\\prime}</span>-close to a linear function that encodes a satisfying witness <span class="math">\\vec{z}</span>, for some <span class="math">\\delta^{\\prime}</span> that is <span class="math">&lt;.03</span>. Note that this <span class="math">\\delta^{\\prime}</span> is different from the <span class="math">\\delta</span> in some of the claims stated earlier.</p>

    <p class="text-gray-300">Now fix <span class="math">t</span>; consider iteration <span class="math">k</span>. Look at query <span class="math">q_{r}</span> in this iteration. By definition of <span class="math">\\delta^{\\prime}</span>-close, we have <span class="math">\\Pr_{q_{r}}\\{q_{r}\\text{ hits}\\,f_{c}(\\cdot)\\text{ where it is not linear}\\}&lt;.03</span>, where the probability is taken over the coins that generate <span class="math">q_{r}</span>. Also, by Corollary B.8, <span class="math">\\Pr_{q_{r}}\\{q_{r}\\text{ is }\\delta\\text{-weak}\\}&lt;1-(\\epsilon/4)^{1/\\rho^{\\prime}}&lt;.05</span>. And we have <span class="math">1/20&gt;\\Pr_{q_{r}}\\{q_{r}\\text{ is }\\epsilon_{3}\\text{-confounding}\\}\\geq\\Pr_{q_{r}}\\{q_{r}\\text{ is }\\delta/10\\text{-confounding}\\}</span>. The first inequality comes from Claim B.9; the second, from the bound on <span class="math">\\epsilon_{3}</span> and the definition of confounding. Therefore, the probability (over the random choice of <span class="math">q_{r}</span> and <span class="math">q_{s}</span>) that <span class="math">q_{r}</span> and <span class="math">q_{s}</span> both have the desirable properties (namely: hit <span class="math">f_{c}(\\cdot)</span> where linear; strong; clear) is at least <span class="math">1-2(.03+.05+.05)=0.74</span>. Call an iteration <span class="math">k</span> in which this event occurs “good”.</p>

    <p class="text-gray-300">Next, consider the “inner loop” (the function extract_response), assuming the iteration is good. We’ll speak of <span class="math">q_{r}</span>, but the same analysis applies to <span class="math">q_{s}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Because <span class="math">q_{r}</span> is <span class="math">\\delta</span>-strong, there is a query position <span class="math">i^{<em>}</span> for which the <span class="math">i^{</em>}</span> response is <span class="math">f_{c}(q_{r})</span>, with probability at least <span class="math">\\delta</span> over the reverse sampling coins. Thus, the expected number of times decommit succeeds when <span class="math">i=i^{<em>}</span> is <span class="math">\\geq\\delta\\cdot T_{2}</span>. Now we apply a Chernoff bound, using this form </em>[61, Thm. 4.2]<em>: <span class="math">\\Pr\\{X\\leq(1-a)E[X]\\}&lt;e^{-a^{2}\\cdot E[X]/2}</span>. We take <span class="math">E[X]\\geq\\delta\\cdot T_{2}</span> and <span class="math">a\\geq 2/3</span>. This implies that for <span class="math">T_{2}&gt;21/\\delta</span>, the probability in iteration <span class="math">k</span> that position <span class="math">i^{</em>}</span> will not label <span class="math">f_{c}(q_{r})</span> a candidate is <span class="math">&lt;(1/100)</span>. The probability is over the coins used for reverse sampling in the <span class="math">j</span> loop of iteration <span class="math">i^{*}</span>.</li>

      <li>Now fix any position <span class="math">i\\in[\\mu]</span>. Call all field elements besides <span class="math">f_{c}(q_{r})</span> scrap. We wish to upper bound the probability of the event (over the reverse sampling coins used in the <span class="math">j</span> loop) that all scrap, together, is decommitted more than <span class="math">(\\delta/3)\\cdot T_{2}</span> times: this probability is an upper bound on the probability that any field value is actually labeled a candidate (since if the scrap together does not clear the threshold, then no element by itself does). <span class="math">q_{r}</span> is <span class="math">(\\delta/10)</span>-clear, so the expected number of times that all scrap, together, is decommitted is <span class="math">&lt;(\\delta/10)\\cdot T_{2}</span>. We use this form of the Chernoff bound <em>[61, Thm 4.3]</em>: <span class="math">\\Pr\\{X\\geq(1+a)E[X]\\}&lt;e^{-a^{2}E[X]/4}</span>. For <span class="math">T_{2}\\geq 4.7/\\delta&gt;(\\ln(100\\mu))/(2.5\\cdot\\delta)</span>, an upper bound on the event in question is <span class="math">10^{-5}</span>.</li>

      <li>Now we can union bound over all <span class="math">\\mu</span> query positions: the probability (over the reverse sampling coins in extract_response) that any position has a scrap candidate is <span class="math">&lt;\\mu\\cdot 10^{-5}</span>. Combining this with the event that <span class="math">f_{c}(q_{r})</span> is not labeled a candidate, we get that <span class="math">f_{c}(q_{r})</span> is not returned from extract_response</li>

    </ul>

    <p class="text-gray-300">with probability upper-bounded by <span class="math">2/100</span>. The same goes for <span class="math">f_{c}(q_{s})</span>.</p>

    <p class="text-gray-300">Now, if iteration <span class="math">k</span> is good, and furthermore produces <span class="math">f_{c}(q_{r})</span> and <span class="math">f_{c}(q_{s})</span>, then <span class="math">\\sigma_{2}-\\sigma_{1}=f_{c}(q_{r}+e_{t})-f_{c}(q_{r})=\\vec{z}\\cdot(q_{r}+e_{t})-\\vec{z}\\cdot(q_{r})=\\vec{z}\\cdot e_{t}=z_{t}</span>. Thus, in iteration <span class="math">k</span>, the probability (over all of the randomness that the algorithm used in the iteration: choice of <span class="math">q_{r},q_{s}</span> and reverse sampling in extract_response) of outputting <span class="math">z_{t}</span> is greater than <span class="math">&gt;1-2(.03+.05+.05+.02)=7/10</span>. Now we apply another Chernoff bound, this time over the iterations <span class="math">k</span>. For <span class="math">T_{1}&gt;3500</span>, the probability that there are fewer than <span class="math">T_{1}/2</span> instances of <span class="math">z_{t}</span> is <span class="math">&lt;e^{-100}</span>.</p>

    <p class="text-gray-300">Applying a union bound to all positions in the witness, the probability of not extracting the witness (if we’re in a useful commit phase) is <span class="math">&lt;n^{\\prime}\\cdot e^{-100}</span>. Also, the probability of a useful commit phase is, as stated above, greater than <span class="math">\\epsilon/4</span>; furthermore, <span class="math">\\epsilon=2\\cdot\\epsilon_{\\text{pcp}}</span> (see page 31). Therefore, the probability (over all of the extractor’s many coin flips) of producing a witness is at least <span class="math">\\left(\\epsilon_{\\text{pcp}}/2\\right)\\cdot\\left(1-n^{\\prime}\\cdot e^{-100}\\right),</span> which was what the lemma claimed. ∎</p>

    <p class="text-gray-300">Our analysis produced lower bounds for <span class="math">T_{1}</span> and <span class="math">T_{2}</span>: <span class="math">T_{1}&gt;3500</span> and <span class="math">T_{2}&gt;80</span> billion. The extractor thus has an appalling concrete cost: producing <em>one</em> component of a witness requires running the verifier-prover decommit phase (including generating queries) <span class="math">5\\cdot 10^{17}</span> times, and that’s only if the event of a useful commit phase happened, which has probability <span class="math">\\geq\\epsilon/4\\approx 2.5\\cdot 10^{-7}</span>! Thus, the expected time to generate a witness is <span class="math">10^{24}</span> times the effort required to run the decommit phase. Nevertheless, the extractor runs in “polynomial time”, as required. (The quotation marks are because our analysis is not asymptotic; in an asymptotic analysis, <span class="math">n^{\\prime}</span> would grow, the error terms would depend on <span class="math">n^{\\prime}</span>, etc.)</p>

    <p class="text-gray-300">Furthermore, the expected time to obtain a witness, though massive, is still far less than the expected time to generate a hash collision, as Pantry uses a hash function with at least 180 bits of security (§7). This gap is sufficient to generate the required contradictions in the proofs in Appendix A.</p>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix C An HMAC-based commitment</h2>

    <p class="text-gray-300">In Section 6, we explain that in order to enable applications where the prover’s state is private, we need a commitment to bind the prover to the state while hiding it from the verifier. Ordinarily, we would use a standard commitment scheme, such as Pedersen’s <em>[67]</em>, which would guarantee binding with respect to a computationally-bound prover along with information-theoretic hiding with respect to the verifier. Because Pedersen’s protocol cannot be represented efficiently as constraints, we instead use a simple scheme based on HMAC-SHA256, which also provides computational binding, but hiding that is only computational. We present our scheme and prove its security here.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup<span class="math">(1^{n})\\to\\textsf{CK}</span></li>

    </ol>

    <p class="text-gray-300">Setup takes a unary string of length <span class="math">n</span>, a security parameter, and returns <span class="math">CK</span>, a public commitment key that is used to distinguish commitments based on this construction from other MACs generated using HMAC-SHA256.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Commit<span class="math">(m,r)\\to c</span>, where $c=\\text{HMAC-SHA256}_{r}(CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m)<span class="math"> and </span>r\\leftarrow_{R}\\{0,1\\}^{512}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Commit takes the message <span class="math">m</span> and a randomly-chosen value <span class="math">r</span> as input and returns a commitment <span class="math">c</span>. <span class="math">r</span> can later be revealed to decommit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Decommit$(m^{\\prime},r^{\\prime},c)\\to\\left\\{\\begin{array}[]{ll}\\text{true}&\\text{if }c=\\text{HMAC-SHA256}_{r^{\\prime}}(CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m^{\\prime})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{false}&\\text{otherwise}\\end{array}\\right.<span class="math"> Decommit takes the purported message </span>m^{\\prime}<span class="math"> and decommitment key </span>r^{\\prime}<span class="math"> as input and recomputes the HMAC-SHA256 to check whether it equals the received commitment </span>c$. If so, the commitment is considered validly decommitted, and it is considered invalidly decommitted otherwise.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma C.1.</h6>

    <p class="text-gray-300">The construction above, which we denote <span class="math">\\Pi=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Decommit})</span>, is a correct, computationally hiding, computationally binding commitment if (1) HMAC-SHA256 is a PRF and (2) SHA-256 is a CRHF.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A commitment scheme is correct if <span class="math">\\mathsf{Decommit}(m,r,\\mathsf{Commit}(m,r))=\\mathsf{true}</span> for all <span class="math">m</span> and <span class="math">r</span>. One can see that <span class="math">\\Pi</span> is correct because <span class="math">\\mathsf{Decommit}(m,r,c)=\\mathsf{true}</span> when $c=\\text{HMAC-SHA256}_{r}(CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m)<span class="math">, which is exactly what </span>\\mathsf{Commit}(m,r)$ computes. The proofs of hiding and binding follow from Claims C.2 and C.3 respectively. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-70" class="text-base font-medium mt-4">Claim C.2.</h6>

    <p class="text-gray-300">If HMAC-SHA256 is a PRF, then <span class="math">\\Pi</span> is a computationally hiding commitment.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Computational hiding is defined with respect to the following game played by a probabilistic polynomial time (PPT) adversary <span class="math">\\mathcal{A}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The committer runs <span class="math">\\mathsf{Setup}(1^{n})\\to\\mathsf{CK}</span></li>

      <li><span class="math">\\mathcal{A}</span> picks two messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span>.</li>

      <li>The committer chooses <span class="math">b\\leftarrow_{R}\\{0,1\\}</span> and <span class="math">r\\leftarrow_{R}\\{0,1\\}^{k}</span>, computes <span class="math">c=\\mathsf{Commit}(m_{b},r)</span>, and sends <span class="math">c</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> outputs <span class="math">b^{\\prime}</span> and wins if <span class="math">b^{\\prime}=b</span>.</li>

    </ol>

    <p class="text-gray-300">Denote the probability (over the random choices of <span class="math">\\mathcal{A}</span> and the committer) that <span class="math">\\mathcal{A}</span> wins this game against commitment scheme <span class="math">\\Pi</span> by <span class="math">\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}</span>. We say that <span class="math">\\Pi</span> is computationally hiding if <span class="math">\\epsilon(n)\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}-\\frac{1}{2}</span> is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To see why <span class="math">\\epsilon(n)</span> must be negligible, we consider a variant of our scheme <span class="math">\\widetilde{\\Pi}=(\\widetilde{\\mathsf{Setup}},\\widetilde{\\mathsf{Commit}},\\widetilde{\\mathsf{Decommit}})</span> where HMAC-SHA256_{r}($CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m<span class="math">) is replaced by </span>f(CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m)<span class="math"> and </span>f<span class="math"> is a truly random function. In that case, </span>\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\widetilde{\\Pi}}(n)=1\\right\\}=\\frac{1}{2}$ and therefore,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\epsilon(n)=\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}-\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\widetilde{\\Pi}}(n)=1\\right\\}.</span></p>

    <p class="text-gray-300">Now, suppose that we construct a PPT algorithm <span class="math">\\mathcal{D}</span> that attempts to distinguish between HMAC-SHA256 and <span class="math">f</span> defined as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{D}</span> is given <span class="math">1^{n}</span> along with an oracle <span class="math">\\mathcal{O}</span> that is either HMAC-SHA256_{r}, where <span class="math">r\\leftarrow_{R}\\{0,1\\}^{512}</span>, or <span class="math">f</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathcal{D}</span> runs <span class="math">\\mathsf{Setup}(1^{n})\\to\\mathsf{CK}</span> and <span class="math">\\mathcal{A}(1^{n})</span>. When <span class="math">\\mathcal{A}</span> provides two messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span>, <span class="math">\\mathcal{D}</span> picks <span class="math">b\\leftarrow_{R}\\{0,1\\}</span>, and returns $c=\\mathcal{O}(CK\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,m_{b})<span class="math"> to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\mathcal{A}</span> outputs <span class="math">b^{\\prime}</span>, <span class="math">\\mathcal{D}</span> returns <span class="math">1</span> if <span class="math">b^{\\prime}=b</span> and <span class="math">0</span> otherwise.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">\\mathcal{O}</span> is HMAC-SHA256_{r}, then <span class="math">\\mathcal{A}</span>’s view when run as a subroutine of <span class="math">\\mathcal{D}</span> is identical to <span class="math">\\mathcal{A}</span>’s view when playing the computational hiding game. Thus,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left\\{\\mathcal{D}^{\\text{HMAC-SHA256}_{r}}(1^{n})=1\\right\\}=\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}</span></p>

    <p class="text-gray-300">where <span class="math">\\Pr\\left\\{\\mathcal{D}^{\\text{HMAC-SHA256}_{r}}(1^{n})=1\\right\\}</span> is taken over <span class="math">r</span> and <span class="math">\\mathcal{D}</span>’s and <span class="math">\\mathcal{A}</span>’s random choices, and similarly,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left\\{\\mathcal{D}^{f}(1^{n})=1\\right\\}=\\Pr\\left\\{\\mathsf{BreakHiding}_{\\mathcal{A},\\widetilde{\\Pi}}(n)=1\\right\\}</span></p>

    <p class="text-gray-300">and so</p>

    <p class="text-gray-300"><span class="math">\\epsilon(n)=\\Pr\\left\\{\\mathcal{D}^{\\text{HMAC-SHA256}_{r}}(1^{n})=1\\right\\}-\\Pr\\left\\{\\mathcal{D}^{f}(1^{n})=1\\right\\}.</span></p>

    <p class="text-gray-300">If <span class="math">\\epsilon(n)</span> were not negligible, then <span class="math">\\mathcal{D}</span> would be able to distinguish between HMAC-SHA256 and <span class="math">f</span>, violating our assumption that HMAC-SHA256 is a PRF. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Claim C.3.</p>

    <p class="text-gray-300">If SHA-256 is a CRHF, then <span class="math">\\Pi</span> is a computationally binding commitment.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Computational binding is defined with respect to the following game played by a PPT adversary <span class="math">\\mathcal{A}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> runs <span class="math">\\mathsf{Setup}(1^{n})\\to\\mathsf{CK}</span></li>

      <li><span class="math">\\mathcal{A}</span> picks two messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span> such that <span class="math">m_{0}\\neq m_{1}</span> and two decommitment keys <span class="math">r_{0}</span> and <span class="math">r_{1}</span>. <span class="math">\\mathcal{A}</span> then computes <span class="math">\\mathsf{Commit}(m_{0},r_{0})\\to c_{0}</span> and <span class="math">\\mathsf{Commit}(m_{1},r_{1})\\to c_{1}</span></li>

      <li><span class="math">\\mathcal{A}</span> outputs <span class="math">CK</span>, <span class="math">m_{0}</span>, <span class="math">m_{1}</span>, <span class="math">r_{0}</span>, <span class="math">r_{1}</span>, <span class="math">c_{0}</span>, and <span class="math">c_{1}</span> and wins if <span class="math">c_{0}=c_{1}</span>.</li>

    </ol>

    <p class="text-gray-300">Let the probability (over <span class="math">\\mathcal{A}</span>’s random choices) that <span class="math">\\mathcal{A}</span> wins this game against our scheme <span class="math">\\Pi</span> be <span class="math">\\Pr\\left\\{\\mathsf{BreakBinding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}</span>. If this probability is negligible, then we can say that <span class="math">\\Pi</span> is computationally binding.</p>

    <p class="text-gray-300">To see why it must be negligible, we construct a PPT algorithm <span class="math">\\mathcal{B}</span> that uses <span class="math">\\mathcal{A}</span> in an attempt to find a collision in SHA-256. <span class="math">\\mathcal{B}</span> is defined as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{B}</span> is given <span class="math">1^{n}</span> and runs <span class="math">\\mathcal{A}(1^{n})</span>.</li>

      <li>When <span class="math">\\mathcal{A}</span> outputs <span class="math">CK</span>, <span class="math">m_{0}</span>, <span class="math">m_{1}</span>, <span class="math">r_{0}</span>, <span class="math">r_{1}</span>, <span class="math">c_{0}</span>, and <span class="math">c_{1}</span>, <span class="math">\\mathcal{B}</span> constructs four messages:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">a_{0}</span> $=(r_{0}\\oplus\\text{ipad})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CK\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">a_{1}</span> $=(r_{1}\\oplus\\text{ipad})\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">CK\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">m_{1}$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">b_{1}</span> $=(r_{1}\\oplus\\text{opad})\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{SHA-256}(a_{1}),$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where opad is a string of <span class="math">64</span> 0x5c bytes and ipad is a string of <span class="math">64</span> 0x36 bytes. If <span class="math">b_{0}\\neq b_{1}</span>, <span class="math">\\mathcal{B}</span> outputs <span class="math">m=b_{0}</span> and <span class="math">m^{\\prime}=b_{1}</span>. Otherwise, <span class="math">\\mathcal{B}</span> outputs <span class="math">m=a_{0}</span> and <span class="math">m^{\\prime}=a_{1}</span>. <span class="math">\\mathcal{B}</span> wins if SHA-256<span class="math">(m)=\\text{SHA-256}(m^{\\prime})</span> and <span class="math">m\\neq m^{\\prime}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{A}</span>’s view when run as a subroutine of <span class="math">\\mathcal{B}</span> is identical to <span class="math">\\mathcal{A}</span>’s view when playing the computational binding game. Moreover, because HMAC-SHA256\${}_{r}(x)=\\text{SHA-256}((r\\oplus\\text{opad})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{SHA-256}((r\\oplus\\text{ipad})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)),<span class="math"> </span>\\mathcal{B}<span class="math"> wins exactly when </span>\\mathcal{A}<span class="math"> would have won the computational binding game (i.e., when </span>\\mathsf{Commit}(m_{0},r_{0})=\\mathsf{Commit}(m_{1},r_{1})<span class="math"> where </span>m_{0}\\neq m_{1}$). Thus,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr\\left\\{\\mathsf{Collision}_{\\mathcal{B}}^{\\text{SHA-256}}(1^{n})=1\\right\\}=\\Pr\\left\\{\\mathsf{BreakBinding}_{\\mathcal{A},\\Pi}(n)=1\\right\\}</span></p>

    <p class="text-gray-300">where <span class="math">\\Pr\\left\\{\\mathsf{Collision}_{\\mathcal{B}}^{\\text{SHA-256}}(1^{n})=1\\right\\}</span> is taken over <span class="math">\\mathcal{B}</span>’s (really <span class="math">\\mathcal{A}</span>’s) random choices. As a result, if the probability that <span class="math">\\mathcal{A}</span> wins the computational binding game were non-negligible, then the probability that <span class="math">\\mathcal{B}</span> finds a collision in SHA-256 would be as well, violating the assumption that SHA-256 is a CRHF. ∎</p>

    <h2 id="sec-73" class="text-2xl font-bold">Appendix D Applications and parameters</h2>

    <p class="text-gray-300">This appendix describes the configuration of our experimental evaluation (§8) in more detail.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">D.1 Details of sample applications</h3>

    <p class="text-gray-300"><em>Dot product.</em> Computes the dot product between two integer arrays, each of length <span class="math">m</span>. Each mapper gets a chunk of the input vectors and computes a partial dot product, outputting an integer. Each reducer gets as input a list of numbers, and sums it. Another reducer phase sums the sums.</p>

    <p class="text-gray-300"><em>Nucleotide substring search.</em> Searches <span class="math">m</span> nucleotides for length-<span class="math">d</span> substring. Each mapper gets as input a chunk of DNA and the same length-<span class="math">d</span> substring; if a mapper finds a match, it outputs the position of the match. Each reducer takes as input a list of locations and concatenates them.</p>

    <p class="text-gray-300">Nearest neighbor search. The search takes as input a length-<span class="math">d</span> target vector and a list of <span class="math">m</span> vectors, each of length <span class="math">d</span>. Each mapper gets as input a subset of the search list of <span class="math">m</span> vectors and the target vector. A mapper computes the Euclidean distance between the target vector and each vector in the subset, outputting a list of distances. Each reducer takes as input a list of Euclidean distances and computes the minimum. Another reducer phases computes the minimum among these minimums.</p>

    <p class="text-gray-300">Covariance matrix. Computes the covariance matrix for <span class="math">m</span> samples, each of dimension <span class="math">d</span>. Each mapper gets as input a subset of the samples and computes a <span class="math">d\\times d</span> covariance matrix, for its samples. Each reducer aggregates a set of these matrices, producing another <span class="math">d\\times d</span> matrix. Then, a final reduce phase produces the final covariance matrix.</p>

    <p class="text-gray-300">select, insert, and update. These queries do as their names imply. Our database has three indices, and parameters are given in Figures 10 and 12.</p>

    <p class="text-gray-300">Face matching. The prover stores a list of 928-bit fingerprints of faces and a threshold for each fingerprint. The verifier supplies a fingerprint of 928 bits, and the prover indicates that there is a match if and only if the Hamming distance between the input fingerprint and one of the faces in the list is below the threshold for that fingerprint. This algorithm is based on the approach of Osadchy et al. <em>[63]</em>.</p>

    <p class="text-gray-300">Tolling. The verifier is a toll collector, and the prover is a driver. The prover uses toll roads during a month and maintains a private database of its own toll road usage. Whenever the prover passes a tolling location, it adds a tuple to its database of the form (time, tolling_location_id, toll_amount). The verifier can randomly and unpredictably “spot check” the prover whenever it uses a tolling location by storing a tuple of the same form in a separate database; the prover cannot tell whether it has been spot checked. At the end of the month, the prover sends a commitment to its database to the verifier. The computation to be verified takes as input the prover’s commitment to its database and the spot checks that the verifier collected. The computation outputs reject if one of the spot checks does not have a “close matching tuple” in the database (two tuples are a close match when the tolling_location_id and toll_amount match and when the difference in the times is less than a system parameter). Otherwise, the computation returns the total cost of tolls incurred by the prover in that month.</p>

    <p class="text-gray-300">Regression analysis. The verifier is a data analyst who, for example, would like to learn a model for the effectiveness of a drug, based on a patient’s background and symptoms; the prover is a clinic. The prover holds a list of patient records and sends a commitment to this data to the verifier. The computation takes as input the prover’s commitment, a set of patient features to model, and a parameter <span class="math">k&gt;0</span>. The computation returns a linear function obtained by applying ridge regression <em>[45]</em> with regularization parameter <span class="math">k</span> to all patient records in the prover’s database; in the regression, the independent variables are the features, and the dependent variable is patient recovery time. That is, the linear function produced by the computation predicts a patient’s recovery time, as a function of the patient’s features, but does not reveal the details of any particular patient record.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">D.2 Parameters</h3>

    <p class="text-gray-300">For the experiments that use Zaatar, we configure the field <span class="math">\\mathbb{F}</span> (recall that <span class="math">\\mathbb{F}=\\mathbb{F}_{p}</span>) to have a prime modulus of 128 bits. Zaatar uses ElGamal encryption (as part of step (3) in Section 2.2), and our experiments presume 1024-bit keys <em>[71]</em>. For the experiments that use Pinocchio, we configure the field to have a prime modulus of 254 bits. For Pinocchio’s pairing-based cryptography, we use a BN curve that provides 128 bits of security <em>[11]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Below, we quantify the constants in the cost model in Figure 3. We run a set of microbenchmarks to measure the costs of the basic operations (e.g., encryption, decryption, multiplication, etc.) on our hardware platform ( <span class="math">\\S 8</span> ), and we use a detailed cost model from prior work [71] to estimate the constants. The values are as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zaatar</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pinocchio</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c1</td>

            <td class="px-3 py-2 border-b border-gray-700">9 ns</td>

            <td class="px-3 py-2 border-b border-gray-700">9 ns</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c2</td>

            <td class="px-3 py-2 border-b border-gray-700">77 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">230 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c3</td>

            <td class="px-3 py-2 border-b border-gray-700">205 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">6 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c4</td>

            <td class="px-3 py-2 border-b border-gray-700">4.8 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c5</td>

            <td class="px-3 py-2 border-b border-gray-700">170 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">243 μs</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 μs</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5 μs</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Accuracy and assumptions. For applications that we use in Pantry, our end-to-end empirical results are generally within  <span class="math">20\\%</span>  of their predictions, but for the prover, the empirics are smaller than predictions of the cost model by up to a factor of 2. The primary reason for this deviation, as mentioned earlier, is that Pantry's applications include a large number of storage constraints (§8), and the values taken by the variables in those constraints are much smaller than the prime modulus,  <span class="math">p</span> , which reduces the value of  <span class="math">c_{5}</span>  for such applications.</p>

    <p class="text-gray-300">Extensions for a more faithful model. One way to improve the accuracy of our simple cost model is to make  <span class="math">c_{5}</span>  depend on the relative number of bitwise operations and on the average number of bits in the values taken by variables in the constraints of a computation.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We first learned of the folklore approach to verifying computations with state from motivating comments by Yuval Ishai and an anonymous NDSS 2012 reviewer. Suggestions by Dan Boneh, Bryan Parno, Chris Peikert, and Shabsi Walfish substantially strengthened this work. We thank Chris and Shabsi for patient explanations. Feedback and comments from Sebastian Angel, Allen Clement, Josh Leners, David Mazières, Bryan Parno, Riad Wahby, Brent Waters, Edmond L. Wong, George Candea (our shepherd), and the anonymous reviewers improved this draft. The Texas Advanced Computing Center (TACC) at UT supplied computing resources. This work was supported by AFOSR grant FA9550-10-1-0073; NSF grants 1040672, 1055057, and 1040083; a Sloan Fellowship; and an Intel Early Career Faculty Award.</p>

    <p class="text-gray-300">For Pantry’s source code: http://cs.utexas.edu/pepper</p>

    <h2 id="sec-77" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Cassandra CQL. http://cassandra.apache.org/doc/cql/CQL.html.</li>

      <li>[2] High-speed software implementation of the optimal Ate pairing over Barreto-Naehrig curves. https://github.com/herumi/ate-pairing.</li>

      <li>[3] leveldb – a fast and lightweight key/value database library by Google. https://code.google.com/p/leveldb/.</li>

      <li>[4] M. Ajtai. Generating hard instances of lattice problems. In ACM Symposium on the Theory of Computing (STOC), pages 99–108, May 1996.</li>

      <li>[5] D. P. Anderson, J. Cobb, E. Korpela, M. Lebofsky, and D. Werthimer. SETI@home: An experiment in public-resource computing. Communications of the ACM (CACM), 45(11):56–61, Nov. 2002.</li>

      <li>[6] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. Proof verification and the hardness of approximation problems. Journal of the ACM, 45(3):501–555, May 1998.</li>

      <li>[7] S. Arora and S. Safra. Probabilistic checking of proofs: a new characterization of NP. Journal of the ACM, 45(1):70–122, Jan. 1998.</li>

      <li>[8] M. J. Atallah and K. B. Frikken. Securely outsourcing linear algebra computations. In ACM Symposium on Information, Computer and Communications Security (ASIACCS), pages 48–59, Apr. 2010.</li>

      <li>[9] L. Babai. Trading group theory for randomness. In ACM Symposium on the Theory of Computing (STOC), pages 421–429, May 1985.</li>

      <li>[10] B. Barak and O. Goldreich. Universal arguments and their applications. SIAM Journal on Computing, 38(5):1661–1694, 2008.</li>

      <li>[11] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography (SAC), 2006.</li>

      <li>[12] M. Bellare. New proofs for NMAC and HMAC: Security without collision-resistance. In CRYPTO, 2006.</li>

      <li>[13] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash functions for message authentication. In IACR International Cryptology Conference (CRYPTO), pages 1–15, 1996.</li>

      <li>[14] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In Innovations in Theoretical Computer Science (ITCS), pages 401–414, Jan. 2013.</li>

      <li>[15] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In IACR International Cryptology Conference (CRYPTO), pages 90–108, Aug. 2013.</li>

      <li>[16] S. Benabbas, R. Gennaro, and Y. Vahlis. Verifiable delegation of computation over large datasets. In IACR International Cryptology Conference (CRYPTO), pages 111–131, Aug. 2011.</li>

      <li>[17] J.-L. Beuchat, J. E. G. Diaz, S. Mitsunari, E. Okamoto, F. Rodriguez-Henriquez, and T. Teruya. High-speed software implementation of the optimal Ate pairing over Barreto-Naehrig curves. Cryptology ePrint Archive, Report 2010/354, June 2010. http://eprint.iacr.org/.</li>

      <li>[18] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Innovations in Theoretical Computer Science (ITCS), pages 326–349, Jan. 2012.</li>

      <li>[19] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In ACM Symposium on the Theory of Computing (STOC), pages 111–120, June 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[20] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In IACR Theory of Cryptography Conference (TCC), pages 315–333, Mar. 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[21] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. Checking the correctness of memories. In Symposium on Foundations of Computer Science (FOCS), pages 90–99, Oct. 1991.</li>

      <li>[22] D. Boneh and D. M. Freeman. Homomorphic signatures for polynomial functions. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), pages 149–168, May 2011.</li>

      <li>[23] G. Brassard, D. Chaum, and C. Crépeau. Minimum disclosure proofs of knowledge. Journal of Computer and System Sciences, 37(2):156–189, Oct. 1988.</li>

      <li>[24] B. Braun. Compiling computations to constraints for verified computation. UT Austin Honors thesis HR-12-10, Dec. 2012.</li>

      <li>[25] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state. In ACM Symposium on Operating Systems Principles (SOSP), pages 341–357, Nov. 2013.</li>

      <li>[26] R. Canetti, B. Riva, and G. Rothblum. Practical delegation of computation using multiple servers. In ACM Conference on Computer and Communications Security (CCS), pages 445–454, Oct. 2011.</li>

      <li>[27] M. Castro and B. Liskov. Practical Byzantine fault tolerance and proactive recovery. ACM Transactions on Computer Systems (TOCS), 20(4):398–461, Nov. 2002.</li>

      <li>[28] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical verified computation with streaming interactive proofs. In Innovations in Theoretical Computer Science (ITCS), pages 90–112, Jan. 2012.</li>

      <li>[29] J.-S. Coron, Y. Dodis, C. Malinaud, and P. Puniya. Merkle-damgård revisited: how to construct a hash function. In IACR International Cryptology Conference (CRYPTO), pages 430–448, Aug. 2005.</li>

      <li>[30] J. Dean and S. Ghemawat. MapReduce: simplified data processing on large clusters. In Symposium on Operating Systems Design and Implementation (OSDI), pages 107–113, Dec. 2004.</li>

      <li>[31] P. Devanbu, M. Gertz, C. Martel, and S. G. Stubblebine. Authentic third-party data publication. In Data and Application Security: Development and Directions, pages 101–112. Springer, 2002.</li>

      <li>[32] D. Fiore and R. Gennaro. Publicly verifiable delegation of large polynomials and matrix computations, with applications. In ACM Conference on Computer and Communications Security (CCS), pages 501–512, May 2012.</li>

      <li>[33] K. Fu, M. F. Kaashoek, and D. Mazières. Fast and secure distributed read-only file system. In Symposium on Operating Systems Design and Implementation (OSDI), pages 1–24, Oct. 2000.</li>

      <li>[34] B. Gassend, G. E. Suh, D. Clarke, M. van Dijk, and S. Devadas. Caches and hash trees for efficient memory integrity verification. In IEEE International Symposium on High Performance Computer Architecture (HPCA), pages 295–306, Feb. 2003.</li>

      <li>[35] R. Gennaro, C. Gentry, and B. Parno. Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In IACR International Cryptology Conference (CRYPTO), pages 465–482, Aug. 2010.</li>

      <li>[36] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), pages 626–645, May 2013.</li>

      <li>[37] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In ACM Symposium on the Theory of Computing (STOC), pages 99–108, June 2011.</li>

      <li>[38] E.-J. Goh, H. Shacham, N. Modadugu, and D. Boneh. SiRiUS: securing remote untrusted storage. In Network and Distributed System Security Symposium (NDSS), pages 131–145, Feb. 2003.</li>

      <li>[39] O. Goldreich. Foundations of Cryptography: II Basic Applications. Cambridge University Press, 2004.</li>

      <li>[40] O. Goldreich, S. Goldwasser, and S. Halevi. Collision-free hashing from lattice problems. Electronic Colloquium on Computational Complexity (ECCC), TR96-042:236–241, 1996.</li>

      <li>[41] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for muggles. In ACM Symposium on the Theory of Computing (STOC), pages 113–122, May 2008.</li>

      <li>[42] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

      <li>[43] P. Golle and I. Mironov. Uncheatable distributed computations. In RSA Conference, pages 425–440, Apr. 2001.</li>

      <li>[44] N. Hardy. The Confused Deputy: (or why capabilities might have been invented). ACM SIGOPS Operating Systems Review, 22(4):36–38, Oct. 1988.</li>

      <li>[45] A. E. Hoerl and R. W. Kennard. Ridge regression: Biased estimation for nonorthogonal problems.</li>

    </ul>

    <p class="text-gray-300">Technometrics, 12(1):55–67, 1970.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[46] Y. Ishai. Personal communication, June 2012.</li>

      <li>[47] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short PCPs. In IEEE Conference on Computational Complexity (CCC), pages 278–291, June 2007.</li>

      <li>[48] M. Kallahalla, E. Riedel, R. Swaminathan, Q. Wang, and K. Fu. Plutus: scalable secure file sharing on untrusted storage. In Conference on File and Storage Technologies (FAST), pages 29–42, Mar. 2003.</li>

      <li>[49] J. Katz and Y. Lindell. Introduction to Modern Cryptography. Chapman & Hall / CRC Press, 2007.</li>

      <li>[50] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In ACM Symposium on the Theory of Computing (STOC), pages 723–732, May 1992.</li>

      <li>[51] H. M. Levy. Capability-Based Computer Systems. Digital Press, 1984.</li>

      <li>[52] J. Li, M. N. Krohn, D. Mazières, and D. Shasha. Secure untrusted data repository (SUNDR). In Symposium on Operating Systems Design and Implementation (OSDI), pages 121–136, Dec. 2004.</li>

      <li>[53] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. Algebraic methods for interactive proof systems. Journal of the ACM, 39(4):859–868, 1992.</li>

      <li>[54] U. Maheshwari, R. Vingralek, and W. Shapiro. How to build a trusted database system on untrusted storage. In Symposium on Operating Systems Design and Implementation (OSDI), pages 135–150, Oct. 2000.</li>

      <li>[55] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay—a secure two-party computation system. In USENIX Security, pages 287–302, Aug. 2004.</li>

      <li>[56] D. Malkhi and M. Reiter. Byzantine quorum systems. Distributed Computing, 11(4):203–213, Oct. 1998.</li>

      <li>[57] C. Martel, G. Nuckolls, P. Devanbu, M. Gertz, A. Kwong, and S. G. Stubblebine. A general model for authenticated data structures. Algorithmica, 39(1):21–41, Jan. 2004.</li>

      <li>[58] R. C. Merkle. A digital signature based on a conventional encryption function. In IACR International Cryptology Conference (CRYPTO), pages 369–378, Aug. 1987.</li>

      <li>[59] D. Micciancio and O. Regev. Lattice-based cryptography. In D. J. Bernstein and J. Buchmann, editors, Post-quantum Cryptography, pages 147–191. Springer, 2008.</li>

      <li>[60] F. Monrose, P. Wycko, and A. D. Rubin. Distributed execution with remote audit. In Network and Distributed System Security Symposium (NDSS), pages 103–113, Feb. 1999.</li>

      <li>[61] R. Motwani and P. Raghavan. Randomized Algorithms. Cambridge University Press, 1995.</li>

      <li>[62] V. Nikolaenko, U. Weinsberg, S. Ioannidis, M. Joye, D. Boneh, and N. Taft. Privacy-preserving ridge regression on hundreds of millions of records. In IEEE Symposium on Security and Privacy, pages 334–348, May 2013.</li>

      <li>[63] M. Osadchy, B. Pinkas, A. Jarrous, and B. Moskovich. SCiFI – a system for secure face identification. In IEEE Symposium on Security and Privacy, pages 239–254, May 2010.</li>

      <li>[64] C. Papamanthou, E. Shi, and R. Tamassia. Signatures of correct computation. In IACR Theory of Cryptography Conference (TCC), pages 222–242, Mar. 2013.</li>

      <li>[65] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In IEEE Symposium on Security and Privacy, pages 238–252, May 2013.</li>

      <li>[66] B. Parno, J. M. McCune, and A. Perrig. Bootstrapping Trust in Modern Computers. Springer, 2011.</li>

      <li>[67] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In IACR International Cryptology Conference (CRYPTO), pages 129–140, Aug. 1991.</li>

      <li>[68] R. A. Popa, H. Balakrishnan, and A. Blumberg. VPriv: Protecting privacy in location-based vehicular services. In USENIX Security, pages 335–350, Aug. 2009.</li>

      <li>[69] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn, and P. Khosla. Pioneer: Verifying integrity and guaranteeing execution of code on legacy platforms. In ACM Symposium on Operating Systems Principles (SOSP), pages 1–16, Oct. 2005.</li>

      <li>[70] S. Setty, A. J. Blumberg, and M. Walfish. Toward practical and unconditional verification of remote computations. In Workshop on Hot Topics in Operating Systems (HotOS), May 2011.</li>

      <li>[71] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In European Conference on Computer Systems (EuroSys), pages 71–84, Apr. 2013.</li>

      <li>[72] S. Setty, R. McPherson, A. J. Blumberg, and M. Walfish. Making argument systems for outsourced computation practical (sometimes). In Network and Distributed System Security Symposium (NDSS), Feb. 2012.</li>

      <li>[73] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified</li>

    </ul>

    <p class="text-gray-300">computation a few steps closer to practicality. In USENIX Security, pages 253–268, Aug. 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[74] H. Shacham and B. Waters. Compact proofs of retrievability. In ASIACRYPT, pages 90–107, Dec. 2008.</li>

      <li>[75] A. Shamir. IP = PSPACE. Journal of the ACM, 39(4):869–877, Oct. 1992.</li>

      <li>[76] R. Sion. Query execution assurance for outsourced databases. In International Conference on Very Large Databases (VLDB), pages 601–612, Aug. 2005.</li>

      <li>[77] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In IACR International Cryptology Conference (CRYPTO), pages 71–89, Aug. 2013.</li>

      <li>[78] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pfister. Verifiable computation with massively parallel interactive proofs. In USENIX HotCloud Workshop, June 2012.</li>

      <li>[79] B. Thompson, S. Haber, W. G. Horne, T. Sander, and D. Yao. Privacy-preserving computation and verification of aggregate queries on outsourced databases. In Privacy Enhancing Technologies Symposium, pages 185–201, Aug. 2009.</li>

      <li>[80] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for interactive verifiable computation. In IEEE Symposium on Security and Privacy, pages 223–237, May 2013.</li>

      <li>[81] C. Wang, K. Ren, and J. Wang. Secure and practical outsourcing of linear programming in cloud computing. In IEEE International Conference on Computer Communications (INFOCOM), pages 820–828, Apr. 2011.</li>

      <li>[82] S. Zahur and D. Evans. Circuit structures for improved efficiency of security and privacy tools. In IEEE Symposium on Security and Privacy, pages 493–507, May 2013.</li>

      <li>[83] L. Zhou. Personal communication, Oct. 2012.</li>

    </ul>`;
---

<BaseLayout title="Verifying Computations with State (Extended Version) (2013/356)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/356
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
