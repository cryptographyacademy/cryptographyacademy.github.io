---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/261';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Efficiency for CCA-Secure Cryptosystems Built Using Identity-Based Encryption';
const AUTHORS_HTML = 'Dan Boneh, Jonathan Katz';

const CONTENT = `    <p class="text-gray-300">1</p>

    <p class="text-gray-300">DAN BONEH*  JONATHAN KATZ†</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">Recently, Canetti, Halevi, and Katz showed a general method for constructing CCA-secure encryption schemes from identity-based encryption schemes in the standard model. We improve the efficiency of their construction, and show two specific instantiations of our resulting scheme which offer the most efficient encryption (and, in one case, key generation) of any CCA-secure encryption scheme to date.</p>

    <p class="text-gray-300">Keywords: Chosen-ciphertext security, Identity-based encryption, Public-key encryption.</p>

    <p class="text-gray-300">Security against adaptive chosen-ciphertext attacks (i.e., "CCA-security") [29, 17, 1] has become the de facto level of security for public-key encryption schemes. The reasons for this are many: CCA security helps protect against subtle attacks that have been demonstrated against schemes not meeting this notion of security [3, 24, 23]; is helpful in defending against "active" attackers who may modify messages in transit (see [32]); and, finally, allows encryption schemes to be developed and then securely "plugged in" to higher-level protocols which may then be executed in arbitrary environments (see, e.g., [8, Sec. 8.2.2]).</p>

    <p class="text-gray-300">Nevertheless, only a relatively small number of encryption schemes have been rigorously proven secure against adaptive chosen-ciphertext attacks in the standard model¹ (i.e., without resorting to the use of random oracles [2]). Schemes based on general assumptions are known [17, 30, 27], but these rely on generic non-interactive zero-knowledge proofs [4, 18] and do not currently lead to practical solutions. More interesting from a practical point of view are efficient schemes based on specific number-theoretic assumptions; two general methodologies for constructing such schemes are known. The first methodology is based on the "smooth hash proof systems" of Cramer and Shoup [14], and has led to a variety of constructions [13, 14, 19, 15, 25]. The second, and more recent, method [11] constructs a CCA-secure encryption scheme from any semantically-secure (or, "CPA-secure") identity-based encryption (IBE) scheme [7, 12] (which can in turn be constructed in the standard model based on specific number-theoretic assumptions [10, 5, 6, 34]). Overall, the most efficient CCA-secure encryption scheme currently known is a hybrid encryption system due to Kurosawa and Desmedt [25] which builds on the original proposal of Cramer and Shoup [13] and relies on the decisional Diffie-Hellman assumption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>dabo@cs.stanford.edu. Computer Science Department, Stanford University. Supported by NSF and the Packard Foundation.</li>

    </ul>

    <p class="text-gray-300">† jkatz@cs.umd.edu. Department of Computer Science, University of Maryland. This research was supported by NSF Trusted Computing Grant #0310751.</p>

    <p class="text-gray-300">¹From now on, we use "CCA security" to refer by default to security which is proven in the standard model.</p>

    <p class="text-gray-300">In this paper, we suggest a new method which allows for the construction of very efficient CCA-secure encryption schemes. Our technique modifies the approach of Canetti, Halevi, and Katz <em>[11]</em>, who (as noted above) show a transformation from any semantically-secure “weak” IBE scheme to a CCA-secure public-key encryption scheme. Briefly and somewhat informally, their transformation from an IBE scheme (<span class="math">\\mathsf{Setup},\\mathsf{Der},\\mathsf{Enc},\\mathsf{Dec}</span>) to a CCA-secure scheme proceeds as follows: key generation is performed by running <span class="math">\\mathsf{Setup}</span> and letting the public (resp. secret) key be the master public key <span class="math">PK</span> (resp., master secret key <span class="math">\\mathsf{msk}</span>) output by this algorithm. To encrypt a message <span class="math">m</span> using public key <span class="math">PK</span>, a sender generates a random key-pair <span class="math">(vk,sk)</span> for a one-time signature scheme and sends the ciphertext <span class="math">\\langle vk,\\mathsf{Enc}_{PK}(vk,m),\\sigma\\rangle</span>, where <span class="math">\\mathsf{Enc}_{PK}(vk,m)</span> represents an encryption of message <span class="math">m</span> for the “identity” <span class="math">vk</span> using master public parameters <span class="math">PK</span>, and <span class="math">\\sigma</span> represents a signature on the second component of this ciphertext using <span class="math">sk</span>. To decrypt ciphertext <span class="math">\\langle vk,C,\\sigma\\rangle</span>, the receiver first verifies whether <span class="math">\\mathsf{Vrfy}_{vk}(C,\\sigma)\\stackrel{{\\scriptstyle?}}{{=}}1</span>. If so, the receiver then decrypts <span class="math">C</span> with respect to the “identity” <span class="math">vk</span> (it can do this since it has the master secret key <span class="math">\\mathsf{msk}</span>).</p>

    <p class="text-gray-300">Though conceptually simple, this transformation does add noticeable overhead to the underlying IBE scheme: encryption requires the sender to generate keys for a one-time signature scheme <em>[26]</em> and also to compute a signature using the keys just generated; decryption requires the receiver to verify a signature with respect to the verification key included as part of the ciphertext. Although one-time signatures are “easy” to construct in theory, and are more efficient than “full-blown” signatures (i.e., those which are existentially unforgeable under an adaptive chosen-message attack <em>[20]</em>), they still have their price. In particular:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One-time signatures based on cryptographic hash functions such as SHA-1 can be designed to allow very efficient <em>signing</em>; key generation, on the other hand, typically requires hundreds of hash function evaluations and is relatively expensive (though not as expensive as key generation in schemes based on number-theoretic assumptions). More problematic, perhaps, is that such schemes have very long public keys and signatures, which would result in very long ciphertexts in the scheme of <em>[11]</em>.</li>

      <li>One-time signatures based on number-theoretic assumptions (say, by adapting “full-blown” signature schemes) yield schemes whose computational cost — both for key generation and signing — is more expensive, but which have the advantage of short(er) public keys and signatures.</li>

    </ul>

    <p class="text-gray-300">Either way, the transformation of Canetti, Halevi, and Katz results in a CCA-secure encryption scheme which is less efficient than the underlying IBE system.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Contribution</h3>

    <p class="text-gray-300">We describe a transformation from any CPA-secure “weak” IBE system to a CCA-secure encryption scheme which adds essentially no overhead. The efficiency advantage of our approach arises from our observation that the one-time signature in the construction of Canetti, et al. (as described earlier) can be replaced by a message-authentication code (mac) along with an appropriate “encapsulation” of a mac key (for the purposes of this informal description, one can think of an encapsulation as a commitment). Using the notation introduced earlier, encryption using our approach is now performed (informally) by first “encapsulating” a key <span class="math">r</span> which results in an encapsulation <span class="math">\\mathsf{com}</span> along with a decommitment string <span class="math">\\mathsf{dec}</span>. The final ciphertext is <span class="math">\\langle\\mathsf{com},\\mathsf{Enc}_{PK}(\\mathsf{com},m\\circ\\mathsf{dec}),\\mathsf{tag}\\rangle</span>, where <span class="math">\\mathsf{tag}</span></p>

    <p class="text-gray-300">is now a message authentication code computed on the second component of the ciphertext using key <span class="math">r</span>. Decryption of ciphertext <span class="math">\\langle\\mathtt{com},C,\\mathtt{tag}\\rangle</span> is done in the natural way, but note that here the receiver must first decrypt <span class="math">C</span> (with respect to “identity” <span class="math">\\mathtt{com}</span>) and only then can the receiver verify the correctness of <span class="math">\\mathtt{tag}</span>. Indeed, this feature of our scheme complicates the security proof somewhat (and in particular we must be careful to avoid circular arguments).</p>

    <p class="text-gray-300">Adapting <em>[16, 21]</em>, we show how encapsulation of the mac key can be done both efficiently and securely using, e.g., SHA-1: encapsulation requires only a single hash function evaluation, and is secure under the assumption that SHA-1 is second-preimage resistant (the scheme can be easily modified so as to be secure under the weaker assumption of the existence of UOWHFs <em>[28]</em>). This encapsulation scheme may have other applications, and thus the scheme — as well as the relatively simple proof of security we provide for this encapsulation scheme here (cf. Theorem 2) — may be of independent interest. Furthermore, our technique of replacing a one-time signature by a mac seems applicable to other constructions (e.g., those of <em>[17, 30]</em> as well as the various extensions mentioned in <em>[11]</em>), giving efficiency improvements in those cases as well.</p>

    <p class="text-gray-300">In addition to the general method discussed above, we also show two specific instantiations of our approach based on two IBE schemes recently introduced by Boneh and Boyen <em>[5]</em>. Our resulting schemes are quite efficient: in particular, the times required for key generation and encryption are as fast as (or faster than) the most efficient previous CCA-secure schemes to date.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Hybrid Encryption</h3>

    <p class="text-gray-300">In practice, public-key encryption is almost never used to encrypt actual data. Instead, <em>hybrid encryption</em> is typically used, whereby a public-key scheme is used to encrypt a random key, and the data is then encrypted using some symmetric-key encryption scheme and this key. In fact, “encryption” of the symmetric key is not required; “encapsulation” (cf. <em>[33]</em>) — which may be more efficient — is enough. It is well known that if both the public-key encapsulation scheme and the underlying symmetric-key encryption scheme are CCA-secure, then the resulting hybrid scheme is CCA-secure as well.</p>

    <p class="text-gray-300">Interestingly, Kurosawa and Desmedt have recently shown <em>[25]</em> that the public-key encapsulation scheme does not necessarily need to be CCA-secure in order for the resulting hybrid scheme to be CCA-secure. In particular, they show a hybrid encryption scheme which is based on, but more efficient than, the Cramer-Shoup scheme <em>[13]</em> <em>when used for hybrid encryption</em>. The specific hybrid schemes proposed here are as efficient as the Kurosawa-Desmedt scheme in terms of encryption (and, in one case, key generation), but somewhat less efficient in other measures; we provide detailed comparisons in Section 4. It is somewhat surprising that constructions based on completely different approaches end up having such similar performance for both encryption and key generation.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Outline</h3>

    <p class="text-gray-300">In Section 3, we present and prove secure a generic construction of a CCA-secure encryption scheme based on a variety of primitives (IBE, macs, and encapsulation) formally defined in Section 2. Section 4 describes in more detail two specific instantiations of the various primitives; the efficiency of the resulting schemes are then compared with previous work.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Basic Definitions</h2>

    <p class="text-gray-300">We review the standard definitions of public-key encryption schemes and their security against adaptive chosen-ciphertext attacks. This is followed by definitions of identity-based encryption,</p>

    <p class="text-gray-300">message authentication, and “encapsulation” as needed for our construction.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1 (Public-key encryption)</h6>

    <p class="text-gray-300">A public-key encryption scheme <span class="math">\\mathsf{PKE}</span> is a triple of ppt algorithms (<span class="math">\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec}</span>) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The randomized key generation algorithm <span class="math">\\mathsf{Gen}</span> takes as input a security parameter <span class="math">1^{k}</span> and outputs a public key <span class="math">PK</span> and a secret key <span class="math">SK</span>. We write <span class="math">(PK,SK)\\leftarrow\\mathsf{Gen}(1^{k})</span>.</li>

      <li>The randomized encryption algorithm <span class="math">\\mathsf{Enc}</span> takes as input a public key <span class="math">PK</span> and a message <span class="math">m\\in\\{0,1\\}^{*}</span>, and outputs a ciphertext <span class="math">C</span>. We write <span class="math">C\\leftarrow\\mathsf{Enc}_{PK}(m)</span>.</li>

      <li>The decryption algorithm <span class="math">\\mathsf{Dec}</span> takes as input a ciphertext <span class="math">C</span> and a secret key <span class="math">SK</span>. It returns a message <span class="math">m\\in\\{0,1\\}^{*}</span> or the distinguished symbol <span class="math">\\bot</span>. We write <span class="math">m\\leftarrow\\mathsf{Dec}_{SK}(C)</span>.</li>

    </ul>

    <p class="text-gray-300">We require that for all <span class="math">(PK,SK)</span> output by <span class="math">\\mathsf{Gen}</span>, all <span class="math">m\\in\\{0,1\\}^{*}</span>, and all <span class="math">C</span> output by <span class="math">\\mathsf{Enc}_{PK}(m)</span> we have <span class="math">\\mathsf{Dec}_{SK}(C)=m</span>. <span class="math">\\blacksquare</span></p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2 (CCA security)</h6>

    <p class="text-gray-300">A public-key encryption scheme <span class="math">\\mathsf{PKE}</span> is secure against adaptive chosen-ciphertext attacks (i.e., is “CCA-secure”) if the advantage of any ppt adversary <span class="math">A</span> in the following game is negligible in the security parameter <span class="math">k</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{k})</span> outputs <span class="math">(PK,SK)</span>. Adversary <span class="math">A</span> is given <span class="math">1^{k}</span> and <span class="math">PK</span>.</li>

      <li>The adversary may make polynomially-many queries to a decryption oracle <span class="math">\\mathsf{Dec}_{SK}(\\cdot)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. At some point, <span class="math">A</span> outputs two messages <span class="math">m_{0},m_{1}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. A bit </span>b<span class="math"> is randomly chosen and the adversary is given a “challenge ciphertext” </span>C^{*}\\leftarrow\\mathsf{Enc}_{PK}(m_{b})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> may continue to query its decryption oracle <span class="math">\\mathsf{Dec}_{SK}(\\cdot)</span> except that it may not request the decryption of <span class="math">C^{*}</span>.</li>

      <li>Finally, <span class="math">A</span> outputs a guess <span class="math">b^{\\prime}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">A</span> succeeds if <span class="math">b^{\\prime}=b</span>, and denote the probability of this event by <span class="math">\\Pr_{A,\\mathsf{PKE}}[\\mathsf{Succ}]</span>. The adversary’s advantage is defined as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{A,\\mathsf{PKE}}[\\mathsf{Succ}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. </span>\\blacksquare$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Identity-Based Encryption</h3>

    <p class="text-gray-300">Informally, an IBE scheme is a public-key encryption scheme in which any string (i.e., identity) can serve as a public key. In more detail, a setup algorithm is first run to generate “master” public and secret keys. Given the master secret key and any string <span class="math">ID\\in\\{0,1\\}^{<em>}</span> (which can be viewed as an identity), it is possible to derive a “personal secret key” <span class="math">SK_{ID}</span>. Any sender can encrypt a message for “identity” <span class="math">ID</span> using only the master public key and the string <span class="math">ID</span>. The resulting ciphertext can be decrypted using the derived secret key <span class="math">SK_{ID}</span>, but the message remains hidden from an adversary who does not know <span class="math">SK_{ID}</span> even if that adversary is given <span class="math">SK_{ID^{\\prime}}</span> for multiple identities <span class="math">ID^{\\prime}\\neq ID</span>. The concept of identity-based encryption was introduced by Shamir </em>[31]<em>, and provably-secure IBE schemes in the random oracle model were demonstrated by Boneh and Franklin </em>[7]<em> and Cocks </em>[12]<em>. More recently, provably-secure IBE schemes in the standard model have been developed </em>[10, 5, 6, 34]*; see further discussion below.</p>

    <p class="text-gray-300">In the original definition of security for IBE proposed and achieved by Boneh and Franklin <em>[7]</em>, the adversary may choose the “target identity” (<span class="math">ID</span> in the above discussion) in an adaptive</p>

    <p class="text-gray-300">manner, based on the master public key and any keys <span class="math">SK_{ID^{\\prime}}</span> the adversary has obtained thus far. A weaker notion of security, proposed and achieved by Canetti, Halevi, and Katz <em>[10]</em>, requires the adversary to specify the target identity <em>before</em> the public-key is published; we will refer to this notion of security as “weak” IBE. As in <em>[11]</em>, our construction only requires weak IBE schemes secure against chosen-plaintext attacks. We therefore only recall this definition of security.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 3 (IBE)</h6>

    <p class="text-gray-300">An identity-based encryption scheme IBE is a 4-tuple of ppt algorithms (Setup, Der, Enc, Dec) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The randomized setup algorithm Setup takes as input a security parameter <span class="math">1^{k}</span> and a value <span class="math">\\ell</span> for the identity length. It outputs some system-wide parameters <span class="math">PK</span> along with a master secret key msk. (We assume that <span class="math">k</span> and <span class="math">\\ell</span> are implicit in <span class="math">PK</span>.)</li>

      <li>The (possibly randomized) key derivation algorithm Der takes as input the master key msk and an identity <span class="math">ID\\in\\{0,1\\}^{\\ell}</span>. It returns the corresponding decryption key <span class="math">SK_{ID}</span>. We write <span class="math">SK_{ID}\\leftarrow\\textsf{Der}_{\\mathsf{msk}}(ID)</span>.</li>

      <li>The randomized encryption algorithm Enc takes as input the system-wide public key <span class="math">PK</span>, an identity <span class="math">ID\\in\\{0,1\\}^{\\ell}</span>, and a message <span class="math">m\\in\\{0,1\\}^{*}</span>; it outputs a ciphertext <span class="math">C</span>. We write <span class="math">C\\leftarrow\\textsf{Enc}_{PK}(ID,m)</span>.</li>

      <li>The decryption algorithm Dec takes as input an identity <span class="math">ID</span>, its associated decryption key <span class="math">SK_{ID}</span>, and a ciphertext <span class="math">C</span>. It outputs a message <span class="math">m\\in\\{0,1\\}^{*}</span> or the distinguished symbol <span class="math">\\bot</span>. We write <span class="math">m\\leftarrow\\textsf{Dec}_{SK_{ID}}(ID,C)</span>.</li>

    </ul>

    <p class="text-gray-300">We require that for all <span class="math">(PK,\\mathsf{msk})</span> output by Setup, all <span class="math">ID\\in\\{0,1\\}^{\\ell}</span>, all <span class="math">SK_{ID}</span> output by <span class="math">\\textsf{Der}_{\\mathsf{msk}}(ID)</span>, all <span class="math">m\\in\\{0,1\\}^{*}</span>, and all <span class="math">C</span> output by <span class="math">\\textsf{Enc}_{PK}(ID,m)</span> we have <span class="math">\\textsf{Dec}_{SK_{ID}}(ID,C)=m</span>. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">As mentioned earlier, we provide a definition of security only for the case of “weak” IBE, as considered in <em>[10, 5]</em>. (Of course, a scheme satisfying the stronger definition of <em>[7, 6]</em> is trivially a weak IBE scheme as well.)</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 4 (Selective-ID IBE)</h6>

    <p class="text-gray-300">An identity-based scheme IBE is secure against selective-identity, chosen-plaintext attacks if for all polynomially-bounded functions <span class="math">\\ell(\\cdot)</span> the advantage of any ppt adversary <span class="math">A</span> in the following game is negligible in the security parameter <span class="math">k</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A(1^{k},\\ell(k))</span> outputs a target identity <span class="math">ID^{*}\\in\\{0,1\\}^{\\ell(k)}</span>.</li>

      <li><span class="math">\\mathsf{Setup}(1^{k},\\ell(k))</span> outputs <span class="math">(PK,\\mathsf{msk})</span>. The adversary is given <span class="math">PK</span>.</li>

      <li>The adversary <span class="math">A</span> may make polynomially-many queries to an oracle <span class="math">\\textsf{Der}_{\\mathsf{msk}}(\\cdot)</span>, except that it may not request the secret key corresponding to the target identity <span class="math">ID^{*}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. At some point, <span class="math">A</span> outputs two messages <span class="math">m_{0},m_{1}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. A bit </span>b<span class="math"> is randomly chosen and the adversary is given a “challenge ciphertext” </span>C^{<em>}\\leftarrow\\textsf{Enc}_{PK}(ID^{</em>},m_{b})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> may continue to query its oracle <span class="math">\\textsf{Der}_{\\mathsf{msk}}(\\cdot)</span>, but still may not request the secret key corresponding to the identity <span class="math">ID^{*}</span>.</li>

      <li>Finally, <span class="math">A</span> outputs a guess <span class="math">b^{\\prime}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">A</span> succeeds if <span class="math">b^{\\prime}=b</span>, and denote the probability of this event by <span class="math">\\Pr_{A,\\mathsf{IBE}}[\\mathsf{Succ}]</span>. The adversary’s advantage is defined as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{A,\\mathsf{IBE}}[\\mathsf{Succ}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. </span>\\blacksquare$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For completeness, we remark that a slightly weaker definition — in which <span class="math">\\ell=\\Omega(\\log k)</span> is <em>a priori</em> bounded, rather than being given as a parameter to Setup — suffices for our construction.</p>

    <p class="text-gray-300">2.2 Message Authentication</p>

    <p class="text-gray-300">We view a <em>message authentication code</em> as a pair of ppt algorithms (Mac, Vrfy). The authentication algorithm Mac takes as input a key <span class="math">sk</span> and a message <span class="math">M</span>, and outputs a string tag. The verification algorithm Vrfy takes as input a key <span class="math">sk</span>, a message <span class="math">M</span>, and a string tag; it outputs either 0 (“reject”) or 1 (“accept”). We require that for all <span class="math">sk</span> and <span class="math">M</span> we have <span class="math">\\textsf{Vrfy}_{sk}(M,\\textsf{Mac}_{sk}(M))=1</span>. For simplicity, we assume that Mac and Vrfy are deterministic.</p>

    <p class="text-gray-300">We give a definition of security tailored to the requirements of our construction; in particular, we require only “one-time” security for our message authentication code. We remark that efficient schemes satisfying this definition can be constructed without any computational assumptions using, e.g., almost strongly universal hash families <em>[35]</em>.</p>

    <p class="text-gray-300">Definition 5 (Message authentication) A message authentication code <span class="math">(\\textsf{Mac},\\textsf{Vrfy})</span> is secure against a one-time chosen-message attack if the success probability of any ppt adversary <span class="math">A</span> in the following game is negligible in the security parameter <span class="math">k</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A random key <span class="math">sk\\in\\{0,1\\}^{k}</span> is chosen.</li>

      <li><span class="math">A(1^{k})</span> outputs a message <span class="math">M</span> and is given in return <span class="math">\\texttt{tag}=\\texttt{Mac}_{sk}(M)</span>.</li>

      <li><span class="math">A</span> outputs a pair <span class="math">(M^{\\prime},\\texttt{tag}^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">We say that <span class="math">A</span> <em>succeeds</em> if <span class="math">(M,\\texttt{tag})\\neq(M^{\\prime},\\texttt{tag}^{\\prime})</span> and <span class="math">\\textsf{Vrfy}_{sk}(M^{\\prime},\\texttt{tag}^{\\prime})=1</span>. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">In the above, the adversary succeeds even if <span class="math">M=M^{\\prime}</span> but <span class="math">\\texttt{tag}\\neq\\texttt{tag}^{\\prime}</span>. Thus, the definition corresponds to what has been termed “strong” security in the context of signature schemes.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 Encapsulation</h3>

    <p class="text-gray-300">We define a notion of “encapsulation” which may be viewed as a weak variant of commitment. (Note that our definition is unrelated to that of <em>key encapsulation</em> which was discussed in Section 1.2.) In terms of functionality, an encapsulation scheme commits the sender to a <em>random string</em> as opposed to a chosen message as in the case of commitment. In terms of security, our construction only requires binding to hold for <em>honestly-generated encapsulations</em>; this is analogous to assuming an honest sender during the first phase of a commitment scheme.</p>

    <p class="text-gray-300">Definition 6 (Encapsulation) An encapsulation scheme is a triple of ppt algorithms <span class="math">(\\texttt{Setup},\\mathcal{S},\\mathcal{R})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup takes as input the security parameter <span class="math">1^{k}</span> and outputs a string pub.</li>

      <li><span class="math">\\mathcal{S}</span> takes as input <span class="math">1^{k}</span> and pub, and outputs <span class="math">(r,\\texttt{com},\\texttt{dec})</span> with <span class="math">r\\in\\{0,1\\}^{k}</span>. We refer to com as the public commitment string and dec as the de-commitment string.</li>

      <li><span class="math">\\mathcal{R}</span> takes as input <span class="math">(\\texttt{pub},\\texttt{com},\\texttt{dec})</span> and outputs an <span class="math">r\\in\\{0,1\\}^{k}\\cup\\{\\bot\\}</span>.</li>

    </ul>

    <p class="text-gray-300">We require that for all pub output by Setup and for all <span class="math">(r,\\texttt{com},\\texttt{dec})</span> output by <span class="math">\\mathcal{S}(1^{k},\\texttt{pub})</span>, we have <span class="math">\\mathcal{R}(\\texttt{pub},\\texttt{com},\\texttt{dec})=r</span>. We also assume for simplicity that com and dec have fixed lengths for any given value of the security parameter. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">As in the case of commitment, an encapsulation scheme satisfies notions of both binding and hiding. Informally, “hiding” requires that com should leak no information about <span class="math">r</span>; more formally, the string <span class="math">r</span> should be indistinguishable from random even when given com (and pub). “Binding”</p>

    <p class="text-gray-300">requires that an honestly-generated com can be “opened” to only a single (legal) value of <span class="math">r</span>; see below.</p>

    <p class="text-gray-300"><strong>Definition 7 (Secure encapsulation)</strong> An encapsulation scheme <span class="math">(\\mathsf{Setup},\\mathcal{S},\\mathcal{R})</span> is secure if it satisfies both hiding and binding as follows:</p>

    <p class="text-gray-300"><strong>Hiding:</strong> The following is negligible for all PPT <span class="math">A</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c} \\mathsf{pub} \\leftarrow \\mathsf{Setup}(1^k); r_0 \\leftarrow \\{0, 1\\}^k; \\\\ (r_1, \\mathsf{com}, \\mathsf{dec}) \\leftarrow \\mathcal{S}(1^k, \\mathsf{pub}); b \\leftarrow \\{0, 1\\} \\end{array} \\right. \\quad : \\quad A(1^k, \\mathsf{pub}, \\mathsf{com}, r_b) = b \\right] - \\frac{1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Binding:</strong> The following is negligible for all PPT <span class="math">A</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf{pub} \\leftarrow \\mathsf{Setup}(1^k); \\\\ (r, \\mathsf{com}, \\mathsf{dec}) \\leftarrow \\mathcal{S}(1^k, \\mathsf{pub}); \\\\ \\mathsf{dec}&#x27; \\leftarrow A(1^k, \\mathsf{pub}, r, \\mathsf{com}, \\mathsf{dec}) \\end{array} \\quad : \\quad \\mathcal{R}(\\mathsf{pub}, \\mathsf{com}, \\mathsf{dec}&#x27;) \\notin \\{\\bot, r\\} \\right].</span></div>

    <p class="text-gray-300">In the above, both hiding and binding are required to hold only computationally. In Section 4 we show a novel encapsulation scheme which is both simple and efficient, and which achieves <em>statistical</em> hiding (and computational binding).</p>

    <p class="text-gray-300">We now describe our construction of a CCA-secure encryption scheme from the primitives introduced in the previous section. Let <span class="math">(\\mathsf{Setup}&#x27;, \\mathsf{Der}&#x27;, \\mathsf{Enc}&#x27;, \\mathsf{Dec}&#x27;)</span> be an IBE scheme, <span class="math">(\\mathsf{Setup}, \\mathcal{S}, \\mathcal{R})</span> be an encapsulation scheme, and <span class="math">(\\mathsf{Mac}, \\mathsf{Vrfy})</span> be a message authentication code. Our scheme is constructed as follows:</p>

    <p class="text-gray-300"><strong>Key generation</strong> Keys for our scheme are generated by running <span class="math">\\mathsf{Setup}&#x27;(1^k)</span> to generate <span class="math">(PK, \\mathsf{msk})</span> and <span class="math">\\mathsf{Setup}(1^k)</span> to generate pub. The public key is <span class="math">(PK, \\mathsf{pub})</span>, and the secret key is msk.</p>

    <p class="text-gray-300"><strong>Encryption</strong> To encrypt a message <span class="math">m</span> using public key <span class="math">(PK, \\mathsf{pub})</span>, a sender first encapsulates a random value by running <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span> to obtain <span class="math">(r, \\mathsf{com}, \\mathsf{dec})</span>. The sender then encrypts the “message” <span class="math">m \\circ \\mathsf{dec}</span> with respect to the “identity” com; that is, the sender computes <span class="math">C \\leftarrow \\mathsf{Enc}_{PK}&#x27;(\\mathsf{com}, m \\circ \\mathsf{dec})</span>. The resulting ciphertext <span class="math">C</span> is then authenticated by using <span class="math">r</span> as a key for a message authentication code; i.e., the sender computes <span class="math">\\mathsf{tag} = \\mathsf{Mac}_r(C)</span>. The final ciphertext is <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>.</p>

    <p class="text-gray-300"><strong>Decryption</strong> To decrypt a ciphertext <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>, the receiver derives the secret key <span class="math">SK_{\\mathsf{com}}</span> corresponding to the “identity” com, and uses this key to decrypt the ciphertext <span class="math">C</span> as per the underlying IBE scheme; this yields a “message” <span class="math">m \\circ \\mathsf{dec}</span> (if decryption fails, the receiver outputs <span class="math">\\bot</span>). Next, the receiver runs <span class="math">\\mathcal{R}(\\mathsf{pub}, \\mathsf{com}, \\mathsf{dec})</span> to obtain a string <span class="math">r</span>; if <span class="math">r \\neq \\bot</span> and <span class="math">\\mathsf{Vrfy}_r(C, \\mathsf{tag}) = 1</span>, the receiver outputs <span class="math">m</span>. Otherwise, the receiver outputs <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Intuition for the security of the above encryption scheme against chosen-ciphertext attacks is similar to [11]. Let <span class="math">\\langle \\mathsf{com}^<em>, C^</em>, \\mathsf{tag}^<em> \\rangle</span> be the challenge ciphertext (cf. Definition 2). In the absence of any decryption queries, it is clear that the value of the bit <span class="math">b</span> remains hidden from the adversary due to the security of the underlying IBE scheme. Decryption queries of the form <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span> with <span class="math">\\mathsf{com} \\neq \\mathsf{com}^</em></span> do not further help the adversary since the adversary would be unable to determine <span class="math">b</span></p>

    <p class="text-gray-300">even if it had the secret key <span class="math">SK_{\\mathsf{com}}</span> corresponding to <span class="math">\\mathsf{com}</span> (this follows again from the security of the underlying IBE scheme). Thus, it is left to examine decryption queries of the form <span class="math">\\langle\\mathsf{com}^{*},C,\\mathsf{tag}\\rangle</span>. The crux of our proof is to show that all queries of this form are rejected (i.e., the decryption oracle returns <span class="math">\\bot</span> in response to all queries of this form) with all but negligible probability. A formal proof of this statement is somewhat involved, as it requires avoiding the apparent “circularity” arising from the IBE scheme, the message authentication code, and the encapsulation scheme; the details are given in the proof below.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">Assuming the IBE scheme, message authentication code, and encapsulation scheme used above satisfy Definitions 2.1, 2.2, and 2.3, respectively, the above construction is a <span class="math">\\mathsf{PKE}</span> scheme which is secure against adaptive chosen-ciphertext attacks.</p>

    <p class="text-gray-300">Proof Given any ppt adversary <span class="math">\\mathcal{A}</span> attacking the above encryption scheme in an adaptive chosen-ciphertext attack, we construct a ppt adversary <span class="math">\\mathcal{A}^{\\prime}</span> attacking the underlying IBE scheme in a selective-identity, chosen-plaintext attack. Relating the success probabilities of these adversaries gives the desired result.</p>

    <p class="text-gray-300">Let <span class="math">\\ell(k)</span> denote the length of strings <span class="math">\\mathsf{com}</span> output by <span class="math">\\mathcal{S}</span>. Define adversary <span class="math">\\mathcal{A}^{\\prime}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}^{\\prime}(1^{k},\\ell(k))</span> runs <span class="math">\\mathsf{Setup}(1^{k})</span> to generate <span class="math">\\mathsf{pub}</span>, and runs <span class="math">\\mathcal{S}(1^{k},\\mathsf{pub})</span> to obtain <span class="math">(r^{<em>},\\mathsf{com}^{</em>},\\mathsf{dec}^{<em>})</span>. The adversary <span class="math">\\mathcal{A}^{\\prime}</span> then outputs the “target identity” <span class="math">\\mathsf{com}^{</em>}</span>.</li>

      <li><span class="math">A^{\\prime}</span> is then given IBE parameters <span class="math">PK</span>. Adversary <span class="math">A^{\\prime}</span>, in turn, runs <span class="math">\\mathcal{A}</span> on inputs <span class="math">1^{k}</span> and <span class="math">(PK,\\mathsf{pub})</span>.</li>

      <li>When <span class="math">\\mathcal{A}</span> submits the ciphertext <span class="math">\\langle\\mathsf{com},C,\\mathsf{tag}\\rangle</span> to its decryption oracle, <span class="math">\\mathcal{A}^{\\prime}</span> proceeds as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{com}=\\mathsf{com}^{*}</span>, then <span class="math">\\mathcal{A}^{\\prime}</span> returns <span class="math">\\bot</span>.</li>

      <li>If <span class="math">\\mathsf{com}\\neq\\mathsf{com}^{*}</span>, then <span class="math">\\mathcal{A}^{\\prime}</span> makes the oracle query <span class="math">\\mathsf{Der}^{\\prime}_{\\mathsf{msk}}(\\mathsf{com})</span> to obtain <span class="math">SK_{\\mathsf{com}}</span>. It then computes <span class="math">m\\circ\\mathsf{dec}=\\mathsf{Dec}^{\\prime}_{SK_{\\mathsf{com}}}(\\mathsf{com},C)</span>, followed by <span class="math">r=\\mathcal{R}(\\mathsf{pub},\\mathsf{com},\\mathsf{dec})</span>. If <span class="math">r\\neq\\bot</span> and <span class="math">\\mathsf{Vrfy}_{r}(C,\\mathsf{tag})=1</span>, it returns <span class="math">m</span> to <span class="math">A</span>. Otherwise, it returns <span class="math">\\bot</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At some point, <span class="math">\\mathcal{A}</span> outputs two messages <span class="math">m_{0},m_{1}</span>. Adversary <span class="math">A^{\\prime}</span> outputs the messages <span class="math">m_{0}\\circ\\mathsf{dec}^{<em>}</span> and <span class="math">m_{1}\\circ\\mathsf{dec}^{</em>}</span>, and receives in return a ciphertext <span class="math">C^{<em>}</span>. It computes <span class="math">\\mathsf{tag}^{</em>}=\\mathsf{Mac}_{r^{<em>}}(C^{</em>})</span> and returns <span class="math">\\langle\\mathsf{com}^{<em>},C^{</em>},\\mathsf{tag}^{*}\\rangle</span> to <span class="math">A</span>.</li>

      <li><span class="math">\\mathcal{A}</span> may continue to make decryption oracle queries, and these are answered as before. (Recall, <span class="math">\\mathcal{A}</span> may not query the decryption oracle on the challenge ciphertext itself.)</li>

      <li>Finally, <span class="math">\\mathcal{A}</span> outputs a guess <span class="math">b^{\\prime}</span>; this same guess is output by <span class="math">\\mathcal{A}^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{A}^{\\prime}</span> represents a legal strategy for attacking the underlying IBE scheme in a selective-identity, chosen-plaintext attack; in particular, <span class="math">\\mathcal{A}^{\\prime}</span> never requests the secret key corresponding to “target identity” <span class="math">\\mathsf{com}^{*}</span>.</p>

    <p class="text-gray-300">Before analyzing the success probability of <span class="math">A^{\\prime}</span>, we prove a claim bounding the probability of a certain event. Say a ciphertext <span class="math">\\langle\\mathsf{com},C,\\mathsf{tag}\\rangle</span> is <em>valid</em> if decryption of this ciphertext would not result in <span class="math">\\bot</span>. Let <span class="math">\\mathsf{Valid}</span> denote the event that <span class="math">A</span> ever submits a ciphertext <span class="math">\\langle\\mathsf{com}^{<em>},C,\\mathsf{tag}\\rangle</span> to its decryption oracle which is valid. (We always implicitly assume that <span class="math">\\langle\\mathsf{com}^{</em>},C,\\mathsf{tag}\\rangle\\neq\\langle\\mathsf{com}^{<em>},C^{</em>},\\mathsf{tag}^{*}\\rangle</span> since this event is disallowed after <span class="math">A</span> is given the challenge ciphertext, and occurs with only negligible probability before <span class="math">A</span> is given the challenge ciphertext.)</p>

    <p class="text-gray-300">Claim <span class="math">\\Pr[\\mathsf{Valid}]</span> is negligible.</p>

    <p class="text-gray-300">Proof</p>

    <p class="text-gray-300">Let Game 0 denote the original experiment in which <span class="math">A</span> interacts with a real decryption oracle (and not the simulated decryption oracle provided by <span class="math">A^{\\prime}</span>); we are interested in bounding <span class="math">\\Pr_{0}[\\mathsf{Valid}]</span>. Let Equiv be the event that the adversary ever submits a ciphertext <span class="math">\\langle\\mathsf{com}^{<em>},C,\\mathsf{tag}\\rangle</span> for which (1) <span class="math">C</span> decrypts to some arbitrary <span class="math">m\\circ\\mathsf{dec}</span> (using the secret key <span class="math">SK_{\\mathsf{com}^{</em>}}</span>) and furthermore (2) <span class="math">\\mathcal{R}(\\mathsf{pub},\\mathsf{com}^{<em>},\\mathsf{dec})=r</span> with <span class="math">r\\not\\in\\{r^{</em>},\\bot\\}</span>. Let <span class="math">\\mathsf{Forge}</span> be the event that Equiv does <em>not</em> occur, and <span class="math">A</span> at some point submits a ciphertext <span class="math">\\langle\\mathsf{com}^{<em>},C,\\mathsf{tag}\\rangle</span> such that <span class="math">\\mathsf{Vrfy}_{r^{</em>}}(C,\\mathsf{tag})=1</span>. Clearly, we have <span class="math">\\Pr_{0}[\\mathsf{Valid}]\\leq\\Pr_{0}[\\mathsf{Equiv}]+\\Pr_{0}[\\mathsf{Forge}]</span>.</p>

    <p class="text-gray-300">We first show that <span class="math">\\Pr_{0}[\\mathsf{Equiv}]</span> is negligible, by the binding property of the encapsulation scheme. Consider an adversary <span class="math">B</span> acting as follows: given input <span class="math">(1^{k},\\mathsf{pub},r^{<em>},\\mathsf{com}^{</em>},\\mathsf{dec}^{<em>})</span>, adversary <span class="math">B</span> generates <span class="math">(PK,\\mathsf{msk})</span> for the IBE scheme and runs <span class="math">A</span> on inputs <span class="math">1^{k}</span> and <span class="math">(PK,\\mathsf{pub})</span>. Whenever <span class="math">A</span> makes a decryption oracle query, <span class="math">B</span> can legitimately answer this query since <span class="math">B</span> knows <span class="math">\\mathsf{msk}</span>. When <span class="math">A</span> submits its two messages <span class="math">m_{0},m_{1}</span>, adversary <span class="math">B</span> simply chooses <span class="math">b\\in\\{0,1\\}</span> at random and encrypts <span class="math">m_{b}</span> in the expected way to generate a completely valid ciphertext <span class="math">\\langle\\mathsf{com}^{</em>},C^{<em>},\\mathsf{tag}^{</em>}\\rangle</span> (<span class="math">B</span> can easily do this since it has both <span class="math">r^{<em>}</span> and <span class="math">\\mathsf{dec}^{</em>}</span>). Now, if Equiv ever occurs then <span class="math">B</span> learns <span class="math">\\mathsf{dec}</span> such that <span class="math">\\mathcal{R}(\\mathsf{pub},\\mathsf{com}^{<em>},\\mathsf{dec})\\not\\in\\{\\bot,r^{</em>}\\}</span>. But this exactly violates the binding property of <span class="math">(\\mathsf{Setup},\\mathcal{S},\\mathcal{R})</span>.</p>

    <p class="text-gray-300">We next show that <span class="math">\\Pr_{0}[\\mathsf{Forge}]</span> is negligible. Let <span class="math">q(k)</span> be a polynomial upper bound on the number of decryption queries made by <span class="math">A</span>, and let <span class="math">\\mathsf{Forge}_{i}</span> denote the event that <span class="math">\\mathsf{Forge}</span> occurs for the first time on the <span class="math">i^{\\text{th}}</span> decryption query of <span class="math">A</span>. Let <span class="math">\\mathsf{Forge}_{i}^{\\prime}</span> denote the event that the <span class="math">i^{\\text{th}}</span> decryption query is of the form <span class="math">\\langle\\mathsf{com}^{<em>},C,\\mathsf{tag}\\rangle</span> and <span class="math">\\mathsf{Vrfy}_{r^{</em>}}(C,\\mathsf{tag})=1</span> <em>when all previous decryption queries of the form <span class="math">\\langle\\mathsf{com}^{</em>},C^{\\prime},\\mathsf{tag}^{\\prime}\\rangle</span> are answered with <span class="math">\\bot</span>* (without checking whether they are valid or not). We refer to this latter “game” (which formally depends on the <span class="math">i</span> under consideration) as Game <span class="math">0^{\\prime}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\Pr_{0}[\\mathsf{Forge}]=\\sum_{i=1}^{q(k)}\\Pr_{0}[\\mathsf{Forge}_{i}]</span>. Furthermore, for all <span class="math">i</span> we have <span class="math">\\Pr_{0^{\\prime}}[\\mathsf{Forge}_{i}^{\\prime}]\\geq\\Pr_{0}[\\mathsf{Forge}_{i}]</span>. Letting <span class="math">\\mathsf{Forge}^{\\prime}\\overset{\\text{def}}{=}\\cup_{i}\\mathsf{Forge}_{i}^{\\prime}</span>, we obtain <span class="math">\\Pr_{0}[\\mathsf{Forge}]\\leq\\Pr_{0^{\\prime}}[\\mathsf{Forge}^{\\prime}]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define Game 1 which proceeds exactly as Game <span class="math">0^{\\prime}</span>, except that <span class="math">A</span> is now given a random encryption of <span class="math">m_{b}\\circ 0^{n(k)}</span> instead of a random encryption of <span class="math">m_{b}\\circ\\mathsf{dec}^{*}</span> (here, $n(k)\\overset{\\text{def}}{=}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{dec}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; recall that Definition 2.3 requires the length of </span>\\mathsf{dec}^{*}<span class="math"> to be fixed for a given value of </span>k<span class="math">). We claim that </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{0^{\\prime}}[\\mathsf{Forge}^{\\prime}]-\\Pr_{1}[\\mathsf{Forge}^{\\prime}]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible. Indeed, if this is not the case then we can easily construct an algorithm </span>B$ attacking the security of the underlying IBE scheme:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given input <span class="math">1^{k}</span>, algorithm <span class="math">B</span> runs <span class="math">\\mathsf{Setup}(1^{k})</span> to generate <span class="math">\\mathsf{pub}</span> and then runs <span class="math">\\mathcal{S}(1^{k},\\mathsf{pub})</span> to obtain <span class="math">(r^{<em>},\\mathsf{com}^{</em>},\\mathsf{dec}^{<em>})</span>. It outputs <span class="math">\\mathsf{com}^{</em>}</span> as the target identity and is then given the IBE parameters <span class="math">PK</span>. Finally, it runs <span class="math">A</span> on inputs <span class="math">1^{k}</span> and <span class="math">(PK,\\mathsf{pub})</span>.</li>

      <li>Decryption queries of <span class="math">A</span> are answered as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Queries of the form <span class="math">\\langle\\mathsf{com},C,\\mathsf{tag}\\rangle</span> with <span class="math">\\mathsf{com}\\neq\\mathsf{com}^{*}</span> are answered by first querying <span class="math">\\mathsf{Der}^{\\prime}_{\\mathsf{msk}}(\\mathsf{com})</span> to obtain <span class="math">SK_{\\mathsf{com}}</span>, and then decrypting in the usual way.</li>

      <li>Upon receiving a query of the form <span class="math">\\langle\\mathsf{com}^{<em>},C,\\mathsf{tag}\\rangle</span>, first check whether <span class="math">\\mathsf{Vrfy}_{r^{</em>}}(C,\\mathsf{tag})=1</span>. If so, abort the experiment and output 1. Otherwise, return <span class="math">\\bot</span> to <span class="math">A</span>.</li>

      <li>Eventually, <span class="math">A</span> sends a pair of messages <span class="math">m_{0},m_{1}</span> to its encryption oracle. <span class="math">B</span> selects a bit <span class="math">b</span> at random, and sends <span class="math">m_{b}\\circ\\mathsf{dec}^{<em>}</span> and <span class="math">m_{b}\\circ 0^{n(k)}</span> to its encryption oracle. It receives in return a challenge ciphertext <span class="math">C^{</em>}</span>, and uses this to generate a ciphertext <span class="math">\\langle\\mathsf{com}^{<em>},C^{</em>},\\mathsf{tag}^{*}\\rangle</span> in the natural way.</li>

      <li>Further decryption queries of <span class="math">A</span> are answered as above.</li>

      <li>If <span class="math">A</span> halts and <span class="math">B</span> has not previously aborted the experiment, then <span class="math">B</span> outputs a random bit.</li>

    </ul>

    <p class="text-gray-300">The probability that <span class="math">B</span> outputs 1 when given an encryption of <span class="math">m_b \\circ \\mathsf{dec}^*</span> is <span class="math">\\frac{1}{2} + \\frac{1}{2} \\cdot \\operatorname{Pr}_{0&#x27;}[\\mathsf{Forge}&#x27;]</span>. On the other hand, the probability that <span class="math">B</span> outputs 1 when given an encryption of <span class="math">m_b \\circ 0^{n(k)}</span> is <span class="math">\\frac{1}{2} + \\frac{1}{2} \\cdot \\operatorname{Pr}_1[\\mathsf{Forge}&#x27;]</span>. Since the difference between these two probabilities must be negligible if the underlying IBE scheme is secure, this proves the current claim.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define Game 2 which proceeds exactly as Game 1, except that the challenge ciphertext given to <span class="math">A</span> is now constructed as follows: <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span> is run to give <span class="math">(r, \\mathsf{com}^<em>, \\mathsf{dec}^</em>)</span> but an independent random key <span class="math">r^<em> \\in \\{0, 1\\}^k</span> is chosen as well. Compute <span class="math">C^</em> \\gets \\mathsf{Enc}_{PK}(\\mathsf{com}^<em>, m \\circ 0^{n(k)})</span>, followed by <span class="math">\\mathsf{tag}^</em> = \\mathsf{Mac}_{r^<em>}(C^</em>)</span>. The challenge ciphertext, as usual, is <span class="math">\\langle \\mathsf{com}^<em>, C^</em>, \\mathsf{tag}^* \\rangle</span>. We claim that the difference $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}_1[\\mathsf{Forge}'] - \\operatorname{Pr}_2[\\mathsf{Forge}']</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible. To see this, consider the following algorithm </span>B$ breaking the hiding property of the encapsulation scheme:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">B</span> is given input <span class="math">1^k</span> and <span class="math">(\\mathsf{pub}, \\mathsf{com}^*, \\tilde{r})</span>. It then runs <span class="math">\\mathsf{Setup}&#x27;(1^k)</span> to generate <span class="math">(PK, \\mathsf{msk})</span>, and runs <span class="math">A</span> on input <span class="math">1^k</span> and <span class="math">(PK, \\mathsf{pub})</span>.</li>

      <li>Decryption queries of <span class="math">A</span> are answered as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Queries of the form <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span> with <span class="math">\\mathsf{com} \\neq \\mathsf{com}^*</span> are answered by running <span class="math">\\mathsf{Der}_{\\mathsf{msk}}&#x27;(\\mathsf{com})</span> to obtain <span class="math">SK_{\\mathsf{com}}</span>, and then decrypting in the usual way.</li>

      <li>Upon receiving a query of the form <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span>, first check whether <span class="math">\\mathsf{Vrfy}_{\\tilde{r}}(C, \\mathsf{tag}) = 1</span>. If so, abort the experiment and output 1. Otherwise, return <span class="math">\\perp</span> to <span class="math">A</span>.</li>

      <li>Eventually, <span class="math">A</span> sends a pair of messages <span class="math">m_0, m_1</span> to its encryption oracle. <span class="math">B</span> selects a bit <span class="math">b</span> at random and proceeds as follows: it computes <span class="math">C^<em> \\gets \\mathsf{Enc}_{PK}(\\mathsf{com}^</em>, m_b \\circ 0^{n(k)})</span>, computes <span class="math">\\mathsf{tag}^<em> = \\mathsf{Mac}_{\\tilde{r}}(C^</em>)</span>, and returns the challenge ciphertext <span class="math">\\langle \\mathsf{com}^<em>, C^</em>, \\mathsf{tag}^* \\rangle</span> to <span class="math">A</span>.</li>

      <li>Further decryption queries of <span class="math">A</span> are answered as above.</li>

      <li>If <span class="math">A</span> halts and <span class="math">B</span> has not previously aborted the experiment, then <span class="math">B</span> outputs a random bit.</li>

    </ul>

    <p class="text-gray-300">Now, if <span class="math">\\tilde{r}</span> is such that <span class="math">(\\tilde{r}, \\mathsf{com}^<em>, \\mathsf{dec}^</em>)</span> was output by <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span> then the view of <span class="math">A</span> is exactly as in Game 1 and so the probability that <span class="math">B</span> outputs 1 in this case is <span class="math">\\frac{1}{2} (1 + \\operatorname{Pr}_1[\\mathsf{Forge}&#x27;])</span>. On the other hand, if <span class="math">\\tilde{r}</span> is chosen independently of <span class="math">\\mathsf{com}^*</span> then the view of <span class="math">A</span> is exactly as in Game 2 and so the probability that <span class="math">B</span> outputs 1 in this case is <span class="math">\\frac{1}{2} (1 + \\operatorname{Pr}_2[\\mathsf{Forge}&#x27;])</span>. Since the difference between these two probabilities must be negligible by the hiding property of the encapsulation scheme, this proves the current claim.</p>

    <p class="text-gray-300">Finally, we claim that <span class="math">\\operatorname{Pr}_2[\\mathsf{Forge}&#x27;]</span> is negligible. This follows quite easily from the security of the message authentication code, and we omit the details here. This completes the proof of the claim.</p>

    <p class="text-gray-300">Given the preceding claim, we see that the simulation which <span class="math">A&#x27;</span> provides for <span class="math">A</span> is statistically close to a real execution of <span class="math">A</span>: in particular, the only difference occurs when Valid occurs. We therefore conclude that the advantage of <span class="math">A&#x27;</span> is negligibly close to the advantage of <span class="math">A</span>. Since the advantage of <span class="math">A&#x27;</span> is negligible under the assumed security of the underlying IBE, the advantage of <span class="math">A</span> must be negligible as well. This completes the proof of Theorem 1.</p>

    <p class="text-gray-300">Here, we describe two particular instantiations of our scheme by describing specific instantiations of the various primitives.</p>

    <p class="text-gray-300">IBE schemes. Boneh and Boyen <em>[5]</em> recently proposed two efficient IBE schemes suitable for our purposes. We refer to <em>[5]</em> for the full details and content ourselves with giving only a high-level description of their first scheme here. Let <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{1}</span> be two (multiplicative) cyclic groups of prime order <span class="math">q</span> for which there exists an efficiently-computable map <span class="math">\\hat{e}:\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{1}</span> which is bilinear and non-degenerate. Namely, (1) for all <span class="math">\\mu,\\nu\\in\\mathbb{G}</span> and <span class="math">a,b\\in\\mathbb{Z}_{q}</span> we have <span class="math">\\hat{e}(\\mu^{a},\\nu^{b})=e(\\mu,\\nu)^{ab}</span>, and (2) <span class="math">\\hat{e}(g,g)\\neq 1</span> for some generator <span class="math">g</span> of <span class="math">\\mathbb{G}</span>. The IBE scheme is defined as follows:</p>

    <p class="text-gray-300">Pick random generators <span class="math">g,g_{1},g_{2}</span> of <span class="math">\\mathbb{G}</span> and a random <span class="math">x\\in\\mathbb{Z}_{q}</span>. Set <span class="math">g_{3}=g^{x}</span> and <span class="math">Z=\\hat{e}(g_{1},g_{3})</span>. The master public key is <span class="math">PK=(g,g_{1},g_{2},g_{3},Z)</span> and the master secret key is <span class="math">\\mathsf{msk}=x</span>. To derive the secret key for “identity” <span class="math">ID\\in\\mathbb{Z}_{q}</span> using <span class="math">\\mathsf{msk}=x</span>, choose a random <span class="math">r\\in\\mathbb{Z}_{q}</span> and return the key <span class="math">SK_{ID}=(g_{1}^{x}g_{2}^{r}g_{3}^{r\\cdot ID},\\;g^{r})</span>. To encrypt a message <span class="math">M\\in\\mathbb{G}_{1}</span> with respect to “identity” <span class="math">ID\\in\\mathbb{Z}_{q}</span>, choose a random <span class="math">s\\in\\mathbb{Z}_{q}</span> and output the ciphertext <span class="math">(g^{s},\\;g_{2}^{s}g_{3}^{s\\cdot ID},\\;M\\cdot Z^{s})</span>. To decrypt ciphertext <span class="math">(A,B,C)</span> using private key <span class="math">(K_{1},K_{2})</span>, output <span class="math">C\\cdot\\hat{e}(B,K_{2})/\\hat{e}(A,K_{1})</span>.</p>

    <p class="text-gray-300">Correctness can be easily verified. Security of the above scheme is based on the decisional bilinear Diffie-Hellman (decision-BDH) problem. For efficiency, we assume that the master secret key <span class="math">\\mathsf{msk}</span> contains the discrete logarithms of <span class="math">g_{1},g_{2}</span>, and <span class="math">g_{3}</span> with respect to base <span class="math">g</span>, in which case generating <span class="math">SK_{ID}</span> requires only two exponentiations.</p>

    <p class="text-gray-300">The second IBE scheme of Boneh and Boyen <em>[5]</em> is more efficient than the above in terms of both key-generation and decryption time (the time required for encryption is essentially the same), but is based on a cryptographic assumption which is less standard.</p>

    <p class="text-gray-300">When the above scheme is used for key encapsulation (in the sense of Section 1.2), the sender need only send <span class="math">(g^{s},\\;g_{2}^{s}g_{3}^{s\\cdot ID})</span> and compute the key <span class="math">H_{\\alpha}(Z^{s})</span> where <span class="math">H</span> is a keyed hash function (see below); the receiver, given ciphertext <span class="math">\\langle A,B\\rangle</span>, computes the matching key <span class="math">H_{\\alpha}(\\hat{e}(A,K_{1})/\\hat{e}(B,K_{2}))</span>, where <span class="math">K_{1},K_{2}</span> are as before. In this description, <span class="math">H</span> represents a keyed hash function where the key <span class="math">\\alpha</span> is included as part of the receiver’s public key. Under the decisional-BDH assumption, it suffices for <span class="math">H</span> to be chosen from a pairwise-independent hash family in order for the scheme to be secure. We remark, however, that this encapsulation scheme is also secure under a potentially weaker “hash BDH” assumption as well (and a similar remark holds also for the second IBE scheme of <em>[5]</em>). See further discussion at the end of this section.</p>

    <p class="text-gray-300">Message authentication codes. A number of efficient message authentication codes are known, and we do not suggest any particular one. We stress that we only require “one-time” security (cf. Definition 2.2) and so efficient schemes which do not rely on any computational assumptions (e.g., <em>[35]</em>) may be used. Furthermore, messages to be authenticated have a (known) fixed length; this enables slight optimizations and/or simplifications of known schemes.</p>

    <p class="text-gray-300">Encapsulation schemes. We suggest an encapsulation scheme based on a fixed cryptographic hash function <span class="math">H:\\{0,1\\}^{448}\\to\\{0,1\\}^{128}</span> (constructed, e.g., by suitably modifying the output length of SHA-1), and for a particular choice of security parameters; it is easy to adapt the scheme for the more general case. Our scheme works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup chooses a hash function <span class="math">h</span> from a family of pairwise independent hash functions mapping 448-bit strings to 128-bit strings, and outputs <span class="math">\\mathsf{pub}=h</span>.</li>

      <li>The encapsulation algorithm <span class="math">\\mathcal{S}</span> takes <span class="math">\\mathsf{pub}</span> as input, chooses a random <span class="math">x\\in\\{0,1\\}^{448}</span>, and then outputs <span class="math">(r=h(x),\\mathsf{com}=H(x),\\mathsf{dec}=x)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The recovery algorithm <span class="math">\\mathcal{R}</span> takes as input <span class="math">(\\mathsf{pub} = h,\\mathsf{com},\\mathsf{dec})</span> and outputs <span class="math">h(\\mathsf{dec})</span> if <span class="math">H(\\mathsf{dec}) = \\mathsf{com}</span>, and <span class="math">\\perp</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">Note that binding holds as long as it is infeasible to find a <span class="math">\\mathsf{dec}&#x27; \\neq \\mathsf{dec}</span> such that <span class="math">H(\\mathsf{dec}&#x27;) = H(\\mathsf{dec})</span>, where <span class="math">\\mathsf{dec}</span> is chosen uniformly at random (cf. Definition 2.3). Thus, binding holds as long as <span class="math">H</span> is second-preimage resistant (the construction can be easily modified so as to be based on UOWHFs by simply having Setup choose a key <span class="math">h&#x27;</span> for a UOWHF and including <span class="math">h&#x27;</span> in <span class="math">\\mathsf{pub}</span>); collision-resistance is not necessary.³ Furthermore, the above scheme satisfies statistical hiding. More specifically:</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> For the encapsulation scheme described above, the statistical difference between the following distributions is at most <span class="math">2^{-63}</span>:</p>

    <p class="text-gray-300">(1) <span class="math">\\{\\mathsf{pub} \\gets \\mathsf{Setup}; (r, \\mathsf{com}, \\mathsf{dec}) \\gets \\mathcal{S}(\\mathsf{pub}) : (\\mathsf{pub}, \\mathsf{com}, r)\\}</span> (2) <span class="math">\\{\\mathsf{pub} \\gets \\mathsf{Setup}; (r, \\mathsf{com}, \\mathsf{dec}) \\gets \\mathcal{S}(\\mathsf{pub}); r&#x27; \\gets \\{0, 1\\}^{128} : (\\mathsf{pub}, \\mathsf{com}, r&#x27;)\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof (Sketch)</strong> The idea is loosely based on [16, 21], but our proof is much simpler. For any <span class="math">x \\in \\{0,1\\}^{448}</span>, let <span class="math">N_x \\stackrel{\\mathrm{def}}{=} \\{x&#x27; \\mid H(x&#x27;) = H(x)\\}</span> (this is simply the set of elements hashing to <span class="math">H(x)</span>). Call <span class="math">x</span> good if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{255}<span class="math">, and bad otherwise. Since the output length of </span>H<span class="math"> is 128 bits, there are at most </span>2^{255} \\cdot 2^{128} = 2^{383}<span class="math"> bad </span>x<span class="math">&#x27;s; thus, the probability that an </span>x<span class="math"> chosen uniformly at random from </span>\\{0,1\\}^{448}<span class="math"> is bad is at most </span>2^{-65}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assuming <span class="math">x</span> is good, the min-entropy of <span class="math">x</span> — given <span class="math">\\mathsf{pub}</span> and <span class="math">\\mathsf{com}</span> — is at least 255 bits since every <span class="math">\\tilde{x} \\in N_x</span> is equally likely. Viewing <span class="math">h</span> as a strong extractor (or, equivalently, applying the leftover-hash lemma [22]) we see that <span class="math">\\{h, H(x), h(x)\\}</span> has statistical difference at most <span class="math">2^{-64}</span> from <span class="math">\\{h, H(x), U_{128}\\}</span>, where <span class="math">U_{128}</span> represents the uniform distribution over <span class="math">\\{0, 1\\}^{128}</span>. The theorem follows easily.</p>

    <p class="text-gray-300"><strong>A concrete scheme.</strong> Given the primitives above, we may construct a CCA-secure encryption scheme as described in the previous section. However, as discussed in Section 1.2, improved efficiency can be obtained by directly constructing a hybrid encryption scheme; we do so here.</p>

    <p class="text-gray-300"><strong>Key generation</strong> requires running the key-generation algorithm for the underlying IBE scheme and then choosing a hash function <span class="math">h</span> from a family of pairwise independent hash functions.</p>

    <p class="text-gray-300"><strong>Encryption</strong> of a message <span class="math">M</span> involves (1) running the encapsulation scheme to obtain <span class="math">(k = h(x), ID = H(x), x)</span>; (2) using the underlying IBE as a key encapsulation scheme, with identity <span class="math">ID</span>, to generate a ciphertext <span class="math">C_1</span> encapsulating a key <span class="math">k&#x27;</span>; (3) using <span class="math">k&#x27;</span> to encrypt <span class="math">M \\circ x</span> by, for example, computing <span class="math">C_2 = G(k&#x27;) \\oplus (M \\circ x)</span>, where <span class="math">G</span> is a PRG; (4) computing a MAC on <span class="math">C_1, C_2</span> using key <span class="math">k</span>.</p>

    <p class="text-gray-300">The ciphertext consists of <span class="math">ID, C_1, C_2</span>, and the tag output by the MAC.</p>

    <p class="text-gray-300"><strong>Decryption</strong> of ciphertext <span class="math">(ID, C_1, C_2, \\mathsf{tag})</span> is done in the obvious way: recover <span class="math">k&#x27;</span> from <span class="math">C_1</span> (using identity <span class="math">ID</span>), recover <span class="math">M \\circ x</span> from <span class="math">C_2</span>, and compute <span class="math">k = h(x)</span>. If <span class="math">H(x) = ID</span> and <span class="math">\\mathsf{Vrfy}_k((C_1, C_2), \\mathsf{tag}) = 1</span>, then output <span class="math">M</span>; otherwise, output <span class="math">\\perp</span>.</p>

    <p class="text-gray-300">We tabulate the efficiency of our schemes, and compare them to the scheme of Kurosawa-Desmedt [25], in Table 1. Scheme 1 is instantiated using the first IBE from [5], as described above;</p>

    <p class="text-gray-300">³This also explains why an output length of 128 bits for <span class="math">H</span> should provide a sufficient level of security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key generation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ciphertext overhead</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scheme 1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5 p-exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">2 p-exps. + 2 pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">3 exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 704</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scheme 2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5 p-exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 exps. + 1 pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">2 exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 704</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KD [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5 p-exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5 exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">3 exps.</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 128</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Efficiency comparison for CCA-secure hybrid encryption schemes. When tabulating computational efficiency, "private-key" operations (hash function/block cipher evaluations) are ignored, and one multi-exponentiation is counted as 1.5 exponentiations. Ciphertext overhead represents the difference (in bits) between the ciphertext length and the message length, and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the length (in bits) of a group element. "p-exp" refers to an exponentiation relative to a fixed base.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">scheme 2 is instantiated using the second IBE from [5]. During encryption all bases of exponentiation are fixed which potentially enables further speed-up by pre-computation. In Scheme 1 we assume that  <span class="math">g_{1}, g_{3}</span>  are generated by raising the fixed generator  <span class="math">g</span>  to a random power. Hence, computing  <span class="math">\\hat{e}(g_{1}, g_{3})</span>  requires only a single exponentiation assuming  <span class="math">\\hat{e}(g, g)</span>  is pre-computed.</p>

    <p class="text-gray-300">In addition to comparing the efficiency of these various schemes, it is interesting also to compare the cryptographic assumptions on which they are based. Security of the Kurosawa-Desmedt scheme (as in the case of the Cramer-Shoup scheme [13] on which it is based) inherently relies on the decisional Diffie-Hellman assumption, and it does not seem possible to obtain provable security using a weaker variant of this assumption. In contrast, as noted earlier, our schemes may be proven secure under "hash BDH"-type assumptions which are potentially weaker than the decisional-BDH assumption. <span class="math">^4</span></p>

    <p class="text-gray-300">We present an efficient methodology for constructing CCA-secure public-key cryptosystems from weak identity-based encryption schemes. Our construction adds only a MAC and a weak "commitment" to the original IBE system. Consequently, performance of the resulting public-key system is very close to the performance of the underlying IBE scheme. This improves on a previous transformation of Canetti, et al. which relies on the use of one-time signature schemes.</p>

    <p class="text-gray-300">Applying our construction to recent IBE systems of Boneh and Boyen we obtain an efficient CCA-secure public-key cryptosystem without random oracles. Encryption (and, in one case, key generation) in the resulting systems are more efficient than in the Cramer-Shoup scheme, and on par with the recent proposal of Kurosawa and Desmedt. Decryption time and ciphertext size are comparable, though a bit worse. Our schemes are also somewhat more flexible than the Kurosawa-Desmedt scheme in terms of the cryptographic assumptions needed to obtain a proof of security. Our results show that building CCA-secure systems from IBE can produce very efficient schemes. The resulting schemes, as well as the proofs of security, are very different from those based on the work of Cramer and Shoup.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations Among Notions of Security for Public-Key Encryption Schemes. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 26–45, 1998.</li>

      <li>[2] M. Bellare and P. Rogaway. Random Oracles are Practical: a Paradigm for Designing Efficient Protocols. First ACM Conf. on Computer and Comm. Security, ACM, pp. 62–73, 1993.</li>

      <li>[3] D. Bleichenbacher. Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS#1. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 1–12, 1998.</li>

      <li>[4] M. Blum, P. Feldman, and S. Micali. Non-Interactive Zero-Knowledge and its Applications. 20th ACM Symposium on Theory of Computing (STOC), ACM, pp. 103–112, 1988.</li>

      <li>[5] D. Boneh and X. Boyen. Efficient Selective-ID Secure Identity Based Encryption Without Random Oracles. Adv. in Cryptology — Eurocrypt 2004, LNCS vol. 3027, Springer-Verlag, pp. 223–238, 2004. Full version available from http://eprint.iacr.org/2004/172</li>

      <li>[6] D. Boneh and X. Boyen. Secure Identity Based Encryption Without Random Oracles. Adv. in Cryptology — Crypto 2004, LNCS vol. 3152, Springer-Verlag, pp. 443–459, 2004.</li>

      <li>[7] D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. Adv. in Cryptology — Crypto 2001, LNCS vol. 2139, Springer-Verlag, pp. 213–229, 2001. Full version in SIAM J. Computing 32(3): 586–615, 2003 and available from http://crypto.stanford.edu/~dabo/pubs.</li>

      <li>[8] R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic Protocols. 42nd IEEE Symp. on Foundations of Computer Science (FOCS), IEEE, pp. 136–145, 2001. Full version available at http://eprint.iacr.org/2000/067/</li>

      <li>[9] R. Canetti, O. Goldreich, and S. Halevi. The Random Oracle Methodology, Revisited. 30th ACM Symp. on Theory of Computing (STOC), ACM, pp. 209–218, 1998.</li>

      <li>[10] R. Canetti, S. Halevi, and J. Katz. A Forward-Secure Public-Key Encryption Scheme. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 255–271, 2003. Full version available at http://eprint.iacr.org/2003/083</li>

      <li>[11] R. Canetti, S. Halevi, and J. Katz. Chosen-Ciphertext Security from Identity-Based Encryption. Adv. in Cryptology — Eurocrypt 2004, LNCS vol. 3027, Springer-Verlag, pp. 207–222, 2004.</li>

      <li>[12] C. Cocks. An Identity-Based Encryption Scheme Based on Quadratic Residues. Cryptography and Coding, LNCS vol. 2260, Springer-Verlag, pp. 360–363, 2001.</li>

      <li>[13] R. Cramer and V. Shoup. A Practical Public Key Cryptosystem Provably Secure Against Chosen Ciphertext Attack. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 13–25, 1998.</li>

      <li>[14] R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. Adv. in Cryptology — Eurocrypt 2002, LNCS vol. 2332, Springer-Verlag, pp. 45–64, 2002.</li>

    </ul>

    <p class="text-gray-300">[15] J. Camenisch and V. Shoup. Practical Verifiable Encryption and Decryption of Discrete Logarithms. Adv. in Cryptology — Crypto 2003, LNCS vol. 2729, Springer-Verlag, pp. 126–144, 2003.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[16] I. Damgård, T.P. Pedersen, and B. Pfitzmann. On the Existence of Statistically-Hiding Bit Commitment Schemes and Fail-Stop Signatures. Adv. in Cryptology — Crypto 1993, LNCS vol. 773, Springer-Verlag, pp. 250–265, 1993.</li>

      <li>[17] D. Dolev, C. Dwork, and M. Naor. Non-Malleable Cryptography. SIAM J. Computing 30(2): 391–437, 2000.</li>

      <li>[18] U. Feige, D. Lapidot, and A. Shamir. Multiple Non-Interactive Zero-Knowledge Proofs Under General Assumptions. SIAM J. Computing 29(1): 1–28, 1999.</li>

      <li>[19] R. Gennaro and Y. Lindell. A Framework for Password-Based Authenticated Key Exchange. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 524–543, 2003.</li>

      <li>[20] S. Goldwasser, S. Micali, and R. Rivest. A Digital Signature Scheme Secure against Adaptive Chosen-Message Attacks. SIAM J. Computing 17(2): 281–308, 1988.</li>

      <li>[21] S. Halevi and S. Micali. Practical and Provably-Secure Commitment Schemes from Collision-Free Hashing. Adv. in Cryptology — Crypto 1996, LNCS vol. 1109, Springer-Verlag, pp. 201–215, 1996.</li>

      <li>[22] J. Håstad, R. Impagliazzo, L. Levin, and M. Luby. Construction of a Pseudorandom Generator from any One-Way Function. SIAM J. Comp. 28(4): 1364–1396, 1999.</li>

      <li>[23] N. Howgrave-Graham, P. Q. Nguyen, D. Pointcheval, J. Proos, J. H. Silverman, A. Singer, and W. Whyte. The Impact of Decryption Failures on the Security of NTRU Encryption. Adv. in Cryptology — Crypto 2003, LNCS vol. 2729, Springer-Verlag, pp. 226–246, 2003.</li>

      <li>[24] M. Joye, J.-J. Quisquater, and M. Yung. On the Power of Misbehaving Adversaries and Security Analysis of the Original EPOC. Cryptographers’ Track — RSA 2001, LNCS vol. 2020, Springer-Verlag, pp. 208–222, 2001.</li>

      <li>[25] K. Kurosawa and Y. Desmedt. A New Paradigm of Hybrid Encryption Scheme. Adv. in Cryptology — Crypto 2004, LNCS vol. 3152, Springer-Verlag, pp. 426–442, 2004.</li>

      <li>[26] L. Lamport. Constructing Digital Signatures from a One-Way Function. Technical Report CSL-98, SRI International, 1978.</li>

      <li>[27] Y. Lindell. A Simpler Construction of CCA-Secure Public-Key Encryption Under General Assumptions. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 241–254, 2003.</li>

      <li>[28] M. Naor and M. Yung. Universal One-Way Hash Functions and Their Cryptographic Applications. 21st ACM Symposium on Theory of Computing (STOC), ACM, pp. 33–43, 1989.</li>

      <li>[29] C. Rackoff and D. Simon. Non-Interactive Zero-Knowledge Proof of Knowledge and Chosen Ciphertext Attack. Adv. in Cryptology — Crypto 1991, LNCS vol. 576, Springer-Verlag, pp. 433–444, 1992.</li>

    </ul>

    <p class="text-gray-300">[30] A. Sahai. Non-Malleable Non-Interactive Zero Knowledge and Adaptive Chosen-Ciphertext Security. 40th IEEE Symposium on Foundations of Computer Science (FOCS), IEEE, pp. 543–553, 1999.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[31] A. Shamir. Identity-Based Cryptosystems and Signature Schemes. Adv. in Cryptology — Crypto 1984, LNCS vol. 196, Springer-Verlag, pp. 47–53, 1985.</li>

      <li>[32] V. Shoup. Why Chosen Ciphertext Security Matters. IBM Research Report RZ 3076, November, 1998. Available at http://www.shoup.net/papers.</li>

      <li>[33] V. Shoup. Using Hash Functions as a Hedge Against Chosen Ciphertext Attack. Adv. in Cryptology — Eurocrypt 2000, LNCS vol. 275–288, Springer-Verlag, pp. 1807, 2000.</li>

      <li>[34] B. Waters. Efficient Identity-Based Encryption Without Random Oracles. Available at http://eprint.iacr.org/2004/180</li>

      <li>[35] M.N. Wegman and J.L. Carter. New Hash Functions and Their Use in Authentication and Set Equality. J. Computer System Sciences 22(3): 265–279, 1981.</li>

    </ul>`;
---

<BaseLayout title="Improved Efficiency for CCA-Secure Cryptosystems Built Using... (2004/261)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/261
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
