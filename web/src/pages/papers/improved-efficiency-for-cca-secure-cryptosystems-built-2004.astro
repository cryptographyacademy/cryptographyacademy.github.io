---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/261';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Improved Efficiency for CCA-Secure Cryptosystems Built Using Identity-Based Encryption';
const AUTHORS_HTML = 'Dan Boneh&lt;sup&gt;∗&lt;/sup&gt; Jonathan Katz†';

const CONTENT = `    <p class="text-gray-300">Dan Boneh&lt;sup&gt;∗&lt;/sup&gt; Jonathan Katz†</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Recently, Canetti, Halevi, and Katz showed a general method for constructing CCA-secure encryption schemes from identity-based encryption schemes in the standard model. We improve the efficiency of their construction, and show two specific instantiations of our resulting scheme which offer the most efficient encryption (and, in one case, key generation) of any CCA-secure encryption scheme to date.</p>

    <p class="text-gray-300">Keywords: Chosen-ciphertext security, Identity-based encryption, Public-key encryption.</p>

    <p class="text-gray-300">Security against adaptive chosen-ciphertext attacks (i.e., &quot;CCA-security&quot;) [29, 17, 1] has become the de facto level of security for public-key encryption schemes. The reasons for this are many: CCA security helps protect against subtle attacks that have been demonstrated against schemes not meeting this notion of security [3, 24, 23]; is helpful in defending against &quot;active&quot; attackers who may modify messages in transit (see [32]); and, finally, allows encryption schemes to be developed and then securely &quot;plugged in&quot; to higher-level protocols which may then be executed in arbitrary environments (see, e.g., [8, Sec. 8.2.2]).</p>

    <p class="text-gray-300">Nevertheless, only a relatively small number of encryption schemes have been rigorously proven secure against adaptive chosen-ciphertext attacks in the standard model &lt;sup&gt;1&lt;/sup&gt; (i.e., without resorting to the use of random oracles [2]). Schemes based on general assumptions are known [17, 30, 27], but these rely on generic non-interactive zero-knowledge proofs [4, 18] and do not currently lead to practical solutions. More interesting from a practical point of view are efficient schemes based on specific number-theoretic assumptions; two general methodologies for constructing such schemes are known. The first methodology is based on the &quot;smooth hash proof systems&quot; of Cramer and Shoup [14], and has led to a variety of constructions [13, 14, 19, 15, 25]. The second, and more recent, method [11] constructs a CCA-secure encryption scheme from any semantically-secure (or, &quot;CPA-secure&quot;) identity-based encryption (IBE) scheme [7, 12] (which can in turn be constructed in the standard model based on specific number-theoretic assumptions [10, 5, 6, 34]). Overall, the most efficient CCA-secure encryption scheme currently known is a hybrid encryption system due to Kurosawa and Desmedt [25] which builds on the original proposal of Cramer and Shoup [13] and relies on the decisional Diffie-Hellman assumption.</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt; dabo@cs.stanford.edu. Computer Science Department, Stanford University. Supported by NSF and the Packard Foundation.</p>

    <p class="text-gray-300">jkatz@cs.umd.edu. Department of Computer Science, University of Maryland. This research was supported by NSF Trusted Computing Grant #0310751.</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt;From now on, we use &quot;CCA security&quot; to refer by default to security which is proven in the standard model.</p>

    <p class="text-gray-300">In this paper, we suggest a new method which allows for the construction of very efficient CCA-secure encryption schemes. Our technique modifies the approach of Canetti, Halevi, and Katz [11], who (as noted above) show a transformation from any semantically-secure &quot;weak&quot; IBE scheme to a CCA-secure public-key encryption scheme. Briefly and somewhat informally, their transformation from an IBE scheme&lt;sup&gt;2&lt;/sup&gt; (Setup, Der, Enc, Dec) to a CCA-secure scheme proceeds as follows: key generation is performed by running Setup and letting the public (resp. secret) key be the master public key P K (resp., master secret key msk) output by this algorithm. To encrypt a message m using public key P K, a sender generates a random key-pair (vk, sk) for a one-time signature scheme and sends the ciphertext hvk, Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(vk, m), σi, where Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(vk, m) represents an encryption of message m for the &quot;identity&quot; vk using master public parameters P K, and σ represents a signature on the second component of this ciphertext using sk. To decrypt ciphertext hvk, C, σi, the receiver first verifies whether Vrfyvk (C, σ) ?= 1. If so, the receiver then decrypts C with respect to the &quot;identity&quot; vk (it can do this since it has the master secret key msk).</p>

    <p class="text-gray-300">Though conceptually simple, this transformation does add noticeable overhead to the underlying IBE scheme: encryption requires the sender to generate keys for a one-time signature scheme [26] and also to compute a signature using the keys just generated; decryption requires the receiver to verify a signature with respect to the verification key included as part of the ciphertext. Although one-time signatures are &quot;easy&quot; to construct in theory, and are more efficient than &quot;full-blown&quot; signatures (i.e., those which are existentially unforgeable under an adaptive chosen-message attack [20]), they still have their price. In particular:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>One-time signatures based on cryptographic hash functions such as SHA-1 can be designed to allow very efficient signing; key generation, on the other hand, typically requires hundreds of hash function evaluations and is relatively expensive (though not as expensive as key generation in schemes based on number-theoretic assumptions). More problematic, perhaps, is that such schemes have very long public keys and signatures, which would result in very long ciphertexts in the scheme of [11].</li>
      <li>One-time signatures based on number-theoretic assumptions (say, by adapting &quot;full-blown&quot; signature schemes) yield schemes whose computational cost — both for key generation and signing — is more expensive, but which have the advantage of short(er) public keys and signatures.</li>
    </ul>

    <p class="text-gray-300">Either way, the transformation of Canetti, Halevi, and Katz results in a CCA-secure encryption scheme which is less efficient than the underlying IBE system.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1.1 Our Contribution</h4>

    <p class="text-gray-300">We describe a transformation from any CPA-secure &quot;weak&quot; IBE system to a CCA-secure encryption scheme which adds essentially no overhead. The efficiency advantage of our approach arises from our observation that the one-time signature in the construction of Canetti, et al. (as described earlier) can be replaced by a message-authentication code (mac) along with an appropriate &quot;encapsulation&quot; of a mac key (for the purposes of this informal description, one can think of an encapsulation as a commitment). Using the notation introduced earlier, encryption using our approach is now performed (informally) by first &quot;encapsulating&quot; a key r which results in an encapsulation com along with a decommitment string dec. The final ciphertext is hcom, Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(com, m◦dec),tagi, where tag</p>

    <p class="text-gray-300">&lt;sup&gt;2&lt;/sup&gt;Definitions of IBE schemes and their security, as well as definitions of CCA-secure encryption, are reviewed in Section 2.</p>

    <p class="text-gray-300">is now a message authentication code computed on the second component of the ciphertext using key r. Decryption of ciphertext hcom, C,tagi is done in the natural way, but note that here the receiver must first decrypt C (with respect to &quot;identity&quot; com) and only then can the receiver verify the correctness of tag. Indeed, this feature of our scheme complicates the security proof somewhat (and in particular we must be careful to avoid circular arguments).</p>

    <p class="text-gray-300">Adapting [16, 21], we show how encapsulation of the mac key can be done both efficiently and securely using, e.g., SHA-1: encapsulation requires only a single hash function evaluation, and is secure under the assumption that SHA-1 is second-preimage resistant (the scheme can be easily modified so as to be secure under the weaker assumption of the existence of UOWHFs [28]). This encapsulation scheme may have other applications, and thus the scheme — as well as the relatively simple proof of security we provide for this encapsulation scheme here (cf. Theorem 2) — may be of independent interest. Furthermore, our technique of replacing a one-time signature by a mac seems applicable to other constructions (e.g., those of [17, 30] as well as the various extensions mentioned in [11]), giving efficiency improvements in those cases as well.</p>

    <p class="text-gray-300">In addition to the general method discussed above, we also show two specific instantiations of our approach based on two IBE schemes recently introduced by Boneh and Boyen [5]. Our resulting schemes are quite efficient: in particular, the times required for key generation and encryption are as fast as (or faster than) the most efficient previous CCA-secure schemes to date.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">1.2 Hybrid Encryption</h4>

    <p class="text-gray-300">In practice, public-key encryption is almost never used to encrypt actual data. Instead, hybrid encryption is typically used, whereby a public-key scheme is used to encrypt a random key, and the data is then encrypted using some symmetric-key encryption scheme and this key. In fact, &quot;encryption&quot; of the symmetric key is not required; &quot;encapsulation&quot; (cf. [33]) — which may be more efficient — is enough. It is well known that if both the public-key encapsulation scheme and the underlying symmetric-key encryption scheme are CCA-secure, then the resulting hybrid scheme is CCA-secure as well.</p>

    <p class="text-gray-300">Interestingly, Kurosawa and Desmedt have recently shown [25] that the public-key encapsulation scheme does not necessarily need to be CCA-secure in order for the resulting hybrid scheme to be CCA-secure. In particular, they show a hybrid encryption scheme which is based on, but more efficient than, the Cramer-Shoup scheme [13] when used for hybrid encryption. The specific hybrid schemes proposed here are as efficient as the Kurosawa-Desmedt scheme in terms of encryption (and, in one case, key generation), but somewhat less efficient in other measures; we provide detailed comparisons in Section 4. It is somewhat surprising that constructions based on completely different approaches end up having such similar performance for both encryption and key generation.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.3 Outline</h4>

    <p class="text-gray-300">In Section 3, we present and prove secure a generic construction of a CCA-secure encryption scheme based on a variety of primitives (IBE, macs, and encapsulation) formally defined in Section 2. Section 4 describes in more detail two specific instantiations of the various primitives; the efficiency of the resulting schemes are then compared with previous work.</p>

    <p class="text-gray-300">We review the standard definitions of public-key encryption schemes and their security against adaptive chosen-ciphertext attacks. This is followed by definitions of identity-based encryption, message authentication, and &quot;encapsulation&quot; as needed for our construction.</p>

    <p class="text-gray-300">Definition 1 (Public-key encryption) A public-key encryption scheme PKE is a triple of ppt algorithms (Gen, Enc, Dec) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The randomized key generation algorithm Gen takes as input a security parameter 1 &lt;sup&gt;k&lt;/sup&gt; and outputs a public key P K and a secret key SK. We write (P K, SK) ← Gen(1&lt;sup&gt;k&lt;/sup&gt; ).</li>
      <li>The randomized encryption algorithm Enc takes as input a public key P K and a message m ∈ {0, 1} ∗ , and outputs a ciphertext C. We write C ← Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(m).</li>
      <li>The decryption algorithm Dec takes as input a ciphertext C and a secret key SK. It returns a message m ∈ {0, 1} &lt;sup&gt;∗&lt;/sup&gt; or the distinguished symbol ⊥. We write m ← DecSK(C).</li>
    </ul>

    <p class="text-gray-300">We require that for all (P K, SK) output by Gen, all m ∈ {0, 1} ∗ , and all C output by Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(m) we have DecSK(C) = m.</p>

    <p class="text-gray-300">Definition 2 (CCA security) A public-key encryption scheme PKE is secure against adaptive chosen-ciphertext attacks (i.e., is &quot;CCA-secure&quot;) if the advantage of any ppt adversary A in the following game is negligible in the security parameter k:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Gen(1&lt;sup&gt;k&lt;/sup&gt; ) outputs (P K, SK). Adversary A is given 1 &lt;sup&gt;k&lt;/sup&gt; and P K.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The adversary may make polynomially-many queries to a decryption oracle DecSK(·).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At some point, A outputs two messages m0, m&lt;sup&gt;1&lt;/sup&gt; with |m0| = |m1|. A bit b is randomly chosen and the adversary is given a &quot;challenge ciphertext&quot; C &lt;sup&gt;∗&lt;/sup&gt; ← Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(mb).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A may continue to query its decryption oracle DecSK(·) except that it may not request the decryption of C ∗ .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, A outputs a guess b 0 .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We say that A succeeds if b &lt;sup&gt;0&lt;/sup&gt; = b, and denote the probability of this event by PrA,PKE[Succ]. The adversary's advantage is defined as |PrA,PKE[Succ] − 1/2|.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.1 Identity-Based Encryption</h4>

    <p class="text-gray-300">Informally, an IBE scheme is a public-key encryption scheme in which any string (i.e., identity) can serve as a public key. In more detail, a setup algorithm is first run to generate &quot;master&quot; public and secret keys. Given the master secret key and any string ID ∈ {0, 1} ∗ (which can be viewed as an identity), it is possible to derive a &quot;personal secret key&quot; SKID. Any sender can encrypt a message for &quot;identity&quot; ID using only the master public key and the string ID. The resulting ciphertext can be decrypted using the derived secret key SKID, but the message remains hidden from an adversary who does not know SKID even if that adversary is given SKID&lt;sup&gt;0&lt;/sup&gt; for multiple identities ID&lt;sup&gt;0&lt;/sup&gt; 6= ID. The concept of identity-based encryption was introduced by Shamir [31], and provably-secure IBE schemes in the random oracle model were demonstrated by Boneh and Franklin [7] and Cocks [12]. More recently, provably-secure IBE schemes in the standard model have been developed [10, 5, 6, 34]; see further discussion below.</p>

    <p class="text-gray-300">In the original definition of security for IBE proposed and achieved by Boneh and Franklin [7], the adversary may choose the &quot;target identity&quot; (ID in the above discussion) in an adaptive manner, based on the master public key and any keys SKID&lt;sup&gt;0&lt;/sup&gt; the adversary has obtained thus far. A weaker notion of security, proposed and achieved by Canetti, Halevi, and Katz [10], requires the adversary to specify the target identity before the public-key is published; we will refer to this notion of security as &quot;weak&quot; IBE. As in [11], our construction only requires weak IBE schemes secure against chosen-plaintext attacks. We therefore only recall this definition of security.</p>

    <p class="text-gray-300">Definition 3 (IBE) An identity-based encryption scheme IBE is a 4-tuple of ppt algorithms (Setup, Der, Enc, Dec) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The randomized setup algorithm Setup takes as input a security parameter 1 &lt;sup&gt;k&lt;/sup&gt; and a value <code>for the identity length. It outputs some system-wide parameters P K along with a master secret key msk. (We assume that k and</code> are implicit in P K.)</li>
      <li>The (possibly randomized) key derivation algorithm Der takes as input the master key msk and an identity ID ∈ {0, 1} \` . It returns the corresponding decryption key SKID. We write SKID ← Dermsk(ID).</li>
      <li>The randomized encryption algorithm Enc takes as input the system-wide public key P K, an identity ID ∈ {0, 1} \` , and a message m ∈ {0, 1} ∗ ; it outputs a ciphertext C. We write C ← Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(ID, m).</li>
      <li>The decryption algorithm Dec takes as input an identity ID, its associated decryption key SKID, and a ciphertext C. It outputs a message m ∈ {0, 1} &lt;sup&gt;∗&lt;/sup&gt; or the distinguished symbol ⊥. We write m ← DecSKID (ID, C).</li>
    </ul>

    <p class="text-gray-300">We require that for all (P K, msk) output by Setup, all ID ∈ {0, 1} \` , all SKID output by Dermsk(ID), all m ∈ {0, 1} ∗ , and all C output by Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(ID, m) we have DecSKID (ID, C) = m.</p>

    <p class="text-gray-300">As mentioned earlier, we provide a definition of security only for the case of &quot;weak&quot; IBE, as considered in [10, 5]. (Of course, a scheme satisfying the stronger definition of [7, 6] is trivially a weak IBE scheme as well.)</p>

    <p class="text-gray-300">Definition 4 (Selective-ID IBE) An identity-based scheme IBE is secure against selectiveidentity, chosen-plaintext attacks if for all polynomially-bounded functions \`(·) the advantage of any ppt adversary A in the following game is negligible in the security parameter k:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A(1&lt;sup&gt;k&lt;/sup&gt; , <code>(k)) outputs a target identity ID&lt;sup&gt;∗&lt;/sup&gt; ∈ {0, 1} </code>(k) .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup(1&lt;sup&gt;k&lt;/sup&gt; , \`(k)) outputs (P K, msk). The adversary is given P K.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The adversary A may make polynomially-many queries to an oracle Dermsk(·), except that it may not request the secret key corresponding to the target identity ID&lt;sup&gt;∗&lt;/sup&gt; .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At some point, A outputs two messages m0, m&lt;sup&gt;1&lt;/sup&gt; with |m0| = |m1|. A bit b is randomly chosen and the adversary is given a &quot;challenge ciphertext&quot; C &lt;sup&gt;∗&lt;/sup&gt; ← Enc&lt;sup&gt;P&lt;/sup&gt; &lt;sup&gt;K&lt;/sup&gt;(ID&lt;sup&gt;∗&lt;/sup&gt; , mb).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A may continue to query its oracle Dermsk(·), but still may not request the secret key corresponding to the identity ID&lt;sup&gt;∗&lt;/sup&gt; .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, A outputs a guess b 0 .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We say that A succeeds if b &lt;sup&gt;0&lt;/sup&gt; = b, and denote the probability of this event by PrA,IBE[Succ]. The adversary's advantage is defined as |PrA,IBE[Succ] − 1/2|.</p>

    <p class="text-gray-300">For completeness, we remark that a slightly weaker definition — in which \` = Ω(log k) is a priori bounded, rather than being given as a parameter to Setup — suffices for our construction.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2.2 Message Authentication</h2>

    <p class="text-gray-300">We view a message authentication code as a pair of ppt algorithms (Mac,Vrfy). The authentication algorithm Mac takes as input a key sk and a message M, and outputs a string tag. The verification algorithm Vrfy takes as input a key sk, a message M, and a string tag; it outputs either 0 (&quot;reject&quot;) or 1 (&quot;accept&quot;). We require that for all sk and M we have Vrfysk(M, Macsk(M)) = 1. For simplicity, we assume that Mac and Vrfy are deterministic.</p>

    <p class="text-gray-300">We give a definition of security tailored to the requirements of our construction; in particular, we require only &quot;one-time&quot; security for our message authentication code. We remark that efficient schemes satisfying this definition can be constructed without any computational assumptions using, e.g., almost strongly universal hash families [35].</p>

    <p class="text-gray-300">Definition 5 (Message authentication) A message authentication code (Mac,Vrfy) is secure against a one-time chosen-message attack if the success probability of any ppt adversary A in the following game is negligible in the security parameter k:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A random key sk ∈ {0, 1} k is chosen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A(1&lt;sup&gt;k&lt;/sup&gt; ) outputs a message M and is given in return tag = Macsk(M).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A outputs a pair (M&lt;sup&gt;0&lt;/sup&gt; ,tag&lt;sup&gt;0&lt;/sup&gt; ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We say that A succeeds if (M,tag) 6= (M&lt;sup&gt;0&lt;/sup&gt; ,tag&lt;sup&gt;0&lt;/sup&gt; ) and Vrfysk(M&lt;sup&gt;0&lt;/sup&gt; ,tag&lt;sup&gt;0&lt;/sup&gt; ) = 1.</p>

    <p class="text-gray-300">In the above, the adversary succeeds even if M = M&lt;sup&gt;0&lt;/sup&gt; but tag 6= tag&lt;sup&gt;0&lt;/sup&gt; . Thus, the definition corresponds to what has been termed &quot;strong&quot; security in the context of signature schemes.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">2.3 Encapsulation</h4>

    <p class="text-gray-300">We define a notion of &quot;encapsulation&quot; which may be viewed as a weak variant of commitment. (Note that our definition is unrelated to that of key encapsulation which was discussed in Section 1.2.) In terms of functionality, an encapsulation scheme commits the sender to a random string as opposed to a chosen message as in the case of commitment. In terms of security, our construction only requires binding to hold for honestly-generated encapsulations; this is analogous to assuming an honest sender during the first phase of a commitment scheme.</p>

    <p class="text-gray-300">Definition 6 (Encapsulation) An encapsulation scheme is a triple of ppt algorithms (Setup, S, R) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup takes as input the security parameter 1 &lt;sup&gt;k&lt;/sup&gt; and outputs a string pub.</li>
      <li>S takes as input 1 &lt;sup&gt;k&lt;/sup&gt; and pub, and outputs (r, com, dec) with r ∈ {0, 1} k . We refer to com as the public commitment string and dec as the de-commitment string.</li>
      <li>R takes as input (pub, com, dec) and outputs an r ∈ {0, 1} &lt;sup&gt;k&lt;/sup&gt; ∪ {⊥}.</li>
    </ul>

    <p class="text-gray-300">We require that for all pub output by Setup and for all (r, com, dec) output by S(1&lt;sup&gt;k&lt;/sup&gt; , pub), we have R(pub, com, dec) = r. We also assume for simplicity that com and dec have fixed lengths for any given value of the security parameter.</p>

    <p class="text-gray-300">As in the case of commitment, an encapsulation scheme satisfies notions of both binding and hiding. Informally, &quot;hiding&quot; requires that com should leak no information about r; more formally, the string r should be indistinguishable from random even when given com (and pub). &quot;Binding&quot; requires that an honestly-generated com can be &quot;opened&quot; to only a single (legal) value of r; see below.</p>

    <p class="text-gray-300"><strong>Definition 7 (Secure encapsulation)</strong> An encapsulation scheme (Setup,  <span class="math">\\mathcal{S}</span> ,  <span class="math">\\mathcal{R}</span> ) is secure if it satisfies both hiding and binding as follows:</p>

    <p class="text-gray-300"><strong>Hiding:</strong> The following is negligible for all PPT A:</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr \\left[ \\begin{array}{c} \\mathsf{pub} \\leftarrow \\mathsf{Setup}(1^k); r_0 \\leftarrow \\{0,1\\}^k; \\\\ (r_1,\\mathsf{com},\\mathsf{dec}) \\leftarrow \\mathcal{S}(1^k,\\mathsf{pub}); b \\leftarrow \\{0,1\\} \\end{array} \\right] : \\quad A(1^k,\\mathsf{pub},\\mathsf{com},r_b) = b \\ \\left| \\begin{array}{c} -\\frac{1}{2} \\end{array} \\right|.</span>$</p>

    <p class="text-gray-300"><strong>Binding:</strong> The following is negligible for all PPT A:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c} \\mathsf{pub} \\leftarrow \\mathsf{Setup}(1^k); \\\\ (r,\\mathsf{com},\\mathsf{dec}) \\leftarrow \\mathcal{S}(1^k,\\mathsf{pub}); \\\\ \\mathsf{dec}&#x27; \\leftarrow A(1^k,\\mathsf{pub},r,\\mathsf{com},\\mathsf{dec}) \\end{array} \\right].</span>$</p>

    <p class="text-gray-300">In the above, both hiding and binding are required to hold only computationally. In Section 4 we show a novel encapsulation scheme which is both simple and efficient, and which achieves <em>statistical</em> hiding (and computational binding).</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 A Generic Construction</h2>

    <p class="text-gray-300">We now describe our construction of a CCA-secure encryption scheme from the primitives introduced in the previous section. Let  <span class="math">(\\mathsf{Setup&#x27;}, \\mathsf{Der&#x27;}, \\mathsf{Enc&#x27;}, \\mathsf{Dec&#x27;})</span>  be an IBE scheme,  <span class="math">(\\mathsf{Setup}, \\mathcal{S}, \\mathcal{R})</span>  be an encapsulation scheme, and  <span class="math">(\\mathsf{Mac}, \\mathsf{Vrfy})</span>  be a message authentication code. Our scheme is constructed as follows:</p>

    <p class="text-gray-300"><strong>Key generation</strong> Keys for our scheme are generated by running  <span class="math">\\mathsf{Setup}&#x27;(1^k)</span>  to generate  <span class="math">(PK, \\mathsf{msk})</span>  and  <span class="math">\\mathsf{Setup}(1^k)</span>  to generate  <span class="math">\\mathsf{pub}</span> . The public key is  <span class="math">(PK, \\mathsf{pub})</span> , and the secret key is  <span class="math">\\mathsf{msk}</span> .</p>

    <p class="text-gray-300">Encryption To encrypt a message m using public key  <span class="math">(PK, \\mathsf{pub})</span> , a sender first encapsulates a random value by running  <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span>  to obtain  <span class="math">(r, \\mathsf{com}, \\mathsf{dec})</span> . The sender then encrypts the &quot;message&quot;  <span class="math">m \\circ \\mathsf{dec}</span>  with respect to the &quot;identity&quot;  <span class="math">\\mathsf{com}</span> ; that is, the sender computes  <span class="math">C \\leftarrow \\mathsf{Enc}&#x27;_{PK}(\\mathsf{com}, m \\circ \\mathsf{dec})</span> . The resulting ciphertext C is then authenticated by using r as a key for a message authentication code; i.e., the sender computes  <span class="math">\\mathsf{tag} = \\mathsf{Mac}_r(C)</span> . The final ciphertext is  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span> .</p>

    <p class="text-gray-300"><strong>Decryption</strong> To decrypt a ciphertext  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span> , the receiver derives the secret key  <span class="math">SK_{\\mathsf{com}}</span>  corresponding to the &quot;identity&quot;  <span class="math">\\mathsf{com}</span> , and uses this key to decrypt the ciphertext C as per the underlying IBE scheme; this yields a &quot;message&quot;  <span class="math">m \\circ \\mathsf{dec}</span>  (if decryption fails, the receiver outputs  <span class="math">\\bot</span> ). Next, the receiver runs  <span class="math">\\mathcal{R}(\\mathsf{pub}, \\mathsf{com}, \\mathsf{dec})</span>  to obtain a string r; if  <span class="math">r \\neq \\bot</span>  and  <span class="math">\\mathsf{Vrfy}_r(C, \\mathsf{tag}) = 1</span> , the receiver outputs m. Otherwise, the receiver outputs  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">Intuition for the security of the above encryption scheme against chosen-ciphertext attacks is similar to [11]. Let  <span class="math">\\langle \\mathsf{com}^*, C^*, \\mathsf{tag}^* \\rangle</span>  be the challenge ciphertext (cf. Definition 2). In the absence of any decryption queries, it is clear that the value of the bit b remains hidden from the adversary due to the security of the underlying IBE scheme. Decryption queries of the form  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>  with  <span class="math">\\mathsf{com} \\neq \\mathsf{com}^*</span>  do not further help the adversary since the adversary would be unable to determine b</p>

    <p class="text-gray-300">even if it had the secret key  <span class="math">SK_{com}</span>  corresponding to com (this follows again from the security of the underlying IBE scheme). Thus, it is left to examine decryption queries of the form  <span class="math">\\langle com^*, C, tag \\rangle</span> . The crux of our proof is to show that all queries of this form are rejected (i.e., the decryption oracle returns  <span class="math">\\bot</span>  in response to all queries of this form) with all but negligible probability. A formal proof of this statement is somewhat involved, as it requires avoiding the apparent &quot;circularity&quot; arising from the IBE scheme, the message authentication code, and the encapsulation scheme; the details are given in the proof below.</p>

    <p class="text-gray-300"><strong>Theorem 1</strong> Assuming the IBE scheme, message authentication code, and encapsulation scheme used above satisfy Definitions 2.1, 2.2, and 2.3, respectively, the above construction is a PKE scheme which is secure against adaptive chosen-ciphertext attacks.</p>

    <p class="text-gray-300"><strong>Proof</strong> Given any PPT adversary  <span class="math">\\mathcal{A}</span>  attacking the above encryption scheme in an adaptive chosen-ciphertext attack, we construct a PPT adversary  <span class="math">\\mathcal{A}&#x27;</span>  attacking the underlying IBE scheme in a selective-identity, chosen-plaintext attack. Relating the success probabilities of these adversaries gives the desired result.</p>

    <p class="text-gray-300">Let  <span class="math">\\ell(k)</span>  denote the length of strings com output by  <span class="math">\\mathcal{S}</span> . Define adversary  <span class="math">\\mathcal{A}&#x27;</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{A}&#x27;(1^k, \\ell(k))</span>  runs  <span class="math">\\mathsf{Setup}(1^k)</span>  to generate  <span class="math">\\mathsf{pub}</span> , and runs  <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span>  to obtain  <span class="math">(r^*, \\mathsf{com}^*, \\mathsf{dec}^*)</span> . The adversary  <span class="math">\\mathcal{A}&#x27;</span>  then outputs the &quot;target identity&quot;  <span class="math">\\mathsf{com}^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A' is then given IBE parameters PK. Adversary A', in turn, runs A on inputs  <span class="math">1^k</span>  and (PK, pub).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When  <span class="math">\\mathcal{A}</span>  submits the ciphertext  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>  to its decryption oracle,  <span class="math">\\mathcal{A}&#x27;</span>  proceeds as follows:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If com = com*, then  <span class="math">\\mathcal{A}&#x27;</span>  returns  <span class="math">\\perp</span> .</li>
      <li>If  <span class="math">\\operatorname{\\mathsf{com}} \\neq \\operatorname{\\mathsf{com}}^*</span> , then  <span class="math">\\mathcal{A}&#x27;</span>  makes the oracle query  <span class="math">\\operatorname{\\mathsf{Der}}&#x27;_{\\mathsf{msk}}(\\operatorname{\\mathsf{com}})</span>  to obtain  <span class="math">SK_{\\mathsf{com}}</span> . It then computes  <span class="math">m \\circ \\operatorname{\\mathsf{dec}} = \\operatorname{\\mathsf{Dec}}&#x27;_{SK_{\\mathsf{com}}}(\\operatorname{\\mathsf{com}}, C)</span> , followed by  <span class="math">r = \\mathcal{R}(\\operatorname{\\mathsf{pub}}, \\operatorname{\\mathsf{com}}, \\operatorname{\\mathsf{dec}})</span> . If  <span class="math">r \\neq \\bot</span>  and  <span class="math">\\operatorname{\\mathsf{Vrfy}}_r(C, \\operatorname{\\mathsf{tag}}) = 1</span> , it returns m to A. Otherwise, it returns  <span class="math">\\bot</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At some point,  <span class="math">\\mathcal{A}</span>  outputs two messages  <span class="math">m_0, m_1</span> . Adversary A' outputs the messages  <span class="math">m_0 \\circ \\mathsf{dec}^*</span>  and  <span class="math">m_1 \\circ \\mathsf{dec}^*</span> , and receives in return a ciphertext  <span class="math">C^*</span> . It computes  <span class="math">\\mathsf{tag}^* = \\mathsf{Mac}_{r^*}(C^*)</span>  and returns  <span class="math">\\langle \\mathsf{com}^*, C^*, \\mathsf{tag}^* \\rangle</span>  to A.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{A}</span>  may continue to make decryption oracle queries, and these are answered as before. (Recall,  <span class="math">\\mathcal{A}</span>  may not query the decryption oracle on the challenge ciphertext itself.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally,  <span class="math">\\mathcal{A}</span>  outputs a guess b'; this same guess is output by  <span class="math">\\mathcal{A}&#x27;</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that  <span class="math">\\mathcal{A}&#x27;</span>  represents a legal strategy for attacking the underlying IBE scheme in a selective-identity, chosen-plaintext attack; in particular,  <span class="math">\\mathcal{A}&#x27;</span>  never requests the secret key corresponding to &quot;target identity&quot;  <span class="math">\\mathsf{com}^*</span> .</p>

    <p class="text-gray-300">Before analyzing the success probability of A', we prove a claim bounding the probability of a certain event. Say a ciphertext  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>  is valid if decryption of this ciphertext would not result in  <span class="math">\\bot</span> . Let Valid denote the event that A ever submits a ciphertext  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span>  to its decryption oracle which is valid. (We always implicitly assume that  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle \\neq \\langle \\mathsf{com}^*, C^*, \\mathsf{tag}^* \\rangle</span>  since this event is disallowed after A is given the challenge ciphertext, and occurs with only negligible probability before A is given the challenge ciphertext.)</p>

    <p class="text-gray-300"><strong>Claim</strong> Pr[Valid] is negligible.</p>

    <p class="text-gray-300"><strong>Proof</strong> Let Game 0 denote the original experiment in which A interacts with a real decryption oracle (and not the simulated decryption oracle provided by A'); we are interested in bounding  <span class="math">\\Pr_0[\\mathsf{Valid}]</span> . Let Equiv be the event that the adversary ever submits a ciphertext  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span>  for which (1) C decrypts to some arbitrary  <span class="math">m \\circ \\mathsf{dec}</span>  (using the secret key  <span class="math">SK_{\\mathsf{com}^*}</span> ) and furthermore (2)  <span class="math">\\mathcal{R}(\\mathsf{pub}, \\mathsf{com}^*, \\mathsf{dec}) = r</span>  with  <span class="math">r \\notin \\{r^*, \\bot\\}</span> . Let Forge be the event that Equiv does not occur, and A at some point submits a ciphertext  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span>  such that  <span class="math">\\mathsf{Vrfy}_{r^*}(C, \\mathsf{tag}) = 1</span> . Clearly, we have  <span class="math">\\Pr_0[\\mathsf{Valid}] \\leq \\Pr_0[\\mathsf{Equiv}] + \\Pr_0[\\mathsf{Forge}]</span> .</p>

    <p class="text-gray-300">We first show that  <span class="math">\\Pr_0[\\mathsf{Equiv}]</span>  is negligible, by the binding property of the encapsulation scheme. Consider an adversary B acting as follows: given input  <span class="math">(1^k, \\mathsf{pub}, r^*, \\mathsf{com}^*, \\mathsf{dec}^*)</span> , adversary B generates  <span class="math">(PK, \\mathsf{msk})</span>  for the IBE scheme and runs A on inputs  <span class="math">1^k</span>  and  <span class="math">(PK, \\mathsf{pub})</span> . Whenever A makes a decryption oracle query, B can legitimately answer this query since B knows  <span class="math">\\mathsf{msk}</span> . When A submits its two messages  <span class="math">m_0, m_1</span> , adversary B simply chooses  <span class="math">b \\in \\{0, 1\\}</span>  at random and encrypts  <span class="math">m_b</span>  in the expected way to generate a completely valid ciphertext  <span class="math">\\langle \\mathsf{com}^*, C^*, \\mathsf{tag}^* \\rangle</span>  (B can easily do this since it has both  <span class="math">r^*</span>  and  <span class="math">\\mathsf{dec}^*</span> ). Now, if Equiv ever occurs then B learns  <span class="math">\\mathsf{dec}</span>  such that  <span class="math">\\mathcal{R}(\\mathsf{pub}, \\mathsf{com}^*, \\mathsf{dec}) \\not\\in \\{\\bot, r^*\\}</span> . But this exactly violates the binding property of  <span class="math">(\\mathsf{Setup}, \\mathcal{S}, \\mathcal{R})</span> .</p>

    <p class="text-gray-300">We next show that  <span class="math">\\Pr_0[\\mathsf{Forge}]</span>  is negligible. Let q(k) be a polynomial upper bound on the number of decryption queries made by A, and let  <span class="math">\\mathsf{Forge}_i</span>  denote the event that  <span class="math">\\mathsf{Forge}</span>  occurs for the first time on the  <span class="math">i^{\\mathsf{th}}</span>  decryption query of A. Let  <span class="math">\\mathsf{Forge}_i&#x27;</span>  denote the event that the  <span class="math">i^{\\mathsf{th}}</span>  decryption query is of the form  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span>  and  <span class="math">\\mathsf{Vrfy}_{r^*}(C, \\mathsf{tag}) = 1</span>  when all previous decryption queries of the form  <span class="math">\\langle \\mathsf{com}^*, C&#x27;, \\mathsf{tag}&#x27; \\rangle</span>  are answered with  <span class="math">\\bot</span>  (without checking whether they are valid or not). We refer to this latter &quot;game&quot; (which formally depends on the i under consideration) as Game 0'.</p>

    <p class="text-gray-300">Note that  <span class="math">\\Pr_0[\\mathsf{Forge}] = \\sum_{i=1}^{q(k)} \\Pr_0[\\mathsf{Forge}_i]</span> . Furthermore, for all i we have  <span class="math">\\Pr_{0&#x27;}[\\mathsf{Forge}_i&#x27;] \\ge \\Pr_0[\\mathsf{Forge}_i]</span> . Letting  <span class="math">\\mathsf{Forge}&#x27; \\stackrel{\\text{def}}{=} \\cup_i \\mathsf{Forge}_i&#x27;</span> , we obtain  <span class="math">\\Pr_0[\\mathsf{Forge}] \\le \\Pr_{0&#x27;}[\\mathsf{Forge}&#x27;]</span> .</p>

    <p class="text-gray-300">Define Game 1 which proceeds exactly as Game 0', except that A is now given a random encryption of  <span class="math">m_b \\circ 0^{n(k)}</span>  instead of a random encryption of  <span class="math">m_b \\circ \\text{dec}^*</span>  (here,  <span class="math">n(k) \\stackrel{\\text{def}}{=} |\\text{dec}^*|</span> ; recall that Definition 2.3 requires the length of  <span class="math">\\text{dec}^*</span>  to be fixed for a given value of k). We claim that  <span class="math">|\\Pr_{0&#x27;}[\\mathsf{Forge&#x27;}] - \\Pr_{1}[\\mathsf{Forge&#x27;}]|</span>  is negligible. Indeed, if this is not the case then we can easily construct an algorithm B attacking the security of the underlying IBE scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given input  <span class="math">1^k</span> , algorithm B runs  <span class="math">\\mathsf{Setup}(1^k)</span>  to generate  <span class="math">\\mathsf{pub}</span>  and then runs  <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span>  to obtain  <span class="math">(r^*, \\mathsf{com}^*, \\mathsf{dec}^*)</span> . It outputs  <span class="math">\\mathsf{com}^*</span>  as the target identity and is then given the IBE parameters PK. Finally, it runs A on inputs  <span class="math">1^k</span>  and  <span class="math">(PK, \\mathsf{pub})</span> .</li>
      <li>Decryption queries of A are answered as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Queries of the form  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>  with  <span class="math">\\mathsf{com} \\neq \\mathsf{com}^*</span>  are answered by first querying  <span class="math">\\mathsf{Der}&#x27;_{\\mathsf{msk}}(\\mathsf{com})</span>  to obtain  <span class="math">SK_{\\mathsf{com}}</span> , and then decrypting in the usual way.</li>
      <li>Upon receiving a query of the form  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span> , first check whether  <span class="math">\\mathsf{Vrfy}_{r^*}(C, \\mathsf{tag}) = 1</span> . If so, abort the experiment and output 1. Otherwise, return  <span class="math">\\bot</span>  to A.</li>
    </ul></li>
      <li>Eventually, A sends a pair of messages  <span class="math">m_0, m_1</span>  to its encryption oracle. B selects a bit b at random, and sends  <span class="math">m_b \\circ \\operatorname{dec}^*</span>  and  <span class="math">m_b \\circ \\operatorname{0}^{n(k)}</span>  to its encryption oracle. It receives in return a challenge ciphertext  <span class="math">C^*</span> , and uses this to generate a ciphertext  <span class="math">\\langle \\operatorname{com}^*, C^*, \\operatorname{tag}^* \\rangle</span>  in the natural way.</li>
      <li>Further decryption queries of A are answered as above.</li>
      <li>If A halts and B has not previously aborted the experiment, then B outputs a random bit.</li>
    </ul>

    <p class="text-gray-300">The probability that B outputs 1 when given an encryption of  <span class="math">m_b \\circ \\mathsf{dec}^*</span>  is  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\cdot \\Pr_{0&#x27;}[\\mathsf{Forge&#x27;}]</span> . On the other hand, the probability that B outputs 1 when given an encryption of  <span class="math">m_b \\circ 0^{n(k)}</span>  is  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\cdot \\Pr_1[\\mathsf{Forge&#x27;}]</span> . Since the difference between these two probabilities must be negligible if the underlying IBE scheme is secure, this proves the current claim.</p>

    <p class="text-gray-300">Define Game 2 which proceeds exactly as Game 1, except that the challenge ciphertext given to A is now constructed as follows:  <span class="math">S(1^k, pub)</span>  is run to give  <span class="math">(r, com^*, dec^*)</span>  but an independent random key  <span class="math">r^* \\in \\{0,1\\}^k</span>  is chosen as well. Compute  <span class="math">C^* \\leftarrow \\operatorname{Enc}_{PK}(com^*, m \\circ 0^{n(k)})</span> , followed by  <span class="math">\\operatorname{tag}^* = \\operatorname{Mac}_{r^*}(C^*)</span> . The challenge ciphertext, as usual, is  <span class="math">\\langle com^*, C^*, tag^* \\rangle</span> . We claim that the difference  <span class="math">|\\operatorname{Pr}_1[\\operatorname{Forge}&#x27;] - \\operatorname{Pr}_2[\\operatorname{Forge}&#x27;]|</span>  is negligible. To see this, consider the following algorithm B breaking the hiding property of the encapsulation scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>B is given input  <span class="math">1^k</span>  and  <span class="math">(pub, com^*, \\tilde{r})</span> . It then runs  <span class="math">Setup&#x27;(1^k)</span>  to generate (PK, msk), and runs A on input  <span class="math">1^k</span>  and (PK, pub).</li>
      <li>Decryption queries of A are answered as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Queries of the form  <span class="math">\\langle \\mathsf{com}, C, \\mathsf{tag} \\rangle</span>  with  <span class="math">\\mathsf{com} \\neq \\mathsf{com}^*</span>  are answered by running  <span class="math">\\mathsf{Der&#x27;_{msk}}(\\mathsf{com})</span>  to obtain  <span class="math">SK_{\\mathsf{com}}</span> , and then decrypting in the usual way.</li>
      <li>Upon receiving a query of the form  <span class="math">\\langle \\mathsf{com}^*, C, \\mathsf{tag} \\rangle</span> , first check whether  <span class="math">\\mathsf{Vrfy}_{\\tilde{r}}(C, \\mathsf{tag}) = 1</span> . If so, abort the experiment and output 1. Otherwise, return  <span class="math">\\bot</span>  to A.</li>
    </ul></li>
      <li>Eventually, A sends a pair of messages  <span class="math">m_0, m_1</span>  to its encryption oracle. B selects a bit b at random and proceeds as follows: it computes  <span class="math">C^* \\leftarrow \\mathsf{Enc}_{PK}(\\mathsf{com}^*, m_b \\circ 0^{n(k)})</span> , computes  <span class="math">\\mathsf{tag}^* = \\mathsf{Mac}_{\\tilde{r}}(C^*)</span> , and returns the challenge ciphertext  <span class="math">\\langle \\mathsf{com}^*, C^*, \\mathsf{tag}^* \\rangle</span>  to A.</li>
      <li>Further decryption queries of A are answered as above.</li>
      <li>If A halts and B has not previously aborted the experiment, then B outputs a random bit.</li>
    </ul>

    <p class="text-gray-300">Now, if  <span class="math">\\tilde{r}</span>  is such that  <span class="math">(\\tilde{r}, \\mathsf{com}^*, \\mathsf{dec}^*)</span>  was output by  <span class="math">\\mathcal{S}(1^k, \\mathsf{pub})</span>  then the view of A is exactly as in Game 1 and so the probability that B outputs 1 in this case is  <span class="math">\\frac{1}{2}(1 + \\Pr_1[\\mathsf{Forge}&#x27;])</span> . On the other hand, if  <span class="math">\\tilde{r}</span>  is chosen independently of  <span class="math">\\mathsf{com}^*</span>  then the view of A is exactly as in Game 2 and so the probability that B outputs 1 in this case is  <span class="math">\\frac{1}{2}(1 + \\Pr_2[\\mathsf{Forge}&#x27;])</span> . Since the difference between these two probabilities must be negligible by the hiding property of the encapsulation scheme, this proves the current claim.</p>

    <p class="text-gray-300">Finally, we claim that  <span class="math">Pr_2[Forge&#x27;]</span>  is negligible. This follows quite easily from the security of the message authentication code, and we omit the details here. This completes the proof of the claim.</p>

    <p class="text-gray-300">Given the preceding claim, we see that the simulation which A' provides for A is statistically close to a real execution of A: in particular, the only difference occurs when Valid occurs. We therefore conclude that the advantage of A' is negligibly close to the advantage of A. Since the advantage of A' is negligible under the assumed security of the underlying IBE, the advantage of A must be negligible as well. This completes the proof of Theorem 1.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">4 Efficient Instantiations</h4>

    <p class="text-gray-300">Here, we describe two particular instantiations of our scheme by describing specific instantiations of the various primitives.</p>

    <p class="text-gray-300"><strong>IBE schemes.</strong> Boneh and Boyen [5] recently proposed two efficient IBE schemes suitable for our purposes. We refer to [5] for the full details and content ourselves with giving only a high-level description of their first scheme here. Let  <span class="math">\\mathbb{G}</span>  and  <span class="math">\\mathbb{G}_1</span>  be two (multiplicative) cyclic groups of prime order q for which there exists an efficiently-computable map  <span class="math">\\hat{e}: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_1</span>  which is bilinear and non-degenerate. Namely, (1) for all  <span class="math">\\mu, \\nu \\in \\mathbb{G}</span>  and  <span class="math">a, b \\in \\mathbb{Z}_q</span>  we have  <span class="math">\\hat{e}(\\mu^a, \\nu^b) = e(\\mu, \\nu)^{ab}</span> , and (2)  <span class="math">\\hat{e}(g,g) \\neq 1</span>  for some generator g of  <span class="math">\\mathbb{G}</span> . The IBE scheme is defined as follows:</p>

    <p class="text-gray-300"><strong>Setup</strong> Pick random generators  <span class="math">g, g_1, g_2</span>  of  <span class="math">\\mathbb{G}</span>  and a random  <span class="math">x \\in \\mathbb{Z}_q</span> . Set  <span class="math">g_3 = g^x</span>  and  <span class="math">Z = \\hat{e}(g_1, g_3)</span> . The master public key is  <span class="math">PK = (g, g_1, g_2, g_3, Z)</span>  and the master secret key is  <span class="math">\\mathsf{msk} = x</span> .</p>

    <p class="text-gray-300"><strong>Derive</strong> To derive the secret key for &quot;identity&quot;  <span class="math">ID \\in \\mathbb{Z}_q</span>  using  <span class="math">\\mathsf{msk} = x</span> , choose a random  <span class="math">r \\in \\mathbb{Z}_q</span>  and return the key  <span class="math">SK_{ID} = (g_1^x g_2^r g_3^{r \\cdot ID}, g^r)</span> .</p>

    <p class="text-gray-300"><strong>Encrypt</strong> To encrypt a message  <span class="math">M \\in \\mathbb{G}_1</span>  with respect to &quot;identity&quot;  <span class="math">ID \\in \\mathbb{Z}_q</span> , choose a random  <span class="math">s \\in \\mathbb{Z}_q</span>  and output the ciphertext  <span class="math">(g^s, g_2^s g_3^{s \\cdot ID}, M \\cdot Z^s)</span> .</p>

    <p class="text-gray-300"><strong>Decrypt</strong> To decrypt ciphertext (A, B, C) using private key  <span class="math">(K_1, K_2)</span> , output  <span class="math">C \\cdot \\hat{e}(B, K_2) / \\hat{e}(A, K_1)</span> .</p>

    <p class="text-gray-300">Correctness can be easily verified. Security of the above scheme is based on the decisional bilinear Diffie-Hellman (decision-BDH) problem. For efficiency, we assume that the master secret key msk contains the discrete logarithms of  <span class="math">g_1, g_2</span> , and  <span class="math">g_3</span>  with respect to base g, in which case generating  <span class="math">SK_{ID}</span>  requires only two exponentiations.</p>

    <p class="text-gray-300">The second IBE scheme of Boneh and Boyen [5] is more efficient than the above in terms of both key-generation and decryption time (the time required for encryption is essentially the same), but is based on a cryptographic assumption which is less standard.</p>

    <p class="text-gray-300">When the above scheme is used for key encapsulation (in the sense of Section 1.2), the sender need only send  <span class="math">(g^s, g_2^s g_3^{s \\cdot ID})</span>  and compute the key  <span class="math">H_{\\alpha}(Z^s)</span>  where H is a keyed hash function (see below); the receiver, given ciphertext  <span class="math">\\langle A, B \\rangle</span> , computes the matching key  <span class="math">H_{\\alpha}(\\hat{e}(A, K_1)/\\hat{e}(B, K_2))</span> , where  <span class="math">K_1, K_2</span>  are as before. In this description, H represents a keyed hash function where the key  <span class="math">\\alpha</span>  is included as part of the receiver's public key. Under the decisional-BDH assumption, it suffices for H to be chosen from a pairwise-independent hash family in order for the scheme to be secure. We remark, however, that this encapsulation scheme is also secure under a potentially weaker &quot;hash BDH&quot; assumption as well (and a similar remark holds also for the second IBE scheme of [5]). See further discussion at the end of this section.</p>

    <p class="text-gray-300">Message authentication codes. A number of efficient message authentication codes are known, and we do not suggest any particular one. We stress that we only require &quot;one-time&quot; security (cf. Definition 2.2) and so efficient schemes which do not rely on any computational assumptions (e.g., [35]) may be used. Furthermore, messages to be authenticated have a (known) fixed length; this enables slight optimizations and/or simplifications of known schemes.</p>

    <p class="text-gray-300"><strong>Encapsulation schemes.</strong> We suggest an encapsulation scheme based on a fixed cryptographic hash function  <span class="math">H: \\{0,1\\}^{448} \\to \\{0,1\\}^{128}</span>  (constructed, e.g., by suitably modifying the output length of SHA-1), and for a particular choice of security parameters; it is easy to adapt the scheme for the more general case. Our scheme works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup chooses a hash function h from a family of pairwise independent hash functions mapping 448-bit strings to 128-bit strings, and outputs pub = h.</li>
      <li>The encapsulation algorithm S takes pub as input, chooses a random  <span class="math">x \\in \\{0,1\\}^{448}</span> , and then outputs (r = h(x), com = H(x), dec = x).</li>
    </ul>

    <p class="text-gray-300">• The recovery algorithm  <span class="math">\\mathcal{R}</span>  takes as input (pub = h, com, dec) and outputs h(dec) if H(dec) = com, and  <span class="math">\\bot</span>  otherwise.</p>

    <p class="text-gray-300">Note that binding holds as long as it is infeasible to find a  <span class="math">dec&#x27; \\neq dec</span>  such that H(dec') = H(dec), where dec is chosen uniformly at random (cf. Definition 2.3). Thus, binding holds as long as H is second-preimage resistant (the construction can be easily modified so as to be based on UOWHFs by simply having Setup choose a key h' for a UOWHF and including h' in pub); collision-resistance is not necessary.&lt;sup&gt;3&lt;/sup&gt; Furthermore, the above scheme satisfies statistical hiding. More specifically:</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> For the encapsulation scheme described above, the statistical difference between the following distributions is at most  <span class="math">2^{-63}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) {pub  <span class="math">\\leftarrow</span>  Setup;  <span class="math">(r, com, dec) \\leftarrow \\mathcal{S}(pub) : (pub, com, r)}</span></li>
      <li>(2) {pub  <span class="math">\\leftarrow</span>  Setup;  <span class="math">(r, \\mathsf{com}, \\mathsf{dec}) \\leftarrow \\mathcal{S}(\\mathsf{pub}); r&#x27; \\leftarrow \\{0, 1\\}^{128} : (\\mathsf{pub}, \\mathsf{com}, r&#x27;)\\}.</span></li>
    </ul>

    <p class="text-gray-300"><strong>Proof</strong> (Sketch) The idea is loosely based on [16, 21], but our proof is much simpler. For any  <span class="math">x \\in \\{0,1\\}^{448}</span> , let  <span class="math">N_x \\stackrel{\\text{def}}{=} \\{x&#x27; \\mid H(x&#x27;) = H(x)\\}</span>  (this is simply the set of elements hashing to H(x)). Call  <span class="math">x \\mod</span>  if  <span class="math">|N_x| \\ge 2^{255}</span> , and bad otherwise. Since the output length of H is 128 bits, there are at most  <span class="math">2^{255} \\cdot 2^{128} = 2^{383}</span>  bad x's; thus, the probability that an x chosen uniformly at random from  <span class="math">\\{0,1\\}^{448}</span>  is bad is at most  <span class="math">2^{-65}</span> .</p>

    <p class="text-gray-300">Assuming x is good, the min-entropy of x — given  <span class="math">\\mathsf{pub}</span>  and  <span class="math">\\mathsf{com}</span>  — is at least 255 bits since every  <span class="math">\\tilde{x} \\in N_x</span>  is equally likely. Viewing h as a strong extractor (or, equivalently, applying the leftover-hash lemma [22]) we see that  <span class="math">\\{h, H(x), h(x)\\}</span>  has statistical difference at most  <span class="math">2^{-64}</span>  from  <span class="math">\\{h, H(x), U_{128}\\}</span> , where  <span class="math">U_{128}</span>  represents the uniform distribution over  <span class="math">\\{0, 1\\}^{128}</span> . The theorem follows easily.</p>

    <p class="text-gray-300">A concrete scheme. Given the primitives above, we may construct a CCA-secure encryption scheme as described in the previous section. However, as discussed in Section 1.2, improved efficiency can be obtained by directly constructing a hybrid encryption scheme; we do so here.</p>

    <p class="text-gray-300"><strong>Key generation</strong> requires running the key-generation algorithm for the underlying IBE scheme and then choosing a hash function h from a family of pairwise independent hash functions.</p>

    <p class="text-gray-300"><strong>Encryption</strong> of a message M involves (1) running the encapsulation scheme to obtain (k = h(x), ID = H(x), x); (2) using the underlying IBE as a key encapsulation scheme, with identity ID, to generate a ciphertext  <span class="math">C_1</span>  encapsulating a key k'; (3) using k' to encrypt  <span class="math">M \\circ x</span>  by, for example, computing  <span class="math">C_2 = G(k&#x27;) \\oplus (M \\circ x)</span> , where G is a PRG; (4) computing a MAC on  <span class="math">C_1, C_2</span>  using key k.</p>

    <p class="text-gray-300">The ciphertext consists of  <span class="math">ID, C_1, C_2</span> , and the tag output by the MAC.</p>

    <p class="text-gray-300"><strong>Decryption</strong> of ciphertext  <span class="math">(ID, C_1, C_2, \\mathsf{tag})</span>  is done in the obvious way: recover k' from  <span class="math">C_1</span>  (using identity ID), recover  <span class="math">M \\circ x</span>  from  <span class="math">C_2</span> , and compute k = h(x). If H(x) = ID and  <span class="math">\\mathsf{Vrfy}_k((C_1, C_2), \\mathsf{tag}) = 1</span> , then output M; otherwise, output  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">We tabulate the efficiency of our schemes, and compare them to the scheme of Kurosawa-Desmedt [25], in Table 1. Scheme 1 is instantiated using the first IBE from [5], as described above;</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;{}^{3}&lt;/sup&gt;</span> This also explains why an output length of 128 bits for H should provide a sufficient level of security.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Encryption</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Decryption</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Key&lt;br&gt;generation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ciphertext&lt;br&gt;overhead</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Scheme&lt;br&gt;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5&lt;br&gt;p-exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;p-exps.&lt;br&gt;+&lt;br&gt;2&lt;br&gt;pairings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3&lt;br&gt;exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 p &lt;br&gt;+&lt;br&gt;704</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Scheme&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5&lt;br&gt;p-exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5&lt;br&gt;exps.&lt;br&gt;+&lt;br&gt;1&lt;br&gt;pairing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&lt;br&gt;exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 p &lt;br&gt;+&lt;br&gt;704</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KD&lt;br&gt;[25]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5&lt;br&gt;p-exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5&lt;br&gt;exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3&lt;br&gt;exps.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 p &lt;br&gt;+&lt;br&gt;128</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Efficiency comparison for CCA-secure hybrid encryption schemes. When tabulating computational efficiency, &quot;private-key&quot; operations (hash function/block cipher evaluations) are ignored, and one multi-exponentiation is counted as 1.5 exponentiations. Ciphertext overhead represents the difference (in bits) between the ciphertext length and the message length, and |p| is the length (in bits) of a group element. &quot;p-exp&quot; refers to an exponentiation relative to a fixed base.</p>

    <p class="text-gray-300">scheme 2 is instantiated using the second IBE from [5]. During encryption all bases of exponentiation are fixed which potentially enables further speed-up by pre-computation. In Scheme 1 we assume that g1, g&lt;sup&gt;3&lt;/sup&gt; are generated by raising the fixed generator g to a random power. Hence, computing eˆ(g1, g3) requires only a single exponentiation assuming eˆ(g, g) is pre-computed.</p>

    <p class="text-gray-300">In addition to comparing the efficiency of these various schemes, it is interesting also to compare the cryptographic assumptions on which they are based. Security of the Kurosawa-Desmedt scheme (as in the case of the Cramer-Shoup scheme [13] on which it is based) inherently relies on the decisional Diffie-Hellman assumption, and it does not seem possible to obtain provable security using a weaker variant of this assumption. In contrast, as noted earlier, our schemes may be proven secure under &quot;hash BDH&quot;-type assumptions which are potentially weaker than the decisional-BDH assumption.&lt;sup&gt;4&lt;/sup&gt;</p>

    <p class="text-gray-300">We present an efficient methodology for constructing CCA-secure public-key cryptosystems from weak identity-based encryption schemes. Our construction adds only a mac and a weak &quot;commitment&quot; to the original IBE system. Consequently, performance of the resulting public-key system is very close to the performance of the underlying IBE scheme. This improves on a previous transformation of Canetti, et al. which relies on the use of one-time signature schemes.</p>

    <p class="text-gray-300">Applying our construction to recent IBE systems of Boneh and Boyen we obtain an efficient CCA-secure public-key cryptosystem without random oracles. Encryption (and, in one case, key generation) in the resulting systems are more efficient than in the Cramer-Shoup scheme, and on par with the recent proposal of Kurosawa and Desmedt. Decryption time and ciphertext size are comparable, though a bit worse. Our schemes are also somewhat more flexible than the Kurosawa-Desmedt scheme in terms of the cryptographic assumptions needed to obtain a proof of security. Our results show that building CCA-secure systems from IBE can produce very efficient schemes. The resulting schemes, as well as the proofs of security, are very different from those based on the work of Cramer and Shoup.</p>

    <p class="text-gray-300">&lt;sup&gt;4&lt;/sup&gt; In fact, we may base security of our constructions on purely computational — rather than decisional — assumptions; e.g., the computational-BDH assumption (using hard-core bits to encrypt one bit at a time). Although this no longer yields a practical scheme, it achieves CCA-secure encryption based on a computational assumption while avoiding the extreme inefficiency of NIZK proofs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations Among Notions of Security for Public-Key Encryption Schemes. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 26–45, 1998.</p></li>
      <li><p class="text-gray-300">[2] M. Bellare and P. Rogaway. Random Oracles are Practical: a Paradigm for Designing Efficient Protocols. First ACM Conf. on Computer and Comm. Security, ACM, pp. 62–73, 1993.</p></li>
      <li><p class="text-gray-300">[3] D. Bleichenbacher. Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS#1. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 1–12, 1998.</p></li>
      <li><p class="text-gray-300">[4] M. Blum, P. Feldman, and S. Micali. Non-Interactive Zero-Knowledge and its Applications. 20th ACM Symposium on Theory of Computing (STOC), ACM, pp. 103–112, 1988.</p></li>
      <li><p class="text-gray-300">[5] D. Boneh and X. Boyen. Efficient Selective-ID Secure Identity Based Encryption Without Random Oracles. Adv. in Cryptology — Eurocrypt 2004, LNCS vol. 3027, Springer-Verlag, pp. 223–238, 2004. Full version available from http://eprint.iacr.org/2004/172</p></li>
      <li><p class="text-gray-300">[6] D. Boneh and X. Boyen. Secure Identity Based Encryption Without Random Oracles. Adv. in Cryptology — Crypto 2004, LNCS vol. 3152, Springer-Verlag, pp. 443–459, 2004.</p></li>
      <li><p class="text-gray-300">[7] D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. Adv. in Cryptology — Crypto 2001, LNCS vol. 2139, Springer-Verlag, pp. 213–229, 2001. Full version in SIAM J. Computing 32(3): 586–615, 2003 and available from http://crypto.stanford.edu/~dabo/pubs.html</p></li>
      <li><p class="text-gray-300">[8] R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic Protocols. 42nd IEEE Symp. on Foundations of Computer Science (FOCS), IEEE, pp. 136–145, 2001. Full version available at http://eprint.iacr.org/2000/067/</p></li>
      <li><p class="text-gray-300">[9] R. Canetti, O. Goldreich, and S. Halevi. The Random Oracle Methodology, Revisited. 30th ACM Symp. on Theory of Computing (STOC), ACM, pp. 209–218, 1998.</p></li>
      <li><p class="text-gray-300">[10] R. Canetti, S. Halevi, and J. Katz. A Forward-Secure Public-Key Encryption Scheme. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 255–271, 2003. Full version available at http://eprint.iacr.org/2003/083</p></li>
      <li><p class="text-gray-300">[11] R. Canetti, S. Halevi, and J. Katz. Chosen-Ciphertext Security from Identity-Based Encryption. Adv. in Cryptology — Eurocrypt 2004, LNCS vol. 3027, Springer-Verlag, pp. 207–222, 2004.</p></li>
      <li><p class="text-gray-300">[12] C. Cocks. An Identity-Based Encryption Scheme Based on Quadratic Residues. Cryptography and Coding, LNCS vol. 2260, Springer-Verlag, pp. 360–363, 2001.</p></li>
      <li><p class="text-gray-300">[13] R. Cramer and V. Shoup. A Practical Public Key Cryptosystem Provably Secure Against Chosen Ciphertext Attack. Adv. in Cryptology — Crypto 1998, LNCS vol. 1462, Springer-Verlag, pp. 13–25, 1998.</p></li>
      <li><p class="text-gray-300">[14] R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. Adv. in Cryptology — Eurocrypt 2002, LNCS vol. 2332, Springer-Verlag, pp. 45–64, 2002.</p></li>
      <li><p class="text-gray-300">[15] J. Camenisch and V. Shoup. Practical Verifiable Encryption and Decryption of Discrete Logarithms. Adv. in Cryptology — Crypto 2003, LNCS vol. 2729, Springer-Verlag, pp. 126–144, 2003.</p></li>
      <li><p class="text-gray-300">[16] I. Damg˚ard, T.P. Pedersen, and B. Pfitzmann. On the Existence of Statistically-Hiding Bit Commitment Schemes and Fail-Stop Signatures. Adv. in Cryptology — Crypto 1993, LNCS vol. 773, Springer-Verlag, pp. 250–265, 1993.</p></li>
      <li><p class="text-gray-300">[17] D. Dolev, C. Dwork, and M. Naor. Non-Malleable Cryptography. SIAM J. Computing 30(2): 391–437, 2000.</p></li>
      <li><p class="text-gray-300">[18] U. Feige, D. Lapidot, and A. Shamir. Multiple Non-Interactive Zero-Knowledge Proofs Under General Assumptions. SIAM J. Computing 29(1): 1–28, 1999.</p></li>
      <li><p class="text-gray-300">[19] R. Gennaro and Y. Lindell. A Framework for Password-Based Authenticated Key Exchange. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 524–543, 2003.</p></li>
      <li><p class="text-gray-300">[20] S. Goldwasser, S. Micali, and R. Rivest. A Digital Signature Scheme Secure against Adaptive Chosen-Message Attacks. SIAM J. Computing 17(2): 281–308, 1988.</p></li>
      <li><p class="text-gray-300">[21] S. Halevi and S. Micali. Practical and Provably-Secure Commitment Schemes from Collision-Free Hashing. Adv. in Cryptology — Crypto 1996, LNCS vol. 1109, Springer-Verlag, pp. 201– 215, 1996.</p></li>
      <li><p class="text-gray-300">[22] J. H˚astad, R. Impagliazzo, L. Levin, and M. Luby. Construction of a Pseudorandom Generator from any One-Way Function. SIAM J. Comp. 28(4): 1364–1396, 1999.</p></li>
      <li><p class="text-gray-300">[23] N. Howgrave-Graham, P. Q. Nguyen, D. Pointcheval, J. Proos, J. H. Silverman, A. Singer, and W. Whyte. The Impact of Decryption Failures on the Security of NTRU Encryption. Adv. in Cryptology — Crypto 2003, LNCS vol. 2729, Springer-Verlag, pp. 226–246, 2003.</p></li>
      <li><p class="text-gray-300">[24] M. Joye, J.-J. Quisquater, and M. Yung. On the Power of Misbehaving Adversaries and Security Analysis of the Original EPOC. Cryptographers' Track — RSA 2001, LNCS vol. 2020, Springer-Verlag, pp. 208–222, 2001.</p></li>
      <li><p class="text-gray-300">[25] K. Kurosawa and Y. Desmedt. A New Paradigm of Hybrid Encryption Scheme. Adv. in Cryptology — Crypto 2004, LNCS vol. 3152, Springer-Verlag, pp. 426–442, 2004.</p></li>
      <li><p class="text-gray-300">[26] L. Lamport. Constructing Digital Signatures from a One-Way Function. Technical Report CSL-98, SRI International, 1978.</p></li>
      <li><p class="text-gray-300">[27] Y. Lindell. A Simpler Construction of CCA-Secure Public-Key Encryption Under General Assumptions. Adv. in Cryptology — Eurocrypt 2003, LNCS vol. 2656, Springer-Verlag, pp. 241–254, 2003.</p></li>
      <li><p class="text-gray-300">[28] M. Naor and M. Yung. Universal One-Way Hash Functions and Their Cryptographic Applications. 21st ACM Symposium on Theory of Computing (STOC), ACM, pp. 33–43, 1989.</p></li>
      <li><p class="text-gray-300">[29] C. Rackoff and D. Simon. Non-Interactive Zero-Knowledge Proof of Knowledge and Chosen Ciphertext Attack. Adv. in Cryptology — Crypto 1991, LNCS vol. 576, Springer-Verlag, pp. 433–444, 1992.</p></li>
      <li><p class="text-gray-300">[30] A. Sahai. Non-Malleable Non-Interactive Zero Knowledge and Adaptive Chosen-Ciphertext Security. 40th IEEE Symposium on Foundations of Computer Science (FOCS), IEEE, pp. 543–553, 1999.</p></li>
      <li><p class="text-gray-300">[31] A. Shamir. Identity-Based Cryptosystems and Signature Schemes. Adv. in Cryptology Crypto 1984, LNCS vol. 196, Springer-Verlag, pp. 47–53, 1985.</p></li>
      <li><p class="text-gray-300">[32] V. Shoup. Why Chosen Ciphertext Security Matters. IBM Research Report RZ 3076, November, 1998. Available at http://www.shoup.net/papers.</p></li>
      <li><p class="text-gray-300">[33] V. Shoup. Using Hash Functions as a Hedge Against Chosen Ciphertext Attack. Adv. in Cryptology — Eurocrypt 2000, LNCS vol. 275–288, Springer-Verlag, pp. 1807, 2000.</p></li>
      <li><p class="text-gray-300">[34] B. Waters. Efficient Identity-Based Encryption Without Random Oracles. Available at http: //eprint.iacr.org/2004/180</p></li>
      <li><p class="text-gray-300">[35] M.N. Wegman and J.L. Carter. New Hash Functions and Their Use in Authentication and Set Equality. J. Computer System Sciences 22(3): 265–279, 1981.</p></li>
    </ul>

`;
---

<BaseLayout title="Improved Efficiency for CCA-Secure Cryptosystems Built Using... (2004/261)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/261
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="improved-efficiency-for-cca-secure-cryptosystems-built-2004" />
  </article>
</BaseLayout>
