---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/573';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'Ouroboros Praos: An adaptively-secure, semi-synchronous proof-of-stake protocol';
const AUTHORS_HTML = 'Bernardo David, Peter Ga&#382;i, Aggelos Kiayias, Alexander Russell';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We present \`\`Ouroboros Praos&#x27;&#x27;, a proof-of-stake blockchain protocol  that, for the first time, provides security against fully-adaptive corruption in the semi-synchronous  setting: Specifically, the adversary can corrupt any participant of a dynamically evolving population of stakeholders at any moment so long as the stakeholder distribution maintains an honest majority of stake; furthermore, the protocol tolerates an adversarially-controlled message delivery delay unknown to protocol participants.

To achieve these guarantees we formalize and realize in the universal composition setting a suitable form of forward secure digital signatures and a new type of verifiable random function that maintains unpredictability under malicious key generation. Our security proof develops a general combinatorial framework for the analysis of semi-synchronous blockchains that may be of independent interest. We prove our protocol secure under standard cryptographic assumptions in the random oracle model.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> blockchain &middot; consensus &middot; proof of stake.</p>
    </section>

    <p class="text-gray-300">The design of proof-of-stake blockchain protocols was identified early on as an important objective in blockchain design; a proof-of-stake blockchain substitutes the costly proof-of-work component in Nakamoto's blockchain protocol <a href="#page-32-0">[Nak08]</a> while still providing similar guarantees in terms of transaction processing in the presence of a dishonest minority of users, where this &quot;minority&quot; is to be understood here in the context of stake rather than computational power.</p>

    <p class="text-gray-300">The basic stability and security properties of blockchain protocols were first rigorously formulated in <a href="#page-31-0">[GKL15]</a> and further studied in <a href="#page-31-1">[KP15,</a><a href="#page-32-1">PSs17]</a>; these include common prefix, chain quality and chain growth and refer to resilient qualities of the underlying data structure of the blockchain in the presence of an adversary that attempts to subvert them.</p>

    <p class="text-gray-300">Proof-of-stake protocols typically possess the following basic characteristics. Based on her local view, a party is capable of deciding, in a publicly verifiable way, whether she is permitted to produce the next block. Assuming the block is valid, other parties update their local views by adopting the block, and proceed in this way continuously. At any moment, the probability of being permitted to issue a block is proportional to the relative stake a player has in the system, as reported by the blockchain itself.</p>

    <p class="text-gray-300">A particularly challenging design aspect is that the above probabilistic mechanism should be designed so that the adversary cannot bias it to its advantage. As the stake shifts, together with the evolving population of stakeholders, so does the honest majority assumption, and hence the function that appoints stakeholders should continuously take the ledger status into account. Preventing the biasing of the election mechanism in a context of a blockchain protocol is a delicate task that so far has eluded a practical solution that is secure against all attacks.</p>

    <p class="text-gray-300">Our Results. We present &quot;Ouroboros Praos&quot;, a provably secure proof-of-stake protocol that is the first to be secure against adaptive attackers and scalable in a truly practical sense. Our protocol is based on a previous proof-of-stake protocol, Ouroboros <a href="#page-31-2">[KRDO17]</a>, as its analysis builds on some of the core combinatorial arguments that were developed to analyze that scheme. Nevertheless,</p>

    <p class="text-gray-300"><sup>&#8902;</sup> IT University of Copenhagen, bernardo@bmdavid.com.</p>

    <p class="text-gray-300"><sup>&#8902;&#8902;</sup> IOG, peter.gazi@iohk.io. Work partly done while the author was a postdoc at IST Austria, supported by the ERC consolidator grant 682815-TOCNeT.</p>

    <p class="text-gray-300"><sup>&#8902; &#8902; &#8902;</sup> University of Edinburgh and IOG. akiayias@inf.ed.ac.uk. Work partly supported by H2020 Project #653497, PANORAMIX.</p>

    <p class="text-gray-300"><sup>&dagger;</sup> University of Connecticut and IOG. acr@cse.uconn.edu. This material is based upon work supported by the National Science Foundation under Grant No. 1717432.</p>

    <p class="text-gray-300">the protocol construction has a number of novel elements that require a significant recasting and generalization of the previous combinatorial analysis. In more detail, our results are as follows.</p>

    <p class="text-gray-300">In Ouroboros Praos, deciding whether a certain participant of the protocol is eligible to issue a block is decided via a private test that is executed locally using a special verifiable random function (VRF) on the current time-stamp and a nonce that is determined for a period of time known as an &quot;epoch&quot;. A special feature of this VRF primitive, novel to our approach, is that the VRF must have strong security characteristics even in the setting of malicious key generation: specifically, if provided with an input that has high entropy, the output of the VRF is unpredictable even when an adversary has subverted the key generation procedure. We call such VRF functions &quot;VRF with unpredictability under malicious key generation&quot; and we present a strong embodiment of this notion with a novel Universal Composable (UC) formulation. We also present a very efficient realization of this primitive under the Computational Diffie Hellman (CDH) assumption in the random oracle model. Beyond this VRF notion, we also formalize in a UC fashion key evolving signatures that provide the forward security that is necessary for handling the adaptive corruption setting.</p>

    <p class="text-gray-300">In more detail, we analyze our protocol in the partial or semi-synchronous model <a href="#page-31-3">[DLS88,</a><a href="#page-32-1">PSs17]</a>. In this setting, we still divide the protocol execution in time units which, as in <a href="#page-31-2">[KRDO17]</a>, are called slots, but there is a maximum delay of &#8710; slots that is applied to message delivery and it is unknown to the protocol participants.<a href="#page-1-0">1</a> In order to cope with the &#8710;-semisynchronous setting we introduce the concept of &quot;empty slots&quot; which occur with sufficient frequency to enable short periods of silence that facilitate synchronization. This feature of the protocol gives also its moniker, &quot;Praos&quot;, meaning &quot;mellow&quot;, or &quot;gentle&quot;. Ensuring that the adversary cannot exploit the stakeholder keys that it possesses to confuse or out-maneuver the honest parties, we develop a combinatorial analysis to show that the simple rule of following the longest chain still enables the honest parties to converge to a unique view with high probability. To accomplish this we revisit and expand the forkable strings and divergence analysis of <a href="#page-31-2">[KRDO17]</a>. We remark that significant alterations are indeed necessary: As we demonstrate in Appendix <a href="#page-36-0">D,</a> the protocol of <a href="#page-31-2">[KRDO17]</a> and its analysis are critically tailored to synchronous operation and is susceptible to a desynchronization attack that can completely violate the common prefix property. Our new combinatorial analysis introduces a new concept of characteristic strings and &quot;forks&quot; that reflects silent periods in protocol execution and network delays. To bound the density of forkable strings in this &#8710;-semisynchronous setting we establish a syntactic reduction from &#8710;-semisynchronous characteristic strings to synchronous strings of <a href="#page-31-2">[KRDO17]</a> that preserves the structure of the forks they support. This is followed by a probabilistic analysis that controls the distortion caused by the reduction and concludes that &#8710;-semisynchronous forkable strings are rare. Finally, we control the effective power of adaptive adversaries in this setting with a stochastic dominance argument that permits us to carry out the analysis of the underlying blockchain guarantees (e.g., common prefix) with a single distribution that provably dominates all distributions on characteristic strings generated by adaptive adversaries. We remark that these arguments yield graceful degradation of the analysis as a function of network delays (&#8710;), in the sense that the effective stake of the adversary is amplified by a function of &#8710;.</p>

    <p class="text-gray-300">The above combinatorial analysis is nevertheless only sufficient to provide a proof of the static stake case, i.e., the setting where the stake distribution relevant to the honest majority assumption remains fixed at the onset of the computation and prior to the selection of the random genesis data that are incorporated in the genesis block. For a true proof-of-stake system, we must permit the set of stakeholders to evolve over time and appropriately adapt our honest stakeholder majority assumption. Achieving this requires a bootstrapping argument that allows the protocol to continue unboundedly by revising its stakeholder distribution as it evolves. We bootstrap our protocol in two conceptual steps. First we show how bootstrapping is possible if a randomness beacon is available to all participants. At regular intervals the beacon can be trusted to emit a new random value; the participants can then reseed the election process so the stakeholder distribution used for sampling can be brought closer to the one that is current. A key observation here is that our protocol is resilient even if the randomness beacon is weakened in the following two ways: (i) it leaks its value to the adversary ahead of time by a bounded number of time units, (ii) it allows the adversary to reset its value if it wishes within a bounded time window. We call the resulting primitive a</p>

    <p class="text-gray-300"><sup>1</sup> It is worth pointing out that the notion of slots we use in this work can be substantially shorter in terms of real time elapsed compared to the slots of <a href="#page-31-2">[KRDO17]</a>, where each slot represented a full round of interaction between all participants.</p>

    <p class="text-gray-300">&quot;leaky resettable beacon&quot; and show that our bootstrapping argument still holds in this stronger adversarial setting.</p>

    <p class="text-gray-300">In the final refinement of our protocol, we show how it is possible to implement the leaky resettable beacon via a simple algorithm that concatenates the VRF outputs that were contributed by the participants from the blockchain and subjects them to a hash function that is modeled as a random oracle. This implementation explains the reasons behind the beacon relaxation we introduced: leakiness stems from the fact that the adversary can complete the blockchain segment that determines the beacon value before revealing it to the honest participants, while resettability stems from the fact that the adversary can try a bounded number of different blockchain extensions that will stabilize the final beacon value to a different preferred value.</p>

    <p class="text-gray-300">Putting all the above together, we show how our protocol provides a &quot;robust transaction ledger&quot; in the sense that an immutable record of transactions is built that also guarantees that new transactions will be always included. Our security definition is in the &#8710;-semisynchronous setting with full adaptive corruptions. As mentioned above, security degrades gracefully as &#8710; increases, and this parameter is unknown to the protocol participants.</p>

    <p class="text-gray-300">Note that implementing the beacon via hashing VRF values will make feasible a type of &quot;grinding attack&quot; where the adversary can trade hashing power for a slight bias of the protocol execution to its advantage. We show how this bias can be controlled by suitably increasing the relevant parameters depending on the hashing power that is available to the adversary.</p>

    <p class="text-gray-300">Comparison to related work. The idea of proof-of-stake protocols has been discussed extensively in the bitcoin forum.<a href="#page-2-0">2</a> The manner that a stakeholder determines eligibility to issue a block is always publicly verifiable and the proof of eligibility is either computed publicly (via a calculation that is verifiable by repeating it) or by using a cryptographic mechanism that involves a secret-key computation and a public-key verification. The first example of the former approach appeared in PPCoin <a href="#page-31-4">[KN12]</a>, and was followed by others including Ouroboros and Snow White <a href="#page-31-5">[BGM14</a><a href="#page-31-2">,KRDO17,</a><a href="#page-31-6">DPS19]</a>; while the first example of the latter approach (that we also employ in our work) appeared in NXT (cf. Section 2.4.1 of <a href="#page-31-7">[Com14]</a>) and was then also used elsewhere, most notably in Algorand <a href="#page-32-2">[Mic16]</a>. The virtue of the latter approach is exactly in its potential to control adaptive corruptions: due to the fact that the adversary cannot predict the eligibility of a stakeholder to issue a block prior to corrupting it, she cannot gain an advantage by directing its corruption quota to specific stakeholders. Nevertheless, none of these previous works isolated explicitly the properties of the primitives that are required to provide a full proof of security in the setting of adaptive corruptions. Injecting high quality randomness in the PoS blockchain was proposed by Bentov et al. <a href="#page-31-8">[BLMR14</a><a href="#page-31-9">,BGM16]</a>, though their proposal does not have a full formal analysis. The Ouroboros proof-of-stake protocol <a href="#page-31-2">[KRDO17]</a> is provably secure in a corruption model that excludes fully adaptive attacks by imposing a corruption delay on the corruption requests of the adversary. The Snow White proof-of-stake <a href="#page-31-6">[DPS19]</a> is the first to prove security in the &#8710;-semi-synchronous model but&mdash;as in the case of Ouroboros&mdash;adopts a weak adaptive corruption model.</p>

    <p class="text-gray-300">A recent work close to ours is Algorand <a href="#page-32-2">[Mic16]</a> that also provides a proof-of-stake ledger that is adaptively secure. It follows an entirely different construction approach that runs a Byzantine agreement protocol for every block and achieves adaptive-corruption security via a novel, appealing concept of player-replaceability. However, Algorand is only secure against a 1/3 adversary bound; and while the protocol itself is very efficient, it yields an inherently slower block production rate compared to an &quot;eventual consensus&quot; protocol (like Bitcoin, Snow White, and Ouroboros). In principle, proof-of-stake blockchain protocols can advance at the theoretical maximum speed (of one block per communication round), while protocols relying on Byzantine agreement, like Algorand, would require a larger number of rounds to settle each block.</p>

    <p class="text-gray-300">Sleepy consensus <a href="#page-32-3">[PS17]</a> puts forth a technique for handling adaptive corruptions in a model that also encompasses fail-stop and recover corruptions; however, the protocol can be applied directly only in a static stake (i.e., permissioned) setting. We note that in fact our protocol can be also proven secure in such mixed corruption setting, where both fail-stop and recover as well as Byzantine corruptions are allowed (with the former occurring at an arbitrarily high rate); nevertheless this is out of scope for the present exposition and we omit further details.</p>

    <p class="text-gray-300"><sup>2</sup> Refer e.g., to the posts by QuantumMechanic and others from 2011 <a href="https://bitcointalk.org/index.php?topic=27787.0" target="_blank" rel="noopener noreferrer">https://bitcointalk.org/index.</a> <a href="https://bitcointalk.org/index.php?topic=27787.0" target="_blank" rel="noopener noreferrer">php?topic=27787.0</a> (Last Accessed 19/09/2017).</p>

    <p class="text-gray-300">Note that the possibility of adversarial grinding in Ouroboros Praos is also present in previous work that derives randomness by hashing <a href="#page-32-2">[Mic16,</a><a href="#page-31-6">DPS19]</a>, as opposed to a dedicated coin-tossing protocol as in <a href="#page-31-2">[KRDO17]</a>. Following the examples of <a href="#page-32-2">[Mic16</a><a href="#page-31-6">,DPS19]</a>, we show that security can be guaranteed despite any adversarial bias resulting from grinding. In fact, we show how to use the q-bounded model of <a href="#page-31-0">[GKL15]</a> to derive a bound that shows how to increase the relevant security parameters given the hashing power that is available to the adversary.</p>

    <p class="text-gray-300">Finally, in the present exposition we also put aside incentives; nevertheless, it is straightforward to adapt the mechanism of input endorsers from the protocol of <a href="#page-31-2">[KRDO17]</a> to our setting and its approximate Nash equilibrium analysis can be ported directly.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Throughout the paper, let N = {0, 1, 2, . . .} denote the set of natural numbers (including zero). We say a function negl(x) is negligible if, for every c &gt; 0, there exists an n &gt; 0 such that negl(x) &lt; 1/x<sup>c</sup> for all x &ge; n. The length of a string w is denoted by |w|; &epsilon; denotes the empty string, and v &#8741; w denotes concatenation of strings.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The Semi-Synchronous Model</h3>

    <p class="text-gray-300">On a high level, we consider the security model of <a href="#page-31-2">[KRDO17]</a> with simple modifications to account for adversarially-controlled message delays and immediate adaptive corruption. Namely, we allow the adversary A to selectively delay any messages sent by honest parties for up to &#8710; &isin; N slots; and corrupt parties without delay.</p>

    <p class="text-gray-300">Time and slots. We consider a setting where time is divided into discrete units called slots that are indexed by natural numbers. We often use the notation sl, sl<sup>i</sup> , etc. to denote variables representing slot numbers. Players are equipped with (roughly) synchronized clocks that indicate the current slot: we assume that any clock drift is subsumed in the slot length.</p>

    <p class="text-gray-300">Security Model. We adopt the model introduced by <a href="#page-31-0">[GKL15]</a> for analyzing security of blockchain protocols enhanced with an ideal functionality F. We note that multiple different &quot;functionalities&quot; can be encompassed by F. In our model we employ the &quot;Delayed Diffuse&quot; functionality, which allows for adversarially-controlled delayed delivery of messages diffused among stakeholders.</p>

    <p class="text-gray-300">The Diffuse Functionality. This functionality is parameterized by &#8710; &isin; N and denoted as DDiffuse&#8710;. It maintains rounds, executing one round per slot. DDiffuse<sup>&#8710;</sup> interacts with the environment Z, stakeholders U1, . . . , U<sup>n</sup> and an adversary A, proceeding as follows for each round:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>DDiffuse<sup>&#8710;</sup> maintains an incoming string for each party U<sup>i</sup> that participates. A party, if activated, is allowed at any moment to fetch the contents of its incoming string, hence one may think of this as a mailbox. Furthermore, parties can give an instruction to the functionality to diffuse a message. Activated parties are allowed to diffuse once in a round.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the adversary A is activated, it is allowed to: (a) Read all inboxes and all diffuse requests and deliver messages to the inboxes in any order it prefers; (b) For any message m obtained via a diffuse request and any party U<sup>i</sup> , A may move m into a special string delayed<sup>i</sup> instead of the inbox of U<sup>i</sup> . A can decide this individually for each message and each party; (c) For any party Ui , A can move any message from the string delayed<sup>i</sup> to the inbox of U<sup>i</sup> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of each round, the functionality also ensures that every message that was either (a) diffused in this round and not put to the string delayed<sup>i</sup> or (b) removed from the string delayed<sup>i</sup> in this round is delivered to the inbox of party U<sup>i</sup> . If any message currently present in delayed<sup>i</sup> was originally diffused at least &#8710; slots ago, then the functionality removes it from delayed<sup>i</sup> and appends it to the inbox of party U<sup>i</sup> , being available to U<sup>i</sup> by the beginning of next round.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving (Create, U, C) from the environment, the functionality spawns a new stakeholder with chain C as its initial local chain (as it was the case in <a href="#page-31-2">[KRDO17]</a>).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Protocol Execution and Adaptive Corruptions. Given the above we will assume that the execution of the protocol is with respect to a functionality F that incorporates DDiffuse as well as possibly additional functionalities to be explained in the following sections. The environment issues transactions on behalf of any stakeholder U<sup>i</sup> by requesting a signature on the transaction as described in Protocol &pi;SPoS of Figure <a href="#page-11-0">4</a> and handing the transaction to stakeholders to put them into blocks. Beyond any restrictions imposed by F, the adversary can only corrupt a stakeholder U<sup>i</sup> if it is given permission by the environment Z running the protocol execution. The permission is in the form of a message (Corrupt, Ui) which is provided to the adversary by the environment. Upon receiving permission from the environment, the adversary immediately corrupts U<sup>i</sup> without any delay, differently from <a href="#page-31-2">[KRDO17</a><a href="#page-31-6">,DPS19]</a>, where corruptions only take place after a given delay. Note that a corrupted stakeholder U<sup>i</sup> will relinquish its entire state to A; from this point on, the adversary will be activated in place of the stakeholder U<sup>i</sup> . The adversary is able to control transactions and blocks generated by corrupted parties by interacting with FDSIG,FKES and FVRF, as described in Protocol &pi;SPoS of Section <a href="#page-5-0">3.</a> In summary, regarding activations we have the following: (a) At each slot, the environment Z activates all honest stakeholders.<a href="#page-4-0">3</a> (b) The adversary is activated at least as the last entity in each slot (as well as during all adversarial party activations and invocations from the ideal functionalities as prescribed); (c) If a stakeholder does not fetch in a certain slot the messages written to its incoming string from the diffuse functionality they are flushed.</p>

    <p class="text-gray-300">Restrictions imposed on the environment. It is easy to see that the model above confers such sweeping power on the adversary that one cannot establish any significant guarantees on protocols of interest. It is thus important to restrict the environment suitably (taking into account the details of the protocol) so that we may be able to argue security. We require that in every slot, at most a minority fraction &delta; &lt; 1/2 of the stake is controlled by the adversary in the view of any honest stakeholder; for a value &delta; to be specified later as part of the protocol analysis. If this is violated, an event Bad<sup>&delta;</sup> becomes true for the given execution. When the environment spawns a new stakeholder by sending message (Create, U, C) to the Key and Transaction functionality, the initial local chain C can be the chain of any honest stakeholder even in the case of &quot;lazy honest&quot; stakeholders as described in Appendix <a href="#page-41-0">H,</a> without requiring this stakeholder to have been online in the past slot as in <a href="#page-31-2">[KRDO17]</a>. Finally, we note that in all of our proofs, whenever we say that a property Q holds with high probability over all executions, we will in fact argue that Q &or; Bad<sup>&delta;</sup> holds with high probability over all executions. This captures the fact that we exclude environments and adversaries that trigger Bad<sup>&delta;</sup> with non-negligible probability.</p>

    <p class="text-gray-300">Random Oracle. We also assume the availability of a random oracle. As usually, this is a function H: {0, 1} <sup>&lowast;</sup> &rarr; {0, 1} <sup>w</sup> available to all parties that answers every fresh query with an independent, uniformly random string from {0, 1} <sup>w</sup>, while any repeated queries are answered consistently.</p>

    <p class="text-gray-300">Erasures. We assume that honest users can carry out secure erasure, a standard assumption for protocols with security against adaptive adversaries; see, for example, <a href="#page-32-4">[Lin09]</a>.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Transaction Ledger Properties</h3>

    <p class="text-gray-300">We adopt the same definitions for transaction ledger properties as <a href="#page-31-2">[KRDO17]</a>. A protocol &Pi; implements a robust transaction ledger provided that the ledger that &Pi; maintains is divided into &quot;blocks&quot; attributed to slots so that each slot is associated with at most one ledger block; this association then determines the order with which transactions are incorporated in the ledger. It should also satisfy the following two properties.</p>

    <p class="text-gray-300">Persistence with parameter k &isin; N. Once a node of the system proclaims a certain transaction tx in the stable part of its ledger, the remaining nodes, if queried, will either report tx in the same position of that ledger or report a stable ledger which is a prefix of that ledger. Here the notion of stability is a predicate that is parameterized by a security parameter k; specifically, a transaction is declared stable if and only if it is in a block that is more than k blocks deep in the ledger.</p>

    <p class="text-gray-300"><sup>3</sup> We assume this to simplify our formal treatment, a variant of our protocol can actually accommodate &quot;lazy honesty&quot; as introduced in <a href="#page-32-2">[Mic16]</a>. In this variant, honest stakeholders only come online at the beginning of each epoch and at a few infrequent, predictable moments, see Appendix <a href="#page-41-0">H.</a></p>

    <p class="text-gray-300"><strong>Liveness with parameter</strong>  <span class="math">u \\in \\mathbb{N}</span> . If all honest nodes in the system attempt to include a certain transaction then, after the passing of time corresponding to u slots (called the transaction confirmation time), all nodes, if queried and responding honestly, will report the transaction as stable.</p>

    <p class="text-gray-300">In [KP15,PSs17] it was shown that persistence and liveness can be derived from elementary &quot;chain properties&quot; provided that protocol  <span class="math">\\Pi</span>  derives the ledger from a data structure in the form of a blockchain. We work with an adaptation of these properties formulated in [KRDO17]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Prefix (CP); with parameter  <span class="math">k \\in \\mathbb{N}</span> . The chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  adopted by two honest parties at the onset of the slots  <span class="math">\\mathsf{sl}_1 \\leq \\mathsf{sl}_2</span>  are such that  <span class="math">\\mathcal{C}_1^{\\lceil k} \\preceq \\mathcal{C}_2</span> , where  <span class="math">\\mathcal{C}_1^{\\lceil k}</span>  denotes the chain obtained by removing the last k blocks from  <span class="math">\\mathcal{C}_1</span> , and  <span class="math">\\preceq</span>  denotes the prefix relation.</li>
      <li>Honest-Bounded Chain Growth (HCG); with parameters  <span class="math">\\tau \\in (0, 1]</span>  and  <span class="math">s \\in \\mathbb{N}</span> . Consider the chain  <span class="math">\\mathcal{C}</span>  adopted by an honest party. Let  <span class="math">\\mathsf{sl}_2</span>  be the slot associated with the last block of  <span class="math">\\mathcal{C}</span>  and let  <span class="math">\\mathsf{sl}_1</span>  be a prior slot in which  <span class="math">\\mathcal{C}</span>  has an honestly-generated block. If  <span class="math">\\mathsf{sl}_2 \\geq \\mathsf{sl}_1 + s</span> , then the number of blocks appearing in  <span class="math">\\mathcal{C}</span>  after  <span class="math">\\mathsf{sl}_1</span>  is at least  <span class="math">\\tau s</span> . The parameter  <span class="math">\\tau</span>  is called the speed coefficient.</li>
      <li>Existential Chain Quality ( <span class="math">\\exists CQ</span> ); with parameter  <span class="math">s \\in \\mathbb{N}</span> . Consider the chain  <span class="math">\\mathcal{C}</span>  adopted by an honest party at the onset of a slot and any portion of  <span class="math">\\mathcal{C}</span>  spanning s prior slots; then at least one honestly-generated block appears in this portion.</li>
    </ul>

    <p class="text-gray-300">We remark that  <span class="math">\\exists CQ</span>  and HCG can be combined in a straightforward way to yield a more general notion of chain growth, described below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Chain Growth (CG); with parameters  <span class="math">\\tau \\in (0,1]</span>  and  <span class="math">s \\in \\mathbb{N}</span> . Consider the chain  <span class="math">\\mathcal{C}</span>  possessed by an honest party at the onset of a slot and any portion of  <span class="math">\\mathcal{C}</span>  spanning s contiguous prior slots; then the number of blocks appearing in this portion of the chain is at least  <span class="math">\\tau s</span> . We call  <span class="math">\\tau</span>  the speed coefficient.</li>
    </ul>

    <p class="text-gray-300">Our choice to focus on  <span class="math">\\exists \\mathsf{CQ}</span>  and  <span class="math">\\mathsf{HCG}</span>  is motivated by analytic concerns.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 The Static Stake Protocol</h2>

    <p class="text-gray-300">We first consider the static stake case, where the stake distribution is fixed throughout protocol execution. The general structure of the protocol in the semi-synchronous model is similar to that of (synchronous) Ouroboros [KRDO17] but introduces several fundamental modifications to the leader selection process: not all slots will be attributed a slot leader, some slots might have multiple slot leaders, and slot leaders' identities remain unknown until they act. The first modification is used to deal with delays in the semi-synchronous network as the <em>empty slots</em>&mdash;where no block is generated&mdash;assist the honest parties to synchronize. The last modification is used to deal with adaptive corruptions, as it prevents the adversary from learning the slot leaders' identity ahead of time and using this knowledge to strategically corrupt coalitions of parties with large (future) influence. Moreover, instead of using concrete instantiations of the necessary building blocks, we describe the protocol with respect to ideal functionalities, which we later realize with concrete constructions. This difference allows us to reason about security in the ideal model through a combinatorial argument without having to deal with the probability that the cryptographic building blocks fail. Before describing the specifics of the new leader selection process and the new protocol, we first formally define the static stake scenario and introduce basic definitions as stated in [KRDO17] following the notation of [GKL15].</p>

    <p class="text-gray-300">In the static stake case, we assume that a fixed collection of n stakeholders  <span class="math">U_1, \\ldots, U_n</span>  interact throughout the protocol. Stakeholder  <span class="math">U_i</span>  is attributed stake  <span class="math">s_i</span>  at the beginning of the protocol.</p>

    <p class="text-gray-300"><strong>Definition 1 (Genesis Block).</strong> The genesis block  <span class="math">B_0</span>  contains the list of stakeholders identified by a label  <span class="math">U_i</span> , their respective public keys and respective stakes</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{S}_0 = \\left( (U_1, v_1^{\\text{vrf}}, v_1^{\\text{kes}}, v_1^{\\text{dsig}}, s_1), \\dots, (U_n, v_n^{\\text{vrf}}, v_n^{\\text{kes}}, v_n^{\\text{dsig}}, s_n) \\right) ,</span>$</p>

    <p class="text-gray-300">and a nonce  <span class="math">\\eta</span> .</p>

    <p class="text-gray-300">We note that the nonce  <span class="math">\\eta</span>  will be used to seed the slot leader election process and that  <span class="math">v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}}</span>  will be determined by  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> ,  <span class="math">\\mathcal{F}_{\\text{KES}}</span>  and  <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> , respectively.</p>

    <p class="text-gray-300"><strong>Definition 2 (Epoch, State, Block Proof, Block, Blockchain).</strong> An epoch starting at some slot sl is a set of R adjacent slots  <span class="math">S = \\{sl, ..., sl + R - 1\\}</span> . (The value R is a parameter of the protocol we analyze in this section.) A state is a string  <span class="math">st \\in \\{0,1\\}^{\\lambda}</span> . A block proof is a value (or set of values) crt containing information that allows stakeholders to verify if a block is valid. A block  <span class="math">B = (sl, st, d, crt_j, \\sigma_j)</span>  generated at a slot  <span class="math">sl \\in S</span>  contains the current state  <span class="math">st \\in \\{0,1\\}^{\\lambda}</span> , data  <span class="math">d \\in \\{0,1\\}^*</span> , the slot number sl, a block proof  <span class="math">crt_j</span>  and  <span class="math">\\sigma_j</span> , a signature on  <span class="math">(st, d, sl, crt_j)</span>  under the signing key for the time period of slot sl of the stakeholder  <span class="math">U_i</span>  generating the block.</p>

    <p class="text-gray-300">A blockchain (or simply chain) relative to the genesis block  <span class="math">B_0</span>  is a sequence of blocks  <span class="math">B_1, \\ldots, B_n</span>  associated with a strictly increasing sequence of slots for which the state  <span class="math">st_i</span>  of  <span class="math">B_i</span>  is equal to  <span class="math">H(B_{i-1})</span> , where H is a prescribed collision-resistant hash function. The length of a chain  <span class="math">len(\\mathcal{C}) = n</span>  is its number of blocks. The block  <span class="math">B_n</span>  is the head of the chain, denoted  <span class="math">head(\\mathcal{C})</span> . We treat the empty string  <span class="math">\\varepsilon</span>  as a legal chain and by convention set  <span class="math">head(\\varepsilon) = \\varepsilon</span> . Let  <span class="math">\\mathcal{C}</span>  be a chain of length n and k be any non-negative integer. We denote by  <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span>  the chain resulting from removal of the k rightmost blocks of  <span class="math">\\mathcal{C}</span> . If  <span class="math">k \\geq len(\\mathcal{C})</span>  we define  <span class="math">\\mathcal{C}^{\\lceil k \\rceil} = \\varepsilon</span> . We let  <span class="math">\\mathcal{C}_1 \\preceq \\mathcal{C}_2</span>  indicate that the chain  <span class="math">\\mathcal{C}_1</span>  is a prefix of the chain  <span class="math">\\mathcal{C}_2</span> .</p>

    <p class="text-gray-300">We consider as valid blocks that are generated by a stakeholder in the slot leader set of the slot to which the block is attributed. Later in Section 3.3 we discuss slot leader sets and how they are selected.</p>

    <p class="text-gray-300"><strong>Definition 3 (Absolute and Relative Stake).</strong> Let  <span class="math">U_{\\mathcal{P}}</span> ,  <span class="math">U_{\\mathcal{A}}</span>  and  <span class="math">U_{\\mathcal{H}}</span>  denote the sets of all stakeholders, the set of stakeholders controlled by an adversary  <span class="math">\\mathcal{A}</span> , and the remaining (honest) stakeholders, respectively. For any party (resp. set of parties) X we denote by  <span class="math">s_X^+</span>  (resp.  <span class="math">s_X^-</span> ) the maximum (resp. minimum) absolute stake controlled by X in the view of all honest stakeholders at a given slot, and by  <span class="math">\\alpha_X^+ \\triangleq s_X^+/s_{\\mathcal{P}}</span>  and  <span class="math">\\alpha_X^- \\triangleq s_X^-/s_{\\mathcal{P}}</span>  its relative stake taken as maximum and minimum respectively across the views of all honest stakeholders. For simplicity, we use  <span class="math">s_X^s</span> ,  <span class="math">\\alpha_X^s</span>  instead of  <span class="math">s_{U_X}</span> ,  <span class="math">\\alpha_{U_X}</span>  for all  <span class="math">X \\in \\{\\mathcal{P}, \\mathcal{A}, \\mathcal{H}\\}</span> ,  <span class="math">s \\in \\{+, -\\}</span> . We also call  <span class="math">\\alpha_{\\mathcal{A}} \\triangleq \\alpha_{\\mathcal{A}}^+</span>  and  <span class="math">\\alpha_{\\mathcal{H}} \\triangleq \\alpha_{\\mathcal{H}}^-</span>  the adversarial stake ratio and honest stake ratio, respectively.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Forward Secure Signatures and <span class="math">\\mathcal{F}_{KES}</span></h3>

    <p class="text-gray-300">In regular digital signature schemes, an adversary who compromises the signing key of a user can generate signatures for any messages it wishes, including messages that were (or should have been) generated in the past. Forward secure signature schemes [BM99] prevent such an adversary from generating signatures for messages that were issued in the past, or rather allows honest users to verify that a given signature was generated at a certain point in time. Basically, such security guarantees are achieved by &quot;evolving&quot; the signing key after each signature is generated and erasing the previous key in such a way that the actual signing key used for signing a message in the past cannot be recovered but a fresh signing key can still be linked to the previous one. This notion is formalized through key evolving signature schemes, which allow signing keys to be evolved into fresh keys for a number of time periods. We remark that efficient constructions of key evolving signature schemes with forward security exist [IR01] but no previous work has fully specified them in the UC setting. Previous (game-based) definitions are presented in Appendix A.3.</p>

    <p class="text-gray-300">We present a UC definition of the type of key-evolving signatures that we will take advantage of in our constructions.  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  allows us to achieve forward security with erasures (<em>i.e.</em>, assuming that parties securely delete old signing keys as the protocol proceeds). This functionality embodies ideal key evolving signature schemes allowing an adversary that corrupts the signer to forge signatures only under the current and future signing keys, but not under a previous signing key that has been updated. Our starting point for  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  is the standard digital signature functionality defined in [Can04] with the difference that packs together with the signing operation a key-evolving operation. During verification,  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  lets the adversary set the response to a verification query (taking as input a given time period) only if no key update has been performed since that time period and no entry exists in its internal table for the specific message, signature and time period specified in the query. We present  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  in Figure 1. In Appendix B, we will show that  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  can be realized by a construction based on key evolving signature schemes as defined in Appendix A.3.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Functionality FKES</h4>

    <p class="text-gray-300">FKES is parameterized by the total number of signature updates T, interacting with a signer U<sup>S</sup> and stakeholders U<sup>i</sup> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key Generation. Upon receiving a message (KeyGen, sid, US) from a stakeholder US, send (KeyGen, sid, US) to the adversary. Upon receiving (VerificationKey, sid, US, v) from the adversary, verify that v is unique and send (VerificationKey, sid, v) to US, record the triple (sid, US, v) and set counter kctr = 1.</li>
      <li>Sign and Update. Upon receiving a message (USign, sid, US, m, j) from US, verify that (sid, US, v) is recorded for some sid and that kctr &le; j &le; T. If not, then ignore the request. Else, set kctr = j + 1 and send (Sign, sid, US, m, j) to the adversary. Upon receiving (Signature, sid, US, m, j, &sigma;) from the adversary, verify that no entry (m, j, &sigma;, v, 0) is recorded. If it is, then output an error message to U<sup>S</sup> and halt. Else, send (Signature, sid, m, j, &sigma;) to US, and record the entry (m, j, &sigma;, v, 1).</li>
      <li>Signature Verification. Upon receiving a message (Verify, sid, m, j, &sigma;, v&prime; ) from some stakeholder U<sup>i</sup> do:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If v &prime; = v and the entry (m, j, &sigma;, v, 1) is recorded, then set f = 1. (This condition guarantees completeness: If the verification key v &prime; is the registered one and &sigma; is a legitimately generated signature for m, then the verification succeeds.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if v &prime; = v, the signer is not corrupted, and no entry (m, j, &sigma;&prime; , v, 1) for any &sigma; &prime; is recorded, then set f = 0 and record the entry (m, j, &sigma;, v, 0). (This condition guarantees unforgeability: If v &prime; is the registered one, the signer is not corrupted, and never signed m, then the verification fails.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if there is an entry (m, j, &sigma;, v&prime; , f&prime; ) recorded, then let f = f &prime; . (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if j &lt; kctr, let f = 0 and record the entry (m, j, &sigma;, v, 0). Otherwise, if j = kctr, hand (Verify, sid, m, j, &sigma;, v&prime; ) to the adversary. Upon receiving (Verified, sid, m, j, &#981;) from the adversary let f = &#981; and record the entry (m, j, &sigma;, v&prime; , &#981;). (This condition guarantees that the adversary is only able to forge signatures under keys belonging to corrupted parties for time periods corresponding to the current or future slots.)</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Output (Verified, sid, m, j, f) to Ui.</p>

    <p class="text-gray-300">Fig. 1: Functionality FKES.</p>

    <p class="text-gray-300">Theorem 1. The &pi;KES construction presented in Appendix <a href="#page-34-0">B,</a> realizes FKES with erasures assuming KES = (Gen, Sign, Verify,Update) is a key evolving signature scheme with forward security as per Definition <a href="#page-33-1">17</a> and Definition <a href="#page-34-1">19.</a></p>

    <p class="text-gray-300">Remark 1. Note that the signing operation in a key-evolving signature is a local operation performed by the signer. To reflect this in our formalism, we require that whenever the adversary is activated to provide a signature, she has to provide the answer (i.e. the signature string) to this request immediately (no other output to another protocol machine is allowed) and return the activation token back to the functionality FKES. We remark that while we do not aim for a fully composable security analysis of Ouroboros Praos in this work, this type of restriction can also be captured in the full UC setting, as is done in <a href="#page-31-13">[BGK</a><sup>+</sup>18] using the formalism proposed by Camenisch et al. <a href="#page-31-14">[CEK</a><sup>+</sup>16].</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 UC-VRFs with Unpredictability Under Malicious Key Generation</h3>

    <p class="text-gray-300">The usual pseudorandomness definition for VRFs (as stated in Appendix <a href="#page-32-5">A.1,</a> Definition <a href="#page-32-6">16)</a> captures the fact that an attacker, seeing a number of VRF outputs and proofs for adversarially chosen inputs under a key pair that is correctly generated by a challenger, cannot distinguish the output of the VRF on a new (also adversarially chosen) input from a truly random string. This definition is too weak for our purposes for two reasons: first, we need a simulation-based definition so that the VRF can be composed directly within our protocol; second, we need the primitive to provide some level of unpredictability even under malicious key generation, i.e., against adversaries who are allowed to generate the secret and public key pair.</p>

    <p class="text-gray-300">Our UC formulation of VRFs cannot be implied by the standard VRF security definition or even the simulatable VRF notion of <a href="#page-31-15">[CL07]</a>. For instance, the VRF proofs in our setting have to be simulatable without knowlege of the VRF output (which is critical as we would like to ensure that the VRF output is not leaked to the adversary prematurely); it is easy to construct a VRF that is secure in the standard definition, but it is impossible to simulate its proofs without knowledge of the VRF output. Furthermore, if the adversary is allowed to generate its own key pair it is easy to see that the distribution of the VRF outputs cannot be guaranteed. Indeed, even for known constructions (e.g. <a href="#page-31-16">[DY05]</a>), an adversary that maliciously generates keys can easily and significantly skew the output distribution.</p>

    <p class="text-gray-300">We call the latter property unpredictability under malicious key generation and we present, in Figure <a href="#page-9-0">2,</a> a UC definition for VRF's that captures this stronger security requirement.<a href="#page-8-1">4</a> The functionality operates as follows. Given a key generation request from one of the stakeholders, it returns a new verification key v that is used to label a table. Two methods are provided for computing VRF values. The first provides just the VRF output and does not interact with the adversary. In the second, whenever invoked on an input m that has not been asked before by a stakeholder that is associated to a certain table labeled by v, the functionality will query the adversary for the value of the proof &pi;, and subsequently sample a random element &rho; to associate with m. Verification is always consistent and will validate outputs that have already been inserted in a table. Unpredictability against malicious key generation is captured by imposing the same random selection of outputs even for the function tables that correspond to keys of corrupted stakeholders. Finally, the adversary is allowed to query all function tables maintained by the functionality for which either a proof has been computed, or they correspond to adversarial keys. In Appendix <a href="#page-35-0">C,</a> we show how to realize FVRF in the random oracle model under the CDH assumption based on the 2-Hash-DH verifiable oblivious PRF construction of <a href="#page-31-17">[JKK14]</a>.</p>

    <p class="text-gray-300">Theorem 2. The 2Hash-DH construction presented in Appendix <a href="#page-35-0">C,</a> realizes FVRF in the random oracle model assuming the CDH.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Oblivious Leader Selection</h3>

    <p class="text-gray-300">As in (synchronous) Ouroboros, for each slot 0 &lt; sl &le; R, a slot leader for sl is a stakeholder who is elected to generate a block at slot sl. However, our leader selection process differs from Ouroboros <a href="#page-31-2">[KRDO17]</a> in three points: (1) potentially, multiple slot leaders may be elected for a particular slot (forming a slot leader set); (2) frequently, slots will have no leaders assigned to them; and (3) a priori, only a slot leader is aware that it is indeed a leader for a given slot; this assignment is unknown to all the other stakeholders&mdash;including other slot leaders of the same slot&mdash;until the other stakeholders receive a valid block from this slot leader. The combinatorial analysis presented in Section <a href="#page-11-1">4</a> shows (with an honest stake majority) that (i.) blockchains generated according to these dynamics are well-behaved even if multiple slot leaders are selected for a slot and that (ii.) sequences of slots with no leader provide sufficient stability for honest stakeholders to effectively synchronize. As a matter of terminology, we call slots with an associated nonempty slot leader set active slots and slots that are not assigned a slot leader empty slots.</p>

    <p class="text-gray-300">The idealized slot leader assignment and the active slots coefficient. The fundamental leader assignment process calls for a stakeholder U<sup>i</sup> to be independently selected as a leader for a particular slot sl with probability p<sup>i</sup> depending only on its relative stake. (In this static-stake analysis, relative stake is simply determined by the genesis block B0.) The exact relationship between p<sup>i</sup> and the relative stake &alpha;<sup>i</sup> is determined by a parameter f of the protocol which we refer to as the active slots coefficient. Specifically,</p>

    <p class="text-gray-300">
<span class="math">$p_i = \\phi_f(\\alpha_i) \\triangleq 1 - (1 - f)^{\\alpha_i} , \\qquad (1)</span>$</p>

    <p class="text-gray-300">where &alpha;<sup>i</sup> is the relative stake held by stakeholder U<sup>i</sup> . We occasionally drop the subscript f and write &#981;(&alpha;i) when f can be inferred from context. As the events &quot;U<sup>i</sup> is a leader for sl&quot; are independent, this process may indeed generate multiple (or zero) leaders for a given slot.</p>

    <p class="text-gray-300"><sup>4</sup> In fact our UC formulation captures a stronger notion: even for adversarial keys the VRF function will act as a random oracle. We note that while we can achieve this notion in the random oracle model, a weaker condition of mere unpredictability can be sufficient for the security of our protocol. A UC version of the notion of verifiable pseudorandom permutations, cf. <a href="#page-31-18">[DP07]</a>, could potentially be used towards a standard model instantiation of the primitive.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Functionality FVRF.</h4>

    <p class="text-gray-300">FVRF interacts with stakeholders U1, . . . , U<sup>n</sup> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key Generation. Upon receiving a message (KeyGen, sid) from a stakeholder Ui, hand (KeyGen, sid, Ui) to the adversary. Upon receiving (VerificationKey, sid, Ui, v) from the adversary, if U<sup>i</sup> is honest, verify that v is unique, record the pair (Ui, v) and return (VerificationKey, sid, v) to Ui. Initialize the table T(v, &middot;) to empty.</li>
      <li>Malicious Key Generation. Upon receiving a message (KeyGen, sid, v) from S, verify that v has not being recorded before; in this case initialize table T(v, &middot;) to empty and record the pair (S, v).</li>
      <li>VRF Evaluation. Upon receiving a message (Eval, sid, m) from Ui, verify that some pair (Ui, v) is recorded. If not, then ignore the request. Then, if the value T(v, m) is undefined, pick a random value y from {0, 1} <sup>&#8467;</sup>VRF and set T(v, m) = (y, &empty;). Then output (Evaluated, sid, y) to Ui, where y is such that T(v, m) = (y, S) for some S.</li>
      <li>VRF Evaluation and Proof. Upon receiving a message (EvalProve, sid, m) from Ui, verify that some pair (Ui, v) is recorded. If not, then ignore the request. Else, send (EvalProve, sid, Ui, m) to the adversary. Upon receiving (EvalProve, sid, m, &pi;) from the adversary, if value T(v, m) is undefined, verify that &pi; is unique, pick a random value y from {0, 1} <sup>&#8467;</sup>VRF and set T(v, m) = (y, {&pi;}). Else, if T(v, m) = (y, S), set T(v, m) = (y, S &cup; {&pi;}). In any case, output (Evaluated, sid, y, &pi;) to Ui.</li>
      <li>Malicious VRF Evaluation. Upon receiving a message (Eval, sid, v, m, &pi;) from S for some v, do the following. First, if (S, v) is recorded and T(v, m) is undefined, then choose a random value y from {0, 1} <sup>&#8467;</sup>VRF and set T(v, m) = (y, S) and output (Evaluated, sid, y) to S. The same is performed in case (Ui, v) is recorded and U<sup>i</sup> corrupted. Else, if T(v, m) = (y, S&prime; ) for some S &prime; =&#824; &empty;, union S to S &prime; and output (Evaluated, sid, y) to S, else ignore the request.</li>
      <li>Verification. Upon receiving a message (Verify, sid, m, y, &pi;, v&prime; ) from some party P, send (Verify, sid, m, y, &pi;, v&prime; ) to the adversary. Upon receiving (Verified, sid, m, y, &pi;, v&prime; ) from the adversary do:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If v &prime; = v for some (&middot;, v) and the entry T(v, m) equals (y, S) with &pi; &isin; S, then set f = 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if v &prime; = v for some recorded pair of the form (&middot;, v), but no entry T(v, m) of the form (y, {. . . , &pi;, . . .}) is recorded, then set f = 0.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, initialize the table T(v &prime; , &middot;) to empty, and set f = 0. Output (Verified, sid, m, y, &pi;, f) to P.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Fig. 2: Functionality FVRF.</p>

    <p class="text-gray-300">Remarks about &#981;<sup>f</sup> (&middot;). Observe that &#981;<sup>f</sup> (1) = f; in particular, the parameter f is the probability that a party holding all the stake will be selected to be a leader for given slot. On the other hand, &#981;<sup>f</sup> () is not linear, but slightly concave; see Figure <a href="#page-18-0">7.</a> To motivate the choice of the function &#981;<sup>f</sup> , we note that it satisfies the &quot;independent aggregation&quot; property:</p>

    <p class="text-gray-300">
<span class="math">$1 - \\phi\\left(\\sum_{i} \\alpha_{i}\\right) = \\prod_{i} (1 - \\phi(\\alpha_{i})). \\tag{2}</span>$</p>

    <p class="text-gray-300">In particular, when leadership is determined according to &#981;<sup>f</sup> , the probability of a stakeholder becoming a slot leader in a particular slot is independent of whether this stakeholder acts as a single party in the protocol, or splits its stake among several &quot;virtual&quot; parties. In particular, consider a party U with relative stake &alpha; who contrives to split its stake among two virtual subordinate parties with stakes &alpha;<sup>1</sup> and &alpha;<sup>2</sup> (so that &alpha;<sup>1</sup> + &alpha;<sup>2</sup> = &alpha;). Then the probability that one of these virtual parties is elected for a particular slot is 1 &minus; (1 &minus; &#981;(&alpha;1))(1 &minus; &#981;(&alpha;2)), as these events are independent. Property <a href="#page-9-1">(2)</a> guarantees that this is identical to &#981;(&alpha;). Thus this selection rule is invariant under arbitrary reapportionment of a party's stake among virtual parties.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 The Protocol in the FINIT-hybrid Model</h3>

    <p class="text-gray-300">We will construct our protocol for the static stake case in the FINIT-hybrid model, where the genesis stake distribution S<sup>0</sup> and the nonce &eta; (to be written in the genesis block B0) are determined by the ideal functionality FINIT defined in Figure <a href="#page-10-0">3.</a> Moreover, FINIT also incorporates the diffuse functionality from Section <a href="#page-3-0">2.1,</a> which is implicitly used by all parties to send messages and keep synchronized with a global clock. FINIT also takes stakeholders' public keys from them and packages them into the genesis block at the outset of the protocol. Note that  <span class="math">\\mathcal{F}_{INIT}</span>  halts if it is not possible to create a genesis block; all security guarantees we provide later in the paper are conditioned on a successful creation of the genesis block.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Functionality <span class="math">\\mathcal{F}_{INIT}</span></h4>

    <p class="text-gray-300"> <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  incorporates the delayed diffuse functionality from Section 2.1 and is parameterized by the number of initial stakeholders n and their respective stakes  <span class="math">s_1, \\ldots, s_n</span> .  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  interacts with stakeholders  <span class="math">U_1, \\ldots, U_n</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the first round, upon a request from some stakeholder  <span class="math">U_i</span>  of the form  <span class="math">(\\text{ver-keys}, sid, U_i, v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}})</span> , it stores the verification keys tuple  <span class="math">(U_i, v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}})</span>  and acknowledges its receipt. If any of the n stakeholders does not send a request of this form to  <span class="math">\\mathcal{F}_{\\text{INIT}}</span> , or if two different stakeholders provide two identical keys, it halts. Otherwise, it samples and stores a random value  <span class="math">\\eta \\overset{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$  and constructs a genesis block  <span class="math">(\\mathbb{S}_0,\\eta)</span> , where  <span class="math">\\mathbb{S}_0 = \\left((U_1, v_1^{\\text{vrf}}, v_1^{\\text{kes}}, v_1^{\\text{dsig}}, s_1), \\ldots, (U_n, v_n^{\\text{vrf}}, v_n^{\\text{kes}}, v_n^{\\text{dsig}}, s_n)\\right)</span> .</li>
      <li>In later rounds, upon a request of the form (genblock_req, sid,  <span class="math">U_i</span> ) from some stakeholder  <span class="math">U_i</span> ,  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  sends (genblock, sid,  <span class="math">\\mathbb{S}_0</span> ,  <span class="math">\\eta</span> ) to  <span class="math">U_i</span> .</li>
    </ul>

    <p class="text-gray-300">Fig. 3: Functionality  <span class="math">\\mathcal{F}_{INIT}</span> .</p>

    <p class="text-gray-300">Blocks are signed with a forward secure signature scheme modelled by  <span class="math">\\mathcal{F}_{KES}</span> , while transactions are signed with a regular EUF-CMA secure digital signature modelled by  <span class="math">\\mathcal{F}_{DSIG}</span>  (described in Appendix A).</p>

    <p class="text-gray-300">Notice that the implicit leader assignment process described in  <span class="math">\\pi_{SPoS}</span>  calls for a party  <span class="math">U_i</span>  to act as a leader for a slot sl when  <span class="math">y &lt; T_i</span> ; this is an event that occurs with probability (exponentially close to)  <span class="math">\\phi_f(\\alpha_i)</span>  as y is uniform according to the functionality  <span class="math">\\mathcal{F}_{VRF}</span> .</p>

    <p class="text-gray-300">We are interested in applications where transactions are inserted in the ledger. For simplicity, transactions are assumed to be simple assertions of the form &quot;Stakeholder  <span class="math">U_i</span>  transfers stake s to Stakeholder  <span class="math">(U_j, v_j^{\\text{vrf}}, v_j^{\\text{kes}}, v_j^{\\text{dsig}})</span> &quot; (In an implementation the different public-keys can be hashed into a single value). Protocol  <span class="math">\\pi_{\\text{SPoS}}</span>  ensures that the environment learns every stakeholder's public keys and provides an interface for the environment to request signatures on arbitrary transactions. A transaction will consist of a transaction template tx of this format accompanied by a signature of tx by stakeholder  <span class="math">U_i</span> . We define a valid transaction as follows:</p>

    <p class="text-gray-300"><strong>Definition 4 (Valid Transaction).</strong> A pair  <span class="math">(tx, \\sigma)</span>  is considered a valid transaction by a verifier  <span class="math">\\forall</span>  if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The transaction template tx is of the format &quot;Stakeholder  <span class="math">U_i</span>  transfers stake s to Stakeholder  <span class="math">(U_j, v_j^{\\text{vrf}}, v_j^{\\text{kes}}, v_j^{\\text{dsig}})</span> &quot; where  <span class="math">U_i</span>  and  <span class="math">U_j</span>  are stakeholders identified by tuples  <span class="math">(U_i, v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}})</span>  and  <span class="math">(U_j, v_j^{\\text{vrf}}, v_j^{\\text{kes}}, v_j^{\\text{dsig}})</span>  contained in the current stake distribution  <span class="math">\\mathbb S</span>  and  <span class="math">x \\in \\mathbb Z</span> .</li>
      <li>The verifier V obtains (Verified, m, 1) as answer upon sending (Verify, tx,  <span class="math">\\sigma</span> ,  <span class="math">v_i^{\\text{dsig}}</span> ) to  <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> .</li>
      <li>Stakeholder  <span class="math">U_i</span>  possesses x coins at the moment the transaction is issued (or registered in the blockchain) according to the view of the verifier V.</li>
    </ul>

    <p class="text-gray-300">Given Definitions 2 and 4, we define a valid chain as a blockchain (according to Definition 2) where all transactions contained in every block are valid (according to Definition 4). The stakeholders  <span class="math">U_1, \\ldots, U_n</span>  interact among themselves and with  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  through Protocol  <span class="math">\\pi_{\\mathsf{SPoS}}</span>  described in Figure 4. The protocol relies on a  <span class="math">\\mathsf{maxvalid}_S(\\mathcal{C}, \\mathbb{C})</span>  function that chooses a chain given the current chain  <span class="math">\\mathcal{C}</span>  and a set of valid chains  <span class="math">\\mathbb{C}</span>  that are available in the network. In the static stake case we analyze the simple &quot;longest chain&quot; rule.</p>

    <p class="text-gray-300">Function  <span class="math">\\mathsf{maxvalid}(\\mathcal{C}, \\mathbb{C})</span> : Returns the longest chain from  <span class="math">\\mathbb{C} \\cup \\{\\mathcal{C}\\}</span> . Ties are broken in favor of  <span class="math">\\mathcal{C}</span> , if it has maximum length, or arbitrarily otherwise.</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Protocol <span class="math">\\pi_{SPoS}</span></h4>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\text{SPoS}}</span>  is run by stakeholders  <span class="math">U_1, \\ldots, U_n</span>  interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{\\text{INIT}}, \\mathcal{F}_{\\text{VRF}}, \\mathcal{F}_{\\text{KES}}, \\mathcal{F}_{\\text{DSIG}}</span> , H over a sequence of slots  <span class="math">S = \\{1, \\ldots, R\\}</span> . Define  <span class="math">T_i \\triangleq 2^{\\ell_{\\text{VRF}}} \\phi_f(\\alpha_i)</span>  as the threshold for a stakeholder  <span class="math">U_i</span> , where  <span class="math">\\alpha_i</span>  is the relative stake of  <span class="math">U_i</span> ,  <span class="math">\\ell_{\\text{VRF}}</span>  denotes the output length of  <span class="math">\\mathcal{F}_{\\text{VRF}}, f</span>  is the active slots coefficient and  <span class="math">\\phi_f</span>  is the mapping from equation (1). Then  <span class="math">\\pi_{\\text{SPoS}}</span>  proceeds as follows for each stakeholder  <span class="math">U_i</span> :</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">1. Initialization.</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">U_i</span>  sends (KeyGen,  <span class="math">sid, U_i</span> ) to  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> ,  <span class="math">\\mathcal{F}_{\\text{KES}}</span>  and  <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> ; receiving (VerificationKey,  <span class="math">sid, v_i</span> ) for  <span class="math">v_i \\in \\{v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}}\\}</span> , respectively. Then, in case it is the first round, it sends (ver_keys,  <span class="math">sid, U_i, v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}}</span> ) to  <span class="math">\\mathcal{F}_{\\text{INIT}}</span>  to claim stake from the genesis block. In any case, it terminates the round by returning  <span class="math">(U_i, v_i^{\\text{vrf}}, v_i^{\\text{kes}}, v_i^{\\text{dsig}})</span>  to  <span class="math">\\mathcal{Z}</span> .</li>
      <li>(b) In the next round,  <span class="math">U_i</span>  sends (genblock_req, sid,  <span class="math">U_i</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span> , receiving (genblock, sid,  <span class="math">\\mathbb{S}_0</span> ,  <span class="math">\\eta</span> ). If  <span class="math">U_i</span>  is initialized in the first round, it sets the local blockchain to  <span class="math">\\mathcal{C} = B_0 = (\\mathbb{S}_0, \\eta)</span>  otherwise it receives the local blockchain  <span class="math">\\mathcal{C}</span>  from the environment.</li>
    </ul>

    <p class="text-gray-300">After initialization, for every slot  <span class="math">\\mathsf{sl}_{\\mathsf{now}} \\in S</span> , every online stakeholder  <span class="math">U_i</span>  performs the following steps:</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">2. Chain Update.</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">U_i</span>  collects all valid chains received via diffusion into a set  <span class="math">\\mathbb{C}</span> , verifying that for every chain  <span class="math">\\mathcal{C}&#x27; \\in \\mathbb{C}</span> , every block  <span class="math">B = (st, d, \\mathsf{sl}, crt, \\sigma) \\in \\mathcal{C}&#x27;</span>  with  <span class="math">crt = (U_s, y, \\pi)</span>  satisfies:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i)  <span class="math">sl \\leq sl_{now}</span>  and  <span class="math">y &lt; T_s</span> ,</li>
      <li>(ii)  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  answers (Verify,  <span class="math">sid, \\eta \\parallel \\mathsf{sl}, y, \\pi, v_s^{\\mathsf{vrf}}</span> ) by (Verified,  <span class="math">sid, \\eta \\parallel \\mathsf{sl}, y, \\pi, 1</span> );</li>
      <li>(iii)  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  answers (Verify, sid,  <span class="math">(st, d, \\mathsf{sl}, crt)</span> ,  <span class="math">\\mathsf{sl}</span> ,  <span class="math">\\sigma</span> ,  <span class="math">v_s^{\\mathsf{kes}}</span> ) by (Verified, sid,  <span class="math">(st, d, \\mathsf{sl}, crt)</span> ,  <span class="math">\\mathsf{sl}</span> , 1).</li>
    </ul></li>
      <li>(b)  <span class="math">U_i</span>  computes  <span class="math">\\mathcal{C} := \\mathsf{maxvalid}(\\mathcal{C}, \\mathbb{C})</span>  and sets  <span class="math">\\mathcal{C}</span>  as the new local chain.</li>
      <li>3. Chain Extension.  <span class="math">U_i</span>  receives from the environment the transaction data  <span class="math">d^* \\in \\{0,1\\}^*</span>  to be inserted into the blockchain, and performs the following steps:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">U_i</span>  sends (EvalProve, sid,  <span class="math">\\eta \\parallel \\mathsf{sl}_{\\mathsf{now}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> , receiving (Evaluated, sid, y,  <span class="math">\\pi</span> ).</li>
      <li>(b)  <span class="math">U_i</span>  checks whether  <span class="math">y &lt; T_i</span> . If yes, it chooses a maximal sequence d' of transactions in  <span class="math">d^*</span>  such that adding a block with d' to  <span class="math">\\mathcal C</span>  results in a valid chain, and attempts to include d' as follows: It generates a new block  <span class="math">B = (st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt, \\sigma)</span>  where  <span class="math">st = \\mathsf{H}(\\mathsf{head}(\\mathcal C)), crt = (U_i, y, \\pi)</span>  and  <span class="math">\\sigma</span>  is a signature obtained by sending (USign, sid,  <span class="math">U_i</span> ,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt), \\mathsf{sl}_{\\mathsf{now}})</span>  to  <span class="math">\\mathcal F_{\\mathsf{KES}}</span>  and receiving (Signature, sid,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt), \\mathsf{sl}_{\\mathsf{now}}, \\sigma)</span> .  <span class="math">U_i</span>  computes  <span class="math">\\mathcal C = \\mathcal C \\parallel B</span> , sets it as the new local chain and diffuses  <span class="math">\\mathcal C</span> .</li>
    </ul></li>
      <li>4. <strong>Signing Transactions.</strong> Upon receiving (sign_tx, sid', tx) from the environment,  <span class="math">U_i</span>  sends (Sign,  <span class="math">sid, U_i, tx</span> ) to  <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> , receiving (Signature,  <span class="math">sid, tx, \\sigma</span> ). Then,  <span class="math">U_i</span>  sends (signed_tx,  <span class="math">sid&#x27;, tx, \\sigma</span> ) back to the environment.</li>
    </ul>

    <p class="text-gray-300">Fig. 4: Protocol  <span class="math">\\pi_{SPoS}</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Combinatorial Analysis of the Static Stake Protocol</h2>

    <p class="text-gray-300">Throughout this section, we focus solely on analysis of the protocol  <span class="math">\\pi_{SPoS}</span>  using the idealized functionalities  <span class="math">\\mathcal{F}_{VRF}</span>  and  <span class="math">\\mathcal{F}_{KES}</span>  for VRFs and digital signatures, respectively&mdash;we refer to it as the hybrid experiment. As argued in Theorems 1 and 2, any property of the protocol that we prove true in the hybrid experiment (such as achieving common prefix, chain growth and chain quality) will remain true (with overwhelming probability) in the setting where  <span class="math">\\mathcal{F}_{VRF}</span>  and  <span class="math">\\mathcal{F}_{KES}</span>  are replaced by their real-world implementations&mdash;in the so-called real experiment.</p>

    <p class="text-gray-300">The hybrid experiment yields a stochastic process for assigning slots to parties which we now abstract and study in detail. Our analysis of the resulting blockchain dynamics proceeds roughly as follows: We begin by generalizing the framework of &quot;forks&quot; [KRDO17] to our semi-synchronous setting&mdash;forks are a natural bookkeeping tool that reflect the valid chains adopted (or observed) by honest players during an execution of the protocol. We then establish a simulation rule that associates with each execution of the semi-synchronous protocol an execution of a related &quot;virtual&quot; synchronous protocol. Motivated by the special case of a <em>static</em> adversary&mdash;which simply corrupts a family of parties at the outset of the protocol&mdash;we identify a natural &quot;generic&quot; probability distribution for this simulation theorem which we prove controls the behavior of adaptive adversaries by stochastic domination. Finally, we prove that this simulation amplifies the effective power of the adversary in a controlled fashion and, furthermore, permits forks of the semi-synchronous protocol to be projected to forks of the virtual protocol in a way that preserves their relevant combinatorial properties. This</p>

    <p class="text-gray-300">allows us to apply the density theorems and divergence result of [KRDO17,RMKQ17] to provide strong common prefix, chain growth, and chain quality (4.7) guarantees for the semi-synchronous protocol with respect to an adaptive adversary.</p>

    <p class="text-gray-300">We begin in Section 4.1 with a discussion of characteristic strings, semi-synchronous forks, and their relationship to executions of  <span class="math">\\pi_{SPoS}</span>  in the hybrid experiment. Section 4.3 then develops the combinatorial reduction from the semi-synchronous to the synchronous setting. The &quot;generic, dominant&quot; distribution on characteristic strings is then motivated and defined in Section 4.4, where the effect of the reduction on this distribution is also described. Section 4.7, as described above, establishes various guarantees on the resulting blockchain under the dominant distribution. The full power of adaptive adversaries is considered in Section 4.8. Finally, in preparation for applying the protocol in the dynamic stake setting, we formulate a &quot;resettable setting&quot; which further enlarges the power of the adversary by providing some control over the random nonce that seeds the protocol.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Chains, Forks and the Abstract Chain Properties</h3>

    <p class="text-gray-300">We begin by suitably generalizing the framework of characteristic strings, forks, and divergence developed in [KRDO17] to our semi-synchronous setting.</p>

    <p class="text-gray-300">The leader assignment process given by protocol  <span class="math">\\pi_{\\text{SPoS}}</span>  in the hybrid experiment assigns leaders to slots with the following guarantees: (i.) a party with relative stake  <span class="math">\\alpha</span>  becomes a slot leader for a given slot with probability  <span class="math">\\phi_f(\\alpha) \\triangleq 1 - (1 - f)^{\\alpha}</span> ; (ii.) the event of becoming a slot leader is independent for each party and for each slot (both points follow from the construction of  <span class="math">\\pi_{\\text{SPoS}}</span>  and the independent random sampling of every new output in  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> ). Clearly, these dynamics may lead to slots with multiple slot leaders and, likewise, slots with no slot leader. For a given (adaptive) adversary  <span class="math">\\mathcal{A}</span>  and environment  <span class="math">\\mathcal{Z}</span> , we reflect the outcome of this process with a <em>characteristic string</em>, as described below.</p>

    <p class="text-gray-300"><strong>Definition 5 (Execution).</strong> For an (adaptive) adversary  <span class="math">\\mathcal{A}</span>  and an environment  <span class="math">\\mathcal{Z}</span> , an execution  <span class="math">\\mathcal{E}</span>  of  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  is a transcript including the inputs provided by  <span class="math">\\mathcal{Z}</span> , the random coins of the parties, the random coins of the adversary, the responses of the ideal functionalities and the random oracle. This data determines the entire dynamics of the protocol: messages sent and delivered, the internal states of the parties at each step, the set of corrupt parties at each step, etc.</p>

    <p class="text-gray-300"><strong>Definition 6 (Characteristic string).</strong> Let  <span class="math">R \\in \\mathbb{N}</span> , let  <span class="math">S = \\{1, \\ldots, R\\}</span>  be a sequence of slots of length R and let  <span class="math">\\mathcal{E}</span>  be an execution (with adversary  <span class="math">\\mathcal{A}</span>  and environment  <span class="math">\\mathcal{Z}</span> ) over S. For a slot  <span class="math">j \\in S</span> , let  <span class="math">\\mathcal{P}(j)</span>  denote the set of parties assigned to be slot leaders for slot j by the protocol  <span class="math">\\pi_{SPoS}</span>  (specifically, those parties  <span class="math">U_i</span>  for which  <span class="math">y &lt; 2^{\\ell_{VRF}} \\phi_f(\\alpha_i)</span> , where  <span class="math">(y, \\pi) \\leftarrow \\mathsf{Prove}_{VRF.sk_i}(\\eta \\parallel j)</span> ). We define the characteristic string  <span class="math">w \\in \\{0, 1, \\bot\\}^R</span>  of S to be the random variable so that</p>

    <p class="text-gray-300"><span class="math">$w_{j} = \\begin{cases} \\bot &amp; \\text{if } \\mathcal{P}(j) = \\emptyset, \\\\ 0 &amp; \\text{if } |\\mathcal{P}(j)| = 1 \\text{ and the assigned party is honest,} \\\\ 1 &amp; \\text{if } |\\mathcal{P}(j)| &gt; 1 \\text{ or a party in } \\mathcal{P}(j) \\text{ is adversarial.} \\end{cases}</span>$
(3)</p>

    <p class="text-gray-300">For such a characteristic string  <span class="math">w \\in \\{0,1,\\perp\\}^*</span>  we say that the index j is uniquely honest if  <span class="math">w_j = 0</span> , tainted if  <span class="math">w_j = 1</span> , and empty if  <span class="math">w_j = \\perp</span> . We say that an index is active if  <span class="math">w_j \\in \\{0,1\\}</span> . Note that an index is &quot;tainted&quot; according to this terminology in cases where multiple honest parties (and no adversarial party) have been assigned to it.</p>

    <p class="text-gray-300">We denote by  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f</span>  the distribution of the random variable  <span class="math">w=w_1...w_R</span>  in the hybrid experiment with the active slots coefficient f, adversary  <span class="math">\\mathcal{A}</span> , and environment  <span class="math">\\mathcal{Z}</span> . For a fixed execution  <span class="math">\\mathcal{E}</span> , we denote by  <span class="math">w_{\\mathcal{E}}</span>  the (fixed) characteristic string resulting from that execution.</p>

    <p class="text-gray-300">We emphasize that in an execution of  <span class="math">\\pi_{SPoS}</span> , the resulting characteristic string is determined by both the nonce (and the effective leader selection process), the adaptive adversary  <span class="math">\\mathcal{A}</span> , and the environment  <span class="math">\\mathcal{Z}</span>  (which, in particular, determines the stake distribution).</p>

    <p class="text-gray-300">From executions to forks. The notion of a &quot;fork&quot;, defined in [KRDO17], is a bookkeeping tool that reflects the chains observed by honest players during an idealized execution of a blockchain protocol. We now adapt the synchronous notion of [KRDO17] to reflect the effect of message delays.</p>

    <p class="text-gray-300">An execution of Protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  induces a collection of blocks delivered to the participants. As we now focus merely on the structural properties of the resulting blockchain, for each delivered block we now retain only two features: the <em>slot</em> associated with the block and the <em>previous block</em> to which it is &quot;attached&quot; by the idealized digital signature  <span class="math">\\sigma_j</span> . (Of course, we only consider blocks with legal structure that meet the verification criteria of  <span class="math">\\pi_{\\mathrm{SPoS}}</span> .) Note that multiple blocks may be associated with a particular slot, either because multiple parties are assigned to the slot or an adversarial party is assigned to a slot (who may choose to deviate from the protocol by issuing multiple blocks). In any case, these blocks induce a natural directed tree by treating the blocks as vertices and introducing a directed edge between each pair of blocks (b,b') for which b' identifies b as the previous block. In the  <span class="math">\\Delta</span> -semisynchronous setting, the maxvalid rule enforces a further critical property on this tree: the depth of any block broadcast by an honest player in some slot t must exceed the depths of any honestly-generated blocks from slots up to  <span class="math">t-1-\\Delta</span> . (This follows because such previously broadcast blocks would have been available to the honest player, who always builds on a chain of maximal length.) We call a directed tree with these structural properties a  <span class="math">\\Delta</span> -fork, and define them precisely below.</p>

    <p class="text-gray-300">We may thus associate with any execution of  <span class="math">\\pi_{SPoS}</span>  a fork. While this fork disregards many of the details of the execution, it retains enough structure to reason about the chain properties discussed in Section 2. Thus a significant portion of our analysis relies on controlling the structure of the forks that can be induced in this way for a given characteristic string (which determines which slots have been assigned to uniquely honest parties). In more detail, we define &quot;abstract&quot; analogues of the chain properties CP, CG, and  <span class="math">\\exists</span> CQ in the language of forks and bound the probability that there exists a fork for which these properties are violated over a characteristic drawn from a suitable distribution. The correspondence between forks and executions permits us to lift this argument to reason about the blockchain protocol.</p>

    <p class="text-gray-300">We begin with the formal definition of  <span class="math">\\Delta</span> -fork.</p>

    <p class="text-gray-300"><strong>Definition 7</strong> ( <span class="math">\\Delta</span> -fork). Let  <span class="math">w \\in \\{0, 1, \\bot\\}^k</span>  and  <span class="math">\\Delta</span>  be a non-negative integer. Let  <span class="math">A = \\{i \\mid w_i \\neq \\bot\\}</span>  denote the set of active indices, and let  <span class="math">H = \\{i \\mid w_i = 0\\}</span>  denote the set of uniquely honest indices. A  <span class="math">\\Delta</span> -fork for the string w is a directed, rooted tree F = (V, E) with a labeling  <span class="math">\\ell : V \\to \\{0\\} \\cup A</span>  so that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) the root  <span class="math">r \\in V</span>  is given the label  <span class="math">\\ell(r) = 0</span> ;</li>
      <li>(ii) each edge of F is directed away from the root;</li>
      <li>(iii) the labels along any directed path are strictly increasing;</li>
      <li>(iv) each uniquely honest index  <span class="math">i \\in H</span>  is the label of exactly one vertex of F;</li>
      <li>(v) the function  <span class="math">\\mathbf{d}: H \\to \\{1, \\dots, k\\}</span> , defined so that  <span class="math">\\mathbf{d}(i)</span>  is the depth in F of the unique vertex v for which  <span class="math">\\ell(v) = i</span> , satisfies the following  <span class="math">\\Delta</span> -monotonicity property: if  <span class="math">i, j \\in H</span>  and  <span class="math">i + \\Delta &lt; j</span> , then  <span class="math">\\mathbf{d}(i) &lt; \\mathbf{d}(j)</span> .</li>
    </ul>

    <p class="text-gray-300">As a matter of notation, we write  <span class="math">F \\vdash_{\\Delta} w</span>  to indicate that F is a  <span class="math">\\Delta</span> -fork for the string w. We typically refer to a  <span class="math">\\Delta</span> -fork as simply a &quot;fork&quot;.</p>

    <p class="text-gray-300">See Figures 5 and 6 for examples of forks. Also note that our notion of a fork deliberately models the behavior of honest parties that may not necessarily have full information about previous blocks thanks to the delivery guarantees provided by the DDiffuse functionality. Additionally, the modeling places special emphasis on uniquely honest slots, in which there is a unique honest leader; specifically, observe that honest leaders of &quot;crowded&quot; slots (with multiple leaders) are not afforded any special properties by the definition. Nonetheless, it remains true that any execution of the hybrid experiment leads to a fork as defined above, a relationship that we make fully formal in Appendix F. Given this relationship, we can later focus on investigating the properties of forks for characteristic strings drawn according to the distribution  <span class="math">\\mathcal{D}_{Z,\\mathcal{A}}^f</span> . Roughly speaking, if we prove that a characteristic string sampled from  <span class="math">\\mathcal{D}_{Z,\\mathcal{A}}^f</span> , with overwhelming probability, does not allow for any &quot;harmful&quot; forks, then this also implies that an execution results in a &quot;harmless&quot; outcome with overwhelming probability.</p>

    <p class="text-gray-300">Now we continue to adapt the framework from [KRDO17] to the semi-synchronous setting.</p>

    <p class="text-gray-300"><strong>Definition 8 (Tines, length, and viability).</strong> A path in a fork F originating at the root is called a tine. For a tine t we let length(t) denote its length, equal to the number of edges on the path.</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5: A (synchronous) fork F for the string w=010100110. Vertices appear with their labels and vertices belonging to (uniquely) honest slots are highlighted with double borders. Note that the depths of the (honest) vertices associated with the honest indices of w are strictly increasing. Two tines are distinguished in the figure: one, labeled  <span class="math">\\hat{t}</span> , terminates at the vertex labeled 9 and is the longest tine in the fork; a second tine t terminates at the vertex labeled 3. The divergence of t and  <span class="math">\\hat{t}</span>  is  <span class="math">\\operatorname{div}(t,\\hat{t})=2</span> .</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6: A 3-fork F' for the characteristic string  <span class="math">w = 0 \\pm 1 \\pm 01001 \\pm 10</span> . Note that F' is not a 2-fork since  <span class="math">\\mathbf{d}(8) = 2 \\ge 2 = \\mathbf{d}(5)</span> . Indices  <span class="math">\\{1, 5, 7, 8, 14\\}</span>  are uniquely honest,  <span class="math">\\{3, 6, 12, 13\\}</span>  are tainted, and  <span class="math">\\{2, 4, 9, 10, 11\\}</span>  are empty. The index 8 is 4-right-isolated, but not 5-right-isolated.</p>

    <p class="text-gray-300">For a vertex v, we call the length of the tine terminating at v the depth of v. For convenience, we overload the notation  <span class="math">\\ell(\\cdot)</span>  so that it applies to tines by defining  <span class="math">\\ell(t) \\triangleq \\ell(v)</span> , where v is the terminal vertex on the tine t. We say that a tine t is  <span class="math">\\Delta</span> -viable if</p>

    <p class="text-gray-300"><span class="math">$length(t) \\ge \\max_{h+\\Delta &lt; \\ell(t)} \\mathbf{d}(h),</span>$</p>

    <p class="text-gray-300">this maximum extended over all uniquely honest indices h (appearing more than  <span class="math">\\Delta</span>  slots before  <span class="math">\\ell(t)</span> ). Note that any tine terminating in a uniquely honest vertex is necessarily viable by the  <span class="math">\\Delta</span> -monotonicity property.</p>

    <p class="text-gray-300">The notion of viability, defined above, demands that the length of a tine t be no less than that of all tines broadcast by uniquely honest slot leaders prior to slot  <span class="math">\\ell(t) - \\Delta</span> . Observe that such a tine could, in principle, be selected according to the maxvalid() rule by an honest player online at time  <span class="math">\\ell(t)</span> : in particular, if all blocks broadcast by honest parties in slots  <span class="math">\\ell(t) - \\Delta, \\ldots, \\ell(t)</span>  are maximally delayed, the tine can favorably compete with all other tines that the adversary is obligated to deliver by slot  <span class="math">\\ell(t)</span> .</p>

    <p class="text-gray-300">Before articulating the abstract chain properties below we set down some further notation. Given a tine t (of a fork  <span class="math">F \\vdash w</span> ) and a natural number k, we let  <span class="math">t^{\\lfloor k}</span>  denote the result of removing the last k vertices from t. If  <span class="math">k \\geq \\operatorname{length}(t)</span> , we define  <span class="math">t^{\\lfloor k}</span>  to be the length 0 path containing only the root. Given a tine t and a sequence of slots S such that  <span class="math">\\ell(t) \\geq \\max S</span> , we refer to a &quot;portion of t spanning S&quot; as the subgraph t' of t induced from all vertices with labels in S. We use the notation t(S) to denote this subgraph. We continue to use interval notation for sequences of slots: that is,  <span class="math">[\\mathsf{sl}_1:\\mathsf{sl}_2] = \\{\\mathsf{sl}_1,\\ldots,\\mathsf{sl}_2\\}</span>  and parentheses in place of brackets indicate that the endpoint is left out. Thus  <span class="math">[\\mathsf{sl}_1:\\mathsf{sl}_2] = \\{\\mathsf{sl}_1,\\ldots,\\mathsf{sl}_2-1\\}</span> . As a final matter of notation, we often elide the parentheses in expressions such as  <span class="math">t([\\mathsf{sl}_1,\\mathsf{sl}_2])</span> , simply writing  <span class="math">t[\\mathsf{sl}_1,\\mathsf{sl}_2]</span> . We will refer to a &quot;portion of t spanning s slots&quot; when the particular sequence of slots is not specified.</p>

    <p class="text-gray-300">The abstract chain properties. Let  <span class="math">w \\in \\{\\bot, 0, 1\\}^n</span>  be a characteristic string. In the context of a particular choice of  <span class="math">\\Delta</span> , we define the following abstract analogues of the general protocol properties defined in Section 2. These abstract versions of the properties can be formulated merely in terms of a characteristic string rather than the full details of an execution of a protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Prefix (cp); with parameter  <span class="math">k \\in \\mathbb{N}</span> . A characteristic string w possesses cp with parameter k (written k-cp) if, for every fork  <span class="math">F \\vdash_{\\Delta} w</span>  and every pair of viable times  <span class="math">t_1</span>  and  <span class="math">t_2</span>  of F for which  <span class="math">\\ell(t_1) \\leq \\ell(t_2)</span> , the time  <span class="math">t_1^{\\lceil k}</span>  is a prefix of  <span class="math">t_2</span> . (Equivalently, length <span class="math">(t_1)</span> -length <span class="math">(t_1 \\cap t_2) \\leq k</span> , where  <span class="math">t_1 \\cap t_2</span>  denotes the common prefix of the two times.)</li>
      <li>Honest-Bounded Chain Growth (hcg); with parameters  <span class="math">\\tau \\in (0,1]</span>  and  <span class="math">s \\in \\mathbb{N}</span> . A characteristic string w possesses hcg with parameters  <span class="math">\\tau</span>  and s (written  <span class="math">(\\tau,s)</span> -hcg) if, for every fork  <span class="math">F \\vdash_{\\Delta} w</span> , every viable tine t of F, and every honest vertex v on t for which  <span class="math">\\ell(v) + s \\leq \\ell(t)</span> , the path  <span class="math">t(\\ell(v), \\ell(t)]</span>  contains at least  <span class="math">\\tau s</span>  vertices.</li>
      <li>Existential Chain Quality ( <span class="math">\\exists cq</span> ); with parameter  <span class="math">s \\in \\mathbb{N}</span> . A characteristic string w possesses  <span class="math">\\exists cq</span>  with parameter s (written s- <span class="math">\\exists cq</span> ) if, for every fork  <span class="math">F \\vdash_{\\Delta} w</span>  and every viable tine t of F, any portion of t spanning s slots contains at least one honest vertex.</li>
    </ul>

    <p class="text-gray-300">As with the protocol properties, it is convenient to separately articulate a chain growth property, which can be directly inferred from  <span class="math">\\exists cq</span>  and hcg.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Chain Growth (cg); with parameters  <span class="math">\\tau \\in (0,1]</span>  and  <span class="math">s \\in \\mathbb{N}</span> . A characteristic string w possesses  <span class="math">(\\tau, s)</span> -cg if, for every fork  <span class="math">F \\vdash_{\\Delta} w</span>  and every viable tine t of F, any portion of t spanning s slots contains at least  <span class="math">\\tau s</span>  vertices.</li>
    </ul>

    <p class="text-gray-300">Observe that these properties depend on a choice of  <span class="math">\\Delta</span>  which is not made explicit in the notation; in our usage, the parameter  <span class="math">\\Delta</span>  will always be clear from context.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Abstract Common Prefix Formulated as Divergence</h3>

    <p class="text-gray-300">The major analytic challenge, both in the synchronous case and in our semisynchronous setting, is to control the possibility of a <em>common prefix</em> violation, which occurs when the adversary can manipulate the protocol to produce a fork with two viable tines with a relatively short common prefix. We define this precisely by introducing the notion of divergence.</p>

    <p class="text-gray-300"><strong>Definition 9 (Divergence).</strong> Let F be a  <span class="math">\\Delta</span> -fork for a string  <span class="math">w \\in \\{0, 1, \\bot\\}^*</span> . For two  <span class="math">\\Delta</span> -viable times t and t' of F, we define the notation t/t' by the rule</p>

    <p class="text-gray-300"><span class="math">$t/t&#x27; = \\operatorname{length}(t) - \\operatorname{length}(t \\cap t&#x27;)</span>$</p>

    <p class="text-gray-300">where  <span class="math">t \\cap t&#x27;</span>  denotes the common prefix of t and t'. Then define the divergence of two viable tines  <span class="math">t_1</span>  and  <span class="math">t_2</span>  to be the quantity</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}(t_1, t_2) = \\begin{cases} t_1/t_2 &amp; \\text{if } \\ell(t_1) &lt; \\ell(t_2), \\\\ t_2/t_1 &amp; \\text{if } \\ell(t_2) &lt; \\ell(t_1), \\\\ \\max(t_1/t_2, t_2/t_1) &amp; \\text{if } \\ell(t_1) = \\ell(t_2). \\end{cases}</span>$</p>

    <p class="text-gray-300">We extend this notation to the fork F by maximizing over viable tines:  <span class="math">\\operatorname{div}_{\\Delta}(F) \\triangleq \\max_{t_1,t_2} \\operatorname{div}(t_1,t_2)</span> , taken over all pairs of  <span class="math">\\Delta</span> -viable tines of F. Finally, we define the  <span class="math">\\Delta</span> -divergence of a characteristic string w to be the maximum over all  <span class="math">\\Delta</span> -forks:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}_{\\Delta}(w) \\triangleq \\max_{F \\vdash_{\\Delta} w} \\operatorname{div}_{\\Delta}(F).</span>$</p>

    <p class="text-gray-300">Our primary goal in this section is to prove that, with high probability, the characteristic strings induced by protocol  <span class="math">\\pi_{SPoS}</span>  have small divergence and hence provide strong guarantees on common prefix.</p>

    <p class="text-gray-300">The Synchronous Case. The original development of <a href="#page-31-2">[KRDO17]</a> assumed a strictly synchronous environment. Their definitions of characteristic string, fork, and divergence correspond to the case &#8710; = 0, where characteristic strings are elements of {0, 1} &lowast; . As this setting will play an important role in our analysis&mdash;fulfilling the role of the &quot;virtual protocol&quot; described at the beginning of this section&mdash;we set down some further terminology for this synchronous case and establish a relevant combinatorial statement based on a result in <a href="#page-31-2">[KRDO17]</a> that we will need for our analysis.</p>

    <p class="text-gray-300">Definition 10 (Synchronous characteristic strings and forks). A synchronous characteristic string is an element of {0, 1} &lowast; . A synchronous fork F for a (synchronous) characteristic string w is a 0-fork F &#8866;<sup>0</sup> w.</p>

    <p class="text-gray-300">An immediate conclusion of the results obtained in <a href="#page-31-2">[KRDO17,</a><a href="#page-32-8">RMKQ17]</a> is the following bound on the probability that a synchronous characteristic string with independent identically distributed (i.i.d.) symbols has large divergence.</p>

    <p class="text-gray-300">Theorem 3. Let &#8467;, k &isin; N and &#1013; &isin; (0, 1). Let w = w1, . . . , w<sup>&#8467;</sup> &isin; {0, 1} &#8467; be a sequence of i.i.d. random variables for which Pr[w<sup>i</sup> = 1] = (1 &minus; &#1013;)/2. Then Pr[div0(w) &ge; k] &le; exp(ln &#8467; &minus; &Omega;(k)).</p>

    <p class="text-gray-300">Note that the &Omega;() notation hides a constant that depends on &#1013;.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 The Semisynchronous to Synchronous Reduction</h3>

    <p class="text-gray-300">We will make use of the following mapping, carrying characteristic strings to synchronous characteristic strings.</p>

    <p class="text-gray-300">Definition 11 (Reduction of characteristic strings). For &#8710; &isin; N, we define the function &rho;<sup>&#8710;</sup> : {0, 1, &perp;}<sup>&lowast;</sup> &rarr; {0, 1} &lowast; inductively as follows: &rho;&#8710;(&epsilon;) = &epsilon;, &rho;&#8710;(&perp; &#8741; w &prime; ) = &rho;&#8710;(w &prime; ),</p>

    <p class="text-gray-300"><span class="math">$\\rho_{\\Delta}(1 \\parallel w&#x27;) = 1 \\parallel \\rho_{\\Delta}(w&#x27;),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\rho_{\\Delta}(0 \\parallel w&#x27;) = \\begin{cases} 0 \\parallel \\rho_{\\Delta}(w&#x27;) &amp; \\text{if } w&#x27; \\in \\perp^{\\Delta} \\parallel \\{0, 1, \\perp\\}^*, \\\\ 1 \\parallel \\rho_{\\Delta}(w&#x27;) &amp; \\text{otherwise.} \\end{cases}</span>$
(4)</p>

    <p class="text-gray-300">We call &rho;<sup>&#8710;</sup> the reduction mapping for delay &#8710;.</p>

    <p class="text-gray-300">A critical feature of the map &rho;<sup>&#8710;</sup> is that it can be coupled with a natural reduction mapping on forks that monotonically preserves many structural features of interest including divergence, chain quality, and chain growth.</p>

    <p class="text-gray-300">Definition 12 (Reduction of forks). Let w &isin; {0, 1, &perp;}<sup>n</sup>, w &prime; = &rho;&#8710;(w), and let F &#8866; w. The fork F can be naturally interpreted as a fork of the reduced string w &prime; by suitably adjusting vertex labels. To make this correspondence precise, define F &prime; to be the labeled graph with the same set of vertices and directed edges as F; the labeling function &#8467; &prime; of F &prime; is given by the reduction mapping. Specifically, let A = {i | w<sup>i</sup> &#824;= &perp;} denote the set of active indices and note that |&rho;&#8710;(w)| = |A|; each non-&perp; symbol of w corresponds to a unique symbol in w &prime; . We let &pi; : A &rarr; {1, . . . , |A|} be the (bijective, increasing) function which records the position in w &prime; corresponding to a particular active index i in w. Then the labeling &#8467; &prime; (for F &prime; ) is given by the rule &#8467; &prime; (v) = &pi;(&#8467;(v)); of course, &#8467; &prime; (r) = 0 for the root vertex r. For convenience, we overload the notation &rho;<sup>&#8710;</sup> by defining &rho;&#8710;(F) = F &prime; .</p>

    <p class="text-gray-300">It remains to confirm that the labeled graph &rho;&#8710;(F) defined above is indeed a fork of &rho;&#8710;(w).</p>

    <p class="text-gray-300">Proposition 1. Let w &isin; {0, 1, &perp;}<sup>n</sup> and let F &#8866; w. Then &rho;&#8710;(F) &#8866;<sup>0</sup> &rho;&#8710;(w). The situation is summarized by the following diagram.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ccc} F &amp; \\vdash &amp; w \\\\ \\downarrow^{\\rho_{\\Delta}} &amp; &amp; \\downarrow^{\\rho_{\\Delta}} \\\\ F&#x27; &amp; \\vdash &amp; w&#x27; \\end{array}</span>$</p>

    <p class="text-gray-300">Proof. Adopting the same notation as above, define  <span class="math">w&#x27; = \\rho_{\\Delta}(w)</span>  and  <span class="math">F&#x27; = \\rho_{\\Delta}(F)</span> . To verify that  <span class="math">F&#x27; \\vdash_0 w&#x27; = \\rho_{\\Delta}(w)</span> , we recall the necessary properties from the definition. Properties (i) and (ii) of the Definition 7 are immediate; property (iii) follows because  <span class="math">\\pi</span>  is strictly increasing. For the remaining properties, we recall the definition of  <span class="math">\\rho_{\\Delta}</span> : According the rule,  <span class="math">w_i = 1 \\Rightarrow w&#x27;_{\\pi(i)} = 1</span>  from which property (iv) follows immediately. It remains to check property (v). When  <span class="math">w_i = 0</span>  the value  <span class="math">w&#x27;_{\\pi(i)}</span>  is determined by the  <span class="math">\\Delta</span>  following symbols of w: if  <span class="math">|w| \\geq i + \\Delta</span>  and  <span class="math">w_{i+1} = w_{i+2} = \\cdots = w_{i+\\Delta} = \\bot</span> , we say that i is  <span class="math">\\Delta</span> -right-isolated (cf. [GKL15], where a similar feature arises in a proof-of-work setting) and in this case  <span class="math">w&#x27;_{\\pi(i)} = 0</span> ; otherwise  <span class="math">w&#x27;_{\\pi(i)} = 1</span> . In particular, if  <span class="math">w&#x27;_{\\pi(i)} = 0</span>  we must have  <span class="math">w_i = 0</span>  and  <span class="math">w_{i+s} = \\bot</span>  for  <span class="math">1 \\leq s \\leq \\Delta</span> . As we wish to conclude that F' is a synchronous fork, it must satisfy the  <span class="math">\\Delta</span> -monotonicity property with  <span class="math">\\Delta = 0</span> , which is to say that  <span class="math">\\mathbf{d}(\\cdot)</span>  is strictly increasing on the set of uniquely honest indices (of w'). However, in light of the discussion above, any two uniquely honest indices of w' must correspond to uniquely honest indices of w separated by at least  <span class="math">\\Delta</span>  intervening  <span class="math">\\bot</span>  symbols; thus the  <span class="math">\\Delta</span> -monotonicity property of F ensures the 0-monotonicity property of F', as desired.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">w \\in \\{0, 1, \\bot\\}^*</span> . Then  <span class="math">\\operatorname{div}_{\\Delta}(w) \\le \\operatorname{div}_{0}(\\rho_{\\Delta}(w))</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">w \\in \\{0, 1, \\bot\\}^*</span>  be a characteristic string with  <span class="math">\\operatorname{div}_{\\Delta}(w) = k</span>  and let  <span class="math">F \\vdash_{\\Delta} w</span>  be a  <span class="math">\\Delta</span> -fork for which  <span class="math">\\operatorname{div}_{\\Delta}(F) = k</span> . Let  <span class="math">w&#x27; = \\rho_{\\Delta}(w)</span> ; to prove that  <span class="math">\\operatorname{div}_{0}(w&#x27;) \\ge k</span> , we establish that  <span class="math">\\operatorname{div}(F&#x27;) \\ge k</span>  where, as above,  <span class="math">F&#x27; = \\rho_{\\Delta}(F)</span> .</p>

    <p class="text-gray-300">In preparation for establishing that  <span class="math">\\operatorname{div}_0(F&#x27;) \\geq \\operatorname{div}(F) = k</span> , we note that a  <span class="math">\\Delta</span> -viable time t of  <span class="math">F \\vdash_{\\Delta} w</span>  is 0-viable when viewed as a time of  <span class="math">F&#x27; \\vdash w&#x27;</span> . In particular, let h' be a uniquely honest index of w' for which  <span class="math">h&#x27; &lt; \\ell&#x27;(t)</span>  and let h be the uniquely honest index of w for which  <span class="math">\\pi(h) = h&#x27;</span> . As  <span class="math">\\pi(h)</span>  is uniquely honest in w', h is  <span class="math">\\Delta</span> -right isolated in w, and we conclude that length <span class="math">(t) \\geq \\mathbf{d}(h)</span> , because t is  <span class="math">\\Delta</span> -viable. This t is hence 0-viable in F'.</p>

    <p class="text-gray-300">Finally, let  <span class="math">t_1</span>  and  <span class="math">t_2</span>  be two  <span class="math">\\Delta</span> -viable tines of F for which  <span class="math">\\ell(t_1) \\leq \\ell(t_2)</span>  and  <span class="math">t_1/t_2 = \\operatorname{div}_{\\Delta}(w)</span> . In light of the discussion above, these tines are 0-viable in F'. Note, additionally, that  <span class="math">\\pi(\\ell(t_1)) \\leq \\pi(\\ell(t_2))</span>  and&mdash;as the two forks have the same structure as graphs&mdash;the quantity  <span class="math">t_1/t_2</span>  takes the same value in the two forks. We conclude that  <span class="math">\\operatorname{div}_0(w&#x27;) \\geq t_1/t_2 = \\operatorname{div}_{\\Delta}(w)</span> , as desired.</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 The Dominant Characteristic Distribution</h3>

    <p class="text-gray-300">The high-probability results for our desired chain properties depend on detailed information about the distribution on characteristic strings  <span class="math">\\mathcal{D}^f_{\\mathcal{Z},\\mathcal{A}}</span>  determined by the adversary  <span class="math">\\mathcal{A}</span> , the environment  <span class="math">\\mathcal{Z}</span> , and the parameters f and R. In this section we define a distinguished distribution on characteristic strings which we will see &quot;dominates&quot; the distributions produced by any static adversary. Later in Section 4.8 we show that the same is true also for adaptive adversaries. We then study the effect of  <span class="math">\\rho_{\\Delta}</span>  on this distribution in preparation for studying common prefix, chain growth, and chain quality.</p>

    <p class="text-gray-300">Motivating the Dominant Distribution: Static Adversaries. To motivate the dominant distribution, consider the distribution induced by a <em>static</em> adversary who corrupts&mdash;at the outset of the protocol&mdash;a set  <span class="math">U_{\\mathcal{A}}</span>  of parties with total relative stake  <span class="math">\\alpha_{\\mathcal{A}}</span> . (Formally, one can model this by restricting to environments that only allow static corruption.) Recalling Definition 1, a party with relative stake  <span class="math">\\alpha_i</span>  is independently assigned to be a leader for a slot with probability</p>

    <p class="text-gray-300">
<span class="math">$\\phi_f(\\alpha_i) \\triangleq \\phi(\\alpha_i) \\triangleq 1 - (1 - f)^{\\alpha_i}</span>$
.</p>

    <p class="text-gray-300">Figure 7 shows a plot of  <span class="math">\\phi_{1/2}</span>  for illustration. As suggested by the figure,  <span class="math">\\phi_f(x) \\approx f \\cdot x</span>  and as  <span class="math">f \\to 0</span>  this approximation is increasingly faithful. This behavior, among other relevant properties of  <span class="math">\\phi_f</span> , is expressed by following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> The function  <span class="math">\\phi_f(\\alpha)</span>  satisfies the following properties.</p>

    <p class="text-gray-300"><span class="math">$\\phi_f\\left(\\sum_i \\alpha_i\\right) = 1 - \\prod_i (1 - \\phi_f(\\alpha_i)) \\le \\sum_i \\phi_f(\\alpha_i), \\qquad \\alpha_i \\ge 0, \\qquad (5)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\leq \\frac{\\phi_f(\\alpha)}{\\phi_f(1)} = \\frac{1 - \\prod_i (1 - \\phi_f(\\alpha_i))}{f} \\leq \\sum_i \\phi_f(\\alpha_i), \\qquad \\alpha_i \\geq 0, \\qquad (5)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\leq \\frac{\\phi_f(\\alpha)}{\\phi_f(1)} = \\frac{\\phi_f(\\alpha)}{f} \\leq \\alpha \\frac{-\\ln(1 - f)}{f} = \\alpha(1 + f/2 + f^2/3 + \\cdots), \\qquad \\alpha \\in [0, 1]. \\qquad (6)</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The properties follow immediately from the first two derivatives:</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial}{\\partial \\alpha} \\phi_f(\\alpha) = -(1-f)^{\\alpha} \\ln(1-f), \\qquad \\frac{\\partial^2 \\phi_f}{\\partial \\alpha^2}(\\alpha) = -(1-f)^{\\alpha} (\\ln(1-f))^2.</span>$</p>

    <p class="text-gray-300">As the second derivative is strictly negative (for all  <span class="math">f \\in (0,1)</span>  and  <span class="math">\\alpha \\in [0,1]</span> ), the function  <span class="math">\\phi_f</span>  is concave on [0,1]. Considering that  <span class="math">\\phi_f(0) = 0</span>  and  <span class="math">\\phi_f(1) = f</span> , concavity implies that  <span class="math">\\phi_f(\\alpha) \\ge f\\alpha</span>  for  <span class="math">\\alpha \\in [0,1]</span> ; this yields the first inequality of (6). Appealing again to concavity, and the fact that  <span class="math">\\phi_f(0) = 0</span> , the function lies (strictly) below the line  <span class="math">\\ell(x) = \\phi_f&#x27;(0) \\cdot x = -x \\ln(1-f)</span> ; this yields the second inequality of (6).</p>

    <p class="text-gray-300">As  <span class="math">\\phi_f(0) \\ge 0</span>  and  <span class="math">\\phi_f</span>  is concave, the function  <span class="math">\\phi_f</span>  is subadditive; this yields (5).</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7: The function  <span class="math">\\phi_{1/2}(\\alpha) = 1 - (1/2)^{\\alpha}</span>  and the linear function  <span class="math">\\alpha \\mapsto \\alpha/2</span> , for comparison. The point (1, 1/2) is marked in solid black.</p>

    <p class="text-gray-300">Recalling Definition 6, this (static) adversary  <span class="math">\\mathcal{A}</span>  determines a distribution  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f</span>  on strings  <span class="math">w \\in \\{0,1,\\perp\\}^R</span>  by independently assigning each  <span class="math">w_i</span>  so that</p>

    <p class="text-gray-300"><span class="math">$p_{\\perp}^{\\mathcal{A}} \\triangleq \\Pr[w_i = \\perp] = \\prod_{i \\in \\mathcal{P}} (1 - \\phi(\\alpha_i)) = \\prod_{i \\in \\mathcal{P}} (1 - f)^{\\alpha_i} = (1 - f),</span>$</p>

    <p class="text-gray-300"><span class="math">$p_0^{\\mathcal{A}} \\triangleq \\Pr[w_i = 0] = \\sum_{h \\in \\mathcal{H}} (1 - (1 - f)^{\\alpha_h}) \\cdot (1 - f)^{1 - \\alpha_i},</span>$</p>

    <p class="text-gray-300"><span class="math">$p_1^{\\mathcal{A}} \\triangleq \\Pr[w_i = 1] = 1 - p_{\\perp}^{\\mathcal{A}} - p_0^{\\mathcal{A}}.</span>$</p>

    <p class="text-gray-300"><span class="math">$(7)</span>$</p>

    <p class="text-gray-300">Here  <span class="math">\\mathcal{H}</span>  denotes the set of all honest parties in the stake distribution  <span class="math">\\mathcal{S}</span>  determined by  <span class="math">\\mathcal{Z}</span> . As before,  <span class="math">\\mathcal{P}</span>  denotes the set of all parties.</p>

    <p class="text-gray-300">It is convenient to work with some bounds on the above quantities that depend only on &quot;macroscopic&quot; features of S and A: namely, the relative stake of the honest and adversarial parties, and the parameter f. For this purpose we note that</p>

    <p class="text-gray-300"><span class="math">$p_0^{\\mathcal{A}} \\ge \\sum_{h \\in \\mathcal{H}} \\phi(\\alpha_h) \\cdot \\prod_{i \\in \\mathcal{P}} (1 - \\phi(\\alpha_i)) \\ge \\phi(\\alpha_{\\mathcal{H}}) \\cdot p_{\\perp}^{\\mathcal{A}} = \\phi(\\alpha_{\\mathcal{H}}) \\cdot (1 - f),</span>$
(8)</p>

    <p class="text-gray-300">where  <span class="math">\\alpha_{\\mathcal{H}}</span>  denotes the total relative stake of the honest parties. Note that this bound applies to all static adversaries  <span class="math">\\mathcal{A}</span>  that corrupt no more than a  <span class="math">1 - \\alpha_{\\mathcal{H}}</span>  fraction of all stake. With this in mind, we define the dominant distribution as follows.</p>

    <p class="text-gray-300"><strong>Definition 13 (The dominant distribution</strong>  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> ). For two parameters f and  <span class="math">\\alpha</span> , define  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  to be the distribution on strings  <span class="math">w \\in \\{0,1,\\perp\\}^{R}</span>  that independently assigns each  <span class="math">w_{i}</span>  so that</p>

    <p class="text-gray-300">
<span class="math">$p_{\\perp} \\triangleq \\Pr[w_i = \\perp] = 1 - f,</span>$</p>

    <p class="text-gray-300"><span class="math">$p_0 \\triangleq \\Pr[w_i = 0] = \\phi(\\alpha) \\cdot (1 - f), \\quad and</span>$</p>

    <p class="text-gray-300"><span class="math">$p_1 \\triangleq \\Pr[w_i = 1] = 1 - p_{\\perp} - p_0.</span>$</p>

    <p class="text-gray-300"><span class="math">$(9)</span>$</p>

    <p class="text-gray-300">The distribution  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  &quot;dominates&quot;  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>  for any static adversary  <span class="math">\\mathcal{A}</span>  that corrupts no more than a relative  <span class="math">1-\\alpha</span>  share of the total stake, in the sense that nonempty slots are more likely to be tainted under  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  than they are under  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span> .</p>

    <p class="text-gray-300">To make this relationship precise, we introduce the partial order  <span class="math">\\leq</span>  on the set  <span class="math">\\{\\bot,0,1\\}</span>  so that  <span class="math">x \\leq y</span>  if and only if x = y or y = 1. We extend this partial order to  <span class="math">\\{\\bot,0,1\\}^R</span>  by declaring  <span class="math">x_1 \\ldots x_R \\leq y_1 \\ldots y_R</span>  if and only if  <span class="math">x_i \\leq y_i</span>  for each <em>i</em>. Intuitively, the relationship x &lt; y asserts that y is &quot;more adversarial than&quot; x; concretely, any legal fork for x is also a legal fork for y. Finally, we define a notion of stochastic dominance for distributions on characteristic strings, and  <span class="math">\\alpha</span> -dominated adversaries.</p>

    <p class="text-gray-300"><strong>Definition 14 (Stochastic dominance).</strong> We say that a subset  <span class="math">E \\subseteq \\{\\bot, 0, 1\\}^R</span>  is monotone if  <span class="math">x \\in E</span>  and  <span class="math">x \\leq y</span>  implies that  <span class="math">y \\in E</span> . Let  <span class="math">\\mathcal{D}</span>  and  <span class="math">\\mathcal{D}&#x27;</span>  be two distributions on the set of characteristic strings  <span class="math">\\{\\bot, 0, 1\\}^R</span> . Then we say that  <span class="math">\\mathcal{D}&#x27;</span>  dominates  <span class="math">\\mathcal{D}</span> , written  <span class="math">\\mathcal{D} \\preceq \\mathcal{D}&#x27;</span> , if  <span class="math">\\Pr_{\\mathcal{D}}[E] \\leq \\Pr_{\\mathcal{D}&#x27;}[E]</span>  for every monotone set E. An adversary  <span class="math">\\mathcal{A}</span>  is called  <span class="math">\\alpha</span> -dominated if the distribution  <span class="math">\\mathcal{D}_{\\mathcal{Z}, \\mathcal{A}}^f</span>  that it induces on the set of characteristic strings satisfies  <span class="math">\\mathcal{D}_{\\mathcal{Z}, \\mathcal{A}}^f \\preceq \\mathcal{D}_{\\alpha}^f</span> .</p>

    <p class="text-gray-300">As noted above, this notion of stochastic dominance is consistent with the chain-theoretic definitions of interest, in the sense that failures of the abstract chain properties form monotone events. We record this in the lemma below.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let x and y be characteristic strings in  <span class="math">\\{0,1,\\perp\\}^R</span>  for which  <span class="math">x \\leq y</span> . Then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1.) For every fork F,  <span class="math">F \\vdash_{\\Delta} x \\Longrightarrow F \\vdash_{\\Delta} y</span> .</li>
      <li>2.) For every  <span class="math">\\Delta</span> ,  <span class="math">\\operatorname{div}_{\\Delta}(x) \\leq \\operatorname{div}_{\\Delta}(y)</span> .</li>
      <li>3.) More generally, let  <span class="math">\\mathcal{P}</span>  be a subset of all forks of characteristic strings of length R (that is,  <span class="math">\\mathcal{P}</span>  is a subset of  <span class="math">\\{F \\vdash w \\mid w \\in \\{0,1,\\perp\\}^R\\}</span> ); then  <span class="math">\\{w \\in \\{0,1,\\perp\\}^R \\mid \\exists F \\vdash w, F \\in \\mathcal{P}\\}</span>  is a monotone set.</li>
    </ul>

    <p class="text-gray-300">The proof is immediate from the definitions.</p>

    <p class="text-gray-300">As an example in our setting, for abstract common prefix the events of interest are  <span class="math">D_{\\Delta} = \\{x \\mid \\operatorname{div}_{\\Delta}(x) \\geq k\\}</span>  which is a monotone set by Lemma 2. We note that any static adversary that corrupts no more than a  <span class="math">1 - \\alpha</span>  fraction of stake is  <span class="math">\\alpha</span> -dominated, and it follows that</p>

    <p class="text-gray-300">
<span class="math">$\\Pr_{\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}}[\\operatorname{div}_{\\Delta}(w) \\geq k] \\leq \\Pr_{\\mathcal{D}_{\\alpha}^{f}}[\\operatorname{div}_{\\Delta}(w) \\geq k].</span>$</p>

    <p class="text-gray-300">This motivates a particular study of the &quot;dominant&quot; distribution  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> .</p>

    <p class="text-gray-300">The Induced Distribution  <span class="math">\\rho_{\\Delta}(\\mathcal{D}_{\\alpha}^f)</span> . The dominant distribution  <span class="math">\\mathcal{D}_{\\alpha}^f</span>  on  <span class="math">\\{0,1,\\bot\\}^R</span>  in conjunction with the definition of  <span class="math">\\rho_{\\Delta}</span>  of (4) above implicitly defines a family of random variables  <span class="math">\\rho_{\\Delta}(w) = x_1 \\dots x_{\\ell} \\in \\{0,1\\}^*</span> , where  <span class="math">w \\in \\{0,1,\\bot\\}^R</span>  is distributed according to  <span class="math">\\mathcal{D}_{\\alpha}^f</span> . Observe that  <span class="math">\\ell = R - \\#_{\\bot}(w)</span>  is precisely the number of active indices of w. We now note a few properties of this resulting distribution that will be useful to us later. In particular, we will see that the  <span class="math">x_i</span>  random variables are roughly independent, but subject to an exotic stochastic &quot;stopping time&quot; condition in tandem with some distortion of the last  <span class="math">\\Delta</span>  variables.</p>

    <p class="text-gray-300"><strong>Lemma 3 (Structure of the induced distribution).</strong> Let  <span class="math">x_1 \\dots x_\\ell = \\rho_\\Delta(w)</span>  where  <span class="math">w \\in \\{0, 1, \\bot\\}^R</span>  is distributed according to  <span class="math">\\mathcal{D}^f_\\alpha</span> . There is a sequence of independent random variables  <span class="math">z_1, z_2, \\dots</span>  with each  <span class="math">z_i \\in \\{0, 1\\}</span>  so that</p>

    <p class="text-gray-300">
<span class="math">$\\Pr[z_i = 0] = \\left(\\frac{p_0}{p_0 + p_1}\\right) p_{\\perp}^{\\Delta} \\ge \\alpha \\cdot (1 - f)^{\\Delta + 1},</span>$
(10)</p>

    <p class="text-gray-300">and
<span class="math">$x_1 \\dots x_{\\ell-\\Delta} = \\rho_{\\Delta}(w_1 \\dots, w_R)^{\\lceil \\Delta}</span>$
is a prefix of  <span class="math">z_1 z_2 \\dots</span>  (11)</p>

    <p class="text-gray-300">(Note that while the  <span class="math">z_i</span>  are independent with each other, they are not independent with w.)</p>

    <p class="text-gray-300"><em>Proof.</em> It simplifies our analysis to treat w as the first R symbols of an infinite string  <span class="math">w_1w_2...</span>  of independent random variables with distribution given by Definition 13 above. (We use the same name for this infinite sequence as it will cause no confusion.) The distribution of the infinite</p>

    <p class="text-gray-300">sequence w can be given an alternative description as  <span class="math">b_0e_1b_1e_2b_2...</span> , where the (independent) random variables  <span class="math">e_i \\in \\{0,1\\}</span>  and  <span class="math">b_i \\in \\{\\bot\\}^*</span>  have the probability laws</p>

    <p class="text-gray-300"><span class="math">$e_i = \\begin{cases} 0 &amp; \\text{with probability } p_0/(p_0 + p_1), \\\\ 1 &amp; \\text{with probability } p_1/(p_0 + p_1), \\end{cases}</span>$</p>

    <p class="text-gray-300">and  <span class="math">b_i = \\bot^t</span>  with probability  <span class="math">p_{\\bot}^t(1 - p_{\\bot})</span> . In this description, the random variables  <span class="math">b_i</span>  generate the contiguous sequences of  <span class="math">\\bot</span>  symbols that appear between appearances of 0 and 1. Now we observe that  <span class="math">z_1 z_2 \\ldots = \\rho_{\\Delta}(b_0 e_1 b_1 \\ldots)</span> &mdash;which we temporarily treat as operating on an infinite sequence&mdash;has an immediate description in terms of the  <span class="math">e_i, b_i</span>  random variables:</p>

    <p class="text-gray-300"><span class="math">$z_i = \\begin{cases} 1 &amp; \\text{if } e_i = 1 \\text{ or } |b_i| &lt; \\Delta, \\\\ 0 &amp; \\text{if } e_i = 0 \\text{ and } |b_i| \\ge \\Delta. \\end{cases}</span>$</p>

    <p class="text-gray-300">It follows that the variables  <span class="math">z_i \\in \\{0,1\\}</span>  are independent with the further property that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[z_i = 0] = \\left(\\frac{p_0}{p_0 + p_1}\\right) p_{\\perp}^{\\Delta} \\stackrel{(9)}{=} \\frac{\\phi(\\alpha)}{f} \\cdot (1 - f)^{\\Delta + 1} \\stackrel{(6)}{\\geq} \\alpha \\cdot (1 - f)^{\\Delta + 1}, \\tag{12}</span>$</p>

    <p class="text-gray-300">where we use the equality  <span class="math">p_0 + p_1 = 1 - p_{\\perp}</span>  as well as equations (9) and (6).</p>

    <p class="text-gray-300">In our setting, the reduction function  <span class="math">\\rho_{\\Delta}(\\cdot)</span>  is applied to a prefix of the string w of finite length R. In fact, the resulting &quot;stopping criteria&quot; on the random variables  <span class="math">z_1, z_2, \\ldots</span>  can both introduce correlations and distort the coordinatewise distribution. However, we note that  <span class="math">\\rho_{\\Delta}(w_1 \\ldots w_R)</span>  produces a prefix of the sequence  <span class="math">z_1, z_2, \\ldots</span>  with the irritating possibility that the last  <span class="math">\\Delta</span>  of the  <span class="math">z_i</span>  in this prefix may be altered by the fact that there are not sufficient symbols in the string w to satisfy the criteria for  <span class="math">z_i = 0</span> . Thus we observe (11):</p>

    <p class="text-gray-300"><span class="math">$x_1 \\dots x_{\\ell-\\Delta} = \\rho_{\\Delta}(w_1 \\dots, w_R)^{\\lceil \\Delta \\rceil}</span>$
is a prefix of  <span class="math">z_1 z_2 \\dots</span></p>

    <p class="text-gray-300">where  <span class="math">\\cdot^{\\lceil \\Delta}</span>  denotes the truncation operator that removes the last  <span class="math">\\Delta</span>  symbols, and the sequence  <span class="math">z_1z_2...</span>  is determined by the infinite string  <span class="math">w_1w_2...</span>  Recall that the  <span class="math">z_i</span>  are Bernoulli random variables with parameter  <span class="math">\\approx 1 - \\alpha(1-f)^{\\Delta+1}</span> .</p>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">4.5 Abstract Common Prefix and the Divergence of the Dominant Distribution</h3>

    <p class="text-gray-300">Our goal is to apply the reduction map  <span class="math">\\rho_{\\Delta}</span> , Lemma 1, and Theorem 3 to establish an upper bound on the probability that a string drawn from the dominant distribution  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  has large  <span class="math">\\Delta</span> -divergence. The difficulty is that the distribution resulting from applying  <span class="math">\\rho_{\\Delta}</span>  to a string drawn from  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  is no longer a sequence of independent random variables, so we cannot apply Theorem 3 directly. We resolve this obstacle in the proof of the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 4 (Abstract Common Prefix (cp)).</strong> Let  <span class="math">f \\in (0,1]</span> ,  <span class="math">\\Delta \\in \\mathbb{N}</span> , and  <span class="math">\\alpha</span>  be such that  <span class="math">\\alpha(1-f)^{\\Delta+1} = (1+\\epsilon)/2</span>  for some  <span class="math">\\epsilon &gt; 0</span> . Let w be a string drawn from  <span class="math">\\{0,1,\\bot\\}^R</span>  according to  <span class="math">\\mathcal{D}^f_{\\alpha}</span> . Then we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w \\ violates \\ (k+\\Delta)\\text{-cp}] = \\Pr[\\operatorname{div}_{\\Delta}(w) &gt; k+\\Delta] = 2^{-\\Omega(k) + \\log R},</span>$</p>

    <p class="text-gray-300">where the asymptotic notation hides a constant that depends on  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Observe that  <span class="math">\\operatorname{div}_0(\\cdot)</span>  is monotone in the sense that if  <span class="math">\\check{y}</span>  is a prefix of y then  <span class="math">\\operatorname{div}_0(\\check{y}) \\leq \\operatorname{div}_0(y)</span> ; this follows because any fork  <span class="math">\\check{F} \\vdash_0 \\check{y}</span>  can be &quot;extended&quot; to a fork  <span class="math">F \\vdash y</span>  which includes all times of  <span class="math">\\check{F}</span> . Additionally, we note that  <span class="math">\\operatorname{div}_0(\\cdot)</span>  has a straightforward &quot;Lipshitz property&quot;: if  <span class="math">|y| \\leq |\\check{y}| + s</span>  then  <span class="math">\\operatorname{div}_0(y) \\leq \\operatorname{div}_0(\\check{y}) + s</span> ; this follows because any fork  <span class="math">F \\vdash_0 y</span>  can be restricted to a fork  <span class="math">\\check{F} \\vdash_0 \\check{y}</span>  by retaining only vertices labeled by  <span class="math">\\check{y}</span> &mdash;this can trim no more than s vertices from any tine.</p>

    <p class="text-gray-300">In light of Lemma 1 we conclude that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}_{\\Delta}(w) \\leq \\operatorname{div}_{0}(\\rho_{\\Delta}(w)) \\leq \\operatorname{div}_{0}(\\rho_{\\Delta}(w)^{\\lceil \\Delta}) + \\Delta \\leq \\operatorname{div}_{0}(z_{1} \\dots z_{R}) + \\Delta,</span>$</p>

    <p class="text-gray-300">where the last inequality follows because the random variable  <span class="math">\\rho_{\\Delta}(w_1 \\dots w_R)</span>  can certainly have length no more than R. As the random variables  <span class="math">z_i</span>  are i.i.d. with  <span class="math">\\Pr[z_i = 0] \\ge \\alpha (1 - f)^{\\Delta + 1}</span> , the conclusion of Theorem 4 now follows directly from the assumption that  <span class="math">\\alpha (1 - f)^{\\Delta + 1} \\ge (1 + \\epsilon)/2</span>  and Theorem 3.</p>

    <p class="text-gray-300">Remark. Intuitively, the theorem asserts that sampling the characteristic string in the  <span class="math">\\Delta</span> -semi-synchronous setting with protocol parameter f according to  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  is, for the purpose of analyzing divergence, comparable to the <em>synchronous</em> setting in which the honest stake has been reduced from  <span class="math">\\alpha</span>  to  <span class="math">\\alpha(1-f)^{\\Delta+1}</span> . Note that this can be made arbitrarily close to  <span class="math">\\alpha</span>  by adjusting f to be small; however, this happens at the expense of longer periods of silence in the protocol.</p>

      <h3 id="sec-4.6" class="text-xl font-semibold mt-8">4.6 Abstract Chain Growth and Chain Quality</h3>

    <p class="text-gray-300">In this section, we establish Abstract Chain Growth and Abstract Chain Quality under the distribution  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> . These results directly imply the corresponding properties for executions of the protocol via stochastic dominance&mdash;this connection is discussed in Section 4.7.</p>

    <p class="text-gray-300">We begin with chain growth, the simpler of the two. We again consider  <span class="math">\\Delta</span> -right-isolated uniquely honest slots as introduced in Section 4.3. Intuitively, the leader of such a slot has already received all blocks that were created in previous such slots and therefore the block it creates will have larger depth. We then observe that, using an honest block as an initial point of reference, the length of any viable tine grows by at least one for each such slot.</p>

    <p class="text-gray-300"><strong>Theorem 5 (Abstract Honest-Bounded Chain Growth (hcg)).</strong> Let  <span class="math">f \\in (0,1]</span> ,  <span class="math">\\Delta \\in \\mathbb{N}</span> , and  <span class="math">\\alpha &gt; 0</span> . Let w be a string drawn from  <span class="math">\\{0,1,\\bot\\}^R</span>  according to  <span class="math">\\mathcal{D}^f_{\\alpha}</span> . Then for  <span class="math">s \\geq 6(\\Delta+1)</span>  and  <span class="math">\\tau = c\\alpha/3</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w \\text{ does not satisfy } (s,\\tau)\\text{-hcg}] \\leq e^{3/8}R^2(\\Delta+1)\\exp\\left(-\\frac{c\\alpha s}{8(\\Delta+1)}\\right)\\,,</span>$</p>

    <p class="text-gray-300">where c denotes the constant  <span class="math">c := c(f, \\Delta) = f(1 - f)^{\\Delta + 1}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall the definition of (Honestly-Bounded) Chain Growth: for any fork F of w, any suffix of a viable tine t that spans s slots and begins right after an honestly generated block must contain  <span class="math">\\tau s</span>  blocks.</p>

    <p class="text-gray-300">Consider a fixed characteristic string w and a pair  <span class="math">\\mathsf{sl}_1 &lt; \\mathsf{sl}_2</span>  of slots; we say that the pair  <span class="math">(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  witnesses a  <span class="math">(s,\\tau)</span> -hcg violation in w if there is a fork  <span class="math">F \\vdash w</span>  and a viable tine t for which (i.)  <span class="math">\\mathsf{sl}_2 = \\ell(t)</span> , (ii.)  <span class="math">\\mathsf{sl}_1 + s \\leq \\mathsf{sl}_2</span> , (iii.) t has an honest vertex t with label  <span class="math">\\mathsf{sl}_1</span> , and (iv.) the length of the path  <span class="math">t(\\mathsf{sl}_1,\\mathsf{sl}_2)</span>  is less than t. Note that if t violates t violates t violates t violates is some pair t violates that witnesses this.</p>

    <p class="text-gray-300">Consider now a pair  <span class="math">(\\mathsf{sl}_1,\\mathsf{sl}_2)</span>  that witnesses an  <span class="math">(s,\\tau)</span> -hcg violation in w via a fork  <span class="math">F \\vdash w</span>  and a viable tine t in F, let u be a vertex as above. Let  <span class="math">\\hat{\\mathsf{sl}}_1,\\ldots,\\hat{\\mathsf{sl}}_h</span>  be the increasing sequence of all  <span class="math">\\Delta</span> -right-isolated uniquely honest slots among the slots in  <span class="math">T:=(\\mathsf{sl}_1+\\Delta,\\mathsf{sl}_2-\\Delta)</span>  and let  <span class="math">v_1,\\ldots v_h</span>  be the (unique) vertices labeled with these slots (so  <span class="math">\\ell(v_i)=\\hat{\\mathsf{sl}}_i</span> ). Let u' denote the last vertex on t, labeled by  <span class="math">\\mathsf{sl}_2</span> . It is an easy matter to confirm that the depths of the honest vertices  <span class="math">u,v_1,\\ldots,v_h</span> , are strictly increasing (in this order), while the depth of u' is at least that of  <span class="math">v_h</span> : First, considering that  <span class="math">\\hat{\\mathsf{sl}}_1&gt;\\mathsf{sl}_1+\\Delta</span>  and  <span class="math">\\hat{\\mathsf{sl}}_1</span>  is uniquely honest, depth( <span class="math">v_1</span> ) &gt; depth( <span class="math">v_1</span> ). Analogously, (for each relevant  <span class="math">v_1</span> ) as  <span class="math">\\hat{\\mathsf{sl}}_{i-1}</span>  is  <span class="math">v_2</span> -right-isolated and both  <span class="math">\\hat{\\mathsf{sl}}_{i-1}</span>  and  <span class="math">\\hat{\\mathsf{sl}}_i</span>  are uniquely honest, depth( <span class="math">v_i</span> ) &gt; depth( <span class="math">v_i</span> ). Finally,  <span class="math">v_i</span>  is viable,  <span class="math">v_i</span>  is honest, and  <span class="math">\\hat{\\mathsf{sl}}_i+\\Delta&lt;\\mathsf{sl}_2</span> ; this implies that depth( <span class="math">v_i</span> ) &gt; depth( <span class="math">v_i</span> ). It follows that length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length( <span class="math">v_i</span> ) - length(v</p>

    <p class="text-gray-300">To complete the proof, we estimate the probability of a violation with a  <span class="math">(\\mathsf{sl}_1,\\mathsf{sl}_2)</span>  witness, for a fixed pair  <span class="math">\\mathsf{sl}_1,\\mathsf{sl}_2</span> , and apply the union bound over all such pairs to yield the final bound. For this purpose, for the random variable  <span class="math">x \\leftarrow \\mathcal{D}_{\\alpha}^f</span>  let  <span class="math">H_T(x)</span>  denote the number of  <span class="math">\\Delta</span> -right-isolated uniquely honest slots among the slots from  <span class="math">T = (\\mathsf{sl}_1 + \\Delta, \\mathsf{sl}_2 - \\Delta)</span> . In particular, we identify the event  <span class="math">E \\triangleq \\{x \\in \\{0,1,\\bot\\}^R \\mid H_T(x) &lt; c\\alpha s/3\\}</span>  where  <span class="math">c = c(f,\\Delta) = f(1-f)^{\\Delta+1}</span> .</p>

    <p class="text-gray-300">For each  <span class="math">t \\in T</span> , let  <span class="math">X_t</span>  be the indicator random variable for the event that slot t is  <span class="math">\\Delta</span> -right-isolated uniquely honest. Observe that  <span class="math">\\mu \\triangleq \\mathbb{E}[X_t] = p_0 p_\\perp^\\Delta \\geq \\alpha f (1-f)^{\\Delta+1}</span>  according to Definition 13 and (6), and that the random variables  <span class="math">X_t</span>  and  <span class="math">X_{t&#x27;}</span>  are independent if  <span class="math">|t-t&#x27;| \\geq \\Delta + 1</span>  (as they depend on the leader sets of non-overlapping sets of slots). If we let  <span class="math">T_z = \\{t \\in T \\mid t \\equiv z \\mod \\Delta + 1\\}</span> , then the family of variables  <span class="math">X_t</span>  indexed by  <span class="math">T_z</span>  are independent. Note also that</p>

    <p class="text-gray-300"><span class="math">|T_z| &gt; \\lfloor (s - 2(\\Delta + 1))/(\\Delta + 1) \\rfloor \\ge s/(\\Delta + 1) - 3</span>  and that we may write T as the disjoint union  <span class="math">T_0 \\cup \\cdots \\cup T_\\Delta</span> . By the Chernoff bound of Appendix E with  <span class="math">\\delta = 1/2</span> , for each  <span class="math">T_z</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\sum_{t \\in T_z} X_t &lt; \\mu |T_z|/2\\right] \\le e^{-(\\frac{1}{2})^2 \\mu |T_z|/2} \\le e^{-\\frac{\\mu}{8} \\left(\\frac{s}{\\Delta + 1} - 3\\right)}.</span>$</p>

    <p class="text-gray-300">Observe that if  <span class="math">\\sum_{t \\in T_z} X_t \\ge \\mu |T_z|/2</span>  for each z then also  <span class="math">H_T(x) = \\sum_{t \\in T} X_t \\ge \\mu |T|/2 \\ge \\mu \\widehat{s}/2</span> , where we let  <span class="math">\\widehat{s} \\triangleq s - 2(\\Delta + 1) \\le |T|</span> . It follows from the union bound that</p>

    <p class="text-gray-300">
<span class="math">$\\Pr_{x \\leftarrow \\mathcal{D}_{\\alpha}^{f}} [H_{T}(x) &lt; \\mu \\hat{s}/2] \\le (\\Delta + 1) \\cdot e^{-\\frac{\\mu(s - 3(\\Delta + 1))}{8(\\Delta + 1)}}.</span>$
(13)</p>

    <p class="text-gray-300">As  <span class="math">\\mu \\ge \\alpha f(1-f)^{\\Delta+1}</span>  (and  <span class="math">\\mu \\le f(1-f) \\le 1/4</span> ), we obtain</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{x \\leftarrow \\mathcal{D}_{\\alpha}^{f}} \\left[ H_{T}(x) &lt; c\\alpha \\widehat{s}/2 \\right] \\leq \\Pr_{x \\leftarrow \\mathcal{D}_{\\alpha}^{f}} \\left[ H_{T}(x) &lt; \\mu \\widehat{s}/2 \\right] \\leq (\\Delta + 1) \\cdot e^{-\\frac{c\\alpha s}{8(\\Delta + 1)} + \\frac{3}{8}} .</span>$</p>

    <p class="text-gray-300">Since  <span class="math">s \\ge 6(\\Delta + 1)</span> , we have  <span class="math">\\hat{s} \\ge 2s/3</span>  and hence that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{x \\leftarrow \\mathcal{D}_{\\alpha}^{f}} [H_{T}(x) &lt; c\\alpha s/3] \\leq (\\Delta + 1) \\cdot e^{-\\frac{c \\cdot \\alpha s}{8(\\Delta + 1)} + \\frac{3}{8}}.</span>$</p>

    <p class="text-gray-300">Applying the union bound over the  <span class="math">R^2</span>  pairs ( <span class="math">\\mathsf{sl}_1, \\mathsf{sl}_2</span> ), we conclude that the probability that there is a chain growth violation with parameters s and  <span class="math">\\tau = c\\alpha/3</span>  is no more than</p>

    <p class="text-gray-300"><span class="math">$e^{3/8}R^2(\\varDelta+1)\\exp(-c\\alpha s/(8(\\varDelta+1))).</span>$</p>

    <p class="text-gray-300">We now turn to chain quality. This argument follows similar reasoning as above, but contrasts the chain growth guaranteed by isolated honest slots with the growth available from other active slots.</p>

    <p class="text-gray-300"><strong>Theorem 6 (Abstract Existential Chain Quality (\\exists cq)).</strong> Let  <span class="math">f \\in (0,1]</span> ,  <span class="math">\\Delta \\in \\mathbb{N}</span> , and  <span class="math">\\alpha</span>  be such that  <span class="math">\\alpha(1-f)^{\\Delta+1} = (1+\\epsilon)/2</span>  for some  <span class="math">\\epsilon &gt; 0</span> . Let w be a string drawn from  <span class="math">\\{0,1,\\bot\\}^R</span>  according to  <span class="math">\\mathcal{D}_{\\alpha}^f</span> . Then for  <span class="math">s \\geq 2(\\Delta+1)/\\epsilon</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[w \\text{ does not satisfy s-} \\exists \\textit{cq}] \\leq R^2(\\varDelta + 2) \\cdot \\exp\\left(-\\frac{f\\epsilon^2(1-\\epsilon)s}{16(\\varDelta + 2)} + f\\epsilon^2/4\\right) \\,.</span>$</p>

    <p class="text-gray-300">Proof. Consider a characteristic string  <span class="math">w \\in \\{0, 1, \\bot\\}^R</span> . We say that a pair of slots  <span class="math">(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  witness an  <span class="math">\\exists \\mathsf{cq}</span>  violation if there is a  <span class="math">\\Delta</span> -fork  <span class="math">F \\vdash w</span>  and a viable tine t so that (i.)  <span class="math">\\mathsf{sl}_2 &gt; \\mathsf{sl}_1 + s</span> , (ii.) t has an honest vertex labeled by slot  <span class="math">\\mathsf{sl}_1</span> , (iii.)  <span class="math">t[0, \\mathsf{sl}_2]</span>  is viable, and (iv.) every vertex on  <span class="math">t(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  is adversarial. It is a fact that if w violates s- <span class="math">\\exists \\mathsf{cq}</span>  then there is a pair of slots  <span class="math">(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  with the properties above: Starting with a nominal violation (a fork with a viable tine t with no honest vertex over a window  <span class="math">[\\mathsf{sl}_1, \\mathsf{sl}_2]</span>  of s slots), one may naturally extend the left end of this window (reducing  <span class="math">\\mathsf{sl}_1</span> ) until t possesses an honest vertex (which may be the root) and extend the right end of this window (increasing  <span class="math">\\mathsf{sl}_2</span> ) until  <span class="math">t[0, \\mathsf{sl}_2]</span>  is viable&mdash;this may occur because t has an honest vertex labeled with  <span class="math">\\mathsf{sl}_2</span> , or because  <span class="math">\\mathsf{sl}_2 = \\ell(t)</span> .</p>

    <p class="text-gray-300">For convenience, let us call a slot good if it is  <span class="math">\\Delta</span> -right-isolated uniquely honest, and bad if it is neither empty nor good. Moreover, we call a block good (resp., bad) if it is labeled with a good (resp., bad) slot. As in the proof of Theorem 5, for a window T and a characteristic string x, let  <span class="math">H_T(x)</span>  denote the number of good slots appearing in the window T. Similarly, let  <span class="math">A_T(x)</span>  denote the number of bad slots (so that  <span class="math">H_T(x) + A_T(x)</span>  is equal to the number of non-empty slots in T). We note that if  <span class="math">T = (\\mathsf{sl}_1 + \\Delta, \\mathsf{sl}_2 - \\Delta)</span>  and  <span class="math">T&#x27; = (\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  then  <span class="math">(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  cannot witness a s- <span class="math">\\exists</span> cq violation unless  <span class="math">H_T(x) \\leq A_{T&#x27;}(x)</span> . To see this, consider a fork  <span class="math">F \\vdash x</span>  and a tine t realizing the conditions that  <span class="math">(\\mathsf{sl}_1, \\mathsf{sl}_2)</span>  is a witness. By the same argument in the proof of Theorem 5, t must have at least  <span class="math">H_T(x)</span>  vertices over the region T'. On the other hand, at most  <span class="math">A_{T&#x27;}(x)</span>  of these vertices can be adversarial. Thus the conditions require  <span class="math">A_{T&#x27;}(x) \\geq H_T(x)</span> .</p>

    <p class="text-gray-300">To conclude the proof, we consider the random variable  <span class="math">x \\leftarrow \\mathcal{D}_{\\alpha}^f</span>  and show, for a specific fixed pair  <span class="math">(\\mathsf{sl}_1,\\mathsf{sl}_2)</span> , that the probability that  <span class="math">A_{T&#x27;}(x) \\geq H_T(x)</span>  is small (for the appropriate T and T'); taking the union bound over all such pairs then upper-bounds the probability of a  <span class="math">\\exists \\mathsf{cq}</span>  failure. Fixing  <span class="math">\\mathsf{sl}_1</span>  and  <span class="math">\\mathsf{sl}_2</span> , note that  <span class="math">|T&#x27;| \\geq s</span>  while  <span class="math">|T| = |T&#x27;| - 2(\\Delta + 1)</span> . Let  <span class="math">H_i</span>   <span class="math">(i \\in T)</span>  be the indicator random variable for the event that slot i is good; let  <span class="math">A_i</span>   <span class="math">(i \\in T&#x27;)</span>  be the indicator random variable for the event that slot i is bad. Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[H_i] = p_0 p_\\perp^{\\Delta} \\ge \\alpha f (1 - f)^{\\Delta + 1} = \\alpha \\cdot c(f, \\Delta) = f (1 + \\epsilon)/2, \\quad \\text{and}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[A_i] = 1 - p_\\perp - p_0 p_\\perp^{\\Delta} = f - p_0 p_\\perp^{\\Delta} \\le f (1 - \\epsilon)/2.</span>$</p>

    <p class="text-gray-300">Applying the very reasoning leading to equation (13) but with  <span class="math">\\delta = \\epsilon/2</span>  and  <span class="math">\\mu = \\mathbb{E}[H_i]</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[H_T(x) \\leq \\underbrace{\\frac{1 + (\\epsilon/2)(1 - \\epsilon)}{2} f \\cdot \\hat{s}}_{(\\dagger)}\\right] = \\Pr\\left[H_T(x) \\leq (1 - \\epsilon/2) \\frac{(1 + \\epsilon)}{2} f \\cdot \\hat{s}\\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\Pr[H_T(x) \\leq (1 - \\delta)\\mu \\hat{s}] \\leq (\\Delta + 1) \\exp\\left(-\\mu \\frac{\\delta^2(\\frac{s}{\\Delta + 1} - 3)}{2}\\right) \\leq (\\Delta + 1) \\exp\\left(-\\frac{f\\epsilon^2(s - 3(\\Delta + 1))}{16(\\Delta + 1)}\\right)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{s} = |T| = |T&#x27;| - 2(\\Delta + 1)</span> . On the other hand,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[A_{T&#x27;}(x) \\ge \\underbrace{\\frac{1 - (\\epsilon/2)(1 + \\epsilon)}{2} f \\cdot |T&#x27;|}_{(\\ddagger)}\\right] = \\Pr\\left[A_{T&#x27;}(x) \\ge \\left(1 + \\frac{\\epsilon}{2}\\right) \\left(f\\frac{1 - \\epsilon}{2}\\right) |T&#x27;|\\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\exp\\left(-\\frac{f(1 - \\epsilon)\\epsilon^2}{32}s\\right).</span>$</p>

    <p class="text-gray-300">As our goal is to ensure that  <span class="math">H_T(x) &gt; A_{T&#x27;}(x)</span> , we examine the thresholds&mdash; <span class="math">(\\dagger)</span>  and  <span class="math">(\\ddagger)</span> &mdash;appearing in these bounds. We note that  <span class="math">(\\dagger) \\geq (\\ddagger)</span>  so long as  <span class="math">s \\geq (2+\\varepsilon)(\\Delta+1)/\\epsilon</span> ; for brevity we assume the stronger condition that  <span class="math">s \\geq 3(\\Delta+1)/\\epsilon</span> . With this assumption it follows that  <span class="math">H_T(x) &gt; A_{T&#x27;}(x)</span>  except with probability</p>

    <p class="text-gray-300"><span class="math">$(\\Delta+1)\\exp\\left(-\\frac{f\\epsilon^2(s-3(\\Delta+1))}{16(\\Delta+1)}\\right) + \\exp\\left(-\\frac{f(1-\\epsilon)\\epsilon^2}{32}s\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq (\\Delta+2)\\exp\\left(-\\frac{f\\epsilon^2(1-\\epsilon)(s-3(\\Delta+1))}{16(\\Delta+2)}\\right). \\quad (14)</span>$</p>

    <p class="text-gray-300">Summing this over all pairs  <span class="math">(sl_1, sl_2)</span>  yields the final statement</p>

    <p class="text-gray-300">For completeness, we also state the simple observation that  <span class="math">\\exists cq</span>  and hcg together imply cg. The following statement (for the actual chain properties, rather than their &quot;abstract&quot; counterparts) first appeared in  <span class="math">[BGK^+18]</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> ([BGK<sup>+</sup>18, Lemma 10]). Consider a characteristic string w that satisfies  <span class="math">\\exists cq</span>  with parameter  <span class="math">s_{\\exists cq}</span>  and hcg with parameters  <span class="math">\\tau_{hcg}</span>  and  <span class="math">s_{hcg}</span> ; then it satisfies cg with parameters</p>

    <p class="text-gray-300"><span class="math">$s = 2s_{\\exists cq} + s_{hcg}</span>$
and  <span class="math">\\tau = \\tau_{hcg} \\cdot \\left(\\frac{s_{hcg}}{s_{hcg} + 2s_{\\exists cq}}\\right)</span> .</p>

    <p class="text-gray-300">In particular, assuming  <span class="math">s_{hcg} \\geq 2s_{\\exists cg}</span> , the execution satisfies cg with parameter  <span class="math">\\tau \\geq \\tau_{hcg}/2</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">F \\vdash w</span>  be a fork and let t be a viable tine. Consider a portion of t spanning  <span class="math">\\hat{s} \\geq s = 2s_{\\exists \\mathsf{cq}} + s_{\\mathsf{hcg}}</span>  slots. By  <span class="math">\\exists \\mathsf{cq}</span> , there must be an honest vertex of t associated with the first  <span class="math">s_{\\exists \\mathsf{cq}}</span>  and last  <span class="math">s_{\\exists \\mathsf{cq}}</span>  slots. As these two honest blocks are separated by at least  <span class="math">s_{\\mathsf{hcg}}</span>  slots, applying  <span class="math">\\mathsf{hcg}</span>  to the tine that terminates at the later honest block (which is necessarily viable) guarantees that at least</p>

    <p class="text-gray-300"><span class="math">$\\tau_{\\mathsf{hcg}} \\cdot (\\hat{s} - 2s_{\\mathsf{\\exists CQ}}) = \\tau_{\\mathsf{hcg}} \\cdot \\underbrace{\\left(\\frac{\\hat{s} - 2s_{\\mathsf{\\exists cq}}}{\\hat{s}}\\right)}_{(\\dagger)} \\hat{s} \\geq \\tau_{\\mathsf{hcg}} \\cdot \\left(\\frac{s_{\\mathsf{hcg}}}{s_{\\mathsf{hcg}} + 2s_{\\mathsf{\\exists cq}}}\\right) \\hat{s}</span>$</p>

    <p class="text-gray-300">vertices appear in the region. (The last inequality follows because the function  <span class="math">f_{\\lambda}(x) = (x - \\lambda)/x</span> , for any  <span class="math">\\lambda &gt; 0</span> , is strictly increasing for x &gt; 0&mdash;thus (&dagger;) is minimized when  <span class="math">\\hat{s} = s_{\\mathsf{HCG}} + 2s_{\\mathsf{\\exists CQ}}</span> .) The statement of the lemma follows.</p>

    <p class="text-gray-300">Applying the failure probability estimates for the abstract, fork-theoretic, notions of common prefix, chain growth, and chain quality, we establish the analogous estimates for protocol executions.</p>

    <p class="text-gray-300">Beginning with common prefix, the results on  <span class="math">\\Delta</span> -divergence from Section 4.5 allow us to easily establish common prefix.</p>

    <p class="text-gray-300"><strong>Theorem 7 (Common prefix).</strong> Let  <span class="math">k, R, \\Delta \\in \\mathbb{N}</span>  and  <span class="math">\\varepsilon \\in (0,1)</span> . Let  <span class="math">\\mathcal{A}</span>  be an  <span class="math">\\alpha</span> -dominated adversary against the protocol  <span class="math">\\pi_{SPoS}</span>  for some  <span class="math">\\alpha</span>  satisfying  <span class="math">\\alpha(1-f)^{\\Delta+1} \\geq (1+\\epsilon)/2</span> . Then the probability that  <span class="math">\\mathcal{A}</span> , when executed in a  <span class="math">\\Delta</span> -semisynchronous environment, makes  <span class="math">\\pi_{SPoS}</span>  violate the common prefix property with parameter k throughout a period of R slots is no more than  <span class="math">\\exp(\\ln R + \\Delta - \\Omega(k))</span> . The constant hidden by the  <span class="math">\\Omega(\\cdot)</span> -notation depends on  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Observe that an execution of protocol  <span class="math">\\pi_{SPoS}</span>  violates the common prefix property with parameter k precisely when the  <span class="math">\\Delta</span> -fork F induced by this execution has  <span class="math">\\operatorname{div}_{\\Delta}(F) \\geq k</span> . We have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\operatorname{div}_{\\Delta}(F) \\geq k] \\leq \\Pr_{\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}}[\\operatorname{div}_{\\Delta}(w) \\geq k] \\leq \\Pr_{\\mathcal{D}_{\\alpha}^{f}}[\\operatorname{div}_{\\Delta}(w) \\geq k] \\leq \\exp(\\ln R - \\Omega(k - \\Delta))</span>$</p>

    <p class="text-gray-300">where the first inequality follows from the definition of  <span class="math">\\operatorname{div}_{\\Delta}(\\cdot)</span> ; the second one holds since  <span class="math">\\mathcal{D}^f_{\\mathcal{Z},\\mathcal{A}} \\preceq \\mathcal{D}^f_{\\alpha}</span>  and the set</p>

    <p class="text-gray-300"><span class="math">$D_{\\Delta} = \\{ x \\mid \\operatorname{div}_{\\Delta}(x) \\ge k \\}</span>$</p>

    <p class="text-gray-300">is monotone; and the last one follows from Theorem 4. (For convenience, we have moved the  <span class="math">\\Delta</span>  outside the asymptotic notation, which only makes the bound weaker as the hidden constant is less than 1.)</p>

    <p class="text-gray-300">As for Chain Growth, this follows directly from Theorem 5.</p>

    <p class="text-gray-300"><strong>Theorem 8 (Honest-Bounded Chain Growth).</strong> Let  <span class="math">f \\in (0,1]</span> ,  <span class="math">R, \\Delta \\in \\mathbb{N}</span> , and  <span class="math">\\alpha &gt; 0</span> . Let A be an  <span class="math">\\alpha</span> -dominated adversary against the protocol  <span class="math">\\pi_{SPoS}</span> . Then the probability that A, when executed in a  <span class="math">\\Delta</span> -semisynchronous environment, makes  <span class="math">\\pi_{SPoS}</span>  violate the Honest-Bounded Chain Growth with parameters  <span class="math">s \\geq 6(\\Delta + 1)</span>  and  <span class="math">\\tau = \\alpha f(1 - f)^{\\Delta + 1}/3</span>  over a period of R slots, is no more than  <span class="math">\\exp(-\\Omega(\\alpha s) + O(\\ln R))</span> , where the asymptotic notation hides constants that depend on  <span class="math">\\Delta</span>  and f.</p>

    <p class="text-gray-300">(A more exact expression for error may be read off from Theorem 5.)</p>

    <p class="text-gray-300"><em>Proof.</em> In light of the development of Section 4.4, we note that  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f \\preceq \\mathcal{D}_{\\alpha}^f</span> , where  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f</span>  is the distribution of characteristic strings generated by this adversary and environment. Let  <span class="math">G_{s,\\tau} = \\{w \\mid w \\text{ violates } (s,\\tau)\\text{-hcg}\\}</span> . By Lemma 2, this is a monotone set and the result follows from Theorem 5. Specifically,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathcal{A}, \\mathcal{Z} \\text{ violates } (s,\\tau)\\text{-HCG}] = \\Pr_{\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f}[w \\text{ violates } (s,\\tau)\\text{-hcg}] \\leq \\Pr_{\\mathcal{D}_{\\alpha}^f}[w \\text{ violates } (s,\\tau)\\text{-hcg}]\\,,</span>$</p>

    <p class="text-gray-300">as desired.</p>

    <p class="text-gray-300">Finally, we record the analogous result for Existential Chain Quality. Theorem 6 directly implies the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 9 (Existential Chain quality).</strong> Let  <span class="math">f \\in (0,1], R, \\Delta \\in \\mathbb{N}</span>  and  <span class="math">\\epsilon \\in (0,1)</span> . Let  <span class="math">\\mathcal{A}</span>  be an  <span class="math">\\alpha</span> -dominated adversary against the protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  for some  <span class="math">\\alpha &gt; 0</span>  satisfying  <span class="math">\\alpha(1-f)^{\\Delta+1} \\geq (1+\\epsilon)/2</span> . Then the probability that  <span class="math">\\mathcal{A}</span> , when executed in a  <span class="math">\\Delta</span> -semisynchronous environment, makes  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  violate Existential Chain Quality with parameter s over a period of R slots is no more than  <span class="math">\\exp(O(\\ln R) - \\Omega(s))</span> . Here the constants hidden by the asymptotic notation may depend on  <span class="math">\\epsilon</span> , f, and  <span class="math">\\Delta</span> .</p>

    <p class="text-gray-300">(A more exact expression for error may be read off from Theorem 6.)</p>

    <p class="text-gray-300"><em>Proof.</em> In light of the development of Section 4.4, we note that  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f \\preceq \\mathcal{D}_{\\alpha}^f</span> , where  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f</span>  is the distribution of characteristic strings generated by this adversary and environment. Let  <span class="math">Q_s = \\{w \\mid w \\text{ violates } s\\text{-}\\exists \\mathsf{cq}\\}</span> . By Lemma 2, this is a monotone set and the result follows from Theorem 5. Specifically,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathcal{A}, \\mathcal{Z} \\text{ violates } s\\text{-}\\exists \\mathsf{CQ}] = \\Pr_{\\mathcal{D}_{\\mathcal{Z}}^f}[w \\text{ violates } s\\text{-}\\exists \\mathsf{cq}] \\leq \\Pr_{\\mathcal{D}_{\\alpha}^f}[w \\text{ violates } s\\text{-}\\exists \\mathsf{cq}] \\,,</span>$</p>

    <p class="text-gray-300">as desired.</p>

      <h3 id="sec-4.8" class="text-xl font-semibold mt-8">4.8 Adaptive Adversaries</h3>

    <p class="text-gray-300">The statements in the previous sections give us guarantees on the common prefix, chain growth, and chain quality properties as long as the adversary is  <span class="math">\\alpha</span> -dominated for some suitable value of  <span class="math">\\alpha</span> . In Section 4.4 we argued that any <em>static</em> adversary that corrupts at most  <span class="math">(1-\\alpha)</span> -fraction of stake is  <span class="math">\\alpha</span> -dominated. In this section we extend this claim also to <em>adaptive</em> adversaries, showing that as long as they corrupt no more than  <span class="math">(1-\\alpha)</span> -fraction of stake adaptively throughout the whole execution, they are still  <span class="math">\\alpha</span> -dominated.</p>

    <p class="text-gray-300"><strong>Theorem 10.</strong> Every adaptive adversary A that corrupts at most  <span class="math">(1-\\alpha)</span> -fraction of stake throughout the whole execution is  <span class="math">\\alpha</span> -dominated.</p>

    <p class="text-gray-300">Proof (sketch). Let us start by taking a different (but equivalent) view on the choice of slot leaders in the execution of  <span class="math">\\pi_{SPoS}</span> . Assuming that we have a fixed number C of coins (corresponding to equally-sized units of stake), consider a family of independent, identically distributed Boolean random variables  <span class="math">\\{c_{t,i} \\mid 1 \\le t \\le R, 1 \\le i \\le C\\}</span>  such that for every  <span class="math">c_{t,i}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$c_{t,i} = \\begin{cases} 1 &amp; \\text{with probability } \\phi_f(1/C) = 1 - (1-f)^{1/C}, \\\\ 0 &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">We can view each of the random variables  <span class="math">c_{t,i}</span>  as being associated with a particular coin owned by one of the parties. These random variables provide an alternative view of the slot leader election process: the owner of coin i becomes a slot leader for slot t if  <span class="math">c_{t,i} = 1</span> . Thanks to the &quot;independent aggregation property&quot; (2), sampling the random variables  <span class="math">c_{t,i}</span>  yields a distribution on slot leaders equivalent to the method used by  <span class="math">\\pi_{\\text{SPoS}}</span> , i.e., switching to this method of assigning slot leaders does not affect  <span class="math">\\mathcal{D}_{Z,\\mathcal{A}}^f</span>  for any adversary  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">We now make the adversary stronger by allowing it to corrupt not only stakeholders, but individual coins. (Formally, we can see each stakeholder with stake  <span class="math">s_i</span>  as  <span class="math">s_i</span>  separate stakeholders where each controls a single coin; corrupting a coin then means corrupting such single-coin stakeholder. In particular, this means that after corrupting coin i in some slot t, the adversary also learns the values of the random variables  <span class="math">c_{t&#x27;,i}</span>  for all  <span class="math">t&#x27; \\geq t</span> .) To see that this only extends the class of considered adversaries, observe that any adversary  <span class="math">\\mathcal{A}</span>  corrupting stakeholders can be trivially modified into a coin-corrupting adversary  <span class="math">\\mathcal{A}_1</span>  that simply corrupts all the coins belonging to the stake of a player corrupted by  <span class="math">\\mathcal{A}</span> , maintaining  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f = \\mathcal{D}_{\\mathcal{Z},\\mathcal{A}_1}^f</span> .</p>

    <p class="text-gray-300">It is now important to observe that at any point during the execution, all the uncorrupted coins are identical from the perspective of the adversary due to symmetry. Therefore, for any coin-corrupting adversary  <span class="math">\\mathcal{A}_1</span>  one can construct another coin-corrupting adversary  <span class="math">\\mathcal{A}_2</span>  that achieves the same outcomes, but corrupts the coins according to some fixed ordering: whenever  <span class="math">\\mathcal{A}_1</span>  corrupts a new coin,  <span class="math">\\mathcal{A}_2</span>  instead corrupts the next coin in this ordering. The only difference this makes from the perspective of the adversary is that with any corruption of a coin in slot t, the index i of random variables  <span class="math">c_{t&#x27;,i}</span>  for  <span class="math">t&#x27; \\geq t</span> , that are disclosed to it, changes. However, all these variables are independent and identically distributed, hence we again have  <span class="math">\\mathcal{D}_{\\mathcal{Z}_i}^f</span> ,  <span class="math">\\mathcal{D}_{\\mathcal{Z}_i}^f</span> ,  <span class="math">\\mathcal{D}_{\\mathcal{Z}_i}^f</span> .</p>

    <p class="text-gray-300">independent and identically distributed, hence we again have  <span class="math">\\mathcal{D}_{Z,\\mathcal{A}_1}^f = \\mathcal{D}_{Z,\\mathcal{A}_2}^f</span> . Finally, consider a static adversary  <span class="math">\\mathcal{A}_3</span>  that corrupts the first  <span class="math">\\lfloor (1-\\alpha)C \\rfloor</span>  coins with respect to the ordering used by  <span class="math">\\mathcal{A}_2</span> . Then, during the execution, it acts exactly like  <span class="math">\\mathcal{A}_2</span>  would, except for corruptions; this is possible, since any coins corrupted by  <span class="math">\\mathcal{A}_2</span>  must be already corrupted by  <span class="math">\\mathcal{A}_3</span>  from the beginning. Note that if we consider the natural coupling of the two executions with  <span class="math">\\mathcal{A}_2</span>  and  <span class="math">\\mathcal{A}_3</span> ,</p>

    <p class="text-gray-300">where the same randomness is used, then the sets of coins chosen for slot leaders will be the same in both executions; and moreover, in each slot the set of coins corrupted by  <span class="math">\\mathcal{A}_3</span>  is a superset of those corrupted by  <span class="math">\\mathcal{A}_2</span> . This implies that  <span class="math">\\Pr[w^{(2)} \\leq w^{(3)}] = 1</span> , where  <span class="math">w^{(i)}</span>  is the random variable corresponding to the characteristic string resulting from the execution with  <span class="math">\\mathcal{A}_i</span> . Using Theorem 13 from Appendix E, this in turn implies  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}_2}^f \\leq \\mathcal{D}_{\\mathcal{Z},\\mathcal{A}_3}^f</span> . The proof is now concluded by observing that  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}_3}^f \\leq \\mathcal{D}_{\\alpha}^f</span>  follows from Section 4.4, since  <span class="math">\\mathcal{A}_3</span>  is static and corrupts at most  <span class="math">(1-\\alpha)</span> -share of the stake.</p>

    <p class="text-gray-300">Theorems 7, 8, 9 and 10 together give us the following corollary.</p>

    <p class="text-gray-300">Corollary 1. Let A be an adaptive adversary against the protocol  <span class="math">\\Pi_{SPoS}</span>  that corrupts at most  <span class="math">(1-\\alpha)</span> -fraction of stake. Then the bounds on common prefix, chain growth and chain quality given in Theorems 7, 8, 9 are satisfied for A.</p>

      <h3 id="sec-4.9" class="text-xl font-semibold mt-8">4.9 The Resettable Protocol</h3>

    <p class="text-gray-300">With the analysis of these basic structural events behind us, we remark that the same arguments apply to a modest generalization of the protocol which permits the adversary some control over the nonce. Specifically, we introduce a &quot;resettable&quot; initialization functionality  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^r</span> , which permits the adversary to select the random nonce from a family of r independent and uniformly random nonces. Specifically,  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^r</span>  is identical to  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span> , with the following exception:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving the first request of the form (genblock_req,  <span class="math">U_i</span> ) from some stakeholder  <span class="math">U_i</span> ,  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^r</span>  samples a nonce  <span class="math">\\eta \\overset{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$ , defines a &quot;nonce candidate&quot; set  <span class="math">H = \\{\\eta\\}</span> , and permits the adversary to carry out up to r-1 reset events: each reset event draws an independent element from  <span class="math">\\{0,1\\}^{\\lambda}</span> , adds the element to the set H, and permits the adversary to replace the current nonce  <span class="math">\\eta</span>  with any element of H. Finally, (genblock,  <span class="math">\\mathbb{S}_0</span> ,  <span class="math">\\eta</span> ) is sent to  <span class="math">U_i</span> . Later requests from any stakeholder are answered using the same value  <span class="math">\\eta</span> .</li>
    </ul>

    <p class="text-gray-300">Looking ahead, our reason to introduce the resettable functionality  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^r</span>  is to capture the limited grinding capabilities of the adversary. A simple application of the union bound shows that this selection of  <span class="math">\\eta</span>  from among a set of size r uniformly random candidate nonces can inflate the probability of events during the run of  <span class="math">\\pi_{\\mathsf{SPoS}}</span>  by a factor no more than r. We record this as a corollary below.</p>

    <p class="text-gray-300">Corollary 2 (Corollary to Theorems 7, 8, 9). The protocol  <span class="math">\\Pi_{SPoS}</span> , with initialization functionality  <span class="math">\\mathcal{F}_{INIT}^r</span> , satisfies the bounds of Theorems 7, 8, 9 with all probabilities scaled by r.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 The Full Protocol</h2>

    <p class="text-gray-300">In this section, we construct a protocol that handles the dynamic case, where the stake distribution changes as the protocol is executed. As in Ouroboros [KRDO17], we divide protocol execution in a number of independent epochs. Each epoch consists of R=24k/f slots (we will ignore rounding for readability) during which the stake distribution used for sampling slot leaders remains unchanged. The strategy we use to bootstrap the static protocol is, at a high level, similar: we first show how the protocol can accommodate dynamic stake utilizing an ideal &quot;leaky beacon&quot; functionality and then we show this beacon functionality can be simulated via an algorithm that collects randomness from the blockchain.</p>

    <p class="text-gray-300">In order to facilitate the implementation of our beacon, we need to allow the leaky beacon functionality to be adversarially manipulated by allowing a number of &quot;resets&quot; to be performed by the adversary. Specifically, the functionality is parameterized by values  <span class="math">\\tau</span>  and r. First, it leaks to the adversary, up to  <span class="math">\\tau</span>  slots prior to the end of an epoch, the beacon value for the next epoch. (Looking ahead, we remark that it is essential that the stake distribution used for sampling slot leaders in the next epoch is determined prior to this leakage.) Second, the adversary can reset the value returned by the functionality as many as r times. As expected for a beacon, it reports to honest parties the beacon value only once the next epoch starts. After the epoch is started no more resets are allowed for the beacon value. This mimics the functionality  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  and its resettable</p>

    <p class="text-gray-300">version  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^r</span> . Note that the ability of the adversary to reset the beacon can be quite influential in the protocol execution: for instance, any event that depends deterministically on the nonce of an epoch and happens with probability 1/2 can be easily forced to happen almost always by the adversary using a small number of resets.</p>

    <p class="text-gray-300">Naturally, we do not want to assume the availability of a randomness beacon in the final protocol, even if it is leaky and resettable. In our final iteration of the protocol we show how it is possible to simulate such beacon using a hash function that is modeled as a random oracle. This hash function is applied to the concatenation of VRF values that are inserted into each block during the first 16k/f slots of an epoch<sup>5</sup> that lasts 24k/f slots in entirety. (The &quot;quiet&quot; period of the final 8k/f slots in each epoch will ensure that the nonce is stable before the next epoch begins.) The verifiability of those values is a key property that we exploit in the proof.</p>

    <p class="text-gray-300">Our proof strategy is to reduce any adversary against the basic properties of the blockchain to a resettable-beacon adversary that will simulate the random oracle. The key point of this reduction is that whenever the random oracle adversary makes a query with a sequence of values that is a candidate sequence for determining the nonce for the next epoch, the resettable attacker detects this as a possible reset opportunity and resets the beacon; it obtains the response from the beacon and sets this as the answer to the random oracle query.</p>

    <p class="text-gray-300">The final issue is to bound the number of resets: towards this, note that the adversary potentially controls a constant fraction of the 16k/f slots associated with nonce selection, and this allows him to explore an a priori large space of independent random potential nonces (and, ultimately, select one as the next epoch nonce). The size of this space is however upper-bounded by the number of random oracle queries that the adversary can afford during the sequence of the middle 8k/f slots, which will contain at least one honest block. To formalize this bound we utilize the q-bounded model of [GKL15] that bounds the number of queries the adversary can pose per round: in that model, the adversary is allowed q queries per adversarial party per round (&quot;slot&quot; in our setting). Assuming that the adversary controls t parties, we obtain a rough bound of 8qtk/f.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 The Dynamic Stake Case with a Resettable Leaky Beacon</h3>

    <p class="text-gray-300">First we construct a protocol for the dynamic stake case assuming access to a resettable leaky beacon that provides a fresh nonce for each epoch. This beacon is leaky in the sense that it allows the adversary to obtain the nonce for the next epoch before the epoch starts, and resettable in the sense that it allows the adversary to reset the nonce a number of times. We model the resettable leaky randomness beacon in functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  presented in Figure 8.</p>

    <p class="text-gray-300">leaky randomness beacon in functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  presented in Figure 8. We now describe protocol  <span class="math">\\pi_{\\text{DPoS}}</span> , which is a modified version of  <span class="math">\\pi_{\\text{SPoS}}</span>  that updates its genesis block  <span class="math">B_0</span>  (and thus the assignment of slot leader sets) for every new epoch. The protocol also adopts an adaptation of the static maxvalid<sub>S</sub> function, defined so that it narrows selection to those chains which share common prefix. Specifically, it adopts the following rule, parametrized by a prefix length k:</p>

    <p class="text-gray-300">Function  <span class="math">\\mathsf{maxvalid}(\\mathcal{C},\\mathbb{C})</span> . Returns the longest chain from  <span class="math">\\mathbb{C} \\cup \\{\\mathcal{C}\\}</span>  that does not fork from  <span class="math">\\mathcal{C}</span>  more than k blocks (i.e., not more than k blocks of  <span class="math">\\mathcal{C}</span>  are discarded). If multiple exist it returns  <span class="math">\\mathcal{C}</span> , if this is one of them, or it returns the one that is listed first in  <span class="math">\\mathbb{C}</span> .</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  is described in Figure 9 and functions in the  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> -hybrid model.</p>

    <p class="text-gray-300">Lazy players. Note that while the protocol  <span class="math">\\pi_{\\text{DPoS}}</span>  in Figure 9 is stated for a stakeholder that is permanently online, this requirement can be easily relaxed. Namely, it is sufficient for an honest stakeholder to join at the beginning of each epoch, determine whether she belongs to the slot leader set for any slots within this epoch (using the Eval interface of  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> ), and then come online and act on those slots while maintaining online presence at least every k slots. We sketch this variant of the protocol in Appendix H.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup> To simplify notation, our protocol description mandates inserting these values into all created blocks, however it is clearly sufficient to do this only for blocks in the first 16k/f slots of each epoch.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> Note that we utilize the q-bounded model only to provide a more refined analysis; given that the total length of the execution is polynomial in  <span class="math">\\lambda</span>  one may also use the total execution length as a bound.</p>

    <h3 id="sec-misc-7" class="text-xl font-semibold mt-8">Functionality <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span></h3>

    <p class="text-gray-300"> <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  incorporates the diffuse functionality from Section 2.1 and is parameterized by the number of initial stakeholders n and their respective stakes  <span class="math">s_1, \\ldots, s_n</span> , a nonce leakage parameter  <span class="math">\\tau</span>  and a number of allowed resets r.  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span>  interacts with stakeholders  <span class="math">U_1,\\ldots,U_n</span>  and an adversary  <span class="math">\\mathcal{A}</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">In the first round,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  operates exactly as  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span> .</p></li>
      <li><p class="text-gray-300">Upon receiving (genblock_req, sid,  <span class="math">U_i</span> ) from stakeholder  <span class="math">U_i</span>  it operates as functionality  <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>  on</p></li>
      <li><p class="text-gray-300">For every epoch j, at slot  <span class="math">jR \\tau</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  samples the next epoch's nonce  <span class="math">\\eta_{j+1} \\stackrel{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$  and leaks it by sending (epochrnd_leak, sid, j,  <span class="math">\\eta_{j+1}</span> ) to the adversary  <span class="math">\\mathcal{A}</span> . Additionally,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  sets an internal reset request counter resets = 0 and sets  <span class="math">\\mathbb{P} = \\emptyset</span> .</p></li>
      <li><p class="text-gray-300">Upon receiving (epochrnd_req, sid,  <span class="math">U_i</span> , j) from stakeholder  <span class="math">U_i</span> , if  <span class="math">j \\geq 2</span>  is the current epoch,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> sends (epochrnd, sid,  <span class="math">\\eta_i</span> ) to  <span class="math">U_i</span> .</p></li>
      <li><p class="text-gray-300">Upon receiving (epochrnd_reset, sid, A) from A at epoch j, if resets &lt; r and if the current slot is past slot  <span class="math">jR - \\tau</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  samples a fresh nonce for the next epoch  <span class="math">\\eta_{j+1} \\stackrel{\\</span>}{\\leftarrow} {0,1}^{\\lambda}$  and leaks it by sending (epochrnd_leak, sid,  <span class="math">\\eta_{j+1}</span> ) to  <span class="math">\\mathcal{A}</span> . Finally,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  increments resets and adds  <span class="math">\\eta_{j+1}</span>  to  <span class="math">\\mathbb{P}</span> .</p>

    <p class="text-gray-300">Upon receiving (epochrnd_set, sid,  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\eta</span> ) from  <span class="math">\\mathcal{A}</span>  at epoch j, if the current slot is past slot  <span class="math">jR - \\tau</span></p></li>
      <li><p class="text-gray-300">and if  <span class="math">\\eta \\in \\mathbb{P}</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  sets  <span class="math">\\eta_{j+1} = \\eta</span>  and sends (epochrnd_leak, sid,  <span class="math">\\eta_{j+1}</span> ) to  <span class="math">\\mathcal{A}</span> .</p></li>
    </ul>

    <p class="text-gray-300">Fig. 8: The resettable leaky beacon Functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> .</p>

    <p class="text-gray-300">We proceed to the security analysis of the full protocol in the hybrid world where the functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  is available to the protocol participants. A key challenge is that in the dynamic stake setting, the honest majority assumption that we have in place refers to the stakeholder view of the honest stakeholders in each slot. Already in the first few slots this assumption may diverge rapidly from the stakeholder distribution that is built-in the genesis block.</p>

    <p class="text-gray-300">To accommodate the issues that will arise from the movement of stake throughout protocol execution, we recall the notion of stake shift defined in [KRDO17].</p>

    <p class="text-gray-300"><strong>Definition 15.</strong> Consider two slots  <span class="math">sl_1, sl_2</span>  and an execution  <span class="math">\\mathcal{E}</span> . The stake shift between  <span class="math">sl_1, sl_2</span>  is the maximum possible statistical distance of the two weighted-by-stake distributions that are defined using the stake reflected in the chain  <span class="math">\\mathcal{C}_1</span>  of some honest stakeholder active at  <span class="math">\\mathsf{sl}_1</span>  and the chain  <span class="math">\\mathcal{C}_2</span> of some honest stakeholder active at  <span class="math">sl_2</span> .</p>

    <p class="text-gray-300">Finally, the security of  <span class="math">\\pi_{DPoS}</span>  is stated below. We slightly abuse the notation from previous sections and denote by  <span class="math">\\alpha_{\\mathcal{H}}</span>  a lower bound on the honest stake ratio throughout the whole execution.</p>

    <p class="text-gray-300">Theorem 11 (Security of  <span class="math">\\pi_{DPoS}</span>  with access to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> ). Fix parameters  <span class="math">k, R, \\Delta, L \\in \\mathbb{N}, \\epsilon, \\sigma \\in</span> (0,1) and r. Let R=24k/f be the epoch length, L the total lifetime of the system, and</p>

    <p class="text-gray-300">
<span class="math">$(\\alpha_{\\mathcal{H}} - \\sigma)(1 - f)^{\\Delta} \\ge (1 + \\epsilon)/2. \\tag{15}</span>$</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{DPoS}</span> , with access to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> , with  <span class="math">\\tau \\leq 8k/f</span>  satisfies persistence with parameters k and liveness with parameters u = 8k/f throughout a period of L slots of  <span class="math">\\Delta</span> -semisynchronous execution with probability  <span class="math">1 - \\exp(\\ln L + \\Delta + \\log(r) - \\Omega(k))</span>  assuming that  <span class="math">\\sigma</span>  is the maximum stake shift over 2R slots.</p>

    <p class="text-gray-300"><em>Proof (sketch)</em>. We first observe that due to the conditions imposed on the leakiness of the  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> oracle, its level of resettability, and the domination of honest stake even after the stake shift is taken into account, Corollary 2 still applies for the whole execution over L slots. The critical observation is the fact that the stakeholder distribution is determined in each epoch i &gt; 2 by the block that has time stamp up to (j-2)R. Since  <span class="math">R \\geq 16k/f</span>  and  <span class="math">\\tau \\leq 8k/f</span>  it holds that at least  <span class="math">R-\\tau \\geq 8k/f</span>  slots will pass before the leaky beacon releases the random value of the next epoch. By applying the chain growth theorem with s = 8k/f we obtain that, except with error  <span class="math">\\exp\\left(-f(1-f)^{\\Delta}\\alpha s/(20\\Delta) + \\ln L\\Delta + O(1)\\right) = \\exp\\left(-\\Omega(k) + \\ln L + \\ln \\Delta\\right)</span>  the chain will grow</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> While  <span class="math">\\pi_{\\rm DPoS}</span>  fixes R = 24k/f, for Theorem 11 it is sufficient to assume  <span class="math">R \\geq 16k/f</span> , and hence we only use this weaker assumption in the proof.</p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Protocol <span class="math">\\pi_{\\mathrm{DPoS}}</span></h4>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\text{DPoS}}</span>  is run by stakeholders, initially equal to  <span class="math">U_1, \\ldots, U_n</span>  interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  (or  <span class="math">\\mathcal{F}_{\\text{INIT}}</span> ),  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> ,  <span class="math">\\mathcal{F}_{\\text{KES}}</span> ,  <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> , H over a sequence of L = ER slots  <span class="math">S = \\{1, \\ldots, L\\}</span>  consisting of E epochs with R = 24k/f slots each. Define  <span class="math">T_i^j \\triangleq 2^{\\ell_{\\text{VRF}}} \\phi_f(\\alpha_i^j)</span>  as the threshold for a stakeholder  <span class="math">U_i</span>  for epoch  <span class="math">e_j</span> , where  <span class="math">\\alpha_i^j</span>  is the relative stake of stakeholder  <span class="math">U_i</span>  at epoch  <span class="math">e_j</span> ,  <span class="math">\\ell_{\\text{VRF}}</span>  denotes the output length of  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> , f is the active slots coefficient and  <span class="math">\\phi_f</span>  is the mapping from equation (1). Then  <span class="math">\\pi_{\\text{DPoS}}</span>  proceeds as follows for each stakeholder  <span class="math">U_i</span> :</p>

    <p class="text-gray-300">1. <strong>Initialization.</strong> This step is the same as Step 1 in  <span class="math">\\pi_{SPoS}</span>  except that any messages for  <span class="math">\\mathcal{F}_{INIT}</span>  are sent to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  if it is available instead.</p>

    <p class="text-gray-300">After initialization, for every slot  <span class="math">\\mathsf{sl}_{\\mathsf{now}} \\in S</span> , every online stakeholder  <span class="math">U_i</span>  performs the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>2. <strong>Epoch Update.</strong> If a new epoch  <span class="math">e_{j^*}</span> , with  <span class="math">j^* \\geq 2</span> , has started,  <span class="math">U_i</span>  defines  <span class="math">\\mathbb{S}_{j^*}</span>  to be the stakeholder distribution drawn from the most recent block with time stamp up to (j-2)R as reflected in  <span class="math">\\mathcal{C}</span>  and sends (epochrnd_req, sid,  <span class="math">U_i</span> ,  <span class="math">e_{j^*}</span> ) to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> , receiving (epochrnd, sid,  <span class="math">\\eta_{j^*}</span> ) as answer.</li>
      <li>3. Chain Update.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">U_i</span>  collects all valid chains received via diffusion into a set  <span class="math">\\mathbb{C}</span> , verifying that for every chain  <span class="math">\\mathcal{C}&#x27; \\in \\mathbb{C}</span> , every block  <span class="math">B = (st, d, \\mathsf{sl}, crt, \\rho, \\sigma) \\in \\mathcal{C}&#x27;</span>  with  <span class="math">crt = (U_s, y, \\pi) \\ \\rho = (y_\\rho, \\pi_\\rho)</span> , and  <span class="math">\\mathsf{sl}</span>  belonging to some epoch  <span class="math">e_j</span>  satisfies:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i)  <span class="math">sl \\leq sl_{now}</span>  and  <span class="math">y &lt; T_s^j</span> ,</li>
      <li>(ii)  <span class="math">\\mathcal{F}_{VRF}</span>  answers (Verify, sid,  <span class="math">\\eta_i \\parallel sl \\parallel TEST</span> , y,  <span class="math">\\pi</span> ,  <span class="math">v_s^{vrf}</span> ) by (Verified, sid,  <span class="math">\\eta \\parallel sl \\parallel TEST</span> , y,  <span class="math">\\pi</span> , 1);</li>
      <li>(iii)  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  answers (Verify, sid,  <span class="math">\\eta_j \\parallel \\mathsf{sl} \\parallel \\mathsf{NONCE}, y_\\rho, \\pi_\\rho, v_s^{\\mathsf{vrf}}</span> ) by responding with (Verified, sid,  <span class="math">\\eta_j \\parallel \\mathsf{sl} \\parallel \\mathsf{NONCE}, y_\\rho, \\pi_\\rho, 1</span> );</li>
      <li>(iv)  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  answers (Verify, sid,  <span class="math">(st, d, \\mathsf{sl}, crt, \\rho)</span> ,  <span class="math">\\mathsf{sl}, \\sigma, v_s^{\\mathsf{kes}}</span> ) by (Verified, sid,  <span class="math">(st, d, \\mathsf{sl}, crt, \\rho)</span> ,  <span class="math">\\mathsf{sl}, 1</span> ).</li>
    </ul></li>
      <li>(b)  <span class="math">U_i</span>  computes  <span class="math">\\mathcal{C} := \\mathsf{maxvalid}(\\mathcal{C}, \\mathbb{C})</span>  and sets  <span class="math">\\mathcal{C}</span>  as the new local chain.</li>
    </ul></li>
      <li>4. Chain Extension.  <span class="math">U_i</span>  receives from the environment the transaction data  <span class="math">d^* \\in \\{0,1\\}^*</span>  to be inserted into the blockchain, and performs the following steps:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">U_i</span>  sends (EvalProve, sid,  <span class="math">\\eta_{j^*} \\parallel \\mathsf{sl}_{\\mathsf{now}} \\parallel \\mathsf{NONCE})</span>  to  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> , obtaining (Evaluated, sid,  <span class="math">y_\\rho</span> ,  <span class="math">\\pi_\\rho</span> ),</li>
      <li>(b)  <span class="math">U_i</span>  sends (EvalProve, sid,  <span class="math">\\eta_{i*}</span>  | | sl<sub>now</sub> | TEST) to  <span class="math">\\mathcal{F}_{VRF}</span> , receiving (Evaluated, sid, y,  <span class="math">\\pi</span> ).</li>
      <li>(c)  <span class="math">U_i</span>  checks whether  <span class="math">y &lt; T_i^{j^*}</span> . If yes, it chooses a maximal sequence d' of transactions in  <span class="math">d^*</span>  such that adding a block with d' to  <span class="math">\\mathcal C</span>  results in a valid chain, and attempts to include d' as follows: It generates a new block  <span class="math">B = (st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt, \\rho, \\sigma)</span>  where  <span class="math">st = \\mathsf{H}(\\mathsf{head}(\\mathcal C))</span> ,  <span class="math">crt = (U_i, y, \\pi)</span> ,  <span class="math">\\rho = (y_\\rho, \\pi_\\rho)</span>  and  <span class="math">\\sigma</span>  is a signature obtained by sending (USign, sid,  <span class="math">U_i</span> ,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt, \\rho)</span> ,  <span class="math">\\mathsf{sl}_{\\mathsf{now}}</span> ) to  <span class="math">\\mathcal F_{\\mathsf{KES}}</span>  and receiving (Signature, sid,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathsf{now}}, crt, \\rho)</span> ,  <span class="math">\\mathsf{sl}_{\\mathsf{now}}, \\sigma)</span> .  <span class="math">U_i</span>  computes  <span class="math">\\mathcal C = \\mathcal C \\parallel B</span> , sets it as the new local chain and diffuses  <span class="math">\\mathcal C</span> .</li>
    </ul></li>
      <li>5. Signing Transactions. This step is the same as Step 4 in  <span class="math">\\pi_{SPoS}</span> .</li>
    </ul>

    <p class="text-gray-300">Fig. 9: Protocol  <span class="math">\\pi_{DPoS}</span></p>

    <p class="text-gray-300">by  <span class="math">f(1-f)^{\\Delta}\\alpha_{\\mathcal{H}}/4 \\cdot s \\geq (1+\\epsilon)/8 \\cdot s \\geq k</span>  blocks in that period of slots and thus the stakeholder distribution is completely determined prior to the leaky beacon releasing the random value of the next epoch. Based on the above, we observe that any violation of persistence in the execution with parameter k results in the violation of common prefix with parameter k. Applying a union bound, we obtain an error of  <span class="math">\\exp(\\ln L + \\Delta + \\log(r) - \\Omega(k))</span> .</p>

    <p class="text-gray-300">We then examine liveness. Consider any transaction that is provided to the honest parties for a sequence of u = 8k/f slots. It will follow as before that by chain growth the chain will grow by k blocks in this interval, and by the chain quality property this means that at least one honest block will be added and hence this block will contain the transaction posted.</p>

    <p class="text-gray-300">Note that while Theorem 11 (and also Corollary 3 below) formulates the bound (15) in terms of the <em>overall</em> upper bound on honest stake ratio  <span class="math">\\alpha_{\\mathcal{H}}</span>  and <em>maximum</em> stake shift  <span class="math">\\sigma</span>  over any 2R-slots interval, one could easily prove more fine-grained statements that would only require inequality (15) to hold for each epoch (with respect to the honest stake ratio in that epoch, and the stake shift occurring for that epoch's stake distribution).</p>

    <p class="text-gray-300">In this section, we show how to substitute the oracle  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  of protocol  <span class="math">\\pi_{\\text{DPoS}}</span>  with a subprotocol  <span class="math">\\pi_{RLB}</span>  that simulates  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> . The resulting protocol can then operate directly in the  <span class="math">\\mathcal{F}_{\\text{INIT}}</span> -hybrid</p>

    <p class="text-gray-300">model as in Section 3 (without resets) while utilizing a random oracle  <span class="math">H(\\cdot)</span> . The sub-protocol  <span class="math">\\pi_{RLB}</span>  is described in Figure 10.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Protocol <span class="math">\\pi_{RLB}</span></h4>

    <p class="text-gray-300">Let  <span class="math">H(\\cdot)</span>  be a random oracle.  <span class="math">\\pi_{RLB}</span>  is a sub-protocol of  <span class="math">\\pi_{DPoS}</span>  proceeding as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving (epochrnd_req, sid,  <span class="math">U_i</span> ,  <span class="math">e_{j^*}</span> ) from stakeholder  <span class="math">U_i</span> , if  <span class="math">e_{j^*} \\geq 2</span>  is the current epoch, it performs the following: for every block  <span class="math">B&#x27; = (st&#x27;, d&#x27;, \\mathsf{sl}&#x27;, crt&#x27;, \\rho&#x27;, \\sigma_{j&#x27;}) \\in \\mathcal{C}</span>  (where  <span class="math">\\mathcal{C}</span>  is the callee's  <span class="math">U_i</span> 's internal chain) belonging to epoch  <span class="math">e_{j^*-1}</span>  up to the slot with timestamp up to  <span class="math">(j^*-2)R+16k/f</span> , concatenate the values  <span class="math">y&#x27;_\\rho</span>  from each  <span class="math">\\rho&#x27; = (y&#x27;_\\rho, \\pi&#x27;_\\rho)</span>  into a value v. Compute  <span class="math">\\eta_j = \\mathsf{H}(\\eta_{j-1}||j||v)</span>  and return (epochrnd, sid,  <span class="math">\\eta_j</span> ).</li>
    </ol>

    <p class="text-gray-300">Fig. 10: Protocol  <span class="math">\\pi_{RLB}</span> .</p>

    <p class="text-gray-300">We will show next that the sub-protocol  <span class="math">\\pi_{RLB}</span>  can safely substitute  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  when called from protocol  <span class="math">\\pi_{\\text{DPoS}}</span> . We will perform our analysis in the q-bounded model of [GKL15] assuming that the adversary is capable of issuing q queries per round of protocol execution per corrupted party and there are t corrupted parties.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Consider the event of violating one of common prefix, chain quality, chain growth in an execution of  <span class="math">\\pi_{DPoS}</span>  using sub-protocol  <span class="math">\\pi_{RLB}</span>  in the  <span class="math">\\mathcal{F}_{INIT}</span> -hybrid model with adversary  <span class="math">\\mathcal{A}</span>  and environment  <span class="math">\\mathcal{Z}</span>  with the same parameter choices as Theorem 11. We construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  so that the corresponding event happens with the same probability in an execution of  <span class="math">\\pi_{DPoS}</span>  in the  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> -hybrid world with adversary  <span class="math">\\mathcal{A}&#x27;</span>  and environment  <span class="math">\\mathcal{Z}</span>  assuming that r=8tqk/f.</p>

    <p class="text-gray-300">Proof (sketch). The adversary  <span class="math">\\mathcal{A}&#x27;</span>  simulates  <span class="math">\\mathcal{A}</span>  by maintaining locally the table for the random oracle  <span class="math">\\mathsf{H}(\\cdot)</span> . The key point in the simulation of  <span class="math">\\mathcal{A}</span>  is to detect when is appropriate for  <span class="math">\\mathcal{A}&#x27;</span>  to issue a reset query to its  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  oracle. Specifically, a reset query will be triggered whenever  <span class="math">\\mathcal{A}</span>  queries  <span class="math">\\mathsf{H}(\\cdot)</span>  with concatenated valid VRF values  <span class="math">\\eta_{j-1} \\parallel j \\parallel y_{\\rho}^{(i)} \\parallel \\cdots \\parallel y_{\\rho}^{(i&#x27;)}</span>  that are drawn from a valid chain and, specifically, from the first block of epoch  <span class="math">e_{j-1}</span>  to a block of that epoch with time stamp between 8k/f and 16k/f after the epoch start. We observe that by chain growth and chain quality at least one honest block in the middle 8k/f slots of an epoch will be included in the chain of all honest parties and contribute to the calculation of the hash. Finally, when the epoch  <span class="math">e_{j-1}</span>  reaches an end,  <span class="math">\\mathcal{A}&#x27;</span>  will issue (epochrnd_set, w) query to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  to set the value of the beacon to the correct value w of the  <span class="math">\\mathsf{H}(\\cdot)</span>  table as it has been determined by the chain that is on the common prefix that consists of all the blocks of the epoch that contains blocks produced in the first 16k/f slots of the epoch. Note that the event that the  <span class="math">\\eta_{j-1} \\parallel j \\parallel y_{\\rho}^{(i)} \\parallel \\cdots \\parallel y_{\\rho}^{(i&#x27;)}</span>  sequence corresponding to that chain in the common prefix was never queried to  <span class="math">\\mathsf{H}(\\cdot)</span>  happens with negligible probability.</p>

    <p class="text-gray-300">Based on the above lemma, it is now easy to revisit Theorem 11, and show that the same result holds when using  <span class="math">\\mathcal{F}_{\\text{INIT}}</span>  and  <span class="math">\\pi_{RLB}</span>  instead of  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> , assuming the q-bounded model, r = 8tkq/f and  <span class="math">\\tau \\leq 8k/f</span> .</p>

    <p class="text-gray-300">Corollary 3 (Security of  <span class="math">\\pi_{\\text{DPoS}}</span>  with subprotocol  <span class="math">\\pi_{RLB}</span> ). Fix parameters  <span class="math">k, R, \\Delta, L \\in \\mathbb{N}, \\epsilon, \\sigma \\in (0,1)</span> . Let R = 24k/f be the epoch length, L the total lifetime of the system, and  <span class="math">(\\alpha_{\\mathcal{H}} - \\sigma)(1-f)^{\\Delta} \\geq (1+\\epsilon)/2</span> . The protocol  <span class="math">\\pi_{\\text{DPoS}}</span>  using subprotocol  <span class="math">\\pi_{RLB}</span>  in the  <span class="math">\\mathcal{F}_{\\text{INIT}}</span> -hybrid model satisfies persistence with parameters k and liveness with parameters u = 8k/f throughout a period of L slots of  <span class="math">\\Delta</span> -semisynchronous execution with probability  <span class="math">1 - \\exp(\\ln L + \\Delta - \\Omega(k - \\log tkq))</span>  assuming that  <span class="math">\\sigma</span>  is the maximum stake shift over 2R slots.</p>

    <p class="text-gray-300">Acknowledgement. We thank Leonid Reyzin and the Horizen team for pointing out a bug in our earlier implementation of  <span class="math">\\mathcal{F}_{VRF}</span> . We also thank Christian Badertscher, Nicolas Frisby, Vanishree Rao, and the anonymous reviewers for several useful suggestions improving the presentation of the paper.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">BGK<sup>+</sup>18. Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang, editors, ACM CCS 2018, pages 913&ndash;930. ACM Press, October 2018.</p></li>
      <li><p class="text-gray-300">BGM14. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. CoRR, abs/1406.5694, 2014.</p></li>
      <li><p class="text-gray-300">BGM16. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. In Jeremy Clark, Sarah Meiklejohn, Peter Y. A. Ryan, Dan S. Wallach, Michael Brenner, and Kurt Rohloff, editors, FC 2016 Workshops, volume 9604 of LNCS, pages 142&ndash;157. Springer, Heidelberg, February 2016.</p></li>
      <li><p class="text-gray-300">BLMR14. Iddo Bentov, Charles Lee, Alex Mizrahi, and Meni Rosenfeld. Proof of activity: Extending bitcoin's proof of work via proof of stake. SIGMETRICS Performance Evaluation Review, 42(3):34&ndash;37, 2014.</p></li>
      <li><p class="text-gray-300">BM99. Mihir Bellare and Sara K. Miner. A forward-secure digital signature scheme. In Michael J. Wiener, editor, CRYPTO'99, volume 1666 of LNCS, pages 431&ndash;448. Springer, Heidelberg, August 1999.</p></li>
      <li><p class="text-gray-300">Can04. Ran Canetti. Universally composable signature, certification, and authentication. In 17th IEEE Computer Security Foundations Workshop, (CSFW-17 2004), page 219. IEEE Computer Society, 2004.</p></li>
      <li><p class="text-gray-300">CEK<sup>+</sup>16. Jan Camenisch, Robert R. Enderlein, Stephan Krenn, Ralf K&uml;usters, and Daniel Rausch. Universal composition with responsive environments. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 807&ndash;840. Springer, Heidelberg, December 2016.</p></li>
      <li><p class="text-gray-300">CL07. Melissa Chase and Anna Lysyanskaya. Simulatable VRFs with applications to multi-theorem NIZK. In Alfred Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 303&ndash;322. Springer, Heidelberg, August 2007.</p></li>
      <li><p class="text-gray-300">Com14. The NXT Community. Nxt whitepaper. <a href="https://bravenewcoin.com/assets/Whitepapers/NxtWhitepaper-v122-rev4.pdf" target="_blank" rel="noopener noreferrer">https://bravenewcoin.com/assets/Whitepapers/</a> <a href="https://bravenewcoin.com/assets/Whitepapers/NxtWhitepaper-v122-rev4.pdf" target="_blank" rel="noopener noreferrer">NxtWhitepaper-v122-rev4.pdf</a>, July 2014.</p></li>
      <li><p class="text-gray-300">DLS88. Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288&ndash;323, 1988.</p></li>
      <li><p class="text-gray-300">DP07. Yevgeniy Dodis and Prashant Puniya. Feistel networks made public, and applications. In Moni Naor, editor, EUROCRYPT 2007, volume 4515 of LNCS, pages 534&ndash;554. Springer, Heidelberg, May 2007.</p></li>
      <li><p class="text-gray-300">DPS19. Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconfigurable consensus and applications to provably secure proof of stake. In Ian Goldberg and Tyler Moore, editors, FC 2019, volume 11598 of LNCS, pages 23&ndash;41. Springer, Heidelberg, February 2019.</p></li>
      <li><p class="text-gray-300">DY05. Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416&ndash;431. Springer, Heidelberg, January 2005.</p></li>
      <li><p class="text-gray-300">GKL15. Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281&ndash;310. Springer, Heidelberg, April 2015.</p></li>
      <li><p class="text-gray-300">IR01. Gene Itkis and Leonid Reyzin. Forward-secure signatures with optimal signing and verifying. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 332&ndash;354. Springer, Heidelberg, August 2001.</p></li>
      <li><p class="text-gray-300">JKK14. Stanislaw Jarecki, Aggelos Kiayias, and Hugo Krawczyk. Round-optimal password-protected secret sharing and T-PAKE in the password-only model. In Palash Sarkar and Tetsu Iwata, editors, ASIACRYPT 2014, Part II, volume 8874 of LNCS, pages 233&ndash;253. Springer, Heidelberg, December 2014.</p></li>
      <li><p class="text-gray-300">KKO77. T. Kamae, U. Krengel, and G. L. O'Brien. Stochastic inequalities on partially ordered spaces. Ann. Probab., 5(6):899&ndash;912, 12 1977.</p></li>
      <li><p class="text-gray-300">Kla00. Bernhard Klar. Bounds on tail probabilities of discrete distributions. Probab. Eng. Inf. Sci., 14(2):161&ndash;171, April 2000.</p></li>
      <li><p class="text-gray-300">KN12. Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. <a href="https://peercoin.net/assets/paper/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://peercoin.net/assets/paper/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">//peercoin.net/assets/paper/peercoin-paper.pdf</a>, August 2012.</p></li>
      <li><p class="text-gray-300">KP15. Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015. <a href="https://eprint.iacr.org/2015/1019" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2015/1019</a>.</p></li>
      <li><p class="text-gray-300">KRDO17. Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357&ndash;388. Springer, Heidelberg, August 2017.</p></li>
      <li><p class="text-gray-300">Lin09. Andrew Y. Lindell. Adaptively secure two-party computation with erasures. In Marc Fischlin, editor, CT-RSA 2009, volume 5473 of LNCS, pages 117&ndash;132. Springer, Heidelberg, April 2009.</p></li>
      <li><p class="text-gray-300">Mic16. Silvio Micali. ALGORAND: the efficient and democratic ledger. CoRR, abs/1607.01341, 2016.</p></li>
      <li><p class="text-gray-300">MR95. Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University Press, New York, NY, USA, 1995.</p></li>
      <li><p class="text-gray-300">Nak08. Satoshi Nakamoto. &quot;the proof-of-work chain is a solution to the byzantine generals' problem&quot;. The Cryptography Mailing List, https://www.mailarchive.com/cryptography@metzdowd.com/msg09997.html, November 2008.</p></li>
      <li><p class="text-gray-300">PS17. Rafael Pass and Elaine Shi. The sleepy model of consensus. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 380&ndash;409. Springer, Heidelberg, December 2017.</p></li>
      <li><p class="text-gray-300">PSs17. Rafael Pass, Lior Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. In Jean-S&eacute;bastien Coron and Jesper Buus Nielsen, editors, <em>EUROCRYPT 2017</em>, <em>Part II</em>, volume 10211 of <em>LNCS</em>, pages 643&ndash;673. Springer, Heidelberg, April / May 2017.</p></li>
      <li><p class="text-gray-300">PWH<sup>+</sup>17. Dimitrios Papadopoulos, Duane Wessels, Shumon Huque, Moni Naor, Jan V&#269;el&aacute;k, Leonid Reyzin, and Sharon Goldberg. Making NSEC5 practical for DNSSEC. Cryptology ePrint Archive, Report 2017/099, 2017. https://eprint.iacr.org/2017/099.</p></li>
      <li><p class="text-gray-300">RMKQ17. Alexander Russell, Cristopher Moore, Aggelos Kiayias, and Saad Quader. Forkable strings are rare. Cryptology ePrint Archive, Report 2017/241, 2017. https://eprint.iacr.org/2017/241.</p></li>
      <li><p class="text-gray-300">Str65. V. Strassen. The existence of probability measures with given marginals. <em>Ann. Math. Statist.</em>, 36(2):423&ndash;439, 04 1965.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Definitions</h2>

    <p class="text-gray-300">In this appendix, we present formal definitions of Verifiable Random Functions and Key Evolving Signature Schemes with Forward Security.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Verifiable Random Functions</h3>

    <p class="text-gray-300">We present formal definitions of Verifiable Random Functions from [DY05].</p>

    <p class="text-gray-300"><strong>Definition 16 (Verifiable Random Function).</strong> A function family  <span class="math">\\mathsf{F}.(\\cdot):\\{0,1\\}^\\ell \\to \\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span>  is a family of VRFs if there exist algorithms (Gen, Prove, Ver) such that (i.) Gen <span class="math">(1^k)</span>  outputs a pair of keys (VRF.pk, VRF.sk), (ii.) Prove<sub>VRF.sk</sub>(x) outputs a pair ( <span class="math">\\mathsf{F}_{\\mathsf{VRF.}sk}(x)</span> ,  <span class="math">\\pi_{\\mathsf{VRF.}sk}(x)</span> ), where  <span class="math">\\mathsf{F}_{\\mathsf{VRF.}sk}(x) \\in \\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span>  is the function value and  <span class="math">\\pi_{\\mathsf{VRF.}sk}(x)</span>  is the proof of correctness, and (iii.) Ver<sub>VRF.pk</sub> <span class="math">(x,y,\\pi_{\\mathsf{VRF.}sk}(x))</span>  verifies that  <span class="math">y=\\mathsf{F}_{\\mathsf{VRF.}sk}(x)</span>  using proof  <span class="math">\\pi_{\\mathsf{VRF.}sk}(x)</span> , outputting 1 if y is valid and 0 otherwise. Additionally, we require the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Uniqueness: no values (VRF.pk,  <span class="math">x, y, y&#x27;, \\pi_{VRF.sk}(x), \\pi_{VRF.sk}(x)&#x27;</span> ) can satisfy both</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathsf{Prove}_{\\mathsf{VRF}.pk}(x,y,\\pi_{\\mathsf{VRF}.sk}(x)) = 1 \\qquad and \\qquad \\mathsf{Prove}_{\\mathsf{VRF}.pk}(x,y&#x27;,\\pi_{\\mathsf{VRF}.sk}(x)&#x27;) = 1</span>$</p>

    <p class="text-gray-300">unless y = y'.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\textit{2. Provability: } if \\ y, \\pi_{\\mathsf{VRF}.sk}(x) = \\mathsf{Prove}_{\\mathsf{VRF}.sk}(x), \\ then \\ \\mathsf{Ver}_{\\mathsf{VRF}.pk}(x,y,\\pi_{\\mathsf{VRF}.sk}(x)) = 1.</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Pseudorandomness:</strong> for any PPT algorithm  <span class="math">A = (A_E, A_J)</span> , which runs for a total of s(k) steps when its first input is  <span class="math">1^k</span> , and does not query the Prove <span class="math">(\\cdot)</span>  oracle on x,</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[b = b&#x27; \\begin{vmatrix} (\\mathsf{VRF}.pk, \\mathsf{VRF}.sk) \\leftarrow \\mathsf{Gen}(1^k); \\\\ (x, A_{st}) \\leftarrow A_E^{\\mathsf{Prove}(\\cdot)}(\\mathsf{VRF}.pk); \\\\ y_0 = \\mathsf{F}_{\\mathsf{VRF}.sk}(x); y_1 \\leftarrow \\{0, 1\\}^{\\ell_{\\mathsf{VRF}}}; \\\\ b \\leftarrow \\{0, 1\\}; b&#x27; \\leftarrow A_J^{\\mathsf{Prove}(\\cdot)}(y_b, A_{st}) \\end{vmatrix} \\leq \\frac{1}{2} + negl(k).</span>$</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Digital Signatures and <span class="math">\\mathcal{F}_{\\mathsf{DSIG}}</span></h3>

    <p class="text-gray-300">In Figure 11, we present Functionality  <span class="math">\\mathcal{F}_{DSIG}</span>  as defined in [Can04], where it is also shown that EUF-CMA signature schemes realize  <span class="math">\\mathcal{F}_{DSIG}</span> . This functionality will be used to model signatures on transactions.</p>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6">Functionality FDSIG</h4>

    <p class="text-gray-300">FDSIG interacts with a signer U<sup>S</sup> and stakeholders U1, . . . , U<sup>n</sup> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key Generation. Upon receiving a message (KeyGen, sid, US) from a stakeholder US, hand (KeyGen, sid, US) to the adversary. Upon receiving (VerificationKey, sid, US, v) from the adversary, output (VerificationKey, sid, v) to Ui, and record the triple (sid, US, v).</li>
      <li>Signature Generation. Upon receiving a message (Sign, sid, US, m) from US, verify that (sid, US, v) is recorded for some sid . If not, then ignore the request. Else, send (Sign, sid, US, m) to the adversary. Upon receiving (Signature, sid, US, m, &sigma;) from the adversary, verify that no entry (m, &sigma;, v, 0) is recorded. If it is, then output an error message to U<sup>S</sup> and halt. Else, output (Signature, sid, m, &sigma;) to US, and record the entry (m, &sigma;, v, 0).</li>
      <li>Signature Verification. Upon receiving a message (Verify, sid, m, &sigma;, v&prime; ) from some stakeholder Ui, hand (Verify, sid, m, &sigma;, v&prime; ) to the adversary. Upon receiving (Verified, sid, m, &#981;) from the adversary do:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If v &prime; = v and the entry (m, &sigma;, v, 1) is recorded, then set f = 1. (This condition guarantees completeness: If the verification key v &prime; is the registered one and &sigma; is a legitimately generated signature for m, then the verification succeeds.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if v &prime; = v, the signer is not corrupted, and no entry (m, &sigma;&prime; , v, 1) for any &sigma; &prime; is recorded, then set f = 0 and record the entry (m, &sigma;, v, 0). (This condition guarantees unforgeability: If v &prime; is the registered one, the signer is not corrupted, and never signed m, then the verification fails.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, if there is an entry (m, &sigma;, v&prime; , f&prime; ) recorded, then let f = f &prime; . (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Else, let f = &#981; and record the entry (m, &sigma;, v&prime; , &#981;).</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Output (Verified, sid, m, f) to Ui.</p>

    <p class="text-gray-300">Fig. 11: Functionality FDSIG.</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Forward Secure Signatures Schemes</h3>

    <p class="text-gray-300">We present the formal definitions of key evolving signature schemes and forward security of <a href="#page-31-10">[BM99</a><a href="#page-31-11">,IR01]</a>.</p>

    <p class="text-gray-300">Definition 17 (Key Evolving Signature Schemes). A key evolving signature scheme KES = (Gen, Sign, Verify,Update) is a tuple of algorithms such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Gen(1<sup>k</sup> , T) is a probabilistic key generation algorithm that takes as input a security parameter 1 <sup>k</sup> and the total number of periods T, outputting a key pair (KES.sk1,KES.vk), where KES.vk is the verification key and KES.sk<sup>1</sup> is the initial signing key (we assume that the period j to which a signing key KES.sk<sup>j</sup> corresponds is encoded in the signing key itself ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>SignKES.sk<sup>j</sup> (m) is a probabilistic signing algorithm that takes as input a secret key KES.skkest for the time period j &le; T and a message m, outputting a signature &sigma;<sup>j</sup> on m for time period j (we assume that the period j for which a signature &sigma;<sup>j</sup> was generated is encoded in the signature itself ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>VerifyKES.vk(m, &sigma;<sup>j</sup> ) is a deterministic verification algorithm that takes as input a public key KES.vk, a message m and a signature &sigma;<sup>j</sup> , outputting 1 if &sigma;<sup>j</sup> is a valid signature on message m for time period j and 0 otherwise.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Update(KES.sk<sup>j</sup> ) is a probabilistic secret key update algorithm that takes as input a secret key KES.sk<sup>j</sup> for the current time period j and outputs a new secret key KES.skj+1 for time period j + 1. We define KES.sk<sup>T</sup> +1 as the empty string and set it as the output of Update(KES.sk<sup>T</sup> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Correctness: for every key pair (KES.sk1,KES.vk) &larr; Gen(1<sup>k</sup> , T), every message m and every time period j &le; T,</p>

    <p class="text-gray-300">VerifyKES.vk(m, SignKES.sk<sup>j</sup> (m)) = 1.</p>

    <p class="text-gray-300">Given a key evolving signature scheme, forward security is defined by a game that starts as the standard Chosen Message Attack (CMA) experiment but after a number of queries to the signing oracle allows the adversary to learn the signing key for the current time period. The adversary is successful if it can produce a valid signature on a message of its choice for an earlier time period. The experiment and forward security are formally defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 18 (Forward Security Experiment).</strong> A forger is a pair of algorithms  <span class="math">F = (F_{\\mathsf{cma}}, F_{\\mathsf{forge}})</span>  such that  <span class="math">F_{\\mathsf{cma}}</span>  has access to a signing oracle. For a key pair  <span class="math">(\\mathsf{KES}.vk, \\mathsf{KES}.sk_1) \\leftarrow \\mathsf{Gen}(1^k, T)</span> ,  <span class="math">F_{\\mathsf{cma}}</span>  is given  <span class="math">\\mathsf{KES}.vk</span>  and T and queries the signing oracle  <span class="math">q_{sig}</span>  times with adaptively chosen message and time period pairs, outputting the set of queried message and time period pairs CM, the set of corresponding signatures sign(CM) and a time period b. Given CM, sign(CM) and the signing key  <span class="math">\\mathsf{KES}.sk_b</span>  for time period b,  <span class="math">F_{\\mathsf{forge}}</span>  outputs  <span class="math">(m, \\sigma_j) \\leftarrow F_{\\mathsf{forge}}(CM, sign(CM), \\mathsf{KES}.sk_b)</span> . F is successful if  <span class="math">(m, j) \\notin CM</span> , j &lt; b and  <span class="math">\\mathsf{Verify}_{\\mathsf{KES}.vk}(m, \\sigma_j) = 1</span> . (The two components of F can communicate the necessary information, including T and b through CM.)</p>

    <p class="text-gray-300"><strong>Definition 19 (Forward Security).</strong> Let  <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span>  be the probability (over the random coins of KES and F) that F is successful in the forward security experiment of Definition 18. Let the function  <span class="math">\\mathbf{InSec}^{fwsig}(\\mathsf{KES}[k,T],t,q_sig)</span>  (the insecurity function) be the maximum of  <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span> , over all algorithms F that are restricted to running time t and  <span class="math">q_sig</span>  signature queries. A key evolving signature scheme KES is forward secure against an adversary that runs in time t and makes  <span class="math">q_sig</span>  signature queries if  <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span>  is negligible in k.</p>

    <p class="text-gray-300">We will follow the proof strategy of [Can04] to show that a construction based on a key evolving signature scheme (Definition 17) realizes  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> . Our construction  <span class="math">\\pi_{KES}</span>  is based on a key evolving signature scheme  <span class="math">\\mathsf{KES} = (\\mathsf{Gen}, \\mathsf{Sign}, \\mathsf{Verify}, \\mathsf{Update})</span> . The signature protocol  <span class="math">\\pi_{KES}</span>  is run between a stakeholder  <span class="math">U_S</span>  and stakeholders  <span class="math">U_1, \\ldots, U_n</span> , proceeding as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Key Generation:</strong> When  <span class="math">U_S</span>  receives an input (KeyGen, sid,  <span class="math">U_S</span> ), it runs  <span class="math">Gen(1^k, T)</span> , records the signing key (sid, KES.sk<sub>1</sub>,), sets counter  <span class="math">k_{ctr} = 1</span>  and outputs (VerificationKey, sid, KES.vk).</li>
      <li><strong>Signature and Update:</strong> When  <span class="math">U_S</span>  receives an input (Sign, sid,  <span class="math">U_S</span> , m, j) for a sid for which it has the signing key (sid,  <span class="math">U_S</span> , KES.sk<sub>kctr</sub>,) and that  <span class="math">k_{ctr} \\geq j \\leq T</span> . Otherwise, it ignores the input. First,  <span class="math">U_S</span>  performs the following steps until  <span class="math">k_{ctr} = j</span> : run Update(KES. <span class="math">sk_{kctr}</span> ) to obtain KES. <span class="math">sk_{kctr}</span> , securely erase KES. <span class="math">sk_{kctr}</span>  and increment  <span class="math">k_{ctr}</span> . Next, It runs Sign<sub>KES. <span class="math">sk_{kctr}</span> </sub> (m) to obtain  <span class="math">\\sigma_{kctr}</span> , runs Update(KES. <span class="math">sk_{kctr}</span> ) to obtain KES. <span class="math">sk_{kctr}</span> +1, securely erases KES. <span class="math">sk_{kctr}</span> , outputs (Signature, sid, m,  <span class="math">k_{ctr}</span> ,  <span class="math">\\sigma_{kctr}</span> ) and increments  <span class="math">k_{ctr}</span> .</li>
      <li><strong>Verification:</strong> When a stakeholder  <span class="math">U_i</span>  receives an input (Verify,  <span class="math">sid, m, j, \\sigma_j</span> , KES.vk'), it outputs (Verified, sid, m, j, Verify<sub>KES.vk'</sub> <span class="math">(m, \\sigma_j)</span> ).</li>
    </ul>

    <p class="text-gray-300"><strong>Theorem 1</strong> The  <span class="math">\\pi_{KES}</span>  construction presented above, realizes  <span class="math">\\mathcal{F}_{KES}</span>  with erasures assuming KES = (Gen, Sign, Verify, Update) is a key evolving signature scheme with forward security as per Definition 17 and Definition 19.</p>

    <p class="text-gray-300"><em>Proof.</em> We follow the approach of [Can04] by showing that an environment  <span class="math">\\mathcal{Z}</span>  that distinguishes an ideal execution with a prescribed simulator  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  from a real execution with an adversary  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\pi_{KES}</span>  can be used to construct a forger for the underlying key evolving signature scheme  <span class="math">\\sigma</span>  that is successful in the forward security experiment of Definition 18 with non-negligible probability, thus contradicting the forward security guarantee of  <span class="math">\\sigma</span> . We argue that since  <span class="math">\\mathcal{Z}</span>  can distinguish the real world execution from the idea world execution for any  <span class="math">\\mathcal{Z}</span> , it will also succeed for an specific simulator  <span class="math">\\mathcal{S}</span> . Simulator  <span class="math">\\mathcal{S}</span>  runs an internal copy of  <span class="math">\\mathcal{A}</span> , proceeding as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\mathcal{S}</span>  forwards any inputs from  <span class="math">\\mathcal{Z}</span>  to  <span class="math">\\mathcal{A}</span>  and any outputs from  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{Z}</span> .</li>
      <li>Upon receiving (KeyGen, sid,  <span class="math">U_S</span> ) from  <span class="math">\\mathcal{F}_{KES}</span> ,  <span class="math">\\mathcal{S}</span>  runs  <span class="math">Gen(1^k, T)</span> , records the signing key (sid,  <span class="math">U_S</span> , KES.sk<sub>1</sub>,), sets counter  <span class="math">k_{ctr} = 1</span>  and sends (VerificationKey, sid,  <span class="math">U_S</span> KES.vk) to  <span class="math">\\mathcal{F}_{KES}</span> .</li>
      <li>&minus; Upon receiving (Signature, sid,  <span class="math">U_S</span> , j, m) from  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> ,  <span class="math">\\mathcal{S}</span>  checks that  <span class="math">\\mathsf{k}_{\\mathsf{ctr}} \\geq j \\leq T</span> . Otherwise, it ignores the request. First,  <span class="math">\\mathcal{S}</span>  performs the following steps until  <span class="math">\\mathsf{k}_{\\mathsf{ctr}} = j</span> : run Update(KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span> ) to obtain KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}+1}</span> , securely erase KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span>  and increment  <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span> . Next,  <span class="math">\\mathcal{S}</span>  runs Sign<sub>KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span> </sub> (m) to obtain  <span class="math">\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}}</span> , runs Update(KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span> ) to obtain KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}+1}</span> , securely erases KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span> , sends (Signature, sid,  <span class="math">U_S</span> , m,  <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span> ,  <span class="math">\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  and increments  <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span> .</li>
      <li>Upon receiving (Verify,  <span class="math">sid, m, j, \\sigma</span> , KES.vk') from  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> ,  <span class="math">\\mathcal{S}</span>  sends (Verified, sid, m, j, Verify<sub>KES.vk'</sub> <span class="math">(m, \\sigma_j)</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> .</li>
    </ul>

    <p class="text-gray-300">&ndash; When  <span class="math">\\mathcal{A}</span>  corrupts a party U',  <span class="math">\\mathcal{S}</span>  corrupts U' in the ideal world. If  <span class="math">U&#x27; = U_S</span>  (i.e. the signer),  <span class="math">\\mathcal{S}</span>  reveals the signing key KES. <span class="math">sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span>  and the internal state of Sign (if there's any) as the state of  <span class="math">U_t</span> .</p>

    <p class="text-gray-300">Given an environment  <span class="math">\\mathcal{Z}</span>  that distinguishes an ideal execution with simulator  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  from a real execution with  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\pi_{KES}</span> , we will construct a forger  <span class="math">F = (F_{\\mathsf{cma}}, F_{\\mathsf{forge}})</span>  for the underlying key evolving signature scheme  <span class="math">\\sigma</span> . Our forger F will run an internal copy of  <span class="math">\\mathcal{Z}</span> , simulating for  <span class="math">\\mathcal{Z}</span>  the interactions with  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  (i.e. acting as  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  towards  <span class="math">\\mathcal{Z}</span> ). Moreover, F will run an internal copy of  <span class="math">\\mathcal{A}</span>  as in the case of  <span class="math">\\mathcal{S}</span> .</p>

    <p class="text-gray-300">Forger F starts execution as  <span class="math">F_{\\mathsf{cma}}</span>  in the first phase of the forward security game (as per Definition 18), where it is given a verification key  <span class="math">\\mathsf{KES}.vk</span>  for total number of time periods T and has access to signing oracle. When F is activated, it gives  <span class="math">\\mathcal{A}</span>  the verification key  <span class="math">\\mathsf{KES}.vk</span>  obtained in the forward security experiment. Whenever F has to generate a signature as  <span class="math">\\mathcal{S}</span> , it calls its signing oracle with the given message and current  <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span> , which are added the set of queried message and time period pairs CM. The signatures obtained from the oracle are used in the answers of the simulated  <span class="math">\\mathcal{S}</span>  and added the set of signatures sign(CM) corresponding to CM. Whenever the internal  <span class="math">\\mathcal{Z}</span>  activates an uncorrupted party with (Verify, sid, m, j,  <span class="math">\\sigma</span> ,  <span class="math">\\mathsf{KES}.vk&#x27;</span> ), F tests whether  <span class="math">(m,j) \\notin CM</span> ,  <span class="math">\\mathsf{Verify}_{\\mathsf{KES}.vk&#x27;}(m,\\sigma_j)</span>  and  <span class="math">j &lt; \\mathsf{k}_{\\mathsf{ctr}}</span> . If this condition is met and the signer is not corrupted, the triple  <span class="math">(m,j,\\sigma)</span>  can be used by F to succeed in the forward security experiment. F outputs CM, sign(CM) and  <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>  ending the first phase of the forward security game. Next, acting as  <span class="math">F_{\\mathsf{forge}}</span>  in the forward security game, it outputs  <span class="math">(m,\\sigma_j)</span> , succeeding in the experiment. If  <span class="math">\\mathcal A</span>  corrupts the signer, F outputs  <span class="math">\\mathcal L</span>  and halts.</p>

    <p class="text-gray-300">Following the same reasoning as in [Can04], we argue that given the correctness property of  <span class="math">\\sigma</span> , the internal environment  <span class="math">\\mathcal{Z}</span>  would not issue a query (Verify,  <span class="math">sid, m, j, \\sigma, \\text{KES}.vk&#x27;</span> ), F such that  <span class="math">(m, j) \\notin CM</span> , Verify<sub>KES.vk'</sub> <span class="math">(m, \\sigma_j)</span>  and  <span class="math">j &lt; \\mathsf{k}_{\\mathsf{ctr}}</span>  in the case that the signer is not corrupted. If this query indeed does not happen,  <span class="math">\\mathcal{Z}</span>  would not be able to distinguish between an ideal and a real executions. However, this query happens with non-negligible probability since we assume that  <span class="math">\\mathcal{Z}</span>  does distinguish real from ideal executions. Moreover, notice that the interactions with  <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>  from the point of view of  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  are the same in a real world execution with  <span class="math">\\pi_{KES}</span> , guaranteeing that a forgery is obtained.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Realizing <span class="math">\\mathcal{F}_{VRF}</span></h2>

    <p class="text-gray-300">We provide an implementation of  <span class="math">\\mathcal{F}_{VRF}</span>  in the random oracle model. It makes use of a cyclic group  <span class="math">\\langle g \\rangle</span>  with a generator g, the description of which is assumed to be publicly known, and two hash functions H, H' with ranges  <span class="math">\\{0,1\\}^{\\ell_{VRF}}</span>  and  <span class="math">\\langle g \\rangle</span>  respectively, with  <span class="math">|\\langle g \\rangle| = q</span> . The implementation is based on the 2-Hash-DH verifiable oblivious PRF construction of [JKK14], and is basically identical to the construction of [PWH<sup>+</sup>17].</p>

    <p class="text-gray-300">Specifically, the public-key is equal to  <span class="math">v=g^k</span>  and the output is y=H(m,u) where  <span class="math">u=H&#x27;(m)^k</span> , while the proof is set to  <span class="math">\\pi=(u,\\operatorname{EQDL}(k:\\log_{H&#x27;(m)}(u)=\\log_g(v);m,v))</span> . The verification of  <span class="math">(m,y,\\pi,v)</span>  proceeds as follows. First it parses  <span class="math">\\pi</span>  as  <span class="math">(u,\\pi&#x27;)</span>  where  <span class="math">\\pi&#x27;</span>  is a proof of equality of discrete logarithms. It verifies y=H(m,u) as well as the proof  <span class="math">\\pi&#x27;</span>  and returns 1 if and only if both tests pass. The proof notation  <span class="math">\\operatorname{EQDL}(k:\\log_{H&#x27;(m)}(u)=\\log_g(v);m,v)</span>  stands for the string (c,s) where  <span class="math">c=H(m,u,v,g^r,H&#x27;(m)^r)</span> ,  <span class="math">s=r+kc \\mod q</span> , while the verification of (c,s) on context m,v is performed by checking the equality</p>

    <p class="text-gray-300"><span class="math">$c = H(m, u, v, g^s v^{-c}, H&#x27;(m)^s u^{-c}).</span>$</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> The 2Hash-DH construction presented above, realizes  <span class="math">\\mathcal{F}_{VRF}</span>  in the random oracle model assuming the CDH.</p>

    <p class="text-gray-300"><em>Proof.</em> We describe a simulator S that controls the random oracles H, H' and operates in the following manner.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving a message (KeyGen, sid,  <span class="math">U_i</span> ) from  <span class="math">\\mathcal{F}_{VRF}</span> , a new value  <span class="math">v = g^k</span>  is selected for a random k and  <span class="math">\\mathcal{S}</span>  inserts ( <span class="math">U_i</span> , v) in its internal registry of keys; in case the key exists already,  <span class="math">\\mathcal{S}</span>  returns FAIL and terminates. It returns to  <span class="math">\\mathcal{F}_{VRF}</span>  the message (VerificationKey, sid,  <span class="math">U_i</span> , v).</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving a message (EvalProve, sid,  <span class="math">U_i</span> , m) from  <span class="math">\\mathcal{F}_{VRF}</span> , this is matched to the verification key v of  <span class="math">U_i</span>  and is checked whether m has been queried before. In such case, the value u that corresponds to m in the table for v is recovered. In case m was not queried before, it is checked whether H'(m) is defined. In such case the entry (base, m, t) is recovered, the value u is set to  <span class="math">v^t</span>  and the triple (v, m, u) is stored for future reference. In case the value H'(m) is undefined  <span class="math">\\mathcal{S}</span>  selects t at random, stores (base, m, t) and sets  <span class="math">H&#x27;(m) = g^t</span> . Subsequently random c, s values are selected by  <span class="math">\\mathcal{S}</span> ; the pair  <span class="math">((m, u, v, g^s v^{-c}, H&#x27;(m)^s u^{-c}), c)</span>  is inserted to the table of the random oracle H. In case this is not feasible (because that would make the table inconsistent),  <span class="math">\\mathcal{S}</span>  outputs FAIL and terminates. Finally,  <span class="math">\\pi</span>  is set to (u, (c, s)) and the message (Eval, sid, m,  <span class="math">\\pi</span> ) is returned to  <span class="math">\\mathcal{F}_{VRF}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving (Verify, sid, m, y,  <span class="math">\\pi</span> , v') from  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> , parse  <span class="math">\\pi</span>  as (u', (c, s)) and verify the proof (c, s) as a proof of equality of discrete logarithms,  <span class="math">\\log_g(v&#x27;) = \\log_{H&#x27;(m)}(u&#x27;)</span> , to obtain a bit b. If b = 1, then submit (Eval, sid, v', m,  <span class="math">\\{\\pi\\}</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  (as it is a valid proof and in case v' is a corrupted key it should be registered with  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> ). Now observe that (base, m, t) must be recorded, and set  <span class="math">b&#x27; = ((u&#x27;)^{1/t} = v&#x27;) \\wedge (H(m, u) = y)</span> . If  <span class="math">b = 1 \\wedge b&#x27; = 0</span>  output FAIL and terminate. In any other case, t return (Verified, sid, m, y,  <span class="math">\\pi</span> , v') to  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  (in particular note that if  <span class="math">b = 0 \\wedge b&#x27; = 1</span> , the proof  <span class="math">\\pi</span>  will not be recorded with  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  and hence  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>  will return the correct output 0 to the verifier).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving a query m for the random oracle H', select t at random, store (base, m, t) and return  <span class="math">g^t</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Upon receiving a query for the random oracle H of the form (m, u), and the value (base, m, t) is stored previously, S performs the following. First, if  <span class="math">v = u^{1/t}</span>  is not registered as a public-key it registers (KeyGen, sid, v) with  <span class="math">\\mathcal{F}_{VRF}</span> . Then it submits (Eval,  <span class="math">sid, u^{1/t}, m, \\emptyset</span> ) to the  <span class="math">\\mathcal{F}_{VRF}</span>  ignores the request S terminates with fail. Else it obtains the response y which is set as the random oracle output to the query (m, u). In case (base, m, t) is not stored, then perform the step that corresponds to the query H'(m) above and repeat the current step. Other queries to H are handled by returning random elements of  <span class="math">\\{0,1\\}^{\\ell_{VRF}}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We observe that unless  <span class="math">\\mathcal{S}</span>  outputs FAIL the simulation of protocol 2Hash-DH is perfect. We next argue that the probability to output FAIL is negligible.  <span class="math">\\mathcal{S}</span>  outputs FAIL in the case that  <span class="math">\\mathcal{F}_{VRF}</span>  ignores a request (Eval, sid,  <span class="math">u^{1/t}</span> , m). This means that the key  <span class="math">v=u^{1/t}</span>  is registered with an honest party that has not evaluated m. It follows that the event an adversary that produces such u can be turned to solver for the CDH assumption. The other cases where  <span class="math">\\mathcal{S}</span>  produces FAIL, specifically, step 1 and step 3 can be easily seen to be negligible probability events.</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Insecurity of the Original Ouroboros Against Adversarial Message Delays</h2>

    <p class="text-gray-300">This appendix informally describes several attacks against the Proof-of-Stake protocol Ouroboros proposed in [KRDO17], when used in various environments that allow the adversary to control message delays to some extent.</p>

    <p class="text-gray-300">We consider two variants of the semi-synchronous model. With <em>sender-side delays</em>, each message can be delayed on the side of its sender, and hence after being delayed, it arrives to all recipients in the same round. On the other hand, if we allow for <em>recipient-side delays</em>, the each message can be delayed for a different time period for each of its recipients. The latter model is the one that we consider for our positive results in the main body of the paper. Clearly this latter model gives more power to the adversary, hence we explore it first here.</p>

      <h3 id="app-d.1" class="text-xl font-semibold mt-8">D.1 Recipient-Side Delays</h3>

    <p class="text-gray-300">The Model. The model for recipient-side delays is identical to the one given in Section 2.1.</p>

    <p class="text-gray-300">Attack Description. Intuitively, the adversary aims to violate the common prefix property by maintaining two tines that are growing at approximately the same rate: so that their lengths never differ by more than one block. This is achieved by disclosing the blocks mined in the past  <span class="math">\\Delta</span>  rounds (which are distributed via the DDiffuse functionality and hence can be delayed by  <span class="math">\\mathcal{A}</span> ) in a controlled</p>

    <p class="text-gray-300">way to affect the decision of the current slot leader (in case he is honest) about which of the two tines to extend.</p>

    <p class="text-gray-300">The attack can be performed even in the simple setting with a static stake and slot leaders sampled by an idealized beacon. Moreover, it can be carried out without any corrupted parties at all (i.e., also if the adversarial stake ratio &alpha;<sup>A</sup> = 0), as long as A maintains control over message delays.</p>

    <p class="text-gray-300">In detail, A behaves as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Internally, A maintains two tines T<sup>0</sup> and T1, initially empty. Whenever any party diffuses a chain C such that some T<sup>i</sup> is a prefix of C, A replaces T<sup>i</sup> with C (except for the trivial initial case when any chain is a prefix of both T<sup>0</sup> and T1, here A only replaces T0).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In each slot slr:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Determine Ts, the tine that is currently not longer, i.e., such that it satisfies |Ts| &le; |T1&minus;s|.</li>
      <li>(b) Let U<sup>i</sup> denote the slot leader for the upcoming slot slr+1. If a message containing T<sup>s</sup> was diffused in this round, A delivers it to the inbox of U<sup>i</sup> and to the delayed<sup>j</sup> -strings for all other parties j =&#824; i. Otherwise, if a message containing T<sup>s</sup> is already present in delayed<sup>i</sup> , A removes it from delayed<sup>i</sup> and delivers it to the inbox of party U<sup>i</sup> .</li>
      <li>(c) A moves all messages diffused in this round into the delayed-strings of all parties.</li>
    </ul></li>
    </ul>

      <h3 id="app-d.2" class="text-xl font-semibold mt-8">D.2 Sender-Side Delays</h3>

    <p class="text-gray-300">We now argue that the original Ouroboros protocol is insecure even against sender-side adversarial message delays.</p>

    <p class="text-gray-300">The Model. We consider an ideal functionality SDiffuse<sup>&#8710;</sup> that is defined exactly as the functionality Diffuse given in <a href="#page-31-2">[KRDO17]</a>, except for two differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When the adversary A is activated, besides performing any of the actions that were allowed by the Diffuse functionality, it is also allowed to:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>move any message obtained in a diffuse request from a party to a special string delayed,</li>
      <li>move any message from the string delayed to the inboxes of all parties.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of each round, the functionality ensures that for every message that was either (a) diffused in this round and not put to the string delayed or (b) removed from the string delayed in this round, it is present in the inboxes of all parties. If any message currently present in delayed was originally diffused at least &#8710; slots ago, then the functionality removes it from delayed and appends it to the inbox of all parties.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We again define our model by replacing Diffuse by SDiffuse<sup>&#8710;</sup> in the model of <a href="#page-31-2">[KRDO17]</a> (this gives us a class of models parametrized by &#8710;, setting &#8710; = 0 again results in the original model of <a href="#page-31-2">[KRDO17]</a>).</p>

    <p class="text-gray-300">Attack Description. The adversary again aims to violate the common prefix property by maintaining two tines that are growing at approximately the same rate. However, this time it cannot deliver messages selectively to future slot leaders, and hence the attack requires a slight modification.</p>

    <p class="text-gray-300">The details of the attack depend on the exact definition of the maxvalid function that honest parties use to choose the winning chain, namely on how it does tie-breaking in case of several equal-length chains. According to <a href="#page-31-2">[KRDO17]</a>, maxvalid should favor the current chain C if it is the longest, otherwise choose arbitrarily. There are several natural possibilities to perform this choice:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) Choose a chain that was delivered first out of those with maximal length.</li>
      <li>(ii) Choose a chain at random out of those with maximal length.</li>
      <li>(iii) Prefer an extension of the current chain C. This is not fully specified, a rule to choose among several extensions of C with maximal length is also needed.</li>
      <li>(iv) Apply some fixed ordering rule, e.g. take the lexicographically first out of the chains with maximal length.</li>
    </ul>

    <p class="text-gray-300">We now sketch an attack for each of the cases above. The attacks can again be performed even in the simple setting with a static stake, slot leaders sampled by an idealized beacon, and without any corrupted parties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Case (i). The adversary starts by partitioning the stakeholders into two sets  <span class="math">S_0</span>  and  <span class="math">S_1</span>  so that each of these sets controls about one half of the total stake. It again maintains two tines  <span class="math">T_0</span>  and  <span class="math">T_1</span> , and also keeps track of the prefixes  <span class="math">T&#x27;_i</span>  of each  <span class="math">T_i</span>  that were already delivered by SDiffuse to all parties. The goal of  <span class="math">\\mathcal{A}</span>  is to maintain  <span class="math">|T&#x27;_0| = |T&#x27;_1|</span> , and make all parties in  <span class="math">S_i</span>  believe that  <span class="math">T&#x27;_i</span>  is their current chain. This is achieved as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In each slot  <span class="math">sl_j</span> , the slot leader  <span class="math">U_j \\in S_i</span>  will extend  <span class="math">T&#x27;_i</span> .</li>
      <li><span class="math">\\mathcal{A}</span>  will delay this new block unless there is already also an existing block in  <span class="math">T_{1-i} \\setminus T&#x27;_{1-i}</span>  that can be used to extend both  <span class="math">T&#x27;_0</span>  and  <span class="math">T&#x27;_1</span>  by one block at the same time.</li>
      <li>If this is the case,  <span class="math">\\mathcal{A}</span>  delivers both delayed blocks, extends both  <span class="math">T&#x27;_0</span>  and  <span class="math">T&#x27;_1</span>  by one block, and uses its power to reorder messages in the inboxes of honest parties to maintain that parties in  <span class="math">S_i</span>  still consider the new  <span class="math">T&#x27;_i</span>  to be their current chain (note that parties follow the rule ((i)) above).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The probability that a message would need to be delayed by  <span class="math">\\mathcal{A}</span>  for more than  <span class="math">\\Delta</span>  slots to follow this strategy decreases exponentially with  <span class="math">\\Delta</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Case (ii). A similar approach as in the case (i) will work, with one small change. Here  <span class="math">\\mathcal{A}</span>  does not need to choose partitions  <span class="math">S_0</span>  and  <span class="math">S_1</span>  and maintain them using its inbox-reordering capability. Instead, it can simply observe which of the chains  <span class="math">T&#x27;_0</span>  and  <span class="math">T&#x27;_1</span>  are being extended, and again only deliver extensions for both of them at the same time. By rule (ii), each stakeholder will choose its current chain by choosing at random between the new  <span class="math">T&#x27;_0</span>  and  <span class="math">T&#x27;_1</span> . This will guarantee a quite even distribution of parties into  <span class="math">S_0</span>  and  <span class="math">S_1</span>  unless there are parties with a very large stake.</li>
      <li>Case (iii). The same attack as in the case (i) will work. Here the partitions  <span class="math">S_0</span>  and  <span class="math">S_1</span>  don't need to be maintained by inbox-reordering, each party will stay in the same partition thanks to following the rule (iii).</li>
      <li>Case (iv). The attacker  <span class="math">\\mathcal{A}</span>  again maintains two times  <span class="math">T_0</span>  and  <span class="math">T_1</span> , and also keeps track of the prefixes  <span class="math">T_i&#x27;</span>  of each  <span class="math">T_i</span>  that were already delivered by  <span class="math">\\mathsf{SDiffuse}_{\\Delta}</span>  to all parties. The goal of  <span class="math">\\mathcal{A}</span>  is to make  <span class="math">T_0</span>  and  <span class="math">T_1</span>  grow at roughly the same speed.</li>
    </ul>

    <p class="text-gray-300">The attack starts by letting the honest slot leaders mine two separate length-1 tines from the genesis block (by delaying the first one). Denote these blocks  <span class="math">B_0^{(1)}</span>  and  <span class="math">B_1^{(1)}</span> , these will be the first blocks of  <span class="math">T_0</span>  and  <span class="math">T_1</span> , respectively. Now,  <span class="math">\\mathcal{A}</span>  delivers to all parties the one of these two blocks (say  <span class="math">B_i^{(1)}</span> ) that has lower preference in the fixed ordering given by the rule (iv), and hence the next honest slot leader will extend this tine by mining some block  <span class="math">B_i^{(2)}</span>  on top of  <span class="math">B_i^{(1)}</span> .  <span class="math">\\mathcal{A}</span>  witholds  <span class="math">B_i^{(2)}</span>  but now publishes  <span class="math">B_{1-i}^{(1)}</span>  and due to the rule (iv), the next honest slot leader will mine a block on top of  <span class="math">B_{1-i}^{(1)}</span> , call it  <span class="math">B_{1-i}^{(2)}</span> . Now  <span class="math">\\mathcal{A}</span>  is in the same situation as before, hence it again delivers the one of the blocks  <span class="math">B_0^{(2)}</span>  and  <span class="math">B_1^{(2)}</span>  that has lower preference according to the rule (iv). The attack continues analogously.</p>

    <p class="text-gray-300">This attack only requires  <span class="math">\\Delta \\geq 2</span> .</p>

    <p class="text-gray-300">In our arguments, we are using the following standard variant of the Chernoff bound. See, e.g., [MR95] for a proof.</p>

    <p class="text-gray-300"><strong>Theorem 12 (Chernoff bound).</strong> Let  <span class="math">X_1, \\ldots, X_T</span>  be independent random variables with  <span class="math">X_i \\in [0,1]</span>  and  <span class="math">\\mathbb{E}[X_i] = p_i</span> . Let  <span class="math">X = \\sum_{i=1}^T X_i</span>  and  <span class="math">\\mu = \\sum_{i=1}^T p_i = \\mathbb{E}[X]</span> .</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;- \\textit{ For all } 0 &lt; \\delta \\leq 1, \\ \\mathsf{P}[X \\leq (1-\\delta)\\mu] \\leq e^{-\\frac{\\delta^2\\mu}{2}}. \\\\ &amp;- \\textit{ For all } 0 &lt; \\delta, \\ \\mathsf{P}[X \\geq (1+\\delta)\\mu] \\leq \\left(\\frac{e^{\\delta}}{(1+\\delta)^{1+\\delta}}\\right)^{\\mu}. \\\\ &amp;- \\textit{ For all } 0 &lt; \\delta &lt; 2e-1, \\ \\mathsf{P}[X \\geq (1+\\delta)\\mu] \\leq e^{-\\frac{\\delta^2\\mu}{4}}. \\end{split}</span>$</p>

    <p class="text-gray-300">We also employ the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 13 ([Str65]).</strong> Let  <span class="math">\\mathcal{D}_1</span>  and  <span class="math">\\mathcal{D}_2</span>  be two distributions on a finite partially ordered set V with partial order  <span class="math">\\preceq</span> . Then  <span class="math">\\mathcal{D}_1 \\preceq \\mathcal{D}_2</span>  iff there is a pair of (typically dependent) random variables,  <span class="math">X_1</span>  and  <span class="math">X_2</span> , taking values in V so that each  <span class="math">X_i</span>  is distributed according to  <span class="math">\\mathcal{D}_i</span> , and  <span class="math">\\Pr[X_1 \\preceq X_2] = 1</span> .</p>

    <p class="text-gray-300">(Note that the statement of this theorem overloads the notation  <span class="math">\\leq</span> , applying it both to distributions in the sense of Definition 14 and elements of the partial order.) This result is implicit in Strassen's 1965 article [Str65]; a presentation with terminology closer to ours appears in Kamae et al. [KKO77].</p>

    <p class="text-gray-300">Theorem 14 (Tail bounds for negative binomial distributions). Let N be a random variable with a negative binomial distribution with parameters r &gt; 1 (a positive integer) and p (a &quot;success&quot; probability), so that</p>

    <p class="text-gray-300"><span class="math">$D_n \\triangleq \\Pr[N=n] = \\binom{n+r-1}{n} p^r (1-p)^n.</span>$</p>

    <p class="text-gray-300">Then, for  <span class="math">n \\ge r(p-1)/p</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{p}D_n \\le \\Pr[N \\ge n] \\le \\left(1 - \\frac{n+r}{n+1}(1-p)\\right)D_n</span>$</p>

    <p class="text-gray-300">This particular bound is developed and discussed in [Kla00].</p>

    </section>

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">F From Executions to Forks</h2>

    <p class="text-gray-300">We define the useful notion of an <em>execution tree</em> that captures the structure formed by all chains that are observed by any honest party during an execution.</p>

    <p class="text-gray-300"><strong>Definition 20 (Execution tree).</strong> Consider an execution  <span class="math">\\mathcal{E}</span>  of the hybrid experiment. The execution tree for this execution is a directed, rooted tree  <span class="math">T_{\\mathcal{E}} = (V, E)</span>  with a labeling  <span class="math">\\ell : V \\to \\mathbb{N}_0</span>  that is constructed during the execution as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) At the beginning,  <span class="math">V = \\{r\\}</span> ,  <span class="math">E = \\emptyset</span>  and  <span class="math">\\ell(r) = 0</span> .</li>
      <li>(ii) Every chain C' that is input to maxvalid as a part of  <span class="math">\\mathbb{C}</span>  in Step 2a or created as a new local chain in Step 3b of  <span class="math">\\pi_{SPoS}</span>  run by any honest party is immediately processed block-by-block from the genesis block to head(C'). For every block  <span class="math">B = (st&#x27;, d&#x27;, sl&#x27;, crt&#x27;, \\sigma_{j&#x27;})</span>  processed for the first time:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a new vertex  <span class="math">v_B</span>  is added to V;</li>
      <li>a new edge  <span class="math">(v_{B^-}, v_B)</span>  is added to E where  <span class="math">B^-</span>  is the unique block such that  <span class="math">H(B^-) = st&#x27;</span> ;</li>
      <li>the labeling  <span class="math">\\ell</span>  is extended by setting  <span class="math">\\ell(v_B) = \\mathsf{sl}&#x27;</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">We now observe that as desired, the execution tree of every execution is among the forks for the characteristic string of that execution. Note that technically, this conclusion is conditioned on no collisions in the random oracle outputs. For the sake of improved readability, we neglect the possibility of such collisions in our further considerations.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> For any execution  <span class="math">\\mathcal{E}</span>  of the hybrid experiment we have  <span class="math">T_{\\mathcal{E}} \\vdash_{\\Delta} w_{\\mathcal{E}}</span> , unless a collision in the responses of the random oracle occurs.</p>

    <p class="text-gray-300">Proof (sketch). Given an execution  <span class="math">\\mathcal{E}</span>  and the resulting execution tree  <span class="math">T_{\\mathcal{E}}</span> , we need to prove that it satisfies the properties (i)&ndash;(v) of Definition 7 with respect to  <span class="math">w_{\\mathcal{E}}</span> . Property (i) follows directly from the definition of  <span class="math">T_{\\mathcal{E}}</span> , while (ii) follows from the order in which vertices in  <span class="math">T_{\\mathcal{E}}</span>  are created: every edge is directed from an older vertex to a newer one and the root is the first vertex created. Property (iii) is satisfied due to the requirement in Definition 2 that the sequence of slots in a valid blockchain is strictly increasing (otherwise, the chain is rejected by  <span class="math">\\pi_{\\rm SPoS}</span>  as invalid). To see property (iv), note that by  <span class="math">\\pi_{\\rm SPoS}</span> , every uniquely honest slot leader will create a block and this is immediately processed, resulting in a vertex with the respective label in  <span class="math">T_{\\mathcal{E}}</span> . Finally, property (v) is satisfied as every uniquely honest slot leader will be aware of any other such slot leader's block created at least  <span class="math">\\Delta</span>  slots ago due to the guarantees provided by DDiffuse, and will hence extend a chain that is at least as long as the one containing this block. Note that several of our arguments above assume no random oracle collisions.</p>

    <p class="text-gray-300">Given Lemma 6, we can later focus on investigating the properties of the distribution  <span class="math">\\mathcal{D}^f_{\\mathcal{Z},\\mathcal{A}}</span> . Roughly speaking, if we prove that a characteristic string sampled from  <span class="math">\\mathcal{D}^f_{\\mathcal{Z},\\mathcal{A}}</span> , with overwhelming probability, does not allow for <em>any</em> &quot;harmful&quot; forks for it, then this also implies that a random execution with overwhelming probability results in a &quot;harmless&quot; execution tree.</p>

    </section>

    <section id="app-g" class="mb-10">
      <h2 class="text-2xl font-bold">G Further Details on Forks, Forkability and Divergence</h2>

    <p class="text-gray-300">We introduce the notion of a forkable string that was central to the analysis in <a href="#page-31-2">[KRDO17]</a>.</p>

    <p class="text-gray-300">Definition 21 (Height and tine intersection). The height of a fork (as usual for a tree) is defined to be the length of the longest tine. For two tines t<sup>1</sup> and t<sup>2</sup> of a fork F, we write t<sup>1</sup> &sim; t<sup>2</sup> if they share an edge. Note that &sim; is an equivalence relation on the set of nontrivial tines; on the other hand, if t<sup>&#1013;</sup> denotes the &quot;empty&quot; tine consisting solely of the root vertex then t<sup>&#1013;</sup> &#824;&sim; t for any tine t.</p>

    <p class="text-gray-300">The common prefix property in the synchronous case is studied by focusing on a local property of &quot;forkability&quot;.</p>

    <p class="text-gray-300">Definition 22 (Flat forks and forkable strings). We say that a synchronous fork is flat if it has two tines t<sup>1</sup> &#824;&sim; t<sup>2</sup> of length equal to the height of the fork. A string w &isin; {0, 1} &lowast; is said to be forkable if there is a flat synchronous fork F &#8866;<sup>0</sup> w.</p>

    <p class="text-gray-300">A fundamental tool in the security analysis in the synchronous case is an estimate of the number of forkable strings of a particular length k. The original bound of 2<sup>&minus;</sup>&Omega;( &radic; k) in <a href="#page-31-2">[KRDO17]</a> was strengthened to 2&minus;&Omega;(k) in <a href="#page-32-8">[RMKQ17]</a>.</p>

    <p class="text-gray-300">Theorem 15 (<a href="#page-31-2">[KRDO17</a><a href="#page-32-8">,RMKQ17]</a>). Let &#1013; &isin; (0, 1) and let w be a string drawn from {0, 1} k by independently assigning each w<sup>i</sup> = 1 with probability (1 &minus; &#1013;)/2. Then Pr[w is forkable] = 2&minus;&Omega;(k) . The constant hidden by the &Omega;(&middot;) notation depends only on &#1013;.</p>

    <p class="text-gray-300">As mentioned above, the notion of forkability is directly related to (synchronous) divergence; this is reflected by the theorem below.</p>

    <p class="text-gray-300">Theorem 16 (<a href="#page-31-2">[KRDO17]</a>). Let w &isin; {0, 1} <sup>&lowast;</sup> with div0(w) &ge; k. Then there is a forkable substring w&#711; of w with |w&#711;| &ge; k.</p>

    <p class="text-gray-300">An immediate conclusion of Theorems <a href="#page-40-0">15</a> and Theorem <a href="#page-40-1">16</a> is the following bound on the probability that a synchronous characteristic string drawn with i.i.d. symbols has large divergence.</p>

    <p class="text-gray-300">Theorem 17 (Restatement of Theorem <a href="#page-16-2">3)</a>. Let &#8467;, k &isin; N and &#1013; &isin; (0, 1). Let w = w<sup>1</sup> . . . w<sup>&#8467;</sup> &isin; {0, 1} &#8467; be drawn by independently assigning each symbol to the value 1 with probability (1 &minus; &#1013;)/2. Then</p>

    <p class="text-gray-300">
<span class="math">$\\Pr[\\operatorname{div}_0(w) \\ge k] \\le \\exp(\\ln \\ell - \\Omega(k))</span>$
.</p>

    <p class="text-gray-300">A proof of a weaker bound of the form exp(ln &#8467; &minus; &Omega;( &radic; k)) appears in <a href="#page-31-2">[KRDO17]</a>. Russell et al. <a href="#page-32-8">[RMKQ17]</a> then strengthened the basic probabilistic tools used in <a href="#page-31-2">[KRDO17]</a> to achieve a bound of the form exp(ln &#8467; &minus; &Omega;(k)) for the local notion of forkability. For completeness, we include a proof of Theorem <a href="#page-16-2">3</a> relying on the results of <a href="#page-32-8">[RMKQ17]</a>.</p>

    <p class="text-gray-300">Proof (of Theorem <a href="#page-16-2">3)</a>. It follows from Theorem <a href="#page-40-1">16</a> that if div0(w) &ge; k, there is a forkable substring w&#711; of length at least k. Thus</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\operatorname{div}_0(w) \\geq k] \\leq \\Pr\\left[ &amp;\\frac{\\exists \\alpha, \\beta \\in \\{1, \\dots, \\ell\\} \\text{ so that } \\alpha + k - 1 \\leq \\beta \\text{ and}}{w_\\alpha \\dots w_\\beta \\text{ is forkable}} \\right] \\\\ \\leq &amp; \\sum_{1 \\leq \\alpha \\leq \\ell} \\sum_{\\alpha + k - 1 \\leq \\beta \\leq \\ell} \\Pr[w_\\alpha \\dots w_\\beta \\text{ is forkable}] \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">According to Theorem <a href="#page-40-0">15</a> the probability that a string of length t drawn from this distribution is forkable is no more than exp(&minus;ct) for a positive constant c. Note that for any &alpha; &ge; 1,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{t=\\alpha+k-1}^{\\ell} e^{-ct} \\le \\int_{k-1}^{\\infty} e^{-ct} dt = (1/c)e^{-c(k-1)} = e^{-\\Omega(k)}</span>$</p>

    <p class="text-gray-300">and it follows that the sum (&lowast;) above is exp(&minus;&Omega;(k)). Thus</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\operatorname{div}_0(w) \\ge k] \\le \\ell \\cdot \\exp(-\\Omega(k)) \\le \\exp(\\ln \\ell - \\Omega(k)),</span>$</p>

    <p class="text-gray-300">as desired. &#8851;&#8852;</p>

    </section>

    <section id="app-h" class="mb-10">
      <h2 class="text-2xl font-bold">H A Lazy Variant of <span class="math">\\pi_{\\text{DPoS}}</span></h2>

    <p class="text-gray-300">This section sketches how the protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  can be easily modified to significantly weaken the requirement of all honest parties being online all the time. In the modified protocol  <span class="math">\\pi_{\\mathrm{DPoS}}^{\\mathsf{lazy}}</span>  given in Figure 12, every stakeholder comes online only at the beginning of each epoch, determining for which of the slots in that epoch he belongs into the slot leader set. Consequently, the stakeholder can only come online in those slots and create blocks as usually. Additionally, the stakeholder also makes sure that it is not offline for k or more slots.</p>

    <p class="text-gray-300">Note that this requires a slightly different mechanism of distributing existing chains, as the lazy stakeholder needs a way to obtain a copy of the current chain the moment he comes online. In theory, this can be achieved by letting all stakeholders diffuse their current chain even if they haven't added a block to it; in practice this would be handled by a request mechanism where a stakeholder can ask for chains from other nodes upon coming online.</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\rm DPoS}^{\\rm lazy}</span>  is run in the same setting as  <span class="math">\\pi_{\\rm DPoS}</span> , with the same definition of  <span class="math">T_i^j</span> . It proceeds as follows for each stakeholder  <span class="math">U_i</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Initialization.</strong> This step is the same as Step 1 in  <span class="math">\\pi_{DPoS}</span> . Additionally,  <span class="math">U_i</span>  initializes  <span class="math">\\mathcal{L} = \\emptyset</span> . After initialization, every stakeholder  <span class="math">U_i</span>  acts as described below. If none of the conditions below occurs,  <span class="math">U_i</span>  can go online and offline arbitrarily, with the requirement that it is never offline for k or more consecutive slots.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Epoch Update.</strong> If a new epoch  <span class="math">e_{j^*}</span>  has started,  <span class="math">U_i</span>  performs Step 2 of  <span class="math">\\pi_{\\text{DPoS}}</span> . Afterwards, for every slot  <span class="math">\\hat{\\mathsf{sl}}</span>  of the upcoming epoch  <span class="math">e_{j^*}</span> ,  <span class="math">U_i</span>  sends (Eval, sid,  <span class="math">\\eta_{j^*} \\parallel \\hat{\\mathsf{sl}} \\parallel \\text{TEST}</span> ) to  <span class="math">\\mathcal{F}_{\\text{VRF}}</span> , receiving (Evaluated, sid, y).  <span class="math">U_i</span>  checks whether it is in the slot leader set of slot  <span class="math">\\hat{\\mathsf{sl}}</span>  with respect to the upcoming epoch  <span class="math">e_{j^*}</span>  by checking that  <span class="math">y &lt; T_j^{j^*}</span> . If yes, it adds  <span class="math">\\hat{\\mathsf{sl}}</span>  to a set  <span class="math">\\mathcal{L}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Chain Update and Extension. Upon a slot in  <span class="math">\\mathcal{L}</span> ,  <span class="math">U_i</span>  comes online, processes all queued incoming chains according to Step 3 of  <span class="math">\\pi_{\\text{DPoS}}</span> , and performs the Step 4 of  <span class="math">\\pi_{\\text{DPoS}}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signing Transactions. Whenever  <span class="math">U_i</span>  is online, it performs Step 5 of  <span class="math">\\pi_{DPoS}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Fig. 12: Protocol  <span class="math">\\pi_{\\rm DPoS}^{\\sf lazy}</span> .</p>

    </section>
`;
---

<BaseLayout title="Ouroboros Praos: An adaptively-secure, semi-synchronous proo... (2017/573)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/573
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The Semi-Synchronous Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Transaction Ledger Properties</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">The Static Stake Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Forward Secure Signatures and \mathcal&#123;F&#125;_&#123;KES&#125;</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">UC-VRFs with Unpredictability Under Malicious Key Generation</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Oblivious Leader Selection</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">The Protocol in the FINIT-hybrid Model</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Combinatorial Analysis of the Static Stake Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Chains, Forks and the Abstract Chain Properties</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Abstract Common Prefix Formulated as Divergence</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">The Semisynchronous to Synchronous Reduction</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">The Dominant Characteristic Distribution</a></li>
            <li><a href="#sec-4.5" class="hover:text-white">Abstract Common Prefix and the Divergence of the Dominant Distribution</a></li>
            <li><a href="#sec-4.6" class="hover:text-white">Abstract Chain Growth and Chain Quality</a></li>
            <li><a href="#sec-4.7" class="hover:text-white">The Transition to Protocol Executions: Common Prefix, Chain Growth, and Chain Quality</a></li>
            <li><a href="#sec-4.8" class="hover:text-white">Adaptive Adversaries</a></li>
            <li><a href="#sec-4.9" class="hover:text-white">The Resettable Protocol</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">The Full Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">The Dynamic Stake Case with a Resettable Leaky Beacon</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Instantiating \mathcal&#123;F&#125;_&#123;RLB&#125;^&#123;\tau,r&#125;</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Definitions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Verifiable Random Functions</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Digital Signatures and \mathcal&#123;F&#125;_&#123;\mathsf&#123;DSIG&#125;&#125;</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Forward Secure Signatures Schemes</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Realizing \mathcal&#123;F&#125;_&#123;\mathsf&#123;KES&#125;&#125;</a></li>
        <li><a href="#app-c" class="hover:text-white">Realizing \mathcal&#123;F&#125;_&#123;VRF&#125;</a></li>
        <li>
          <a href="#app-d" class="hover:text-white">Insecurity of the Original Ouroboros Against Adversarial Message Delays</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-d.1" class="hover:text-white">Recipient-Side Delays</a></li>
            <li><a href="#app-d.2" class="hover:text-white">Sender-Side Delays</a></li>
          </ol>
        </li>
        <li><a href="#app-e" class="hover:text-white">Probability-Theoretic Tools</a></li>
        <li><a href="#app-f" class="hover:text-white">From Executions to Forks</a></li>
        <li><a href="#app-g" class="hover:text-white">Further Details on Forks, Forkability and Divergence</a></li>
        <li><a href="#app-h" class="hover:text-white">A Lazy Variant of \pi_&#123;\text&#123;DPoS&#125;&#125;</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="ouroboros-praos-an-adaptively-secure-semi-synchronous-proof-2017" />
  </article>
</BaseLayout>
