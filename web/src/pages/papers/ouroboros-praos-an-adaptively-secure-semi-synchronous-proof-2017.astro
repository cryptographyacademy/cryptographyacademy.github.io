---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/573';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Ouroboros Praos: An adaptively-secure, semi-synchronous proof-of-stake protocol';
const AUTHORS_HTML = 'Bernardo David, Peter Gaži, Aggelos Kiayias, Alexander Russell';

const CONTENT = `    <p class="text-gray-300">A. K. KARAS, A. K. KARAS, AND A. K. KARAS</p>

    <p class="text-gray-300">2018</p>

    <p class="text-gray-300">2019</p>

    <p class="text-gray-300">the protocol construction has a number of novel elements that require a significant recasting and generalization of the previous combinatorial analysis. In more detail, our results are as follows.</p>

    <p class="text-gray-300">In Ouroboros Praos, deciding whether a certain participant of the protocol is eligible to issue a block is decided via a private test that is executed locally using a special verifiable random function (VRF) on the current time-stamp and a nonce that is determined for a period of time known as an “epoch”. A special feature of this VRF primitive, novel to our approach, is that the VRF must have strong security characteristics even in the setting of malicious key generation: specifically, if provided with an input that has high entropy, the output of the VRF is unpredictable even when an adversary has subverted the key generation procedure. We call such VRF functions “VRF with unpredictability under malicious key generation” and we present a strong embodiment of this notion with a novel Universal Composable (UC) formulation. We also present a very efficient realization of this primitive under the Computational Diffie Hellman (CDH) assumption in the random oracle model. Beyond this VRF notion, we also formalize in a UC fashion key evolving signatures that provide the forward security that is necessary for handling the adaptive corruption setting.</p>

    <p class="text-gray-300">In more detail, we analyze our protocol in the partial or semi-synchronous model <em>[x10, x31]</em>. In this setting, we still divide the protocol execution in time units which, as in <em>[x23]</em>, are called slots, but there is a maximum delay of <span class="math">\\Delta</span> slots that is applied to message delivery and it is unknown to the protocol participants. In order to cope with the <span class="math">\\Delta</span>-semisynchronous setting we introduce the concept of “empty slots” which occur with sufficient frequency to enable short periods of silence that facilitate synchronization. This feature of the protocol gives also its moniker, “Praos”, meaning “mellow”, or “gentle”. Ensuring that the adversary cannot exploit the stakeholder keys that it possesses to confuse or out-maneuver the honest parties, we develop a combinatorial analysis to show that the simple rule of following the longest chain still enables the honest parties to converge to a unique view with high probability. To accomplish this we revisit and expand the forkable strings and divergence analysis of <em>[x23]</em>. We remark that significant alterations are indeed necessary: As we demonstrate in Appendix D, the protocol of <em>[x23]</em> and its analysis are critically tailored to synchronous operation and is susceptible to a desynchronization attack that can completely violate the common prefix property. Our new combinatorial analysis introduces a new concept of characteristic strings and “forks” that reflects silent periods in protocol execution and network delays. To bound the density of forkable strings in this <span class="math">\\Delta</span>-semisynchronous setting we establish a syntactic reduction from <span class="math">\\Delta</span>-semisynchronous characteristic strings to synchronous strings of <em>[x23]</em> that preserves the structure of the forks they support. This is followed by a probabilistic analysis that controls the distortion caused by the reduction and concludes that <span class="math">\\Delta</span>-semisynchronous forkable strings are rare. Finally, we control the effective power of adaptive adversaries in this setting with a stochastic dominance argument that permits us to carry out the analysis of the underlying blockchain guarantees (e.g., common prefix) with a single distribution that provably dominates all distributions on characteristic strings generated by adaptive adversaries. We remark that these arguments yield graceful degradation of the analysis as a function of network delays (<span class="math">\\Delta</span>), in the sense that the effective stake of the adversary is amplified by a function of <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">The above combinatorial analysis is nevertheless only sufficient to provide a proof of the static stake case, i.e., the setting where the stake distribution relevant to the honest majority assumption remains fixed at the onset of the computation and prior to the selection of the random genesis data that are incorporated in the genesis block. For a true proof-of-stake system, we must permit the set of stakeholders to evolve over time and appropriately adapt our honest stakeholder majority assumption. Achieving this requires a bootstrapping argument that allows the protocol to continue unboundedly by revising its stakeholder distribution as it evolves. We bootstrap our protocol in two conceptual steps. First we show how bootstrapping is possible if a randomness beacon is available to all participants. At regular intervals the beacon can be trusted to emit a new random value; the participants can then reseed the election process so the stakeholder distribution used for sampling can be brought closer to the one that is current. A key observation here is that our protocol is resilient even if the randomness beacon is weakened in the following two ways: (i) it leaks its value to the adversary ahead of time by a bounded number of time units, (ii) it allows the adversary to reset its value if it wishes within a bounded time window. We call the resulting primitive a</p>

    <p class="text-gray-300">“leaky resettable beacon” and show that our bootstrapping argument still holds in this stronger adversarial setting.</p>

    <p class="text-gray-300">In the final refinement of our protocol, we show how it is possible to implement the leaky resettable beacon via a simple algorithm that concatenates the VRF outputs that were contributed by the participants from the blockchain and subjects them to a hash function that is modeled as a random oracle. This implementation explains the reasons behind the beacon relaxation we introduced: leakiness stems from the fact that the adversary can complete the blockchain segment that determines the beacon value before revealing it to the honest participants, while resettability stems from the fact that the adversary can try a bounded number of different blockchain extensions that will stabilize the final beacon value to a different preferred value.</p>

    <p class="text-gray-300">Putting all the above together, we show how our protocol provides a “robust transaction ledger” in the sense that an immutable record of transactions is built that also guarantees that new transactions will be always included. Our security definition is in the <span class="math">\\Delta</span>-semisynchronous setting with full adaptive corruptions. As mentioned above, security degrades gracefully as <span class="math">\\Delta</span> increases, and this parameter is unknown to the protocol participants.</p>

    <p class="text-gray-300">Note that implementing the beacon via hashing VRF values will make feasible a type of “grinding attack” where the adversary can trade hashing power for a slight bias of the protocol execution to its advantage. We show how this bias can be controlled by suitably increasing the relevant parameters depending on the hashing power that is available to the adversary.</p>

    <p class="text-gray-300">Comparison to related work. The idea of proof-of-stake protocols has been discussed extensively in the bitcoin forum. The manner that a stakeholder determines eligibility to issue a block is always publicly verifiable and the proof of eligibility is either computed publicly (via a calculation that is verifiable by repeating it) or by using a cryptographic mechanism that involves a secret-key computation and a public-key verification. The first example of the former approach appeared in PPCoin <em>[x13]</em>, and was followed by others including Ouroboros and Snow White <em>[x4, x12, x10]</em>; while the first example of the latter approach (that we also employ in our work) appeared in NXT (cf. Section 2.4.1 of <em>[x7]</em>) and was then also used elsewhere, most notably in Algorand <em>[x16]</em>. The virtue of the latter approach is exactly in its potential to control adaptive corruptions: due to the fact that the adversary cannot predict the eligibility of a stakeholder to issue a block prior to corrupting it, she cannot gain an advantage by directing its corruption quota to specific stakeholders. Nevertheless, none of these previous works isolated explicitly the properties of the primitives that are required to provide a full proof of security in the setting of adaptive corruptions. Injecting high quality randomness in the PoS blockchain was proposed by Bentov et al. <em>[x5, x4]</em>, though their proposal does not have a full formal analysis. The Ouroboros proof-of-stake protocol <em>[x12]</em> is provably secure in a corruption model that excludes fully adaptive attacks by imposing a corruption delay on the corruption requests of the adversary. The Snow White proof-of-stake <em>[x10]</em> is the first to prove security in the <span class="math">\\Delta</span>-semi-synchronous model but—as in the case of Ouroboros—adopts a weak adaptive corruption model.</p>

    <p class="text-gray-300">A recent work close to ours is Algorand <em>[x16]</em> that also provides a proof-of-stake ledger that is adaptively secure. It follows an entirely different construction approach that runs a Byzantine agreement protocol for every block and achieves adaptive-corruption security via a novel, appealing concept of player-replaceability. However, Algorand is only secure against a 1/3 adversary bound; and while the protocol itself is very efficient, it yields an inherently slower block production rate compared to an “eventual consensus” protocol (like Bitcoin, Snow White, and Ouroboros). In principle, proof-of-stake blockchain protocols can advance at the theoretical maximum speed (of one block per communication round), while protocols relying on Byzantine agreement, like Algorand, would require a larger number of rounds to settle each block.</p>

    <p class="text-gray-300">Sleepy consensus <em>[x19]</em> puts forth a technique for handling adaptive corruptions in a model that also encompasses fail-stop and recover corruptions; however, the protocol can be applied directly only in a static stake (i.e., permissioned) setting. We note that in fact our protocol can be also proven secure in such mixed corruption setting, where both fail-stop and recover as well as Byzantine corruptions are allowed (with the former occurring at an arbitrarily high rate); nevertheless this is out of scope for the present exposition and we omit further details.</p>

    <p class="text-gray-300">Note that the possibility of adversarial grinding in Ouroboros Praos is also present in previous work that derives randomness by hashing <em>[x13, x10]</em>, as opposed to a dedicated coin-tossing protocol as in <em>[x12]</em>. Following the examples of <em>[x13, x10]</em>, we show that security can be guaranteed despite any adversarial bias resulting from grinding. In fact, we show how to use the <span class="math">q</span>-bounded model of <em>[x11]</em> to derive a bound that shows how to increase the relevant security parameters given the hashing power that is available to the adversary.</p>

    <p class="text-gray-300">Finally, in the present exposition we also put aside incentives; nevertheless, it is straightforward to adapt the mechanism of input endorsers from the protocol of <em>[x12]</em> to our setting and its approximate Nash equilibrium analysis can be ported directly.</p>

    <h2 id="sec-20" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout the paper, let <span class="math">\\mathbb{N}=\\{0,1,2,\\ldots\\}</span> denote the set of natural numbers (including zero). We say a function <span class="math">negl(x)</span> is negligible if, for every <span class="math">c&gt;0</span>, there exists an <span class="math">n&gt;0</span> such that <span class="math">negl(x)&lt;1/x^{c}</span> for all <span class="math">x\\geq n</span>. The length of a string <span class="math">w</span> is denoted by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; </span>\\varepsilon<span class="math"> denotes the empty string, and </span>v\\mathbin{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}w$ denotes concatenation of strings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.1 The Semi-Synchronous Model</h3>

    <p class="text-gray-300">On a high level, we consider the security model of <em>[x12]</em> with simple modifications to account for adversarially-controlled message delays and immediate adaptive corruption. Namely, we allow the adversary <span class="math">\\mathcal{A}</span> to selectively delay any messages sent by honest parties for up to <span class="math">\\Delta\\in\\mathbb{N}</span> slots; and corrupt parties without delay.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Time and slots</h5>

    <p class="text-gray-300">We consider a setting where time is divided into discrete units called <em>slots</em> that are indexed by natural numbers. We often use the notation <span class="math">\\mathsf{sl}</span>, <span class="math">\\mathsf{sl}_{i}</span>, etc. to denote variables representing slot numbers. Players are equipped with (roughly) synchronized clocks that indicate the current slot: we assume that any clock drift is subsumed in the slot length.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Security Model</h5>

    <p class="text-gray-300">We adopt the model introduced by <em>[x11]</em> for analyzing security of blockchain protocols enhanced with an ideal functionality <span class="math">\\mathcal{F}</span>. We note that multiple different “functionalities” can be encompassed by <span class="math">\\mathcal{F}</span>. In our model we employ the “Delayed Diffuse” functionality, which allows for adversarially-controlled delayed delivery of messages diffused among stakeholders.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">The Diffuse Functionality</h5>

    <p class="text-gray-300">This functionality is parameterized by <span class="math">\\Delta\\in\\mathbb{N}</span> and denoted as <span class="math">\\mathsf{DDiffuse}_{\\Delta}</span>. It maintains rounds, executing one round per slot. <span class="math">\\mathsf{DDiffuse}_{\\Delta}</span> interacts with the environment <span class="math">\\mathcal{Z}</span>, stakeholders <span class="math">U_{1},\\ldots,U_{n}</span> and an adversary <span class="math">\\mathcal{A}</span>, proceeding as follows for each round:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{DDiffuse}_{\\Delta}</span> maintains an incoming string for each party <span class="math">U_{i}</span> that participates. A party, if activated, is allowed at any moment to fetch the contents of its incoming string, hence one may think of this as a mailbox. Furthermore, parties can give an instruction to the functionality to diffuse a message. Activated parties are allowed to diffuse once in a round.</li>

      <li>When the adversary <span class="math">\\mathcal{A}</span> is activated, it is allowed to: (a) Read all inboxes and all diffuse requests and deliver messages to the inboxes in any order it prefers; (b) For any message <span class="math">m</span> obtained via a diffuse request and any party <span class="math">U_{i}</span>, <span class="math">\\mathcal{A}</span> may move <span class="math">m</span> into a special string <span class="math">\\mathsf{delayed}_{i}</span> instead of the inbox of <span class="math">U_{i}</span>. <span class="math">\\mathcal{A}</span> can decide this individually for each message and each party; (c) For any party <span class="math">U_{i}</span>, <span class="math">\\mathcal{A}</span> can move any message from the string <span class="math">\\mathsf{delayed}_{i}</span> to the inbox of <span class="math">U_{i}</span>.</li>

      <li>At the end of each round, the functionality also ensures that every message that was either (a) diffused in this round and not put to the string <span class="math">\\mathsf{delayed}_{i}</span> or (b) removed from the string <span class="math">\\mathsf{delayed}_{i}</span> in this round is delivered to the inbox of party <span class="math">U_{i}</span>. If any message currently present in <span class="math">\\mathsf{delayed}_{i}</span> was originally diffused at least <span class="math">\\Delta</span> slots ago, then the functionality removes it from <span class="math">\\mathsf{delayed}_{i}</span> and appends it to the inbox of party <span class="math">U_{i}</span>, being available to <span class="math">U_{i}</span> by the beginning of next round.</li>

      <li>Upon receiving <span class="math">(\\mathsf{Create},U,\\mathcal{C})</span> from the environment, the functionality spawns a new stakeholder with chain <span class="math">\\mathcal{C}</span> as its initial local chain (as it was the case in <em>[x12]</em>).</li>

    </ol>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Protocol Execution and Adaptive Corruptions</h5>

    <p class="text-gray-300">Given the above we will assume that the execution of the protocol is with respect to a functionality <span class="math">\\mathcal{F}</span> that incorporates DDiffuse as well as possibly additional functionalities to be explained in the following sections. The environment issues transactions on behalf of any stakeholder <span class="math">U_{i}</span> by requesting a signature on the transaction as described in Protocol <span class="math">\\pi_{\\text{SPuS}}</span> of Figure 4 and handing the transaction to stakeholders to put them into blocks. Beyond any restrictions imposed by <span class="math">\\mathcal{F}</span>, the adversary can only corrupt a stakeholder <span class="math">U_{i}</span> if it is given permission by the environment <span class="math">\\mathcal{Z}</span> running the protocol execution. The permission is in the form of a message <span class="math">(\\text{\\sf Corrupt},U_{i})</span> which is provided to the adversary by the environment. Upon receiving permission from the environment, the adversary immediately corrupts <span class="math">U_{i}</span> without any delay, differently from <em>[x13, x10]</em>, where corruptions only take place after a given delay. Note that a corrupted stakeholder <span class="math">U_{i}</span> will relinquish its entire state to <span class="math">\\mathcal{A}</span>; from this point on, the adversary will be activated in place of the stakeholder <span class="math">U_{i}</span>. The adversary is able to control transactions and blocks generated by corrupted parties by interacting with <span class="math">\\mathcal{F}_{\\text{\\sf DSiG}}</span>,<span class="math">\\mathcal{F}_{\\text{\\sf KES}}</span> and <span class="math">\\mathcal{F}_{\\text{\\sf VRF}}</span>, as described in Protocol <span class="math">\\pi_{\\text{SPuS}}</span> of Section 3. In summary, regarding activations we have the following: (a) At each slot, the environment <span class="math">\\mathcal{Z}</span> activates all honest stakeholders. (b) The adversary is activated at least as the last entity in each slot (as well as during all adversarial party activations and invocations from the ideal functionalities as prescribed); (c) If a stakeholder does not fetch in a certain slot the messages written to its incoming string from the diffuse functionality they are flushed.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Restrictions imposed on the environment</h5>

    <p class="text-gray-300">It is easy to see that the model above confers such sweeping power on the adversary that one cannot establish any significant guarantees on protocols of interest. It is thus important to restrict the environment suitably (taking into account the details of the protocol) so that we may be able to argue security. We require that in every slot, at most a minority fraction <span class="math">\\delta&lt;1/2</span> of the stake is controlled by the adversary in the view of any honest stakeholder; for a value <span class="math">\\delta</span> to be specified later as part of the protocol analysis. If this is violated, an event <span class="math">\\mathsf{Bad}^{\\delta}</span> becomes true for the given execution. When the environment spawns a new stakeholder by sending message <span class="math">(\\text{\\sf Create},U,\\mathcal{C})</span> to the Key and Transaction functionality, the initial local chain <span class="math">\\mathcal{C}</span> can be the chain of any honest stakeholder even in the case of “lazy honest” stakeholders as described in Appendix H, without requiring this stakeholder to have been online in the past slot as in <em>[x13]</em>. Finally, we note that in all of our proofs, whenever we say that a property <span class="math">Q</span> holds with high probability over all executions, we will in fact argue that <span class="math">Q\\vee\\mathsf{Bad}^{\\delta}</span> holds with high probability over all executions. This captures the fact that we exclude environments and adversaries that trigger <span class="math">\\mathsf{Bad}^{\\delta}</span> with non-negligible probability.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Random Oracle</h5>

    <p class="text-gray-300">We also assume the availability of a random oracle. As usually, this is a function <span class="math">\\mathsf{H}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{w}</span> available to all parties that answers every fresh query with an independent, uniformly random string from <span class="math">\\{0,1\\}^{w}</span>, while any repeated queries are answered consistently.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Erasures</h5>

    <p class="text-gray-300">We assume that honest users can carry out secure erasure, a standard assumption for protocols with security against adaptive adversaries; see, for example, <em>[x16]</em>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">2.2 Transaction Ledger Properties</h3>

    <p class="text-gray-300">We adopt the same definitions for transaction ledger properties as <em>[x13]</em>. A protocol <span class="math">\\Pi</span> implements a robust transaction ledger provided that the ledger that <span class="math">\\Pi</span> maintains is divided into “blocks” attributed to slots so that each slot is associated with at most one ledger block; this association then determines the order with which transactions are incorporated in the ledger. It should also satisfy the following two properties.</p>

    <p class="text-gray-300">[leftmargin=<em>] <span class="math">\\textbf{Persistence with parameter }k\\in\\mathbb{N}.</span> Once a node of the system proclaims a certain transaction <span class="math">tx</span> in the </em>stable<em> part of its ledger, the remaining nodes, if queried, will either report <span class="math">tx</span> in the same position of that ledger or report a stable ledger which is a prefix of that ledger. Here the notion of stability is a predicate that is parameterized by a security parameter <span class="math">k</span>; specifically, a transaction is declared </em>stable* if and only if it is in a block that is more than <span class="math">k</span> blocks deep in the ledger.</p>

    <p class="text-gray-300">Liveness with parameter <span class="math">u\\in\\mathbb{N}</span>. If all honest nodes in the system attempt to include a certain transaction then, after the passing of time corresponding to <span class="math">u</span> slots (called the transaction confirmation time), all nodes, if queried and responding honestly, will report the transaction as stable.</p>

    <p class="text-gray-300">In <em>[x13, x15]</em> it was shown that persistence and liveness can be derived from elementary “chain properties” provided that protocol <span class="math">\\Pi</span> derives the ledger from a data structure in the form of a blockchain. We work with an adaptation of these properties formulated in <em>[x12]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Prefix (CP); with parameter <span class="math">k\\in\\mathbb{N}</span>. The chains <span class="math">\\mathcal{C}_{1},\\mathcal{C}_{2}</span> adopted by two honest parties at the onset of the slots <span class="math">\\mathsf{sl}_{1}\\leq\\mathsf{sl}_{2}</span> are such that <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rceil}\\preceq\\mathcal{C}_{2}</span>, where <span class="math">\\mathcal{C}_{1}^{\\lceil k\\rceil}</span> denotes the chain obtained by removing the last <span class="math">k</span> blocks from <span class="math">\\mathcal{C}_{1}</span>, and <span class="math">\\preceq</span> denotes the prefix relation.</li>

      <li>Honest-Bounded Chain Growth (HCG); with parameters <span class="math">\\tau\\in(0,1]</span> and <span class="math">s\\in\\mathbb{N}</span>. Consider the chain <span class="math">\\mathcal{C}</span> adopted by an honest party. Let <span class="math">\\mathsf{sl}_{2}</span> be the slot associated with the last block of <span class="math">\\mathcal{C}</span> and let <span class="math">\\mathsf{sl}_{1}</span> be a prior slot in which <span class="math">\\mathcal{C}</span> has an honestly-generated block. If <span class="math">\\mathsf{sl}_{2}\\geq\\mathsf{sl}_{1}+s</span>, then the number of blocks appearing in <span class="math">\\mathcal{C}</span> after <span class="math">\\mathsf{sl}_{1}</span> is at least <span class="math">\\tau s</span>. The parameter <span class="math">\\tau</span> is called the speed coefficient.</li>

      <li>Existential Chain Quality (<span class="math">\\exists\\mathsf{CQ}</span>); with parameter <span class="math">s\\in\\mathbb{N}</span>. Consider the chain <span class="math">\\mathcal{C}</span> adopted by an honest party at the onset of a slot and any portion of <span class="math">\\mathcal{C}</span> spanning <span class="math">s</span> prior slots; then at least one honestly-generated block appears in this portion.</li>

    </ul>

    <p class="text-gray-300">We remark that <span class="math">\\exists\\mathsf{CQ}</span> and <span class="math">\\mathsf{HCG}</span> can be combined in a straightforward way to yield a more general notion of chain growth, described below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain Growth (CG); with parameters <span class="math">\\tau\\in(0,1]</span> and <span class="math">s\\in\\mathbb{N}</span>. Consider the chain <span class="math">\\mathcal{C}</span> possessed by an honest party at the onset of a slot and any portion of <span class="math">\\mathcal{C}</span> spanning <span class="math">s</span> contiguous prior slots; then the number of blocks appearing in this portion of the chain is at least <span class="math">\\tau s</span>. We call <span class="math">\\tau</span> the speed coefficient.</li>

    </ul>

    <p class="text-gray-300">Our choice to focus on <span class="math">\\exists\\mathsf{CQ}</span> and <span class="math">\\mathsf{HCG}</span> is motivated by analytic concerns.</p>

    <h2 id="sec-30" class="text-2xl font-bold">3 The Static Stake Protocol</h2>

    <p class="text-gray-300">We first consider the static stake case, where the stake distribution is fixed throughout protocol execution. The general structure of the protocol in the semi-synchronous model is similar to that of (synchronous) Ouroboros <em>[x12]</em> but introduces several fundamental modifications to the leader selection process: not all slots will be attributed a slot leader, some slots might have multiple slot leaders, and slot leaders’ identities remain unknown until they act. The first modification is used to deal with delays in the semi-synchronous network as the <em>empty slots</em>—where no block is generated—assist the honest parties to synchronize. The last modification is used to deal with adaptive corruptions, as it prevents the adversary from learning the slot leaders’ identity ahead of time and using this knowledge to strategically corrupt coalitions of parties with large (future) influence. Moreover, instead of using concrete instantiations of the necessary building blocks, we describe the protocol with respect to <em>ideal functionalities</em>, which we later realize with concrete constructions. This difference allows us to reason about security in the ideal model through a combinatorial argument without having to deal with the probability that the cryptographic building blocks fail. Before describing the specifics of the new leader selection process and the new protocol, we first formally define the static stake scenario and introduce basic definitions as stated in <em>[x12]</em> following the notation of <em>[x10]</em>.</p>

    <p class="text-gray-300">In the static stake case, we assume that a fixed collection of <span class="math">n</span> stakeholders <span class="math">U_{1},\\ldots,U_{n}</span> interact throughout the protocol. Stakeholder <span class="math">U_{i}</span> is attributed stake <span class="math">s_{i}</span> at the beginning of the protocol.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 1 (Genesis Block).</h6>

    <p class="text-gray-300">The <em>genesis block</em> <span class="math">B_{0}</span> contains the list of stakeholders identified by a label <span class="math">U_{i}</span>, their respective public keys and respective stakes</p>

    <p class="text-gray-300"><span class="math">\\mathbb{S}_{0}=\\left((U_{1},v_{1}^{\\mathrm{vrf}},v_{1}^{\\mathrm{kes}},v_{1}^{\\mathrm{dsig}},s_{1}),\\ldots,(U_{n},v_{n}^{\\mathrm{vrf}},v_{n}^{\\mathrm{kes}},v_{n}^{\\mathrm{dsig}},s_{n})\\right)\\;,</span></p>

    <p class="text-gray-300">and a nonce <span class="math">\\eta</span>.</p>

    <p class="text-gray-300">We note that the nonce <span class="math">\\eta</span> will be used to seed the slot leader election process and that <span class="math">v_{i}^{\\mathrm{vrf}},v_{i}^{\\mathrm{kes}},v_{i}^{\\mathrm{deig}}</span> will be determined by <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>, <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> and <span class="math">\\mathcal{F}_{\\mathsf{DSIG}}</span>, respectively.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 2 (Epoch, State, Block Proof, Block, Blockchain).</h6>

    <p class="text-gray-300">An <em>epoch</em> starting at some slot <span class="math">\\mathsf{sl}</span> is a set of <span class="math">R</span> adjacent slots <span class="math">S=\\{\\mathsf{sl},\\ldots,\\mathsf{sl}+R-1\\}</span>. (The value <span class="math">R</span> is a parameter of the protocol we analyze in this section.) A <em>state</em> is a string <span class="math">st\\in\\{0,1\\}^{\\lambda}</span>. A <em>block proof</em> is a value (or set of values) <span class="math">crt</span> containing information that allows stakeholders to verify if a block is valid. A <em>block</em> <span class="math">B=(\\mathsf{sl},st,d,crt_{j},\\sigma_{j})</span> generated at a slot <span class="math">\\mathsf{sl}\\in S</span> contains the current state <span class="math">st\\in\\{0,1\\}^{\\lambda}</span>, data <span class="math">d\\in\\{0,1\\}^{*}</span>, the slot number <span class="math">\\mathsf{sl}</span>, a block proof <span class="math">crt_{j}</span> and <span class="math">\\sigma_{j}</span>, a signature on <span class="math">(st,d,\\mathsf{sl},crt_{j})</span> under the signing key for the time period of slot <span class="math">\\mathsf{sl}</span> of the stakeholder <span class="math">U_{i}</span> generating the block.</p>

    <p class="text-gray-300">A <em>blockchain</em> (or simply <em>chain</em>) relative to the genesis block <span class="math">B_{0}</span> is a sequence of blocks <span class="math">B_{1},\\ldots,B_{n}</span> associated with a strictly increasing sequence of slots for which the state <span class="math">st_{i}</span> of <span class="math">B_{i}</span> is equal to <span class="math">H(B_{i-1})</span>, where <span class="math">H</span> is a prescribed collision-resistant hash function. The <em>length</em> of a chain <span class="math">\\mathrm{len}(\\mathcal{C})=n</span> is its number of blocks. The block <span class="math">B_{n}</span> is the <em>head</em> of the chain, denoted <span class="math">\\mathrm{head}(\\mathcal{C})</span>. We treat the empty string <span class="math">\\varepsilon</span> as a legal chain and by convention set <span class="math">\\mathrm{head}(\\varepsilon)=\\varepsilon</span>. Let <span class="math">\\mathcal{C}</span> be a chain of length <span class="math">n</span> and <span class="math">k</span> be any non-negative integer. We denote by <span class="math">\\mathcal{C}^{\\upharpoonright k}</span> the chain resulting from removal of the <span class="math">k</span> rightmost blocks of <span class="math">\\mathcal{C}</span>. If <span class="math">k\\geq\\mathrm{len}(\\mathcal{C})</span> we define <span class="math">\\mathcal{C}^{\\upharpoonright k}=\\varepsilon</span>. We let <span class="math">\\mathcal{C}_{1}\\preceq\\mathcal{C}_{2}</span> indicate that the chain <span class="math">\\mathcal{C}_{1}</span> is a prefix of the chain <span class="math">\\mathcal{C}_{2}</span>.</p>

    <p class="text-gray-300">We consider as valid blocks that are generated by a stakeholder in the slot leader set of the slot to which the block is attributed. Later in Section 3.3 we discuss slot leader sets and how they are selected.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 3 (Absolute and Relative Stake).</h6>

    <p class="text-gray-300">Let <span class="math">U_{\\mathcal{P}}</span>, <span class="math">U_{\\mathcal{A}}</span> and <span class="math">U_{\\mathcal{H}}</span> denote the sets of all stakeholders, the set of stakeholders controlled by an adversary <span class="math">\\mathcal{A}</span>, and the remaining (honest) stakeholders, respectively. For any party (resp. set of parties) <span class="math">X</span> we denote by <span class="math">s_{X}^{\\times}</span> (resp. <span class="math">s_{X}^{-}</span>) the maximum (resp. minimum) <em>absolute stake</em> controlled by <span class="math">X</span> in the view of all honest stakeholders at a given slot, and by <span class="math">\\alpha_{X}^{\\times}\\triangleq s_{X}^{\\times}/s_{\\mathcal{P}}</span> and <span class="math">\\alpha_{X}^{-}\\triangleq s_{X}^{-}/s_{\\mathcal{P}}</span> its <em>relative stake</em> taken as maximum and minimum respectively across the views of all honest stakeholders. For simplicity, we use <span class="math">s_{X}^{\\mathrm{s}},\\alpha_{X}^{\\mathrm{s}}</span> instead of <span class="math">s_{U_{X}},\\alpha_{U_{X}}</span> for all <span class="math">X\\in\\{\\mathcal{P},\\mathcal{A},\\mathcal{H}\\},\\mathrm{s}\\in\\{+,-\\}</span>. We also call <span class="math">\\alpha_{\\mathcal{A}}\\triangleq\\alpha_{\\mathcal{A}}^{\\times}</span> and <span class="math">\\alpha_{\\mathcal{H}}\\triangleq\\alpha_{\\mathcal{H}}^{-}</span> the <em>adversarial stake ratio</em> and <em>honest stake ratio</em>, respectively.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">3.1 Forward Secure Signatures and <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span></h3>

    <p class="text-gray-300">In regular digital signature schemes, an adversary who compromises the signing key of a user can generate signatures for any messages it wishes, including messages that were (or should have been) generated in the past. Forward secure signature schemes <em>[x1]</em> prevent such an adversary from generating signatures for messages that were issued in the past, or rather allows honest users to verify that a given signature was generated at a certain point in time. Basically, such security guarantees are achieved by “evolving” the signing key after each signature is generated and erasing the previous key in such a way that the actual signing key used for signing a message in the past cannot be recovered but a fresh signing key can still be linked to the previous one. This notion is formalized through <em>key evolving signature schemes</em>, which allow signing keys to be evolved into fresh keys for a number of time periods. We remark that efficient constructions of key evolving signature schemes with forward security exist <em>[x10]</em> but no previous work has fully specified them in the UC setting. Previous (game-based) definitions are presented in Appendix A.3.</p>

    <p class="text-gray-300">We present a UC definition of the type of key-evolving signatures that we will take advantage of in our constructions. <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> allows us to achieve forward security with erasures (i.e., assuming that parties securely delete old signing keys as the protocol proceeds). This functionality embodies ideal key evolving signature schemes allowing an adversary that corrupts the signer to forge signatures only under the current and future signing keys, but not under a previous signing key that has been updated. Our starting point for <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> is the standard digital signature functionality defined in <em>[x7]</em> with the difference that packs together with the signing operation a key-evolving operation. During verification, <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> lets the adversary set the response to a verification query (taking as input a given time period) only if no key update has been performed since that time period and no entry exists in its internal table for the specific message, signature and time period specified in the query. We present <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> in Figure 1. In Appendix B, we will show that <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> can be realized by a construction based on key evolving signature schemes as defined in Appendix A.3.</p>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{F}_{\\text{KES}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message <span class="math">(\\text{\\emph{KeyGen}},sid,U_{S})</span> from a stakeholder <span class="math">U_{S}</span>, send <span class="math">(\\text{\\emph{KeyGen}},sid,U_{S})</span> to the adversary. Upon receiving <span class="math">(\\text{\\emph{VerificationKey}},sid,U_{S},v)</span> from the adversary, verify that <span class="math">v</span> is unique and send <span class="math">(\\text{\\emph{VerificationKey}},sid,v)</span> to <span class="math">U_{S}</span>, record the triple <span class="math">(sid,U_{S},v)</span> and set counter <span class="math">\\text{\\emph{k}_{\\text{ctr}}}={1}</span>.</li>

      <li>Sign and Update. Upon receiving a message <span class="math">(\\text{\\emph{USign}},sid,U_{S},m,j)</span> from <span class="math">U_{S}</span>, verify that <span class="math">(sid,U_{S},v)</span> is recorded for some <span class="math">sid</span> and that <span class="math">\\text{\\emph{k}_{\\text{ctr}}}\\leq j\\leq T</span>. If not, then ignore the request. Else, set <span class="math">\\text{\\emph{k}_{\\text{ctr}}}={j+1}</span> and send <span class="math">(\\text{\\emph{Sign}},sid,U_{S},m,j)</span> to the adversary. Upon receiving <span class="math">(\\text{\\emph{Signature}},sid,U_{S},m,j,\\sigma)</span> from the adversary, verify that no entry <span class="math">(m,j,\\sigma,v,0)</span> is recorded. If it is, then output an error message to <span class="math">U_{S}</span> and halt. Else, send <span class="math">(\\text{\\emph{Signature}},sid,m,j,\\sigma)</span> to <span class="math">U_{S}</span>, and record the entry <span class="math">(m,j,\\sigma,v,1)</span>.</li>

      <li>Signature Verification. Upon receiving a message <span class="math">(\\text{\\emph{Verify}},sid,m,j,\\sigma,v^{\\prime})</span> from some stakeholder <span class="math">U_{i}</span> do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v^{\\prime}=v</span> and the entry <span class="math">(m,j,\\sigma,v,1)</span> is recorded, then set <span class="math">f=1</span>. (This condition guarantees completeness: If the verification key <span class="math">v^{\\prime}</span> is the registered one and <span class="math">\\sigma</span> is a legitimately generated signature for <span class="math">m</span>, then the verification succeeds.)</li>

      <li>Else, if <span class="math">v^{\\prime}=v</span>, the signer is not corrupted, and no entry <span class="math">(m,j,\\sigma^{\\prime},v,1)</span> for any <span class="math">\\sigma^{\\prime}</span> is recorded, then set <span class="math">f=0</span> and record the entry <span class="math">(m,j,\\sigma,v,0)</span>. (This condition guarantees unforgeability: If <span class="math">v^{\\prime}</span> is the registered one, the signer is not corrupted, and never signed <span class="math">m</span>, then the verification fails.)</li>

      <li>Else, if there is an entry <span class="math">(m,j,\\sigma,v^{\\prime},f^{\\prime})</span> recorded, then let <span class="math">f=f^{\\prime}</span>. (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>

      <li>Else, if <span class="math">j&lt;\\text{\\emph{k}_{\\text{ctr}}}</span>, let <span class="math">f=0</span> and record the entry <span class="math">(m,j,\\sigma,v,0)</span>. Otherwise, if <span class="math">j=\\text{\\emph{k}_{\\text{ctr}}}</span>, hand <span class="math">(\\text{\\emph{Verify}},sid,m,j,\\sigma,v^{\\prime})</span> to the adversary. Upon receiving <span class="math">(\\text{\\emph{Verified}},sid,m,j,\\phi)</span> from the adversary let <span class="math">f=\\phi</span> and record the entry <span class="math">(m,j,\\sigma,v^{\\prime},\\phi)</span>. (This condition guarantees that the adversary is only able to forge signatures under keys belonging to corrupted parties for time periods corresponding to the current or future slots.)</li>

    </ol>

    <p class="text-gray-300">Output <span class="math">(\\text{\\emph{Verified}},sid,m,j,f)</span> to <span class="math">U_{i}</span>.</p>

    <p class="text-gray-300">Figure 1: Functionality <span class="math">\\mathcal{F}_{\\text{KES}}</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The <span class="math">\\pi_{\\text{KES}}</span> construction presented in Appendix B, realizes <span class="math">\\mathcal{F}_{\\text{KES}}</span> with erasures assuming <span class="math">\\text{\\emph{KES}}=({\\text{\\emph{Gen}},{\\text{\\emph{Sign}},{\\text{\\emph{Verify}},{\\text{\\emph{Update}}}}})</span> is a key evolving signature scheme with forward security as per Definition 17 and Definition 19.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Note that the signing operation in a key-evolving signature is a <em>local</em> operation performed by the signer. To reflect this in our formalism, we require that whenever the adversary is activated to provide a signature, she has to provide the answer (i.e. the signature string) to this request immediately (no other output to another protocol machine is allowed) and return the activation token back to the functionality <span class="math">\\mathcal{F}_{\\text{KES}}</span>. We remark that while we do not aim for a fully composable security analysis of Ouroboros Praos in this work, this type of restriction can also be captured in the full UC setting, as is done in <em>[BGK^{+}18]</em> using the formalism proposed by Camenisch et al. <em>[CEK^{+}16]</em>.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">3.2 UC-VRFs with Unpredictability Under Malicious Key Generation</h3>

    <p class="text-gray-300">The usual pseudorandomness definition for VRFs (as stated in Appendix A.1, Definition 16) captures the fact that an attacker, seeing a number of VRF outputs and proofs for adversarially chosen inputs under a key pair that is correctly generated by a challenger, cannot distinguish the output of the VRF on a new (also adversarially chosen) input from a truly random string. This definition is too weak for our purposes for two reasons: first, we need a simulation-based definition so that the VRF can be composed directly within our protocol; second, we need the primitive to provide some level of unpredictability even under malicious key generation, <em>i.e.,</em> against adversaries who are allowed to generate the secret and public key pair.</p>

    <p class="text-gray-300">Our UC formulation of VRFs cannot be implied by the standard VRF security definition or even the simulatable VRF notion of <em>[x10]</em>. For instance, the VRF proofs in our setting have to be</p>

    <p class="text-gray-300">simulatable without knowlege of the VRF output (which is critical as we would like to ensure that the VRF output is not leaked to the adversary prematurely); it is easy to construct a VRF that is secure in the standard definition, but it is impossible to simulate its proofs without knowledge of the VRF output. Furthermore, if the adversary is allowed to generate its own key pair it is easy to see that the distribution of the VRF outputs cannot be guaranteed. Indeed, even for known constructions (e.g. <em>[x10]</em>), an adversary that maliciously generates keys can easily and significantly skew the output distribution.</p>

    <p class="text-gray-300">We call the latter property <em>unpredictability under malicious key generation</em> and we present, in Figure 2, a UC definition for VRF’s that captures this stronger security requirement. The functionality operates as follows. Given a key generation request from one of the stakeholders, it returns a new verification key <span class="math">v</span> that is used to label a table. Two methods are provided for computing VRF values. The first provides just the VRF output and does not interact with the adversary. In the second, whenever invoked on an input <span class="math">m</span> that has not been asked before by a stakeholder that is associated to a certain table labeled by <span class="math">v</span>, the functionality will query the adversary for the value of the proof <span class="math">\\pi</span>, and subsequently sample a random element <span class="math">\\rho</span> to associate with <span class="math">m</span>. Verification is always consistent and will validate outputs that have already been inserted in a table. Unpredictability against malicious key generation is captured by imposing the same random selection of outputs even for the function tables that correspond to keys of corrupted stakeholders. Finally, the adversary is allowed to query all function tables maintained by the functionality for which either a proof has been computed, or they correspond to adversarial keys. In Appendix C, we show how to realize <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> in the random oracle model under the CDH assumption based on the 2-Hash-DH verifiable oblivious PRF construction of <em>[x16]</em>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">The 2Hash-DH construction presented in Appendix C, realizes <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span> in the random oracle model assuming the CDH.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">3.3 Oblivious Leader Selection</h3>

    <p class="text-gray-300">As in (synchronous) Ouroboros, for each slot <span class="math">0&lt;\\mathfrak{sl}\\leq R</span>, a <em>slot leader</em> for <span class="math">\\mathfrak{sl}</span> is a stakeholder who is elected to generate a block at slot <span class="math">\\mathfrak{sl}</span>. However, our leader selection process differs from Ouroboros <em>[x21]</em> in three points: (1) potentially, multiple slot leaders may be elected for a particular slot (forming a <em>slot leader set</em>); (2) frequently, slots will have <em>no leaders</em> assigned to them; and (3) a priori, only a slot leader is aware that it is indeed a leader for a given slot; this assignment is unknown to all the other stakeholders—including other slot leaders of the same slot—until the other stakeholders receive a valid block from this slot leader. The combinatorial analysis presented in Section 4 shows (with an honest stake majority) that (i.) blockchains generated according to these dynamics are well-behaved even if multiple slot leaders are selected for a slot and that (ii.) sequences of slots with no leader provide sufficient stability for honest stakeholders to effectively synchronize. As a matter of terminology, we call slots with an associated nonempty slot leader set <em>active slots</em> and slots that are not assigned a slot leader <em>empty slots</em>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">The idealized slot leader assignment and the active slots coefficient.</h4>

    <p class="text-gray-300">The fundamental leader assignment process calls for a stakeholder <span class="math">U_{i}</span> to be independently selected as a leader for a particular slot <span class="math">\\mathfrak{sl}</span> with probability <span class="math">p_{i}</span> depending only on its relative stake. (In this static-stake analysis, relative stake is simply determined by the genesis block <span class="math">B_{0}</span>.) The exact relationship between <span class="math">p_{i}</span> and the relative stake <span class="math">\\alpha_{i}</span> is determined by a parameter <span class="math">f</span> of the protocol which we refer to as the <em>active slots coefficient</em>. Specifically,</p>

    <p class="text-gray-300"><span class="math">p_{i}=\\phi_{f}(\\alpha_{i})\\triangleq 1-(1-f)^{\\alpha_{i}}\\;,</span> (1)</p>

    <p class="text-gray-300">where <span class="math">\\alpha_{i}</span> is the relative stake held by stakeholder <span class="math">U_{i}</span>. We occasionally drop the subscript <span class="math">f</span> and write <span class="math">\\phi(\\alpha_{i})</span> when <span class="math">f</span> can be inferred from context. As the events “<span class="math">U_{i}</span> is a leader for <span class="math">\\mathfrak{sl}</span>” are independent, this process may indeed generate multiple (or zero) leaders for a given slot.</p>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> interacts with stakeholders <span class="math">U_{1},\\ldots ,U_{n}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message (KeyGen, sid) from a stakeholder <span class="math">U_{i}</span>, hand (KeyGen, sid, <span class="math">U_{i}</span>) to the adversary. Upon receiving (VerificationKey, sid, <span class="math">U_{i}, v</span>) from the adversary, if <span class="math">U_{i}</span> is honest, verify that <span class="math">v</span> is unique, record the pair <span class="math">(U_{i}, v)</span> and return (VerificationKey, sid, <span class="math">v</span>) to <span class="math">U_{i}</span>. Initialize the table <span class="math">T(v, \\cdot)</span> to empty.</li>

      <li>Malicious Key Generation. Upon receiving a message (KeyGen, sid, v) from <span class="math">S</span>, verify that <span class="math">v</span> has not been recorded before; in this case initialize table <span class="math">T(v, \\cdot)</span> to empty and record the pair <span class="math">(S, v)</span>.</li>

      <li>VRF Evaluation. Upon receiving a message (Eval, sid, m) from <span class="math">U_{i}</span>, verify that some pair <span class="math">(U_{i}, v)</span> is recorded. If not, then ignore the request. Then, if the value <span class="math">T(v, m)</span> is undefined, pick a random value <span class="math">y</span> from <span class="math">\\{0, 1\\}^{\\ell_{\\mathsf{VRF}}}</span> and set <span class="math">T(v, m) = (y, \\emptyset)</span>. Then output (Evaluated, sid, y) to <span class="math">U_{i}</span>, where <span class="math">y</span> is such that <span class="math">T(v, m) = (y, S)</span> for some <span class="math">S</span>.</li>

      <li>VRF Evaluation and Proof. Upon receiving a message (EvalProve, sid, m) from <span class="math">U_{i}</span>, verify that some pair <span class="math">(U_{i}, v)</span> is recorded. If not, then ignore the request. Else, send (EvalProve, sid, <span class="math">U_{i}, m</span>) to the adversary. Upon receiving (EvalProve, sid, <span class="math">m, \\pi</span>) from the adversary, if value <span class="math">T(v, m)</span> is undefined, verify that <span class="math">\\pi</span> is unique, pick a random value <span class="math">y</span> from <span class="math">\\{0, 1\\}^{\\ell_{\\mathsf{VRF}}}</span> and set <span class="math">T(v, m) = (y, \\{\\pi\\})</span>. Else, if <span class="math">T(v, m) = (y, S)</span>, set <span class="math">T(v, m) = (y, S \\cup \\{\\pi\\})</span>. In any case, output (Evaluated, sid, <span class="math">y, \\pi</span>) to <span class="math">U_{i}</span>.</li>

      <li>Malicious VRF Evaluation. Upon receiving a message (Eval, sid, v, m, π) from S for some v, do the following. First, if (S, v) is recorded and T(v, m) is undefined, then choose a random value y from {0,1} <span class="math">^{\\ell_{\\mathsf{VRF}}}</span> and set T(v, m) = (y, S) and output (Evaluated, sid, y) to S. The same is performed in case (U_i, v) is recorded and U_i corrupted. Else, if T(v, m) = (y, S') for some S' ≠ ∅, union S to S' and output (Evaluated, sid, y) to S, else ignore the request.</li>

      <li>Verification. Upon receiving a message (Verify, sid, m, y, π, v') from some party P, send (Verify, sid, m, y, π, v') to the adversary. Upon receiving (Verified, sid, m, y, π, v') from the adversary do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v&#x27; = v</span> for some <span class="math">(\\cdot, v)</span> and the entry <span class="math">T(v, m)</span> equals <span class="math">(y, S)</span> with <span class="math">\\pi \\in S</span>, then set <span class="math">f = 1</span>.</li>

      <li>Else, if <span class="math">v&#x27; = v</span> for some recorded pair of the form <span class="math">(\\cdot, v)</span>, but no entry <span class="math">T(v, m)</span> of the form <span class="math">(y, \\{\\dots, \\pi, \\dots\\})</span> is recorded, then set <span class="math">f = 0</span>.</li>

      <li>Else, initialize the table <span class="math">T(v&#x27;, \\cdot)</span> to empty, and set <span class="math">f = 0</span>.</li>

    </ol>

    <p class="text-gray-300">Output (Verified, sid, m, y, π, f) to P.</p>

    <p class="text-gray-300">Fig. 2: Functionality <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>.</p>

    <p class="text-gray-300">Remarks about <span class="math">\\phi_f(\\cdot)</span>. Observe that <span class="math">\\phi_f(1) = f</span>; in particular, the parameter <span class="math">f</span> is the probability that a party holding all the stake will be selected to be a leader for given slot. On the other hand, <span class="math">\\phi_f()</span> is not linear, but slightly concave; see Figure 7. To motivate the choice of the function <span class="math">\\phi_f</span>, we note that it satisfies the "independent aggregation" property:</p>

    <div class="my-4 text-center"><span class="math-block">1 - \\phi \\left(\\sum_{i} \\alpha_{i}\\right) = \\prod_{i} \\left(1 - \\phi (\\alpha_{i})\\right). \\tag{2}</span></div>

    <p class="text-gray-300">In particular, when leadership is determined according to <span class="math">\\phi_f</span>, the probability of a stakeholder becoming a slot leader in a particular slot is independent of whether this stakeholder acts as a single party in the protocol, or splits its stake among several "virtual" parties. In particular, consider a party <span class="math">U</span> with relative stake <span class="math">\\alpha</span> who contrives to split its stake among two virtual subordinate parties with stakes <span class="math">\\alpha_1</span> and <span class="math">\\alpha_2</span> (so that <span class="math">\\alpha_1 + \\alpha_2 = \\alpha</span>). Then the probability that one of these virtual parties is elected for a particular slot is <span class="math">1 - (1 - \\phi(\\alpha_1))(1 - \\phi(\\alpha_2))</span>, as these events are independent. Property (2) guarantees that this is identical to <span class="math">\\phi(\\alpha)</span>. Thus this selection rule is invariant under arbitrary reapportionment of a party's stake among virtual parties.</p>

    <h2 id="sec-41" class="text-2xl font-bold">3.4 The Protocol in the <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>-hybrid Model</h2>

    <p class="text-gray-300">We will construct our protocol for the static stake case in the <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>-hybrid model, where the genesis stake distribution <span class="math">\\mathbb{S}_0</span> and the nonce <span class="math">\\eta</span> (to be written in the genesis block <span class="math">B_0</span>) are determined by the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> defined in Figure 3. Moreover, <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> also incorporates the diffuse functionality from Section 2.1, which is implicitly used by all parties to send messages and keep synchronized with a global clock. <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> also takes stakeholders' public keys from them and packages</p>

    <p class="text-gray-300">them into the genesis block at the outset of the protocol. Note that  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  halts if it is not possible to create a genesis block; all security guarantees we provide later in the paper are conditioned on a successful creation of the genesis block.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  incorporates the delayed diffuse functionality from Section 2.1 and is parameterized by the number of initial stakeholders  <span class="math">n</span>  and their respective stakes  <span class="math">s_1, \\ldots, s_n</span> .  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  interacts with stakeholders  <span class="math">U_1, \\ldots, U_n</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round, upon a request from some stakeholder  <span class="math">U_{i}</span>  of the form (ver_keys, sid,  <span class="math">U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}, v_{i}^{\\mathrm{disig}}</span> ), it stores the verification keys tuple  <span class="math">(U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}, v_{i}^{\\mathrm{disig}})</span>  and acknowledges its receipt. If any of the  <span class="math">n</span>  stakeholders does not send a request of this form to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> , or if two different stakeholders provide two identical keys, it halts. Otherwise, it samples and stores a random value  <span class="math">\\eta \\stackrel{\\mathrm{s}}{\\leftarrow} \\{0,1\\}^{\\mathrm{A}}</span>  and constructs a genesis block  <span class="math">(\\mathbb{S}_0, \\eta)</span> , where  <span class="math">\\mathbb{S}_0 = \\left((U_1, v_1^{\\mathrm{vrf}}, v_1^{\\mathrm{kes}}, v_1^{\\mathrm{disig}}, s_1), \\ldots, (U_n, v_n^{\\mathrm{vrf}}, v_n^{\\mathrm{kes}}, v_n^{\\mathrm{disig}}, s_n)\\right)</span> .</li>

      <li>In later rounds, upon a request of the form (genblock_req, sid,  <span class="math">U_{i}</span> ) from some stakeholder  <span class="math">U_{i}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  sends (genblock, sid,  <span class="math">\\mathbb{S}_0, \\eta</span> ) to  <span class="math">U_{i}</span> .</li>

    </ul>

    <p class="text-gray-300">Fig. 3: Functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span></p>

    <p class="text-gray-300">Blocks are signed with a forward secure signature scheme modelled by  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span> , while transactions are signed with a regular EUF-CMA secure digital signature modelled by  <span class="math">\\mathcal{F}_{\\mathrm{DSIG}}</span>  (described in Appendix A).</p>

    <p class="text-gray-300">Notice that the implicit leader assignment process described in  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  calls for a party  <span class="math">U_{i}</span>  to act as a leader for a slot  <span class="math">\\mathsf{sl}</span>  when  <span class="math">y &amp;lt; T_{i}</span> ; this is an event that occurs with probability (exponentially close to)  <span class="math">\\phi_f(\\alpha_i)</span>  as  <span class="math">y</span>  is uniform according to the functionality  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> .</p>

    <p class="text-gray-300">We are interested in applications where transactions are inserted in the ledger. For simplicity, transactions are assumed to be simple assertions of the form "Stakeholder  <span class="math">U_{i}</span>  transfers stake  <span class="math">s</span>  to Stakeholder  <span class="math">(U_{j}, v_{j}^{\\mathrm{vrf}}, v_{j}^{\\mathrm{kes}}, v_{j}^{\\mathrm{disig}})</span> " (In an implementation the different public-keys can be hashed into a single value). Protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  ensures that the environment learns every stakeholder's public keys and provides an interface for the environment to request signatures on arbitrary transactions. A transaction will consist of a transaction template  <span class="math">tx</span>  of this format accompanied by a signature of  <span class="math">tx</span>  by stakeholder  <span class="math">U_{i}</span> . We define a valid transaction as follows:</p>

    <p class="text-gray-300">Definition 4 (Valid Transaction). A pair  <span class="math">(tx, \\sigma)</span>  is considered a valid transaction by a verifier  <span class="math">\\mathsf{V}</span>  if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The transaction template  <span class="math">tx</span>  is of the format "Stakeholder  <span class="math">U_i</span>  transfers stake  <span class="math">s</span>  to Stakeholder  <span class="math">(U_j, v_j^{\\mathrm{vrf}}, v_j^{\\mathrm{kes}}, v_j^{\\mathrm{disig}})</span> " where  <span class="math">U_i</span>  and  <span class="math">U_j</span>  are stakeholders identified by tuples  <span class="math">(U_i, v_i^{\\mathrm{vrf}}, v_i^{\\mathrm{kes}}, v_i^{\\mathrm{disig}})</span>  and  <span class="math">(U_j, v_j^{\\mathrm{vrf}}, v_j^{\\mathrm{kes}}, v_j^{\\mathrm{disig}})</span>  contained in the current stake distribution  <span class="math">\\mathbb{S}</span>  and  <span class="math">x \\in \\mathbb{Z}</span> .</li>

      <li>The verifier  <span class="math">V</span>  obtains (Verified,  <span class="math">m, 1</span> ) as answer upon sending (Verify,  <span class="math">tx, \\sigma, v_i^{\\mathrm{disig}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{DSIG}}</span> .</li>

      <li>Stakeholder  <span class="math">U_{i}</span>  possesses  <span class="math">x</span>  coins at the moment the transaction is issued (or registered in the blockchain) according to the view of the verifier  <span class="math">\\mathsf{V}</span> .</li>

    </ul>

    <p class="text-gray-300">Given Definitions 2 and 4, we define a valid chain as a blockchain (according to Definition 2) where all transactions contained in every block are valid (according to Definition 4). The stakeholders  <span class="math">U_{1}, \\ldots, U_{n}</span>  interact among themselves and with  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  through Protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  described in Figure 4. The protocol relies on a maxvalid  <span class="math">S(\\mathcal{C}, \\mathbb{C})</span>  function that chooses a chain given the current chain  <span class="math">\\mathcal{C}</span>  and a set of valid chains  <span class="math">\\mathbb{C}</span>  that are available in the network. In the static stake case we analyze the simple "longest chain" rule.</p>

    <p class="text-gray-300">Function maxvalid  <span class="math">(\\mathcal{C},\\mathbb{C})</span>  : Returns the longest chain from  <span class="math">\\mathbb{C}\\cup \\{\\mathcal{C}\\}</span>  . Ties are broken in favor of  <span class="math">\\mathcal{C}</span>  , if it has maximum length, or arbitrarily otherwise.</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  is run by stakeholders  <span class="math">U_{1},\\ldots ,U_{n}</span>  interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{\\mathrm{INIT}},\\mathcal{F}_{\\mathrm{VRF}},\\mathcal{F}_{\\mathrm{KES}},\\mathcal{F}_{\\mathrm{DSIG}},\\mathsf{H}</span>  over a sequence of slots  <span class="math">S = \\{1,\\dots ,R\\}</span> . Define  <span class="math">T_{i}\\triangleq 2^{t_{\\mathrm{VRF}}}\\phi_{f}(\\alpha_{i})</span>  as the threshold for a stakeholder  <span class="math">U_{i}</span> , where  <span class="math">\\alpha_{i}</span>  is the relative stake of  <span class="math">U_{i}</span> ,  <span class="math">\\ell_{\\mathrm{VRF}}</span>  denotes the output length of  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> ,  <span class="math">f</span>  is the active slots coefficient and  <span class="math">\\phi_f</span>  is the mapping from equation (1). Then  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  proceeds as follows for each stakeholder  <span class="math">U_{i}</span> :</p>

    <p class="text-gray-300">(a)  <span class="math">U_{i}</span>  sends (KeyGen,  <span class="math">sid, U_{i}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> ,  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{DSIG}}</span> ; receiving (VerificationKey,  <span class="math">sid, v_{i}</span> ) for  <span class="math">v_{i} \\in \\{v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}, v_{i}^{\\mathrm{disig}}\\}</span> , respectively. Then, in case it is the first round, it sends (ver_keys,  <span class="math">sid, U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}, v_{i}^{\\mathrm{disig}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  to claim stake from the genesis block. In any case, it terminates the round by returning  <span class="math">(U_{i}, v_{i}^{\\mathrm{vrf}}, v_{i}^{\\mathrm{kes}}, v_{i}^{\\mathrm{disig}})</span>  to  <span class="math">\\mathcal{Z}</span> . (b) In the next round,  <span class="math">U_{i}</span>  sends (genblock_req,  <span class="math">sid, U_{i}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> , receiving (genblock,  <span class="math">sid, \\mathbb{S}_0, \\eta</span> ). If  <span class="math">U_{i}</span>  is initialized in the first round, it sets the local blockchain to  <span class="math">\\mathcal{C} = B_0 = (\\mathbb{S}_0, \\eta)</span>  otherwise it receives the local blockchain  <span class="math">\\mathcal{C}</span>  from the environment.</p>

    <p class="text-gray-300">After initialization, for every slot  <span class="math">\\mathsf{sl}_{\\mathrm{now}} \\in S</span> , every online stakeholder  <span class="math">U_{i}</span>  performs the following steps:</p>

    <p class="text-gray-300">(a)  <span class="math">U_{i}</span>  collects all valid chains received via diffusion into a set  <span class="math">\\mathbb{C}</span> , verifying that for every chain  <span class="math">\\mathcal{C}&#x27; \\in \\mathbb{C}</span> , every block  <span class="math">B = (st, d, \\mathsf{sl}, crt, \\sigma) \\in \\mathcal{C}&#x27;</span>  with  <span class="math">crt = (U_s, y, \\pi)</span>  satisfies:</p>

    <p class="text-gray-300">(i)  <span class="math">\\mathsf{sl}\\leq \\mathsf{sl}_{\\mathrm{now}}</span>  and  <span class="math">y &amp;lt;   T_{s}</span> (ii)  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  answers (Verify,  <span class="math">sid,\\eta \\parallel \\mathsf{sl},y,\\pi ,v_s^{\\mathrm{vrf}})</span>  by (Verified,  <span class="math">sid,\\eta \\parallel \\mathsf{sl},y,\\pi ,1)</span> (iii)  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  answers (Verify,  <span class="math">sid,(st,d,\\mathsf{sl},crt),\\mathsf{sl},\\sigma ,v_s^{\\mathrm{kes}})</span>  by (Verified,  <span class="math">sid,(st,d,\\mathsf{sl},crt),\\mathsf{sl},1)</span> (b)  <span class="math">U_{i}</span>  computes  <span class="math">\\mathcal{C} \\coloneqq \\text{maxvalid}(\\mathcal{C}, \\mathbb{C})</span>  and sets  <span class="math">\\mathcal{C}</span>  as the new local chain.</p>

    <p class="text-gray-300">(a)  <span class="math">U_{i}</span>  sends (EvalProve,  <span class="math">sid,\\eta \\parallel \\mathsf{sl}_{\\mathrm{now}}</span>  ) to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  , receiving (Evaluated,  <span class="math">sid,y,\\pi</span> (b)  <span class="math">U_{i}</span>  checks whether  <span class="math">y &amp;lt; T_{i}</span> . If yes, it chooses a maximal sequence  <span class="math">d&#x27;</span>  of transactions in  <span class="math">d^{*}</span>  such that adding a block with  <span class="math">d&#x27;</span>  to  <span class="math">\\mathcal{C}</span>  results in a valid chain, and attempts to include  <span class="math">d&#x27;</span>  as follows: It generates a new block  <span class="math">B = (st, d&#x27;, \\mathsf{sl}_{\\mathrm{now}}, crt, \\sigma)</span>  where  <span class="math">st = \\mathsf{H}(\\mathrm{head}(\\mathcal{C}))</span> ,  <span class="math">crt = (U_{i}, y, \\pi)</span>  and  <span class="math">\\sigma</span>  is a signature obtained by sending (USign,  <span class="math">sid, U_{i}</span> ,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathrm{now}}, crt), \\mathsf{sl}_{\\mathrm{now}}</span> ) to  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  and receiving (Signature,  <span class="math">sid</span> ,  <span class="math">(st, d&#x27;, \\mathsf{sl}_{\\mathrm{now}}, crt), \\mathsf{sl}_{\\mathrm{now}}, \\sigma</span> ).  <span class="math">U_{i}</span>  computes  <span class="math">\\mathcal{C} = \\mathcal{C} \\parallel B</span> , sets it as the new local chain and diffuses  <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">Fig. 4: Protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span></p>

    <p class="text-gray-300">Throughout this section, we focus solely on analysis of the protocol  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  using the idealized functionalities  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  for VRFs and digital signatures, respectively—we refer to it as the hybrid experiment. As argued in Theorems 1 and 2, any property of the protocol that we prove true in the hybrid experiment (such as achieving common prefix, chain growth and chain quality) will remain true (with overwhelming probability) in the setting where  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  and  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  are replaced by their real-world implementations—in the so-called real experiment.</p>

    <p class="text-gray-300">The hybrid experiment yields a stochastic process for assigning slots to parties which we now abstract and study in detail. Our analysis of the resulting blockchain dynamics proceeds roughly as follows: We begin by generalizing the framework of "forks" [KRDO17] to our semi-synchronous setting—forks are a natural bookkeeping tool that reflect the valid chains adopted (or observed) by honest players during an execution of the protocol. We then establish a simulation rule that associates with each execution of the semi-synchronous protocol an execution of a related "virtual" synchronous protocol. Motivated by the special case of a static adversary—which simply corrupts a family of parties at the outset of the protocol—we identify a natural "generic" probability distribution for this simulation theorem which we prove controls the behavior of adaptive adversaries by stochastic domination. Finally, we prove that this simulation amplifies the effective power of the adversary in a controlled fashion and, furthermore, permits forks of the semi-synchronous protocol to be projected to forks of the virtual protocol in a way that preserves their relevant combinatorial properties. This</p>

    <p class="text-gray-300">allows us to apply the density theorems and divergence result of <em>[x13, x14]</em> to provide strong common prefix, chain growth, and chain quality (4.7) guarantees for the semi-synchronous protocol with respect to an adaptive adversary.</p>

    <p class="text-gray-300">We begin in Section 4.1 with a discussion of characteristic strings, semi-synchronous forks, and their relationship to executions of <span class="math">\\pi_{\\mathrm{SPoS}}</span> in the hybrid experiment. Section 4.3 then develops the combinatorial reduction from the semi-synchronous to the synchronous setting. The “generic, dominant” distribution on characteristic strings is then motivated and defined in Section 4.4, where the effect of the reduction on this distribution is also described. Section 4.7, as described above, establishes various guarantees on the resulting blockchain under the dominant distribution. The full power of adaptive adversaries is considered in Section 4.8. Finally, in preparation for applying the protocol in the dynamic stake setting, we formulate a “resettable setting” which further enlarges the power of the adversary by providing some control over the random nonce that seeds the protocol.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">4.1 Chains, Forks and the Abstract Chain Properties</h3>

    <p class="text-gray-300">We begin by suitably generalizing the framework of characteristic strings, forks, and divergence developed in <em>[x13]</em> to our semi-synchronous setting.</p>

    <p class="text-gray-300">The leader assignment process given by protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> in the hybrid experiment assigns leaders to slots with the following guarantees: (i.) a party with relative stake <span class="math">\\alpha</span> becomes a slot leader for a given slot with probability <span class="math">\\phi_{f}(\\alpha)\\triangleq 1-(1-f)^{\\alpha}</span>; (ii.) the event of becoming a slot leader is independent for each party and for each slot (both points follow from the construction of <span class="math">\\pi_{\\mathrm{SPoS}}</span> and the independent random sampling of every new output in <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>). Clearly, these dynamics may lead to slots with multiple slot leaders and, likewise, slots with no slot leader. For a given (adaptive) adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>, we reflect the outcome of this process with a <em>characteristic string</em>, as described below.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 5 (Execution).</h6>

    <p class="text-gray-300">For an (adaptive) adversary <span class="math">\\mathcal{A}</span> and an environment <span class="math">\\mathcal{Z}</span>, an <em>execution</em> <span class="math">\\mathcal{E}</span> of <span class="math">\\pi_{\\mathrm{SPoS}}</span> is a transcript including the inputs provided by <span class="math">\\mathcal{Z}</span>, the random coins of the parties, the random coins of the adversary, the responses of the ideal functionalities and the random oracle. This data determines the entire dynamics of the protocol: messages sent and delivered, the internal states of the parties at each step, the set of corrupt parties at each step, etc.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 6 (Characteristic string).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">R\\in\\mathbb{N}</span>, let <span class="math">S=\\{1,\\ldots,R\\}</span> be a sequence of slots of length <span class="math">R</span> and let <span class="math">\\mathcal{E}</span> be an execution (with adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>) over <span class="math">S</span>. For a slot <span class="math">j\\in S</span>, let <span class="math">\\mathcal{P}(j)</span> denote the set of parties assigned to be slot leaders for slot <span class="math">j</span> by the protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> (specifically, those parties <span class="math">U_{i}</span> for which <span class="math">y&lt;2^{\\ell_{\\mathsf{VRF}}}\\phi_{f}(\\alpha_{i})</span>, where $(y,\\pi)\\leftarrow\\mathsf{Prove}_{\\mathsf{VRF}.sk_{i}}(\\eta\\mathbin{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j})<span class="math">). We define the <em>characteristic string</em> </span>w\\in\\{0,1,\\bot\\}^{R}<span class="math"> of </span>S$ to be the random variable so that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ w_{j}=\\begin{cases}\\bot&\\text{if }\\mathcal{P}(j)=\\emptyset,\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0&\\text{if }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}(j)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1\\text{ and the assigned party is honest,}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For such a characteristic string <span class="math">w\\in\\{0,1,\\bot\\}^{<em>}</span> we say that the index <span class="math">j</span> is </em>uniquely honest<em> if <span class="math">w_{j}=0</span>, </em>tainted<em> if <span class="math">w_{j}=1</span>, and </em>empty<em> if <span class="math">w_{j}=\\bot</span>. We say that an index is </em>active* if <span class="math">w_{j}\\in\\{0,1\\}</span>. Note that an index is “tainted” according to this terminology in cases where multiple honest parties (and no adversarial party) have been assigned to it.</p>

    <p class="text-gray-300">We denote by <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span> the distribution of the random variable <span class="math">w=w_{1}\\ldots w_{R}</span> in the hybrid experiment with the active slots coefficient <span class="math">f</span>, adversary <span class="math">\\mathcal{A}</span>, and environment <span class="math">\\mathcal{Z}</span>. For a fixed execution <span class="math">\\mathcal{E}</span>, we denote by <span class="math">w_{\\mathcal{E}}</span> the (fixed) characteristic string resulting from that execution.</p>

    <p class="text-gray-300">We emphasize that in an execution of <span class="math">\\pi_{\\mathrm{SPoS}}</span>, the resulting characteristic string is determined by both the nonce (and the effective leader selection process), the adaptive adversary <span class="math">\\mathcal{A}</span>, and the environment <span class="math">\\mathcal{Z}</span> (which, in particular, determines the stake distribution).</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">From executions to forks.</h4>

    <p class="text-gray-300">The notion of a “fork”, defined in <em>[x13]</em>, is a bookkeeping tool that reflects the chains observed by honest players during an idealized execution of a blockchain protocol. We now adapt the synchronous notion of <em>[x13]</em> to reflect the effect of message delays.</p>

    <p class="text-gray-300">An execution of Protocol <span class="math">\\pi_{\\text{SPoS}}</span> induces a collection of blocks delivered to the participants. As we now focus merely on the structural properties of the resulting blockchain, for each delivered block we now retain only two features: the <em>slot</em> associated with the block and the <em>previous block</em> to which it is “attached” by the idealized digital signature <span class="math">\\sigma_{j}</span>. (Of course, we only consider blocks with legal structure that meet the verification criteria of <span class="math">\\pi_{\\text{SPoS}}</span>.) Note that multiple blocks may be associated with a particular slot, either because multiple parties are assigned to the slot or an adversarial party is assigned to a slot (who may choose to deviate from the protocol by issuing multiple blocks). In any case, these blocks induce a natural directed tree by treating the blocks as vertices and introducing a directed edge between each pair of blocks <span class="math">(b,b^{\\prime})</span> for which <span class="math">b^{\\prime}</span> identifies <span class="math">b</span> as the previous block. In the <span class="math">\\Delta</span>-semisynchronous setting, the maxvalid rule enforces a further critical property on this tree: the depth of any block broadcast by an honest player in some slot <span class="math">t</span> must exceed the depths of any honestly-generated blocks from slots up to <span class="math">t-1-\\Delta</span>. (This follows because such previously broadcast blocks would have been available to the honest player, who always builds on a chain of maximal length.) We call a directed tree with these structural properties a <span class="math">\\Delta</span>-fork, and define them precisely below.</p>

    <p class="text-gray-300">We may thus associate with any execution of <span class="math">\\pi_{\\text{SPoS}}</span> a fork. While this fork disregards many of the details of the execution, it retains enough structure to reason about the chain properties discussed in Section 2. Thus a significant portion of our analysis relies on controlling the structure of the forks that can be induced in this way for a given characteristic string (which determines which slots have been assigned to uniquely honest parties). In more detail, we define “abstract” analogues of the chain properties CP, CG, and <span class="math">\\exists\\textsf{CQ}</span> in the language of forks and bound the probability that there exists a fork for which these properties are violated over a characteristic drawn from a suitable distribution. The correspondence between forks and executions permits us to lift this argument to reason about the blockchain protocol.</p>

    <p class="text-gray-300">We begin with the formal definition of <span class="math">\\Delta</span>-fork.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 7 (<span class="math">\\Delta</span>-fork).</h6>

    <p class="text-gray-300">Let <span class="math">w\\in\\{0,1,\\bot\\}^{k}</span> and <span class="math">\\Delta</span> be a non-negative integer. Let <span class="math">A=\\{i\\mid w_{i}\\neq\\bot\\}</span> denote the set of active indices, and let <span class="math">H=\\{i\\mid w_{i}=0\\}</span> denote the set of uniquely honest indices. A <span class="math">\\Delta</span>-fork for the string <span class="math">w</span> is a directed, rooted tree <span class="math">F=(V,E)</span> with a labeling <span class="math">\\ell:V\\rightarrow\\{0\\}\\cup A</span> so that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the root <span class="math">r\\in V</span> is given the label <span class="math">\\ell(r)=0</span>;</li>

      <li>each edge of <span class="math">F</span> is directed away from the root;</li>

      <li>the labels along any directed path are strictly increasing;</li>

      <li>each uniquely honest index <span class="math">i\\in H</span> is the label of exactly one vertex of <span class="math">F</span>;</li>

      <li>the function <span class="math">\\mathbf{d}:H\\rightarrow\\{1,\\ldots,k\\}</span>, defined so that <span class="math">\\mathbf{d}(i)</span> is the depth in <span class="math">F</span> of the unique vertex <span class="math">v</span> for which <span class="math">\\ell(v)=i</span>, satisfies the following <span class="math">\\Delta</span>-monotonicity property: if <span class="math">i,j\\in H</span> and <span class="math">i+\\Delta&lt;j</span>, then <span class="math">\\mathbf{d}(i)&lt;\\mathbf{d}(j)</span>.</li>

    </ol>

    <p class="text-gray-300">As a matter of notation, we write <span class="math">F\\vdash_{\\Delta}w</span> to indicate that <span class="math">F</span> is a <span class="math">\\Delta</span>-fork for the string <span class="math">w</span>. We typically refer to a <span class="math">\\Delta</span>-fork as simply a “fork”.</p>

    <p class="text-gray-300">See Figures 5 and 6 for examples of forks. Also note that our notion of a fork deliberately models the behavior of honest parties that may not necessarily have full information about previous blocks thanks to the delivery guarantees provided by the DDiffuse functionality. Additionally, the modeling places special emphasis on uniquely honest slots, in which there is a unique honest leader; specifically, observe that honest leaders of “crowded” slots (with multiple leaders) are not afforded any special properties by the definition. Nonetheless, it remains true that any execution of the hybrid experiment leads to a fork as defined above, a relationship that we make fully formal in Appendix F. Given this relationship, we can later focus on investigating the properties of forks for characteristic strings drawn according to the distribution <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>. Roughly speaking, if we prove that a characteristic string sampled from <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>, with overwhelming probability, does not allow for <em>any</em> “harmful” forks, then this also implies that an execution results in a “harmless” outcome with overwhelming probability.</p>

    <p class="text-gray-300">Now we continue to adapt the framework from <em>[x14]</em> to the semi-synchronous setting.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 8 (Tines, length, and viability).</h6>

    <p class="text-gray-300">A path in a fork <span class="math">F</span> originating at the root is called a <em>tine</em>. For a tine <span class="math">t</span> we let <span class="math">\\textnormal{length}(t)</span> denote its <em>length</em>, equal to the number of edges on the path.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 5: A (synchronous) fork  <span class="math">F</span>  for the string  <span class="math">w = 010100110</span> . Vertices appear with their labels and vertices belonging to (uniquely) honest slots are highlighted with double borders. Note that the depths of the (honest) vertices associated with the honest indices of  <span class="math">w</span>  are strictly increasing. Two tines are distinguished in the figure: one, labeled  <span class="math">\\hat{t}</span> , terminates at the vertex labeled 9 and is the longest tine in the fork; a second tine  <span class="math">t</span>  terminates at the vertex labeled 3. The divergence of  <span class="math">t</span>  and  <span class="math">\\hat{t}</span>  is  <span class="math">\\mathrm{div}(t, \\hat{t}) = 2</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 6: A 3-fork  <span class="math">F&#x27;</span>  for the characteristic string  <span class="math">w = 0 \\bot 1 \\bot 01001 \\bot \\bot 10</span> . Note that  <span class="math">F&#x27;</span>  is not a 2-fork since  <span class="math">\\mathbf{d}(8) = 2 \\neq 2 = \\mathbf{d}(5)</span> . Indices  <span class="math">\\{1, 5, 7, 8, 14\\}</span>  are uniquely honest,  <span class="math">\\{3, 6, 12, 13\\}</span>  are tainted, and  <span class="math">\\{2, 4, 9, 10, 11\\}</span>  are empty. The index 8 is 4-right-isolated, but not 5-right-isolated.</p>

    <p class="text-gray-300">For a vertex  <span class="math">v</span> , we call the length of the tine terminating at  <span class="math">v</span>  the depth of  <span class="math">v</span> . For convenience, we overload the notation  <span class="math">\\ell(\\cdot)</span>  so that it applies to tines by defining  <span class="math">\\ell(t) \\triangleq \\ell(v)</span> , where  <span class="math">v</span>  is the terminal vertex on the tine  <span class="math">t</span> . We say that a tine  <span class="math">t</span>  is  <span class="math">\\Delta</span> -viable if</p>

    <p class="text-gray-300"><span class="math">\\operatorname{length}(t) \\geq \\max_{h + \\Delta &amp;lt; \\ell(t)} \\mathbf{d}(h)</span> ,</p>

    <p class="text-gray-300">this maximum extended over all uniquely honest indices  <span class="math">h</span>  (appearing more than  <span class="math">\\Delta</span>  slots before  <span class="math">\\ell(t)</span> ). Note that any tine terminating in a uniquely honest vertex is necessarily viable by the  <span class="math">\\Delta</span> -monotonicity property.</p>

    <p class="text-gray-300">The notion of viability, defined above, demands that the length of a tine  <span class="math">t</span>  be no less than that of all tines broadcast by uniquely honest slot leaders prior to slot  <span class="math">\\ell(t) - \\Delta</span> . Observe that such a tine could, in principle, be selected according to the maxvalid() rule by an honest player online at time  <span class="math">\\ell(t)</span> : in particular, if all blocks broadcast by honest parties in slots  <span class="math">\\ell(t) - \\Delta, \\ldots, \\ell(t)</span>  are maximally delayed, the tine can favorably compete with all other tines that the adversary is obligated to deliver by slot  <span class="math">\\ell(t)</span> .</p>

    <p class="text-gray-300">Before articulating the abstract chain properties below we set down some further notation. Given a tine  <span class="math">t</span>  (of a fork  <span class="math">F \\vdash w</span> ) and a natural number  <span class="math">k</span> , we let  <span class="math">t^{\\lfloor k \\rfloor}</span>  denote the result of removing the last  <span class="math">k</span>  vertices from  <span class="math">t</span> . If  <span class="math">k \\geq \\mathrm{length}(t)</span> , we define  <span class="math">t^{\\lfloor k \\rfloor}</span>  to be the length 0 path containing only the root. Given a tine  <span class="math">t</span>  and a sequence of slots  <span class="math">S</span>  such that  <span class="math">\\ell(t) \\geq \\max S</span> , we refer to a "portion of  <span class="math">t</span>  spanning  <span class="math">S</span> " as the subgraph  <span class="math">t&#x27;</span>  of  <span class="math">t</span>  induced from all vertices with labels in  <span class="math">S</span> . We use the notation  <span class="math">t(S)</span>  to denote this subgraph. We continue to use interval notation for sequences of slots: that is,  <span class="math">[\\mathfrak{sl}_1 : \\mathfrak{sl}_2] = \\{\\mathfrak{sl}_1, \\ldots, \\mathfrak{sl}_2\\}</span>  and parentheses in place of brackets indicate that the endpoint is left out. Thus  <span class="math">[\\mathfrak{sl}_1 : \\mathfrak{sl}_2] = \\{\\mathfrak{sl}_1, \\ldots, \\mathfrak{sl}_2 - 1\\}</span> . As a final matter of notation, we often elide the parentheses in expressions such as  <span class="math">t([\\mathfrak{sl}_1, \\mathfrak{sl}_2])</span> , simply writing  <span class="math">t[\\mathfrak{sl}_1, \\mathfrak{sl}_2]</span> . We will refer to a "portion of  <span class="math">t</span>  spanning  <span class="math">s</span>  slots" when the particular sequence of slots is not specified.</p>

    <p class="text-gray-300">The abstract chain properties. Let <span class="math">w \\in \\{\\bot, 0, 1\\}^n</span> be a characteristic string. In the context of a particular choice of <span class="math">\\Delta</span>, we define the following abstract analogues of the general protocol properties defined in Section 2. These abstract versions of the properties can be formulated merely in terms of a characteristic string rather than the full details of an execution of a protocol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Prefix (cp); with parameter <span class="math">k \\in \\mathbb{N}</span>. A characteristic string <span class="math">w</span> possesses cp with parameter <span class="math">k</span> (written <span class="math">k</span>-cp) if, for every fork <span class="math">F \\vdash_{\\Delta} w</span> and every pair of viable tines <span class="math">t_1</span> and <span class="math">t_2</span> of <span class="math">F</span> for which <span class="math">\\ell(t_1) \\leq \\ell(t_2)</span>, the tine <span class="math">t_1^{\\lceil k \\rceil}</span> is a prefix of <span class="math">t_2</span>. (Equivalently, <span class="math">\\mathrm{length}(t_1) - \\mathrm{length}(t_1 \\cap t_2) \\leq k</span>, where <span class="math">t_1 \\cap t_2</span> denotes the common prefix of the two tines.)</li>

      <li>Honest-Bounded Chain Growth (hcg); with parameters <span class="math">\\tau \\in (0,1]</span> and <span class="math">s \\in \\mathbb{N}</span>. A characteristic string <span class="math">w</span> possesses hcg with parameters <span class="math">\\tau</span> and <span class="math">s</span> (written <span class="math">(\\tau, s)</span>-hcg) if, for every fork <span class="math">F \\vdash_{\\Delta} w</span>, every viable tine <span class="math">t</span> of <span class="math">F</span>, and every honest vertex <span class="math">v</span> on <span class="math">t</span> for which <span class="math">\\ell(v) + s \\leq \\ell(t)</span>, the path <span class="math">t(\\ell(v), \\ell(t))</span> contains at least <span class="math">\\tau s</span> vertices.</li>

      <li>Existential Chain Quality (<span class="math">\\exists \\mathbf{cq}</span>); with parameter <span class="math">s \\in \\mathbb{N}</span>. A characteristic string <span class="math">w</span> possesses <span class="math">\\exists \\mathbf{cq}</span> with parameter <span class="math">s</span> (written <span class="math">s</span>-<span class="math">\\exists \\mathbf{cq}</span>) if, for every fork <span class="math">F \\vdash_{\\Delta} w</span> and every viable tine <span class="math">t</span> of <span class="math">F</span>, any portion of <span class="math">t</span> spanning <span class="math">s</span> slots contains at least one honest vertex.</li>

    </ul>

    <p class="text-gray-300">As with the protocol properties, it is convenient to separately articulate a chain growth property, which can be directly inferred from <span class="math">\\exists \\mathbf{cq}</span> and hcg.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain Growth (cg); with parameters <span class="math">\\tau \\in (0,1]</span> and <span class="math">s \\in \\mathbb{N}</span>. A characteristic string <span class="math">w</span> possesses <span class="math">(\\tau, s)</span>-cg if, for every fork <span class="math">F \\vdash_{\\Delta} w</span> and every viable tine <span class="math">t</span> of <span class="math">F</span>, any portion of <span class="math">t</span> spanning <span class="math">s</span> slots contains at least <span class="math">\\tau s</span> vertices.</li>

    </ul>

    <p class="text-gray-300">Observe that these properties depend on a choice of <span class="math">\\Delta</span> which is not made explicit in the notation; in our usage, the parameter <span class="math">\\Delta</span> will always be clear from context.</p>

    <h2 id="sec-55" class="text-2xl font-bold">4.2 Abstract Common Prefix Formulated as Divergence</h2>

    <p class="text-gray-300">The major analytic challenge, both in the synchronous case and in our semisynchronous setting, is to control the possibility of a common prefix violation, which occurs when the adversary can manipulate the protocol to produce a fork with two viable tines with a relatively short common prefix. We define this precisely by introducing the notion of divergence.</p>

    <p class="text-gray-300"><strong>Definition 9 (Divergence).</strong> Let <span class="math">F</span> be a <span class="math">\\Delta</span>-fork for a string <span class="math">w \\in \\{0,1,\\bot\\}^*</span>. For two <span class="math">\\Delta</span>-viable tines <span class="math">t</span> and <span class="math">t&#x27;</span> of <span class="math">F</span>, we define the notation <span class="math">t / t&#x27;</span> by the rule</p>

    <div class="my-4 text-center"><span class="math-block">t / t ^ {\\prime} = \\operatorname {l e n g t h} (t) - \\operatorname {l e n g t h} (t \\cap t ^ {\\prime}),</span></div>

    <p class="text-gray-300">where <span class="math">t \\cap t&#x27;</span> denotes the common prefix of <span class="math">t</span> and <span class="math">t&#x27;</span>. Then define the divergence of two viable tines <span class="math">t_1</span> and <span class="math">t_2</span> to be the quantity</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {d i v} (t _ {1}, t _ {2}) = \\left\\{ \\begin{array}{l l} t _ {1} / t _ {2} &amp;amp; \\text{if } \\ell (t _ {1}) &amp;lt; \\ell (t _ {2}), \\\\ t _ {2} / t _ {1} &amp;amp; \\text{if } \\ell (t _ {2}) &amp;lt; \\ell (t _ {1}), \\\\ \\max  (t _ {1} / t _ {2}, t _ {2} / t _ {1}) &amp;amp; \\text{if } \\ell (t _ {1}) = \\ell (t _ {2}). \\end{array} \\right.</span></div>

    <p class="text-gray-300">We extend this notation to the fork <span class="math">F</span> by maximizing over viable tines: <span class="math">\\operatorname{div}_{\\Delta}(F) \\triangleq \\max_{t_1, t_2} \\operatorname{div}(t_1, t_2)</span>, taken over all pairs of <span class="math">\\Delta</span>-viable tines of <span class="math">F</span>. Finally, we define the <span class="math">\\Delta</span>-divergence of a characteristic string <span class="math">w</span> to be the maximum over all <span class="math">\\Delta</span>-forks:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {d i v} _ {\\Delta} (w) \\triangleq \\max  _ {F \\vdash_ {\\Delta} w} \\operatorname {d i v} _ {\\Delta} (F).</span></div>

    <p class="text-gray-300">Our primary goal in this section is to prove that, with high probability, the characteristic strings induced by protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> have small divergence and hence provide strong guarantees on common prefix.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">The Synchronous Case. The original development of [KRDO17] assumed a strictly synchronous environment. Their definitions of characteristic string, fork, and divergence correspond to the case <span class="math">\\Delta = 0</span>, where characteristic strings are elements of <span class="math">\\{0,1\\}^*</span>. As this setting will play an important role in our analysis—fulfilling the role of the “virtual protocol” described at the beginning of this section—we set down some further terminology for this synchronous case and establish a relevant combinatorial statement based on a result in [KRDO17] that we will need for our analysis.</p>

    <p class="text-gray-300"><strong>Definition 10 (Synchronous characteristic strings and forks).</strong> A synchronous characteristic string is an element of <span class="math">\\{0,1\\}^*</span>. A synchronous fork <span class="math">F</span> for a (synchronous) characteristic string <span class="math">w</span> is a 0-fork <span class="math">F \\vdash_0 w</span>.</p>

    <p class="text-gray-300">An immediate conclusion of the results obtained in [KRDO17,RMKQ17] is the following bound on the probability that a synchronous characteristic string with independent identically distributed (i.i.d.) symbols has large divergence.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> Let <span class="math">\\ell, k \\in \\mathbb{N}</span> and <span class="math">\\epsilon \\in (0,1)</span>. Let <span class="math">w = w_1, \\ldots, w_\\ell \\in \\{0,1\\}^\\ell</span> be a sequence of i.i.d. random variables for which <span class="math">\\operatorname<em>{Pr}[w_i = 1] = (1 - \\epsilon)/2</span>. Then <span class="math">\\operatorname</em>{Pr}[\\mathrm{div}_0(w) \\geq k] \\leq \\exp(\\ln \\ell - \\Omega(k))</span>.</p>

    <p class="text-gray-300">Note that the <span class="math">\\Omega()</span> notation hides a constant that depends on <span class="math">\\epsilon</span>.</p>

    <h2 id="sec-56" class="text-2xl font-bold">4.3 The Semisynchronous to Synchronous Reduction</h2>

    <p class="text-gray-300">We will make use of the following mapping, carrying characteristic strings to synchronous characteristic strings.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 11 (Reduction of characteristic strings).</strong> For <span class="math">\\Delta \\in \\mathbb{N}</span>, we define the function <span class="math">\\rho_{\\Delta} \\colon \\{0,1,\\bot\\}^<em> \\to \\{0,1\\}^</em></span> inductively as follows: <span class="math">\\rho_{\\Delta}(\\varepsilon) = \\varepsilon</span>, $\\rho_{\\Delta}(\\bot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w') = \\rho_{\\Delta}(w')$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w') = 1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(w'), \\tag{4}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w') = \\begin{cases} 0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(w') &amp; \\text{if } w' \\in \\bot^{\\Delta} \\mid \\{0, 1, \\bot\\}^*, \\\\ 1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(w') &amp; \\text{otherwise}. \\end{cases}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We call <span class="math">\\rho_{\\Delta}</span> the reduction mapping for delay <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">A critical feature of the map <span class="math">\\rho_{\\Delta}</span> is that it can be coupled with a natural reduction mapping on forks that monotonically preserves many structural features of interest including divergence, chain quality, and chain growth.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 12 (Reduction of forks).</strong> Let <span class="math">w \\in \\{0,1,\\bot\\}^n</span>, <span class="math">w&#x27; = \\rho_{\\Delta}(w)</span>, and let <span class="math">F \\vdash w</span>. The fork <span class="math">F</span> can be naturally interpreted as a fork of the reduced string <span class="math">w&#x27;</span> by suitably adjusting vertex labels. To make this correspondence precise, define <span class="math">F&#x27;</span> to be the labeled graph with the same set of vertices and directed edges as <span class="math">F</span>; the labeling function <span class="math">\\ell&#x27;</span> of <span class="math">F&#x27;</span> is given by the reduction mapping. Specifically, let <span class="math">A = \\{i \\mid w_i \\neq \\bot\\}</span> denote the set of active indices and note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\Delta}(w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; each non-</span>\\bot<span class="math"> symbol of </span>w<span class="math"> corresponds to a unique symbol in </span>w'<span class="math">. We let </span>\\pi: A \\to \\{1,\\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> be the (bijective, increasing) function which records the position in </span>w'<span class="math"> corresponding to a particular active index </span>i<span class="math"> in </span>w<span class="math">. Then the labeling </span>\\ell'<span class="math"> (for </span>F'<span class="math">) is given by the rule </span>\\ell'(v) = \\pi(\\ell(v))<span class="math">; of course, </span>\\ell'(r) = 0<span class="math"> for the root vertex </span>r<span class="math">. For convenience, we overload the notation </span>\\rho_{\\Delta}<span class="math"> by defining </span>\\rho_{\\Delta}(F) = F'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to confirm that the labeled graph <span class="math">\\rho_{\\Delta}(F)</span> defined above is indeed a fork of <span class="math">\\rho_{\\Delta}(w)</span>.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Let <span class="math">w \\in \\{0,1,\\bot\\}^n</span> and let <span class="math">F \\vdash w</span>. Then <span class="math">\\rho_{\\Delta}(F) \\vdash_0 \\rho_{\\Delta}(w)</span>. The situation is summarized by the following diagram.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{ccc} F &amp;amp; \\vdash &amp;amp; w \\\\ \\Big\\downarrow_{\\rho_{\\Delta}} &amp;amp; &amp;amp; \\Big\\downarrow_{\\rho_{\\Delta}} \\\\ F&#x27; &amp;amp; \\vdash &amp;amp; w&#x27; \\end{array}</span></div>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adopting the same notation as above, define <span class="math">w^{\\prime}=\\rho_{\\Delta}(w)</span> and <span class="math">F^{\\prime}=\\rho_{\\Delta}(F)</span>. To verify that <span class="math">F^{\\prime}\\vdash_{0}w^{\\prime}=\\rho_{\\Delta}(w)</span>, we recall the necessary properties from the definition. Properties (i) and (ii) of the Definition 7 are immediate; property (iii) follows because <span class="math">\\pi</span> is strictly increasing. For the remaining properties, we recall the definition of <span class="math">\\rho_{\\Delta}</span>: According the rule, <span class="math">w_{i}=1\\Rightarrow w^{\\prime}_{\\pi(i)}=1</span> from which property (iv) follows immediately. It remains to check property (v). When <span class="math">w_{i}=0</span> the value <span class="math">w^{\\prime}_{\\pi(i)}</span> is determined by the <span class="math">\\Delta</span> following symbols of <span class="math">w</span>: if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq i+\\Delta<span class="math"> and </span>w_{i+1}=w_{i+2}=\\cdots=w_{i+\\Delta}=\\bot<span class="math">, we say that </span>i<span class="math"> is </span>\\Delta<span class="math">-right-isolated (cf. <em>[x11]</em>, where a similar feature arises in a proof-of-work setting) and in this case </span>w^{\\prime}_{\\pi(i)}=0<span class="math">; otherwise </span>w^{\\prime}_{\\pi(i)}=1<span class="math">. In particular, if </span>w^{\\prime}_{\\pi(i)}=0<span class="math"> we must have </span>w_{i}=0<span class="math"> and </span>w_{i+s}=\\bot<span class="math"> for </span>1\\leq s\\leq\\Delta<span class="math">. As we wish to conclude that </span>F^{\\prime}<span class="math"> is a synchronous fork, it must satisfy the </span>\\Delta<span class="math">-monotonicity property with </span>\\Delta=0<span class="math">, which is to say that </span>\\mathbf{d}(\\cdot)<span class="math"> is strictly increasing on the set of uniquely honest indices (of </span>w^{\\prime}<span class="math">). However, in light of the discussion above, any two uniquely honest indices of </span>w^{\\prime}<span class="math"> must correspond to uniquely honest indices of </span>w<span class="math"> separated by at least </span>\\Delta<span class="math"> intervening </span>\\bot<span class="math"> symbols; thus the </span>\\Delta<span class="math">-monotonicity property of </span>F<span class="math"> ensures the </span>0<span class="math">-monotonicity property of </span>F^{\\prime}$, as desired. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-58" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">w\\in\\{0,1,\\bot\\}^{*}</span>. Then <span class="math">\\operatorname{div}_{\\Delta}(w)\\leq\\operatorname{div}_{0}(\\rho_{\\Delta}(w))</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">w\\in\\{0,1,\\bot\\}^{*}</span> be a characteristic string with <span class="math">\\operatorname{div}_{\\Delta}(w)=k</span> and let <span class="math">F\\vdash_{\\Delta}w</span> be a <span class="math">\\Delta</span>-fork for which <span class="math">\\operatorname{div}_{\\Delta}(F)=k</span>. Let <span class="math">w^{\\prime}=\\rho_{\\Delta}(w)</span>; to prove that <span class="math">\\operatorname{div}_{0}(w^{\\prime})\\geq k</span>, we establish that <span class="math">\\operatorname{div}(F^{\\prime})\\geq k</span> where, as above, <span class="math">F^{\\prime}=\\rho_{\\Delta}(F)</span>.</p>

    <p class="text-gray-300">In preparation for establishing that <span class="math">\\operatorname{div}_{0}(F^{\\prime})\\geq\\operatorname{div}(F)=k</span>, we note that a <span class="math">\\Delta</span>-viable tine <span class="math">t</span> of <span class="math">F\\vdash_{\\Delta}w</span> is <span class="math">0</span>-viable when viewed as a tine of <span class="math">F^{\\prime}\\vdash w^{\\prime}</span>. In particular, let <span class="math">h^{\\prime}</span> be a uniquely honest index of <span class="math">w^{\\prime}</span> for which <span class="math">h^{\\prime}&lt;\\ell^{\\prime}(t)</span> and let <span class="math">h</span> be the uniquely honest index of <span class="math">w</span> for which <span class="math">\\pi(h)=h^{\\prime}</span>. As <span class="math">\\pi(h)</span> is uniquely honest in <span class="math">w^{\\prime}</span>, <span class="math">h</span> is <span class="math">\\Delta</span>-right isolated in <span class="math">w</span>, and we conclude that <span class="math">\\operatorname{length}(t)\\geq\\mathbf{d}(h)</span>, because <span class="math">t</span> is <span class="math">\\Delta</span>-viable. This <span class="math">t</span> is hence <span class="math">0</span>-viable in <span class="math">F^{\\prime}</span>.</p>

    <p class="text-gray-300">Finally, let <span class="math">t_{1}</span> and <span class="math">t_{2}</span> be two <span class="math">\\Delta</span>-viable tines of <span class="math">F</span> for which <span class="math">\\ell(t_{1})\\leq\\ell(t_{2})</span> and <span class="math">t_{1}/t_{2}=\\operatorname{div}_{\\Delta}(w)</span>. In light of the discussion above, these tines are <span class="math">0</span>-viable in <span class="math">F^{\\prime}</span>. Note, additionally, that <span class="math">\\pi(\\ell(t_{1}))\\leq\\pi(\\ell(t_{2}))</span> and—as the two forks have the same structure as graphs—the quantity <span class="math">t_{1}/t_{2}</span> takes the same value in the two forks. We conclude that <span class="math">\\operatorname{div}_{0}(w^{\\prime})\\geq t_{1}/t_{2}=\\operatorname{div}_{\\Delta}(w)</span>, as desired. ∎</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">4.4 The Dominant Characteristic Distribution</h3>

    <p class="text-gray-300">The high-probability results for our desired chain properties depend on detailed information about the distribution on characteristic strings <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span> determined by the adversary <span class="math">\\mathcal{A}</span>, the environment <span class="math">\\mathcal{Z}</span>, and the parameters <span class="math">f</span> and <span class="math">R</span>. In this section we define a distinguished distribution on characteristic strings which we will see “dominates” the distributions produced by any static adversary. Later in Section 4.8 we show that the same is true also for adaptive adversaries. We then study the effect of <span class="math">\\rho_{\\Delta}</span> on this distribution in preparation for studying common prefix, chain growth, and chain quality.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Motivating the Dominant Distribution: Static Adversaries.</h4>

    <p class="text-gray-300">To motivate the dominant distribution, consider the distribution induced by a <em>static</em> adversary who corrupts—at the outset of the protocol—a set <span class="math">U_{\\mathcal{A}}</span> of parties with total relative stake <span class="math">\\alpha_{\\mathcal{A}}</span>. (Formally, one can model this by restricting to environments that only allow static corruption.) Recalling Definition 1, a party with relative stake <span class="math">\\alpha_{i}</span> is independently assigned to be a leader for a slot with probability</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}(\\alpha_{i})\\triangleq\\phi(\\alpha_{i})\\triangleq 1-(1-f)^{\\alpha_{i}}\\,.</span></p>

    <p class="text-gray-300">Figure 7 shows a plot of <span class="math">\\phi_{1/2}</span> for illustration. As suggested by the figure, <span class="math">\\phi_{f}(x)\\approx f\\cdot x</span> and as <span class="math">f\\to 0</span> this approximation is increasingly faithful. This behavior, among other relevant properties of <span class="math">\\phi_{f}</span>, is expressed by following proposition.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proposition 2.</h6>

    <p class="text-gray-300">The function <span class="math">\\phi_{f}(\\alpha)</span> satisfies the following properties.</p>

    <p class="text-gray-300"><span class="math">\\phi_{f}\\left(\\sum_{i}\\alpha_{i}\\right)=1-\\prod_{i}(1-\\phi_{f}(\\alpha_{i}))\\leq\\sum_{i}\\phi_{f}(\\alpha_{i})\\,,</span> <span class="math">\\alpha_{i}\\geq 0\\,,</span> (5) <span class="math">\\alpha\\leq\\frac{\\phi_{f}(\\alpha)}{\\phi_{f}(1)}=\\frac{\\phi_{f}(\\alpha)}{f}\\leq\\alpha\\frac{-\\ln(1-f)}{f}=\\alpha(1+f/2+f^{2}/3+\\cdots)\\,,</span> <span class="math">\\alpha\\in[0,1]\\,.</span> (6)</p>

    <p class="text-gray-300">Proof. The properties follow immediately from the first two derivatives:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\partial}{\\partial \\alpha} \\phi_ {f} (\\alpha) = - (1 - f) ^ {\\alpha} \\ln (1 - f), \\quad \\frac {\\partial^ {2} \\phi_ {f}}{\\partial \\alpha^ {2}} (\\alpha) = - (1 - f) ^ {\\alpha} (\\ln (1 - f)) ^ {2}.</span></div>

    <p class="text-gray-300">As the second derivative is strictly negative (for all  <span class="math">f \\in (0,1)</span>  and  <span class="math">\\alpha \\in [0,1]</span> ), the function  <span class="math">\\phi_f</span>  is concave on  <span class="math">[0,1]</span> . Considering that  <span class="math">\\phi_f(0) = 0</span>  and  <span class="math">\\phi_f(1) = f</span> , concavity implies that  <span class="math">\\phi_f(\\alpha) \\geq f\\alpha</span>  for  <span class="math">\\alpha \\in [0,1]</span> ; this yields the first inequality of (6). Appealing again to concavity, and the fact that  <span class="math">\\phi_f(0) = 0</span> , the function lies (strictly) below the line  <span class="math">\\ell(x) = \\phi_f&#x27;(0) \\cdot x = -x\\ln(1 - f)</span> ; this yields the second inequality of (6).</p>

    <p class="text-gray-300">As  <span class="math">\\phi_f(0) \\geq 0</span>  and  <span class="math">\\phi_f</span>  is concave, the function  <span class="math">\\phi_f</span>  is subadditive; this yields (5).</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 7: The function  <span class="math">\\phi_{1/2}(\\alpha) = 1 - (1/2)^{\\alpha}</span>  and the linear function  <span class="math">\\alpha \\mapsto \\alpha / 2</span> , for comparison. The point  <span class="math">(1, 1/2)</span>  is marked in solid black.</p>

    <p class="text-gray-300">Recalling Definition 6, this (static) adversary  <span class="math">\\mathcal{A}</span>  determines a distribution  <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^f</span>  on strings  <span class="math">w\\in \\{0,1,\\bot \\}^{R}</span>  by independently assigning each  <span class="math">w_{i}</span>  so that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\perp} ^ {\\mathcal {A}} \\triangleq \\Pr [ w _ {i} = \\bot ] = \\prod_ {i \\in \\mathcal {P}} (1 - \\phi (\\alpha_ {i})) = \\prod_ {i \\in \\mathcal {P}} (1 - f) ^ {\\alpha_ {i}} = (1 - f),</span></div>

    <div class="my-4 text-center"><span class="math-block">p _ {0} ^ {\\mathcal {A}} \\triangleq \\Pr [ w _ {i} = 0 ] = \\sum_ {h \\in \\mathcal {H}} (1 - (1 - f) ^ {\\alpha_ {h}}) \\cdot (1 - f) ^ {1 - \\alpha_ {i}}, \\tag {7}</span></div>

    <div class="my-4 text-center"><span class="math-block">p _ {1} ^ {\\mathcal {A}} \\triangleq \\Pr [ w _ {i} = 1 ] = 1 - p _ {\\perp} ^ {\\mathcal {A}} - p _ {0} ^ {\\mathcal {A}}.</span></div>

    <p class="text-gray-300">Here  <span class="math">\\mathcal{H}</span>  denotes the set of all honest parties in the stake distribution  <span class="math">\\mathcal{S}</span>  determined by  <span class="math">\\mathcal{Z}</span> . As before,  <span class="math">\\mathcal{P}</span>  denotes the set of all parties.</p>

    <p class="text-gray-300">It is convenient to work with some bounds on the above quantities that depend only on "macroscopic" features of  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{A}</span> : namely, the relative stake of the honest and adversarial parties, and the parameter  <span class="math">f</span> . For this purpose we note that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {0} ^ {\\mathcal {A}} \\geq \\sum_ {h \\in \\mathcal {H}} \\phi (\\alpha_ {h}) \\cdot \\prod_ {i \\in \\mathcal {P}} (1 - \\phi (\\alpha_ {i})) \\geq \\phi (\\alpha_ {\\mathcal {H}}) \\cdot p _ {\\perp} ^ {\\mathcal {A}} = \\phi (\\alpha_ {\\mathcal {H}}) \\cdot (1 - f), \\tag {8}</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_{\\mathcal{H}}</span>  denotes the total relative stake of the honest parties. Note that this bound applies to all static adversaries  <span class="math">\\mathcal{A}</span>  that corrupt no more than a  <span class="math">1 - \\alpha_{\\mathcal{H}}</span>  fraction of all stake. With this in mind, we define the dominant distribution as follows.</p>

    <p class="text-gray-300">Definition 13 (The dominant distribution  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> ). For two parameters  <span class="math">f</span>  and  <span class="math">\\alpha</span> , define  <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>  to be the distribution on strings  <span class="math">w \\in \\{0,1,\\bot\\}^{R}</span>  that independently assigns each  <span class="math">w_{i}</span>  so that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\perp} \\triangleq \\Pr [ w _ {i} = \\bot ] = 1 - f,</span></div>

    <div class="my-4 text-center"><span class="math-block">p _ {0} \\triangleq \\Pr [ w _ {i} = 0 ] = \\phi (\\alpha) \\cdot (1 - f), \\quad \\text {and} \\tag {9}</span></div>

    <div class="my-4 text-center"><span class="math-block">p _ {1} \\triangleq \\Pr [ w _ {i} = 1 ] = 1 - p _ {\\perp} - p _ {0}.</span></div>

    <p class="text-gray-300">The distribution <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> “dominates” <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span> for any static adversary <span class="math">\\mathcal{A}</span> that corrupts no more than a relative <span class="math">1-\\alpha</span> share of the total stake, in the sense that nonempty slots are more likely to be tainted under <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> than they are under <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>.</p>

    <p class="text-gray-300">To make this relationship precise, we introduce the partial order <span class="math">\\preceq</span> on the set <span class="math">\\{\\bot,0,1\\}</span> so that <span class="math">x\\preceq y</span> if and only if <span class="math">x=y</span> or <span class="math">y=1</span>. We extend this partial order to <span class="math">\\{\\bot,0,1\\}^{R}</span> by declaring <span class="math">x_{1}\\ldots x_{R}\\preceq y_{1}\\ldots y_{R}</span> if and only if <span class="math">x_{i}\\preceq y_{i}</span> for each <span class="math">i</span>. Intuitively, the relationship <span class="math">x\\prec y</span> asserts that <span class="math">y</span> is “more adversarial than” <span class="math">x</span>; concretely, any legal fork for <span class="math">x</span> is also a legal fork for <span class="math">y</span>. Finally, we define a notion of stochastic dominance for distributions on characteristic strings, and <span class="math">\\alpha</span>-dominated adversaries.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Definition 14 (Stochastic dominance).</h6>

    <p class="text-gray-300">We say that a subset <span class="math">E\\subseteq\\{\\bot,0,1\\}^{R}</span> is <em>monotone</em> if <span class="math">x\\in E</span> and <span class="math">x\\preceq y</span> implies that <span class="math">y\\in E</span>. Let <span class="math">\\mathcal{D}</span> and <span class="math">\\mathcal{D}^{\\prime}</span> be two distributions on the set of characteristic strings <span class="math">\\{\\bot,0,1\\}^{R}</span>. Then we say that <span class="math">\\mathcal{D}^{\\prime}</span> <em>dominates</em> <span class="math">\\mathcal{D}</span>, written <span class="math">\\mathcal{D}\\preceq\\mathcal{D}^{\\prime}</span>, if <span class="math">\\Pr_{\\mathcal{D}}[E]\\leq\\Pr_{\\mathcal{D}^{\\prime}}[E]</span> for every monotone set <span class="math">E</span>. An adversary <span class="math">\\mathcal{A}</span> is called <span class="math">\\alpha</span>-dominated if the distribution <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span> that it induces on the set of characteristic strings satisfies <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}\\preceq\\mathcal{D}_{\\alpha}^{f}</span>.</p>

    <p class="text-gray-300">As noted above, this notion of stochastic dominance is consistent with the chain-theoretic definitions of interest, in the sense that failures of the abstract chain properties form monotone events. We record this in the lemma below.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">x</span> and <span class="math">y</span> be characteristic strings in <span class="math">\\{0,1,\\bot\\}^{R}</span> for which <span class="math">x\\preceq y</span>. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every fork <span class="math">F</span>, <span class="math">F\\vdash_{\\Delta}x\\Longrightarrow F\\vdash_{\\Delta}y</span>.</li>

      <li>For every <span class="math">\\Delta</span>, <span class="math">\\operatorname{div}_{\\Delta}(x)\\leq\\operatorname{div}_{\\Delta}(y)</span>.</li>

      <li>More generally, let <span class="math">\\mathcal{P}</span> be a subset of all forks of characteristic strings of length <span class="math">R</span> (that is, <span class="math">\\mathcal{P}</span> is a subset of <span class="math">\\{F\\vdash w\\mid w\\in\\{0,1,\\bot\\}^{R}\\}</span>); then <span class="math">\\{w\\in\\{0,1,\\bot\\}^{R}\\mid\\exists F\\vdash w,F\\in\\mathcal{P}\\}</span> is a monotone set.</li>

    </ol>

    <p class="text-gray-300">The proof is immediate from the definitions.</p>

    <p class="text-gray-300">As an example in our setting, for abstract common prefix the events of interest are <span class="math">D_{\\Delta}=\\{x\\mid\\operatorname{div}_{\\Delta}(x)\\geq k\\}</span> which is a monotone set by Lemma 2. We note that any static adversary that corrupts no more than a <span class="math">1-\\alpha</span> fraction of stake is <span class="math">\\alpha</span>-dominated, and it follows that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}}[\\operatorname{div}_{\\Delta}(w)\\geq k]\\leq\\Pr_{\\mathcal{D}_{\\alpha}^{f}}[\\operatorname{div}_{\\Delta}(w)\\geq k]\\,.</span></p>

    <p class="text-gray-300">This motivates a particular study of the “dominant” distribution <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>.</p>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">The Induced Distribution <span class="math">\\rho_{\\Delta}(\\mathcal{D}_{\\alpha}^{f})</span>.</h4>

    <p class="text-gray-300">The dominant distribution <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> on <span class="math">\\{0,1,\\bot\\}^{R}</span> in conjunction with the definition of <span class="math">\\rho_{\\Delta}</span> of (4) above implicitly defines a family of random variables <span class="math">\\rho_{\\Delta}(w)=x_{1}\\ldots x_{\\ell}\\in\\{0,1\\}^{*}</span>, where <span class="math">w\\in\\{0,1,\\bot\\}^{R}</span> is distributed according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. Observe that <span class="math">\\ell=R-\\#_{\\bot}(w)</span> is precisely the number of active indices of <span class="math">w</span>. We now note a few properties of this resulting distribution that will be useful to us later. In particular, we will see that the <span class="math">x_{i}</span> random variables are roughly independent, but subject to an exotic stochastic “stopping time” condition in tandem with some distortion of the last <span class="math">\\Delta</span> variables.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 3 (Structure of the induced distribution).</h6>

    <p class="text-gray-300">Let <span class="math">x_{1}\\ldots x_{\\ell}=\\rho_{\\Delta}(w)</span> where <span class="math">w\\in\\{0,1,\\bot\\}^{R}</span> is distributed according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. There is a sequence of independent random variables <span class="math">z_{1},z_{2},\\ldots</span> with each <span class="math">z_{i}\\in\\{0,1\\}</span> so that</p>

    <p class="text-gray-300"><span class="math">\\Pr[z_{i}=0]=\\left(\\frac{p_{0}}{p_{0}+p_{1}}\\right)p_{\\bot}^{\\Delta}\\geq\\alpha\\cdot(1-f)^{\\Delta+1}\\,,</span> (10) <span class="math">\\text{and}\\qquad x_{1}\\ldots x_{\\ell-\\Delta}=\\rho_{\\Delta}(w_{1}\\ldots,w_{R})^{\\lceil\\Delta}\\quad\\text{is a prefix of}\\quad z_{1}z_{2}\\ldots\\,.</span> (11)</p>

    <p class="text-gray-300">(Note that while the <span class="math">z_{i}</span> are independent with each other, they are not independent with <span class="math">w</span>.)</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It simplifies our analysis to treat <span class="math">w</span> as the first <span class="math">R</span> symbols of an infinite string <span class="math">w_{1}w_{2}\\ldots</span> of independent random variables with distribution given by Definition 13 above. (We use the same name for this infinite sequence as it will cause no confusion.) The distribution of the infinite</p>

    <p class="text-gray-300">sequence <span class="math">w</span> can be given an alternative description as <span class="math">b_{0}e_{1}b_{1}e_{2}b_{2}\\ldots</span>, where the (independent) random variables <span class="math">e_{i}\\in\\{0,1\\}</span> and <span class="math">b_{i}\\in\\{\\bot\\}^{*}</span> have the probability laws</p>

    <p class="text-gray-300">\\[ e_{i}=\\begin{cases}0&\\text{with probability }p_{0}/(p_{0}+p_{1}),\\\\ 1&\\text{with probability }p_{1}/(p_{0}+p_{1}),\\end{cases} \\]</p>

    <p class="text-gray-300">and <span class="math">b_{i}=\\bot^{t}</span> with probability <span class="math">p_{\\bot}^{t}(1-p_{\\bot})</span>. In this description, the random variables <span class="math">b_{i}</span> generate the contiguous sequences of <span class="math">\\bot</span> symbols that appear between appearances of <span class="math">0</span> and <span class="math">1</span>. Now we observe that <span class="math">z_{1}z_{2}\\ldots=\\rho_{\\Delta}(b_{0}e_{1}b_{1}\\ldots)</span>—which we temporarily treat as operating on an infinite sequence—has an immediate description in terms of the <span class="math">e_{i},b_{i}</span> random variables:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ z_{i}=\\begin{cases}1&\\text{if }e_{i}=1\\text{ or }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\Delta,\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that the variables <span class="math">z_{i}\\in\\{0,1\\}</span> are independent with the further property that</p>

    <p class="text-gray-300"><span class="math">\\Pr[z_{i}=0]=\\left(\\frac{p_{0}}{p_{0}+p_{1}}\\right)p_{\\bot}^{\\Delta}\\overset{(9)}{=}\\frac{\\phi(\\alpha)}{f}\\cdot(1-f)^{\\Delta+1}\\overset{(6)}{\\geq}\\alpha\\cdot(1-f)^{\\Delta+1}\\,,</span> (12)</p>

    <p class="text-gray-300">where we use the equality <span class="math">p_{0}+p_{1}=1-p_{\\bot}</span> as well as equations (9) and (6).</p>

    <p class="text-gray-300">In our setting, the reduction function <span class="math">\\rho_{\\Delta}(\\cdot)</span> is applied to a prefix of the string <span class="math">w</span> of finite length <span class="math">R</span>. In fact, the resulting “stopping criteria” on the random variables <span class="math">z_{1},z_{2},\\ldots</span> can both introduce correlations and distort the coordinatewise distribution. However, we note that <span class="math">\\rho_{\\Delta}(w_{1}\\ldots w_{R})</span> produces a prefix of the sequence <span class="math">z_{1},z_{2},\\ldots</span> with the irritating possibility that the last <span class="math">\\Delta</span> of the <span class="math">z_{i}</span> in this prefix may be altered by the fact that there are not sufficient symbols in the string <span class="math">w</span> to satisfy the criteria for <span class="math">z_{i}=0</span>. Thus we observe (11):</p>

    <p class="text-gray-300"><span class="math">x_{1}\\ldots x_{\\ell-\\Delta}=\\rho_{\\Delta}(w_{1}\\ldots,w_{R})^{\\lceil\\Delta}\\quad\\text{is a prefix of}\\quad z_{1}z_{2}\\ldots\\,.</span></p>

    <p class="text-gray-300">where <span class="math">\\cdot^{\\lceil\\Delta}</span> denotes the truncation operator that removes the last <span class="math">\\Delta</span> symbols, and the sequence <span class="math">z_{1}z_{2}\\ldots</span> is determined by the infinite string <span class="math">w_{1}w_{2}\\ldots</span>. Recall that the <span class="math">z_{i}</span> are Bernoulli random variables with parameter <span class="math">\\approx 1-\\alpha(1-f)^{\\Delta+1}</span>. ∎</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">4.5 Abstract Common Prefix and the Divergence of the Dominant Distribution</h3>

    <p class="text-gray-300">Our goal is to apply the reduction map <span class="math">\\rho_{\\Delta}</span>, Lemma 1, and Theorem 3 to establish an upper bound on the probability that a string drawn from the dominant distribution <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> has large <span class="math">\\Delta</span>-divergence. The difficulty is that the distribution resulting from applying <span class="math">\\rho_{\\Delta}</span> to a string drawn from <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> is no longer a sequence of independent random variables, so we cannot apply Theorem 3 directly. We resolve this obstacle in the proof of the following theorem.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 4 (Abstract Common Prefix (cp)).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in(0,1]</span>, <span class="math">\\Delta\\in\\mathbb{N}</span>, and <span class="math">\\alpha</span> be such that <span class="math">\\alpha(1-f)^{\\Delta+1}=(1+\\epsilon)/2</span> for some <span class="math">\\epsilon&gt;0</span>. Let <span class="math">w</span> be a string drawn from <span class="math">\\{0,1,\\bot\\}^{R}</span> according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. Then we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[w\\text{ violates }(k+\\Delta)\\text{-}\\text{\\text{\\text{cp}}}]=\\Pr[\\operatorname{div}_{\\Delta}(w)&gt;k+\\Delta]=2^{-\\Omega(k)+\\log R}\\,,</span></p>

    <p class="text-gray-300">where the asymptotic notation hides a constant that depends on <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that <span class="math">\\operatorname{div}_{0}(\\cdot)</span> is monotone in the sense that if <span class="math">\\check{y}</span> is a prefix of <span class="math">y</span> then <span class="math">\\operatorname{div}_{0}(\\check{y})\\leq\\operatorname{div}_{0}(y)</span>; this follows because any fork <span class="math">\\check{F}\\vdash_{0}\\check{y}</span> can be “extended” to a fork <span class="math">F\\vdash y</span> which includes all tines of <span class="math">\\check{F}</span>. Additionally, we note that <span class="math">\\operatorname{div}_{0}(\\cdot)</span> has a straightforward “Lipshitz property”: if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\check{y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+s<span class="math"> then </span>\\operatorname{div}_{0}(y)\\leq\\operatorname{div}_{0}(\\check{y})+s<span class="math">; this follows because any fork </span>F\\vdash_{0}y<span class="math"> can be restricted to a fork </span>\\check{F}\\vdash_{0}\\check{y}<span class="math"> by retaining only vertices labeled by </span>\\check{y}<span class="math">—this can trim no more than </span>s$ vertices from any tine.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In light of Lemma 1 we conclude that</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}_{\\Delta}(w)\\leq\\operatorname{div}_{0}(\\rho_{\\Delta}(w))\\leq\\operatorname{div}_{0}(\\rho_{\\Delta}(w)^{\\lceil\\Delta})+\\Delta\\leq\\operatorname{div}_{0}(z_{1}\\ldots z_{R})+\\Delta\\,,</span></p>

    <p class="text-gray-300">where the last inequality follows because the random variable <span class="math">\\rho_{\\Delta}(w_{1}\\ldots w_{R})</span> can certainly have length no more than <span class="math">R</span>. As the random variables <span class="math">z_{i}</span> are i.i.d. with <span class="math">\\Pr[z_{i}=0]\\geq\\alpha(1-f)^{\\Delta+1}</span>, the conclusion of Theorem 4 now follows directly from the assumption that <span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2</span> and Theorem 3. ∎</p>

    <p class="text-gray-300">Remark.</p>

    <p class="text-gray-300">Intuitively, the theorem asserts that sampling the characteristic string in the <span class="math">\\Delta</span>-semi-synchronous setting with protocol parameter <span class="math">f</span> according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span> is, for the purpose of analyzing divergence, comparable to the <em>synchronous</em> setting in which the honest stake has been reduced from <span class="math">\\alpha</span> to <span class="math">\\alpha(1-f)^{\\Delta+1}</span>. Note that this can be made arbitrarily close to <span class="math">\\alpha</span> by adjusting <span class="math">f</span> to be small; however, this happens at the expense of longer periods of silence in the protocol.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">4.6 Abstract Chain Growth and Chain Quality</h3>

    <p class="text-gray-300">In this section, we establish Abstract Chain Growth and Abstract Chain Quality under the distribution <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. These results directly imply the corresponding properties for executions of the protocol via stochastic dominance—this connection is discussed in Section 4.7.</p>

    <p class="text-gray-300">We begin with chain growth, the simpler of the two. We again consider <span class="math">\\Delta</span>-right-isolated uniquely honest slots as introduced in Section 4.3. Intuitively, the leader of such a slot has already received all blocks that were created in previous such slots and therefore the block it creates will have larger depth. We then observe that, using an honest block as an initial point of reference, the length of any viable tine grows by at least one for each such slot.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 5 (Abstract Honest-Bounded Chain Growth (hcg)).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in(0,1]</span>, <span class="math">\\Delta\\in\\mathbb{N}</span>, and <span class="math">\\alpha&gt;0</span>. Let <span class="math">w</span> be a string drawn from <span class="math">\\{0,1,\\bot\\}^{R}</span> according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. Then for <span class="math">s\\geq 6(\\Delta+1)</span> and <span class="math">\\tau=c\\alpha/3</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[w\\text{ does not satisfy }(s,\\tau)\\text{-hcg}]\\leq e^{3/8}R^{2}(\\Delta+1)\\exp\\left(-\\frac{c\\alpha s}{8(\\Delta+1)}\\right)\\,,</span></p>

    <p class="text-gray-300">where <span class="math">c</span> denotes the constant <span class="math">c:=c(f,\\Delta)=f(1-f)^{\\Delta+1}</span>.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall the definition of (Honestly-Bounded) Chain Growth: for any fork <span class="math">F</span> of <span class="math">w</span>, any suffix of a viable tine <span class="math">t</span> that spans <span class="math">s</span> slots and begins right after an honestly generated block must contain <span class="math">\\tau s</span> blocks.</p>

    <p class="text-gray-300">Consider a fixed characteristic string <span class="math">w</span> and a pair <span class="math">\\mathfrak{sl}_{1}&lt;\\mathfrak{sl}_{2}</span> of slots; we say that the pair <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> <em>witnesses</em> a <span class="math">(s,\\tau)</span>-hcg violation in <span class="math">w</span> if there is a fork <span class="math">F\\vdash w</span> and a viable tine <span class="math">t</span> for which (i.) <span class="math">\\mathfrak{sl}_{2}=\\ell(t)</span>, (ii.) <span class="math">\\mathfrak{sl}_{1}+s\\leq\\mathfrak{sl}_{2}</span>, (iii.) <span class="math">t</span> has an honest vertex <span class="math">u</span> with label <span class="math">\\mathfrak{sl}_{1}</span>, and (iv.) the length of the path <span class="math">t(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2}]</span> is less than <span class="math">\\tau s</span>. Note that if <span class="math">w</span> violates <span class="math">(s,\\tau)</span>-hcg then there is some pair <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> that witnesses this.</p>

    <p class="text-gray-300">Consider now a pair <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> that witnesses an <span class="math">(s,\\tau)</span>-hcg violation in <span class="math">w</span> via a fork <span class="math">F\\vdash w</span> and a viable tine <span class="math">t</span> in <span class="math">F</span>, let <span class="math">u</span> be a vertex as above. Let <span class="math">\\hat{\\mathfrak{sl}}_{1},\\ldots,\\hat{\\mathfrak{sl}}_{h}</span> be the increasing sequence of all <span class="math">\\Delta</span>-right-isolated uniquely honest slots among the slots in <span class="math">T:=(\\mathfrak{sl}_{1}+\\Delta,\\mathfrak{sl}_{2}-\\Delta)</span> and let <span class="math">v_{1},\\ldots v_{h}</span> be the (unique) vertices labeled with these slots (so <span class="math">\\ell(v_{i})=\\hat{\\mathfrak{sl}}_{i}</span>). Let <span class="math">u^{\\prime}</span> denote the last vertex on <span class="math">t</span>, labeled by <span class="math">\\mathfrak{sl}_{2}</span>. It is an easy matter to confirm that the depths of the honest vertices <span class="math">u</span>, <span class="math">v_{1},\\ldots,v_{h}</span>, are strictly increasing (in this order), while the depth of <span class="math">u^{\\prime}</span> is at least that of <span class="math">v_{h}</span>: First, considering that <span class="math">\\hat{\\mathfrak{sl}}_{1}&gt;\\mathfrak{sl}_{1}+\\Delta</span> and <span class="math">\\hat{\\mathfrak{sl}}_{1}</span> is uniquely honest, <span class="math">\\text{depth}(v_{1})&gt;\\text{depth}(u)</span>. Analogously, (for each relevant <span class="math">i</span>) as <span class="math">\\hat{\\mathfrak{sl}}_{i-1}</span> is <span class="math">\\Delta</span>-right-isolated and both <span class="math">\\hat{\\mathfrak{sl}}_{i-1}</span> and <span class="math">\\hat{\\mathfrak{sl}}_{i}</span> are uniquely honest, <span class="math">\\text{depth}(v_{i})&gt;\\text{depth}(v_{i-1})</span>. Finally, <span class="math">t</span> is viable, <span class="math">v_{h}</span> is honest, and <span class="math">\\hat{\\mathfrak{sl}}_{h}+\\Delta&lt;\\mathfrak{sl}_{2}</span>; this implies that <span class="math">\\text{depth}(u^{\\prime})\\geq\\text{depth}(v_{h})</span>. It follows that <span class="math">\\text{length}(t)-\\text{length}(u)\\geq h</span>. We conclude that if <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> witnesses a <span class="math">(s,\\tau)</span>-hcg violation then the number of <span class="math">\\Delta</span>-isolated uniquely honest slots in the relevant interval <span class="math">T</span> must be less than <span class="math">\\tau s</span>. Note that this is a property (only) of the characteristic string <span class="math">w</span>.</p>

    <p class="text-gray-300">To complete the proof, we estimate the probability of a violation with a <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> witness, for a fixed pair <span class="math">\\mathfrak{sl}_{1},\\mathfrak{sl}_{2}</span>, and apply the union bound over all such pairs to yield the final bound. For this purpose, for the random variable <span class="math">x\\leftarrow\\mathcal{D}_{\\alpha}^{f}</span> let <span class="math">H_{T}(x)</span> denote the number of <span class="math">\\Delta</span>-right-isolated uniquely honest slots among the slots from <span class="math">T=(\\mathfrak{sl}_{1}+\\Delta,\\mathfrak{sl}_{2}-\\Delta)</span>. In particular, we identify the event <span class="math">E\\triangleq\\left\\{x\\in\\{0,1,\\bot\\}^{R}\\mid H_{T}(x)&lt;c\\alpha s/3\\right\\}</span> where <span class="math">c=c(f,\\Delta)=f(1-f)^{\\Delta+1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each <span class="math">t\\in T</span>, let <span class="math">X_{t}</span> be the indicator random variable for the event that slot <span class="math">t</span> is <span class="math">\\Delta</span>-right-isolated uniquely honest. Observe that <span class="math">\\mu\\triangleq\\mathbb{E}[X_{t}]=p_{0}p_{\\bot}^{\\Delta}\\geq\\alpha f(1-f)^{\\Delta+1}</span> according to Definition 13 and (6), and that the random variables <span class="math">X_{t}</span> and <span class="math">X_{t^{\\prime}}</span> are independent if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t-t^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\Delta+1<span class="math"> (as they depend on the leader sets of non-overlapping sets of slots). If we let </span>T_{z}=\\{t\\in T\\mid t\\equiv z\\mod\\Delta+1\\}<span class="math">, then the family of variables </span>X_{t}<span class="math"> indexed by </span>T_{z}$ are independent. Note also that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\lfloor(s-2(\\Delta+1))/(\\Delta+1)\\rfloor\\geq s/(\\Delta+1)-3<span class="math"> and that we may write </span>T<span class="math"> as the disjoint union </span>T_{0}\\cup\\cdots\\cup T_{\\Delta}<span class="math">. By the Chernoff bound of Appendix E with </span>\\delta=1/2<span class="math">, for each </span>T_{z}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\sum_{t\\in T_{z}}X_{t}<\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2\\right]\\leq e^{-(\\frac{1}{2})^{2}\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2}\\leq e^{-\\frac{\\mu}{8}\\left(\\frac{s}{\\Delta+1}-3\\right)}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that if $\\sum_{t\\in T_{z}}X_{t}\\geq\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math"> for each </span>z<span class="math"> then also </span>H_{T}(x)=\\sum_{t\\in T}X_{t}\\geq\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2\\geq\\mu\\widehat{s}/2<span class="math">, where we let </span>\\widehat{s}\\triangleq s-2(\\Delta+1)\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. It follows from the union bound that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\leftarrow\\mathcal{D}_{\\alpha}^{f}}\\left[H_{T}(x)&lt;\\mu\\widehat{s}/2\\right]\\leq(\\Delta+1)\\cdot e^{-\\frac{\\mu(s-3(\\Delta+1))}{8(\\Delta+1)}}\\,.</span> (13)</p>

    <p class="text-gray-300">As <span class="math">\\mu\\geq\\alpha f(1-f)^{\\Delta+1}</span> (and <span class="math">\\mu\\leq f(1-f)\\leq 1/4</span>), we obtain</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\leftarrow\\mathcal{D}_{\\alpha}^{f}}\\left[H_{T}(x)&lt;c\\alpha\\widehat{s}/2\\right]\\leq\\Pr_{x\\leftarrow\\mathcal{D}_{\\alpha}^{f}}\\left[H_{T}(x)&lt;\\mu\\widehat{s}/2\\right]\\leq(\\Delta+1)\\cdot e^{-\\frac{c\\alpha s}{8(\\Delta+1)}+\\frac{3}{8}}\\,.</span></p>

    <p class="text-gray-300">Since <span class="math">s\\geq 6(\\Delta+1)</span>, we have <span class="math">\\widehat{s}\\geq 2s/3</span> and hence that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\leftarrow\\mathcal{D}_{\\alpha}^{f}}\\left[H_{T}(x)&lt;c\\alpha s/3\\right]\\leq(\\Delta+1)\\cdot e^{-\\frac{c\\cdot\\alpha s}{8(\\Delta+1)}+\\frac{3}{8}}\\,.</span></p>

    <p class="text-gray-300">Applying the union bound over the <span class="math">R^{2}</span> pairs <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span>, we conclude that the probability that there is a chain growth violation with parameters <span class="math">s</span> and <span class="math">\\tau=c\\alpha/3</span> is no more than</p>

    <p class="text-gray-300"><span class="math">e^{3/8}R^{2}(\\Delta+1)\\exp(-c\\alpha s/(8(\\Delta+1)))\\,.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We now turn to chain quality. This argument follows similar reasoning as above, but contrasts the chain growth guaranteed by isolated honest slots with the growth available from other active slots.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Theorem 6 (Abstract Existential Chain Quality (<span class="math">\\exists\\bf cq</span>)).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in(0,1]</span>, <span class="math">\\Delta\\in\\mathbb{N}</span>, and <span class="math">\\alpha</span> be such that <span class="math">\\alpha(1-f)^{\\Delta+1}=(1+\\epsilon)/2</span> for some <span class="math">\\epsilon&gt;0</span>. Let <span class="math">w</span> be a string drawn from <span class="math">\\{0,1,\\bot\\}^{R}</span> according to <span class="math">\\mathcal{D}_{\\alpha}^{f}</span>. Then for <span class="math">s\\geq 2(\\Delta+1)/\\epsilon</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[w\\hbox{ does not satisfy }s\\text{-}\\exists\\bf cq]\\leq R^{2}(\\Delta+2)\\cdot\\exp\\left(-\\frac{f\\epsilon^{2}(1-\\epsilon)s}{16(\\Delta+2)}+f\\epsilon^{2}/4\\right)\\,.</span></p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a characteristic string <span class="math">w\\in\\{0,1,\\bot\\}^{R}</span>. We say that a pair of slots <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> <em>witness</em> an <span class="math">\\exists\\bf cq</span> violation if there is a <span class="math">\\Delta</span>-fork <span class="math">F\\vdash w</span> and a viable tine <span class="math">t</span> so that (i.) <span class="math">\\mathfrak{sl}_{2}&gt;\\mathfrak{sl}_{1}+s</span>, (ii.) <span class="math">t</span> has an honest vertex labeled by slot <span class="math">\\mathfrak{sl}_{1}</span>, (iii.) <span class="math">t[0,\\mathfrak{sl}_{2}]</span> is viable, and (iv.) every vertex on <span class="math">t(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> is adversarial. It is a fact that if <span class="math">w</span> violates <span class="math">s\\text{-}\\exists\\bf cq</span> then there is a pair of slots <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> with the properties above: Starting with a nominal violation (a fork with a viable tine <span class="math">t</span> with no honest vertex over a window <span class="math">[\\mathfrak{sl}_{1},\\mathfrak{sl}_{2}]</span> of <span class="math">s</span> slots), one may naturally extend the left end of this window (reducing <span class="math">\\mathfrak{sl}_{1}</span>) until <span class="math">t</span> possesses an honest vertex (which may be the root) and extend the right end of this window (increasing <span class="math">\\mathfrak{sl}_{2}</span>) until <span class="math">t[0,\\mathfrak{sl}_{2}]</span> is viable—this may occur because <span class="math">t</span> has an honest vertex labeled with <span class="math">\\mathfrak{sl}_{2}</span>, or because <span class="math">\\mathfrak{sl}_{2}=\\ell(t)</span>.</p>

    <p class="text-gray-300">For convenience, let us call a slot <em>good</em> if it is <span class="math">\\Delta</span>-right-isolated uniquely honest, and <em>bad</em> if it is neither empty nor good. Moreover, we call a block <em>good</em> (resp., <em>bad</em>) if it is labeled with a good (resp., bad) slot. As in the proof of Theorem 5, for a window <span class="math">T</span> and a characteristic string <span class="math">x</span>, let <span class="math">H_{T}(x)</span> denote the number of good slots appearing in the window <span class="math">T</span>. Similarly, let <span class="math">A_{T}(x)</span> denote the number of bad slots (so that <span class="math">H_{T}(x)+A_{T}(x)</span> is equal to the number of non-empty slots in <span class="math">T</span>). We note that if <span class="math">T=(\\mathfrak{sl}_{1}+\\Delta,\\mathfrak{sl}_{2}-\\Delta)</span> and <span class="math">T^{\\prime}=(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2}]</span> then <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> cannot witness a <span class="math">s\\text{-}\\exists\\bf cq</span> violation unless <span class="math">H_{T}(x)\\leq A_{T^{\\prime}}(x)</span>. To see this, consider a fork <span class="math">F\\vdash x</span> and a tine <span class="math">t</span> realizing the conditions that <span class="math">(\\mathfrak{sl}_{1},\\mathfrak{sl}_{2})</span> is a witness. By the same argument in the proof of Theorem 5, <span class="math">t</span> must have at least <span class="math">H_{T}(x)</span> vertices over the region <span class="math">T^{\\prime}</span>. On the other hand, at most <span class="math">A_{T^{\\prime}}(x)</span> of these vertices can be adversarial. Thus the conditions require <span class="math">A_{T^{\\prime}}(x)\\geq H_{T}(x)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To conclude the proof, we consider the random variable <span class="math">x \\gets \\mathcal{D}_{\\alpha}^{f}</span> and show, for a specific fixed pair <span class="math">(\\mathfrak{sl}_1, \\mathfrak{sl}_2)</span>, that the probability that <span class="math">A_{T&#x27;}(x) \\geq H_T(x)</span> is small (for the appropriate <span class="math">T</span> and <span class="math">T&#x27;</span>); taking the union bound over all such pairs then upper-bounds the probability of a <span class="math">\\exists \\mathbf{cq}</span> failure. Fixing <span class="math">\\mathfrak{sl}_1</span> and <span class="math">\\mathfrak{sl}_2</span>, note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq s<span class="math"> while </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2(\\Delta + 1)<span class="math">. Let </span>H_i<span class="math"> (</span>i \\in T<span class="math">) be the indicator random variable for the event that slot </span>i<span class="math"> is good; let </span>A_i<span class="math"> (</span>i \\in T'<span class="math">) be the indicator random variable for the event that slot </span>i$ is bad. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ H _ {i} ] = p _ {0} p _ {\\perp} ^ {\\Delta} \\geq \\alpha f (1 - f) ^ {\\Delta + 1} = \\alpha \\cdot c (f, \\Delta) = f (1 + \\epsilon) / 2, \\quad \\text {and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ A _ {i} ] = 1 - p _ {\\perp} - p _ {0} p _ {\\perp} ^ {\\Delta} = f - p _ {0} p _ {\\perp} ^ {\\Delta} \\leq f (1 - \\epsilon) / 2.</span></div>

    <p class="text-gray-300">Applying the very reasoning leading to equation (13) but with <span class="math">\\delta = \\epsilon /2</span> and <span class="math">\\mu = \\mathbb{E}[H_i]</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ H _ {T} (x) \\leq \\underbrace {\\frac {1 + (\\epsilon / 2) (1 - \\epsilon)}{2} f \\cdot \\hat {s}} _ {(\\dagger)} \\right] = \\Pr \\left[ H _ {T} (x) \\leq (1 - \\epsilon / 2) \\frac {(1 + \\epsilon)}{2} f \\cdot \\hat {s} \\right] \\\\ \\leq \\Pr [ H _ {T} (x) \\leq (1 - \\delta) \\mu \\hat {s} ] \\leq (\\Delta + 1) \\exp \\left(- \\mu \\frac {\\delta^ {2} \\left(\\frac {s}{\\Delta + 1} - 3\\right)}{2}\\right) \\leq (\\Delta + 1) \\exp \\left(- \\frac {f \\epsilon^ {2} (s - 3 (\\Delta + 1))}{1 6 (\\Delta + 1)}\\right) \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\hat{s} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2(\\Delta + 1)$. On the other hand,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ A _ {T ^ {\\prime}} (x) \\geq \\underbrace {\\frac {1 - (\\epsilon / 2) (1 + \\epsilon)}{2} f \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} _ {(\\ddagger)} \\right] = \\Pr \\left[ A _ {T ^ {\\prime}} (x) \\geq \\left(1 + \\frac {\\epsilon}{2}\\right) \\left(f \\frac {1 - \\epsilon}{2}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right] \\\\ \\leq \\exp \\left(- \\frac {f (1 - \\epsilon) \\epsilon^ {2}}{3 2} s\\right). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As our goal is to ensure that <span class="math">H_{T}(x) &amp;gt; A_{T^{\\prime}}(x)</span>, we examine the thresholds—( <span class="math">\\dagger</span> ) and ( <span class="math">\\ddagger</span> )—appearing in these bounds. We note that ( <span class="math">\\dagger</span> ) <span class="math">\\geq</span> ( <span class="math">\\ddagger</span> ) so long as <span class="math">s \\geq (2 + \\varepsilon)(\\Delta + 1) / \\epsilon</span> ; for brevity we assume the stronger condition that <span class="math">s \\geq 3(\\Delta + 1) / \\epsilon</span>. With this assumption it follows that <span class="math">H_{T}(x) &amp;gt; A_{T^{\\prime}}(x)</span> except with probability</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (\\Delta + 1) \\exp \\left(- \\frac {f \\epsilon^ {2} (s - 3 (\\Delta + 1))}{1 6 (\\Delta + 1)}\\right) + \\exp \\left(- \\frac {f (1 - \\epsilon) \\epsilon^ {2}}{3 2} s\\right) \\\\ \\leq (\\Delta + 2) \\exp \\left(- \\frac {f \\epsilon^ {2} (1 - \\epsilon) (s - 3 (\\Delta + 1))}{1 6 (\\Delta + 2)}\\right). \\tag {14} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Summing this over all pairs <span class="math">(\\mathfrak{sl}_1,\\mathfrak{sl}_2)</span> yields the final statement.</p>

    <p class="text-gray-300">For completeness, we also state the simple observation that <span class="math">\\exists \\mathbf{cq}</span> and hcg together imply cg. The following statement (for the actual chain properties, rather than their "abstract" counterparts) first appeared in [BGK+18].</p>

    <p class="text-gray-300">Lemma 4 ([BGK+18, Lemma 10]). Consider a characteristic string <span class="math">w</span> that satisfies <span class="math">\\exists cq</span> with parameter <span class="math">s_{\\exists cq}</span> and <span class="math">hcg</span> with parameters <span class="math">\\tau_{hcg}</span> and <span class="math">s_{hcg}</span>; then it satisfies <span class="math">cg</span> with parameters</p>

    <div class="my-4 text-center"><span class="math-block">s = 2 s _ {\\exists c q} + s _ {h c g} \\qquad a n d \\qquad \\tau = \\tau_ {h c g} \\cdot \\left(\\frac {s _ {h c g}}{s _ {h c g} + 2 s _ {\\exists c q}}\\right).</span></div>

    <p class="text-gray-300">In particular, assuming <span class="math">s_{hcg} \\geq 2s_{\\exists cq}</span>, the execution satisfies <span class="math">cg</span> with parameter <span class="math">\\tau \\geq \\tau_{hcg} / 2</span>.</p>

    <p class="text-gray-300">Proof. Let <span class="math">F \\vdash w</span> be a fork and let <span class="math">t</span> be a viable tine. Consider a portion of <span class="math">t</span> spanning <span class="math">\\hat{s} \\geq s = 2s_{\\exists cq} + s_{hcg}</span> slots. By <span class="math">\\exists cq</span>, there must be an honest vertex of <span class="math">t</span> associated with the first <span class="math">s_{\\exists cq}</span> and last <span class="math">s_{\\exists cq}</span> slots. As these two honest blocks are separated by at least <span class="math">s_{hcg}</span> slots, applying hcg to the tine that terminates at the later honest block (which is necessarily viable) guarantees that at least</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {\\mathrm {h c g}} \\cdot (\\hat {s} - 2 s _ {\\exists \\mathrm {C Q}}) = \\tau_ {\\mathrm {h c g}} \\cdot \\underbrace {\\left(\\frac {\\hat {s} - 2 s _ {\\exists \\mathrm {c q}}}{\\hat {s}}\\right)} _ {(\\dagger)} \\hat {s} \\geq \\tau_ {\\mathrm {h c g}} \\cdot \\left(\\frac {s _ {\\mathrm {h c g}}}{s _ {\\mathrm {h c g}} + 2 s _ {\\exists \\mathrm {c q}}}\\right) \\hat {s}</span></div>

    <p class="text-gray-300">vertices appear in the region. (The last inequality follows because the function <span class="math">f_{\\lambda}(x)=(x-\\lambda)/x</span>, for any <span class="math">\\lambda&gt;0</span>, is strictly increasing for <span class="math">x&gt;0</span>—thus <span class="math">(\\dagger)</span> is minimized when <span class="math">\\hat{s}=s_{\\mathsf{HCG}}+2s_{\\exists\\mathsf{CQ}}</span>.) The statement of the lemma follows. ∎</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">4.7 The Transition to Protocol Executions: Common Prefix, Chain Growth, and Chain Quality</h3>

    <p class="text-gray-300">Applying the failure probability estimates for the abstract, fork-theoretic, notions of common prefix, chain growth, and chain quality, we establish the analogous estimates for protocol executions.</p>

    <p class="text-gray-300">Beginning with common prefix, the results on <span class="math">\\Delta</span>-divergence from Section 4.5 allow us to easily establish common prefix.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Theorem 7 (Common prefix).</h6>

    <p class="text-gray-300">Let <span class="math">k,R,\\Delta\\in\\mathbb{N}</span> and <span class="math">\\varepsilon\\in(0,1)</span>. Let <span class="math">\\mathcal{A}</span> be an <span class="math">\\alpha</span>-dominated adversary against the protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> for some <span class="math">\\alpha</span> satisfying <span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2</span>. Then the probability that <span class="math">\\mathcal{A}</span>, when executed in a <span class="math">\\Delta</span>-semisynchronous environment, makes <span class="math">\\pi_{\\mathrm{SPoS}}</span> violate the common prefix property with parameter <span class="math">k</span> throughout a period of <span class="math">R</span> slots is no more than <span class="math">\\exp(\\ln R+\\Delta-\\Omega(k))</span>. The constant hidden by the <span class="math">\\Omega(\\cdot)</span>-notation depends on <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that an execution of protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> violates the common prefix property with parameter <span class="math">k</span> precisely when the <span class="math">\\Delta</span>-fork <span class="math">F</span> induced by this execution has <span class="math">\\operatorname{div}_{\\Delta}(F)\\geq k</span>. We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{\\Delta}(F)\\geq k]\\leq\\Pr_{\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}}[\\operatorname{div}_{\\Delta}(w)\\geq k]\\leq\\Pr_{\\mathcal{D}^{f}_{\\alpha}}[\\operatorname{div}_{\\Delta}(w)\\geq k]\\leq\\exp(\\ln R-\\Omega(k-\\Delta))</span></p>

    <p class="text-gray-300">where the first inequality follows from the definition of <span class="math">\\operatorname{div}_{\\Delta}(\\cdot)</span>; the second one holds since <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}\\preceq\\mathcal{D}^{f}_{\\alpha}</span> and the set</p>

    <p class="text-gray-300"><span class="math">D_{\\Delta}=\\{x\\mid\\operatorname{div}_{\\Delta}(x)\\geq k\\}</span></p>

    <p class="text-gray-300">is monotone; and the last one follows from Theorem 4. (For convenience, we have moved the <span class="math">\\Delta</span> outside the asymptotic notation, which only makes the bound weaker as the hidden constant is less than 1.) ∎</p>

    <p class="text-gray-300">As for Chain Growth, this follows directly from Theorem 5.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Theorem 8 (Honest-Bounded Chain Growth).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in(0,1]</span>, <span class="math">R,\\Delta\\in\\mathbb{N}</span>, and <span class="math">\\alpha&gt;0</span>. Let <span class="math">\\mathcal{A}</span> be an <span class="math">\\alpha</span>-dominated adversary against the protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span>. Then the probability that <span class="math">\\mathcal{A}</span>, when executed in a <span class="math">\\Delta</span>-semisynchronous environment, makes <span class="math">\\pi_{\\mathrm{SPoS}}</span> violate the Honest-Bounded Chain Growth with parameters <span class="math">s\\geq 6(\\Delta+1)</span> and <span class="math">\\tau=\\alpha f(1-f)^{\\Delta+1}/3</span> over a period of <span class="math">R</span> slots, is no more than <span class="math">\\exp\\left(-\\Omega(\\alpha s)+O(\\ln R)\\right)</span>, where the asymptotic notation hides constants that depend on <span class="math">\\Delta</span> and <span class="math">f</span>.</p>

    <p class="text-gray-300">(A more exact expression for error may be read off from Theorem 5.)</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In light of the development of Section 4.4, we note that <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}\\preceq\\mathcal{D}^{f}_{\\alpha}</span>, where <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}</span> is the distribution of characteristic strings generated by this adversary and environment. Let <span class="math">G_{s,\\tau}=\\{w\\mid w\\text{ violates }(s,\\tau)\\text{-}\\mathsf{hcg}\\}</span>. By Lemma 2, this is a monotone set and the result follows from Theorem 5. Specifically,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{A},\\mathcal{Z}\\text{ violates }(s,\\tau)\\text{-}\\mathsf{HCG}]=\\Pr_{\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}}\\left[w\\text{ violates }(s,\\tau)\\text{-}\\mathsf{hcg}\\right]\\leq\\Pr_{\\mathcal{D}^{f}_{\\alpha}}[w\\text{ violates }(s,\\tau)\\text{-}\\mathsf{hcg}]\\,,</span></p>

    <p class="text-gray-300">as desired.</p>

    <p class="text-gray-300">Finally, we record the analogous result for Existential Chain Quality. Theorem 6 directly implies the following theorem.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 9 (Existential Chain quality).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in(0,1],R,\\Delta\\in\\mathbb{N}</span> and <span class="math">\\epsilon\\in(0,1)</span>. Let <span class="math">\\mathcal{A}</span> be an <span class="math">\\alpha</span>-dominated adversary against the protocol <span class="math">\\pi_{\\mathrm{SPoS}}</span> for some <span class="math">\\alpha&gt;0</span> satisfying <span class="math">\\alpha(1-f)^{\\Delta+1}\\geq(1+\\epsilon)/2</span>. Then the probability that <span class="math">\\mathcal{A}</span>, when executed in a <span class="math">\\Delta</span>-semisynchronous environment, makes <span class="math">\\pi_{\\mathrm{SPoS}}</span> violate Existential Chain Quality with parameter <span class="math">s</span> over a period of <span class="math">R</span> slots is no more than <span class="math">\\exp(O(\\ln R)-\\Omega(s))</span>. Here the constants hidden by the asymptotic notation may depend on <span class="math">\\epsilon</span>, <span class="math">f</span>, and <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">(A more exact expression for error may be read off from Theorem 6.)</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In light of the development of Section 4.4, we note that <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}\\preceq\\mathcal{D}^{f}_{\\alpha}</span>, where <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}</span> is the distribution of characteristic strings generated by this adversary and environment. Let <span class="math">Q_{s}=\\{w\\mid w\\text{ violates }s\\text{-}\\exists\\mathsf{cq}\\}</span>. By Lemma 2, this is a monotone set and the result follows from Theorem 5. Specifically,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{A},\\mathcal{Z}\\text{ violates }s\\text{-}\\exists\\mathsf{CQ}]=\\Pr_{\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}}\\left[w\\text{ violates }s\\text{-}\\exists\\mathsf{cq}\\right]\\leq\\Pr_{\\mathcal{D}^{f}_{\\alpha}}[w\\text{ violates }s\\text{-}\\exists\\mathsf{cq}]\\,,</span></p>

    <p class="text-gray-300">as desired.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">4.8 Adaptive Adversaries</h3>

    <p class="text-gray-300">The statements in the previous sections give us guarantees on the common prefix, chain growth, and chain quality properties as long as the adversary is <span class="math">\\alpha</span>-dominated for some suitable value of <span class="math">\\alpha</span>. In Section 4.4 we argued that any <em>static</em> adversary that corrupts at most <span class="math">(1-\\alpha)</span>-fraction of stake is <span class="math">\\alpha</span>-dominated. In this section we extend this claim also to <em>adaptive</em> adversaries, showing that as long as they corrupt no more than <span class="math">(1-\\alpha)</span>-fraction of stake adaptively throughout the whole execution, they are still <span class="math">\\alpha</span>-dominated.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">Every adaptive adversary <span class="math">\\mathcal{A}</span> that corrupts at most <span class="math">(1-\\alpha)</span>-fraction of stake throughout the whole execution is <span class="math">\\alpha</span>-dominated.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof (sketch).</h6>

    <p class="text-gray-300">Let us start by taking a different (but equivalent) view on the choice of slot leaders in the execution of <span class="math">\\pi_{\\text{SPoS}}</span>. Assuming that we have a fixed number <span class="math">C</span> of coins (corresponding to equally-sized units of stake), consider a family of independent, identically distributed Boolean random variables <span class="math">\\{c_{t,i}\\mid 1\\leq t\\leq R,1\\leq i\\leq C\\}</span> such that for every <span class="math">c_{t,i}</span> we have</p>

    <p class="text-gray-300">\\[ c_{t,i}=\\begin{cases}1&\\text{with probability }\\phi_{f}(1/C)=1-(1-f)^{1/C},\\\\ 0&\\text{otherwise}.\\end{cases} \\]</p>

    <p class="text-gray-300">We can view each of the random variables <span class="math">c_{t,i}</span> as being associated with a particular coin owned by one of the parties. These random variables provide an alternative view of the slot leader election process: the owner of coin <span class="math">i</span> becomes a slot leader for slot <span class="math">t</span> if <span class="math">c_{t,i}=1</span>. Thanks to the “independent aggregation property” (2), sampling the random variables <span class="math">c_{t,i}</span> yields a distribution on slot leaders equivalent to the method used by <span class="math">\\pi_{\\text{SPoS}}</span>, i.e., switching to this method of assigning slot leaders does not affect <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}</span> for any adversary <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">We now make the adversary stronger by allowing it to corrupt not only stakeholders, but individual coins. (Formally, we can see each stakeholder with stake <span class="math">s_{i}</span> as <span class="math">s_{i}</span> separate stakeholders where each controls a single coin; corrupting a coin then means corrupting such single-coin stakeholder. In particular, this means that after corrupting coin <span class="math">i</span> in some slot <span class="math">t</span>, the adversary also learns the values of the random variables <span class="math">c_{t^{\\prime},i}</span> for all <span class="math">t^{\\prime}\\geq t</span>.) To see that this only extends the class of considered adversaries, observe that any adversary <span class="math">\\mathcal{A}</span> corrupting stakeholders can be trivially modified into a coin-corrupting adversary <span class="math">\\mathcal{A}_{1}</span> that simply corrupts all the coins belonging to the stake of a player corrupted by <span class="math">\\mathcal{A}</span>, maintaining <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}}=\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{1}}</span>.</p>

    <p class="text-gray-300">It is now important to observe that at any point during the execution, all the uncorrupted coins are identical from the perspective of the adversary due to symmetry. Therefore, for any coin-corrupting adversary <span class="math">\\mathcal{A}_{1}</span> one can construct another coin-corrupting adversary <span class="math">\\mathcal{A}_{2}</span> that achieves the same outcomes, but corrupts the coins according to some fixed ordering: whenever <span class="math">\\mathcal{A}_{1}</span> corrupts a new coin, <span class="math">\\mathcal{A}_{2}</span> instead corrupts the next coin in this ordering. The only difference this makes from the perspective of the adversary is that with any corruption of a coin in slot <span class="math">t</span>, the index <span class="math">i</span> of random variables <span class="math">c_{t^{\\prime},i}</span> for <span class="math">t^{\\prime}\\geq t</span>, that are disclosed to it, changes. However, all these variables are independent and identically distributed, hence we again have <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{1}}=\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{2}}</span>.</p>

    <p class="text-gray-300">Finally, consider a static adversary <span class="math">\\mathcal{A}_{3}</span> that corrupts the first <span class="math">\\left\\lfloor(1-\\alpha)C\\right\\rfloor</span> coins with respect to the ordering used by <span class="math">\\mathcal{A}_{2}</span>. Then, during the execution, it acts exactly like <span class="math">\\mathcal{A}_{2}</span> would, except for corruptions; this is possible, since any coins corrupted by <span class="math">\\mathcal{A}_{2}</span> must be already corrupted by <span class="math">\\mathcal{A}_{3}</span> from the beginning. Note that if we consider the natural coupling of the two executions with <span class="math">\\mathcal{A}_{2}</span> and <span class="math">\\mathcal{A}_{3}</span>,</p>

    <p class="text-gray-300">where the same randomness is used, then the sets of coins chosen for slot leaders will be the same in both executions; and moreover, in each slot the set of coins corrupted by <span class="math">\\mathcal{A}_{3}</span> is a superset of those corrupted by <span class="math">\\mathcal{A}_{2}</span>. This implies that <span class="math">\\Pr[w^{(2)}\\preceq w^{(3)}]=1</span>, where <span class="math">w^{(i)}</span> is the random variable corresponding to the characteristic string resulting from the execution with <span class="math">\\mathcal{A}_{i}</span>. Using Theorem 13 from Appendix E, this in turn implies <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{2}}\\preceq\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{3}}</span>. The proof is now concluded by observing that <span class="math">\\mathcal{D}^{f}_{\\mathcal{Z},\\mathcal{A}_{3}}\\preceq\\mathcal{D}^{f}_{\\alpha}</span> follows from Section 4.4, since <span class="math">\\mathcal{A}_{3}</span> is static and corrupts at most <span class="math">(1-\\alpha)</span>-share of the stake. ∎</p>

    <p class="text-gray-300">Theorems 7, 8, 9 and 10 together give us the following corollary.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adaptive adversary against the protocol <span class="math">\\Pi_{\\mathrm{SPoS}}</span> that corrupts at most <span class="math">(1-\\alpha)</span>-fraction of stake. Then the bounds on common prefix, chain growth and chain quality given in Theorems 7, 8, 9 are satisfied for <span class="math">\\mathcal{A}</span>.</p>

    <h3 id="sec-87" class="text-xl font-semibold mt-8">4.9 The Resettable Protocol</h3>

    <p class="text-gray-300">With the analysis of these basic structural events behind us, we remark that the same arguments apply to a modest generalization of the protocol which permits the adversary some control over the nonce. Specifically, we introduce a “resettable” initialization functionality <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^{\\circ}</span>, which permits the adversary to select the random nonce from a family of <span class="math">r</span> independent and uniformly random nonces. Specifically, <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^{\\circ}</span> is identical to <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span>, with the following exception:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving the first request of the form <span class="math">(\\mathsf{genblock\\_req},U_{i})</span> from some stakeholder <span class="math">U_{i}</span>, <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^{r}</span> samples a nonce <span class="math">\\eta\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\{0,1\\}^{\\lambda}</span>, defines a “nonce candidate” set <span class="math">H=\\{\\eta\\}</span>, and permits the adversary to carry out up to <span class="math">r-1</span> <em>reset events</em>: each reset event draws an independent element from <span class="math">\\{0,1\\}^{\\lambda}</span>, adds the element to the set <span class="math">H</span>, and permits the adversary to replace the current nonce <span class="math">\\eta</span> with any element of <span class="math">H</span>. Finally, <span class="math">(\\mathsf{genblock},\\mathbb{S}_{0},\\eta)</span> is sent to <span class="math">U_{i}</span>. Later requests from any stakeholder are answered using the same value <span class="math">\\eta</span>.</li>

    </ul>

    <p class="text-gray-300">Looking ahead, our reason to introduce the resettable functionality <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^{\\circ}</span> is to capture the limited grinding capabilities of the adversary. A simple application of the union bound shows that this selection of <span class="math">\\eta</span> from among a set of size <span class="math">r</span> uniformly random candidate nonces can inflate the probability of events during the run of <span class="math">\\pi_{\\mathrm{SPoS}}</span> by a factor no more than <span class="math">r</span>. We record this as a corollary below.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Corollary 2 (Corollary to Theorems 7, 8, 9).</h6>

    <p class="text-gray-300">The protocol <span class="math">\\Pi_{\\mathrm{SPoS}}</span>, with initialization functionality <span class="math">\\mathcal{F}_{\\mathsf{INIT}}^{\\circ}</span>, satisfies the bounds of Theorems 7, 8, 9 with all probabilities scaled by <span class="math">r</span>.</p>

    <h2 id="sec-89" class="text-2xl font-bold">5 The Full Protocol</h2>

    <p class="text-gray-300">In this section, we construct a protocol that handles the dynamic case, where the stake distribution changes as the protocol is executed. As in Ouroboros <em>[x10]</em>, we divide protocol execution in a number of independent <em>epochs</em>. Each epoch consists of <span class="math">R=24k/f</span> slots (we will ignore rounding for readability) during which the stake distribution used for sampling slot leaders remains unchanged. The strategy we use to bootstrap the static protocol is, at a high level, similar: we first show how the protocol can accommodate dynamic stake utilizing an ideal “leaky beacon” functionality and then we show this beacon functionality can be simulated via an algorithm that collects randomness from the blockchain.</p>

    <p class="text-gray-300">In order to facilitate the implementation of our beacon, we need to allow the leaky beacon functionality to be adversarially manipulated by allowing a number of “resets” to be performed by the adversary. Specifically, the functionality is parameterized by values <span class="math">\\tau</span> and <span class="math">r</span>. First, it leaks to the adversary, up to <span class="math">\\tau</span> slots prior to the end of an epoch, the beacon value for the next epoch. (Looking ahead, we remark that it is essential that the stake distribution used for sampling slot leaders in the next epoch is determined prior to this leakage.) Second, the adversary can <em>reset</em> the value returned by the functionality as many as <span class="math">r</span> times. As expected for a beacon, it reports to honest parties the beacon value only once the next epoch starts. After the epoch is started no more resets are allowed for the beacon value. This mimics the functionality <span class="math">\\mathcal{F}_{\\mathsf{INIT}}</span> and its resettable</p>

    <p class="text-gray-300">version <span class="math">\\mathcal{F}_{\\textsf{INIT}}^{r}</span>. Note that the ability of the adversary to reset the beacon can be quite influential in the protocol execution: for instance, any event that depends deterministically on the nonce of an epoch and happens with probability <span class="math">1/2</span> can be easily forced to happen almost always by the adversary using a small number of resets.</p>

    <p class="text-gray-300">Naturally, we do not want to assume the availability of a randomness beacon in the final protocol, even if it is leaky and resettable. In our final iteration of the protocol we show how it is possible to simulate such beacon using a hash function that is modeled as a random oracle. This hash function is applied to the concatenation of VRF values that are inserted into each block during the first <span class="math">16k/f</span> slots of an epoch that lasts <span class="math">24k/f</span> slots in entirety. (The “quiet” period of the final <span class="math">8k/f</span> slots in each epoch will ensure that the nonce is stable before the next epoch begins.) The verifiability of those values is a key property that we exploit in the proof.</p>

    <p class="text-gray-300">Our proof strategy is to reduce any adversary against the basic properties of the blockchain to a resettable-beacon adversary that will simulate the random oracle. The key point of this reduction is that whenever the random oracle adversary makes a query with a sequence of values that is a candidate sequence for determining the nonce for the next epoch, the resettable attacker detects this as a possible reset opportunity and resets the beacon; it obtains the response from the beacon and sets this as the answer to the random oracle query.</p>

    <p class="text-gray-300">The final issue is to bound the number of resets: towards this, note that the adversary potentially controls a constant fraction of the <span class="math">16k/f</span> slots associated with nonce selection, and this allows him to explore an a priori large space of independent random potential nonces (and, ultimately, select one as the next epoch nonce). The size of this space is however upper-bounded by the number of random oracle queries that the adversary can afford during the sequence of the middle <span class="math">8k/f</span> slots, which will contain at least one honest block. To formalize this bound we utilize the <span class="math">q</span>-bounded model of <em>[x13]</em> that bounds the number of queries the adversary can pose per round: in that model, the adversary is allowed <span class="math">q</span> queries per adversarial party per round (“slot” in our setting). Assuming that the adversary controls <span class="math">t</span> parties, we obtain a rough bound of <span class="math">8qtk/f</span>.</p>

    <h3 id="sec-90" class="text-xl font-semibold mt-8">5.1 The Dynamic Stake Case with a Resettable Leaky Beacon</h3>

    <p class="text-gray-300">First we construct a protocol for the dynamic stake case assuming access to a resettable leaky beacon that provides a fresh nonce for each epoch. This beacon is leaky in the sense that it allows the adversary to obtain the nonce for the next epoch before the epoch starts, and resettable in the sense that it allows the adversary to reset the nonce a number of times. We model the resettable leaky randomness beacon in functionality <span class="math">\\mathcal{F}_{RLB}^{r,r}</span> presented in Figure 8.</p>

    <p class="text-gray-300">We now describe protocol <span class="math">\\pi_{\\text{DPoS}}</span>, which is a modified version of <span class="math">\\pi_{\\text{SPoS}}</span> that updates its genesis block <span class="math">B_{0}</span> (and thus the assignment of slot leader sets) for every new epoch. The protocol also adopts an adaptation of the static <span class="math">\\mathsf{maxvalid}_{S}</span> function, defined so that it narrows selection to those chains which share common prefix. Specifically, it adopts the following rule, parametrized by a prefix length <span class="math">k</span>:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Function <span class="math">\\mathsf{maxvalid}(\\mathcal{C},\\mathbb{C})</span>. Returns the longest chain from <span class="math">\\mathbb{C}\\cup\\{\\mathcal{C}\\}</span> that does not fork from <span class="math">\\mathcal{C}</span> more than <span class="math">k</span> blocks (i.e., not more than <span class="math">k</span> blocks of <span class="math">\\mathcal{C}</span> are discarded). If multiple exist it returns <span class="math">\\mathcal{C}</span>, if this is one of them, or it returns the one that is listed first in <span class="math">\\mathbb{C}</span>.</p>
    </blockquote>

    <p class="text-gray-300">The protocol <span class="math">\\pi_{\\text{DPoS}}</span> is described in Figure 9 and functions in the <span class="math">\\mathcal{F}_{RLB}^{r,r}</span>-hybrid model.</p>

    <h5 id="sec-91" class="text-base font-semibold mt-4">Lazy players.</h5>

    <p class="text-gray-300">Note that while the protocol <span class="math">\\pi_{\\text{DPoS}}</span> in Figure 9 is stated for a stakeholder that is permanently online, this requirement can be easily relaxed. Namely, it is sufficient for an honest stakeholder to join at the beginning of each epoch, determine whether she belongs to the slot leader set for any slots within this epoch (using the <span class="math">\\mathsf{Eval}</span> interface of <span class="math">\\mathcal{F}_{\\textsf{VRF}}</span>), and then come online and act on those slots while maintaining online presence at least every <span class="math">k</span> slots. We sketch this variant of the protocol in Appendix H.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  incorporates the diffuse functionality from Section 2.1 and is parameterized by the number of initial stakeholders  <span class="math">n</span>  and their respective stakes  <span class="math">s_1, \\ldots, s_n</span> , a nonce leakage parameter  <span class="math">\\tau</span>  and a number of allowed resets  <span class="math">r</span> .  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  interacts with stakeholders  <span class="math">U_1, \\ldots, U_n</span>  and an adversary  <span class="math">\\mathcal{A}</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the first round,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  operates exactly as  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> .</li>

      <li>Upon receiving (genblock_req,  <span class="math">sid, U_i</span> ) from stakeholder  <span class="math">U_i</span>  it operates as functionality  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  on that message.</li>

      <li>For every epoch  <span class="math">j</span> , at slot  <span class="math">jR - \\tau</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  samples the next epoch's nonce  <span class="math">\\eta_{j+1} \\stackrel{\\S}{\\leftarrow} \\{0,1\\}^{\\lambda}</span>  and leaks it by sending (epochrnd_leak, sid,  <span class="math">j</span> ,  <span class="math">\\eta_{j+1}</span> ) to the adversary  <span class="math">\\mathcal{A}</span> . Additionally,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  sets an internal reset request counter resets = 0 and sets  <span class="math">\\mathbb{P} = \\emptyset</span> .</li>

      <li>Upon receiving (epochrnd_req,  <span class="math">sid, U_i, j</span> ) from stakeholder  <span class="math">U_i</span> , if  <span class="math">j \\geq 2</span>  is the current epoch,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  sends (epochrnd,  <span class="math">sid, \\eta_j</span> ) to  <span class="math">U_i</span> .</li>

      <li>Upon receiving (epochrnd_reset,  <span class="math">sid, \\mathcal{A}</span> ) from  <span class="math">\\mathcal{A}</span>  at epoch  <span class="math">j</span> , if resets  <span class="math">&amp;lt; r</span>  and if the current slot is past slot  <span class="math">jR - \\tau</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  samples a fresh nonce for the next epoch  <span class="math">\\eta_{j+1} \\stackrel{\\S}{\\leftarrow} \\{0,1\\}^{\\lambda}</span>  and leaks it by sending (epochrnd_leak,  <span class="math">sid, \\eta_{j+1}</span> ) to  <span class="math">\\mathcal{A}</span> . Finally,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  increments resets and adds  <span class="math">\\eta_{j+1}</span>  to  <span class="math">\\mathbb{P}</span> .</li>

      <li>Upon receiving (epochrnd_set,  <span class="math">sid, \\mathcal{A}, \\eta</span> ) from  <span class="math">\\mathcal{A}</span>  at epoch  <span class="math">j</span> , if the current slot is past slot  <span class="math">jR - \\tau</span>  and if  <span class="math">\\eta \\in \\mathbb{P}</span> ,  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  sets  <span class="math">\\eta_{j+1} = \\eta</span>  and sends (epochrnd_leak,  <span class="math">sid, \\eta_{j+1}</span> ) to  <span class="math">\\mathcal{A}</span> .</li>

    </ul>

    <p class="text-gray-300">Fig. 8: The resettable leaky beacon Functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> .</p>

    <p class="text-gray-300">We proceed to the security analysis of the full protocol in the hybrid world where the functionality  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  is available to the protocol participants. A key challenge is that in the dynamic stake setting, the honest majority assumption that we have in place refers to the stakeholder view of the honest stakeholders in each slot. Already in the first few slots this assumption may diverge rapidly from the stakeholder distribution that is built-in the genesis block.</p>

    <p class="text-gray-300">To accommodate the issues that will arise from the movement of stake throughout protocol execution, we recall the notion of stake shift defined in [KRD017].</p>

    <p class="text-gray-300">Definition 15. Consider two slots  <span class="math">\\mathfrak{sl}_1, \\mathfrak{sl}_2</span>  and an execution  <span class="math">\\mathcal{E}</span> . The stake shift between  <span class="math">\\mathfrak{sl}_1, \\mathfrak{sl}_2</span>  is the maximum possible statistical distance of the two weighted-by-stake distributions that are defined using the stake reflected in the chain  <span class="math">\\mathcal{C}_1</span>  of some honest stakeholder active at  <span class="math">\\mathfrak{sl}_1</span>  and the chain  <span class="math">\\mathcal{C}_2</span>  of some honest stakeholder active at  <span class="math">\\mathfrak{sl}_2</span> .</p>

    <p class="text-gray-300">Finally, the security of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  is stated below. We slightly abuse the notation from previous sections and denote by  <span class="math">\\alpha_{\\mathcal{H}}</span>  a lower bound on the honest stake ratio throughout the whole execution.</p>

    <p class="text-gray-300">Theorem 11 (Security of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  with access to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> ). Fix parameters  <span class="math">k, R, \\Delta, L \\in \\mathbb{N}, \\epsilon, \\sigma \\in (0,1)</span>  and  <span class="math">r</span> . Let  <span class="math">R = 24k/f</span>  be the epoch length,  <span class="math">L</span>  the total lifetime of the system, and</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\alpha_ {\\mathcal {H}} - \\sigma\\right) (1 - f) ^ {\\Delta} \\geq (1 + \\epsilon) / 2. \\tag {15}</span></div>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span> , with access to  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> , with  <span class="math">\\tau \\leq 8k/f</span>  satisfies persistence with parameters  <span class="math">k</span>  and liveness with parameters  <span class="math">u = 8k/f</span>  throughout a period of  <span class="math">L</span>  slots of  <span class="math">\\Delta</span> -semisynchronous execution with probability  <span class="math">1 - \\exp(\\ln L + \\Delta + \\log(r) - \\Omega(k))</span>  assuming that  <span class="math">\\sigma</span>  is the maximum stake shift over  <span class="math">2R</span>  slots.</p>

    <p class="text-gray-300">Proof (sketch). We first observe that due to the conditions imposed on the leakiness of the  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  oracle, its level of resettability, and the domination of honest stake even after the stake shift is taken into account, Corollary 2 still applies for the whole execution over  <span class="math">L</span>  slots. The critical observation is the fact that the stakeholder distribution is determined in each epoch  <span class="math">j \\geq 2</span>  by the block that has time stamp up to  <span class="math">(j - 2)R</span> . Since  <span class="math">R \\geq 16k/f</span>  and  <span class="math">\\tau \\leq 8k/f</span>  it holds that at least  <span class="math">R - \\tau \\geq 8k/f</span>  slots will pass before the leaky beacon releases the random value of the next epoch. By applying the chain growth theorem with  <span class="math">s = 8k/f</span>  we obtain that, except with error  <span class="math">\\exp\\left(-f(1 - f)^{\\Delta} \\alpha s / (20\\Delta) + \\ln L \\Delta + O(1)\\right) = \\exp\\left(-\\Omega(k) + \\ln L + \\ln \\Delta\\right)</span>  the chain will grow</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  is run by stakeholders, initially equal to  <span class="math">U_{1},\\ldots ,U_{n}</span>  interacting among themselves and with ideal functionalities  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span>  (or  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> ),  <span class="math">\\mathcal{F}_{\\mathrm{VRF}},\\mathcal{F}_{\\mathrm{KES}},\\mathcal{F}_{\\mathrm{DSIG}},\\mathsf{H}</span>  over a sequence of  <span class="math">L = ER</span>  slots  <span class="math">S = \\{1,\\dots ,L\\}</span>  consisting of  <span class="math">E</span>  epochs with  <span class="math">R = 24k / f</span>  slots each. Define  <span class="math">T_{i}^{j}\\triangleq 2^{\\ell_{\\mathrm{VRF}}}\\phi_{f}(\\alpha_{i}^{j})</span>  as the threshold for a stakeholder  <span class="math">U_{i}</span>  for epoch  <span class="math">e_j</span> , where  <span class="math">\\alpha_{i}^{j}</span>  is the relative stake of stakeholder  <span class="math">U_{i}</span>  at epoch  <span class="math">e_j</span> ,  <span class="math">\\ell_{\\mathrm{VRF}}</span>  denotes the output length of  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> ,  <span class="math">f</span>  is the active slots coefficient and  <span class="math">\\phi_f</span>  is the mapping from equation (1). Then  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  proceeds as follows for each stakeholder  <span class="math">U_{i}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. This step is the same as Step 1 in  <span class="math">\\pi_{\\mathrm{SPoS}}</span>  except that any messages for  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  are sent to  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span>  if it is available instead.</li>

    </ol>

    <p class="text-gray-300">After initialization, for every slot  <span class="math">\\mathsf{sl}_{\\mathrm{now}} \\in S</span> , every online stakeholder  <span class="math">U_{i}</span>  performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Epoch Update. If a new epoch  <span class="math">e_{j^<em>}</span> , with  <span class="math">j^</em> \\geq 2</span> , has started,  <span class="math">U_i</span>  defines  <span class="math">\\mathbb{S}_{j^<em>}</span>  to be the stakeholder distribution drawn from the most recent block with time stamp up to  <span class="math">(j - 2)R</span>  as reflected in  <span class="math">\\mathcal{C}</span>  and sends (epochrnd_req, sid,  <span class="math">U_i, e_{j^</em>}</span> ) to  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span> , receiving (epochrnd, sid,  <span class="math">\\eta_{j^*}</span> ) as answer.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain Update.</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">U_{i}</span>  collects all valid chains received via diffusion into a set  <span class="math">\\mathbb{C}</span> , verifying that for every chain  <span class="math">\\mathcal{C}&#x27; \\in \\mathbb{C}</span> , every block  <span class="math">B = (st, d, \\mathsf{sl}, crt, \\rho, \\sigma) \\in \\mathcal{C}&#x27;</span>  with  <span class="math">crt = (U_s, y, \\pi)</span> <span class="math">\\rho = (y_\\rho, \\pi_\\rho)</span> , and  <span class="math">\\mathsf{sl}</span>  belonging to some epoch  <span class="math">e_j</span>  satisfies:</p>

    <p class="text-gray-300">(i)  <span class="math">\\mathsf{sl} \\leq \\mathsf{sl}_{\\mathrm{now}}</span>  and  <span class="math">y &amp;lt; T_i^j</span> , (ii)  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  answers (Verify, sid,  <span class="math">\\eta_{j}\\parallel \\mathsf{sl}\\parallel</span>  TEST,  <span class="math">y,\\pi ,v_{s}^{\\mathrm{crf}})</span>  by (Verified, sid,  <span class="math">\\eta \\parallel \\mathsf{sl}\\parallel</span>  TEST,  <span class="math">y,\\pi ,1)</span> (iii)  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  answers (Verify, sid,  <span class="math">\\eta_{j}\\parallel \\mathsf{sl}\\parallel \\mathsf{NONCE},y_{\\rho},\\pi_{\\rho},v_{s}^{\\mathrm{crf}})</span>  by responding with (Verified, sid,  <span class="math">\\eta_{j}\\parallel \\mathsf{sl}\\parallel \\mathsf{NONCE},y_{\\rho},\\pi_{\\rho},1)</span> ; (iv)  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  answers (Verify, sid,  <span class="math">(st,d,\\mathsf{sl},crt,\\rho),\\mathsf{sl},\\sigma ,v_s^{\\mathrm{kcs}})</span>  by (Verified, sid,  <span class="math">(st,d,\\mathsf{sl},crt,\\rho),\\mathsf{sl},1)</span> .</p>

    <p class="text-gray-300">(b)  <span class="math">U_{i}</span>  computes  <span class="math">\\mathcal{C} \\coloneqq \\max \\text{valid}(\\mathcal{C}, \\mathbb{C})</span>  and sets  <span class="math">\\mathcal{C}</span>  as the new local chain.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Chain Extension.  <span class="math">U_{i}</span>  receives from the environment the transaction data  <span class="math">d^{<em>} \\in \\{0,1\\}^{</em>}</span>  to be inserted into the blockchain, and performs the following steps:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">U_{i}</span>  sends (EvalProve, sid,  <span class="math">\\eta_{j^{<em>}}\\parallel \\mathsf{sl}_{\\mathrm{now}}\\parallel \\mathsf{NONCE})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  , obtaining (Evaluated, sid,  <span class="math">y_{\\rho},\\pi_{\\rho})</span> (b)  <span class="math">U_{i}</span>  sends (EvalProve, sid,  <span class="math">\\eta_{j^{</em>}}\\parallel \\mathsf{sl}_{\\mathrm{now}}\\parallel \\mathsf{TEST})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span>  , receiving (Evaluated, sid,  <span class="math">y,\\pi</span> (c)  <span class="math">U_{i}</span>  checks whether  <span class="math">y &amp;lt; T_{i}^{j^{<em>}}</span> . If yes, it chooses a maximal sequence  <span class="math">d^{\\prime}</span>  of transactions in  <span class="math">d^{</em>}</span>  such that adding a block with  <span class="math">d^{\\prime}</span>  to  <span class="math">\\mathcal{C}</span>  results in a valid chain, and attempts to include  <span class="math">d^{\\prime}</span>  as follows: It generates a new block  <span class="math">B = (st,d^{\\prime},\\mathsf{sl}_{\\mathrm{now}},crt,\\rho ,\\sigma)</span>  where  <span class="math">st = \\mathsf{H}(\\mathrm{head}(\\mathcal{C}))</span> ,  <span class="math">crt = (U_i,y,\\pi)</span> ,  <span class="math">\\rho = (y_{\\rho},\\pi_{\\rho})</span>  and  <span class="math">\\sigma</span>  is a signature obtained by sending (USign, sid,  <span class="math">U_{i}</span> ,  <span class="math">(st,d^{\\prime},\\mathsf{sl}_{\\mathrm{now}},crt,\\rho),\\mathsf{sl}_{\\mathrm{now}})</span>  to  <span class="math">\\mathcal{F}_{\\mathrm{KES}}</span>  and receiving (Signature, sid,  <span class="math">(st,d^{\\prime},\\mathsf{sl}_{\\mathrm{now}},crt,\\rho),\\mathsf{sl}_{\\mathrm{now}},\\sigma)</span> .  <span class="math">U_{i}</span>  computes  <span class="math">\\mathcal{C} = \\mathcal{C}\\parallel B</span> , sets it as the new local chain and diffuses  <span class="math">\\mathcal{C}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing Transactions. This step is the same as Step 4 in  <span class="math">\\pi_{\\mathrm{SPoS}}</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 9: Protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span></p>

    <p class="text-gray-300">by  <span class="math">f(1 - f)^{\\Delta} \\alpha_{\\mathcal{H}} / 4 \\cdot s \\geq (1 + \\epsilon) / 8 \\cdot s \\geq k</span>  blocks in that period of slots and thus the stakeholder distribution is completely determined prior to the leaky beacon releasing the random value of the next epoch. Based on the above, we observe that any violation of persistence in the execution with parameter  <span class="math">k</span>  results in the violation of common prefix with parameter  <span class="math">k</span> . Applying a union bound, we obtain an error of  <span class="math">\\exp(\\ln L + \\Delta + \\log(r) - \\Omega(k))</span> .</p>

    <p class="text-gray-300">We then examine liveness. Consider any transaction that is provided to the honest parties for a sequence of  <span class="math">u = 8k / f</span>  slots. It will follow as before that by chain growth the chain will grow by  <span class="math">k</span>  blocks in this interval, and by the chain quality property this means that at least one honest block will be added and hence this block will contain the transaction posted.</p>

    <p class="text-gray-300">Note that while Theorem 11 (and also Corollary 3 below) formulates the bound (15) in terms of the overall upper bound on honest stake ratio  <span class="math">\\alpha_{\\mathcal{H}}</span>  and maximum stake shift  <span class="math">\\sigma</span>  over any  <span class="math">2R</span> -slots interval, one could easily prove more fine-grained statements that would only require inequality (15) to hold for each epoch (with respect to the honest stake ratio in that epoch, and the stake shift occurring for that epoch's stake distribution).</p>

    <p class="text-gray-300">In this section, we show how to substitute the oracle  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span>  of protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  with a subprotocol  <span class="math">\\pi_{RLB}</span>  that simulates  <span class="math">\\mathcal{F}_{RLB}^{r,r}</span> . The resulting protocol can then operate directly in the  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> -hybrid</p>

    <p class="text-gray-300">model as in Section 3 (without resets) while utilizing a random oracle  <span class="math">\\mathsf{H}(\\cdot)</span> . The sub-protocol  <span class="math">\\pi_{RLB}</span>  is described in Figure 10.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{H}(\\cdot)</span>  be a random oracle.  <span class="math">\\pi_{RLB}</span>  is a sub-protocol of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  proceeding as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Upon receiving (epochrdS, sid,  <span class="math">U_{i}, e_{j^{<em>}}</span> ) from stakeholder  <span class="math">U_{i}</span> , if  <span class="math">e_{j^{</em>}} \\geq 2</span>  is the current epoch, it performs the following: for every block  <span class="math">B&#x27; = (st&#x27;, d&#x27;, \\mathsf{sl}&#x27;, crt&#x27;, \\rho&#x27;, \\sigma_{j&#x27;}) \\in \\mathcal{C}</span>  (where  <span class="math">\\mathcal{C}</span>  is the callee's  <span class="math">U_{i}</span> 's internal chain) belonging to epoch  <span class="math">e_{j^{<em>}-1}</span>  up to the slot with timestamp up to  <span class="math">(j^{</em>} - 2)R + 16k/f</span> , concatenate the values  <span class="math">y_{\\rho}&#x27;</span>  from each  <span class="math">\\rho&#x27; = (y_{\\rho}&#x27;, \\pi_{\\rho}&#x27;)</span>  into a value  <span class="math">v</span> . Compute  $\\eta_{j} = \\mathsf{H}(\\eta_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v)<span class="math">  and return (epochrdS, sid,  </span>\\eta_{j}$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 10: Protocol  <span class="math">\\pi_{RLB}</span> .</p>

    <p class="text-gray-300">We will show next that the sub-protocol  <span class="math">\\pi_{RLB}</span>  can safely substitute  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  when called from protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span> . We will perform our analysis in the  <span class="math">q</span> -bounded model of [GKL15] assuming that the adversary is capable of issuing  <span class="math">q</span>  queries per round of protocol execution per corrupted party and there are  <span class="math">t</span>  corrupted parties.</p>

    <p class="text-gray-300">Lemma 5. Consider the event of violating one of common prefix, chain quality, chain growth in an execution of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  using sub-protocol  <span class="math">\\pi_{RLB}</span>  in the  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> -hybrid model with adversary  <span class="math">\\mathcal{A}</span>  and environment  <span class="math">\\mathcal{Z}</span>  with the same parameter choices as Theorem 11. We construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  so that the corresponding event happens with the same probability in an execution of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  in the  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> -hybrid world with adversary  <span class="math">\\mathcal{A}&#x27;</span>  and environment  <span class="math">\\mathcal{Z}</span>  assuming that  <span class="math">r = 8tqk/f</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof (sketch). The adversary  <span class="math">\\mathcal{A}&#x27;</span>  simulates  <span class="math">\\mathcal{A}</span>  by maintaining locally the table for the random oracle  <span class="math">\\mathsf{H}(\\cdot)</span> . The key point in the simulation of  <span class="math">\\mathcal{A}</span>  is to detect when is appropriate for  <span class="math">\\mathcal{A}&#x27;</span>  to issue a reset query to its  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span>  oracle. Specifically, a reset query will be triggered whenever  <span class="math">\\mathcal{A}</span>  queries  <span class="math">\\mathsf{H}(\\cdot)</span>  with concatenated valid VRF values  $\\eta_{j-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{\\rho}^{(i)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{\\rho}^{(i')}<span class="math">  that are drawn from a valid chain and, specifically, from the first block of epoch  </span>e_{j-1}<span class="math">  to a block of that epoch with time stamp between  </span>8k/f<span class="math">  and  </span>16k/f<span class="math">  after the epoch start. We observe that by chain growth and chain quality at least one honest block in the middle  </span>8k/f<span class="math">  slots of an epoch will be included in the chain of all honest parties and contribute to the calculation of the hash. Finally, when the epoch  </span>e_{j-1}<span class="math">  reaches an end,  </span>\\mathcal{A}'<span class="math">  will issue (epochrd_set,  </span>w<span class="math"> ) query to  </span>\\mathcal{F}_{RLB}^{\\tau,r}<span class="math">  to set the value of the beacon to the correct value  </span>w<span class="math">  of the  </span>\\mathsf{H}(\\cdot)<span class="math">  table as it has been determined by the chain that is on the common prefix that consists of all the blocks of the epoch that contains blocks produced in the first  </span>16k/f<span class="math">  slots of the epoch. Note that the event that the  </span>\\eta_{j-1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{\\rho}^{(i)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{\\rho}^{(i')}<span class="math">  sequence corresponding to that chain in the common prefix was never queried to  </span>\\mathsf{H}(\\cdot)$  happens with negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Based on the above lemma, it is now easy to revisit Theorem 11, and show that the same result holds when using  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span>  and  <span class="math">\\pi_{RLB}</span>  instead of  <span class="math">\\mathcal{F}_{RLB}^{\\tau,r}</span> , assuming the  <span class="math">q</span> -bounded model,  <span class="math">r = 8tkq/f</span>  and  <span class="math">\\tau \\leq 8k/f</span> .</p>

    <p class="text-gray-300">Corollary 3 (Security of  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  with subprotocol  <span class="math">\\pi_{RLB}</span> ). Fix parameters  <span class="math">k, R, \\Delta, L \\in \\mathbb{N}, \\epsilon, \\sigma \\in (0,1)</span> . Let  <span class="math">R = 24k/f</span>  be the epoch length,  <span class="math">L</span>  the total lifetime of the system, and  <span class="math">(\\alpha_{\\mathsf{H}} - \\sigma)(1 - f)^{\\Delta} \\geq (1 + \\epsilon)/2</span> . The protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  using subprotocol  <span class="math">\\pi_{RLB}</span>  in the  <span class="math">\\mathcal{F}_{\\mathrm{INIT}}</span> -hybrid model satisfies persistence with parameters  <span class="math">k</span>  and liveness with parameters  <span class="math">u = 8k/f</span>  throughout a period of  <span class="math">L</span>  slots of  <span class="math">\\Delta</span> -semisynchronous execution with probability  <span class="math">1 - \\exp(\\ln L + \\Delta - \\Omega(k - \\log tkq))</span>  assuming that  <span class="math">\\sigma</span>  is the maximum stake shift over  <span class="math">2R</span>  slots.</p>

    <p class="text-gray-300">Acknowledgement. We thank Leonid Reyzin and the Horizen team for pointing out a bug in our earlier implementation of  <span class="math">\\mathcal{F}_{\\mathrm{VRF}}</span> . We also thank Christian Badertscher, Nicolas Frisby, Vanishree Rao, and the anonymous reviewers for several useful suggestions improving the presentation of the paper.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BGK^{+}18. Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang, editors, ACM CCS 2018, pages 913–930. ACM Press, October 2018.</li>

      <li>BGM14. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. CoRR, abs/1406.5694, 2014.</li>

      <li>BGM16. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. In Jeremy Clark, Sarah Meiklejohn, Peter Y. A. Ryan, Dan S. Wallach, Michael Brenner, and Kurt Rohloff, editors, FC 2016 Workshops, volume 9604 of LNCS, pages 142–157. Springer, Heidelberg, February 2016.</li>

      <li>BLMR14. Iddo Bentov, Charles Lee, Alex Mizrahi, and Meni Rosenfeld. Proof of activity: Extending bitcoin’s proof of work via proof of stake. SIGMETRICS Performance Evaluation Review, 42(3):34–37, 2014.</li>

      <li>BM99. Mihir Bellare and Sara K. Miner. A forward-secure digital signature scheme. In Michael J. Wiener, editor, CRYPTO’99, volume 1666 of LNCS, pages 431–448. Springer, Heidelberg, August 1999.</li>

      <li>Can04. Ran Canetti. Universally composable signature, certification, and authentication. In 17th IEEE Computer Security Foundations Workshop, (CSFW-17 2004), page 219. IEEE Computer Society, 2004.</li>

      <li>CEK^{+}16. Jan Camenisch, Robert R. Enderlein, Stephan Krenn, Ralf Küsters, and Daniel Rausch. Universal composition with responsive environments. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 807–840. Springer, Heidelberg, December 2016.</li>

      <li>CL07. Melissa Chase and Anna Lysyanskaya. Simulatable VRFs with applications to multi-theorem NIZK. In Alfred Menezes, editor, CRYPTO 2007, volume 4622 of LNCS, pages 303–322. Springer, Heidelberg, August 2007.</li>

      <li>Com14. The NXT Community. Nxt whitepaper. https://bravenewcoin.com/assets/Whitepapers/NxtWhitepaper-v122-rev4.pdf, July 2014.</li>

      <li>DLS88. Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.</li>

      <li>DP07. Yevgeniy Dodis and Prashant Puniya. Feistel networks made public, and applications. In Moni Naor, editor, EUROCRYPT 2007, volume 4515 of LNCS, pages 534–554. Springer, Heidelberg, May 2007.</li>

      <li>DPS19. Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconfigurable consensus and applications to provably secure proof of stake. In Ian Goldberg and Tyler Moore, editors, FC 2019, volume 11598 of LNCS, pages 23–41. Springer, Heidelberg, February 2019.</li>

      <li>DY05. Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, January 2005.</li>

      <li>GKL15. Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer, Heidelberg, April 2015.</li>

      <li>IR01. Gene Itkis and Leonid Reyzin. Forward-secure signatures with optimal signing and verifying. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 332–354. Springer, Heidelberg, August 2001.</li>

      <li>JKK14. Stanislaw Jarecki, Aggelos Kiayias, and Hugo Krawczyk. Round-optimal password-protected secret sharing and T-PAKE in the password-only model. In Palash Sarkar and Tetsu Iwata, editors, ASIACRYPT 2014, Part II, volume 8874 of LNCS, pages 233–253. Springer, Heidelberg, December 2014.</li>

      <li>KKO77. T. Kamae, U. Krengel, and G. L. O’Brien. Stochastic inequalities on partially ordered spaces. Ann. Probab., 5(6):899–912, 12 1977.</li>

      <li>Kla00. Bernhard Klar. Bounds on tail probabilities of discrete distributions. Probab. Eng. Inf. Sci., 14(2):161–171, April 2000.</li>

      <li>KN12. Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. https://peercoin.net/assets/paper/peercoin-paper.pdf, August 2012.</li>

      <li>KP15. Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015. https://eprint.iacr.org/2015/1019.</li>

      <li>KRDO17. Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357–388. Springer, Heidelberg, August 2017.</li>

    </ul>

    <p class="text-gray-300">Lin09. Andrew Y. Lindell. Adaptively secure two-party computation with erasures. In Marc Fischlin, editor, CT-RSA 2009, volume 5473 of LNCS, pages 117–132. Springer, Heidelberg, April 2009. Mic16. Silvio Micali. ALGORAND: the efficient and democratic ledger. CoRR, abs/1607.01341, 2016. MR95. Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University Press, New York, NY, USA, 1995. Nak08. Satoshi Nakamoto. “the proof-of-work chain is a solution to the byzantine generals’ problem”. The Cryptography Mailing List, https://www.mail-archive.com/cryptography@metzdowd.com/msg09997.html, November 2008. PS17. Rafael Pass and Elaine Shi. The sleepy model of consensus. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 380–409. Springer, Heidelberg, December 2017. PSs17. Rafael Pass, Lior Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 643–673. Springer, Heidelberg, April / May 2017. <span class="math">\\mathrm{PWH}^{+}17</span>. Dimitrios Papadopoulos, Duane Wessels, Shumon Huque, Moni Naor, Jan Včelák, Leonid Reyzin, and Sharon Goldberg. Making NSEC5 practical for DNSSEC. Cryptology ePrint Archive, Report 2017/099, 2017. https://eprint.iacr.org/2017/099. RMKQ17. Alexander Russell, Christopher Moore, Aggelos Kiayias, and Saad Quader. Forkable strings are rare. Cryptology ePrint Archive, Report 2017/241, 2017. https://eprint.iacr.org/2017/241. Str65. V. Strassen. The existence of probability measures with given marginals. Ann. Math. Statist., 36(2):423–439, 04 1965.</p>

    <h2 id="sec-96" class="text-2xl font-bold">Appendix A Definitions</h2>

    <p class="text-gray-300">In this appendix, we present formal definitions of Verifiable Random Functions and Key Evolving Signature Schemes with Forward Security.</p>

    <h3 id="sec-97" class="text-xl font-semibold mt-8">A.1 Verifiable Random Functions</h3>

    <p class="text-gray-300">We present formal definitions of Verifiable Random Functions from <em>[x10]</em>.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Definition 16 (Verifiable Random Function).</h6>

    <p class="text-gray-300">A function family <span class="math">\\mathsf{F}.(\\cdot):\\{0,1\\}^{\\ell}\\to\\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span> is a family of VRFs if there exist algorithms <span class="math">(\\mathsf{Gen},\\mathsf{Prove},\\mathsf{Ver})</span> such that (i.) <span class="math">\\mathsf{Gen}(1^{k})</span> outputs a pair of keys <span class="math">(\\mathsf{VRF}.pk,\\mathsf{VRF}.sk)</span>, (ii.) <span class="math">\\mathsf{Prove}_{\\mathsf{VRF}.sk}(x)</span> outputs a pair <span class="math">(\\mathsf{F}_{\\mathsf{VRF}.sk}(x),\\pi_{\\mathsf{VRF}.sk}(x))</span>, where <span class="math">\\mathsf{F}_{\\mathsf{VRF}.sk}(x)\\in\\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span> is the function value and <span class="math">\\pi_{\\mathsf{VRF}.sk}(x)</span> is the proof of correctness, and (iii.) <span class="math">\\mathsf{Ver}_{\\mathsf{VRF}.pk}(x,y,\\pi_{\\mathsf{VRF}.sk}(x))</span> verifies that <span class="math">y=\\mathsf{F}_{\\mathsf{VRF}.sk}(x)</span> using proof <span class="math">\\pi_{\\mathsf{VRF}.sk}(x)</span>, outputting <span class="math">1</span> if <span class="math">y</span> is valid and <span class="math">0</span> otherwise. Additionally, we require the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Uniqueness: no values <span class="math">(\\mathsf{VRF}.pk,x,y,y^{\\prime},\\pi_{\\mathsf{VRF}.sk}(x),\\pi_{\\mathsf{VRF}.sk}(x)^{\\prime})</span> can satisfy both</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}_{\\mathsf{VRF}.pk}(x,y,\\pi_{\\mathsf{VRF}.sk}(x))=1\\qquad\\text{and}\\qquad\\mathsf{Prove}_{\\mathsf{VRF}.pk}(x,y^{\\prime},\\pi_{\\mathsf{VRF}.sk}(x)^{\\prime})=1</span></p>

    <p class="text-gray-300">unless <span class="math">y=y^{\\prime}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Provability: if <span class="math">y,\\pi_{\\mathsf{VRF}.sk}(x)=\\mathsf{Prove}_{\\mathsf{VRF}.sk}(x)</span>, then <span class="math">\\mathsf{Ver}_{\\mathsf{VRF}.pk}(x,y,\\pi_{\\mathsf{VRF}.sk}(x))=1</span>.</li>

      <li>Pseudorandomness: for any <span class="math">PPT</span> algorithm <span class="math">A=(A_{E},A_{J})</span>, which runs for a total of <span class="math">s(k)</span> steps when its first input is <span class="math">1^{k}</span>, and does not query the <span class="math">\\mathsf{Prove}(\\cdot)</span> oracle on <span class="math">x</span>,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[b=b^{\\prime}\\Bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\begin{array}[]{l}(\\mathsf{VRF}.pk,\\mathsf{VRF}.sk)\\leftarrow\\mathsf{Gen}(1^{k});\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(x,A_{st})\\leftarrow A_{E}^{\\mathsf{Prove}(\\cdot)}(\\mathsf{VRF}.pk);\\\\ y_{0}=\\mathsf{F}_{\\mathsf{VRF}.sk}(x);y_{1}\\leftarrow\\{0,1\\}^{\\ell_{\\mathsf{VRF}}};\\\\ b\\leftarrow\\{0,1\\};b^{\\prime}\\leftarrow A_{J}^{\\mathsf{Prove}(\\cdot)}(y_{b},A_{st})\\end{array}\\right]\\leq\\frac{1}{2}+negl(k)\\,. \\]</p>

    <h3 id="sec-99" class="text-xl font-semibold mt-8">A.2 Digital Signatures and <span class="math">\\mathcal{F}_{\\mathsf{DSIG}}</span></h3>

    <p class="text-gray-300">In Figure 11, we present Functionality <span class="math">\\mathcal{F}_{\\mathsf{DSIG}}</span> as defined in <em>[x11]</em>, where it is also shown that EUF-CMA signature schemes realize <span class="math">\\mathcal{F}_{\\mathsf{DSIG}}</span>. This functionality will be used to model signatures on transactions.</p>

    <p class="text-gray-300">Functionality <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> <span class="math">\\mathcal{F}_{\\text{DSIG}}</span> interacts with a signer <span class="math">U_{S}</span> and stakeholders <span class="math">U_{1},\\ldots,U_{n}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation. Upon receiving a message <span class="math">(\\text{KeyGen},sid,U_{S})</span> from a stakeholder <span class="math">U_{S}</span>, hand <span class="math">(\\text{KeyGen},sid,U_{S})</span> to the adversary. Upon receiving <span class="math">(\\text{VerificationKey},sid,U_{S},v)</span> from the adversary, output <span class="math">(\\text{VerificationKey},sid,v)</span> to <span class="math">U_{i}</span>, and record the triple <span class="math">(sid,U_{S},v)</span>.</li>

      <li>Signature Generation. Upon receiving a message <span class="math">(\\text{Sign},sid,U_{S},m)</span> from <span class="math">U_{S}</span>, verify that <span class="math">(sid,U_{S},v)</span> is recorded for some <span class="math">sid</span> . If not, then ignore the request. Else, send <span class="math">(\\text{Sign},sid,U_{S},m)</span> to the adversary. Upon receiving <span class="math">(\\text{Signature},sid,U_{S},m,\\sigma)</span> from the adversary, verify that no entry <span class="math">(m,\\sigma,v,0)</span> is recorded. If it is, then output an error message to <span class="math">U_{S}</span> and halt. Else, output <span class="math">(\\text{Signature},sid,m,\\sigma)</span> to <span class="math">U_{S}</span>, and record the entry <span class="math">(m,\\sigma,v,0)</span>.</li>

      <li>Signature Verification. Upon receiving a message <span class="math">(\\text{Verify},sid,m,\\sigma,v^{\\prime})</span> from some stakeholder <span class="math">U_{i}</span>, hand <span class="math">(\\text{Verify},sid,m,\\sigma,v^{\\prime})</span> to the adversary. Upon receiving <span class="math">(\\text{Verified},sid,m,\\phi)</span> from the adversary do:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v^{\\prime}=v</span> and the entry <span class="math">(m,\\sigma,v,1)</span> is recorded, then set <span class="math">f=1</span>. (This condition guarantees completeness: If the verification key <span class="math">v^{\\prime}</span> is the registered one and <span class="math">\\sigma</span> is a legitimately generated signature for <span class="math">m</span>, then the verification succeeds.)</li>

      <li>Else, if <span class="math">v^{\\prime}=v</span>, the signer is not corrupted, and no entry <span class="math">(m,\\sigma^{\\prime},v,1)</span> for any <span class="math">\\sigma^{\\prime}</span> is recorded, then set <span class="math">f=0</span> and record the entry <span class="math">(m,\\sigma,v,0)</span>. (This condition guarantees unforgeability: If <span class="math">v^{\\prime}</span> is the registered one, the signer is not corrupted, and never signed <span class="math">m</span>, then the verification fails.)</li>

      <li>Else, if there is an entry <span class="math">(m,\\sigma,v^{\\prime},f^{\\prime})</span> recorded, then let <span class="math">f=f^{\\prime}</span>. (This condition guarantees consistency: All verification requests with identical parameters will result in the same answer.)</li>

      <li>Else, let <span class="math">f=\\phi</span> and record the entry <span class="math">(m,\\sigma,v^{\\prime},\\phi)</span>.</li>

    </ol>

    <p class="text-gray-300">Output <span class="math">(\\text{Verified},sid,m,f)</span> to <span class="math">U_{i}</span>.</p>

    <p class="text-gray-300">Fig. 11: Functionality <span class="math">\\mathcal{F}_{\\text{DSIG}}</span>.</p>

    <h3 id="sec-100" class="text-xl font-semibold mt-8">A.3 Forward Secure Signatures Schemes</h3>

    <p class="text-gray-300">We present the formal definitions of key evolving signature schemes and forward security of <em>[x1, x12]</em>.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Definition 17 (Key Evolving Signature Schemes).</h6>

    <p class="text-gray-300">A key evolving signature scheme <span class="math">\\text{\\tt KES}=(\\text{\\tt Gen},\\text{\\tt Sign},\\text{\\tt Verify},\\text{\\tt Update})</span> is a tuple of algorithms such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{\\tt Gen}(1^{k},T)</span> is a probabilistic key generation algorithm that takes as input a security parameter <span class="math">1^{k}</span> and the total number of periods <span class="math">T</span>, outputting a key pair <span class="math">(\\text{\\tt KES}.sk_{1},\\text{\\tt KES}.vk)</span>, where <span class="math">\\text{\\tt KES}.vk</span> is the verification key and <span class="math">\\text{\\tt KES}.sk_{1}</span> is the initial signing key (we assume that the period <span class="math">j</span> to which a signing key <span class="math">\\text{\\tt KES}.sk_{j}</span> corresponds is encoded in the signing key itself).</li>

      <li><span class="math">\\text{\\tt Sign}_{\\text{\\tt KES}.sk_{j}}(m)</span> is a probabilistic signing algorithm that takes as input a secret key <span class="math">\\text{\\tt KES}.sk_{k}</span>est for the time period <span class="math">j\\leq T</span> and a message <span class="math">m</span>, outputting a signature <span class="math">\\sigma_{j}</span> on <span class="math">m</span> for time period <span class="math">j</span> (we assume that the period <span class="math">j</span> for which a signature <span class="math">\\sigma_{j}</span> was generated is encoded in the signature itself).</li>

      <li><span class="math">\\text{\\tt Verify}_{\\text{\\tt KES}.vk}(m,\\sigma_{j})</span> is a deterministic verification algorithm that takes as input a public key <span class="math">\\text{\\tt KES}.vk</span>, a message <span class="math">m</span> and a signature <span class="math">\\sigma_{j}</span>, outputting <span class="math">1</span> if <span class="math">\\sigma_{j}</span> is a valid signature on message <span class="math">m</span> for time period <span class="math">j</span> and <span class="math">0</span> otherwise.</li>

      <li><span class="math">\\text{\\tt Update}(\\text{\\tt KES}.sk_{j})</span> is a probabilistic secret key update algorithm that takes as input a secret key <span class="math">\\text{\\tt KES}.sk_{j}</span> for the current time period <span class="math">j</span> and outputs a new secret key <span class="math">\\text{\\tt KES}.sk_{j+1}</span> for time period <span class="math">j+1</span>. We define <span class="math">\\text{\\tt KES}.sk_{T+1}</span> as the empty string and set it as the output of <span class="math">\\text{\\tt Update}(\\text{\\tt KES}.sk_{T})</span>.</li>

    </ol>

    <p class="text-gray-300">Correctness: for every key pair <span class="math">(\\text{\\tt KES}.sk_{1},\\text{\\tt KES}.vk)\\leftarrow\\text{\\tt Gen}(1^{k},T)</span>, every message <span class="math">m</span> and every time period <span class="math">j\\leq T</span>, <span class="math">\\text{\\tt Verify}_{\\text{\\tt KES}.vk}(m,\\text{\\tt Sign}_{\\text{\\tt KES}.sk_{j}}(m))=1</span>.</p>

    <p class="text-gray-300">Given a key evolving signature scheme, forward security is defined by a game that starts as the standard Chosen Message Attack (CMA) experiment but after a number of queries to the signing oracle allows the adversary to learn the signing key for the current time period. The adversary is successful if it can produce a valid signature on a message of its choice for an earlier time period. The experiment and forward security are formally defined as follows.</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Definition 18 (Forward Security Experiment).</h6>

    <p class="text-gray-300">A forger is a pair of algorithms <span class="math">F=(F_{\\mathsf{cma}},F_{\\mathsf{forge}})</span> such that <span class="math">F_{\\mathsf{cma}}</span> has access to a signing oracle. For a key pair <span class="math">(\\mathsf{KES}.vk,\\mathsf{KES}.sk_{1})\\leftarrow\\mathsf{Gen}(1^{k},T)</span>, <span class="math">F_{\\mathsf{cma}}</span> is given <span class="math">\\mathsf{KES}.vk</span> and <span class="math">T</span> and queries the signing oracle <span class="math">q_{sig}</span> times with adaptively chosen message and time period pairs, outputting the set of queried message and time period pairs <span class="math">CM</span>, the set of corresponding signatures <span class="math">sign(CM)</span> and a time period <span class="math">b</span>. Given <span class="math">CM</span>, <span class="math">sign(CM)</span> and the signing key <span class="math">\\mathsf{KES}.sk_{b}</span> for time period <span class="math">b</span>, <span class="math">F_{\\mathsf{forge}}</span> outputs <span class="math">(m,\\sigma_{j})\\leftarrow F_{\\mathsf{forge}}(CM,sign(CM),\\mathsf{KES}.sk_{b})</span>. <span class="math">F</span> is successful if <span class="math">(m,j)\\notin CM</span>, <span class="math">j&lt;b</span> and <span class="math">\\mathsf{Verify}_{\\mathsf{KES}.vk}(m,\\sigma_{j})=1</span>. (The two components of <span class="math">F</span> can communicate the necessary information, including <span class="math">T</span> and <span class="math">b</span> through <span class="math">CM</span>.)</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Definition 19 (Forward Security).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span> be the probability (over the random coins of <span class="math">\\mathsf{KES}</span> and <span class="math">F</span>) that <span class="math">F</span> is successful in the forward security experiment of Definition 18. Let the function <span class="math">\\mathbf{InSec}^{fwsig}(\\mathsf{KES}[k,T],t,q_{s}ig)</span> (the <em>insecurity</em> function) be the maximum of <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span>, over all algorithms <span class="math">F</span> that are restricted to running time <span class="math">t</span> and <span class="math">q_{s}ig</span> signature queries. A key evolving signature scheme <span class="math">\\mathsf{KES}</span> is forward secure against an adversary that runs in time <span class="math">t</span> and makes <span class="math">q_{s}ig</span> signature queries if <span class="math">\\mathbf{Succ}^{fwsig}(\\mathsf{KES}[k,T],F)</span> is negligible in <span class="math">k</span>.</p>

    <h2 id="sec-104" class="text-2xl font-bold">Appendix B Realizing <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span></h2>

    <p class="text-gray-300">We will follow the proof strategy of <em>[x1]</em> to show that a construction based on a key evolving signature scheme (Definition 17) realizes <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>. Our construction <span class="math">\\pi_{KES}</span> is based on a key evolving signature scheme <span class="math">\\mathsf{KES}=(\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Verify},\\mathsf{Update})</span>. The signature protocol <span class="math">\\pi_{KES}</span> is run between a stakeholder <span class="math">U_{S}</span> and stakeholders <span class="math">U_{1},\\ldots,U_{n}</span>, proceeding as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key Generation: When <span class="math">U_{S}</span> receives an input <span class="math">(\\mathsf{KeyGen},sid,U_{S})</span> , it runs <span class="math">\\mathsf{Gen}(1^{k},T)</span>, records the signing key <span class="math">(\\mathsf{sid},\\mathsf{KES}.sk_{1},)</span>, sets counter <span class="math">\\mathsf{k}_{\\mathsf{ctr}}=1</span> and outputs <span class="math">(\\mathsf{VerificationKey},sid,\\mathsf{KES}.vk)</span>.</li>

      <li>Signature and Update: When <span class="math">U_{S}</span> receives an input <span class="math">(\\mathsf{Sign},sid,U_{S},m,j)</span> for a <span class="math">sid</span> for which it has the signing key <span class="math">(\\mathsf{sid},\\mathsf{U_{S}},\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}},)</span> and that <span class="math">\\mathsf{k}_{\\mathsf{ctr}}\\geq j\\leq T</span>. Otherwise, it ignores the input. First, <span class="math">U_{S}</span> performs the following steps until <span class="math">\\mathsf{k}_{\\mathsf{ctr}}=j</span>: run <span class="math">\\mathsf{Update}(\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}})</span> to obtain <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}+1}</span>, securely erase <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}</span> and increment <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>. Next, It runs <span class="math">\\mathsf{Sign}_{\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}}(m)</span> to obtain <span class="math">\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}}</span>, runs <span class="math">\\mathsf{Update}(\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}})</span> to obtain <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}+1}</span>, securely erases <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}</span>, outputs <span class="math">(\\mathsf{Signature},sid,m,\\mathsf{k}_{\\mathsf{ctr}},\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}})</span> and increments <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>.</li>

      <li>Verification: When a stakeholder <span class="math">U_{i}</span> receives an input <span class="math">(\\mathsf{Verify},sid,m,j,\\sigma_{j},\\mathsf{KES}.vk^{\\prime})</span>, it outputs <span class="math">(\\mathsf{Verified},sid,m,j,\\mathsf{Verify}_{\\mathsf{KES}.vk^{\\prime}}(m,\\sigma_{j}))</span>.</li>

    </ul>

    <h6 id="sec-105" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">The <span class="math">\\pi_{KES}</span> construction presented above, realizes <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> with erasures assuming <span class="math">\\mathsf{KES}=(\\mathsf{Gen},\\mathsf{Sign},\\mathsf{Verify},\\mathsf{Update})</span> is a key evolving signature scheme with forward security as per Definition 17 and Definition 19.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We follow the approach of <em>[x1]</em> by showing that an environment <span class="math">\\mathcal{Z}</span> that distinguishes an ideal execution with a prescribed simulator <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> from a real execution with an adversary <span class="math">\\mathcal{A}</span> and <span class="math">\\pi_{KES}</span> can be used to construct a forger for the underlying key evolving signature scheme <span class="math">\\sigma</span> that is successful in the forward security experiment of Definition 18 with non-negligible probability, thus contradicting the forward security guarantee of <span class="math">\\sigma</span>. We argue that since <span class="math">\\mathcal{Z}</span> can distinguish the real world execution from the idea world execution for any <span class="math">\\mathcal{Z}</span>, it will also succeed for an specific simulator <span class="math">\\mathcal{S}</span>. Simulator <span class="math">\\mathcal{S}</span> runs an internal copy of <span class="math">\\mathcal{A}</span>, proceeding as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> forwards any inputs from <span class="math">\\mathcal{Z}</span> to <span class="math">\\mathcal{A}</span> and any outputs from <span class="math">\\mathcal{A}</span> to <span class="math">\\mathcal{Z}</span>.</li>

      <li>Upon receiving <span class="math">(\\mathsf{KeyGen},sid,U_{S})</span> from <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>, <span class="math">\\mathcal{S}</span> runs <span class="math">\\mathsf{Gen}(1^{k},T)</span>, records the signing key <span class="math">(\\mathsf{sid},\\mathsf{U_{S}},\\mathsf{KES}.sk_{1},)</span>, sets counter <span class="math">\\mathsf{k}_{\\mathsf{ctr}}=1</span> and sends <span class="math">(\\mathsf{VerificationKey},sid,U_{S}\\mathsf{KES}.vk)</span> to <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>.</li>

      <li>Upon receiving <span class="math">(\\mathsf{Signature},sid,U_{S},j,m)</span> from <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>, <span class="math">\\mathcal{S}</span> checks that <span class="math">\\mathsf{k}_{\\mathsf{ctr}}\\geq j\\leq T</span>. Otherwise, it ignores the request. First, <span class="math">\\mathcal{S}</span> performs the following steps until <span class="math">\\mathsf{k}_{\\mathsf{ctr}}=j</span>: run <span class="math">\\mathsf{Update}(\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}})</span> to obtain <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}+1}</span>, securely erase <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}</span> and increment <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>. Next, <span class="math">\\mathcal{S}</span> runs <span class="math">\\mathsf{Sign}_{\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}}(m)</span> to obtain <span class="math">\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}}</span>, runs <span class="math">\\mathsf{Update}(\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}})</span> to obtain <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}+1}</span>, securely erases <span class="math">\\mathsf{KES}.sk_{k_{\\mathsf{ctr}}}</span>, sends <span class="math">(\\mathsf{Signature},sid,U_{S},m,\\mathsf{k}_{\\mathsf{ctr}},\\sigma_{\\mathsf{k}_{\\mathsf{ctr}}})</span> to <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> and increments <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>.</li>

      <li>Upon receiving <span class="math">(\\mathsf{Verify},sid,m,j,\\sigma,\\mathsf{KES}.vk^{\\prime})</span> from <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span>, <span class="math">\\mathcal{S}</span> sends</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{(</span>\\mathsf{Verified},sid,m,j,\\mathsf{Verify}_{\\mathsf{KES}.vk^{\\prime}}(m,\\sigma_{j})<span class="math">)}\\text{ to }\\mathcal{F}_{\\mathsf{KES}}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\mathcal{A}</span> corrupts a party <span class="math">U^{\\prime}</span>, <span class="math">\\mathcal{S}</span> corrupts <span class="math">U^{\\prime}</span> in the ideal world. If <span class="math">U^{\\prime}=U_{S}</span> (i.e. the signer), <span class="math">\\mathcal{S}</span> reveals the signing key <span class="math">\\mathsf{KES}.sk_{\\mathsf{k}_{\\mathsf{ctr}}}</span> and the internal state of <span class="math">\\mathsf{Sign}</span> (if there’s any) as the state of <span class="math">U_{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Given an environment <span class="math">\\mathcal{Z}</span> that distinguishes an ideal execution with simulator <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> from a real execution with <span class="math">\\mathcal{A}</span> and <span class="math">\\pi_{KES}</span>, we will construct a forger <span class="math">F=(F_{\\mathsf{cma}},F_{\\mathsf{forge}})</span> for the underlying key evolving signature scheme <span class="math">\\sigma</span>. Our forger <span class="math">F</span> will run an internal copy of <span class="math">\\mathcal{Z}</span>, simulating for <span class="math">\\mathcal{Z}</span> the interactions with <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> (i.e. acting as <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> towards <span class="math">\\mathcal{Z}</span>). Moreover, <span class="math">F</span> will run an internal copy of <span class="math">\\mathcal{A}</span> as in the case of <span class="math">\\mathcal{S}</span>.</p>

    <p class="text-gray-300">Forger <span class="math">F</span> starts execution as <span class="math">F_{\\mathsf{cma}}</span> in the first phase of the forward security game (as per Definition 18), where it is given a verification key <span class="math">\\mathsf{KES}.vk</span> for total number of time periods <span class="math">T</span> and has access to signing oracle. When <span class="math">F</span> is activated, it gives <span class="math">\\mathcal{A}</span> the verification key <span class="math">\\mathsf{KES}.vk</span> obtained in the forward security experiment. Whenever <span class="math">F</span> has to generate a signature as <span class="math">\\mathcal{S}</span>, it calls its signing oracle with the given message and current <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span>, which are added the set of queried message and time period pairs <span class="math">CM</span>. The signatures obtained from the oracle are used in the answers of the simulated <span class="math">\\mathcal{S}</span> and added the set of signatures <span class="math">sign(CM)</span> corresponding to <span class="math">CM</span>. Whenever the internal <span class="math">\\mathcal{Z}</span> activates an uncorrupted party with <span class="math">(\\mathsf{Verify},sid,m,j,\\sigma,\\mathsf{KES}.vk^{\\prime})</span>, <span class="math">F</span> tests whether <span class="math">(m,j)\\notin CM</span>, <span class="math">\\mathsf{Verify}_{\\mathsf{KES}.vk^{\\prime}}(m,\\sigma_{j})</span> and <span class="math">j&lt;\\mathsf{k}_{\\mathsf{ctr}}</span>. If this condition is met and the signer is not corrupted, the triple <span class="math">(m,j,\\sigma)</span> can be used by <span class="math">F</span> to succeed in the forward security experiment. <span class="math">F</span> outputs <span class="math">CM</span>, <span class="math">sign(CM)</span> and <span class="math">\\mathsf{k}_{\\mathsf{ctr}}</span> ending the first phase of the forward security game. Next, acting as <span class="math">F_{\\mathsf{forge}}</span> in the forward security game, it outputs <span class="math">(m,\\sigma_{j})</span>, succeeding in the experiment. If <span class="math">\\mathcal{A}</span> corrupts the signer, <span class="math">F</span> outputs <span class="math">\\bot</span> and halts.</p>

    <p class="text-gray-300">Following the same reasoning as in <em>[x1]</em>, we argue that given the correctness property of <span class="math">\\sigma</span>, the internal environment <span class="math">\\mathcal{Z}</span> would not issue a query <span class="math">(\\mathsf{Verify},sid,m,j,\\sigma,\\mathsf{KES}.vk^{\\prime})</span>, <span class="math">F</span> such that <span class="math">(m,j)\\notin CM</span>, <span class="math">\\mathsf{Verify}_{\\mathsf{KES}.vk^{\\prime}}(m,\\sigma_{j})</span> and <span class="math">j&lt;\\mathsf{k}_{\\mathsf{ctr}}</span> in the case that the signer is not corrupted. If this query indeed does not happen, <span class="math">\\mathcal{Z}</span> would not be able to distinguish between an ideal and a real executions. However, this query happens with non-negligible probability since we assume that <span class="math">\\mathcal{Z}</span> does distinguish real from ideal executions. Moreover, notice that the interactions with <span class="math">\\mathcal{F}_{\\mathsf{KES}}</span> from the point of view of <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span> are the same in a real world execution with <span class="math">\\pi_{KES}</span>, guaranteeing that a forgery is obtained. ∎</p>

    <h2 id="sec-107" class="text-2xl font-bold">Appendix C Realizing <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span></h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We provide an implementation of <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> in the random oracle model. It makes use of a cyclic group <span class="math">\\langle g\\rangle</span> with a generator <span class="math">g</span>, the description of which is assumed to be publicly known, and two hash functions <span class="math">H,H^{\\prime}</span> with ranges <span class="math">\\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span> and <span class="math">\\langle g\\rangle</span> respectively, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle g\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q$. The implementation is based on the 2-Hash-DH verifiable oblivious PRF construction of <em>[x11]</em>, and is basically identical to the construction of <em>[PWH^{+}17]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Specifically, the public-key is equal to <span class="math">v=g^{k}</span> and the output is <span class="math">y=H(m,u)</span> where <span class="math">u=H^{\\prime}(m)^{k}</span>, while the proof is set to <span class="math">\\pi=(u,\\text{EQDL}(k:\\log_{H^{\\prime}(m)}(u)=\\log_{g}(v);m,v))</span>. The verification of <span class="math">(m,y,\\pi,v)</span> proceeds as follows. First it parses <span class="math">\\pi</span> as <span class="math">(u,\\pi^{\\prime})</span> where <span class="math">\\pi^{\\prime}</span> is a proof of equality of discrete logarithms. It verifies <span class="math">y=H(m,u)</span> as well as the proof <span class="math">\\pi^{\\prime}</span> and returns <span class="math">1</span> if and only if both tests pass. The proof notation <span class="math">\\text{EQDL}(k:\\log_{H^{\\prime}(m)}(u)=\\log_{g}(v);m,v)</span> stands for the string <span class="math">(c,s)</span> where <span class="math">c=H(m,u,v,g^{c},H^{\\prime}(m)^{c})</span>, <span class="math">s=r+kc\\bmod q</span>, while the verification of <span class="math">(c,s)</span> on context <span class="math">m,v</span> is performed by checking the equality</p>

    <p class="text-gray-300"><span class="math">c=H(m,u,v,g^{s}v^{-c},H^{\\prime}(m)^{s}u^{-c})\\,.</span></p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Theorem 2</h6>

    <p class="text-gray-300">The 2Hash-DH construction presented above, realizes <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> in the random oracle model assuming the CDH.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We describe a simulator <span class="math">\\mathcal{S}</span> that controls the random oracles <span class="math">H,H^{\\prime}</span> and operates in the following manner.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving a message <span class="math">(\\mathsf{KeyGen},sid,U_{i})</span> from <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>, a new value <span class="math">v=g^{k}</span> is selected for a random <span class="math">k</span> and <span class="math">\\mathcal{S}</span> inserts <span class="math">(U_{i},v)</span> in its internal registry of keys; in case the key exists already, <span class="math">\\mathcal{S}</span> returns fail and terminates. It returns to <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> the message <span class="math">(\\mathsf{VerificationKey},sid,U_{i},v)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving a message (EvalProve, <span class="math">sid,U_{i},m</span>) from <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>, this is matched to the verification key <span class="math">v</span> of <span class="math">U_{i}</span> and is checked whether <span class="math">m</span> has been queried before. In such case, the value <span class="math">u</span> that corresponds to <span class="math">m</span> in the table for <span class="math">v</span> is recovered. In case <span class="math">m</span> was not queried before, it is checked whether <span class="math">H^{\\prime}(m)</span> is defined. In such case the entry <span class="math">(\\mathsf{base},m,t)</span> is recovered, the value <span class="math">u</span> is set to <span class="math">v^{t}</span> and the triple <span class="math">(v,m,u)</span> is stored for future reference. In case the value <span class="math">H^{\\prime}(m)</span> is undefined <span class="math">\\mathcal{S}</span> selects <span class="math">t</span> at random, stores <span class="math">(\\mathsf{base},m,t)</span> and sets <span class="math">H^{\\prime}(m)=g^{t}</span>. Subsequently random <span class="math">c,s</span> values are selected by <span class="math">\\mathcal{S}</span>; the pair <span class="math">((m,u,v,g^{s}v^{-c},H^{\\prime}(m)^{s}u^{-c}),c)</span> is inserted to the table of the random oracle <span class="math">H</span>. In case this is not feasible (because that would make the table inconsistent), <span class="math">\\mathcal{S}</span> outputs fail and terminates. Finally, <span class="math">\\pi</span> is set to <span class="math">(u,(c,s))</span> and the message <span class="math">(\\mathsf{Eval},sid,m,\\pi)</span> is returned to <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>.</li>

      <li>Upon receiving <span class="math">(\\mathsf{Verify},sid,m,y,\\pi,v^{\\prime})</span> from <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>, parse <span class="math">\\pi</span> as <span class="math">(u^{\\prime},(c,s))</span> and verify the proof <span class="math">(c,s)</span> as a proof of equality of discrete logarithms, <span class="math">\\log_{g}(v^{\\prime})=\\log_{H^{\\prime}(m)}(u^{\\prime})</span>, to obtain a bit <span class="math">b</span>. If <span class="math">b=1</span>, then submit <span class="math">(\\mathsf{Eval},sid,v^{\\prime},m,\\{\\pi\\})</span> to <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> (as it is a valid proof and in case <span class="math">v^{\\prime}</span> is a corrupted key it should be registered with <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>). Now observe that <span class="math">(\\mathsf{base},m,t)</span> must be recorded, and set <span class="math">b^{\\prime}=((u^{\\prime})^{1/t}=v^{\\prime})\\wedge(H(m,u)=y)</span>. If <span class="math">b=1\\wedge b^{\\prime}=0</span> output fail and terminate. In any other case, t return <span class="math">(\\mathsf{Verified},sid,m,y,\\pi,v^{\\prime})</span> to <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> (in particular note that if <span class="math">b=0\\wedge b^{\\prime}=1</span>, the proof <span class="math">\\pi</span> will not be recorded with <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> and hence <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> will return the correct output <span class="math">0</span> to the verifier).</li>

      <li>Upon receiving a query <span class="math">m</span> for the random oracle <span class="math">H^{\\prime}</span>, select <span class="math">t</span> at random, store <span class="math">(\\mathsf{base},m,t)</span> and return <span class="math">g^{t}</span>.</li>

      <li>Upon receiving a query for the random oracle <span class="math">H</span> of the form <span class="math">(m,u)</span>, and the value <span class="math">(\\mathsf{base},m,t)</span> is stored previously, <span class="math">\\mathcal{S}</span> performs the following. First, if <span class="math">v=u^{1/t}</span> is not registered as a public-key it registers <span class="math">(\\mathsf{KeyGen},sid,v)</span> with <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>. Then it submits <span class="math">(\\mathsf{Eval},sid,u^{1/t},m,\\emptyset)</span> to the <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span>. If <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> ignores the request <span class="math">\\mathcal{S}</span> terminates with fail. Else it obtains the response <span class="math">y</span> which is set as the random oracle output to the query <span class="math">(m,u)</span>. In case <span class="math">(\\mathsf{base},m,t)</span> is not stored, then perform the step that corresponds to the query <span class="math">H^{\\prime}(m)</span> above and repeat the current step.</li>

    </ol>

    <p class="text-gray-300">Other queries to <span class="math">H</span> are handled by returning random elements of <span class="math">\\{0,1\\}^{\\ell_{\\mathsf{VRF}}}</span>.</p>

    <p class="text-gray-300">We observe that unless <span class="math">\\mathcal{S}</span> outputs fail the simulation of protocol 2Hash-DH is perfect. We next argue that the probability to output fail is negligible. <span class="math">\\mathcal{S}</span> outputs fail in the case that <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> ignores a request <span class="math">(\\mathsf{Eval},sid,u^{1/t},m)</span>. This means that the key <span class="math">v=u^{1/t}</span> is registered with an honest party that has not evaluated <span class="math">m</span>. It follows that the event an adversary that produces such <span class="math">u</span> can be turned to solver for the CDH assumption. The other cases where <span class="math">\\mathcal{S}</span> produces fail, specifically, step 1 and step 3 can be easily seen to be negligible probability events. ∎</p>

    <h2 id="sec-110" class="text-2xl font-bold">Appendix D Insecurity of the Original Ouroboros Against Adversarial Message Delays</h2>

    <p class="text-gray-300">This appendix informally describes several attacks against the Proof-of-Stake protocol Ouroboros proposed in <em>[x10]</em>, when used in various environments that allow the adversary to control message delays to some extent.</p>

    <p class="text-gray-300">We consider two variants of the semi-synchronous model. With sender-side delays, each message can be delayed on the side of its sender, and hence after being delayed, it arrives to all recipients in the same round. On the other hand, if we allow for recipient-side delays, the each message can be delayed for a different time period for each of its recipients. The latter model is the one that we consider for our positive results in the main body of the paper. Clearly this latter model gives more power to the adversary, hence we explore it first here.</p>

    <h3 id="sec-111" class="text-xl font-semibold mt-8">D.1 Recipient-Side Delays</h3>

    <h4 id="sec-112" class="text-lg font-semibold mt-6">The Model.</h4>

    <p class="text-gray-300">The model for recipient-side delays is identical to the one given in Section 2.1.</p>

    <h4 id="sec-113" class="text-lg font-semibold mt-6">Attack Description.</h4>

    <p class="text-gray-300">Intuitively, the adversary aims to violate the common prefix property by maintaining two tines that are growing at approximately the same rate: so that their lengths never differ by more than one block. This is achieved by disclosing the blocks mined in the past <span class="math">\\Delta</span> rounds (which are distributed via the DDiffuse functionality and hence can be delayed by <span class="math">\\mathcal{A}</span>) in a controlled</p>

    <p class="text-gray-300">way to affect the decision of the current slot leader (in case he is honest) about which of the two tines to extend.</p>

    <p class="text-gray-300">The attack can be performed even in the simple setting with a static stake and slot leaders sampled by an idealized beacon. Moreover, it can be carried out without any corrupted parties at all (i.e., also if the adversarial stake ratio <span class="math">\\alpha_{\\mathcal{A}}=0</span>), as long as <span class="math">\\mathcal{A}</span> maintains control over message delays.</p>

    <p class="text-gray-300">In detail, <span class="math">\\mathcal{A}</span> behaves as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Internally, <span class="math">\\mathcal{A}</span> maintains two tines <span class="math">T_{0}</span> and <span class="math">T_{1}</span>, initially empty. Whenever any party diffuses a chain <span class="math">C</span> such that some <span class="math">T_{i}</span> is a prefix of <span class="math">C</span>, <span class="math">\\mathcal{A}</span> replaces <span class="math">T_{i}</span> with <span class="math">C</span> (except for the trivial initial case when any chain is a prefix of both <span class="math">T_{0}</span> and <span class="math">T_{1}</span>, here <span class="math">\\mathcal{A}</span> only replaces <span class="math">T_{0}</span>).</li>

      <li>In each slot <span class="math">sl_{r}</span>:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Determine <span class="math">T_{s}</span>, the tine that is currently not longer, i.e., such that it satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{1-s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">U_{i}</span> denote the slot leader for the upcoming slot <span class="math">sl_{r+1}</span>. If a message containing <span class="math">T_{s}</span> was diffused in this round, <span class="math">\\mathcal{A}</span> delivers it to the inbox of <span class="math">U_{i}</span> and to the <span class="math">\\mathsf{delayed}_{j}</span>-strings for all other parties <span class="math">j\\neq i</span>. Otherwise, if a message containing <span class="math">T_{s}</span> is already present in <span class="math">\\mathsf{delayed}_{i}</span>, <span class="math">\\mathcal{A}</span> removes it from <span class="math">\\mathsf{delayed}_{i}</span> and delivers it to the inbox of party <span class="math">U_{i}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> moves all messages diffused in this round into the <span class="math">\\mathsf{delayed}</span>-strings of all parties.</li>

    </ol>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">D.2 Sender-Side Delays</h3>

    <p class="text-gray-300">We now argue that the original Ouroboros protocol is insecure even against sender-side adversarial message delays.</p>

    <h4 id="sec-115" class="text-lg font-semibold mt-6">The Model.</h4>

    <p class="text-gray-300">We consider an ideal functionality <span class="math">\\mathsf{SDiffuse}_{\\Delta}</span> that is defined exactly as the functionality <span class="math">\\mathsf{Diffuse}</span> given in <em>[x13]</em>, except for two differences:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the adversary <span class="math">\\mathcal{A}</span> is activated, besides performing any of the actions that were allowed by the <span class="math">\\mathsf{Diffuse}</span> functionality, it is also allowed to:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>move any message obtained in a diffuse request from a party to a special string <span class="math">\\mathsf{delayed}</span>,</li>

      <li>move any message from the string <span class="math">\\mathsf{delayed}</span> to the inboxes of all parties.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of each round, the functionality ensures that for every message that was either (a) diffused in this round and not put to the string <span class="math">\\mathsf{delayed}</span> or (b) removed from the string <span class="math">\\mathsf{delayed}</span> in this round, it is present in the inboxes of all parties. If any message currently present in <span class="math">\\mathsf{delayed}</span> was originally diffused at least <span class="math">\\Delta</span> slots ago, then the functionality removes it from <span class="math">\\mathsf{delayed}</span> and appends it to the inbox of all parties.</li>

    </ol>

    <p class="text-gray-300">We again define our model by replacing <span class="math">\\mathsf{Diffuse}</span> by <span class="math">\\mathsf{SDiffuse}_{\\Delta}</span> in the model of <em>[x13]</em> (this gives us a class of models parametrized by <span class="math">\\Delta</span>, setting <span class="math">\\Delta=0</span> again results in the original model of <em>[x13]</em>).</p>

    <h4 id="sec-116" class="text-lg font-semibold mt-6">Attack Description.</h4>

    <p class="text-gray-300">The adversary again aims to violate the common prefix property by maintaining two tines that are growing at approximately the same rate. However, this time it cannot deliver messages selectively to future slot leaders, and hence the attack requires a slight modification.</p>

    <p class="text-gray-300">The details of the attack depend on the exact definition of the <span class="math">\\mathsf{maxvalid}</span> function that honest parties use to choose the winning chain, namely on how it does tie-breaking in case of several equal-length chains. According to <em>[x13]</em>, <span class="math">\\mathsf{maxvalid}</span> should favor the current chain <span class="math">C</span> if it is the longest, otherwise choose arbitrarily. There are several natural possibilities to perform this choice:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a chain that was delivered first out of those with maximal length.</li>

      <li>Choose a chain at random out of those with maximal length.</li>

      <li>Prefer an extension of the current chain <span class="math">C</span>. This is not fully specified, a rule to choose among several extensions of <span class="math">C</span> with maximal length is also needed.</li>

      <li>Apply some fixed ordering rule, e.g. take the lexicographically first out of the chains with maximal length.</li>

    </ol>

    <p class="text-gray-300">We now sketch an attack for each of the cases above. The attacks can again be performed even in the simple setting with a static stake, slot leaders sampled by an idealized beacon, and without any corrupted parties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The adversary starts by partitioning the stakeholders into two sets <span class="math">S_{0}</span> and <span class="math">S_{1}</span> so that each of these sets controls about one half of the total stake. It again maintains two tines <span class="math">T_{0}</span> and <span class="math">T_{1}</span>, and also keeps track of the prefixes <span class="math">T_{i}^{\\prime}</span> of each <span class="math">T_{i}</span> that were already delivered by <span class="math">\\mathsf{SDiffuse}_{\\Delta}</span> to all parties. The goal of <span class="math">\\mathcal{A}</span> is to maintain $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{0}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{1}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and make all parties in </span>S_{i}<span class="math"> believe that </span>T_{i}^{\\prime}$ is their current chain. This is achieved as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In each slot <span class="math">sl_{j}</span>, the slot leader <span class="math">U_{j}\\in S_{i}</span> will extend <span class="math">T_{i}^{\\prime}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> will delay this new block unless there is already also an existing block in <span class="math">T_{1-i}\\setminus T_{1-i}^{\\prime}</span> that can be used to extend both <span class="math">T_{0}^{\\prime}</span> and <span class="math">T_{1}^{\\prime}</span> by one block at the same time.</li>

      <li>If this is the case, <span class="math">\\mathcal{A}</span> delivers both delayed blocks, extends both <span class="math">T_{0}^{\\prime}</span> and <span class="math">T_{1}^{\\prime}</span> by one block, and uses its power to reorder messages in the inboxes of honest parties to maintain that parties in <span class="math">S_{i}</span> still consider the new <span class="math">T_{i}^{\\prime}</span> to be their current chain (note that parties follow the rule ((i)) above).</li>

    </ul>

    <p class="text-gray-300">The probability that a message would need to be delayed by <span class="math">\\mathcal{A}</span> for more than <span class="math">\\Delta</span> slots to follow this strategy decreases exponentially with <span class="math">\\Delta</span>. A similar approach as in the case (i) will work, with one small change. Here <span class="math">\\mathcal{A}</span> does not need to choose partitions <span class="math">S_{0}</span> and <span class="math">S_{1}</span> and maintain them using its inbox-reordering capability. Instead, it can simply observe which of the chains <span class="math">T_{0}^{\\prime}</span> and <span class="math">T_{1}^{\\prime}</span> are being extended, and again only deliver extensions for both of them at the same time. By rule (ii), each stakeholder will choose its current chain by choosing at random between the new <span class="math">T_{0}^{\\prime}</span> and <span class="math">T_{1}^{\\prime}</span>. This will guarantee a quite even distribution of parties into <span class="math">S_{0}</span> and <span class="math">S_{1}</span> unless there are parties with a very large stake. The same attack as in the case (i) will work. Here the partitions <span class="math">S_{0}</span> and <span class="math">S_{1}</span> don’t need to be maintained by inbox-reordering, each party will stay in the same partition thanks to following the rule (iii). The attacker <span class="math">\\mathcal{A}</span> again maintains two tines <span class="math">T_{0}</span> and <span class="math">T_{1}</span>, and also keeps track of the prefixes <span class="math">T_{i}^{\\prime}</span> of each <span class="math">T_{i}</span> that were already delivered by <span class="math">\\mathsf{SDiffuse}_{\\Delta}</span> to all parties. The goal of <span class="math">\\mathcal{A}</span> is to make <span class="math">T_{0}</span> and <span class="math">T_{1}</span> grow at roughly the same speed.</p>

    <p class="text-gray-300">The attack starts by letting the honest slot leaders mine two separate length-1 tines from the genesis block (by delaying the first one). Denote these blocks <span class="math">B_{0}^{(1)}</span> and <span class="math">B_{1}^{(1)}</span>, these will be the first blocks of <span class="math">T_{0}</span> and <span class="math">T_{1}</span>, respectively. Now, <span class="math">\\mathcal{A}</span> delivers to all parties the one of these two blocks (say <span class="math">B_{i}^{(1)}</span>) that has lower preference in the fixed ordering given by the rule (iv), and hence the next honest slot leader will extend this tine by mining some block <span class="math">B_{i}^{(2)}</span> on top of <span class="math">B_{i}^{(1)}</span>. <span class="math">\\mathcal{A}</span> witholds <span class="math">B_{i}^{(2)}</span> but now publishes <span class="math">B_{1-i}^{(1)}</span> and due to the rule (iv), the next honest slot leader will mine a block on top of <span class="math">B_{1-i}^{(1)}</span>, call it <span class="math">B_{1-i}^{(2)}</span>. Now <span class="math">\\mathcal{A}</span> is in the same situation as before, hence it again delivers the one of the blocks <span class="math">B_{0}^{(2)}</span> and <span class="math">B_{1}^{(2)}</span> that has lower preference according to the rule (iv). The attack continues analogously.</p>

    <p class="text-gray-300">This attack only requires <span class="math">\\Delta\\geq 2</span>.</p>

    <h2 id="sec-117" class="text-2xl font-bold">Appendix E Probability-Theoretic Tools</h2>

    <p class="text-gray-300">In our arguments, we are using the following standard variant of the Chernoff bound. See, e.g., <em>[x20]</em> for a proof.</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Theorem 12 (Chernoff bound).</h6>

    <p class="text-gray-300">Let <span class="math">X_{1},\\ldots,X_{T}</span> be independent random variables with <span class="math">X_{i}\\in[0,1]</span> and <span class="math">\\mathbb{E}[X_{i}]=p_{i}</span>. Let <span class="math">X=\\sum_{i=1}^{T}X_{i}</span> and <span class="math">\\mu=\\sum_{i=1}^{T}p_{i}=\\mathbb{E}[X]</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">0&lt;\\delta\\leq 1</span>, <span class="math">\\mathsf{P}[X\\leq(1-\\delta)\\mu]\\leq e^{-\\frac{\\delta^{2}\\mu}{2}}</span>.</li>

      <li>For all <span class="math">0&lt;\\delta</span>, <span class="math">\\mathsf{P}[X\\geq(1+\\delta)\\mu]\\leq\\left(\\frac{e^{\\delta}}{(1+\\delta)^{1+\\delta}}\\right)^{\\mu}</span>.</li>

      <li>For all <span class="math">0&lt;\\delta&lt;2e-1</span>, <span class="math">\\mathsf{P}[X\\geq(1+\\delta)\\mu]\\leq e^{-\\frac{\\delta^{2}\\mu}{4}}</span>.</li>

    </ul>

    <p class="text-gray-300">We also employ the following theorem.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Theorem 13 (<em>[x23]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}_{1}</span> and <span class="math">\\mathcal{D}_{2}</span> be two distributions on a finite partially ordered set <span class="math">V</span> with partial order <span class="math">\\preceq</span>. Then <span class="math">\\mathcal{D}_{1}\\preceq\\mathcal{D}_{2}</span> iff there is a pair of (typically dependent) random variables, <span class="math">X_{1}</span> and <span class="math">X_{2}</span>, taking values in <span class="math">V</span> so that each <span class="math">X_{i}</span> is distributed according to <span class="math">\\mathcal{D}_{i}</span>, and <span class="math">\\Pr[X_{1}\\preceq X_{2}]=1</span>.</p>

    <p class="text-gray-300">(Note that the statement of this theorem overloads the notation <span class="math">\\preceq</span>, applying it both to distributions in the sense of Definition 14 and elements of the partial order.) This result is implicit in Strassen’s 1965 article <em>[x27]</em>; a presentation with terminology closer to ours appears in Kamae et al. <em>[x14]</em>.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Theorem 14 (Tail bounds for negative binomial distributions).</h6>

    <p class="text-gray-300">Let <span class="math">N</span> be a random variable with a negative binomial distribution with parameters <span class="math">r&gt;1</span> (a positive integer) and <span class="math">p</span> (a “success” probability), so that</p>

    <p class="text-gray-300"><span class="math">D_{n}\\triangleq\\Pr[N=n]=\\binom{n+r-1}{n}p^{r}(1-p)^{n}\\,.</span></p>

    <p class="text-gray-300">Then, for <span class="math">n\\geq r(p-1)/p</span>,</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{p}D_{n}\\leq\\Pr[N\\geq n]\\leq\\left(1-\\frac{n+r}{n+1}(1-p)\\right)D_{n}</span></p>

    <p class="text-gray-300">This particular bound is developed and discussed in <em>[x13]</em>.</p>

    <h2 id="sec-121" class="text-2xl font-bold">Appendix F From Executions to Forks</h2>

    <p class="text-gray-300">We define the useful notion of an <em>execution tree</em> that captures the structure formed by all chains that are observed by any honest party during an execution.</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Definition 20 (Execution tree).</h6>

    <p class="text-gray-300">Consider an execution <span class="math">\\mathcal{E}</span> of the hybrid experiment. The <em>execution tree</em> for this execution is a directed, rooted tree <span class="math">T_{\\mathcal{E}}=(V,E)</span> with a labeling <span class="math">\\ell:V\\to\\mathbb{N}_{0}</span> that is constructed during the execution as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the beginning, <span class="math">V=\\{r\\}</span>, <span class="math">E=\\emptyset</span> and <span class="math">\\ell(r)=0</span>.</li>

      <li>Every chain <span class="math">C^{\\prime}</span> that is input to <span class="math">\\mathsf{maxvalid}</span> as a part of <span class="math">\\mathbb{C}</span> in Step 2a or created as a new local chain in Step 3b of <span class="math">\\pi_{\\mathrm{SPoS}}</span> run by any honest party is immediately processed block-by-block from the genesis block to <span class="math">\\mathrm{head}(C^{\\prime})</span>. For every block <span class="math">B=(st^{\\prime},d^{\\prime},\\mathsf{sl}^{\\prime},crt^{\\prime},\\sigma_{j^{\\prime}})</span> processed for the first time:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a new vertex <span class="math">v_{B}</span> is added to <span class="math">V</span>;</li>

      <li>a new edge <span class="math">(v_{B^{-}},v_{B})</span> is added to <span class="math">E</span> where <span class="math">B^{-}</span> is the unique block such that <span class="math">H(B^{-})=st^{\\prime}</span>;</li>

      <li>the labeling <span class="math">\\ell</span> is extended by setting <span class="math">\\ell(v_{B})=\\mathsf{sl}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">We now observe that as desired, the execution tree of every execution is among the forks for the characteristic string of that execution. Note that technically, this conclusion is conditioned on no collisions in the random oracle outputs. For the sake of improved readability, we neglect the possibility of such collisions in our further considerations.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">For any execution <span class="math">\\mathcal{E}</span> of the hybrid experiment we have <span class="math">T_{\\mathcal{E}}\\vdash_{\\Delta}w_{\\mathcal{E}}</span>, unless a collision in the responses of the random oracle occurs.</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Proof (sketch).</h6>

    <p class="text-gray-300">Given an execution <span class="math">\\mathcal{E}</span> and the resulting execution tree <span class="math">T_{\\mathcal{E}}</span>, we need to prove that it satisfies the properties (i)–(v) of Definition 7 with respect to <span class="math">w_{\\mathcal{E}}</span>. Property (i) follows directly from the definition of <span class="math">T_{\\mathcal{E}}</span>, while (ii) follows from the order in which vertices in <span class="math">T_{\\mathcal{E}}</span> are created: every edge is directed from an older vertex to a newer one and the root is the first vertex created. Property (iii) is satisfied due to the requirement in Definition 2 that the sequence of slots in a valid blockchain is strictly increasing (otherwise, the chain is rejected by <span class="math">\\pi_{\\mathrm{SPoS}}</span> as invalid). To see property (iv), note that by <span class="math">\\pi_{\\mathrm{SPoS}}</span>, every uniquely honest slot leader will create a block and this is immediately processed, resulting in a vertex with the respective label in <span class="math">T_{\\mathcal{E}}</span>. Finally, property (v) is satisfied as every uniquely honest slot leader will be aware of any other such slot leader’s block created at least <span class="math">\\Delta</span> slots ago due to the guarantees provided by <span class="math">\\mathsf{DDiffuse}</span>, and will hence extend a chain that is at least as long as the one containing this block. Note that several of our arguments above assume no random oracle collisions. ∎</p>

    <p class="text-gray-300">Given Lemma 6, we can later focus on investigating the properties of the distribution <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>. Roughly speaking, if we prove that a characteristic string sampled from <span class="math">\\mathcal{D}_{\\mathcal{Z},\\mathcal{A}}^{f}</span>, with overwhelming probability, does not allow for <em>any</em> “harmful” forks for it, then this also implies that a random execution with overwhelming probability results in a “harmless” execution tree.</p>

    <p class="text-gray-300">G Further Details on Forks, Forkability and Divergence</p>

    <p class="text-gray-300">We introduce the notion of a forkable string that was central to the analysis in <em>[x11]</em>.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Definition 21 (Height and tine intersection).</h6>

    <p class="text-gray-300">The <em>height</em> of a fork (as usual for a tree) is defined to be the length of the longest tine. For two tines <span class="math">t_{1}</span> and <span class="math">t_{2}</span> of a fork <span class="math">F</span>, we write <span class="math">t_{1}\\sim t_{2}</span> if they share an edge. Note that <span class="math">\\sim</span> is an equivalence relation on the set of nontrivial tines; on the other hand, if <span class="math">t_{\\epsilon}</span> denotes the “empty” tine consisting solely of the root vertex then <span class="math">t_{\\epsilon}\\not\\sim t</span> for any tine <span class="math">t</span>.</p>

    <p class="text-gray-300">The common prefix property in the synchronous case is studied by focusing on a local property of “forkability”.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Definition 22 (Flat forks and forkable strings).</h6>

    <p class="text-gray-300">We say that a synchronous fork is <em>flat</em> if it has two tines <span class="math">t_{1}\\not\\sim t_{2}</span> of length equal to the height of the fork. A string <span class="math">w\\in\\{0,1\\}^{<em>}</span> is said to be </em>forkable* if there is a flat synchronous fork <span class="math">F\\vdash_{0}w</span>.</p>

    <p class="text-gray-300">A fundamental tool in the security analysis in the synchronous case is an estimate of the number of forkable strings of a particular length <span class="math">k</span>. The original bound of <span class="math">2^{-\\Omega(\\sqrt{k})}</span> in <em>[x11]</em> was strengthened to <span class="math">2^{-\\Omega(k)}</span> in <em>[x13]</em>.</p>

    <h6 id="sec-127" class="text-base font-medium mt-4">Theorem 15 (<em>[x11, x13]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\epsilon\\in(0,1)</span> and let <span class="math">w</span> be a string drawn from <span class="math">\\{0,1\\}^{k}</span> by independently assigning each <span class="math">w_{i}=1</span> with probability <span class="math">(1-\\epsilon)/2</span>. Then <span class="math">\\Pr[w\\text{ is forkable}]=2^{-\\Omega(k)}</span>. The constant hidden by the <span class="math">\\Omega(\\cdot)</span> notation depends only on <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">As mentioned above, the notion of forkability is directly related to (synchronous) divergence; this is reflected by the theorem below.</p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Theorem 16 (<em>[x11]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">w\\in\\{0,1\\}^{*}</span> with <span class="math">\\operatorname{div}_{0}(w)\\geq k</span>. Then there is a forkable substring <span class="math">\\hat{w}</span> of <span class="math">w</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An immediate conclusion of Theorems 15 and Theorem 16 is the following bound on the probability that a synchronous characteristic string drawn with i.i.d. symbols has large divergence.</p>

    <h6 id="sec-129" class="text-base font-medium mt-4">Theorem 17 (Restatement of Theorem 3).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell,k\\in\\mathbb{N}</span> and <span class="math">\\epsilon\\in(0,1)</span>. Let <span class="math">w=w_{1}\\ldots w_{\\ell}\\in\\{0,1\\}^{\\ell}</span> be drawn by independently assigning each symbol to the value <span class="math">1</span> with probability <span class="math">(1-\\epsilon)/2</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{0}(w)\\geq k]\\leq\\exp(\\ln\\ell-\\Omega(k))\\;.</span></p>

    <p class="text-gray-300">A proof of a weaker bound of the form <span class="math">\\exp(\\ln\\ell-\\Omega(\\sqrt{k}))</span> appears in <em>[x11]</em>. Russell et al. <em>[x13]</em> then strengthened the basic probabilistic tools used in <em>[x11]</em> to achieve a bound of the form <span class="math">\\exp(\\ln\\ell-\\Omega(k))</span> for the local notion of <em>forkability</em>. For completeness, we include a proof of Theorem 3 relying on the results of <em>[x13]</em>.</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Proof (of Theorem 3).</h6>

    <p class="text-gray-300">It follows from Theorem 16 that if <span class="math">\\operatorname{div}_{0}(w)\\geq k</span>, there is a forkable substring <span class="math">\\hat{w}</span> of length at least <span class="math">k</span>. Thus</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{0}(w)\\geq k]</span> <span class="math">\\leq\\Pr\\left[\\exists\\alpha,\\beta\\in\\{1,\\ldots,\\ell\\}\\text{ so that }\\alpha+k-1\\leq\\beta\\text{ and}\\right]</span> (1) <span class="math">\\leq\\sum_{1\\leq\\alpha\\leq\\ell}\\underbrace{\\sum_{\\alpha+k-1\\leq\\beta\\leq\\ell}\\Pr[w_{\\alpha}\\ldots w_{\\beta}\\text{ is forkable}]}_{(*)}\\;.</span></p>

    <p class="text-gray-300">According to Theorem 15 the probability that a string of length <span class="math">t</span> drawn from this distribution is forkable is no more than <span class="math">\\exp(-ct)</span> for a positive constant <span class="math">c</span>. Note that for any <span class="math">\\alpha\\geq 1</span>,</p>

    <p class="text-gray-300"><span class="math">\\sum_{t=\\alpha+k-1}^{\\ell}e^{-ct}\\leq\\int_{k-1}^{\\infty}e^{-ct}\\,dt=(1/c)e^{-c(k-1)}=e^{-\\Omega(k)}</span></p>

    <p class="text-gray-300">and it follows that the sum <span class="math">(*)</span> above is <span class="math">\\exp(-\\Omega(k))</span>. Thus</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{div}_{0}(w)\\geq k]\\leq\\ell\\cdot\\exp(-\\Omega(k))\\leq\\exp(\\ln\\ell-\\Omega(k))\\,,</span></p>

    <p class="text-gray-300">as desired. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">This section sketches how the protocol  <span class="math">\\pi_{\\mathrm{DPoS}}</span>  can be easily modified to significantly weaken the requirement of all honest parties being online all the time. In the modified protocol  <span class="math">\\pi_{\\mathrm{DPoS}}^{\\mathrm{lazy}}</span>  given in Figure 12, every stakeholder comes online only at the beginning of each epoch, determining for which of the slots in that epoch he belongs into the slot leader set. Consequently, the stakeholder can only come online in those slots and create blocks as usually. Additionally, the stakeholder also makes sure that it is not offline for  <span class="math">k</span>  or more slots.</p>

    <p class="text-gray-300">Note that this requires a slightly different mechanism of distributing existing chains, as the lazy stakeholder needs a way to obtain a copy of the current chain the moment he comes online. In theory, this can be achieved by letting all stakeholders diffuse their current chain even if they haven't added a block to it; in practice this would be handled by a request mechanism where a stakeholder can ask for chains from other nodes upon coming online.</p>

    <p class="text-gray-300">The protocol  <span class="math">\\pi_{\\mathrm{DPoS}}^{\\mathrm{lazy}}</span>  is run in the same setting as  <span class="math">\\pi_{\\mathrm{DPoS}}</span> , with the same definition of  <span class="math">T_i^j</span> . It proceeds as follows for each stakeholder  <span class="math">U_i</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. This step is the same as Step 1 in  <span class="math">\\pi_{\\mathrm{DPoS}}</span> . Additionally,  <span class="math">U_i</span>  initializes  <span class="math">\\mathcal{L} = \\emptyset</span> . After initialization, every stakeholder  <span class="math">U_i</span>  acts as described below. If none of the conditions below occurs,  <span class="math">U_i</span>  can go online and offline arbitrarily, with the requirement that it is never offline for  <span class="math">k</span>  or more consecutive slots.</li>

      <li><strong>Epoch Update.</strong> If a new epoch  <span class="math">e_{j^<em>}</span>  has started,  <span class="math">U_i</span>  performs Step 2 of  <span class="math">\\pi_{\\mathrm{DPoS}}</span> . Afterwards, for every slot  <span class="math">\\hat{\\mathsf{s}}</span>  of the upcoming epoch  <span class="math">e_{j^</em>}</span> ,  <span class="math">U_i</span>  sends (Eval, sid,  <span class="math">\\eta_{j^<em>} \\parallel \\hat{\\mathsf{s}} \\parallel \\mathsf{TEST}</span> ) to  <span class="math">\\mathcal{F}_{\\mathsf{VRF}}</span> , receiving (Evaluated, sid,  <span class="math">y</span> ).  <span class="math">U_i</span>  checks whether it is in the slot leader set of slot  <span class="math">\\hat{\\mathsf{s}}</span>  with respect to the upcoming epoch  <span class="math">e_{j^</em>}</span>  by checking that  <span class="math">y &amp;lt; T_i^{j^*}</span> . If yes, it adds  <span class="math">\\hat{\\mathsf{s}}</span>  to a set  <span class="math">\\mathcal{L}</span> .</li>

      <li>Chain Update and Extension. Upon a slot in  <span class="math">\\mathcal{L}</span> ,  <span class="math">U_{i}</span>  comes online, processes all queued incoming chains according to Step 3 of  <span class="math">\\pi_{\\mathrm{DPoS}}</span> , and performs the Step 4 of  <span class="math">\\pi_{\\mathrm{DPoS}}</span> .</li>

      <li>Signing Transactions. Whenever  <span class="math">U_{i}</span>  is online, it performs Step 5 of  <span class="math">\\pi_{\\mathrm{DPoS}}</span> .</li>

    </ol>

    <p class="text-gray-300">Fig. 12: Protocol  <span class="math">\\pi_{\\mathrm{DPoS}}^{\\mathrm{lazy}}</span></p>`;
---

<BaseLayout title="Ouroboros Praos: An adaptively-secure, semi-synchronous proo... (2017/573)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/573
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
