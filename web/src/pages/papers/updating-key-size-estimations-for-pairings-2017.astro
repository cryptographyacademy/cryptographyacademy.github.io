---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/334';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'Updating key size estimations for pairings';
const AUTHORS_HTML = 'Razvan Barbulescu&lt;sup&gt;1&lt;/sup&gt; and Sylvain Duquesne&lt;sup&gt;2&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Razvan Barbulescu&lt;sup&gt;1&lt;/sup&gt; and Sylvain Duquesne&lt;sup&gt;2&lt;/sup&gt;</p>

    <pre><code class="language-text">1 IMJ-PRG, UMR CNRS 7586, Univ Paris 6, Univ Paris 7
</code></pre>

    <p class="text-gray-300"><strong>Abstract.</strong> Recent progress on NFS imposed a new estimation of the security of pairings. In this work we study the best attacks against some of the most popular pairings and propose new key sizes using an analysis which is more precise than the analysis in a recent article of Menezes, Sarkar and Singh. We also select pairing-friendly curves for standard security levels.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Introduction</h4>

    <p class="text-gray-300">Pairing based cryptography has been introduced in the beginning of the century allowing new protocols that could not be realized otherwise such as identity based cryptography [BF01], short signature schemes [BLS04] or broadcast encryption [BGW05]. It has now many more practical applications in various fields. A pairing is a non degenerate bilinear map</p>

    <p class="text-gray-300"><span class="math">$e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_3</span>$
.</p>

    <p class="text-gray-300">It is usually realized thanks to elliptic curves. More precisely, the groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are subgroups or quotient groups of an elliptic curve defined over a finite field  <span class="math">\\mathbb{F}_q</span>  or one of its extensions and  <span class="math">\\mathbb{G}_3</span>  is a subgroup or a quotient group of  <span class="math">\\mathbb{F}_{q^k}^*</span>  where k is called the embedding degree. A suitable pairing for cryptographic applications requires that the discrete logarithm problem is sufficiently difficult on these three groups. The security of pairings defined over  <span class="math">\\mathbb{F}_q</span>  having embedding degree k and group order r is determined by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the cost of the discrete logarithm problem (DLP) on an order r subgroup or quotient group of an elliptic curve defined over  <span class="math">\\mathbb{F}_q</span>  (the curve side);</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the cost of the DLP in a quotient of the multiplicative group of  <span class="math">\\mathbb{F}_{q^k}</span>  (the finite field side).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The security evaluation on the curve side is simple: if s is the desired level of security, we select r such that  <span class="math">\\log_2 r \\ge 2s</span>  because of Pollard's rho algorithm (and by consequence  <span class="math">\\log_2 q \\ge 2s</span> ).</p>

    <p class="text-gray-300">Attacks on the field side however are harder to estimate since the best algorithms belong to the Index Calculus family and their complexity is hard to write down explicitly. The recommended key sizes can be found in the reports of the standardization organizations: ISO [ISO15], IEEE [IEE17]. The NIST hasn't standardized pairing-based cryptography but it published reports [MPP+] which do specify key sizes. The recommendations of ECRYPT [Sma12], which were published by ENISA [NA13], corroborate with those of the ISO, the IEEE and the NIST.</p>

    <p class="text-gray-300">Since 2013 there have been a series of attacks on the field side of pairings of small characteristic which completely invalidated the use of these pairings. The classical algorithms, Coppersmith [Cop84] and the function field sieve [Adl94], [AH99], [JL02], [JL06], were replaced by algorithms of smaller complexity [Jou13a], [Jou13b], [GGMZ13b], followed by a heuristic quasi-polynomial algorithm [BGJT14]. ENISA reacted immediately and in its standard document from October 2013 [NA13, page 32] the agency forbid the use of small characteristic pairings. Improvements and records continued [GGMZ13a], [AMORH15], [JP14] and a second quasi-polynomial algorithm was proposed [GKZ14b,GKZ17]. Two record computations broke 128-bit pairings in characteristic 2 [GKZ14a] and respectively 3 [ACMC+16].</p>

    <p class="text-gray-300">In the case of non-small characteristic the best-known algorithm is the number field sieve [Gor93], [Sch93], [Sch00], [Sem02], [JL03], [CS06], [JLSV06]. Since 2013 there have been a series of new variants and improvements [JP13], [BP14], [BGGM14], [BGGM15a], [Pie15], [SS16c,SS16d,SS16b], [BGK15] and record computations [BGGM14], [BGGM15b], [GMT16], [FGHT17] and [KDL+16]. The extended tower number field [KB16,JK16] changed considerably the complexity of the attacks and a precise analysis in the same article of a popular pairing, Baretto-Naehrig of 128 bits of security, showed that the key sizes must be reevaluated.</p>

    <p class="text-gray-300">The implementation of SexTNFS requires to code from scratch a subprogram which can be called &quot;sieving in higher dimension&quot;. The first implementations of this subprogram [Zaj10], [HAKT15] and [GGV16], were all accompanied by algorithmic improvements, and the latest was used in a record computation [GGMT17]. The CADO-NFS software package [BGI+14] has a branch called nfs-hd which corresponds to sieving in higher dimension, but it could take years before its development is finished (CADO-NFS has more than 200000 lines of code and its development has already lasted 10 years, with continuous improvements in all the stages of NFS).</p>

    <p class="text-gray-300">The goal of this paper is to give a precise evaluation of the complexity of these algorithms in the absence of computational records. In the case of pairings, where the characteristic of the base field is parametrized by a polynomial, we obtain parameters sizes for the 128, 192 and 256-bits security levels and propose pairing-friendly curves which have this security. We compare our analysis to that of a contemporaneous article of Menezes, Sarkar and Singh [MSS16]. The cost of an attack with SexTNFS depends on the size of the norms of the algebraic numbers in the sieving domain. The two analysis differ in the way in which the size of the norms is estimated: in their approach the mathematical upper bound is used whereas we rely on the experimental values.</p>

    <p class="text-gray-300"><strong>Roadmap.</strong> After explaining the necessity of a new and more precise evaluation of key sizes in Section 1 we recall the most popular families of pairings in Section 2 and identify the best variant of NFS that an attacker can use against these families in Section 3. Then we estimate the best parameters by seeing it as an optimization problem (Section 4). At the end of the same section we explain the difference between the analysis of [MSS16] and that of this work. The proposal of new curves is done in three steps: first we solve the optimization problem on the precise case of the most popular pairings families and find what are the field sizes which correspond to 128, 192 and 256 bits of security (Section 5), then we search for curves of this size (Section 6) and finally we do an analysis even more precise than before for each of the curves we propose (Section 7). We conclude the article by estimating the complexity of an optimal ate pairing for the new curves proposed for 128 bits of security (Section 8).</p>

    <p class="text-gray-300">Whether the goal is to factor a composite integer N or to compute discrete logarithms in a field of  <span class="math">p^n</span>  elements, NFS works in a similar manner. We select a number ring  <span class="math">\\mathbb{Z}_i</span> , which is simply  <span class="math">\\mathbb{Z}</span>  when factoring and is such that p is inert for discrete logarithms. Then we select two polynomials  <span class="math">f,g\\in\\mathbb{Z}_i[x]</span>  having a common factor  <span class="math">\\varphi</span>  modulo q, where q=N for factoring and q=p for discrete logarithms. This allows to draw a commutative diagram which is the core of NFS:</p>

    <p class="text-gray-300">    <img src="_page_1_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">where  <span class="math">\\alpha_f</span>  and  <span class="math">\\alpha_g</span>  are roots of f and g in their number fields and where  <span class="math">\\mathcal{O}_f</span>  and  <span class="math">\\mathcal{O}_g</span>  are the rings of integers of these same number fields.</p>

    <p class="text-gray-300">The algorithm starts with a stage in which small polynomials  <span class="math">\\phi(x)</span>  are enumerated and put in the top of the diagram. What a small polynomial is changes from variant to variant but the degree and the coefficients are small, the simplest example being  <span class="math">\\phi(x) = a - bx</span>  with integers a, b smaller in absolute value than some parameter. If  <span class="math">\\phi(\\alpha_f)</span>  and  <span class="math">\\phi(\\alpha_g)</span>  are B-smooth for a parameter B (factor into ideals of norm less than B) then we obtain a multiplicative relation in  <span class="math">\\mathbb{Z}_i[x]/\\langle q,\\varphi\\rangle</span> . At this step the two variants of NFS split: either one transforms multiplicative relations into linear equations and computes a right kernel to obtain a large number of discrete logarithms or one writes a matrix of valuations and computes a left kernel to obtain a non-trivial solution to the equation  <span class="math">x^2 \\equiv 1 \\mod N</span> . In both cases one finishes with a step of negligible cost.</p>

    <p class="text-gray-300">The classical variant of NFS has complexity  <span class="math">L_Q[64]^{1+o(1)}</span>  where Q=N or  <span class="math">p^n</span>  and</p>

    <p class="text-gray-300"><span class="math">$L_Q[c] = \\exp\\left((c/9)^{\\frac{1}{3}}(\\log Q)^{\\frac{1}{3}}(\\log\\log Q)^{\\frac{2}{3}}\\right).</span>$</p>

    <p class="text-gray-300">Each of the variants of NFS requires its own complexity analysis but it is always of the form  <span class="math">L_Q[c]^{1+o(1)}</span>  for some constant. Joux and Pierrot [JP13] invented a method of polynomial selection which obtains c=32 for some finite fields where the characteristic p has a special form. Barbulescu, Gaudry, Guillevic and Morain [BGGM15a] proposed new methods of polynomial selection which achieve c=48 in some cases that are intractable with the previous method. Later Barbulescu, Gaudry and Kleinjung [BGK15] proposed to replace  <span class="math">\\mathbb{Z}</span>  by a larger number ring  <span class="math">\\mathbb{Z}_i</span>  and also obtained c=32 for some finite fields, in particular proving that a popular pairings curve estimated to 128 bits can be the target of this variant. Finally, Kim and Barbulescu [KB16] showed how to use the new methods of polynomial selection together with the new choices of  <span class="math">\\mathbb{Z}_i</span>  and obtained c=32 for a very large range of finite fields. It is reassuring to note that one can give arguments that one cannot go below the c=32 constant (cf. Appendix B).</p>

    <p class="text-gray-300">o(1)-less estimation. What is the impact of these new constants in the complexity on the real-life security? To get a first idea one can start by dropping the o(1) term, so that the cost of each variant of NFS is  <span class="math">2^{\\kappa}L_Q[c]</span>  where  <span class="math">\\kappa</span>  and c are two constants. We use the same convention as in [Len01a, Section 2.4.6] and count a clock cycle as one operation. Thanks to real-life record computations we have a relatively good estimation of  <span class="math">\\kappa</span>  as summarized in Table 1 and we conclude on the security estimations in Figure 1. For those fields where the fastest variant applies it seems that we have to use 5004 bit fields for 128 bits of security and 12871 for 192 bits of security.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">variant</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">classical NFS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">classical MNFS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">composite <span class="math">n</span> NFS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">composite <span class="math">n</span> MNFS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">SNFS</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">c</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.00</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-8[KDL^{+}16]</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-8 [KDL^{+}16]</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-7[BGGM15a]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-7 [BGGM15a]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-7[AFK^{+}07]</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 1.</strong> Value of  <span class="math">\\kappa</span>  to match the formula cost(NFS)= <span class="math">2^{\\kappa}L_{Q}[c]</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;    <img src="_page_2_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Modification of key sizes according to the o(1)-less formula.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;Note that the previous analysis is very similar to that of [MSS16, Section 6.2], but they didn't consider the curve corresponding to SexTNFS as they argue in Remark 4..</p>

    <p class="text-gray-300">The goal of this article is to go beyond the o(1)-less estimation and to study in each case what is the best variant of NFS which applies, concluding on new key sizes. This type of estimations seem to be rare but we can note the works of Lenstra [Len01b] and of Bos et al. [BKK&lt;sup&gt;+&lt;/sup&gt;] who evaluate the security of RSA, DSA and DH.</p>

    <p class="text-gray-300">Depending on the required embedding degree, some families of curves have been built [FST10]. We recall here the most popular ones.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;2.1 BN curves</h4>

    <p class="text-gray-300">A BN curve [BN05] is an elliptic curve E defined over a finite field  <span class="math">\\mathbb{F}_p</span> ,  <span class="math">p \\geq 5</span> , such that its order r and p are prime numbers parametrized by</p>

    <p class="text-gray-300"><span class="math">$p = 36u^4 + 36u^3 + 24u^2 + 6u + 1,</span>$</p>

    <p class="text-gray-300"><span class="math">$r = 36u^4 + 36u^3 + 18u^2 + 6u + 1,</span>$</p>

    <p class="text-gray-300">for some well chosen u in  <span class="math">\\mathbb{Z}</span> . It has an equation of the form  <span class="math">y^2=x^3+b</span> , where  <span class="math">b\\in\\mathbb{F}_p^*</span> . BN curves have an embedding degree equal to 12. They were widely used for the 128-bit security level until the recent results on the discrete logarithm problem in  <span class="math">\\mathbb{F}_{p^{12}}^*</span> . Indeed, a 256-bits prime p leads to a 256-bits curve and to pairings taking values in  <span class="math">\\mathbb{F}_{p^{12}}^*</span> , which is a 3072-bits multiplicative group. Both groups involved are then supposed to match the 128-bit security level according to the NIST recommendations [oSN12] (which are however now invalidate by [KB16]). Incidentally, BN curves have been the object of numerous recent publications ([DSD07,AKL+11,CSF+11,GSNB11,NNS10,GAL+13,UW14]).</p>

    <p class="text-gray-300">Finally, BN curves always have order 6 twists. If  <span class="math">\\xi</span>  is an element which is neither a square nor a cube in  <span class="math">\\mathbb{F}_{p^2}</span> , the twisted curve E' of E is defined over  <span class="math">\\mathbb{F}_{p^2}</span>  by the equation  <span class="math">y^2 = x^3 + b&#x27;</span>  with  <span class="math">b&#x27; = b/\\xi</span>  or  <span class="math">b&#x27; = b\\xi</span> . In order to simplify the computations, the element  <span class="math">\\xi</span>  should also be used to represent  <span class="math">\\mathbb{F}_{p^{12}}</span>  as a degree 6 extension of  <span class="math">\\mathbb{F}_{p^2}</span>  ( <span class="math">\\mathbb{F}_{p^{12}} = \\mathbb{F}_{p^2}[\\gamma]</span>  with  <span class="math">\\gamma^6 = \\xi</span> ) [DSD07], [LN97].</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.2 BLS curves</h4>

    <p class="text-gray-300">BLS curves were introduced in [BLS03]. They are also defined over a parametrized prime field  <span class="math">\\mathbb{F}_p</span>  by an equation of the form  <span class="math">y^2 = x^3 + b</span>  and have a twist of order 6 defined in the same way as BN curves. Contrary to BN curves, they do not have prime order but their order is divisible by a large parametrized prime r and the pairing will be defined on the r-torsions points. They are available for different embedding degrees but we are only interested here by the BLS12 and BLS24 families having embedding degrees 12 and 24 with respect to r. Until now, they were used for the 192-bis security level [AFCK+13]. The parametrizations are given by</p>

    <p class="text-gray-300">BLS12 BLS24
<span class="math">$p = (u-1)^2(u^4 - u^2 + 1)/3 + u \\qquad p = (u-1)^2(u^8 - u^4 + 1)/3 + u</span>$</p>

    <p class="text-gray-300"><span class="math">$r = u^4 - u^2 + 1 \\qquad r = u^8 - u^4 + 1.</span>$</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.3 KSS curves</h4>

    <p class="text-gray-300">KSS curves are also available for different embedding degrees [KSS08]. If the required embedding degree is 18, this is very similar to BLS curves (same defining equation, degree 6 twist, parametrized primes p and  <span class="math">r|\\#E(\\mathbb{F}_p)</span> ). In this case, the parametrization is given by</p>

    <p class="text-gray-300"><span class="math">$p = (u^8 + 5u^7 + 7u^6 + 37u^5 + 188u^4 + 259u^3 + 343u^2 + 1763u + 2401)/21</span>$</p>

    <p class="text-gray-300"><span class="math">$r = (u^6 + 37u^3 + 343)/343.</span>$</p>

    <p class="text-gray-300">If the required embedding degree is 16, the KSS16 curves are defined over a parametrized prime field  <span class="math">\\mathbb{F}_p</span>  by an equation of the form  <span class="math">y^2 = x^3 + ax</span>  and have a twist of order only 4. Again they do not have a prime order but it is divisible by a parametrized prime r and the pairing will be defined on the r-torsions points. In this case, the parametrization is</p>

    <p class="text-gray-300"><span class="math">$p = (u^{10} + 2u^9 + 5u^8 + 48u^6 + 152u^5 + 240u^4 + 625u^2 + 2398u + 3125)/980</span>$</p>

    <p class="text-gray-300"><span class="math">$r = (u^8 + 48u^4 + 625)/61250.</span>$</p>

    <p class="text-gray-300">Whatever the family, a curve is always obtained by finding a parameter u such that both p and r are prime numbers. The curve and its twist are generated by finding suitable coefficients which can usually be chosen small. More details on the generation process are given in Section 6.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2.4 Optimal ate pairing</h2>

    <p class="text-gray-300">There are several available pairings (Weil, Tate, ate, R-ate, ...) but the most efficient pairing is always the so-called optimal ate pairing [Ver09]. Let us recall this pairing in the context of ordinary elliptic curves defined over prime fields and more precisely in the case of the considered families.</p>

    <p class="text-gray-300">Let E be an elliptic curve defined over the prime field  <span class="math">\\mathbb{F}_p</span> . Let r be a prime divisor of  <span class="math">\\#E(\\mathbb{F}_p)</span>  and k the embedding degree relatively to r. We also assume that  <span class="math">r^2 \\nmid p^k - 1</span>  to ensure the non-degeneracy of the pairing. Let  <span class="math">\\tilde{E}</span>  be a degree d twist of E defined over  <span class="math">\\mathbb{F}_{p^e}</span>  where e = k/d [HSV06]. The optimal ate pairing is defined over  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span>  and takes its values in  <span class="math">\\mathbb{G}_3</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{G}_1</span>  is the set of rational points on E of order r.</li>
      <li><span class="math">\\mathbb{G}_2</span>  is the image of  <span class="math">\\tilde{E}(\\mathbb{F}_{p^e})[r]</span>  in  <span class="math">E(\\mathbb{F}_{p^k})</span>  by the twisting isomorphism.</li>
      <li><span class="math">\\mathbb{G}_3</span>  is the order r subgroup of  <span class="math">\\mathbb{F}_{n^k}^*</span></li>
    </ul>

    <p class="text-gray-300">For the considered parametrized curves, the optimal ate pairing of P and Q is mainly made of 2 parts. The first one (usually called the Miller loop) is the computation of  <span class="math">f_{u,Q}(P)</span> , where u is (usually) the family parameter and the second one is an exponentiation to the power  <span class="math">\\frac{p^k-1}{r}</span> . Assuming  <span class="math">\\ell_{A,B}</span>  denotes the line through points A and B, the precise pairings are given in Table 2 [HSV06, Ver09].</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Miller loop of <span class="math">P</span> and <span class="math">Q</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">final exponent</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{6u+2,Q}(P) \\cdot \\ell_{[6u+2]Q,[p]Q}(P) \\cdot \\ell_{[6u+2+p]Q,[p^2]Q}(P)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(p^{12}-1)/r</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{u,Q}(P)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(p^{12}-1)/r</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\left(f_{u,Q}(P) \\cdot \\ell_{[u]Q,[p]Q}(P)\\right)^{p^3} \\cdot \\ell_{Q,Q}(P)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(p^{16}-1)/r</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{u,Q}(P) \\cdot f_{3,Q}(P)^p \\cdot \\ell_{[u]Q,[3p]Q}(P)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(p^{18}-1)/r</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2. Optimal ate pairings</p>

    <h2 id="sec-6" class="text-2xl font-bold">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;3 The spectrum of possibilities for an attack on the field side</h2>

    <p class="text-gray-300">An attacker who uses an algorithm of Index calculus type can make a series of choices: decide which algorithm and variant to use, make practical improvements, select polynomials, and optimize the main parameters. In this section we explain what are the reasonable choices for an attacker and give arguments to eliminate other choices.</p>

    <h2 id="sec-7" class="text-2xl font-bold">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;3.1 Choice of algorithm</h2>

    <p class="text-gray-300">Let us make a list of the algorithms which can be implemented on a classical computer.</p>

    <p class="text-gray-300">We discard the FFS algorithm [Adl94,AH99,JL02,JL06] and its pinpointing variant [Jou13a] by estimating the size of the factor base. Indeed, when the target is  <span class="math">\\mathbb{F}_{p^k}</span> , the factor base of FFS is formed of all the monic polynomials  <span class="math">\\mathbb{F}_p[x]</span>  of degree less than a parameter b. This has been confirmed by implementations of FFS [JL06,HSW+10,HSST12] and pinpointing [Jou13a,SS16a]. Hence the factor base has at least p elements and then the linear algebra step has a cost of at least  <span class="math">p^2</span>  operations, which is more than the security on the curve side evaluated to  <span class="math">p^{\\frac{1}{2}}</span>  operations.</p>

    <p class="text-gray-300">We also discard the MNFS variants, i.e. the variants of NFS in which more than two sides are used. Indeed, the asymptotic complexity is close to that of NFS ([KB16, Table 2] so the &quot;o(1)-less&quot; extrapolation leads us to results which are similar to those of the classical case (see Figure 1). Detrey [Det14] and Lenstra and al. [KBL14] made proof-of-concept implementations of FFS and NFS for factoring, which are similar to NFS for discrete logarithms. Their results seem to show that the crossing point between classical and MNFS variants of NFS is around 1000 bits, but the gain is small, say less than 2 bits of security, so that we can ignore it in this article.</p>

    <p class="text-gray-300">The three variants of NFS, classical [Gor93,Sch93,JL03], TNFS [Sch00,BGK15] and JLSV [JLSV06], can be seen as particular cases of exTNFS [KB16], which remains the only algorithm to consider.</p>

    <p class="text-gray-300">When p can be written as P(u)/v, for some polynomial  <span class="math">P \\in \\mathbb{Z}[x]</span>  and some integers u and v (as it is the case for pairing applications), the polynomial selection is done differently and one of f and g has small coefficients. To emphasize this difference we give a different name to the algorithm by adding the letter S: the &quot;special&quot; variant of NFS is called SNFS, the special variant of exTNFS is called SexTNFS, the corresponding variant of TNFS is STNFS and the special variant of JLSV will be called S-JLSV or simply Joux-Pierrot. This case encompasses but is not restricted to low-weight primes p, e. g. in an article [Sch10] discussing the complexity of NFS on numbers which are midway between having a general form (NFS) and a polynomial form.(SNFS), these numbers are described as &quot;low weigh numbers&quot;.</p>

    <p class="text-gray-300">In order to fix the notations we recall the <strong>SexTNFS algorithm</strong> [KB16]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Polynomial selection. Given a parameter  <span class="math">\\eta</span> , chosen among the divisors of n, one selects a polynomial  <span class="math">h \\in \\mathbb{Z}[x]</span>  of degree  <span class="math">\\eta</span>  which is irreducible modulo p. Then one selects two polynomials f and g in  <span class="math">\\mathbb{Z}[t,x]</span>  so that f mod  <span class="math">\\langle h(t),p\\rangle</span>  and g mod  <span class="math">\\langle h(t),p\\rangle</span> , seen as elements of  <span class="math">\\mathbb{F}_{p^{\\eta}}[x]</span> , have a common factor  <span class="math">\\varphi(x)</span>  which is irreducible of degree  <span class="math">\\kappa:=k/\\eta</span> . In the particular case  <span class="math">\\gcd(\\eta,\\kappa)=1</span>  we can take  <span class="math">f,g\\in\\mathbb{Z}[x]</span>  which share an irreducible factor of degree  <span class="math">\\kappa</span> , whereas in the case  <span class="math">\\gcd(\\eta,\\kappa)\\neq 1</span>  we have to guarantee that f and g are not defined over a proper subfield of the number field of h.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sieve. Given two parameters A and B, one collects all (up to sign) the degree 1 polynomials in  <span class="math">\\mathbb{F}_{p^k}[x]</span>  or equivalently tuples in the set  <span class="math">\\{(a_0,\\ldots,a_{\\eta-1},b_0,\\ldots,b_{\\eta-1}\\in[-A,A]^{2\\eta}\\mid a_0\\geq 0\\}</span> , called sieving domain, so that  <span class="math">N_f</span>  and  <span class="math">N_g</span>  are B-smooth (all prime factors are less than B), where</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$N_f = \\text{Res}_t \\left( \\text{Res}_x \\left( \\sum_{i=0}^{\\eta - 1} a_i t^i - x \\sum_{i=0}^{\\eta - 1} b_i t^i, f(t, x) \\right), h(t) \\right)</span>$</p>

    <p class="text-gray-300">is the norm on the f side, and similarly for g instead of f. In order to emphasize the analogy with the simpler variants of NFS, we put  <span class="math">E = A^{\\eta}</span>  which is a good approximation of the square root of the cardinality of the sieving domain.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Filtering. Unknowns which occur in a single relation are called singletons and are deleted together with the corresponding equation. Additionally, using elementary transformations of the matrix one can create new singletons. This leads to a smaller matrix and hence a faster resolution of the linear system.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;u&gt;Linear algebra step.&lt;/u&gt; One computes the right kernel of the sparse matrix obtained after the filtering using the Wiedemann algorithm [Wie86] or the Lanczos algorithm [Lan52,LO90] or their block variants [Cop94] and [Cop93,Mon95]. The coordinates of the kernel vector are called virtual logarithms.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Individual logarithms. Given a generator g of  <span class="math">\\mathbb{F}_{p^n}</span>  and an element h, compute the discrete logarithm  <span class="math">\\log_g h</span>  using the virtual logarithms.</li>
    </ol></li>
    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;3.2 Practical improvements</h2>

    <p class="text-gray-300">Although the complexity of NFS for DLP in F&lt;sup&gt;p&lt;/sup&gt; hasn't changed for almost 30 years, its real-life speed has been improving continuously. In the jargon of the NFS community an improvement which changes only the o(1) term in the complexity is called a practical improvement.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-2&quot;&gt;&lt;/span&gt;3.2.1 Filtering. If an ideal occurs in a single relation then we can erase this ideal and its relation from the matrix. Thanks to the exceeding number of relations compared to the cardinality of the factor base, one can erase rows and do linear operations on the rows in order to create new singletons <a href="#page-24-19">[CH02,</a> Ch 3]. Table <a href="#page-6-0">3</a> summarizes how does the filtering behave in practice. It is hard to compare the different rows of the table because the authors of different records made different choices, some of which collected much more relations than needed (oversieved) and hence helped the filtering step reduce considerably the matrix.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">record</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">rows before filtering rows after filtering reduction factor log2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">B</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-1039 (factor)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.8G</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">82.8M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">167</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-768 (factor)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47.7G</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192.8M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">247</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FFS-809</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67.4M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.6M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-1024 (DLP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">249M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-768 (DLP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.0G</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.5M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">382</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3. Behavior of filtering in practice</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;We made an asymptotic estimation of the number of ideals which might be used to reduce the matrix and we obtained the following statement.</p>

    <p class="text-gray-300"><em>Conjecture 1.</em> In the filtering step of NFS one reduces the matrix by a factor (log B) 1+o(1), where B is the smoothness bound.</p>

    <p class="text-gray-300"><em>Justification:</em> Let q be an ideal in the factor base of NFS lying above a prime q and let N denote the size of the norms product and B the smoothness bound. We shall argue that the following statements are true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If q &lt; B/(log B) 1+ with &gt; 0 then q occurs in a number of relations which tends to infinity as B and N go to infinity.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If q &gt; B/(log B) &lt;sup&gt;1&lt;/sup&gt;− with &gt; 0 then q will occur in a number of relations which tends to 0 as B and N go to infinity.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The sieving domain has B&lt;sup&gt;2&lt;/sup&gt; elements (parameter tuning in NFS implies E = B where E is the square root of the number of sieved pairs <a href="#page-24-20">[BLJP93]</a>) and a proportion of 1/q are divisible by q. They produce relations if the cofactor of size N/q is B-smooth, for which we have no proven formula, but which is approximated by the proportion of integers in the interval [1, N/q] which are B-smooth. Due to the theorem of Canfield, Erdos and Pomerance [ ¨ <a href="#page-24-21">CEP83]</a> this proportion is ρ log(N/q) log B where ρ is Dickman's function, i.e. the function such that ρ(v) = 1 for v ≤ 1 and ρ 0 (v) = −ρ(v − 1)/v for v &gt; 1.</p>

    <p class="text-gray-300">number of relations where q occurs
<span class="math">$\\approx B^2/q \\cdot \\rho\\left(\\frac{\\log(N/q)}{\\log B}\\right)</span>$
.</p>

    <p class="text-gray-300">Recall that in NFS we set B so that ρ log N log B &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; = B (once again see <a href="#page-24-20">[BLJP93]</a>). We put v = log N log B , so that we have log B = v log v, log N = v 2 log v and q &gt; B/v1+2 (resp. q &lt; B/v&lt;sup&gt;1&lt;/sup&gt;−2 ). We replace all variables on the right hand side by their expressions in terms of v and obtain that its logarithm is equivalent to v 1+ − v. It tends to ∞ if &gt; 0 so the ideals of norm  <span class="math">q &lt; B/(\\log B)</span>  occur in a very large number of relations and are unlikely to create singletons, so they are not erased during filtering. The right hand side tends to  <span class="math">-\\infty</span>  if  <span class="math">\\epsilon &lt; 0</span>  so the ideals of norm  <span class="math">q &gt; B/\\log(B)</span>  occur in almost no relations, and are very likely to be used during filtering.</p>

    <p class="text-gray-300">Hence the filtering erases most of the ideals of norm larger than  <span class="math">B/(\\log B)^{1+o(1)}</span>  and keeps all but a negligible fraction of the others, so that the matrix size is reduced by a factor  <span class="math">(\\log B)^{1+o(1)}</span> .</p>

    <p class="text-gray-300">It seems then plausible that the filtering gain is a constant times log(B), and by comparing it with Table 3 we model the gain by  <span class="math">log_2 B</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;<strong>3.2.2 Exploiting automorphisms.</strong> Record computations with FFS [HSW&lt;sup&gt;+&lt;/sup&gt;10,HSST12] and NFS [BGGM15a] showed that if the target field is of the form  <span class="math">p^{\\kappa\\eta}</span>  for two integers  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  so that  <span class="math">\\kappa</span>  is small, then one can gain a factor  <span class="math">\\kappa</span>  in the sieve and a factor  <span class="math">\\kappa^2</span>  in the linear algebra.</p>

    <p class="text-gray-300">Kim and Barbulescu [KB16] explained that one has a similar gain in SexTNFS, where  <span class="math">\\kappa</span>  is to be replaced by  <span class="math">\\mathcal{A}</span> , the number of automorphisms of h which fix g times the number of automorphisms of g. If  <span class="math">\\kappa=1</span>  and h has  <span class="math">\\eta</span>  automorphisms then the exact number of automorphisms is  <span class="math">\\mathcal{A}=\\eta</span> , e.g.  <span class="math">\\mathcal{A}=\\ell-1</span>  if  <span class="math">h=\\Phi_\\ell</span> , the  <span class="math">\\ell</span> -th cyclotomic polynomial, for some prime  <span class="math">\\ell</span> . If  <span class="math">\\kappa=2</span>  one doubles the number of automorphisms thanks to the automorphisms of g. For example if  <span class="math">h=\\Phi_7</span>  and  <span class="math">g=x^2+\\alpha x+\\beta+t^4+t^2+t-u</span>  for some integers  <span class="math">\\alpha</span> ,  <span class="math">\\beta</span>  then  <span class="math">\\mathcal{A}=6</span>  because any automorphism in the set  <span class="math">\\{\\tau^i\\sigma^j, 0\\leq i\\leq 1, 0\\leq j\\leq 2\\}</span>  can be used (here  <span class="math">\\sigma:t\\mapsto t^2</span>  and  <span class="math">\\tau:x\\mapsto -\\alpha-x</span> ). Finally, if  <span class="math">\\kappa=3</span>  and  <span class="math">\\eta=4</span>  an attacker might use  <span class="math">h=\\phi_8</span>  and find polynomials g which have three automorphisms, so for a worst case analysis we count  <span class="math">\\mathcal{A}=12</span> .</p>

    <h2 id="sec-9" class="text-2xl font-bold">&lt;span id=&quot;page-7-2&quot;&gt;&lt;/span&gt;3.3 Selection of polynomials</h2>

    <p class="text-gray-300">The polynomial selection consists of selecting h, f and g.</p>

    <p class="text-gray-300"><strong>3.3.1</strong> Choice of h. The polynomial  <span class="math">h \\in \\mathbb{Z}[x]</span>  has two constraints, its degree is  <span class="math">\\eta</span>  and it is irreducible modulo p. Among the possible choices we select those having small norms for  <span class="math">N_f</span>  and  <span class="math">N_g</span> , which generally corresponds to the case when h has small coefficients. In all examples we could select h with coefficients in  <span class="math">\\{0, -1, 1\\}</span>  and experiments confirmed that the best choice is never much better than  <span class="math">h = t^{\\eta} - t - 1</span> .</p>

    <p class="text-gray-300">In Section 3.2.2 we saw that in order to use the Galois automorphisms the attacker has to find a polynomial h with non-trivial automorphisms. We ran an exhaustive search on the polynomials in  <span class="math">\\mathbb{Z}[x]</span>  of degree less than 19 having coefficients less than 6 in absolute value. In this set, the only polynomials that have automorphisms of order different from 2 are those listed in Table 4.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">degree</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">6</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">12</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">18</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">polynomials</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Phi_7, \\Phi_9, \\Phi_{14}, \\Phi_{18}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Phi_{13}, \\Phi_{26}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Phi_{17}, \\Phi_{34}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Phi_{19}, \\Phi_{38}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;<strong>Table 4.</strong> List of all monic polynomials  <span class="math">h \\in \\mathbb{Z}[x]</span>  of degree between 6 and 20 such that  <span class="math">||h|| \\le 10</span>  and Aut(h) has elements of order larger than 2.</p>

    <p class="text-gray-300"><strong>3.3.2</strong> Construction of f and g. One produces a large number of pairs of polynomials using one of the following methods: base-m [BLJP93], base-m-SNFS [LLJMP90], Joux-Pierrot [JP13], Conjugation [BGGM15a], JLSV1 [JLSV06, Section 2.3], GJL [BGGM15a,Mat06], algorithms A,B,C or D of Sarkar and Singh [SS16c,SS16d,SS16b].</p>

    <p class="text-gray-300">In this article we focus on families of pairings where p is parametrized, then one choice of polynomials is by far the most natural. Let  <span class="math">P(x) \\in \\mathbb{Z}[x]</span>  and the integers u,v be such that p = P(u)/v. Then one can take  <span class="math">f = P(x^{\\kappa} + S(t,x))</span>  and  <span class="math">g = x^{\\kappa} + S(t,x) - u</span>  for some  <span class="math">S \\in \\mathbb{Z}[t,x]</span>  of degree in x less than  <span class="math">\\kappa</span>  so that g is irreducible in  <span class="math">(\\mathbb{F}_p[t]/h)[x]</span> . In most</p>

    <p class="text-gray-300">cases this is the only choice but for instance in the case of KSS 18 one can also take f = P(x - 2) and g = x - 2 - u, with a non negligible effect on the complexity estimation.</p>

    <p class="text-gray-300">How can we be sure that the attacker cannot find choices of f that we could not predict? See [FGHT17] for a discussion about the consequences of this question on discrete logarithms in  <span class="math">\\mathbb{F}_p</span> . The attacker cannot use the fastest versions of NFS (SNFS, STNFS, SexTNFS, Joux-Pierrot) unless he finds three polynomials,  <span class="math">T(x,y) \\in \\mathbb{Z}[x,y]</span>  and  <span class="math">U, V \\in \\mathbb{Z}(x)</span>  whose coefficients are bounded by an absolute constant, so that p = T(U(u), V(u)) for some integer u, in which case he sets</p>

    <p class="text-gray-300"><span class="math">$f = T(x)</span>$
and  <span class="math">g = V(u)x - U(u)</span> .</p>

    <p class="text-gray-300">In the case of SexTNFS, the coefficients of f occur at large powers in the norms and hence we can restrict the search to very small constants. We ran the exhaustive search and obtained that the only alternative choices are f = P(x-1) for KSS 16, f = P(x-2) for KSS 18 and  <span class="math">f = 4x^4 - 4x^3 + 12x^2 - 10x + 7</span>  and g = x - (3u+1) for BN. In the rest of the security evaluation we considered the alternative choices together with the natural ones.</p>

    <p class="text-gray-300"><strong>3.3.3 Optimization.</strong> Murphy [Mur98] introduced a map  <span class="math">\\alpha:\\mathbb{Q}[x]\\to\\mathbb{R}</span>  which allows to decide which are the best polynomials for NFS. Barbulescu and Lachand [BL17] proved, when f is quadratic of fundamental negative discriminant, that for a random pair of relatively prime integers the norm  <span class="math">N=\\mathrm{Res}_x(a-bx,f)</span>  has the same probability to be B-smooth (for a parameter B) as a random integer less than  <span class="math">e^{\\alpha(f)}N</span> . Because of the uncertainty on  <span class="math">\\alpha</span>  we cannot predict the exact cost of a DLP computation with NFS. In the previous paragraph we saw that in the case of parametrized pairings we only have one or two choices of f and g. For each choice we verify directly that  <span class="math">\\alpha(f)\\approx 0</span>  whereas for linear polynomials the value of  <span class="math">\\alpha</span>  is constant equal to 0.56..., which is also the average value of  <span class="math">\\alpha</span>  on all polynomials [BL17].</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}_{p^n}</span>  where the characteristic is parametrized by a polynomial P(u)/v of degree d, we decided to use SexTNFS with  <span class="math">f=P(x^\\kappa+S(t,x))</span>  and  <span class="math">g=x^\\kappa+S(t,x)-u</span>  for some polynomial S of degree in x less than n. We also decided to use, if possible, h from Table 4 and otherwise  <span class="math">h=t^{n/\\kappa}-t-1</span>  because it is the simplest one and then the one providing the smallest norms. This choice is the best possible for the attacker. At this point we need to decide which value of  <span class="math">\\kappa</span>  to use and to optimize parameters A and B.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.1 Choice of <span class="math">\\kappa</span> .</h4>

    <p class="text-gray-300">According to [KB16, Section 4.1] the parameter  <span class="math">\\kappa</span>  is chosen to minimize the norms product  <span class="math">N_f N_g \\approx E^{(d+1)\\kappa} Q^{\\frac{1}{d\\kappa}}</span> , where E is the square root of the cardinality of the sieve space and Q is  <span class="math">p^n</span> . This corresponds to</p>

    <p class="text-gray-300"><span class="math">$\\kappa \\approx \\sqrt{\\frac{\\log_2 Q}{d(d+1)\\log_2 E}}.</span>$</p>

    <p class="text-gray-300">It was useful for us to guess the optimal value of  <span class="math">\\kappa</span> , which is the most likely to be optimal, but we do nevertheless an exhaustive search. Our method was to approximate  <span class="math">\\log_2 Q</span>  from Figure 1 and to take  <span class="math">E^2 = 2^s</span>  where s is the security level, which leads to Table 5. We verified that in every case the best value is in this table.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">security level</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d=4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d = 6</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d = 8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d = 10</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 or 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 or 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 or 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 or 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 or 2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;<strong>Table 5.</strong> Rule of thumb values for  <span class="math">\\kappa</span> . Here d is the degree of the polynomial P(x) such that p = P(u) for some integer u.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.2 Optimization of the bounds A and B.</h4>

    <p class="text-gray-300">As before B denotes the smoothness bound and A the bound on the coefficients of the sieved polynomials. A pair of values is valid if the sieve produces enough relations, so we need to estimate the number of relations. The sieving space is formed of the pairs a(t), b(t) in  <span class="math">\\mathbb{Z}(t)/h</span>  so that  <span class="math">\\deg a, \\deg b \\leq \\eta - 1</span> . If  <span class="math">\\mu(t)</span>  is a root of unity of the number field of h then the pairs  <span class="math">(\\mu a, \\mu b)</span>  and (a, b) give the same multiplicative relation. In Section 3.1 we restricted  <span class="math">a_0</span>  to positive values to account for the unit -1, here the sieving space shrinks further by the number of roots of unity divided by two.</p>

    <p class="text-gray-300">sieving space=
<span class="math">$(2A+1)^{2\\eta}/(2w)</span>$
,</p>

    <p class="text-gray-300">where w is the index of  <span class="math">\\{1,-1\\}</span>  in the group of roots of unity. By a Monte Carlo integration (Appendix  <span class="math">\\bf A</span> ) we estimate the bit size of the norms: we considered random tuples  <span class="math">(a_0,\\ldots,a_{\\eta-1},b_0,\\ldots,b_{\\eta-1})</span>  each of the components being uniformly chosen in the interval [-A,A]. We call bit size of the norms the arithmetic mean of the bits sizes of the norms for each tuple in a sample of 25600 tuples (see Appendix  <span class="math">\\bf A</span>  for more details). We emphasize that we average the logarithms  <span class="math">\\log_2(N_f)</span>  and  <span class="math">\\log_2(N_g)</span> , rather than  <span class="math">N_f</span>  and  <span class="math">N_g</span> , because the logarithms are used to compute the smoothness probabilities  <span class="math">p_f = \\rho\\left(\\frac{\\log_2 N_f}{\\log_2 B}\\right)</span>  and  <span class="math">p_g = \\rho\\left(\\frac{\\log_2 N_g}{\\log_2 B}\\right)</span> . This gives us the total number of relations which is</p>

    <p class="text-gray-300">relations = (sieving space)
<span class="math">$\\cdot p_f \\cdot p_q</span>$
.</p>

    <p class="text-gray-300">The factor base is formed of the prime ideals of norm less than B in the number fields of f and g, so the cardinality of the factor base is asymptotically equal to  <span class="math">2B/\\log(B)</span> . In some record computations the number of relations is less than the cardinality of the factor base, e.g. 68% in [AFK+07], but for simplicity and without changing the complexity results by more than one bit, we consider that the attacker must collect at least as many relations as elements in the factor base. Hence the validity condition is</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\frac{(2A+1)^{2\\eta}}{2w} \\cdot p_f \\cdot p_g \\ge \\frac{2B}{\\log(B)}.</span>$
(1)</p>

    <p class="text-gray-300">Due to Galois automorphisms (see the discussion in Section 3.2.2)  <span class="math">\\frac{2B}{A \\log(B)}</span>  non-conjugate relations can be used to obtain  <span class="math">2B/\\log(B)</span>  relations (where  <span class="math">\\mathcal{A}</span>  is the number of automorphisms of h times the number of automorphisms of  <span class="math">\\mathbb{F}_{p^n}/\\mathbb{F}_{p^n}</span>  which fix f and g). Equivalently, we collect only  <span class="math">\\frac{2B}{A \\log(B)}</span>  relations and we keep one ideal in each class of conjugacy so that the cardinality of the reduced factor base becomes  <span class="math">\\frac{2B}{A \\log(B)}</span> . Each relation is obtained on average after testing  <span class="math">p_f^{-1}p_g^{-1}</span>  elements of the sieving space, so the total number of enumerated (or sieved) elements is  <span class="math">2B/(A \\log(B)p_fp_g)</span> .</p>

    <p class="text-gray-300">The ratio between the real cost of the sieve and the number of tuples enumerated (or sieved) in the sieve is hard to evaluate so we call it  <span class="math">c_{\\text{sieve}}</span> . According to Table 6,  <span class="math">c_{\\text{sieve}}</span>  is almost constant in various computations realized with various variants of NFS. We stay on the safe side and model  <span class="math">c_{\\text{sieve}}</span>  to be a constant equal to 1.</p>

    <p class="text-gray-300">One might ask if in the case of the new variants, TNFS, exTNFS and SexTNFS, one can approximate  <span class="math">c_{\\text{sieve}}</span>  by its value in the classical variants. Examples abound where new attacks with better asymptotic complexity were actually slower in practice beacuse of hidden constants [MSS16]. In a recent record computation [GGMT17, Section 2.1], Grémy, Guillevic and Morain sieved a dimension three lattice with  <span class="math">A = 2^{16}</span>  in 359 CPU hours, which accounts for  <span class="math">c_{\\text{sieve}} \\approx 27</span> . This value can decrease with the size of A and thaks to practical improvements. However, it is safe to assume that  <span class="math">c_{\\text{sieve}}</span>  will remain  <span class="math">\\geq 1</span> .</p>

    <p class="text-gray-300">In the rest of the analysis we consider  <span class="math">c_{\\text{sieve}} = 1</span>  which means that the sieving time equals the number of elements of the sieving domain. Finally we obtain</p>

    <p class="text-gray-300">sieve cost =
<span class="math">$\\frac{2B}{A \\log(B) \\cdot p_f \\cdot p_q}.</span>$</p>

    <p class="text-gray-300">The size of the matrix sent to filtering is  <span class="math">2B/\\mathcal{A}\\log(B)</span> . As explained in Section 3.2 it is reduced by a factor  <span class="math">\\log_2 B</span> . The number of non-zero entries per row in the reduced matrix varies between 100 and 200 in all records that we consider and we will approximate it by 128. Let then  <span class="math">c_{\\text{lin.alg}}</span>  be such that the cost of the linear algebra is  <span class="math">c_{\\text{lin.alg}} 2^7 B^2/(\\mathcal{A}\\log(B)\\log_2(B))^2</span> , as it is expected to be using Wiedemann's algorithm. The factor  <span class="math">c_{\\text{lin.alg}}</span>  accounts for</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">record</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2 E</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2(\\text{cost of sieve})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2 B</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2(\\text{cost of lin.alg.})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2(c_{\\text{sieve}})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2(c_{lin.alg.})</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-1039 (factor)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-768 (factor)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FFS-809</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-1024 (DLP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-768 (DLP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-4</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6. A list of records and their parameters.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;the cost of a multiplication in  <span class="math">\\mathbb{F}_r</span> , where r is the order of the pairings group. Since  <span class="math">\\log_2 r</span>  varies by at most a factor 2 between various types of pairings and various security levels between 128 and 256, we expect  <span class="math">c_{\\text{lin.alg}}</span>  to be a constant. The records we summarized in Table 6 confirm that  <span class="math">c_{\\text{lin.alg}}</span>  is a constant close to 1.</p>

    <p class="text-gray-300">We conclude this section with a model of the cost:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;
<span class="math">$cost = \\frac{2B}{A \\log B} \\rho \\left( \\frac{\\log_2(N_f)}{\\log_2 B} \\right)^{-1} \\rho \\left( \\frac{\\log_2(N_g)}{\\log_2 B} \\right)^{-1} + 2^7 \\frac{B^2}{A^2 (\\log B)^2 (\\log_2 B)^2}, \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{A}</span>  can be upper bounded by  <span class="math">\\eta \\kappa / \\gcd(\\eta, \\kappa)</span> .</p>

    <p class="text-gray-300">For each pairing curve and choice of polynomials one has to solve an optimization problem: find the values of  <span class="math">\\log_2 A</span>  and  <span class="math">\\log_2 B</span>  which minimize the cost in Equation 2 under the condition in Equation 1.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4.3 Comparison to the analysis of Menezes, Sarkar and Singh</h2>

    <p class="text-gray-300">At this point of the article we can explain the difference between our analysis and that of [MSS16].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;<strong>4.3.1</strong> Impreciseness in the estimation of  <span class="math">\\log_2 N_f</span>  and  <span class="math">\\log_2 N_g</span> . In order to estimate the bit size of the norms  <span class="math">N_f</span>  and  <span class="math">N_g</span> , Menezes, Sarkar and Singh used the mathematical upper bounds. In an experiment we computed the distribution of the bit sizes of norms, and we present our results in Figure 4.3.1. A script to reproduce the experiment on the same sample of 1000 pairs  <span class="math">(\\mathbf{a}, \\mathbf{b})</span>  is available online at [BD17]. The target is the 3072-bit finite field corresponding to a BN curve in Section 5.2. The bitsize  <span class="math">\\log_2 N_f</span>  (in the left) varies between 175 and 244, which is much smaller than 740, the mathematical upper bound. Similarly,  <span class="math">\\log_2 N_g</span>  varies between 417 and 472 which is much smaller than 853, the mathematical upper bound. In a similar experiment [MSS16, Table 3], Menezes, Sarkar and Singh observed a similar</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_10.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. Experimental distribution of  <span class="math">\\log_2 N_f</span>  (in the left) and  <span class="math">\\log_2 N_g</span>  (in the right) on the sieving domain of SexTNFS. The vertical line shows the mathematical upper bound used in [MSS16].</p>

    <p class="text-gray-300">situation: &quot;It is possible that a non-negligible fraction of these have norms close to the upper bounds. Our experiments</p>

    <p class="text-gray-300">only indicate that this fraction is less than 1/1000&quot;. This corroborates with our results but the figure shows at which point the upper bound used in [MSS16] is far away from 99.9% of the values. We remark however that their method is adapted for a practitioner to convince himself that a NFS computation is feasible, because it gives an upper bound on the complexity, but it cannot be used to obtain security estimations which ideally would require a lower bound.</p>

    <p class="text-gray-300">This difference is well known to practitioners of factoring and discrete logarithm. Hence, the CADO-NFS software package  <span class="math">[BGI^+14]</span>  sacrifices a few percents of relations by skipping the pairs  <span class="math">(\\mathbf{a}, \\mathbf{b})</span>  having large norms. For example, from file params.c90 in the parameters directory of CADO-NFS we learn that &quot;lambda0/lambda1 is the early abort sieving parameter, and if [...] the approximation of the log of the remaining cofactor is larger than lambda times lpb, we reject&quot;, where lambda0, lambda1 and lpb are parameters which control the percentage of relations we sacrifice. In this light, the size of the largest 0.1% of the norms has no impact on the behavior of NFS implementations.</p>

    <p class="text-gray-300"><strong>4.3.2 Other differences.</strong> Moreover, the analysis of Menezes, Sarkar and Singh in Section 6.3 does not mention a series of aspects which can decrease the running time of SexTNFS.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Filtering.</strong> On page 13 of [MSS16] one reads &quot;the linear algebra phase will have a cost approximatively  <span class="math">B^2</span> &quot;. This ignores that the number of rows and columns of the matrix is reduced during the filtering step. There is no evidence that the reduction factor is a constant and in Section 3.2.1 we give heuristic arguments that it is approximatively  <span class="math">\\log_2 B</span> . Moreover the size of the factor base is  <span class="math">2B/\\log(B)</span>  rather than B. The discussion on the arithmetic modulo  <span class="math">r(\\ell)</span>  in their notations) on the same page is not necessary because elements of  <span class="math">\\mathbb{F}_r</span>  are implemented on two or three machine words already in the records that we list in Table 6, and elements in  <span class="math">\\mathbb{F}_r</span>  are stored on at most 4 machine words even for 256 bits of security.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(2A+1) instead of A. We didn't find in [MSS16] a discussion on the relation between E and A other than the asymptotic relation  <span class="math">E \\sim A^{\\eta}</span> . An attacker can use (and is likely to do so) as sieving domain the set of tuples  <span class="math">(\\mathbf{a},\\mathbf{b}) \\in \\mathbb{Z}^{2\\eta}</span>  which have the smallest value of  <span class="math">\\max(\\|a\\|_{\\infty},\\|b\\|_{\\infty}) \\leq A</span> , with A as small as possible so that the cardinality of the sieving domain allows to obtain enough relations. In this case we have the relation  <span class="math">(2A+1)^{2\\eta}=E^2</span> . To our understanding, Menezes, Sarkar and Singh used the formula  <span class="math">A=E^{1/\\eta}</span> , which is less precise, especially when the quotient  <span class="math">\\eta/\\log_2 E</span>  is not very small.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Automorphisms and roots of unity.</strong> Menezes, Sarkar and Sing do not use the Galois automorphisms that we discussed in Section 3.2.2.</li>
    </ol></li>
    </ul>

    <h2 id="sec-13" class="text-2xl font-bold">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;5 Estimating SexTNFS complexity on the most popular pairings</h2>

    <p class="text-gray-300">In this section, we use the results of the previous section to estimate the security level provided by a given finite field  <span class="math">\\mathbb{F}_{p^k}</span>  when p is parametrized by a polynomial P(x).</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;5.1 Summarizing the process for computing SexTNFS cost</h4>

    <p class="text-gray-300">Let us first summarize the way to estimate the complexity of the SexTNFS algorithm. It is made of 4 steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1: Parameter selection. The first choice to be made is the one of the  <span class="math">\\kappa</span> . All divisors of k must be tested so that the following steps are done once for each  <span class="math">\\kappa</span> . However, the first values to try are the ones in Table 5. Then one has to choose the polynomial h such that  <span class="math">\\mathcal{A}</span>  is as large as possible and h is as simple as possible (small and few coefficients) and the polynomials f and g to define the commutative diagram given in the introduction. The details on the ways to choose these polynomials are given in Section 3.3. In this step, we also determine the number of roots of unity divided by two w and the number of automorphisms  <span class="math">\\mathcal{A}</span> .</li>
      <li>Step 2: Choice of the bounds A and B. These bounds will define the number of enumerated relations and the size of the factor basis so they have a direct impact on the complexity. As already explained they must be chosen to minimize the cost in Equation 2 under the condition in Equation 1. This optimization problem will be solve by brute force because we do not need a very high accuracy. We first enumerate only integer values of  <span class="math">\\log_2 A \\in [1, \\frac{100}{\\eta}]</span>  and  <span class="math">\\log_2 B \\in [1, 100]</span>  because the cost is lower bounded by  <span class="math">(A^{2\\eta} + B^2)/1000</span>  which is more than  <span class="math">2^{192}</span>  for larger values of A and B. We call  <span class="math">\\log_2 A_0</span>  and  <span class="math">\\log_2 B_0</span>  the optimum of this integer search. In a second time we test</li>
    </ul>

    <p class="text-gray-300">all values of  <span class="math">\\log_2 A</span>  in the set  <span class="math">\\{\\log_2 A_0 + i/100 \\mid i \\text{ integer in } [-100, 100]\\}</span>  and all values of  <span class="math">\\log_2 B</span>  in the set  <span class="math">\\{\\log_2 B_0 + j/5 \\mid j \\text{ integer in } [-25, 25]\\}</span> . When the optimal values of A is less than 10, we switch from enumerating values of  <span class="math">\\log_2 A</span>  to enumerating integer values of A.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 3: Verification. At this point we know what is the security level. For completeness we continue by verifying once again by hand that the values of A and B, which were found by a non-proven program, are indeed valid parameters for SexTNFS by checking that the number of relations is larger than the cardinality of the factor base.</li>
      <li>Step 4: Conclusion. We inject A and B in Equation 2 an verify once again that the cost of SexTNFS is that found
by our unproven solver of the optimization problem.</li>
    </ul>

    <h2 id="sec-15" class="text-2xl font-bold">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;5.2 Example: a BN curve where the finite field has 3072 bits</h2>

    <p class="text-gray-300">One of the most popular BN curve is the one associated to  <span class="math">u = -2^{62} - 2^{55} - 1</span>  which was evaluated to 128 bits of security before the recent developments on NFS. Let us follow Section 5.1 to estimate its real security level.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1: Parameter selection. We decide to use the SexTNFS algorithm with  <span class="math">\\kappa=2</span>  and  <span class="math">\\eta=6</span>  because it gives the best result from the viewpoint of the attacker. The intermediate field will be defined by  <span class="math">h=t^6-t^3-t-1</span>  which is irreducible modulo p. Indeed the cyclotomic polynomials  <span class="math">\\Phi_7, \\Phi_9, \\Phi_{14}</span>  and  <span class="math">\\Phi_{18}</span>  are not irreducible in this case and h is the &quot;smallest&quot; irreducible polynomial (it has only 4 non-zero coefficients which moreover equal  <span class="math">\\pm 1</span> ). We tried several polynomials and found that  <span class="math">x^2+t-u</span>  is irreducible in  <span class="math">\\mathbb{F}_{p^6}=\\mathbb{F}_p[t]/h(t)</span>  so that  <span class="math">\\mathbb{F}_{p^{12}}=\\mathbb{F}_{p^6}[x]/(x^2+t-u)</span> . Hence we can take  <span class="math">f=P(x^2+t)</span>  (where P is the polynomial parametrizing p given in Section 2.1) and  <span class="math">g=x^2+t-u</span> . In this case, we have no non-trivial roots of unity (w=1) and A=2 because g has degree two (as explained in Section 3.2.2).</li>
      <li>Step 2: Choice of the bounds A and B. As explained in Section 5.1, we applied Steps 3 and 4 for many values of A and B to find that  <span class="math">\\log_2 A = 7.36</span>  and  <span class="math">\\log_2(B) = 57</span>  are minimizing the cost given by the Equation 2.</li>
      <li>Step 3: Verification. The total number of tuples in the sieving space is  <span class="math">(2A+1)^{2\\eta}/(2w)</span> , where w=1 is the number of roots of unity of the number field of h, divided by 2, so the size of the sieving space is  <span class="math">2^{99.45}</span> . By Monte Carlo integration (Appendix A) we estimate the norms on the two sides of the commutative diagram and then one can approximate the smoothness probability using Dickman's function</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\log_2(N_f) \\approx 414.7 \\Rightarrow \\rho\\left(\\frac{\\log_2(N_f)}{\\log_2(B)}\\right) \\approx 2^{-21.41} \\ \\ \\text{and} \\ \\ \\log_2(N_g) \\approx 460.8 \\Rightarrow \\rho\\left(\\frac{\\log_2(N_g)}{\\log_2(B)}\\right) \\approx 2^{-25.30}</span>$</p>

    <p class="text-gray-300">Hence the number of relations is approximatively  <span class="math">2^{99.45-21.41-25.30} \\approx 2^{52.74}</span></p>

    <p class="text-gray-300">On the other hand, the cardinality of the factor base is approximatively  <span class="math">2B/\\log(B) \\approx 2^{52.70}</span> , which is less than the number of relations, so we have enough relations (Equation 1 is satisfied).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 4: Conclusion. Equation 2 gives a security level of 99.69 bits. The details are as follows: the number of relations we need to collect is  <span class="math">2^{51.70}</span>  and each relation is obtained after testing on average  <span class="math">2^{21.41+25.30} = 2^{46.71}</span>  pairs (a,b); hence the cost of the sieve is  <span class="math">c_{\\text{sieve}}2^{51.70+46.71} \\approx 2^{98.41}</span>  assuming  <span class="math">c_{\\text{sieve}} \\approx 1</span> ; on the other hand, the filtering stage allows to reduce the matrix size by a factor around  <span class="math">\\log_2 B = 57</span> , its new size being  <span class="math">N = 2^{51.70}/57 \\approx 2^{46.87}</span> ; the cost of the algorithms of sparse linear algebra is given by  <span class="math">2^5N^2 = 2^{98.73}</span>  times the cost of an addition modulo p, which counts here for an elementary operation.</li>
    </ul>

    <p class="text-gray-300">Finally, we get the overall cost by adding the cost of the relation collection and the one of the linear algebra  <span class="math">:2^{98.65} + 2^{98.73} = 2^{99.69}</span>  which means that the BN curve used in most of the existing implementations ensures no more than the 100-bits security level.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;5.3 General results and recommendations</h4>

    <p class="text-gray-300">The goal of this section is to determine the required size of the finite field involved in the pairings given in Section 2 to ensure the 128, 192 and 256-bits security levels. For this, we follow the strategy given in Section 5.1 for each family of curves making at each step the most favorable choice (for the attacker). For example we assumed that the number of automorphisms  <span class="math">\\mathcal{A}</span>  is maximal. If the parameter u (and therefore p) is selected such that the attacker cannot use the best polynomials listed in Table 7 then we observed an increase of up to 3 bits of security (Sections 7.1.1 and 7.1.2).</p>

    <p class="text-gray-300">However, for the purpose of general recommendations, we consider that the attacker can use the best polynomials. The results are given in Tables <a href="#page-13-2">8,</a> <a href="#page-13-3">9</a> and <a href="#page-13-4">10,</a> which then contain our recommendations for the size of p &lt;sup&gt;k&lt;/sup&gt; where k is the embedding degree. Note that in the case of KSS16 and KSS18 curves for 128 bits of security the parameter A is very small (A = 9), and one might want to compute the proportion of elements in the sieving space having each possible value of norms bit size. In every other case in this article we checked that such a precise analysis arrives to the same results as our analysis.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Family</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">η</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">h</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">g</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">w A</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN, BLS12 6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Φ7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 −&lt;br&gt;x&lt;br&gt;u + t 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 Φ17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x − u</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18 Φ19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x − u</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19 18</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 7. Best choices of h and g at 128 bits of security</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Family log2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k&lt;br&gt;(p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">) κ</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">log2&lt;br&gt;B</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5534</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 1145 74.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5530</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 1098 73.65</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS16 ≈ 4400 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18 ≈ 4300 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">76</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-13-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;Table 8. Size of finite fields associated to pairing-friendly curves which have a DLP cost of 2 &lt;sup&gt;128&lt;/sup&gt; operations. Note that in the KSS case the curve side is weaker than the field side and additionally the field side security is particularly difficult to evaluate.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Family log2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k&lt;br&gt;u log2&lt;br&gt;(p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">) κ A log2&lt;br&gt;B</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12200</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 44 110.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13300</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">109.4</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-13-3&quot;&gt;&lt;/span&gt;Table 9. Recommended parameters for pairings of 192 bits of security</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Family log2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k&lt;br&gt;u log2&lt;br&gt;(p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">) κ</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">log2&lt;br&gt;B</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">185</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26900</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 12855 137.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24700</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">141.0</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 10. Recommended parameters for pairings of 256 bits of security</p>

    <p class="text-gray-300">The goal of this section is to propose new parameters for the 128-bits security level for the main families of curves given in Section <a href="#page-3-0">2</a> (BN, BLS12, KSS16 and KSS18). This is done in 2 steps. The first one consists in finding the size of the</p>

    <p class="text-gray-300">extension field ensuring this security level in the general case which means that we assume that all the improvements of the NFS-like algorithms can be used. This was done in Section 5.3 and the results are given in Table 8. We must also take care that the r-torsion subgroup of the elliptic curve involved in the pairing computation ensures the 128-bits security level. For example, this is the limiting factor in the KSS cases. Then, for each family, we know the size of the curve parameter u that should be used to ensure the 128-bits security level (Table 11) in the general case. These sizes guarantee the security level as soon as the parameter u has the required bit size.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Curve</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BN</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLS12</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">KSS16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">KSS18</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\log_2(u)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">114</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">77</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 11.</strong> Bit size of the parameter u ensuring the 128-bits security level</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;The second step is to generate the best possible parameter u having the good bit size. Let us start with the generation of a BN curve.</p>

    <h2 id="sec-17" class="text-2xl font-bold">6.1 New BN parameter for level 128</h2>

    <p class="text-gray-300">The way to build the parameter u is detailed in [DMHR15]: it should be chosen sparse and congruent to 7 or 11 mod 12 so that building  <span class="math">\\mathbb{F}_{p^{12}}</span>  can be done via  <span class="math">Y^6-(1+\\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2}=\\mathbb{F}_p[\\mathbf{i}]</span> . We also impose the condition that the curve obtained is twist-secure [VLFR08] which means that p+1+t should have a 256-bits prime factor (where t is the trace of the Frobenius as usual). We then performed an exhaustive search on u having increasing Hamming weight. There are no results of weight 2. We found some values having Hamming weight 3 but not satisfying the congruence. More precisely, the extension tower should be built using  <span class="math">\\sqrt{-5}</span>  which is much less interesting in terms of  <span class="math">\\mathbb{F}_{p^{12}}</span>  arithmetic. Finally, we found the value  <span class="math">u=2^{114}+2^{101}-2^{14}-1</span>  which satisfies all the required conditions. The curve E defined over  <span class="math">\\mathbb{F}_p</span>  by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 - 4</span>$</p>

    <p class="text-gray-300">is twist-secure (p+1+t) has a 280-bits prime factor) and  <span class="math">u=7 \\mod 12</span>  so that  <span class="math">\\mathbb{F}_{p^2}</span>  is defined by  <span class="math">X^2+1</span>  and  <span class="math">\\mathbb{F}_{p^{12}}</span>  by  <span class="math">Y^6-(1+\\mathbf{i})</span> . The twisted curve E' is defined over  <span class="math">\\mathbb{F}_{p^2}</span>  by</p>

    <p class="text-gray-300"><span class="math">$E&#x27;: y^2 = x^3 - 4(1 + \\mathbf{i}).</span>$</p>

    <h2 id="sec-18" class="text-2xl font-bold">6.2 New BLS12 parameter for level 128</h2>

    <p class="text-gray-300">Most of the results of [DMHR15] can be used for BLS curves because the extension degree is also 12. Again, we performed an exhaustive search on the parameter u having increasing Hamming weight. We did not find any value of weight 2 but we found two having Hamming weight 3,  <span class="math">-2^{77}+2^{50}+2^{33}</span>  and  <span class="math">-2^{77}-2^{59}+2^{9}</span> . In both cases  <span class="math">\\mathbb{F}_{p^{12}}</span>  can be built via  <span class="math">Y^6-(1+\\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2}=\\mathbb{F}_p[\\mathbf{i}]</span> , which provides the best possible  <span class="math">\\mathbb{F}_{p^{12}}</span>  arithmetic. We recommend to use the first one because if the second one is used, the cyclotomic polynomial  <span class="math">\\Phi_7</span>  is irreducible and can be used for h, which improves the SexNFS attack. Then, for  <span class="math">u=-2^{77}+2^{50}+2^{33}</span> , the elliptic curve E (resp. its twist E') is defined over  <span class="math">\\mathbb{F}_p</span>  (resp.  <span class="math">\\mathbb{F}_{p^2}</span> ) by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 + 4, \\qquad E&#x27;: y^2 = x^3 + 4(1 + \\mathbf{i})</span>$</p>

    <p class="text-gray-300">E is of course twist-secure (thanks to a 273 prime factor).</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">6.3 New KSS16 parameter for level 128</h4>

    <p class="text-gray-300">In this case, the parameter u should have at least 34 bits to ensure the 128-bits security level on the elliptic curve side. Unfortunately, an exhaustive search does not provide any suitable value of the parameter having Hamming weight less than or equal to 5. The sparser parameter we found is  <span class="math">-2^{34} + 2^{27} - 2^{23} + 2^{20} - 2^{11} + 1</span> . In this case, the extension</p>

    <p class="text-gray-300">field is defined by  <span class="math">X^{16}-2</span>  which provides the best possible  <span class="math">\\mathbb{F}_{p^{16}}</span>  arithmetic. The elliptic curve E (resp. its twist E') is defined over  <span class="math">\\mathbb{F}_p</span>  (resp.  <span class="math">\\mathbb{F}_{p^4}</span> ) by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 + x, \\qquad E&#x27;: y^2 = x^3 + 2^{\\frac{1}{4}}x</span>$</p>

    <p class="text-gray-300">And again, E is twist-secure (thanks to a 318-bits prime factor). However we found a suitable 35-bits parameter having Hamming weight 5. Such a parameter will of course involve an additional doubling/squaring step in the exponentiation algorithms but it will also involve one addition/multiplication step less. The impact on the Miller loop is negligible, but in the final exponentiation this means that a  <span class="math">\\mathbb{F}_{p^{16}}</span>  multiplication is replaced by a cyclotomic squaring and this happens 9 times since 9 exponentiations by u are performed (see Section 8 for details). Since a cyclotomic squaring is more than twice faster than a  <span class="math">\\mathbb{F}_{p^{16}}</span>  multiplication, it is better to use the 35-bits parameter as long as  <span class="math">\\mathbb{F}_p</span>  arithmetic is not impacted. For example, p has 330 bits for the 34-bits value of u and 340 for the 35-bits value. Hence, if a 32-bits device is used, both values of p require 11 words so the  <span class="math">\\mathbb{F}_p</span>  arithmetic is not impacted. On the contrary, if a 16-bits device is used, choosing the 35-bits value of u implies that p requires 22 words instead of 21. Then the 34-bits value may be preferred in this case. This parameter is  <span class="math">u=2^{35}-2^{32}-2^{18}+2^8+1</span> ,  <span class="math">\\mathbb{F}_{p^{16}}</span>  is also defined by  <span class="math">X^{16}-2</span>  and the elliptic curve E (resp. its twist E') is defined over  <span class="math">\\mathbb{F}_p</span>  (resp.  <span class="math">\\mathbb{F}_{p^4}</span> ) by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 + x,</span>$
<span class="math">E&#x27;: y^2 = x^3 + 2^{-\\frac{1}{4}}x</span></p>

    <p class="text-gray-300">E is of course twist-secure (thanks to a 281-bits prime factor).</p>

    <h2 id="sec-20" class="text-2xl font-bold">6.4 New KSS18 parameter for level 128</h2>

    <p class="text-gray-300">Again, the limiting factor for the security level is the elliptic curve size so that u should have at least 44 bits. Our exhaustive search provides no values having weight 2 or 3 and only one having weight 4. It is  <span class="math">u=2^{44}+2^{22}-2^9+2</span> . In this case,  <span class="math">\\mathbb{F}_{p^{18}}</span>  cannot be defined by  <span class="math">X^{18}-2</span>  but by  <span class="math">X^{18}-3</span> . The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 + 3,</span>$
<span class="math">E&#x27;: y^2 = x^3 + 3.3^{\\frac{1}{3}}</span>  (or  <span class="math">3.3^{-\\frac{1}{3}}</span> ).</p>

    <p class="text-gray-300">The curve E is twist-secure (thanks to a 333-bits prime factor).</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">6.5 Discussion on subgroup-secure curves for level 128</h4>

    <p class="text-gray-300">All the curves provided are not protected against the so-called subgroup attacks. These attacks use the fact that the three groups involved in the pairing may have small cofactors [LL97]. They can be prevented by choosing resistant parameters. However they do not occur for all protocols. They can also be prevented by the use of some (potentially expensive) subgroup membership tests. Then subgroup-secure parameters are not always used in the literature and in real-life implementations. That is the reason why we provided non subgroup-secure parameters in the general case (better efficiency) and subgroup-secure ones in this higher security section (that should be preferred in some situations).</p>

    <p class="text-gray-300">The definition of subgroup security for pairing is given in [BCM+15] and implies that one should be able to find factors of  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\mathbb{G}_3</span> . This can be done using the ECM method but it is very costly so one cannot perform an exhaustive search checking subgroup security at each step. As explained in [BCM+15], the most reasonable way to find a subgroup-secure curve for pairing applications is to find a parameter u such that  <span class="math">\\#\\mathbb{G}_2/r</span>  and  <span class="math">\\#\\mathbb{G}_3/r</span>  are primes. This is of course much easier to check but on the other hand there are much fewer candidates.</p>

    <p class="text-gray-300">According Section 8, we are only interested in BLS12 and KSS16 curves in the case of security level 128. We then made an exhaustive search of increasing Hamming weight values of u satisfying this condition. For BLS12 curves, we find some parameters in weight 7. We give only one here but the other ones are not so difficult to find:  <span class="math">u=-2^{77}-2^{71}-2^{64}+2^{37}+2^{35}+2^{22}-2^5</span> . In this cases  <span class="math">\\mathbb{F}_{p^{12}}</span>  can be built via  <span class="math">Y^6-(1+\\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2}=\\mathbb{F}_p[\\mathbf{i}]</span>  which provides the best possible  <span class="math">\\mathbb{F}_{p^{12}}</span>  arithmetic. The elliptic curve E (resp. its twist E') is defined over  <span class="math">\\mathbb{F}_p</span>  (resp.  <span class="math">\\mathbb{F}_{p^2}</span> ) by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 - 2,</span>$
<span class="math">E&#x27;: y^2 = x^3 - 2/(1 + i)</span></p>

    <p class="text-gray-300">E is of course twist-secure (thanks to a 433 prime factor).</p>

    <p class="text-gray-300">The case of KSS16 curves is more complicated. We first remark that  <span class="math">\\#\\mathbb{G}_2/r</span>  and  <span class="math">\\#\\mathbb{G}_3/r</span>  are always even and often divisible by 17 [GF16] so we have interest to relax the condition. Unfortunately it was not sufficient to find a parameter of Hamming weight less than or equal to 10. This is due to the fact that  <span class="math">\\log_2(u) = 34</span>  implies that there are not enough possibilities for u to have a reasonable probability that all the numbers involved  <span class="math">(p, r, \\#\\mathbb{G}_2/2r, \\#\\mathbb{G}_3/2r)</span>  are primes together (up to some  <span class="math">17^n</span>  factor). As a consequence, it is probably more interesting to choose the previous subgroup-secure BLS curve or the non subgroup-secure KSS16 curve given in Section 7.1.3 together with the necessary subgroup membership tests (depending on the protocol).</p>

    <h2 id="sec-22" class="text-2xl font-bold">6.6 New parameters for level 192</h2>

    <p class="text-gray-300">In the case of higher levels of security we prefer to be more cautious. Instead of a comparison of the best curves we simply give our own proposals. In terms of security we are once again cautious, our curves having more than 192 bits of security. This is due to the nature of our approach (the targeted extension field size is first determined in the worst case). We give only a KSS18 and a BLS24 curve since there is no doubt that BN, BLS12 and KSS16 will be less efficient.</p>

    <p class="text-gray-300"><strong>6.6.1</strong> New KSS18 parameter for level 192 We saw in Table 9 that the parameter u should be chosen such that  <span class="math">\\log_2(u) \\geq 85</span> . As in the 128-bits case, we perform an exhaustive search of low Hamming weight values for u. The best value we found is  <span class="math">u = -2^{85} - 2^{31} - 2^{26} + 2^6</span> . In this case,  <span class="math">\\mathbb{F}_{p^{18}}</span>  can be defined by  <span class="math">X^{18} - 2</span> . The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 + 2, \\qquad E&#x27;: y^2 = x^3 + 2.2^{\\frac{1}{3}} \\text{ (or } 2.2^{-\\frac{1}{3}})</span>$</p>

    <p class="text-gray-300">The curve E is twist-secure (thanks to a 652-bits prime factor).</p>

    <p class="text-gray-300"><strong>6.6.2</strong> New BLS24 parameter for level 192 We saw in Table 9 that the parameter u should be chosen such that  <span class="math">\\log_2(u) \\geq 56</span> . As in the 128-bits case, we perform an exhaustive search of low Hamming weight values for u. The best value we found is  <span class="math">u = -2^{56} - 2^{43} + 2^9 - 2^6</span> . In this case,  <span class="math">\\mathbb{F}_{p^{24}}</span>  can be built via  <span class="math">Y^{12} - (1 + \\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[\\mathbf{i}]</span>  which provides the best possible  <span class="math">\\mathbb{F}_{p^{24}}</span>  arithmetic. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 - 2,</span>$
<span class="math">E&#x27;: y^2 = x^3 - 2/(1 + \\mathbf{i})</span></p>

    <p class="text-gray-300">E is of course twist-secure (thanks to a 427 prime factor).</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">6.7 New parameters for lever 256</h4>

    <p class="text-gray-300">As in the case of level 192, the fast pairings correspond to KSS18 and BLS24, thanks to theirs embedding degrees which are higher than that of BN, BLS12 and KSS16.</p>

    <p class="text-gray-300">In order to keep the complexity low we use only values of u which can be written as a small number of terms of the form  <span class="math">2^a</span>  for some integers a. A side effect is that  <span class="math">u \\approx 2^a</span>  for some a and therefore  <span class="math">p \\approx u^{18}</span>  and  <span class="math">p \\approx u^{24}</span>  in the cases of KSS18 and respectively BLS24. This makes it difficult to tune  <span class="math">\\log_2 p^k</span>  precisely.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">6.7.1 New KSS18 parameter for level 256 The parameter</h4>

    <p class="text-gray-300"><span class="math">$u = 2^{186} - 2^{75} - 2^{22} + 2^4</span>$</p>

    <p class="text-gray-300">allows to have a finite field bit size of 26700. In this case,  <span class="math">\\mathbb{F}_{p^{18}}</span>  can be defined by  <span class="math">X^{18}-2</span> . The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 - 2, \\qquad E&#x27;: y^2 = x^3 - 2.2^{\\frac{1}{3}} \\text{ (or } 2.2^{-\\frac{1}{3}})</span>$</p>

    <p class="text-gray-300">The curve E is twist-secure (thanks to a 1205-bits prime factor).</p>

    <h2 id="sec-25" class="text-2xl font-bold"><strong>6.7.2</strong> New BLS24 parameter for level 256 We propose parameter</h2>

    <p class="text-gray-300"><span class="math">$u = -2^{103} - 2^{101} + 2^{68} + 2^{50},</span>$</p>

    <p class="text-gray-300">which allows to have a finite field of bit size 24760. In this case,  <span class="math">\\mathbb{F}_{p^{24}}</span>  can be also built via  <span class="math">Y^{12} - (1+\\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[\\mathbf{i}]</span> . The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">$E: y^2 = x^3 - 2, \\qquad E&#x27;: y^2 = x^3 - 2/(1 + \\mathbf{i})</span>$</p>

    <p class="text-gray-300">E is of course twist-secure (thanks to a 581 prime factor).</p>

    <p class="text-gray-300">Let us now apply the strategy given in Section 5.1 to evaluate the real security of the proposed curves.</p>

    <h2 id="sec-26" class="text-2xl font-bold">7.1 Level 128</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;<strong>7.1.1</strong> BN We study the BN curve proposed in the previous section, which has parameter  <span class="math">u = 2^{114} + 2^{101} - 2^{14} - 1</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1. The best results are obtained with  <span class="math">\\kappa=2</span>  and  <span class="math">\\eta=6</span> . The best choices for the polynomials are h=6 <span class="math">t^6 - t^4 + t^2 + 1</span> ,  <span class="math">q = x^2 - t - u</span>  and  <span class="math">f = P(x^2 - t)</span> . In this case, we have w = 1 and A = 2 as in Section 5.2. As a consequence we will find a higher security level here than in the general case.</li>
    </ul></li>
      <li>Step 2.  <span class="math">A = 1098 \\approx 2^{10.10}</span>  and  <span class="math">B = 2^{74.2}</span>  are minimizing Equation 2 and satisfying Equation 1.</li>
      <li>Step 3. The size of the sieving space is  <span class="math">(2A+1)^{12}/2 \\approx 2^{132.21}</span> . The Monte Carlo integration (Appendix A) gives  <span class="math">\\log_2(N_f) \\approx 557.0</span>  and  <span class="math">\\log_2(N_g) \\approx 808.9</span> . Then the smoothness probabilities are approximatively equal to  <span class="math">\\rho\\left(\\frac{\\log_2(N_f)}{\\log_2(B)}\\right) \\approx 2^{-22.87}</span>  and  <span class="math">\\rho\\left(\\frac{\\log_2(N_g)}{\\log_2(B)}\\right) \\approx 2^{-40.52}</span> . Hence we expect a number of  <span class="math">2^{132.21-22.87-40.52} \\approx 2^{68.82}</span> relations which is larger than the cardinality of the factor base which is around  <span class="math">2^{68.78}</span> .</li>
      <li>Step 4. Evaluating Equation 2 with these data finally gives an overall complexity of  <span class="math">2^{131.3}</span> .</li>
    </ul>

    <p class="text-gray-300">Remark 1. The size of the parameters for this pairing are so that they guarantee 128 bits of security for arbitrary parameters in the BN family. However this particular choice offers 131 bits of security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1. We chose  <span class="math">\\kappa = 2</span>  and  <span class="math">\\eta = 6</span> . The best polynomials are  <span class="math">h = t^6 t 1</span> ,  <span class="math">f = P(x^2 + t + t^2 + t^4 + 1)</span>  where  <span class="math">P(x) = (x-1)^2(x^4-x^2+1) + 3x</span>  and  <span class="math">q = x^2+t+t^2+t^4+1-u</span> . In this case, we have w = 7 and A = 2(because g is quadratic).</li>
      <li>Step 2. A = 1169 and  <span class="math">\\log_2 B = 73.50</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 133.30</span></li>
      <li><span class="math">\\log_2(N_f) = 791.2 \\Rightarrow \\log_2(\\text{smoothness probability on the } f \\text{ side}) = -39.17</span></li>
      <li><span class="math">\\log_2(N_q) = 584.8 \\Rightarrow \\log_2(\\text{smoothness probability on the } g \\text{ side}) = -24.67</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 69.46</span></li>
      <li><span class="math">\\log_2(\\text{reduced factor base}) = 67.83 \\text{ (enough relations)}</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security=131.8</li>
    </ul>

    <p class="text-gray-300">Remark 2. Zhaohui Cheng communicated to us two choices of BLS12 curses which have 127 bits of security:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{array}{l} \\textbf{-- equation } y^2 = x^3 + 9 \\text{ and parameter } u = -(2^{73} + 2^{72} + 2^{50} + 2^{24}); \\\\ \\textbf{-- equation } y^2 = x^3 + 7 \\text{ and parameter } u = -(2^{12} + 2^{48} + 2^{49} + 2^{50} + 2^{51} + 2^{52} + 2^{53} + 2^{54} + 2^{55} + 2^{56} + 2^{57} + 2^{58} + 2^{59} + 2^{60} + 2^{61} + 2^{62} + 2^{63} + 2^{64} + 2^{65} + 2^{66} + 2^{67} + 2^{68} + 2^{69} + 2^{70} + 2^{72} + 2^{73}). \\end{array}</span></li>
    </ul>

    <p class="text-gray-300">The field  <span class="math">p^k</span>  is 5280 bits long instead of the 5530 bits required by the general estimations in Table 7. Hence, our approach of first finding general recommendations for each family (assuming the attacker can apply all improvements), then checking specific values of u, only loses 5% in length.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;<strong>7.1.3</strong> KSS 16 The recommended parameter is  <span class="math">u = 2^{35} - 2^{32} - 2^{18} + 2^8 + 1</span> .</li>
      <li>Step 1. We chose  <span class="math">\\kappa=1</span>  and  <span class="math">\\eta=16</span> . The best polynomials are  <span class="math">h=\\Phi_{17}, f=P(x-1)</span>  and g=x-u-1. In this case, we have w=17 and  <span class="math">\\mathcal{A}=16</span> .</li>
      <li>Step 2. A=12 and  <span class="math">\\log_2 B=80</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 143.52</span></li>
      <li><span class="math">\\log_2(N_f) = 920.4 \\Rightarrow \\log_2(\\text{smoothness probability on the } f \\text{ side}) = -43.23</span></li>
      <li><span class="math">\\log_2(N_q) = 628.9 \\Rightarrow \\log_2(\\text{smoothness probability on the } g \\text{ side}) = -24.21</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 76.08</span></li>
      <li><span class="math">log_2(reduced factor base) = 71.20 (enough relations)</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security=139.0. Note that this is the security only on the finite field side. The security on the elliptic curve side is 128 as required.</li>
      <li><strong>7.1.4</strong> KSS 18 The recommended parameter is  <span class="math">u = 2^{44} + 2^{22} 2^9 + 2</span> .</li>
      <li>Step 1. We chose  <span class="math">\\kappa=1</span>  and  <span class="math">\\eta=18</span> . The best polynomials are  <span class="math">h=t^{18}-t^4-t^2-t-1</span> , f=P(x-2) and g=x-u-2. In this case, we have w=1 and  <span class="math">\\mathcal{A}=1</span> .</li>
      <li><strong>Step 2.</strong> A = 11 and  <span class="math">\\log_2 B = 82.5</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 161.85</span></li>
      <li><span class="math">\\log_2(N_f) = 920.4 \\Rightarrow \\log_2(\\text{smoothness probability on the } f \\text{ side}) = -36.21</span></li>
      <li><span class="math">\\log_2(N_g) = 628.9 \\Rightarrow \\log_2(\\text{smoothness probability on the } g \\text{ side}) = -38.33</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 87.31</span></li>
      <li><span class="math">\\log_2(\\text{reduced factor base}) = 77.66 \\text{ (enough relations)}</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security=152.4. Note that this is the security only on the finite field side. The security on the elliptic curve side is 128 as required.</li>
    </ul>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">7.2 Level 192</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>7.2.1 KSS18 for level 192 To evaluate its real security, we use the way described in Section 5.1 and we get    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1. We chose  <span class="math">\\kappa=1</span>  and  <span class="math">\\eta=18</span> . The best polynomials are  <span class="math">h=t^{18}-t^4-t^2-t-1</span> , f=P(x-2) and g=x-u-2. In this case, we have w=1 and  <span class="math">\\mathcal{A}=1</span> .</li>
    </ul></li>
      <li><strong>Step 2.</strong> A = 34 and  <span class="math">\\log_2 B = 108.9</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 161.85</span></li>
      <li><span class="math">\\log_2(N_f) = 1114 \\Rightarrow \\log_2(\\text{smoothness probability on the } f \\text{ side}) = -36.29</span></li>
      <li><span class="math">\\log_2(N_q) = 1642 \\Rightarrow \\log_2(\\text{smoothness probability on the } g \\text{ side}) = -63.99</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 118.62</span></li>
      <li><span class="math">\\log_2(\\text{reduced factor base}) = 103.66 \\text{ (enough relations)}</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security = 204.09.</li>
      <li>7.2.2 BLS24 for level 192 To evaluate its real security, we use the way described in Section 5.1 and we get</li>
      <li>Step 1. We chose  <span class="math">\\kappa=1</span>  and  <span class="math">\\eta=24</span> . The best polynomials are  <span class="math">h=t^{24}+t^4-t^3-t-1, f=P(x)</span>  and g=x-u. In this case, we have w=1 and  <span class="math">\\mathcal{A}=1</span> .</li>
      <li><strong>Step 2.</strong> A = 9 and  <span class="math">\\log_2 B = 109.8</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 202.90</span></li>
      <li><span class="math">\\log_2(N_f) = 1295 \\Rightarrow \\log_2(\\text{smoothness probability on the } f \\text{ side}) = -44.85</span></li>
      <li><span class="math">\\log_2(N_g) = 1460 \\Rightarrow \\log_2(\\text{smoothness probability on the } g \\text{ side}) = -53.42</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 104.63</span></li>
      <li><span class="math">\\log_2(\\text{reduced factor base}) = 104.55 \\text{ (enough relations)}</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security = 203.72.</li>
    </ul>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">7.3 Level 256</h4>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">7.3.1 KSS18</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Step 1.</strong> We chose  <span class="math">\\kappa = 2</span>  and  <span class="math">\\eta = 9</span> . The best polynomials are  <span class="math">h = t^9 + t^8 + t^7 t^6 1</span> ,  <span class="math">f = P(x^2 2)</span>  where  <span class="math">P = x^8 + 5x^7 + 7x^6 + 37x^5 + 188x^4 + 259x^3 + 343x^2 + 1763x + 240</span> ,  <span class="math">g = x^2 2 u</span> .</li>
      <li>Step 2. A = 11747 and  <span class="math">\\log_2 B = 137.7</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieve space}) = 260.36</span></li>
      <li><span class="math">\\log_2(N_f) = 2185</span>  and  <span class="math">\\log_2(N_q) = 1928</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 134.35 \\text{ } \\log_2(\\text{factor base}) = 131.12 \\text{ (enough relations)}</span></li>
    </ul></li>
      <li><strong>Step 4.</strong> security = 257.13</li>
    </ul>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">7.3.2 BLS24</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Step 1.</strong> We choose  <span class="math">\\kappa = 1</span>  and  <span class="math">\\eta = 24</span> . The best polynomials are  <span class="math">h = t^{24} t^{23} t^{21} + t^{20} 1</span> ,  <span class="math">f = P = (x-1)^2 * (x^8 x^4 + 1) + 3 * x</span> , g = x u.</li>
      <li><strong>Step 2.</strong> A = 23 and  <span class="math">\\log_2 B = 138.5</span></li>
      <li>Step 3.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\log_2(\\text{sieving domain}) = 262.62</span></li>
      <li><span class="math">\\log_2(N_f) = 1522</span>  and  <span class="math">\\log_2(N_g) = 2619</span></li>
      <li><span class="math">\\log_2(\\text{relations}) = 137.28 &gt; 131.92 = \\log_2(\\text{factor base})</span>  (enough relations)</li>
    </ul></li>
      <li><strong>Step 4.</strong> security = 260.9</li>
    </ul>

    <p class="text-gray-300">The goal of this section is to compare the pairing computation cost for the curves given in section 6 at the 128 bits security level. For this, we evaluate the cost of an optimal pairing [Ver09] (because it is by far the most efficient at this security level) computation in each case (BN, BLS12, KSS16 and KSS18). Let us first recall the steps of the computation.</p>

    <h2 id="sec-31" class="text-2xl font-bold">8.1 Optimal ate pairing computation</h2>

    <p class="text-gray-300">We do not give here the detailed algorithm to compute pairings but only what is necessary to analyze its complexity. More details can be found for example in [EMJ17].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>8.1.1</strong> The Miller loop. Miller explains how to compute  <span class="math">f_{u,Q}</span>  in [Mil04]. The algorithm is based on the computation of [u]Q using the double and add algorithm. At each step of this algorithm, f is updated with the line function involved in the elliptic curve operation. This algorithm has been improved by many authors in particular using the twisted curve to eliminate denominators and replace  <span class="math">\\mathbb{F}_{p^k}</span>  multiplications by sparse ones. The best known complexity for each step are obtained using projective coordinates [GS10]. They are given below    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If d=6, the doubling step requires one squaring in  <span class="math">\\mathbb{F}_{p^k}</span> , denoted  <span class="math">S_k</span> , one sparse multiplication in  <span class="math">\\mathbb{F}_{p^k}</span> , denoted  <span class="math">sM_k</span>  (for updating f) together with 2 multiplications in  <span class="math">\\mathbb{F}_{p^e}</span> , denoted  <span class="math">M_e</span> , 7 squarings in  <span class="math">\\mathbb{F}_{p^e}</span>  and 2e multiplications in  <span class="math">\\mathbb{F}_p</span> , denoted M (for doubling on the curve and computing the line involved in this doubling). If d=4, the curve side requires one additional  <span class="math">S_e</span> .</li>
    </ul></li>
      <li>If d=6, the mixed addition step requires one  <span class="math">sM_k</span>  for updating f together with  <span class="math">11M_e</span> ,  <span class="math">2S_e</span>  and 2eM (or  <span class="math">9M_e</span> ,  <span class="math">5S_e</span>  and 2eM if d=4).</li>
      <li>Additional lines in the pairing given in Table 2 are nothing but extra addition steps. In term of complexity, the last one is usually less expensive ( <span class="math">4M_e</span>  and 2eM for the curve side) because the resulting point on the curve is useless.</li>
      <li>The computation of points of the form [p]Q is very easy because Q is in the p-eigenspace of the Frobenius map. Then it requires no more than 2 Frobenius mapping in  <span class="math">\\mathbb{F}_{p^k}</span> , denoted  <span class="math">F_k</span> . In practice, it requires even less but there is no interest to get into these kind of details for this comparison work.</li>
    </ul>

    <p class="text-gray-300"><strong>8.1.2</strong> The final exponentiation. It is usually split in 2 parts, an easy one with the exponent  <span class="math">\\frac{p^k-1}{\\phi_k(p)}</span>  (where  <span class="math">\\phi_k</span>  is the k-th cyclotomic polynomial) and a hard one with the exponent  <span class="math">\\frac{\\phi_k(p)}{r}</span> . The easy part is made of an inversion, denoted  <span class="math">I_k</span> , and few multiplications and Frobenius mappings in  <span class="math">\\mathbb{F}_{p^k}</span> . The hard part is much more expensive but Scott et al. [SBC+09] reduce this cost by writing the exponent in base p (because p-th powering is only a Frobenius mapping). As p is polynomially parametrized by p, the result is obtained thanks to p0 degree by considering powers of the pairing [FKR11]. Note also that, thanks to the easy part of the final exponentiation, the squaring operations (which are widely used during the hard part) can be simplified. We can either use cyclotomic squarings [GS10], denoted p1, denoted p2, or compressed squarings [Kar13,AKL+11], denoted p3. Compressed squarings are usually more efficient. However, this method has been developed in the case of degree 6 twists [Kar13,AKL+11]. There is no doubt that it can be adapted to the case of degree 4 twists (and then to KSS16 curves) but we did not find explicit formulas in the literature. Then, for a fairer comparison between the curves, we chose to consider both squaring methods in the following.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;8.2 Finite field arithmetic</h4>

    <p class="text-gray-300">In order to compare the different candidates, we need a common base. It cannot be the field  <span class="math">\\mathbb{F}_p</span>  because p has not the same size in all cases. So we have to go to the data-words level. We will only give global estimates so we need to make some assumptions that are close to an average environment. Then, we assume that we work on a 32 bits device because it is a good average between software, FPGA and embedded devices. We will also assume that  <span class="math">\\mathbb{F}_p</span>  arithmetic is quadratic (even if the multiplication complexity can be subquadratic, the reduction usually stays quadratic). Finally, for simplicity, we will assume that  <span class="math">\\mathbb{F}_p</span>  multiplications and squarings have almost the same cost and we will neglect additions. Of course, these assumptions are very dependent on the device so we do not pretend that our result is valid in every case. Anyway, our goal here is not to get an universal comparison (which is not possible) but to have an idea of which curve has to be chosen to get the best efficiency. For a given precise device or context, such general estimates cannot replace a real implementation for a fair comparison.</p>

    <p class="text-gray-300">Pairing computation makes a large use of  <span class="math">\\mathbb{F}_{p^e}</span>  arithmetic. Let us first recall them in Table 12 for the considered values of e.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbb{F}_{p^4}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multiplication</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Squaring</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6M</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 12.</strong> Complexities of  <span class="math">\\mathbb{F}_{p^e}</span>  arithmetic</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;Concerning the  <span class="math">\\mathbb{F}_{p^k}</span>  arithmetic, the complexities are given in the literature in the pairing context for extensions of degree 12 [AFCK+13,DMHR15], 16 [ZL12] and 18 [AFCK+13]. They are summarized in Table 13.</p>

    <p class="text-gray-300">We made the simplistic assumption that the cost of Frobenius mapping in  <span class="math">\\mathbb{F}_{p^k}</span>  is always (k-1)M which is not always the case (for example for  <span class="math">p^2</span>  or  <span class="math">p^3</span>  powering) but this has negligible impact on our comparison (there are few such mapping and this remark holds for all the considered cases).</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">8.3 <span class="math">\\mathbb{F}_p</span> complexities estimations</h4>

    <p class="text-gray-300"><strong>8.3.1 BN curve.</strong> In this case, the optimal ate pairing is given by</p>

    <p class="text-gray-300"><span class="math">$\\left(f_{6u+2,Q}(P).\\ell_{[6u+2]Q,[p]Q}(P).\\ell_{[6u+2+p]Q,[p^2]Q}(P)\\right)^{\\frac{p^{12}-1}{r}}</span>$</p>

    <p class="text-gray-300">It is explained in Section 6 that  <span class="math">u = 2^{114} + 2^{101} - 2^{14} - 1</span>  should be chosen to ensure the 128-bits security level and the best possible extension field arithmetic. Then 6u + 2 has length 116 and Hamming weight 7. As a consequence, the</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Fp12</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Fp16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Fp18</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multiplication</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">108M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sparse multiplication</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">78M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Inversion</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I + 97M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I + 134M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I + 172M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Frobenius</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Squaring</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Cyclotomic squaring</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compressed squaring</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">–</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Simult. decompression I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">–</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I + (51n − 6)M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of n elements</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+ (24n − 5)M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 13. Complexities of Fp&lt;sup&gt;k&lt;/sup&gt; arithmetic</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;Miller loop requires 116 doubling steps and 6 addition steps. Extra lines computations require 4 Frobenius mapping (to compute [p]Q and [p 2 ]Q), one addition step and one incomplete addition step. Then the overall cost is</p>

    <p class="text-gray-300"><span class="math">$116(2M_2 + 7S_2 + 4M) + 115(S_{12} + sM_{12}) + 7(11M_2 + 2S_2 + 4M) + 4M_2 + 4M + 8sM_{12} + 4F_{12} + 4M + 8sM_{12} + 4F_{13} + 4M + 8sM_{14} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{15} + 4M + 8sM_{</span>$</p>

    <p class="text-gray-300">Using Tables <a href="#page-20-0">12</a> and <a href="#page-21-0">13,</a> this step requires 12068 multiplications in Fp.</p>

    <p class="text-gray-300">There are many ways to compute the final exponentiation for BN curves. The most efficient one is given in <a href="#page-25-26">[FKR11]</a> and requires I&lt;sup&gt;12&lt;/sup&gt; + 12M&lt;sup&gt;12&lt;/sup&gt; + 3cS&lt;sup&gt;12&lt;/sup&gt; + 4F&lt;sup&gt;12&lt;/sup&gt; in addition to the 3 exponentiation by u (because p has degree 4 in u). As u has length 114 and Hamming weight 4, each of these exponentiations requires 114 squarings and 3 multiplications. If the cyclotomic squaring are used, we need 114cS&lt;sup&gt;12&lt;/sup&gt; + 3M&lt;sup&gt;12&lt;/sup&gt; = 2214M according Table <a href="#page-21-0">13.</a> If the compressed squaring technique is used, we additionally need the simultaneous decompression of 4 elements. Then, according to Table <a href="#page-21-0">13</a> each exponentiation by u requires 1621M + I.</p>

    <p class="text-gray-300">The final exponentiation then requires 7485M + I or 5706M + 4I depending on the way to perform squarings. Finally computing the optimal ate pairing for BN curve ensuring the 128-bits security level requires 19553M + I or 17774M + 4I depending on the way to perform squarings during the final exponentiation.</p>

    <h2 id="sec-34" class="text-2xl font-bold">8.3.2 BLS12 curve. The optimal ate pairing is simpler in this case since it is given by</h2>

    <p class="text-gray-300"><span class="math">$(f_{u,Q}(P))^{\\frac{p^{12}-1}{r}}</span>$</p>

    <p class="text-gray-300">We have seen that the best choice of u is −2 &lt;sup&gt;77&lt;/sup&gt; + 2&lt;sup&gt;50&lt;/sup&gt; + 2&lt;sup&gt;33&lt;/sup&gt; so that the Miller loop is made of 77 doubling steps and 2 addition steps. Then, its cost is</p>

    <p class="text-gray-300"><span class="math">$77(2M_2 + 7S_2 + 4M) + 76(S_{12} + sM_{12}) + 2(11M_2 + 2S_2 + 4M) + 2sM_{12} = 7708M</span>$</p>

    <p class="text-gray-300">According <a href="#page-23-3">[AFCK</a>&lt;sup&gt;+&lt;/sup&gt;13], the final exponentiation requires I&lt;sup&gt;12&lt;/sup&gt; + 12M&lt;sup&gt;12&lt;/sup&gt; + 2cS&lt;sup&gt;12&lt;/sup&gt; + 4F&lt;sup&gt;12&lt;/sup&gt; = 825M + I in addition to the 5 exponentiation by u (because p has degree 6 in u). As u has length 77 and Hamming weight 3, each of these exponentiations requires 77 squarings and 2 multiplications. If the cyclotomic squaring are used, we need 77cS&lt;sup&gt;12&lt;/sup&gt; + 2M&lt;sup&gt;12&lt;/sup&gt; = 1494M. If the compressed squaring technique is used, we additionally need the simultaneous decompression of 3 elements so that each exponentiation by u requires 1099M + I.</p>

    <p class="text-gray-300">The final exponentiation then requires 8295M + I or 6320M + 6I depending on the way to perform squarings. Finally computing the optimal ate pairing for BLS12 curve ensuring the 128-bits security level requires 16003M + I or 14028M + 6I.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">8.3.3 KSS16 curve. For KSS16 curves, the optimal ate pairing is given by</h4>

    <p class="text-gray-300"><span class="math">$\\left(\\left(f_{u,Q}(P).\\ell_{[u]Q,[p]Q}(P)\\right)^{p^3}.\\ell_{Q,Q}(P)\\right)^{\\frac{p^{16}-1}{r}}</span>$</p>

    <p class="text-gray-300">and u has been chosen to be  <span class="math">2^{35} - 2^{32} - 2^{18} + 2^8 + 1</span>  in section 6. Then the Miller loop requires 35 doubling steps and 4 addition steps. According [ZL12], extra lines computations require 3 Frobenius mapping (2 to compute [p]Q and one to raise to  <span class="math">p^3</span> ) and two incomplete addition steps. The overall cost is then</p>

    <p class="text-gray-300"><span class="math">$35(2M_4 + 8S_4 + 8M) + 34(S_{16} + 8M_{16}) + 4(9M_4 + 5S_4 + 8M) + 3F_{16} + 5M_4 + S_4 + 16M + 6sM_{16} = 7534M</span>$</p>

    <p class="text-gray-300">According [GF16], the final exponentiation requires  <span class="math">I_{16} + 32M_{16} + 34cS_{16} + 24M_4 + 8F_{16}</span>  in addition to the 9 exponentiation by u (because p has degree 10 in u). As u has length 35 and Hamming weight 5, each of these exponentiations requires 35 cyclotomic squarings and 4 multiplications. According Table 13, each exponentiation by u then requires 1584M. Note that we do not find in the literature formulas for compressed squaring in the KSS16 case. The final exponentiation then requires 18542M + I. Finally computing the optimal ate pairing for KSS16 curve ensuring the 128-bits security level requires 26076M + I.</p>

    <h2 id="sec-36" class="text-2xl font-bold"><strong>8.3.4</strong> KSS18 curve. In this case, the optimal ate pairing is given by</h2>

    <p class="text-gray-300"><span class="math">$(f_{u,Q}(P).f_{3,Q}(P)^p.\\ell_{[u]Q,[3p]Q}(P))^{\\frac{p^{18}-1}{r}}</span>$</p>

    <p class="text-gray-300">The best choice of u to ensure the 128-bits security level is  <span class="math">2^{44} + 2^{22} - 2^9 + 2</span>  so that the Miller loop is made of 44 doubling steps and 3 addition steps. Extra lines computations requires one addition step and one Frobenius mapping (to compute  <span class="math">f_{3,Q}(P)^p</span> ) together with one  <span class="math">\\mathbb{F}_{p^{18}}</span>  multiplication (to multiply the result by  <span class="math">f_{u,Q}(P)</span> ), 2 Frobenius mappings and one incomplete addition step [AFCK+13]. Then its cost is</p>

    <p class="text-gray-300"><span class="math">$44(2M_3+7S_3+6M)+43(S_{18}+sM_{18})+4(11M_3+2S_3+6M)+4sM_{18}+M_{18}+3F_{18}+4M_3+6M+sM_{18}=9431M</span>$</p>

    <p class="text-gray-300">According [FKR11,AFCK+13], the final exponentiation requires  <span class="math">I_{18}+54M_{18}+8cS_{18}+29F_{18}=6785M+I</span>  in addition to the 7 exponentiation by u (because p has degree 8 in u). As u has length 44 and Hamming weight 4, each of these exponentiations requires 44 squarings and 3 multiplications. If the cyclotomic squaring are used, we need  <span class="math">44cS_{18}+3M_{18}=1908M</span> . If the compressed squaring technique is used, we additionally need the simultaneous decompression of 4 elements so that each exponentiation by u requires 1578M+I.</p>

    <p class="text-gray-300">The final exponentiation then requires 20141M + I or 17831M + 8I depending on the way to perform squarings. Finally computing the optimal ate pairing for KSS18 curve ensuring the 128-bits security level requires 29572M + I or 27262M + 8I.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">8.4 Comparison</h4>

    <p class="text-gray-300">Let us first summarize the complexities obtained in the previous subsections.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Using cyclotomic squarings</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Using compressed squarings</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Base field size</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19553M + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17774M + 4I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">461 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16003M + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14028M + 6I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">461 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26076M + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">340 bits</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29572M + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27262M + 8I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">348 bits</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 14.</strong>  <span class="math">\\mathbb{F}_p</span>  complexities of optimal ate pairing computation</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;We can obviously conclude that BLS12 curve is more efficient than BN one and that KSS16 is better than KSS18. It is more complicated to compare BLS12 and KSS16 because the base fields are not the same. For this, let us first compare the costs of M which is depending of p. As explained in Section 8.2, we assumed that we are working on a 32-bits architecture but the theoretical results would be similar with another choice and, in any case, this will not</p>

    <p class="text-gray-300">replace real life implementations. For BN and BLS12 curves, p has 461 bits so that 15 32-bits words are necessary. For the KSS curves, 11 32-bits words are necessary. As a consequence, we can assume that M = 15&lt;sup&gt;2&lt;/sup&gt; = 225 for BN and BLS12 curves while M = 11&lt;sup&gt;2&lt;/sup&gt; = 121 for KSS ones. Reporting these values in Table <a href="#page-22-0">14,</a> we get the comparative table <a href="#page-23-4">15.</a> In any case, the KSS16 curve gives the best result which was not expected at the beginning of this work. Of course</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Using cyclotomic Using compressed</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">squarings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">squarings</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4399425 + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3999150 + 4I</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3600675 + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3156300 + 6I</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3155196 + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">–</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KSS18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3578212 + I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3298702 + 8I</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 15. Comparative complexities of optimal ate pairing computation</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-4&quot;&gt;&lt;/span&gt;the complexity for the BLS12 curve using compressed squaring is very close to the complexity of the KSS16 curve with cyclotomic squarings and a practical implementation should be done to confirm the estimated result obtained here. But KSS16 curves have not been studied as much as the BN curves and, more generally, as curves having a degree 6 twist. Then we are quite confident that optimal pairing on the KSS16 curve given in section <a href="#page-18-0">7.1.3</a> can be improved for example by computing the formulas for compressed squaring in this case.</p>

    <h2 id="sec-38" class="text-2xl font-bold">Conclusion</h2>

    <p class="text-gray-300">It was already known that the BN curves, widely used in the literature for the 128-bits security level, do not ensure this security level because of the SexTNFS algorithm. In a recent paper, Menezes, Sarkar and Singh <a href="#page-26-13">[MSS16]</a> proposed new key sizes but their analysis is not precise enough. In this paper, we carefully estimated the complexity of this algorithm in the context of most common pairing families. We also explained why it is much more realistic than the one given in <a href="#page-26-13">[MSS16]</a> for any real life SexTNFS implementation. As a consequence, we give the updated security level of this curve which is in fact 100 bits. We also use this complexity estimation to determine the sizes of the finite field extensions that has to be used to ensure the 128, 192 and 256-bit security levels, and obtained values which are more than 66% larger than the formerly used ones. According to these recommendations, we generate new pairing parameters especially in the 128,192 and 256-bit security levels that are twist-secure (but also some that are twist and subgroup-secure). Finally, for the curves ensuring 128 bits of security we estimated the complexity of the optimal ate pairing for each proposed curve and concluded that BLS12 and, more surprisingly, KSS16 are the most efficient choices. Therefore we encourage the community to study more precisely these curves and to propose software or hardware implementation to confirm our conclusions. This study which is focused on the most popular families is probably not complete since other families and/or embedding degrees could be more interesting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-1&quot;&gt;&lt;/span&gt;ACMC&lt;sup&gt;+&lt;/sup&gt;16. G. Adj, I. Canales-Mart´ınez, N. C. Cortes, A. Menezes, T. Oliveira, L. Rivera-Zamarripa, and F. Rodr ´ ´ıguez-Henr´ıquez. Computing discrete logarithms in cryptographically-interesting characteristic-three finite fields. Cryptology ePrint Archive, Report 2016/914, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;Adl94. L. M. Adleman. The function field sieve. In <em>Algorithmic number theory symposium – ANTS I</em>, volume 877 of <em>Lecture notes in computer science</em>, pages 108–121, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-3&quot;&gt;&lt;/span&gt;AFCK&lt;sup&gt;+&lt;/sup&gt;13. D. F. Aranha, L. Fuentes-Castaneda, E. Knapp, A. Menezes, and F. Rodr ˜ ´ıguez-Henr´ıquez. Implementing pairings at the 192-bit security level. In <em>Pairing-Based Cryptography – PAIRING 2012</em>, volume 7708 of <em>Lecture notes in computer science</em>, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-2&quot;&gt;&lt;/span&gt;AFK&lt;sup&gt;+&lt;/sup&gt;07. K. Aoki, J. Franke, T. Kleinjung, A. Lenstra, and D. A. Osvik. A kilobit special number field sieve factorization. In <em>Advances in Cryptology – ASIACRYPT 2007</em>, volume 4833 of <em>Lecture notes in computer science</em>, pages 1–12, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-4&quot;&gt;&lt;/span&gt;AH99. L. M. Adleman and M. D. A. Huang. Function field sieve method for discrete logarithms over finite fields. <em>Information and Computation</em>, 151(1):5–16, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-15&quot;&gt;&lt;/span&gt;AKL&lt;sup&gt;+&lt;/sup&gt;11. D. Aranha, K. Karabina, P. Longa, C. H. Gebotys, and J Lopez. Faster explicit formulas for computing pairings over ´ ordinary curves. In <em>Advances in Cryptology EUROCRYPT 2011</em>, volume 6632 of <em>&quot;Lecture notes in computer science&quot;</em>, pages 48–68, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-6&quot;&gt;&lt;/span&gt;AMORH15. G. Adj, A. Menezes, T. Oliveira, and F. Rodriguez-Henriquez. Weakness of F36·&lt;sup&gt;1429&lt;/sup&gt; and F24·&lt;sup&gt;3041&lt;/sup&gt; for discrete logarithm cryptography. <em>Finite Fields and Their Applications</em>, 32:148–170, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-24&quot;&gt;&lt;/span&gt;BCM&lt;sup&gt;+&lt;/sup&gt;15. Paulo S. L. M. Barreto, Craig Costello, Rafael Misoczki, Michael Naehrig, Geovandro C. C. F. Pereira, and Gustavo Zanon. Subgroup security in pairing-based cryptography. In Kristin Lauter and Francisco Rodr´ıguez-Henr´ıquez, editors, <em>Progress in Cryptology – LATINCRYPT 2015: 4th International Conference on Cryptology and Information Security in Latin America, Guadalajara, Mexico, August 23-26, 2015, Proceedings</em>, pages 245–265, Cham, 2015. Springer International Publishing.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-23&quot;&gt;&lt;/span&gt;BD17. R. Barbulescu and S. Duquesne. Online supplement for &quot;updating keysizes of pairings&quot;., 2017. Downloadable from <a href="https://webusers.imj-prg.fr/~razvan.barbaud/Pairings/Pairings.html">https://webusers.imj-prg.fr/˜razvan.barbaud/Pairings/Pairings.html</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;BF01. D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. In <em>Advances in Cryptology – CRYPTO 2001</em>, volume 2139 of <em>Lecture notes in computer science</em>, pages 213–229, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-8&quot;&gt;&lt;/span&gt;BGGM14. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Discrete logarithms in GF(p 2 ) — 160 digits, 2014. Announcement available at the NMBRTHRY archives, item 004706.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-9&quot;&gt;&lt;/span&gt;BGGM15a. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In <em>Advances in Cryptology - EUROCRYPT 2015</em>, volume 9056 of <em>Lecture notes in computer science</em>, pages 129–155, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-11&quot;&gt;&lt;/span&gt;BGGM15b. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. New record in Fp&lt;sup&gt;3&lt;/sup&gt; , 2015. Available online at <a href="https://webusers.imj-prg.fr/~razvan.barbaud/p3dd52.pdf">https:</a> <a href="https://webusers.imj-prg.fr/~razvan.barbaud/p3dd52.pdf">//webusers.imj-prg.fr/˜razvan.barbaud/p3dd52.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-12&quot;&gt;&lt;/span&gt;BGI&lt;sup&gt;+&lt;/sup&gt;14. C. Bouvier, P. Gaudry, L. Imbert, H. Jeljeli, and E. Thome. Discrete logarithms in GF(p) — 180 digits, 2014. ´ Announcement available at the NMBRTHRY archives, item 004703.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-5&quot;&gt;&lt;/span&gt;BGJT14. R. Barbulescu, P. Gaudry, A. Joux, and E. Thome. A heuristic quasi-polynomial algorithm for discrete logarithm in ´ finite fields of small characteristic. In <em>Advances in Cryptology - EUROCRYPT 2014</em>, volume 8441 of <em>Lecture notes in computer science</em>, pages 1–16, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-10&quot;&gt;&lt;/span&gt;BGK15. R. Barbulescu, P. Gaudry, and T. Kleinjung. The tower number field sieve. In <em>Advances in Cryptology – ASIACRYPT 2015</em>, volume 9453 of <em>Lecture notes in computer science</em>, pages 31–55, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;BGW05. D. Boneh, C. Gentry, and B. Waters. Collusion resistant broadcast encryption with short ciphertexts and private keys. In <em>Advances in Cryptology - CRYPTO 2005</em>, volume 3621 of <em>Lecture notes in computer science</em>, pages 258–275, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-13&quot;&gt;&lt;/span&gt;BKK&lt;sup&gt;+&lt;/sup&gt;. J. Bos, M. Kaihara, T. Kleinjung, A. Lenstra, and P Montgomery. On the security of 1024-bit RSA and 160-bit elliptic curve cryptography. Cryptology ePrint Archive, Report 2009/389.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-22&quot;&gt;&lt;/span&gt;BL17. R. Barbulescu and A. Lachand. Some mathematical remarks on the polynomial selection in NFS. <em>Mathematics of Computation</em>, 86(303):397–418, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-20&quot;&gt;&lt;/span&gt;BLJP93. J. P. Buhler, H. Lenstra Jr., and C. Pomerance. Factoring integers with the number field sieve. In <em>The development of the number field sieve</em>, volume 1554 of <em>Lecture notes in mathematics</em>, pages 50–94. 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-16&quot;&gt;&lt;/span&gt;BLS03. P. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In <em>Security in Communication Networks</em>, volume 2576 of <em>Lecture notes in computer science</em>, pages 257–267, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;BLS04. D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. <em>Journal of cryptology</em>, 17(4):297–319, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-14&quot;&gt;&lt;/span&gt;BN05. P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In <em>Selected Areas in Cryptography–SAC 2005</em>, volume 3006 of <em>Lecture notes in computer science</em>, pages 319–331, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-7&quot;&gt;&lt;/span&gt;BP14. R. Barbulescu and C. Pierrot. The multiple number field sieve for medium- and high-characteristic finite fields. <em>LMS Journal of Computation and Mathematics</em>, 17:230–246, 2014. The published version contains an error which is corrected in version 2 available at <a href="https://hal.inria.fr/hal-00952610">https://hal.inria.fr/hal-00952610</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-21&quot;&gt;&lt;/span&gt;CEP83. E. R. Canfield, P. Erdos, and C. Pomerance. On a problem of Oppenheim concerning &quot;factorisatio numerorum&quot;. ¨ <em>Journal of Number Theory</em>, 17(1):1–28, 1983.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-19&quot;&gt;&lt;/span&gt;CH02. S. Cavallar Hedwig. <em>On the number field sieve integer factorisation algorithm</em>. PhD thesis, Universiteit Leiden, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-3&quot;&gt;&lt;/span&gt;Cop84. D. Coppersmith. Fast evaluation of logarithms in fields of characteristic two. <em>IEEE transactions in information theory</em>, 30(4):587–594, 1984.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-18&quot;&gt;&lt;/span&gt;Cop93. D. Coppersmith. Solving linear equations over GF(2): block Lanczos algorithm. <em>Linear algebra and its applications</em>, 192:33–60, 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-17&quot;&gt;&lt;/span&gt;Cop94. D. Coppersmith. Solving homogeneous linear equations over GF(2) via block Wiedemann algorithm. <em>Mathematics of Computation</em>, 62(205):333–350, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-7&quot;&gt;&lt;/span&gt;CS06. A. Commeine and I. Semaev. An algorithm to solve the discrete logarithm problem with the number field sieve. In <em>Public Key cryptography – PKC 2006</em>, volume 3958 of <em>Lecture notes in computer science</em>, pages 174–190, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-15&quot;&gt;&lt;/span&gt;CSF&lt;sup&gt;+&lt;/sup&gt;11. R. Cheung, S.Duquesne, J. Fan, N. Guillermin, I. Verbauwhede, and G. X. Yao. FPGA implementation of pairings using residue number system and lazy reduction. In <em>Cryptographic Hardware and Embedded Systems - CHES 2011</em>, volume 6917 of <em>Lecture notes in computer science</em>, pages 421–441, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-21&quot;&gt;&lt;/span&gt;Det14. J. Detrey. FFS factory: Adapting Coppersmith's &quot;factorization factory&quot; to the function field sieve. Cryptology ePrint Archive, Report 2014/419, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-22&quot;&gt;&lt;/span&gt;DMHR15. S. Duquesne, N. El Mrabet, S. Haloui, and F. Rondepierre. Choosing and generating parameters for low level pairing implementation on BN curves. Cryptology ePrint Archive, Report 2015/1212, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-14&quot;&gt;&lt;/span&gt;DSD07. A. J. Devegili, M. Scott, and R. Dahab. Implementing cryptographic pairings over Barreto-Naehrig curve. In <em>Pairing-based cryptography – Pairing 2007</em>, volume 4575 of <em>Lecture notes in computer science</em>, pages 197–207, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-24&quot;&gt;&lt;/span&gt;EMJ17. N. El Mrabet and M. Joye. <em>Guide to Pairing-Based Cryptography</em>. Chapman &amp; Hall/CRC Cryptography and Network Security Series. CRC Press, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-9&quot;&gt;&lt;/span&gt;FGHT17. J. Fried, P. Gaudry, N. Heninger, and E. Thomé. A kilobit hidden SNFS discrete logarithm computation. In <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>, volume 10210 of <em>Lecture notes in computer science</em>, pages 202–231, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-26&quot;&gt;&lt;/span&gt;FKR11. L. Fuentes-Castañeda, E. Knapp, and F. Rdríuez-Henríquez. Faster hashing to  <span class="math">\\mathbb{G}_2</span> . In <em>Selected Areas in Cryptography - SAC 2011</em>, volume 7118 of <em>Lecture Notes in Computer Science</em>, pages 412–430, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-13&quot;&gt;&lt;/span&gt;FST10. D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. <em>Journal of cryptology</em>, 23(2):224–280, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-17&quot;&gt;&lt;/span&gt;GAL&lt;sup&gt;+&lt;/sup&gt;13. G. Grewal, R. Azarderakhsh, P. Longa, S. Hu, and D. Jao. Efficient implementation of bilinear pairings on ARM processors. In <em>Selected Areas in Cryptography</em>, volume 7707 of <em>Lecture Notes in Computer Science</em>, pages 149–165, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-23&quot;&gt;&lt;/span&gt;GF16. L. Ghammam and E. Fouotsa. Adequate elliptic curves for computing the product of n pairings. In <em>Arithmetic of Finite Fields – WAIFI 2016</em>, volume 10064 of <em>Lecture notes in computer science</em>, pages 36–352, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-12&quot;&gt;&lt;/span&gt;GGMT17. L. Grémy, A. Guillevic, F. Morain, and E. Thomé. Computing discrete logarithms in GF( <span class="math">p^6</span> ). In <em>Selected Areas in Cryptography – SAC 2017</em>, Lecture notes in computer science, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;GGMZ13a. F. Göloğlu, R. Granger, G. McGuire, and J. Zumbrägel. Solving a 6120-bit DLP on a desktop computer. In <em>Selected Areas in Cryptography–SAC</em>, volume 8282 of <em>Lecture notes in computer science</em>, pages 136–152, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;GGMZ13b. F. Göloğlu, R. Granger, G. McGuire, and J. Zumbrägel. On the function field sieve and the impact of higher splitting probabilities: Application to discrete logarithms in  <span class="math">\\mathbb{F}_{2^{1971}}</span> , 2013. Cryptology ePrint Archive, Report 2013/074.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-11&quot;&gt;&lt;/span&gt;GGV16. P. Gaudry, L. Grémy, and M. Videau. Collecting relations in the number field sieve in GF(p&lt;sup&gt;6&lt;/sup&gt;). <em>LMS Journal of Computation and Mathematics</em>, 19(A):332–350, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-5&quot;&gt;&lt;/span&gt;GKZ14a. R. Granger, T. Kleinjung, and J. Zumbrägel. Breaking '128-bit secure' supersingular binary curves. In <em>Advances in cryptology – CRYPTO 2014</em>, volume 8617 of <em>Lecture notes in computer science</em>, pages 126–145, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;GKZ14b. R. Granger, T. Kleinjung, and J. Zumbrägel. On the powers of 2. Cryptology ePrint Archive, Report 2014/300, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-4&quot;&gt;&lt;/span&gt;GKZ17. R. Granger, T. Kleinjung, and J. Zumbrägel. On the discrete logarithm problem in finite fields of fixed characteristic. <em>Transactions of the American Mathematical Society</em>, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-8&quot;&gt;&lt;/span&gt;GMT16. A. Guillevic, F. Morain, and E. Thomé. Solving discrete logarithms on a 170-bit MNT curve by pairing reduction. In <em>Selected Areas in Cryptography – SAC 2016</em>, volume 10532 of <em>Lecture notes of computer science</em>, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-6&quot;&gt;&lt;/span&gt;Gor93. D. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discret. Math., 6(1):124–138, 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-25&quot;&gt;&lt;/span&gt;GS10. R. Granger and M. Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. In <em>Public Key Cryptography - PKC 2010</em>, volume 6056 of <em>Lecture notes in computer science</em>, pages 209–223, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-16&quot;&gt;&lt;/span&gt;GSNB11. C. C. F. Pereira Geovandro, M. A. Jr. Simplicio, M. Naehrig, and P. Barreto. A family of implementation-friendly BN elliptic curves. <em>Journal of Systems and Software</em>, 84(8):1319–1326, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-10&quot;&gt;&lt;/span&gt;HAKT15. K. Hayasaka, K. Aoki, T. Kobayashi, and T. Takagi. A construction of 3-dimensional lattice sieve for number field sieve over  <span class="math">GF(p^n)</span> . Cryptology ePrint Archive, Report 2015/1179, 2015. http://eprint.iacr.org/2014/300.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-20&quot;&gt;&lt;/span&gt;HSST12. T. Hayashi, T. Shimoyama, N. Shinohara, and T. Takagi. Breaking pairing-based cryptosystems using  <span class="math">\\eta_t</span>  pairing over  <span class="math">GF(3^{97})</span> . In <em>Advances in cryptology – ASIACRYPT 2012</em>, volume 7658 of <em>Lecture notes in computer science</em>, pages 43–60, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-18&quot;&gt;&lt;/span&gt;HSV06. F. Hess, N. Smart, and F. Vercauteren. The Eta pairing revisited. <em>IEEE Transactions on Information Theory</em>, 52(10):4595–4602, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-19&quot;&gt;&lt;/span&gt;HSW&lt;sup&gt;+&lt;/sup&gt;10. T. Hayashi, N. Shinohara, L. Wang, S. Matsuo, M. Shirase, and T. Takagi. Solving a 676-bit discrete logarithm problem in GF(3&lt;sup&gt;6n&lt;/sup&gt;). In <em>Public Key cryptography – PKC 2010</em>, volume 6056 of <em>Lecture notes in computer science</em>, pages 351–367, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;IEE17. IEEE. 1363.3-2013 - IEEE standard for identity-based cryptographic techniques using pairings, 2017. can be purchased online at http://ieeexplore.ieee.org/document/6662370/.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;ISO15. ISO. Iso/iec 18033-5:2015, 2015. can be purchased online at <a href="https://www.iso.org/obp/ui/#iso:std:59948:en">https://www.iso.org/obp/ui/#iso:std:</a> <a href="https://www.iso.org/obp/ui/#iso:std:59948:en">59948:en</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-12&quot;&gt;&lt;/span&gt;JK16. J. Jeong and T. Kim. Extended tower number field sieve with application to finite fields of arbitrary composite extension degree. Cryptology ePrint Archive, Report 2016/526, 2016. <a href="http://eprint.iacr.org/2016/526">http://eprint.iacr.org/2016/526</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;JL02. A. Joux and R. Lercier. The function field sieve is quite special. In <em>Algorithmic number theory symposium – ANTS V</em>, volume 2369 of <em>Lecture notes in computer science</em>, pages 431–445, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-7&quot;&gt;&lt;/span&gt;JL03. A. Joux and R. Lercier. Improvements to the general number field for discrete logarithms in prime fields. <em>Mathematics of Computation</em>, 72(242):953–967, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;JL06. A. Joux and R. Lercier. The function field sieve in the medium prime case. In <em>Advances in Cryptology –EUROCRYPT 2006</em>, volume 4005 of <em>Lecture notes in computer science</em>, pages 254–270, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-8&quot;&gt;&lt;/span&gt;JLSV06. A. Joux, R. Lercier, N. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In <em>Advances in Cryptology - CRYPTO 2006</em>, volume 4117 of <em>Lecture notes in computer science</em>, pages 326–344, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-4&quot;&gt;&lt;/span&gt;Jou13a. A. Joux. Faster index calculus for the medium prime case application to 1175-bit and 1425-bit finite fields. In <em>Advances in cryptology – EUROCRYPT 2013</em>, volume 7881 of <em>Lecture notes in computer science</em>, pages 177–193, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-5&quot;&gt;&lt;/span&gt;Jou13b. A. Joux. Faster index calculus for the medium prime case application to 1175-bit and 1425-bit finite fields. In <em>Advances in Cryptology – EUROCRYPT 2013</em>, volume 7881 of <em>Lecture notes in computer science</em>, pages 177–193, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-9&quot;&gt;&lt;/span&gt;JP13. A. Joux and C. Pierrot. The special number field sieve in Fp&lt;sup&gt;n&lt;/sup&gt; – application to pairing-friendly constructions. In <em>Pairing-Based Cryptography - Pairing 2013</em>, volume 8365 of <em>Lecture notes in computer science</em>, pages 45–61, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-6&quot;&gt;&lt;/span&gt;JP14. Antoine Joux and Cecile Pierrot. Improving the polynomial time precomputation of Frobenius representation discrete ´ logarithm algorithms. In <em>Advances in Cryptology – ASIACRYPT 2014</em>, volume 8873 of <em>Lecture notes in computer science</em>, pages 378–397, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-26&quot;&gt;&lt;/span&gt;Kar13. K. Karabina. Squaring in cyclotomic subgroups. <em>Mathematics of Computation</em>, 82(281), 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-11&quot;&gt;&lt;/span&gt;KB16. T. Kim and R. Barbulescu. The extended tower number field sieve: A new complexity for the medium prime case. In <em>Advances in Cryptology – CRYPTO 2016</em>, volume 9814 of <em>Lecture notes in computer science</em>, pages 543–571, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-18&quot;&gt;&lt;/span&gt;KBL14. T. Kleinjung, J. Bos, and A. Lenstra. Mersenne factorization factory. In <em>International Conference on the Theory and Application of Cryptology and Information Security</em>, volume 8873 of <em>Lecture notes in computer science</em>, pages 358–377, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-10&quot;&gt;&lt;/span&gt;KDL&lt;sup&gt;+&lt;/sup&gt;16. T. Kleinjung, C. Diem, A. Lenstra, C. Priplata, and C. Stahlke. Discrete logarithms in GF(p) — 768 bits, 2016. Announcement available at the NMBRTHRY archives, item 004917.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-17&quot;&gt;&lt;/span&gt;KSS08. E. J. Kachisa, E. F. Schaefer, and M. Scott. Constructing Brezing-Weng pairing-friendly elliptic curves using elements in the cyclotomic field. In <em>Pairing-Based Cryptography – Pairing 2008</em>, volume 5209 of <em>Lecture notes in computer science</em>, pages 126–135, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-19&quot;&gt;&lt;/span&gt;Lan52. C. Lanczos. Solution of systems of linear equations by minimized iterations. <em>J. Res. Nat. Bur. Standards</em>, 49(1):33–53, 1952.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-14&quot;&gt;&lt;/span&gt;Len01a. A. Lenstra. Unbelievable security matching AES security using public key systems. In <em>International Conference on the Theory and Application of Cryptology and Information Security</em>, volume 2188 of <em>Lecture notes in computer science</em>, pages 67–86, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-15&quot;&gt;&lt;/span&gt;Len01b. A. Lenstra. Unbelievable security: Matching AES security using public key systems. In <em>Advances in cryptology – ASIACRYPT 2001</em>, volume 2248 of <em>Lecture notes in computer science</em>, pages 67–86, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-24&quot;&gt;&lt;/span&gt;LL97. C. H. Lim and P. J. Lee. A key recovery attack on discrete log-based schemes using a prime order subgroup. In <em>Advances in Cryptology — CRYPTO '97</em>, volume 1294 of <em>Lecture notes in computer science</em>, pages 249–263, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-22&quot;&gt;&lt;/span&gt;LLJMP90. A. Lenstra, H. Lenstra Jr., M. Manasse, and J. Pollard. The number field sieve. In <em>Proceedings of the twenty-second annual ACM symposium on Theory of computing</em>, pages 564–572. ACM, 1990.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-16&quot;&gt;&lt;/span&gt;LN97. R. Lidl and H. Niederreiter. <em>Finite Fields</em>. Cambridge University Press, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-20&quot;&gt;&lt;/span&gt;LO90. B. LaMacchia and A. Odlyzko. Solving large sparse linear systems over finite fields. In <em>Advances in cryptology – CRYPTO 1990</em>, volume 537 of <em>Lecture notes in computer science</em>, pages 109–133, 1990.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-23&quot;&gt;&lt;/span&gt;Mat06. D. Matyukhin. Effective version of the number field sieve for discrete logarithms in the field GF(p k ) (in Russian). <em>Trudy po Discretnoi Matematike</em>, 9:121–151, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-25&quot;&gt;&lt;/span&gt;Mil04. V. Miller. The Weil pairing and its efficient calculation. <em>Journal of Cryptology</em>, 17(4):235–261, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-21&quot;&gt;&lt;/span&gt;Mon95. P. Montgomery. A block Lanczos algorithm for finding dependencies over GF(2). In <em>Advances in cryptology – EUROCRYPT 1995</em>, volume 95, pages 106–120. Springer, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;MPP&lt;sup&gt;+&lt;/sup&gt;. Dustin Moody, Rene C. Peralta, Ray A. Perlner, Andrew R. Regenscheid, Allen L. Roginsky, and Lidong Chen. Report on pairing-based cryptography-2015. can be freely downloaded from <a href="http://nvlpubs.nist.gov/nistpubs/jres/120/jres.120.002.pdf">http://nvlpubs.nist.gov/</a> <a href="http://nvlpubs.nist.gov/nistpubs/jres/120/jres.120.002.pdf">nistpubs/jres/120/jres.120.002.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-13&quot;&gt;&lt;/span&gt;MSS16. A. Menezes, P. Sarkar, and S. Singh. Challenges with assessing the impact of NFS advances on the security of pairing-based cryptography. In <em>Paradigms in cryptology – Mycrypt 2016</em>, volume 10311 of <em>Lecture notes in computer science</em>, 2016.</p></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-27-17&quot;&gt;&lt;/span&gt;Mur98. B. Murphy. Modelling the yield of number field sieve polynomials. In <em>Algorithmic number theory symposium– ANTS III</em>, volume 1423 of <em>Lecture notes in computer science</em>, pages 137–150, 1998.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;NA13. European Network and Information Security Agency. Algorithms, key sizes and parameters report - 2013, 2013.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-11&quot;&gt;&lt;/span&gt;NNS10. M. Naehrig, R. Niederhagen, and P. Schwabe. New software speed records for cryptographic pairings. In <em>Progress in cryptology – LATINCRYPT 2010</em>, volume 6212 of <em>Lecture notes in computer science</em>, pages 109–123, 2010.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-10&quot;&gt;&lt;/span&gt;oSN12. National Institute of Standards and Technology (NIST). NIST special publication 800-57 part 1 (revised) : Recommendation for key management, part 1: General (revised), July 2012. Publication available online at <a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">http://csrc.</a> <a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2\\_Mar08-2007.pdf</a>.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-5&quot;&gt;&lt;/span&gt;Pie15. C. Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In <em>Advances in Cryptology - EUROCRYPT 2015</em>, volume 9056 of <em>Lecture notes in computer science</em>, pages 156–170, 2015.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-20&quot;&gt;&lt;/span&gt;SBC&lt;sup&gt;+&lt;/sup&gt;09. M. Scott, N. Benger, M. Charlemagne, L. J. Dominguez Perez, and E. J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. In <em>Pairing-Based Cryptography - PAIRING 2009</em>, volume 5671 of <em>Lecture Notes in Computer Science</em>, pages 78–88, 2009.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;Sch93. O. Schirokauer. Discrete logarithms and local units. <em>Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences</em>, 345(1676):409–423, 1993.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;Sch00. O. Schirokauer. Using number fields to compute logarithms in finite fields. <em>Mathematics of Computation</em>, 69(231):1267– 1283, 2000.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-15&quot;&gt;&lt;/span&gt;Sch10. O. Schirokauer. The number field sieve for integers of low weight. <em>Mathematics of Computation</em>, 79(269):583–602, 2010.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-4&quot;&gt;&lt;/span&gt;Sem02. I. Semaev. Special prime numbers and discrete logs in finite prime fields. <em>Mathematics of Computation</em>, 71(237):363– 377, 2002.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;Sma12. N. Smart. ECRYPT II yearly report on algorithms and key sizes (2011-2012), 2012.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-14&quot;&gt;&lt;/span&gt;SS16a. P. Sarkar and S. Singh. Fine tuning the function field sieve algorithm for the medium prime case. <em>IEEE Transactions on Information Theory</em>, 62(4):2233–2253, 2016.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-8&quot;&gt;&lt;/span&gt;SS16b. P. Sarkar and S. Singh. A generalisation of the conjugation method for polynomial selection for the extended tower number field sieve algorithm. Cryptology ePrint Archive, Report 2016/537, 2016.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-6&quot;&gt;&lt;/span&gt;SS16c. P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>, pages 429–458, 2016.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-7&quot;&gt;&lt;/span&gt;SS16d. P. Sarkar and S. Singh. Tower number field sieve variant of a recent polynomial selection method. Cryptology ePrint Archive, Report 2016/401, 2016.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-12&quot;&gt;&lt;/span&gt;UW14. T. Unterluggauer and E. Wenger. Efficient pairings and ECC for embedded systems. In <em>Cryptographic Hardware and Embedded Systems - CHES 2014</em>, volume 8731 of <em>Lecture Notes in Computer Science</em>, pages 298–315, 2014.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-13&quot;&gt;&lt;/span&gt;Ver09. F. Vercauteren. Optimal pairings. <em>IEEE Transactions of Information Theory</em>, 56:455–461, 2009.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-19&quot;&gt;&lt;/span&gt;VLFR08. F. Valette, R. Lercier, P.-A. Fouque, and D. Real. Fault attack on elliptic curve Montgomery ladder implementation. In ´ <em>5th Workshop on Fault Diagnosis and Tolerance in Cryptography</em>, pages 92–98. IEEE, 2008.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-16&quot;&gt;&lt;/span&gt;Wie86. D. Wiedemann. Solving sparse linear equations over finite fields. <em>IEEE Trans. Inform. Theory</em>, 32(1):54–62, 1986.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-9&quot;&gt;&lt;/span&gt;Zaj10. Pavol Zajac. On the use of the lattice sieve in the 3D NFS. <em>Tatra Mountains Mathematical Publications</em>, 45(1):161–172, 2010.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-21&quot;&gt;&lt;/span&gt;ZL12. X. Zhang and D. Lin. Analysis of optimum pairing products at high security levels. In <em>Progress in Cryptology - INDOCRYPT 2012</em>, volume 7668 of <em>Lecture Notes in Computer Science</em>, pages 412–430, 2012.</p>

    <p class="text-gray-300">The size of the norms can by computed via numerical methods. Due to the known upper bounds we can certify that our results are correct up to an error probability of 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;128&lt;/sup&gt;, so that our chances to be wrong are equal to the chances of an attacker to break the system by pure luck.</p>

    <p class="text-gray-300">Given a polynomial f and a sieve parameter A let c(f, A) be the average of value of {log&lt;sup&gt;2&lt;/sup&gt; N&lt;sup&gt;f&lt;/sup&gt; (e) | e tuple in sieving domain} and U(f, A) an upper bound on the norms on the f side for pairs in the sieving domain. Let e1, . . ., e&lt;sup&gt;T&lt;/sup&gt; be random tuples in the sieving domain, uniformly and independently chosen. Then the Chernoff theorem applied to the random variables log&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;N&lt;/sup&gt;&lt;sup&gt;f&lt;/sup&gt; (e1) log&lt;sup&gt;2&lt;/sup&gt; U(f) ,. . ., log&lt;sup&gt;2&lt;/sup&gt; N&lt;sup&gt;f&lt;/sup&gt; (e&lt;sup&gt;T&lt;/sup&gt; ) log&lt;sup&gt;2&lt;/sup&gt; U(f) states that for any constant ε &gt; 0</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Prob}\\left(\\left|c(f,A) - +\\frac{1}{T}\\sum_{i=1}^{T}\\log_{2}N_{f}(e_{i})\\right| &lt; \\varepsilon\\log_{2}U(f,A)\\right) \\le 2e^{-2\\varepsilon^{2}T}.</span>$
(3)</p>

    <p class="text-gray-300">For ε = 0.05 we solve the equation e −2ε &lt;sup&gt;2&lt;/sup&gt;&lt;sup&gt;T&lt;/sup&gt; = 2&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;128&lt;/sup&gt; and obtain T = 25600.</p>

    <h2 id="sec-39" class="text-2xl font-bold">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;B One cannot change the complexity inside the frame of NFS</h2>

    <p class="text-gray-300">Variants of NFS where p is parametrized (SNFS, STNFS, SexTNFS, Joux-Pierrot) are considered to be the dream situation for an attacker. Fried et al. [FGHT17, Sec 4.1] made a series of arguments very similar to the arguments that we use below.</p>

    <p class="text-gray-300"><strong>Fact 1</strong> Let  <span class="math">p^n</span>  be a prime power and let  <span class="math">f, g \\in \\mathbb{Z}[x]</span>  two polynomials which have a common factor  <span class="math">\\varphi</span>  modulo p which is irreducible of degree n. A variant of NFS which uses these polynomials and find all relations in a time proportional to or larger than the size of the sieving space (enumeration or sieving) has complexity at least  <span class="math">L[32]^{1+o(1)}</span>  where  <span class="math">L[c] = \\exp(c^{1/3} \\log p^{n/3} \\log \\log(p^n)^{2/3})</span> .</p>

    <p class="text-gray-300">Argument:</p>

    <p class="text-gray-300"><strong>step 1</strong> We start by proving that  <span class="math">p^n</span>  divides the resultant of f and  <span class="math">g:p^n\\mid \\mathrm{Res}(f,g)</span> . Indeed, the resultant is the discriminant of the Sylvester matrix and further the volume of the lattice  <span class="math">L=f\\mathbb{Z}[x]+g\\mathbb{Z}[x]</span>  inside of  <span class="math">\\mathbb{Z}[x]</span> . Since  <span class="math">L&#x27;=p\\mathbb{Z}[x]+\\varphi\\mathbb{Z}[x]</span>  is a lattice which contains L we conclude that the volume of the latter divides the volume of the former:  <span class="math">p^n</span>  divides  <span class="math">\\mathrm{Res}(f,g)</span> .</p>

    <p class="text-gray-300"><strong>step 2</strong> Let  <span class="math">d_f</span>  and  <span class="math">d_g</span>  be the degrees of f and g and let E be the sieve parameter ( <span class="math">E = A^{\\eta}</span>  in STNFS and SexTNFS). We have  <span class="math">\\operatorname{Res}(f,g) \\leq d_f \\log_2 \\|g\\| + d_g \\log_2 \\|f\\|</span>  which creates the constraint</p>

    <p class="text-gray-300"><span class="math">$d_f \\log_2 ||g|| + d_g \\log_2 ||f|| \\ge n \\log_2 p.</span>$</p>

    <p class="text-gray-300">We easily compute the size of the norms as  <span class="math">\\log_2 \\|f\\| + \\log_2 \\|g\\| + (d_f + d_g) \\log_2 E</span> . At this point we note that we have to solve an optimization problem for which we set  <span class="math">K := \\log_2(p^n)</span>  and  <span class="math">\\log_2 E</span> , which are constants, and we set the variables  <span class="math">x_1 = d_f \\log_2 E</span> ,  <span class="math">x_2 = d_g \\log_2 E</span> ,  <span class="math">y_1 = \\max(1, \\log_2 \\|g\\|)</span>  et  <span class="math">y_2 = \\max(1, \\log_2 \\|f\\|)</span> . Hence the problem becomes:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\text{subject to } x_1y_1+x_2y_2 &amp;\\geq K\\\\ y_1,y_2 &amp;\\geq 1\\\\ x_1,x_2 &amp;\\geq \\log_2 E\\\\ \\text{minimize } x_1+y_1+x_2+y_2. \\end{aligned} \\tag{4}</span>$</p>

    <p class="text-gray-300">step 3 Put  <span class="math">F(x_1, y_1, x_2, y_2) = x_1y_1 + x_2y_2</span>  and  <span class="math">G(x_1, y_1, x_2, y_2) = x_1 + y_1 + x_2 + y_2</span> . The local extrema of G on an set where F is constant are obtained in one of the three situations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\nabla F \\parallel \\nabla G</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>One of the variables is on the boundary  <span class="math">(y_1 = 1, y_2 = 1, x_1 = \\log_2 E \\text{ or } x_2 = \\log_2 E)</span> , say  <span class="math">y_1 = 1</span> , and  <span class="math">\\nabla F \\mid_{\\{y_1 = 1\\}} \\parallel \\nabla G \\mid_{\\{y_1 = 1\\}}</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Two or more variables are on the boundary.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We check that all extrema of points (i) and (ii) are maxima, so we are left with case (iii) which further divides in four cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">y_1 = y_2 = 1</span>  i.e.  <span class="math">\\log_2 ||f|| \\le 1</span>  and  <span class="math">\\log_2 ||g|| \\le 1</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">x_1 = x_2 = \\log_2 E</span>  i.e.  <span class="math">d_f = d_g = 1</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">y_2 = 1</span>  and  <span class="math">x_1 = \\log_2 E</span>  i.e.  <span class="math">\\log_2 ||f|| \\le 1</span>  and  <span class="math">d_f = 1</span>  or vice-versa.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">x_1 = \\log_2 E</span>  and  <span class="math">y_1 = 1</span>  or the same for  <span class="math">x_2</span>  and  <span class="math">y_2</span> . This is the NFS case with  <span class="math">\\log_2 ||f|| = d_q = 1</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In case (1), the minimum is  <span class="math">x_1+x_2+y_1+y_2=K+2</span>  while in the case (2) the minimum is  <span class="math">2\\log_2 E+K/\\log_2 E</span> . In case (3) we find that the optimized expression becomes  <span class="math">x_2+(K-x_2\\log_2 E)+1+\\log_2 E</span>  whose minimum is obtained when  <span class="math">y_1=1</span>  and we are again in case (2). Finally, in case (4) we have  <span class="math">x_2y_2=K-1</span>  and we have to minimize  <span class="math">2+x_2+y_2</span> . This happens when  <span class="math">x_2=y_2=\\sqrt{K-1}</span>  and  <span class="math">x_1+y_1+x_2+y_2=2+2\\sqrt{K-1}</span> .</p>

    <p class="text-gray-300">We can now compare the local minima and conclude that the global minimum is</p>

    <p class="text-gray-300"><span class="math">$\\min G \\mid_{\\{F=K\\}} = 2 + 2\\sqrt{K - 1}.</span>$</p>

    <p class="text-gray-300">Note that the minimum is independent on the value of E.</p>

    <p class="text-gray-300">step 4 It is classical to estimate the cost of NFS as Bρ( log&lt;sup&gt;2&lt;/sup&gt; N log&lt;sup&gt;2&lt;/sup&gt; B ) + B&lt;sup&gt;2&lt;/sup&gt; where N is the norms product and ρ is Dickman's function, which is 2 + 2&lt;sup&gt;√&lt;/sup&gt; K − 1 ≈ 2 p log&lt;sup&gt;2&lt;/sup&gt; (p &lt;sup&gt;n&lt;/sup&gt;). Then the classical analysis of NFS leads to the complexity of SexTNFS: L[32]1+o(1) .</p>

    <p class="text-gray-300">Fried et al <a href="#page-25-9">[FGHT17]</a> noted that a multiple variant of SexTNFS is impossible, so it is safe to say that Figure <a href="#page-2-1">1</a> cannot contain a curve below the one used in this article to approximate the security of parametrized pairings.</p>

    <p class="text-gray-300">Practical improvements will continue to come but they will modify only the o(1) term. A hypothetical algorithm which would beat SexTNFS needs to produce relations faster than by enumerating all elements of a sieving space, as it happened in small characteristic with pinpointing, or it would have to completely abandon the NFS diagram. Such an algorithm would be a great discontinuity, comparable to a possible sub-exponential algorithm for DLP on elliptic curves.</p>

`;
---

<BaseLayout title="Updating key size estimations for pairings (2017/334)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/334
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="updating-key-size-estimations-for-pairings-2017" />
  </article>
</BaseLayout>
