---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/334';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Updating key size estimations for pairings';
const AUTHORS_HTML = 'Razvan Barbulescu, Sylvain Duquesne';

const CONTENT = `    <p class="text-gray-300">Razvan Barbulescu [ IMJ-PRG, UMR CNRS 7586, Univ Paris 6, Univ Paris 7 razvan.barbulescu@imj-prg.fr ] Sylvain Duquesne [ IRMAR, UMR CNRS 6625, Univ Rennes 1 sylvain.duquesne@univ-rennes1.fr ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Recent progress on NFS imposed a new estimation of the security of pairings. In this work we study the best attacks against some of the most popular pairings and propose new key sizes using an analysis which is more precise than the analysis in a recent article of Menezes, Sarkar and Singh. We also select pairing-friendly curves for standard security levels.</p>

    <h2 id="sec-3" class="text-2xl font-bold">Introduction</h2>

    <p class="text-gray-300">Pairing based cryptography has been introduced in the beginning of the century allowing new protocols that could not be realized otherwise such as identity based cryptography <em>[x1]</em>, short signature schemes <em>[x3]</em> or broadcast encryption <em>[x4]</em>. It has now many more practical applications in various fields. A pairing is a non degenerate bilinear map</p>

    <p class="text-gray-300"><span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{3}.</span></p>

    <p class="text-gray-300">It is usually realized thanks to elliptic curves. More precisely, the groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are subgroups or quotient groups of an elliptic curve defined over a finite field <span class="math">\\mathbb{F}_{q}</span> or one of its extensions and <span class="math">\\mathbb{G}_{3}</span> is a subgroup or a quotient group of <span class="math">\\mathbb{F}_{q^{k}}^{*}</span> where <span class="math">k</span> is called the embedding degree. A suitable pairing for cryptographic applications requires that the discrete logarithm problem is sufficiently difficult on these three groups. The security of pairings defined over <span class="math">\\mathbb{F}_{q}</span> having embedding degree <span class="math">k</span> and group order <span class="math">r</span> is determined by:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the cost of the discrete logarithm problem (DLP) on an order <span class="math">r</span> subgroup or quotient group of an elliptic curve defined over <span class="math">\\mathbb{F}_{q}</span> (the curve side);</li>

      <li>the cost of the DLP in a quotient of the multiplicative group of <span class="math">\\mathbb{F}_{q^{k}}</span> (the finite field side).</li>

    </ol>

    <p class="text-gray-300">The security evaluation on the curve side is simple: if <span class="math">s</span> is the desired level of security, we select <span class="math">r</span> such that <span class="math">\\log_{2}r\\geq 2s</span> because of Pollard’s rho algorithm (and by consequence <span class="math">\\log_{2}q\\geq 2s</span>).</p>

    <p class="text-gray-300">Attacks on the field side however are harder to estimate since the best algorithms belong to the Index Calculus family and their complexity is hard to write down explicitly. The recommended key sizes can be found in the reports of the standardization organizations : ISO <em>[x10]</em> , IEEE <em>[x13]</em>. The NIST hasn’t standardized pairing-based cryptography but it published reports <em>[MPP^{+}]</em> which do specify key sizes. The recommendations of ECRYPT <em>[x18]</em>, which were published by ENISA <em>[x16]</em>, corroborate with those of the ISO, the IEEE and the NIST.</p>

    <p class="text-gray-300">Since 2013 there have been a series of attacks on the field side of pairings of small characteristic which completely invalidated the use of these pairings. The classical algorithms, Coppersmith <em>[x7]</em> and the function field sieve <em>[x1]</em>, <em>[x2]</em>, <em>[x11]</em>, were replaced by algorithms of smaller complexity <em>[x15]</em>, <em>[x16]</em>, <em>[x10]</em>, followed by a heuristic quasi-polynomial algorithm <em>[x5]</em>. ENISA reacted immediately and in its standard document from October 2013 <em>[x16, page 32]</em> the agency forbid the use of small characteristic pairings. Improvements and records continued <em>[x10, x1]</em>, <em>[x1]</em> and a second quasi-polynomial algorithm was proposed <em>[x12, x13]</em>. Two record computations broke 128-bit pairings in characteristic 2 <em>[x12]</em> and respectively 3 <em>[ACMC^{+}16]</em>.</p>

    <p class="text-gray-300">In the case of non-small characteristic the best-known algorithm is the number field sieve <em>[x11]</em>, <em>[x14]</em>, <em>[x15]</em>, <em>[x16]</em>, <em>[x17]</em>, <em>[x18]</em>, <em>[x19]</em>. Since 2013 there have been a series of new variants and improvements <em>[x14]</em>, <em>[x2]</em>, <em>[x3]</em>, <em>[x4]</em>, <em>[x5]</em>, <em>[x13]</em>, <em>[x14]</em>, <em>[x6]</em>, <em>[x7]</em> and record computations <em>[x3]</em>, <em>[x4]</em>, <em>[x5]</em>, <em>[x10]</em>, <em>[x6]</em> and <em>[KDL^{+}16]</em>. The extended tower number field <em>[x15, x16]</em> changed considerably the complexity of the attacks and a precise analysis in the same article of a popular pairing, Baretto-Naehrig of 128 bits of security, showed that the key sizes must be reevaluated.</p>

    <p class="text-gray-300">The implementation of SexTNFS requires to code from scratch a subprogram which can be called "sieving in higher dimension". The first implementations of this subprogram [Zaj10], [HAKT15] and [GGV16], were all accompanied by algorithmic improvements, and the latest was used in a record computation [GGMT17]. The CADO-NFS software package  <span class="math">\\left[\\mathrm{BGI}^{+}14\\right]</span>  has a branch called nfs-hd which corresponds to sieving in higher dimension, but it could take years before its development is finished (CADO-NFS has more than 200000 lines of code and its development has already lasted 10 years, with continuous improvements in all the stages of NFS).</p>

    <p class="text-gray-300">The goal of this paper is to give a precise evaluation of the complexity of these algorithms in the absence of computational records. In the case of pairings, where the characteristic of the base field is parametrized by a polynomial, we obtain parameters sizes for the 128, 192 and 256-bits security levels and propose pairing-friendly curves which have this security. We compare our analysis to that of a contemporaneous article of Menezes, Sarkar and Singh [MSS16]. The cost of an attack with SexTNFS depends on the size of the norms of the algebraic numbers in the sieving domain. The two analysis differ in the way in which the size of the norms is estimated : in their approach the mathematical upper bound is used whereas we rely on the experimental values.</p>

    <p class="text-gray-300">Roadmap. After explaining the necessity of a new and more precise evaluation of key sizes in Section 1 we recall the most popular families of pairings in Section 2 and identify the best variant of NFS that an attacker can use against these families in Section 3. Then we estimate the best parameters by seeing it as an optimization problem (Section 4). At the end of the same section we explain the difference between the analysis of [MSS16] and that of this work. The proposal of new curves is done in three steps: first we solve the optimization problem on the precise case of the most popular pairings families and find what are the field sizes which correspond to 128, 192 and 256 bits of security (Section 5), then we search for curves of this size (Section 6) and finally we do an analysis even more precise than before for each of the curves we propose (Section 7). We conclude the article by estimating the complexity of an optimal ate pairing for the new curves proposed for 128 bits of security (Section 8).</p>

    <p class="text-gray-300">Whether the goal is to factor a composite integer  <span class="math">N</span>  or to compute discrete logarithms in a field of  <span class="math">p^n</span>  elements, NFS works in a similar manner. We select a number ring  <span class="math">\\mathbb{Z}_i</span> , which is simply  <span class="math">\\mathbb{Z}</span>  when factoring and is such that  <span class="math">p</span>  is inert for discrete logarithms. Then we select two polynomials  <span class="math">f, g \\in \\mathbb{Z}_i[x]</span>  having a common factor  <span class="math">\\varphi</span>  modulo  <span class="math">q</span> , where  <span class="math">q = N</span>  for factoring and  <span class="math">q = p</span>  for discrete logarithms. This allows to draw a commutative diagram which is the core of NFS:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">where  <span class="math">\\alpha_{f}</span>  and  <span class="math">\\alpha_{g}</span>  are roots of  <span class="math">f</span>  and  <span class="math">g</span>  in their number fields and where  <span class="math">\\mathcal{O}_f</span>  and  <span class="math">\\mathcal{O}_g</span>  are the rings of integers of these same number fields.</p>

    <p class="text-gray-300">The algorithm starts with a stage in which small polynomials  <span class="math">\\phi(x)</span>  are enumerated and put in the top of the diagram. What a small polynomial is changes from variant to variant but the degree and the coefficients are small, the simplest example being  <span class="math">\\phi(x) = a - bx</span>  with integers  <span class="math">a, b</span>  smaller in absolute value than some parameter. If  <span class="math">\\phi(\\alpha_f)</span>  and  <span class="math">\\phi(\\alpha_g)</span>  are  <span class="math">B</span> -smooth for a parameter  <span class="math">B</span>  (factor into ideals of norm less than  <span class="math">B</span> ) then we obtain a multiplicative relation in  <span class="math">\\mathbb{Z}_i[x] / \\langle q, \\varphi \\rangle</span> . At this step the two variants of NFS split: either one transforms multiplicative relations into linear equations and computes a right kernel to obtain a large number of discrete logarithms or one writes a matrix of valuations and computes a left kernel to obtain a non-trivial solution to the equation  <span class="math">x^2 \\equiv 1 \\mod N</span> . In both cases one finishes with a step of negligible cost.</p>

    <p class="text-gray-300">The classical variant of NFS has complexity  <span class="math">L_{Q}[64]^{1 + o(1)}</span>  where  <span class="math">Q = N</span>  or  <span class="math">p^n</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">L _ {Q} [ c ] = \\exp \\left((c / 9) ^ {\\frac {1}{3}} (\\log Q) ^ {\\frac {1}{3}} (\\log \\log Q) ^ {\\frac {2}{3}}\\right).</span></div>

    <p class="text-gray-300">Each of the variants of NFS requires its own complexity analysis but it is always of the form  <span class="math">L_{Q}[c]^{1 + o(1)}</span>  for some constant. Joux and Pierrot [JP13] invented a method of polynomial selection which obtains  <span class="math">c = 32</span>  for some finite fields where the characteristic  <span class="math">p</span>  has a special form. Barbulescu, Gaudry, Guillevic and Morain [BGGM15a] proposed new methods of polynomial selection which achieve  <span class="math">c = 48</span>  in some cases that are intractable with the previous method. Later Barbulescu, Gaudry and Kleinjung [BGK15] proposed to replace  <span class="math">\\mathbb{Z}</span>  by a larger number ring  <span class="math">\\mathbb{Z}_i</span>  and also obtained  <span class="math">c = 32</span>  for some finite fields, in particular proving that a popular pairings curve estimated to 128 bits can be the target of this variant. Finally, Kim and Barbulescu [KB16] showed how to use the new methods of polynomial selection together with the new choices of  <span class="math">\\mathbb{Z}_i</span>  and obtained  <span class="math">c = 32</span>  for a very large range of finite fields. It is reassuring to note that one can give arguments that one cannot go below the  <span class="math">c = 32</span>  constant (cf. Appendix B).</p>

    <p class="text-gray-300">o(1)-less estimation. What is the impact of these new constants in the complexity on the real-life security? To get a first idea one can start by dropping the  <span class="math">o(1)</span>  term, so that the cost of each variant of NFS is  <span class="math">2^{\\kappa}L_{Q}[c]</span>  where  <span class="math">\\kappa</span>  and  <span class="math">c</span>  are two constants. We use the same convention as in [Len01a, Section 2.4.6] and count a clock cycle as one operation. Thanks to real-life record computations we have a relatively good estimation of  <span class="math">\\kappa</span>  as summarized in Table 1 and we conclude on the security estimations in Figure 1. For those fields where the fastest variant applies it seems that we have to use 5004 bit fields for 128 bits of security and 12871 for 192 bits of security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">variant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">classical NFS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">classical MNFS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">composite n NFS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">composite n MNFS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SNFS</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">61.93</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">45.00</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">-8[KDL+16]</td>

            <td class="px-3 py-2 border-b border-gray-700">-8 [KDL+16]</td>

            <td class="px-3 py-2 border-b border-gray-700">-7[BGGM15a]</td>

            <td class="px-3 py-2 border-b border-gray-700">-7 [BGGM15a]</td>

            <td class="px-3 py-2 border-b border-gray-700">-7[AFK+07]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Value of  <span class="math">\\kappa</span>  to match the formula cost(NFS)=2  <span class="math">{}^{n}{L}_{Q}\\left\\lbrack  c\\right\\rbrack</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig.1. Modification of key sizes according to the o(1)-less formula.</p>

    <p class="text-gray-300">Note that the previous analysis is very similar to that of [MSS16, Section 6.2], but they didn't consider the curve corresponding to SexTNFS as they argue in Remark 4..</p>

    <p class="text-gray-300">The goal of this article is to go beyond the <span class="math">o(1)</span>-less estimation and to study in each case what is the best variant of NFS which applies, concluding on new key sizes. This type of estimations seem to be rare but we can note the works of Lenstra <em>[x13]</em> and of Bos et al. <em>[BKK+]</em> who evaluate the security of RSA, DSA and DH.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Families of pairing-friendly curves</h2>

    <p class="text-gray-300">Depending on the required embedding degree, some families of curves have been built <em>[x10]</em>. We recall here the most popular ones.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 BN curves</h3>

    <p class="text-gray-300">A BN curve <em>[x4]</em> is an elliptic curve <span class="math">E</span> defined over a finite field <span class="math">\\mathbb{F}_{p}</span>, <span class="math">p\\geq 5</span>, such that its order <span class="math">r</span> and <span class="math">p</span> are prime numbers parametrized by</p>

    <p class="text-gray-300"><span class="math">p=36u^{4}+36u^{3}+24u^{2}+6u+1,</span> <span class="math">r=36u^{4}+36u^{3}+18u^{2}+6u+1,</span></p>

    <p class="text-gray-300">for some well chosen <span class="math">u</span> in <span class="math">\\mathbb{Z}</span>. It has an equation of the form <span class="math">y^{2}=x^{3}+b</span>, where <span class="math">b\\in\\mathbb{F}_{p}^{<em>}</span>. BN curves have an embedding degree equal to <span class="math">12</span>. They were widely used for the <span class="math">128</span>-bit security level until the recent results on the discrete logarithm problem in <span class="math">\\mathbb{F}_{p^{12}}^{</em>}</span>. Indeed, a <span class="math">256</span>-bits prime <span class="math">p</span> leads to a <span class="math">256</span>-bits curve and to pairings taking values in <span class="math">\\mathbb{F}_{p^{12}}^{<em>}</span>, which is a <span class="math">3072</span>-bits multiplicative group. Both groups involved are then supposed to match the <span class="math">128</span>-bit security level according to the NIST recommendations </em>[x16]<em> (which are however now invalidate by </em>[x15]<em>). Incidentally, BN curves have been the object of numerous recent publications (</em>[x11,AKL+11,CSF+11,GSNB11,NNS10,GAL+13,UW14]*).</p>

    <p class="text-gray-300">Finally, BN curves always have order <span class="math">6</span> twists. If <span class="math">\\xi</span> is an element which is neither a square nor a cube in <span class="math">\\mathbb{F}_{p^{2}}</span>, the twisted curve <span class="math">E^{\\prime}</span> of <span class="math">E</span> is defined over <span class="math">\\mathbb{F}_{p^{2}}</span> by the equation <span class="math">y^{2}=x^{3}+b^{\\prime}</span> with <span class="math">b^{\\prime}=b/\\xi</span> or <span class="math">b^{\\prime}=b\\xi</span>. In order to simplify the computations, the element <span class="math">\\xi</span> should also be used to represent <span class="math">\\mathbb{F}_{p^{12}}</span> as a degree <span class="math">6</span> extension of <span class="math">\\mathbb{F}_{p^{2}}</span> (<span class="math">\\mathbb{F}_{p^{12}}=\\mathbb{F}_{p^{2}}[\\gamma]</span> with <span class="math">\\gamma^{6}=\\xi</span>) <em>[x11]</em>, <em>[x17]</em>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 BLS curves</h3>

    <p class="text-gray-300">BLS curves were introduced in <em>[x2]</em>. They are also defined over a parametrized prime field <span class="math">\\mathbb{F}_{p}</span> by an equation of the form <span class="math">y^{2}=x^{3}+b</span> and have a twist of order <span class="math">6</span> defined in the same way as BN curves. Contrary to BN curves, they do not have prime order but their order is divisible by a large parametrized prime <span class="math">r</span> and the pairing will be defined on the <span class="math">r</span>-torsions points. They are available for different embedding degrees but we are only interested here by the BLS12 and BLS24 families having embedding degrees <span class="math">12</span> and <span class="math">24</span> with respect to <span class="math">r</span>. Until now, they were used for the 192-bis security level <em>[AFCK+13]</em>. The parametrizations are given by</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{ll}\\text{BLS12}&\\text{BLS24}\\\\ p=(u-1)^{2}(u^{4}-u^{2}+1)/3+u&p=(u-1)^{2}(u^{8}-u^{4}+1)/3+u\\\\ r=u^{4}-u^{2}+1&r=u^{8}-u^{4}+1.\\end{array} \\]</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.3 KSS curves</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS curves are also available for different embedding degrees <em>[x14]</em>. If the required embedding degree is <span class="math">18</span>, this is very similar to BLS curves (same defining equation, degree 6 twist, parametrized primes <span class="math">p</span> and $r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\#E(\\mathbb{F}_{p})$). In this case, the parametrization is given by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">p=(u^{8}+5u^{7}+7u^{6}+37u^{5}+188u^{4}+259u^{3}+343u^{2}+1763u+2401)/21</span> <span class="math">r=(u^{6}+37u^{3}+343)/343.</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">If the required embedding degree is 16, the KSS16 curves are defined over a parametrized prime field  <span class="math">\\mathbb{F}_p</span>  by an equation of the form  <span class="math">y^{2} = x^{3} + ax</span>  and have a twist of order only 4. Again they do not have a prime order but it is divisible by a parametrized prime  <span class="math">r</span>  and the pairing will be defined on the  <span class="math">r</span> -torsions points. In this case, the parametrization is</p>

    <div class="my-4 text-center"><span class="math-block">p = \\left(u ^ {1 0} + 2 u ^ {9} + 5 u ^ {8} + 4 8 u ^ {6} + 1 5 2 u ^ {5} + 2 4 0 u ^ {4} + 6 2 5 u ^ {2} + 2 3 9 8 u + 3 1 2 5\\right) / 9 8 0</span></div>

    <div class="my-4 text-center"><span class="math-block">r = \\left(u ^ {8} + 4 8 u ^ {4} + 6 2 5\\right) / 6 1 2 5 0.</span></div>

    <p class="text-gray-300">Whatever the family, a curve is always obtained by finding a parameter  <span class="math">u</span>  such that both  <span class="math">p</span>  and  <span class="math">r</span>  are prime numbers. The curve and its twist are generated by finding suitable coefficients which can usually be chosen small. More details on the generation process are given in Section 6.</p>

    <p class="text-gray-300">There are several available pairings (Weil, Tate, ate, R-ate, ...) but the most efficient pairing is always the so-called optimal ate pairing [Ver09]. Let us recall this pairing in the context of ordinary elliptic curves defined over prime fields and more precisely in the case of the considered families.</p>

    <p class="text-gray-300">Let  <span class="math">E</span>  be an elliptic curve defined over the prime field  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">r</span>  be a prime divisor of  <span class="math">\\# E(\\mathbb{F}_p)</span>  and  <span class="math">k</span>  the embedding degree relatively to  <span class="math">r</span> . We also assume that  <span class="math">r^2 \\nmid p^k - 1</span>  to ensure the non-degeneracy of the pairing. Let  <span class="math">\\hat{E}</span>  be a degree  <span class="math">d</span>  twist of  <span class="math">E</span>  defined over  <span class="math">\\mathbb{F}_{p^e}</span>  where  <span class="math">e = k / d</span>  [HSV06]. The optimal ate pairing is defined over  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span>  and takes its values in  <span class="math">\\mathbb{G}_3</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{G}_1</span>  is the set of rational points on  <span class="math">E</span>  of order  <span class="math">r</span> .</li>

      <li><span class="math">\\mathbb{G}_2</span>  is the image of  <span class="math">\\hat{E} (\\mathbb{F}_{p^e})[r]</span>  in  <span class="math">E(\\mathbb{F}_{p^k})</span>  by the twisting isomorphism.</li>

      <li><span class="math">\\mathbb{G}_3</span>  is the order  <span class="math">r</span>  subgroup of  <span class="math">\\mathbb{F}_{p^k}^*</span></li>

    </ul>

    <p class="text-gray-300">For the considered parametrized curves, the optimal ate pairing of  <span class="math">P</span>  and  <span class="math">Q</span>  is mainly made of 2 parts. The first one (usually called the Miller loop) is the computation of  <span class="math">f_{u,Q}(P)</span> , where  <span class="math">u</span>  is (usually) the family parameter and the second one is an exponentiation to the power  <span class="math">\\frac{p^k - 1}{r}</span> . Assuming  <span class="math">\\ell_{A,B}</span>  denotes the line through points  <span class="math">A</span>  and  <span class="math">B</span> , the precise pairings are given in Table 2 [HSV06,Ver09].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Miller loop of P and Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">final exponent</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN</td>

            <td class="px-3 py-2 border-b border-gray-700">f6u+2,Q(P) · ℓ[6u+2]Q,[p]Q(P) · ℓ[6u+2+p]Q,[p3]Q(P)</td>

            <td class="px-3 py-2 border-b border-gray-700">(p12-1)/r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12</td>

            <td class="px-3 py-2 border-b border-gray-700">fu,Q(P)</td>

            <td class="px-3 py-2 border-b border-gray-700">(p12-1)/r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS16</td>

            <td class="px-3 py-2 border-b border-gray-700">(fu,Q(P) · ℓ[u]Q,[p]Q(P))p3 · ℓQ,Q(P)</td>

            <td class="px-3 py-2 border-b border-gray-700">(p16-1)/r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">fu,Q(P) · f3,Q(P)p · ℓ[u]Q,[3p]Q(P)</td>

            <td class="px-3 py-2 border-b border-gray-700">(p18-1)/r</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Optimal ate pairings</p>

    <p class="text-gray-300">An attacker who uses an algorithm of Index calculus type can make a series of choices: decide which algorithm and variant to use, make practical improvements, select polynomials, and optimize the main parameters. In this section we explain what are the reasonable choices for an attacker and give arguments to eliminate other choices.</p>

    <p class="text-gray-300">3.1 Choice of algorithm</p>

    <p class="text-gray-300">Let us make a list of the algorithms which can be implemented on a classical computer.</p>

    <p class="text-gray-300">We discard the FFS algorithm <em>[x1, x2, x12, x13]</em> and its pinpointing variant <em>[x16]</em> by estimating the size of the factor base. Indeed, when the target is <span class="math">\\mathbb{F}_{p^{k}}</span>, the factor base of FFS is formed of all the monic polynomials <span class="math">\\mathbb{F}_{p}[x]</span> of degree less than a parameter <span class="math">b</span>. This has been confirmed by implementations of FFS <em>[x12, HSW^{+}10, x14]</em> and pinpointing <em>[x16, x23]</em>. Hence the factor base has at least <span class="math">p</span> elements and then the linear algebra step has a cost of at least <span class="math">p^{2}</span> operations, which is more than the security on the curve side evaluated to <span class="math">p^{\\frac{1}{2}}</span> operations.</p>

    <p class="text-gray-300">We also discard the MNFS variants, i.e. the variants of NFS in which more than two sides are used. Indeed, the asymptotic complexity is close to that of NFS (<em>[x18]</em>, Table 2] so the “o(1)-less” extrapolation leads us to results which are similar to those of the classical case (see Figure 1). Detrey <em>[x6]</em> and Lenstra and al. <em>[x19]</em> made proof-of-concept implementations of FFS and NFS for factoring, which are similar to NFS for discrete logarithms. Their results seem to show that the crossing point between classical and MNFS variants of NFS is around 1000 bits, but the gain is small, say less than <span class="math">2</span> bits of security, so that we can ignore it in this article.</p>

    <p class="text-gray-300">The three variants of NFS, classical <em>[x10, x26, x19]</em>, TNFS <em>[x22, x3]</em> and JLSV <em>[x17]</em>, can be seen as particular cases of exTNFS <em>[x18]</em>, which remains the only algorithm to consider.</p>

    <p class="text-gray-300">When <span class="math">p</span> can be written as <span class="math">P(u)/v</span>, for some polynomial <span class="math">P\\in\\mathbb{Z}[x]</span> and some integers <span class="math">u</span> and <span class="math">v</span> (as it is the case for pairing applications), the polynomial selection is done differently and one of <span class="math">f</span> and <span class="math">g</span> has small coefficients. To emphasize this difference we give a different name to the algorithm by adding the letter S: the “special” variant of NFS is called SNFS, the special variant of exTNFS is called SexTNFS, the corresponding variant of TNFS is STNFS and the special variant of JLSV will be called S-JLSV or simply Joux-Pierrot. This case encompasses but is not restricted to low-weight primes <span class="math">p</span>, e. g. in an article <em>[x24]</em> discussing the complexity of NFS on numbers which are midway between having a general form (NFS) and a polynomial form.(SNFS), these numbers are described as ”low weigh numbers”.</p>

    <p class="text-gray-300">In order to fix the notations we recall the SexTNFS algorithm <em>[x18]</em>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial selection. Given a parameter <span class="math">\\eta</span>, chosen among the divisors of <span class="math">n</span>, one selects a polynomial <span class="math">h\\in\\mathbb{Z}[x]</span> of degree <span class="math">\\eta</span> which is irreducible modulo <span class="math">p</span>. Then one selects two polynomials <span class="math">f</span> and <span class="math">g</span> in <span class="math">\\mathbb{Z}[t,x]</span> so that <span class="math">f\\bmod\\langle h(t),p\\rangle</span> and <span class="math">g\\bmod\\langle h(t),p\\rangle</span>, seen as elements of <span class="math">\\mathbb{F}_{p^{\\eta}}[x]</span>, have a common factor <span class="math">\\varphi(x)</span> which is irreducible of degree <span class="math">\\kappa:=k/\\eta</span>. In the particular case <span class="math">\\gcd(\\eta,\\kappa)=1</span> we can take <span class="math">f,g\\in\\mathbb{Z}[x]</span> which share an irreducible factor of degree <span class="math">\\kappa</span>, whereas in the case <span class="math">\\gcd(\\eta,\\kappa)\\neq 1</span> we have to guarantee that <span class="math">f</span> and <span class="math">g</span> are not defined over a proper subfield of the number field of <span class="math">h</span>.</li>

      <li>Sieve. Given two parameters <span class="math">A</span> and <span class="math">B</span>, one collects all (up to sign) the degree 1 polynomials in <span class="math">\\mathbb{F}_{p^{k}}[x]</span> or equivalently tuples in the set <span class="math">\\{(a_{0},\\ldots,a_{\\eta-1},b_{0},\\ldots,b_{\\eta-1}\\in[-A,A]^{2\\eta}\\mid a_{0}\\geq 0\\}</span>, called sieving domain, so that <span class="math">N_{f}</span> and <span class="math">N_{g}</span> are <span class="math">B</span>-smooth (all prime factors are less than <span class="math">B</span>), where</li>

    </ol>

    <p class="text-gray-300"><span class="math">N_{f}=\\operatorname{Res}_{t}\\left(\\operatorname{Res}_{x}\\left(\\sum_{i=0}^{\\eta-1}a_{i}t^{i}-x\\sum_{i=0}^{\\eta-1}b_{i}t^{i},f(t,x)\\right),h(t)\\right)</span></p>

    <p class="text-gray-300">is the norm on the <span class="math">f</span> side, and similarly for <span class="math">g</span> instead of <span class="math">f</span>. In order to emphasize the analogy with the simpler variants of NFS, we put <span class="math">E=A^{\\eta}</span> which is a good approximation of the square root of the cardinality of the sieving domain.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Filtering. Unknowns which occur in a single relation are called singletons and are deleted together with the corresponding equation. Additionally, using elementary transformations of the matrix one can create new singletons. This leads to a smaller matrix and hence a faster resolution of the linear system.</li>

      <li>Linear algebra step. One computes the right kernel of the sparse matrix obtained after the filtering using the Wiedemann algorithm <em>[x29]</em> or the Lanczos algorithm <em>[x15, x11]</em> or their block variants <em>[x10]</em> and <em>[x10, x21]</em>. The coordinates of the kernel vector are called virtual logarithms.</li>

      <li>Individual logarithms. Given a generator <span class="math">g</span> of <span class="math">\\mathbb{F}_{p^{n}}</span> and an element <span class="math">h</span>, compute the discrete logarithm <span class="math">\\log_{g}h</span> using the virtual logarithms.</li>

    </ol>

    <p class="text-gray-300">Although the complexity of NFS for DLP in  <span class="math">\\mathbb{F}_p</span>  hasn't changed for almost 30 years, its real-life speed has been improving continuously. In the jargon of the NFS community an improvement which changes only the  <span class="math">o(1)</span>  term in the complexity is called a practical improvement.</p>

    <p class="text-gray-300">3.2.1 Filtering. If an ideal occurs in a single relation then we can erase this ideal and its relation from the matrix. Thanks to the exceeding number of relations compared to the cardinality of the factor base, one can erase rows and do linear operations on the rows in order to create new singletons [CH02, Ch 3]. Table 3 summarizes how does the filtering behave in practice. It is hard to compare the different rows of the table because the authors of different records made different choices, some of which collected much more relations than needed (oversieved) and hence helped the filtering step reduce considerably the matrix.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">record</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rows before filtering</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rows after filtering</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">reduction factor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-1039 (factor)</td>

            <td class="px-3 py-2 border-b border-gray-700">13.8G</td>

            <td class="px-3 py-2 border-b border-gray-700">82.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">167</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-768 (factor)</td>

            <td class="px-3 py-2 border-b border-gray-700">47.7G</td>

            <td class="px-3 py-2 border-b border-gray-700">192.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">247</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FFS-809</td>

            <td class="px-3 py-2 border-b border-gray-700">67.4M</td>

            <td class="px-3 py-2 border-b border-gray-700">3.6M</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-1024 (DLP)</td>

            <td class="px-3 py-2 border-b border-gray-700">249M</td>

            <td class="px-3 py-2 border-b border-gray-700">28M</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-768 (DLP)</td>

            <td class="px-3 py-2 border-b border-gray-700">9.0G</td>

            <td class="px-3 py-2 border-b border-gray-700">23.5M</td>

            <td class="px-3 py-2 border-b border-gray-700">382</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Behavior of filtering in practice</p>

    <p class="text-gray-300">We made an asymptotic estimation of the number of ideals which might be used to reduce the matrix and we obtained the following statement.</p>

    <p class="text-gray-300">Conjecture 1. In the filtering step of NFS one reduces the matrix by a factor  <span class="math">(\\log B)^{1 + o(1)}</span> , where  <span class="math">B</span>  is the smoothness bound.</p>

    <p class="text-gray-300">Justification: Let  <span class="math">\\mathfrak{q}</span>  be an ideal in the factor base of NFS lying above a prime  <span class="math">q</span>  and let  <span class="math">N</span>  denote the size of the norms product and  <span class="math">B</span>  the smoothness bound. We shall argue that the following statements are true:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">q &amp;lt; B / (\\log B)^{1 + \\epsilon}</span>  with  <span class="math">\\epsilon &amp;gt; 0</span>  then  <span class="math">\\mathfrak{q}</span>  occurs in a number of relations which tends to infinity as  <span class="math">B</span>  and  <span class="math">N</span>  go to infinity.</li>

      <li>If  <span class="math">q &amp;gt; B / (\\log B)^{1 - \\epsilon}</span>  with  <span class="math">\\epsilon &amp;gt; 0</span>  then  <span class="math">\\mathfrak{q}</span>  will occur in a number of relations which tends to 0 as  <span class="math">B</span>  and  <span class="math">N</span>  go to infinity.</li>

    </ol>

    <p class="text-gray-300">The sieving domain has  <span class="math">B^2</span>  elements (parameter tuning in NFS implies  <span class="math">E = B</span>  where  <span class="math">E</span>  is the square root of the number of sieved pairs [BLJP93]) and a proportion of  <span class="math">1/q</span>  are divisible by  <span class="math">\\mathfrak{q}</span> . They produce relations if the cofactor of size  <span class="math">N/q</span>  is  <span class="math">B</span> -smooth, for which we have no proven formula, but which is approximated by the proportion of integers in the interval  <span class="math">[1, N/q]</span>  which are  <span class="math">B</span> -smooth. Due to the theorem of Canfield, Erdős and Pomerance [CEP83] this proportion is  <span class="math">\\rho\\left(\\frac{\\log(N/q)}{\\log B}\\right)</span>  where  <span class="math">\\rho</span>  is Dickman's function, i.e. the function such that  <span class="math">\\rho(v) = 1</span>  for  <span class="math">v \\leq 1</span>  and  <span class="math">\\rho&#x27;(v) = -\\rho(v - 1)/v</span>  for  <span class="math">v &amp;gt; 1</span> .</p>

    <p class="text-gray-300">number of relations where  <span class="math">\\mathfrak{q}</span>  occurs  <span class="math">\\approx B^2 / q \\cdot \\rho\\left(\\frac{\\log(N / q)}{\\log B}\\right)</span> .</p>

    <p class="text-gray-300">Recall that in NFS we set  <span class="math">B</span>  so that  <span class="math">\\rho\\left(\\frac{\\log N}{\\log B}\\right)^{-1} = B</span>  (once again see [BLJP93]). We put  <span class="math">v = \\frac{\\log N}{\\log B}</span> , so that we have  <span class="math">\\log B = v \\log v</span> ,  <span class="math">\\log N = v^2 \\log v</span>  and  <span class="math">q &amp;gt; B / v^{1 + 2\\epsilon}</span>  (resp.  <span class="math">q &amp;lt; B / v^{1 - 2\\epsilon}</span> ). We replace all variables on the right hand side by their expressions in terms of  <span class="math">v</span>  and obtain that its logarithm is equivalent to  <span class="math">v^{1 + \\epsilon} - v</span> . It tends to  <span class="math">\\infty</span>  if  <span class="math">\\epsilon &amp;gt; 0</span>  so</p>

    <p class="text-gray-300">the ideals of norm  <span class="math">q &amp;lt; B / (\\log B)</span>  occur in a very large number of relations and are unlikely to create singletons, so they are not erased during filtering. The right hand side tends to  <span class="math">-\\infty</span>  if  <span class="math">\\epsilon &amp;lt; 0</span>  so the ideals of norm  <span class="math">q &amp;gt; B / \\log (B)</span>  occur in almost no relations, and are very likely to be used during filtering.</p>

    <p class="text-gray-300">Hence the filtering erases most of the ideals of norm larger than  <span class="math">B / (\\log B)^{1 + o(1)}</span>  and keeps all but a negligible fraction of the others, so that the matrix size is reduced by a factor  <span class="math">(\\log B)^{1 + o(1)}</span> .</p>

    <p class="text-gray-300">It seems then plausible that the filtering gain is a constant times  <span class="math">\\log (B)</span> , and by comparing it with Table 3 we model the gain by  <span class="math">\\log_2 B</span> .</p>

    <p class="text-gray-300">3.2.2 Exploiting automorphisms. Record computations with FFS [HSW+10,HSST12] and NFS [BGGM15a] showed that if the target field is of the form  <span class="math">p^{\\kappa \\eta}</span>  for two integers  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  so that  <span class="math">\\kappa</span>  is small, then one can gain a factor  <span class="math">\\kappa</span>  in the sieve and a factor  <span class="math">\\kappa^2</span>  in the linear algebra.</p>

    <p class="text-gray-300">Kim and Barbulescu [KB16] explained that one has a similar gain in SexTNFS, where  <span class="math">\\kappa</span>  is to be replaced by  <span class="math">\\mathcal{A}</span> , the number of automorphisms of  <span class="math">h</span>  which fix  <span class="math">g</span>  times the number of automorphisms of  <span class="math">g</span> . If  <span class="math">\\kappa = 1</span>  and  <span class="math">h</span>  has  <span class="math">\\eta</span>  automorphisms then the exact number of automorphisms is  <span class="math">\\mathcal{A} = \\eta</span> , e.g.  <span class="math">\\mathcal{A} = \\ell - 1</span>  if  <span class="math">h = \\Phi_{\\ell}</span> , the  <span class="math">\\ell</span> -th cyclotomic polynomial, for some prime  <span class="math">\\ell</span> . If  <span class="math">\\kappa = 2</span>  one doubles the number of automorphisms thanks to the automorphisms of  <span class="math">g</span> . For example if  <span class="math">h = \\Phi_7</span>  and  <span class="math">g = x^2 + \\alpha x + \\beta + t^4 + t^2 + t - u</span>  for some integers  <span class="math">\\alpha, \\beta</span>  then  <span class="math">\\mathcal{A} = 6</span>  because any automorphism in the set  <span class="math">\\{\\tau^i \\sigma^j, 0 \\leq i \\leq 1, 0 \\leq j \\leq 2\\}</span>  can be used (here  <span class="math">\\sigma : t \\mapsto t^2</span>  and  <span class="math">\\tau : x \\mapsto -\\alpha - x</span> ). Finally, if  <span class="math">\\kappa = 3</span>  and  <span class="math">\\eta = 4</span>  an attacker might use  <span class="math">h = \\phi_8</span>  and find polynomials  <span class="math">g</span>  which have three automorphisms, so for a worst case analysis we count  <span class="math">\\mathcal{A} = 12</span> .</p>

    <p class="text-gray-300">The polynomial selection consists of selecting  <span class="math">h</span> ,  <span class="math">f</span>  and  <span class="math">g</span> .</p>

    <p class="text-gray-300">3.3.1 Choice of  <span class="math">h</span> . The polynomial  <span class="math">h \\in \\mathbb{Z}[x]</span>  has two constraints, its degree is  <span class="math">\\eta</span>  and it is irreducible modulo  <span class="math">p</span> . Among the possible choices we select those having small norms for  <span class="math">N_f</span>  and  <span class="math">N_g</span> , which generally corresponds to the case when  <span class="math">h</span>  has small coefficients. In all examples we could select  <span class="math">h</span>  with coefficients in  <span class="math">\\{0, -1, 1\\}</span>  and experiments confirmed that the best choice is never much better than  <span class="math">h = t^\\eta - t - 1</span> .</p>

    <p class="text-gray-300">In Section 3.2.2 we saw that in order to use the Galois automorphisms the attacker has to find a polynomial  <span class="math">h</span>  with non-trivial automorphisms. We ran an exhaustive search on the polynomials in  <span class="math">\\mathbb{Z}[x]</span>  of degree less than 19 having coefficients less than 6 in absolute value. In this set, the only polynomials that have automorphisms of order different from 2 are those listed in Table 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">polynomials</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ7, Φ9, Φ14, Φ18</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ13, Φ26</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ17, Φ34</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ19, Φ38</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 4. List of all monic polynomials  <span class="math">h \\in  \\mathbb{Z}\\left\\lbrack  x\\right\\rbrack</span>  of degree between 6 and 20 such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq  {10}<span class="math">  and  </span>{Aut}\\left( h\\right)$  has elements of order larger than 2 .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3.3.2 Construction of  <span class="math">f</span>  and  <span class="math">g</span> . One produces a large number of pairs of polynomials using one of the following methods: base-m [BLJP93], base-m-SNFS [LLJMP90], Joux-Pierrot [JP13], Conjugation [BGGM15a], JLSV1 [JLSV06, Section 2.3], GJL [BGGM15a,Mat06], algorithms A,B,C or D of Sarkar and Singh [SS16c,SS16d,SS16b].</p>

    <p class="text-gray-300">In this article we focus on families of pairings where  <span class="math">p</span>  is parametrized, then one choice of polynomials is by far the most natural. Let  <span class="math">P(x) \\in \\mathbb{Z}[x]</span>  and the integers  <span class="math">u, v</span>  be such that  <span class="math">p = P(u) / v</span> . Then one can take  <span class="math">f = P(x^{\\kappa} + S(t,x))</span>  and  <span class="math">g = x^{\\kappa} + S(t,x) - u</span>  for some  <span class="math">S \\in \\mathbb{Z}[t,x]</span>  of degree in  <span class="math">x</span>  less than  <span class="math">\\kappa</span>  so that  <span class="math">g</span>  is irreducible in  <span class="math">(\\mathbb{F}_p[t] / h)[x]</span> . In most</p>

    <p class="text-gray-300">cases this is the only choice but for instance in the case of KSS 18 one can also take  <span class="math">f = P(x - 2)</span>  and  <span class="math">g = x - 2 - u</span> , with a non-negligible effect on the complexity estimation.</p>

    <p class="text-gray-300">How can we be sure that the attacker cannot find choices of  <span class="math">f</span>  that we could not predict? See [FGHT17] for a discussion about the consequences of this question on discrete logarithms in  <span class="math">\\mathbb{F}_p</span> . The attacker cannot use the fastest versions of NFS (SNFS, STNFS, SexTNFS, Joux-Pierrot) unless he finds three polynomials,  <span class="math">T(x,y) \\in \\mathbb{Z}[x,y]</span>  and  <span class="math">U, V \\in \\mathbb{Z}(x)</span>  whose coefficients are bounded by an absolute constant, so that  <span class="math">p = T(U(u),V(u))</span>  for some integer  <span class="math">u</span> , in which case he sets</p>

    <div class="my-4 text-center"><span class="math-block">f = T (x) \\text {a n d} g = V (u) x - U (u).</span></div>

    <p class="text-gray-300">In the case of SexTNFS, the coefficients of  <span class="math">f</span>  occur at large powers in the norms and hence we can restrict the search to very small constants. We ran the exhaustive search and obtained that the only alternative choices are  <span class="math">f = P(x - 1)</span>  for KSS 16,  <span class="math">f = P(x - 2)</span>  for KSS 18 and  <span class="math">f = 4x^4 - 4x^3 + 12x^2 - 10x + 7</span>  and  <span class="math">g = x - (3u + 1)</span>  for BN. In the rest of the security evaluation we considered the alternative choices together with the natural ones.</p>

    <p class="text-gray-300">3.3.3 Optimization. Murphy [Mur98] introduced a map  <span class="math">\\alpha : \\mathbb{Q}[x] \\to \\mathbb{R}</span>  which allows to decide which are the best polynomials for NFS. Barbulescu and Lachand [BL17] proved, when  <span class="math">f</span>  is quadratic of fundamental negative discriminant, that for a random pair of relatively prime integers the norm  <span class="math">N = \\operatorname{Res}_x(a - bx, f)</span>  has the same probability to be  <span class="math">B</span> -smooth (for a parameter  <span class="math">B</span> ) as a random integer less than  <span class="math">e^{\\alpha(f)}N</span> . Because of the uncertainty on  <span class="math">\\alpha</span>  we cannot predict the exact cost of a DLP computation with NFS. In the previous paragraph we saw that in the case of parametrized pairings we only have one or two choices of  <span class="math">f</span>  and  <span class="math">g</span> . For each choice we verify directly that  <span class="math">\\alpha(f) \\approx 0</span>  whereas for linear polynomials the value of  <span class="math">\\alpha</span>  is constant equal to 0.56..., which is also the average value of  <span class="math">\\alpha</span>  on all polynomials [BL17].</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}_{p^n}</span>  where the characteristic is parametrized by a polynomial  <span class="math">P(u) / v</span>  of degree  <span class="math">d</span> , we decided to use SexTNFS with  <span class="math">f = P(x^{\\kappa} + S(t,x))</span>  and  <span class="math">g = x^{\\kappa} + S(t,x) - u</span>  for some polynomial  <span class="math">S</span>  of degree in  <span class="math">x</span>  less than  <span class="math">n</span> . We also decided to use, if possible,  <span class="math">h</span>  from Table 4 and otherwise  <span class="math">h = t^{n / \\kappa} - t - 1</span>  because it is the simplest one and then the one providing the smallest norms. This choice is the best possible for the attacker. At this point we need to decide which value of  <span class="math">\\kappa</span>  to use and to optimize parameters  <span class="math">A</span>  and  <span class="math">B</span> .</p>

    <p class="text-gray-300">According to [KB16, Section 4.1] the parameter  <span class="math">\\kappa</span>  is chosen to minimize the norms product  <span class="math">N_{f}N_{g}\\approx E^{(d + 1)\\kappa}Q^{\\frac{1}{d\\kappa}}</span> , where  <span class="math">E</span>  is the square root of the cardinality of the sieve space and  <span class="math">Q</span>  is  <span class="math">p^n</span> . This corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa \\approx \\sqrt {\\frac {\\log_ {2} Q}{d (d + 1) \\log_ {2} E}}.</span></div>

    <p class="text-gray-300">It was useful for us to guess the optimal value of  <span class="math">\\kappa</span> , which is the most likely to be optimal, but we do nevertheless an exhaustive search. Our method was to approximate  <span class="math">\\log_2 Q</span>  from Figure 1 and to take  <span class="math">E^2 = 2^s</span>  where  <span class="math">s</span>  is the security level, which leads to Table 5. We verified that in every case the best value is in this table.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=10</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">2 or 3</td>

            <td class="px-3 py-2 border-b border-gray-700">1 or 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 or 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">2 or 3</td>

            <td class="px-3 py-2 border-b border-gray-700">1 or 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 or 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 or 2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Rule of thumb values for  <span class="math">\\kappa</span>  . Here  <span class="math">d</span>  is the degree of the polynomial  <span class="math">P\\left( x\\right)</span>  such that  <span class="math">p = P\\left( u\\right)</span>  for some integer  <span class="math">u</span>  .</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.2 Optimization of the bounds <span class="math">A</span> and <span class="math">B</span>.</h3>

    <p class="text-gray-300">As before <span class="math">B</span> denotes the smoothness bound and <span class="math">A</span> the bound on the coefficients of the sieved polynomials. A pair of values is valid if the sieve produces enough relations, so we need to estimate the number of relations. The sieving space is formed of the pairs <span class="math">a(t),b(t)</span> in <span class="math">\\mathbb{Z}(t)/h</span> so that <span class="math">\\deg a,\\deg b\\leq\\eta-1</span>. If <span class="math">\\mu(t)</span> is a root of unity of the number field of <span class="math">h</span> then the pairs <span class="math">(\\mu a,\\mu b)</span> and <span class="math">(a,b)</span> give the same multiplicative relation. In Section 3.1 we restricted <span class="math">a_{0}</span> to positive values to account for the unit <span class="math">-1</span>, here the sieving space shrinks further by the number of roots of unity divided by two.</p>

    <p class="text-gray-300"><span class="math">\\text{sieving space}=(2A+1)^{2\\eta}/(2w),</span></p>

    <p class="text-gray-300">where <span class="math">w</span> is the index of <span class="math">\\{1,-1\\}</span> in the group of roots of unity. By a Monte Carlo integration (Appendix A) we estimate the bit size of the norms: we considered random tuples <span class="math">(a_{0},\\ldots,a_{\\eta-1},b_{0},\\ldots,b_{\\eta-1})</span> each of the components being uniformly chosen in the interval <span class="math">[-A,A]</span>. We call bit size of the norms the arithmetic mean of the bits sizes of the norms for each tuple in a sample of 25600 tuples (see Appendix A for more details). We emphasize that we average the logarithms <span class="math">\\log_{2}(N_{f})</span> and <span class="math">\\log_{2}(N_{g})</span>, rather than <span class="math">N_{f}</span> and <span class="math">N_{g}</span>, because the logarithms are used to compute the smoothness probabilities <span class="math">p_{f}=\\rho\\left(\\frac{\\log_{2}N_{f}}{\\log_{2}B}\\right)</span> and <span class="math">p_{g}=\\rho\\left(\\frac{\\log_{2}N_{g}}{\\log_{2}B}\\right)</span>. This gives us the total number of relations which is</p>

    <p class="text-gray-300"><span class="math">\\text{relations = (sieving space)}\\cdot p_{f}\\cdot p_{g}.</span></p>

    <p class="text-gray-300">The factor base is formed of the prime ideals of norm less than <span class="math">B</span> in the number fields of <span class="math">f</span> and <span class="math">g</span>, so the cardinality of the factor base is asymptotically equal to <span class="math">2B/\\log(B)</span>. In some record computations the number of relations is less than the cardinality of the factor base, e.g. <span class="math">68\\%</span> in <em>[AFK^{+}07]</em>, but for simplicity and without changing the complexity results by more than one bit, we consider that the attacker must collect at least as many relations as elements in the factor base. Hence the validity condition is</p>

    <p class="text-gray-300"><span class="math">\\frac{(2A+1)^{2\\eta}}{2w}\\cdot p_{f}\\cdot p_{g}\\geq\\frac{2B}{\\log(B)}.</span> (1)</p>

    <p class="text-gray-300">Due to Galois automorphisms (see the discussion in Section 3.2.2) <span class="math">\\frac{2B}{\\mathcal{A}\\log(B)}</span> non-conjugate relations can be used to obtain <span class="math">2B/log(B)</span> relations (where <span class="math">\\mathcal{A}</span> is the number of automorphisms of <span class="math">h</span> times the number of automorphisms of <span class="math">\\mathbb{F}_{p^{\\alpha}}/\\mathbb{F}_{p^{\\eta}}</span> which fix <span class="math">f</span> and <span class="math">g</span>). Equivalently, we collect only <span class="math">\\frac{2B}{\\mathcal{A}\\log(B)}</span> relations and we keep one ideal in each class of conjugacy so that the cardinality of the reduced factor base becomes <span class="math">\\frac{2B}{\\mathcal{A}\\log(B)}</span>. Each relation is obtained on average after testing <span class="math">p_{f}^{-1}p_{g}^{-1}</span> elements of the sieving space, so the total number of enumerated (or sieved) elements is <span class="math">2B/(\\mathcal{A}\\log(B)p_{f}p_{g})</span>.</p>

    <p class="text-gray-300">The ratio between the real cost of the sieve and the number of tuples enumerated (or sieved) in the sieve is hard to evaluate so we call it <span class="math">c_{\\text{sieve}}</span>. According to Table 6, <span class="math">c_{\\text{sieve}}</span> is almost constant in various computations realized with various variants of NFS. We stay on the safe side and model <span class="math">c_{\\text{sieve}}</span> to be a constant equal to <span class="math">1</span>.</p>

    <p class="text-gray-300">One might ask if in the case of the new variants, TNFS, exTNFS and SexTNFS, one can approximate <span class="math">c_{\\text{sieve}}</span> by its value in the classical variants. Examples abound where new attacks with better asymptotic complexity were actually slower in practice beacuse of hidden constants <em>[x20]</em>. In a recent record computation <em>[x13, Section 2.1]</em>, Grémy, Guillevic and Morain sieved a dimension three lattice with <span class="math">A=2^{16}</span> in 359 CPU hours, which accounts for <span class="math">c_{\\text{sieve}}\\approx 27</span>. This value can decrease with the size of <span class="math">A</span> and thaks to practical improvements. However, it is safe to assume that <span class="math">c_{\\text{sieve}}</span> will remain <span class="math">\\geq 1</span>.</p>

    <p class="text-gray-300">In the rest of the analysis we consider <span class="math">c_{\\text{sieve}}=1</span> which means that the sieving time equals the number of elements of the sieving domain. Finally we obtain</p>

    <p class="text-gray-300"><span class="math">\\text{sieve cost}=\\frac{2B}{\\mathcal{A}\\log(B)\\cdot p_{f}\\cdot p_{g}}.</span></p>

    <p class="text-gray-300">The size of the matrix sent to filtering is <span class="math">2B/\\mathcal{A}\\log(B)</span>. As explained in Section 3.2 it is reduced by a factor <span class="math">\\log_{2}B</span>. The number of non-zero entries per row in the reduced matrix varies between <span class="math">100</span> and <span class="math">200</span> in all records that we consider and we will approximate it by <span class="math">128</span>. Let then <span class="math">c_{\\text{lin.alg}}</span> be such that the cost of the linear algebra is <span class="math">c_{\\text{lin.alg}}2^{7}B^{2}/(\\mathcal{A}\\log(B)\\log_{2}(B))^{2}</span>, as it is expected to be using Wiedemann’s algorithm. The factor <span class="math">c_{\\text{lin.alg}}</span> accounts for</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">record</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2 E</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2(\\text{cost of sieve})</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2 B</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2(\\text{cost of lin.alg.})</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2(\\text{c sieve})</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log_2(\\text{c lin.alg.})</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-1039 (factor)</td>

            <td class="px-3 py-2 border-b border-gray-700">31.0</td>

            <td class="px-3 py-2 border-b border-gray-700">63.0</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">63.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-768 (factor)</td>

            <td class="px-3 py-2 border-b border-gray-700">33.0</td>

            <td class="px-3 py-2 border-b border-gray-700">66.5</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">64.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">-2</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FFS-809</td>

            <td class="px-3 py-2 border-b border-gray-700">27.0</td>

            <td class="px-3 py-2 border-b border-gray-700">57.5</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">55.0</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-1024 (DLP)</td>

            <td class="px-3 py-2 border-b border-gray-700">31.5</td>

            <td class="px-3 py-2 border-b border-gray-700">64.5</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">63.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-768 (DLP)</td>

            <td class="px-3 py-2 border-b border-gray-700">35.0</td>

            <td class="px-3 py-2 border-b border-gray-700">68.0</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">66.0</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">-2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">-4</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. A list of records and their parameters.</p>

    <p class="text-gray-300">the cost of a multiplication in <span class="math">\\mathbb{F}_r</span>, where <span class="math">r</span> is the order of the pairings group. Since <span class="math">\\log_2 r</span> varies by at most a factor 2 between various types of pairings and various security levels between 128 and 256, we expect <span class="math">c_{\\mathrm{lin.alg}}</span> to be a constant. The records we summarized in Table 6 confirm that <span class="math">c_{\\mathrm{lin.alg}}</span> is a constant close to 1.</p>

    <p class="text-gray-300">We conclude this section with a model of the cost:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{cost} = \\frac{2B}{\\mathcal{A} \\log B} \\rho \\left(\\frac{\\log_2 (N_f)}{\\log_2 B}\\right)^{-1} \\rho \\left(\\frac{\\log_2 (N_g)}{\\log_2 B}\\right)^{-1} + 2^7 \\frac{B^2}{\\mathcal{A}^2 (\\log B)^2 (\\log_2 B)^2}, \\tag{2}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{A}</span> can be upper bounded by <span class="math">\\eta \\kappa / \\gcd(\\eta, \\kappa)</span>.</p>

    <p class="text-gray-300">For each pairing curve and choice of polynomials one has to solve an optimization problem: find the values of <span class="math">\\log_2 A</span> and <span class="math">\\log_2 B</span> which minimize the cost in Equation 2 under the condition in Equation 1.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4.3 Comparison to the analysis of Menezes, Sarkar and Singh</h2>

    <p class="text-gray-300">At this point of the article we can explain the difference between our analysis and that of [MSS16].</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3.1 Impreciseness in the estimation of <span class="math">\\log_2 N_f</span> and <span class="math">\\log_2 N_g</span></h3>

    <p class="text-gray-300">In order to estimate the bit size of the norms <span class="math">N_f</span> and <span class="math">N_g</span>, Menezes, Sarkar and Singh used the mathematical upper bounds. In an experiment we computed the distribution of the bit sizes of norms, and we present our results in Figure 4.3.1. A script to reproduce the experiment on the same sample of 1000 pairs <span class="math">(\\mathbf{a}, \\mathbf{b})</span> is available online at [BD17]. The target is the 3072-bit finite field corresponding to a BN curve in Section 5.2. The bitsize <span class="math">\\log_2 N_f</span> (in the left) varies between 175 and 244, which is much smaller than 740, the mathematical upper bound. Similarly, <span class="math">\\log_2 N_g</span> varies between 417 and 472 which is much smaller than 853, the mathematical upper bound. In a similar experiment [MSS16, Table 3], Menezes, Sarkar and Singh observed a similar</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Experimental distribution of <span class="math">\\log_2 N_f</span> (in the left) and <span class="math">\\log_2 N_g</span> (in the right) on the sieving domain of SexTNFS. The vertical line shows the mathematical upper bound used in [MSS16].</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">situation: "It is possible that a non-negligible fraction of these have norms close to the upper bounds. Our experiments</p>

    <p class="text-gray-300">only indicate that this fraction is less than 1/1000”. This corroborates with our results but the figure shows at which point the upper bound used in <em>[x13]</em> is far away from 99.9% of the values. We remark however that their method is adapted for a practitioner to convince himself that a NFS computation is feasible, because it gives an upper bound on the complexity, but it cannot be used to obtain security estimations which ideally would require a lower bound.</p>

    <p class="text-gray-300">This difference is well known to practitioners of factoring and discrete logarithm. Hence, the CADO-NFS software package <em>[BGI^{+}14]</em> sacrifices a few percents of relations by skipping the pairs <span class="math">(\\mathbf{a},\\mathbf{b})</span> having large norms. For example, from file params.c90 in the parameters directory of CADO-NFS we learn that ”lambda0/lambda1 is the early abort sieving parameter, and if […] the approximation of the log of the remaining cofactor is larger than lambda times lpb, we reject”, where lambda0, lambda1 and lpb are parameters which control the percentage of relations we sacrifice. In this light, the size of the largest 0.1% of the norms has no impact on the behavior of NFS implementations.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">4.3.2 Other differences.</h4>

    <p class="text-gray-300">Moreover, the analysis of Menezes, Sarkar and Singh in Section 6.3 does not mention a series of aspects which can decrease the running time of SexTNFS.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Filtering. On page 13 of <em>[x13]</em> one reads ”the linear algebra phase will have a cost approximatively <span class="math">B^{2}</span>”. This ignores that the number of rows and columns of the matrix is reduced during the filtering step. There is no evidence that the reduction factor is a constant and in Section 3.2.1 we give heuristic arguments that it is approximatively <span class="math">\\log_{2}B</span>. Moreover the size of the factor base is <span class="math">2B/\\log(B)</span> rather than <span class="math">B</span>. The discussion on the arithmetic modulo <span class="math">r</span> (<span class="math">\\ell</span> in their notations) on the same page is not necessary because elements of <span class="math">\\mathbb{F}_{r}</span> are implemented on two or three machine words already in the records that we list in Table 6, and elements in <span class="math">\\mathbb{F}_{r}</span> are stored on at most 4 machine words even for <span class="math">256</span> bits of security.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">(2A+1)</span> instead of <span class="math">A</span>. We didn’t find in <em>[x13]</em> a discussion on the relation between <span class="math">E</span> and <span class="math">A</span> other than the asymptotic relation <span class="math">E\\sim A^{\\eta}</span>. An attacker can use (and is likely to do so) as sieving domain the set of tuples <span class="math">(\\mathbf{a},\\mathbf{b})\\in\\mathbb{Z}^{2\\eta}</span> which have the smallest value of $\\max(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty})\\leq A<span class="math">, with </span>A<span class="math"> as small as possible so that the cardinality of the sieving domain allows to obtain enough relations. In this case we have the relation </span>(2A+1)^{2\\eta}=E^{2}<span class="math">. To our understanding, Menezes, Sarkar and Singh used the formula </span>A=E^{1/\\eta}<span class="math">, which is less precise, especially when the quotient </span>\\eta/\\log_{2}E$ is not very small.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Automorphisms and roots of unity. Menezes, Sarkar and Sing do not use the Galois automorphisms that we discussed in Section 3.2.2.</li>

    </ol>

    <h2 id="sec-19" class="text-2xl font-bold">5 Estimating SexTNFS complexity on the most popular pairings</h2>

    <p class="text-gray-300">In this section, we use the results of the previous section to estimate the security level provided by a given finite field <span class="math">\\mathbb{F}_{p^{k}}</span> when <span class="math">p</span> is parametrized by a polynomial <span class="math">P(x)</span>.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.1 Summarizing the process for computing SexTNFS cost</h3>

    <p class="text-gray-300">Let us first summarize the way to estimate the complexity of the SexTNFS algorithm. It is made of 4 steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1: Parameter selection. The first choice to be made is the one of the <span class="math">\\kappa</span>. All divisors of <span class="math">k</span> must be tested so that the following steps are done once for each <span class="math">\\kappa</span>. However, the first values to try are the ones in Table 5. Then one has to choose the polynomial <span class="math">h</span> such that <span class="math">\\mathcal{A}</span> is as large as possible and <span class="math">h</span> is as simple as possible (small and few coefficients) and the polynomials <span class="math">f</span> and <span class="math">g</span> to define the commutative diagram given in the introduction. The details on the ways to choose these polynomials are given in Section 3.3. In this step, we also determine the number of roots of unity divided by two <span class="math">w</span> and the number of automorphisms <span class="math">\\mathcal{A}</span>.</li>

      <li>Step 2: Choice of the bounds <span class="math">A</span> and <span class="math">B</span>. These bounds will define the number of enumerated relations and the size of the factor basis so they have a direct impact on the complexity. As already explained they must be chosen to minimize the cost in Equation 2 under the condition in Equation 1. This optimization problem will be solve by brute force because we do not need a very high accuracy. We first enumerate only integer values of <span class="math">\\log_{2}A\\in[1,\\frac{100}{\\eta}]</span> and <span class="math">\\log_{2}B\\in[1,100]</span> because the cost is lower bounded by <span class="math">(A^{2\\eta}+B^{2})/1000</span> which is more than <span class="math">2^{192}</span> for larger values of <span class="math">A</span> and <span class="math">B</span>. We call <span class="math">\\log_{2}A_{0}</span> and <span class="math">\\log_{2}B_{0}</span> the optimum of this integer search. In a second time we test</li>

    </ul>

    <p class="text-gray-300">all values of <span class="math">\\log_{2}A</span> in the set <span class="math">\\{\\log_{2}A_{0}+i/100\\mid i\\text{ integer in }[-100,100]\\}</span> and all values of <span class="math">\\log_{2}B</span> in the set <span class="math">\\{\\log_{2}B_{0}+j/5\\mid j\\text{ integer in }[-25,25]\\}</span>. When the optimal values of <span class="math">A</span> is less than <span class="math">10</span>, we switch from enumerating values of <span class="math">\\log_{2}A</span> to enumerating integer values of <span class="math">A</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 3: Verification. At this point we know what is the security level. For completeness we continue by verifying once again by hand that the values of <span class="math">A</span> and <span class="math">B</span>, which were found by a non-proven program, are indeed valid parameters for SexTNFS by checking that the number of relations is larger than the cardinality of the factor base.</li>

      <li>Step 4: Conclusion. We inject <span class="math">A</span> and <span class="math">B</span> in Equation 2 an verify once again that the cost of SexTNFS is that found by our unproven solver of the optimization problem.</li>

    </ul>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 Example: a BN curve where the finite field has 3072 bits</h3>

    <p class="text-gray-300">One of the most popular BN curve is the one associated to <span class="math">u=-2^{62}-2^{55}-1</span> which was evaluated to 128 bits of security before the recent developments on NFS. Let us follow Section 5.1 to estimate its real security level.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1: Parameter selection. We decide to use the SexTNFS algorithm with <span class="math">\\kappa=2</span> and <span class="math">\\eta=6</span> because it gives the best result from the viewpoint of the attacker. The intermediate field will be defined by <span class="math">h=t^{6}-t^{3}-t-1</span> which is irreducible modulo p. Indeed the cyclotomic polynomials <span class="math">\\Phi_{7},\\Phi_{9},\\Phi_{14}</span> and <span class="math">\\Phi_{18}</span> are not irreducible in this case and <span class="math">h</span> is the ”smallest” irreducible polynomial (it has only <span class="math">4</span> non-zero coefficients which moreover equal <span class="math">\\pm 1</span>). We tried several polynomials and found that <span class="math">x^{2}+t-u</span> is irreducible in <span class="math">\\mathbb{F}_{p^{6}}=\\mathbb{F}_{p}[t]/h(t)</span> so that <span class="math">\\mathbb{F}_{p^{12}}=\\mathbb{F}_{p^{6}}[x]/(x^{2}+t-u)</span>. Hence we can take <span class="math">f=P(x^{2}+t)</span> (where <span class="math">P</span> is the polynomial parametrizing <span class="math">p</span> given in Section 2.1) and <span class="math">g=x^{2}+t-u</span>. In this case, we have no non-trivial roots of unity (<span class="math">w=1</span>) and <span class="math">\\mathcal{A}=2</span> because <span class="math">g</span> has degree two (as explained in Section 3.2.2).</li>

      <li>Step 2: Choice of the bounds <span class="math">A</span> and <span class="math">B</span>. As explained in Section 5.1, we applied Steps 3 and 4 for many values of <span class="math">A</span> and <span class="math">B</span> to find that <span class="math">\\log_{2}A=7.36</span> and <span class="math">\\log_{2}(B)=57</span> are minimizing the cost given by the Equation 2.</li>

      <li>Step 3: Verification. The total number of tuples in the sieving space is <span class="math">(2A+1)^{2\\eta}/(2w)</span>, where <span class="math">w=1</span> is the number of roots of unity of the number field of <span class="math">h</span>, divided by <span class="math">2</span>, so the size of the sieving space is <span class="math">2^{99.45}</span>. By Monte Carlo integration (Appendix A) we estimate the norms on the two sides of the commutative diagram and then one can approximate the smoothness probability using Dickman’s function</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\log_{2}(N_{f})\\approx 414.7\\Rightarrow\\rho\\left(\\frac{\\log_{2}(N_{f})}{\\log_{2}(B)}\\right)\\approx 2^{-21.41}\\ \\ \\text{and}\\ \\ \\log_{2}(N_{g})\\approx 460.8\\Rightarrow\\rho\\left(\\frac{\\log_{2}(N_{g})}{\\log_{2}(B)}\\right)\\approx 2^{-25.30}</span></p>

    <p class="text-gray-300">Hence the number of relations is approximatively <span class="math">2^{99.45-21.41-25.30}\\approx 2^{52.74}</span>.</p>

    <p class="text-gray-300">On the other hand, the cardinality of the factor base is approximatively <span class="math">2B/\\log(B)\\approx 2^{52.70}</span>, which is less than the number of relations, so we have enough relations (Equation 1 is satisfied).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 4: Conclusion. Equation 2 gives a security level of <span class="math">99.69</span> bits. The details are as follows : the number of relations we need to collect is <span class="math">2^{51.70}</span> and each relation is obtained after testing on average <span class="math">2^{21.41+25.30}=2^{46.71}</span> pairs <span class="math">(a,b)</span>; hence the cost of the sieve is <span class="math">c_{\\text{sieve}}2^{51.70+46.71}\\approx 2^{98.41}</span> assuming <span class="math">c_{\\text{sieve}}\\approx 1</span>; on the other hand, the filtering stage allows to reduce the matrix size by a factor around <span class="math">\\log_{2}B=57</span>, its new size being <span class="math">N=2^{51.70}/57\\approx 2^{46.87}</span>; the cost of the algorithms of sparse linear algebra is given by <span class="math">2^{5}N^{2}=2^{98.73}</span> times the cost of an addition modulo <span class="math">p</span>, which counts here for an elementary operation.</li>

    </ul>

    <p class="text-gray-300">Finally, we get the overall cost by adding the cost of the relation collection and the one of the linear algebra :<span class="math">2^{98.65}+2^{98.73}=2^{99.69}</span> which means that the BN curve used in most of the existing implementations ensures no more than the <span class="math">100</span>-bits security level.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.3 General results and recommendations</h3>

    <p class="text-gray-300">The goal of this section is to determine the required size of the finite field involved in the pairings given in Section 2 to ensure the <span class="math">128,192</span> and <span class="math">256</span>-bits security levels. For this, we follow the strategy given in Section 5.1 for each family of curves making at each step the most favorable choice (for the attacker). For example we assumed that the number of automorphisms <span class="math">\\mathcal{A}</span> is maximal. If the parameter <span class="math">u</span> (and therefore <span class="math">p</span>) is selected such that the attacker cannot use the best polynomials listed in Table 7 then we observed an increase of up to 3 bits of security (Sections 7.1.1 and 7.1.2).</p>

    <p class="text-gray-300">However, for the purpose of general recommendations, we consider that the attacker can use the best polynomials. The results are given in Tables 8, 9 and 10, which then contain our recommendations for the size of  <span class="math">p^k</span>  where  <span class="math">k</span>  is the embedding degree. Note that in the case of KSS16 and KSS18 curves for 128 bits of security the parameter  <span class="math">A</span>  is very small ( <span class="math">A = 9</span> ), and one might want to compute the proportion of elements in the sieving space having each possible value of norms bit size. In every other case in this article we checked that such a precise analysis arrives to the same results as our analysis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Family</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">η</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN, BLS12</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ7</td>

            <td class="px-3 py-2 border-b border-gray-700">x2 - u + t</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS16</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ17</td>

            <td class="px-3 py-2 border-b border-gray-700">x - u</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">Φ19</td>

            <td class="px-3 py-2 border-b border-gray-700">x - u</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7. Best choices of  <span class="math">h</span>  and  <span class="math">g</span>  at 128 bits of security</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Family</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2(pk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN</td>

            <td class="px-3 py-2 border-b border-gray-700">5534</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1145</td>

            <td class="px-3 py-2 border-b border-gray-700">74.00</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12</td>

            <td class="px-3 py-2 border-b border-gray-700">5530</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1098</td>

            <td class="px-3 py-2 border-b border-gray-700">73.65</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS16</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 4400</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">76.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 4300</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8. Size of finite fields associated to pairing-friendly curves which have a DLP cost of  <span class="math">2^{128}</span>  operations. Note that in the KSS case the curve side is weaker than the field side and additionally the field side security is particularly difficult to evaluate.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Family</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2(pk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">12200</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">110.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS24</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">13300</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">109.4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 9. Recommended parameters for pairings of 192 bits of security</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Family</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2(pk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

            <td class="px-3 py-2 border-b border-gray-700">26900</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12855</td>

            <td class="px-3 py-2 border-b border-gray-700">137.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS24</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">24700</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">141.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 10. Recommended parameters for pairings of 256 bits of security</p>

    <p class="text-gray-300">The goal of this section is to propose new parameters for the 128-bits security level for the main families of curves given in Section 2 (BN, BLS12, KSS16 and KSS18). This is done in 2 steps. The first one consists in finding the size of the</p>

    <p class="text-gray-300">extension field ensuring this security level in the general case which means that we assume that all the improvements of the NFS-like algorithms can be used. This was done in Section 5.3 and the results are given in Table 8. We must also take care that the  <span class="math">r</span> -torsion subgroup of the elliptic curve involved in the pairing computation ensures the 128-bits security level. For example, this is the limiting factor in the KSS cases. Then, for each family, we know the size of the curve parameter  <span class="math">u</span>  that should be used to ensure the 128-bits security level (Table 11) in the general case. These sizes guarantee the security level as soon as the parameter  <span class="math">u</span>  has the required bit size.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLS12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS18</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log2(u)</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 11. Bit size of the parameter  <span class="math">u</span>  ensuring the 128-bits security level</p>

    <p class="text-gray-300">The second step is to generate the best possible parameter  <span class="math">u</span>  having the good bit size. Let us start with the generation of a BN curve.</p>

    <p class="text-gray-300">The way to build the parameter  <span class="math">u</span>  is detailed in [DMHR15]: it should be chosen sparse and congruent to 7 or 11 mod 12 so that building  <span class="math">\\mathbb{F}_{p^{12}}</span>  can be done via  <span class="math">Y^6 - (1 + \\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[\\mathbf{i}]</span> . We also impose the condition that the curve obtained is twist-secure [VLFR08] which means that  <span class="math">p + 1 + t</span>  should have a 256-bits prime factor (where  <span class="math">t</span>  is the trace of the Frobenius as usual). We then performed an exhaustive search on  <span class="math">u</span>  having increasing Hamming weight. There are no results of weight 2. We found some values having Hamming weight 3 but not satisfying the congruence. More precisely, the extension tower should be built using  <span class="math">\\sqrt{-5}</span>  which is much less interesting in terms of  <span class="math">\\mathbb{F}_{p^{12}}</span>  arithmetic. Finally, we found the value  <span class="math">u = 2^{114} + 2^{101} - 2^{14} - 1</span>  which satisfies all the required conditions. The curve  <span class="math">E</span>  defined over  <span class="math">\\mathbb{F}_p</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">E: y ^ {2} = x ^ {3} - 4</span></div>

    <p class="text-gray-300">is twist-secure ( <span class="math">p + 1 + t</span>  has a 280-bits prime factor) and  <span class="math">u = 7 \\mod 12</span>  so that  <span class="math">\\mathbb{F}_{p^2}</span>  is defined by  <span class="math">X^2 + 1</span>  and  <span class="math">\\mathbb{F}_{p^{12}}</span>  by  <span class="math">Y^6 - (1 + \\mathbf{i})</span> . The twisted curve  <span class="math">E&#x27;</span>  is defined over  <span class="math">\\mathbb{F}_{p^2}</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">E ^ {\\prime}: y ^ {2} = x ^ {3} - 4 (1 + \\mathbf {i}).</span></div>

    <p class="text-gray-300">Most of the results of [DMHR15] can be used for BLS curves because the extension degree is also 12. Again, we performed an exhaustive search on the parameter  <span class="math">u</span>  having increasing Hamming weight. We did not find any value of weight 2 but we found two having Hamming weight 3,  <span class="math">-2^{77} + 2^{50} + 2^{33}</span>  and  <span class="math">-2^{77} - 2^{59} + 2^9</span> . In both cases  <span class="math">\\mathbb{F}_{p^{12}}</span>  can be built via  <span class="math">Y^6 - (1 + \\mathbf{i})</span>  over  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[\\mathbf{i}]</span> , which provides the best possible  <span class="math">\\mathbb{F}_{p^{12}}</span>  arithmetic. We recommend to use the first one because if the second one is used, the cyclotomic polynomial  <span class="math">\\varPhi_7</span>  is irreducible and can be used for  <span class="math">h</span> , which improves the SexNFS attack. Then, for  <span class="math">u = -2^{77} + 2^{50} + 2^{33}</span> , the elliptic curve  <span class="math">E</span>  (resp. its twist  <span class="math">E&#x27;</span> ) is defined over  <span class="math">\\mathbb{F}_p</span>  (resp.  <span class="math">\\mathbb{F}_{p^2}</span> ) by</p>

    <div class="my-4 text-center"><span class="math-block">E: y ^ {2} = x ^ {3} + 4, \\quad E ^ {\\prime}: y ^ {2} = x ^ {3} + 4 (1 + \\mathbf {i})</span></div>

    <p class="text-gray-300"><span class="math">E</span>  is of course twist-secure (thanks to a 273 prime factor).</p>

    <p class="text-gray-300">In this case, the parameter  <span class="math">u</span>  should have at least 34 bits to ensure the 128-bits security level on the elliptic curve side. Unfortunately, an exhaustive search does not provide any suitable value of the parameter having Hamming weight less than or equal to 5. The sparser parameter we found is  <span class="math">-2^{34} + 2^{27} - 2^{23} + 2^{20} - 2^{11} + 1</span> . In this case, the extension</p>

    <p class="text-gray-300">field is defined by <span class="math">X^{16}-2</span> which provides the best possible <span class="math">\\mathbb{F}_{p^{16}}</span> arithmetic. The elliptic curve <span class="math">E</span> (resp. its twist <span class="math">E^{\\prime}</span>) is defined over <span class="math">\\mathbb{F}_{p}</span> (resp. <span class="math">\\mathbb{F}_{p^{4}}</span>) by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}+x,\\qquad E^{\\prime}:y^{2}=x^{3}+2^{\\frac{1}{4}}x</span></p>

    <p class="text-gray-300">And again, <span class="math">E</span> is twist-secure (thanks to a <span class="math">318</span>-bits prime factor). However we found a suitable <span class="math">35</span>-bits parameter having Hamming weight <span class="math">5</span>. Such a parameter will of course involve an additional doubling/squaring step in the exponentiation algorithms but it will also involve one addition/multiplication step less. The impact on the Miller loop is negligible, but in the final exponentiation this means that a <span class="math">\\mathbb{F}_{p^{18}}</span> multiplication is replaced by a cyclotomic squaring and this happens <span class="math">9</span> times since <span class="math">9</span> exponentiations by <span class="math">u</span> are performed (see Section 8 for details). Since a cyclotomic squaring is more than twice faster than a <span class="math">\\mathbb{F}_{p^{16}}</span> multiplication, it is better to use the <span class="math">35</span>-bits parameter as long as <span class="math">\\mathbb{F}_{p}</span> arithmetic is not impacted. For example, <span class="math">p</span> has <span class="math">330</span> bits for the <span class="math">34</span>-bits value of <span class="math">u</span> and <span class="math">340</span> for the <span class="math">35</span>-bits value. Hence, if a <span class="math">32</span>-bits device is used, both values of <span class="math">p</span> require <span class="math">11</span> words so the <span class="math">\\mathbb{F}_{p}</span> arithmetic is not impacted. On the contrary, if a <span class="math">16</span>-bits device is used, choosing the <span class="math">35</span>-bits value of <span class="math">u</span> implies that <span class="math">p</span> requires <span class="math">22</span> words instead of <span class="math">21</span>. Then the <span class="math">34</span>-bits value may be preferred in this case. This parameter is <span class="math">u=2^{35}-2^{32}-2^{18}+2^{8}+1</span>, <span class="math">\\mathbb{F}_{p^{16}}</span> is also defined by <span class="math">X^{16}-2</span> and the elliptic curve <span class="math">E</span> (resp. its twist <span class="math">E^{\\prime}</span>) is defined over <span class="math">\\mathbb{F}_{p}</span> (resp. <span class="math">\\mathbb{F}_{p^{4}}</span>) by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}+x,\\qquad E^{\\prime}:y^{2}=x^{3}+2^{-\\frac{1}{4}}x</span></p>

    <p class="text-gray-300"><span class="math">E</span> is of course twist-secure (thanks to a <span class="math">281</span>-bits prime factor).</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">6.4 New KSS18 parameter for level 128</h3>

    <p class="text-gray-300">Again, the limiting factor for the security level is the elliptic curve size so that <span class="math">u</span> should have at least <span class="math">44</span> bits. Our exhaustive search provides no values having weight <span class="math">2</span> or <span class="math">3</span> and only one having weight <span class="math">4</span>. It is <span class="math">u=2^{44}+2^{22}-2^{9}+2</span>. In this case, <span class="math">\\mathbb{F}_{p^{18}}</span> cannot be defined by <span class="math">X^{18}-2</span> but by <span class="math">X^{18}-3</span>. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}+3,\\qquad E^{\\prime}:y^{2}=x^{3}+3.3^{\\frac{1}{3}}\\;\\;(\\text{or}\\;3.3^{-\\frac{1}{3}}).</span></p>

    <p class="text-gray-300">The curve <span class="math">E</span> is twist-secure (thanks to a <span class="math">333</span>-bits prime factor).</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.5 Discussion on subgroup-secure curves for level 128</h3>

    <p class="text-gray-300">All the curves provided are not protected against the so-called subgroup attacks. These attacks use the fact that the three groups involved in the pairing may have small cofactors <em>[x10]</em>. They can be prevented by choosing resistant parameters. However they do not occur for all protocols. They can also be prevented by the use of some (potentially expensive) subgroup membership tests. Then subgroup-secure parameters are not always used in the literature and in real-life implementations. That is the reason why we provided non subgroup-secure parameters in the general case (better efficiency) and subgroup-secure ones in this higher security section (that should be preferred in some situations).</p>

    <p class="text-gray-300">The definition of subgroup security for pairing is given in <em>[BCM^{+}15]</em> and implies that one should be able to find factors of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{3}</span>. This can be done using the ECM method but it is very costly so one cannot perform an exhaustive search checking subgroup security at each step. As explained in <em>[BCM^{+}15]</em>, the most reasonable way to find a subgroup-secure curve for pairing applications is to find a parameter <span class="math">u</span> such that <span class="math">\\#\\mathbb{G}_{2}/r</span> and <span class="math">\\#\\mathbb{G}_{3}/r</span> are primes. This is of course much easier to check but on the other hand there are much fewer candidates.</p>

    <p class="text-gray-300">According Section 8, we are only interested in BLS12 and KSS16 curves in the case of security level <span class="math">128</span>. We then made an exhaustive search of increasing Hamming weight values of <span class="math">u</span> satisfying this condition. For BLS12 curves, we find some parameters in weight <span class="math">7</span>. We give only one here but the other ones are not so difficult to find: <span class="math">u=-2^{77}-2^{71}-2^{64}+2^{37}+2^{35}+2^{22}-2^{5}</span>. In this cases <span class="math">\\mathbb{F}_{p^{12}}</span> can be built via <span class="math">Y^{6}-(1+\\mathbf{i})</span> over <span class="math">\\mathbb{F}_{p^{2}}=\\mathbb{F}_{p}[\\mathbf{i}]</span> which provides the best possible <span class="math">\\mathbb{F}_{p^{12}}</span> arithmetic. The elliptic curve <span class="math">E</span> (resp. its twist <span class="math">E^{\\prime}</span>) is defined over <span class="math">\\mathbb{F}_{p}</span> (resp. <span class="math">\\mathbb{F}_{p^{2}}</span>) by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}-2,\\qquad E^{\\prime}:y^{2}=x^{3}-2/(1+\\mathbf{i})</span></p>

    <p class="text-gray-300">is of course twist-secure (thanks to a <span class="math">433</span> prime factor).</p>

    <p class="text-gray-300">The case of KSS16 curves is more complicated. We first remark that <span class="math">\\#\\mathbb{G}_{2}/r</span> and <span class="math">\\#\\mathbb{G}_{3}/r</span> are always even and often divisible by <span class="math">17</span> <em>[x13]</em> so we have interest to relax the condition. Unfortunately it was not sufficient to find a parameter of Hamming weight less than or equal to <span class="math">10</span>. This is due to the fact that <span class="math">\\log_{2}(u)=34</span> implies that there are not enough possibilities for <span class="math">u</span> to have a reasonable probability that all the numbers involved (<span class="math">p</span>, <span class="math">r</span>, <span class="math">\\#\\mathbb{G}_{2}/2r</span>, <span class="math">\\#\\mathbb{G}_{3}/2r</span>) are primes together (up to some <span class="math">17^{n}</span> factor). As a consequence, it is probably more interesting to choose the previous subgroup-secure BLS curve or the non subgroup-secure KSS16 curve given in Section 7.1.3 together with the necessary subgroup membership tests (depending on the protocol).</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.6 New parameters for level 192</h3>

    <p class="text-gray-300">In the case of higher levels of security we prefer to be more cautious. Instead of a comparison of the best curves we simply give our own proposals. In terms of security we are once again cautious, our curves having more than 192 bits of security. This is due to the nature of our approach (the targeted extension field size is first determined in the worst case). We give only a KSS18 and a BLS24 curve since there is no doubt that BN, BLS12 and KSS16 will be less efficient.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">6.6.1 New KSS18 parameter for level 192</h4>

    <p class="text-gray-300">We saw in Table 9 that the parameter <span class="math">u</span> should be chosen such that <span class="math">\\log_{2}(u)\\geq 85</span>. As in the <span class="math">128</span>-bits case, we perform an exhaustive search of low Hamming weight values for <span class="math">u</span>. The best value we found is <span class="math">u=-2^{85}-2^{31}-2^{26}+2^{6}</span>. In this case, <span class="math">\\mathbb{F}_{p^{18}}</span> can be defined by <span class="math">X^{18}-2</span>. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}+2,\\qquad E^{\\prime}:y^{2}=x^{3}+2.2^{\\frac{1}{3}}\\ \\ (\\text{or}\\ 2.2^{-\\frac{1}{3}})</span></p>

    <p class="text-gray-300">The curve <span class="math">E</span> is twist-secure (thanks to a <span class="math">652</span>-bits prime factor).</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">6.6.2 New BLS24 parameter for level 192</h4>

    <p class="text-gray-300">We saw in Table 9 that the parameter <span class="math">u</span> should be chosen such that <span class="math">\\log_{2}(u)\\geq 56</span>. As in the <span class="math">128</span>-bits case, we perform an exhaustive search of low Hamming weight values for <span class="math">u</span>. The best value we found is <span class="math">u=-2^{56}-2^{43}+2^{9}-2^{6}</span>. In this case, <span class="math">\\mathbb{F}_{p^{24}}</span> can be built via <span class="math">Y^{12}-(1+\\mathbf{i})</span> over <span class="math">\\mathbb{F}_{p^{2}}=\\mathbb{F}_{p}[\\mathbf{i}]</span> which provides the best possible <span class="math">\\mathbb{F}_{p^{24}}</span> arithmetic. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}-2,\\qquad E^{\\prime}:y^{2}=x^{3}-2/(1+\\mathbf{i})</span></p>

    <p class="text-gray-300"><span class="math">E</span> is of course twist-secure (thanks to a <span class="math">427</span> prime factor).</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.7 New parameters for lever 256</h3>

    <p class="text-gray-300">As in the case of level 192, the fast pairings correspond to KSS18 and BLS24, thanks to theirs embedding degrees which are higher than that of BN, BLS12 and KSS16.</p>

    <p class="text-gray-300">In order to keep the complexity low we use only values of <span class="math">u</span> which can be written as a small number of terms of the form <span class="math">2^{a}</span> for some integers <span class="math">a</span>. A side effect is that <span class="math">u\\approx 2^{a}</span> for some <span class="math">a</span> and therefore <span class="math">p\\approx u^{18}</span> and <span class="math">p\\approx u^{24}</span> in the cases of KSS18 and respectively BLS24. This makes it difficult to tune <span class="math">\\log_{2}p^{k}</span> precisely.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">6.7.1 New KSS18 parameter for level 256</h4>

    <p class="text-gray-300">The parameter</p>

    <p class="text-gray-300"><span class="math">u=2^{186}-2^{75}-2^{22}+2^{4}</span></p>

    <p class="text-gray-300">allows to have a finite field bit size of 26700. In this case, <span class="math">\\mathbb{F}_{p^{18}}</span> can be defined by <span class="math">X^{18}-2</span>. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}-2,\\qquad E^{\\prime}:y^{2}=x^{3}-2.2^{\\frac{1}{3}}\\ \\ (\\text{or}\\ 2.2^{-\\frac{1}{3}})</span></p>

    <p class="text-gray-300">The curve <span class="math">E</span> is twist-secure (thanks to a <span class="math">1205</span>-bits prime factor).</p>

    <p class="text-gray-300">6.7.2 New BLS24 parameter for level 256</p>

    <p class="text-gray-300">We propose parameter</p>

    <p class="text-gray-300"><span class="math">u=-2^{103}-2^{101}+2^{68}+2^{50},</span></p>

    <p class="text-gray-300">which allows to have a finite field of bit size 24760. In this case, <span class="math">\\mathbb{F}_{p^{24}}</span> can be also built via <span class="math">Y^{12}-(1+\\mathbf{i})</span> over <span class="math">\\mathbb{F}_{p^{2}}=\\mathbb{F}_{p}[\\mathbf{i}]</span>. The elliptic curves are defined by</p>

    <p class="text-gray-300"><span class="math">E:y^{2}=x^{3}-2,\\qquad E^{\\prime}:y^{2}=x^{3}-2/(1+\\mathbf{i})</span></p>

    <p class="text-gray-300"><span class="math">E</span> is of course twist-secure (thanks to a <span class="math">581</span> prime factor).</p>

    <h2 id="sec-34" class="text-2xl font-bold">7 Effective security of the selected curves</h2>

    <p class="text-gray-300">Let us now apply the strategy given in Section 5.1 to evaluate the real security of the proposed curves.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">7.1 Level 128</h3>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">7.1.1 BN</h4>

    <p class="text-gray-300">We study the BN curve proposed in the previous section, which has parameter <span class="math">u=2^{114}+2^{101}-2^{14}-1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. The best results are obtained with <span class="math">\\kappa=2</span> and <span class="math">\\eta=6</span>. The best choices for the polynomials are <span class="math">h=t^{6}-t^{4}+t^{2}+1,g=x^{2}-t-u</span> and <span class="math">f=P(x^{2}-t)</span>. In this case, we have <span class="math">w=1</span> and <span class="math">\\mathcal{A}=2</span> as in Section 5.2. As a consequence we will find a higher security level here than in the general case.</li>

      <li>Step 2. <span class="math">A=1098\\approx 2^{10.10}</span> and <span class="math">B=2^{74.2}</span> are minimizing Equation 2 and satisfying Equation 1.</li>

      <li>Step 3. The size of the sieving space is <span class="math">(2A+1)^{12}/2\\approx 2^{132.21}</span>. The Monte Carlo integration (Appendix A) gives <span class="math">\\log_{2}(N_{f})\\approx 557.0</span> and <span class="math">\\log_{2}(N_{g})\\approx 808.9</span>. Then the smoothness probabilities are approximatively equal to <span class="math">\\rho\\left(\\frac{\\log_{2}(N_{f})}{\\log_{2}(B)}\\right)\\approx 2^{-22.87}</span> and <span class="math">\\rho\\left(\\frac{\\log_{2}(N_{g})}{\\log_{2}(B)}\\right)\\approx 2^{-40.52}</span>. Hence we expect a number of <span class="math">2^{132.21-22.87-40.52}\\approx 2^{68.82}</span> relations which is larger than the cardinality of the factor base which is around <span class="math">2^{68.78}</span>.</li>

      <li>Step 4. Evaluating Equation 2 with these data finally gives an overall complexity of <span class="math">2^{131.3}</span>.</li>

    </ul>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">The size of the parameters for this pairing are so that they guarantee 128 bits of security for arbitrary parameters in the BN family. However this particular choice offers 131 bits of security.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">7.1.2 BLS 12</h4>

    <p class="text-gray-300">The recommended parameter is <span class="math">u=-2^{77}+2^{50}+2^{33}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=2</span> and <span class="math">\\eta=6</span>. The best polynomials are <span class="math">h=t^{6}-t-1</span>, <span class="math">f=P(x^{2}+t+t^{2}+t^{4}+1)</span> where <span class="math">P(x)=(x-1)^{2}(x^{4}-x^{2}+1)+3x</span> and <span class="math">g=x^{2}+t+t^{2}+t^{4}+1-u</span>. In this case, we have <span class="math">w=7</span> and <span class="math">\\mathcal{A}=2</span> (because <span class="math">g</span> is quadratic).</li>

      <li>Step 2. <span class="math">A=1169</span> and <span class="math">\\log_{2}B=73.50</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}(\\text{sieve space})=133.30</span></li>

      <li><span class="math">\\log_{2}(N_{f})=791.2\\Rightarrow\\log_{2}(\\text{smoothness probability on the </span>f<span class="math"> side})=-39.17</span></li>

      <li><span class="math">\\log_{2}(N_{g})=584.8\\Rightarrow\\log_{2}(\\text{smoothness probability on the </span>g<span class="math"> side})=-24.67</span></li>

      <li><span class="math">\\log_{2}(\\text{relations})=69.46</span></li>

      <li><span class="math">\\log_{2}(\\text{reduced factor base})=67.83</span> (enough relations)</li>

      <li>Step 4. security=<span class="math">131.8</span></li>

    </ul>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Zhaohui Cheng communicated to us two choices of BLS12 curses which have <span class="math">127</span> bits of security:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>equation <span class="math">y^{2}=x^{3}+9</span> and parameter <span class="math">u=-(2^{73}+2^{72}+2^{50}+2^{24})</span>;</li>

      <li>equation <span class="math">y^{2}=x^{3}+7</span> and parameter <span class="math">u=-(2^{12}+2^{48}+2^{49}+2^{50}+2^{51}+2^{52}+2^{53}+2^{54}+2^{55}+2^{56}+2^{57}+2^{58}+2^{59}+2^{60}+2^{61}+2^{62}+2^{63}+2^{64}+2^{65}+2^{66}+2^{67}+2^{68}+2^{69}+2^{70}+2^{72}+2^{73})</span>.</li>

    </ul>

    <p class="text-gray-300">The field <span class="math">p^{k}</span> is <span class="math">5280</span> bits long instead of the <span class="math">5530</span> bits required by the general estimations in Table 7. Hence, our approach of first finding general recommendations for each family (assuming the attacker can apply all improvements), then checking specific values of <span class="math">u</span>, only loses <span class="math">5\\%</span> in length.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.1.3 KSS 16</p>

    <p class="text-gray-300">The recommended parameter is <span class="math">u=2^{35}-2^{32}-2^{18}+2^{8}+1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=1</span> and <span class="math">\\eta=16</span>. The best polynomials are <span class="math">h=\\Phi_{17}</span>, <span class="math">f=P(x-1)</span> and <span class="math">g=x-u-1</span>. In this case, we have <span class="math">w=17</span> and <span class="math">\\mathcal{A}=16</span>.</li>

      <li>Step 2. <span class="math">A=12</span> and <span class="math">\\log_{2}B=80</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieve space) = <span class="math">143.52</span></li>

      <li><span class="math">\\log_{2}(N_{f})=920.4\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">f</span> side) = <span class="math">-43.23</span></li>

      <li><span class="math">\\log_{2}(N_{g})=628.9\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">g</span> side) = <span class="math">-24.21</span></li>

      <li><span class="math">\\log_{2}</span>(relations) = <span class="math">76.08</span></li>

      <li><span class="math">\\log_{2}</span>(reduced factor base) = <span class="math">71.20</span> (enough relations)</li>

      <li>Step 4. security=<span class="math">139.0</span>. Note that this is the security only on the finite field side. The security on the elliptic curve side is <span class="math">128</span> as required.</li>

    </ul>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">7.1.4 KSS 18</h4>

    <p class="text-gray-300">The recommended parameter is <span class="math">u=2^{44}+2^{22}-2^{9}+2</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=1</span> and <span class="math">\\eta=18</span>. The best polynomials are <span class="math">h=t^{18}-t^{4}-t^{2}-t-1</span>, <span class="math">f=P(x-2)</span> and <span class="math">g=x-u-2</span>. In this case, we have <span class="math">w=1</span> and <span class="math">\\mathcal{A}=1</span>.</li>

      <li>Step 2. <span class="math">A=11</span> and <span class="math">\\log_{2}B=82.5</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieve space) = <span class="math">161.85</span></li>

      <li><span class="math">\\log_{2}(N_{f})=920.4\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">f</span> side) = <span class="math">-36.21</span></li>

      <li><span class="math">\\log_{2}(N_{g})=628.9\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">g</span> side) = <span class="math">-38.33</span></li>

      <li><span class="math">\\log_{2}</span>(relations) = <span class="math">87.31</span></li>

      <li><span class="math">\\log_{2}</span>(reduced factor base) = <span class="math">77.66</span> (enough relations)</li>

      <li>Step 4. security=<span class="math">152.4</span>. Note that this is the security only on the finite field side. The security on the elliptic curve side is <span class="math">128</span> as required.</li>

    </ul>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">7.2 Level 192</h3>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">7.2.1 KSS18 for level <span class="math">192</span></h4>

    <p class="text-gray-300">To evaluate its real security, we use the way described in Section 5.1 and we get</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=1</span> and <span class="math">\\eta=18</span>. The best polynomials are <span class="math">h=t^{18}-t^{4}-t^{2}-t-1</span>, <span class="math">f=P(x-2)</span> and <span class="math">g=x-u-2</span>. In this case, we have <span class="math">w=1</span> and <span class="math">\\mathcal{A}=1</span>.</li>

      <li>Step 2. <span class="math">A=34</span> and <span class="math">\\log_{2}B=108.9</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieve space) = <span class="math">161.85</span></li>

      <li><span class="math">\\log_{2}(N_{f})=1114\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">f</span> side) = <span class="math">-36.29</span></li>

      <li><span class="math">\\log_{2}(N_{g})=1642\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">g</span> side) = <span class="math">-63.99</span></li>

      <li><span class="math">\\log_{2}</span>(relations) = <span class="math">118.62</span></li>

      <li><span class="math">\\log_{2}</span>(reduced factor base) = <span class="math">103.66</span> (enough relations)</li>

      <li>Step 4. security = <span class="math">204.09</span>.</li>

    </ul>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">7.2.2 BLS24 for level 192</h4>

    <p class="text-gray-300">To evaluate its real security, we use the way described in Section 5.1 and we get</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=1</span> and <span class="math">\\eta=24</span>. The best polynomials are <span class="math">h=t^{24}+t^{4}-t^{3}-t-1</span>, <span class="math">f=P(x)</span> and <span class="math">g=x-u</span>. In this case, we have <span class="math">w=1</span> and <span class="math">\\mathcal{A}=1</span>.</li>

      <li>Step 2. <span class="math">A=9</span> and <span class="math">\\log_{2}B=109.8</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieve space) = <span class="math">202.90</span></li>

      <li><span class="math">\\log_{2}(N_{f})=1295\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">f</span> side) = <span class="math">-44.85</span></li>

      <li><span class="math">\\log_{2}(N_{g})=1460\\Rightarrow\\log_{2}</span>(smoothness probability on the <span class="math">g</span> side) = <span class="math">-53.42</span></li>

      <li><span class="math">\\log_{2}</span>(relations) = <span class="math">104.63</span></li>

      <li><span class="math">\\log_{2}</span>(reduced factor base) = <span class="math">104.55</span> (enough relations)</li>

      <li>Step 4. security = <span class="math">203.72</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7.3 Level 256</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">7.3.1 KSS18</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We chose <span class="math">\\kappa=2</span> and <span class="math">\\eta=9</span>. The best polynomials are <span class="math">h=t^{9}+t^{8}+t^{7}-t^{6}-1</span>, <span class="math">f=P(x^{2}-2)</span> where <span class="math">P=x^{8}+5x^{7}+7x^{6}+37x^{5}+188x^{4}+259x^{3}+343x^{2}+1763x+240</span>, <span class="math">g=x^{2}-2-u</span>.</li>

      <li>Step 2. <span class="math">A=11747</span> and <span class="math">\\log_{2}B=137.7</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieve space) <span class="math">=260.36</span></li>

      <li><span class="math">\\log_{2}(N_{f})=2185</span> and <span class="math">\\log_{2}(N_{g})=1928</span></li>

      <li><span class="math">\\log_{2}</span>(relations) <span class="math">=134.35</span> <span class="math">\\downarrow</span> <span class="math">\\log_{2}</span>(factor base) <span class="math">=131.12</span> (enough relations)</li>

      <li>Step 4. security = <span class="math">257.13</span></li>

    </ul>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">7.3.2 BLS24</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We choose <span class="math">\\kappa=1</span> and <span class="math">\\eta=24</span>. The best polynomials are <span class="math">h=t^{24}-t^{23}-t^{21}+t^{20}-1</span>, <span class="math">f=P=(x-1)^{2}<em>(x^{8}-x^{4}+1)+3</em>x</span>, <span class="math">g=x-u</span>.</li>

      <li>Step 2. <span class="math">A=23</span> and <span class="math">\\log_{2}B=138.5</span></li>

      <li>Step 3.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\log_{2}</span>(sieving domain) <span class="math">=262.62</span></li>

      <li><span class="math">\\log_{2}(N_{f})=1522</span> and <span class="math">\\log_{2}(N_{g})=2619</span></li>

      <li><span class="math">\\log_{2}</span>(relations) <span class="math">=137.28&gt;131.92=\\log_{2}</span>(factor base) (enough relations)</li>

      <li>Step 4. security = <span class="math">260.9</span></li>

    </ul>

    <h2 id="sec-46" class="text-2xl font-bold">8 Complexity estimations and comparisons for the 128 bits security level</h2>

    <p class="text-gray-300">The goal of this section is to compare the pairing computation cost for the curves given in section 6 at the 128 bits security level. For this, we evaluate the cost of an optimal pairing <em>[x21]</em> (because it is by far the most efficient at this security level) computation in each case (BN, BLS12, KSS16 and KSS18). Let us first recall the steps of the computation.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">8.1 Optimal ate pairing computation</h3>

    <p class="text-gray-300">We do not give here the detailed algorithm to compute pairings but only what is necessary to analyze its complexity. More details can be found for example in <em>[x10]</em>.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">8.1.1 The Miller loop.</h4>

    <p class="text-gray-300">Miller explains how to compute <span class="math">f_{u,Q}</span> in <em>[x16]</em>. The algorithm is based on the computation of <span class="math">[u]Q</span> using the double and add algorithm. At each step of this algorithm, <span class="math">f</span> is updated with the line function involved in the elliptic curve operation. This algorithm has been improved by many authors in particular using the twisted curve to eliminate denominators and replace <span class="math">\\mathbb{F}_{p^{k}}</span> multiplications by sparse ones. The best known complexity for each step are obtained using projective coordinates <em>[x12]</em>. They are given below</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">d=6</span>, the doubling step requires one squaring in <span class="math">\\mathbb{F}_{p^{k}}</span>, denoted <span class="math">S_{k}</span>, one sparse multiplication in <span class="math">\\mathbb{F}_{p^{k}}</span>, denoted <span class="math">sM_{k}</span> (for updating <span class="math">f</span>) together with <span class="math">2</span> multiplications in <span class="math">\\mathbb{F}_{p^{e}}</span>, denoted <span class="math">M_{e}</span>, 7 squarings in <span class="math">\\mathbb{F}_{p^{e}}</span> and <span class="math">2e</span> multiplications in <span class="math">\\mathbb{F}_{p}</span>, denoted <span class="math">M</span> (for doubling on the curve and computing the line involved in this doubling). If <span class="math">d=4</span>, the curve side requires one additional <span class="math">S_{e}</span>.</li>

      <li>If <span class="math">d=6</span>, the mixed addition step requires one <span class="math">sM_{k}</span> for updating <span class="math">f</span> together with <span class="math">11M_{e}</span>, <span class="math">2S_{e}</span> and <span class="math">2e\\,M</span> (or <span class="math">9M_{e}</span>, <span class="math">5S_{e}</span> and <span class="math">2e\\,M</span> if <span class="math">d=4</span>).</li>

      <li>Additional lines in the pairing given in Table 2 are nothing but extra addition steps. In term of complexity, the last one is usually less expensive (<span class="math">4M_{e}</span> and <span class="math">2e\\,M</span> for the curve side) because the resulting point on the curve is useless.</li>

      <li>The computation of points of the form <span class="math">[p]Q</span> is very easy because <span class="math">Q</span> is in the <span class="math">p</span>-eigenspace of the Frobenius map. Then it requires no more than 2 Frobenius mapping in <span class="math">\\mathbb{F}_{p^{k}}</span>, denoted <span class="math">F_{k}</span>. In practice, it requires even less but there is no interest to get into these kind of details for this comparison work.</li>

    </ul>

    <p class="text-gray-300">8.1.2 The final exponentiation. It is usually split in 2 parts, an easy one with the exponent  <span class="math">\\frac{p^k - 1}{\\phi_k(p)}</span>  (where  <span class="math">\\phi_{k}</span>  is the  <span class="math">k</span> -th cyclotomic polynomial) and a hard one with the exponent  <span class="math">\\frac{\\phi_k(p)}{r}</span> . The easy part is made of an inversion, denoted  <span class="math">I_{k}</span> , and few multiplications and Frobenius mappings in  <span class="math">\\mathbb{F}_{p^k}</span> . The hard part is much more expensive but Scott et al. [SBC+09] reduce this cost by writing the exponent in base  <span class="math">p</span>  (because  <span class="math">p</span> -th powering is only a Frobenius mapping). As  <span class="math">p</span>  is polynomially parametrized by  <span class="math">u</span> , the result is obtained thanks to  <span class="math">\\deg_u(p) - 1</span>  exponentiations by  <span class="math">u</span>  and some additional  <span class="math">\\mathbb{F}_{p^k}</span>  operations. The number of these additional operations can be reduced by considering powers of the pairing [FKR11]. Note also that, thanks to the easy part of the final exponentiation, the squaring operations (which are widely used during the hard part) can be simplified. We can either use cyclotomic squarings [GS10], denoted  <span class="math">cS_{k}</span> , or compressed squarings [Kar13,AKL+11], denoted  <span class="math">s_k</span> . Compressed squarings are usually more efficient. However, this method has been developed in the case of degree 6 twists [Kar13,AKL+11]. There is no doubt that it can be adapted to the case of degree 4 twists (and then to KSS16 curves) but we did not find explicit formulas in the literature. Then, for a fairer comparison between the curves, we chose to consider both squaring methods in the following.</p>

    <p class="text-gray-300">In order to compare the different candidates, we need a common base. It cannot be the field  <span class="math">\\mathbb{F}_p</span>  because  <span class="math">p</span>  has not the same size in all cases. So we have to go to the data-words level. We will only give global estimates so we need to make some assumptions that are close to an average environment. Then, we assume that we work on a 32 bits device because it is a good average between software, FPGA and embedded devices. We will also assume that  <span class="math">\\mathbb{F}_p</span>  arithmetic is quadratic (even if the multiplication complexity can be subquadratic, the reduction usually stays quadratic). Finally, for simplicity, we will assume that  <span class="math">\\mathbb{F}_p</span>  multiplications and squarings have almost the same cost and we will neglect additions. Of course, these assumptions are very dependent on the device so we do not pretend that our result is valid in every case. Anyway, our goal here is not to get an universal comparison (which is not possible) but to have an idea of which curve has to be chosen to get the best efficiency. For a given precise device or context, such general estimates cannot replace a real implementation for a fair comparison.</p>

    <p class="text-gray-300">Pairing computation makes a large use of  <span class="math">\\mathbb{F}_{p^e}</span>  arithmetic. Let us first recall them in Table 12 for the considered values of  <span class="math">e</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp4</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">6M</td>

            <td class="px-3 py-2 border-b border-gray-700">9M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Squaring</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">5M</td>

            <td class="px-3 py-2 border-b border-gray-700">6M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 12. Complexities of  <span class="math">{\\mathbb{F}}_{{p}^{e}}</span>  arithmetic</p>

    <p class="text-gray-300">Concerning the  <span class="math">\\mathbb{F}_{p^k}</span>  arithmetic, the complexities are given in the literature in the pairing context for extensions of degree 12 [AFCK+13,DMHR15], 16 [ZL12] and 18 [AFCK+13]. They are summarized in Table 13.</p>

    <p class="text-gray-300">We made the simplistic assumption that the cost of Frobenius mapping in  <span class="math">\\mathbb{F}_{p^k}</span>  is always  <span class="math">(k - 1)M</span>  which is not always the case (for example for  <span class="math">p^2</span>  or  <span class="math">p^3</span>  powering) but this has negligible impact on our comparison (there are few such mapping and this remark holds for all the considered cases).</p>

    <p class="text-gray-300">8.3.1 BN curve. In this case, the optimal ate pairing is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\left(f _ {6 u + 2, Q} (P). \\ell_ {[ 6 u + 2 ] Q, [ p ] Q} (P). \\ell_ {[ 6 u + 2 + p ] Q, [ p ^ {2} ] Q} (P)\\right) ^ {\\frac {p ^ {1 2} - 1}{r}}</span></div>

    <p class="text-gray-300">It is explained in Section 6 that  <span class="math">u = 2^{114} + 2^{101} - 2^{14} - 1</span>  should be chosen to ensure the 128-bits security level and the best possible extension field arithmetic. Then  <span class="math">6u + 2</span>  has length 116 and Hamming weight 7. As a consequence, the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp18</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">54M</td>

            <td class="px-3 py-2 border-b border-gray-700">81M</td>

            <td class="px-3 py-2 border-b border-gray-700">108M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sparse multiplication</td>

            <td class="px-3 py-2 border-b border-gray-700">39M</td>

            <td class="px-3 py-2 border-b border-gray-700">63M</td>

            <td class="px-3 py-2 border-b border-gray-700">78M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Inversion</td>

            <td class="px-3 py-2 border-b border-gray-700">I+97M</td>

            <td class="px-3 py-2 border-b border-gray-700">I+134M</td>

            <td class="px-3 py-2 border-b border-gray-700">I+172M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Frobenius</td>

            <td class="px-3 py-2 border-b border-gray-700">11M</td>

            <td class="px-3 py-2 border-b border-gray-700">15M</td>

            <td class="px-3 py-2 border-b border-gray-700">17M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Squaring</td>

            <td class="px-3 py-2 border-b border-gray-700">36M</td>

            <td class="px-3 py-2 border-b border-gray-700">54M</td>

            <td class="px-3 py-2 border-b border-gray-700">66M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cyclotomic squaring</td>

            <td class="px-3 py-2 border-b border-gray-700">18M</td>

            <td class="px-3 py-2 border-b border-gray-700">36M</td>

            <td class="px-3 py-2 border-b border-gray-700">36M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compressed squaring</td>

            <td class="px-3 py-2 border-b border-gray-700">12M</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">24M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Simult. decompression of n elements</td>

            <td class="px-3 py-2 border-b border-gray-700">I+(24n-5)M</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">I+(51n-6)M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 13. Complexities of  <span class="math">{\\mathbb{F}}_{p}{}^{k}</span>  arithmetic</p>

    <p class="text-gray-300">Miller loop requires 116 doubling steps and 6 addition steps. Extra lines computations require 4 Frobenius mapping (to compute  <span class="math">[p]Q</span>  and  <span class="math">[p^2]Q</span> ), one addition step and one incomplete addition step. Then the overall cost is</p>

    <div class="my-4 text-center"><span class="math-block">1 1 6 (2 M _ {2} + 7 S _ {2} + 4 M) + 1 1 5 (S _ {1 2} + s M _ {1 2}) + 7 (1 1 M _ {2} + 2 S _ {2} + 4 M) + 4 M _ {2} + 4 M + 8 s M _ {1 2} + 4 F _ {1 2}</span></div>

    <p class="text-gray-300">Using Tables 12 and 13, this step requires 12068 multiplications in  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">There are many ways to compute the final exponentiation for BN curves. The most efficient one is given in [FKR11] and requires  <span class="math">I_{12} + 12M_{12} + 3cS_{12} + 4F_{12}</span>  in addition to the 3 exponentiation by  <span class="math">u</span>  (because  <span class="math">p</span>  has degree 4 in  <span class="math">u</span> ). As  <span class="math">u</span>  has length 114 and Hamming weight 4, each of these exponentiations requires 114 squarings and 3 multiplications. If the cyclotomic squaring are used, we need  <span class="math">114cS_{12} + 3M_{12} = 2214M</span>  according Table 13. If the compressed squaring technique is used, we additionally need the simultaneous decompression of 4 elements. Then, according to Table 13 each exponentiation by  <span class="math">u</span>  requires  <span class="math">1621M + I</span> .</p>

    <p class="text-gray-300">The final exponentiation then requires  <span class="math">7485M + I</span>  or  <span class="math">5706M + 4I</span>  depending on the way to perform squarings. Finally computing the optimal ate pairing for BN curve ensuring the 128-bits security level requires  <span class="math">19553M + I</span>  or  <span class="math">17774M + 4I</span>  depending on the way to perform squarings during the final exponentiation.</p>

    <p class="text-gray-300">8.3.2 BLS12 curve. The optimal ate pairing is simpler in this case since it is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\left(f _ {u, Q} (P)\\right) ^ {\\frac {p ^ {1 2} - 1}{r}}</span></div>

    <p class="text-gray-300">We have seen that the best choice of  <span class="math">u</span>  is  <span class="math">-2^{77} + 2^{50} + 2^{33}</span>  so that the Miller loop is made of 77 doubling steps and 2 addition steps. Then, its cost is</p>

    <div class="my-4 text-center"><span class="math-block">7 7 (2 M _ {2} + 7 S _ {2} + 4 M) + 7 6 (S _ {1 2} + s M _ {1 2}) + 2 (1 1 M _ {2} + 2 S _ {2} + 4 M) + 2 s M _ {1 2} = 7 7 0 8 M</span></div>

    <p class="text-gray-300">According [AFCK+13], the final exponentiation requires  <span class="math">I_{12} + 12M_{12} + 2cS_{12} + 4F_{12} = 825M + I</span>  in addition to the 5 exponentiation by  <span class="math">u</span>  (because  <span class="math">p</span>  has degree 6 in  <span class="math">u</span> ). As  <span class="math">u</span>  has length 77 and Hamming weight 3, each of these exponentiations requires 77 squarings and 2 multiplications. If the cyclotomic squaring are used, we need  <span class="math">77cS_{12} + 2M_{12} = 1494M</span> . If the compressed squaring technique is used, we additionally need the simultaneous decompression of 3 elements so that each exponentiation by  <span class="math">u</span>  requires  <span class="math">1099M + I</span> .</p>

    <p class="text-gray-300">The final exponentiation then requires  <span class="math">8295M + I</span>  or  <span class="math">6320M + 6I</span>  depending on the way to perform squarings. Finally computing the optimal ate pairing for BLS12 curve ensuring the 128-bits security level requires  <span class="math">16003M + I</span>  or  <span class="math">14028M + 6I</span> .</p>

    <p class="text-gray-300">8.3.3 KSS16 curve. For KSS16 curves, the optimal ate pairing is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(f _ {u, Q} (P). \\ell_ {[ u ] Q, [ p ] Q} (P)\\right) ^ {p ^ {3}}. \\ell_ {Q, Q} (P)\\right) ^ {\\frac {p ^ {1 6} - 1}{r}}</span></div>

    <p class="text-gray-300">and  <span class="math">u</span>  has been chosen to be  <span class="math">2^{35} - 2^{32} - 2^{18} + 2^{8} + 1</span>  in section 6. Then the Miller loop requires 35 doubling steps and 4 addition steps. According [ZL12], extra lines computations require 3 Frobenius mapping (2 to compute  <span class="math">[p]Q</span>  and one to raise to  <span class="math">p^3</span> ) and two incomplete addition steps. The overall cost is then</p>

    <div class="my-4 text-center"><span class="math-block">3 5 (2 M _ {4} + 8 S _ {4} + 8 M) + 3 4 (S _ {1 6} + s M _ {1 6}) + 4 (9 M _ {4} + 5 S _ {4} + 8 M) + 3 F _ {1 6} + 5 M _ {4} + S _ {4} + 1 6 M + 6 s M _ {1 6} = 7 5 3 4 M</span></div>

    <p class="text-gray-300">According [GF16], the final exponentiation requires  <span class="math">I_{16} + 32M_{16} + 34cS_{16} + 24M_4 + 8F_{16}</span>  in addition to the 9 exponentiation by  <span class="math">u</span>  (because  <span class="math">p</span>  has degree 10 in  <span class="math">u</span> ). As  <span class="math">u</span>  has length 35 and Hamming weight 5, each of these exponentiations requires 35 cyclotomic squarings and 4 multiplications. According Table 13, each exponentiation by  <span class="math">u</span>  then requires  <span class="math">1584M</span> . Note that we do not find in the literature formulas for compressed squaring in the KSS16 case. The final exponentiation then requires  <span class="math">18542M + I</span> . Finally computing the optimal ate pairing for KSS16 curve ensuring the 128-bits security level requires  <span class="math">26076M + I</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\left(f _ {u, Q} (P). f _ {3, Q} (P) ^ {p}. \\ell_ {[ u ] Q, [ 3 p ] Q} (P)\\right) ^ {\\frac {p ^ {1 8} - 1}{r}}</span></div>

    <p class="text-gray-300">The best choice of  <span class="math">u</span>  to ensure the 128-bits security level is  <span class="math">2^{44} + 2^{22} - 2^9 + 2</span>  so that the Miller loop is made of 44 doubling steps and 3 addition steps. Extra lines computations require one addition step and one Frobenius mapping (to compute  <span class="math">f_{3,Q}(P)^p</span> ) together with one  <span class="math">\\mathbb{F}_{p^{18}}</span>  multiplication (to multiply the result by  <span class="math">f_{u,Q}(P)</span> ), 2 Frobenius mappings and one incomplete addition step [AFCK+13]. Then its cost is</p>

    <div class="my-4 text-center"><span class="math-block">4 4 (2 M _ {3} + 7 S _ {3} + 6 M) + 4 3 (S _ {1 8} + s M _ {1 8}) + 4 (1 1 M _ {3} + 2 S _ {3} + 6 M) + 4 s M _ {1 8} + M _ {1 8} + 3 F _ {1 8} + 4 M _ {3} + 6 M + s M _ {1 8} = 9 4 3 1 M</span></div>

    <p class="text-gray-300">According [FKR11,  <span class="math">\\mathrm{AFCK}^{+}13</span> ], the final exponentiation requires  <span class="math">I_{18} + 54M_{18} + 8cS_{18} + 29F_{18} = 6785M + I</span>  in addition to the 7 exponentiation by  <span class="math">u</span>  (because  <span class="math">p</span>  has degree 8 in  <span class="math">u</span> ). As  <span class="math">u</span>  has length 44 and Hamming weight 4, each of these exponentiations requires 44 squarings and 3 multiplications. If the cyclotomic squaring are used, we need  <span class="math">44cS_{18} + 3M_{18} = 1908M</span> . If the compressed squaring technique is used, we additionally need the simultaneous decompression of 4 elements so that each exponentiation by  <span class="math">u</span>  requires  <span class="math">1578M + I</span> .</p>

    <p class="text-gray-300">The final exponentiation then requires  <span class="math">20141M + I</span>  or  <span class="math">17831M + 8I</span>  depending on the way to perform squarings. Finally computing the optimal ate pairing for KSS18 curve ensuring the 128-bits security level requires  <span class="math">29572M + I</span>  or  <span class="math">27262M + 8I</span> .</p>

    <p class="text-gray-300">Let us first summarize the complexities obtained in the previous subsections.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using cyclotomic squarings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using compressed squarings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Base field size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN</td>

            <td class="px-3 py-2 border-b border-gray-700">19553M + I</td>

            <td class="px-3 py-2 border-b border-gray-700">17774M + 4I</td>

            <td class="px-3 py-2 border-b border-gray-700">461 bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12</td>

            <td class="px-3 py-2 border-b border-gray-700">16003M + I</td>

            <td class="px-3 py-2 border-b border-gray-700">14028M + 6I</td>

            <td class="px-3 py-2 border-b border-gray-700">461 bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS16</td>

            <td class="px-3 py-2 border-b border-gray-700">26076M + I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">340 bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">29572M + I</td>

            <td class="px-3 py-2 border-b border-gray-700">27262M + 8I</td>

            <td class="px-3 py-2 border-b border-gray-700">348 bits</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 14.  <span class="math">{\\mathbb{F}}_{p}</span>  complexities of optimal ate pairing computation</p>

    <p class="text-gray-300">We can obviously conclude that BLS12 curve is more efficient than BN one and that KSS16 is better than KSS18. It is more complicated to compare BLS12 and KSS16 because the base fields are not the same. For this, let us first compare the costs of  <span class="math">M</span>  which is depending on  <span class="math">p</span> . As explained in Section 8.2, we assumed that we are working on a 32-bits architecture but the theoretical results would be similar with another choice and, in any case, this will not</p>

    <p class="text-gray-300">replace real life implementations. For BN and BLS12 curves,  <span class="math">p</span>  has 461 bits so that 15 32-bits words are necessary. For the KSS curves, 11 32-bits words are necessary. As a consequence, we can assume that  <span class="math">M = 15^2 = 225</span>  for BN and BLS12 curves while  <span class="math">M = 11^2 = 121</span>  for KSS ones. Reporting these values in Table 14, we get the comparative table 15. In any case, the KSS16 curve gives the best result which was not expected at the beginning of this work. Of course</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using cyclotomic squarings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using compressed squarings</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN</td>

            <td class="px-3 py-2 border-b border-gray-700">4399425 + I</td>

            <td class="px-3 py-2 border-b border-gray-700">3999150 + 4I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS12</td>

            <td class="px-3 py-2 border-b border-gray-700">3600675 + I</td>

            <td class="px-3 py-2 border-b border-gray-700">3156300 + 6I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS16</td>

            <td class="px-3 py-2 border-b border-gray-700">3155196 + I</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS18</td>

            <td class="px-3 py-2 border-b border-gray-700">3578212 + I</td>

            <td class="px-3 py-2 border-b border-gray-700">3298702 + 8I</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 15. Comparative complexities of optimal ate pairing computation</p>

    <p class="text-gray-300">the complexity for the BLS12 curve using compressed squaring is very close to the complexity of the KSS16 curve with cyclotomic squarings and a practical implementation should be done to confirm the estimated result obtained here. But KSS16 curves have not been studied as much as the BN curves and, more generally, as curves having a degree 6 twist. Then we are quite confident that optimal pairing on the KSS16 curve given in section 7.1.3 can be improved for example by computing the formulas for compressed squaring in this case.</p>

    <p class="text-gray-300">It was already known that the BN curves, widely used in the literature for the 128-bits security level, do not ensure this security level because of the SexTNFS algorithm. In a recent paper, Menezes, Sarkar and Singh [MSS16] proposed new key sizes but their analysis is not precise enough. In this paper, we carefully estimated the complexity of this algorithm in the context of most common pairing families. We also explained why it is much more realistic than the one given in [MSS16] for any real life SexTNFS implementation. As a consequence, we give the updated security level of this curve which is in fact 100 bits. We also use this complexity estimation to determine the sizes of the finite field extensions that has to be used to ensure the 128, 192 and 256-bit security levels, and obtained values which are more than  <span class="math">66\\%</span>  larger than the formerly used ones. According to these recommendations, we generate new pairing parameters especially in the 128,192 and 256-bit security levels that are twist-secure (but also some that are twist and subgroup-secure). Finally, for the curves ensuring 128 bits of security we estimated the complexity of the optimal ate pairing for each proposed curve and concluded that BLS12 and, more surprisingly, KSS16 are the most efficient choices. Therefore we encourage the community to study more precisely these curves and to propose software or hardware implementation to confirm our conclusions. This study which is focused on the most popular families is probably not complete since other families and/or embedding degrees could be more interesting.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{ACMC}^{+}16</span>  G. Adj, I. Canales-Martínez, N. C. Cortés, A. Menezes, T. Oliveira, L. Rivera-Zamarripa, and F. Rodríguez-Henriquez. Computing discrete logarithms in cryptographically-interesting characteristic-three finite fields. Cryptology ePrint Archive, Report 2016/914, 2016. Adl94. L. M. Adleman. The function field sieve. In Algorithmic number theory symposium - ANTS I, volume 877 of Lecture notes in computer science, pages 108-121, 1994. <span class="math">\\mathrm{AFCK}^{+}13</span>  D. F. Aranha, L. Fuentes-Castaneda, E. Knapp, A. Menezes, and F. Rodríguez-Henriquez. Implementing pairings at the 192-bit security level. In Pairing-Based Cryptography - PAIRING 2012, volume 7708 of Lecture notes in computer science, 2013. <span class="math">\\mathrm{AFK}^{+}07</span>  K. Aoki, J. Franke, T. Kleinjung, A. Lenstra, and D. A. Osvik. A kilobit special number field sieve factorization. In Advances in Cryptology - ASIACRyPT 2007, volume 4833 of Lecture notes in computer science, pages 1-12, 2007.</p>

    <p class="text-gray-300">AH99. L. M. Adleman and M. D. A. Huang. Function field sieve method for discrete logarithms over finite fields. Information and Computation, 151(1):5–16, 1999.</p>

    <p class="text-gray-300">AKL^{+}11. D. Aranha, K. Karabina, P. Longa, C. H. Gebotys, and J López. Faster explicit formulas for computing pairings over ordinary curves. In Advances in Cryptology EUROCRYPT 2011, volume 6632 of ”Lecture notes in computer science”, pages 48–68, 2011.</p>

    <p class="text-gray-300">AMORH15. G. Adj, A. Menezes, T. Oliveira, and F. Rodriguez-Henriquez. Weakness of <span class="math">\\mathbb{F}_{2^{6}\\cdot 1429}</span> and <span class="math">\\mathbb{F}_{2^{4}\\cdot 3041}</span> for discrete logarithm cryptography. Finite Fields and Their Applications, 32:148–170, 2015.</p>

    <p class="text-gray-300">BCM^{+}15. Paulo S. L. M. Barreto, Craig Costello, Rafael Misoczki, Michael Naehrig, Geovandro C. C. F. Pereira, and Gustavo Zanon. Subgroup security in pairing-based cryptography. In Kristin Lauter and Francisco Rodríguez-Henríquez, editors, Progress in Cryptology – LATINCRYPT 2015: 4th International Conference on Cryptology and Information Security in Latin America, Guadalajara, Mexico, August 23-26, 2015, Proceedings, pages 245–265, Cham, 2015. Springer International Publishing.</p>

    <p class="text-gray-300">BD17. R. Barbulescu and S. Duquesne. Online supplement for ”updating keysizes of pairings”,, 2017. Downloadable from https://webusers.imj-prg.fr/~razvan.barbaud/Pairings/Pairings.html.</p>

    <p class="text-gray-300">BF01. D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. In Advances in Cryptology – CRYPTO 2001, volume 2139 of Lecture notes in computer science, pages 213–229, 2001.</p>

    <p class="text-gray-300">BGGM14. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Discrete logarithms in GF(<span class="math">p^{2}</span>) — 160 digits, 2014. Announcement available at the NMBRTHRY archives, item 004706.</p>

    <p class="text-gray-300">BGGM15a. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture notes in computer science, pages 129–155, 2015.</p>

    <p class="text-gray-300">BGGM15b. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. New record in <span class="math">\\mathbb{F}_{p^{3}}</span>, 2015. Available online at https://webusers.imj-prg.fr/~razvan.barbaud/p3dd52.pdf.</p>

    <p class="text-gray-300">BGI^{+}14. C. Bouvier, P. Gaudry, L. Imbert, H. Jeljeli, and E. Thomé. Discrete logarithms in GF(p) — 180 digits, 2014. Announcement available at the NMBRTHRY archives, item 004703.</p>

    <p class="text-gray-300">BGJT14. R. Barbulescu, P. Gaudry, A. Joux, and E. Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Advances in Cryptology - EUROCRYPT 2014, volume 8441 of Lecture notes in computer science, pages 1–16, 2014.</p>

    <p class="text-gray-300">BGK15. R. Barbulescu, P. Gaudry, and T. Kleinjung. The tower number field sieve. In Advances in Cryptology – ASIACRYPT 2015, volume 9453 of Lecture notes in computer science, pages 31–55, 2015.</p>

    <p class="text-gray-300">BGW05. D. Boneh, C. Gentry, and B. Waters. Collusion resistant broadcast encryption with short ciphertexts and private keys. In Advances in Cryptology - CRYPTO 2005, volume 3621 of Lecture notes in computer science, pages 258–275, 2005.</p>

    <p class="text-gray-300">BKK^{+}. J. Bos, M. Kaihara, T. Kleinjung, A. Lenstra, and P Montgomery. On the security of 1024-bit RSA and 160-bit elliptic curve cryptography. Cryptology ePrint Archive, Report 2009/389.</p>

    <p class="text-gray-300">BL17. R. Barbulescu and A. Lachand. Some mathematical remarks on the polynomial selection in NFS. Mathematics of Computation, 86(303):397–418, 2017.</p>

    <p class="text-gray-300">BLJP93. J. P. Buhler, H. Lenstra Jr., and C. Pomerance. Factoring integers with the number field sieve. In The development of the number field sieve, volume 1554 of Lecture notes in mathematics, pages 50–94. 1993.</p>

    <p class="text-gray-300">BLS03. P. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In Security in Communication Networks, volume 2576 of Lecture notes in computer science, pages 257–267, 2003.</p>

    <p class="text-gray-300">BLS04. D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. Journal of cryptology, 17(4):297–319, 2004.</p>

    <p class="text-gray-300">BN05. P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography–SAC 2005, volume 3006 of Lecture notes in computer science, pages 319–331, 2005.</p>

    <p class="text-gray-300">BP14. R. Barbulescu and C. Pierrot. The multiple number field sieve for medium- and high-characteristic finite fields. LMS Journal of Computation and Mathematics, 17:230–246, 2014. The published version contains an error which is corrected in version 2 available at https://hal.inria.fr/hal-00952610.</p>

    <p class="text-gray-300">CEP83. E. R. Canfield, P. Erdös, and C. Pomerance. On a problem of Oppenheim concerning “factorisatio numerorum”. Journal of Number Theory, 17(1):1–28, 1983.</p>

    <p class="text-gray-300">CH02. S. Cavallar Hedwig. On the number field sieve integer factorisation algorithm. PhD thesis, Universiteit Leiden, 2002.</p>

    <p class="text-gray-300">Cop84. D. Coppersmith. Fast evaluation of logarithms in fields of characteristic two. IEEE transactions in information theory, 30(4):587–594, 1984.</p>

    <p class="text-gray-300">Cop93. D. Coppersmith. Solving linear equations over GF(2): block Lanczos algorithm. Linear algebra and its applications, 192:33–60, 1993.</p>

    <p class="text-gray-300">Cop94. D. Coppersmith. Solving homogeneous linear equations over GF(2) via block Wiedemann algorithm. Mathematics of Computation, 62(205):333–350, 1994.</p>

    <p class="text-gray-300">CS06. A. Commeine and I. Semaev. An algorithm to solve the discrete logarithm problem with the number field sieve. In Public Key cryptography – PKC 2006, volume 3958 of Lecture notes in computer science, pages 174–190, 2006.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CSF^{+}11. R. Cheung, S.Duquesne, J. Fan, N. Guillermin, I. Verbauwhede, and G. X. Yao. FPGA implementation of pairings using residue number system and lazy reduction. In Cryptographic Hardware and Embedded Systems - CHES 2011, volume 6917 of Lecture notes in computer science, pages 421–441, 2011.</li>

      <li>Det14. J. Detrey. FFS factory: Adapting Coppersmith’s ”factorization factory” to the function field sieve. Cryptology ePrint Archive, Report 2014/419, 2014.</li>

      <li>DMHR15. S. Duquesne, N. El Mrabet, S. Haloui, and F. Rondepierre. Choosing and generating parameters for low level pairing implementation on BN curves. Cryptology ePrint Archive, Report 2015/1212, 2015.</li>

      <li>DSD07. A. J. Devegili, M. Scott, and R. Dahab. Implementing cryptographic pairings over Barreto-Naehrig curve. In Pairing-based cryptography – Pairing 2007, volume 4575 of Lecture notes in computer science, pages 197–207, 2007.</li>

      <li>EMJ17. N. El Mrabet and M. Joye. Guide to Pairing-Based Cryptography. Chapman & Hall/CRC Cryptography and Network Security Series. CRC Press, 2017.</li>

      <li>FGHT17. J. Fried, P. Gaudry, N. Heninger, and E. Thomé. A kilobit hidden SNFS discrete logarithm computation. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, volume 10210 of Lecture notes in computer science, pages 202–231, 2017.</li>

      <li>FKR11. L. Fuentes-Castañeda, E. Knapp, and F. Rdrǐuez-Henríquez. Faster hashing to <span class="math">\\mathbb{G}_{2}</span>. In Selected Areas in Cryptography - SAC 2011, volume 7118 of Lecture Notes in Computer Science, pages 412–430, 2011.</li>

      <li>FST10. D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. Journal of cryptology, 23(2):224–280, 2010.</li>

      <li>GAL^{+}13. G. Grewal, R. Azarderakhsh, P. Longa, S. Hu, and D. Jao. Efficient implementation of bilinear pairings on ARM processors. In Selected Areas in Cryptography, volume 7707 of Lecture Notes in Computer Science, pages 149–165, 2013.</li>

      <li>GF16. L. Ghammam and E. Fouotsa. Adequate elliptic curves for computing the product of n pairings. In Arithmetic of Finite Fields – WAIFI 2016, volume 10064 of Lecture notes in computer science, pages 36–352, 2016.</li>

      <li>GGMT17. L. Grémy, A. Guillevic, F. Morain, and E. Thomé. Computing discrete logarithms in <span class="math">\\text{GF}(p^{6})</span>. In Selected Areas in Cryptography – SAC 2017, Lecture notes in computer science, 2017.</li>

      <li>GGMZ13a. F. Göloğlu, R. Granger, G. McGuire, and J. Zumbrägel. Solving a 6120-bit DLP on a desktop computer. In Selected Areas in Cryptography– SAC, volume 8282 of Lecture notes in computer science, pages 136–152, 2013.</li>

      <li>GGMZ13b. F. Göloğlu, R. Granger, G. McGuire, and J. Zumbrägel. On the function field sieve and the impact of higher splitting probabilities: Application to discrete logarithms in <span class="math">\\mathbb{F}_{2^{1071}}</span>, 2013. Cryptology ePrint Archive, Report 2013/074.</li>

      <li>GGV16. P. Gaudry, L. Grémy, and M. Videau. Collecting relations in the number field sieve in <span class="math">\\text{GF}(p^{6})</span>. LMS Journal of Computation and Mathematics, 19(A):332–350, 2016.</li>

      <li>GKZ14a. R. Granger, T. Kleinjung, and J. Zumbrägel. Breaking ‘128-bit secure’ supersingular binary curves. In Advances in cryptology – CRYPTO 2014, volume 8617 of Lecture notes in computer science, pages 126–145, 2014.</li>

      <li>GKZ14b. R. Granger, T. Kleinjung, and J. Zumbrägel. On the powers of 2. Cryptology ePrint Archive, Report 2014/300, 2014.</li>

      <li>GKZ17. R. Granger, T. Kleinjung, and J. Zumbrägel. On the discrete logarithm problem in finite fields of fixed characteristic. Transactions of the American Mathematical Society, 2017.</li>

      <li>GMT16. A. Guillevic, F. Morain, and E. Thomé. Solving discrete logarithms on a 170-bit MNT curve by pairing reduction. In Selected Areas in Cryptography – SAC 2016, volume 10532 of Lecture notes of computer science, 2016.</li>

      <li>Gor93. D. Gordon. Discrete logarithms in <span class="math">\\text{GF}(p)</span> using the number field sieve. SIAM J. Discret. Math., 6(1):124–138, 1993.</li>

      <li>GS10. R. Granger and M. Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. In Public Key Cryptography - PKC 2010, volume 6056 of Lecture notes in computer science, pages 209–223, 2010.</li>

      <li>GSNB11. C. C. F. Pereira Geovandro, M. A. Jr. Simplicio, M. Naehrig, and P. Barreto. A family of implementation-friendly BN elliptic curves. Journal of Systems and Software, 84(8):1319–1326, 2011.</li>

      <li>HAKT15. K. Hayasaka, K. Aoki, T. Kobayashi, and T. Takagi. A construction of 3-dimensional lattice sieve for number field sieve over <span class="math">\\text{GF}(p^{n})</span>. Cryptology ePrint Archive, Report 2015/1179, 2015. http://eprint.iacr.org/2014/300.</li>

      <li>HSST12. T. Hayashi, T. Shimoyama, N. Shinohara, and T. Takagi. Breaking pairing-based cryptosystems using <span class="math">\\eta_{t}</span> pairing over <span class="math">\\text{GF}(\\mathbb{J}^{97})</span>. In Advances in cryptology – ASIACRYPT 2012, volume 7658 of Lecture notes in computer science, pages 43–60, 2012.</li>

      <li>HSV06. F. Hess, N. Smart, and F. Vercauteren. The Eta pairing revisited. IEEE Transactions on Information Theory, 52(10):4595–4602, 2006.</li>

      <li>HSW^{+}10. T. Hayashi, N. Shinohara, L. Wang, S. Matsuo, M. Shirase, and T. Takagi. Solving a 676-bit discrete logarithm problem in <span class="math">\\text{GF}(\\mathbb{J}^{6n})</span>. In Public Key cryptography – PKC 2010, volume 6056 of Lecture notes in computer science, pages 351–367, 2010.</li>

      <li>IEE17. IEEE. 1363.3-2013 - IEEE standard for identity-based cryptographic techniques using pairings, 2017. can be purchased online at http://ieeexplore.ieee.org/document/6662370/.</li>

    </ul>

    <p class="text-gray-300">ISO. Iso/iec 18033-5:2015, 2015. can be purchased online at https://www.iso.org/obp/ui/#iso:std:59948:en.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JK16] J. Jeong and T. Kim. Extended tower number field sieve with application to finite fields of arbitrary composite extension degree. Cryptology ePrint Archive, Report 2016/526, 2016. http://eprint.iacr.org/2016/526.</li>

      <li>[JL02] A. Joux and R. Lercier. The function field sieve is quite special. In Algorithmic number theory symposium – ANTS V, volume 2369 of Lecture notes in computer science, pages 431–445, 2002.</li>

      <li>[JL03] A. Joux and R. Lercier. Improvements to the general number field for discrete logarithms in prime fields. Mathematics of Computation, 72(242):953–967, 2003.</li>

      <li>[JL06] A. Joux and R. Lercier. The function field sieve in the medium prime case. In Advances in Cryptology –EUROCRYPT 2006, volume 4005 of Lecture notes in computer science, pages 254–270, 2006.</li>

      <li>[JLSV06] A. Joux, R. Lercier, N. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In Advances in Cryptology - CRYPTO 2006, volume 4117 of Lecture notes in computer science, pages 326–344, 2006.</li>

      <li>[Jou13a] A. Joux. Faster index calculus for the medium prime case application to 1175-bit and 1425-bit finite fields. In Advances in cryptology – EUROCRYPT 2013, volume 7881 of Lecture notes in computer science, pages 177–193, 2013.</li>

      <li>[Jou13b] A. Joux. Faster index calculus for the medium prime case application to 1175-bit and 1425-bit finite fields. In Advances in Cryptology – EUROCRYPT 2013, volume 7881 of Lecture notes in computer science, pages 177–193, 2013.</li>

      <li>[JP13] A. Joux and C. Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> – application to pairing-friendly constructions. In Pairing-Based Cryptography - Pairing 2013, volume 8365 of Lecture notes in computer science, pages 45–61, 2013.</li>

      <li>[JP14] Antoine Joux and Cécile Pierrot. Improving the polynomial time precomputation of Frobenius representation discrete logarithm algorithms. In Advances in Cryptology – ASIACRYPT 2014, volume 8873 of Lecture notes in computer science, pages 378–397, 2014.</li>

      <li>[Kar13] K. Karabina. Squaring in cyclotomic subgroups. Mathematics of Computation, 82(281), 2013.</li>

      <li>[KB16] T. Kim and R. Barbulescu. The extended tower number field sieve: A new complexity for the medium prime case. In Advances in Cryptology – CRYPTO 2016, volume 9814 of Lecture notes in computer science, pages 543–571, 2016.</li>

      <li>[KBL14] T. Kleinjung, J. Bos, and A. Lenstra. Mersenne factorization factory. In International Conference on the Theory and Application of Cryptology and Information Security, volume 8873 of Lecture notes in computer science, pages 358–377, 2014.</li>

      <li>[KDL^{+}16] T. Kleinjung, C. Diem, A. Lenstra, C. Priplata, and C. Stahlke. Discrete logarithms in GF(p) — 768 bits, 2016. Announcement available at the NMBRTHRY archives, item 004917.</li>

      <li>[KSS08] E. J. Kachisa, E. F. Schaefer, and M. Scott. Constructing Brezing-Weng pairing-friendly elliptic curves using elements in the cyclotomic field. In Pairing-Based Cryptography – Pairing 2008, volume 5209 of Lecture notes in computer science, pages 126–135, 2008.</li>

      <li>[Lan52] C. Lanczos. Solution of systems of linear equations by minimized iterations. J. Res. Nat. Bur. Standards, 49(1):33–53, 1952.</li>

      <li>[Len01a] A. Lenstra. Unbelievable security matching AES security using public key systems. In International Conference on the Theory and Application of Cryptology and Information Security, volume 2188 of Lecture notes in computer science, pages 67–86, 2001.</li>

      <li>[Len01b] A. Lenstra. Unbelievable security: Matching AES security using public key systems. In Advances in cryptology – ASIACRYPT 2001, volume 2248 of Lecture notes in computer science, pages 67–86, 2001.</li>

      <li>[LL97] C. H. Lim and P. J. Lee. A key recovery attack on discrete log-based schemes using a prime order subgroup. In Advances in Cryptology — CRYPTO ’97, volume 1294 of Lecture notes in computer science, pages 249–263, 1997.</li>

      <li>[LLJMP90] A. Lenstra, H. Lenstra Jr., M. Manasse, and J. Pollard. The number field sieve. In Proceedings of the twenty-second annual ACM symposium on Theory of computing, pages 564–572. ACM, 1990.</li>

      <li>[LN97] R. Lidl and H. Niederreiter. Finite Fields. Cambridge University Press, 1997.</li>

      <li>[LO90] B. LaMacchia and A. Odlyzko. Solving large sparse linear systems over finite fields. In Advances in cryptology – CRYPTO 1990, volume 537 of Lecture notes in computer science, pages 109–133, 1990.</li>

      <li>[Mat06] D. Matyukhin. Effective version of the number field sieve for discrete logarithms in the field GF(<span class="math">p^{k}</span>) (in Russian). Trudy po Discretnoi Matematike, 9:121–151, 2006.</li>

      <li>[Mil04] V. Miller. The Weil pairing and its efficient calculation. Journal of Cryptology, 17(4):235–261, 2004.</li>

      <li>[Mon95] P. Montgomery. A block Lanczos algorithm for finding dependencies over GF(2). In Advances in cryptology – EUROCRYPT 1995, volume 95, pages 106–120. Springer, 1995.</li>

      <li>[MPP^{+}. Dustin Moody, Rene C. Peralta, Ray A. Perlner, Andrew R. Regenscheid, Allen L. Roginsky, and Lidong Chen. Report on pairing-based cryptography-2015. can be freely downloaded from http://nvlpubs.nist.gov/nistpubs/jres/120/jres.120.002.pdf.</li>

      <li>[MSS16. A. Menezes, P. Sarkar, and S. Singh. Challenges with assessing the impact of NFS advances on the security of pairing-based cryptography. In Paradigms in cryptology – Mycrypt 2016, volume 10311 of Lecture notes in computer science, 2016.</li>

    </ul>

    <p class="text-gray-300">Mur98. B. Murphy. Modelling the yield of number field sieve polynomials. In Algorithmic number theory symposium– ANTS III, volume 1423 of Lecture notes in computer science, pages 137–150, 1998.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>NA13. European Network and Information Security Agency. Algorithms, key sizes and parameters report - 2013, 2013.</li>

      <li>NNS10. M. Naehrig, R. Niederhagen, and P. Schwabe. New software speed records for cryptographic pairings. In Progress in cryptology – LATINCRYPT 2010, volume 6212 of Lecture notes in computer science, pages 109–123, 2010.</li>

      <li>oSN12. National Institute of Standards and Technology (NIST). NIST special publication 800-57 part 1 (revised) : Recommendation for key management, part 1: General (revised), July 2012. Publication available online at http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf.</li>

      <li>Pie15. C. Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture notes in computer science, pages 156–170, 2015.</li>

      <li>SBC^{+}09. M. Scott, N. Benger, M. Charlemagne, L. J. Dominguez Perez, and E. J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. In Pairing-Based Cryptography - PAIRING 2009, volume 5671 of Lecture Notes in Computer Science, pages 78–88, 2009.</li>

      <li>Sch93. O. Schirokauer. Discrete logarithms and local units. Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, 345(1676):409–423, 1993.</li>

      <li>Sch00. O. Schirokauer. Using number fields to compute logarithms in finite fields. Mathematics of Computation, 69(231):1267–1283, 2000.</li>

      <li>Sch10. O. Schirokauer. The number field sieve for integers of low weight. Mathematics of Computation, 79(269):583–602, 2010.</li>

      <li>Sem02. I. Semaev. Special prime numbers and discrete logs in finite prime fields. Mathematics of Computation, 71(237):363–377, 2002.</li>

      <li>Sma12. N. Smart. ECRYPT II yearly report on algorithms and key sizes (2011-2012), 2012.</li>

      <li>SS16a. P. Sarkar and S. Singh. Fine tuning the function field sieve algorithm for the medium prime case. IEEE Transactions on Information Theory, 62(4):2233–2253, 2016.</li>

      <li>SS16b. P. Sarkar and S. Singh. A generalisation of the conjugation method for polynomial selection for the extended tower number field sieve algorithm. Cryptology ePrint Archive, Report 2016/537, 2016.</li>

      <li>SS16c. P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 429–458, 2016.</li>

      <li>SS16d. P. Sarkar and S. Singh. Tower number field sieve variant of a recent polynomial selection method. Cryptology ePrint Archive, Report 2016/401, 2016.</li>

      <li>UW14. T. Unterluggauer and E. Wenger. Efficient pairings and ECC for embedded systems. In Cryptographic Hardware and Embedded Systems - CHES 2014, volume 8731 of Lecture Notes in Computer Science, pages 298–315, 2014.</li>

      <li>Ver09. F. Vercauteren. Optimal pairings. IEEE Transactions of Information Theory, 56:455–461, 2009.</li>

      <li>VLFR08. F. Valette, R. Lercier, P.-A. Fouque, and D. Réal. Fault attack on elliptic curve Montgomery ladder implementation. In 5th Workshop on Fault Diagnosis and Tolerance in Cryptography, pages 92–98. IEEE, 2008.</li>

      <li>Wie86. D. Wiedemann. Solving sparse linear equations over finite fields. IEEE Trans. Inform. Theory, 32(1):54–62, 1986.</li>

      <li>Zaj10. Pavol Zajac. On the use of the lattice sieve in the 3D NFS. Tatra Mountains Mathematical Publications, 45(1):161–172, 2010.</li>

      <li>ZL12. X. Zhang and D. Lin. Analysis of optimum pairing products at high security levels. In Progress in Cryptology - INDOCRYPT 2012, volume 7668 of Lecture Notes in Computer Science, pages 412–430, 2012.</li>

    </ul>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix A Numerical integration</h2>

    <p class="text-gray-300">The size of the norms can by computed via numerical methods. Due to the known upper bounds we can certify that our results are correct up to an error probability of <span class="math">2^{-128}</span>, so that our chances to be wrong are equal to the chances of an attacker to break the system by pure luck.</p>

    <p class="text-gray-300">Given a polynomial <span class="math">f</span> and a sieve parameter <span class="math">A</span> let <span class="math">c(f,A)</span> be the average of value of <span class="math">\\{\\log_{2}N_{f}(e)\\mid e</span> tuple in sieving domain<span class="math">\\}</span> and <span class="math">U(f,A)</span> an upper bound on the norms on the <span class="math">f</span> side for pairs in the sieving domain. Let <span class="math">e_{1},\\ldots</span>, <span class="math">e_{T}</span> be random tuples in the sieving domain, uniformly and independently chosen. Then the Chernoff theorem applied to the random variables <span class="math">\\frac{\\log_{2}N_{f}(e_{1})}{\\log_{2}U(f)},\\ldots,\\frac{\\log_{2}N_{f}(e_{T})}{\\log_{2}U(f)}</span> states that for any constant <span class="math">\\varepsilon&gt;0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{Prob}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c(f,A)-+\\frac{1}{T}\\sum_{i=1}^{T}\\log_{2}N_{f}(e_{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\varepsilon\\log_{2}U(f,A)\\right)\\leq 2e^{-2\\varepsilon^{2}T}.$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\varepsilon=0.05</span> we solve the equation <span class="math">e^{-2\\varepsilon^{2}T}=2^{-128}</span> and obtain <span class="math">T=25600</span>.</p>

    <p class="text-gray-300">B One cannot change the complexity inside the frame of NFS</p>

    <p class="text-gray-300">Variants of NFS where <span class="math">p</span> is parametrized (SNFS, STNFS, SexTNFS, Joux-Pierrot) are considered to be the dream situation for an attacker. Fried et al. <em>[x10, Sec 4.1]</em> made a series of arguments very similar to the arguments that we use below.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Fact 1</h6>

    <p class="text-gray-300">Let <span class="math">p^{n}</span> be a prime power and let <span class="math">f,g\\in\\mathbb{Z}[x]</span> two polynomials which have a common factor <span class="math">\\varphi</span> modulo <span class="math">p</span> which is irreducible of degree <span class="math">n</span>. A variant of NFS which uses these polynomials and find all relations in a time proportional to or larger than the size of the sieving space (enumeration or sieving) has complexity at least <span class="math">L[32]^{1+o(1)}</span> where <span class="math">L[c]=\\exp(c^{1/3}\\log p^{n^{1/3}}\\log\\log(p^{n})^{2/3})</span>.</p>

    <p class="text-gray-300">Argument:</p>

    <p class="text-gray-300">step 1 We start by proving that <span class="math">p^{n}</span> divides the resultant of <span class="math">f</span> and <span class="math">g:p^{n}\\mid\\mathrm{Res}(f,g)</span>. Indeed, the resultant is the discriminant of the Sylvester matrix and further the volume of the lattice <span class="math">L=f\\mathbb{Z}[x]+g\\mathbb{Z}[x]</span> inside of <span class="math">\\mathbb{Z}[x]</span>. Since <span class="math">L^{\\prime}=p\\mathbb{Z}[x]+\\varphi\\mathbb{Z}[x]</span> is a lattice which contains <span class="math">L</span> we conclude that the volume of the latter divides the volume of the former : <span class="math">p^{n}</span> divides <span class="math">\\mathrm{Res}(f,g)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">step 2 Let <span class="math">d_{f}</span> and <span class="math">d_{g}</span> be the degrees of <span class="math">f</span> and <span class="math">g</span> and let <span class="math">E</span> be the sieve parameter (<span class="math">E=A^{\\eta}</span> in STNFS and SexTNFS). We have $\\mathrm{Res}(f,g)\\leq d_{f}\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d_{g}\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ which creates the constraint</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$d_{f}\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d_{g}\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq n\\log_{2}p.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We easily compute the size of the norms as $\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(d_{f}+d_{g})\\log_{2}E<span class="math">. At this point we note that we have to solve an optimization problem for which we set </span>K:=\\log_{2}(p^{n})<span class="math"> and </span>\\log_{2}E<span class="math">, which are constants, and we set the variables </span>x_{1}=d_{f}\\log_{2}E<span class="math">, </span>x_{2}=d_{g}\\log_{2}E<span class="math">, </span>y_{1}=\\max(1,\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> et </span>y_{2}=\\max(1,\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Hence the problem becomes:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ \\begin{array}[]{c}\\text{subject to }x_{1}y_{1}+x_{2}y_{2}\\geq K\\\\ y_{1},y_{2}\\geq 1\\\\ x_{1},x_{2}\\geq\\log_{2}E\\\\ \\text{minimize }x_{1}+y_{1}+x_{2}+y_{2}.\\end{array} \\] (4)</p>

    <p class="text-gray-300">step 3 Put <span class="math">F(x_{1},y_{1},x_{2},y_{2})=x_{1}y_{1}+x_{2}y_{2}</span> and <span class="math">G(x_{1},y_{1},x_{2},y_{2})=x_{1}+y_{1}+x_{2}+y_{2}</span>. The local extrema of <span class="math">G</span> on an set where <span class="math">F</span> is constant are obtained in one of the three situations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\nabla F\\parallel\\nabla G</span></li>

      <li>One of the variables is on the boundary (<span class="math">y_{1}=1</span>, <span class="math">y_{2}=1</span>, <span class="math">x_{1}=\\log_{2}E</span> or <span class="math">x_{2}=\\log_{2}E</span>), say <span class="math">y_{1}=1</span>, and <span class="math">\\nabla F\\mid_{\\{y_{1}=1\\}}\\parallel\\nabla G\\mid_{\\{y_{1}=1\\}}</span></li>

      <li>Two or more variables are on the boundary.</li>

    </ol>

    <p class="text-gray-300">We check that all extrema of points (i) and (ii) are maxima, so we are left with case (iii) which further divides in four cases:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">y_{1}=y_{2}=1</span> i.e. $\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math"> and </span>\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x_{1}=x_{2}=\\log_{2}E</span> i.e. <span class="math">d_{f}=d_{g}=1</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">y_{2}=1</span> and <span class="math">x_{1}=\\log_{2}E</span> i.e. $\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math"> and </span>d_{f}=1$ or vice-versa.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In case <span class="math">(1)</span>, the minimum is <span class="math">x_{1}+x_{2}+y_{1}+y_{2}=K+2</span> while in the case (2) the minimum is <span class="math">2\\log_{2}E+K/\\log_{2}E</span>. In case (3) we find that the optimized expression becomes <span class="math">x_{2}+(K-x_{2}\\log_{2}E)+1+\\log_{2}E</span> whose minimum is obtained when <span class="math">y_{1}=1</span> and we are again in case (2). Finally, in case (4) we have <span class="math">x_{2}y_{2}=K-1</span> and we have to minimize <span class="math">2+x_{2}+y_{2}</span>. This happens when <span class="math">x_{2}=y_{2}=\\sqrt{K-1}</span> and <span class="math">x_{1}+y_{1}+x_{2}+y_{2}=2+2\\sqrt{K-1}</span>.</p>

    <p class="text-gray-300">We can now compare the local minima and conclude that the global minimum is</p>

    <p class="text-gray-300"><span class="math">\\min G\\mid_{\\{F=K\\}}=2+2\\sqrt{K-1}.</span></p>

    <p class="text-gray-300">Note that the minimum is independent on the value of <span class="math">E</span></p>

    <p class="text-gray-300">step 4 It is classical to estimate the cost of NFS as <span class="math">B\\rho(\\frac{\\log_{2}N}{\\log_{2}B})+B^{2}</span> where <span class="math">N</span> is the norms product and <span class="math">\\rho</span> is Dickman’s function, which is <span class="math">2+2\\sqrt{K-1}\\approx 2\\sqrt{\\log_{2}(p^{n})}</span>. Then the classical analysis of NFS leads to the complexity of SexTNFS: <span class="math">L[32]^{1+o(1)}</span>. <span class="math">\\diamond</span></p>

    <p class="text-gray-300">Fried et al <em>[x14]</em> noted that a multiple variant of SexTNFS is impossible, so it is safe to say that Figure 1 cannot contain a curve below the one used in this article to approximate the security of parametrized pairings.</p>

    <p class="text-gray-300">Practical improvements will continue to come but they will modify only the o(1) term. A hypothetical algorithm which would beat SexTNFS needs to produce relations faster than by enumerating all elements of a sieving space, as it happened in small characteristic with pinpointing, or it would have to completely abandon the NFS diagram. Such an algorithm would be a great discontinuity, comparable to a possible sub-exponential algorithm for DLP on elliptic curves.</p>`;
---

<BaseLayout title="Updating key size estimations for pairings (2017/334)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/334
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
