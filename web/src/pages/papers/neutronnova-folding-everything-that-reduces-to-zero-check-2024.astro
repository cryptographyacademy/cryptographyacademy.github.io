---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1606';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'NeutronNova: Folding everything that reduces to zero-check';
const AUTHORS_HTML = 'Abhiram Kothapalli, Srinath Setty';

const CONTENT = `    <p class="text-gray-300">Abhiram Kothapalli University of California, Berkeley [AbhiramKothapalli] Srinath Setty Microsoft Research</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We introduce NeutronNova, a new folding scheme for the <em>zero-check</em> relation: an instance-witness pair is in the zero-check relation if a corresponding multivariate polynomial evaluates to zero for all inputs over a suitable Boolean hypercube. The folding scheme is a two-round protocol, and it internally invokes a <em>single</em> round of the sum-check protocol. The folding scheme is more efficient than prior state-of-the-art schemes and directly benefits from recent improvements to the sum-check prover. The prover’s work is the cost to commit to a witness and field operations in a single round of the sum-check protocol. So, if the witness contains “small” field elements, the prover only commits to “small” field elements. The verifier’s work is a constant number of group scalar multiplications, field operations, and hash computations. Moreover, the folding scheme generalizes to fold multiple instances at once and requires only <span class="math">\\log n</span> rounds of the sum-check protocol, where <span class="math">n</span> is the number of instances folded.</p>

    <p class="text-gray-300">As a corollary, we provide a folding scheme for any relation <span class="math">\\mathcal{R}</span> for which there is a reduction of knowledge (RoK) from <span class="math">\\mathcal{R}</span> to one or more instance-witness pairs in the zero-check relation. Such RoKs appear implicitly in prior lookup arguments (e.g., Lasso) and high-performance zkVMs for RISC-V (e.g., Jolt). We formalize these RoKs for several relations including indexed lookups, grand products, and CCS (which generalizes Plonkish, AIR, and R1CS). These are simple and constant round RoKs that leverage interaction to perform randomized checks on committed witness elements. Instead of <em>proving</em> these resulting zero-check instances as is done in prior proof systems such as Jolt, NeutronNova provides the more efficient option of continual folding of zero-check instances into a single running instance.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A folding scheme <em>[x10]</em> is a simple cryptographic protocol between a <em>prover</em> and a <em>verifier</em> that reduces the task of checking two NP instances into the task of checking a single instance. For example, suppose that a verifier holds two public inputs <span class="math">x_{1}</span> and <span class="math">x_{2}</span> and suppose that the prover wishes to prove that it knows two witnesses <span class="math">w_{1}</span> and <span class="math">w_{2}</span> such that they both satisfy a circuit <span class="math">C</span>, that is, <span class="math">C(w_{1},x_{1})=1</span> and <span class="math">C(w_{2},x_{2})=1</span>. Instead of proving both claims, the prover and the verifier can first invoke a folding scheme for circuit satisfiability to reduce both claims into a single claim of the same size about some witness <span class="math">w_{3}</span> and some public input <span class="math">x_{3}</span>. Furthermore, Kothapalli et al. <em>[x10, x11]</em> show that folding schemes when used in a recursive manner provides incrementally verifiable computation (IVC) <em>[x16]</em>, a powerful cryptographic primitive that</p>

    <p class="text-gray-300">allows producing a proof of correct execution of a “long running” computation in an incremental fashion—without having to prove the entire computation at once. Specifically, the prover to takes as input a proof <span class="math">\\pi_{i}</span> proving the correct execution of the first <span class="math">i</span> steps of a computation, and update it to produce a proof <span class="math">\\pi_{i+1}</span> proving the first <span class="math">i+1</span> steps of the computation. Notably, the prover’s per-step work to update a proof and the verifier’s work to verify a proof are both independent of the number of steps executed.</p>

    <p class="text-gray-300">Prior to folding schemes, IVC was constructed using succinct non-interactive arguments of knowledge (SNARKs) <em>[x18, x1]</em>, non-interactive arguments of knowledge (NARKs) with accumulation schemes <em>[x2, x3]</em>, or NARKs with split-accumulation schemes <em>[BCL^{+}21]</em>. Folding schemes avoid SNARKs and NARKs entirely and merely employ a particular type of reduction of knowledge <em>[x12]</em>. Furthermore, folding schemes not only provide a clean abstraction that is not tied to SNARKs or NARKs, they also provide a significantly more efficient prover than their predecessors. The efficiency stems from not having to produce a SNARK (or a NARK), but rather directly fold instances in some relation. In state-of-the-art folding schemes <em>[x13, x2, x4]</em>, the prover merely commits to its witness and performs some finite field operations.</p>

    <p class="text-gray-300">Motivating application: zkVMs. zkVMs refer to succinct proof systems for machine executions: given an assembly program designed to run on a machine (e.g., RISC-V), the prover proves the correct execution of the program. zkVMs are attractive in practice because one does not need to express their computation with circuits. Rather, a programmer expresses their desired computation in a high-level language (e.g., Rust) and compiles it to an assembly program using existing compiler toolchains. Furthermore, zkVMs can, by design, support proving program executions with arbitrary control flow.</p>

    <p class="text-gray-300">Technical challenges: time efficiency + space efficiency. A key challenge is to ensure that the zkVM prover runs efficiently, and, in particular, ensure that the prover’s space complexity is independent of the length of the execution proven. As demonstrated by Ben-Sasson et al. <em>[x1]</em> this can be achieved by utilizing (SNARK-based) IVC, which allows one to prove the correct execution of the supported machine cycle-by-cycle (or a fixed number of cycles at once). This ensures that the prover’s space requirements are essentially the space requirements of the program whose execution is being proven.</p>

    <p class="text-gray-300">Given that folding schemes offer a more efficient route to constructing IVC, at first blush, folding schemes appear to be a perfect fit for constructing time-efficient and space-efficient zkVMs. Indeed, this is the approach taken by the Nexus project <em>[x11]</em>, which effectively replaces SNARKs with folding schemes in the</p>

    <p class="text-gray-300">zkVM due to <em>[x1]</em> and builds a zkVM for RISC-V. While this certainly achieves better efficiency than <em>[x1]</em>, Nexus’s prover is still 3+ orders of magnitude slower than state-of-the-art zkVMs such as Jolt <em>[x2]</em>.</p>

    <p class="text-gray-300">Focusing on time efficiency, Jolt achieves a significant speedup through a carefully-designed set of reductions from the correctness of a RISC-V execution to a simpler set of problems in NP (a combination of lookups, grand products, and R1CS), which are then proven with a proof system derived from Spartan <em>[x24]</em>. In contrast, Nexus encodes the entire RISC-V execution with a universal circuit expressed with R1CS. This means that even though folding ensures that the prover’s space requirements do not exceed the size of (a circuit representation of) a single cycle (or a pre-defined number of cycles) and the per-constraint prover costs are low, the circuit encoding each cycle is substantial: 15,000 R1CS constraints <em>[x12]</em>. Specifically, the universal circuit pays for every instruction supported by the machine. Furthermore, it uses Merkle proofs to verify memory operations, which is up to three orders of magnitude less efficient than Jolt’s approach, which is a collection of techniques referred to as offline memory checking <em>[BEG^{+}91, CDD^{+}03, x26]</em>.</p>

    <p class="text-gray-300">Focusing on space efficiency, Jolt is a monolithic zkVM that can only execute a limited number of CPU cycles, where the limit is given by the amount of space available to the prover. In contrast, Nexus is a space-efficient zkVM that scales to any number of CPU cycles, thanks to the use of folding schemes.</p>

    <p class="text-gray-300">Research questions. The above motivates the following question: Can we design folding schemes that enable space-efficient zkVMs while still leveraging reductions from universal machine execution into more efficient problems?</p>

    <p class="text-gray-300">To answer this, we start with Jolt’s design paradigm of using a carefully-curated set of relations that imply the correctness of universal machine execution as opposed to directly proving machine execution via constraints. We bring this approach to the folding-based zkVM setting by designing a suite of optimized folding schemes for such relations, which can then be used instead of directly folding machine execution constraints. As such, the folding schemes that we provide serve as a starting point toward the goal of building a zkVM that is simultaneously space and time efficient.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 A technical overview our solution: NeutronNova</h3>

    <p class="text-gray-300">We introduce NeutronNova, a suite of folding schemes for relations that arise in the context of proving the correct execution of CPUs such as RISC-V.</p>

    <p class="text-gray-300">We design NeutronNova in a modular fashion to enable a rapid development of folding schemes for new relations that may arise in the future. To enable such extensibility, we design a folding scheme for a highly-expressive core-relation, zero-check, to which we can naturally reduce a variety of complex relations such</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. An overview of ZeroFold, our folding scheme for the zero-check relation underlying NeutronNova. An instance in the zero-check relation, ZC, is folded into a running instance consisting of instances in the power-check relation,  <span class="math">ZC_{PC}</span> , that checks that a vector commits to the powers of a random challenge, a variant of the sum-check relation NSC, and a variant of the sum-check relation that enforces the power-check relation  <span class="math">NSC_{PC}</span> . In the diagram, * indicates that one of the outputs of the zero-check reduction is a fresh  <span class="math">ZC_{PC}</span>  instance included in the output running instance.</p>

    <p class="text-gray-300">as CCS [STW23], lookups, and grand-products. We believe that this modular framework also eases the formal verification of a zkVM based on NeutronNova.</p>

    <p class="text-gray-300">In more detail, an instance-witness pair is in the zero-check relation if a prescribed multivariate polynomial, with coefficients that are a function of the instance and witness, evaluates to zero for all values over a suitable hypercube. As shown implicitly in prior work, a vast number of complex relations can be interactively reduced to the zero-check relation, often with minimal computation and communication [BFLS91,BFL92,Sha92,BTVW14,Set20,GWC19,GW20,SL20,CBBZ23,STW24,AST24]. For instance, the circuit satisfiability relation reduces to checking that a set of multiplication and addition gate constraints [BFLS91,Sha92,BFL92] evaluate to zero, the grand product relation reduces to checking a set of constraints between coefficients of polynomials at neighboring monomials evaluate to zero [SL20,GW20], and modern NP-complete relations, such as R1CS [GGPR13], CCS [STW23], and Plonkish [GWC19] reduce to checking that entry-wise constraints on a fixed set of vectors evaluate to zero. By formally modeling such interactive reductions as reductions of knowledge [KP23], a folding scheme for the zero-check relation would imply a folding scheme for all of these relations.</p>

    <p class="text-gray-300">We introduce ZeroFold, a two-round folding scheme for the zero-check relation. This folding scheme internally invokes a single round of the sum-check protocol [LFKN90]. The prover's work is in the folding scheme is the cost to commit to its witness and some finite field operations in the single round of</p>

    <p class="text-gray-300">the sum-check protocol. Notably, if the witness contains “small” field elements, the prover only commits to “small” field elements. This makes these commitments very fast to compute (an order of magnitude faster than committing to arbitrary field elements), a property also leveraged in prior works like Spartan <em>[x20, x21]</em>, HyperNova <em>[x13]</em>, Protostar <em>[x3]</em>, Lasso <em>[x22]</em>, and Jolt <em>[x1]</em>. Furthermore, our prover benefits from recent efficiency improvements to the sum-check prover <em>[x10]</em>. The verifier’s work is a constant number of group scalar multiplications, field operations, and hash computations. Our folding scheme naturally extends to folding an arbitrary number of instances at once (i.e, ZeroFold is a multi-folding scheme <em>[x13]</em>), while ensuring that costs grow only linearly for the prover and the verifier in the number of instances. Note that the communication within the single round of the sum-check protocol and the verifier’s work for sum-check messages do <em>not</em> depend on the number of instances folded. When folding <span class="math">n</span> instances, ZeroFold requires only <span class="math">\\log n</span> rounds of the sum-check protocol.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (Folding zero-check (Informal))</h6>

    <p class="text-gray-300">There exists a folding scheme for folding <span class="math">n\\geq 2</span> instances in the zero-check relation, <span class="math">\\mathsf{ZC}</span>, with <span class="math">1+\\log n</span> rounds, an <span class="math">O(\\log n)</span> communication complexity, an <span class="math">O(n)</span> prover time complexity, and an <span class="math">O(\\log n)</span> verifier time complexity.</p>

    <p class="text-gray-300">As a concrete example, suppose that the verifier holds two linearly homomorphic commitments <span class="math">\\overline{w}_{0}</span> and <span class="math">\\overline{w}_{1}</span>, and would like to fold the task of checking that the prover knows openings <span class="math">w_{0}\\in\\mathbb{F}^{n}</span> and <span class="math">w_{1}\\in\\mathbb{F}^{n}</span> such that, say, all the elements are <span class="math">0</span> or <span class="math">1</span>. This can be reduced to the task of folding two zero-check statements</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=w_{0}(x)\\cdot w_{0}(x)-w_{0}(x)</span> <span class="math">0</span> <span class="math">=w_{1}(x)\\cdot w_{1}(x)-w_{1}(x)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, where <span class="math">w_{i}(x)</span> indicates evaluating the polynomial representation of <span class="math">w_{i}</span> at location <span class="math">x</span> and <span class="math">\\ell=\\log n</span>.</p>

    <p class="text-gray-300">A prior approach <em>[x5, x6, x20, x4, x11, x12]</em>, notably from <em>[x6]</em>, for encoding zero-check is to embed each of the constraints into coefficients of a Lagrange polynomial, and then check that this polynomial is zero when evaluated at a random point. In particular the verifier first samples a challenge <span class="math">\\tau</span> and instead checks that</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot(w_{0}(x)\\cdot w_{0}(x)-w_{0}(x))</span> (1) <span class="math">0</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot(w_{1}(x)\\cdot w_{1}(x)-w_{1}(x)),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">X</span> is the corresponding decimal representation if <span class="math">x</span> is treated as the bit representation i.e., <span class="math">X=\\sum_{i=0}^{\\ell-1}2^{i}\\cdot x_{i}</span>. This essentially amounts to folding the sum-check problem, which checks the sum of evaluations of a polynomial over a</p>

    <p class="text-gray-300">suitable hypercube. While sum-check is decidedly an easier problem to work with, it is still not clear how to fold the above instances: the verifier cannot simply output a folded instance as a random linear combination of the input instances due to the inherent non-linearity of the summand polynomial.</p>

    <p class="text-gray-300">To solve the non-linearity issue, we devise a new folding technique that utilizes a <em>single</em> round of the sum-check protocol, which we refer to as SumFold. The essential idea in SumFold is that we can devise new polynomials <span class="math">f(b,x)</span> such that <span class="math">f(0,x)=w_{0}(x)</span> and <span class="math">f(1,x)=w_{1}(x)</span>. Then, checking Equations (1), and (2) is equivalent to checking that</p>

    <p class="text-gray-300"><span class="math">Q(B)=\\sum_{b\\in\\{0,1\\}}\\mathsf{eq}(b,B)\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot(f(B,x)\\cdot f(B,x)-f(B,x))</span> (3)</p>

    <p class="text-gray-300">is the zero polynomial, where <span class="math">\\mathsf{eq}</span> is a Lagrange polynomial such that <span class="math">\\mathsf{eq}(b,b^{\\prime})=1</span> if <span class="math">b=b^{\\prime}</span> and <span class="math">0</span> otherwise for <span class="math">b,b^{\\prime}\\in\\{0,1\\}</span>. Then, the verifier can check Equation (3) with overwhelming probability by sampling a random challenge <span class="math">\\beta\\in\\mathbb{F}</span> and checking that <span class="math">0=Q(\\beta)</span>.</p>

    <p class="text-gray-300">Then, by running the sum-check protocol <em>[x14]</em> on the outer sum for a <em>single</em> round, the verifier can reduce the task of checking Equation (3) to the task of checking</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot f(\\beta,x)\\cdot f(\\beta,x)-f(\\beta,x),</span></p>

    <p class="text-gray-300">for some value <span class="math">T</span>. By the construction of <span class="math">f</span>, for <span class="math">w\\leftarrow w_{1}+\\beta\\cdot w_{2}</span>, this amounts to checking</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot(w(x)\\cdot w(x)-w(x)).</span></p>

    <p class="text-gray-300">The verifier can accordingly output a folded instance <span class="math">\\overline{w}\\leftarrow\\overline{w}_{1}+\\beta\\cdot\\overline{w}_{2}</span>.</p>

    <p class="text-gray-300">Hence, the verifier has folded two zero-check instances into a single sum-check instance. The verifier can then fold in new zero-check instances by first reducing to a sum-check instance (the zero-check reduction in Figure 1), and then repeating the above procedure (the nested sum-check reduction in Figure 1).</p>

    <p class="text-gray-300">However, several challenges remain. First, with each additional zero-check instance, a new challenge <span class="math">\\tau</span> must be sampled, and polynomials encoding the powers of <span class="math">\\tau</span> (and the corresponding commitments) must also be folded. As it is too expensive for the verifier to compute these commitments in each folding step, this task must be outsourced to the prover. This places an additional burden on the verifier in each step to check that the claimed commitment to the powers of <span class="math">\\tau</span> indeed agrees with <span class="math">\\tau</span>. In applications such as IVC, where the verifier is represented as an arithmetic circuit, this is overly expensive and infeasible. Our idea here is to encode this check itself as <em>another</em> zero-check instance, which we refer to as <span class="math">\\mathsf{ZC_{PC}}</span>, and bootstrap the existing folding scheme to fold these checks</p>

    <p class="text-gray-300">alongside. Moreover, even on the prover’s end, committing to the full vector of the powers of <span class="math">\\tau</span> (which scales with <span class="math">2^{\\ell}</span>) is too expensive. We show how this can be circumvented by having the prover commit to two <span class="math">\\sqrt{n}</span>-sized vectors, one with the powers of <span class="math">\\tau</span> and the other with a strided powers of <span class="math">\\tau</span> (a similar pattern appears in tensor polynomial commitment schemes <em>[GLS^{+}23]</em>). The prover and the verifier can then consider a variant of the sum-check relation, which we refer to as the <em>nested sum-check relation</em> (<span class="math">\\mathsf{NSC}</span>), that computes the tensor product of these two vectors to produce the full powers of <span class="math">\\tau</span> on the fly. Figure 1 summarizes the resulting folding scheme.</p>

    <p class="text-gray-300">NeutronNova: Folding schemes for more complex relations</p>

    <p class="text-gray-300">NeutronNova is the resulting suite of folding schemes that result from sequentially composing a reduction of knowledge (RoK) from a relation <span class="math">\\mathcal{R}</span> to any number of zero-check instances with the folding scheme for zero-check.</p>

    <p class="text-gray-300">This immediately provides a new folding scheme with attractive efficiency characteristics for customizable constraint systems (CCS), an NP-complete relation that generalizes R1CS <em>[x11]</em>, Plonkish <em>[x12]</em>, and AIR <em>[x4]</em> and naturally reduces to zero-check. We provide a comparison between NeutronNova’s folding scheme for CCS and prior work in Section 1.2.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 1 (Folding CCS (Informal))</h6>

    <p class="text-gray-300">There exists a folding scheme for the CCS relation, <span class="math">\\mathsf{CCS}</span>, with the same round complexity, communication complexity, prover time complexity, and verifier time complexity as ZeroFold.</p>

    <p class="text-gray-300">Moreover, by the results of Kothapalli and Setty <em>[x15, Lemma 4]</em>, we have that a folding scheme for CCS induces a corresponding non-uniform IVC (NIVC) scheme (i.e., IVC that supports different functions in each step of execution) over arbitrary degree constraints with a matching cost profile.</p>

    <p class="text-gray-300">Beyond CCS, we formally describe a reduction of knowledge (RoK) from the grand-product relation, where a witness is a vector, and an instance is a commitment to a vector and a claimed product of all entries in the witness, to the zero-check relation. This RoK is based on the grand-product argument of Setty and Lee <em>[x23]</em> and it is a non-interactive RoK.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 2 (Folding grand-product (Informal))</h6>

    <p class="text-gray-300">There exists a folding scheme for folding <span class="math">n</span> instances in the grand-product relation, <span class="math">\\mathsf{GP}</span>, with <span class="math">2+\\log n</span> rounds and the same communication complexity, prover time complexity, and verifier time complexity as ZeroFold.</p>

    <p class="text-gray-300">We additionally describe a RoK from an indexed lookup relation to four instance-witness pairs in the grand product relation. This RoK is based on Lasso <em>[x26]</em> and consists of a single round of interaction. By sequentially composing the prior two RoKs, we get a RoK from indexed lookups to zero-checks and hence a folding scheme for indexed lookups. We compare this with prior lookup arguments for folding schemes in Section 1.2.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 3 (Folding lookup (Informal)).</h6>

    <p class="text-gray-300">There exists a folding scheme for folding <span class="math">n</span> instances in the lookup relation, LKP, with <span class="math">3+\\log 4n</span> rounds, and the same communication complexity, prover time complexity, and verifier time complexity as ZeroFold.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <p class="text-gray-300">HyperNova. HyperNova <em>[x13]</em> is a folding scheme for CCS, where the prover runs the sum-check protocol <em>[x11]</em> to reduce an instance-witness pair in CCS <em>[x17]</em> into an instance-witness pair in linearized CCS, which admits a simple folding scheme based on random linear combination without any additional help from the prover. Beyond committing to the witness, HyperNova’s prover’s work is merely finite field operations in the sum-check protocol. Furthermore, HyperNova is a multi-folding scheme that can fold <span class="math">k\\geq 2</span> instances at once. Leveraging this, <em>[x16]</em> show that HyperNova naturally extends to provide a generalization of IVC called PCD <em>[x2]</em>. One can apply their transformation to NeutronNova’s folding scheme for CCS to obtain PCD.</p>

    <p class="text-gray-300">NeutronNova improves upon HyperNova: NeutronNova avoids running the sum-check protocol in entirety, so NeutronNova’s prover’s work in the sum-check protocol is lower by <span class="math">\\approx$$2\\times</span>. More importantly, NeutronNova features a dramatically smaller verifier circuit. HyperNova’s verifier circuit performs <span class="math">k-1</span> group scalar multiplications and NeutronNova’s verifier circuit performs <span class="math">k+1</span> group scalar multiplications. However, HyperNova’s verifier circuit verifies the sum-check protocol messages from <span class="math">\\log m</span> rounds, where <span class="math">m</span> is the number of constraints in CCS. HyperNova’s verifier circuit incurs <span class="math">O(d\\cdot\\log m)</span> hash computations and field operations, where <span class="math">d</span> is the degree of CCS constraints. In contrast, NeutronNova’s verifier circuit incurs <span class="math">O(d)</span> hash computations and field operations. Overall, NeutronNova’s verifier circuit is smaller.</p>

    <p class="text-gray-300">Protostar. Protostar <em>[x3]</em> focuses on folding special-sound protocols (with a algebraic verifiers) and it provides special-sound protocols for various relations including Plonkish, CCS, and lookups. To fold special-sound protocols, Protostar folds the verifier of a non-interactive special sound protocol expressed as a relation. This relation can be naturally reduced to the zero-check relation.</p>

    <p class="text-gray-300">Focusing on their folding scheme for CCS, the prover’s work and the verifier circuit size under NeutronNova’s folding scheme for CCS are similar to that of Protostar’s. Unfortunately, Protostar cannot efficiently fold more than two instances at once. To fold <span class="math">k&gt;2</span> instances, Protostar has to fold them one-by-one increasing the verifier circuit size by a factor of <span class="math">O(k)</span> compared to folding two instances. Alternatively, one can attempt to fold all <span class="math">k</span> instances at once, but the costs grow exponentially in <span class="math">k</span> <em>[x6, §1.2]</em>. Furthermore, unlike Protostar, NeutronNova employs the sum-check protocol as a black box, so it can leverage recent optimizations <em>[x10, x12]</em> to the sum-check protocol.</p>

    <p class="text-gray-300">Protostar also describes a lookup argument within folding schemes. Their folding scheme is based on logarithmic derivatives <em>[x12]</em> (which relies on grand sums of</p>

    <p class="text-gray-300">ratios of field elements) whereas the RoK that we describe for lookups is based on Lasso <em>[x21]</em> (which relies on grand products). As described, they have similar asymptotic efficiency. However, by using the hybrid reduction of Quarks (§5.2), our approach can avoid commitments to arbitrary field elements. Regardless, we could devise a RoK from lookups to zero-checks relying on logarithmic derivatives.</p>

    <p class="text-gray-300">Recently, Bünz and Chen <em>[x1]</em> extend Protostar with access to a global read-write memory. One can replace Protostar with NeutronNova in their construction to achieve better efficiency, especially due to NeutronNova’s support for folding multiple instances at once.</p>

    <p class="text-gray-300">Protogalaxy. Protogalaxy <em>[x6]</em> extends Protostar <em>[x1]</em> to support folding <span class="math">k&gt;2</span> instances at once. In Protogalaxy, an instance is logarithmic in the number of constraints folded, whereas in NeutronNova, the instances are constant-sized. In Protogalaxy, the verifier circuit performs <span class="math">O(d+\\log m)</span> finite field operations and hash computations when folding two instances. Whereas, with NeutronNova, this is only <span class="math">O(d)</span>. Their prover time scales super-linearly with the number of instances folded i.e., <span class="math">O(k\\log k)</span>, whereas in NeutronNova, the prover time scales linearly with <span class="math">k</span>. Protogalaxy describes alternate schemes that scale better for larger values of <span class="math">k</span> and handle the more general case of multiple running instances, but remarks that it may have worse constants than their main protocol. In any case, the instances are still logarithmic in the number of constraints folded. Recent work <em>[EGS^{+}24]</em> applies Protogalaxy to build a relaxed version of IVC, where they apply Protogalaxy to a relation that appears closely related to our zero-check relation. One can replace Protogalaxy with NeutronNova in their construction and achieve better efficiency due to our improved folding scheme.</p>

    <p class="text-gray-300">LatticeFold. LatticeFold <em>[x2]</em> describes a HyperNova-like folding scheme in the lattice setting. Unlike most folding schemes including NeutronNova, LatticeFold provides plausible post-quantum security. However, LatticeFold, like HyperNova, runs the full sum-check protocol, so it incurs higher recursion overheads than NeutronNova. Furthermore, their prover must commit to low-norm versions of witness vectors and prove range checks to ensure that each entry in the committed vector is a value in the range <span class="math">[b]</span>. The degree of the sum-check is <span class="math">\\min(2b,d)</span>, so choosing a small value for <span class="math">b</span> (e.g., <span class="math">b=2</span>) makes the prover commit to an excessive number of witness vectors. On the other hand, choosing a large value of <span class="math">b</span> increases the degree of the sum-check protocol, which in turn increases the prover’s work in the sum-check protocol and the verifier circuit sizes.</p>

    <p class="text-gray-300">Folding schemes for non-homomorphic commitments. Recently, there is work to generalize Protostar-type folding schemes to non-homomorphic commitments (e.g., Merkle commitments to codewords) <em>[x3]</em>. Compared to NeutronNova, they provide plausible post-quantum security. Unfortunately, they still require excessive amounts of hashing to verify Merkle membership proofs. Furthermore, the resulting IVC schemes are limited to a bounded number of steps (i.e., concrete attacks exist for non-constant recursion depth).</p>

    <p class="text-gray-300">Mova and Ova. Mova <em>[x10]</em> is a recent folding scheme that improves on Nova <em>[x12]</em> by avoiding a commitment to the cross-term. NeutronNova (like</p>

    <p class="text-gray-300">its predecessors HyperNova and Protostar) naturally achieves this property. Furthermore, unlike NeutronNova, Mova is limited to folding two instances at once. Moreover, when folding two instances, Mova requires a logarithmic number of hashes and finite field operations in the verifier circuit, whereas NeutronNova requires only a constant number of hashes and finite field operations.</p>

    <p class="text-gray-300">Ova <em>[x12]</em> reduces the number of group scalar multiplications in Nova by 1. This is an improvement atop Nova in terms of verifier circuit sizes (by about 10–13%). Unfortunately, the prover still needs to compute and commit to a cross-term, which can contain arbitrary field elements even when witness elements are “small”, a problem solved by prior works <em>[x10, x2, x1]</em> including this work.</p>

    <p class="text-gray-300">Nebula. In a companion work, Nebula <em>[x1]</em> provides an efficient read-write memory primitive in folding schemes. The read-write memory is globally accessible across different steps of NIVC and beyond. To achieve this, Nebula provides a natural generalization of NIVC, which they refer to as commitment-carrying NIVC (CC-NIVC): a proof contains an incremental commitment to non-deterministic witness provided at each step of NIVC. To construct CC-IVC, they adapt HyperNova’s compiler to provide a compiler from multi-folding schemes to CC-NIVC. Using CC-NIVC, Nebula retrofits offline memory checking <em>[BEG^{+}91, x13, x18, x19]</em> within NIVC. Since they use a folding scheme as a black box, one can adapt their techniques to our setting and directly reduce read-write memory checking to zero-check and use NeutronNova’s folding scheme for zero-check. We leave this to the future work.</p>

    <p class="text-gray-300">Jolt+Nova. A naive approach <em>[x19]</em> to make Jolt space efficient is to recursively compose it with Nova <em>[x11]</em>: Jolt produces a proof of some number of CPU cycles at once, which is verified using a step of Nova. Unfortunately, it requires writing optimized circuits that check Jolt’s proofs. Furthermore, this approach requires producing a Jolt proof. In contract, rather than proofs, NeutronNova generates zero-check instances (roughly, witness commitments), which are then folded with a single round of the sum-check protocol. Furthermore, NeutronNova’s single-round sum-check protocol makes it more friendly to GPUs and ASICs than <span class="math">O(\\log^{2}n)</span> rounds of the sum-check protocol used in Jolt (where <span class="math">n</span> is the number of CPU cycles). Overall, NeutronNova provides a more efficient and a more direct route to build zkVMs that are both space and time efficient.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section, we fix our notation and recall reductions of knowledge, which we use throughout our development. In Appendix A, we formally present multi-linear polynomials and relevant properties, commitment schemes, arguments of knowledge, and IVC.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.1 Notation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">\\lambda</span> to denote the security parameter. We let <span class="math">\\mathsf{negl}(\\lambda)</span> to denote a negligible function in <span class="math">\\lambda</span>. We write <span class="math">\\Pr[X]\\approx\\epsilon</span> to mean that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X]-\\epsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)<span class="math">. Throughout the paper, the depicted asymptotics depend on </span>\\lambda<span class="math">, but we elide this for brevity. We let PPT denote probabilistic polynomial time and let EPT denote expected probabilistic polynomial time. We let </span>[n]<span class="math"> denote the set </span>\\{1,\\ldots,n\\}<span class="math">. We let </span>\\{u_{i}\\}_{i\\in[n]}<span class="math"> denote the set </span>\\{u_{1},\\ldots,u_{n}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let <span class="math">\\mathbb{F}</span> to denote a finite field (e.g., the prime field <span class="math">\\mathbb{F}_{p}</span> for a large prime <span class="math">p</span>) and let <span class="math">\\mathbb{F}^{n}</span> denote vectors of length <span class="math">n</span> over elements in <span class="math">\\mathbb{F}</span>. We write <span class="math">\\mathbb{F}^{d}[X_{1},\\ldots,X_{n}]</span> to denote multivariate polynomials over field <span class="math">\\mathbb{F}</span> in the variables <span class="math">(X_{1},\\ldots,X_{n})</span> with degree bound <span class="math">d</span> for each variable. We omit the superscript if there is no degree bound. We denote vectors as <span class="math">\\vec{v}=(v_{1},\\ldots,v_{n})</span>. Given a vector of polynomials <span class="math">\\vec{g}</span>, we let <span class="math">\\vec{g}(x)=(g_{1}(x),\\ldots,g_{n}(x))</span>. We let <span class="math">\\mathsf{eq}(x,y)\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell},Y_{1},\\ldots,Y_{\\ell}]</span> denote the polynomial that outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\ell}</span>. For vector <span class="math">v\\in\\mathbb{F}^{n}</span> we let <span class="math">\\widetilde{v}\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\log n}]</span> denote the multilinear polynomial extension of <span class="math">v</span> (i.e., <span class="math">\\widetilde{v}(i)=\\sum_{j}\\mathsf{eq}(i,j)\\cdot v_{j}</span>).</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 Reductions of Knowledge</h3>

    <p class="text-gray-300">We now recall the reductions of knowledge framework, introduced by Kothapalli and Parno <em>[x10]</em>. Reductions of knowledge are a generalization of arguments of knowledge, in which a verifier interactively <em>reduces</em> checking a prover’s knowledge of a witness in a relation <span class="math">\\mathcal{R}_{1}</span> to checking the prover’s knowledge of a witness in another (simpler) relation <span class="math">\\mathcal{R}_{2}</span>. In particular, both parties take as input a claimed instance <span class="math">u_{1}</span> to be checked, and the prover additionally takes as input a corresponding witness <span class="math">w_{1}</span> such that <span class="math">(u_{1},w_{1})\\in\\mathcal{R}_{1}</span>. After interaction, the prover and verifier together output a new statement <span class="math">u_{2}</span> to be checked in place of the original statement, and the prover additionally outputs a corresponding witness <span class="math">w_{2}</span> such that <span class="math">(u_{2},w_{2})\\in\\mathcal{R}_{2}</span>.</p>

    <p class="text-gray-300">We modify the original definition to account for the preprocessed setting, in which a deterministic <em>encoder</em> algorithm preprocesses a portion of the statement called the structure (typically encoding a circuit or set of constraints) <em>once</em> and outputs a prover and verifier key which can be used to verify any number of witnesses (e.g., variable assignments) against this structure. We enable the encoder to additionally output a new structure to check the output instance-witness pair against (this can be preprocessed by a subsequent encoder).</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 1 (Reduction of Knowledge <em>[x10]</em>).</h6>

    <p class="text-gray-300">Consider relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> over public parameters, structure, instance, and witness tuples. A reduction of knowledge from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic algorithm <span class="math">\\mathcal{K}</span>, called the generator, the prover, the verifier and the encoder respectively with the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(\\lambda,n)\\to\\mathsf{pp}</span>: Takes as input security parameter <span class="math">\\lambda</span> and size parameters <span class="math">n</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})\\to(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span> and structure <span class="math">\\mathsf{s}_{1}</span>. Outputs prover key <span class="math">\\mathsf{pk}</span>, verifier key <span class="math">\\mathsf{vk}</span>, and updated structure <span class="math">\\mathsf{s}_{2}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},u_{1},w_{1})\\to(u_{2},w_{2})</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, and an instance-witness pair <span class="math">(u_{1},w_{1})</span>. Interactively reduces the task of checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span> to the task of checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{2},w_{2})\\in\\mathcal{R}_{2}</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pk},u_{1})\\to u_{2}</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, and an instance <span class="math">u_{1}</span> in <span class="math">\\mathcal{R}_{1}</span>. Interactively reduces the task of checking instance <span class="math">u_{1}</span> to the task of checking a new instance <span class="math">u_{2}</span> in <span class="math">\\mathcal{R}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> denote the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. We treat <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> as a function that takes as input <span class="math">((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1})</span> and runs the interaction on the prover’s input <span class="math">(\\mathsf{pk},u_{1},w_{1})</span> and the verifier’s input <span class="math">(\\mathsf{pp},u_{1})</span>. At the end of the interaction, <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> outputs the verifier’s instance <span class="math">u_{2}</span> and the prover’s witness <span class="math">w_{2}</span>. A reduction of knowledge <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies the following conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For any PPT adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n)</span>, <span class="math">(\\mathsf{s}_{1},u_{1},w_{1})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span> and <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})</span> we have that the prover’s output instance is equal to the verifier’s output instance <span class="math">u_{2}</span>, and that</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathsf{s}_{2},\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1}))\\in\\mathcal{R}_{2}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness: For any expected polynomial-time adversaries <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{P}^{*}</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n)</span>, <span class="math">(\\mathsf{s}_{1},u_{1},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})</span>, we have that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[(\\mathsf{pp},\\mathsf{s}_{1},u_{1},\\mathcal{E}(\\mathsf{pp},\\mathsf{s},u_{1},\\mathsf{st}))\\in\\mathcal{R}_{1}]\\approx\\Pr[(\\mathsf{pp},\\mathsf{s}_{2},\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},\\mathsf{st}))\\in\\mathcal{R}_{2}].</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public reducibility: There exists a deterministic polynomial-time function <span class="math">\\varphi</span> such that for any PPT adversary <span class="math">\\mathcal{A}</span> and expected polynomial-time adversary <span class="math">\\mathcal{P}^{*}</span>, given</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n),</span> <span class="math">(\\mathsf{s}_{1},u_{1},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp}),</span> <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1}),</span></p>

    <p class="text-gray-300">and <span class="math">(u_{2},w_{2})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},\\mathsf{st})</span> with the interaction transcript <span class="math">\\mathsf{tr}</span>, we have that <span class="math">\\varphi(\\mathsf{pp},\\mathsf{s}_{1},u_{1},\\mathsf{tr})=u_{2}</span>.</p>

    <p class="text-gray-300">As with arguments of knowledge, we can define various additional properties for reductions of knowledge such as succinctness (the communication is sublinear in the witness size), non-interactivity (the interaction consists of a single message from the prover), public-coin (the verifier only sends random challenges), and tree-extractability (there exists an extractor that can produce a satisfying witness given a tree of accepting transcripts). We define these properties in Appendix A.3.</p>

    <p class="text-gray-300">Typically, we are interested in reducing several relations at once. We can interpret several relations as a single relation using the following product operator.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2 (Relation product).</h6>

    <p class="text-gray-300">For relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> over public parameter, structure, instance, and witness pairs we define the relation product as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{1}\\times\\mathcal{R}_{2}=\\left\\{\\left(\\mathsf{pp},\\mathsf{s},(u_{1},u_{2}),(w_{1},w_{2})\\right)\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(\\mathsf{pp},\\mathsf{s},u_{1},w_{1}\\right)\\in\\mathcal{R}_{1},\\left(\\mathsf{pp},\\mathsf{s},u_{2},w_{2}\\right)\\in\\mathcal{R}_{2}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let <span class="math">\\mathcal{R}^{n}</span> denote <span class="math">\\mathcal{R}\\times\\ldots\\times\\mathcal{R}</span> for <span class="math">n</span> times.</p>

    <p class="text-gray-300">A motivating property of reductions of knowledge is that they are composable, allowing us to build complex reductions by stitching together simpler ones. In particular, given reductions <span class="math">\\Pi_{1}:\\mathcal{R}_{1}\\to\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}:\\mathcal{R}_{2}\\to\\mathcal{R}_{3}</span> we have that <span class="math">\\Pi_{2}\\circ\\Pi_{1}</span> (that is, running <span class="math">\\Pi_{1}</span> first and then running <span class="math">\\Pi_{2}</span> on the outputs) is a reduction of knowledge from <span class="math">R_{1}</span> to <span class="math">\\mathcal{R}_{3}</span>. Similarly, given reductions <span class="math">\\Pi_{1}:\\mathcal{R}_{1}\\to\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}:\\mathcal{R}_{3}\\to\\mathcal{R}_{4}</span> we have that <span class="math">\\Pi_{1}\\times\\Pi_{2}</span> (that is, independently running <span class="math">\\Pi_{1}</span> and <span class="math">\\Pi_{2}</span> on pairs of inputs) is a reduction of knowledge from <span class="math">\\mathcal{R}_{1}\\times\\mathcal{R}_{3}</span> to <span class="math">\\mathcal{R}_{2}\\times\\mathcal{R}_{4}</span>. We formally define sequential and parallel composition in Appendix A.3.</p>

    <p class="text-gray-300">In this work we are chiefly interested in building folding schemes, a particular type of reduction of knowledge that reduces the task of checking several instances in some relation <span class="math">\\mathcal{R}_{2}</span> into a running instance in a relation <span class="math">\\mathcal{R}_{1}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3 (Folding scheme).</h6>

    <p class="text-gray-300">A folding scheme for <span class="math">\\mathcal{R}_{1}^{m}</span> and <span class="math">\\mathcal{R}_{2}^{n}</span> is a reduction of knowledge of type <span class="math">\\mathcal{R}_{1}^{m}\\times\\mathcal{R}_{2}^{n}\\to\\mathcal{R}_{1}</span> where the encoder outputs its input structure. We call a reduction of type <span class="math">\\mathcal{R}^{n}\\to\\mathcal{R}</span> simply as a folding scheme for <span class="math">\\mathcal{R}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.3 The sum-check protocol</h3>

    <p class="text-gray-300">Recall that the standard sum-check relation checks that the sum of evaluations of an <span class="math">\\ell</span>-variate polynomial <span class="math">Q</span> (under a commitment) on the Boolean hypercube results in some value <span class="math">T</span>. Formally, the sum-check relation is defined as follows.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 4 (Unstructured sum-check relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively homomorphic commitment scheme. Consider a size bound <span class="math">\\ell\\in\\mathbb{N}</span>. The unstructured sum-check relation <span class="math">\\mathsf{USC}</span> over public parameter, instance, witness pairs is defined as follows.</p>

    <p class="text-gray-300">\\[ \\mathsf{USC}=\\left\\{\\left(\\mathsf{pp},(\\overline{Q},T),Q\\right)\\begin{vmatrix}Q\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}],\\\\ \\overline{Q}=\\mathsf{Commit}(\\mathsf{pp},Q),\\\\ T=\\sum_{x\\in\\{0,1\\}^{\\ell}}Q(x)\\end{vmatrix}\\right\\} \\]</p>

    <p class="text-gray-300">Central to our development is the sum-check protocol <em>[x14]</em>, which, when recast as a reduction of knowledge <em>[x3]</em>, reduces from the sum-check relation to the polynomial evaluation relation, which we define below.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 5 (Polynomial evaluation relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively homomorphic commitment scheme. Consider size bound <span class="math">\\ell\\in\\mathbb{N}</span>. We define the polynomial evaluation relation, <span class="math">\\mathsf{PE}</span>, as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{PE}=\\left\\{\\left.\\left(\\mathsf{pp},(\\overline{Q},x,y),g\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}Q\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}],\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline{Q}=\\mathsf{Commit}(\\mathsf{pp},Q),\\\\ y=Q(x)\\end{matrix}\\right\\}. \\]</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 4 (The sum-check protocol).</h6>

    <p class="text-gray-300">There exists a succinct, public-coin, tree-extractable reduction of knowledge (Lemma 15) from <span class="math">\\mathsf{USC}</span> to <span class="math">\\mathsf{PE}</span> compatible with all encoder, generator, and commitment algorithms where the output commitment is the same as the input commitment. For polynomials in <span class="math">\\mathbb{F}^{d}[X_{1},\\ldots,X_{\\ell}]</span> the communication complexity is <span class="math">O(d\\cdot\\ell)</span> elements in <span class="math">\\mathbb{F}</span>.</p>

    <h2 id="sec-20" class="text-2xl font-bold">3 SumFold: A folding scheme for the sum-check relation</h2>

    <p class="text-gray-300">In this section, we design a folding scheme for instance-witness pairs in the sum-check relation by using the sum-check protocol itself as a core building block. In the next section, we show that this enables a folding scheme for zero-check.</p>

    <p class="text-gray-300">A strawman folding scheme for the unstructured sum-check relation (Definition 4) is quite natural. By linearity, to interactively fold two unstructured sum-check instances <span class="math">(T_{1},\\overline{Q}_{1})</span> and <span class="math">(T_{2},\\overline{Q}_{2})</span> the verifier can send a random challenge <span class="math">\\rho</span> and check instead that the prover knows a polynomial <span class="math">Q</span> to the folded instance <span class="math">(T_{1}+\\rho\\cdot T_{2},\\overline{Q}_{1}+\\rho\\cdot\\overline{Q}_{2})</span>, which indeed the prover can compute so long as it knows polynomials <span class="math">Q_{1}</span> and <span class="math">Q_{2}</span> that satisfy <span class="math">(T_{1},\\overline{Q}_{1})</span> and <span class="math">(T_{2},\\overline{Q}_{2})</span>.</p>

    <p class="text-gray-300">Sum-check over structured polynomials. Challenges arise in contexts of interest, where the verifier does not explicitly hold commitments to <span class="math">Q_{1}</span> and <span class="math">Q_{2}</span>. In particular, when encoding instances in NP-complete relations, where the polynomial <span class="math">Q</span> is more concisely represented as a set of multilinear polynomials <span class="math">(g_{0},\\ldots,g_{t-1})</span> which we denote as <span class="math">\\vec{g}</span> and a polynomial <span class="math">F\\in\\mathbb{F}[Y_{1},\\ldots,Y_{t}]</span> such that <span class="math">Q(x)=F(g_{0}(x),\\ldots,g_{t-1}(x))</span> for all <span class="math">x</span> in <span class="math">\\{0,1\\}^{\\ell}</span>. The multilinear polynomials <span class="math">\\vec{g}</span> themselves are typically a linear function <span class="math">G</span> of some (smaller) set of underlying vectors <span class="math">\\vec{w}=(w_{0},\\ldots,w_{s-1})</span> and sometimes a public vector <span class="math">\\mathsf{x}</span>. For example, when encoding circuit satisfiability, polynomials <span class="math">g_{1}</span>, <span class="math">g_{2}</span>, and <span class="math">g_{3}</span> could represent left, right, and output gate values selected from a single vector <span class="math">(w,\\mathsf{x})</span> encoding the full list of intermediate wire values and inputs.</p>

    <p class="text-gray-300">Hence, in practice, the commitment to the polynomial <span class="math">Q</span> is much more concisely represented as a commitments to polynomials <span class="math">\\vec{w}</span> alongside public vector <span class="math">\\mathsf{x}</span> and functions <span class="math">F</span> and <span class="math">G</span>. With this the following more accurately captures the relation we aim to fold.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 6 (Sum-check relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size</p>

    <p class="text-gray-300">bounds <span class="math">n,m,\\ell,d,s,t\\in\\mathbb{N}</span>. We define the sum-check relation, <span class="math">\\mathsf{SC}</span>, as follows</p>

    <p class="text-gray-300">\\[ \\mathsf{SC}=\\left\\{\\begin{array}[]{l l}&T\\in\\mathbb{F},F\\in\\mathbb{F}^{d}[Y_{1},\\ldots,Y_{t}],\\vec{w}\\in(\\mathbb{F}^{n})^{s},\\mathsf{x}\\in\\mathbb{F}^{m},\\\\ \\mathsf{Commit}(\\mathsf{pp},w_{i})=u_{i},\\\\ &\\vec{g}\\in(\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell}])^{t}\\leftarrow G(\\vec{w},\\mathsf{x})\\\\ &T=\\sum_{x\\in\\{0,1\\}^{\\ell}}F(\\vec{g}(x))\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">where <span class="math">G</span> is linear over the input vector <span class="math">(\\vec{w},\\mathsf{x})</span>.</p>

    <p class="text-gray-300">Challenges with folding sum-check. The simple folding scheme that worked for <span class="math">\\mathsf{USC}</span> no longer works for <span class="math">\\mathsf{SC}</span> due to the potential non-linearity of <span class="math">F</span>. To demonstrate this, consider the following. Concretely, suppose that <span class="math">G</span> simply outputs multilinear extensions of its inputs (e.g., the multilinear extension of the witness and the public input concatenated) and <span class="math">F</span> multiplies all its inputs. Suppose then that the verifier holds two sets of commitments <span class="math">(\\overline{g}_{0},\\ldots,\\overline{g}_{t-1})</span> and <span class="math">(\\overline{h}_{0},\\ldots,\\overline{h}_{t-1})</span> and would like to check that the prover knows two sets of <span class="math">\\ell</span>-variate multilinear polynomial openings <span class="math">(g_{0},\\ldots,g_{t-1})</span> and <span class="math">(h_{0},\\ldots,h_{t-1})</span> such that</p>

    <p class="text-gray-300"><span class="math">T_{0}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}g_{0}(x)\\cdot g_{1}(x)\\cdot\\ldots\\cdot g_{t-1}(x)</span> (4) <span class="math">T_{1}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}h_{0}(x)\\cdot h_{1}(x)\\cdot\\ldots\\cdot h_{t-1}(x).</span> (5)</p>

    <p class="text-gray-300">Suppose that the verifier samples a challenge <span class="math">\\rho</span> (as before), and computes the folded instance:</p>

    <p class="text-gray-300"><span class="math">(T_{0}+\\rho\\cdot T_{1},(\\overline{g}_{0}+\\rho\\cdot\\overline{h}_{0}),\\ldots,(\\overline{g}_{t-1}+\\rho\\cdot\\overline{g}_{t-1})).</span></p>

    <p class="text-gray-300">Then, while the prover can compute the corresponding openings <span class="math">(g_{0}+\\rho\\cdot h_{0}),\\ldots,(g_{t-1}+\\rho\\cdot g_{t-1})</span>, they no longer satisfy the sum-check relation because</p>

    <p class="text-gray-300"><span class="math">T_{0}+\\rho\\cdot T_{1}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}g_{0}(x)\\cdot\\ldots\\cdot g_{t-1}(x)+\\rho\\cdot h_{0}(x)\\cdot\\ldots\\cdot h_{t-1}(x)</span> <span class="math">\\neq\\sum_{x\\in\\{0,1\\}^{\\ell}}(g_{0}(x)+\\rho\\cdot h_{0}(x))\\cdot\\ldots\\cdot(g_{t-1}(x)+\\rho\\cdot h_{t-1}(x)).</span></p>

    <p class="text-gray-300">Our solution: SumFold. We are now ready to describe NeutronNova’s folding scheme for the sum-check relation, which we refer to as SumFold. Recall that the crux of SumFold is that we embed polynomials <span class="math">g_{i}</span> and <span class="math">h_{i}</span> as Lagrange coefficients in a single-variable linear polynomial <span class="math">f_{i}</span> (and likewise for <span class="math">T_{0}</span> and <span class="math">T_{1}</span>). The prover and the verifier then run the sum-check protocol <em>[x14]</em> for a <em>single</em> round to bind this new variable to a random value.</p>

    <p class="text-gray-300">Indeed, for all <span class="math">j\\in[t]</span>, define <span class="math">f_{i}</span> as a multilinear polynomial in <span class="math">\\ell+1</span> variables such that for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, <span class="math">f_{j}(0,x)=g_{j}(x)</span> and <span class="math">f_{j}(1,x)=h_{j}(x)</span>. Specifically, we define</p>

    <p class="text-gray-300"><span class="math">f_{j}(b,x)=(1-b)\\cdot g_{j}(x)+b\\cdot h_{j}(x).</span></p>

    <p class="text-gray-300">Then, checking Claims (4) and (5) is equivalent to checking</p>

    <p class="text-gray-300"><span class="math">T_{0}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}f_{0}(0,x)\\cdot f_{1}(0,x)\\cdot\\ldots\\cdot f_{t-1}(0,x)</span> <span class="math">T_{1}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}f_{0}(1,x)\\cdot f_{1}(1,x)\\cdot\\ldots\\cdot f_{t-1}(1,x)</span></p>

    <p class="text-gray-300">Embedding the above polynomials as Lagrange coefficients, the verifier can equivalently check</p>

    <p class="text-gray-300"><span class="math">\\sum_{b\\in\\{0,1\\}}\\mathsf{eq}(X,b)\\cdot T_{b}=\\sum_{b\\in\\{0,1\\}}\\mathsf{eq}(X,b)\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}f_{0}(b,x)\\cdot f_{1}(b,x)\\cdot\\ldots\\cdot f_{t-1}(b,x).</span></p>

    <p class="text-gray-300">Then, the verifier picks a random challenge <span class="math">\\beta\\in\\mathbb{F}</span>, and by the Schwartz-Zippel Lemma (Lemma 12), it reduces to checking</p>

    <p class="text-gray-300"><span class="math">\\sum_{b\\in\\{0,1\\}}\\mathsf{eq}(\\beta,b)\\cdot T_{b}=\\sum_{b\\in\\{0,1\\}}\\mathsf{eq}(\\beta,b)\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}f_{0}(b,x)\\cdot f_{1}(b,x)\\cdot\\ldots\\cdot f_{t-1}(b,x).</span></p>

    <p class="text-gray-300">The prover and verifier then apply the sum-check protocol <em>[x14]</em> for a <em>single</em> round to the outer sum to bind the variable <span class="math">b</span> to a random challenge <span class="math">r_{b}\\in\\mathbb{F}</span>. Then, for some <span class="math">T^{\\prime}\\in\\mathbb{F}</span>, the verifier is left to check the following claim about the inner sum</p>

    <p class="text-gray-300"><span class="math">T^{\\prime}=\\sum_{x\\in\\{0,1\\}^{\\ell}}f_{0}(r_{b},x)\\cdot f_{1}(r_{b},x)\\cdot\\ldots\\cdot f_{t-1}(r_{b},x).</span></p>

    <p class="text-gray-300">At this point, for <span class="math">j\\in[t]</span>, the verifier computes commitments to multilinear polynomials <span class="math">f_{j}(r_{b})</span> (i.e., <span class="math">f_{j}</span> with the first variable set to <span class="math">r_{b}</span>), homomorphically as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},f_{j}(r_{b}))</span> <span class="math">=(1-r_{b})\\cdot\\mathsf{Commit}(\\mathsf{pp},f_{j}(0))+r_{b}\\cdot\\mathsf{Commit}(\\mathsf{pp},f_{j}(1))</span> <span class="math">=(1-r_{b})\\cdot\\overline{g}_{j}+r_{b}\\cdot\\overline{h}_{j}</span></p>

    <p class="text-gray-300">Finally, the verifier produces the folded instance</p>

    <p class="text-gray-300"><span class="math">(T^{\\prime},((1-r_{b})\\cdot\\overline{g}_{0}+r_{b}\\cdot\\overline{h}_{0}),\\ldots,((1-r_{b})\\cdot\\overline{g}_{t-1}+r_{b}\\cdot\\overline{h}_{t-1})).</span></p>

    <p class="text-gray-300">Furthermore, the prover can produce the satisfying folded witness <span class="math">((1-r_{b})\\cdot g_{0}+r_{b}\\cdot h_{0}),\\ldots,((1-r_{b})\\cdot g_{t-1}+r_{b}\\cdot h_{t-1})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SumFold}</span> generalizes naturally to fold <em>any</em> number of sum-check instances. If there are <span class="math">n</span> sum-check instances, then the verifier samples <span class="math">r_{b}\\in\\mathbb{F}^{\\log n}</span> and run the sum-check protocol for <span class="math">\\log n</span> rounds. At the end of the protocol, the commitments and witnesses are folded using the evaluations of <span class="math">\\mathsf{eq}(r_{b},i)</span> for all <span class="math">i\\in\\{0,1\\}^{\\log n}</span> as weights. In the case of <span class="math">n=2</span>, these weights are simply <span class="math">(1-r_{b})</span> and <span class="math">r_{b}</span> as described above. We now formally describe our generalized construction.</p>

    <p class="text-gray-300">Construction 1 (SumFold). We construct a folding scheme for SC. Consider size bounds  <span class="math">\\ell, d, s, t \\in \\mathbb{N}</span>  and let  <span class="math">\\nu = \\log n</span> . Let  <span class="math">(\\mathcal{P}_{\\mathrm{sc}}, \\mathcal{V}_{\\mathrm{sc}})</span>  denote the sum-check protocol (Lemma 4). Consider an arbitrary generator algorithm and an underlying additively homomorphic commitment scheme. We define the encoder, prover, and verifier as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},(F,G))</span>  : Output  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets ((F,G),\\bot)</span>  and structure  <span class="math">(F,G)</span></p>

    <p class="text-gray-300"><span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle ((\\mathsf{pk},\\mathsf{vk}),\\{(T_i,\\vec{u}_i,\\mathsf{x}_i)\\}_{i\\in [n]},\\{\\vec{w}_i\\}_{i\\in [n]})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> : Sample and send  <span class="math">\\rho \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^{\\nu}</span> .</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>  : Compute  <span class="math">(c,r_b)\\gets \\langle \\mathcal{P}_{\\mathrm{sc}},\\mathcal{V}_{\\mathrm{sc}}\\rangle ((\\mathsf{pk},\\mathsf{vk}),(\\overline{Q},T),Q)</span>  , where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T \\leftarrow \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\mathbf {e q} (\\rho , i) \\cdot T _ {i} \\\\ f _ {j} (b, x) \\leftarrow \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\mathbf {e q} (b, i) \\cdot g _ {i, j} (x) \\text {w h e r e} \\vec {g} _ {i} \\leftarrow G (\\vec {w} _ {i}, \\mathbf {x} _ {i}) \\\\ Q (b) \\leftarrow \\mathbf {e q} (\\rho , b) \\cdot \\left(\\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F \\left(f _ {1} (b, x), \\dots , f _ {t} (b, x)\\right)\\right) \\\\ \\overline {{Q}} \\leftarrow ((F, G), \\rho , (\\vec {u} _ {i}, \\mathbf {x} _ {i}) _ {i \\in [ n ]}). \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span> : Output the folded instance-witness pair (the verifier only outputs the instance)  <span class="math">((T^{\\prime},\\vec{u},\\mathbf{x}),\\vec{w})</span> , where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T ^ {\\prime} \\leftarrow c \\cdot \\mathbf {e q} (\\rho , r _ {b}) ^ {- 1} \\\\ u _ {j} \\leftarrow \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\mathbf {e q} (r _ {b}, i) \\cdot u _ {i, j} \\\\ \\mathbf {x} \\leftarrow \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\mathbf {e q} (r _ {b}, i) \\cdot \\mathbf {x} _ {i} \\\\ w _ {j} \\leftarrow \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\mathbf {e q} (r _ {b}, i) \\cdot w _ {i, j} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We formally prove the following theorem in Appendix B.1.</p>

    <p class="text-gray-300">Theorem 2 (SumFold). Construction 1 is a folding scheme for SC with  <span class="math">1 + \\log n</span>  rounds, a communication complexity of  <span class="math">O(d\\log n)</span>  field elements, a prover time complexity of  <span class="math">O(ntd \\cdot 2^{\\ell})</span>  field operations, and a verifier time complexity of  <span class="math">O(d\\log n)</span>  field operations.</p>

    <p class="text-gray-300">Proof (Intuition). We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct PPT extractor  <span class="math">\\chi</span>  that outputs a satisfying input witness with</p>

    <p class="text-gray-300">probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> given a tree of accepting transcripts and the corresponding output instance-witness pairs in <span class="math">\\mathsf{SC}</span>. We do so by leveraging the tree-extractor <span class="math">\\chi_{\\mathsf{sc}}</span> guaranteed by the tree extractability of the sum-check protocol (Lemma 4).</p>

    <p class="text-gray-300">In particular, <span class="math">\\chi</span> can produce a sufficient number of accepting sub-trees for the underlying sum-check protocol by using the provided instance-witness pairs in <span class="math">\\mathsf{SC}</span> to solve for satisfying instance-witness pairs output by the sum-check protocol in the polynomial evaluation relation <span class="math">\\mathsf{PE}</span>. Then, the sum-check tree extractor <span class="math">\\chi_{\\mathsf{sc}}</span> can produce a satisfying input witness in the unstructured sum-check relation <span class="math">\\mathsf{USC}</span> for each sub-tree. By the binding property of the commitment scheme, these witnesses must all be identical. But, by interpolating over the verifier’s initial challenge, this means that the witness produced by <span class="math">\\chi_{\\mathsf{sc}}</span> must also be a satisfying witness for the input relation <span class="math">\\mathsf{SC}^{n}</span>. ∎</p>

    <h2 id="sec-22" class="text-2xl font-bold">4 ZeroFold: A folding scheme for the zero-check relation</h2>

    <p class="text-gray-300">In this section, we design ZeroFold, a folding scheme for the zero-check relation, which asserts that a polynomial is zero over a prescribed set of points. We use SumFold (Construction 1), which is a folding scheme for the sum-check relation, as the central engine underlying our construction. In the next section, we show that this enables folding schemes for a variety of relations that reduce to zero-check.</p>

    <p class="text-gray-300">As with folding unstructured sum-check instances, unstructured zero-check instances can be folded with a standard random linear combination. However, as with the sum-check relation, in practice, commitments to the involved polynomials are typically represented as commitments to a set of (smaller) witness vectors that generate the aforementioned polynomials. Hence, we are more accurately interested in folding the following relation.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 7 (The zero-check relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size bounds <span class="math">n,m,\\ell,d,s,t\\in\\mathbb{N}</span>. We define the zero-check relation, <span class="math">\\mathsf{ZC}</span>, as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{ZC}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(F,G),(\\vec{u},\\mathsf{x}),\\vec{w})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}F\\in\\mathbb{F}^{d}[Y_{1},\\ldots,Y_{t}],\\vec{w}\\in(\\mathbb{F}^{n})^{s},\\mathsf{x}\\in\\mathbb{F}^{m},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{Commit}(\\mathsf{pp},w_{i})=u_{i},\\\\ \\vec{g}\\in(\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell}])^{t}\\leftarrow G(\\vec{w},\\mathsf{x}),\\\\ \\forall x\\in\\{0,1\\}^{\\ell}.\\ 0=F(\\vec{g}(x))\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">where <span class="math">G</span> is linear over the input vector <span class="math">(\\vec{w},\\mathsf{x})</span>.</p>

    <p class="text-gray-300">Once again, we can no longer use a standard random linear combination due to non-linearity. Our goal then is to <em>reduce</em> zero-check to the sum-check relation and then invoke SumFold from Section 3. This introduces various difficulties in terms of efficiency, which we methodically address.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">4.1 From zero-check to (nested) sum-check</h3>

    <p class="text-gray-300">To illustrate core ideas, as in the previous section, suppose that the linear map <span class="math">G</span> simply outputs multilinear extensions of its inputs and the polynomial</p>

    <p class="text-gray-300"><span class="math">F</span> multiplies all its inputs. Suppose then that the verifier holds two sets of commitments <span class="math">(\\overline{g}_0, \\ldots, \\overline{g}_{t-1})</span> and <span class="math">(\\overline{h}_0, \\ldots, \\overline{h}_{t-1})</span>, and would like to check that the prover knows two sets of <span class="math">\\ell</span>-variate multilinear polynomial openings <span class="math">(g_0, \\ldots, g_{t-1})</span> and <span class="math">(h_0, \\ldots, h_{t-1})</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">0 = g _ {0} (x) \\cdot \\dots \\cdot g _ {t - 1} (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = h _ {0} (x) \\cdot \\dots \\cdot h _ {t - 1} (x)</span></div>

    <p class="text-gray-300">for all <span class="math">x \\in \\{0,1\\}^\\ell</span>. To fold these instances, our goal is to reduce them to a corresponding set of sum-check instances.</p>

    <p class="text-gray-300">Recall that, from prior work [BTVW14], this can be done by having the verifier sample a challenge <span class="math">\\tau</span> and instead check for all <span class="math">x \\in \\{0,1\\}^\\ell</span> that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\tau^ {X} \\cdot g _ {0} (x) \\cdot \\dots \\cdot g _ {t - 1} (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\tau^ {X} \\cdot h _ {0} (x) \\cdot \\dots \\cdot h _ {t - 1} (x)</span></div>

    <p class="text-gray-300">where <span class="math">X = \\sum_{i=0}^{\\ell} 2^{i} \\cdot x_{i}</span> (i.e., <span class="math">X</span> is the corresponding decimal representation if <span class="math">x</span> is treated as the bit representation).</p>

    <p class="text-gray-300">To match the interface of the sum-check folding scheme, we define the Lagrange polynomial <span class="math">e(x) = \\sum_{z\\in \\{0,1\\}^{\\ell}}\\mathsf{eq}(z,x)\\cdot \\tau^{Z}</span> encoding the powers of <span class="math">\\tau</span> (i.e., <span class="math">e</span> is the multilinear extension of the vector <span class="math">[\\tau^0,\\dots ,\\tau^{2^\\ell}]</span>), and have the verifier check for all <span class="math">x\\in \\{0,1\\}^{\\ell}</span> that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} e (x) \\cdot g _ {0} (x) \\cdot \\dots \\cdot g _ {t - 1} (x)</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} e (x) \\cdot h _ {0} (x) \\cdot \\dots \\cdot h _ {t - 1} (x)</span></div>

    <p class="text-gray-300">Recall that in SumFold, the verifier samples a challenge <span class="math">\\rho</span> and the prover computes the folded witness as <span class="math">g_{j} + \\rho \\cdot h_{j}</span> for <span class="math">j\\in [t]</span> for which the verifier homomorphically computes the corresponding folded commitment <span class="math">\\overline{g}_j + \\rho \\cdot \\overline{h}_j</span>. Then, by extension the prover will similarly need to fold <span class="math">e</span> and the verifier will need to fold a corresponding commitment to <span class="math">e</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">A key question is the following: how do the verifier and the prover represent a commitment to <span class="math">e</span>, which is highly structured. Naturally, the prover can directly send a commitment to a vector of powers of <span class="math">\\tau</span>, which for now we will assume is trusted. However, this requires committing to a vector of size equal to the number of constraints <span class="math">2^{\\ell}</span>. Furthermore, these vector entries are completely random. If the witness for the zero-check instance contains “small” field elements (e.g., witness elements are from the set <span class="math">\\{0,\\ldots,2^{b}-1\\}</span>, for <span class="math">b=32</span>), the cost to commit to <span class="math">e</span> is at least an order of magnitude more expensive than the cost to commit to the witness, which is highly undesirable.</p>

    <p class="text-gray-300">As a first attempt, <span class="math">\\tau</span> itself could serve as a commitment to <span class="math">e</span>. However, because <span class="math">e</span> loses its tensor structure after folding, we will no longer have that <span class="math">\\tau+\\rho\\cdot\\tau</span> represents a commitment to <span class="math">e+\\rho\\cdot e</span>. In particular, we have that</p>

    <p class="text-gray-300"><span class="math">e+\\rho\\cdot e</span> <span class="math">=\\sum_{z\\in\\{0,1\\}}(1+\\rho)\\cdot\\mathsf{eq}(z,x)\\cdot\\tau^{Z}</span> <span class="math">\\neq\\sum_{z\\in\\{0,1\\}}\\mathsf{eq}(z,x)\\cdot(\\tau+\\rho\\cdot\\tau)^{Z}</span></p>

    <p class="text-gray-300">Our solution starts with the observation that</p>

    <p class="text-gray-300"><span class="math">e(x)</span> <span class="math">=\\sum_{z\\in\\{0,1\\}^{\\ell}}\\mathsf{eq}(z,x)\\cdot\\tau^{Z}</span> <span class="math">=(\\sum_{z_{1}\\in\\{0,1\\}^{\\ell}}\\mathsf{eq}(z_{1},x_{1})\\cdot\\tau^{Z_{1}})\\cdot(\\sum_{z_{2}\\in\\{0,1\\}^{\\ell}}\\mathsf{eq}(z_{2},x_{2})\\cdot\\tau^{\\sqrt{2^{\\ell}}\\cdot Z_{2}})</span></p>

    <p class="text-gray-300">where <span class="math">z_{1}</span> and <span class="math">z_{2}</span> represent the first and second half of <span class="math">z</span> and <span class="math">Z_{i}</span> is the decimal representation of <span class="math">z_{i}</span> (for <span class="math">i\\in\\{1,2\\}</span>). Following this, we define</p>

    <p class="text-gray-300"><span class="math">e_{1}(x_{1})</span> <span class="math">=\\sum_{z_{1}\\in\\{0,1\\}^{\\ell}}\\mathsf{eq}(z_{1},x_{1})\\cdot\\tau^{Z_{1}}</span> <span class="math">e_{2}(x_{2})</span> <span class="math">=\\sum_{z_{2}\\in\\{0,1\\}^{\\ell}}\\mathsf{eq}(z_{2},x_{2})\\cdot\\tau^{\\sqrt{2^{\\ell}}\\cdot Z_{2}}.</span></p>

    <p class="text-gray-300">Now, we have that <span class="math">e(x)=e_{1}(x_{1})\\cdot e_{2}(x_{2})</span>. Hence, the verifier can instead check</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}e_{1}(x_{1})\\cdot e_{2}(x_{2})\\cdot g_{0}(x)\\cdot\\ldots\\cdot g_{t-1}(x)</span> <span class="math">0</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}e_{1}(x_{1})\\cdot e_{2}(x_{2})\\cdot h_{0}(x)\\cdot\\ldots\\cdot h_{t-1}(x)</span></p>

    <p class="text-gray-300">Now, the prover can directly provide commitments to <span class="math">e_1</span> and <span class="math">e_2</span>, or, for efficiency, a single commitment <span class="math">\\overline{e}</span> to the vector <span class="math">e = (e_1, e_2)</span>, which only commits to a vector of size <span class="math">2 \\cdot \\sqrt{2^{\\ell}}</span>. By linearity, the verifier can compute the folded commitment <span class="math">\\overline{e} + \\rho \\cdot \\overline{e}</span> for which the prover can compute the folded witness <span class="math">(e_1 + \\rho \\cdot e_1, e_2 + \\rho \\cdot e_2)</span>. Formally, the prover and the verifier have reduced to folding the following variant of sum-check. Note that the verifier still needs to check the correctness of the provided commitments (which we address below).</p>

    <p class="text-gray-300"><strong>Definition 8 (Nested sum-check relation).</strong> Let <span class="math">(\\text{Gen}, \\text{Commit})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size bounds <span class="math">n, m, \\ell, d, s, t \\in \\mathbb{N}</span>. We define the nested sum-check relation, NSC, as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N S C} = \\left\\{ \\begin{array}{l l} (\\mathsf {p p}, &amp;amp; T \\in \\mathbb {F}, F \\in \\mathbb {F} ^ {d} [ Y _ {1}, \\ldots , Y _ {t} ], \\vec {w} \\in (\\mathbb {F} ^ {n}) ^ {s}, \\mathsf {x} \\in \\mathbb {F} ^ {m}, \\\\ (F, G), &amp;amp; \\mathsf {C o m m i t} (\\mathsf {p p}, w _ {i}) = u _ {i}, \\mathsf {C o m m i t} (\\mathsf {p p}, e) = \\overline {{e}}, \\\\ (T, \\vec {u}, \\mathsf {x}, \\overline {{e}}), &amp;amp; \\vec {g} \\in \\mathbb {F} ^ {1} [ X _ {1}, \\ldots , X _ {\\ell} ] \\leftarrow G ((\\vec {w}, \\mathsf {x})) \\\\ (\\vec {w}, e)) &amp;amp; T = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} e _ {1} (x _ {1}) \\cdot e _ {2} (x _ {2}) \\cdot F (\\vec {g} (x)) \\end{array} \\right.</span></div>

    <p class="text-gray-300">where <span class="math">G</span> is linear over the input vector <span class="math">(w, \\mathbf{x})</span> and <span class="math">x_{1}</span> and <span class="math">x_{2}</span> (likewise, <span class="math">e_{1}</span> and <span class="math">e_{2}</span>) represent the first and second half of <span class="math">x</span> (likewise, <span class="math">e</span>).</p>

    <p class="text-gray-300">It appears that we can now apply SumFold, but two problems remain. First, unlike the sum-check relation, the nested sum-check relation enforces an additional stipulation that <span class="math">e_1</span> is only evaluated on the first half of <span class="math">x</span> and <span class="math">e_2</span> is only evaluated on the second half of <span class="math">x</span>. As we will see in the next section, this is only a minor technicality which we can fix with an appropriate padding to <span class="math">e_1</span> and <span class="math">e_2</span>. Second, when reducing from zero-check to the nested sum-check relation, the verifier must still ensure that <span class="math">e_1</span> and <span class="math">e_2</span> indeed contain appropriate powers of <span class="math">\\tau</span>. Formally, the verifier is tasked with checking the following relation.</p>

    <p class="text-gray-300"><strong>Definition 9 (Power-check relation).</strong> Let <span class="math">(\\text{Gen}, \\text{Commit})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size bound <span class="math">m</span>. We define the power-check relation <span class="math">\\mathsf{PC}</span> over public parameter, instance, witness tuples as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {P C} = \\left\\{ \\begin{array}{l} (\\mathsf {p p}, (\\overline {{e}}, \\tau), e) \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {C o m m i t} (\\mathsf {p p}, e) = \\overline {{e}}, \\\\ e _ {1} = (\\tau^ {0}, \\tau^ {1}, \\tau^ {2}, \\ldots , \\tau^ {\\sqrt {m} - 1}) \\\\ e _ {2} = (\\tau^ {0}, \\tau^ {\\sqrt {m}}, \\tau^ {2 \\sqrt {m}}, \\ldots , \\tau^ {(\\sqrt {m} - 1) \\cdot \\sqrt {m}}) \\end{array} \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">e_1</span> and <span class="math">e_2</span> represent the first and second half of <span class="math">e</span>.</p>

    <p class="text-gray-300"><strong>From power-check to zero-check.</strong> Recall that for most applications it is too expensive for the verifier to check a power-check instance in each folding step. To circumvent this, our solution is for the prover and the verifier to also fold the power-check instances alongside the zero-check instances. Instead of designing a new folding scheme for the power-check relation, we reinterpret the power-check</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">relation as a particular type of zero-check relation. This allows us the bootstrap our eventual folding scheme for zero-check for the purpose of power-check.</p>

    <p class="text-gray-300">Let <span class="math">m = 2^{\\ell}</span>. We observe that the power-check relation can be enforced with <span class="math">2 \\cdot \\sqrt{m}</span> quadratic constraints. The first half of <span class="math">e</span> can be checked by checking if <span class="math">e_0 = 1</span> and that each subsequent entry is the result of multiplying the previous entry by <span class="math">\\tau</span>. The second half of <span class="math">e</span> can be checked by checking that <span class="math">e_{\\sqrt{m}} = 1</span>, checking that <span class="math">e_{\\sqrt{m} + 1}</span> (presumably <span class="math">\\tau^{\\sqrt{m}}</span>) is the result of multiplying the last entry of the first half of <span class="math">e</span> (presumably <span class="math">\\tau^{\\sqrt{m} - 1}</span>) by <span class="math">\\tau</span>, checking that the subsequent entry <span class="math">e_{\\sqrt{m} + 2}</span> (presumably <span class="math">\\tau^{2 \\cdot \\sqrt{m}}</span>) is the square of the previous entry, and then check that all subsequent entries result from multiplying the previous entry by <span class="math">e_{\\sqrt{m} + 1}</span>.</p>

    <p class="text-gray-300">To reduce to power-check to zero-check, we observe that each entry of <span class="math">e</span> is checked to be the result of multiplying two other entries in <span class="math">(e, \\tau)</span>. Then, given <span class="math">e</span> and <span class="math">\\tau</span> we can fix the structure polynomial <span class="math">G_{\\mathsf{PC}}</span> to set <span class="math">g_1 \\gets \\widetilde{e}</span> and set <span class="math">g_2</span> and <span class="math">g_3</span> to contain the left and right inputs respectively to the multiplication operation. Then, <span class="math">F_{\\mathsf{PC}}</span> can compute <span class="math">g_1(x) - g_2(x) \\cdot g_3(x)</span>, for all <span class="math">x \\in \\{0, 1\\}^\\ell</span> thereby enforcing each multiplication constraint in the zero-check. Formally, we encode a power-check instance as a zero-check instance as follows.</p>

    <p class="text-gray-300"><strong>Construction 2 (From power-check to zero-check).</strong> We have that <span class="math">(\\mathsf{pp}, (\\overline{e}, \\tau), e) \\in \\mathsf{PC}</span> if and only if <span class="math">(\\mathsf{pp}, (F_{\\mathsf{PC}}, G_{\\mathsf{PC}}), (\\overline{e}, \\tau), e) \\in \\mathsf{ZC}</span> where <span class="math">G_{\\mathsf{PC}}(e, \\tau)</span> produces <span class="math">g_1 \\gets \\widetilde{e}</span>, <span class="math">g_2</span>, and <span class="math">g_3</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">g _ {2} (i) = \\left\\{ \\begin{array}{l l} 1 &amp;amp; i = 0 \\\\ e _ {i - 1} &amp;amp; 1 \\leq i &amp;lt;   \\sqrt {m} \\\\ 1 &amp;amp; i = \\sqrt {m} \\\\ e _ {i - 2} &amp;amp; i = \\sqrt {m} + 1 \\\\ e _ {i - 1} &amp;amp; i = \\sqrt {m} + 2 \\\\ e _ {\\sqrt {m} + 1} &amp;amp; \\sqrt {m} + 2 &amp;lt;   i &amp;lt;   2 \\sqrt {m} \\end{array} \\right. \\quad g _ {3} (i) = \\left\\{ \\begin{array}{l l} 1 &amp;amp; i = 0 \\\\ \\tau &amp;amp; 1 \\leq i &amp;lt;   \\sqrt {m} \\\\ 1 &amp;amp; i = \\sqrt {m} \\\\ \\tau &amp;amp; i = \\sqrt {m} + 1 \\\\ e _ {i - 1} &amp;amp; i = \\sqrt {m} + 2 \\\\ e _ {i - 1} &amp;amp; \\sqrt {m} + 2 &amp;lt;   i &amp;lt;   2 \\sqrt {m} \\end{array} \\right.</span></div>

    <p class="text-gray-300">and <span class="math">F_{\\mathsf{PC}}(y_1, y_2, y_3) = y_1 - y_2 \\cdot y_3</span>. Note that <span class="math">g_1, g_2</span>, and <span class="math">g_3</span> can be padded with evaluations to zero to any desired length. We let <span class="math">\\mathsf{ZC}_{\\mathsf{PC}}</span> denote the zero-check relation with <span class="math">(F_{\\mathsf{PC}}, G_{\\mathsf{PC}})</span> fixed for the structure. Similarly, we let <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span> denote the nested sum-check relation with <span class="math">(F_{\\mathsf{PC}}, G_{\\mathsf{PC}})</span> fixed for the structure.</p>

    <p class="text-gray-300">Putting everything together, given any number of zero-check instances, and any number of power-check instances (represented as zero-check instances), the verifier first samples a challenge <span class="math">\\tau</span> for which the prover responds with an (unverified) commitment <span class="math">\\overline{e}</span> to the powers of <span class="math">\\tau</span>. Then, the zero-check instances, and similarly the power-check instances, can be reduced to the corresponding nested sum-check instances over the corresponding structures with respect to the challenge <span class="math">\\tau</span>. Alongside, the verifier outputs a new power-check instance <span class="math">(\\overline{e}, \\tau)</span> to be checked (in the future). The following construction formally captures this aggregate reduction.</p>

    <p class="text-gray-300">22</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Construction 3 (Zero-check reduction).</h6>

    <p class="text-gray-300">We construct a reduction of knowledge of type</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ZC}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}^{m}\\to\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{m}\\times\\mathsf{ZC}_{\\mathsf{PC}}.</span></p>

    <p class="text-gray-300">Consider size bounds <span class="math">\\ell,d,t\\in\\mathbb{N}</span>. Consider an arbitrary generator algorithm, an arbitrary encoder algorithm that outputs its input structure and an arbitrary underlying additively homomorphic commitment scheme. We define the prover and the verifier as follows.</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),(\\vec{u},\\vec{u}_{\\mathsf{pc}}),(\\vec{\\mathsf{w}},\\vec{\\mathsf{w}}_{\\mathsf{pc}}))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Sample and send <span class="math">\\tau\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{P}</span>: Compute <span class="math">((\\overline{e},\\tau),e)\\in\\mathsf{ZC}_{\\mathsf{PC}}</span> with size parameter <span class="math">m=2^{\\ell/2}</span> and send <span class="math">\\overline{e}</span>.</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Output the following instance-witness pairs (the verifier only outputs the instances).</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Big{(}\\{(0,\\mathsf{u}_{i},\\overline{e})\\}_{i\\in[n]},\\{(\\mathsf{w}_{i},e)\\}_{i\\in[n]}\\Big{)}</span> <span class="math">\\in\\mathsf{NSC}^{n}</span> <span class="math">\\Big{(}\\{(0,\\mathsf{u}_{\\mathsf{pc},j},\\overline{e})\\}_{j\\in[m]},\\{(\\mathsf{w}_{\\mathsf{pc},j},e)\\}_{j\\in[m]}\\Big{)}</span> <span class="math">\\in\\mathsf{NSC}_{\\mathsf{PC}}^{m}</span> <span class="math">\\Big{(}(\\overline{e},\\tau),e\\Big{)}</span> <span class="math">\\in\\mathsf{ZC}_{\\mathsf{PC}}</span></p>

    <p class="text-gray-300">We formally prove the following lemma in Appendix B.2.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 5 (Zero-check reduction).</h6>

    <p class="text-gray-300">Construction 3 is a reduction of knowledge of type <span class="math">\\mathsf{ZC}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}^{m}\\to\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{m}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span> with <span class="math">1</span> round, a communication complexity of <span class="math">1</span> field element and <span class="math">1</span> element in the message space of the commitment scheme over size <span class="math">2^{\\ell/2+1}</span> vectors, an <span class="math">O(2^{\\ell/2+1})</span> prover time complexity, and an <span class="math">O(1)</span> verifier time complexity.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness given a tree of accepting transcripts and corresponding output instance-witness pairs in <span class="math">\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{m}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span>.</p>

    <p class="text-gray-300">Indeed, in such a tree, consider an output satisfying <span class="math">\\mathsf{NSC}</span> instance-witness pair</p>

    <p class="text-gray-300"><span class="math">((0,\\mathsf{u}_{i},\\overline{e}),(\\mathsf{w}_{i},e))\\in\\mathsf{NSC}.</span></p>

    <p class="text-gray-300">By the satisfiability condition of <span class="math">\\mathsf{NSC}</span>, for <span class="math">(\\vec{u}_{i},\\mathsf{x}_{i})\\leftarrow\\mathsf{u}_{i}</span> and <span class="math">\\vec{w}_{i}\\leftarrow\\mathsf{w}_{i}</span> we have that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})).</span></p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\tau^{X}\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x)),</span></p>

    <p class="text-gray-300">where <span class="math">X</span> is the corresponding decimal representation if <span class="math">x</span> is treated as the bit representation.</p>

    <p class="text-gray-300">By the binding property of the commitment scheme, and the verifier’s construction, we must have that <span class="math">\\vec{w}_{i}</span> and <span class="math">\\mathsf{x}_{i}</span> remain identical across all transcripts. Then, with enough such transcripts, by interpolation we have that</p>

    <p class="text-gray-300"><span class="math">0=F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>. But, this means that</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})\\in\\mathsf{ZC}.</span></p>

    <p class="text-gray-300">By an identical line of reasoning <span class="math">\\chi</span> can produce satisfying witnesses for the input <span class="math">\\mathsf{ZC_{PC}}</span> instances as well. ∎</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.2 A folding scheme for the nested sum-check relation</h3>

    <p class="text-gray-300">Given the reductions in the prior subsection, our goal is to fold a set of nested sum-check instances over the original structure <span class="math">(F,G)</span>, and a set of nested sum-check instances over the power-check structure <span class="math">(F_{\\mathsf{PC}},F_{\\mathsf{PC}})</span>. This involves recasting nested sum-check instances as sum-check instances.</p>

    <p class="text-gray-300">Indeed, as stated earlier, one technicality is that unlike the sum-check relation, which performs a check of the form <span class="math">T=\\sum_{x}F(G(\\vec{w},\\mathsf{x})(x))</span>, the nested sum-check relation performs a more structured check of the form:</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(G(\\vec{w},\\mathsf{x})(x)).</span></p>

    <p class="text-gray-300">The nested sum-check instance can be reinterpreted as a sum-check instance by first defining polynomials <span class="math">h_{1}</span> and <span class="math">h_{2}</span>, which extend the domain of <span class="math">e_{1}</span> and <span class="math">e_{2}</span> to <span class="math">\\{0,1\\}^{\\ell}</span> as follows</p>

    <p class="text-gray-300"><span class="math">h_{1}(x)</span> <span class="math">=e_{1}(x_{1})\\cdot(\\widetilde{1,\\ldots,1})(x_{2})=e_{1}(x_{1})</span> <span class="math">h_{2}(x)</span> <span class="math">=(\\widetilde{1,\\ldots,1})(x_{1})\\cdot e_{2}(x_{2})=e_{2}(x_{2})</span></p>

    <p class="text-gray-300">Then, we can define the structure <span class="math">G^{\\prime}</span> to additionally produce <span class="math">h_{1}</span> and <span class="math">h_{2}</span> given an additional vector <span class="math">e</span> in the nested sum-check witness</p>

    <p class="text-gray-300"><span class="math">G^{\\prime}((\\vec{w},e),\\mathsf{x})=(G(\\vec{w},\\mathsf{x}),h_{1},h_{2})</span></p>

    <p class="text-gray-300">Crucially, we have that <span class="math">h_{1}</span> and <span class="math">h_{2}</span> are produced linearly from <span class="math">e</span>, which is stipulated by the sum-check relation. Then, we can define the polynomial <span class="math">F^{\\prime}</span> to account for these additionally produced polynomials</p>

    <p class="text-gray-300"><span class="math">F^{\\prime}(\\vec{g}(x),h_{1}(x),h_{2}(x))=h_{1}(x)\\cdot h_{2}(x)\\cdot F(\\vec{g}(x))</span></p>

    <p class="text-gray-300">Then, we have that</p>

    <p class="text-gray-300"><span class="math">T</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(G(\\vec{w},\\mathsf{x})(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}(G^{\\prime}((\\vec{w},e),\\mathsf{x})(x))</span></p>

    <p class="text-gray-300">Hence, the prover and the verifier can fold a set of nested sum-check instances over structure <span class="math">(F,G)</span> by using SumFold to fold equivalent sum-check instances with respect to structure <span class="math">(F^{\\prime},G^{\\prime})</span>.</p>

    <p class="text-gray-300">We can similarly define the structure <span class="math">(F^{\\prime}_{\\mathsf{PC}},G^{\\prime}_{\\mathsf{PC}})</span> to fold the nested sum-check instances over the power-check structure. At this point the prover and the verifier can run two independent invocations of SumFold, once to fold over structure <span class="math">(F^{\\prime},G^{\\prime})</span> and once to fold over structure <span class="math">(F^{\\prime}_{\\mathsf{PC}},G^{\\prime}_{\\mathsf{PC}})</span>. Alternatively, for concrete efficiency, the prover and the verifier can run a single invocation of SumFold by taking a random linear combination of the original structures. In particular, consider two sets of nested sum-check instance-witness pairs</p>

    <p class="text-gray-300"><span class="math">\\{(T_{i},(\\vec{u}_{i},\\overline{e}_{i},\\mathsf{x}_{i}),(\\vec{w}_{i},e_{i}))\\}_{i\\in[n]}</span> <span class="math">\\in\\mathsf{NSC}^{n}</span> <span class="math">\\{(T_{\\mathsf{pc},i},(\\vec{u}_{\\mathsf{pc},i},\\overline{e}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i}),(\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i}))\\}_{i\\in[n]}</span> <span class="math">\\in\\mathsf{NSC}^{n}_{\\mathsf{PC}}</span></p>

    <p class="text-gray-300">to be checked over structures <span class="math">(F,G)</span> and <span class="math">(F_{\\mathsf{PC}},G_{\\mathsf{PC}})</span> respectively. The verifier begins by sending a challenge <span class="math">\\gamma\\in\\mathbb{F}</span>. Then, for each <span class="math">i\\in[n]</span>, the prover and the verifier can reduce to checking that</p>

    <p class="text-gray-300"><span class="math">T_{i}+\\gamma\\cdot T_{\\mathsf{pc},i}=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}(G^{\\prime}((\\vec{w}_{i},e_{i}),\\mathsf{x}_{i})(x))+\\gamma\\cdot F^{\\prime}_{\\mathsf{PC}}(G^{\\prime}_{\\mathsf{PC}}((\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i}),\\mathsf{x}_{\\mathsf{pc},i})(x))</span></p>

    <p class="text-gray-300">Once again, we can recast the above instance to a sum-check instance by defining the following structure:</p>

    <p class="text-gray-300"><span class="math">F^{\\prime\\prime}(\\vec{g},\\vec{g}_{\\mathsf{pc}})</span> <span class="math">=F(\\vec{g})+\\gamma\\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}})</span> <span class="math">G^{\\prime\\prime}(\\vec{w},e,\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}},(\\mathsf{x},\\mathsf{x}_{\\mathsf{pc}}))</span> <span class="math">=(G^{\\prime}((\\vec{w},e),\\mathsf{x}),G^{\\prime}_{\\mathsf{PC}}((\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}}),\\mathsf{x}_{\\mathsf{pc}})).</span></p>

    <p class="text-gray-300">Then, for the aggregated instance-witness pair</p>

    <p class="text-gray-300"><span class="math">(T_{i}+\\gamma\\cdot T_{\\mathsf{pc},i},(\\vec{u}_{i},\\overline{e}_{i},\\vec{u}_{\\mathsf{pc},i},\\overline{e}_{\\mathsf{pc},i},(\\mathsf{x}_{i},\\mathsf{x}_{\\mathsf{pc},i})),(\\vec{w}_{i},e_{i},\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i})),</span></p>

    <p class="text-gray-300">the verifier can equivalently check</p>

    <p class="text-gray-300"><span class="math">T_{i}+\\gamma\\cdot T_{\\mathsf{pc},i}=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime\\prime}(G^{\\prime\\prime}((\\vec{w}_{i},e_{i},\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i}),(\\mathsf{x}_{i},\\mathsf{x}_{\\mathsf{pc},i}))(x))</span> (6)</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">for all <span class="math">i \\in [n]</span>. Note that because we are pairing off <span class="math">\\mathsf{NSC}</span> and <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span> instances, the above optimization specifically requires the same number of instances from each relation. This is not a problem in practice as we can always pad either side with trivially satisfying instance-witness pairs.</p>

    <p class="text-gray-300">Then, the prover and the verifier can run SumFold over all the instance-witness pairs in Equation (6) to reduce to checking a single instance</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T_{\\gamma} = \\sum_{x \\in \\{0, 1\\}^{\\ell}} F&#x27;&#x27;(G&#x27;&#x27;((\\vec{w}, e, \\vec{w}_{\\mathsf{pc}}, e_{\\mathsf{pc}}), (\\mathsf{x}_i, \\mathsf{x}_{\\mathsf{pc}}))(x)) \\\\ = \\sum_{x \\in \\{0, 1\\}^{\\ell}} F&#x27;(G&#x27;((\\vec{w}, e), \\mathsf{x})(x)) + \\gamma \\cdot F_{\\mathsf{PC}}&#x27;(G&#x27;_{\\mathsf{PC}}((\\vec{w}_{\\mathsf{pc}}, e_{\\mathsf{pc}}), \\mathsf{x}_{\\mathsf{pc}})(x)) \\end{array}</span></div>

    <p class="text-gray-300">At this point, the prover can send</p>

    <div class="my-4 text-center"><span class="math-block">T = \\sum_{x \\in \\{0, 1\\}^{\\ell}} \\widetilde{e}_1(x_1) \\cdot \\widetilde{e}_2(x_2) \\cdot F(G(\\vec{w}, \\mathsf{x})(x)) \\tag{7}</span></div>

    <div class="my-4 text-center"><span class="math-block">T_{\\mathsf{pc}} = \\sum_{x \\in \\{0, 1\\}^{\\ell}} \\widetilde{e}_{\\mathsf{pc},1}(x_1) \\cdot \\widetilde{e}_{\\mathsf{pc},2}(x_2) \\cdot F_{\\mathsf{PC}}(G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc}}, \\mathsf{x}_{\\mathsf{pc}})(x)). \\tag{8}</span></div>

    <p class="text-gray-300">The verifier checks that indeed <span class="math">T_{\\gamma} = T + \\gamma \\cdot T_{\\mathsf{pc}}</span>, and reduces to checking Equations (7) and (8). But, by definition, this is precisely equivalent to checking an instance in <span class="math">\\mathsf{NSC}</span> and an instance in <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span>. Hence, the above interaction gives us a reduction of knowledge from <span class="math">\\mathsf{NSC}^n \\times \\mathsf{NSC}_{\\mathsf{PC}}^n</span> to <span class="math">\\mathsf{NSC} \\times \\mathsf{NSC}_{\\mathsf{PC}}</span>. We formally describe this reduction below.</p>

    <p class="text-gray-300"><strong>Construction 4 (Folding nested sum-check).</strong> We construct a reduction of knowledge of type</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NSC}^n \\times \\mathsf{NSC}_{\\mathsf{PC}}^n \\to \\mathsf{NSC} \\times \\mathsf{NSC}_{\\mathsf{PC}}.</span></div>

    <p class="text-gray-300">Indeed, let <span class="math">(\\mathcal{G}_{\\mathsf{SF}}, \\mathcal{K}_{\\mathsf{SF}}, \\mathcal{P}_{\\mathsf{SF}}, \\mathcal{V}_{\\mathsf{SF}})</span> be SumFold (Construction 1). Consider size bounds <span class="math">\\ell, d, t \\in \\mathbb{N}</span>. Consider an arbitrary generator algorithm and an underlying additively homomorphic commitment scheme. We define the encoder, the prover, and the verifier as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp}, (F, G))</span>: Output <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets ((F, G), \\bot)</span> and structure <span class="math">(F, G)</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathcal{P}, \\mathcal{V} \\rangle ((\\mathsf{pk}, \\mathsf{vk}), \\{((T_i, \\mathsf{u}_i, \\mathsf{x}_i), (T_{\\mathsf{pc},i}, \\mathsf{u}_{\\mathsf{pc},i}, \\mathsf{x}_{\\mathsf{pc},i}))\\}_{i \\in [n]}, \\{(\\mathsf{w}_i, \\mathsf{w}_{\\mathsf{pc},i})\\}_{i \\in [n]}) \\colon</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Sample and send <span class="math">\\gamma \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{P}</span>: Compute the updated prover key <span class="math">\\mathsf{pk}&#x27; \\gets (F&#x27;, G&#x27;)</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F&#x27;(\\vec{g}, h_1, h_2, \\vec{g}_{\\mathsf{pc}}, h_{\\mathsf{pc},1}, h_{\\mathsf{pc},2}) = h_1 \\cdot h_2 \\cdot F(\\vec{g}) + \\gamma \\cdot h_{\\mathsf{pc},1} \\cdot h_{\\mathsf{pc},2} \\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}}) \\\\ G&#x27;(\\vec{w}, e, \\vec{w}_{\\mathsf{pc}}, e_{\\mathsf{pc}}, (\\mathsf{x}, \\mathsf{x}_{\\mathsf{pc}})) = (G(\\vec{w}, \\mathsf{x}), h_1, h_2, G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc}}, \\mathsf{x}_{\\mathsf{pc}}), h_{\\mathsf{pc},1}, h_{\\mathsf{pc},2}) \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">(F_{\\mathsf{PC}}, G_{\\mathsf{PC}})</span> are defined as in Construction 2 with an appropriate padding, and for <span class="math">j \\in \\{1, 2\\}</span>, <span class="math">h_j(x) = \\widetilde{e}_j(x_j)</span> and <span class="math">h_{\\mathsf{pc},j}(x) = \\widetilde{e}_{\\mathsf{pc},j}(x_j)</span>, where</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300"><span class="math">(e_{1},e_{2})</span>, <span class="math">(e_{\\mathsf{pc},1},e_{\\mathsf{pc},2})</span>, and <span class="math">(x_{1},x_{2})</span> represent the first and second half of the original vector.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Run the sum-check folding reduction <span class="math">\\langle\\mathcal{P}_{\\mathsf{SF}},\\mathcal{V}_{\\mathsf{SF}}\\rangle</span> on the updated prover and verifier keys <span class="math">(\\mathsf{pk}^{\\prime},\\mathsf{vk})</span>, and the updated instance-witness pairs for <span class="math">i\\in[n]</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\left(\\left(T_{i}+\\gamma\\cdot T_{\\mathsf{pc},i},(\\mathsf{u}_{i},\\mathsf{u}_{\\mathsf{pc},i}),(\\mathsf{x}_{i},\\mathsf{x}_{\\mathsf{pc},i})\\right),(\\mathsf{w}_{i},\\mathsf{w}_{\\mathsf{pc},i})\\right)</span></p>

    <p class="text-gray-300">to produce a folded instance-witness pair <span class="math">(T_{\\gamma},(\\mathsf{u},\\mathsf{u}_{\\mathsf{pc}}),(\\mathsf{x},\\mathsf{x}_{\\mathsf{pc}})),(\\mathsf{w},\\mathsf{w}_{\\mathsf{pc}})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Parse <span class="math">(\\vec{w},e)\\leftarrow\\mathsf{w}</span>, <span class="math">(\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}})\\leftarrow\\mathsf{w}_{\\mathsf{pc}}</span>, compute <span class="math">\\vec{g}\\leftarrow G(\\vec{w},\\mathsf{x})</span>, <span class="math">\\vec{g}_{\\mathsf{pc}}\\leftarrow G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc}},\\mathsf{x}_{\\mathsf{pc}})</span>, and send to <span class="math">\\mathcal{V}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">T\\leftarrow\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(\\vec{g}(x))</span> <span class="math">T_{\\mathsf{pc}}\\leftarrow\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{\\mathsf{pc},1}(x_{1})\\cdot\\widetilde{e}_{\\mathsf{pc},2}(x_{2})\\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}}(x)).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Check that <span class="math">T_{\\gamma}=T+\\gamma\\cdot T_{\\mathsf{pc}}</span>.</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Output the following instance-witness pairs (the verifier only outputs the instances).</li>

    </ol>

    <p class="text-gray-300"><span class="math">((T,\\mathsf{u},\\mathsf{x}),\\mathsf{w})\\in\\mathsf{NSC}</span> <span class="math">((T_{\\mathsf{pc}},\\mathsf{u}_{\\mathsf{pc}},\\mathsf{x}_{\\mathsf{pc}}),\\mathsf{w}_{\\mathsf{pc}})\\in\\mathsf{NSC}_{\\mathsf{PC}}</span></p>

    <p class="text-gray-300">We formally prove the following lemma in Appendix B.3.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 6 (Folding nested sum-check).</h6>

    <p class="text-gray-300">Construction 4 is a reduction of knowledge of type <span class="math">\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}\\to\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}</span> with <span class="math">2+\\log n</span> rounds, a communication complexity of <span class="math">O(d\\log n)</span> field elements, a prover time complexity of <span class="math">O(ntd\\cdot 2^{\\ell})</span> field operations, and a verifier time complexity of <span class="math">O(d\\log n)</span> field operations.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness given a tree of accepting transcripts and corresponding output instance-witness pairs in <span class="math">\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}</span>. We do so by leveraging the tree-extractor <span class="math">\\chi_{\\mathsf{FSC}}</span> guaranteed by the tree extractability of SumFold (Lemma 17).</p>

    <p class="text-gray-300">In particular, <span class="math">\\chi</span> can produce a sufficient number of accepting sub-trees for the underlying SumFold by using the provided instance witness pairs in <span class="math">\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}</span> to solve for corresponding satisfying output instance-witness pairs in <span class="math">\\mathsf{SC}</span>. Then, SumFold’s tree extractor <span class="math">\\chi_{\\mathsf{FSC}}</span> can produce a satisfying input witness in <span class="math">\\mathsf{SC}^{n}</span> for each sub-tree. By the binding property of the commitment scheme, these witnesses must all be identical. Then, by interpolating over the verifier’s initial challenge, this means that the witness produced by <span class="math">\\chi_{\\mathsf{FSC}}</span> must also be a satisfying witness for the input relation <span class="math">\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}</span>. ∎</p>

    <p class="text-gray-300">4.3 ZeroFold: Putting everything together</p>

    <p class="text-gray-300">So far, we have constructed the zero-check reduction <span class="math">\\Pi_{\\mathsf{ZCR}}:\\mathsf{ZC}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}^{n}\\to\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span> (Construction 3) and a folding scheme for the nested sum-check relation <span class="math">\\Pi_{\\mathsf{FNSC}}:\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}\\to\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}</span> (Construction 4). We can use these two reductions to produce a folding scheme for <span class="math">\\mathsf{ZC}</span> with a running instance type of <span class="math">\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span></p>

    <p class="text-gray-300">Indeed, suppose that a verifier would like to check <span class="math">n</span> zero-check instances <span class="math">\\vec{u}=(\\mathsf{u}_{1},\\ldots,\\mathsf{u}_{n})</span> and <span class="math">n</span> running instances <span class="math">\\vec{\\mathsf{U}}=(\\mathsf{U}_{1},\\ldots,\\mathsf{U}_{n})</span> in <span class="math">\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span>. The verifier first collects <span class="math">n</span> instances in <span class="math">\\mathsf{ZC}_{\\mathsf{PC}}</span> from <span class="math">\\vec{\\mathsf{U}}</span> and reduces these instances along with <span class="math">\\vec{u}</span> via the zero-check reduction <span class="math">\\Pi_{\\mathsf{ZCR}}</span> into <span class="math">n</span> instances in <span class="math">\\mathsf{NSC}</span>, <span class="math">n</span> instances <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span>, and a fresh instance in <span class="math">\\mathsf{ZC}_{\\mathsf{PC}}</span>. Now the verifier is left with <span class="math">2n</span> instances in <span class="math">\\mathsf{NSC}</span> and <span class="math">2n</span> instances in <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span> (half from the original <span class="math">n</span> running instances and half freshly generated by <span class="math">\\Pi_{\\mathsf{ZCR}}</span>). The verifier reduces all these instances via the folding scheme for the nested sum-check relation <span class="math">\\Pi_{\\mathsf{FNSC}}</span> into a single instance in <span class="math">\\mathsf{NSC}</span> and a single instance in <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span>. The verifier concludes by outputting these two instances alongside the fresh instance in <span class="math">\\mathsf{ZC}_{\\mathsf{PC}}</span> generated by <span class="math">\\Pi_{\\mathsf{ZCR}}</span> as the folded instance.</p>

    <p class="text-gray-300">We formally capture this construction in the following theorem. We let <span class="math">1_{\\mathcal{R}}</span> denote the identity reduction (i.e. the prover and the verifier output their inputs) for the relation <span class="math">\\mathcal{R}</span>. In Appendix 4.4, we discuss how to reduce the number of rounds to <span class="math">1+\\log n</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 3 (ZeroFold).</h6>

    <p class="text-gray-300">Given reductions of knowledge</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathsf{ZCR}}:\\mathsf{ZC}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}^{n}\\to\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}\\times\\mathsf{ZC}_{\\mathsf{PC}}</span> (Construction 3), <span class="math">\\Pi_{\\mathsf{FNSC}}:\\mathsf{NSC}^{2n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{2n}\\to\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}</span> (Construction 4)</p>

    <p class="text-gray-300">we have that</p>

    <p class="text-gray-300"><span class="math">(\\Pi_{\\mathsf{FNSC}}\\times 1_{\\mathsf{ZC}_{\\mathsf{PC}}})\\circ(1_{\\mathsf{NSC}^{n}\\times\\mathsf{NSC}_{\\mathsf{PC}}^{n}}\\times\\Pi_{\\mathsf{ZCR}})</span></p>

    <p class="text-gray-300">is a reduction of knowledge of type</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}})^{n}\\times\\mathsf{ZC}^{n}\\to(\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}})</span></p>

    <p class="text-gray-300">with <span class="math">3+\\log n</span> rounds, a communication complexity of <span class="math">O(d\\log n)</span> field elements and <span class="math">1</span> element in the message space of the commitment scheme over size <span class="math">2^{\\ell/2+1}</span> vectors, a prover time complexity of <span class="math">O(ntd\\cdot 2^{\\ell})</span> field operations and a commitment over a size <span class="math">2^{\\ell/2+1}</span> vector, and a verifier time complexity of <span class="math">O(d\\log n)</span> field operations.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.4 Optimizing the round complexity of Theorem 3</h3>

    <p class="text-gray-300">We observe that the zero-check folding scheme can be optimized down to <span class="math">1+\\log n</span> rounds of communication: First, as the commitment <span class="math">\\overline{e}</span> to the powers of <span class="math">\\tau</span> in <span class="math">\\Pi_{\\mathsf{ZCR}}</span> is checked independently of the interaction at a later point, the prover is free to send it as part of its first message in <span class="math">\\Pi_{\\mathsf{FNSC}}</span>. This allows the verifier to send the randomness <span class="math">\\tau</span> in <span class="math">\\Pi_{\\mathsf{ZCR}}</span>, the randomness <span class="math">\\gamma</span> in <span class="math">\\Pi_{\\mathsf{NSC}}</span>, and the randomness <span class="math">\\rho</span> in the</p>

    <p class="text-gray-300">first round of SumFold all in one message, removing a round of communication. Second, in <span class="math">\\Pi_{\\mathsf{NSC}}</span>, instead of sending <span class="math">T_{\\gamma}</span> at the end of the underlying sum-check protocol and then again <span class="math">T</span> and <span class="math">T_{\\mathsf{pc}}</span>. the prover can directly send <span class="math">T</span> and <span class="math">T_{\\mathsf{pc}}</span> (in place of <span class="math">T_{\\gamma}</span>) in the final round of the underlying sum-check protocol. This, once again, removes a round of communication. In the case of folding a single zero-check instance with a single running instance, this brings the overall number of rounds to 2.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5 Folding relations targeting zero-check</h2>

    <p class="text-gray-300">In this section, we design reductions of knowledge <em>[x13]</em> from various relations to zero-check, thereby demonstrating that these relations can also be efficiently folded. Concretely, we reduce an NP-complete relation, CCS <em>[x16]</em>, the grand-product relation, and the lookup relation to zero-check. In all these cases, the reductions are simple, constant-round, and involve minimal verifier work.</p>

    <p class="text-gray-300">To tie together the results of this section, we start with a natural corollary of Theorem 3, which formally states that if there exists a reduction of knowledge from a relation <span class="math">\\mathcal{R}</span> to any number of zero-check instances, then we can fold instances in <span class="math">\\mathcal{R}</span> by first reducing them to instances in the zero-check relation and then applying ZeroFold, NeutronNova’s folding scheme for zero-check.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Corollary 1 (Folding relations targeting zero-check).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathsf{FZC}}</span> represent the zero-check folding scheme from Theorem 3. Given a reduction of knowledge <span class="math">\\Pi:\\mathcal{R}\\to\\mathsf{ZC}^{m}</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathsf{FZC}}\\circ(1_{(\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}})^{nm}}\\times\\Pi^{n})</span></p>

    <p class="text-gray-300">is a reduction of knowledge of type</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}})^{nm}\\times\\mathcal{R}^{n}\\to(\\mathsf{NSC}\\times\\mathsf{NSC}_{\\mathsf{PC}}\\times\\mathsf{ZC}_{\\mathsf{PC}})</span></p>

    <p class="text-gray-300">where the round complexity, communication complexity, prover time complexity and verifier time complexity is the combined total of running <span class="math">\\Pi</span> for <span class="math">n</span> times and <span class="math">\\Pi_{\\mathsf{FZC}}</span> over <span class="math">nm</span> zero-check instances.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">5.1 Reducing CCS to zero-check</h3>

    <p class="text-gray-300">We first reduce the customizable constraint system (CCS) <em>[x16]</em>, to zero-check without any interaction or work by the verifier. Since CCS is an NP-complete language that simultaneously generalizes R1CS <em>[x7]</em>, AIR <em>[x2]</em>, and Plonkish <em>[x9]</em>, we obtain a folding scheme for all of these relations whose efficiency matches the efficiency of our folding scheme for zero-check.</p>

    <p class="text-gray-300">Recall that CCS checks arbitrary degree constraints represented using selector matrices <span class="math">M_{1},\\ldots,M_{t}</span> over <span class="math">z</span> (which is the concatenation of a witness vector <span class="math">w</span>, a public vector <span class="math">\\mathsf{x}</span>, and a constant of 1) by first computing the matrix-vector products <span class="math">M_{j}\\cdot w</span> for all <span class="math">j\\in[t]</span> and then checking a sum of Hadamard products over the resulting vectors. Formally, CCS is defined as follows.</p>

    <p class="text-gray-300">Definition 10 (CCS [STW23]). Let  <span class="math">(\\text{Gen}, \\text{Commit})</span>  denote an additively homomorphic commitment scheme for vectors over finite field  <span class="math">\\mathbb{F}</span> . Consider size bounds  <span class="math">m, n, N, \\ell, t, q, d \\in \\mathbb{N}</span>  where  <span class="math">n &amp;gt; \\ell</span> . We define the customizable constraint system (CCS) relation, CCS, over structure, instance, witness tuples as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {C C S} = \\left\\{(\\mathsf {p p}, (\\vec {M}, \\vec {S}, \\vec {c}), (\\overline {{w}}, \\mathsf {x}), w) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} M \\in (\\mathbb {F} ^ {m \\times n}) ^ {t}, S _ {i} \\subseteq [ t ] \\text { for } i \\in [ q ], \\vec {c} \\in \\mathbb {F} ^ {q} \\\\ \\mathsf {x} \\in \\mathbb {F} ^ {\\ell}, w \\in \\mathbb {F} ^ {m - \\ell - 1}, \\\\ \\mathsf {C o m m i t} (\\mathsf {p p}, w) = \\overline {{w}}, \\\\ \\sum_ {i \\in [ q ]} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} M _ {j} z = 0 \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">z = (w,\\mathsf{x},1)</span>  and each matrix  <span class="math">M_{i}</span>  contains at most  <span class="math">\\Omega (m)</span>  non-zero entries.</p>

    <p class="text-gray-300">We reduce CCS to zero-check as follows: we design an inner zero-check structure polynomial  <span class="math">G_{\\vec{M}}</span>  that encodes the CCS selector matrices  <span class="math">M_1, \\ldots, M_t</span> . Specifically, on input witness vector  <span class="math">w</span>  and a public vector  <span class="math">\\mathbf{x}</span> ,  <span class="math">G_{\\vec{M}}</span>  outputs the multilinear extensions of  <span class="math">M_1z, \\ldots, M_tz</span> , where  <span class="math">z = (w, \\mathbf{x}, 1)</span> . Then, for each row of entries in these vectors, we design an outer zero-check structure polynomial  <span class="math">F_{\\vec{S},\\vec{c}}</span>  that takes a sum of products exactly as the original CCS structure dictates. Formally we have the following reduction from CCS to zero-check.</p>

    <p class="text-gray-300">Lemma 7 (From CCS to zero-check [STW23]). Consider size bounds  <span class="math">m</span> ,  <span class="math">n</span> ,  <span class="math">N</span> ,  <span class="math">\\ell</span> ,  <span class="math">t</span> ,  <span class="math">q</span> , and  <span class="math">d</span>  where  <span class="math">n &amp;gt; \\ell</span> . We have that  <span class="math">(\\mathsf{pp}, (\\vec{M}, \\vec{S}, \\vec{c}), (\\overline{w}, \\mathsf{x}), w) \\in \\mathsf{CCS}</span>  if and only if  <span class="math">(\\mathsf{pp}, (F, G), (\\overline{w}, \\mathsf{x}), w) \\in \\mathsf{ZC}</span>  where for  <span class="math">z = (w, \\mathsf{x}, 1)</span></p>

    <div class="my-4 text-center"><span class="math-block">F _ {\\vec {S}, \\vec {c}} (m _ {1}, \\dots , m _ {t}) = \\sum_ {i \\in [ q ]} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} m _ {j}</span></div>

    <div class="my-4 text-center"><span class="math-block">G _ {\\vec {M}} (w, \\mathsf {x}) = (\\widetilde {(M _ {1} z)}, \\ldots , \\widetilde {(M _ {t} z)}).</span></div>

    <p class="text-gray-300">This naturally induces an equivalent reduction of knowledge (with no interaction) by defining the encoder, prover, and verifier to map the structure, instance, and witness identically. Then, by Corollary 1, we have a folding scheme for CCS.</p>

    <h2 id="sec-36" class="text-2xl font-bold">5.2 Reducing grand-product to zero-check</h2>

    <p class="text-gray-300">In this section, we reduce the grand-product relation to the zero-check relation, thereby providing a folding scheme for grand-products. We rely on results from Lasso [STW24], which itself builds on its predecessors [Set20,SL20].</p>

    <p class="text-gray-300">Recall that the grand-product relation checks that taking the product of elements of a committed vector  <span class="math">v</span>  results in some prescribed value  <span class="math">p</span> .</p>

    <p class="text-gray-300">Definition 11 (Grand-product relation). Let  <span class="math">(\\text{Gen}, \\text{Commit})</span>  denote an additively-homomorphic commitment scheme for vectors over finite field  <span class="math">\\mathbb{F}</span> . Consider size bound  <span class="math">n, m \\in \\mathbb{N}</span> . We define the grand-product relation  <span class="math">\\mathsf{GP}</span>  over public parameter, instance, witness tuples as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {G P} = \\left\\{\\left(\\mathsf {p p}, (p, \\overline {{v}}), v\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} v \\in \\mathbb {F} ^ {n} \\\\ \\mathsf {C o m m i t} (\\mathsf {p p}, v) = \\overline {{v}}, \\\\ v = \\prod_ {i \\in [ m ]} v _ {i} \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Lasso provides two options for <em>proving</em> grand products: (1) the approach presented in Section 5.2, which in their setting is then proven with the sum-check protocol; and (2) the protocol of Thaler <em>[x10]</em>, a specialization of GKR proof system <em>[x5]</em>. The main trade-off is that the first option requires committing to an additional vector of size <span class="math">N</span>, where <span class="math">N</span> us the number of entries in <span class="math">v</span> whereas the second protocol requires logarithmic number of invocations of the sum-check protocol, resulting in a proof length of <span class="math">O(\\log^{2}N)</span>. To mitigate this trade-off, Setty and Lee <em>[x16, §6]</em> also describe a hybrid solution where their grand product argument is applied on an instance of size <span class="math">N/2^{k}</span> (for some chosen parameter <span class="math">k</span>) and Thaler’s protocol is applied to reduce a claim about that instance to a multilinear evaluation claim about <span class="math">\\widetilde{v}</span>. For simplicity, we focus on option (1). However, both option (2) and the hybrid solution induce alternative compatible reductions from grand-product to zero-check.</p>

    <p class="text-gray-300">At a high level, Setty and Lee consider a new polynomial <span class="math">f</span>, which contains the original vector <span class="math">v</span> as well as all the intermediate products computed in a tree-like fashion. Then, the relationship between <span class="math">v</span> and the final claimed product <span class="math">p</span> can be checked using quadratic constraints.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 8 (Grand-product arithmetization <em>[x16]</em>).</h6>

    <p class="text-gray-300">Consider <span class="math">p\\in\\mathbb{F}</span> and <span class="math">v\\in\\mathbb{F}^{n}</span>. There exists an efficiently computable <span class="math">f\\in\\mathbb{F}[X_{1},\\ldots,X_{\\log n+1}]</span> such that <span class="math">p=\\prod_{i\\in[n]}v_{i}</span> if and only if <span class="math">f(0,x)=\\widetilde{v}(x)</span>, <span class="math">f(1,\\ldots,1,0)=p</span> and</p>

    <p class="text-gray-300"><span class="math">f(1,x)=f(x,0)\\cdot f(x,1)</span> (9)</p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span>.</p>

    <p class="text-gray-300">In light of this arithmetization, we get a natural reduction from grand-product to zero-check: The prover begins by committing to an intermediate product vector <span class="math">v^{\\prime}</span> which is the portion of <span class="math">f</span> not including <span class="math">v</span>. Together <span class="math">v</span> and <span class="math">v^{\\prime}</span> are treated as the new zero-check witness and a vector with a single entry of <span class="math">p</span> is treated as the public vector. Then, we design an inner zero-check structure polynomial <span class="math">G_{\\mathsf{GP}}</span>, which produces polynomials <span class="math">g_{1}(x)=f(1,x)</span>, <span class="math">g_{2}(x)=f(x,0)</span>, and <span class="math">g_{3}(x)=f(x,1)</span> by selecting elements from <span class="math">v</span>, <span class="math">v^{\\prime}</span>, and <span class="math">p</span>. For each evaluation of these polynomials we design an outer zero-check structure polynomial <span class="math">F_{\\mathsf{GP}}</span> that computes Equation 9. Formally, we have the following reduction.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Construction 5 (From grand-product to zero-check).</h6>

    <p class="text-gray-300">We construct a reduction of knowledge of type</p>

    <p class="text-gray-300"><span class="math">\\mathsf{GP}\\to\\mathsf{ZC}.</span></p>

    <p class="text-gray-300">Consider size bound <span class="math">n\\in\\mathbb{N}</span>. Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an arbitrary additively homomorphic vector commitment scheme. We define the generator, encoder, prover, and verifier as follows.</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathcal{G}(\\lambda,n)}</span>: Output <span class="math">\\mathsf{pp}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathsf{Gen}(\\lambda,n)$.</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathcal{K}(\\mathsf{pp})}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">F_{\\mathsf{GP}}(g_{1},g_{2},g_{3})=g_{1}-g_{2}\\cdot g_{3}</span> and define <span class="math">G_{\\mathsf{GP}}</span> on input <span class="math">((v,v^{\\prime}),p)</span> to output</li>

    </ol>

    <p class="text-gray-300"><span class="math">g_{1}(x)</span> <span class="math">\\leftarrow f(1,x)</span> <span class="math">g_{2}(x)</span> <span class="math">\\leftarrow f(x,0)</span> <span class="math">g_{3}(x)</span> <span class="math">\\leftarrow f(x,1)</span></p>

    <p class="text-gray-300">where <span class="math">f</span> is the multilinear extension of <span class="math">(v,(v^{\\prime}_{1},\\ldots,v^{\\prime}_{n-2},p,v^{\\prime}_{n}))</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow(\\mathsf{pp},\\bot)</span> and the updated zero-check structure <span class="math">(F_{\\mathsf{GP}},G_{\\mathsf{GP}})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),(p,\\overline{v}),v)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute a multilinear polynomial <span class="math">\\widetilde{f}</span> as guaranteed by Lemma 8. Define <span class="math">v^{\\prime}\\in\\mathbb{F}^{n}</span> such that <span class="math">\\widetilde{v}^{\\prime}=\\widetilde{f}(1,x)</span> and send a commitment <span class="math">\\overline{v}^{\\prime}\\leftarrow\\mathsf{Commit}(\\mathsf{pp},v^{\\prime})</span>.</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}:</span> Produce the following zero-check instance-witness pair (the verifier only outputs the instance)</li>

    </ol>

    <p class="text-gray-300"><span class="math">(((\\overline{v},\\overline{v}^{\\prime}),p),(v,v^{\\prime}))\\in\\mathsf{ZC}.</span></p>

    <p class="text-gray-300">We formally prove the following lemma in Appendix B.5, which, by Corollary 1 implies a folding scheme for <span class="math">\\mathsf{GP}</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 9 (From grand-product to zero-check)</h6>

    <p class="text-gray-300">Construction 5 is an RoK of type <span class="math">\\mathsf{GP}\\to\\mathsf{ZC}</span> with a single round, a communication complexity of one element in the message space of the commitment scheme for vectors of size <span class="math">n</span>. The prover’s time complexity is <span class="math">O(n)</span> and the verifier’s time complexity is <span class="math">O(1)</span>.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">5.3 Reducing lookups to grand-product</h3>

    <p class="text-gray-300">In this section, we reduce a lookup instance to several grand product instances, which, from the previous subsection, can be reduced to zero-check instances. Hence, we get a folding scheme for the lookup relation.</p>

    <p class="text-gray-300">Our starting point is Lasso <em>[x20]</em>, a state-of-the-art lookup argument. Lasso supports unstructured tables (for which the verifier holds a commitment) as well as very large Spark-only structured (SOS) tables that do not need to be materialized either by the prover nor the verifier. Crucially, Lasso’s lookup argument for very large structured tables of size <span class="math">N</span> is obtained by essentially running <span class="math">c</span> copies of the lookup argument for unstructured tables on tables of size <span class="math">N^{1/c}</span> and then assembling results of sub-table lookups (e.g., with CCS). A similar observation appears in prior work <em>[x10]</em>. For this reason, the rest of the section focuses on lookups over unstructured tables, but our results naturally generalize to Lasso’s SOS tables.</p>

    <p class="text-gray-300">Recall that the lookup relation checks that a committed vector <span class="math">v</span> only consists of elements found in a committed table <span class="math">t</span>. Lasso considers a more general form, which they refer to as indexed lookups, where an additional committed vector</p>

    <p class="text-gray-300">indicates which index of <span class="math">t</span> each entry of <span class="math">v</span> can be found. All lookups used in Jolt <em>[x1]</em> are indexed lookups, so we focus on this general version.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 12 (Lookup relation <em>[x20]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size parameters <span class="math">n,m\\in\\mathbb{N}</span>. We define the lookup relation <span class="math">\\mathsf{LKP}</span> over public parameter, instance, witness tuples as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{LKP}=\\left\\{(\\mathsf{pp},(\\bar{t},\\overline{a},\\overline{v}),(t,a,v))\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}v,a\\in\\mathbb{F}^{m},t\\in\\mathbb{F}^{n},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\forall i\\in[m].\\ v_{i}=t_{a_{i}},\\\\ \\mathsf{Commit}(\\mathsf{pp},t)=\\bar{t},\\\\ \\mathsf{Commit}(\\mathsf{pp},a)=\\overline{a},\\\\ \\mathsf{Commit}(\\mathsf{pp},v)=\\overline{v},\\end{array} \\right.\\right\\}. \\]</p>

    <p class="text-gray-300">Instead of directly proving the above relation, Lasso reformulates the lookup relation as the following bivariate polynomial identity test. This bivariate identity is implicit in <em>[x20, Claim 3]</em>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 10 (Lookup arithmetization <em>[x22, x20]</em>).</h6>

    <p class="text-gray-300">Consider vectors <span class="math">v,a\\in\\mathbb{F}^{m}</span> and <span class="math">t\\in\\mathbb{F}^{n}</span>. There exist efficiently computable vectors <span class="math">c\\in\\mathbb{F}^{m}</span> and <span class="math">f\\in\\mathbb{F}^{n}</span> such that <span class="math">v_{i}=t_{a_{i}}</span> for all <span class="math">i\\in[m]</span> if and only if</p>

    <p class="text-gray-300">\\[ \\left(\\prod_{i\\in[n]}(i+t_{i}\\cdot X-Y)\\right)\\cdot\\left(\\prod_{i\\in[m]}(a_{i}+v_{i}\\cdot X+(c_{i}+1)\\cdot X^{2}-Y)\\right)=\\\\ \\left(\\prod_{i\\in[m]}(a_{i}+v_{i}\\cdot X+c_{i}\\cdot X^{2}-Y)\\right)\\cdot\\left(\\prod_{i\\in[n]}(i+t_{i}\\cdot X+f_{i}\\cdot X^{2}-Y)\\right). \\] (10)</p>

    <p class="text-gray-300">Checking Equation (10) can be reduced to checking four grand product instances (Definition 11). In particular, the prover first computes <span class="math">c</span> and <span class="math">f</span> as guaranteed by Lemma 10 and send the corresponding commitments <span class="math">\\overline{c}</span> and <span class="math">\\overline{f}</span>. The verifier samples and sends challenges <span class="math">r_{X}\\in\\mathbb{F}</span> and <span class="math">r_{Y}\\in\\mathbb{F}</span> to check Equation (10) at a single random point. By the Schwartz-Zippel lemma, this implies checking the original polynomial identity with overwhelming probability. The prover then sends claimed products <span class="math">p_{1}</span>, <span class="math">p_{2}</span>, <span class="math">p_{3}</span>, and <span class="math">p_{4}</span> for each of the grand products in Equation (10) The verifier checks that <span class="math">p_{1}\\cdot p_{2}=p_{3}\\cdot p_{4}</span>, and then homomorphically compute and output commitments to each of the inner vectors to be checked in constant time. Formally, we have the following reduction.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Construction 6 (From Lookup to grand-product).</h6>

    <p class="text-gray-300">We construct a reduction of knowledge of type</p>

    <p class="text-gray-300"><span class="math">\\mathsf{LKP}\\to\\mathsf{GP}^{4}.</span></p>

    <p class="text-gray-300">Consider size bounds <span class="math">n,m\\in\\mathbb{N}</span>. Let <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> denote an arbitrary additively homomorphic commitment scheme. We define the generator, encoder, prover,</p>

    <p class="text-gray-300">and verifier as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(\\lambda,(n,m))</span>: Output <span class="math">\\mathsf{pp}\\stackrel{{\\scriptstyle\\mathfrak{s}}}{{\\leftarrow}}\\mathsf{Gen}(\\lambda,\\max{(n,m)})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute vector commitments</li>

    </ol>

    <p class="text-gray-300"><span class="math">G_{n}</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},1^{n})</span> <span class="math">G_{m}</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},1^{m})</span> <span class="math">H</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},(1,\\ldots,n)).</span> <span class="math">G_{n}</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},1^{n}),\\,G_{m}</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},1^{m}),\\,H</span> <span class="math">\\leftarrow\\mathsf{Commit}(\\mathsf{pp},(1,\\ldots,n)).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow((\\mathsf{pp},(G_{n},G_{m},H)),(G_{n},G_{m},H)).</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),(\\bar{t},\\overline{a},\\overline{v}),(t,a,v))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute <span class="math">c\\in\\mathbb{F}^{m}</span> and <span class="math">f\\in\\mathbb{F}^{n}</span> as guaranteed by Lemma 10 and send <span class="math">\\overline{c}\\leftarrow\\mathsf{Commit}(\\mathsf{pp},c)</span> and <span class="math">\\overline{f}\\leftarrow\\mathsf{Commit}(\\mathsf{pp},f).</span></li>

      <li><span class="math">\\mathcal{V}</span>: Send random challenges <span class="math">r_{X}\\in\\mathbb{F}</span> and <span class="math">r_{Y}\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{P}</span>: Compute the underlying grand-product witnesses</li>

    </ol>

    <p class="text-gray-300"><span class="math">v_{1}</span> <span class="math">\\leftarrow\\{(i+t_{i}\\cdot r_{X}-r_{Y})\\}_{i\\in[n]}</span> <span class="math">v_{2}</span> <span class="math">\\leftarrow\\{(a_{i}+v_{i}\\cdot r_{X}+(c_{i}+1)\\cdot r_{X}^{2}-r_{Y})\\}_{i\\in[m]}</span> <span class="math">v_{3}</span> <span class="math">\\leftarrow\\{(a_{i}+v_{i}\\cdot r_{X}+c_{i}\\cdot r_{X}^{2}-r_{Y})\\}_{i\\in[m]}</span> <span class="math">v_{4}</span> <span class="math">\\leftarrow\\{(i+t_{i}\\cdot r_{X}+f_{i}\\cdot r_{X}^{2}-r_{Y})\\}_{i\\in[n]}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute and send the claimed products <span class="math">p_{k}\\leftarrow\\prod_{i}v_{k,i}</span> for <span class="math">k\\in\\{1,2,3,4\\}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Check that <span class="math">p_{1}\\cdot p_{2}=p_{3}\\cdot p_{4}</span>.</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Compute the corresponding vector commitments</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\overline{v}_{1}</span> <span class="math">\\leftarrow H+\\bar{t}\\cdot r_{X}-G_{n}\\cdot r_{Y}</span> <span class="math">\\overline{v}_{2}</span> <span class="math">\\leftarrow\\overline{a}+\\overline{v}\\cdot r_{X}+(\\overline{c}+G_{m})\\cdot r_{X}^{2}-G_{m}\\cdot r_{Y}</span> <span class="math">\\overline{v}_{3}</span> <span class="math">\\leftarrow\\overline{a}+\\overline{v}\\cdot r_{X}+\\overline{c}\\cdot r_{X}^{2}-G_{m}\\cdot r_{Y}</span> <span class="math">\\overline{v}_{4}</span> <span class="math">\\leftarrow H+\\bar{t}\\cdot r_{X}+\\overline{f}\\cdot r_{X}^{2}-G_{n}\\cdot r_{Y}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Output the following grand-product instance-witness pairs (the verifier only outputs instances)</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\{((p_{k},\\overline{v}_{k}),v_{k})\\}_{k\\in[4]}\\in\\mathsf{GP}^{4}</span></p>

    <p class="text-gray-300">We formally prove the following lemma in Appendix B.4.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Lemma 11 (From lookup to grand-product).</h6>

    <p class="text-gray-300">Construction 6 is an RoK of type <span class="math">\\mathsf{LKP}\\to\\mathsf{GP}^{4}</span> with <span class="math">2</span> rounds, a communication cost of <span class="math">6</span> field elements, and <span class="math">2</span> elements in the message space of the commitment scheme over vectors of size <span class="math">n</span> and <span class="math">m</span>. The prover’s time complexity is <span class="math">O(n+m)</span> field operations, time to compute commitments to vectors of size <span class="math">n</span> and <span class="math">m</span>, and <span class="math">O(1)</span> operations in the message space of the commitment scheme. The verifier’s time complexity is <span class="math">O(1)</span>.</p>

    <p class="text-gray-300">By Lemma 9, we have a reduction of knowledge from lookup to four zero-check instances. By Corollary 1, we get the desired folding scheme for the lookup relation. However, by our optimization in Section 4, to combine two sum-check reductions into one, we can only fold the same number of “fresh” instances and “running” instances. However, in our setting, we must fold <span class="math">n</span> lookup instances into <span class="math">4n</span> running instances. This is not an issue as we can always generate trivially satisfying running instances or forgo the optimization to remove this dependence.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">Acknowledgments</h3>

    <p class="text-gray-300">We thank Justin Thaler for helpful conversations and comments on a prior version of this paper. Abhiram Kothapalli was supported by the Carnegie Mellon University (CMU) Secure Blockchain Initiative and Anaxi Labs through the CMU CyLab partnership program.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AS24. Arasu Arun and Srinath Setty. Nebula: Efficient read-write memory and switchboard circuits for folding schemes. Cryptology ePrint Archive, 2024.</li>

      <li>AST24. Arasu Arun, Srinath Setty, and Justin Thaler. Jolt: SNARKs for VMs via lookups. In EUROCRYPT, 2024.</li>

      <li>BC23. Benedikt Bünz and Binyi Chen. Protostar: Generic efficient accumulation/folding for special sound protocols. In ASIACRYPT, 2023.</li>

      <li>BC24a. Dan Boneh and Binyi Chen. LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257, 2024.</li>

      <li>BC24b. Benedikt Bünz and Jessica Chen. Proofs for deep thought: Accumulation for large memories and deterministic computations. Cryptology ePrint Archive, Paper 2024/325, 2024.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT, 2016.</li>

      <li>BCCT13. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In STOC, 2013.</li>

      <li>BCL^{+}21. Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data without succinct arguments. In CRYPTO, 2021.</li>

      <li>BCMS20. Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. In TCC, 2020.</li>

      <li>BCS21. Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. Sumcheck arguments and their applications. In CRYPTO, pages 742–773, 2021.</li>

      <li>BCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. In CRYPTO, 2014.</li>

      <li>BEG^{+}91. Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. In FOCS, 1991.</li>

      <li>BFL92. L. Babai, L. Fortnow, and C. Lund. Non-deterministic exponential time has two-prover interactive protocols. Computational Complexity, 2(4), December 1992.</li>

      <li>BFLS91. László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In STOC, 1991.</li>

      <li>BGH19. Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019.</li>

      <li>BMNW24. Benedikt Bünz, Pratyush Mishra, Wilson Nguyen, and William Wang. Accumulation without homomorphism. Cryptology ePrint Archive, Paper 2024/474, 2024.</li>

      <li>BSBHR19. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In CRYPTO, 2019.</li>

      <li>BTVW14. Andrew J. Blumberg, Justin Thaler, Victor Vu, and Michael Walfish. Verifiable computation using multiple provers. ePrint Report 2014/846, 2014.</li>

      <li>CBBZ23. Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In EUROCRYPT, 2023.</li>

    </ul>

    <p class="text-gray-300">CDD^{+}03. Dwaine Clarke, Srinivas Devadas, Marten Van Dijk, Blaise Gassend, G. Edward, and Suh Mit. Incremental multiset hash functions and their application to memory integrity checking. In ASIACRYPT, 2003.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] DGMV24. Nikolaos Dimitriou, Albert Garreta, Ignacio Manzur, and Ilia Vlasov. Mova: Nova folding without committing to error terms. Cryptology ePrint Archive, Paper 2024/1220, 2024.</li>

      <li>[21] DP23. Benjamin E. Diamond and Jim Posen. Succinct arguments over towers of binary fields. Cryptology ePrint Archive, Paper 2023/1784, 2023.</li>

      <li>[22] DT24. Quang Dao and Justin Thaler. More optimizations to sum-check proving. Cryptology ePrint Archive, Paper 2024/1210, 2024.</li>

      <li>[23] EG23. Liam Eagen and Ariel Gabizon. Protogalaxy: Efficient ProtoStar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106, 2023.</li>

      <li>[24] EGS^{+}24. Liam Eagen, Ariel Gabizon, Marek Sefranek, Patrick Towa, and Zachary J. Williamson. Stackproofs: Private proofs of stack and contract execution using protogalaxy. Cryptology ePrint Archive, Paper 2024/1281, 2024.</li>

      <li>[25] GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In EUROCRYPT, 2013.</li>

      <li>[26] GKR08. Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for muggles. In STOC, 2008.</li>

      <li>[27] GLS^{+}23. Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In CRYPTO, 2023.</li>

      <li>[28] Gru24. Angus Gruen. Some improvements for the PIOP for ZeroCheck. Cryptology ePrint Archive, Paper 2024/108, 2024.</li>

      <li>[29] GW20. Ariel Gabizon and Zachary J Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, 2020.</li>

      <li>[30] GWC19. Ariel Gabizon, Zachary J Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, 2019.</li>

      <li>[31] Hab22. Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Paper 2022/1530, 2022.</li>

      <li>[32] KP23. Abhiram Kothapalli and Bryan Parno. Algebraic reductions of knowledge. In CRYPTO, 2023.</li>

      <li>[33] KS24. Abhiram Kothapalli and Srinath Setty. Hypernova: Recursive arguments for customizable constraint systems. In CRYPTO, pages 345–379, 2024.</li>

      <li>[34] KST22. Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. Nova: Recursive Zero-Knowledge Arguments from Folding Schemes. In CRYPTO, 2022.</li>

      <li>[35] LFKN90. Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In FOCS, October 1990.</li>

      <li>[36] NDC^{+}24. Wilson Nguyen, Trisha Datta, Binyi Chen, Nirvan Tyagi, and Dan Boneh. Mangrove: A scalable framework for folding-based SNARKs. In CRYPTO, 2024.</li>

      <li>[37] nex24a. Summary of Nexus zkVM costs. https://docs.nexus.xyz/specs/nexus-costs, 2024.</li>

      <li>[38] nex24b. The Nexus zkVM. https://github.com/nexus-xyz/nexus-zkvm, 2024.</li>

      <li>[39] ova. Ova: A slightly better Nova. https://hackmd.io/V4838nnlRKal9ZiTHiGYzw.</li>

    </ul>

    <p class="text-gray-300">SAGL18. Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. Proving the correct execution of concurrent services in zero-knowledge. In OSDI, October 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sch [2020] Sch80. Jacob T Schwartz. Fast probabilistic algorithms for verification of polynomial identities. Journal of the ACM, 27(4), 1980.</li>

      <li>Set [2019] Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In CRYPTO, 2020.</li>

      <li>Sha [1992] Sha92. Adi Shamir. IP = PSPACE. Journal of the ACM, 39(4):869–877, 1992.</li>

      <li>SL [2019] SL20. Srinath Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Report 2020/1275, 2020.</li>

      <li>ST [2024] ST24. Srinath Setty and Justin Thaler. Folding (Jolt Book). https://jolt.a16zcrypto.com/future/folding.html, 2024.</li>

      <li>STW [2023] STW23. Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, 2023.</li>

      <li>STW [2024] STW24. Srinath Setty, Justin Thaler, and Riad Wahby. Unlocking the lookup singularity with Lasso. In EUROCRYPT, 2024.</li>

      <li>Tha [2013] Tha13. Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In CRYPTO, 2013.</li>

      <li>Val [2008] Val08. Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In TCC, pages 552–576, 2008.</li>

      <li>VSBW [2013] VSBW13. Victor Vu, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. A hybrid architecture for verifiable computation. In S&P, 2013.</li>

      <li>ZV [2023] ZV23. Yan Zhang and Aard Vark. Parallelizing Nova – Visualizations and Mental Models behind Paranova. https://zkresear.ch/t/parallelizing-nova-visualizations-and-mental-models-behind-paranova/198, 2023.</li>

      <li>ZZD [2023] ZZD23. Zibo Zhou, Zongyang Zhang, and Jin Dong. Proof-carrying data from multi-folding schemes. Cryptology ePrint Archive, Paper 2023/1282, 2023.</li>

    </ul>

    <p class="text-gray-300">A Additional Background</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">A.1 Polynomials and multilinear extensions</h3>

    <p class="text-gray-300">We adapt this subsection from prior work <em>[x23]</em>. We recall several definitions and results regarding multivariate polynomials.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 13 (Multilinear polynomial).</h6>

    <p class="text-gray-300">A multivariate polynomial is called a multilinear polynomial if the degree of the polynomial in each variable is at most one.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 14 (Multilinear polynomial extension).</h6>

    <p class="text-gray-300">Given a vector <span class="math">v\\in\\mathbb{F}^{n}</span> a <em>multilinear polynomial extension</em> of <span class="math">v</span> is an <span class="math">(\\log n)</span>-variate multilinear polynomial, denoted <span class="math">\\widetilde{v}</span>, such that <span class="math">\\widetilde{v}(x)=v_{x}</span> for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span>. Specifically, <span class="math">\\widetilde{v}</span> can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{v}(x)=\\sum_{y\\in\\{0,1\\}^{\\ell}}v_{y}\\cdot\\mathsf{eq}(x,y)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{eq}(x,y)=\\prod_{i=1}^{\\ell}(x_{i}\\cdot y_{i}+(1-x_{i})\\cdot(1-y_{i}))</span>, outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\log n}</span>.</p>

    <p class="text-gray-300">For any <span class="math">r\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\widetilde{v}(r)</span> can be computed in <span class="math">O(2^{\\ell})</span> operations in <span class="math">\\mathbb{F}</span> <em>[x25, x18]</em>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 12 (Schwartz-Zippel <em>[x20]</em>).</h6>

    <p class="text-gray-300">let <span class="math">g:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be an <span class="math">\\ell</span>-variate polynomial of total degree at most <span class="math">d</span>. Then, on any finite set <span class="math">S\\subseteq\\mathbb{F}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\leftarrow S^{\\ell}}[g(x)=0]\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">A.2 Commitment Schemes</h3>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 15 (Commitment Scheme).</h6>

    <p class="text-gray-300">A commitment scheme is defined by polynomial-time algorithm <span class="math">\\mathsf{Gen}:\\mathbb{N}^{2}\\to P</span> that produces public parameters given the security parameter and size parameter, a deterministic polynomial-time algorithm <span class="math">\\mathsf{Commit}:P\\times M\\times R\\to C</span> that produces a commitment in <span class="math">C</span> given a public parameters, message, and randomness tuple such that binding holds. That is, for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(\\lambda,n)</span>, and given <span class="math">((m_{1},r_{1}),(m_{2},r_{2}))\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[(m_{1},r_{1})\\neq(m_{2},r_{2})\\land\\mathsf{Commit}(\\mathsf{pp},m_{1},r_{1})=\\mathsf{Commit}(\\mathsf{pp},m_{2},r_{2})]\\approx 0.</span></p>

    <p class="text-gray-300">The commitment scheme is deterministic if <span class="math">\\mathsf{Commit}</span> does not use its randomness.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 16 (Homomorphic).</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">(\\mathsf{Gen},\\mathsf{Commit})</span> is homomorphic if the message space <span class="math">M</span>, randomness space <span class="math">R</span>, and commitment space <span class="math">C</span> are groups and for all <span class="math">n\\in\\mathbb{N}</span>, and <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(\\lambda,n)</span>, we have that for any <span class="math">m_{1},m_{2}\\in M</span> and <span class="math">r_{1},r_{2}\\in R</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},m_{1},r_{1})+\\mathsf{Commit}(\\mathsf{pp},m_{2},r_{2})=\\mathsf{Commit}(\\mathsf{pp},m_{1}+m_{2},r_{1}+r_{2}).</span></p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 17 (Succinct Commitments). A commitment scheme (Gen, Commit), over message space <span class="math">M</span> and commitment space <span class="math">R</span>, provides succinct commitments if for all <span class="math">\\mathsf{pp} \\gets \\mathsf{Gen}(1^{\\lambda})</span>, and any <span class="math">m \\in M</span> and <span class="math">r \\in R</span>, we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Commit}(\\mathsf{pp}, m, r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O_{\\lambda}(\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-53" class="text-2xl font-bold">A.3 Reductions of Knowledge</h2>

    <p class="text-gray-300">First, we define additional properties of reductions of knowledge.</p>

    <p class="text-gray-300">Definition 18 (Succinctness). A reduction of knowledge is succinct if the communication complexity and the verifier time complexity is at most polylogarithmic in the size of the structure and witness.</p>

    <p class="text-gray-300">Definition 19 (Non-interactivity). A reduction of knowledge is non-interactive if the interaction consists of a single message from the prover to the verifier. In this case, we denote this single message as the output of the prover, and as an input to the verifier.</p>

    <p class="text-gray-300">Definition 20 (Public-coin). A reduction of knowledge is public-coin if the verifier only sends uniformly random challenges during the interaction.</p>

    <p class="text-gray-300">Next, we define the semantics of the sequential and parallel composition operators.</p>

    <p class="text-gray-300">Lemma 13 (Sequential composition [KP23]). For reductions <span class="math">\\Pi_1 = (\\mathcal{G}, \\mathcal{K}_1, \\mathcal{P}_1, \\mathcal{V}_1): \\mathcal{R}_1 \\to \\mathcal{R}_2</span> and <span class="math">\\Pi_2 = (\\mathcal{G}, \\mathcal{K}_2, \\mathcal{P}_2, \\mathcal{V}_2): \\mathcal{R}_2 \\to \\mathcal{R}_3</span>, we have that <span class="math">\\Pi_2 \\circ \\Pi_1 = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V}): \\mathcal{R}_1 \\to \\mathcal{R}_3</span> where <span class="math">\\mathcal{K}(\\mathsf{pp}, \\mathsf{s}_1)</span> computes <span class="math">(\\mathsf{pk}_1, \\mathsf{vk}_1, \\mathsf{s}_2) \\gets \\mathcal{K}_1(\\mathsf{pp}, \\mathsf{s}_1)</span>, <span class="math">(\\mathsf{pk}_2, \\mathsf{vk}_2, \\mathsf{s}_3) \\gets \\mathcal{K}_2(\\mathsf{pp}, \\mathsf{s}_2)</span> and outputs <span class="math">((\\mathsf{pk}_1, \\mathsf{pk}_2), (\\mathsf{vk}_1, \\mathsf{vk}_2), \\mathsf{s}_3)</span> and where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{P}((\\mathsf{pk}_1, \\mathsf{pk}_2), u_1, w_1) = \\mathcal{P}_2(\\mathsf{pk}_2, \\mathcal{P}_1(\\mathsf{pk}_1, u_1, w_1))</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{V}((\\mathsf{vk}_1, \\mathsf{vk}_2), u_1) = \\mathcal{V}_2(\\mathsf{vk}_2, \\mathcal{V}_1(\\mathsf{vk}_1, u_1, w_1))</span></div>

    <p class="text-gray-300">Lemma 14 (Parallel composition [KP23]). Consider relations <span class="math">\\mathcal{R}_1</span>, <span class="math">\\mathcal{R}_2</span>, <span class="math">\\mathcal{R}_3</span>, and <span class="math">\\mathcal{R}_4</span>. For reductions of knowledge <span class="math">\\Pi_1 = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}_1, \\mathcal{V}_1): \\mathcal{R}_1 \\to \\mathcal{R}_2</span> and <span class="math">\\Pi_2 = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}_2, \\mathcal{V}_2): \\mathcal{R}_3 \\to \\mathcal{R}_4</span> we have that <span class="math">\\Pi_1 \\times \\Pi_2 = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V}): \\mathcal{R}_1 \\times \\mathcal{R}_3 \\to \\mathcal{R}_2 \\times \\mathcal{R}_4</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{P}(\\mathsf{pk}, (u_1, u_3), (w_1, w_3)) = (\\mathcal{P}_1(\\mathsf{pk}, u_1, w_1), \\mathcal{P}_2(\\mathsf{pk}, u_3, w_3))</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{V}(\\mathsf{vk}, (u_1, u_3)) = (\\mathcal{V}_1(\\mathsf{vk}, u_1), \\mathcal{V}_2(\\mathsf{vk}, u_3))</span></div>

    <p class="text-gray-300">Next, we can define arguments of knowledge as a special type of reduction of knowledge.</p>

    <p class="text-gray-300">Definition 21 (Argument of Knowledge). Consider the boolean relation <span class="math">\\mathsf{TRUE} = \\{(\\mathsf{true}, \\bot)\\}</span>. A proof of knowledge for relation <span class="math">\\mathcal{R}</span> is a reduction of knowledge of type <span class="math">\\mathcal{R} \\to \\mathsf{TRUE}</span>.</p>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">When proving the security of protocols, reasoning about knowledge soundness directly is typically cumbersome. To alleviate this issue, Bootle et al. <em>[BCC^{+}16]</em> show that to prove knowledge soundness for the vast majority of public-coin interactions, it is sufficient to show that there exists an extractor that can produce a satisfying witness when provided a tree of accepting transcripts with refreshed verifier randomness at each layer. This property is known as <em>tree-extractability</em> and we formally state the corresponding result for reductions of knowledge (proven by Kothapalli and Parno <em>[x10]</em>).</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 22 (Tree of transcripts)</h6>

    <p class="text-gray-300">Consider an <span class="math">m</span>-round public-coin interactive protocol <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> that satisfies the interface described in Definition 1. For a public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1})</span>, a <span class="math">(n_{1},\\ldots,n_{m})</span>-tree of accepting transcripts is a tree of depth <span class="math">m</span> where each vertex at layer <span class="math">i</span> has <span class="math">n_{i}</span> outgoing edges such that (1) each vertex in layer <span class="math">i\\in[m]</span> is labeled with a prover message for round <span class="math">i</span>; (2) each outgoing edge from layer <span class="math">i\\in[m]</span> is labeled with a different choice of verifier randomness for round <span class="math">i</span>; (3) each leaf is labeled with an accepting statement-witness pair output by the prover and verifier corresponding to the interaction along the path.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Lemma 15 (Tree extraction <em>[x10]</em>)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider an <span class="math">m</span>-round public-coin interactive protocol <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> that satisfies the interface described in Definition 1 and satisfies completeness. Then <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is a reduction of knowledge if there exists a PPT extractor <span class="math">\\chi</span> that outputs a satisfying witness <span class="math">w_{1}</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>, given an <span class="math">(n_{1},\\ldots,n_{m})</span>-tree of accepting transcripts for public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1})</span> where the verifier’s randomness is sampled from space <span class="math">Q</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\lambda})<span class="math">, and </span>\\prod_{i}n_{i}=\\mathsf{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">A.4 Incrementally Verifiable Computation</h3>

    <p class="text-gray-300">Recall that incrementally verifiable computation (IVC), enables a prover to to produce a proof <span class="math">\\pi_{i+1}</span> for <span class="math">i+1</span> steps of a computation given a proof <span class="math">\\pi_{i}</span> for <span class="math">i</span> steps of the computation in a way that ensures that the proof size remains independent of the total steps of computation. As IVC is a major application of folding schemes <em>[BCL^{+}21, x11, x12, x13]</em>, for completeness, we recall the formal definition below.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 23 (Incrementally verifiable computation (IVC))</h6>

    <p class="text-gray-300">An incrementally verifiable computation (IVC) scheme is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic <span class="math">\\mathcal{K}</span> denoting the generator, the prover, the verifier, and the encoder respectively, with the following interface</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},N)\\to\\mathsf{pp}</span>: on input security parameter <span class="math">\\lambda</span> and size bounds <span class="math">N</span>, samples public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\to(\\mathsf{pk},\\mathsf{vk})</span>: on input public parameters <span class="math">\\mathsf{pp}</span>, and polynomial-time function <span class="math">F</span>, deterministically produces a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{pk}, (i, z_0, z_i), \\omega_i, \\Pi_i) \\to \\Pi_{i+1}</span>: on input a prover key <span class="math">\\mathsf{pk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_0</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_i</span>, a non-deterministic advice <span class="math">\\omega_i</span>, and an IVC proof <span class="math">\\Pi_i</span> attesting to <span class="math">z_i</span>, produces a new proof <span class="math">\\Pi_{i+1}</span> attesting to <span class="math">z_{i+1} = F(z_i, \\omega_i)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathsf{vk}, (i, z_0, z_i), \\Pi_i) \\to \\{0, 1\\}</span>: on input a verifier key <span class="math">\\mathsf{vk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_0</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_i</span>, and an IVC proof <span class="math">\\Pi_i</span> attesting to <span class="math">z_i</span>, outputs 1 if <span class="math">\\Pi_i</span> is accepting, and 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">An IVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies the following requirements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: For any PPT adversary <span class="math">\\mathcal{A}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} (\\mathsf {v k}, (i + 1, z _ {0}, z _ {i + 1}), \\Pi_ {i + 1}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ F, (i, z _ {0}, z _ {i}, \\Pi_ {i}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F), \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}), \\\\ \\mathcal {V} (\\mathsf {v k}, i, z _ {0}, z _ {i}, \\Pi_ {i}) = 1, \\\\ \\Pi_ {i + 1} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\Pi_ {i}) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">F</span> is a polynomial-time computable function represented as an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: Consider constant <span class="math">n \\in \\mathbb{N}</span>. For all expected polynomial-time adversaries <span class="math">\\mathcal{P}^*</span> there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that over all randomness <span class="math">\\rho</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l l} z _ {n} = z \\text{ where} &amp; \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (F, (z _ {0}, z _ {i}), \\Pi) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}, \\rho), \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}) \\\\ \\forall i \\in \\{0, \\ldots , n - 1 \\} &amp; \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathcal {V} (\\mathsf {v k}, (n, z _ {0}, z), \\Pi) = 1, \\\\ (\\omega_ {0}, \\ldots , \\omega_ {n - 1}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\rho) \\end{array} \\right. \\end{array} \\right. \\end{array} \\right] \\approx 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Moreover, <span class="math">F</span> is a polynomial-time computable function represented as an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: The size of an IVC proof <span class="math">\\Pi</span> is independent of the number of iterations <span class="math">n</span>.</li>

    </ol>

    <h2 id="sec-58" class="text-2xl font-bold">B Deferred Proofs</h2>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">B.1 Proof of Theorem 2 (SumFold)</h3>

    <p class="text-gray-300"><strong>Lemma 16 (Completeness).</strong> Construction 1 is complete.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an arbitrary generator and encoder algorithm <span class="math">(\\mathcal{G},\\mathcal{K})</span>, and an arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. For an arbitrary size parameter <span class="math">N</span>, and a structure <span class="math">(F,G)</span>, let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(\\lambda,N)</span> and <span class="math">(\\mathsf{pk},\\mathsf{vk}) \\gets \\mathcal{K}(\\mathsf{pp},(F,G))</span>. Suppose now that the adversary <span class="math">\\mathcal{A}</span> on input <span class="math">\\mathsf{pp}</span> generates input instance-witness pairs</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left\\{\\left(T _ {i}, \\vec {u} _ {i}, \\mathbf {x} _ {i}\\right) \\right\\} _ {i \\in [ n ]}, \\left\\{\\vec {w} _ {i} \\right\\} _ {i \\in [ n ]}\\right) \\in \\mathbb {S C} ^ {n}. \\tag {11}</span></div>

    <p class="text-gray-300">The prover and the verifier on input <span class="math">(\\mathsf{pk},\\mathsf{vk}),\\{(T_i,\\vec{u}_i,\\mathsf{x}_i)\\}_{i\\in [n]},\\{\\vec{w}_i\\}_{i\\in [n]}</span> interactively produce the output instance-witness pairs</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(T ^ {\\prime}, \\vec {u}, \\mathrm {x}\\right), \\vec {w}\\right).</span></div>

    <p class="text-gray-300">We must show that <span class="math">((T&#x27;,\\vec{u},\\mathsf{x}),\\vec{w})\\in \\mathsf{SC}</span></p>

    <p class="text-gray-300">Indeed, by the linearity of the commitment scheme and by the satisfiability of the input instances, we have that for <span class="math">j \\in [s]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} u _ {j} = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} \\left(r _ {b}, i\\right) \\cdot u _ {i, j} \\\\ = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} \\left(r _ {b}, i\\right) \\cdot \\operatorname {C o m m i t} (\\mathrm {p p}, w _ {i, j}) \\tag {12} \\\\ = \\operatorname {C o m m i t} (\\mathsf {p p}, \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} (r _ {b}, i) \\cdot w _ {i, j}) \\\\ = \\operatorname {C o m m i t} (\\mathrm {p p}, w _ {j}). \\end{array}</span></div>

    <p class="text-gray-300">That is, we have that all output witnesses are satisfying openings to the output commitments.</p>

    <p class="text-gray-300">Moreover, given <span class="math">\\vec{g}_i\\gets G(\\vec{w}_i,\\mathsf{x}_i)</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} (\\rho , i) \\cdot T _ {i} \\quad \\text {By construction} \\\\ = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} (\\rho , i) \\cdot \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F (\\vec {g} _ {i} (x)) \\quad \\text {By Precondition} \\tag {11} \\\\ = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} \\operatorname {e q} (\\rho , i) \\cdot \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F (\\vec {f} (i, x)) \\quad \\text {By construction} \\\\ = \\sum_ {i \\in \\{0, 1 \\} ^ {\\nu}} Q (i) \\quad \\text {By construction} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by the completeness of the sum-check protocol, we have that</p>

    <div class="my-4 text-center"><span class="math-block">c = Q (r _ {b}).</span></div>

    <p class="text-gray-300">This means that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T ^ {\\prime} = \\operatorname {e q} (\\rho , r _ {b}) ^ {- 1} \\cdot c \\\\ = \\operatorname {e q} \\left(\\rho , r _ {b}\\right) ^ {- 1} \\cdot Q \\left(r _ {b}\\right) \\tag {13} \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F (\\vec {f} (r _ {b}, x)). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">But, by the linearity of <span class="math">G</span> (Definition 7), we have that</p>

    <p class="text-gray-300"><span class="math">G(\\vec{w},\\mathsf{x})</span> <span class="math">=G(\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(r_{b},i)\\cdot\\vec{w}_{i},\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(r_{b},i)\\cdot\\mathsf{x}_{i})</span> (14) <span class="math">=\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(r_{b},i)\\cdot G(\\vec{w}_{i},\\mathsf{x}_{i})</span> <span class="math">=\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(r_{b},i)\\cdot\\vec{g}_{i}</span> <span class="math">=\\vec{f}(r_{b},x).</span></p>

    <p class="text-gray-300">Thus, by derivations (12), (13), and (14), we have that <span class="math">((T^{\\prime},\\vec{u},\\mathsf{x}),\\vec{w})\\in\\mathsf{SC}</span>. ∎</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Lemma 17 (Knowledge soundness).</h6>

    <p class="text-gray-300">Construction 1 is knowledge sound (and in particular tree-extractable).</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct a PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> given a tree of accepting transcripts and the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Indeed, let <span class="math">\\chi_{\\mathsf{sc}}</span> denote the tree-extractor for the sum-check protocol which reduces from the unstructured sum-check relation <span class="math">\\mathsf{USC}</span> to the polynomial evaluation relation <span class="math">\\mathsf{PE}</span>. Suppose that <span class="math">\\chi_{\\mathsf{sc}}</span> can extract using an <span class="math">L</span>-tree of accepting transcripts where <span class="math">L\\in\\mathbb{N}^{\\nu}</span>. Then, we provide <span class="math">\\chi</span> with a <span class="math">(2^{\\nu},L)</span>-tree of accepting transcripts for public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},(F,G),\\{(T_{i},\\vec{u}_{i},\\mathsf{x}_{i})\\}_{i\\in[n]})</span>. For <span class="math">k\\in[2^{\\nu}]</span> and <span class="math">l\\in([L_{1}],\\ldots,[L_{\\nu}])</span>, let <span class="math">\\rho^{(k)}</span> denote the verifier’s first challenge, and for each such challenge let <span class="math">r_{b}^{(k,l)}</span> denote the verifier’s challenges during the sum-check protocol. Let</p>

    <p class="text-gray-300"><span class="math">((T^{\\prime(k,l)},\\vec{u}^{(k,l)},\\mathsf{x}^{(k,l)}),\\vec{w}^{(k,l)})\\in\\mathsf{SC}</span> (15)</p>

    <p class="text-gray-300">denote the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">For <span class="math">k\\in[2^{l}]</span>, the extractor <span class="math">\\chi</span> interpolates <span class="math">\\vec{w}_{i}^{(k)}</span> for <span class="math">i\\in[n]</span> such that for <span class="math">j\\in[s]</span></p>

    <p class="text-gray-300"><span class="math">w_{j}^{(k,l)}=\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(r_{b}^{(k,l)},i)\\cdot w_{i,j}^{(k)}.</span> (16)</p>

    <p class="text-gray-300">Now, by the satisfiability requirement of <span class="math">\\mathsf{SC}</span> (Precondition 15), we have that</p>

    <p class="text-gray-300"><span class="math">T^{\\prime(k,l)}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{l}}F(G(\\vec{w}^{(k,l)},\\mathsf{x}^{(k,l)})(x))</span> (17) <span class="math">u_{j}^{(k,l)}</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},w_{j}^{(k,l)})</span> (18)</p>

    <p class="text-gray-300">Moreover, by the verifier's computation we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} G(\\vec{w}^{(k,l)}, \\mathbf{x}^{(k,l)}) = G\\left(\\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot \\vec{w}_i^{(k)}, \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot \\mathbf{x}_i^{(k)}\\right) \\quad \\text{By (16)} \\\\ = \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot G(\\vec{w}_i^{(k)}, \\mathbf{x}_i^{(k)}) \\\\ = \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot \\vec{g}_{i,1}^{(k)} \\\\ = \\vec{f}^{(k)}(r_b^{(k,l)}) \\end{array}</span></div>

    <p class="text-gray-300">Then, by the verifier's computation in Step 3 and Equation (17), this means that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c^{(k,l)} = \\mathbf{eq}(\\rho^{(k)}, r_b^{(k,l)}) \\cdot T&#x27;^{(k,l)} \\\\ = \\mathbf{eq}(\\rho^{(k)}, r_b^{(k,l)}) \\cdot \\sum_{x \\in \\{0,1\\}^t} F(G(\\vec{w}^{(k,l)}, \\mathbf{x}^{(k,l)})(x)) \\tag{19} \\\\ = \\mathbf{eq}(\\rho^{(k)}, r_b^{(k,l)}) \\cdot \\sum_{x \\in \\{0,1\\}^t} F(\\vec{f}^{(k)}(r_b^{(k,l)}, x)) \\\\ = Q^{(k)}(r_b^{(k,l)}) \\end{array}</span></div>

    <p class="text-gray-300">Moreover, by the verifier's computation for <span class="math">i \\in [n]</span> and <span class="math">j \\in [s]</span>, we have that for all <span class="math">r_b^{(k,l)}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot u_{i,j}^{(k)} = u_j^{(k,l)} \\\\ = \\operatorname{Commit}(\\mathfrak{pp}, w_j^{(k,l)}) \\quad \\text{By (18)} \\\\ = \\operatorname{Commit}(\\mathfrak{pp}, \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot w_{i,j}^{(k)}) \\quad \\text{By (16)} \\\\ = \\sum_{i \\in \\{0,1\\}^{\\nu}} \\mathbf{eq}(r_b^{(k,l)}, i) \\cdot \\operatorname{Commit}(\\mathfrak{pp}, w_{i,j}^{(k)}) \\quad \\text{By linearity} \\end{array}</span></div>

    <p class="text-gray-300">Then, by interpolation, we have that for all <span class="math">i \\in [n]</span> and <span class="math">j \\in [s]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">u_{i,j}^{(k)} = \\operatorname{Commit}(\\mathfrak{pp}, w_{i,j}^{(k)}). \\tag{20}</span></div>

    <p class="text-gray-300">Then, by Derivation (19) and Equation (20), we have that for each challenge <span class="math">\\rho^{(k)}</span>, <span class="math">\\chi</span> can produce an <span class="math">L</span>-sub-tree of accepting transcripts for an input unstructured sum-check instance <span class="math">(T^{(k)}, \\overline{Q}^{(k)})</span> where <span class="math">\\overline{Q}^{(k)} = ((F, G), \\rho^{(k)}, (\\vec{u}_i, \\mathbf{x}_i)_{i \\in [n]})</span>, with output polynomial evaluation instance-witness pairs</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\overline{Q}^{(k)}, c^{(k,l)}, r_b^{(k,l)}\\right), Q^{(k)}\\right) \\in \\mathsf{PE}</span></div>

    <p class="text-gray-300">where <span class="math">Q^{(k)}</span> is represented as the tuple <span class="math">((F,G),\\rho^{(k)},(\\vec{w}^{(k)}_{i},\\mathsf{x}_{i})_{i\\in[n]})</span>.</p>

    <p class="text-gray-300">Now, for each challenge <span class="math">\\rho^{(k)}</span>, given the corresponding <span class="math">L</span>-sub-tree <span class="math">\\chi_{\\mathsf{sc}}</span> can produce a witness <span class="math">Q^{(k)}</span> represented as the tuple <span class="math">((F,G),\\rho^{(k)},(\\vec{w}^{(k)}_{i},\\mathsf{x}_{i})_{i\\in[n]})</span> such that</p>

    <p class="text-gray-300"><span class="math">((T^{(k)},\\overline{Q}^{(k)}),Q^{(k)})\\in\\mathsf{USC}.</span> (21)</p>

    <p class="text-gray-300">Then, because <span class="math">Q^{(k)}</span> must be a valid opening to <span class="math">\\overline{Q}^{(k)}</span> which contains the same commitment <span class="math">\\vec{u}_{i}</span> across all transcripts by Equation (21), we must have that <span class="math">\\vec{w}^{(k)}_{i}=\\vec{w}^{(k^{\\prime})}_{i}</span> for all <span class="math">k,k^{\\prime}\\in[2^{\\ell}]</span>. We denote this value across all transcripts simply as <span class="math">\\vec{w}_{i}</span>.</p>

    <p class="text-gray-300">By the satisfiability condition of <span class="math">\\mathsf{USC}</span> and the verifier’s computation, this means that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(\\rho^{(k)},i)\\cdot T_{i}</span> <span class="math">=T^{(k)}</span> <span class="math">=\\sum_{b\\in\\{0,1\\}^{\\nu}}Q^{(k)}(\\rho^{(k)})</span> <span class="math">=\\sum_{b\\in\\{0,1\\}^{\\nu}}\\mathsf{eq}(\\rho^{(k)},b)\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}F(\\vec{f}(b,x))</span></p>

    <p class="text-gray-300">Then, interpolating, we must have for <span class="math">i\\in\\{0,1\\}^{\\nu}</span></p>

    <p class="text-gray-300"><span class="math">T_{i}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}(\\vec{f}(i,x))</span> <span class="math">=F(\\vec{g}_{i}(x))</span> <span class="math">=F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))</span></p>

    <p class="text-gray-300">This means that</p>

    <p class="text-gray-300"><span class="math">(\\{(T_{i},\\vec{u}_{i},\\mathsf{x}_{i})\\}_{i\\in[n]},\\{\\vec{w}_{i}\\}_{i\\in[n]})\\in\\mathsf{SC}^{n}.</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\chi</span> can compute and output a satisfying input witness <span class="math">\\vec{w}_{i}</span> for <span class="math">i\\in[n]</span>. ∎</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">B.2 Proof of Lemma 5 (Zero-check reduction)</h3>

    <h6 id="sec-63" class="text-base font-medium mt-4">Lemma 18 (Completeness).</h6>

    <p class="text-gray-300">Construction 3 is complete.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an arbitrary generator and encoder algorithms <span class="math">(\\mathcal{G},\\mathcal{K})</span>, and an arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. For an arbitrary size parameter <span class="math">N</span>, let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,N)</span>. Suppose now that the adversary <span class="math">\\mathcal{A}</span> on input <span class="math">\\mathsf{pp}</span>, generates input structure-instance-witness pairs</p>

    <p class="text-gray-300"><span class="math">(F,G),(\\vec{u},\\vec{u}_{\\mathsf{pc}}),(\\vec{w},\\vec{w}_{\\mathsf{pc}})\\in\\mathsf{ZC}^{n}\\times\\mathsf{ZC}^{m}_{\\mathsf{PC}}.</span> (22)</p>

    <p class="text-gray-300">Suppose that for <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},(F,G))</span>, the prover and the verifier on input <span class="math">(\\mathsf{pk},\\mathsf{vk}),(\\vec{u},\\vec{u}_{\\mathsf{pc}}),(\\vec{w},\\vec{w}_{\\mathsf{pc}})</span> interactively produce the output instance-witness pairs</p>

    <p class="text-gray-300"><span class="math">(\\{(0,\\mathsf{u}_{i},\\overline{e})\\}_{i\\in[n]},\\{(\\mathsf{w}_{i},e)\\}_{i\\in[n]}),(\\{(0,\\mathsf{u}_{\\mathsf{pc},j},\\overline{e})\\}_{j\\in[m]},\\{(\\mathsf{w}_{\\mathsf{pc},j},e)\\}_{j\\in[m]}),((\\overline{e},\\tau),e).</span></p>

    <p class="text-gray-300">We must show that</p>

    <p class="text-gray-300"><span class="math">(\\{(0,\\mathsf{u}_{i},\\overline{e})\\}_{i\\in[n]},\\{(\\mathsf{w}_{i},e)\\}_{i\\in[n]})</span> <span class="math">\\in\\mathsf{NSC}^{n}</span> (23) <span class="math">(\\{(0,\\mathsf{u}_{\\mathsf{pc},j},\\overline{e})\\}_{j\\in[m]},\\{(\\mathsf{w}_{\\mathsf{pc},j},e)\\}_{j\\in[m]})</span> <span class="math">\\in\\mathsf{NSC}^{m}_{\\mathsf{PC}}</span> (24) <span class="math">((\\overline{e},\\tau),e)</span> <span class="math">\\in\\mathsf{ZC}_{\\mathsf{PC}}.</span> (25)</p>

    <p class="text-gray-300">Indeed, by the prover’s construction (Step 2), we immediately have that Equation 25 holds.</p>

    <p class="text-gray-300">Now, for each <span class="math">i\\in[n]</span>, we parse <span class="math">(\\vec{u}_{i},\\mathsf{x}_{i})\\leftarrow\\mathsf{u}_{i}</span>, and <span class="math">\\vec{w}_{i}\\leftarrow\\mathsf{w}_{i}</span>. By Precondition (22) we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},w_{i,j})=u_{i,j}.</span> (26)</p>

    <p class="text-gray-300">Moreover, by the precondition, we have that for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span></p>

    <p class="text-gray-300"><span class="math">0=F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x)).</span></p>

    <p class="text-gray-300">This means that for any choice of <span class="math">e</span></p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))</span> (27)</p>

    <p class="text-gray-300">where <span class="math">x_{1}</span> and <span class="math">x_{2}</span> (likewise <span class="math">e_{1}</span> and <span class="math">e_{2}</span>) represent the first and the second half of the original vector. Then, by Equations (26) and (27), we have that Equation (23) holds. By an identical line of reasoning, we have that Equation (24) holds as well. Thus, we have that completeness holds. ∎</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 19 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 3 is knowledge sound.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct a PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> given a tree of accepting transcripts and the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Indeed, suppose <span class="math">\\chi</span> is provided with a <span class="math">(2^{\\ell})</span>-tree of accepting transcripts for public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},(F,G),(\\{\\vec{u}_{i}\\}_{i\\in[n]},\\{\\vec{u}_{\\mathsf{pc},j}\\}_{j\\in[m]}))</span>. For <span class="math">k\\in[2^{\\ell}]</span>, let <span class="math">\\tau^{(k)}</span> denote the verifier challenge in each of these transcripts, and let</p>

    <p class="text-gray-300"><span class="math">(\\{(0,\\mathsf{u}^{(k)}_{i},\\overline{e}^{(k)})\\}_{i\\in[n]},\\{(\\mathsf{w}^{(k)}_{i},e^{(k)})\\}_{i\\in[n]})</span> <span class="math">\\in\\mathsf{NSC}^{n}</span> (28) <span class="math">(\\{(0,\\mathsf{u}^{(k)}_{\\mathsf{pc},j},\\overline{e}^{(k)})\\}_{j\\in[m]},\\{(\\mathsf{w}^{(k)}_{\\mathsf{pc},j},e^{(k)})\\}_{j\\in[m]})</span> <span class="math">\\in\\mathsf{NSC}^{m}_{\\mathsf{PC}}</span> (29) <span class="math">((\\overline{e}^{(k)},\\tau^{(k)}),e^{(k)})</span> <span class="math">\\in\\mathsf{ZC}_{\\mathsf{PC}}</span> (30)</p>

    <p class="text-gray-300">denote the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">By the verifier’s construction (Step 3) we have that <span class="math">\\mathsf{u}_{i}^{(k)}</span> is the same as the input instance <span class="math">\\mathsf{u}_{i}</span> for all <span class="math">k\\in[2^{\\ell}]</span>. Then, by the binding property of the commitment scheme, we have that <span class="math">\\mathsf{w}_{i}^{(k)}=\\mathsf{w}_{i}^{(k^{\\prime})}</span> for all <span class="math">k,k^{\\prime}\\in[2^{\\ell}]</span>. Thus, we denote this value as <span class="math">\\mathsf{w}_{i}</span>. Now, for each <span class="math">i\\in[n]</span>, we parse <span class="math">(\\vec{u}_{i},\\mathsf{x}_{i})\\leftarrow\\mathsf{u}_{i}</span>, and <span class="math">\\vec{w}_{i}\\leftarrow\\mathsf{w}_{i}</span>. By Equation (28), for each <span class="math">k\\in[2^{\\ell}]</span>, given</p>

    <p class="text-gray-300"><span class="math">\\vec{g}_{i}\\leftarrow G(\\vec{w}_{i},\\mathsf{x}_{i}),</span></p>

    <p class="text-gray-300">we have that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}^{(k)}(x_{1})\\cdot\\widetilde{e}_{2}^{(k)}(x_{2})\\cdot F(\\vec{g}_{i}(x)),</span></p>

    <p class="text-gray-300">where <span class="math">x_{1}</span> and <span class="math">x_{2}</span> (likewise <span class="math">e_{1}^{(k)}</span> and <span class="math">e_{2}^{(k)}</span>) represent the first and the second half of the original vector. But by Equation (30), we have that</p>

    <p class="text-gray-300"><span class="math">e_{1}</span> <span class="math">=((\\tau^{(k)})^{0},(\\tau^{(k)})^{1},(\\tau^{(k)})^{2},\\ldots,(\\tau^{(k)})^{\\sqrt{m}-1})</span> <span class="math">e_{2}</span> <span class="math">=((\\tau^{(k)})^{0},(\\tau^{(k)})^{\\sqrt{m}},(\\tau^{(k)})^{2\\sqrt{m}},\\ldots,(\\tau^{(k)})^{(\\sqrt{m}-1)\\cdot\\sqrt{m}}).</span></p>

    <p class="text-gray-300">Substituting, we have that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\ell}}(\\tau^{(k)})^{X_{1}+\\sqrt{m}\\cdot X_{2}}\\cdot F(\\vec{g}_{i}(x)),</span></p>

    <p class="text-gray-300">where <span class="math">X_{i}=\\sum_{j\\in[\\ell/2]}x_{i,j}\\cdot 2^{\\ell/2-j}</span> (i.e. the corresponding decimal representation if <span class="math">x_{i}</span> is treated as the bit representation). Then, by interpolation, we have that the Lagrange polynomial</p>

    <p class="text-gray-300"><span class="math">Q(Y)=\\sum_{x\\in\\{0,1\\}^{\\ell}}Y^{X_{1}+\\sqrt{m}\\cdot X_{2}}\\cdot F(\\vec{g}_{i}(x))</span></p>

    <p class="text-gray-300">is the zero polynomial. This means that</p>

    <p class="text-gray-300"><span class="math">0=F(\\vec{g}_{i}(x))</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>. Hence, we have that</p>

    <p class="text-gray-300"><span class="math">(\\vec{u},\\vec{w})\\in\\mathsf{ZC}^{n}.</span></p>

    <p class="text-gray-300">Then, <span class="math">\\chi</span> can produce <span class="math">\\vec{w}_{i}</span> for all <span class="math">i\\in[n]</span> by reading the output witness from any one of the transcripts. By an identical line of reasoning <span class="math">\\chi</span> can produce <span class="math">\\vec{w}_{\\mathsf{pc}}</span> such that</p>

    <p class="text-gray-300"><span class="math">(\\vec{u}_{\\mathsf{pc}},\\vec{w}_{\\mathsf{pc}})\\in\\mathsf{ZC}^{m}_{\\mathsf{PC}}.</span></p>

    <p class="text-gray-300">Thus, we have that tree-extractability holds.</p>

    <p class="text-gray-300">B.3 Proof of Lemma 6 (Folding nested sum-check)</p>

    <p class="text-gray-300">Lemma 20 (Completeness). Construction 4 is complete.</p>

    <p class="text-gray-300">Proof. Consider an arbitrary generator and encoder algorithm <span class="math">(\\mathcal{G},\\mathcal{K})</span>, and an arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. For an arbitrary size parameter <span class="math">N</span>, let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(\\lambda, N)</span>. Suppose now that the adversary <span class="math">\\mathcal{A}</span> on input <span class="math">\\mathsf{pp}</span> generates a structure <span class="math">(F, G)</span>, and input instance-witness pairs</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left(\\left(T _ {i}, \\mathrm {u} _ {i}, \\mathrm {x} _ {i}\\right), \\left(T _ {\\mathrm {p c}, i}, \\mathrm {u} _ {\\mathrm {p c}, i}, \\mathrm {x} _ {\\mathrm {p c}, i}\\right)\\right) \\right\\} _ {i \\in [ n ]}, \\left\\{\\left(\\mathrm {w} _ {i}, \\mathrm {w} _ {\\mathrm {p c}, i}\\right) \\right\\} _ {i \\in [ n ]} \\in \\mathsf {N S C} ^ {n} \\times \\mathsf {N S C} _ {\\mathsf {P C}} ^ {n}. \\tag {31}</span></div>

    <p class="text-gray-300">Suppose for <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},(F,G))</span>, the prover and the verifier on input <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> and this instance-witness pair interactively produce the output instance-witness pair</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\left(T, \\mathrm {u}, \\mathrm {x}\\right), \\left(T _ {\\mathrm {p c}}, \\mathrm {u} _ {\\mathrm {p c}}, \\mathrm {x} _ {\\mathrm {p c}}\\right)\\right), \\left(\\mathrm {w}, \\mathrm {w} _ {\\mathrm {p c}}\\right)\\right).</span></div>

    <p class="text-gray-300">We must show that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\left(T, \\mathrm {u}, \\mathrm {x}\\right), \\mathrm {w}\\right) \\in \\mathsf {N S C} \\\\ \\left(\\left(T _ {\\mathrm {p c}}, \\mathrm {u} _ {\\mathrm {p c}}, \\mathrm {x} _ {\\mathrm {p c}}\\right), \\mathrm {w} _ {\\mathrm {p c}}\\right) \\in \\mathsf {N S C} _ {\\mathsf {P C}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Indeed, for each <span class="math">i \\in [n]</span>, we parse <span class="math">(\\vec{w}_i, e_i) \\gets \\mathsf{w}_i</span> and <span class="math">(\\vec{w}_{\\mathsf{pc},i}, e_{\\mathsf{pc},i}) \\gets \\mathsf{w}_{\\mathsf{pc},i}</span>. Then, for <span class="math">\\vec{g}_i \\gets G(\\vec{w}_i, \\mathsf{x}_i)</span> and <span class="math">\\vec{g}_{\\mathsf{pc},i} \\gets G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc},i}, \\mathsf{x}_{\\mathsf{pc},i})</span>, by Precondition 31, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T _ {i} + \\gamma \\cdot T _ {\\mathrm {p c}, i} \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\widetilde {e} _ {i, 1} (x _ {1}) \\cdot \\widetilde {e} _ {i, 2} (x _ {2}) \\cdot F (\\vec {g} _ {i} (x)) + \\gamma \\cdot \\widetilde {e} _ {\\mathrm {p c}, i, 1} (x _ {1}) \\cdot \\widetilde {e} _ {\\mathrm {p c}, i, 2} (x _ {2}) \\cdot F _ {\\mathrm {P C}} (\\vec {g} _ {\\mathrm {p c}, i} (x)) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} h _ {1, i} (x) \\cdot h _ {2, i} (x) \\cdot F (\\vec {g} _ {i} (x)) + \\gamma \\cdot h _ {\\mathrm {p c}, 1, i} (x) \\cdot h _ {\\mathrm {p c}, 2, i} (x) \\cdot F _ {\\mathrm {P C}} (\\vec {g} _ {\\mathrm {p c}, i} (x)) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F ^ {\\prime} (\\vec {g} _ {i} (x), h _ {1, i} (x), h _ {2, i} (x), \\vec {g} _ {\\mathrm {p c}, i}, h _ {\\mathrm {p c}, 1, i} (x), h _ {\\mathrm {p c}, 2, i} (x)) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F ^ {\\prime} \\left(G ^ {\\prime} \\left(\\vec {w} _ {i}, e _ {i}, \\vec {w} _ {\\mathrm {p c}, i}, e _ {\\mathrm {p c}, i}, \\left(\\mathrm {x} _ {i}, \\mathrm {x} _ {\\mathrm {p c}, i}\\right)\\right) (x)\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">h_{1,i}, h_{2,i}, h_{\\mathsf{pc},1,i}</span>, and <span class="math">h_{\\mathsf{pc},2,i}</span> are defined as in the construction. This implies that the completeness precondition holds for the sum-check folding reduction. That is, for <span class="math">i \\in [n]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p p}, \\left(F ^ {\\prime}, G ^ {\\prime}\\right), \\left(T _ {i} + \\gamma \\cdot T _ {\\mathsf {p c}, i}, \\left(\\mathsf {u} _ {i}, \\mathsf {u} _ {\\mathsf {p c}, i}\\right), \\left(\\mathsf {x} _ {i}, \\mathsf {x} _ {\\mathsf {p c}, i}\\right)\\right), \\left(\\mathsf {w} _ {i}, \\mathsf {w} _ {\\mathsf {p c}, i}\\right)\\right) \\in \\mathsf {S C}.</span></div>

    <p class="text-gray-300">Then, by the completeness of the sum-check folding reduction, we have that the instance-witness pair output from the folding sum-check reduction is satisfying. That is</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p p}, \\left(F ^ {\\prime}, G ^ {\\prime}\\right), \\left(T _ {\\gamma}, \\left(\\mathrm {u}, \\mathrm {u} _ {\\mathrm {p c}}\\right), \\left(\\mathrm {x}, \\mathrm {x} _ {\\mathrm {p c}}\\right)\\right), \\left(\\mathrm {w}, \\mathrm {w} _ {\\mathrm {p c}}\\right)\\right) \\in \\mathsf {S C}. \\tag {32}</span></div>

    <p class="text-gray-300">This implies that given <span class="math">(\\vec{w},e)\\leftarrow\\mathsf{w}</span>, <span class="math">(\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}})\\leftarrow\\mathsf{w}_{\\mathsf{pc}}</span>, <span class="math">\\vec{g}\\leftarrow G(\\vec{w},e)</span>, and <span class="math">\\vec{g}_{\\mathsf{pc}}\\leftarrow G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}})</span> we have that</p>

    <p class="text-gray-300"><span class="math">T_{\\gamma}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}(G^{\\prime}(\\vec{w},e,\\vec{w}_{\\mathsf{pc}},e_{\\mathsf{pc}},(\\mathsf{x},\\mathsf{x}_{\\mathsf{pc}}))(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}h_{1}(x)\\cdot h_{2}(x)\\cdot F(\\vec{g}(x))+\\gamma\\cdot h_{\\mathsf{pc},1}(x)\\cdot h_{\\mathsf{pc},2}(x)\\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}}(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(\\vec{g}(x))+\\gamma\\cdot\\widetilde{e}_{\\mathsf{pc},1}(x_{1})\\cdot\\widetilde{e}_{\\mathsf{pc},2}(x)\\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}}(x))</span> <span class="math">=T+\\gamma\\cdot T_{\\mathsf{pc}}.</span></p>

    <p class="text-gray-300">Therefore, we have that the verifier’s check in Step 5 passes.</p>

    <p class="text-gray-300">Moreover, by the prover’s computation, we have that</p>

    <p class="text-gray-300"><span class="math">T</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1}(x_{1})\\cdot\\widetilde{e}_{2}(x_{2})\\cdot F(\\vec{g}(x))</span> <span class="math">T_{\\mathsf{pc}}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{\\mathsf{pc},1}(x_{1})\\cdot\\widetilde{e}_{\\mathsf{pc},2}(x)\\cdot F_{\\mathsf{PC}}(\\vec{g}_{\\mathsf{pc}}(x))</span></p>

    <p class="text-gray-300">Then, by the validity of the commitments implied by Equation 32, we have that</p>

    <p class="text-gray-300"><span class="math">((T,(\\mathsf{u},\\mathsf{x})),\\mathsf{w})</span> <span class="math">\\in\\mathsf{NSC}</span> <span class="math">((T_{\\mathsf{pc}},(\\mathsf{u}_{\\mathsf{pc}},\\mathsf{x}_{\\mathsf{pc}})),\\mathsf{w}_{\\mathsf{pc}})</span> <span class="math">\\in\\mathsf{NSC}_{\\mathsf{PC}}.</span></p>

    <p class="text-gray-300">Therefore, completeness holds. ∎</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 21 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 4 is knowledge sound.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct a PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> given a tree of accepting transcripts and the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Indeed, let <span class="math">\\chi_{\\mathsf{FSC}}</span> denote the tree-extractor for the sum-check folding reduction, which reduces from <span class="math">\\mathsf{SC}^{n}</span> to <span class="math">\\mathsf{SC}</span> in Step 3. Suppose that <span class="math">\\chi_{\\mathsf{FSC}}</span> can extract using an <span class="math">L</span>-tree of accepting transcripts where <span class="math">L\\in\\mathbb{N}^{\\nu+1}</span>. Then, we provide <span class="math">\\chi</span> with a <span class="math">(2,L)</span>-tree of accepting transcripts for public parameter, structure, instance tuple</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},(F,G),\\{((T_{i},\\mathsf{u}_{i},\\mathsf{x}_{i}),(T_{\\mathsf{pc},i},\\mathsf{u}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i}))\\}_{i\\in[n]}).</span></p>

    <p class="text-gray-300">For <span class="math">k\\in[2]</span> and <span class="math">l\\in([L_{1}],\\ldots,[L_{\\nu+1}])</span>, let <span class="math">\\gamma^{(k)}</span> denote the verifier’s first challenge, and for each such challenge let <span class="math">r^{(k,l)}</span> denote the verifier’s challenges during the sum-check folding reduction. Let</p>

    <p class="text-gray-300"><span class="math">((T^{(k,l)},\\mathsf{u}^{(k,l)},\\mathsf{x}^{(k,l)}),\\mathsf{w}^{(k,l)})</span> <span class="math">\\in\\mathsf{NSC}</span> <span class="math">((T_{\\mathsf{pc}}^{(k,l)},\\mathsf{u}_{\\mathsf{pc}}^{(k,l)},\\mathsf{x}_{\\mathsf{pc}}^{(k,l)}),\\mathsf{w}_{\\mathsf{pc}}^{(k,l)})</span> <span class="math">\\in\\mathsf{NSC}_{\\mathsf{PC}}</span></p>

    <p class="text-gray-300">denote the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Now, by the satisfiability condition of NSC and <span class="math">\\mathsf{NSC}_{\\mathsf{PC}}</span> for</p>

    <div class="my-4 text-center"><span class="math-block">(\\vec {u} ^ {(k, l)}, \\overline {{e}} ^ {(k, l)}) \\leftarrow u ^ {(k, l)}</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\vec {u} _ {\\mathsf {p c}} ^ {(k, l)}, \\overline {{e}} _ {\\mathsf {p c}} ^ {(k, l)}) \\leftarrow u _ {\\mathsf {p c}} ^ {(k, l)}</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\vec {w} ^ {(k, l)}, e ^ {(k, l)}) \\leftarrow w ^ {(k, l)}</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\vec {w} _ {\\mathsf {p c}} ^ {(k, l)}, e _ {\\mathsf {p c}} ^ {(k, l)}) \\leftarrow \\mathsf {w} _ {\\mathsf {p c}} ^ {(k, l)},</span></div>

    <p class="text-gray-300">we have that</p>

    <div class="my-4 text-center"><span class="math-block">T ^ {(k, l)} = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\widetilde {e} _ {1} ^ {(k, l)} (x _ {1}) \\cdot \\widetilde {e} _ {2} ^ {(k, l)} (x _ {2}) \\cdot F (G (\\vec {w} ^ {(k, l)}, \\mathsf {x} ^ {(k, l)}) (x))</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {\\mathsf {p c}} ^ {(k, l)} = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\widetilde {e} _ {\\mathsf {p c}, 1} ^ {(k, l)} (x _ {1}) \\cdot \\widetilde {e} _ {\\mathsf {p c}, 2} ^ {(k, l)} (x _ {2}) \\cdot F _ {\\mathsf {P C}} (G _ {\\mathsf {P C}} (\\vec {w} _ {\\mathsf {p c}} ^ {(k, l)}, \\mathsf {x} _ {\\mathsf {p c}} ^ {(k, l)}) (x))</span></div>

    <p class="text-gray-300">and that</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {e} ^ {(k, l)} = \\operatorname {C o m m i t} (\\mathrm {p p}, e ^ {(k, l)}) \\tag {33}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bar {e} _ {\\mathrm {p c}} ^ {(k, l)} = \\operatorname {C o m m i t} (\\mathrm {p p}, e _ {\\mathrm {p c}} ^ {(k, l)}) \\tag {34}</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {j} ^ {(k, l)} = \\operatorname {C o m m i t} (\\mathrm {p p}, w _ {j} ^ {(k, l)}) \\tag {35}</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {\\mathrm {p c}, j} ^ {(k, l)} = \\operatorname {C o m m i t} (\\mathrm {p p}, w _ {\\mathrm {p c}, j} ^ {(k, l)}) \\tag {36}</span></div>

    <p class="text-gray-300">for <span class="math">j\\in [s]</span>.</p>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">Then, by the verifier's check in Step 5, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T _ {\\gamma} ^ {(k, l)} = T ^ {(k, l)} + \\gamma^ {(k, l)} \\cdot T _ {\\mathrm {p c}} ^ {(k, l)} \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\widetilde {e} _ {1} ^ {(k, l)} \\left(x _ {1}\\right) \\cdot \\widetilde {e} _ {2} ^ {(k, l)} \\left(x _ {2}\\right) \\cdot F \\left(G \\left(\\vec {w} ^ {(k, l)}, \\mathrm {x} ^ {(k, l)}\\right) (x)\\right) + \\\\ \\quad \\gamma^ {(k, l)} \\cdot \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\widetilde {e} _ {\\mathrm {p c}, 1} ^ {(k, l)} (x _ {1}) \\cdot \\widetilde {e} _ {\\mathrm {p c}, 2} ^ {(k, l)} (x _ {2}) \\cdot F _ {\\mathrm {P C}} (G _ {\\mathrm {P C}} (\\vec {w} _ {\\mathrm {p c}} ^ {(k, l)}, \\mathrm {x} _ {\\mathrm {p c}} ^ {(k, l)}) (x)) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} h _ {1} ^ {(k, l)} (x) \\cdot h _ {2} ^ {(k, l)} (x) \\cdot F (G (\\vec {w} ^ {(k, l)}, \\mathrm {x} ^ {(k, l)}) (x)) + \\\\ \\quad \\gamma^ {(k, l)} \\cdot \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} h _ {\\mathrm {p c}, 1} ^ {(k, l)} (x) \\cdot h _ {\\mathrm {p c}, 2} ^ {(k, l)} (x) \\cdot F _ {\\mathrm {P C}} (G _ {\\mathrm {P C}} (\\vec {w} _ {\\mathrm {p c}} ^ {(k, l)}, \\mathrm {x} _ {\\mathrm {p c}} ^ {(k, l)}) (x)) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F ^ {\\prime} \\left(\\left(G \\left(\\vec {w} ^ {(k, l)}, x ^ {(k, l)}\\right), h _ {1} ^ {(k, l)}, h _ {2} ^ {(k, l)}, G _ {P C} \\left(\\vec {w} _ {p c} ^ {(k, l)}, x _ {p c} ^ {(k, l)}\\right), h _ {p c, 1} ^ {(k, l)}, h _ {p c, 2} ^ {(k, l)}\\right) (x)\\right) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F ^ {\\prime} \\left(G ^ {\\prime} \\left(\\vec {w} ^ {(k, l)}, e ^ {(k, l)}, \\vec {w} _ {\\mathrm {p c}} ^ {(k, l)}, e _ {\\mathrm {p c}} ^ {(k, l)}, \\left(\\mathrm {x} ^ {(k, l)}, \\mathrm {x} _ {\\mathrm {p c}} ^ {(k, l)}\\right)\\right) (x)\\right) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} F ^ {\\prime} \\left(G ^ {\\prime} \\left(\\left(\\mathrm {w} ^ {(k, l)}, \\mathrm {w} _ {\\mathrm {p c}} ^ {(k, l)}\\right), \\left(\\mathrm {x} ^ {(k, l)}, \\mathrm {x} _ {\\mathrm {p c}} ^ {(k, l)}\\right)\\right) (x)\\right) \\tag {37} \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by Derivation (37), and Equations (33), (34), (35), and (36) we have that</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathfrak {p p}, (F ^ {\\prime}, G ^ {\\prime}), (T _ {\\gamma} ^ {(k, l)}, (\\mathfrak {u} ^ {(k, l)}, \\mathfrak {u} _ {\\mathrm {p c}} ^ {(k, l)}), (\\mathfrak {x} ^ {(k, l)}, \\mathfrak {x} _ {\\mathrm {p c}} ^ {(k, l)})), (\\mathfrak {w} ^ {(k, l)}, \\mathfrak {w} _ {\\mathrm {p c}} ^ {(k, l)})) \\in \\mathsf {S C}.</span></div>

    <p class="text-gray-300">This means that for each challenge  <span class="math">\\gamma^{(k)}</span> , and the corresponding input instance to the sum-check folding reduction</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathfrak {p p}, (F ^ {\\prime}, G ^ {\\prime}), \\{(T _ {i} ^ {(k)} + \\gamma^ {(k)} \\cdot T _ {\\mathrm {p c}, i} ^ {(k)}, (\\mathfrak {u} _ {i} ^ {(k)}, \\mathfrak {u} _ {\\mathrm {p c}, i} ^ {(k)}), (\\mathfrak {x} _ {i} ^ {(k)}, \\mathfrak {x} _ {\\mathrm {p c}, i} ^ {(k)})) \\} _ {i \\in [ n ]}),</span></div>

    <p class="text-gray-300"><span class="math">\\chi</span>  can produce a satisfying  <span class="math">L</span> -sub-tree of transcripts for the sum-check folding reduction with satisfying output instance-witness pairs in SC. Then,  <span class="math">\\chi</span>  can run  <span class="math">\\chi_{\\mathsf{FSC}}</span>  on each of these sub-trees to retrieve a corresponding satisfying input witness  <span class="math">\\{(\\mathsf{w}_i^{(k)},\\mathsf{w}_{\\mathsf{pc},i}^{(k)})\\}_{i\\in [n]}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left\\{\\left(T _ {i} ^ {(k)} + \\gamma^ {(k)} \\cdot T _ {\\mathrm {p c}, i} ^ {(k)}, \\left(\\mathfrak {u} _ {i} ^ {(k)}, \\mathfrak {u} _ {\\mathrm {p c}, i} ^ {(k)}\\right), \\left(\\mathfrak {x} _ {i} ^ {(k)}, \\mathfrak {x} _ {\\mathrm {p c}, i} ^ {(k)}\\right)\\right) \\right\\} _ {i \\in [ n ]}, \\left\\{\\left(\\mathsf {w} _ {i} ^ {(k)}, \\mathsf {w} _ {\\mathrm {p c}, i} ^ {(k)}\\right) \\right\\} _ {i \\in [ n ]}\\right) \\in \\mathsf {S C} ^ {n}</span></div>

    <p class="text-gray-300">with respect to structure  <span class="math">(F&#x27;, G&#x27;)</span> .</p>

    <p class="text-gray-300">By the verifier's construction, we have that for all  <span class="math">i \\in [n]</span> ,  <span class="math">T_i^{(k)} = T_i</span> ,  <span class="math">T_{\\mathsf{pc},i}^{(k)} = T_{\\mathsf{pc},i}</span> ,  <span class="math">\\mathsf{x}_i^{(k)} = \\mathsf{x}_i</span> ,  <span class="math">\\mathsf{x}_{\\mathsf{pc},i}^{(k)} = \\mathsf{x}_{\\mathsf{pc},i}</span> ,  <span class="math">\\mathsf{u}_i^{(k)} = \\mathsf{u}_i</span> , and  <span class="math">\\mathsf{u}_{\\mathsf{pc},i}^{(k)} = \\mathsf{u}_{\\mathsf{pc},i}</span> . Then, by the binding property of the commitment scheme, for all  <span class="math">i \\in [n]</span>  we must have that for any  <span class="math">k, k&#x27; \\in [2]</span> <span class="math">\\mathsf{w}_i^{(k)} = \\mathsf{w}_i^{(k&#x27;)}</span>  and  <span class="math">\\mathsf{w}_{\\mathsf{pc},i}^{(k)} = \\mathsf{w}_{\\mathsf{pc},i}^{(k&#x27;)}</span> . We denote these values simply as  <span class="math">\\mathsf{w}_i</span>  and  <span class="math">\\mathsf{w}_{\\mathsf{pc},i}</span> .</p>

    <p class="text-gray-300">Then, for</p>

    <p class="text-gray-300"><span class="math">(\\vec{w}_{i},e_{i})\\leftarrow\\mathsf{w}_{i}</span> <span class="math">(\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i})\\leftarrow\\mathsf{w}_{\\mathsf{pc},i},</span></p>

    <p class="text-gray-300">by the satisfiability condition of <span class="math">\\mathsf{SC}</span> we have that</p>

    <p class="text-gray-300"><span class="math">T_{i}+\\gamma^{(k)}\\cdot T_{\\mathsf{pc},i}</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}(G^{\\prime}((\\mathsf{w}_{i},\\mathsf{w}_{\\mathsf{pc},i}),(\\mathsf{x}_{i},\\mathsf{x}_{\\mathsf{pc},i}))(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}(G^{\\prime}((\\vec{w}_{i},e_{i},\\vec{w}_{\\mathsf{pc},i},e_{\\mathsf{pc},i}),(\\mathsf{x}_{i},\\mathsf{x}_{\\mathsf{pc},i}))(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}F^{\\prime}((G(\\vec{w}_{i},\\mathsf{x}_{i}),h_{1,i},h_{2,i},G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i}),h_{\\mathsf{pc},1,i},h_{\\mathsf{pc},2,i})(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}h_{1,i}(x)\\cdot h_{2,i}(x)\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))+</span> <span class="math">\\gamma^{(k)}\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}h_{\\mathsf{pc},1,i}(x)\\cdot h_{\\mathsf{pc},2,i}(x)\\cdot F_{\\mathsf{PC}}(G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i})(x))</span> <span class="math">=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1,i}(x_{1})\\cdot\\widetilde{e}_{2,i}(x_{2})\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))+</span> <span class="math">\\gamma^{(k)}\\cdot\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{\\mathsf{pc},1,i}(x_{1})\\cdot\\widetilde{e}_{\\mathsf{pc},2,i}(x_{2})\\cdot F_{\\mathsf{PC}}(G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i})(x)).</span></p>

    <p class="text-gray-300">Then, by interpolation, we have that</p>

    <p class="text-gray-300"><span class="math">T_{i}=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{1,i}(x_{1})\\cdot\\widetilde{e}_{2,i}(x_{2})\\cdot F(G(\\vec{w}_{i},\\mathsf{x}_{i})(x))</span> <span class="math">T_{\\mathsf{pc},i}=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{e}_{\\mathsf{pc},1,i}(x_{1})\\cdot\\widetilde{e}_{\\mathsf{pc},2,i}(x_{2})\\cdot F_{\\mathsf{PC}}(G_{\\mathsf{PC}}(\\vec{w}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i})(x)).</span></p>

    <p class="text-gray-300">This means that for <span class="math">i\\in[n]</span></p>

    <p class="text-gray-300"><span class="math">((T_{i},\\mathsf{u}_{i},\\mathsf{x}_{i}),\\mathsf{w}_{i})\\in\\mathsf{NSC}</span> <span class="math">((T_{\\mathsf{pc},i},\\mathsf{u}_{\\mathsf{pc},i},\\mathsf{x}_{\\mathsf{pc},i}),\\mathsf{w}_{\\mathsf{pc},i})\\in\\mathsf{NSC}_{\\mathsf{PC}}.</span></p>

    <p class="text-gray-300">Therefore, <span class="math">\\chi</span> can compute a satisfying input witness <span class="math">(\\mathsf{w}_{i},\\mathsf{w}_{\\mathsf{pc},i})</span> for <span class="math">i\\in[n]</span>. ∎</p>

    <h3 id="sec-69" class="text-xl font-semibold mt-8">B.4 Proof of Lemma 11 (From lookup to grand-product)</h3>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 22 (Completeness)</h6>

    <p class="text-gray-300">Construction 6 is complete.</p>

    <p class="text-gray-300">Proof. Consider an arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. For arbitrary size parameters <span class="math">(n,m)</span>, let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(\\lambda, (n,m))</span>, and <span class="math">\\mathsf{pk}, \\mathsf{vk} \\gets \\mathcal{K}(\\mathsf{pp})</span>. Suppose now that the adversary on input <span class="math">\\mathsf{pp}</span> generates</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\bar {t}, \\bar {a}, \\bar {v}\\right), (t, a, v)\\right) \\in \\mathsf {L K P}.</span></div>

    <p class="text-gray-300">The prover and verifier on input <span class="math">(\\mathsf{pk},\\mathsf{vk}),(\\bar{t},\\bar{a},\\bar{v}),(t,a,v)</span> interactively produce output instance-witness pairs</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\left(\\left(p _ {k}, \\bar {v} _ {k}\\right), v _ {k}\\right) \\right\\} _ {k \\in [ 4 ]}</span></div>

    <p class="text-gray-300">We must show that <span class="math">\\left\\{\\left(\\left(p_{k},\\overline{v}_{k}\\right),v_{k}\\right)\\right\\}_{k\\in [4]}\\in \\mathsf{GP}^{4}</span>.</p>

    <p class="text-gray-300">Indeed, by the linearity of the commitment scheme and by definitions of <span class="math">G_{n} = \\mathsf{Commit}(\\mathsf{pp},1^{n})</span>, <span class="math">G_{m} = \\mathsf{Commit}(\\mathsf{pp},1^{m})</span>, and <span class="math">H = \\mathsf{Commit}(\\mathsf{pp},(1,\\ldots ,n))</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {v} _ {k} = \\operatorname {C o m m i t} (\\mathrm {p p}, v _ {k}) \\tag {38}</span></div>

    <p class="text-gray-300">for <span class="math">k\\in [4]</span>.</p>

    <p class="text-gray-300">Next, by the prover's computation of <span class="math">f</span> and <span class="math">c</span> and by Lemma 10, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\prod_ {i \\in [ n ]} (i + t _ {i} \\cdot X - Y)\\right) \\cdot \\left(\\prod_ {i \\in [ m ]} (a _ {i} + v _ {i} \\cdot X + (c _ {i} + 1) \\cdot X ^ {2} - Y)\\right) = \\\\ \\left(\\prod_ {i \\in [ m ]} \\left(a _ {i} + v _ {i} \\cdot X + c _ {i} \\cdot X ^ {2} - Y\\right)\\right) \\cdot \\left(\\prod_ {i \\in [ n ]} \\left(i + t _ {i} \\cdot X + f _ {i} \\cdot X ^ {2} - Y\\right)\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">But, this means that for an arbitrary <span class="math">r_X,r_Y\\in \\mathbb{F}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\prod_ {i \\in [ n ]} (i + t _ {i} \\cdot r _ {X} - r _ {Y})\\right) \\cdot \\left(\\prod_ {i \\in [ m ]} (a _ {i} + v _ {i} \\cdot r _ {X} + (c _ {i} + 1) \\cdot r _ {X} ^ {2} - Y)\\right) = \\\\ \\left(\\prod_ {i \\in [ m ]} \\left(a _ {i} + v _ {i} \\cdot r _ {X} + c _ {i} \\cdot r _ {X} ^ {2} - r _ {Y}\\right)\\right) \\cdot \\left(\\prod_ {i \\in [ n ]} \\left(i + t _ {i} \\cdot r _ {X} + f _ {i} \\cdot r _ {X} ^ {2} - r _ {Y}\\right)\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Then, by the definition of <span class="math">v_{1}, \\ldots, v_{4}</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i \\in [ n ]} v _ {1, i} \\cdot \\prod_ {i \\in [ m ]} v _ {2, i} = \\prod_ {i \\in [ m ]} v _ {3, i} \\cdot \\prod_ {i \\in [ n ]} v _ {4, i}.</span></div>

    <p class="text-gray-300">Hence, by construction, we have that</p>

    <div class="my-4 text-center"><span class="math-block">p _ {k} = \\prod_ {i} v _ {k, i} \\tag {39}</span></div>

    <p class="text-gray-300">for <span class="math">k\\in[4]</span>, by substitution, we have that</p>

    <p class="text-gray-300"><span class="math">p_{1}\\cdot p_{2}=p_{3}\\cdot p_{4}.</span></p>

    <p class="text-gray-300">Therefore, we have that the verifier’s check in Step 5 passes.</p>

    <p class="text-gray-300">Then, by Equations 38 and 39, we have that <span class="math">\\{((p_{k},\\overline{v}_{k}),v_{k})\\}_{k\\in[4]}\\in\\mathsf{GP}^{4}</span>. ∎</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 23 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 6 is knowledge sound.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct a PPT extractor <span class="math">\\chi</span> that outputs a satisfying input witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> given a tree of accepting transcripts and the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Indeed, for a sufficiently large <span class="math">N=O(nm)</span> we provide <span class="math">\\chi</span> with an <span class="math">N</span>-tree of accepting transcripts for the public parameter, instance tuple <span class="math">(\\mathsf{pp},(\\overline{t},\\overline{a},\\overline{v}))</span>. For <span class="math">l\\in[N]</span>, let <span class="math">r_{X}^{(l)}</span> and <span class="math">r_{Y}^{(l)}</span> denote the verifier’s challenges in Step 2. Let</p>

    <p class="text-gray-300"><span class="math">\\{((p_{k}^{(l)},\\overline{v}_{k}^{(l)}),v_{k}^{(l)})\\}_{k\\in[4]}\\in\\mathsf{GP}^{4}</span> (40)</p>

    <p class="text-gray-300">denote the corresponding output instance-witness pairs.</p>

    <p class="text-gray-300">Using an arbitrary but sufficiently large subsets of transcripts, the extractor <span class="math">\\chi</span> interpolates <span class="math">t</span> such that for <span class="math">i\\in[n]</span></p>

    <p class="text-gray-300"><span class="math">v_{1,i}^{(l)}=i+t_{i}\\cdot r_{X}^{(l)}-r_{Y}^{(l)},</span> (41)</p>

    <p class="text-gray-300">interpolates <span class="math">a</span>, <span class="math">v</span>, and <span class="math">c</span> such that for <span class="math">i\\in[m]</span></p>

    <p class="text-gray-300"><span class="math">v_{2,i}^{(l)}=a_{i}+v_{i}\\cdot r_{X}^{(l)}+(c_{i}+1)\\cdot{r_{X}^{(l)}}^{2}-r_{Y}^{(l)},</span> (42)</p>

    <p class="text-gray-300">interpolates <span class="math">a^{\\prime}</span>, <span class="math">v^{\\prime}</span>, and <span class="math">c^{\\prime}</span> such that for <span class="math">i\\in[m]</span></p>

    <p class="text-gray-300"><span class="math">v_{3,i}^{(l)}=a_{i}^{\\prime}+v_{i}^{\\prime}\\cdot r_{X}^{(l)}+c_{i}^{\\prime}\\cdot{r_{X}^{(l)}}^{2}-r_{Y}^{(l)}</span> (43)</p>

    <p class="text-gray-300">interpolates <span class="math">t^{\\prime}</span> and <span class="math">f</span> such that for <span class="math">i\\in[n]</span></p>

    <p class="text-gray-300"><span class="math">v_{4,i}^{(l)}=i+t_{i}^{\\prime}\\cdot r_{X}^{(l)}+f_{i}\\cdot{r_{X}^{(l)}}^{2}-r_{Y}^{(l)}.</span> (44)</p>

    <p class="text-gray-300">We will now argue that regardless of the extractors choice of transcripts, due to the binding property of the commitment scheme, it will derive the same interpolated vectors <span class="math">t</span>, <span class="math">a</span>, <span class="math">v</span>, <span class="math">c</span>, and <span class="math">f</span>. Indeed, starting with <span class="math">t</span>, regardless of the extractors choice of <span class="math">l\\in[N]</span> to derive <span class="math">t</span>, we must have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp},t)</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},(v_{1}^{(l)}-(1,\\ldots,n)+(r_{Y}^{(l)},\\ldots,r_{Y}^{(l)}))\\cdot{r_{X}^{(l)}}^{-1})</span> <span class="math">=(\\overline{v}_{1}^{(l)}-H+G_{n}\\cdot r_{Y}^{(l)})\\cdot{r_{X}^{(l)}}^{-1}</span> <span class="math">=\\overline{t}</span></p>

    <p class="text-gray-300">Therefore, because <span class="math">\\bar{t}</span> is identical across all transcripts, by the binding property of the commitment scheme, we have that <span class="math">t</span> is identically derived regardless of the choice of transcripts. For similar reasons, because <span class="math">\\overline{a}</span>, <span class="math">\\overline{v}</span>, <span class="math">\\overline{c}</span>, and <span class="math">\\overline{f}</span> are identical across transcripts we must have that <span class="math">a</span>, <span class="math">v</span>, <span class="math">c</span>, and <span class="math">f</span> are identically derived regardless of the choice of transcripts, and moreover that <span class="math">t = t&#x27;</span>, <span class="math">a = a&#x27;</span>, <span class="math">v = v&#x27;</span> and <span class="math">c = c&#x27;</span>. Then, we must have that Equations (41), (42) (43) (44) hold for all <span class="math">l \\in [N]</span>.</p>

    <p class="text-gray-300">Then, by Precondition (40), and the verifier's check in Step (5), we have for all <span class="math">l \\in [N]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\prod_{i \\in [n]} \\left(i + t_i \\cdot r_X^{(l)} - r_Y^{(l)}\\right)\\right) \\cdot \\left(\\prod_{i \\in [m]} \\left(a_i + v_i \\cdot r_X^{(l)} + (c_i + 1) \\cdot r_X^{(l)}^2 - r_Y^{(l)}\\right)\\right) \\\\ = \\prod_{i \\in [n]} v_{1,i}^{(l)} \\cdot \\prod_{i \\in [m]} v_{2,i}^{(l)} \\\\ = p_1^{(l)} \\cdot p_2^{(l)} \\\\ = p_3^{(l)} \\cdot p_4^{(l)} \\\\ = \\prod_{i \\in [n]} v_{3,i}^{(l)} \\cdot \\prod_{i \\in [m]} v_{4,i}^{(l)} = \\\\ \\left(\\prod_{i \\in [m]} \\left(a_i + v_i \\cdot r_X^{(l)} + c_i \\cdot r_X^{(l)}^2 - r_Y^{(l)}\\right)\\right) \\cdot \\left(\\prod_{i \\in [n]} \\left(i + t_i \\cdot r_X^{(l)} + f_i \\cdot r_X^{(l)}^2 - r_Y^{(l)}\\right)\\right). \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by the precondition that <span class="math">N</span> is sufficiently large, by interpolation, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\prod_{i \\in [n]} \\left(i + t_i \\cdot X - Y\\right)\\right) \\cdot \\left(\\prod_{i \\in [m]} \\left(a_i + v_i \\cdot X + (c_i + 1) \\cdot X^2 - Y\\right)\\right) = \\\\ \\left(\\prod_{i \\in [m]} \\left(a_i + v_i \\cdot X + c_i \\cdot X^2 - Y\\right)\\right) \\cdot \\left(\\prod_{i \\in [n]} \\left(i + t_i \\cdot X + f_i \\cdot X^2 - Y\\right)\\right). \\end{array}</span></div>

    <p class="text-gray-300">Then, by Lemma 10, and by the derivation that <span class="math">\\mathsf{Commit}(\\mathsf{pp}, t) = \\bar{t}</span> (and the similar implied derivations for <span class="math">a</span> and <span class="math">v</span>), we have that</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pp}, (\\bar{t}, \\bar{a}, \\bar{v}), (t, a, v)) \\in \\mathsf{LKP}.</span></div>

    <p class="text-gray-300">□</p>

    <h2 id="sec-73" class="text-2xl font-bold">B.5 Proof of Lemma 9 (From grand-product to zero-check)</h2>

    <p class="text-gray-300"><strong>Lemma 24 (Completeness).</strong> Construction 5 is complete.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. For an arbitrary size parameter <span class="math">n</span>, let <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(\\lambda, n)</span>, and <span class="math">(\\mathsf{pk}, \\mathsf{vk}, (F_{\\mathsf{GP}}, G_{\\mathsf{GP}})) \\gets \\mathcal{K}(\\mathsf{pp})</span>. Suppose now that the</p>

    <p class="text-gray-300">adversary on input pp generates</p>

    <p class="text-gray-300"><span class="math">((p,\\overline{v}),v)\\in\\mathsf{GP}.</span> (45)</p>

    <p class="text-gray-300">The prover and verifier on input <span class="math">(\\mathsf{pk},\\mathsf{vk}),(p,\\overline{v}),v</span> interactively produce output instance-witness pairs <span class="math">((({\\overline{v}},{\\overline{v}}^{\\prime}),p),(v,v^{\\prime}))</span>. We must show that</p>

    <p class="text-gray-300"><span class="math">((F_{\\mathsf{GP}},G_{\\mathsf{GP}}),(({\\overline{v}},{\\overline{v}}^{\\prime}),p),(v,v^{\\prime}))\\in\\mathsf{ZC}.</span> (46)</p>

    <p class="text-gray-300">Indeed, by Precondition 45 and the prover’s computation in Step 1, we have that</p>

    <p class="text-gray-300"><span class="math">\\overline{v}</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},v)</span> <span class="math">\\overline{v}^{\\prime}</span> <span class="math">=\\mathsf{Commit}(\\mathsf{pp},v^{\\prime})</span></p>

    <p class="text-gray-300">By Lemma 8 we have that</p>

    <p class="text-gray-300"><span class="math">f(0,x)</span> <span class="math">=\\widetilde{v}(x)</span> <span class="math">f(1,\\ldots,1,0)</span> <span class="math">=p,</span></p>

    <p class="text-gray-300">and that for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span></p>

    <p class="text-gray-300"><span class="math">f(1,x)=f(x,0)\\cdot f(x,1).</span></p>

    <p class="text-gray-300">Then, for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=f(1,x)-f(x,0)\\cdot f(x,1)</span> <span class="math">=\\widetilde{(v,v^{\\prime})}(1,x)-\\widetilde{(v,v^{\\prime})}(x,0)\\cdot\\widetilde{(v,v^{\\prime})}(x,1)</span> <span class="math">=(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(1,x)-(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(x,0)\\cdot(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(x,1)</span> <span class="math">=F_{\\mathsf{GP}}(G_{\\mathsf{GP}}((v,v^{\\prime}),p)(x))</span></p>

    <p class="text-gray-300">Therefore, we have that Equation 46 holds. ∎</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 25 (Knowledge soundness).</h6>

    <p class="text-gray-300">Construction 5 is knowledge-sound</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove knowledge soundness via tree extraction (Lemma 15). That is, we construct a PPT extractor <span class="math">\\chi</span>, that can produce a satisfying input witness given as input a single transcript for public parameters <span class="math">\\mathsf{pp}</span> and input instance <span class="math">(p,\\overline{v})</span>, and output instance-witness pair</p>

    <p class="text-gray-300"><span class="math">((F_{\\mathsf{GP}},G_{\\mathsf{GP}}),(({\\overline{v}},{\\overline{v}}^{\\prime}),p),(v,v^{\\prime}))\\in\\mathsf{ZC}.</span> (47)</p>

    <p class="text-gray-300">Indeed, by Precondition (47), we have that for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span></p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=F_{\\mathsf{GP}}(G_{\\mathsf{GP}}((v,v^{\\prime}),p)(x))</span> <span class="math">=(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(1,x)-(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(x,0)\\cdot(v,(v_{1}^{\\prime},\\ldots,p,v_{n}^{\\prime}))(x,1)</span> <span class="math">=f(1,x)-f(x,0)\\cdot f(x,1)</span></p>

    <p class="text-gray-300">for <span class="math">f = (v, (\\widehat{v_1&#x27;, \\ldots, p, v_n&#x27;}))</span>. But this means that <span class="math">f(1, x) = f(x, 0) \\cdot f(x, 1)</span> for all <span class="math">x \\in \\{0, 1\\}^{\\log n}</span>, <span class="math">f(1, \\ldots, 1, 0) = p</span>, and <span class="math">f(0, x) = \\widetilde{v}(x)</span>. Then, by Lemma 8, we must have that <span class="math">p = \\prod_{i \\in [n]} v_i</span>. Moreover, by Precondition (47), we have that <span class="math">\\operatorname{Commit}(\\mathfrak{pp}, v) = \\overline{v}</span>. Therefore, we have that</p>

    <div class="my-4 text-center"><span class="math-block">((p, \\widetilde{v}), v) \\in \\mathsf{GP}.</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">58</p>`;
---

<BaseLayout title="NeutronNova: Folding everything that reduces to zero-check (2024/1606)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1606
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
