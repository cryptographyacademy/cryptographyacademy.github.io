---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/152';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Compressed $\\Sigma$-Protocol Theory and Practical Application to Plug &amp; Play Secure Algorithmics';
const AUTHORS_HTML = 'Thomas Attema, Ronald Cramer';

const CONTENT = `    <p class="text-gray-300">Compressed <span class="math">\\Sigma</span>-Protocol Theory and Practical Application to Plug &amp; Play Secure Algorithmics</p>

    <p class="text-gray-300">Thomas Attema^{1,2,3,} and Ronald Cramer^{1,2,†}</p>

    <p class="text-gray-300">^{1} CWI, Cryptology Group, Amsterdam, The Netherlands ^{2} Leiden University, Mathematical Institute, Leiden, The Netherlands ^{3} TNO, Cyber Security and Robustness, The Hague, The Netherlands</p>

    <p class="text-gray-300">Full Version^{4,5}- July 16, 2020</p>

    <p class="text-gray-300">Abstract. <span class="math">\\Sigma</span>-Protocols provide a well-understood basis for secure algorithmics. Recently, Bulletproofs (Bootle et al., EUROCRYPT 2016, and Bünz et al., S&amp;P 2018) have been proposed as a drop-in replacement in case of zero-knowledge (ZK) for arithmetic circuits, achieving logarithmic communication instead of linear. Its pivot is an ingenious, logarithmic-size proof of knowledge BP for certain quadratic relations. However, reducing ZK for general relations to it forces a somewhat cumbersome “reinvention” of cryptographic protocol theory.</p>

    <p class="text-gray-300">We take a rather different viewpoint and reconcile Bulletproofs with <span class="math">\\Sigma</span>-Protocol Theory such that (a) simpler circuit ZK is developed within established theory, while (b) achieving exactly the same logarithmic communication.</p>

    <p class="text-gray-300">The natural key here is linearization. First, we repurpose BPs as a blackbox compression mechanism for standard <span class="math">\\Sigma</span>-Protocols handling ZK proofs of general linear relations (on compactly committed secret vectors); our pivot. Second, we reduce the case of general nonlinear relations to blackbox applications of our pivot via a novel variation on arithmetic secret sharing based techniques for <span class="math">\\Sigma</span>-Protocols (Cramer et al., ICITS 2012). Orthogonally, we enhance versatility by enabling scenarios not previously addressed, e.g., when a secret input is dispersed across several commitments. Standard implementation platforms leading to logarithmic communication follow from a Discrete-Log assumption or a generalized Strong-RSA assumption. Also, under a Knowledge-of-Exponent Assumption (KEA) communication drops to constant, as in ZK-SNARKS.</p>

    <p class="text-gray-300">All in all, our theory should more generally be useful for modular (“plug &amp; play”) design of practical cryptographic protocols; this is further evidenced by our separate work (2020) on proofs of partial knowledge.</p>

    <p class="text-gray-300">Keywords: <span class="math">\\Sigma</span>-protocols, Bulletproofs, Zero-Knowledge, Plug-and-Play, Secure Algorithmics, ZK-SNARKS, Verifiable Computation.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The theory of <span class="math">\\Sigma</span>-Protocols provides a well-understood basis for plug-and-play secure algorithmics. Recently, Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> have been introduced as a “drop-in replacement” for <span class="math">\\Sigma</span>-Protocols in several important applications. Notably, this includes ZK for arithmetic circuits with communication $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">^{∗}thomas.attema@tno.nl ^{†}cramer@cwi.nl, cramer@math.leidenuniv.nl ^{5}This is the full version of the same title work accepted for publication at CRYPTO 2020. ^{5}Change log w.r.t. previous version- June 23, 2020: (a) modified the extractor analysis of Appendix A to account for the fact that our previous derivations are only meaningful for a portion of the full parameter space, and (b) for the full range of parameters we rely on prior results and, for this reason, refrain from giving concrete knowledge errors in several theorems. ^{6}Loosely speaking, we refer to modular design of “cryptographic realizations” of standard “algorithmic tasks”. In other words, this entails porting algorithms for standard tasks to cryptographic scenarios, e.g., MPC and zero-</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bits where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the circuit size and </span>\\kappa<span class="math"> is the security parameter, down from </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\kappa)$ bits. A similar result holds for range proofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At the heart of Bulletproofs is an interactive proof of knowledge between a Prover and Verifier showing that a Pedersen commitment to a vector of large length <span class="math">n</span> satisfies a multi-variate polynomial equation of degree 2, defined with an inner product. We refer to this PoK by BP. Concretely, suppose <span class="math">\\mathbb{G}</span> is a cyclic group of prime order <span class="math">q</span> (denoted multiplicatively) supporting discrete-log-based cryptography. Suppose, furthermore, that <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{n})\\in\\mathbb{G}^{n}</span> and <span class="math">h\\in\\mathbb{G}</span> (each <span class="math">g_{i}</span> as well as <span class="math">h</span> generators of <span class="math">\\mathbb{G}</span>) have been set up once-and-for-all such that, for parties that may subsequently act as provers, finding nontrivial linear relations between them is computationally as hard as computing discrete logarithms in <span class="math">\\mathbb{G}</span>. For each <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>, define <span class="math">\\mathbf{g}^{\\mathbf{x}}=\\prod_{i=1}^{n}g_{i}^{x_{i}}</span>. A Pedersen-commitment <span class="math">P</span> to a vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> is then computed as <span class="math">P=\\mathbf{g}^{\\mathbf{x}}\\cdot h^{\\rho}</span> where <span class="math">\\rho\\in\\mathbb{Z}_{q}</span> is selected uniformly at random. This commitment is information-theoretically hiding and, on account of the set-up, computationally binding. Note that it is compact in the sense that, independently of <span class="math">n</span>, a commitment is a single <span class="math">\\mathbb{G}</span>-element. Suppose that <span class="math">n</span> is even and write <span class="math">n=2m</span>. Setting <span class="math">\\mathbf{x}=(\\mathbf{x}_{0},\\mathbf{x}_{1})\\in\\mathbb{Z}_{q}^{m}\\times\\mathbb{Z}_{q}^{m}</span>, a Bulletproof allows the prover to prove that it can open <span class="math">P</span> such that the inner-product <span class="math">\\langle\\mathbf{x}_{0},\\mathbf{x}_{1}\\rangle</span> equals some value claimed by the prover.</p>

    <p class="text-gray-300">BPs stand out in that they ingeniously reduce communication to <span class="math">O(\\log n)</span> elements from <span class="math">O(n)</span> via traditional methods. Although this is at the expense of introducing logarithmic number of moves (instead of constant), its public-coin nature ensures that it can be rendered non-interactive using the Fiat-Shamir heuristic <em>[x10]</em>. However, design of BP applications meet with a number of technical difficulties. First, BPs are not zero-knowledge, and second, cryptographic protocol theory has to be “reinvented” with the quadratic constraint proved as its “pivot”. This leads to practical yet rather opaque, complex protocols where applying natural plug-and-play intuition appears hard.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Summary of Our Contributions</h3>

    <p class="text-gray-300">In this work we take a different approach. We reconcile Bulletproofs with theory of <span class="math">\\Sigma</span>-Protocols such that (a) applications can follow (established) cryptographic protocol theory, thereby dispensing with the need for “reinventing” it, while (b) enjoying exactly the same communication reduction. We do this by giving a precise perspective on BPs as a significant strengthening of the power of <span class="math">\\Sigma</span>-protocols. We believe this novel perspective is rather useful for intuitive, plug-and-play or modular design of practical secure algorithmics. Perhaps surprisingly our approach yields the same communication complexity; up to and including the constants.</p>

    <p class="text-gray-300">We combine two essential components. First, we isolate a natural, alternative pivot: compact commitment with “arbitrary linear form openings”. Given a Pedersen commitment to a long vector <span class="math">\\mathbf{x}</span>, consider a ZKPoK that the prover knows <span class="math">\\mathbf{x}</span>, while also revealing, for an arbitrary, public, linear form <span class="math">L</span>, the scalar <span class="math">L(\\mathbf{x})</span> correctly and nothing else. This has a simple <span class="math">\\Sigma</span>-Protocol. We then compress it by replacing the final (long) prover-message with an appropriate BP that the prover knows it. Indeed, the relation that this message is required to satisfy turns out amenable to deployment of a suitable BP. As a result, PoK and honest-verifier ZK are preserved, but overall communication drops from linear to logarithmic. In the process, we simplify, for a portion of the full parameter space relevant to our applications, known run-time analyses of knowledge extractors involved and give concrete estimates. For the remainder, we continue to rely on known analyses. On top of this, we introduce further necessary utility enhancements. First, without increasing overall complexity, we show, using the pivot as black-box, how to open several linear form evaluations instead of just one. Second, using this and by plug & play with our basic theory, we show how to handle the application scenario where the secret, long vector is initially “dispersed” across several commitments, by compactifying these into a single compact commitment first. This is useful in important applications. From this point on, the only fact about the pivot that we will need is that we have access to a compact commitment scheme that allows a ZKPoK with low overall communication, showing that the prover knows the long secret committed vector and</p>

    <p class="text-gray-300">showing the correct openings of several linear evaluations on that committed vector; the technical details do not matter anymore.</p>

    <p class="text-gray-300">Second, the pivot’s significance now surfaces when integrated with a novel variation on – hitherto largely overlooked – arithmetic secret sharing based techniques for <span class="math">\\Sigma</span>-Protocols <em>[x11]</em>, inspired by MPC. These techniques allow for linearization of “nonlinear relations”. Mathematically, solving the linear instances first and then “linearizing” the non-linear ones is perhaps among the most natural problem solving strategies; here, this fits seamlessly with Sigma-protocol theory and our adaptation of <em>[x11]</em>. It is in these adaptations that free choice of linear forms in the pivot is fully exploited; the maps arising from our adaptation of <em>[x11]</em> do not form a well-structured subclass of maps. All in all, this yields simple logarithmic communication solutions for circuit ZK. Similarly for range proofs, which are now trivial to design. We also offer trade-offs, i.e., “square-root” complexity in constant rounds. Our results are based on either of three assumptions, the Discrete Logarithm assumption, an assumption derived from the Strong-RSA assumption, or a Knowledge-of-Exponent derived assumption.</p>

    <p class="text-gray-300">We proceed as follows. We start by outlining our program, in nearly exclusively conceptual fashion. We believe that the fact that it is possible to do so further underscores our main points. Later on we detail how this program deviates exactly from the paths taken in the recent literature.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 A More Detailed View of Our Program</h3>

    <p class="text-gray-300">A. Our Pivotal <span class="math">\\Sigma</span>-Protocol We isolate a basic <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> that, given a compact commitment to a secret vector <span class="math">\\mathbf{x}</span> of large length <span class="math">n</span>, allows to partially open it. Concretely, given an arbitrary, public, linear form <span class="math">L</span>, only the value <span class="math">L(\\mathbf{x})</span> is released and nothing else. Briefly, the prover has a compact commitment <span class="math">P</span> to a long secret vector <span class="math">\\mathbf{x}</span>. By a simple twist on basic <span class="math">\\Sigma</span>-protocol theory, the prover then selects a compact commitment <span class="math">A</span> to a secret random vector <span class="math">\\mathbf{r}</span>. The prover sends, as first move, this commitment <span class="math">A</span> and the values <span class="math">y=L(\\mathbf{x})</span> and <span class="math">y^{\\prime}=L(\\mathbf{r})</span>. In the second move, the verifier sends a random challenge <span class="math">c\\in\\mathbb{Z}_{q}</span>. In the third, final move, the prover then opens the commitment <span class="math">AP^{c}</span> to a vector <span class="math">\\mathbf{z}</span> (i.e., <span class="math">\\mathbf{z}</span> is its committed vector; we leave the randomness underlying the commitment implicit here). Finally, the verifier checks the opening of the commitment and checks that <span class="math">L(\\mathbf{z})=cy+y^{\\prime}</span>. The communication in this <span class="math">\\Sigma</span>-protocol is dominated by the opening of <span class="math">AP^{c}</span>. The latter amounts to <span class="math">O(n\\kappa)</span> bits (where <span class="math">\\kappa</span> is the security parameter), whereas the remainder of the protocol has <span class="math">O(\\kappa)</span> bits in total. That said, it is an honest-verifier zero-knowledge proof of knowledge (with unconditional soundness). In addition, we describe an amortized version of this basic <span class="math">\\Sigma</span>-protocol, i.e., a <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}^{\\mathrm{Am}}</span> that, given <span class="math">s</span> compact commitments to secret vectors <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{s}</span> and a linear form <span class="math">L</span>, allows to open <span class="math">L(\\mathbf{x}_{1}),\\ldots,L(\\mathbf{x}_{s})</span> and nothing else. The communication costs of this amortized <span class="math">\\Sigma</span>-protocol are exactly <span class="math">s-1</span> elements more than that of the basic <span class="math">\\Sigma</span>-protocol (i.e., the evaluations at the <span class="math">s-1</span> additional input vectors).</p>

    <p class="text-gray-300">Using the pivotal <span class="math">\\Sigma</span>-protocol as a black-box, its utility can be enhanced, which will be important later on. More concretely, many linear forms can be opened for essentially the price of a single one. First, by deploying a “polynomial amortization trick” (known, e.g., from MPC) we can do any number of nullity checks without any substantial increase in complexity. Second, building on this trick, we can extend the utility to the opening of several arbitrary linear forms <span class="math">L_{1},\\ldots,L_{s}</span> instead of a single one, at the cost of increasing the communication by exactly <span class="math">s-1</span> values in <span class="math">\\mathbb{Z}_{q}</span> (i.e., the evaluations of <span class="math">s-1</span> additional forms). Finally, we note the entire discussion on these enhancements holds verbatim when we replace linear forms by affine forms.</p>

    <p class="text-gray-300">Note that we have identified two distinct intractability assumptions, each of which supports this pivot: the Discrete Logarithm assumption (as used in prior work involving Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em>) but also one derived from the Strong-RSA assumption (as nailed down in a recent work <em>[x10]</em> on Bulletproofs and their improved applications). The introduction focuses on the DL assumption, but the <span class="math">\\Sigma</span>-protocol for the solution derived from the Strong-RSA assumption follows similarly. Our program can be based on either platform. In addition, we show how to base the program on a specific knowledge of exponent assumption.</p>

    <p class="text-gray-300">However, such assumptions are known to be unfalsifiable and, therefore, not without controversy. The details of our pivotal <span class="math">\\Sigma</span>-protocol can be found in Section 3, and the utility enhancements are described in Section 5.</p>

    <p class="text-gray-300">B. Compressing the Pivot We argue that protocol <span class="math">\\Pi_{0}</span> can be compressed using the ideas underlying Bulletproofs, yielding a protocol <span class="math">\\Pi_{c}</span> that has the same functionality and is still an honest-verifier zero-knowledge proof of knowledge for the relation in question, but that has communication <span class="math">O(\\kappa\\log n)</span> bits instead, and <span class="math">O(\\log n)</span> moves. Technically the compression degrades the soundness from unconditional to computational, and protocols with computational soundness are called arguments of knowledge. However, we will use the terms proof and argument of knowledge interchangeably. The compression techniques directly carry over to amortized <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}^{\\text{Am}}</span>. See below for variations achieving unconditional soundness.</p>

    <p class="text-gray-300">Main compression idea. The idea is simply as follows, starting from <span class="math">\\Pi_{0}</span>. Suppose that <span class="math">P</span> is the commitment in question. The linear forms are constants as they are part of the relation proved, so they will not be made explicit for now. Furthermore suppose that the prover has sent the message <span class="math">a</span> as first move of <span class="math">\\Pi_{0}</span>, and that the verifier has subsequently sent challenge <span class="math">c</span> as the second move. Thus, in the third –and final– move, the prover would be required to send the reply <span class="math">z</span>. The verifier would, finally, apply the verification function <span class="math">\\phi</span> attached to <span class="math">\\Pi_{0}</span> to check that <span class="math">\\phi(P;a,c,z)=1</span>, and accept only if this is the case. To define the compressed protocol <span class="math">\\Pi_{c}</span>, instead of requiring the prover to send the long vector <span class="math">z</span>, a suitable adaptation of Bulletproof’s PoK (BP) will be deployed to let the prover convince the verifier that it knows some <span class="math">z</span> such that <span class="math">\\phi(P;a,c,z)=1</span>, which is much more efficient. Note that it is immaterial that the Bulletproof part is not zero knowledge as, in <span class="math">\\Pi_{0}</span>, the prover would have revealed <span class="math">z</span> anyway.</p>

    <p class="text-gray-300">This will ensure the claimed communication reduction, i.e., <span class="math">O(\\kappa\\log n)</span> bits in <span class="math">O(\\log n)</span> moves. We show that, as a trade-off, we may opt for constant number of rounds (instead of logarithmic) and <span class="math">O(\\kappa\\sqrt{n})</span> communication (instead of logarithmic). But of course, in non-interactive Fiat-Shamir mode (which clearly applies here), the logarithmic variant may be preferable.</p>

    <p class="text-gray-300">Note that this compression idea equally applies to the enhancements of the basic utility as discussed above. It gives essentially the same complexities. Of course, this assumes that the number of openings of linear forms is not too large; it is not sensitive to the number of nullity checks though. The details of the compression idea can be found in Section 4.</p>

    <p class="text-gray-300">Refined Analysis of Knowledge Extractors. In the theory of <span class="math">\\Sigma</span>-protocols <em>[x10]</em>, it is well known that special soundness implies knowledge soundness with knowledge error <span class="math">1/q</span>, where <span class="math">q</span> is the size of the challenge set. Depending on a choice for the definition of knowledge soundness, this result can either be shown by an application <em>[x10]</em> of Jensen’s inequality, or by a more intricate variation of the classical heavy-row type approach <em>[x13]</em>.</p>

    <p class="text-gray-300">Recently, and particularly for the above mentioned compression techniques, natural generalizations of special soundness have become relevant. However, the mentioned proof techniques are no longer directly applicable. The nature of the compression techniques namely significantly reduces the efficiency of the corresponding knowledge extractors. For this reason prior works <em>[BCC^{+}16, BBB^{+}18]</em> resort to alternative arguments without computing the exact knowledge error. See also <em>[x24]</em> and <em>[x15]</em> for a discussion on extractor efficiency and knowledge errors.</p>

    <p class="text-gray-300">Here, we show that an adaptation of the proof using Jensen’s inequality does apply for a portion of the full parameter space relevant to our applications. This results in a simple proof and an exact knowledge error for this portion of the parameter space. For parameters that do not fall in this range we resort to prior results <em>[BCC^{+}16, BBB^{+}18]</em>. The details of the extractor analysis can be found in Appendix A.</p>

    <p class="text-gray-300">Compressed Pivot with Unconditional Soundness. In addition, we show two approaches for realizing our compressed pivot with unconditional soundness, rather than computational. In our first approach we simply omit the step of the BP compression in which the linear-form evaluation is incorporated into the commitment, and execute that part “in the open”. This works for us here since we only consider linear constraints in the compressed pivot and no quadratic ones. As a result, unconditional soundness is achieved. This approach increases the communication costs by a factor 2.</p>

    <p class="text-gray-300">Our second approach is based on the observation that an unconditionally sound ZKPoK for opening linear forms can be based on black-box access to an unconditionally sound ZKPoK for just proving knowledge of an opening of a Pedersen vector commitment. The reduction uses structural information of a given linear form (i.e., it depends on the null-space and selection of a basis for it). By removing the provisions for linear forms from the compressed pivot <span class="math">\\Pi_{c}</span> the required black-box is realized. The details can be found in Appendix C.</p>

    <p class="text-gray-300">C. Compactifying a Vector of Commitments Our compressed pivot may be summarized as compact commitments to long secret vectors that allow for very efficient partial openings, i.e., arbitrary linear forms applied to the secret committed vector. As we show later on, this is sufficient for proving any (nonlinear) relation. To make this work, all relevant prover data (secret data vector plus secret auxiliary data, such a random coins) is required to be committed to in a single compact commitment.</p>

    <p class="text-gray-300">However, in many relevant practical scenarios, we must assume that the commitment to the prover’s secret data vector, about which something is to be proved in zero knowledge, has already been produced before the zero knowledge protocol is run. In order to handle this, we require the prover to compactify these commitments together with the secret auxiliary data in a single commitment.</p>

    <p class="text-gray-300">We consider two extreme scenarios: (1) the prover has a single compact commitment to the secret data vector about which some zero knowledge proof is to be conducted and (2) same, except that the prover has individual commitments to the coordinates of that secret data vector. For each scenario we give a conceptually clean realization by plug & play with our basic theory. We note that scenario 1 has not been addressed by previous work.</p>

    <p class="text-gray-300">For the first scenario the prover uses new generators to commit to the auxiliary information. Using the compressed <span class="math">\\Sigma</span>-protocol, the prover shows that this is indeed a commitment that exclusively involves the new generators. Prover and verifier multiply the two compact commitments to obtain a single compact commitment to all relevant data.</p>

    <p class="text-gray-300">For the second scenario, a basic (amortized) <span class="math">\\Sigma</span>-protocol shows that the prover knows openings to all individual commitments. From this basic protocol, we define a new <span class="math">\\Sigma</span>-protocol as follows. The prover appends the first message <span class="math">a</span> of the basic protocol with a compact commitment containing all relevant data and the randomness sampled in the first move of the basic <span class="math">\\Sigma</span>-protocol. After receiving the challenge the prover’s response can now be computed as a public linear form (parameterized by the challenge <span class="math">c</span>) evaluated at the vector to which the prover committed. Instead of sending this message directly, the prover and verifier run the interactive protocol to open the associated linear form on the compact vector commitment. The verifier checks that the opening of the vector commitment is also an opening of the commitment in the <span class="math">\\Sigma</span>-protocol. As a result the prover has shown that it knows openings to all the individual commitments and that these openings are contained in the compact commitment together with the auxiliary data. The details on the compactification of vector commitments can be found in Section 5.3.</p>

    <p class="text-gray-300">D. Plug-and-Play Secure Algorithmics from Compressed Pivot We will now explain the power of our compressed pivot. It will turn out that we only need black-box access. Our key point is to show how to combine this with a hitherto largely overlooked part of <span class="math">\\Sigma</span>-protocol theory, namely the work of <em>[x1]</em> that shows how to prove arbitrary constraints on committed vectors by exploiting techniques from secure multi-party computation based on arithmetic secret sharing, more concretely, the ideas underlying the Commitment Multiplication Protocol from <em>[x2]</em>. For more information, see Section 12.5.3 in <em>[x3]</em> for a general description of efficient zero-knowledge verification of secret multiplications in terms of arbitrary (strongly-multiplicative) arithmetic secret sharing. It is this combination of “compact commitments with linear openings” and arithmetic secret sharing that allows for “linearizing nonlinear relations”. So this explains also why our compressed pivot does not need any “direct” provision to handle nonlinearity.</p>

    <p class="text-gray-300">We need to make some appropriate adaptations to make this work for us here. We first outline the technique from <em>[x1]</em> and then we discuss adaptations. The work of <em>[x1]</em> considers homomorphic commitment schemes where the secret committed to is not a vector of large length, but a single element of <span class="math">\\mathbb{Z}_{q}</span> instead. The primary result is a <span class="math">\\Sigma</span>-protocol showing the correctness of commitments to <span class="math">m</span> multiplication</p>

    <p class="text-gray-300">triples <span class="math">(\\alpha_{i},\\beta_{i},\\gamma_{i}:=\\alpha_{i}\\beta_{i})</span>, with low amortized complexity for large <span class="math">m</span>. In other words, the protocol verifies the multiplicative relations, and the costs per triple are relatively small.</p>

    <p class="text-gray-300">Each of the <span class="math">\\alpha_{i}</span>’s (resp., the <span class="math">\\beta_{i}</span>’s and <span class="math">\\gamma_{i}</span>’s) is individually committed to. Their solution employs strongly-multiplicative packed-secret sharing. For instance, consider Shamir’s scheme over <span class="math">\\mathbb{Z}_{q}</span>, with privacy parameter <span class="math">t=1</span>, but with secret-space dimension <span class="math">m</span>. This uses random polynomials of degree <span class="math">\\leq m</span>, subject to the evaluations on the points <span class="math">1,\\ldots,m</span> comprising the desired secret vector. Note that, for each sharing, a single random <span class="math">\\mathbb{Z}_{q}</span>-element is required (which can be taken as the evaluation at <span class="math">0</span>).</p>

    <p class="text-gray-300">It is important to note that, given secret vector and random element, it holds by Lagrange Interpolation that, for each <span class="math">c\\in\\mathbb{Z}_{q}</span>, the evaluation <span class="math">f(c)</span> of such polynomial <span class="math">f(X)</span> is some public <span class="math">\\mathbb{Z}_{q}</span>-linear combination over the coordinates of the secret vector and the random element. Namely, consider the map that takes <span class="math">m+1</span> arbitrary evaluations on the points <span class="math">0,\\ldots,m</span> and that outputs the unique polynomial <span class="math">f(X)</span> of degree <span class="math">\\leq m</span> interpolating them to the evaluations of <span class="math">f(X)</span> in all other points. A transformation matrix describing this map does not correspond to a Vandermonde-matrix, but it can be determined from it.</p>

    <p class="text-gray-300">Now, assume that <span class="math">2m&lt;q</span> (for strong-multiplicativity). The protocol goes as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The vectors of commitments to the multiplication triples are assumed to be part of the common input.</li>

      <li>The prover selects a random polynomial <span class="math">f(X)</span> that defines a packed secret sharing of the vector <span class="math">(\\alpha_{1},\\ldots,\\alpha_{m})</span>. The prover also selects a random polynomial <span class="math">g(X)</span> that defines a packed secret sharing of the vector <span class="math">(\\beta_{1},\\ldots,\\beta_{m})</span>. Finally, the prover computes the product polynomial <span class="math">h(X):=f(X)g(X)</span> of degree <span class="math">\\leq 2m&lt;q</span>.</li>

      <li>The prover commits to the random <span class="math">\\mathbb{Z}_{q}</span>-element for the sharing based on <span class="math">f(X)</span>, i.e., <span class="math">f(0)</span>, and commits to the random <span class="math">\\mathbb{Z}_{q}</span>-element for the sharing based on <span class="math">g(X)</span>, i.e., <span class="math">g(0)</span>. The prover also commits the evaluations of <span class="math">h(X)</span> on the points <span class="math">0,m+1,\\ldots,2m</span>. Note that the “absent” evaluations at <span class="math">1,\\ldots,m</span> comprise the <span class="math">\\gamma_{i}</span>’s and their commitments are already assumed to be part of the common input.</li>

      <li>The prover sends these commitments to the verifier.</li>

      <li>The verifier selects a random challenge <span class="math">c\\in\\mathbb{Z}_{q}</span> distinct from <span class="math">1,\\ldots,m</span> and sends it to the prover.</li>

      <li>By public linear combinations, both prover and verifier can compute three commitments: one to <span class="math">u:=f(c)</span>, one to <span class="math">v:=g(c)</span> and one to <span class="math">w:=h(c)</span>. The prover opens each of these (assuming, of course, that <span class="math">c</span> is in the right range). The verifier checks each of these three openings and checks whether <span class="math">w=uv</span>. If the committed polynomials do not satisfy <span class="math">f(X)g(X)=h(X)</span>, and under the assumption that the commitment scheme is binding, there are at most <span class="math">2m</span> values of <span class="math">c</span> out of the <span class="math">q-m</span> possibilities such that the final check goes through. So a lying prover is caught with probability greater than <span class="math">1-2m/(q-m)</span>. With <span class="math">q</span> exponential in the security parameter and <span class="math">m</span>, say, polynomial in it, this is exponentially close to <span class="math">1</span>. Honest-verifier zero-knowledge essentially follows from 1-privacy of the secret sharing scheme.</li>

    </ul>

    <p class="text-gray-300">Our first observation here is as follows. In the above protocol, the prover may as well use our compressed pivot as a black-box. Indeed, the entire vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\alpha_{1},\\ldots,\\alpha_{m},\\beta_{1},\\ldots,\\beta_{m},f(0),g(0),h(0),h(1),\\ldots,h(2m))\\in\\mathbb{Z}_{q}^{4m+3}</span></p>

    <p class="text-gray-300">of data that the prover commits to in the protocol above can be committed to in a single compact commitment. Note that, by definition, <span class="math">\\gamma_{i}=h(i)</span> for all <span class="math">1\\leq i\\leq m</span>. Furthermore, all of the data opened to the verifier is some fixed linear form on the (long) secret committed vector <span class="math">\\mathbf{y}</span>. Indeed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each of the values <span class="math">u,v</span> correspond to an opening of a public linear form applied to <span class="math">\\mathbf{y}</span>. The linear form is determined by some row in a transformation matrix as addressed above, under the convention that the form takes zeros on the portion of the coordinates of <span class="math">\\mathbf{y}</span> not relevant to the computation.</li>

      <li>Similarly for the value <span class="math">w</span>, except that this simply corresponds to an “evaluation of a polynomial whose coefficients are defined by a part of <span class="math">\\mathbf{y}</span>”. So evaluation is a public linear form as well.</li>

    </ol>

    <p class="text-gray-300">Overall, we get an honest-verifier proof of knowledge for showing correctness of <span class="math">m</span> secret multiplication-triples with <span class="math">O(k\\log m)</span> bits communication in <span class="math">O(\\log m)</span> moves (or in constant rounds but with <span class="math">O(k\\sqrt{m})</span> bits communication).</p>

    <p class="text-gray-300">Our second observation here is as follows. Suppose we have an arithmetic circuit <span class="math">C</span> over <span class="math">\\mathbb{Z}_{q}</span> with <span class="math">n</span> inputs, <span class="math">s</span> outputs and <span class="math">m</span> multiplication gates. We can easily turn the observation above into a solution for “circuit zero-knowledge”, i.e., the prover convinces the verifier that the committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> satisfies some constraint captured by a given circuit <span class="math">C</span> which (w.l.o.g.) returns <span class="math">0</span>. We note that <em>[x10]</em> also gives a solution for circuit zero-knowledge. But that one does not work for us here as it gives too large complexity. So we make some changes.</p>

    <p class="text-gray-300">By the aforementioned compactification techniques it is sufficient to consider the ZK scenario where the prover wants to demonstrate that <span class="math">C</span> is satisfiable; this means that we may assume that the prover commits to all relevant data (inputs and all auxiliary data) in a single compact commitment. Other ZK scenarios, in which the prover has already committed to input data, are dealt with by first compactifying existing commitments and auxiliary information into a single compact commitment.</p>

    <p class="text-gray-300">The protocol goes as follows. The prover first determines the computation graph implied by instantiating the circuit <span class="math">C</span> with its input vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>. The <span class="math">m</span> multiplication gates in <span class="math">C</span> will be handled as above, i.e., via polynomials <span class="math">f(X)</span>, <span class="math">g(X)</span> and <span class="math">h(X)</span> defining packed-secret sharings of the left inputs, the right inputs and outputs of the multiplication gates. The prover commits to each of the coordinates of <span class="math">\\mathbf{x}</span> and to the auxiliary data <span class="math">\\mathfrak{aux}=(f(0),g(0),h(0),h(1),\\ldots,h(2m))\\in\\mathbb{Z}_{q}^{2m+3}</span> in one single compact commitment. The length <span class="math">\\gamma</span> of the committed vector <span class="math">\\mathbf{y}</span> thus equals <span class="math">n+2m+3</span>.</p>

    <p class="text-gray-300">A simple fact about arithmetic circuits shows that all wire values are accessible as affine combinations of the coefficients committed to. These affine combinations are uniquely defined by the addition and scalar multiplication gates of the circuit. This explains why, in contrast to the discussion above, it is no longer necessary to commit explicitly to the <span class="math">\\alpha_{i}</span>’s and the <span class="math">\\beta_{i}</span>’s as these are now implicitly committed to via said affine functions of <span class="math">\\mathbf{y}</span>. Therefore, since the values <span class="math">f(0)</span>, <span class="math">g(0)</span> are still included in <span class="math">\\mathbf{y}</span>, the polynomials <span class="math">f(X)</span>, <span class="math">g(X)</span> and <span class="math">h(X)</span> are well-defined by <span class="math">\\mathbf{y}</span>, and their evaluations are, by composition of the appropriate maps, also affine evaluations on <span class="math">\\mathbf{y}</span>.</p>

    <p class="text-gray-300">With the above observations in hand, the protocol is reduced to opening the affine map <span class="math">\\Phi</span> that, on input <span class="math">\\mathbf{y}</span>, outputs <span class="math">(C(\\mathbf{x}),f(c),g(c),h(c))</span> for a challenge <span class="math">c\\in\\mathbb{Z}_{q}\\setminus\\{1,\\ldots,m\\}</span> sampled uniformly at random by the verifier. First, the verifier checks that <span class="math">h(c)=f(c)g(c)</span> which, as above, shows that the required multiplicative relations hold with high probability. Second, the verifier checks that <span class="math">C(\\mathbf{x})=0</span>, which shows that the circuit is satisfiable and that the prover knows a witness <span class="math">\\mathbf{x}</span>. By the amortized nullity checks (A) the costs of these openings can be amortized. As a result, circuit zero knowledge can be done <span class="math">O(\\kappa\\log\\gamma)</span> bits in <span class="math">O(\\log\\gamma)</span> moves. In particular, the communication costs are independent of the number of output vertices <span class="math">s</span>. Trade-off between communication and moves applies as above. More details on circuit ZK can be found in Section 6.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">E. Range Proofs</h3>

    <p class="text-gray-300">In a basic range proof a prover wishes to commit to a secret integer <span class="math">v</span> and show that this integer is in a public range, say <span class="math">[0,2^{n-1}]</span>. From the above circuit ZK protocols, range proofs immediately follow. A prover simply considers the bit decomposition <span class="math">\\mathbf{b}\\in\\mathbb{Z}^{n}</span> of the integer <span class="math">v</span>, the length of this decomposition determines the range. Note that <span class="math">v</span> can be accessed as a linear form evaluated at <span class="math">\\mathbf{b}</span> and thereby a commitment to <span class="math">\\mathbf{b}</span> is an implicit commitment to <span class="math">v</span>. Prover and verifier run the above circuit satisfiability protocol to commit to <span class="math">\\mathbf{b}</span> and prove that <span class="math">C(\\mathbf{b})=0</span> for <span class="math">C:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}^{n},\\quad x\\mapsto x<em>(1-x)</span>, where <span class="math"></em></span> represents the component-wise product. The nullity check for <span class="math">C</span> shows that the committed coefficients are indeed bits. The communication complexity of this range proof is <span class="math">O(\\kappa\\log n)</span> bits. Using the techniques described in Section 5.3, this functionality can be extended to scenario where a prover has to prove that a Pedersen commitment to <span class="math">v\\in\\mathbb{Z}_{q}</span> is in a certain range. The details can be found in Section 7 and Appendix F.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">F. Our Program from the Strong-RSA Assumption</h3>

    <p class="text-gray-300">Thus far, we have implemented our program in the discrete log setting, starting from Pedersen commitments and their basic <span class="math">\\Sigma</span>-protocols. Besides some minor details in the compressed pivot, we show that the above discussion holds verbatim for a commitment scheme based on an assumption derived from the Strong-RSA</p>

    <p class="text-gray-300">assumption. More precisely, we show how the polynomial commitment scheme from a recent work <em>[x1]</em> can be adapted to open arbitrary linear forms. Our adaptations of the linearization techniques from <em>[x3]</em> are directly applicable to the Strong-RSA derived pivot. The details can be found in Section 7 and Appendix G.</p>

    <p class="text-gray-300">G. Our Program from the Knowledge-of-Exponent Assumption In addition to the discrete log and strong-RSA derived assumptions, our program can also be based on an assumption derived from the Knowledge-of-Exponent Assumption (KEA). Note that KEA is unfalsifiable and its application is not completely without controversy <em>[x21, x4]</em>. Moreover, this approach introduces a trusted set-up phase, which might be undesirable. The main benefit of the KEA based approach is that it reduces the communication complexity from logarithmic to constant, i.e., independent of the dimension of the committed vector. In Section 9 we describe the main techniques and for more details we refer to <em>[x11]</em>.</p>

    <p class="text-gray-300">H. Proofs of Partial Knowledge from Compressed <span class="math">\\Sigma</span>-Protocol Theory In a ZK proof of <span class="math">(k,n)</span>-partial knowledge, a prover knowing witnesses for some <span class="math">k</span>-subset of <span class="math">n</span> given public statements can convince the verifier of this fact without revealing which <span class="math">k</span>-subset. In separate work <em>[x1]</em>, we construct logarithmic size proofs of partial knowledge <em>for all <span class="math">k,n</span></em>, by adapting our compressed <span class="math">\\Sigma</span>-protocols and repurposing ideas from <em>[x5]</em>. So far, a <em>direct</em> , linear size solution is known for all <span class="math">k,n</span> <em>[x5]</em>; logarithmic size <em>only</em> for <span class="math">k=1</span>, i.e., <em>1-out-of-n proofs</em> <em>[x13, BCC^{+}15, x16]</em>. We note that, for <span class="math">k=1</span>, we nearly halve the best known communication costs.</p>

    <p class="text-gray-300">I. Our program from Lattice Assumptions From the work of <em>[x6]</em> we can extract an instantiation of our compressed pivot based on lattice assumptions. Based on this, our framework can therefore be instantiated from lattice assumptions. However, lattice based proofs of knowledge in general are typically subject to a so called soundness slack that is further increased by the compression in <em>[x6]</em>. Therefore, whether or not one follows our framework, selection of <em>larger</em> implementation parameters is warranted. Further research is required to determine if and how the implementation parameters can be improved.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Comparison with Earlier Work</h3>

    <p class="text-gray-300">Traditional solutions for circuit ZK in the discrete logarithm setting have a communication complexity that is linear in the circuit size. Building on the work of Groth <em>[x12]</em>, an ingenious recursive approach achieved logarithmic communication complexity <em>[BCC^{+}16]</em>. At its heart lies an earlier version of the BP protocol discussed earlier. Further improvements were introduced in <em>[BBB^{+}18]</em> and later revisited in <em>[x15]</em>. Recently, Bünz, Fisch and Szepieniec <em>[x1]</em> show that similar results can be derived from the Strong-RSA assumption. The main merit of the Strong-RSA derived solutions is a reduction in the number of public parameters. In addition, <em>[x1]</em> deploys proofs of exponentiation <em>[x27]</em> to reduce the computational complexity.</p>

    <p class="text-gray-300">A common denominator in the aforementioned works is the use of a quadratic constraint as a main pivot. In <em>[x12]</em>, a specific inner-product relation is introduced, and it is shown how basic <span class="math">\\Sigma</span>-protocols for this relation can be enhanced to achieve sub-linear communication complexity. A similar inner-product relation lies at the foundation of the logarithmic size protocols of <em>[BCC^{+}16]</em>, except that it also uses an earlier version of the BP idea. In <em>[BBB^{+}18]</em>, it is subsequently shown that a modification of the quadratic relation leads to better constants. In <em>[x15]</em>, more general quadratic constraints were considered with a view towards reducing <em>computational</em> complexity in specific ZK scenarios. Also they strive for a more modular approach. However, this induces (minor) communication overhead in comparison to Bulletproofs <em>[BBB^{+}18]</em>.</p>

    <p class="text-gray-300">Furthermore, it is worth mentioning that in <em>[BCC^{+}16]</em>, as an intermediate stepping stone, a polynomial commitment scheme is constructed. A polynomial commitment is a commitment to the coefficient vector of a polynomial together with the functionality of opening the evaluation at any given point. The solution derived from the Strong-RSA assumption <em>[x1]</em> bases itself entirely on this polynomial functionality. For</p>

    <p class="text-gray-300">general relations it uses recent, but complicated, reductions <em>[x15, x21, x27]</em>. Constructing protocols from quadratic constraints, either directly or via a polynomial commitment scheme, leads to a complex theory in which plug-and-play secure algorithmics appears hard. Significant effort is required to realize higher level applications such as circuit ZK or range proofs.</p>

    <p class="text-gray-300">As for zero-knowledge, the work of <em>[BBB^{+}18]</em> and <em>[x14]</em> establishes this property at a higher level, and not, as do the other works, at the level of their main pivot, which leads to additional difficulties in designing ZK protocols. In fact, in <em>[x14]</em>, zero-knowledge, reduced communication and reduced computation is achieved in an integrated manner.</p>

    <p class="text-gray-300">The most significant difference between our approach and that of the aforementioned works is our simple and direct construction of a compressed pivot to open arbitrary linear forms and to combine this with the simple (MPC inspired) linearization techniques from <em>[x7]</em>. The compression is achieved by a suitable adaptation of the BP ideas <em>[BBB^{+}18]</em>, and the linearization techniques discard the need for a direct provision to handle nonlinearity. Moreover, plug and play design of applications according to this compressed <span class="math">\\Sigma</span>-protocol theory is just as easy as with the standard <span class="math">\\Sigma</span>-protocol theory. Despite the conceptual simplicity, the communication complexities of our approach are, even including the constants, equal to that of Bulletproofs <em>[BBB^{+}18]</em>.</p>

    <p class="text-gray-300">Note that polynomial evaluation, as used in some of the other works, of course also comes down to the evaluation of a linear form, albeit a specific one. Therefore these approaches are not amenable to the linearization techniques we use. Opening arbitrary linear forms therefore seems to be a sweet spot in that it achieves conceptual simplicity, both in designing ZK protocols and in implementing the pivot.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we introduce the basic notation, definitions and conventions used in the remainder of the paper.</p>

    <p class="text-gray-300">Interactive Protocols. Let <span class="math">R=\\{(x,w)\\}</span> be some NP-relation. Here, <span class="math">x</span> is called a statement and <span class="math">w</span> is called a witness for <span class="math">x</span>. An interactive protocol <span class="math">\\Pi</span> for relation <span class="math">R</span> is a protocol that allows a prover to convince a verifier that it knows a witness <span class="math">w</span> for given statement <span class="math">x</span>. Protocol 1 shows a graphical protocol description of dummy protocol <span class="math">\\Pi</span>.Protocol <span class="math">\\Pi</span> takes <span class="math">x</span> as public input and <span class="math">w</span> as prover’s private input, which we write as either <span class="math">\\Pi(x;w)</span> or, in the graphical protocol description, as <span class="math">\\textsc{Input}(x;w)</span>. The verifier always implicitly outputs reject or accept. Optionally, the protocol can output a public string <span class="math">y</span> to both verifier and prover, and a private string <span class="math">w^{\\prime}</span> only to the prover. In this case we write <span class="math">\\textsc{Output}(y;w^{\\prime})</span>. In addition to the input and output of the protocol, the prover’s claim (i.e, <span class="math">(x;w)\\in R</span>) is made explicit in the graphical protocol description. An interactive protocol in which the verifier chooses all its messages uniformly at random and independent from the prover’s messages is called a public coin protocol. All protocols in this work are public coin and can therefore be made non-interactive by applying the Fiat-Shamir transformation <em>[x11]</em>.</p>

    <p class="text-gray-300">Special Soundness and Zero-Knowledge. A public coin protocol is said to be (unconditionally) <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound if there exists a polynomial time algorithm that on input a statement <span class="math">x</span> and a <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts, outputs a witness <span class="math">w</span> for <span class="math">x</span>. See <em>[BCC^{+}16]</em> for a detailed definition. In brief, a <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts is a set of <span class="math">\\prod_{i=1}^{\\mu}k_{i}</span> accepting transcripts that are arranged in a tree structure. The edges in this three correspond to the verifier’s challenges and vertices to the prover’s messages, which can be empty. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node. Note that this notion is, in two ways, a natural generalization of the standard notion special soundness: (1) from a colliding pair of transcripts to a <span class="math">k</span>-collision and (2) from 1 challenge protocols to protocols with <span class="math">\\mu\\geq 1</span> challenges. In <em>[BCC^{+}16]</em> it is shown that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness implies witness extended emulation <em>[x17]</em>. A protocol is said to have this property if for any prover <span class="math">\\mathcal{P}^{<em>}</span> there exists an efficient algorithm, with rewindable oracle access to <span class="math">\\mathcal{P}^{</em>}</span>, that outputs a transcript and, if this transcript is accepting then it outputs, with overwhelming probability, a witness as well. The transcripts generated by this algorithm are required to be indistinguishable from conversations between <span class="math">\\mathcal{P}^{*}</span> and an honest verifier. We show that all</p>

    <p class="text-gray-300">Protocol 1 Dummy Protocol  <span class="math">\\varPi</span>  for Relation  <span class="math">R</span></p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS : ...  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT(x;w)  |   |   |</p>

    <p class="text-gray-300">|  OUTPUT(y;w')  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(x;w) ∈ R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ← |   |</p>

    <p class="text-gray-300">|   | ⋮ |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">→</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">protocols in this work are  <span class="math">(k_{1}, k_{2}, \\ldots, k_{\\mu})</span> -special sound for some  <span class="math">\\mu</span>  and some set of  <span class="math">k_{i}</span> 's. From the result of  <span class="math">[\\mathrm{BCC}^{+}16]</span>  it then follows that the protocols in this work are proofs of knowledge.</p>

    <p class="text-gray-300">The protocol's public parameters are typically a set of generators  <span class="math">g_{1}, \\ldots, g_{n}, h</span>  of a group  <span class="math">\\mathbb{G}</span>  of prime order  <span class="math">q</span> . We assume that, in the setup phase, these generators are sampled uniformly at random such that the prover does not know a non-trivial DL relation between them. We say that the protocol is computationally  <span class="math">(k_{1}, k_{2}, \\ldots, k_{\\mu})</span> -special sound, under the DL assumption, if there exists an efficient algorithm that either extracts a witness or finds a non-trivial DL relation between the public parameters  <span class="math">g_{1}, \\ldots, g_{n}, h</span> . Protocols that satisfy this computational variant of soundness are also called arguments of knowledge. Later we will also consider different set up assumptions, based on Strong-RSA of Knowledge of Exponent derived assumptions. Finally, we will consider standard notions of zero-knowledge such special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300">This section formally describes the Pedersen vector commitment scheme and our pivotal  <span class="math">\\Sigma</span> -protocol, as discussed in Section 1.2 (A). In addition, we describe a standard amortized  <span class="math">\\Sigma</span> -protocol for opening a linear form on many commitments. Compression is described in Section 4.</p>

    <p class="text-gray-300">The primary commitment scheme under consideration in this paper is the Pedersen vector commitment scheme.</p>

    <p class="text-gray-300">Definition 1 (Pedersen Vector Commitment [Ped91]). Let  <span class="math">\\mathbb{G}</span>  be an Abelian group of prime order  <span class="math">q</span> . Pedersen vector commitments are defined by the following setup and commitment phase:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:  <span class="math">\\mathbf{g} = (g_1, \\ldots, g_n) \\gets_R \\mathbb{G}^n</span> ,  <span class="math">h \\gets_R \\mathbb{G}</span> .</li>

      <li>Commit:  <span class="math">\\operatorname{COM} : \\mathbb{Z}_q^n \\times \\mathbb{Z}_q \\to \\mathbb{G}</span> ,  <span class="math">(\\mathbf{x}, \\gamma) \\mapsto h^\\gamma \\mathbf{g}^{\\mathbf{x}} := h^\\gamma \\prod_{i=1}^n g_i^{x_i}</span> .</li>

    </ul>

    <p class="text-gray-300">We define  <span class="math">\\mathbf{g}^{\\mathbf{x}} := \\prod_{i=1}^{n} g_i^{x_i}</span>  and  <span class="math">\\mathbf{g}^c := (g_1^c, g_2^c, \\ldots, g_n^c)</span>  for any  <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> ,  <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span>  and  <span class="math">c \\in \\mathbb{Z}_q</span> . Moreover, the component-wise product between two vectors  <span class="math">\\mathbf{g}, \\mathbf{h} \\in \\mathbb{G}^n</span>  is written as  <span class="math">\\mathbf{g} * \\mathbf{h} = (g_1 h_1, g_2 h_2, \\ldots, g_n h_n)</span> .</p>

    <p class="text-gray-300">Pedersen vector commitments are perfectly hiding and computationally binding under the assumption that the prover does not know a non-trivial discrete log relation between the generators  <span class="math">g_{1}, \\ldots, g_{n}, h</span> .</p>

    <p class="text-gray-300">To open a commitment to a linear form  <span class="math">L: \\mathbb{Z}_q^n \\to \\mathbb{Z}_q</span>  means that the prover wishes to reveal  <span class="math">L(\\mathbf{x})</span>  together with a proof of validity without revealing any additional information on  <span class="math">\\mathbf{x}</span> . Achieving this functionality amounts for the prover to send the value  <span class="math">L(\\mathbf{x})</span>  along with a ZKPoK for the relation</p>

    <div class="my-4 text-center"><span class="math-block">R = \\left\\{\\left(P \\in \\mathbb {G}, L \\in \\mathcal {L} \\left(\\mathbb {Z} _ {q} ^ {n}\\right), y \\in \\mathbb {Z} _ {q}; \\mathbf {x} \\in \\mathbb {Z} _ {q} ^ {n}, \\gamma \\in \\mathbb {Z} _ {q}\\right): P = \\mathbf {g} ^ {\\mathbf {x}} h ^ {\\gamma}, y = L (\\mathbf {x}) \\right\\}, \\tag {1}</span></div>

    <p class="text-gray-300">where we use the following definition for the set of linear forms on  <span class="math">\\mathbb{Z}_q^n</span> .</p>

    <p class="text-gray-300">Definition 2. <span class="math">\\mathcal{L}\\left(\\mathbb{Z}_q^n\\right)\\coloneqq \\{(L:Z_q^n\\to \\mathbb{Z}_q):L</span> is a <span class="math">\\mathbb{Z}_q</span>-linear map\\}.</p>

    <p class="text-gray-300">Protocol 2, denoted by <span class="math">\\varPi_0</span>, shows a basic <span class="math">\\Sigma</span>-protocol for relation <span class="math">R</span>. <span class="math">\\varPi_0</span> was informally described in Section 1.2 (A). Theorem 1 shows that <span class="math">\\varPi_0</span> is indeed a special honest-verifier zero-knowledge (SHVZK) Proof of Knowledge (PoK). Both the communication costs from the prover <span class="math">\\mathcal{P}</span> to the verifier <span class="math">\\mathcal{V}</span> and vice versa are given. Note that in the non-interactive Fiat-Shamir [FS86] mode the communication costs from verifier to prover might be irrelevant.</p>

    <p class="text-gray-300">Theorem 1 (Basic Pivot). <span class="math">\\varPi_0</span> is a 3-move protocol for relation <span class="math">R</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: 1 element of <span class="math">\\mathbb{G}</span> and <span class="math">n + 2</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: 1 element of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">Protocol 2 <span class="math">\\Sigma</span>-protocol <span class="math">\\varPi_0</span> for relation <span class="math">R</span></p>

    <p class="text-gray-300"><span class="math">\\Sigma</span>-protocol to prove correctness of a linear form evaluation.</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span>, <span class="math">h \\in \\mathbb{G}</span></p>

    <p class="text-gray-300">INPUT <span class="math">(P, L, y; \\mathbf{x}, \\gamma)</span>  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | <span class="math">P = \\mathbf{g}^{\\mathbf{x}} h^{\\gamma} \\in \\mathbb{G}</span> |   |</p>

    <p class="text-gray-300">|   | <span class="math">y = L(\\mathbf{x}) \\in \\mathbb{Z}_q</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbf{r} \\leftarrow_R \\mathbb{Z}_q^n, \\rho \\leftarrow_R \\mathbb{Z}_q</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">t = L(\\mathbf{r})</span> |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">A = \\mathbf{g}^{\\mathbf{r}} h^{\\rho}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\xrightarrow{t, A}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbf{z} = c\\mathbf{x} + \\mathbf{r}</span> |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\phi = c\\gamma + \\rho</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\xrightarrow{\\mathbf{z}, \\phi}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | <span class="math">\\mathbf{g}^{\\mathbf{z}} h^{\\phi} \\stackrel{?}{=} AP^c</span>  |</p>

    <p class="text-gray-300">|   |  | <span class="math">L(\\mathbf{z}) \\stackrel{?}{=} cy + t</span>  |</p>

    <h2 id="sec-10" class="text-2xl font-bold">3.2 Amortization over Many Commitments</h2>

    <p class="text-gray-300">A standard amortization technique for <span class="math">\\Sigma</span>-protocols allows a prover to show correctness of <span class="math">s</span> evaluations of the linear form <span class="math">L</span> on <span class="math">s</span> committed vectors for essentially the costs of one evaluation. For details we refer to Appendix B.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 Compressing the Pivot</h2>

    <p class="text-gray-300">This section shows how Bulletproof techniques can be applied to compress our pivotal <span class="math">\\Sigma</span>-protocol <span class="math">\\varPi_0</span>, as mentioned in Section 1.2 (B). The key observation is that sending the final message <span class="math">\\widehat{\\mathbf{z}} := (\\mathbf{z}, \\phi) \\in \\mathbb{Z}_q^{n+1}</span> is actually a (trivial) proof of knowledge for the relation</p>

    <div class="my-4 text-center"><span class="math-block">R_1 = \\left\\{ \\left( \\widehat{P}, \\widehat{L}, \\widehat{y}; \\widehat{\\mathbf{z}} \\right) : \\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}} = \\widehat{P} \\wedge \\widehat{y} = \\widehat{L}(\\widehat{\\mathbf{z}}) \\right\\}, \\tag{2}</span></div>

    <p class="text-gray-300">where, with respect to relation <span class="math">R</span>, <span class="math">\\widehat{\\mathbf{g}}:=(g_{1},\\ldots,g_{n},h)\\in\\mathbb{G}^{n+1},\\widehat{P}:=AP^{c},\\widehat{y}:=cy+t</span> and <span class="math">\\widehat{L}(\\mathbf{z},\\phi):=L(\\mathbf{z})</span> for all <span class="math">(\\mathbf{z},\\phi)</span>. Another PoK would also suffice, in particular a PoK with a smaller communication complexity. Moreover, it is immaterial that the PoK is zero-knowledge as the original PoK clearly is not. In <em>[BCC^{+}16]</em> this observation was applied to Groth’s <span class="math">\\Sigma</span>-protocol <em>[x13]</em>. The main difference is that we start with linear form relation <span class="math">R</span>, whereas Groth’s <span class="math">\\Sigma</span>-protocol is for a specific quadratic relation.</p>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a PoK for relation <span class="math">R_{1}</span>. We call the new protocol obtained by replacing the final move of protocol <span class="math">\\Pi_{0}</span> by protocol <span class="math">\\Pi</span> the composition and write <span class="math">\\Pi\\diamond\\Pi_{0}</span>. Since <span class="math">\\Pi_{0}</span> is SHVZK it immediately follows that the composition is also SHVZK.</p>

    <p class="text-gray-300">The essence of Bulletproofs is a PoK, denoted by BP, with logarithmic communication complexity for the following inner product relation,</p>

    <p class="text-gray-300"><span class="math">R_{\\text{bullet}}=\\left\\{\\left(P\\in\\mathbb{G},u\\in\\mathbb{Z}_{q};\\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}_{q}^{n}\\right):P=\\mathbf{g}^{\\mathbf{a}}\\mathbf{h}^{\\mathbf{b}}\\wedge u=\\langle\\mathbf{a},\\mathbf{b}\\rangle\\right\\},</span> (3)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n}</span> are the public parameters. The quadratic relation <span class="math">R_{\\text{bullet}}</span> is quite similar to the relation <span class="math">R_{1}</span> and it turns out that minor adaptations of BP give a logarithmic size PoK for relation <span class="math">R_{1}</span>. We will now describe the components of the BP protocol, while simultaneously adapting these to our relation <span class="math">R_{1}</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.1 Reduction from Relation <span class="math">R_{1}</span> to Relation <span class="math">R_{2}</span></h3>

    <p class="text-gray-300">The first step of the BP PoK is to incorporate the linear form into the Pedersen vector commitment. For this step an additional generator <span class="math">k\\in\\mathbb{G}</span> is required such that the prover does not know a discrete log relation between the generators <span class="math">g_{1},\\ldots,g_{n},h,k</span>. More precisely, the problem of finding a proof for relation <span class="math">R_{1}</span> is reduced to the problem of finding a proof for relation</p>

    <p class="text-gray-300"><span class="math">R_{2}=\\left\\{\\left(Q\\in\\mathbb{G},\\widetilde{L}\\in\\mathcal{L}\\left(\\mathbb{Z}_{q}^{n+1}\\right);\\widehat{\\mathbf{z}}\\in\\mathbb{Z}_{q}^{n+1}\\right):Q=\\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}}k^{\\widetilde{L}(\\widehat{\\mathbf{z}})}\\right\\}.</span> (4)</p>

    <p class="text-gray-300">where, <span class="math">Q:=\\widehat{P}k^{\\widehat{y}}</span> and <span class="math">\\widetilde{L}:=c\\widehat{L}</span> for a random challenge <span class="math">c\\in\\mathbb{Z}_{q}</span> sampled by the verifier. The reduction is described in Protocol 3 and denoted by <span class="math">\\Pi_{1}</span>. Lemma 1 shows that <span class="math">\\Pi_{1}</span> is an argument of knowledge for relation <span class="math">R_{1}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{1}</span> is a <span class="math">2</span>-move protocol for relation <span class="math">R_{1}</span>. It is perfectly complete and computationally special sound, under the discrete logarithm assumption. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">n+1</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300">Special soundness: We show that there exists an efficient algorithm <span class="math">\\chi</span> that, on input two accepting transcripts, either extracts a witness for <span class="math">R_{1}</span>, or finds a non-trivial discrete log relation. So let <span class="math">(c_{1},\\widehat{\\mathbf{z}}_{1})</span> and <span class="math">(c_{2},\\widehat{\\mathbf{z}}_{2})</span> be two accepting transcripts with <span class="math">c_{1}\\neq c_{2}</span>, then <span class="math">\\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}_{1}-\\widehat{\\mathbf{z}}_{2}}k^{c_{1}\\widehat{L}(\\widehat{\\mathbf{z}}_{1})-c_{2}\\widehat{L}(\\widehat{\\mathbf{z}}_{2})}=k^{(c_{1}-c_{2})\\widehat{y}}</span>. Hence, either we have found a non-trivial discrete log relation, or <span class="math">\\widehat{\\mathbf{z}}_{1}=\\widehat{\\mathbf{z}}_{2}</span> and <span class="math">c_{1}\\widehat{L}(\\widehat{\\mathbf{z}}_{1})-c_{2}\\widehat{L}(\\widehat{\\mathbf{z}}_{2})=(c_{1}-c_{2})\\widehat{y}</span>. In the latter case, it follows that <span class="math">\\widehat{L}(\\widehat{\\mathbf{z}}_{1})=\\widehat{L}(\\widehat{\\mathbf{z}}_{2})=\\widehat{y}</span>. Moreover, from this it follows that <span class="math">\\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}_{1}}k^{c_{1}\\widehat{L}(\\widehat{\\mathbf{z}}_{1})}=\\widehat{P}k^{c_{1}\\widehat{y}}</span> which implies <span class="math">\\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}_{1}}=\\widehat{P}</span>. Hence, <span class="math">\\widehat{\\mathbf{z}}_{1}</span> is a witness for relation <span class="math">R_{1}</span>, which completes the proof.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.2 Logarithmic Size PoK for Linear Relation <span class="math">R_{2}</span></h3>

    <p class="text-gray-300">Next we deploy the main technique of the Bulletproof protocol to construct an efficient PoK for relation <span class="math">R_{2}</span>. For simplicity let us assume that <span class="math">n+1</span> is a power of <span class="math">2</span>. If this is not the case the vector can be appended with zeros. The protocol is recursive and in each iteration the dimension of the witness is halved until its dimension equals <span class="math">2</span>. We could add one additional step to the recursion and only send the response when the dimension equals <span class="math">1</span>. This would reduce the communication costs by one field element, but it would increase the number of group elements sent by the prover by <span class="math">2</span></p>

    <p class="text-gray-300">Protocol 3 Argument of Knowledge <span class="math">\\Pi_1</span> for <span class="math">R_1</span> Reduction from relation <span class="math">R_1</span> to relation <span class="math">R_2</span>.</p>

    <p class="text-gray-300">PUBLIC PARAMETERS: <span class="math">\\widehat{\\mathbf{g}} \\in \\mathbb{G}^{n+1}, k \\in \\mathbb{G}</span> INPUT(<span class="math">\\widehat{P}, \\widehat{L}, \\widehat{y}; \\widehat{\\mathbf{z}}</span>)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\widehat{P} = \\widehat{\\mathbf{g}}^{\\widehat{\\mathbf{z}}} \\in \\mathbb{G}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">c \\leftarrow_R \\mathbb{Z}_q</span>  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any even dimension <span class="math">m</span> and vector <span class="math">\\mathbf{g} \\in \\mathbb{G}^m</span>, we define <span class="math">\\mathbf{g}_L = (g_1, \\ldots, g_{m/2})</span> as its left half and <span class="math">\\mathbf{g}_R = (g_{m/2+1}, \\ldots, g_m)</span> as its right half. The same notation is used for vectors in <span class="math">\\mathbb{Z}_q^m</span>. For a linear form <span class="math">L: \\mathbb{Z}_q^m \\to \\mathbb{Z}_q</span>, we define</p>

    <div class="my-4 text-center"><span class="math-block">L_L: \\mathbb{Z}_q^{m/2} \\rightarrow \\mathbb{Z}_q, \\quad \\mathbf{x} \\mapsto L(\\mathbf{x}, 0), \\quad L_R: \\mathbb{Z}_q^{m/2} \\rightarrow \\mathbb{Z}_q, \\quad \\mathbf{x} \\mapsto L(0, \\mathbf{x}), \\tag{5}</span></div>

    <p class="text-gray-300">where <span class="math">(\\mathbf{x}, 0), (0, \\mathbf{x}) \\in \\mathbb{Z}_q^m</span> are the vectors <span class="math">\\mathbf{x}</span> appended with <span class="math">m/2</span> zeros on the right and left, respectively. Recall that the component-wise product between two vectors is denoted by <span class="math">*</span>.</p>

    <p class="text-gray-300">The compression is described in Protocol 4 and denoted by <span class="math">\\Pi_2</span>. Theorem 2 shows that protocol <span class="math">\\Pi_2</span> is a proof of knowledge for relation <span class="math">R_2</span>. Note that, in contrast to the compression mechanism of [BBB⁺18], protocol <span class="math">\\Pi_2</span> is unconditionally <span class="math">(3, \\ldots, 3)</span>-special sound.</p>

    <p class="text-gray-300">Theorem 2 (Compression Mechanism). <span class="math">\\Pi_2</span> is a <span class="math">(2\\mu + 1)</span>-move protocol for relation <span class="math">R_2</span>, where <span class="math">\\mu = \\lceil \\log_2(n + 1) \\rceil - 1</span>. It is perfectly complete and unconditionally <span class="math">(k_1, \\ldots, k_\\mu)</span>-special sound, where <span class="math">k_i = 3</span> for all <span class="math">1 \\leq i \\leq \\mu</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">2\\lceil \\log_2(n + 1) \\rceil - 2</span> elements of <span class="math">\\mathbb{G}</span> and 2 elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\lceil \\log_2(n + 1) \\rceil - 1</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness follows directly.</p>

    <p class="text-gray-300">Special soundness follows in a similar manner as it does for the amortized <span class="math">\\Sigma</span>-protocol of Theorem 9 (Appendix B). Namely, by the same "polynomial amortization trick" the commitments <span class="math">A</span>, <span class="math">Q</span>, <span class="math">B</span> are combined in a single commitment <span class="math">Q&#x27; := AQ^c B^{c^2}</span> where <span class="math">c</span> is a random challenge. Informally, if a prover can open commitment <span class="math">Q&#x27;</span>, it follows, with high probability, that a prover can open all three commitments <span class="math">A</span>, <span class="math">Q</span> and <span class="math">B</span>. For completeness we include the detailed proof.</p>

    <p class="text-gray-300">For simplicity we assume that we only run one of the recursive steps, i.e., we consider the 3-move variant of protocol <span class="math">\\Pi_2</span>, where the prover sends the response <span class="math">\\mathbf{z}&#x27;</span> regardless of its dimension, and we show that this protocol is 3-special sound. From there <span class="math">(3, \\ldots, 3)</span>-special soundness follows by an inductive argument of which we omit the details.</p>

    <p class="text-gray-300">So let us show that there exists an efficient algorithm <span class="math">\\chi</span> that, on input 3 accepting transcripts <span class="math">(A, B, c_1, \\mathbf{z}_1)</span>, <span class="math">(A, B, c_2, \\mathbf{z}_2)</span>, <span class="math">(A, B, c_3, \\mathbf{z}_3)</span>, with <span class="math">c_i \\neq c_j</span> for all <span class="math">i, j</span>, outputs a witness for relation <span class="math">R_2</span>. Given these transcripts let us define Vandermonde matrix</p>

    <div class="my-4 text-center"><span class="math-block">V = \\left( \\begin{array}{ccc} 1 &amp;amp; 1 &amp;amp; 1 \\\\ c_1 &amp;amp; c_2 &amp;amp; c_3 \\\\ c_1^2 &amp;amp; c_2^2 &amp;amp; c_3^2 \\end{array} \\right), \\tag{6}</span></div>

    <p class="text-gray-300">with <span class="math">\\operatorname{det}(V) = (c_3 - c_1)(c_3 - c_1)(c_3 - c_2)</span>. Since <span class="math">c_i \\neq c_j</span> for all <span class="math">i, j</span>, it follows that <span class="math">V</span> is invertible and that we can define</p>

    <div class="my-4 text-center"><span class="math-block">\\left(a_1 a_2 a_3\\right)^T := V^{-1} \\left(0 \\ 1 \\ 0\\right)^T. \\tag{7}</span></div>

    <p class="text-gray-300">Now it is easily seen that, for  <span class="math">\\bar{\\mathbf{z}} := \\left(\\sum_{i=1}^{3} a_i \\mathbf{z}_i, \\sum_{i=1}^{3} a_i c_i \\mathbf{z}_i\\right)</span> , it holds that  <span class="math">\\mathbf{g}^{\\bar{\\mathbf{z}}} k^{\\widetilde{L}(\\bar{\\mathbf{z}})} = Q</span> . Hence,  <span class="math">\\mathbf{z}</span>  is a witness for relation  <span class="math">R_2</span> , which proves the claim.</p>

    <p class="text-gray-300">Protocol 4 Compressed Proof of Knowledge  <span class="math">\\Pi_2</span>  for  <span class="math">R_2</span></p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g, k INPUT(Q, L; z) Q = g^z k^L(z)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A = g^z_R k^L_R(z_L) |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B = g^z_R k^L_L(z_R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A,B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c←R Z_q</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ←c |   |</p>

    <p class="text-gray-300">|   | g' := g^c_L * g_R ∈ G^{(n+1)/2} |   |</p>

    <p class="text-gray-300">|   | Q' := AQ^c B^c^2 |   |</p>

    <p class="text-gray-300">|   | L' := c^L_L + L_R |   |</p>

    <p class="text-gray-300">|  z' = z_L + c^z_R |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if (z' ∈ Z_q^2):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g')^z' k^L'(z') = Q'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_c</span>  for relation  <span class="math">R</span>  is the composition of the previously mentioned protocols, i.e.,  <span class="math">\\Pi_c \\coloneqq \\Pi_2 \\diamond \\Pi_1 \\diamond \\Pi_0</span> . For a graphical protocol description of  <span class="math">\\Pi_c</span>  we refer to Protocol 5. Theorem 3 shows that  <span class="math">\\Pi_c</span>  is indeed a SHVZK argument of knowledge for relation  <span class="math">R</span>  with a logarithmic communication complexity.</p>

    <p class="text-gray-300">Theorem 3 (Compressed Pivot).  <span class="math">\\Pi_c</span>  is a  <span class="math">(2\\mu + 3)</span> -move protocol for relation  <span class="math">R</span> , where  <span class="math">\\mu = \\lceil \\log_2(n + 1) \\rceil - 1</span> . It is perfectly complete, special honest-verifier zero-knowledge and computationally  <span class="math">(2, 2, k_1, \\ldots, k_\\mu)</span> -special sound, under the discrete logarithm assumption, where  <span class="math">k_i = 3</span>  for all  <span class="math">1 \\leq i \\leq \\mu</span> . Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">2\\lceil \\log_2(n + 1)\\rceil -1</span>  elements of  <span class="math">\\mathbb{G}</span>  and 3 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\lceil \\log_2(n + 1) \\rceil + 1</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness follows directly from the completeness of  <span class="math">\\Pi_0, \\Pi_1</span>  and  <span class="math">\\Pi_2</span> .</p>

    <p class="text-gray-300">SHVZK follows since  <span class="math">\\Pi_0</span>  is SHVZK. The simulator for  <span class="math">\\Pi_c</span>  namely runs the simulator for  <span class="math">\\Pi_0</span>  and continues with honest executions of  <span class="math">\\Pi_1</span>  and  <span class="math">\\Pi_2</span> .</p>

    <p class="text-gray-300">Special soundness follows from a straightforward combination of the extraction algorithms of protocols  <span class="math">\\Pi_0</span> ,  <span class="math">\\Pi_1</span>  and  <span class="math">\\Pi_2</span> .</p>

    <p class="text-gray-300">In a completely analogous manner, the amortized  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0^{\\mathrm{Am}}</span>  of Section 3.2 can be compressed. For the properties of the amortized and compressed  <span class="math">\\Sigma</span> -protocol we refer to Appendix B.</p>

    <p class="text-gray-300">Note that since protocol  <span class="math">\\varPi_{1}</span>  has computational soundness so does the compressed pivot  <span class="math">\\varPi_{c}</span> . In Appendix C we show two approaches for deriving an unconditionally sound compressed pivot.</p>

    <p class="text-gray-300">Protocol 5 Compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_c</span>  for relation  <span class="math">R</span></p>

    <p class="text-gray-300">Compressed  <span class="math">\\Sigma</span> -protocol to prove correctness of a linear form evaluation.</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g, h, k INPUT(P, L, y; x, γ)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P = g*hγ ∈ G y = L(x) ∈ Zq  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z = c0x + r φ = c0γ + ρ z := (z, φ)</td>

            <td class="px-3 py-2 border-b border-gray-700">c0, c1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A = ĝR^zL k^L_R(z_L) B = ĝR^zR k^L_L(z_R)</td>

            <td class="px-3 py-2 border-b border-gray-700">g := (g, h) Q := A P^{c0} k^{c1(c0y+t)} L(z, φ) := c1 L(z)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A, B</td>

            <td class="px-3 py-2 border-b border-gray-700">c←R Zq</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | c |   |</p>

    <p class="text-gray-300">|   | g' := ĝL^c * g_R ∈ G^{(n+1)/2} Q' := AQ^c B^{c^2} L' := cL_L + L_R |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z' = z_L + cz_R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g')^{z'} k^{L'}(z') = Q'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A straightforward adaptation of the compression techniques from Section 4 allows the round complexity of the compressed pivot to be reduced from logarithmic to constant. However, this reduction comes at the cost of increasing the communication complexity from  <span class="math">O(\\log(n))</span>  to  <span class="math">O(\\sqrt{n})</span>  elements. For more details on this trade-off we refer to Appendix D.</p>

    <p class="text-gray-300">From this point on, the only facts about the pivot that we need is that we have access to a compact vector commitment scheme that allows a prover to open arbitrary linear forms on multiple commitments. Hence, we assume black-box access to such a pivot. First, we treat the utility enhancements mentioned in Section 1.2 (A). Second, we describe the compactification techniques as discussed in Section 1.2 (C).</p>

    <p class="text-gray-300">We use the following notation. We write  <span class="math">[\\mathbf{x}]</span>  for a compact commitment to a vector  <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span> , and for a (public) linear form  <span class="math">L</span>  we write  <span class="math">\\Pi_{\\mathrm{OPEN}}([\\mathbf{x}], L; \\mathbf{x})</span>  for the interactive protocol that reveals  <span class="math">L(\\mathbf{x})</span>  and nothing else to the verifier. For completeness the diagram of  <span class="math">\\Pi_{\\mathrm{OPEN}}</span>  is depicted in Protocol 6. Recall that our notation  <span class="math">\\Pi_{\\mathrm{OPEN}}([\\mathbf{x}], L; \\mathbf{x})</span>  means that interactive protocol  <span class="math">\\Pi_{\\mathrm{OPEN}}</span>  takes as public input  <span class="math">[\\mathbf{x}]</span>  and  <span class="math">L</span>  and as prover's private input  <span class="math">\\mathbf{x}</span> . The communication costs of  <span class="math">\\Pi_{\\mathrm{OPEN}}</span>  are equal to the cost of the underlying interactive protocol  <span class="math">(\\Pi_c)</span>  plus 1 field element from  <span class="math">\\mathcal{P}</span>  to  <span class="math">\\mathcal{V}</span>  (the output of  <span class="math">L</span> ), unless of course the output is known in advance. Similarly, we write  <span class="math">\\Pi_{\\mathrm{OPEN}}([\\mathbf{x}_1], \\ldots, [\\mathbf{x}_s], L; \\mathbf{x}_1, \\ldots, \\mathbf{x}_s)</span>  for the (amortized) interactive protocol that exclusively reveals  <span class="math">L(\\mathbf{x}_i)</span>  for  <span class="math">1 \\leq i \\leq s</span>  to the verifier.</p>

    <p class="text-gray-300">At this point, the implementation details of the compact commitment scheme do not matter anymore. However, when we give soundness properties and communication costs it is implicitly assumed that  <span class="math">[\\cdot]</span>  is instantiated with Pedersen vector commitments and compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_c</span> .</p>

    <p class="text-gray-300">Protocol 6 Protocol  <span class="math">\\Pi_{\\mathrm{OPEN}}</span>  for Opening a Linear Form Evaluated in a Committed Vector The randomness and generators of the underlying commitment scheme  <span class="math">[\\cdot]</span>  are left implicit.</p>

    <p class="text-gray-300">|   | INPUT([x], L; x) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | OUTPUT(L(x)) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  y = L(x) |   |   |</p>

    <p class="text-gray-300">|   | Run Πc([x], L, y; x) |   |</p>

    <p class="text-gray-300">A "polynomial amortization trick" (known, e.g., from MPC) allows us to do many nullity checks on the committed vector  <span class="math">\\mathbf{x}</span>  without a substantial increase in complexity. Consider linear forms  <span class="math">L_{1},\\ldots ,L_{s}</span>  and suppose the prover claims that  <span class="math">L_{i}(\\mathbf{x}) = 0</span>  for  <span class="math">i = 1\\dots ,s</span> . The verifier then samples  <span class="math">\\rho \\in \\mathbb{Z}_q</span>  uniformly at random and asks the prover to open the linear form  <span class="math">L(\\mathbf{x})\\coloneqq \\sum_{i = 1}^{s}L_{i}(\\mathbf{x})\\rho^{i - 1}</span> , i.e., prover and verifier run  <span class="math">\\Pi_{\\mathrm{OPEN}}([\\mathbf{x}],L;\\mathbf{x})</span> . The opening of  <span class="math">L(\\mathbf{x})</span>  equals the evaluation of some polynomial of degree at most  <span class="math">s - 1</span> . If this polynomial is non-zero, it has at most  <span class="math">s - 1</span>  zero's. Hence,  <span class="math">L(\\mathbf{x}) = 0</span>  implies that  <span class="math">L_{i}(\\mathbf{x}) = 0</span>  for all  <span class="math">i</span>  with probability at least  <span class="math">1 - (s - 1) / q</span> . When  <span class="math">q</span>  is exponential and  <span class="math">s</span>  is polynomial in the security parameter this probability is exponentially close to 1. We write  <span class="math">\\Pi_{\\mathrm{NULLITY}}([\\mathbf{x}],L_1,\\dots ,L_s;\\mathbf{x})</span>  for this protocol. Its diagram is presented in Protocol 7. The communication costs are equal to the costs of a single nullity-check ( <span class="math">s = 1</span> ) plus one additional  <span class="math">\\mathbb{Z}_q</span>  element from  <span class="math">\\mathcal{V}</span>  to  <span class="math">\\mathcal{P}</span>  (the challenge  <span class="math">\\rho</span> ).</p>

    <p class="text-gray-300">The above discussion holds verbatim when we replace the linear forms by affine forms  <span class="math">\\varPhi_1,\\ldots,\\varPhi_s</span> , for which we also write  <span class="math">\\varPi_{\\mathrm{NULLITY}}([\\mathbf{x}],\\varPhi_1,\\ldots,\\varPhi_s;\\mathbf{x})</span> . Moreover, by the amortized and compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\varPi_c^{\\mathrm{Am}}</span>  these techniques directly carry over to the scenario where the prover makes the same nullity claims over many different commitments.</p>

    <p class="text-gray-300">Many ZK scenarios can be reduced to nullity-checks and, as such, the above utility enhancement is extremely powerful. As an often encountered example, we specifically mention the functionality of opening arbitrary affine maps  <span class="math">\\varPhi:\\mathbb{Z}_q^n\\to\\mathbb{Z}_q^s</span> <span class="math">\\mathbf{x}\\mapsto A\\mathbf{x} + b</span>  , at the cost of increasing the communication by exactly  <span class="math">s - 1</span>  values in  <span class="math">\\mathbb{Z}_q</span>  in comparison to opening one linear form (i.e., the evaluations of  <span class="math">s - 1</span>  additional outputs). Note that  <span class="math">\\varPhi</span>  is the combination of  <span class="math">s</span>  affine forms. The protocol goes as follows. The prover reveals the evaluation  <span class="math">\\mathbf{y} = \\varPhi (\\mathbf{x})</span>  followed by an amortized nullity-check on the affine forms  <span class="math">\\varPhi_{1}(\\mathbf{x})-y_{1},\\ldots,\\varPhi_{s}(\\mathbf{x})-y_{s}</span>  . For the interactive protocol that opens an affine map  <span class="math">\\varPhi</span>  we write  <span class="math">\\varPi_{\\mathrm{OPEN}}([\\mathbf{x}],\\varPhi;\\mathbf{x})</span></p>

    <p class="text-gray-300">Protocol 7 Amortized Protocol  <span class="math">\\Pi_{\\mathrm{NULLITY}}</span>  for Many Nullity Checks at Once The randomness and generators of the underlying commitment scheme  <span class="math">[\\cdot ]</span>  are left implicit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">INPUT([x],L1,...,Ls;x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  ←ρ  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L := ∑i=1sLiρi-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ←R Zq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Run Πc([x],L,0;x) |   |</p>

    <p class="text-gray-300">As before, this protocol directly carries over the scenario where a prover opens the evaluations of  <span class="math">\\varPhi</span>  on many committed vectors. The communications costs are only increased by the additional evaluations, i.e., the communication costs of the underlying compressed  <span class="math">\\Sigma</span> -protocol remain the same. Note that in this case amortization is applied twice. First, at the  <span class="math">\\Sigma</span> -protocol level, allowing many commitments to be considered. Second, only requiring black-box access to the pivotal  <span class="math">\\Sigma</span> -protocols, allowing many affine forms to be considered.</p>

    <p class="text-gray-300">So far, we have shown how to open many linear forms  <span class="math">L</span>  applied to a compactly committed secret vector  <span class="math">\\mathbf{x}</span>  with low complexity. Dealing with nonlinear functions of a secret-vector-of-interest  <span class="math">\\mathbf{x}</span>  will, as shown in Section 6, require that the prover, at the starting point, is also committed to a vector aux consisting of correlated secret randomness. As the method will consist of opening appropriate linear forms on the entire vector given by the pair  <span class="math">(\\mathbf{x},\\mathbf{aux})</span> , it will be assumed that the prover is committed to this pair via a single compact commitment.</p>

    <p class="text-gray-300">Now, from a practical application perspective, it is likely that the prover is already committed to  <span class="math">\\mathbf{x}</span>  before the start of a ZK proof. Consider, for example, the following two extreme cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: The prover is committed to  <span class="math">\\mathbf{x}</span>  in a single compact commitment. This scenario may be said to correspond to a "textbook" ZK setting.</li>

      <li>Case 2: The prover is committed to the coordinates of  <span class="math">\\mathbf{x}</span>  individually. This scenario is relevant in practical situations with a natural dynamic where provers deliver committed data in subsequent transactions and only periodically prove in ZK some property on the compound information.</li>

    </ul>

    <p class="text-gray-300">In order to deal with each of these scenarios, we need some further utility enhancements of the compressed pivot in order to bring about the desired starting point for the methods from Section 6, without too much loss in communication. It turns out that this is just a matter of "technology", i.e., plug and play with our compressed pivot and its basic theory suffices.</p>

    <p class="text-gray-300">Besides these extreme cases one can consider hybrid scenarios in which the secret-vector-of-interest  <span class="math">\\mathbf{x}</span>  is dispersed over various compact commitments. The methods described below both carry over to hybrid scenarios. The optimal approach depends on specific properties of the scenario. Namely, the communication complexity of the "Case 1 enhancement" is linear in the number of commitments, whereas the communication complexity of the "Case 2 enhancement" is linear in the (maximum) dimension of the committed vectors.</p>

    <p class="text-gray-300">Case 1. We describe a straightforward approach. We use the homomorphic property of Pedersen commitments. The prover has a compact commitment  <span class="math">P</span>  to  <span class="math">\\mathbf{x}</span> . Taking from the public set-up information a new set of generators disjoint from the initial set that, supposedly, underlies  <span class="math">P</span> , the prover creates a compact commitment  <span class="math">Q</span>  to  <span class="math">\\mathbf{aux}</span> . Eventually, the prover will set  <span class="math">P&#x27; := P \\cdot Q</span>  as the compact commitment to the secret pair  <span class="math">(\\mathbf{x}, \\mathbf{aux})</span> , a join. But, first, the prover must show that  <span class="math">\\mathbf{x}</span>  and  <span class="math">\\mathbf{aux}</span>  "live on disjoint sets of generators".</p>

    <p class="text-gray-300">his is just a nullity check, basically. The prover shows that, in <span class="math">P</span>, there is a window of zeros w.r.t. the new generators, i.e., each occurs to the power <span class="math">0</span>. Similarly for <span class="math">Q</span> but with a window of zeros w.r.t. the initial set of generators. By the methods for amortized nullity checks described earlier, this is handled with logarithmic communication. In fact, for the methods of Section 6 to work, it is easy to see that it suffices to perform the check on <span class="math">Q</span> only. However, since the methods of Section 6 would be applied serially, i.e., after the join above, this would incur a constant multiplicative factor <span class="math">2</span> loss in communication efficiency. We show how it can be done in parallel, thereby avoiding any such loss.</p>

    <p class="text-gray-300">The amortized pivot allows a prover to open one linear form on many compact commitments efficiently. By the amortized nullity checks a prover can open many linear forms on one compact commitments efficiently. Together these amortization techniques almost suffice, except that they force a prover to open linear forms “intended” for one particular commitment on other commitments as well; they reveal the cross-terms. Thus, to prevent a privacy breach, we need to mask these cross-terms appropriately and we do this by constructing a small shell around commitments containing sufficient randomness. Masking the appropriate cross-terms returns us to the “standard” amortization scenario where the prover wishes to open one affine map on multiple compact commitments. The shells cause unintended evaluations to return random values, whereas intended evaluations are left unaltered. For the details we refer to Appendix E.1.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Case 2.</h4>

    <p class="text-gray-300">In this case we describe a simple, single protocol that integrates the compactification of a vector of commitments to individual coordinates of <span class="math">\\mathbf{x}</span> together with a compact commitment to <span class="math">\\mathsf{aux}</span>. See Appendix E.2. for the details. Performing this integration in parallel with the methods of Section 6 is a straightforward application of the amortized nullity checks.</p>

    <h2 id="sec-24" class="text-2xl font-bold">6 Proving Nonlinear Relations via Arithmetic Circuits</h2>

    <p class="text-gray-300">Using our compressed pivot as a black-box, this section describes how to obtain efficient zero-knowledge arguments for arbitrary arithmetic circuits. We consider arithmetic circuits <span class="math">C</span> over <span class="math">\\mathbb{Z}_{q}</span> with <span class="math">n</span> inputs, <span class="math">s</span> outputs and <span class="math">m</span> multiplication gates. Addition and multiplication gates have fan-in <span class="math">2</span> and unbounded fan-out. The number of addition gates is immaterial, as is the number of gates for scalar multiplication. For this reason <span class="math">m</span> only refers to the multiplication gates that take two variable inputs. We fix an ordering <span class="math">1,\\ldots,n</span> of the inputs and an ordering <span class="math">1,\\ldots,m</span> of the multiplication gates.</p>

    <p class="text-gray-300">The approach is to combine the compressed pivot with an adaptation of the work of <em>[x10]</em> that shows how to prove arbitrary constraints on vectors of committed elements by exploiting techniques from secure multi-party computation. Concretely, we use the ideas underlying the Commitment Multiplication Protocol from <em>[x11]</em>. A detailed overview of the approach has been given in Section 1.2 (D). Here, we summarize the key points and formalize the main properties of the resulting protocols.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">6.1 Basic Circuit Satisfiability</h3>

    <p class="text-gray-300">First, we consider the basic circuit satisfiability scenario in which a prover shows that it knows an input <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> for which the arithmetic circuit <span class="math">C</span> evaluates to <span class="math">0</span>. More precisely, we construct a ZK protocol for the following circuit satisfiability relation:</p>

    <p class="text-gray-300"><span class="math">R_{cs}=\\{(C;\\mathbf{x}):C(\\mathbf{x})=0\\}.</span> (8)</p>

    <p class="text-gray-300">Our approach follows the commit and prove paradigm, i.e., the prover commits to the witness <span class="math">\\mathbf{x}</span> and subsequently proves that it satisfies the required relation. The terminology circuit satisfiability seems to suggest that we are only considering circuits for which it is hard to compute a satisfying witness <span class="math">\\mathbf{x}</span>. However, many practical scenarios consider circuits <span class="math">C</span> for which it is easy to compute an <span class="math">\\mathbf{x}</span> such that <span class="math">C(\\mathbf{x})=0</span>. In</p>

    <p class="text-gray-300">these scenarios the arithmetic circuit allows the prover to show that a committed vector satisfies certain properties.</p>

    <p class="text-gray-300">If <span class="math">C</span> is an affine map, i.e., without multiplication gates, the protocol follows directly from the (enhanced) functionality of our pivot. Namely, the prover commits to <span class="math">\\mathbf{x}</span> and runs <span class="math">\\Pi_{\\textsc{nullty}}([\\mathbf{x}],C;\\mathbf{x})</span>. Hence, addition gates and scalar multiplications, are implicitly handled since our pivot allows the opening of arbitrary linear forms.</p>

    <p class="text-gray-300">Multiplication gates are handled by an appropriate adaptation of the techniques from <em>[x11]</em>. Their primary result is a <span class="math">\\Sigma</span>-protocol showing correctness of <span class="math">m</span> multiplication triples <span class="math">(\\alpha_{i},\\beta_{i},\\gamma_{i})</span>. First, we recall the adaptation of their approach that uses our compressed pivot as a black-box. See also the first observation made in Section 1.2 (D). The protocol goes as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover selects a random polynomial <span class="math">f(X)\\in\\mathbb{Z}_{q}[X]_{\\leq m}</span> that defines a packed secret sharing of the vector <span class="math">(\\alpha_{1},\\ldots,\\alpha_{m})</span>. The prover also selects a random polynomial <span class="math">g(X)\\in\\mathbb{Z}_{q}[X]_{\\leq m}</span> that defines a packed secret sharing of the vector <span class="math">(\\beta_{1},\\ldots,\\beta_{m})</span>. Finally, the prover computes the product polynomial <span class="math">h(X):=f(X)g(X)</span> of degree <span class="math">\\leq 2m&lt;q</span>.</li>

      <li>The prover commits to the vector</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\alpha_{1},\\ldots,\\alpha_{m},\\beta_{1},\\ldots,\\beta_{m},f(0),g(0),h(0),h(1),\\ldots,h(2m))\\in\\mathbb{Z}_{q}^{4m+3}</span></p>

    <p class="text-gray-300">in a single compact commitment and sends the commitment to the verifier. Note that, by Lagrange interpolation, the polynomials <span class="math">f(X)</span>, <span class="math">g(X)</span> and <span class="math">h(X)</span> are uniquely defined by the vector <span class="math">\\mathbf{y}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier selects a random challenge <span class="math">c\\in\\mathbb{Z}_{q}</span> distinct from <span class="math">1,\\ldots,m</span> and sends it to the prover.</li>

      <li>Public linear combinations of the coefficients of <span class="math">\\mathbf{y}</span> define three values: <span class="math">u:=f(c)</span>, <span class="math">v:=g(c)</span> and <span class="math">w:=h(c)</span>. These values are opened and the verifier checks whether <span class="math">w=uv</span>. A cheating prover is caught with probability greater than <span class="math">1-2m/(q-m)</span> and honest-verifier zero-knowledge essentially follows from 1-privacy of the secret sharing scheme.</li>

    </ul>

    <p class="text-gray-300">Now we adapt this approach to the circuit satisfiability scenario, where we let <span class="math">C:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}^{s}</span> be an arbitrary arithmetic circuits with <span class="math">m</span> multiplication gates. We use a simple fact about a circuit <span class="math">C</span>. Consider the computation graph induced by evaluation at input-vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>. Write <span class="math">\\gamma_{1},\\ldots,\\gamma_{m}\\in\\mathbb{Z}_{q}</span> for the resulting outputs of the multiplication gates. For each <span class="math">i</span>, write <span class="math">(\\alpha_{i},\\beta_{i})\\in\\mathbb{Z}_{q}^{2}</span> for the resulting inputs to the <span class="math">i</span>-th multiplication gate. Finally, write <span class="math">\\omega\\in\\mathbb{Z}_{q}^{s}</span> for the resulting output of the circuit. Then, for each <span class="math">i</span>, there are affine forms <span class="math">u_{i},v_{i}:\\mathbb{Z}_{q}^{n+m}\\to\\mathbb{Z}_{q}</span>, depending only on <span class="math">C</span>, such that, for all <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>, it holds that <span class="math">\\alpha_{i}=u_{i}(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})</span> and <span class="math">\\beta_{i}=v_{i}(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})</span>. These forms are uniquely determined by the addition and scalar multiplication gates. Similarly, there is an affine function <span class="math">w:\\mathbb{Z}_{q}^{n+m}\\to\\mathbb{Z}_{q}^{s}</span> such that, for all <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>, it holds that <span class="math">\\omega=w(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})</span>. In other words, a given pair <span class="math">(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}^{m}</span> can be completed to an accepting computation graph if and only if <span class="math">u_{i}(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})\\cdot v_{i}(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})=\\gamma_{i}</span> (for <span class="math">i=1,\\ldots,m</span>) and <span class="math">w(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})=0</span>.</p>

    <p class="text-gray-300">The vector <span class="math">\\mathbf{y}</span>, from the above multiplication-triples approach, is now adapted as follows. The prover includes the input vector <span class="math">\\mathbf{x}</span>. However, the <span class="math">\\alpha_{i}</span>’s and the <span class="math">\\beta_{i}</span>’s are omitted from <span class="math">\\mathbf{y}</span>. Otherwise, the vector <span class="math">\\mathbf{y}</span> is unchanged. In particular,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\mathbf{x},f(0),g(0),h(0),h(1),\\ldots,h(2m))\\in\\mathbb{Z}_{q}^{n+2m+3}</span></p>

    <p class="text-gray-300">and <span class="math">(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m}):=(\\mathbf{x},h(1),\\ldots,h(m))</span> is a subvector of <span class="math">\\mathbf{y}</span>. Subsequently, the prover compactly commits to this adapted vector <span class="math">\\mathbf{y}</span>. By the handle discussed above, the prover needs to convince the verifier that (1) <span class="math">w(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})=0</span>, and that (2) <span class="math">\\alpha_{i}\\cdot\\beta_{i}=\\gamma_{i}</span> for all <span class="math">1\\leq i\\leq m</span>. The <span class="math">\\alpha_{i}</span>’s and <span class="math">\\beta_{i}</span>’s are now taken as the evaluation at <span class="math">(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})</span> of the affine functions <span class="math">u_{i},v_{i}</span> introduced above. Note that we may capture all these as affine functions evaluated at <span class="math">\\mathbf{y}</span>.</p>

    <p class="text-gray-300">As for (1), checking that <span class="math">w(\\mathbf{x},\\gamma_{1},\\ldots,\\gamma_{m})=0</span> is just a nullity check as provided by the pivot. As for (2), the polynomials <span class="math">f(X)</span>, <span class="math">g(X)</span> are still well-defined by the prover’s compact commitment to <span class="math">\\mathbf{y}</span>. Namely,</p>

    <p class="text-gray-300"><span class="math">\\rho:=f(0)</span>, i.e., the randomness underlying its selection, is still included in <span class="math">\\mathbf{y}</span>. As the <span class="math">\\alpha_{i}</span>’s thus defined are affine functions of <span class="math">\\mathbf{y}</span>, the prover is still (implicitly) committed to a polynomial <span class="math">f(X)</span> of degree <span class="math">\\leq m</span> such that <span class="math">f(0)=\\rho</span> and <span class="math">f(i)=\\alpha_{i}</span> (<span class="math">i=1,\\ldots,m</span>) and evaluation of <span class="math">f(X)</span> in a point <span class="math">c</span> is still, by composition of appropriate maps, an affine evaluation at <span class="math">\\mathbf{y}</span>, as enabled by the pivot. Since <span class="math">\\rho^{\\prime}:=g(0)</span> is also still included in <span class="math">\\mathbf{y}</span>, a similar conclusion is drawn about the <span class="math">\\beta_{i}</span>’s, <span class="math">g(X)</span>, and evaluation of the latter. As no changes with respect to <span class="math">h(X)</span> were made in <span class="math">\\mathbf{y}</span>, we conclude that the required check can be performed in the same way as before.</p>

    <p class="text-gray-300">The costs of the different openings are reduced by applying the amortized nullity checks of Section 5.1. In fact, the communication costs are independent of the number of outputs <span class="math">s</span>.</p>

    <p class="text-gray-300">The protocol is formally described in Protocol 8 and denoted by <span class="math">\\Pi_{cs}</span>. Protocol <span class="math">\\Pi_{cs}</span> only requires black-box access to the commitment scheme <span class="math">[\\cdot]</span>. For notational convenience, we write</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\textsc{nullity}}\\left([\\mathbf{y}],C(\\mathbf{x}),f(c)-y_{1},g(c)-y_{2},h(c)-y_{3};\\mathbf{y}\\right)</span> (9)</p>

    <p class="text-gray-300">for the amortized nullity check on the affine forms associated to the <span class="math">s+3</span> coefficients of <span class="math">(C(\\mathbf{x}),f(c)-z_{1},g(c)-z_{2},h(c)-z_{3})</span>.</p>

    <p class="text-gray-300">Theorem 4 shows that, when <span class="math">[\\cdot]</span> is instantiated with Pedersen vector commitments and compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span>, <span class="math">\\Pi_{cs}</span> is a SHVZK argument of knowledge for relation <span class="math">R_{cs}</span>. The theorem also shows that the special soundness property depends on the number of multiplication gates in the circuit. If the circuit size is polynomial in the security parameter and <span class="math">q</span> is exponential, then witness extended emulation follows from the special soundness property of <span class="math">\\Pi_{cs}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 4 (Basic Circuit ZK).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{cs}</span> is a <span class="math">(2\\mu+7)</span>-move protocol for the circuit relation <span class="math">R_{cs}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(n+2m+4)\\rceil-1</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(2m+1,s+3,2,2,k_{1},\\ldots,k_{\\mu})</span>-special sound, under the discrete logarithm assumption, where <span class="math">k_{i}=3</span> for all <span class="math">1\\leq i\\leq\\mu</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}</span>: <span class="math">2\\lceil\\log_{2}(n+2m+4)\\rceil</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">6</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\rightarrow\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}(n+2m+4)\\rceil+3</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300">Special soundness: By Lagrange interpolation there exists an efficient algorithm to reconstruct a polynomial of degree <span class="math">t</span> given <span class="math">t+1</span> evaluations. Hence, the packed secret sharing and the amortized nullity-checks are <span class="math">(2m+1)</span>-special sound and <span class="math">(s+3)</span>-special sound, respectively. The soundness in these steps is computational, i.e., it is essential that the prover does not know a non-trivial discrete log relation. The special soundness claim now from the properties of protocol <span class="math">\\Pi_{c}</span>.</p>

    <p class="text-gray-300">SHVZK follows from 1-privacy of the secret sharing scheme and the fact that <span class="math">\\Pi_{c}</span> is SHVZK.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.2 Circuit ZK from Compactification</h3>

    <p class="text-gray-300">Thus far, we have restricted ourselves to the basic circuit satisfiability scenario where the prover commits to all input and auxiliary data at once. However, there is a great variety of other scenarios, where the circuit takes as input committed values. As in Section 5.3 we consider two extreme cases for circuit ZK:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1. Prove that <span class="math">C(\\mathbf{x})=0</span> for a vector commitment <span class="math">[\\mathbf{x}]</span> with <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>.</li>

      <li>Case 2. Prove that <span class="math">C(x_{1},\\ldots,x_{n})=0</span> for commitments <span class="math">[x_{i}]</span> with <span class="math">x_{i}\\in\\mathbb{Z}_{q}</span> for all <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">These cases are dealt with by compactifying the commitments into a single compact commitment to all relevant data. The resulting protocol for Case 1 is denoted by <span class="math">\\Pi_{cs}^{(1)}</span> with corresponding relation <span class="math">R_{cs}^{(1)}</span> and its properties are given by Theorem 5. Recall that we consider arithmetic circuits <span class="math">C</span> over <span class="math">\\mathbb{Z}_{q}</span> with <span class="math">n</span> input, <span class="math">s</span> output and <span class="math">m</span> multiplication gates.</p>

    <p class="text-gray-300">Protocol 8 Circuit Satisfiability Argument  <span class="math">\\Pi_{cs}</span>  for Relation  <span class="math">R_{cs}</span></p>

    <p class="text-gray-300">The polynomials  <span class="math">f</span>  and  <span class="math">g</span>  are sampled uniformly at random such that their evaluations in  <span class="math">1, \\ldots, m</span>  coincide with the left and, respectively, right inputs of the  <span class="math">m</span>  multiplication gates of  <span class="math">C</span>  evaluated at  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">Theorem 5 (Circuit ZK Case 1).  <span class="math">\\Pi_{cs}^{(1)}</span>  is a  <span class="math">(2\\mu +9)</span> -move protocol for circuit relation  <span class="math">R_{cs}^{(1)}</span> , where  <span class="math">\\mu = \\lceil \\log_2(n + 2m + 6)\\rceil -1</span> . It is perfectly complete, special honest-verifier zero-knowledge and computationally  <span class="math">(2m + 1,\\max (n,s + 3) + 1,2,2,3,2,k_1,\\ldots ,k_\\mu)</span> -special sound, under the discrete logarithm assumption, where  <span class="math">k_{i} = 3</span>  for all  <span class="math">1\\leq i\\leq \\mu</span> . Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">2\\lceil \\log_2(n + 2m + 6)\\rceil +4</span>  elements of  <span class="math">\\mathbb{G}</span>  and 12 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\lceil \\log_2(n + 2m + 6) \\rceil + 5</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">The protocol for Case 2 is denoted by  <span class="math">\\Pi_{cs}^{(2)}</span>  with corresponding relation  <span class="math">R_{cs}^{(2)}</span>  and its properties are given by Theorem 6. Note that in this case we can restrict ourselves to  <span class="math">n \\leq 2m</span> . For if  <span class="math">n</span>  is larger than the number of inputs to multiplication gates there must exist linear reductions that can be applied directly to the Pedersen commitments  <span class="math">[x_i]</span>  using its homomorphic properties. Therefore, the communication costs from prover to verifier are upper-bounded by  <span class="math">2\\lceil \\log_2(4m + 5)\\rceil +9 \\leq 2\\lceil \\log_2(m + 2)\\rceil +13</span>  elements. Bulletproofs achieve a communication cost of  <span class="math">2\\lceil \\log (m)\\rceil +13</span>  elements. Hence, perhaps surprisingly, our plug-and-play approach almost never increases the communication costs.</p>

    <p class="text-gray-300">Theorem 6 (Circuit ZK Case 2).  <span class="math">\\Pi_{cs}^{(2)}</span>  is a  <span class="math">(2\\mu +7)</span> -move protocol for circuit relation  <span class="math">R_{cs}^{(2)}</span> , where  <span class="math">\\mu = \\lceil \\log_2(n + 2m + 5)\\rceil -1</span> . It is perfectly complete, special honest-verifier zero-knowledge and computationally  <span class="math">(2m + 1,n + 1,s + 4,2,2,k_1,\\ldots ,k_\\mu)</span> -special sound, under the discrete logarithm assumption, where  <span class="math">k_{i} = 3</span>  for all  <span class="math">1\\leq i\\leq \\mu</span> . Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">2\\lceil \\log_2(n + 2m + 5)\\rceil +1</span>  elements of  <span class="math">\\mathbb{G}</span>  and 8 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\lceil \\log_2(n + 2m + 5) \\rceil + 4</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">In a range proof a prover wishes to show that a secret committed integer  <span class="math">v</span>  is in a public range, say  <span class="math">[0, 2^{n-1}]</span> . For our range proofs, we invoke the circuit ZK protocols of Section 6 in a black-box manner and thereby</p>

    <p class="text-gray-300">achieve a conceptual simplification of earlier solutions such as those in <em>[BCC^{+}16, BBB^{+}18]</em>. Note that this black-box approach for range proofs can also be instantiated from the circuit ZK protocols of (e.g.) <em>[BCC^{+}16]</em> and <em>[BBB^{+}18]</em>. For details we refer to Appendix F.</p>

    <h2 id="sec-30" class="text-2xl font-bold">8 Our Program from the Strong-RSA Assumption</h2>

    <p class="text-gray-300">In this section we describe how our program can be based on Strong-RSA derived assumptions, as mentioned in Section 1.2 (F). We treat the main differences and refer to Appendix G and <em>[x1]</em> for more details.</p>

    <p class="text-gray-300">A disadvantage of the Pedersen vector commitment scheme is the number of generators required. In fact, to commit to an <span class="math">n</span>-dimensional vector, <span class="math">n+1</span> generators of the group <span class="math">\\mathbb{G}</span> are required. Moreover, the compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span> has a verification time that is linear in the dimension <span class="math">n</span>.</p>

    <p class="text-gray-300">Alternatively, vector commitment schemes can be constructed via integer commitment schemes <em>[x10, x12]</em>. A commitment to the vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> is then a commitment to an integer representation <span class="math">\\widehat{\\mathbf{x}}\\in\\mathbb{Z}</span> of <span class="math">\\mathbf{x}</span>. The integer commitment schemes of <em>[x10, x12]</em> are constructed by using groups <span class="math">\\mathbb{G}</span> of unknown order.</p>

    <p class="text-gray-300">This is precisely the approach followed in a recent work of Bünz, Fisch and Szepieniec <em>[x1]</em>. They construct a polynomial commitment scheme allowing a prover to commit to a polynomial <span class="math">f\\in\\mathbb{Z}_{q}[X]</span> of arbitrary degree, via a unique integer representation of its coefficient vector. A commitment to such a representation only requires two group elements <span class="math">g,h\\in\\mathbb{G}</span>.</p>

    <p class="text-gray-300">The work of <em>[x1]</em> shows how to open arbitrary evaluations <span class="math">f(a)\\in\\mathbb{Z}_{q}</span> of a committed polynomial without revealing any additional information about <span class="math">f</span>. Their polynomial evaluation protocol uses recursive techniques similar to those used in Bulletproofs. This approach results in a logarithmic communication complexity. In addition, <em>[x1]</em> deploys Proofs of Exponentiation (PoE) <em>[x24]</em> to achieve logarithmic verification time.</p>

    <p class="text-gray-300">Their work refers to generic constructions that can be used to obtain more general ZK protocols from polynomial commitment schemes. However, we argue that these constructions are overly complicated and that a stronger functionality (vector commitment scheme with linear form openings) avoids many difficulties in the design of ZK protocols. Moreover, it turns out that the protocols of <em>[x1]</em> only require minor adaptations to accommodate this stronger functionality. From this, an instantiation of the black-box functionality of Section 5 is derived, now based on the hardness assumptions related to the Strong-RSA assumption <em>[x3]</em>. The techniques of Section 6 and Section 7 directly apply, and the higher level applications inherit the logarithmic communication and computation complexity of the vector commitment scheme. The compactification methods of Section 5.3 are tailored to Pedersen (vector) commitments. Minor modifications are required to adapt these techniques to the Strong-RSA setting.</p>

    <h2 id="sec-31" class="text-2xl font-bold">9 Our Program from the KEA</h2>

    <p class="text-gray-300">If one desires our program can also be instantiated from the the Knowledge-of-Exponent Assumption (KEA), i.e., we construct a KEA based vector commitment scheme with compact linear form openings. The techniques from Section 6 apply as before, resulting in ZK protocols for arbitrary arithmetic circuits. Basing our program on KEA reduces communication complexity from logarithmic to <em>constant</em>. The protocols do require a trusted setup that depends on the arithmetic circuit under consideration.</p>

    <p class="text-gray-300">We stress that KEA is of a different nature than the DL or strong-RSA assumption. KEA is not an intractability assumption and it is unfalsifiable <em>[x21, x2]</em>. For these reasons, its application is not completely without controversy.</p>

    <p class="text-gray-300">We now, informally, describe the main components of the KEA based vector commitment scheme together with its ZK protocol for opening linear forms. Our approach uses the techniques of <em>[x13]</em> and only minor adaptations are required.</p>

    <p class="text-gray-300">A compact commitment to a vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> is, as before, a Pedersen vector commitment <span class="math">P=h^{\\gamma}\\mathbf{g}^{\\mathbf{x}}</span>. A ZKPoK for knowing an opening to <span class="math">P</span> is another Pedersen commitment <span class="math">P^{\\prime}</span> to <span class="math">\\mathbf{x}</span>, under the same randomness <span class="math">\\gamma</span>, using a different set of generators <span class="math">h^{\\prime}:=h^{\\alpha},g_{1}^{\\prime}:=g_{1}^{\\alpha},\\ldots,g_{n}^{\\prime}:=g_{n}^{\\alpha}</span>. The value <span class="math">\\alpha\\in\\mathbb{Z}_{q}</span> is sampled uniformly</p>

    <p class="text-gray-300">at random in the trusted setup phase and is only shared with a designated verifier. Both sets of generators are public and part of the common reference string. The proof <span class="math">P^{\\prime}</span> is verified by checking that <span class="math">P^{\\prime}=P^{\\alpha}</span>.</p>

    <p class="text-gray-300">The Knowledge-of-Exponent Assumption states that an adversary capable of computing pairs <span class="math">(P,P^{\\prime})</span> with <span class="math">P^{\\prime}=P^{\\alpha}</span>, either knows <span class="math">\\alpha</span> or an opening to <span class="math">P</span>. From this assumption knowledge soundness follows. Correctness and zero-knowledge are immediate. Note that the resulting ZKPoK is non-interactive and its size is independent of the dimension <span class="math">n</span>.</p>

    <p class="text-gray-300">Given a bilinear pairing <span class="math">e:\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{T}</span> the verification can be done without knowledge of <span class="math">\\alpha</span>, eliminating the restriction to a designated verifier. In this case verification amounts to checking that <span class="math">e(P,h^{\\prime})=e(h,P^{\\prime})</span>.</p>

    <p class="text-gray-300">To prove that the committed vector <span class="math">\\mathbf{x}</span> satisfies a linear form relation <span class="math">L(\\mathbf{x})=u</span>, the generators are taken of a specific form. More precisely, the generators are sampled under the condition that <span class="math">g_{i}=h^{\\beta^{i}}</span>, for some secret <span class="math">\\beta\\in\\mathbb{Z}_{q}</span>, for all <span class="math">1\\leq i\\leq n</span>. The associated KEA derived assumption is the <span class="math">n</span>-power Knowledge-of-Exponent Assumption (<span class="math">n</span>-PKEA).</p>

    <p class="text-gray-300">Groth showed that, using this additional structure, together with the bilinear pairing, efficient circuit ZK protocols exist <em>[x11]</em>. His protocols are easily adapted to our situation, where we simply wish to prove correctness of a linear form evaluation. The adaptation relies on the following observation. Suppose that <span class="math">\\mathbf{a}=(a_{1},\\ldots,a_{n})\\in\\mathbb{Z}_{q}^{n}</span> is such that <span class="math">L(\\mathbf{z})=\\langle\\mathbf{a},\\mathbf{z}\\rangle</span> for all <span class="math">\\mathbf{z}\\in\\mathbb{Z}_{q}^{n}</span>, and let us define the following polynomials:</p>

    <p class="text-gray-300"><span class="math">f(Y):=\\gamma+\\sum_{i=1}^{n}x_{i}Y^{i},\\quad g(Y):=\\sum_{i=0}^{n-1}a_{n-i}Y^{i},\\quad h(Y):=f(Y)g(Y)=\\sum_{i=0}^{2n-1}c_{i}Y^{i}.</span></p>

    <p class="text-gray-300">The <span class="math">n</span>-th coefficient of <span class="math">h(Y)</span> equals <span class="math">c_{n}=\\langle\\mathbf{x},\\mathbf{a}\\rangle=L(\\mathbf{x})</span>. This observation allows for a straightforward adaptation of the product argument in <em>[x11, Section 6]</em> , resulting in a constant size ZKPoK for the correctness of a linear form evaluation. We omit further details and refer the reader to <em>[x11]</em>.</p>

    <p class="text-gray-300">For circuit ZK protocols we apply the techniques from Section 6 to linearize the non-linearities in a black-box manner. In contrast, other KEA based approaches use a protocol for proving quadratic relations as their main pivot and translate arithmetic circuit relations to so called quadratic span programs or QSPs <em>[x10, x11]</em>. This translation, also called arithmetization, is not required when applying our linearization techniques. However, in contrast to other KEA based protocols, the linearization techniques render our solution interactive (although in a setting where Fiat-Shamir applies). Additionally, we note that this approach achieves constant verification complexity, in contrast to the linear complexity of the DL based approach, i.e., our KEA based protocol is a ZK-SNARK.</p>

    <h2 id="sec-32" class="text-2xl font-bold">10 Acknowledgements</h2>

    <p class="text-gray-300">We thank Serge Fehr, Toon Segers and Thijs Veugen for extensive commenting at an early stage. We also thank Jens Groth for useful editorial comments and pointers. We are grateful for a comment by Michael Klooß that our exact analysis of knowledge error is only meaningful for a portion of the full parameter space relevant to our application. Thomas Attema has been supported by EU H2020 project No 780701 (PROMETHEUS). Ronald Cramer has been supported by ERC ADG project No 74079 (ALGSTRONGCRYPTO) and by the NWO Gravitation project QSC.</p>

    <h2 id="sec-33" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACF20] Thomas Attema, Ronald Cramer, and Serge Fehr. Compressing proofs of <span class="math">k</span>-out-of-<span class="math">n</span>-partial knowledge. IACR Cryptol. ePrint Arch., 2020:753, 2020.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society, 2018.</li>

      <li>[BCC^{+}15] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Essam Ghadafi, Jens Groth, and Christophe Petit. Short accountable ring signatures based on DDH. In ESORICS (1), volume 9326 of Lecture Notes in Computer Science, pages 243–265. Springer, 2015.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 327–357. Springer, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BCPR14. Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In STOC, pages 505–514. ACM, 2014.</li>

      <li>BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent snarks from DARK compilers. In EUROCRYPT (1), volume 12105 of Lecture Notes in Computer Science, pages 677–706. Springer, 2020.</li>

      <li>BG92. Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In CRYPTO, volume 740 of Lecture Notes in Computer Science, pages 390–420. Springer, 1992.</li>

      <li>BLNS20. Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. A non-pcp approach to succinct quantum-safe zero-knowledge. IACR Cryptol. ePrint Arch., page 737, 2020.</li>

      <li>BN06. Mihir Bellare and Gregory Neven. Multi-signatures in the plain public-key model and a general forking lemma. In ACM Conference on Computer and Communications Security, pages 390–399. ACM, 2006.</li>

      <li>BP97. Niko Baric and Birgit Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In EUROCRYPT, volume 1233 of Lecture Notes in Computer Science, pages 480–494. Springer, 1997.</li>

      <li>CDM00. Ronald Cramer, Ivan Damgård, and Ueli M. Maurer. General secure multi-party computation from any linear secret-sharing scheme. In EUROCRYPT, volume 1807 of Lecture Notes in Computer Science, pages 316–334. Springer, 2000.</li>

      <li>CDN15. Ronald Cramer, Ivan Damgård, and Jesper Buus Nielsen. Secure Multiparty Computation and Secret Sharing. Cambridge University Press, 2015.</li>

      <li>CDP12. Ronald Cramer, Ivan Damgård, and Valerio Pastro. On the amortized complexity of zero knowledge protocols for multiplicative relations. In ICITS, volume 7412 of Lecture Notes in Computer Science, pages 62–79. Springer, 2012.</li>

      <li>CDS94. Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO, volume 839 of Lecture Notes in Computer Science, pages 174–187. Springer, 1994.</li>

      <li>Cra96. Ronald Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</li>

      <li>Dam10. Ivan Damgård. On sigma-protocols. Lecture Notes, Aarhus University, Department of Computer Science, 2010.</li>

      <li>DF02. Ivan Damgård and Eiichiro Fujisaki. A statistically-hiding integer commitment scheme based on groups with hidden order. In ASIACRYPT, volume 2501 of Lecture Notes in Computer Science, pages 125–142. Springer, 2002.</li>

      <li>FO97. Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In CRYPTO, volume 1294 of Lecture Notes in Computer Science, pages 16–30. Springer, 1997.</li>

      <li>FS86. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.</li>

      <li>GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT, volume 7881 of Lecture Notes in Computer Science, pages 626–645. Springer, 2013.</li>

      <li>GK15. Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In EUROCRYPT (2), volume 9057 of Lecture Notes in Computer Science, pages 253–280. Springer, 2015.</li>

      <li>Gro09. Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO, volume 5677 of Lecture Notes in Computer Science, pages 192–208. Springer, 2009.</li>

      <li>Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, volume 6477 of Lecture Notes in Computer Science, pages 321–340. Springer, 2010.</li>

      <li>Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 305–326. Springer, 2016.</li>

      <li>GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint Arch., 2019:953, 2019.</li>

      <li>HKR19. Max Hoffmann, Michael Klooß, and Andy Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In ACM Conference on Computer and Communications Security, pages 2093–2110. ACM, 2019.</li>

      <li>HM98. Shai Halevi and Silvio Micali. More on proofs of knowledge. IACR Cryptol. ePrint Arch., 1998:15, 1998.</li>

      <li>JM20. Aram Jivanyan and Tigran Mamikonyan. Hierarchical one-out-of-many proofs with applications to blockchain privacy and ring signatures. IACR Cryptol. ePrint Arch., 2020:430, 2020.</li>

    </ul>

    <p class="text-gray-300">Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In ACM Conference on Computer and Communications Security, pages 2111–2128. ACM, 2019.</li>

      <li>[Nao03] Moni Naor. On cryptographic assumptions and challenges. In CRYPTO, volume 2729 of Lecture Notes in Computer Science, pages 96–109. Springer, 2003.</li>

      <li>[Ped91] Torben P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 129–140. Springer, 1991.</li>

      <li>[Wes19] Benjamin Wesolowski. Efficient verifiable delay functions. In EUROCRYPT (3), volume 11478 of Lecture Notes in Computer Science, pages 379–407. Springer, 2019.</li>

      <li>[Wik18] Douglas Wikström. Special soundness revisited. IACR Cryptol. ePrint Arch., 2018:1157, 2018.</li>

      <li>[XZZ^{+}19] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In CRYPTO (3), volume 11694 of Lecture Notes in Computer Science, pages 733–764. Springer, 2019.</li>

    </ul>

    <h2 id="sec-34" class="text-2xl font-bold">Appendix A Extractor Analysis</h2>

    <p class="text-gray-300">This appendix describes an extractor analysis for a generalized notion of special soundness: <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness. Compared to standard special soundness this is a generalization in two ways: (1) from requiring a colliding pair of transcripts to requiring a <span class="math">k</span>-collision of <span class="math">k</span> transcripts and (2) from protocols containing 1 challenge, sent from the verifier to the prover, to protocols containing <span class="math">\\mu</span> challenges. We show that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness implies, in a portion of the full parameter space, knowledge soundness. Moreover, we recall that the result that shows that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness implies witness extended emulation.</p>

    <p class="text-gray-300">An interactive protocol <span class="math">\\Pi</span> for relation <span class="math">R</span> is said to be knowledge sound with knowledge error <span class="math">\\kappa(\\cdot)</span> if the following holds <em>[x1]</em>. There exists an algorithm <span class="math">\\chi</span> that, on input a statement <span class="math">x</span> and given rewindable oracle access to a (possibly dishonest) prover <span class="math">\\mathcal{P}^{<em>}</span>, outputs a witness <span class="math">w</span> for <span class="math">x</span> in expected time <span class="math">O\\left(1/(\\epsilon(x)-\\kappa(x))\\right)</span>, where <span class="math">\\epsilon(x)&gt;\\kappa(x)</span> is the probability that the verifier accepts a protocol execution with <span class="math">\\mathcal{P}^{</em>}</span> on public input <span class="math">x</span>. Here, invoking <span class="math">\\mathcal{P}^{*}</span> is assumed to take unit time. Such an algorithm is called a knowledge extractor.</p>

    <p class="text-gray-300">An alternative definition of knowledge soundness <em>[x10]</em> requires the knowledge extractor to run in strict polynomial time and to succeed with probability at least <span class="math">(\\epsilon(x)-\\kappa(x))^{c}</span> for some constant <span class="math">c</span>. Note that by repeating such an extractor until it succeeds a new extractor with expected run time <span class="math">O(1/(\\epsilon(x)-\\kappa(x))^{c})</span> is obtained. This alternative definition, and in particular the constant <span class="math">c</span>, therefore allows an extractor to be somewhat less efficient. An interactive protocol that is knowledge sound is said to be a proof of knowledge (PoK).</p>

    <p class="text-gray-300">However, a technical issue with both these definitions for knowledge soundness arises when proofs of knowledge are used within larger cryptographic protocols. To avoid these composition issues, Lindell <em>[x14]</em> introduced the notion witness extended emulation. An interactive protocol is said to have witness extended emulation if there exists an expected polynomial time algorithm that, on input a statement <span class="math">x</span> and given rewindable oracle access to a (possibly dishonest) prover <span class="math">\\mathcal{P}^{<em>}</span>, not only outputs a witness <span class="math">w</span> but also a transcript that is statistically indistinguishable from a conversation between <span class="math">\\mathcal{P}^{</em>}</span> and an honest verifier. Moreover, the probability that the transcript is accepting and that the witness is not valid is negligible. Such an algorithm is called a witness extended emulator and interactive protocols that have witness extended emulation are also called proofs of knowledge.</p>

    <p class="text-gray-300">When <span class="math">\\mathcal{P}^{<em>}</span> succeeds only with negligible probability knowledge extractors are, in contrast to witness extended emulators, not required to run in expected polynomial time. However, a witness extended emulator is allowed to fail in outputting a valid witness with negligible probability. For this reason, a witness extended emulator is only required to output witnesses for provers <span class="math">\\mathcal{P}^{</em>}</span> that succeed with non-negligible probability.</p>

    <p class="text-gray-300">In Section A.1, we first show that any <span class="math">k</span>-special sound protocol has a strict polynomial time knowledge extractor that succeeds with probability at least <span class="math">\\left(\\epsilon(x)-\\left(k-1\\right)/q\\right)^{k}</span>, where <span class="math">q</span> is the size of the challenge</p>

    <p class="text-gray-300">set. The argument follows by an application of Jensen’s inequality. Second, by a more intricate heavy-row type analysis, we also show the existence of an extractor that output a witness in expected time <span class="math">O\\left(1/\\left(\\epsilon(x)-\\left(k-1\\right)/q\\right)\\right)</span>.</p>

    <p class="text-gray-300">In Section A.2, we show that any <span class="math">\\left(k_{1},\\ldots,k_{\\mu}\\right)</span>-special sound protocol has a strict polynomial time knowledge extractor that succeeds with probability at least <span class="math">\\left(\\epsilon(x)-\\kappa(x)\\right)^{K}</span>, where <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span> and</p>

    <p class="text-gray-300"><span class="math">\\kappa=\\frac{\\sum_{i=1}^{\\mu}(k_{i}-1)q^{\\mu-i}\\prod_{j=1}^{i-1}(q-k_{j}+1)}{q^{\\mu}}.</span> (10)</p>

    <p class="text-gray-300">Since the success probability of this extractor degrades exponentially with <span class="math">K</span>, this result only implies a meaningful definition of knowledge soundness when <span class="math">K</span> is constant in the security parameter. Therefore this result is only applicable to a portion of the full parameter space relevant to our applications. It turns out to be a challenging task to construct efficient knowledge extractors and find exact knowledge errors for protocols that satisfy this generalized notion of special soundness. See also <em>[x21]</em> and <em>[x12]</em> for a discussion on knowledge errors and extractor efficiencies. For this reason, we resort to prior work <em>[BCC^{+}16]</em> that shows that any <span class="math">\\left(k_{1},\\ldots,k_{\\mu}\\right)</span>-special sound protocol has witness extended emulation, and omit determining exact knowledge errors. For completeness, we recall this result in Lemma 5.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">A.1 <span class="math">k</span>-Special Soundness</h3>

    <p class="text-gray-300">In the theory of <span class="math">\\Sigma</span>-protocols, an interactive protocol for relation <span class="math">R</span> is called special sound if there exists an efficient algorithm that extracts a witness <span class="math">w</span> for statement <span class="math">x</span> from a “collision,” i.e., two accepting conversations <span class="math">\\left(x,a,c,z\\right)</span> and <span class="math">\\left(x,a,c^{\\prime},z^{\\prime}\\right)</span> with <span class="math">c\\neq c^{\\prime}</span>. It is well known that special soundness implies both definitions of knowledge soundness <em>[x1, x13]</em> with knowledge error <span class="math">1/q</span>, where <span class="math">q</span> is the size of the challenge set.</p>

    <p class="text-gray-300">Let us first consider the second definition of knowledge soundness and show the existence of a polynomial time extractor that succeeds with probability at least <span class="math">\\left(\\epsilon(x)-1/q\\right)^{2}</span>. This result <em>[x5]</em> can be shown to follow from an application of Jensen’s inequality to the convex function <span class="math">f(X)=X(X-1/q)</span>. We note that <em>[x3]</em> considers extraction for a more general class of randomized algorithms, i.e., a class that is not restricted to <span class="math">\\Sigma</span>-protocols. Their proof only requires a minor adaptation of the techniques from <em>[x5]</em>. However, this generalization is not sufficient for our purposes.</p>

    <p class="text-gray-300">To show that a special sound protocol is knowledge sound, the following “collision-game” is defined in <em>[x5]</em>. This is essentially the game played by the knowledge extractor and Lemma 2 gives a bound on the success probability when playing this game. Both the game and the lemma are almost identical to the ones found in <em>[x5]</em>.</p>

    <p class="text-gray-300">Consider a <span class="math">0/1</span>-matrix with <span class="math">n</span> rows and <span class="math">q</span> columns. The rows correspond to the prover’s randomness and the columns to the verifier’s randomness. An entry of the matrix is <span class="math">1</span> if the prover is able to supply an accepting response for the associated first message and challenge and <span class="math">0</span> otherwise. Let <span class="math">\\epsilon</span> denote the number of ones in <span class="math">H</span>.</p>

    <p class="text-gray-300">The game goes as follows. Select an entry of <span class="math">H</span> uniformly at random. If this entry is a <span class="math">1</span>, select another entry of the same row uniformly at random. If this entry is again a <span class="math">1</span> the game outputs success.</p>

    <p class="text-gray-300">To bound the success probability of the collision-game, Jensen’s inequality is used. Jensen’s inequality states that if <span class="math">X</span> is a real random variable and <span class="math">f</span> is a continuous convex function defined on the support of <span class="math">X</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">f\\left(\\mathbb{E}[X]\\right)\\leq\\mathbb{E}[f(X)].</span> (11)</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 2 (Lemma 2.1 of <em>[x5]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">H</span> be a <span class="math">0/1</span>-matrix with <span class="math">n</span> rows and <span class="math">q</span> columns, and let <span class="math">\\epsilon</span> denote the fraction of <span class="math">1</span>-entries in <span class="math">H</span>. Suppose <span class="math">\\epsilon&gt;1/q</span>. Then the success probability of one iteration of the ”collision-game” is greater than or equal to <span class="math">\\epsilon(\\epsilon-1/q)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Let <span class="math">e_{i}</span> denote the number of 1-entries in the <span class="math">i</span>-th row, <span class="math">i=1\\ldots n</span>. and let <span class="math">\\epsilon_{i}</span> denote the fraction of 1-entries in the <span class="math">i</span>-th row, i.e., <span class="math">\\epsilon_{i}=e_{i}/q</span>. Clearly, the success-probability is equal to</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{n}\\sum_{i=1}^{n}\\epsilon_{i}\\left(\\frac{q\\epsilon_{i}-1}{q-1}\\right)=\\frac{1}{n}\\frac{q}{q-1}\\sum_{i=1}^{n}\\epsilon_{i}\\left(\\epsilon_{i}-\\frac{1}{q}\\right).</span> (12)</p>

    <p class="text-gray-300">Now observe that <span class="math">\\mathbb{E}[\\epsilon_{i}]=\\epsilon</span>, put <span class="math">f(x)=x(x-1/q)</span> on the interval <span class="math">[0,1]</span> and apply Jensen’s inequality. Together with the fact that <span class="math">q/(q-1)&gt;1</span> the Lemma follows.</p>

    <p class="text-gray-300">Using this lemma, it is straightforward to construct a polynomial time knowledge extractor that succeeds with probability at least <span class="math">(\\epsilon(x)-1/q)^{2}</span>. Instead, we immediately consider a generalization that has recently become relevant, <span class="math">k</span>-special soundness. A 3-move interactive protocol is called <span class="math">k</span>-special sound, if there exists an efficient algorithm that takes as input <span class="math">k</span> accepting conversations <span class="math">(x,a,c_{1},z_{1}),\\ldots,(x,a,c_{k},z_{k})</span> with <span class="math">c_{i}\\neq c_{j}</span>, <span class="math">\\forall i\\neq j</span>, and outputs a witness <span class="math">w</span> for <span class="math">x</span>. This set of <span class="math">k</span> accepting transcripts with common first message and pairwise distinct challenges is called a <em><span class="math">k</span>-collision</em>. The proof technique using Jensen’s inequality is no longer directly applicable, since the associated function is not convex. Here, we show that an adaptation of the proof using Jensen’s inequality does apply. To this end let us consider the following function.</p>

    <p class="text-gray-300">\\[ f:\\mathbb{R}\\to\\mathbb{R}:\\quad x\\mapsto\\begin{cases}\\prod_{j=0}^{k-1}\\frac{q}{q-j}\\left(x-\\frac{j}{q}\\right),&\\text{if }x\\geq\\frac{k-1}{q},\\\\ 0,&\\text{otherwise}.\\end{cases} \\] (13)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that $q=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easily seen that <span class="math">f</span> is twice-differentiable and <span class="math">f^{\\prime\\prime}(x)\\geq 0</span> for all <span class="math">x\\in\\mathbb{R}\\setminus\\left\\{\\frac{k-1}{q}\\right\\}</span>. Moreover, for <span class="math">x_{0}=\\frac{k-1}{q}</span> it holds that</p>

    <p class="text-gray-300"><span class="math">\\lim_{x\\uparrow x_{0}}\\frac{f(x)-f(x_{0})}{x-x_{0}}=0\\leq\\frac{q}{q-k+1}\\prod_{j=0}^{k-2}\\frac{k-1-j}{q-j}=\\lim_{x\\downarrow x_{0}}\\frac{f(x)-f(x_{0})}{x-x_{0}}.</span> (14)</p>

    <p class="text-gray-300">Hence, <span class="math">f</span> is a convex function.</p>

    <p class="text-gray-300">The following lemma now shows the existence of a polynomial time extractor that succeeds with probability at least <span class="math">\\left(\\epsilon(x)-(k-1)/q\\right)^{k}</span>. If <span class="math">k</span> is constant in the security parameter, it therefore follows that <span class="math">k</span>-special soundness implies knowledge soundness according to the definition of <em>[x10]</em>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 7 (Knowledge Soundness Type II).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">k</span>-special sound interactive protocol for relation <span class="math">R</span> and let <span class="math">x</span> be some statement, where <span class="math">\\mathcal{V}</span> samples the challenge uniformly at random from a challenge set of size <span class="math">q</span>. Let <span class="math">\\mathcal{P}^{<em>}</span> be a prover such that <span class="math">(\\mathcal{P}^{</em>},\\mathcal{V})</span> accepts with probability <span class="math">\\epsilon(x)&gt;\\frac{k-1}{q}</span>. Then there exists a polynomial time extractor <span class="math">\\mathcal{E}</span> with rewindable black-box access to <span class="math">\\mathcal{P}^{*}</span> that on input <span class="math">x</span> outputs a witness <span class="math">w</span> for <span class="math">x</span> with probability at least</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=0}^{k-1}\\left(\\epsilon(x)-\\frac{j}{q}\\right)\\geq\\left(\\epsilon(x)-\\frac{k-1}{q}\\right)^{k},</span> (15)</p>

    <p class="text-gray-300">in at most <span class="math">k</span> calls to <span class="math">\\mathcal{P}^{*}</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> runs <span class="math">(\\mathcal{P}^{*},\\mathcal{V})</span> on a random challenge <span class="math">c\\in\\mathcal{C}</span>. If <span class="math">\\mathcal{V}</span> accepts, <span class="math">\\mathcal{E}</span> rewinds to move 2 and samples a uniform random challenge from <span class="math">\\mathcal{C}\\setminus\\{c\\}</span>. <span class="math">\\mathcal{E}</span> continues until it aborts or has extracted <span class="math">k</span> accepting transcripts. In the latter case, <span class="math">k</span>-special soundness implies the existence of an efficient algorithm to compute a witness <span class="math">w</span>. So let us now determine the success probability of <span class="math">\\mathcal{E}</span>.</p>

    <p class="text-gray-300">Let <span class="math">a</span> be any first message of <span class="math">(\\mathcal{P}^{<em>},\\mathcal{V})</span> on input <span class="math">(x;w)\\in R</span>. Let <span class="math">\\epsilon_{a}</span> be the probability that <span class="math">\\mathcal{P}^{</em>}</span> succeeds conditioned on the first message being equal to <span class="math">a</span>. Then <span class="math">\\mathbb{E}[\\epsilon_{a}]=\\epsilon(x)</span>, where the expected value is taken over all possible first messages <span class="math">a</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Moreover, the success probability of <span class="math">\\mathcal{E}</span>, conditioned on the first message being equal to <span class="math">a</span> can easily seen to be equal to <span class="math">f(\\epsilon_{a})</span>, where <span class="math">f</span> is defined in Equation 13.</p>

    <p class="text-gray-300">Hence, the unconditional success probability of <span class="math">\\mathcal{E}</span> equals</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[f(X)]\\geq f\\left(\\mathbb{E}[X]\\right)=f(\\epsilon(x))\\geq\\prod_{j=0}^{k-1}\\left(\\epsilon(x)-\\frac{j}{q}\\right),</span> (16)</p>

    <p class="text-gray-300">where the first inequality follows from Jensen’s inequality.</p>

    <p class="text-gray-300">The success probability of this extractor of Theorem 7 degrades exponentially with <span class="math">k</span>. For this reason, this extractor only implies a meaningful definition of knowledge soundness if <span class="math">k</span> is constant in the security parameter. For this reason we also consider a more intricate heavy-row type extraction algorithm. The extractor is an adaptation of the knowledge extractor of <em>[x10]</em> that merely considered 2-special-soundness. Its properties are summarized in the following theorem. In particular, it follows that <span class="math">k</span>-special soundness implies knowledge soundness according to the definition of <em>[x3]</em>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 8 (Knowledge Soundness Type I).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">k</span>-special sound interactive protocol for relation <span class="math">R</span> and let <span class="math">x</span> be some statement, where <span class="math">\\mathcal{V}</span> samples the challenge uniformly at random from a challenge set of size <span class="math">q</span>. Let <span class="math">\\mathcal{P}^{<em>}</span> be a prover such that <span class="math">(\\mathcal{P}^{</em>},\\mathcal{V})</span> accepts with probability <span class="math">\\epsilon(x)&gt;\\frac{k-1}{q}</span>. Then there exists a polynomial time extractor <span class="math">\\mathcal{E}</span> with rewindable black-box access to <span class="math">\\mathcal{P}^{*}</span> that on input <span class="math">x</span> outputs a witness <span class="math">w</span> for <span class="math">x</span> in expected time:</p>

    <p class="text-gray-300"><span class="math">O\\left(\\frac{k}{\\epsilon(x)-(k-1)/q}\\right).</span> (17)</p>

    <p class="text-gray-300">Here, invoking <span class="math">\\mathcal{P}^{*}</span> is assumed to take unit time.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We aim to construct an algorithm that outputs a <span class="math">k</span>-collision for protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span> and public input <span class="math">x</span>. Then <span class="math">k</span>-special soundness implies the existence of an efficient extractor. The algorithm is required to run in expected time <span class="math">O\\left(\\frac{k}{\\epsilon(x)-(k-1)/q}\\right)</span>. We now describe the algorithm and analyze its expected run time.</p>

    <p class="text-gray-300">The algorithm considers two different cases that depend on the success probability <span class="math">\\epsilon(x)</span> and for each case we describe a different approach. Because the success probability <span class="math">\\epsilon(x)</span> is unknown, the extractor runs both approaches in parallel.</p>

    <p class="text-gray-300">Case 1. Let us first consider the case <span class="math">(k-1)/q&lt;\\epsilon(x)&lt;4(k-1)/q</span>, i.e., <span class="math">\\epsilon(x)=(1+\\delta)\\frac{k-1}{q}</span> for some <span class="math">0&lt;\\delta&lt;3</span>. The algorithm starts by generating random transcripts by invoking <span class="math">\\mathcal{P}^{<em>}</span> until it finds an accepting transcripts <span class="math">(a,c,z)</span>. This takes expected time <span class="math">1/\\epsilon(x)</span>. Let <span class="math">\\epsilon_{a}</span> be the success probability of <span class="math">\\mathcal{P}^{</em>}</span> conditioned on the prover sending first message <span class="math">a</span>. Note that, if <span class="math">\\epsilon_{a}\\geq k/q</span> there exist at least <span class="math">k</span> accepting transcripts with common first message <span class="math">a</span> and pairwise distinct challenges.</p>

    <p class="text-gray-300">To find these transcripts, the algorithm rewinds <span class="math">q-1</span> times and tries all challenges <span class="math">c^{\\prime}\\neq c</span> given first message <span class="math">a</span>. This second step takes time <span class="math">q-1</span>. As a result the algorithm has generated <span class="math">q</span> transcripts, for which at least the first one is accepting, in expected time</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{\\epsilon(x)}+q-1&lt;\\frac{1}{\\epsilon(x)}+\\frac{k-1}{(k-1)/q}=\\frac{1+(1+\\delta)(k-1)}{\\epsilon(x)}.</span> (18)</p>

    <p class="text-gray-300">Moreover, the algorithm is successful if and only if at least <span class="math">k</span> of these transcripts are accepting, i.e., if and only if <span class="math">\\epsilon_{a}\\geq k/q</span>. Let us now determine this success probability. Let <span class="math">R</span> be the number of possible random choices by <span class="math">\\mathcal{P}^{<em>}</span> and recall that the number of possible random choices by <span class="math">\\mathcal{V}</span> is <span class="math">q</span>. For precisely <span class="math">\\epsilon(x)Rq</span> of these random choices <span class="math">\\mathcal{P}^{</em>}</span> succeeds. Moreover, at least <span class="math">\\epsilon(x)Rq-(k-1)R=(k-1)R\\delta</span> of these successful choices correspond to a first message <span class="math">a</span> with <span class="math">\\epsilon_{a}\\geq k/q</span>. Hence, the success probability of this algorithm is at least,</p>

    <p class="text-gray-300"><span class="math">\\frac{(k-1)R\\delta}{\\epsilon(x)Rq}=\\frac{\\delta}{1+\\delta}.</span> (19)</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2}\\left(\\frac{k}{\\epsilon(x)-(k-1)/q}\\right)\\leq\\frac{1}{2}\\left(\\frac{k-1}{q}\\right).</span> (19)</p>

    <p class="text-gray-300">Repeating this algorithm until it finds a sets of <span class="math">k</span> accepting transcripts therefore results in an expected run time of,</p>

    <p class="text-gray-300"><span class="math">\\frac{(1+\\delta)\\left(1+(1+\\delta)(k-1)\\right)}{\\delta\\epsilon(x)}=\\frac{1+(1+\\delta)(k-1)}{\\delta(k-1)/q}=\\frac{1+(1+\\delta)(k-1)}{\\epsilon(x)-(k-1)/q}&lt;\\frac{4k-3}{\\epsilon(x)-(k-1)/q},</span> (20)</p>

    <p class="text-gray-300">which is <span class="math">O\\left(\\frac{k}{\\epsilon(x)-(k-1)/q}\\right)</span> and therefore proves the theorem for this case.</p>

    <p class="text-gray-300">Case 2. Let us now consider the case <span class="math">\\epsilon(x)\\geq 4(k-1)/q</span>, i.e., <span class="math">\\epsilon(x)=(1+\\delta)\\frac{k-1}{q}</span> or some <span class="math">\\delta\\geq 3</span>. In this case, the previous approach of simply rewinding <span class="math">q-1</span> times does not work since we cannot bound <span class="math">\\delta</span> in Equation 20. For this reason, we must abort the rewinding procedure at some point to reduce the expected run time.</p>

    <p class="text-gray-300">The algorithm starts as before by generating random transcripts until it finds an accepting transcript <span class="math">(a,c,z)</span>. By a simple counting argument it can be seen that <span class="math">\\epsilon_{a}\\geq\\epsilon(x)/2</span> with probability at least <span class="math">1/2</span> <em>[x10]</em>. Subsequently, the algorithm rewinds and tries different challenges until it is told to abort.</p>

    <p class="text-gray-300">The abort procedure works as follows. After every rewinding step the algorithm flips a coin that lands heads with probability <span class="math">\\epsilon(x)/(8(k-1))</span>. If the coin lands tails the algorithm continues by rewinding again and if not the algorithm aborts. The extractor can implement such a coin, even if it does not know <span class="math">\\epsilon(x)</span>, by querying <span class="math">\\mathcal{P}^{*}</span>. The expected run time of this step is <span class="math">8(k-1)/\\epsilon(x)</span>. The probability that the algorithm rewinds at most <span class="math">4(k-1)/\\epsilon(x)</span> times can, by a union bound, by upper bounded by <span class="math">1/2</span>. In other words, the probability that the algorithm rewinds at least <span class="math">4(k-1)/\\epsilon(x)</span> times is at least <span class="math">1/2</span>.</p>

    <p class="text-gray-300">Let us now determine the probability that the algorithm finds at least <span class="math">k</span> accepting transcripts conditioned on <span class="math">\\epsilon_{a}\\geq\\epsilon(x)/2</span> and the event that the algorithm rewinds at least <span class="math">4(k-1)/\\epsilon(x)</span> times. This conditional success probability is at least the probability that the algorithm succeeds after exactly <span class="math">4(k-1)/\\epsilon(x)</span> rewinds.</p>

    <p class="text-gray-300">The rewinding procedure can be modeled by a negative hypergeometric distribution with population size <span class="math">q-1</span> from which draw without replacement until we have found <span class="math">k-1</span> accepting transcripts out of <span class="math">\\epsilon_{a}q-1\\geq\\epsilon(x)q/2-1\\geq 2(k-1)-1\\geq k-1</span> transcripts. The expected number of rewinds before obtaining <span class="math">k</span> accepting transcripts is therefore equal to,</p>

    <p class="text-gray-300"><span class="math">\\frac{k-1}{\\epsilon_{a}}\\leq\\frac{2(k-1)}{\\epsilon(x)}.</span> (21)</p>

    <p class="text-gray-300">By Markov’s inequality the probability that we need more than <span class="math">4(k-1)/\\epsilon(x)</span> rewinds is at most <span class="math">1/2</span>. Therefore, conditioned on <span class="math">\\epsilon_{a}\\geq\\epsilon(x)/2</span> and the event that the algorithm rewinds at least <span class="math">4(k-1)/\\epsilon(x)</span> times, the algorithm succeeds in obtaining <span class="math">k</span> accepting transcripts with probability at least <span class="math">1/2</span>.</p>

    <p class="text-gray-300">Altogether the case 2 algorithm runs in expected time at most,</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{\\epsilon(x)}+\\frac{8(k-1)}{\\epsilon(x)},</span> (22)</p>

    <p class="text-gray-300">which is <span class="math">O\\left(\\frac{k}{\\epsilon(x)-(k-1)/q}\\right)</span>. Moreover, it succeeds in finding <span class="math">k</span> accepting transcripts, with common first message <span class="math">a</span> and pairwise distinct challenges <span class="math">c_{i}</span>, with probability at least <span class="math">1/8</span>. Hence, by running this algorithm an expected number of <span class="math">8</span> times gives the desired extraction algorithm, which concludes the proof of this theorem.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">A.2 <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special Soundness</h3>

    <p class="text-gray-300">Recall that an interactive protocol is called <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound, if there exists an efficient algorithm that computes a witness from any set of <span class="math">K:=\\prod_{i=1}^{\\mu}k_{i}</span> accepting transcripts <span class="math">(x,a,c_{1,j},z_{1,j},\\ldots,c_{\\mu,j},z_{\\mu,j})</span>, <span class="math">1\\leq j\\leq K</span>, that they are in a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree structure. The vertices of this tree correspond to the prover’s messages, in particular the root of a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree is some message <span class="math">a</span>. The edges of the tree correspond to the verifier’s challenges. Every vertex at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. This way we obtain precisely <span class="math">K</span> paths from the leaves to the root representing the accepting transcripts. We also note that in some protocols it occurs that the verifier sends multiple</p>

    <p class="text-gray-300">challenges in one message. In these protocol the number of moves is strictly less than <span class="math">2\\mu+1</span>. However, we still consider depth <span class="math">\\mu</span> trees by allowing prover’s messages to be empty.</p>

    <p class="text-gray-300">In this section, we show the existence of a polynomial time extractor that succeeds with probability <span class="math">(\\epsilon(x)-\\kappa)^{K}</span>, where <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span> and <span class="math">\\kappa</span> is defined in Equation 23. For notational convenience, Lemma 3 assumes that all challenges are sampled from <span class="math">\\mathbb{Z}_{q}</span> uniformly at random. Subsequently, Lemma 4 generalizes this to the case where the verifier samples from different subsets of <span class="math">\\mathbb{Z}_{q}</span> in the different rounds of the protocol. The bound <span class="math">\\epsilon(x)&gt;\\kappa</span> is tight, since the existence of an extractor, not necessarily expected polynomial time, can not be guaranteed if <span class="math">\\epsilon(x)\\leq\\kappa</span>. However, the success probability of this extractor degrades exponentially with <span class="math">K</span>. Therefore this extractor only implies knowledge soundness if <span class="math">K</span> is constant in the security parameter. For this reason, we also recall, in Lemma 5, a result of <em>[BCC^{+}16]</em>. This result shows that a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol has witness extended emulation and it follows from the extractor analysis of <em>[BCC^{+}16, Lemma 1]</em>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound <span class="math">(2\\mu+1)</span>-move interactive protocol for relation <span class="math">R</span>, where <span class="math">\\mathcal{V}</span> samples each challenge uniformly at random from a challenge set of size <span class="math">q</span>. Let <span class="math">x</span> be some statement. Let <span class="math">\\mathcal{P}^{<em>}</span> be a prover such that <span class="math">(\\mathcal{P}^{</em>},\\mathcal{V})</span> accepts with probability <span class="math">\\epsilon(x)&gt;\\kappa</span>, where</p>

    <p class="text-gray-300"><span class="math">\\kappa=\\frac{\\sum_{i=1}^{\\mu}(k_{i}-1)q^{\\mu-i}\\prod_{j=1}^{i-1}(q-k_{j}+1)}{q^{\\mu}}\\leq\\frac{\\sum_{i=1}^{\\mu}(k_{i}-1)}{q}.</span> (23)</p>

    <p class="text-gray-300">Then there exists a polynomial time extractor <span class="math">\\mathcal{E}</span> with rewindable black-box access to <span class="math">\\mathcal{P}^{<em>}</span> that on input <span class="math">x</span> outputs a witness <span class="math">w</span> for <span class="math">x</span> with probability at least <span class="math">\\left(\\epsilon(x)-\\kappa\\right)^{K}</span> in at most <span class="math">K</span> calls to <span class="math">\\mathcal{P}^{</em>}</span>, where <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct a polynomial time algorithm that generates a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of accepting transcripts with probability at least <span class="math">(\\epsilon(x)-\\kappa)^{K}</span> in at most <span class="math">K</span> calls. The lemma then follows from the definition of <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness.</p>

    <p class="text-gray-300">For <span class="math">0\\leq m\\leq\\mu-1</span> and <span class="math">c_{i}\\in\\mathcal{C}</span> let <span class="math">\\textsc{Tree}(x,a,c_{1},\\ldots,c_{m})</span> be the algorithm that tries to find a <span class="math">(k_{m+1},\\ldots,k_{\\mu})</span>-sub-tree after the first <span class="math">2m+1</span> rounds have been fixed by <span class="math">a,c_{1},\\ldots,c_{m}</span>. More precisely, for <span class="math">m=\\mu</span> it simply runs <span class="math">\\mathcal{P}^{*}</span> on challenges <span class="math">c_{1},\\ldots,c_{\\mu}</span> and for <span class="math">m&lt;\\mu</span> it runs <span class="math">\\textsc{Tree}(x,a,c_{1},\\ldots,c_{m},y_{\\ell})</span> for <span class="math">1\\leq\\ell\\leq k_{m+1}</span> and <span class="math">y_{\\ell}\\in\\mathcal{C}</span> sampled uniformly at random such that <span class="math">y_{i}\\neq y_{j}</span> for all <span class="math">i\\neq j</span>. We say Tree aborts if at any stage the verifier <span class="math">\\mathcal{V}</span> rejects and write <span class="math">\\textsc{Tree}=\\bot</span> in this case.</p>

    <p class="text-gray-300">For notational convenience we define <span class="math">\\bar{\\mathbf{c}}_{m}:=(x,a,c_{1},\\ldots,c_{m})</span>. For such a vector we define <span class="math">\\epsilon_{\\bar{\\mathbf{c}}_{m}}</span> to be the probability that <span class="math">\\mathcal{P}^{*}</span> succeeds conditioned on the first <span class="math">2m+1</span> rounds to coincide with <span class="math">\\bar{\\mathbf{c}}_{m}</span>. Moreover, let us define</p>

    <p class="text-gray-300"><span class="math">\\kappa_{m}:=\\frac{\\sum_{i=m+1}^{\\mu}(k_{i}-1)q^{\\mu-i}\\prod_{j=m+1}^{i-1}(q-k_{j}+1)}{q^{\\mu-m}}.</span> (24)</p>

    <p class="text-gray-300">Finally, we let <span class="math">K_{m}=\\prod_{i=m+1}^{\\mu}k_{i}</span>. We will show by induction that the success probability <span class="math">P_{m}</span> of <span class="math">\\textsc{Tree}(x,a,c_{1},\\ldots,c_{m})</span> is at least <span class="math">\\max(\\epsilon_{\\bar{\\mathbf{c}}_{m}}-\\kappa_{m},0)^{K_{m}}</span> for all <span class="math">0\\leq m\\leq\\mu</span>.</p>

    <p class="text-gray-300">For <span class="math">m=\\mu</span> the induction hypothesis immediately follows by the definition of <span class="math">\\epsilon_{\\bar{\\mathbf{c}}_{m}}</span>. So let us assume that the success probability of <span class="math">\\textsc{Tree}(x,a,c_{1},\\ldots,c_{m})</span> is at least <span class="math">\\max(\\epsilon_{\\bar{\\mathbf{c}}_{m}}-\\kappa_{m},0)^{K_{m}}</span> for all <span class="math">m&gt;M</span>. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P_{M} := P \\left(\\operatorname{Tree}(x, a, c_{1}, \\dots, c_{M}) \\neq \\bot\\right), \\\\ = \\prod_{\\ell=1}^{k_{M+1}} P \\left(\\operatorname{Tree}(x, a, c_{1}, \\dots, c_{M}, y_{\\ell}) \\neq \\bot\\right), \\\\ \\geq \\prod_{\\ell=1}^{k_{M+1}} \\max \\left(\\epsilon_{\\bar{e}_{M}, y_{\\ell}} - \\kappa_{M+1}, 0\\right)^{K_{M+1}}, \\\\ \\stackrel{(1)}{\\geq} \\prod_{\\ell=1}^{k_{M+1}} \\max \\left(\\frac{q}{q - \\ell + 1} \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{\\ell - 1}{q}\\right) - \\kappa_{M+1}, 0\\right)^{K_{M+1}}, \\tag{25} \\\\ = \\prod_{\\ell=1}^{k_{M+1}} \\max \\left(\\frac{q}{q - \\ell + 1} \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{\\ell - 1 + \\kappa_{M+1}(q - \\ell + 1)}{q}\\right), 0\\right)^{K_{M+1}}, \\\\ \\stackrel{(2)}{\\geq} \\prod_{\\ell=1}^{k_{M+1}} \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{k_{M+1} - 1 + \\kappa_{M+1}(q - k_{M+1} + 1)}{q}, 0\\right)^{K_{M+1}}, \\\\ = \\max \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{k_{M+1} - 1 + \\kappa_{M+1}(q - k_{M+1} + 1)}{q}, 0\\right)^{K_{M}}, \\\\ \\stackrel{(3)}{=} \\max \\left(\\epsilon_{\\bar{e}_{M}} - \\kappa_{M}, 0\\right)^{K_{M}}. \\end{array}</span></div>

    <p class="text-gray-300">For inequality (1) we use that <span class="math">y_{\\ell}</span> is sampled uniformly at random from <span class="math">\\mathcal{C} \\setminus \\{y_1, \\ldots, y_{\\ell-1}\\}</span>, hence</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\epsilon_{\\bar{e}_{M}, y_{\\ell}} = \\frac{q}{q - \\ell + 1} \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{1}{q} \\sum_{j=1}^{\\ell-1} \\epsilon_{\\bar{e}_{M}, y_{j}}\\right), \\tag{26} \\\\ \\geq \\frac{q}{q - \\ell + 1} \\left(\\epsilon_{\\bar{e}_{M}} - \\frac{\\ell - 1}{q}\\right). \\end{array}</span></div>

    <p class="text-gray-300">For inequality (2) we use that <span class="math">\\ell \\leq k_{M+1}</span> and that <span class="math">0 \\leq \\kappa_m \\leq 1</span> for all <span class="math">m</span>. For equality (3) we use that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{k_{M+1} - 1 + \\kappa_{M+1}(q - k_{M+1} + 1)}{q} = \\kappa_{M}. \\tag{27}</span></div>

    <p class="text-gray-300">Hence, by induction the hypothesis is true for all <span class="math">0 \\leq m \\leq \\mu</span>. In particular, we find that <span class="math">P(\\mathrm{Tree}(x,a)) \\geq \\max(\\epsilon_a - \\kappa, 0)^K</span>. Now define the convex function,</p>

    <div class="my-4 text-center"><span class="math-block">f: \\mathbb{R} \\rightarrow \\mathbb{R}: \\quad x \\mapsto \\begin{cases} (x - \\kappa)^K, &amp;amp; \\text{if } x \\geq \\kappa, \\\\ 0, &amp;amp; \\text{otherwise}. \\end{cases} \\tag{28}</span></div>

    <p class="text-gray-300">Then the success probability of the extractor is at least</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{E}[f(\\epsilon_a)] \\geq f(\\mathbb{E}[\\epsilon_a]) = f(\\epsilon(x)) = (\\epsilon(x) - \\kappa)^K, \\tag{29}</span></div>

    <p class="text-gray-300">where the first inequality follows by Jensen's inequality. This proves the theorem.</p>

    <p class="text-gray-300">The following lemma generalizes Lemma 3 to interactive protocols in which the challenges sets are in the different rounds of the protocol are of different cardinalities.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Let <span class="math">(\\mathcal{P}, \\mathcal{V})</span> be a <span class="math">(k_1, \\ldots, k_\\mu)</span>-special sound <span class="math">(2\\mu + 1)</span>-move interactive protocol for relation <span class="math">R</span>, such that the verifier samples challenge <span class="math">c_i</span> in move <span class="math">2i</span> uniformly at random from challenge set <span class="math">\\mathcal{C}_i</span> for <span class="math">1 \\leq i \\leq \\mu</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">x</span> be some statement. Let $n_i :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and let </span>\\mathcal{P}^<em><span class="math"> be a prover such that </span>(\\mathcal{P}^</em>, \\mathcal{V})<span class="math"> accepts with probability </span>\\epsilon(x) &gt; \\kappa$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\kappa \\leq \\sum_{i=1}^{\\mu} \\frac{k_i - 1}{n_i}. \\tag{30}</span></div>

    <p class="text-gray-300">Then there exists a polynomial time extractor <span class="math">\\mathcal{E}</span> with rewindable black-box access to <span class="math">\\mathcal{P}^<em></span> that on input <span class="math">x</span> outputs a witness <span class="math">w</span> for <span class="math">x</span> with probability at least <span class="math">\\left(\\epsilon(x) - \\kappa\\right)^K</span> in at most <span class="math">K</span> calls to <span class="math">\\mathcal{P}^</em></span>, where <span class="math">K = \\prod_{i=1}^{\\mu} k_i</span>.</p>

    <p class="text-gray-300">The following lemma is a paraphrasing of Lemma 1 of [BCC+16] and it shows <span class="math">(k_1, \\ldots, k_\\mu)</span>-special soundness implies witness extended emulation.</p>

    <p class="text-gray-300"><strong>Lemma 5 (Witness Extended Emulation [BCC+16]).</strong> Let <span class="math">(\\mathcal{P}, \\mathcal{V})</span> be a <span class="math">(k_1, \\ldots, k_\\mu)</span>-special sound interactive protocol for relation <span class="math">R</span>, where <span class="math">\\mathcal{V}</span> samples each challenge uniformly at random from an exponentially sized challenge set. Suppose that <span class="math">K = \\prod_{i=1}^{\\mu} k_i</span> is polynomial in the security parameter. Then <span class="math">(\\mathcal{P}, \\mathcal{V})</span> has witness extended emulation.</p>

    <h2 id="sec-44" class="text-2xl font-bold">B Amortization over Many Commitments</h2>

    <p class="text-gray-300">In this section we describe how, from a standard amortization technique, a prover can show correctness of <span class="math">s</span> evaluations of the linear form <span class="math">L</span> on <span class="math">s</span> different committed vectors for essentially the costs of evaluating one standard <span class="math">\\Sigma</span>-protocol. Compression then follows as before by which logarithmic communication complexity is achieved. We denote the corresponding relation by <span class="math">R^{\\mathrm{Am}}</span>, i.e., every element of <span class="math">R^{\\mathrm{Am}}</span> is composed of <span class="math">s</span> elements of <span class="math">R</span>. More precisely,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} R^{\\mathrm{Am}} &amp;amp;= \\left\\{ \\left( P_1, \\dots, P_s \\in \\mathbb{G}, L \\in \\mathcal{L}(\\mathbb{Z}_q^n), y_1, \\dots, y_s \\in \\mathbb{Z}_q; \\right. \\right. \\\\ \\left. \\mathbf{x}_1, \\dots, \\mathbf{x}_s \\in \\mathbb{Z}_q^n, \\gamma_1, \\dots, \\gamma_s \\in \\mathbb{Z}_q \\right): P_i = \\mathbf{g}^{\\mathbf{x}_i} h^{\\gamma_i}, y_i = L(\\mathbf{x}_i) \\quad \\forall i \\right\\}. \\end{aligned} \\tag{31}</span></div>

    <p class="text-gray-300">Note that the same linear form <span class="math">L</span> is evaluated on different commitments.</p>

    <p class="text-gray-300">Now note that for a uniform random challenge <span class="math">c \\in \\mathbb{Z}_q</span>, the group element <span class="math">\\tilde{P} = A \\prod_{i=1}^{s} P_i^{c^i}</span> is a Pedersen commitment to <span class="math">\\tilde{\\mathbf{x}} = \\mathbf{r} + \\sum_{i=1}^{s} \\mathbf{x}_i c^i \\in \\mathbb{Z}_q^n</span>, where <span class="math">A</span> is a commitment to a (random) vector <span class="math">\\mathbf{r}</span>. Moreover, it holds that <span class="math">L(\\tilde{\\mathbf{x}}) = L(\\mathbf{r}) + \\sum_{i=1}^{s} y_i c^i</span>.</p>

    <p class="text-gray-300">Furthermore, if there is a commitment <span class="math">P_j</span> for which the prover does not know an opening then the prover knows an opening to <span class="math">\\tilde{P}</span> with probability at most <span class="math">s/q</span>. Informally, a cheating prover succeeds when <span class="math">c</span> is the zero of some polynomial of degree at most <span class="math">s</span>. When <span class="math">s</span> is polynomial and <span class="math">q</span> exponential in the security parameter this probability is exponentially close to 0.</p>

    <p class="text-gray-300">The first two moves of the amortized <span class="math">\\Sigma</span>-protocol, denoted by <span class="math">\\Pi_0^{\\mathrm{Am}}</span>, are identical to that of <span class="math">\\Pi_0</span>. In the third move, the prover sends an opening to <span class="math">\\tilde{P}</span>, instead of an opening of <span class="math">AP^c</span>, and the verifier performs the appropriate checks. Protocol <span class="math">\\Pi_0^{\\mathrm{Am}}</span> is <span class="math">(s+1)</span>-special sound and knowledge soundness follows from Theorem 7 (Appendix A.1). The discussion is summarized in the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 9 (Basic Pivot Amortized).</strong> <span class="math">\\Pi_0^{Am}</span> is a 3-move protocol for relation <span class="math">R^{Am}</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally <span class="math">(s+1)</span>-special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: 1 element of <span class="math">\\mathbb{G}</span> and <span class="math">n + 2</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: 1 element of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_c^{\\mathrm{Am}} \\coloneqq \\Pi_2 \\diamond \\Pi_1 \\diamond \\Pi_0^{\\mathrm{Am}}</span> for relation <span class="math">R^{\\mathrm{Am}}</span> achieves a logarithmic communication complexity. Its properties are summarized in the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 10 (Compressed Pivot Amortized).</strong> <span class="math">\\Pi_c^{Am}</span> is a <span class="math">(2\\mu + 3)</span>-move protocol for relation <span class="math">R^{Am}</span>, where <span class="math">\\mu = \\lceil \\log_2(n + 1) \\rceil - 1</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(s + 1, 2, k_1, \\ldots, k_\\mu)</span>-special sound, under the discrete logarithm assumption, where <span class="math">k_i = 3</span> for all <span class="math">1 \\leq i \\leq \\mu</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\left\\lceil\\log_{2}(n+1)\\right\\rceil-1</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">3</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\left\\lceil\\log_{2}(n+1)\\right\\rceil+1</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h2 id="sec-45" class="text-2xl font-bold">Appendix C Compressed Pivot with Unconditional Soundness</h2>

    <p class="text-gray-300">In this section we describe two approaches to implement the compressed pivot with unconditional knowledge soundness, rather than computational.</p>

    <p class="text-gray-300">First, observe that, in contrast to Bulletproofs <em>[BBB^{+}18]</em>, our compression mechanism by itself achieves unconditional soundness. The reason is that our pivot only considers linear constraints and no quadratic ones. The only building block that does not achieve unconditional soundness is the reduction of protocol <span class="math">\\Pi_{1}</span>. To achieve unconditional soundness, we simply omit this reduction. Only minor adaptations of the compression mechanism are required. A negative consequence of this approach is that the communication costs, while still logarithmic, are increased by a factor <span class="math">2</span>.</p>

    <p class="text-gray-300">Second, we describe an approach that achieves unconditional soundness without incurring this factor <span class="math">2</span> loss in communication efficiency. To this end, we show a conceptual simplification of <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> that reduces the requirements for the compressed pivot to a minimum. Namely, to open linear forms, it turns out to be sufficient to have access to an efficient ZKPoK for just opening Pedersen vector commitments. Thus, in principle, a direct provision within the compressed pivot to show that a committed vector satisfies a linear constraint is no longer required.</p>

    <p class="text-gray-300">We begin by showing that a ZK protocol for opening linear forms can be derived from a ZK protocol for only proving knowledge of an opening of a Pedersen vector commitment. More precisely, we show that a ZK protocol for relation</p>

    <p class="text-gray-300"><span class="math">R^{\\prime}=\\{(P\\in\\mathbb{G};\\mathbf{z}\\in\\mathbb{Z}_{q}^{n-1},\\gamma\\in\\mathbb{Z}_{q}):\\mathbf{k^{z}}h^{\\gamma}=P\\},</span> (32)</p>

    <p class="text-gray-300">with public parameters <span class="math">\\mathbf{k}\\in\\mathbb{G}^{n-1}</span> and <span class="math">h\\in\\mathbb{G}</span>, implies a ZK protocol for relation <span class="math">R</span> of Equation 1.</p>

    <p class="text-gray-300">The main observation is that proving that a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> satisfies <span class="math">L(\\mathbf{x})=y</span>, for some linear form <span class="math">L</span> and scalar <span class="math">y</span>, is equivalent to proving that <span class="math">\\mathbf{x}</span> lies in the affine subspace <span class="math">A_{L,y}=\\{\\mathbf{z}\\in\\mathbb{Z}_{q}^{n}:L(\\mathbf{z})=y\\}</span>. We assume (w.l.o.g.) that <span class="math">y=0</span> and that <span class="math">L\\neq 0</span>. Then <span class="math">V_{L}:=A_{L,0}\\subset\\mathbb{Z}_{q}^{n}</span> is a linear subspace of dimension <span class="math">n-1</span>. Both prover and verifier use the same deterministic algorithm to compute a basis <span class="math">\\mathbf{v}_{1},\\ldots,\\mathbf{v}_{n-1}</span> for <span class="math">V_{L}</span> and a new set of generators <span class="math">\\mathbf{k}:=(\\mathbf{g}^{\\mathbf{v}_{1}},\\ldots,\\mathbf{g}^{\\mathbf{v}_{n-1}})\\in\\mathbb{G}^{n-1}</span>. Note that, since <span class="math">\\mathbf{v}_{1},\\ldots,\\mathbf{v}_{n-1}</span> is a basis, a non-trivial discrete log relation between <span class="math">k_{1},\\ldots,k_{n-1},h</span> implies a non-trivial discrete log relation between <span class="math">g_{1},\\ldots,g_{n},h</span>.</p>

    <p class="text-gray-300">By black-box application of the ZK protocol for relation <span class="math">R^{\\prime}</span> the prover shows that it knows an opening of commitment <span class="math">P</span> with respect to generators <span class="math">k_{1},\\ldots,k_{n-1},h</span>. From this it follows that the prover knows an opening <span class="math">(\\mathbf{x},\\gamma)</span> of <span class="math">P</span> with respect to generators <span class="math">g_{1},\\ldots,g_{n},h</span> such that <span class="math">\\mathbf{x}\\in V_{L}</span> and therefore <span class="math">L(\\mathbf{x})=0</span>, i.e., <span class="math">(\\mathbf{x},\\gamma)</span> is a witness for relation <span class="math">R</span> which completes the reduction.</p>

    <p class="text-gray-300">Subsequently, we note that the simplified compressed pivot is immediately obtained from protocols <span class="math">\\Pi_{0}</span> and <span class="math">\\Pi_{2}</span> by “stripping them of their linear forms”, i.e., all protocols steps involving the linear form <span class="math">L</span> can be omitted. The reduction of protocol <span class="math">\\Pi_{1}</span> is no longer required. As a result, the minimized compressed pivot described here achieves unconditional soundness.</p>

    <p class="text-gray-300">Although this view may be superior from a conceptual standpoint, it does increase the computational costs for both the prover and the verifier. Both have to compute a basis for <span class="math">V_{L}</span> and a new set of generators of <span class="math">\\mathbb{G}</span>. Moreover, at the point of writing, it is not clear how smoothly this approach carries over to assumptions other than the discrete log assumption. For these reasons, this paper is mainly based on the compressed pivot of Section 4.3.</p>

    <h2 id="sec-46" class="text-2xl font-bold">Appendix D A Remark on Sublinear Communication Complexity</h2>

    <p class="text-gray-300">For his protocols Groth <em>[Gro09]</em> made the observation that there is a trade-off between the communication complexity and the number of rounds. A similar trade-off applies to our situation. Protocol <span class="math">\\Pi_{2}</span> achieves a</p>

    <p class="text-gray-300">logarithmic communication complexity at the cost of a logarithmic number of rounds. The protocol recursively divides the witness into two parts, left and right. This idea is easily generalized to the situation in which the witness <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> is divided into <span class="math">k</span> parts.</p>

    <p class="text-gray-300">For simplicity we assume <span class="math">n</span> to be a power of <span class="math">k</span>. A quick inspection of this generalization shows that instead of the two group elements <span class="math">A</span> and <span class="math">B</span> in the first round of <span class="math">\\Pi_{2}</span>, the prover has to sent <span class="math">2k-2</span> group elements. Recursing the protocol <span class="math">\\log_{k}(n)-1</span> times results in a total communication of <span class="math">(2k-2)\\log_{k}(n)-2k+2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">k</span> elements of <span class="math">\\mathbb{Z}_{q}</span> from prover to verifier. It is easily seen that these communication costs are minimized for <span class="math">k=2</span>.</p>

    <p class="text-gray-300">In contrast, <span class="math">k=\\sqrt{n/2}</span> results in a constant round protocol with sublinear communication costs of <span class="math">\\sqrt{2n}-2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">\\sqrt{2n}</span> elements of <span class="math">\\mathbb{Z}_{q}</span> from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span>. Of course, in the non-interactive Fiat-Shamir mode the logarithmic variant might be preferable.</p>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix E Compactifying a Vector of Commitments</h2>

    <p class="text-gray-300">This section describes two solutions for the two extreme ZK cases, where the prover wishes to show that some relation holds for data that has already been committed to. Recall the two cases from Section 5.3:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: The prover is committed to the input data <span class="math">\\mathbf{x}</span> in a single compact commitment.</li>

      <li>Case 2: The prover is committed to the coordinates of the input data <span class="math">\\mathbf{x}</span> individually.</li>

    </ul>

    <p class="text-gray-300">Both solutions reduce the situation to that of a prover with a single compact commitment <span class="math">[(\\mathbf{x},\\mathsf{aux})]</span> to all relevant data (i.e., input data and auxiliary data). Applying the methods of Section 6 serially, i.e., after these reductions, induces a factor 2 loss in the communication efficiency. Here, we show how these phases can be executed in parallel, amortizing their costs and thereby avoiding the factor 2 loss.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">E.1 Case 1</h3>

    <p class="text-gray-300">The straightforward serial approach for this case is described in Section 5.3. It requires the prover to open one linear form on one compact commitment, and another linear form on another commitment. First, the amortized nullity checks on Pedersen commitment <span class="math">Q</span> to <span class="math">(0,\\mathsf{aux})\\in\\mathbb{Z}_{q}^{n+t}</span> and, second, an opening on Pedersen commitment <span class="math">P^{\\prime}=PQ</span> to <span class="math">(\\mathbf{x},\\mathsf{aux})\\in\\mathbb{Z}_{q}^{n+t}</span> when applying the methods of Section 6. Recall that, here, <span class="math">P</span> is a Pedersen commitment to the input data <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>. In this section we describe a <span class="math">\\Sigma</span>-protocol for precisely this amortization scenario where the linear form that is to be opened depends on the commitment.</p>

    <p class="text-gray-300">More precisely, let us consider the two linear forms <span class="math">L_{1},L_{2}:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}</span> and two compact commitments <span class="math">[\\mathbf{x}_{1}]</span> and <span class="math">[\\mathbf{x}_{2}]</span> to <span class="math">\\mathbf{x}_{1},\\mathbf{x}_{2}\\in\\mathbb{Z}_{q}^{n}</span>. The goal is to efficiently open <span class="math">L_{1}(\\mathbf{x}_{1})</span> and <span class="math">L_{2}(\\mathbf{x}_{2})</span> in ZK. In particular, the cross-terms <span class="math">L_{1}(\\mathbf{x}_{2})</span> and <span class="math">L_{2}(\\mathbf{x}_{1})</span> are to remain secret.</p>

    <p class="text-gray-300">The main idea is to build a shell around the compact commitments that allows the prover to mask linear form evaluations that are not supposed to be revealed, i.e., the cross-terms. Thereby, the problem can be reduced to a standard amortization scenario where the entire “matrix” of linear form evaluations</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}L_{1}(\\mathbf{x}_{1})&L_{1}(\\mathbf{x}_{2})\\\\ L_{2}(\\mathbf{x}_{1})&L_{2}(\\mathbf{x}_{2})\\end{pmatrix} \\]</p>

    <p class="text-gray-300">is revealed. More precisely, intended evaluations, on the diagonal of this matrix, will return the correct value and unintended evaluations will return a random, i.e., masked, value.</p>

    <p class="text-gray-300">The solution presented here is constructed at the level of our basic <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> (Section 3). Black-box access to <span class="math">[\\cdot]</span> is insufficient and we therefore focus on the Pedersen vector commitment scheme. It suffices to consider a solution with linear communication complexity. A compressed version of this <span class="math">\\Sigma</span>-protocol, with logarithmic communication complexity, directly follows from the compression techniques of Section 4.</p>

    <p class="text-gray-300">Let us now consider the details of our solution. Taking from the public set-up information a new pair of generators <span class="math">k_{1},k_{2}</span> disjoint from the initial set that, supposedly, underlie Pedersen commitments <span class="math">[\\mathbf{x}_{1}]</span> and <span class="math">[\\mathbf{x}_{2}]</span>. These additional generators allow the prover to incorporate additional (random) coefficients <span class="math">u,w\\in\\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300">in the commitments. However, it is essential that generator <span class="math">k_{1}</span> is only used to equip commitment <span class="math">[\\mathbf{x}_1]</span> with a shell and generator <span class="math">k_{2}</span> is only used to equip commitment <span class="math">[\\mathbf{x}_2]</span> with a shell. Shelled Pedersen commitments to <span class="math">\\mathbf{x}_1</span> and <span class="math">\\mathbf{x}_2</span> are obtained by multiplying <span class="math">[\\mathbf{x}_1]</span> and <span class="math">[\\mathbf{x}_2]</span> with shells <span class="math">k_1^u</span> and <span class="math">k_2^w</span>, respectively, and take the form <span class="math">[(\\mathbf{x}_1,u,0)]</span> and <span class="math">[(\\mathbf{x}_2,0,w)]</span>.</p>

    <p class="text-gray-300">Altogether we have reduced the problem to finding a ZK protocol for the following relation,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} R_{\\text{shell}} = \\left\\{ \\left(P_1, P_2, L_1, L_2, y_1, y_2; \\mathbf{x}_1, \\mathbf{x}_2, u, w, \\gamma_1, \\gamma_2\\right): \\right. \\\\ \\left. \\begin{array}{l} P_1 = \\mathbf{g}^{\\mathbf{x}_1} k_1^u h^{\\gamma_1}, P_2 = \\mathbf{g}^{\\mathbf{x}_2} k_2^w h^{\\gamma_2}, \\\\ L_1(\\mathbf{x}_1) = y_1, L_2(\\mathbf{x}_2) = y_2 \\end{array} \\right. \\tag{33} \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> and <span class="math">k_1, k_2, h \\in \\mathbb{G}</span> are public parameters, <span class="math">P_1, P_2 \\in \\mathbb{G}</span>, <span class="math">u, w, y_1, y_2, \\gamma_1, \\gamma_2 \\in \\mathbb{Z}_q</span>, <span class="math">\\mathbf{x}_1, \\mathbf{x}_2 \\in \\mathbb{Z}_q^n</span> and <span class="math">L_1, L_2: \\mathbb{Z}_q^n \\to \\mathbb{Z}_q</span> are linear forms.</p>

    <p class="text-gray-300">Next, we describe how this relation can be reduced to the standard amortization scenario where cross terms are revealed. Simultaneously, we introduce amortized nullity checks on the appropriated coordinates of <span class="math">(\\mathbf{x}_1, u, 0)</span> and <span class="math">(\\mathbf{x}_2, 0, w)</span>. These nullity checks have to be incorporated at this stage of the protocol, otherwise they will again introduce cross terms that are to remain secret. So let <span class="math">\\rho \\in \\mathbb{Z}_q \\setminus \\{-1\\}</span> be a uniform random challenge and let us consider the following linear forms:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{L}_1: \\mathbb{Z}_q^{n+2} \\to \\mathbb{Z}_q, \\quad (\\mathbf{x}, a, b) \\mapsto L_1(\\mathbf{x}) - y_1 + b(\\rho + 1), \\\\ \\widehat{L}_2: \\mathbb{Z}_q^{n+2} \\to \\mathbb{Z}_q, \\quad (\\mathbf{x}, a, b) \\mapsto L_2(\\mathbf{x}) - y_2 + a(\\rho + 1). \\end{array} \\tag{34}</span></div>

    <p class="text-gray-300">Note that to mask the cross terms it is essential that <span class="math">\\rho \\neq -1</span>.</p>

    <p class="text-gray-300">From these derived linear forms the following relation, with public cross-terms, arises:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{R}_{\\text{shell}} = \\left\\{ \\left(\\mathbf{g}, k_1, k_2, h, P_1, P_2, L_1, L_2, y_1, y_2, y_{11}, y_{21}; \\mathbf{x}_1, \\mathbf{x}_2, u, w, u&#x27;, w&#x27;, \\gamma_1, \\gamma_2\\right): \\right. \\\\ \\left. \\begin{array}{l} P_1 = \\mathbf{g}^{\\mathbf{x}_1} k_1^u k_2^{w&#x27;} h^{\\gamma_1}, P_2 = \\mathbf{g}^{\\mathbf{x}_2} k_1^{u&#x27;} k_2^w h^{\\gamma_2}, \\widehat{L}_1(\\mathbf{x}_1, u, w&#x27;) = \\widehat{L}_2(\\mathbf{x}_2, u&#x27;, w) = 0, \\end{array} \\right. \\tag{35} \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat{L}_1(\\mathbf{x}_2, u&#x27;, w) = y_{12}, \\widehat{L}_2(\\mathbf{x}_1, u, w&#x27;) = y_{21}.</span></div>

    <p class="text-gray-300">Standard amortization techniques directly yield a <span class="math">\\Sigma</span>-protocol for <span class="math">\\widehat{R}_{\\mathrm{shell}}</span> with the desired communication complexity. However, a ZKPoK for relation <span class="math">\\widehat{R}_{\\mathrm{shell}}</span> does not yield a ZKPoK for relation <span class="math">R_{\\mathrm{shell}}</span>, since information about the masks <span class="math">u</span> and <span class="math">w</span> is revealed. For this reason, the prover first re-randomizes the shells by sending commitments <span class="math">R_1, R_2</span> to <span class="math">s_1, s_2 \\in \\mathbb{Z}_q</span> chosen uniformly at random under generators <span class="math">(k_1, h)</span> and <span class="math">(k_2, h)</span>, respectively. The prover and verifier compute the re-randomized commitments <span class="math">R_1P_1</span> and <span class="math">R_2P_2</span> and by two standard <span class="math">\\Sigma</span>-protocols the prover shows that commitments <span class="math">R_1</span> and <span class="math">R_2</span> exclusively involve the appropriate generators. After re-randomization the prover and verifier run a standard amortized <span class="math">\\Sigma</span>-protocol for relation <span class="math">\\widehat{R}_{\\mathrm{shell}}</span>.</p>

    <p class="text-gray-300">To summarize, the ZKPoK for relation <span class="math">R_{\\mathrm{shell}}</span> contains three components:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Amortized nullity checks on shelled commitments <span class="math">P_1</span> and <span class="math">P_2</span>.</li>

      <li>Re-randomization of the shells, together with the basic <span class="math">\\Sigma</span>-protocols for <span class="math">R_1</span> and <span class="math">R_2</span>.</li>

      <li>Amortized <span class="math">\\Sigma</span>-protocol for relation <span class="math">\\widehat{R}_{\\mathrm{shell}}</span>.</li>

    </ol>

    <p class="text-gray-300">The protocol is formally described in Protocol 9 and denoted by <span class="math">\\Pi_{\\mathrm{shell}}</span>. Theorem 11 summarizes its main properties. To achieve logarithmic communication complexity, compression can be applied as before. Moreover, we note that a straightforward generalization allows the compactification of any <span class="math">s &amp;gt; 1</span> compact commitments.</p>

    <p class="text-gray-300"><strong>Theorem 11.</strong> <span class="math">\\Pi_{\\mathrm{shell}}</span> is a 4-move protocol for relation <span class="math">R_{\\mathrm{shell}}</span>. It is perfectly complete, special honest verifier zero-knowledge and computationally (2,3)-special sound, under the discrete logarithm assumption. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: 5 elements of <span class="math">\\mathbb{G}</span> and <span class="math">n + 11</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">2</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness directly follows.</p>

    <p class="text-gray-300">SHVZK: On input <span class="math">\\rho,c\\in\\mathbb{Z}_{q}</span> with <span class="math">\\rho\\neq-1</span>, the simulator samples <span class="math">R_{1},R_{2}\\in\\mathbb{G}</span>, <span class="math">y_{21},y_{12},z_{1},z_{2},\\phi_{1},\\phi_{2},\\phi\\in\\mathbb{Z}_{q}</span> and <span class="math">\\mathbf{z}\\in\\mathbb{Z}_{q}^{n+2}</span> uniformly at random. From these values the simulator computes:</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=(\\mathbf{g},k_{1},k_{2})^{\\mathbf{z}}h^{\\phi}(P_{1}R_{1})^{-c}(P_{2}R_{2})^{-c^{2}},</span> (36) <span class="math">A_{1}</span> <span class="math">=k_{1}^{z_{1}}h^{\\phi_{1}}R_{1}^{-c},</span> <span class="math">A_{2}</span> <span class="math">=k_{2}^{z_{2}}h^{\\phi_{2}}R_{2}^{-c},</span> <span class="math">t_{1}</span> <span class="math">=\\widehat{L}_{1}(\\mathbf{z})-c^{2}y_{12},</span> <span class="math">t_{2}</span> <span class="math">=\\widehat{L}_{2}(\\mathbf{z})-cy_{21}.</span></p>

    <p class="text-gray-300">The resulting transcript <span class="math">\\mathsf{tr}</span> is now easily seen to be accepting. Moreover, using the fact that <span class="math">\\rho\\neq-1</span>, it follows that the probability distribution of <span class="math">\\mathsf{tr}</span> is equal to that of an honest execution.</p>

    <p class="text-gray-300">Special Soundness: Let us now show that <span class="math">\\Pi_{\\text{shell}}</span> is <span class="math">(2,3)</span>-special sound. From three accepting transcripts with coinciding first and second messages and different challenges, the extractor uses standard techniques to extract elements <span class="math">\\bar{\\mathbf{z}}_{1},\\bar{\\mathbf{z}}_{2}\\in\\mathbb{Z}_{q}^{n+2}</span> and <span class="math">\\bar{\\phi}_{1},\\bar{\\phi}_{2},\\bar{z}_{1},\\bar{z}_{2},\\bar{\\phi}_{11},\\bar{\\phi}_{21}\\in\\mathbb{Z}_{q}</span> for which it holds that</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{g},k_{1},k_{2})^{\\bar{\\mathbf{z}}_{1}}h^{\\bar{\\phi}_{1}}</span> <span class="math">=P_{1}R_{1},</span> <span class="math">\\widehat{L}_{1}(\\bar{\\mathbf{z}}_{1})</span> <span class="math">=0,</span> <span class="math">k_{1}^{\\bar{z}_{1}}h^{\\bar{\\phi}_{11}}</span> <span class="math">=R_{1},</span> (37) <span class="math">(\\mathbf{g},k_{1},k_{2})^{\\bar{\\mathbf{z}}_{2}}h^{\\bar{\\phi}_{2}}</span> <span class="math">=P_{2}R_{2},</span> <span class="math">\\widehat{L}_{2}(\\bar{\\mathbf{z}}_{2})</span> <span class="math">=0,</span> <span class="math">k_{2}^{\\bar{z}_{2}}h^{\\bar{\\phi}_{21}}</span> <span class="math">=R_{2}.</span></p>

    <p class="text-gray-300">Now let us define <span class="math">\\widehat{\\mathbf{z}}_{1}:=\\bar{\\mathbf{z}}_{1}-(0,\\ldots,0,\\bar{z}_{1},0)</span>, <span class="math">\\widehat{\\mathbf{z}}_{1}:=\\bar{\\mathbf{z}}_{2}-(0,\\ldots,0,\\bar{z}_{2})</span>, <span class="math">\\widehat{\\phi_{1}}:=\\bar{\\phi}_{1}-\\bar{\\phi}_{11}</span> and <span class="math">\\widehat{\\phi_{2}}:=\\bar{\\phi}_{2}-\\bar{\\phi}_{21}</span>. Then it holds that</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{g},k_{1},k_{2})^{\\widehat{\\mathbf{z}}_{1}}h^{\\widehat{\\phi}_{1}}</span> <span class="math">=P_{1},</span> <span class="math">\\widehat{L}_{1}(\\widehat{\\mathbf{z}}_{1})</span> <span class="math">=0,</span> (38) <span class="math">(\\mathbf{g},k_{1},k_{2})^{\\widehat{\\mathbf{z}}_{2}}h^{\\widehat{\\phi}_{2}}</span> <span class="math">=P_{2},</span> <span class="math">\\widehat{L}_{2}(\\widehat{\\mathbf{z}}_{2})</span> <span class="math">=0.</span></p>

    <p class="text-gray-300">The remainder of the proof follows from an analysis of the polynomial amortization trick. Namely, rewinding once more and running the same procedure for a different first move challenge <span class="math">\\rho^{\\prime}</span> allows the extraction of another set of elements <span class="math">\\widetilde{\\mathbf{z}}_{1},\\widetilde{\\mathbf{z}}_{2},\\widetilde{\\phi}_{1},\\widetilde{\\phi}_{2}</span> and an affine form <span class="math">\\widehat{L}</span> satisfying the relations of Equation 38. Hence, either the extractor has found a non-trivial discrete log relation or <span class="math">\\widetilde{\\mathbf{z}}_{1}=\\widehat{\\mathbf{z}}_{1}</span>, <span class="math">\\widetilde{\\mathbf{z}}_{2}=\\widehat{\\mathbf{z}}_{2}</span>, <span class="math">\\widetilde{\\phi}_{1}=\\widetilde{\\phi}_{1}</span> and <span class="math">\\widetilde{\\phi}_{2}=\\widetilde{\\phi}_{2}</span>. In the latter case it follows that <span class="math">\\widehat{\\mathbf{z}}_{1}=(\\widehat{\\mathbf{x}}_{1},a_{1},b_{1})</span> and <span class="math">\\widehat{\\mathbf{z}}_{2}=(\\widehat{\\mathbf{x}}_{2},a_{2},b_{2})</span> satisfy <span class="math">b_{1}=a_{2}=0</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{\\widehat{\\mathbf{x}}_{1}}k_{1}^{a_{1}}h^{\\widehat{\\phi}_{1}}</span> <span class="math">=P_{1},</span> <span class="math">L_{1}(\\widehat{\\mathbf{x}}_{1})</span> <span class="math">=0,</span> (39) <span class="math">\\mathbf{g}^{\\widehat{\\mathbf{x}}_{2}}k_{2}^{b_{2}}h^{\\widehat{\\phi}_{2}}</span> <span class="math">=P_{2},</span> <span class="math">L_{2}(\\widehat{\\mathbf{x}}_{2})</span> <span class="math">=0.</span></p>

    <p class="text-gray-300">Hence, Protocol <span class="math">\\Pi_{\\text{shell}}</span> is <span class="math">(2,3)</span>-special sound which proves the Theorem.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">E.2 Case 2</h3>

    <p class="text-gray-300">Let us consider the case where the prover has <span class="math">s</span> individual Pedersen commitments <span class="math">P_{i}</span> to <span class="math">v_{i}\\in\\mathbb{Z}_{q}</span>. The goal is to construct an interactive protocol that takes as public input <span class="math">P_{1},\\ldots,P_{s}</span>, as prover’s private input <span class="math">v_{1},\\ldots,v_{s}</span> and <span class="math">\\mathsf{aux}\\in\\mathbb{Z}_{q}^{t}</span> and outputs a compact commitment to <span class="math">[(v_{1},\\ldots,v_{s},\\mathsf{aux})]</span>. In fact, our solution outputs a commitment <span class="math">[(v_{1},\\ldots,v_{s},r,\\mathsf{aux})]</span> where <span class="math">r\\in\\mathbb{Z}_{q}</span> is sampled uniformly at random. This additional coefficient <span class="math">r</span> does not introduce any difficulties in applying the methods of Section 6. In contrast to Case 1, we will see that parallelization with this compactification technique immediately follows. Moreover, black-box access to our compressed pivot <span class="math">[\\cdot]</span> suffices.</p>

    <p class="text-gray-300">The main idea is to create a new compact commitment to <span class="math">(v_{1},\\ldots,v_{s},r,\\mathsf{aux})\\in\\mathbb{Z}_{q}^{s+t+1}</span> and use a standard (amortized) <span class="math">\\Sigma</span>-protocol to prove correctness of this compact commitment. The amortized <span class="math">\\Sigma</span>-protocol was, for the more general Pedersen vector commitments, described in Appendix B. More precisely, from the</p>

    <p class="text-gray-300">Protocol 9 Zero-Knowledge Proof of Knowledge  <span class="math">\\Pi_{\\mathrm{shell}}</span>  for relation  <span class="math">R_{\\mathrm{shell}}</span> Amortizing the costs of opening two different linear forms on two different Pedersen vector commitments.</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g, k1, k2, h INPUT(P1, P2, L1, L2, y1, y2; x1, x2, u, w, γ1, γ2)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">L1(x, a, b) := L1(x) - y1 + b(ρ + 1) L2(x, a, b) := L2(x) - y2 + a(ρ + 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ ← R Zq \\ {−1}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  s1, s2, ψ1, ψ2 ← R Zq R1 = k1s1hψ1, R2 = k2s2hψ2 |  |   |</p>

    <p class="text-gray-300">|  y21 = L2(x1, u + s1, 0) y12 = L1(x2, 0, w + s2) |  |   |</p>

    <p class="text-gray-300">|  r1, r2, η1, η2 ← Zq A1 = k1r1hη1, A2 = k2r2hη2 |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r ← R Zqn+2, ω ← R Zq t1 = L1(r), t2 = L2(r) A = (g, k1, k2)rhω</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1, R2, A, A1, A2, y21, y12, t1, t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ← R Zq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">amortized  <span class="math">\\Sigma</span> -protocol for proving knowledge of openings to  <span class="math">P_{1}, \\ldots, P_{s}</span> , we construct a new protocol  <span class="math">\\Pi_{P}</span> . The first message of the basic  <span class="math">\\Sigma</span> -protocol is appended with a compact commitment  <span class="math">[\\mathbf{y}] = [(v_{1}, \\ldots, v_{s}, r, \\mathsf{aux})]</span> , where  <span class="math">r</span>  is the random element to which the prover committed in the first round of the  <span class="math">\\Sigma</span> -protocol. After the final round of the  <span class="math">\\Sigma</span> -protocol, the prover and verifier run the interactive nullity check on compact commitment  <span class="math">[\\mathbf{y}]</span>  and affine form  <span class="math">L_{c}(\\mathbf{x}) - z = x_{s+1} + \\sum_{i=1}^{s} c^{i} x_{i} - z</span> , where  <span class="math">c</span>  is the verifier's challenge and  <span class="math">z</span>  is the prover's response. This nullity check shows that the commitment  <span class="math">[\\mathbf{y}]</span>  is of the correct form.</p>

    <p class="text-gray-300">Note that it is immaterial that  <span class="math">P</span>  is a Pedersen commitment. Any other commitment scheme with a  <span class="math">\\Sigma</span> -protocol that satisfies some linearity constraints suffices. In particular, the thirds message should be</p>

    <p class="text-gray-300">computed as the evaluation of a public linear form parameterized by the challenge <span class="math">c</span>. Moreover, because <span class="math">\\Pi_{P}</span> only performs a nullity check on compact commitment <span class="math">[\\mathbf{y}]</span>, parallelization with the methods of Section 6 directly follows. Namely, these methods follow from partial openings of exactly the same vector <span class="math">[\\mathbf{y}]</span>.</p>

    <p class="text-gray-300">The protocol is formally described in Protocol 10. It outputs a vector commitment <span class="math">[\\mathbf{y}]</span> and is a ZK protocol for the following relation</p>

    <p class="text-gray-300"><span class="math">R_{P}=\\left\\{(P_{1},\\ldots,P_{s},[\\mathbf{y}];v_{1},\\gamma_{1},\\ldots v_{s},\\gamma_{s},\\mathbf{y}):P_{j}=g^{v_{j}}h^{\\gamma_{j}},v_{j}=y_{j}\\quad 1\\leq j\\leq s\\right\\}.</span> (40)</p>

    <p class="text-gray-300">The properties of <span class="math">\\Pi_{P}</span> are summarized in Theorem 12.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 12.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{P}</span> is a <span class="math">(2\\mu+5)</span>-move protocol for relation <span class="math">R_{P}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(s+t+2)\\rceil-1</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(s+1,2,2,k_{1},\\ldots,k_{\\mu})</span>-special sound, under the discrete logarithm assumption, where <span class="math">k_{i}=3</span> for all <span class="math">1\\leq i\\leq\\mu</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\left\\lceil\\log_{2}(s+t+2)\\right\\rceil+1</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">5</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}(s+t+2)\\rceil+2</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness and SHVZK follow from the associated properties of the <span class="math">\\Sigma</span>-protocol and <span class="math">\\Pi_{\\text{\\tiny NULLITY}}</span>.</p>

    <p class="text-gray-300">Special soundness: We first recall the proof that shows that the basic amortized <span class="math">\\Sigma</span>-protocol is <span class="math">(s+1)</span>-special sound. Let <span class="math">(A,c_{j},\\mathbf{z}_{j},\\phi_{i})</span> be accepting transcripts for <span class="math">0\\leq j\\leq s</span> with <span class="math">c_{i}\\neq c_{j}</span> for all <span class="math">i\\neq j</span>. Let <span class="math">V</span> be the <span class="math">(s+1)\\times(s+1)</span> Vandermonde matrix generated by <span class="math">c_{0},\\ldots,c_{s}</span>. Since the challenges are distinct, it follows that <span class="math">V</span> is invertible. Let <span class="math">V^{-1}=(a_{i,j})_{0\\leq i,j\\leq s}</span> and, for <span class="math">1\\leq\\ell\\leq s</span>, let</p>

    <p class="text-gray-300"><span class="math">\\bar{z}_{\\ell}</span> <span class="math">:=\\sum_{j=0}^{s}a_{\\ell,j}\\mathbf{z}_{j},</span> (41) <span class="math">\\bar{\\gamma}_{\\ell}</span> <span class="math">:=\\sum_{j=0}^{s}a_{\\ell,j}\\phi_{j}.</span></p>

    <p class="text-gray-300">Then, it holds that <span class="math">g^{\\bar{z}_{\\ell}}h^{\\bar{\\gamma}_{\\ell}}=P_{\\ell}</span> for all <span class="math">\\ell</span>, which proves that the basic amortized <span class="math">\\Sigma</span>-protocol is <span class="math">(s+1)</span>-special sound.</p>

    <p class="text-gray-300">Special soundness of the compound protocol now follows by the <span class="math">(2,2,k_{1},\\ldots,k_{\\mu})</span>-special soundness of <span class="math">\\Pi_{\\text{\\tiny NULLITY}}</span> and the fact that for all <span class="math">\\ell</span></p>

    <p class="text-gray-300"><span class="math">\\sum_{j=0}^{s}a_{\\ell,j}L_{c_{j}}(\\mathbf{x})=x_{\\ell}.</span> (42)</p>

    <h2 id="sec-53" class="text-2xl font-bold">Appendix F Range Proof</h2>

    <p class="text-gray-300">In this section we show how two variations of range proofs can be derived as an immediate consequence of the circuit ZK protocols of Section 6. First, we treat the basic scenario where a prover wishes to commit to a secret integer <span class="math">v</span> and show that this integer is in a public range, say <span class="math">[0,2^{n-1}]</span>. Second, we consider the scenario where the prover wishes to convince a verifier that many different integer commitments are all in some fixed range.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">F.1 Basic Range Proofs</h3>

    <p class="text-gray-300">In the basic scenario the prover commits to the integer <span class="math">v\\in\\{0,\\ldots,2^{n-1}\\}</span> and the required auxiliary data <span class="math">\\mathsf{aux}</span> at once in a single compact commitment. In the following solution the prover does not commit to the integer <span class="math">v</span> explicitly, but only via its bit-decomposition <span class="math">\\mathbf{b}\\in\\mathbb{Z}_{q}^{n}</span>. Namely, note that <span class="math">v</span> can be computed as linear form</p>

    <p class="text-gray-300">Protocol 10 Extended <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_P</span> for <span class="math">s</span> Pedersen commitments</p>

    <p class="text-gray-300">|   | INPUT(<span class="math">P_1, \\ldots, P_s; v_1, \\gamma_1, \\ldots, v_s, \\gamma_s</span>, aux)</p>

    <p class="text-gray-300">OUTPUT(<span class="math">[v_1, \\ldots, v_s, r</span>, aux])  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | <span class="math">P_j = g^{v_j} h^{\\gamma_j}</span> |   |</p>

    <p class="text-gray-300">|   | <span class="math">L_a(\\mathbf{x}) := x_{s+1} + \\sum_{i=1}^{s} a^i x_i</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">r \\leftarrow_R \\mathbb{Z}_q, \\rho \\leftarrow_R \\mathbb{Z}_q</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">A = g^r h^\\rho</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">\\mathbf{y} = (v_1, \\ldots, v_s, r</span>, aux) |  |   |</p>

    <p class="text-gray-300">|   | <span class="math">A, [\\mathbf{y}]</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\leftarrow c</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">c \\leftarrow_R \\mathbb{Z}_q</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">z = r + \\sum_{i=1}^{s} c^i v_i</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">\\phi = \\rho + \\sum_{i=1}^{s} c^i \\gamma_i</span> |  |   |</p>

    <p class="text-gray-300">|   | <span class="math">z, \\phi</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pi_{\\text{NULLITY}}([\\mathbf{y}], L_c - z; \\mathbf{y})</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">g^s h^\\phi \\stackrel{i}{=} A \\prod_{i=1}^{s} P^{c^i}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">evaluated at <span class="math">\\mathbf{b}</span>, hence a compact commitment to <span class="math">\\mathbf{b}</span> is an implicit commitment to <span class="math">v</span>. To show that <span class="math">v</span> is in the range <span class="math">[0, 2^{n-1}]</span>, the prover now only has to convince the verifier that the committed vector <span class="math">\\mathbf{b}</span> is comprised of 0's and 1's, which can be done by a simple application of the circuit ZK protocol <span class="math">\\Pi_{cs}</span>.</p>

    <p class="text-gray-300">To this end, let <span class="math">C: \\mathbb{Z}_q^n \\to \\mathbb{Z}_q^n, \\mathbf{x} \\mapsto \\mathbf{x} * (1 - \\mathbf{x})</span>. Prover and verifier run <span class="math">\\Pi_{cs}</span> on input <span class="math">(C; \\mathbf{b})</span> to obtain a ZK protocol for relation</p>

    <div class="my-4 text-center"><span class="math-block">R_r = \\left\\{ (C; \\mathbf{b}) : C(\\mathbf{b}) = 0 \\right\\}. \\tag{43}</span></div>

    <p class="text-gray-300">Minor improvements to the protocol are obtained by observing that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All multiplication gates have inputs of the form <span class="math">\\alpha</span> and <span class="math">1 - \\alpha</span>. Hence, instead of sampling a random polynomial <span class="math">g(X)</span> for the right inputs of multiplication gates we take <span class="math">g(X) = 1 - f(X)</span>.</li>

      <li>All outputs of multiplications gates are 0, hence <span class="math">h(1) = h(2) = \\cdots = h(n) = 0</span> and these values do not have to be included in the compact commitment.</li>

    </ol>

    <p class="text-gray-300">The full protocol, denoted by <span class="math">\\Pi_r</span>, is described in Protocol 11. Theorem 13 shows that <span class="math">\\Pi_r</span> is a SHVZK argument of knowledge for relation <span class="math">R_r</span>.</p>

    <p class="text-gray-300"><strong>Theorem 13 (Basic Range Proof).</strong> <span class="math">\\Pi_r</span> is a <span class="math">(2\\mu + 7)</span>-move protocol for relation <span class="math">R_r</span>, where <span class="math">\\mu = \\lceil \\log_2(2n + 3) \\rceil - 1</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(2n + 1, n + 2, 2, 2, k_1, \\ldots, k_\\mu)</span>-special sound, under the discrete logarithm assumption, where <span class="math">k_i = 3</span> for all <span class="math">1 \\leq i \\leq \\mu</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">2\\lceil \\log_2(2n + 3) \\rceil</span> elements of <span class="math">\\mathbb{G}</span> and 5 elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\lceil \\log_2(2n + 3) \\rceil + 3</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <h2 id="sec-55" class="text-2xl font-bold">F.2 Compactifying Many Pedersen Commitments</h2>

    <p class="text-gray-300">Let us now consider the case of a prover that wishes to show that <span class="math">s</span> Pedersen commitments to <span class="math">v_1, \\ldots, v_s \\in \\mathbb{Z}_q</span> are all in the range <span class="math">[0, 2^{n-1}]</span>. For the corresponding relation we write <span class="math">R_r^{(s)}</span>. The protocol, denoted by <span class="math">\\Pi_r^{(s)}</span>, is constructed by deploying a minor adaptation of the "Case 2" compactification techniques of Section 5.3. The compactification techniques are easily adapted to obtain a single compact commitment to the <span class="math">ns</span> bits of the <span class="math">s</span> committed values together with the auxiliary data required to prove their correctness. The properties of <span class="math">\\Pi_r^{(s)}</span> are given by the following theorem.</p>

    <p class="text-gray-300">Protocol 11 Range proof  <span class="math">\\varPi_r</span> The polynomial  <span class="math">f</span>  is sampled uniformly at random such that its evaluations at  <span class="math">1, \\ldots, n</span>  correspond to  <span class="math">\\mathbf{b}</span> .</p>

    <p class="text-gray-300">|   | INPUT(C;b)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | C: Zqn → Zqn, x ↦ x * (1 - x) C(b) = 0  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z1 = f(c) z2 = h(c)</td>

            <td class="px-3 py-2 border-b border-gray-700">z1,z2 →</td>

            <td class="px-3 py-2 border-b border-gray-700">z2 ≡ z1(1 - z1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ΠNULITY(C(b) [y], f(c) - z1; y h(c) - z2) |   |</p>

    <p class="text-gray-300">Theorem 14 (Range Proof Case 2).  <span class="math">\\Pi_r^{(s)}</span>  is a  <span class="math">(2\\mu +7)</span> -move protocol for relation  <span class="math">R_{r}^{(s)}</span> , where  <span class="math">\\mu = \\lceil \\log_2(2ns + 4)\\rceil -1</span> . It is perfectly complete, special honest-verifier zero-knowledge and computationally ( <span class="math">s + 1,2ns + 1,ns + 3,2,2,k_1,\\ldots ,k_\\mu</span> )-special sound, under the discrete logarithm assumption, where  <span class="math">k_{i} = 3</span>  for all  <span class="math">1\\leq i\\leq \\mu</span> . Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">2\\lceil \\log_2(2ns + s + 4)\\rceil +1</span>  elements of  <span class="math">\\mathbb{G}</span>  and 7 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\lceil \\log_2(2ns + s + 4) \\rceil + 4</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">In this appendix we informally sketch the approach of [BFS20] along with our adaptations to allow for the opening of arbitrary linear forms. This adaptations can be used to base our pivot on assumptions derived from the Strong-RSA assumption.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We briefly recall the integer commitment scheme of [DF02]. The commitment space of this scheme is a group  <span class="math">\\mathbb{G}</span>  of unknown order, such as an RSA group or a class group. Although the exact order of  <span class="math">\\mathbb{G}</span>  is unknown, we do assume to know an upper bound  <span class="math">B</span>  on the order, i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The setup phase of the commitment scheme generates two random group elements  <span class="math">g, h \\in \\mathbb{G}</span>  such that they both generate the same subgroup of  <span class="math">\\mathbb{G}</span> . In this case the distribution of  <span class="math">h^\\gamma</span>  for  <span class="math">\\gamma</span>  chosen uniformly at random from  <span class="math">[0, B \\cdot 2^\\kappa)</span> , where  <span class="math">\\kappa</span>  is the security parameter, will be exponentially close to the uniform distribution on  <span class="math">\\langle g \\rangle</span> . Hence for an arbitrary integer  <span class="math">x</span> , the element  <span class="math">[x] = g^x h^\\gamma \\in \\mathbb{G}</span>  statistically hides  <span class="math">x</span> .</p>

    <p class="text-gray-300">Intuitively, the binding property follows from the assumption that the prover does not know the order of  <span class="math">\\mathbb{G}</span> . Formally, the binding property can be shown to follow from the root assumption [DF02, BFS20].</p>

    <p class="text-gray-300">G.2 Vector Encoding</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The vector encoding scheme of [BFS20] first lifts vectors <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span> to their unique representatives in $\\mathbb{Z}\\left(\\frac{q - 1}{2}\\right)^n = \\{\\mathbf{x} \\in \\mathbb{Z}^n : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\frac{q - 1}{2}\\}<span class="math">. Subsequently, for any </span>b \\in \\mathbb{Z}<span class="math"> and </span>Q &gt; 2b$ the following encoding is applied:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Encode}: \\mathbb{Z}(b)^n \\to \\mathbb{Z}, \\quad \\mathbf{x} \\mapsto \\sum_{i=1}^{n} x_i Q^{i-1}. \\tag{44}</span></div>

    <p class="text-gray-300">This encoding is injective since <span class="math">Q &amp;gt; 2b</span>. For both <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span> and <span class="math">\\mathbf{x} \\in \\mathbb{Z}(b)^n</span>, we will write <span class="math">\\widehat{\\mathbf{x}} \\in \\mathbb{Z}</span> for their integer encodings. A commitment <span class="math">[\\mathbf{x}]</span> to a vector <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span> or <span class="math">\\mathbf{x} \\in \\mathbb{Z}(b)^n</span> is an integer commitment to <span class="math">\\widehat{\\mathbf{x}}</span>.</p>

    <p class="text-gray-300">G.3 <span class="math">\\Sigma</span>-Protocol</p>

    <p class="text-gray-300">The above thus generates a compact vector commitment scheme <span class="math">[\\cdot]: \\mathbb{Z}_q^n \\to \\mathbb{G}</span>. For a linear form <span class="math">L: \\mathbb{Z}_q^n \\to \\mathbb{Z}_q</span>, this commitment scheme has a basic <span class="math">\\Sigma</span>-protocol for the relation</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathbb{Z}_q} = \\left\\{ \\left( P \\in \\mathbb{G}, u \\in \\mathbb{Z}_q, Q \\in \\mathbb{Z}, L; \\mathbf{x} \\in \\mathbb{Z}_q^n, \\gamma \\in \\mathbb{Z}_q \\right): P = g^{\\widehat{\\mathbf{x}}} h^{\\gamma}, L(\\mathbf{x}) = \\mathbf{u}, Q &amp;gt; q \\right\\}. \\tag{45}</span></div>

    <p class="text-gray-300">The main differences between this <span class="math">\\Sigma</span>-protocol and protocol <span class="math">\\Pi_0</span> from Section 3 is that the protocol is statistically hiding and all exponents are sampled from subsets of <span class="math">\\mathbb{Z}</span>. For this reason, the verifier has to check that the final response is of bounded norm. A similar <span class="math">\\Sigma</span>-protocol is described in [BFS20].</p>

    <p class="text-gray-300">Protocol 12 Basic <span class="math">\\Sigma</span>-protocol for inner product relation <span class="math">R_{\\mathbb{Z}_q}</span></p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: <span class="math">g, h</span> INPUT(<span class="math">P, Q, L; \\mathbf{x}, \\gamma</span>)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | <span class="math">P = g^{\\widehat{\\mathbf{x}}} h^{\\gamma} \\in \\mathbb{G}</span> |   |</p>

    <p class="text-gray-300">|   | <span class="math">u = L(\\mathbf{x}) \\in \\mathbb{Z}_q^m</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbf{r} \\leftarrow_R \\mathbb{Z} \\left( (q - 1)^2 2^{\\kappa - 2} \\right)^n</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">\\rho \\leftarrow_R [0, B \\cdot 2^\\kappa)</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">t = L(\\mathbf{r}) \\mod q</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">A = g^{\\widehat{\\mathbf{r}}} h^\\rho</span> |  |   |</p>

    <p class="text-gray-300">|   | <span class="math">\\xrightarrow{t, A}</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\leftarrow_c</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">c \\leftarrow_R \\left[ -\\frac{q - 1}{2}, \\frac{q - 1}{2} \\right]</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbf{z} = c\\mathbf{x} + \\mathbf{r} \\in \\mathbb{Z}^n</span> |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\phi = c\\gamma + \\rho \\in \\mathbb{Z}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\xrightarrow{\\phi, \\mathbf{z}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | <span class="math">g^{\\mathbf{z}} h^\\phi \\stackrel{\\gamma}{\\underset{\\gamma}{\\rightleftarrows}} P^c A</span>  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\stackrel{\\sim}{\\sim} q^2 2^{\\kappa - 1}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | <span class="math">L(\\mathbf{z}) \\stackrel{\\sim}{=} cu + t</span>  |</p>

    <p class="text-gray-300">G.4 Compressed <span class="math">\\Sigma</span>-Protocol</p>

    <p class="text-gray-300">The protocol can be compressed by observing that the response <span class="math">\\mathbf{z}</span> is, in fact, a trivial PoK for the relation <span class="math">R_{\\mathbb{Z}}</span>.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{\\mathbb{Z}} = \\left\\{ \\left( P \\in \\mathbb{G}, u \\in \\mathbb{Z}_q, Q, b \\in \\mathbb{Z}, L; \\mathbf{x} \\in \\mathbb{Z}^n \\right): \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq b &lt; q, P = g^{\\widehat{\\mathbf{x}}}, L(\\mathbf{x}) = u \\mod p \\right\\}. \\tag{46}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Following Bulletproof's recursive techniques a more efficient PoK for relation  <span class="math">R_{\\mathbb{Z}}</span>  can be constructed. Protocol 13 shows one iteration of the recursion, repeating this recursion  <span class="math">O(\\log n)</span>  times results in a logarithmic complexity. It must be noted that the bound  <span class="math">b</span>  grows in each iteration. For this reason the encoding parameter  <span class="math">Q</span>  has to be chosen large enough. The polynomial evaluation protocol of [BFS20] replaces the computationally expensive exponentiation after the first move (i.e., computing  <span class="math">A_R^{n/2}</span> ) by a Proof of Exponentiation [Wes19], thereby reducing the verification time. For details we refer to [BFS20].</p>

    <p class="text-gray-300">Another difference between this approach and the compression in the discrete log setting is that here the linear form evaluation  <span class="math">L(\\mathbf{x})</span>  is not included in the commitment. For this reason the cross terms  <span class="math">A_{R}</span>  and  <span class="math">A_{L}</span>  are part of the first message.</p>

    <p class="text-gray-300">Protocol 13 Compressed Argument of Knowledge for relation  <span class="math">R_{\\mathbb{Z}}</span> PUBLIC PARAMETERS:  <span class="math">g</span>  INPUT  <span class="math">(P,u,Q,b,L;\\mathbf{x})</span></p>

    <p class="text-gray-300">|  x ∈ Z(b)n P = g^k L(x) = u mod q  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AL← g^kL AR← g^kR uL=LR(xL) uR=LL(xR)</td>

            <td class="px-3 py-2 border-b border-gray-700">AL,ARuL,uR→ ALARn/2? = P c←R{−p-1/2, ..., p-1/2}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z=cxL+xR</td>

            <td class="px-3 py-2 border-b border-gray-700">g^k? = A^cLAR (LL+cLR)(z)? cu+c^2uL+uR 0≤b<Q/2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">∞ < bq+1/2</td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Compressed $\Sigma$-Protocol Theory and Practical Applicatio... (2020/152)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/152
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
