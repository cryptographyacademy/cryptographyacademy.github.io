---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/916';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = '3 Defining Fairness';
const AUTHORS_HTML = 'We turn to defining our notion of fairness. Roughly speaking, a blockchain protocol is  $\\delta$ -approximately fair w.r.t.  $\\rho$  attackers if, with overwhelming probability, any honest subset controlling  $\\phi$  fraction of the compute power is guaranteed to get at least a';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold">FruitChains: A Fair Blockchain</h2>

    <p class="text-gray-300">Rafael Pass Cornell Tech rafael@cs.cornell.edu</p>

    <p class="text-gray-300">Elaine Shi Cornell University elaine@cs.cornell.edu</p>

    <p class="text-gray-300">May 5, 2017</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Nakamoto's famous blockchain protocol enables achieving consensus in a so-called permissionless setting—anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players. His ingenious protocol prevents &quot;sybil attacks&quot; (where an adversary spawns any number of new players) by relying on <em>computational puzzles</em> (a.k.a. &quot;moderately hard functions&quot;) introduced by Dwork and Naor (Crypto'92). Recent work by Garay et al (EuroCrypt'15) and Pass et al (manuscript, 2016) demonstrate that this protocol provably achieves consistency and liveness assuming a) honest players control a majority of the computational power in the network, b) the puzzle-hardness is appropriately set as a function of the maximum network delay and the total computational power of the network, and c) the computational puzzle is modeled as a random oracle. Assuming honest participation, however, is a strong assumption, especially in a setting where honest players are expected to perform a lot of work (to solve the computational puzzles). In Nakamoto's Bitcoin application of the blockchain protocol, players are <em>incentivized</em> to solve these puzzles by receiving rewards for every &quot;block&quot; (of transactions) they contribute to the blockchain. An elegant work by Eyal and Sirer (Financial Crypt'14), strengthening and formalizing an earlier attack discussed on the Bitcoin forum, demonstrates that a coalition controlling even a minority fraction of the computational power in the network can gain (close to) 2 times its &quot;fair share&quot; of the rewards (and transaction fees) by deviating from the protocol instructions. In contrast, in a fair protocol, one would expect that players controlling a  <span class="math">\\phi</span>  fraction of the computational resources to reap a  <span class="math">\\phi</span>  fraction of the rewards.</p>

    <p class="text-gray-300">In this work, we present a new blockchain protocol—the FruitChain protocol—which satisfies the same consistency and liveness properties as Nakamoto's protocol (assuming an honest majority of the computing power), and additionally is  <span class="math">\\delta</span> -approximately fair: with overwhelming probability, any honest set of players controlling a  <span class="math">\\phi</span>  fraction of computational power is guaranteed to get at least a fraction  <span class="math">(1-\\delta)\\phi</span>  of the blocks (and thus rewards) in any  <span class="math">\\Omega(\\frac{\\kappa}{\\delta})</span>  length segment of the chain (where  <span class="math">\\kappa</span>  is the security parameter). As a consequence, if this blockchain protocol is used as the ledger underlying a cryptocurrency system, where rewards and transaction fees are evenly distributed among the miners of blocks in a length  <span class="math">\\kappa</span>  segment of the chain, no coalition controlling less than a majority of the computing power can gain more than a factor  <span class="math">(1+3\\delta)</span>  by deviating from the protocol (i.e., honest participation is an  <span class="math">\\frac{n}{2}</span> -coalition-safe  <span class="math">3\\delta</span> -Nash equilibrium). Finally, the FruitChain protocol enables decreasing the variance of mining rewards and as such significantly lessens (or even obliterates) the need for mining pools.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Distributed systems have been historically analyzed in a closed setting—a.k.a. the permissioned setting—in which the number of participants in the system, as well as their identities, are common knowledge. In 2008, Nakamoto <a href="#page-26-0">[Nak08]</a> proposed his celebrated &quot;blockchain protocol&quot; which attempts to achieve consensus in a permissionless setting: anyone can join (or leave) the protocol execution (without getting permission from a centralized or distributed authority), and the protocol instructions do not depend on the identities of the players. The core blockchain protocol (a.k.a. &quot;Nakamoto consensus&quot;, or the &quot;Bare-bones blockchain protocol&quot;), roughly speaking, is a method for maintaining a public, immutable and ordered ledger of records (for instance, in the Bitcoin application, these records are simply transactions); that is, records can be added to the end of the ledger at any time (but only to the end of it); additionally, we are guaranteed that records previously added cannot be removed or reordered and that all honest users have a consistent view of the ledger—we refer to this as consistency. Additionally, the protocol should satify a liveness property: transactions submitted by an honest user get incorporated into the ledger sufficiently fast.</p>

    <p class="text-gray-300">The key challenge with the permissionless setting is that an attacker can trivially mount a socalled &quot;sybil attack&quot;—it simply spawns lots of players (that it controls) and can thus easily ensure that it controls a majority of all the players. Indeed, Barak et al <a href="#page-25-0">[BCL</a>+05] proved that this is a fundamental problem with the permissionless model. Nakamoto blockchain protocol overcomes this issue by relying on &quot;computational puzzles&quot;—a.k.a. moderately hard functions or proofs of work put forth by Dwork and Naor <a href="#page-25-1">[DN92]</a>: roughly speaking, the participants are required to solve the computational puzzle of some well-defined diffulty in order to confirm transactions—this is referred to as mining. Next, rather than attempting to provide robustness whenever the majority of the participants are honest (since participants can be easily spawned in the permissionless setting), Nakamoto's goal was to provide robustness of the protocol under the assumption that a majority of the computing power is held by honest participants. Indeed, recent works by Garay et al. <a href="#page-25-2">[GKL15]</a> and Pass et al. <a href="#page-26-1">[PSS17]</a> formally proved that Nakamoto's blockchain protocol satisfies the abovementioned consistency and liveness under different network assumptions, as long as the puzzle difficulty (referred to as the mining hardness) is apporpriately set as a function of the maxiumum delay in the network.</p>

    <p class="text-gray-300">Nakamoto's blockchain represents an exciting breakthrough: it demonstrated that distributed consensus is possible on an Internet scale. The above analyses, however, assume that a majority of the computing power is controlled by honest players, and that honest players correctly execute the protocol. Assuming such honest participation is a strong assumption, especially in a setting where honest players are expected to perform a lot of work (to solve the computational puzzles)—why would we expect players to want to participate if it is costly! (This can be formalized in the Game-Theory with Costly computation framework of Halpern and Pass <a href="#page-26-2">[HP15]</a>). In Nakamoto's ingenious Bitcoin application of the blockchain protocol, players are thus incentivized to solve these puzzles by receiving, so-called, block rewards for every &quot;blocks&quot; (of transactions) they contribute to the blockchain; additionally, the miners also receive transaction fees for all the transactions that are confirmed in the block. The hope is that these reward mechanism (block rewards and transaction fees) properly incentivize honest participation. Unfortunately, as shown by several recent work, this is not the case:</p>

    <p class="text-gray-300">• Selfish mining undermines incentive compatibility. Nakamoto's blockchain suffers from a so-called selfish-mining attack, where even a minority coalition that controls network delivery can manage to reap close to twice its fair share of block rewards <a href="#page-26-3">[mtg10,</a> <a href="#page-25-3">ES14,</a> <a href="#page-26-4">SSZ16,</a> <a href="#page-25-4">CKWN16,</a> <a href="#page-26-5">NKMS16]</a> — in particular, if the adversary wields close to a half of the computational power, it can reap almost all of the rewards, thus denying honest players of (almost) any reward! (More specifically, whenever the adversary mines a new block, it simply withholds it (not sharing it with the honest players), and only releases it when some honest player mines a new block—if the adversary controls the network it can ensure that all honest players receive the adversarial block before the block mined by the honest players, and as such, it effectively &quot;erases&quot; the honest player's block replacing it with its own block.) This selfish mining attack was first observed in discussions on the Bitcoin forum [mtg10]; the first analytical study provided by Eyal and Sirer [ES14], and subsequently improved by Sapirshtein et al. [SSZ16] and Nayak et al. [NKMS16].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Transaction fees exacerbate instability. Due to Bitcoin's particular coin minting schedule, the block reward is scheduled to decrease over time and miners are expected to obtain rewards increasingly more from transaction fees. A recent work by Carlsten et al. [CKWN16] (concurrent to ours) demonstrates that the situation gets even worse once we take into account the transaction fees: as a simplest example, if a block contains transactions with large fees, miners will be incentivized to create a &quot;fork&quot; and attempt to confirm the transaction themselves.</li>
      <li>Mining pools harm decentralization. Finally, to maintain consistency of the blockchain, the puzzle difficulty is (and by the analysis of [PSS17] need to be set) so that the whole world combined mines a block (i.e., solves a computational puzzle) roughly every 10 minutes. As a consequence, an individual &quot;solo miner&quot; with state-of-the-art equiment needs to wait on average, roughly, 2 years before it gets any rewards [sol]. This has led to the formation of &quot;mining pools&quot; where miners are coordinated by a pool operator and share the rewards to reduce the variance of their gains. In essence, the decentralized nature of the blockchain is lost.</li>
    </ul>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">In this work, we introduce a notion of fairness for blockchain protocols: Roughly speaking, we say that a blockchain protocol that is fair if honest players that wield  <span class="math">\\phi</span>  fraction of the computational resources will reap at least  <span class="math">\\phi</span>  fraction of the blocks in any sufficiently long window of the chain. (This notion of fairness can be viewed as a strengthen form of the notion of &quot;ideal chain quality&quot; considered, but not acheived, in [GKL15,PSS17]) More precisely, we say that a blockchain protocol is  <span class="math">\\delta</span> -approximately fair w.r.t.  <span class="math">\\rho</span>  attackers if, with overwhelming probability, any  <span class="math">\\phi</span>  fraction coalition of honest users is guaranteed to get at least a  <span class="math">(1 - \\delta)\\phi</span>  fraction of the blocks in every sufficiently long window of the chain, even in the presence of an adversary controlling up to a  <span class="math">\\rho</span>  fraction of the computing power. Our main theorem shows how to acheive a blockchain which satisfies the same consistency and liveness properties as Nakamoto's one, as well as fairness:</p>

    <p class="text-gray-300"><strong>Theorem 1.1</strong> (Informally stated). Let  <span class="math">\\rho &lt; \\frac{1}{2}</span>  be a constant. Then, for every constant  <span class="math">\\delta &gt; 0</span> , there exists a blockchain protocol that satisfies consistency, liveness and  <span class="math">\\delta</span> -approximate fairness.</p>

    <p class="text-gray-300">Note that approximate fairness directly implies that an attacker cannot get &quot;much&quot; more than its fair share of the block rewards (and thus it disincentivizes selfish mining). But the instability issue with transaction fees still remains, and so does the mining pool issue. We finally demonstrate that our protocol provides a solution to both these issues as well:</p>

    <p class="text-gray-300">• Regarding transaction fees: we suggest a method for spreading out the transaction fees of a block over the miners of a sequence of blocks preceeding it. As we show, any fair blockchain protocol can be used to disincentivize deviation even in the presence of transaction fee under this new reward rule. More precisely, we show that no coalition controlling less than a majority of the computing power can gain more than a factor  <span class="math">(1+3\\delta)</span>  of the block rewards and transaction fees by deviating from the protocol—that is, honest participation is an  <span class="math">\\frac{n}{2}</span> -coalition-safe  <span class="math">3\\delta</span> -Nash equilibrium.</p>

    <p class="text-gray-300">• Regarding mining pools, we demonstrate that the block (i.e., fruit) mining difficulty in our protocol can be made almost arbitrarily small, and as a consequence, miners can get paid much more often. Indeed, experimental results implenting our new blockchain <a href="#page-25-6">[BHP</a>+] show that with Bitcoin current block size of 1MB, by sacrificing 8% to 10% of the block to new meta data, we can ensure that miners get paid 1000x more often (and thus on average, roughly, twice per day). Consequently, there is no longer a need for pooled mining.</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.2 Protocol Overview</h2>

    <p class="text-gray-300">To explain our protocol, let us first recall Nakamoto's blockchain protocol as we will make use of it.</p>

    <p class="text-gray-300">Nakamoto's protocol in a nutshell. Roughly speaking, players &quot;confirm&quot; records/transactions by &quot;mining blocks of transactions&quot; through solving some computational puzzle that is a function of the transactions and the history so far. More precisely, each participant maintains its own local &quot;chain&quot; of &quot;blocks&quot; of records —called the blockchain. Each block consists of a triple (h−1, η, m) where h−&lt;sup&gt;1&lt;/sup&gt; is a pointer to the previous block in chain, m is the record component of the block, and η is a &quot;proof-of-work&quot;—a solution to a computational puzzle that is derived from the pair (h−1, m). The proof of work can be thought of as a &quot;key-less digital signature&quot; on the whole blockchain up until this point.</p>

    <p class="text-gray-300">Concretely, Nakamoto's protocol is parametrized by a parameter p—which we refer to as the mining hardness parameter, and a proof-of-work is deemed valid if η is a string such that H(h−1, η, m) &lt; Dp, where H is a hash function (modeled as a random oracle) and D&lt;sup&gt;p&lt;/sup&gt; is set so that the probability that an input satisfies the relation is less than p. At any point of the protocol execution, each participant attempts to increase the length of its own chain by &quot;mining&quot; for a new block: upon receiving some record m, it picks a random η and checks whether η is a valid proof of work w.r.t. m and h−1, where h−&lt;sup&gt;1&lt;/sup&gt; is a pointer to the last block of its current chain; if so, it extends is own local chain and broadcast it to the all the other participants. Whenever a participant receives a chain that is longer than its own local chain, it replaces its own chain with the longer one.</p>

    <p class="text-gray-300">The FruitChain protocol. Roughly speaking, our protocol, which we refer to as the FruitChain protocol, will be running an instance of Nakamoto's blockchain protocol, but instead of directly storing the records m inside the blockchain, the records are put inside &quot;fruits&quot; denoted f; these fruits themselves require solving some proof of work, with a different hardness parameter p&lt;sup&gt;f&lt;/sup&gt; ; additionally, we require the fruits to &quot;hang&quot; from a block in the chain which is not too &quot;far&quot; from the block which records the fruit—more specifically, the fruit needs to &quot;point&quot; to an earlier block in the chain which is not too far from the block containing it (and thus, the fruit could not have been mined &quot;too&quot; long ago)—we refer to such a fruit as being recent. In this new protocol, the fruits play the roles of &quot;blocks&quot;—i.e., &quot;orange is the new block&quot;<a href="#page-3-0">1</a>—and chain quality is thus defined in terms of fruits.</p>

    <p class="text-gray-300">In each round, honest players simultaneously mine for a fruit and a block (for Nakamoto's blockchain) by making one invocation of the hash function—this follows the 2-for-1 trick of <a href="#page-25-2">[GKL15]</a> where, say, the prefix of the output of H determines whether fruit mining is successful, and the suffix is used to determine whether block mining is successful. Whenever a player successfully mines a fruit it broadcasts it to all other players; fruits that have not yet been recorded in the blockchain (and that are still recent) are stored in a buffer and all honest players next attempt to add them to the blockchain.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;We thank Hugo Krawczyk for this phrase!</p>

    <p class="text-gray-300">Intuitively, the reason why &quot;selfish mining&quot; fails is that even if an adversary tries to &quot;erase&quot; some block mined by an honest player (which contains some honest fruits), by the chain growth and chain quality properties of the underlying blockchain, eventually an honest player will mine a new block which is stable and this honest player will include the fruits in it—in fact, the time before such an &quot;honest block&quot; arrives is short enough for the fruit to still be &quot;recent&quot; at the time of the honest block arriving.</p>

    <p class="text-gray-300">Intuitively, the reason why we require fruits to be recent is to prevent a different kind of attack: without it, an attacker could withhold fruits, and suddenly release lots of them at the same time, thereby creating an very high fraction of adversarial fruits in some segment of the (fruit) chain. By requiring the fruits to be recent, we prevent the adversary from squirreling away (too many of) its fruits: since the underlying blockchain has a guaranteed liveness, we can upperbound the extra amount of time the attacker can withhold fruits and thus upperbound the number of extra fruits it can release in any window.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">Comparison with GHOST, the Inclusive Blockchain, and [GKL15] Although our approach of including fruits in a main blockchain take inspiration from to the earlier elegant works on GHOST [SZ15] and inclusive blockchains [LSZ15], we stress that these earlier works do not attain our goals of providing a provably secure, fair blockchain. GHOST [SZ15] is a mechanism such that forking blocks not on the main chain will affect the chain selection rule— however, as the subsequent work by Kiayias and Panagiotakos [KP16] shows, GHOST actually worsens &quot;chain quality&quot; (i.e., the fraction of honest blocks in the chain) whereas our goal is to improve chain quality and fairness. The inclusive blockchain work proposes to maintain a direct acyclic graph rather than a chain, such that forking subtrees may be included in the linearized transaction log — despite the superficial resemblance at first sight, the mechanisms employed by the inclusive blockchain is actually quit different from how we include fruits in the main blockchain.</p>

    <p class="text-gray-300">As mentionned above, our protocol borrows the 2-for-1 trick from the work Garay et al [GKL15] which also relied on a separate &quot;mining process&quot; to acheive a different goal (namely, to implement a broadcast channel from a blockchain).</p>

    <p class="text-gray-300"><strong>Subsequent works.</strong> In both Nakamoto's blockchain protocol and ours, the time needed to confirm transactions grows with the worst-case upper-bound on the network delay [PS16, PSS17]. In contrast, in a responsive protocol, we require the confirmation time to only be a function of the actual network delay, which may be a lot smaller than the worst-case one. In a companion paper called hybrid consensus [PS16], we show how to combine any blockchain protocol with classical asynchronous consensus to improve the latency of the blockchain protocol and achieve a responsive protocol. Roughly speaking, hybrid consensus makes use of a blockchain to elect a committee more specifically, the miners of blocks in a sufficiently long segment of the chain are elected as the committee—and then this committee executes the classical consensus protocol. The chain quality of the blockchain determines the fraction of honest players in the committee: if we employ Nakamoto's block chain, we would need to require that  <span class="math">\\frac{3}{4}</span>  of the computing power is controlled by honest player to ensure a chain quality of  <span class="math">\\frac{2}{3}</span>  and thus a fraction  <span class="math">\\frac{2}{3}</span>  honest committee members (which is required by the consensus protocol). In contrast, by relying on our new FruitChain protocol, it suffices to assume that  <span class="math">\\frac{2}{3}</span>  of the computing power is controlled by honest players. We highlight that, as shown in [PS16], achieving a responsive protocol also requires assuming that  <span class="math">\\frac{2}{3}</span>  of the computing is held by honest parties, and as such relying on our FruitChain protocol enables achieving an optimal resilience for low-latency blockchains.</p>

    <p class="text-gray-300">Besides hybrid consensus, other subsequent works have also employed ideas from FruitChain to achieve incentive compatibility in blockchain style protocols. Notably, recent provably secure</p>

    <p class="text-gray-300">proof-of-stake protocols, including Snow White [BPS16] and Ouroboros [KRDO16], argue that the idea from FruitChain is applicable to non-proof-of-work blockchains as well.</p>

    <p class="text-gray-300">Other related works. Kiayias et al. [KKKT16] model Bitcoin mining as a game, where nodes decide on which blocks to extend and whether to release a mined block. They show that for small players controlling less than  <span class="math">\\frac{1}{3}</span>  of the resources, following Bitcoin's protocol specification is a Nash equilibrium. Their results, however, only apply to a rather constrained idealistic model where all honest miners can communicate with 0 latency, and the adversary cannot perform form any network level attacks (such as rushing). As we mentionned in the introduction, in our model where the adversary can control the delivery of messages, the bitcoin protocol is not incentive compatible even for players controlling less than a  <span class="math">\\frac{1}{3}</span>  of the computational resources—there is a selfish mining attack which enables an attacker to gain  <span class="math">\\frac{1}{2}</span>  of the block rewards.</p>

    <h2 id="sec-7" class="text-2xl font-bold">1.4 Roadmap</h2>

    <p class="text-gray-300">In Section 2, we define the protocol execution model and the formal abstraction of a blockchain protocol. In Section 3, we present our new fairness definition for a blockchain protocol. In Section 4, we formally present our FruitChain protocol. In Section 5, we provide formal proofs for our main theorem. In Section 6, we describe how, given any (approximately) fair blockchain, we can design payout mechanisms to achieve incentive compatibility and  <span class="math">\\epsilon</span> -Nash equilibrium. Finally, in Section 7, we describe how FruitChain can also be used to disincentivize mining pools and ensure the decentralized nature of a blockchain.</p>

    <h2 id="sec-8" class="text-2xl font-bold">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;2 Preliminaries and Definitions</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Protocol Execution Model and Notations</h3>

    <p class="text-gray-300">A protocol refers to an algorithm for a set of interactive Turing Machines (also called nodes) to interact with each other. The execution of a protocol  <span class="math">\\Pi</span>  that is directed by an environment  <span class="math">Z(1^{\\kappa})</span>  (where  <span class="math">\\kappa</span>  is a security parameter), which activates a number of parties  <span class="math">1, 2, \\ldots, n</span>  as either &quot;honest&quot; or corrupted parties. Honest parties would faithfully follow the protocol's prescription, whereas corrupt parties are controlled by an adversary A which reads all their inputs/message and sets their outputs/messages to be sent.</p>

    <p class="text-gray-300">The environment Z is a terminology often used in protocol composition in the cryptography literature — one can regard the environment Z a catch-all term that encompasses everything that lives outside the &quot;box&quot; defined by the protocol. For example, as mentioned later, part of the environment Z's job is to provide inputs to honest nodes and receive outputs from them. This models the fact that the inputs to the protocol may originate from external applications and the protocol's outputs can be consumed by external applications where any external application or other protocols running in the system are viewed as part of Z.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A protocol's execution proceeds in rounds that model atomic time steps. At the beginning of every round, honest nodes receive inputs from an environment Z; at the end of every round, honest nodes send outputs to the environment Z.</li>
      <li>A is responsible for delivering all messages sent by parties (honest or corrupted) to all other parties. A cannot modify the content of messages broadcast by honest players, but it may delay or reorder the delivery of a message as long as it eventually delivers all messages. (Later, we</li>
    </ul>

    <p class="text-gray-300">shall consider restrictions on the delivery time.) The identity of the sender is not known to the recipient.<a href="#page-6-0">2</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At any point, Z can corrupt an honest party j which means that A gets access to its local state and subsequently, A controls party j. (In particular, this means we consider a model with &quot;erasures&quot;; random coin tosses that are no longer stored in the local state of j are not visible to A.)<a href="#page-6-1">3</a></li>
      <li>At any point, Z can uncorrupt a corrupted player j, which means that A no longer controls j. A player that becomes uncorrupt is treated in the same way as a newly spawning player, i.e., the player's internal state is re-initialized and then the player starts executing the honest protocol no longer controlled by A.</li>
    </ul>

    <p class="text-gray-300">Notations for randomized execution. A protocol's execution is randomized, where the randomness comes from honest players as well as the adversary denoted A that controls all corrupt nodes, and the environment Z that sends inputs to honest nodes during the protocol execution. We use the notation view $ ←EXECΠ(A, Z, κ) to denote a randomly sampled execution trace, and |view| denotes the number of rounds in the execution trace view. More specifically, view is a random variable denoting the joint view of all parties (i.e., all their inputs, random coins and messages received, including those from the random oracle) in the above execution; note that this joint view fully determines the execution.</p>

    <p class="text-gray-300">Constraints on (A, Z). The environment Z and the adversary A must respect certain constraints. We say that a p.p.t. pair (A, Z) is (n, ρ, ∆)-respecting w.r.t. Π, iff for every κ ∈ N, every view view in the support of EXECΠ(A, Z, κ), the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Z activates n parties in view;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any message broadcast by an honest player at any time t in view, any player that is honest at time t+∆ or later must have received the message. This means that in the case of newly spawned players, instantly delivers messages that were sent more than ∆ rounds ago. As long as this ∆ contraint is respected, A is allowed to delay or reorder honest players' messages arbitrarily.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>at any round r in view, A controls at most ρ · n parties; and</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let Γ(·, ·, ·) be a boolean predicate. We say that a p.p.t. pair (A, Z) is Γ-compliant w.r.t. protocol π iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(A, Z) is (n, ρ, ∆)-respecting w.r.t. π; and</li>
      <li>Γ(n, ρ, ∆) = 1.</li>
    </ul>

    <p class="text-gray-300">In other words Γ is a predicate that places constraints on additional constraints on the parameter (n, ρ, ∆) that (A, Z) must respect. When the context is clear, we often say that (A, Z) is Γ-compliant while omitting to specify w.r.t. which protocol.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;2&lt;/sup&gt;We could also consider a seemingly weaker model where messages sent by corrupted parties need not be delivered to all honest players. We can easily convert the weaker model to the stronger model by having honest parties &quot;gossip&quot; all messages they receive.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;3&lt;/sup&gt;Our proof actually extends also to the model &quot;without erasures&quot;.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.2 Conventions</h2>

    <p class="text-gray-300">Variables that are functions of the security parameter. Unless otherwise noted, by default we assume that all variables are a function of the security parameter κ. If any variable is not a function of κ, we shall explicitly note that the variable is a constant. Variables may also be functions of each other as defined later by relations that (A, Z) must additionally satisfy for our blockchain protocol to be secure.</p>

    <p class="text-gray-300">For two variables that by default are functions of κ, we say that var&lt;sup&gt;1&lt;/sup&gt; &lt; var&lt;sup&gt;2&lt;/sup&gt; iff for every κ ∈ N, var1(κ) &lt; var2(κ). Similarly, if we say that var is positive, we mean that var(κ) is positive for any κ ∈ N.</p>

    <p class="text-gray-300">Other conventions. Throughout this paper, whenever we refer to p.p.t. machines, we mean that the machine is non-uniform probabilistic polynomial-time.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.3 Blockchain Protocols</h2>

    <p class="text-gray-300">In this section, we recall the abstract model for blockchain protocols from <a href="#page-26-1">[PSS17]</a> and a provide a description of Nakamoto's original blockchain protocol which we will heavily make use of.</p>

    <p class="text-gray-300">In a blockchain protocol Π, nodes receive input records from an environment Z, and nodes interact with each other to agree on a linearly ordered log of transactions in a way that achieves consistency and liveness.</p>

    <p class="text-gray-300">Inputs and outputs of a blockchain protocol. At the beginning of each time step, the environment Z inputs a record m to each honest player. At the end of each time step, each honest player outputs a chain to the environment Z, where chain denotes an ordered sequence of records (also referred to as blocks). Each record (or block) may in turn contain an ordered sequence of transactions. Henceforth we use the notation</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">output of node i in round t : chain&lt;sup&gt;t&lt;/sup&gt; i (view)</p>

    </blockquote>

    <p class="text-gray-300">to denote the output of node i in round t to Z in a given execution trace view.</p>

    <p class="text-gray-300">Modeling proofs-of-work. To model Nakamoto's blockchain protocol, we need to extend the protocol execution model with a random oracle. In an execution with security parameter κ, we assume all parties have access to a random function H : {0, 1} &lt;sup&gt;∗&lt;/sup&gt; → {0, 1} &lt;sup&gt;κ&lt;/sup&gt; which they can access through two oracles: H(x) simply outputs H(x) and H.ver(x, y) output 1 iff H(x) = y and 0 otherwise. In any round r, the players (as well as A) may make any number of queries to H.ver. On the other hand, in each round r, honest players can make only a single query to H, and an adversary A controlling q parties, can make q sequential queries to H. (This modeling is meant to capture the assumption that we only &quot;charge&quot; for the effort of finding a solution to a &quot;proof of work&quot; <a href="#page-25-1">[DN92]</a>, but checking the validity of a solution is cheap. We discuss this further after introducing Nakamoto's protocol.) We emphasize that the environment Z does not get direct access to the random oracle (but can instruct A to make queries).</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.4 Nakamoto's Blockchain Protocol</h2>

    <p class="text-gray-300">We turn to describing Nakamoto's protocol <a href="#page-26-0">[Nak08]</a>, which we refer to as Πnak(p). Πnak(p) takes in a puzzle difficulty parameter p that denotes the probability that each player mines a block in a single round.</p>

    <p class="text-gray-300"><strong>Protocol overview.</strong> In  <span class="math">\\Pi_{\\text{nak}}</span> , each honest node maintains an internal state <em>chain</em> at any point of time. Each chain[i] is referred to as a (mined) block and is of the format  <span class="math">chain[i] := (h_{-1}, \\eta, \\mathsf{m}, h)</span> , containing the hash of the previous block denoted  <span class="math">h_{-1}</span> , a nonce  <span class="math">\\eta</span> , a record  <span class="math">\\mathsf{m}</span> , and a hash  <span class="math">h^4</span>  Let  <span class="math">\\mathsf{chain} := \\mathsf{extract}(chain)</span>  be the sequence of records contained in the sequence of blocks chain. chain is the version that honest nodes output to the environment.</p>

    <p class="text-gray-300">The  <span class="math">\\Pi_{nak}</span>  works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Nodes that are newly spawned or that have been become uncorrupt start with initial chain containing only a special genesis block:  <span class="math">chain := (0, 0, \\bot, H(0, 0, \\bot))</span> .</li>
      <li>In every round: a node reads all incoming messages (delivered by A). If any incoming message chain' is a valid sequence of blocks that is longer than its local state chain, replace chain by chain'. We define what it means for a chain to be valid later. Note that checking the validity of chain' can be done using only H.ver queries.</li>
      <li>Read an input record m from the environment Z. Now parse chain <span class="math">[-1] := (-, -, -, h_{-1})</span> , pick a random nonce  <span class="math">\\eta \\in \\{0, 1\\}^{\\kappa}</span> , and issue query  <span class="math">h = \\mathsf{H}(h_{-1}, \\eta, \\mathsf{m})</span> . If  <span class="math">h &lt; D_p</span> , then append the newly mined block  <span class="math">(h_{-1}, \\eta, b, h)</span>  to chain and broadcasts the updated chain.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>More specifically,  <span class="math">D_p = p(\\kappa) \\cdot 2^{\\kappa}</span>  such that for all (h, m),  <span class="math">\\Pr_n[\\mathsf{H}(h, \\eta, m) &lt; D_p] = p</span> . In other words,  <span class="math">D_p</span>  is appropriately parameterized such that the probability that any player mines a block in a round is p.</li>
    </ul></li>
      <li>Output chain := extract(chain) to the environment Z. Note that the notation chain extracts only the sequence of records from chain removing all other metadata that are not needed by external applications.</li>
    </ul>

    <p class="text-gray-300"><strong>Valid chain.</strong> We say a block  <span class="math">chain[i] = (h_{-1}, \\eta, \\mathsf{m}, h)</span>  is valid with respect to (a predecessor block)  <span class="math">chain[i-1] = (h&#x27;_{-1}, n&#x27;, \\mathsf{m}&#x27;, h&#x27;)</span>  if two conditions hold:  <span class="math">h_{-1} = h&#x27;</span> ,  <span class="math">h = \\mathsf{H}(h_{-1}, \\eta, \\mathsf{m})</span> , and  <span class="math">h &lt; D_p</span> . A chain of blocks chain is valid if a)  <span class="math">chain[0] = (0, 0, \\bot, \\mathsf{H}(0, 0, \\bot))</span>  is the genesis block, and b) for all  <span class="math">i \\in [\\ell]</span> , chain[i] is valid with respect to chain[i-1].</p>

    <p class="text-gray-300">Remark: on our use of the random oracle. Recall that in our model, we restrict players to a single evaluation query H per round, but allow them any number of verification queries H.ver in the same round. We do this to model the fact that checking the validity of mined blocks is &quot;cheap&quot; whereas the mining process is expensive. (To enable this, we have included a pointer h to the current record in every mined block in the description of Nakamoto; thus a player need not spend an H query to compute the pointer to the previous record.)</p>

    <p class="text-gray-300">In practice, the cost of evaluating a hash function (which is used to instantiate the random oracle) is the same as verifying its outputs, but our modeling attempts to capture the phenomena that a miner typically use various heuristics (such as black lists of IP addresses that have sent invalid blocks) and different hardware to check the validity of a mined block versus to mine a new block.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.5 Security of Blockchain Protocols</h3>

    <p class="text-gray-300">In this section, we recall the security properties of blockchains from [PSS17], which in turn are based on earlier definitions from [GKL15, KP15] For our purposes, we slightly generalize the properties</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{4}&lt;/sup&gt;</span> In reality (as well as in the description in the introduction), h is not included in the block (as it can be easily determined from the remaining elements); we include it to ensure that we can verify validity of a block using only H.ver.</p>

    <p class="text-gray-300">from [PSS17] (see below for a discussion of this generalization), but point out that our generalized definitions suffice for all known applications of them; see [PSS17] for more discussion (and historical remarks) on these definitions.</p>

    <p class="text-gray-300"><strong>Negligible functions.</strong> A function  <span class="math">\\epsilon(\\cdot)</span>  is said to be <em>negligible</em> if for every polynomial  <span class="math">p(\\cdot)</span> , there exists some  <span class="math">\\kappa_0</span>  such that  <span class="math">\\epsilon(\\kappa) \\leq \\frac{1}{p(\\kappa)}</span>  for all  <span class="math">\\kappa \\geq \\kappa_0</span> .</p>

    <p class="text-gray-300">We now define three useful properties, referred to as chain growth, chain quality, and consistency respectively. Note that all properties are defined over honest nodes' outputs to the environment that are visible at the abstraction level (rather than over nodes' internal states chain).</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">2.5.1 Chain Growth</h4>

    <p class="text-gray-300">The first desideratum is that the chain grows proportionally with the number of time steps. Let,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{min\\text{-}chain\\text{-}increase}_{t,t&#x27;}(\\mathsf{view}) = \\min_{i,j} |\\mathsf{chain}_{j}^{t+t&#x27;}(\\mathsf{view})| - |\\mathsf{chain}_{i}^{t}(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{max\\text{-}chain\\text{-}increase}_{t,t&#x27;}(\\mathsf{view}) = \\max_{i,j} |\\mathsf{chain}_j^{t+t&#x27;}(\\mathsf{view})| - |\\mathsf{chain}_i^t(\\mathsf{view})|</span>$</p>

    <p class="text-gray-300">where we quantify over nodes i, j such that i is honest at round t and j is honest at round t + t' in view.</p>

    <p class="text-gray-300">Let growth&lt;sup&gt; <span class="math">t_0,t_1</span> &lt;/sup&gt;(view,  <span class="math">\\Delta,T</span> ) = 1 iff the following two properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(consistent length) for all time steps  <span class="math">t \\leq |\\mathsf{view}| \\Delta</span> ,  <span class="math">t + \\Delta \\leq t&#x27; \\leq |\\mathsf{view}|</span> , for every two players i, j such that in view i is honest at t and j is honest at t', we have that  <span class="math">|\\mathsf{chain}_j^{t&#x27;}(\\mathsf{view})| \\geq |\\mathsf{chain}_i^t(\\mathsf{view})|</span></li>
      <li>(chain growth lower bound) for every time step  <span class="math">t \\leq |\\text{view}| t_0</span> , we have</li>
    </ul>

    <p class="text-gray-300">min-chain-increase&lt;sub&gt;<span class="math">$t,t_0</span><span class="math">&lt;/sub&gt; (view)  </span>\\geq T$ .</p>

    <p class="text-gray-300">• (chain growth upper bound) for every time step  <span class="math">t \\leq |\\text{view}| - t_1</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\max</span>$
-chain-increase&lt;sub&gt;t,t1&lt;/sub&gt; (view)  <span class="math">\\leq T</span> .</p>

    <p class="text-gray-300">In other words,  <span class="math">\\operatorname{\\mathsf{growth}}^{t_0,t_1}</span>  is a predicate which tests that a) honest parties have chains of roughly the same length, and b) during any  <span class="math">t_0</span>  time steps in the execution, all honest parties' chains increase by at least T, and c) during any  <span class="math">t_1</span>  time steps in the execution, honest parties' chains increase by at most T.</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Chain growth). A blockchain protocol  <span class="math">\\Pi</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth in  <span class="math">\\Gamma</span> -environments, if for all  <span class="math">\\Gamma</span> -compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every  <span class="math">\\kappa \\in \\mathbb{N}</span> ,  <span class="math">T \\geq T_0</span> ,  <span class="math">t_0 \\geq \\frac{T}{g_0}</span>  and  <span class="math">t_1 \\leq \\frac{T}{g_1}</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathit{view} \\leftarrow \\mathit{EXEC}^\\Pi(A, Z, \\kappa) : \\mathit{growth}^{t_0, t_1}(\\mathit{view}, \\Delta, \\kappa) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)</span>$</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.5.2 Chain Quality</h3>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large. Given a chain, we say that a block  <span class="math">B := \\mathsf{chain}[j]</span>  is honest w.r.t. view and prefix  <span class="math">\\mathsf{chain}[:j&#x27;]</span>  where j' &lt; j if in view there exists some node i honest at some time  <span class="math">t \\leq |\\mathsf{view}|</span> , such that 1)  <span class="math">\\mathsf{chain}[:j&#x27;] \\prec \\mathsf{chain}_i^t(\\mathsf{view})</span>  where  <span class="math">\\prec</span>  denotes &quot;is a prefix of&quot; and 2) Z input B to node i at time t. Informally, for an honest node's chain denoted  <span class="math">\\mathsf{chain}</span> , a block  <span class="math">B := \\mathsf{chain}[j]</span>  is honest w.r.t. a prefix</p>

    <p class="text-gray-300">chain[: j'] where j' &lt; j, if earlier there is some honest node who received B as input when its local chain contains the prefix chain[: j'].</p>

    <p class="text-gray-300">Let quality&lt;sup&gt;T&lt;/sup&gt;(view,  <span class="math">\\mu</span> ) = 1 iff for every time t and every player i such that i is honest at t in view, among any consecutive sequence of T blocks chain <span class="math">[j+1..j+T] \\subseteq \\mathsf{chain}_i^t(\\mathsf{view})</span> , the fraction of blocks that are honest w.r.t. view and chain[:j] is at least  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>Definition 2.2</strong> (Chain quality). A blockchain protocol  <span class="math">\\Pi</span>  has  <span class="math">(T_0, \\mu)</span> —chain quality, in  <span class="math">\\Gamma</span> -environments if for all  <span class="math">\\Gamma</span> -compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every  <span class="math">\\kappa \\in \\mathbb{N}</span>  and every  <span class="math">T \\geq T_0</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathit{view} \\leftarrow \\mathit{EXEC}^\\Pi(A, Z, \\kappa) : \\mathit{quality}^T(\\mathit{view}, \\mu) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)</span>$</p>

    <h2 id="sec-16" class="text-2xl font-bold">2.5.3 Consistency</h2>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes' chains, except for roughly  <span class="math">O(\\kappa)</span>  number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node's present chain, except for roughly  <span class="math">O(\\kappa)</span>  number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two honest nodes' chains must be of similar length).</p>

    <p class="text-gray-300">Let consistent&lt;sup&gt;T&lt;/sup&gt;(view) = 1 iff for all times  <span class="math">t \\le t&#x27;</span> , and all players i, j (potentially the same) such that i is honest at t and j is honest at t' in view, we have that the prefixes of  <span class="math">\\mathsf{chain}_i^t(\\mathsf{view})</span>  and  <span class="math">\\mathsf{chain}_j^{t&#x27;}(\\mathsf{view})</span>  consisting of the first  <span class="math">\\ell = |\\mathsf{chain}_i^t(\\mathsf{view})| - T</span>  records are identical — this also implies that the following must be true:  <span class="math">\\mathsf{chain}_j^{t&#x27;}(\\mathsf{view}) &gt; \\ell</span> , i.e.,  <span class="math">\\mathsf{chain}_j^{t&#x27;}(\\mathsf{view})</span>  cannot be too much shorter than  <span class="math">\\mathsf{chain}_i^t(\\mathsf{view})</span>  given that  <span class="math">t&#x27; \\ge t</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.3</strong> (Consistency). A blockchain protocol  <span class="math">\\Pi</span>  satisfies  <span class="math">T_0</span> -consistency, in  <span class="math">\\Gamma</span> -environments if for all  <span class="math">\\Gamma</span> -compliant p.p.t. pair (A, Z), there exists some negligible function negl such that for every  <span class="math">\\kappa \\in \\mathbb{N}</span>  and every  <span class="math">T \\geq T_0</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{\\Pi}(A, Z, \\kappa) : \\textit{consistent}^{T}(\\textit{view}) = 1\\right] \\geq 1 - \\mathsf{negl}(\\kappa)</span>$</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain lengths of any two honest players can differ by at most T (except with negligible probability).</p>

    <h2 id="sec-17" class="text-2xl font-bold">2.6 Preliminaries from [PSS17]: Security of Nakamoto's Blockchain</h2>

    <p class="text-gray-300">The results from [PSS17] (and as we shall shortly see, also ours) are parametrized by the following quantities (which are defined for some fixed mining hardness function  <span class="math">p(\\cdot)</span> ; recall that Nakamoto's protocol is parametrized a <em>single</em> hardness parameter p):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let  <span class="math">\\alpha := 1 (1 p)^{(1-\\rho)n}</span> . That is,  <span class="math">\\alpha</span>  is the probability that <em>some</em> honest player succeeds in mining a block in a round;</li>
      <li>let  <span class="math">\\beta := \\rho np</span> . That is  <span class="math">\\beta</span>  is the expected number blocks that an attacker can mine in a round.</li>
      <li>let  <span class="math">\\gamma := \\frac{\\alpha}{1+\\Delta\\alpha}</span> .  <span class="math">\\gamma</span>  is a &quot;discounted&quot; version of  <span class="math">\\alpha</span>  which takes into account the fact that messages sent by honest parties can be delayed by  <span class="math">\\Delta</span>  rounds and this may lead to honest players &quot;redoing work&quot;;  <span class="math">\\gamma</span>  corresponds to their &quot;effective&quot; mining power.</li>
    </ul>

    <p class="text-gray-300">In essence, the quantities capture the per round expected &quot;chain length increase&quot; by the honest parties and the adversary; the reason that  <span class="math">\\alpha, \\beta</span>  are defined differently is that we assume that the</p>

    <p class="text-gray-300">adversary can sequentialize its queries in a round, whereas honest players make a single parallel query (they each act independently), and thus even if they manage to mine several blocks, the longest chain held by honest players can increase by at most 1. Note, however, that when p is small (in comparison to 1/n), which is case for the Bitcoin protocol,  <span class="math">\\alpha</span>  is well approximated by  <span class="math">(1-\\rho)np</span>  and thus  <span class="math">\\frac{\\alpha}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> , so this difference is minor; additionally, when p is small,  <span class="math">\\gamma \\approx \\alpha</span>  and thus  <span class="math">\\frac{\\gamma}{\\beta} \\approx \\frac{1-\\rho}{\\rho}</span> .</p>

    <p class="text-gray-300">Compliant executions for Nakamoto's blockchain. We now specify the compliance predicate  <span class="math">\\Gamma^p_{\\mathrm{nak}}(\\cdot,\\cdot,\\cdot)</span>  for the Nakamoto blockchain. We say that  <span class="math">\\Gamma^p_{\\mathrm{nak}}(\\cdot,\\cdot,\\cdot)=1</span>  iff there is a constant  <span class="math">\\lambda&gt;1</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\alpha(1 - 2(\\Delta + 1)\\alpha) \\ge \\lambda\\beta</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  are functions of the parameters  <span class="math">n, \\rho, \\Delta</span>  and  <span class="math">\\kappa</span>  as defined above.</p>

    <p class="text-gray-300">As shown in Pass et al. [PSS17], this condition also implies the following:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;Fact 2.4. If (A, Z) is  <span class="math">\\Gamma^p_{\\text{nak}}</span> -compliant, then  <span class="math">np\\Delta &lt; 1</span> .</p>

    <p class="text-gray-300">We directly get the following corollary that will be useful to us.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-3&quot;&gt;&lt;/span&gt;<strong>Fact 2.5.</strong> If (A, Z) is  <span class="math">\\Gamma^p_{nak}</span> -compliant, then  <span class="math">\\gamma \\geq \\frac{np}{8}</span>  and</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that  <span class="math">\\gamma = \\frac{\\alpha}{1+\\Delta\\alpha}</span> . Since  <span class="math">\\alpha \\leq np</span> , by Fact 2.4, we directly get that</p>

    <p class="text-gray-300"><span class="math">$\\gamma \\geq \\frac{\\alpha}{2}\\beta</span>$</p>

    <p class="text-gray-300">Recall that,  <span class="math">\\alpha = 1 - (1 - p)^{(1-\\rho)n}</span> . Since by Fact 2.4, n &lt; 1/p, by the binomial expansion we have that</p>

    <p class="text-gray-300"><span class="math">$(1-p)^{(1-\\rho)n} &lt; 1 - \\frac{(1-\\rho)np}{2}</span>$</p>

    <p class="text-gray-300">Thus,  <span class="math">\\gamma &gt; \\frac{(1-\\rho)np}{4} \\ge \\frac{np}{8}</span>  since under our restrictions, we have that  <span class="math">\\rho &lt; \\frac{1}{2}</span> .</p>

    <p class="text-gray-300">Formal guarantees of Nakamoto's blockchain. The following theorem was proven in [PSS17].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;<strong>Theorem 2.6</strong> (Security of Nakamoto [PSS17]). For any constant  <span class="math">\\delta &gt; 0</span> , any  <span class="math">0 , any super-logarithmic function &lt;math&gt;T_0 = \\omega(\\log \\kappa)</span>  Nakamoto's blockchain protocol  <span class="math">\\Pi_{nak}(p)</span>  satisfies the following properties in  <span class="math">\\Gamma^p_{nak}</span> -environments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">T_0</span> -consistency;</li>
      <li>chain growth rate  <span class="math">(T_0, g_0, g_1)</span>  where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$q_0 = (1 - \\delta)\\gamma</span>$</p>

    <p class="text-gray-300"><span class="math">$g_1 = (1 + \\delta)np</span>$</p>

    <p class="text-gray-300">• chain quality  <span class="math">(T_0, \\mu)</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\mu = 1 - (1 + \\delta) \\frac{\\beta}{\\gamma}</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;Remark 2.7 (Blockchain quality and consistency). The consistency property proven in [PSS17] is actually a bit stronger than stated. Not only it shows that players agree on the records contained in their blockchains, but also that the actual blockchains agree except for potentially the last  <span class="math">\\kappa</span>  blocks. We refer to this property as blockchain consistency, and will rely on it in the sequel.</p>

    <p class="text-gray-300">Additionally, the chain quality property is also stronger in that not only the records of honest blocks are contributed by honest players, but also the actual blocks are mined by honest players. We refer to this property as blockchain quality, and will rely on it in the sequel.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.6.1 Liveness</h3>

    <p class="text-gray-300">The liveness property from [PSS17] (which generalized the one from [GKL15]), stipulates that from any given round r, if a sufficiently long period of time t elapses—we refer to this time as the wait-time of the blockchain—every honest player will have a record m sufficiently &quot;deep&quot; in their chain (technically,  <span class="math">\\kappa</span>  blocks from the end of the chain), where m was provided as an input to some honest player between rounds r and  <span class="math">r+t^5</span>  More precisely, let live(view, t) = 1 iff for any t consecutive rounds t, ..., t in view there exists some round t s.t. t in view t and player t such that in view, t is honest at t in view, t is received a record m as input at round t and t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t in view, t</p>

    <p class="text-gray-300"><strong>Definition 2.8.</strong> We say that blockchain  <span class="math">(\\Pi, chain)</span>  satisfies liveness with wait-time w in  <span class="math">\\Gamma</span> -environments if for all  <span class="math">\\Gamma</span> -compliant p.p.t. pair (A, Z), there exists a negligible function  <span class="math">\\epsilon</span>  in the security parameter  <span class="math">\\kappa \\in \\mathbb{N}</span> , such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathit{view} \\leftarrow \\mathit{EXEC}^\\Pi(A, Z, \\kappa) : \\mathit{live}(\\mathit{view}, w) = 1\\right] \\geq 1 - \\epsilon(\\kappa)</span>$</p>

    <p class="text-gray-300">The following theorem was shown in the prior work [PSS17].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-3&quot;&gt;&lt;/span&gt;<strong>Theorem 2.9</strong> ([PSS17]). For any boolean predicate  <span class="math">\\Gamma(\\cdot,\\cdot,\\cdot)</span> , let  <span class="math">\\Pi</span>  be a blockchain protocol satisfying chain growth  <span class="math">(T_0,g_0,g_1)</span> , chain quality  <span class="math">(T_0,\\mu)</span>  and  <span class="math">T_0</span> -chain consistency in  <span class="math">\\Gamma</span> -environments where  <span class="math">\\mu</span>  and  <span class="math">g_0</span>  are strictly positive, and  <span class="math">T_0</span>  is sublinear. Then,  <span class="math">\\Pi</span>  satisfies liveness with wait-time</p>

    <p class="text-gray-300"><span class="math">$w = (1+\\delta)\\frac{\\kappa}{g_0}</span>$</p>

    <p class="text-gray-300">against in  <span class="math">\\Gamma</span> -environments</p>

    <p class="text-gray-300">As a direct corollary of 2.9 and 2.6, we get:</p>

    <p class="text-gray-300">Corollary 2.10 ( [PSS17]). For any constant  <span class="math">\\delta &gt; 0</span> , and any  <span class="math">0 , &lt;math&gt;\\Pi_{nak}(p)</span>  satisfies liveness with wait-time</p>

    <p class="text-gray-300"><span class="math">w = (1 + \\delta) \\, \\frac{\\kappa}{\\gamma}</span></p>

    <p class="text-gray-300">in  <span class="math">\\Gamma^p_{\\text{nak}}</span> -environments.</p>

    <p class="text-gray-300">We turn to defining our notion of fairness. Roughly speaking, a blockchain protocol is  <span class="math">\\delta</span> -approximately fair w.r.t.  <span class="math">\\rho</span>  attackers if, with overwhelming probability, any honest subset controlling  <span class="math">\\phi</span>  fraction of the compute power is guaranteed to get at least a</p>

    <p class="text-gray-300"><span class="math">$(1-\\delta)\\phi</span>$</p>

    <p class="text-gray-300">fraction of the blocks in every sufficiently long window, even in the presence of an adversary controlling a  <span class="math">\\rho</span>  fraction of the computation power. Note that this condition trivially implies  <span class="math">(1 - \\delta)(1-\\rho)</span>  chain quality (by considering  <span class="math">\\phi = 1-\\rho</span> , that is, the full set of honest players). Consequently, to formally define this notion, we first generalize the definition of quality (used in the definition of chain quality, see Definition 2.2) to consider &quot;quality&quot; w.r.t to any subset S of the honest players.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^5&lt;/sup&gt;</span> The weaker liveness property from [GKL15] only requires this is <em>all</em> honest players have m as their input; this weaker property is not enough for our purposes.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt; [PSS17] only explicitly considered the case when  <span class="math">T_0</span>  is some slightly super-logarithmic function, but their proof actually only assumes that  <span class="math">T_0</span>  is sublinear. We also remark that any blockchain protocol which satisfies the security properties w.r.t. to a polynomial  <span class="math">T_0</span>  which potentially is super-linear can always be modified to satisfy security w.r.t. a sublinear  <span class="math">T_0</span>  by redefining the security parameter.</p>

    <p class="text-gray-300">Warmup: fairness definition for static corruption. As a warmup, let us consider how to define (approximate) fairness in a static corruption model where the adversary must declare corrupt nodes upfront — once we show how to do this, we then discuss how to extend the definition to an adaptive corruption model. Under a static corruption model, we say that a blockchain protocol satisfies  <span class="math">(T, \\delta)</span> -approximate fairness, iff the following holds except with negligible probability over the protocol's execution: for any honest node's chain during the protocol execution, for any constant  <span class="math">\\phi &gt; 0</span> , for any subset S of honest users such that  <span class="math">|S| = \\phi \\cdot n</span>  where n denotes the total number of users, for any T consecutive blocks chain [j+1..j+T] in chain, it holds that the fraction of blocks in chain [j+1..j+T] contributed by nodes in S is at least  <span class="math">(1-\\delta)\\phi</span> .</p>

    <p class="text-gray-300">Fairness definition for adaptive corruption. In general, the corruptions can be declared in an adaptive fashion, therefore nodes in any subset S may become corrupt during the course of the window we care about. To define (approximate) fairness with adaptive corruptions, we need to allow the subset S to change over time. We formalize the definition below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let a player subset selection, S(view, r), be a function that given (view, r) outputs a subset of the players that are honest at round r in view.</li>
      <li>We say that S is a  <span class="math">\\phi</span> -fraction player subset selection if S(view, r) always outputs a set of size  <span class="math">\\phi n</span>  (rounded upwards) where n is the number of players in view.</li>
      <li>Given a player subset selection S, we say that a record m is S-compatible w.r.t. view and prefix chain if there exists a player j and round r' such that j is in S(view, r'), the environment provided m as an input to j at round r', and chain  <span class="math">\\prec</span>  chain; r'(view) where  <span class="math">\\prec</span>  denotes &quot;is a prefix of&quot;;</li>
      <li>Let quality&lt;sup&gt;T,S&lt;/sup&gt;(view,  <span class="math">\\mu</span> ) = 1 iff for every round r and every player i such that i is honest in round r of view, we have that among any consecutive sequence of T records  <span class="math">\\operatorname{chain}_i^r(\\operatorname{view})[j+1:j+T]</span> , the fraction of records that are S-compatible w.r.t. view and prefix  <span class="math">\\operatorname{chain}_i^r(\\operatorname{view})[:j]</span>  is at least  <span class="math">\\mu</span> .</li>
    </ul>

    <p class="text-gray-300">We now define fairness analogously to chain quality.</p>

    <p class="text-gray-300"><strong>Definition 3.1.</strong> A blockchain protocol  <span class="math">\\Pi</span>  has (approximate) fairness  <span class="math">(T_0, \\delta)</span>  in  <span class="math">\\Gamma</span> -environments, if for all  <span class="math">\\Gamma</span> -compliant p.p.t. (A, Z), every positive constant  <span class="math">\\phi \\leq 1 - \\rho</span> , every  <span class="math">\\phi</span> -fraction subset selection S, there exists some negligible function  <span class="math">\\epsilon</span>  such that for every  <span class="math">\\kappa \\in \\mathbb{N}</span>  and every  <span class="math">T \\geq T_0</span>  the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{\\Pi}(A, Z, \\kappa) : \\textit{quality}^{T, S}(\\textit{view}, (1 - \\delta)\\phi)) = 1\\right] \\geq 1 - \\epsilon(\\kappa)</span>$</p>

    <p class="text-gray-300">As a sanity check, note that the definition of quality T,S (view,  <span class="math">\\mu</span> ) collapses down to quality T (view,  <span class="math">\\mu</span> ) if S is the full set of the honest players. As a consequence,  <span class="math">(T_0, \\delta)</span> -fairness trivially implies  <span class="math">(T_0, (1-\\delta)(1-\\rho))</span> -chain quality (by considering  <span class="math">\\phi = 1-\\rho</span> ). Additionally, when  <span class="math">\\rho \\leq \\frac{1}{2}</span>  which is the case we consider in this paper,</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta)(1 - \\rho) = 1 - \\delta - \\rho + \\delta \\rho = 1 - [\\delta + (1 - \\delta)\\rho] \\ge 1 - [2\\delta\\rho + (1 - \\delta)\\rho] = 1 - (1 + \\delta)\\rho</span>$</p>

    <p class="text-gray-300">Thus, no  <span class="math">\\rho</span> -size coalition can get more than a factor  <span class="math">(1+\\delta)</span>  more than its &quot;fair&quot; share of blocks.</p>

    <p class="text-gray-300"><strong>Fact 3.2.</strong> If a blockchain protocol  <span class="math">\\Pi</span>  satisfies  <span class="math">(T_0, \\delta)</span> -fairness in  <span class="math">\\Gamma</span> -environments, then it satisfies  <span class="math">(T_0, \\mu)</span> -chain quality where  <span class="math">\\mu = (1 - \\delta)(1 - \\rho) \\ge 1 - (1 + \\delta)\\rho</span>  in  <span class="math">\\Gamma</span> -environments.</p>

    <h2 id="sec-19" class="text-2xl font-bold">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;4 The FruitChain Protocol</h2>

    <p class="text-gray-300">We now turn to formally defining our FruitChain protocol. Roughly speaking, the FruitChain protocol will be running an instance of Πnak(p) but instead of directly putting the records m inside the blockchain, the records are put inside &quot;fruits&quot; denoted f; these fruits themselves requires solving some proof of work—with a different hardness parameter p&lt;sup&gt;f&lt;/sup&gt; ; additionally, we require a fruit to &quot;hang&quot; from a block which isn't too far from from the block which records the fruit—more specifically, the fruit needs to &quot;point&quot; to an earlier block in the chain which is not too far from the block containing it (and thus, the fruit could not have been mined &quot;too&quot; long ago); the recency parameter R will be used to specify how far back a fruit is allowed to hang.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4.1 Valid Blocks, Fruits, and Blockchain</h2>

    <p class="text-gray-300">Towards formalizing the protocol, we start by introducing some notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We assume that the random oracle H outputs strings of length at least 2κ. Let d be a collisionresistant hash-function (technically, it is a family of functions, and the instance from the family is selected as a public-parameter; in the sequel we ignore this selection and simply treat it as a single function (for instance, selected using randomness H(0).)</li>
      <li>Our protocol is parametrized by two &quot;hardness&quot; parameters p = p, p&lt;sup&gt;f&lt;/sup&gt; = p&lt;sup&gt;f&lt;/sup&gt; , and a recency parameter R. (p is the mining hardness parameter for the underlying Nakamoto blockchain, and p&lt;sup&gt;f&lt;/sup&gt; is the &quot;fruit mining&quot; hardness parameter, as mentioned above, the recency parameter will specify how far back a fruit is allowed to &quot;hang&quot;); the quantity q = pf p will be useful in our analysis.</li>
    </ul>

    <p class="text-gray-300">Valid fruits. A fruit is of the format f = (h−1; h 0 ; η, digest; m; h) where each entry means the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>h−&lt;sup&gt;1&lt;/sup&gt; points to the previous block's reference this entry is an artifact of the fruit mining and block mining piggybacked on top of each other; a fruit actually does not care about this entry (but a block does). However the value still needs to be included for the fruit to be verified;</li>
      <li>h &lt;sup&gt;0&lt;/sup&gt; points to a (recently stablized) block that the fruit is hanging from — we call h 0 the pointer of the fruit f;</li>
      <li>η is a random nonce denoting the puzzle solution;</li>
      <li>digest is the digest of some fruit-set F this is an artifact since the fruit mining and block mining are piggybacked on top of each other. The block must contain a set of fruits denoted F, but the fruit does not care about the fruit-set, and therefore we include only its d that is necessary for checking that the fruit is correct;</li>
      <li>m is the record to be contained in the fruit; and</li>
      <li>h is the hash or reference of the fruit.</li>
    </ul>

    <p class="text-gray-300">We say that a fruit denoted f = (h−1; h 0 ; η, digest; m; h) is valid iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) H(h−1; h 0 ; η; digest; m) = h;</li>
      <li>(ii) [h]−κ: &lt; Dp&lt;sup&gt;f&lt;/sup&gt; where [h]−κ: denotes the last κ bits of h.</li>
    </ul>

    <p class="text-gray-300">We say that F is a valid fruit-set if either F = ∅ or F is a set of valid fruits.</p>

    <p class="text-gray-300"><strong>Valid blocks.</strong> Since the block mining and the fruit mining are piggybacked on top of each other, a block looks very much like a fruit, except that a block must additionally include the actual fruit-set F. More specifically, a block is of the following format  <span class="math">b = ((h_{-1}; h&#x27;; \\eta; \\mathsf{digest}; \\mathsf{m}; h), F)</span>  where each entry means the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">h_{-1}</span>  points to the previous block's reference, this represents the chain that the block extends from;</li>
      <li>h' is an artifact of the fruit mining and block mining piggybacked atop each other; a block actually does not care about this field (but a fruit does), but it still needs to be included for block verification;</li>
      <li><span class="math">\\eta</span>  is a random nonce denoting the puzzle solution;</li>
      <li><span class="math">\\bullet</span>  digest is the digest of some fruit-set F to be included in the block later;</li>
      <li>m is a record the block also does not care about this field, and this is an artifact of the two piggybacked mining processes;</li>
      <li><span class="math">\\bullet</span>  h is called the reference of the block, which is a hash of the previous fields; and</li>
      <li>F is a fruit-set to be included in the block.</li>
    </ul>

    <p class="text-gray-300">We say that a block denoted  <span class="math">b = ((h_{-1}; h&#x27;; \\eta; digest; m; h), F)</span> , is valid iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) digest = d(F) where d is a collision-resistant hash function as mentioned earlier;</li>
      <li>(ii) F is a valid fruit-set;</li>
      <li>(iii)  <span class="math">H(h_{-1}; h&#x27;; \\eta, d(F); m) = h;</span></li>
      <li>(iv)  <span class="math">[h]_{:\\kappa} &lt; D_{p_1}</span>  where  <span class="math">[h]_{:\\kappa}</span>  denotes the first  <span class="math">\\kappa</span>  bits of h.</li>
    </ul>

    <p class="text-gray-300">Valid blockchain. We say that a <em>chain</em> is valid iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[0] = genesis where  <span class="math">genesis := ((0; 0; 0; 0; \\bot; \\mathsf{H}(0; 0; 0; 0, \\bot)), \\emptyset)</span>  is the &quot;genesis&quot; block;</li>
      <li>for all  <span class="math">i \\in [\\ell]</span> ,  <span class="math">chain[i].h_{-1} = chain[i-1].h</span> , i.e., each block refers to the previous block's reference;</li>
      <li>for all  <span class="math">i \\in [\\ell]</span> , all  <span class="math">f \\in chain[i].F</span> , there exists some  <span class="math">j \\geq i R\\kappa</span>  such that the pointer of f is chain[j].h.</li>
    </ul>

    <p class="text-gray-300"><strong>Recency of fruits.</strong> Finally, we say that the <em>fruit</em> f <em>is</em> recent w.r.t. <em>chain</em> if the pointer of f is the reference of a block in  <span class="math">chain[-R\\kappa:]</span>  (i.e., one of the last  <span class="math">R\\kappa</span>  blocks in chain).</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.2 The FruitChain Protocol and our Main Theorem</h3>

    <p class="text-gray-300">The FruitChain protocol denoted  <span class="math">\\Pi_{\\text{fruit}}</span>  is described in Figure 1. Henceforth, we say that</p>

    <p class="text-gray-300"><span class="math">$\\Gamma^{p,p_f,R}_{\\mathrm{fruit}}(n,\\rho,\\Delta) = 1 \\text{ iff } \\Gamma^p_{\\mathrm{nak}}(n,\\rho,\\Delta) = 1</span>$</p>

    <p class="text-gray-300">Moreover, we assume the following quantities are constants throughout this paper:</p>

    <p class="text-gray-300"><span class="math">$q := \\frac{p_f}{p} = \\Theta(1), \\qquad R = \\Theta(1)</span>$</p>

    <p class="text-gray-300">We are now ready to state our main theorem.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Πfruit(p, p&lt;sup&gt;f&lt;/sup&gt; , R): FruitChain protocol</h2>

    <p class="text-gray-300">Initialize: chain := genesis, F = ∅</p>

    <p class="text-gray-300">Upon receiving a valid fruit,</p>

    <p class="text-gray-300">• let F := F ∪ {fruit}</p>

    <p class="text-gray-300">Upon receiving a valid chain&lt;sup&gt;0&lt;/sup&gt; , if |chain&lt;sup&gt;0&lt;/sup&gt; | &gt; |chain|:</p>

    <p class="text-gray-300">• let chain := chain&lt;sup&gt;0&lt;/sup&gt;</p>

    <p class="text-gray-300">Every time step, upon receiving input m from the environment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let F &lt;sup&gt;0&lt;/sup&gt; be all fruits f ∈ F that are recent w.r.t. chain and not already in chain;</li>
      <li>let h &lt;sup&gt;0&lt;/sup&gt; be the reference of chain[pos] where pos = max(1, |chain| − κ);</li>
      <li>let h−&lt;sup&gt;1&lt;/sup&gt; be the reference of chain[−1];</li>
      <li>Pick random η ∈ {0, 1} &lt;sup&gt;κ&lt;/sup&gt; and let h := H(h−1; h 0 ; η; d(F 0 ); m)</li>
      <li>If [h]−κ: &lt; Dp&lt;sup&gt;f&lt;/sup&gt; (i.e., we &quot;mined a fruit&quot;)    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let fruit := (h−1; h 0 ; η; d(F 0 ); m, h), F := F ∪ {fruit}, and broadcast fruit</li>
    </ul></li>
      <li>If [h]:&lt;sup&gt;κ&lt;/sup&gt; &lt; D&lt;sup&gt;p&lt;/sup&gt; (i.e., we &quot;mined a block&quot;)    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let chain := chain||((h−1; h 0 ; η, d(F 0 ); m, h), F&lt;sup&gt;0&lt;/sup&gt; ), and broadcast chain</li>
    </ul></li>
      <li>Output extractfruit(chain) to Z, where extractfruit(·) is defined as below:</li>
    </ul>

    <h2 id="sec-23" class="text-2xl font-bold">extractfruit(chain):</h2>

    <p class="text-gray-300">On input a valid chain,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>first extract a sequence of distinct fruits from chain, where if the same fruit is included multiple times, only the first occurrence is included. The extracted fruits are ordered by the first block that contains the fruit; and for fruits in the same block, follow the order in which the fruits are serialized within the block.</li>
      <li>&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;• then, output the sequence of records m contained in the extracted sequence of fruits, where records contained in earlier fruits are extracted earlier.</li>
    </ul>

    <p class="text-gray-300">Figure 1: The FruitChain protocol. Nodes not only mine for blocks, but also fruits. Blocks confirm &quot;recent&quot; fruits; whereas fruits confirm transactions.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong> (Security of FruitChain). For any constant  <span class="math">0 &lt; \\delta &lt; 1</span> , and any  <span class="math">p, p_f</span> , let R = 17,  <span class="math">\\kappa_f = 2qR\\kappa</span> , and  <span class="math">T_0 = 5\\frac{\\kappa_f}{\\delta}</span> . Then the FruitChain protocol denoted  <span class="math">\\Pi_{\\text{fruit}}(p, p_f, R)</span>  satisfies</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\kappa_f</span> -consistency;</li>
      <li>chain growth rate  <span class="math">(T_0, g_0, g_1)</span>  where</li>
    </ul>

    <p class="text-gray-300"><span class="math">$g_0 = (1 - \\delta)(1 - \\rho)np_f,</span>$</p>

    <p class="text-gray-300"><span class="math">$g_1 = (1 + \\delta)np_f</span>$</p>

    <p class="text-gray-300">•  <span class="math">fairness\\ (T_0, \\delta)</span> .</p>

    <p class="text-gray-300">in  <span class="math">\\Gamma_{\\text{fruit}}^{p,p_f,R}</span> -environments.</p>

    <h2 id="sec-24" class="text-2xl font-bold">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;5 Proof of the Main Theorem</h2>

    <p class="text-gray-300">We start by introducing some additional notation and useful lemmas, and then turn to proving each of the three security properties.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.1 Additional Notations</h3>

    <p class="text-gray-300">Let us introduce some additional notation that will be useful in the analysis of the protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We say that a fruit  <span class="math">f = (h_{-1}; h&#x27;; \\eta, \\text{digest}; m; h)</span>  was mined at round r if r is the first time H outputs h.</li>
      <li>We say that a block,  <span class="math">b = ((h_{-1}; h&#x27;; \\eta; digest; m; h), F)</span>  was mined at round r if r is the first time H outputs h.</li>
      <li>We say that a block/fruit was mined by an honest player if there it was an honest players that first mined it.</li>
    </ul>

    <p class="text-gray-300">To simplify notation, in addition to the parameters  <span class="math">\\alpha, \\beta, \\gamma</span>  previously defined, we also define analogs of  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  with respect to the &quot;fruit mining&quot; process:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let  <span class="math">\\alpha_f = (1 \\rho)np_f</span>  (that is, the expected number of fruits mined by honest players in one round);</li>
      <li>let  <span class="math">\\beta_f = \\rho n p_f</span>  (that is, the expected number of fruits mined by corrupt players in one round).</li>
    </ul>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">5.2 The Fruit Freshness Lemma</h4>

    <p class="text-gray-300">In this section, we present a lemma demonstrating the key property of the FruitChain protocol: any fruit mined by an honest player will be incorporated sufficiently deep in the chain (and thus never lost). We refer to this as the <em>Fruit Freshness Lemma</em>—fruits stay &quot;fresh&quot; (i.e., recent) sufficiently long to be incorporated.</p>

    <p class="text-gray-300">Let fruitfreshness(view,  <span class="math">w, \\kappa) = 1</span>  iff for every honest player i and every round  <span class="math">r &lt; |\\mathsf{view}| - w</span> , if i mines a fruit at round r in view, then for every honest player j, there exists some index pos such that f is at position pos in the record chain (w.r.t. Nakamoto's protocol) of j at every round  <span class="math">r&#x27; \\geq r + w</span>  (i.e.,  <span class="math">f \\in chain_j^{r&#x27;}(\\mathsf{view})[pos]</span> ) and additionally pos is at least  <span class="math">\\kappa</span>  positions from the end of the chain.</p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">$wait = 2\\Delta + \\frac{2\\kappa}{\\gamma}</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;Lemma 5.1. Let R = 17. For any p, p&lt;sup&gt;f&lt;/sup&gt; , for any Γ p,p&lt;sup&gt;f&lt;/sup&gt; ,R fruit -compliant (A, Z), there exists a negligible function such that for any κ ∈ N,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{\\Pi_{\\text{fruit}}(p,p_f,R)}(A,Z,\\kappa) : \\textit{fruitfreshness}(\\textit{view},wait,\\kappa) = 1\\right] \\geq 1 - \\epsilon(\\kappa)</span>$</p>

    <p class="text-gray-300">Proof. Disregard the blockchain consistency (see Remark <a href="#page-11-2">2.7)</a>, liveness and chain growth failure events—they only happen with negligible probability. Let wait = wait(κ, n, ρ, ∆).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By blockchain consistency, at any point in the execution, whenever an honest player mines a fruit f, the block pointed to by the fruit is at some fixed position pos on the blockchain of every honest player, now and at every time in the future. (Recall that honest players try to mine fruit that point back to a block that is κ steps back in the chain, and thus the consistency condition kicks in.) Let <code>denote the length of the chain of the player that mines f; by definition pos =</code> − κ.</li>
      <li>By the description of the protocol, if the fruit f is mined at a round r 0 , it gets seen by all honest players by round r &lt;sup&gt;0&lt;/sup&gt; + ∆; additionally, when this happens all honest players attempt to add f to their chain as long as it remains recent (w.r.t. all honest players).</li>
      <li>By liveness, it thus follows that f gets incorporated into the record chain of all honest players at some position pos that is at least κ records from the end of their chain by round</li>
    </ul>

    <p class="text-gray-300"><span class="math">$r&#x27; + \\Delta + (1 + \\delta)\\frac{\\kappa}{\\gamma} \\le r&#x27; + wait - \\Delta</span>$</p>

    <p class="text-gray-300">as long as f is recent by then (w.r.t. all honest players).</p>

    <p class="text-gray-300">• By the upperbound on chain growth, at most</p>

    <p class="text-gray-300"><span class="math">$(1+\\delta)np\\left(\\Delta+\\frac{2\\kappa}{\\gamma}\\right)</span>$</p>

    <p class="text-gray-300">blocks are &quot;added&quot; in time wait − ∆; more precisely, by round r &lt;sup&gt;0&lt;/sup&gt; + wait − ∆, no honest player has ever had a chain of length \` 0 such that</p>

    <p class="text-gray-300"><span class="math">$\\ell&#x27; &gt; \\ell + (1+\\delta) np \\left(\\Delta + \\frac{2\\kappa}{\\gamma}\\right)</span>$</p>

    <p class="text-gray-300">Thus, by round r &lt;sup&gt;0&lt;/sup&gt; + wait − ∆, for every such honest player's chain length \` &lt;sup&gt;0&lt;/sup&gt; we have</p>

    <p class="text-gray-300"><span class="math">$pos = \\ell - \\kappa \\ge \\ell&#x27; - \\kappa - (1 + \\delta)np\\left(\\Delta + \\frac{2\\kappa}{\\gamma}\\right)</span>$</p>

    <p class="text-gray-300">By our compliance assumption and by Fact <a href="#page-11-0">2.4</a> and Fact <a href="#page-11-3">2.5,</a> we have that γ ≥ np 8 and np∆ &lt; 1, thus</p>

    <p class="text-gray-300"><span class="math">$pos \\ge \\ell&#x27; - \\kappa - (1+\\delta) - (1+\\delta)16\\kappa \\le 17\\kappa = \\ell&#x27; - R\\kappa</span>$</p>

    <p class="text-gray-300">which means that f remains recent until round r &lt;sup&gt;0&lt;/sup&gt; + wait − ∆ w.r.t. all honest players.</p>

    <p class="text-gray-300">• Finally, by consistency, all honest players agree that f is found at position pos in their blockchain at any point after r &lt;sup&gt;0&lt;/sup&gt; +wait−∆; additionally, by the consistent length property all honest players agree that position pos is at least κ from the end of the chain by r &lt;sup&gt;0&lt;/sup&gt; + wait − ∆ + ∆ = r &lt;sup&gt;0&lt;/sup&gt; + wait.</p>

    <p class="text-gray-300">We also observe the following fact about wait, which says that the expected number of fruits mined by all players during wait + 2 steps is upper bounded by k&lt;sup&gt;f&lt;/sup&gt; .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;Fact 5.2. For any
<span class="math">$p, p_f</span>$
, any  <span class="math">\\Gamma_{\\text{fruit}}^{p, p_f, R}</span> -compliant  <span class="math">(A, Z)</span> ,</p>

    <p class="text-gray-300"><span class="math">$(wait + 2) \\cdot np_f \\le \\kappa_f</span>$</p>

    <p class="text-gray-300">Proof. Note that by Fact <a href="#page-11-0">2.4</a> and Fact <a href="#page-11-3">2.5,</a> we have that γ ≥ np 8 and np∆ &lt; 1, thus</p>

    <p class="text-gray-300"><span class="math">$(wait + 2) \\cdot np_f = (2\\Delta + 2\\frac{\\kappa}{\\gamma} + 2) \\cdot qpn \\le 2q + 2\\kappa \\cdot 8q + 2 \\le 2qR\\kappa = \\kappa_f</span>$</p>

    <h2 id="sec-27" class="text-2xl font-bold">5.3 Some Simplifying Assumptions</h2>

    <p class="text-gray-300">Towards proving our main theorem we state some simplifying assumptions that can be made without loss of generality. These assumptions (which all follow from properties of the random oracle H) will prove helpful in our subsequent analysis.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>WLOG1: We may without loss of generality assume that honest players never query the RO on the same input—more precisely, we analyze an experiment where if some honest player wants to query it on an &quot;old&quot; input, it resamples nonce until the input is &quot;new&quot;; since nonce is selected from {0, 1} κ , this &quot;resampling&quot; experiment is identical to the real one with except with negligible probability, thus we can WLOG analyze it.</li>
      <li>WLOG2: We may without loss of generality assume that any fruit that points to a block b which was first mined at time t, has been mined after t. Additionally, any fruit that points to a block that comes after b in a valid chain must have been mined after t. (If not, we can predict the outcome of the random oracle H on some input before having queries H which is a contradiction. We omit the standard details.)</li>
      <li>WLOG3: We may assume without loss of generality that all fruit mined by honest players are &quot;new&quot; (i.e., different from all valid fruit previously seen by honest players); this follows by WLOG1 and the fact that the probability of seeing a collision in the random oracle is negligible (by a simple union bound over the number of random oracle queries).</li>
      <li>WLOG4: We may assume without loss of generality that any valid fruit which appears in some honest players chain at round r was mined before r; this follows from the unpredictability of the random oracle (and a simple union bound over the number of random oracle queries).</li>
      <li>WLOG5: We may assume without loss of generality that there are no &quot;blockchain collisions&quot; namely, there are no two different valid sequences of blocks which end with the same block.</li>
    </ul>

    <p class="text-gray-300">We now turn to proving the three security properties.</p>

    <h2 id="sec-28" class="text-2xl font-bold">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;5.4 Proof of Fruit Consistency</h2>

    <p class="text-gray-300">Disregard the chain growth and consistency, and blockchain quality (see Remark <a href="#page-11-2">2.7)</a> failure events—they happen with negligible probability. Consider some view view in the support of EXECΠfruit(p,p&lt;sup&gt;f&lt;/sup&gt; ,R) (A, Z, κ), rounds r, r&lt;sup&gt;0&lt;/sup&gt; s.t. r &lt;sup&gt;0&lt;/sup&gt; ≥ r, and players i, j that are honest respectively at r, r&lt;sup&gt;0&lt;/sup&gt; in view. By consistency, the chains of i, j at r, r&lt;sup&gt;0&lt;/sup&gt; agree except for potentially the last κ blocks in the chain of i—let C = b0, . . . , b|C&lt;sup&gt;|&lt;/sup&gt; denote those initial blocks on which they agree, and let b|C|+1, . . . denote the (max κ) blocks in the chain of i at r which are not in the chain of j at r 0 ; we now bound the number of fruits that can be contained in these remaining (max κ) &quot;inconsistent&quot; blocks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By the &quot;recency condition&quot; of valid fruit, any valid fruit in the chain of i at r which is after C must point to a block  <span class="math">b_{j&#x27;}</span>  such that  <span class="math">j&#x27; &gt; |C| R\\kappa</span> .</li>
      <li>By the blockchain quality condition, there exists some j'' s.t.  <span class="math">|C| R\\kappa \\kappa \\le j&#x27;&#x27; \\le |C| R\\kappa</span>  and  <span class="math">b_{j&#x27;&#x27;}</span>  was mined by an honest player. Let  <span class="math">r&#x27;_0</span>  denote the round when this block was mined.</li>
      <li>Note that at  <span class="math">r&#x27;_0</span> ,  <span class="math">b_{j&#x27;&#x27;}</span>  was mined by an honest player holding a chain of length  <span class="math">j&#x27;&#x27; \\geq |C| R\\kappa \\kappa</span> ; additionally, at r, i is honest, holding a chain of length at most  <span class="math">|C| + \\kappa</span>  (recall that |C| contains the blocks on which i and j agree, and by consistency, all but the last  <span class="math">\\kappa</span>  blocks in the chain of i must be in the chain of j). Thus, by the <em>chain growth upperbound</em>, at most</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mu = (1 + \\delta) \\frac{2\\kappa + R\\kappa}{np}</span>$</p>

    <p class="text-gray-300">rounds could thus have elapsed between  <span class="math">r&#x27;_0</span>  and r.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By WLOG2, any fruit which gets added after C must have been mined after  <span class="math">r&#x27;_0</span> . By WLOG4, any such fruit that is part of the chain of i by r was mined before r.</li>
      <li>We thus conclude by the Chernoff bound (see Lemma A.1) that for every sufficiently small  <span class="math">\\delta&#x27;</span> , except with probability  <span class="math">e^{-\\Omega(np_f\\cdot\\frac{\\kappa(R+2)}{np})}=e^{-\\Omega(q(R+2)\\kappa)}</span> , there were at most</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(1+\\delta&#x27;)^2 \\cdot np_f \\cdot \\frac{\\kappa(R+2)}{np} = (1+\\delta&#x27;)^2 q(R+2)\\kappa &lt; 2qR\\kappa = \\kappa_f</span>$</p>

    <p class="text-gray-300">&quot;inconsistent&quot; fruits in the chain of i at r.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.5 Proof of Fruit Growth</h3>

    <p class="text-gray-300">Consistent length. The consistent length property follows directly from the consistent length property of the underlying blockchain.</p>

    <p class="text-gray-300"><strong>Lowerbound.</strong> Disregard the fruit freshness failure event (Lemma 5.1)—it happens with negligible probability. Consider any r, t and players i, j that are honest respectively at round r and r + t. Consider the t rounds starting from round r.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By the fruit freshness condition, every fruit that is mined by some honest party by round r + t wait gets incorporated into (and remains in) the chain of player j by r + t.</li>
      <li>By the Chernoff bound, in the t-wait rounds from r to r+t-wait, except with probability  <span class="math">e^{-\\Omega((t-wait)\\alpha_f)}</span> , the honest parties mine at least</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)(t - wait)\\alpha_f</span>$</p>

    <p class="text-gray-300">fruits (where  <span class="math">\\delta&#x27;</span>  is some arbitrarily small constant), which are all included in the chain of j at r+t. Additionally, by WLOG3 they are all &quot;new&quot; (i.e., not included in the chains of i at r) and different.</p>

    <p class="text-gray-300">• Finally, by fruit consistency (proved in Section 5.4), we have that all but potentially  <span class="math">\\kappa_f</span>  of the fruits in the chain of i at r are still in the chain of j at r + t.</p>

    <p class="text-gray-300">• We conclude that, except with probability  <span class="math">e^{-\\Omega((t-wait)\\alpha_f)}</span> , the chain of j at r+t contains at least</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)(t - wait)\\alpha_f - \\kappa_f</span>$</p>

    <p class="text-gray-300">more fruits than the chain of j at r. By Fact 5.2,  <span class="math">wait \\cdot \\alpha_f = wait \\cdot (1-\\rho)np_f \\leq (1-\\rho)\\kappa_f \\leq \\kappa_f</span> ; thus, have at least</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;
<span class="math">$(1 - \\delta)(t - wait)\\alpha_f - \\kappa_f \\ge (1 - \\delta)\\alpha_f t - 2\\kappa_f \\tag{1}</span>$</p>

    <p class="text-gray-300">new fruit.</p>

    <p class="text-gray-300">We conclude by noting that this implies that a fruit growth lower bound of  <span class="math">g_0 = \\frac{1}{1+\\delta}\\alpha_f \\ge (1-\\delta)\\alpha_f</span>  in the desired regime: Consider any  <span class="math">T \\ge \\frac{5\\kappa_f}{\\delta}</span>  and any</p>

    <p class="text-gray-300"><span class="math">$t \\ge \\frac{T}{g_0} = \\frac{T}{\\frac{\\alpha_f}{1+\\delta}}</span>$</p>

    <p class="text-gray-300">As shown above (see Equation 1), during this time t, except with probability,  <span class="math">e^{-\\Omega((t-wait)\\alpha_f)}</span>  the chain must grown by at least</p>

    <p class="text-gray-300"><span class="math">$T(1+\\delta)(1-\\delta&#x27;) - 2\\kappa_f = T(1+\\frac{\\delta}{2})(1-\\delta&#x27;) + T\\frac{\\delta}{2}(1-\\delta&#x27;) - 2\\kappa_f</span>$</p>

    <p class="text-gray-300">For a sufficiently small  <span class="math">\\delta&#x27;</span>  the first term is greater than T, and the second term greater than  <span class="math">2\\kappa_f</span> , and thus the chain must have grown by at least T. Finally note that by Equation 1</p>

    <p class="text-gray-300"><span class="math">$e^{-\\Omega((t-wait)\\alpha_f)} = e^{-\\Omega((t\\alpha_f - \\kappa_f))} = e^{-\\Omega((T-\\kappa_f))} = e^{-\\Omega((5\\kappa_f - \\kappa_f))} = e^{-\\Omega((5\\kappa_f - \\kappa_f))} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f)} = e^{-\\Omega(\\kappa_f - \\kappa_f</span>$</p>

    <p class="text-gray-300">Thus the chain growth is guaranteed except with negligible probability.</p>

    <p class="text-gray-300"><strong>Upperbound.</strong> Disregard the chain growth, consistency and blockchain quality (see Remark 2.7) failure events—they happen with negligible probability. Consider some view view in the support of  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{fruit}}(p,p_f,R)}(A,Z,\\kappa)</span> , rounds r,r'=r+t and players i,j that are honest respectively at r and r' in view. By consistency, the chains of i,j at r,r' agree except for potentially the last  <span class="math">\\kappa</span>  blocks of the chain of i—let  <span class="math">C=\\mathsf{b}_0,\\ldots,\\mathsf{b}_{|C|}</span>  denote those initial blocks on which they agree, and let  <span class="math">\\mathsf{b}_{|C|+1},\\ldots</span>  denote the blocks in the chain of j at r' which are not in the chain of i at r' (there may be more than  <span class="math">\\kappa</span>  such blocks since we are looking at the chain of j at a later time r'); We now upper bound the number of fruits in the new blocks in the chain of j which come after C, similarly to the fruit consistency proof (they main difference is that we now consider the chain of j as opposed to the chain of i). The details follow:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By the &quot;recency condition&quot; of valid fruit, any valid fruit in the chain of j at r' which is after C must point to a block  <span class="math">b_{j&#x27;}</span>  such that  <span class="math">j&#x27; &gt; |C| R\\kappa</span> ,</li>
      <li>By the blockchain quality condition, there exists some j'' s.t.  <span class="math">|C| R\\kappa \\kappa \\le j&#x27;&#x27; \\le |C| R\\kappa</span>  and  <span class="math">b_{j&#x27;&#x27;}</span>  was mined by an honest player. Let  <span class="math">r&#x27;_0</span>  denote the round when this block was mined.</li>
      <li>Note that at  <span class="math">r&#x27;_0</span> ,  <span class="math">b_{j&#x27;&#x27;}</span>  was mined by an honest player holding a chain of length  <span class="math">j&#x27;&#x27; \\geq |C| R\\kappa \\kappa</span> ; additionally, at r, i is honest, holding a chain of length at most  <span class="math">|C| + \\kappa</span>  (recall that |C| contains the blocks on which i and j agree, and by consistency, all but the last  <span class="math">\\kappa</span>  block in the chain of i must be in the chain of j). Thus, by the <em>chain growth upperbound</em>, for any arbitrarily small  <span class="math">\\delta&#x27;</span>  at most</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mu = (1 + \\delta&#x27;) \\frac{2\\kappa + R\\kappa}{np}</span>$</p>

    <p class="text-gray-300">rounds could thus have elapsed between  <span class="math">r&#x27;_0</span>  and r.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By WLOG2, any fruit which gets added after C must have been mined after  <span class="math">r&#x27;_0</span> . By WLOG4, any such fruit that is part of the chain of j by r' was mined before r'.</li>
      <li>We thus conclude by the Chernoff bound that except with probability  <span class="math">e^{-\\Omega(np_f \\cdot \\frac{\\kappa(R+2)}{np})} = e^{-\\Omega(q(R+2)\\kappa)}</span> , there were at most</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;
<span class="math">$(1 + \\delta&#x27;)^2 \\cdot np_f \\cdot \\left(\\frac{\\kappa(R+2)}{np} + t\\right) = (1 + \\delta&#x27;)^2 \\left(q(R+2)\\kappa + np_f t\\right) \\le \\kappa_f + (1 + \\delta&#x27;)^2 np_f t \\tag{2}</span>$</p>

    <p class="text-gray-300">&quot;new&quot; fruits in the chain of j at r'.</p>

    <p class="text-gray-300">We conclude by noting that this implies a fruit growth upper bound of  <span class="math">g_1=(1+\\delta)np_f</span>  in the desired regime: Consider any  <span class="math">T\\geq \\frac{5\\kappa_f}{\\delta}</span>  and any</p>

    <p class="text-gray-300"><span class="math">$t = \\frac{T}{g_1} = \\frac{T(1+\\delta)}{np_f}.</span>$</p>

    <p class="text-gray-300">As shown above (see Equation 2), during this time t, except with negligible probability, the chain must have grown by at most</p>

    <p class="text-gray-300"><span class="math">$\\kappa_f + (1 + \\delta&#x27;)^2 T (1 - \\delta) \\le T \\delta / 5 + (1 + \\delta&#x27;)^2 T / (1 + \\delta)</span>$</p>

    <p class="text-gray-300">For any  <span class="math">0 &lt; \\delta &lt; 1</span>  and  <span class="math">\\delta&#x27; = 0.1\\delta</span> , the above expression is upper bounded by T.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">5.6 Proof of Fruit Fairness</h3>

    <p class="text-gray-300">Disregard the chain growth, blockchain quality (see Remark 2.7), fruit freshness, and the fruit growth failure events—they happen with negligible probability. Consider some  <span class="math">\\phi</span> -fraction player subset selection S, some view view in the support of  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{fruit}}(p,p_f,R)}(A,Z,\\kappa)</span> , some round r and player i that is honest in round r of view. Let  <span class="math">C = \\mathsf{b}_0,\\ldots,\\mathsf{b}_{|C|}</span>  be the blocks in the view of i at view, let  <span class="math">f_0,\\ldots,f_\\ell</span>  be the fruits contained in them, and let  <span class="math">\\mathsf{m}_0,\\ldots,\\mathsf{m}_\\ell</span>  be the records contained in the fruits; let  <span class="math">f_j,\\ldots,f_{j+T}</span>  be T consecutive fruits for some j, where  <span class="math">T \\geq \\frac{5\\kappa_f}{s}</span></p>

    <p class="text-gray-300">the fruits; let  <span class="math">f_j, \\ldots, f_{j+T}</span>  be T consecutive fruits for some j, where  <span class="math">T \\geq \\frac{5\\kappa_f}{\\delta}</span> Let  <span class="math">r_0</span>  be the round when the block in the view of i at r containing  <span class="math">f_{j+\\kappa_f}</span>  was first added to some honest player  <span class="math">j_0</span> 's chain&lt;sup&gt;7&lt;/sup&gt;; let  <span class="math">r_1</span>  be the round when the block (again in the view of i at r) containing  <span class="math">f_{j+T}</span>  was first added to some honest player  <span class="math">j_1</span> 's chain, and let  <span class="math">t = r_1 - r_0 - 2</span>  be the number of rounds from  <span class="math">r_0 + 1</span>  to  <span class="math">r_1 - 1</span> . We lower bound the number of S-compatible (honest) fruits in the sequence, following similar lines (but slightly more complicated) to the proof of fruit growth lowerbound:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By the fruit freshness condition, every fruit mined by some honest player between  <span class="math">(r_0 + 1)</span>  and  <span class="math">(r_1 1) wait</span>  will be in the chain of  <span class="math">j_1</span>  at some position pos that is at least  <span class="math">\\kappa</span>  positions from the end of the chain, before the beginning of round  <span class="math">r_1</span>  and will remain so.</li>
      <li>By the Chernoff bound, in the t-wait rounds from  <span class="math">r_0+1</span>  to  <span class="math">(r_1-1)-wait</span> , except with probability  <span class="math">e^{-\\Omega((t-wait)\\phi np_f)}</span> , the honest parties in S mine at least</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)(t - wait)\\phi np_f</span>$</p>

    <p class="text-gray-300">fruits (where  <span class="math">\\delta&#x27;</span>  is some arbitrarily small constant), which thus are all included in the chain of  <span class="math">j_1</span>  by  <span class="math">r_1 - 1</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;7&lt;/sup&gt;Note that we cannot consider the time when it was added to i's chain as i may potentially be corrupted up until r.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Since fruits are ordered by the block containing them, and since in round r&lt;sup&gt;1&lt;/sup&gt; a new block is added which contains fj+&lt;sup&gt;T&lt;/sup&gt; , it follows from blockchain consistency that all these fruits are contained in the sequence f1, . . . , fj+&lt;sup&gt;T&lt;/sup&gt; (recall that all these fruits are found in blocks that are at least κ positions from the end of the chain, so by consistency, those block cannot change and thus were not added in round r&lt;sup&gt;1&lt;/sup&gt; and consequently must come before the block containing fj+&lt;sup&gt;T&lt;/sup&gt; ).</li>
      <li>By WLOG3, these fruits are also all &quot;new&quot; (i.e., not included in the chains of j&lt;sup&gt;0&lt;/sup&gt; at r0) and different. Since in round r0, the block containing fj+κ&lt;sup&gt;f&lt;/sup&gt; was added to the chain of j0, and since by WLOG5, the chain of j&lt;sup&gt;0&lt;/sup&gt; at r&lt;sup&gt;0&lt;/sup&gt; up until (and including) the block which contains fj+κ&lt;sup&gt;f&lt;/sup&gt; is a prefix of C, all these fruits must in fact be contained in the sequence fj+κ&lt;sup&gt;f&lt;/sup&gt; , . . . , fj+&lt;sup&gt;T&lt;/sup&gt; .</li>
      <li>Finally, by fruit consistency, at r&lt;sup&gt;0&lt;/sup&gt; all honest players' fruit chains contain f1, . . . f&lt;sup&gt;j&lt;/sup&gt; (since recall that some player added fj+κ&lt;sup&gt;f&lt;/sup&gt; at r0). Thus all these fruits are S-compatible w.r.t the prefix f1, . . . fj−&lt;sup&gt;1&lt;/sup&gt; before the T segment we are considering.</li>
    </ul>

    <p class="text-gray-300">We proceed to show that t is sufficiently large. Recall that j&lt;sup&gt;0&lt;/sup&gt; is honest at r&lt;sup&gt;0&lt;/sup&gt; and j&lt;sup&gt;1&lt;/sup&gt; is honest at r1. We know that at r1, the fruit chain contains at least fj+&lt;sup&gt;T&lt;/sup&gt; fruits. Additionally, at r&lt;sup&gt;0&lt;/sup&gt; the fruit fj+κ&lt;sup&gt;f&lt;/sup&gt; is added for the first time, so by fruit chain consistency, at most j + 2κ&lt;sup&gt;f&lt;/sup&gt; fruits could have been in the chain of i at this point (since a fruit at position j + κ&lt;sup&gt;f&lt;/sup&gt; is modified). Thus, the fruit chain must have grown by at least T − 2κ&lt;sup&gt;f&lt;/sup&gt; from r&lt;sup&gt;0&lt;/sup&gt; to r1. By the upperbound on fruit growth (see Equation <a href="#page-22-0">2)</a> we thus have that</p>

    <p class="text-gray-300"><span class="math">$T - 2\\kappa_f \\le \\kappa_f + (1 - \\delta&#x27;)^2 n p_f(t+2)</span>$</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">$t \\ge \\frac{1}{(1+\\delta&#x27;)^2 n p_f} \\left( T - 3\\kappa_f \\right) - 2</span>$</p>

    <p class="text-gray-300">We conclude that (except with negligible probability) the number of fruits in the sequence is at least:</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)\\phi np_f \\left(\\frac{1}{(1 + \\delta&#x27;)^2 np_f} (T - 3\\kappa_f) - 2 - wait\\right) =</span>$</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)\\phi \\left(\\frac{1}{(1 + \\delta&#x27;)^2} (T - 3\\kappa_f) - np_f(wait + 2)\\right) \\geq</span>$</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)\\phi \\left(\\frac{1}{(1 + \\delta&#x27;)^2} (T - 3\\kappa_f) - \\kappa_f\\right) \\geq</span>$</p>

    <p class="text-gray-300"><span class="math">$(1 - \\delta&#x27;)\\phi \\left(\\frac{1}{(1 + \\delta&#x27;)^2} (T - 4.5\\kappa_f)\\right) \\geq</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi(T - 5\\kappa_f)</span>$</p>

    <p class="text-gray-300">where the first inequality follows by Fact <a href="#page-19-1">5.2,</a> and the second and third by the taking a sufficiently small δ 0 . Since T ≥ 5κ&lt;sup&gt;f&lt;/sup&gt; δ , we have that (1−δ)T ≥ T −5κ&lt;sup&gt;f&lt;/sup&gt; , thus the number of fruits in the sequence is at least</p>

    <p class="text-gray-300"><span class="math">$(1-\\delta)\\phi T</span>$</p>

    <p class="text-gray-300">We remark that any secure blockchain protocol that satisfies δ-approximate fairness (where δ &lt; 0.3) w.r.t T(κ) length windows can be used as the ledger underlying a cryptocurrency system while ensuring 3δ-incentive compatibility if players (i.e. miners) only care about how much money they receive—that is, a miner's utility is the sum of the rewards and transaction fees it receives (potentially times some constant).<a href="#page-24-1">8</a></p>

    <p class="text-gray-300">Consider a crypto-currency which uses a blockchain protocol as the underlying ledger; we omit a formalization of what this means, but have in mind a system such as Bitcoin where rewards and transaction fees are somehow distributed among the miners of blocks—for instance, recall that in Bitcoin, the miner of a block receives a mining reward as well as all the transaction fees contained in the block it mined.</p>

    <p class="text-gray-300">We say that honest mining is a ρ-coalition-safe -Nash equilibrium if, with overwhelming probability, no ρ &lt;sup&gt;0&lt;/sup&gt; &lt; ρ fraction coalition can gain more than a multiplicative factor (1 + ) in utility, no matter what transactions are being processed—formally, consider some environment providing transactions into the system. We restrict to a setting where the total rewards and transaction fees during the run of the system is some fixed constant V <a href="#page-24-2">9</a> .</p>

    <p class="text-gray-300">We now remark that if rewards and transaction fees are evenly distributed among the (miners of the) blocks in the T(κ)-length segment of the chain preceeding the block (and in the initial phase, before the chain is of length T(κ), simply the first T(κ) blocks) then it follows that honest mining is a ρ-coalition-safe 3δ-Nash equilibrium as long as the underlying blockchain satisfies δ-approximate fairness w.r.t. ρ attackers: as noted above, fairness implies that no matter what deviation the coalition performs, with overwhelming probability, the fraction of adversarial blocks in any T(κ) length window of the chain is upperbounded by (1+δ)ρ and thus the total amount of compensation received by the attacker is bounded by (1 + δ)ρ · V ; in contrast, by fairness, if the coalition had been following the honest protocol, they are guaranteed to receive at least (1 − δ)ρ · V ; thus, the multiplicative increase in utility is</p>

    <p class="text-gray-300"><span class="math">$\\frac{1+\\delta}{1-\\delta} \\le 1+3\\delta</span>$</p>

    <p class="text-gray-300">when δ &lt; 0.3.<a href="#page-24-3">10</a></p>

    <p class="text-gray-300">To see why the &quot;standard&quot; bitcoin approach of giving all rewards and fees to the miner of the block does not work, consider an freshly mined (honest) block containing a transaction with a very high transaction fee. A coalition controlling a constant fraction of the computing power would have a huge incentive to &quot;drop&quot; this block and instead try to mine a new block which contains it. Fairness does not prevent such an attack, and indeed, even in our protocol such an attack will be successful with constant probability. (Indeed, it has been informally conjectured in the bitcoin community that -incentive compatibility is impossible to achieve in the presence of transaction fees, due to exactly this reason. Our method of distributing the fees over a segment overcomes this &quot;barrier&quot;.)</p>

    <p class="text-gray-300">An issue with the Bitcoin protocol (which relies on Nakamoto's blockchain protocol) is that the mining hardness is set so that the world (combined) finds a new block every 10 minutes—as shown in <a href="#page-26-1">[PSS17]</a>, the mining hardness needs to be set in such a way to ensure consistency. This not only leads to a long latency (which can be remedied by the Hybrid Consensus approach discussed</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;8&lt;/sup&gt;This may not always be a realistic assumption. For instance, a miner can care about what transactions get added into the blockchain etc, but following earlier approaches to modeling incentives in blockchains (e.g., <a href="#page-25-3">[ES14]</a>), we focus only on miners' monetary rewards.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;9&lt;/sup&gt;The analysis directly extends to a setting where the total rewards and fees are only guaranteed to be withing some multiplicative factor (1 + δ 0 ) of V at the cost of a degradation of the quality of the Nash equilibrium (i.e., increasing the ).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-3&quot;&gt;&lt;/span&gt;&lt;sup&gt;10&lt;/sup&gt;Let us remark that an alternative approach would be to give the whole mining reward to the miner of a block (as in Bitcoin) but still distribute the transaction fees among the group of miners in a T(κ)-segment of the chain. This approach works by the same analysis as long as mining rewards are fixed throughout the experiment (which is not the case for e.g., Bitcoin where mining rewards decrease over time).</p>

    <p class="text-gray-300">above), but also leads to the issue that it may take a very long time for an individual miner to be successful in mining a block and consequently reap a reward for its work. In other words, the payments received by miners has a very high variance. This has lead to the creation of mining pools, where miners come together and pool their work and then share the reward once someone in the pool mines a block—such pooling decreases the variance. To prevent free-riding, miners submit &quot;partial proofs of work&quot; (that is, &quot;near&quot; solutions to the mining puzzles) that are significantly easier to find, and rewards are distributed (according to some distribution rule) among the contributors of the partial proofs-of-work.</p>

    <p class="text-gray-300">An undesirable effect of such pools is that the pool operator effectively controls a large number of participants and potentially could get them to deviate; in a sense, the decentralized nature of the system gets lost.</p>

    <p class="text-gray-300">We note that since the FruitChain protocol is parametrized by two mining hardnesses—the block hardness p, and the fruit hardness pf—which are independent of each other, we can set p appropriately to ensure consistency, but p&lt;sup&gt;f&lt;/sup&gt; can be set to be much larger—for instance, as large as the probability of find a partial proof-of-work in mining pools—and consequently, we would reduce the variance of the rewards received by miners in exactly the same way as in mining pool, but now in a fully decentralized way.</p>

    <p class="text-gray-300">Today, a solo miner (assuming one unit of typical commodity mining ASIC) would take 2 to 5 years to obtain its first reward <a href="#page-25-5">[sol]</a>. With FruitChain, suppose we allocate space for 1000 fruits per block where each fruit is 80 bytes (same size as a Bitcoin puzzle solution), this would occupy roughly 8% of a 1MB block — however, this would allow a solo miner to get its first rewards 1000x faster, roughly on the order of a day (or days) rather than years.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-5&quot;&gt;&lt;/span&gt;[sol] <a href="http://www.coinwarz.com/calculators/bitcoin-mining-calculator">http://www.coinwarz.com/calculators/bitcoin-mining-calculator</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;[BCL+05] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO'05, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-6&quot;&gt;&lt;/span&gt;[BHP+] Iddo Bentov, Yuncong Hu, Rafael Pass, Elaine Shi, and Siqiu Yao. Decentralized pooled mining: An implementation of fruitchain. Manuscript.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-7&quot;&gt;&lt;/span&gt;[BPS16] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report 2016/919, 2016. <a href="http://eprint.iacr.org/2016/919">http://eprint.iacr.org/2016/</a> <a href="http://eprint.iacr.org/2016/919">919</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-4&quot;&gt;&lt;/span&gt;[CKWN16] Miles Carlsten, Harry A. Kalodner, S. Matthew Weinberg, and Arvind Narayanan. On the instability of bitcoin without the block reward. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016, pages 154–167, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO'92, pages 139–147, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;[ES14] Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography and Data Security, pages 436–454. Springer, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;[GKL15] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology-EUROCRYPT 2015, pages 281– 310. Springer, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;[HP15] Joseph Y. Halpern and Rafael Pass. Algorithmic rationality: Game theory with costly computation. J. Economic Theory, 156:246–268, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-11&quot;&gt;&lt;/span&gt;[KKKT16] Aggelos Kiayias, Elias Koutsoupias, Maria Kyropoulou, and Yiannis Tselekounis. Blockchain mining games. In Proceedings of the 2016 ACM Conference on Economics and Computation, EC '16, pages 365–382, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-12&quot;&gt;&lt;/span&gt;[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-8&quot;&gt;&lt;/span&gt;[KP16] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. IACR Cryptology ePrint Archive, 2016:545, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-10&quot;&gt;&lt;/span&gt;[KRDO16] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. <a href="http://eprint.iacr.org/2016/889">http://eprint.iacr.org/2016/889</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-7&quot;&gt;&lt;/span&gt;[LSZ15] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain protocols. In Financial Crypto'15, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;[mtg10] mtgox. <a href="https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606">https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606</a>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;[Nak08] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-5&quot;&gt;&lt;/span&gt;[NKMS16] Kartik Nayak, Srijan Kumar, Andrew Miller, and Elaine Shi. Stubborn mining: Generalizing selfish mining and combining with an eclipse attack. In IEEE European Symposium on Security and Privacy, EuroS&amp;P 2016, Saarbr¨ucken, Germany, March 21-24, 2016, pages 305–320, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;[PSS17] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. In Eurocrypt, 2017.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-9&quot;&gt;&lt;/span&gt;[PS16] Rafael Pass and Elaine Shi. Hybrid consensus. <a href="http://eprint.iacr.org/2016/917">http://eprint.iacr.org/2016/917</a>, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-4&quot;&gt;&lt;/span&gt;[SSZ16] Ayelet Sapirshtein, Yonatan Sompolinsky, and Aviv Zohar. Optimal selfish mining strategies in bitcoin. In Financial Crypto'16, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-6&quot;&gt;&lt;/span&gt;[SZ15] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, pages 507–527, 2015.</p></li>
    </ul>

    <p class="text-gray-300">We recall the standard Chernoff bound.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-13&quot;&gt;&lt;/span&gt;Lemma A.1 (Multiplicative Chernoff Bound). Let X1, . . . X&lt;sup&gt;n&lt;/sup&gt; be independent Boolean random variables, such that for all i, Pr[X&lt;sup&gt;i&lt;/sup&gt; = 1] = p; let X be the sum of these variables, and µ be the expectation of the sum. Then for any δ ∈ (0, 1], we have</p>

    <p class="text-gray-300"><span class="math">$Pr\\left[X &gt; (1+\\delta)\\,\\mu\\right] &lt; e^{-\\Omega\\left(\\delta^2\\mu\\right)}</span>$</p>

    <p class="text-gray-300"><span class="math">$Pr[X &lt; (1 - \\delta)\\mu] &lt; e^{-\\Omega(\\delta^2\\mu)}</span>$</p>

`;
---

<BaseLayout title="3 Defining Fairness (2016/916)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/916
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="3-defining-fairness-2016" />
  </article>
</BaseLayout>
