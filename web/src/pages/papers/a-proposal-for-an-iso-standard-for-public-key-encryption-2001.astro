---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2001/112';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Proposal for an ISO Standard for Public Key Encryption';
const AUTHORS_HTML = 'Victor Shoup';

const CONTENT = `    <p class="text-gray-300">A Proposal for an ISO Standard for Public Key Encryption (version 2.1)</p>

    <p class="text-gray-300">Victor Shoup IBM Zurich Research Lab, Säumerstr. 4, 8803 Rüschlikon, Switzerland sho@zurich.ibm.com</p>

    <p class="text-gray-300">December 20, 2001</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">This document is an initial proposal for a draft for a forthcoming ISO standard on public-key encryption. It is hoped that this proposal will serve as a basis for discussion, from which a consensus for a standard may be formed.</p>

    <p class="text-gray-300">Summary of Changes from version 2.0 (September 17, 2001) to version 2.1 (December 20, 2001)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fixed a few minor typos, and added some references to supporting documents.</li>

      <li>Otherwise, there are no substantive changes, and the section numbering is identical to that of version 2.0.</li>

    </ul>

    <p class="text-gray-300">i</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Some new and quite severe criticisms of the security of ECIES in certain modes of operation have been added. Specifically, it is shown that in certain modes of operation, the scheme is malleable in a very strong and quite non-trivial sense. See §15 and in particular §15.6.4.</li>

      <li>The implementation of "cofactor mode" for ECIES is now based on the notion of "compatible cofactor mode" in IEEE P1363a, and the "old cofactor mode" is no longer recommended. See §15 as well as §15.6.5.</li>

      <li>A new "primitive" called a data encapsulation mechanism has been introduced (see §4). This primitive was implicit in previous versions, but now it has been made explicit. This is mainly just a conceptual change. Note, however, that there is one slight change in the recommended implementation of the primitive (which we call DEMI); namely, the way in which the length of the label is formatted when passed to the MAC. This is done so as to align with IEEE P1363a. This change affects ECIES, as well as other hybrid schemes. See §10.</li>

      <li>A new section has been added that details all the differences between our recommended version of ECIES and that recommended in the IEEE P1363a standard. Note that our recommended version of ECIES is consistent with the IEEE P1363a version — the only differences between the two are that our recommended version does not allow several options and modes of operations allowed by the IEEE P1363a version. See §15.6.</li>

      <li>Two changes were made to ACE-KEM (formerly ACE-Encrypt'). First, the value of  <span class="math">\\mathbf{v}</span>  is now encoded in the ciphertext using the group encoding function, rather than the partial encoding function as in previous versions. This was done mainly for aesthetic reasons. Second, the implementation of "cofactor mode" has been changed to align with the IEEE P1363a notion of "compatible cofactor mode." See §17.</li>

      <li>It is now recommended that all Diffie-Hellman-based schemes use prime order subgroups. This is done mainly for alignment with other standards, as well overall consistency.</li>

      <li>Following discussions in Santa Barbara, this report now recommends inclusion of EPOC-2 in the standard, although this report does not yet include a detailed specification of EPOC-2.</li>

      <li>A new final section has been added that recommends the next steps to be taken toward an ISO standard. See §21.</li>

      <li>A number of names have been changed. Some of these name changes were suggested by working group members, while others were made to increase overall consistency.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">old name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">new name</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECIES'</td>

            <td class="px-3 py-2 border-b border-gray-700">ECIES-KEM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PSEC-2'</td>

            <td class="px-3 py-2 border-b border-gray-700">PSEC-KEM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ACE-Encrypt'</td>

            <td class="px-3 py-2 border-b border-gray-700">ACE-KEM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Simple RSA</td>

            <td class="px-3 py-2 border-b border-gray-700">RSA-KEM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EME-OAEP</td>

            <td class="px-3 py-2 border-b border-gray-700">OAEP-EME</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">XEME-OAEP+</td>

            <td class="px-3 py-2 border-b border-gray-700">OAEP+XEME</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A number of other, essentially aesthetic, changes.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The decryption algorithm for ACE-Encrypt<span class="math">^r</span> has been slightly modified (see §17.3).</li>

      <li>Additionally, some minor errors — not affecting the descriptions of any algorithms — have been fixed.</li>

    </ul>

    <p class="text-gray-300">iii</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Background 1 1.2 Goals of this document 2 1.3 Preliminary remarks on security 2 1.4 A summary of submissions and proposed schemes 4</p>

    <p class="text-gray-300">2 Public-key encryption and chosen ciphertext attack 8 2.1 Abstract interface 8 2.2 Notion of security 11 2.3 Benign malleability: a slightly weaker notion of security 13</p>

    <p class="text-gray-300">3 Key encapsulation 13 3.1 Abstract interface 14 3.2 Notion of security 14 3.3 Further remarks 15</p>

    <p class="text-gray-300">4 Data encapsulation 15 4.1 Abstract interface 16 4.2 Notion of security 16</p>

    <p class="text-gray-300">5 Hybrid encryption 16 6 Byte string/integer conversions 17 7 Pseudo-random byte generator 17 8 Symmetric key encryption 18 8.1 Abstract interface 18 8.2 Notion of security 18</p>

    <p class="text-gray-300">9 One-time MAC 18 10 DEM1 19 11 Hash functions 20 12 Key derivation functions 20 12.1 KDF1 21 12.2 KDF2 21 12.3 Security critique of KDF1 and KDF2 21 12.4 KDF3 22 12.5 KDF4 22</p>

    <p class="text-gray-300">13 Abstract groups 23 13.1 Subgroups of <span class="math">\\mathbf{Z}_p^*</span> 24 13.2 Subgroups of Elliptic Curves 24</p>

    <p class="text-gray-300">14 Intractability assumptions related to groups 24</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>14.1 The Computational Diffie-Hellman Problem 24</li>

      <li>14.2 The Decisional Diffie-Hellman Problem 25</li>

      <li>14.3 The Gap-CDH Problem 25</li>

    </ul>

    <p class="text-gray-300">15 ECIES-KEM 25</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>15.1 Key Generation 25</li>

      <li>15.2 Encryption 26</li>

      <li>15.3 Decryption 26</li>

      <li>15.4 Some remarks 26</li>

      <li>15.5 Security considerations 27</li>

      <li>15.6 Compatibility with the IEEE P1363a version of ECIES 27</li>

      <li>15.7 Compatibility with the submitted version of ECIES 32</li>

    </ul>

    <p class="text-gray-300">16 PSEC-KEM 32</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>16.1 Key Generation 32</li>

      <li>16.2 Encryption 32</li>

      <li>16.3 Decryption 33</li>

      <li>16.4 Some remarks 33</li>

      <li>16.5 Changes from PSEC-2 34</li>

      <li>16.6 Security considerations 35</li>

    </ul>

    <p class="text-gray-300">17 ACE-KEM 39</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>17.1 Key Generation 39</li>

      <li>17.2 Encryption 39</li>

      <li>17.3 Decryption 40</li>

      <li>17.4 Some remarks 41</li>

      <li>17.5 Security considerations 41</li>

      <li>17.6 Further remarks 42</li>

    </ul>

    <p class="text-gray-300">18 RSA-OAEP 44</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>18.1 Message encoding functions 44</li>

      <li>18.2 OAEP-EME 44</li>

      <li>18.3 RSA-OAEP 45</li>

      <li>18.4 Defects of RSA-OAEP 46</li>

    </ul>

    <p class="text-gray-300">19 RSA-OAEP+ 46</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>19.1 Extended message encoding functions 47</li>

      <li>19.2 OAEP+XEME 47</li>

      <li>19.3 RSA-OAEP+ 49</li>

      <li>19.4 Security considerations 50</li>

    </ul>

    <p class="text-gray-300">20 RSA-KEM 51</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>20.1 Key generation 51</li>

      <li>20.2 Encryption 52</li>

      <li>20.3 Decryption 52</li>

      <li>20.4 Security considerations 52</li>

    </ul>

    <p class="text-gray-300">21 Further actions</p>

    <p class="text-gray-300">vi</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Background</h3>

    <p class="text-gray-300">At its meeting on April 3-7 2000 in London, the ISO/IEC JTC 1/SC 27/WG 2 decided to put out a call for contributions for a proposed new project (NP 18033) on encryption algorithms. This call for contributions (document SC 27 N 2563) proposed four parts:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>General</li>

      <li>Asymmetric Ciphers</li>

      <li>Block Ciphers</li>

      <li>Stream Ciphers</li>

    </ol>

    <p class="text-gray-300">The author of this document is currently the acting editor for the Asymmetric Ciphers part of the standard. This document deals exclusively with asymmetric ciphers, a.k.a., public-key encryption schemes.</p>

    <p class="text-gray-300">A number of submissions in response to the call for contributions were received, and are available as ISO document SC 27 N 2656. The author of the present document has carefully reviewed all of the submitted proposals for public-key encryption schemes.</p>

    <p class="text-gray-300">There were a number of different types of schemes submitted:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Some are based on the hardness of factoring integers or related problems.</li>

      <li>Some are Diffie-Hellman-based schemes — of these, some are based on elliptic curves, and some are based on subgroups of <span class="math">{\\bf Z}_{p}^{*}</span>.</li>

      <li>Some allow encryption of arbitrary length messages, and others only allow encryption of short messages.</li>

      <li>Some allow for additional data to be “non-malleably bound” to the ciphertext, while others do not.</li>

      <li>Some allow for messages and ciphertexts to be efficiently processed as “streams,” while others do not, requiring more than one pass over this data.</li>

      <li>Some have claims of “provable” security against adaptive chosen ciphertext attack — some relying on the “random oracle” heuristic — some not. For several schemes, these claims of security have proven to be invalid upon closer scrutiny.</li>

    </ul>

    <p class="text-gray-300">Clearly, these submissions are quite incompatible in a number of respects, and one of the challenges of this project is to minimize these incompatibilities.</p>

    <p class="text-gray-300">Recently, an ad hoc meeting of the working group was held on August 21 in Santa Barbara, to further discuss the proposals in an earlier draft of this document. The current version of this proposal reflects the author’s own vision for how this standard should develop, while at the same time, takes into account the discussions at the ad hoc meeting.</p>

    <p class="text-gray-300">1.2 Goals of this document</p>

    <p class="text-gray-300">The goals of this document are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To propose a standard functionality that a public-key encryption scheme should implement. This is essentially an abstract interface.</li>

      <li>To propose a “unified framework” for hybrid encryption. In order for a cryptosystem to be practical, it must be able to process messages that are arbitrary byte strings. There are traditional, and fairly well known “hybrid” schemes to do this: one first uses public-key techniques to derive a shared key, and then encrypts or decrypts the actual payload using symmetric-key techniques. We propose a fairly traditional and “provably” secure way of doing this.</li>

    </ul>

    <p class="text-gray-300">We shall refer to a method of generating a shared random key in this sense as a “key encapsulation mechanism,” and we shall refer to a method of encrypting the message using such a shared random key as a “data encapsulation mechanism.”</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To propose a “unified framework” for Diffie-Hellman-based encryption schemes. This framework specifies an “abstract group interface” for a group so that any Diffie-Hellman-based encryption scheme can be specified with respect to an abstract group, but yet the group can be implemented in one of several ways, including as a subgroup of an elliptic curve group, and as a subgroup of <span class="math">\\mathbf{Z}_{p}^{*}</span>. The interface is rich enough so as to support all of the subtleties and quirks found in many proposed cryptosystems, especially those using elliptic curves.</li>

      <li>To propose a set of encryption schemes such that each scheme</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>is “provably” secure against adaptive chosen ciphertext attack in some reasonable sense,</li>

      <li>conforms to the proposed abstract interface,</li>

      <li>conforms to the proposed unified framework for hybrid encryption (where applicable),</li>

      <li>conforms to the proposed unified framework for Diffie-Hellman-based encryption (where applicable),</li>

      <li>provides a fairly unique and attractive tradeoff between efficiency and security, and</li>

      <li>conforms to pre-existing standards (where applicable).</li>

    </ul>

    <p class="text-gray-300">In order to achieve the last goal of proposing a set of schemes meeting the stated requirements, we have taken several of the submitted schemes, and proposed modified schemes that meet the stated requirements. Some of these changes are quite minor, while others are more drastic. Some schemes were omitted altogether — given the limited amount of time and other resources available to construct this proposal for a standard, resources had to be concentrated on those schemes which appeared most likely to meet the stated objectives, either with or without minor modification.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Preliminary remarks on security</h3>

    <p class="text-gray-300">Typically, practical symmetric encryption schemes are designed “from scratch,” based partly on established design principles. The security of such a scheme is usually simply taken on faith — there is no justification other than to demonstrate that reasonable design principles were employed in the design of the scheme, and to give (perhaps heuristic) arguments that the scheme resists known types of attacks.</p>

    <p class="text-gray-300">For public-key encryption schemes, the situation is somewhat different. Such a scheme is typically composed of a number of components: besides some kind of “trapdoor” cryptographic transform, there may also be various other components, such as hash functions, symmetric ciphers, etc. Because of this, it is customary nowadays to formally analyze the security of such a scheme relative to the security of its constituent components; that is, to prove the security of the scheme under the assumption that these components satisfy particular, explicit security requirements.</p>

    <p class="text-gray-300">Since proving the security of practical schemes in this way is often infeasible, a heuristic called the random oracle model is sometimes used in the proof. In this approach, a cryptographic hash function is modeled — for the purposes of analysis — as a “black box” containing a random function to which the adversary and the algorithms implementing the cryptosystem have “oracle access.” This approach has been used implicitly and informally for some time; however, it was formalized by Bellare and Rogaway <em>[x1]</em>, and has subsequently been used quite a bit in the cryptographic research community.</p>

    <p class="text-gray-300">We should stress, however, that the random oracle model is not just “another assumption,” like assuming that a hash function is collision resistant, or that a function is pseudo-random. It is a heuristic “leap of faith” — invoking this heuristic is qualitatively a much bigger step than making any particular cryptographic assumption. Indeed, in <em>[x2]</em>, it is shown that there are cryptosystems that are secure in the random oracle model, but are insecure no matter what hash function is used to implement the random oracle.</p>

    <p class="text-gray-300">Despite these problems, the random oracle model is still a useful heuristic and design principle. A proof of security in the random oracle model is still much better than no proof at all, and certainly such a proof does rule out a large family of attacks.</p>

    <p class="text-gray-300">In judging the security of a “provably secure” scheme, there are several independent “dimensions”:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the use or non-use of the random oracle heuristic,</li>

      <li>the “strength” of the underlying assumptions, and</li>

      <li>the efficiency of the security reduction.</li>

    </ul>

    <p class="text-gray-300">Because of these several dimensions, the security of two “provably secure” schemes might be essentially incomparable. For example, one scheme might rely on the random oracle heuristic and a weak assumption, and the other might not use the random oracle heuristic but rely on a stronger assumption, or perhaps the assumptions are simply incomparable.</p>

    <p class="text-gray-300">The efficiency of a security reduction is an issue that is all too often ignored. However, it should be taken into account. For example, a scheme might be secure if RSA inversion is hard, but the security reduction may be so inefficient that for typical sizes of keys — say 1024-bit RSA modulus — the implied algorithm for solving the RSA inversion problem might be slower than the fastest currently known algorithm for factoring numbers.</p>

    <p class="text-gray-300">Even if the security reduction is very inefficient, it can still be argued that such a proof of security nevertheless provides a “qualitative” guarantee of security. Moreover, such a reduction does rule out attacks that would efficiently “scale” to larger sizes of keys.</p>

    <p class="text-gray-300">For public-key encryption schemes, it is widely agreed that the “right” notion of security for a scheme intended for general-purpose use is that of security against adaptive chosen ciphertext attack. This notion was introduced in <em>[x10]</em>, and implies other useful properties, like non-malleability. See <em>[x4, x5, x3]</em> for further discussion. In this document, this will be the relevant notion of security used for judging the security of an encryption scheme.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.4 A summary of submissions and proposed schemes</p>

    <p class="text-gray-300">In this section, we summarize the submissions that were made, give a very brief assessment of of the submissions, and briefly describe the schemes that we actually propose to be included in the standard.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.4.1 RSA-OAEP, RSA-OAEP+, and RSA-KEM</h4>

    <p class="text-gray-300">RSA-OAEP is the fairly well-established RSA encryption scheme, using the padding scheme OAEP invented by Bellare and Rogaway <em>[x1]</em>, with enhancements and refinements due to Johnson and Matyas <em>[x10]</em>.</p>

    <p class="text-gray-300">The submission coincides with the standards PKCS #1 v2.0 and IEEE P1363.</p>

    <p class="text-gray-300">One of the main supposed virtues of this scheme was an alleged proof in the random oracle model of security against adaptive chosen ciphertext attack, assuming RSA inversion is hard. This “proof” was published in <em>[x1]</em>, and despite years of public scrutiny, it was only recently observed in <em>[x22]</em> that not only is the proof invalid, but that there can be no standard proof via “black box” reduction for the OAEP construction in general, given an arbitrary one-way trapdoor permutation.</p>

    <p class="text-gray-300">This negative result does not necessarily imply that the specific instance RSA-OAEP is insecure. Indeed, as it turns out — essentially by accident, rather than design — RSA-OAEP is indeed secure in the random oracle model. This was proven for encryption exponent 3 in <em>[x22]</em>, and for arbitrary encryption exponent in <em>[x12]</em>. The security reduction is the latter paper is highly inefficient, however.</p>

    <p class="text-gray-300">Another problem with RSA-OAEP is that it only encrypts messages of short length. As such, many applications that use RSA-OAEP use it simply as a key encapsulation mechanism, which wastes one of the most attractive features of RSA-OAEP, namely, its fairly compact ciphertexts.</p>

    <p class="text-gray-300">To overcome these problems, we propose in this document a new scheme, called RSA-OAEP+. It is just as efficient as RSA-OAEP, but the general OAEP+ construction is provably secure in the random oracle model (as shown in <em>[x22]</em>). Moreover, even with RSA, the security reduction for OAEP+ is much more efficient than that in <em>[x12]</em> for OAEP, making the scheme more attractive from a concrete security point of view. Also, RSA-OAEP+ is enhanced to deal with arbitrary-length messages in a very “compact” manner.</p>

    <p class="text-gray-300">Even with the security improvements provided by RSA-OAEP+, the security reduction is still so inefficient that the security guarantees provided are still not very meaningful in a strict, quantitative sense. For this reason, we also recommend an alternative RSA scheme which is both simpler and more secure, which we call RSA-KEM. This scheme is designed as a pure key encapsulation mechanism, and fits more nicely into our framework for hybrid encryption.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.4.2 ECIES</h4>

    <p class="text-gray-300">ECIES is the “Elliptic Curve Integrated Encryption Scheme.” It is a Diffie-Hellman-based scheme. It is a hybrid encryption scheme based on the hardness of the Computational Diffie-Hellman (CDH) problem for elliptic curves. It is closely related to the DHAES construction in <em>[x1]</em>.</p>

    <p class="text-gray-300">The current draft of IEEE P1363a also contains a version of ECIES, but this version differs in some significant respects from the submitted version of ECIES.</p>

    <p class="text-gray-300">As we shall point out, this scheme is not secure against adaptive chosen ciphertext attack, but can easily be made so with some small changes. Therefore, we have proposed a scheme ECIES-KEM,</p>

    <p class="text-gray-300">which besides providing a higher level of security, also has been generalized to conform to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. The changes between ECIES and ECIES-KEM are the minimal changes required to ensure security.</p>

    <p class="text-gray-300">The ECIES-KEM scheme is a pure key encapsulation mechanism. It can be converted into a hybrid encryption scheme using the techniques standardized here. The resulting hybrid encryption scheme is consistent with the ECIES scheme proposed in IEEE P1363a, in the sense that the scheme proposed here conforms to that in IEEE P1363a; however, there are a number of variations and modes of operation of ECIES in P1363a that do not conform to the scheme proposed here. Thus, this standard for ECIES is a strict subset of the IEEE P1363a standard for ECIES.</p>

    <p class="text-gray-300">The main motivation for these restrictions are security concerns about the IEEE P1363a version of ECIES. The secondary motivation for these restrictions is to make this standard simpler, more uniform, and self-consistent.</p>

    <p class="text-gray-300">The ECIES-KEM scheme can be proven secure against adaptive chosen ciphertext attack, either by using the rather non-standard assumption in <em>[x1]</em>, or by using the random oracle heuristic, combined with the (also not very standard) assumption that the CDH problem is hard, even when given access to an oracle for the Decisional Diffie-Hellman (DDH) problem. This latter assumption is called the gap-CDH assumption, and is studied in detail in <em>[x22]</em>.</p>

    <p class="text-gray-300">As for efficiency, encryption takes two group exponentiations, and decryption takes one or two (depending on the group, but usually one for elliptic curves).</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">1.4.3 PSEC</h4>

    <p class="text-gray-300">PSEC is a family of Diffie-Hellman-based encryption schemes.</p>

    <p class="text-gray-300">It is claimed that these schemes are all provably secure in the random oracle model, under different assumptions. There are three schemes: PSEC-1, PSEC-2, and PSEC-3.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For PSEC-1, the DDH problem is assumed to be hard.</li>

      <li>For PSEC-2, the CDH problem is assumed to be hard.</li>

      <li>PSEC-3 is based on the gap-CDH assumption.</li>

    </ul>

    <p class="text-gray-300">We shall argue that actually, these security claims for PSEC-1 and PSEC-2 are unjustified (see §16.5).</p>

    <p class="text-gray-300">We shall propose a scheme PSEC-KEM that is a variant of PSEC-2, and we provide a complete and detailed proof of security in the random oracle model based on the CDH assumption. Besides correcting the security problems of PSEC-2, other changes were made so that the resulting scheme conforms to our proposed abstract interface and to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. In particular, as the name implies, PSEC-KEM is a key encapsulation mechanism.</p>

    <p class="text-gray-300">As for efficiency, both PSEC-KEM encryption and decryption require two group exponentiations.</p>

    <p class="text-gray-300">PSEC-1 is based on stronger assumptions, is not significantly more efficient than the other schemes, and has some significant security problems. For these reasons, we have chosen not to include it (or a variant thereof) in this proposal.</p>

    <p class="text-gray-300">PSEC-3 is very similar to ECIES, offering an almost identical efficiency/security trade-off; since ECIES appears to be the more well-established scheme, we have chosen not to include PSEC-3 (or a variant thereof) in this proposal.</p>

    <p class="text-gray-300">ACE-Encrypt is a Diffie-Hellman-based hybrid encryption scheme that can be proven secure against adaptive chosen ciphertext attack assuming the DDH problem is hard. It is the only submission that can truly be proven secure — it does not rely on the random oracle heuristic. It is slightly less efficient than PSEC-2.</p>

    <p class="text-gray-300">The submission is based on the DDH problem for a subgroup of <span class="math">\\mathbf{Z}_{p}^{*}</span>. We have proposed a variant, ACE-KEM. Several changes were made to the original ACE-Encrypt scheme so that the resulting scheme conforms to our proposed abstract interface and to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. As the name suggests, ACE-KEM is a key encapsulation mechanism. ACE-KEM and the corresponding hybrid scheme are still provably secure — without the random oracle heuristic — based on the DDH, as well as a couple of other reasonable symmetric-key cryptographic assumptions.</p>

    <p class="text-gray-300">As for efficiency, ACE-KEM encryption requires five group exponentiations, and decryption requires either three or four (depending on the group, but usually three for elliptic curves). Several optimizations are available to reduce the effective costs of these exponentiations, however.</p>

    <p class="text-gray-300">We point out that, like PSEC-KEM, the scheme ACE-KEM can be proven secure in the random oracle model under the weaker CDH assumption, although the security reduction for ACE-KEM is much less efficient than that for PSEC-KEM. Additionally, it can be shown that ACE-KEM is no less secure than ECIES-KEM, in the sense that there is a very tight reduction from an attack on ECIES-KEM to an attack ACE-KEM. That is, any attack on ACE-KEM can be converted into an attack on ECIES-KEM, where the running time and success probability of the latter attack are essentially the same as for the former attack. This is discussed in detail in §17.6.2. Thus, any fears that the DDH assumption is “too strong” (see <em>[x10]</em>) can be safely put to rest.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">1.4.5 EPOC</h4>

    <p class="text-gray-300">EPOC is a family of encryption schemes based on factoring integers of the form <span class="math">n=p^{2}q</span>. There are three variants: EPOC-1, EPOC-2, and EPOC-3.</p>

    <p class="text-gray-300">Security of these schemes is claimed in the random oracle model under one of several assumptions (including the assumption that factoring is hard).</p>

    <p class="text-gray-300">It was the initial judgment of this author that these schemes should not be included in the standard, for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the theory on which these schemes are based has not been very widely scrutinized, nor have many of the implementation details;</li>

      <li>they do not seem to offer a particularly attractive efficiency/security tradeoff in relation to the other schemes (one drawback in particular is that it is not amenable “stream processing” — see §2.1.3).</li>

    </ul>

    <p class="text-gray-300">However, at the ad hoc meeting in Santa Barbara, a consensus was reached that EPOC-2 should be included in the standard. The reasons given were that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it is the only proposed scheme whose proof of security is based on factoring (as opposed to RSA inversion);</li>

      <li>the decryption operation may be somewhat faster than for RSA;</li>

      <li>it has been subjected to a certain amount of public scrutiny, and no security problems have yet been discovered;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it is in IEEE P1363a, and so including it in the ISO standard increases the compatibility of these two standards.</li>

    </ul>

    <p class="text-gray-300">At the present time, we have not yet incorporated a specification EPOC-2 into this proposal, although the intention is that it will be a part of the first working draft. This specification should be consistent with the IEEE P1363a version of EPOC-2.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">1.4.6 HIME</h4>

    <p class="text-gray-300">HIME is a family of encryption schemes based on factoring integers.</p>

    <p class="text-gray-300">Security of these schemes is claimed in the random oracle model under one of several assumptions (including the assumption that factoring is hard).</p>

    <p class="text-gray-300">It was the judgment of this author that these schemes should not be included in the standard. The main reason for this is that the design of the schemes and the claims of security do not appear to stand on very firm ground. Indeed, many details are missing, and it is not at all clear that these gaps can be filled in. Moreover, none of these schemes have been published anywhere, and therefore have not been widely scrutinized.</p>

    <p class="text-gray-300">Also, it was the general consensus at the ad hoc meeting in Santa Barbara that this scheme should not be considered any further.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">1.4.7 Further references on the submissions</h4>

    <p class="text-gray-300">The schemes RSA-OAEP, ECIES, PSEC, EPOC, and ACE-Encrypt have also been submitted to the Crypto-Nessie evaluation project, and were presented at the first Crypto-Nessie workshop, held in Leuven on November 13-14, 2000.</p>

    <p class="text-gray-300">Besides the ISO document SC 27 N 2656, detailed descriptions of these algorithms are publicly available at www.cryptonessie.org/workshop.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">1.4.8 Summary of proposed schemes</h4>

    <p class="text-gray-300">So our proposed schemes are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Diffie-Hellman-based schemes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ECIES-KEM</li>

      <li>PSEC-KEM</li>

      <li>ACE-KEM</li>

      <li>RSA-based schemes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RSA-OAEP</li>

      <li>RSA-OAEP+</li>

      <li>RSA-KEM</li>

      <li>Factoring-based schemes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EPOC-2</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">exponentiations per encryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">exponentiations per decryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">random oracle heuristic</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">main assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECIES-KEM</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 (or 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">gap CDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PSEC-KEM</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">CDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ACE-KEM</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3 (or 4)</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">DDH</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of Diffie-Hellman-based schemes</p>

    <p class="text-gray-300">The reason for proposing three different RSA-based schemes is that they each offer a unique efficiency/security trade-off. While they are all based on the RSA problem, the security reduction for  <span class="math">RSA</span> - <span class="math">KEM</span>  is much tighter than that for  <span class="math">RSA-OAEP+</span> , and the security reduction for  <span class="math">RSA-OAEP+</span>  is much tighter than that of  <span class="math">RSA-OAEP</span> . Additionally,  <span class="math">RSA</span> - <span class="math">KEM</span>  is very simple, and fits more nicely into our general framework for hybrid encryption. The scheme  <span class="math">RSA-OAEP+</span>  is attractive as it yields more compact ciphertexts than the hybrid scheme arising from  <span class="math">RSA</span> - <span class="math">KEM</span> . The scheme  <span class="math">RSA-OAEP</span>  is included here mainly for compatibility with other standards: it offers no real security or performance benefit compared to the other RSA-based schemes.</p>

    <p class="text-gray-300">The reason for including three different Diffie-Hellman-based schemes is that they seem to each offer a unique efficiency/security trade-off, as summarized in Table 1.</p>

    <p class="text-gray-300">We first define the basic structure of a public-key encryption scheme.</p>

    <p class="text-gray-300">A public-key encryption scheme  <span class="math">PKE</span>  consists of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A key generation algorithm  <span class="math">PKE.KeyGen()</span> , that outputs a public key/secret key pair  <span class="math">(PK, SK)</span> . The structure of  <span class="math">PK</span>  and  <span class="math">SK</span>  depend on the particular scheme.</li>

      <li>An encryption algorithm  <span class="math">PKE.Encrypt(PK, L, M, options)</span>  that takes as input a public key  <span class="math">PK</span> , a label  <span class="math">L</span> , a message  <span class="math">M</span> , and an optional options argument, and outputs a ciphertext  <span class="math">C</span> . Note that  <span class="math">L, M</span> , and  <span class="math">C</span>  are byte strings. See §2.1.4 below for more on labels. See §2.1.6 below for more on the options argument.</li>

      <li>A decryption algorithm  <span class="math">PKE.Decrypt(SK, L, C)</span>  that takes as input a secret key  <span class="math">SK</span> , a label  <span class="math">L</span> , and a ciphertext  <span class="math">C</span> , and outputs a message  <span class="math">M</span> .</li>

    </ul>

    <p class="text-gray-300">In general, the key generation and encryption algorithms will be probabilistic algorithms, while the decryption algorithm is deterministic.</p>

    <p class="text-gray-300">A basic requirement of any public-key encryption scheme is soundness: for any public-key/secret-key pair  <span class="math">(PK, SK)</span> , for any label/message pair  <span class="math">(L, M)</span> , any encryption of  <span class="math">M</span>  with label  <span class="math">L</span>  under  <span class="math">PK</span>  decrypts with label  <span class="math">L</span>  under  <span class="math">SK</span>  to the original message  <span class="math">M</span> . This requirement may be relaxed, so that it holds only for all but an acceptably negligible fraction of public-key/secret-key pairs, and even just for all but an acceptably negligible fraction of encryptions.</p>

    <p class="text-gray-300">It is important to note that messages may be of arbitrary and variable length, although a particular scheme may choose to impose a (very large) upper bound on this length. Thus, our proposed notion of a public-key encryption scheme is essentially a “digital envelope.”</p>

    <p class="text-gray-300">Some currently available public-key encryption schemes, like RSA-OAEP, only allow for very short messages, and leave it to application engineers to design their own “hybrid” scheme to encrypt long messages (i.e., by encrypting a session key and then using symmetric-key cryptography to encrypt the payload).</p>

    <p class="text-gray-300">However, it seems unrealistic to expect application engineers to correctly design such a secure hybrid scheme. Even PKCS#7 — the standard “digital envelope” mechanism — is not appropriate. The simplest version of this simply encrypts a session key using RSA-OAEP, and then encrypts the message using a standard symmetric cipher — no additional integrity checks are made. Because of this, straightforward application of PKCS#7 yields a trivially malleable encryption scheme.</p>

    <p class="text-gray-300">Despite all of the above potential problems and limitations, given that some very important existing encryption schemes do impose a small upper bound on the length of a message, we also introduce the notion of a bounded-length public-key encryption scheme. Such a scheme PKE supports the same interface as that of an ordinary (unbounded) scheme, but only allows messages of length bounded by PKE.MaxLen(PK).</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">2.1.3 Stream processing</h4>

    <p class="text-gray-300">Given that messages may be arbitrarily long, a highly desirable property of any public-key encryption scheme should be that both the encryption and decryption algorithms can be efficiently implemented as filters. That is, the message may be presented to the encryption algorithm as an input stream, and the ciphertext should be written to an output stream. The algorithm should never have to rewind these streams, and should be able to process these streams using a small, bounded amount of internal storage, independent of the length of these streams. Similarly, the decryption algorithm should be given access to an input stream representing the ciphertext, and the message should be written to an output stream.</p>

    <p class="text-gray-300">All of the schemes proposed here are amenable to stream processing, with the sole exception of EPOC-2.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">2.1.4 The use of labels</h4>

    <p class="text-gray-300">A label is a byte string that is effectively bound to the ciphertext in a non-malleable way. It may contain data that is implicit from context and need not be encrypted, but that should nevertheless be bound to the ciphertext. We view a label to be a byte string that is meaningful to the application using the encryption scheme, and that is independent of the implementation of the encryption scheme.</p>

    <p class="text-gray-300">For example, there are key exchange protocols in which one party, say <span class="math">A</span>, encrypts a session key <span class="math">K</span> under the public key of the other party, say <span class="math">B</span>. In order for the protocol to be secure, party <span class="math">A</span>’s identity (or public key or certificate) must be non-malleably bound to the ciphertext. One way to do this is simply to append this identity to the message. However, this creates an unnecessarily large ciphertext, since <span class="math">A</span>’s identity is typically already known to <span class="math">B</span> in the context of such a protocol. A good implementation of the labeling mechanism achieves the same effect, without increasing the size of the ciphertext.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Labels may also be of arbitrary and variable length, but we do not impose the restriction that the encryption and decryption algorithms should be able to process labels as streams.</p>

    <p class="text-gray-300">Both the ECIES and RSA-OAEP submissions include the notion of a label (where it is called an encoding parameter), although no indication was given as to the role or function of a label. Nevertheless, it seems to be a potentially useful feature, and so we include it here.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">2.1.5 Ciphertext format</h4>

    <p class="text-gray-300">The schemes proposed in this document describe precisely the format of a ciphertext. This is desirable for several reasons. First, it facilitates the inter-operability of different implementations of the same scheme. Second, it allows higher-level protocols to use public-key encryption as a “black box” in a way that is independent of the particular scheme. Third, it is necessary to even discuss the notion of security in a meaningful way.</p>

    <p class="text-gray-300">It is highly recommended that a general-purpose library offering public-key encryption implement the abstract interface in a way suitable for its particular programming environment, and that the ciphertexts conform to the prescribed format. Standardizing the abstract interface and the ciphertext format is meant to facilitate this type of software development.</p>

    <p class="text-gray-300">However, these specifications in no way dictate that such formatting must be preserved in a system using an encryption scheme, or that an implementation of the abstract interface must explicitly appear anywhere in the system. For example, in transporting a ciphertext over a network, it may be chopped up, and reformatted in an arbitrary way. Some transformations may be generic, i.e., independent of the encryption scheme, while others may be applicable only to a specific scheme. Indeed, it is not even necessary that a particular system using a scheme standardized here actually outputs (resp., inputs) ciphertexts in the prescribed format upon encryption (resp., decryption): the encryption and decryption algorithms may behave as if they performed such transformations on the ciphertext, even though the ciphertext may never really be represented in the prescribed format. In such a system, the prescribed format of the ciphertext plays a purely conceptual role in reasoning about the security of the system, even though it plays no direct role in the implementation of the system.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">2.1.6 Scheme-specific encryption options</h4>

    <p class="text-gray-300">Some schemes allow certain types of scheme-specific options to be passed to the encryption algorithm, which is why we have allowed for an extra argument options in our abstract interface.</p>

    <p class="text-gray-300">Allowing scheme-specific options in an abstract interface is clearly not such a good idea, as this runs counter to the very notion of an abstract interface. Also, since such options are scheme specific, their use will almost certainly atrophy over time, especially if more applications take advantage of the benefits provided by an abstract encryption interface.</p>

    <p class="text-gray-300">Although we strongly discourage the use of such options, we nevertheless allow them in our formal model for the sake of allowing us to cast some existing schemes into the model.</p>

    <p class="text-gray-300">The only place where we will actually use encryption options is in discussing encryption schemes based on elliptic curves: some of these scheme allows the encryptor to dynamically choose, from one of several formats, how it wants to format a point on the curve.</p>

    <p class="text-gray-300">For the sake of some notion of completeness or symmetry, one could also allow scheme-specific decryption options, but since we do not need such a notion, we do not attempt to formalize it.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.1.7 Algorithm failure</p>

    <p class="text-gray-300">Throughout this document, algorithms will always compute a function on their inputs, except that instead of returning a value, they may fail. By convention, if an algorithm fails, then unless otherwise specified, an algorithm that invokes that algorithm as a sub-routine also fails. Thus, failing is analogous to “throwing an exception” in many programming languages.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">2.1.8 Bits vs. Bytes</h4>

    <p class="text-gray-300">Our abstract interface treats messages and labels as strings of bytes (a.k.a., octets), rather than strings of bits.</p>

    <p class="text-gray-300">We argue against allowing bit strings, for the following reasons.</p>

    <p class="text-gray-300">First, it seems unlikely that many, if indeed any, applications really work with data that is represented as bit strings, rather than byte strings.</p>

    <p class="text-gray-300">Second, even if an application does want to work with bit strings, it can be left to the application to encode these bit strings as byte strings. Anyway, an application may in general have to properly format its messages before encryption, for example, to hide any information that may be leaked just from the length of the message (see §2.2.2).</p>

    <p class="text-gray-300">Third, we note that existing standards, such as IEEE P1363a, are themselves inconsistent in this regard, and so it does not seem advisable to propagate this inconsistency here as well. Indeed, while some encryption schemes in IEEE P1363a (ECIES) allow for bit strings, others (RSA-OAEP and EPOC-2) are byte oriented.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.2 Notion of security</h3>

    <p class="text-gray-300">We next recall the definition of security against adaptive chosen ciphertext attack, adapted to deal with labels.</p>

    <p class="text-gray-300">We begin by describing the attack scenario.</p>

    <p class="text-gray-300">First, the key generation algorithm is run, generating the public key and private key for the cryptosystem. The adversary, of course, obtains the public key, but not the private key.</p>

    <p class="text-gray-300">Second, the adversary makes a series of arbitrary queries to a decryption oracle. Each query is a label/ciphertext pair <span class="math">(L,C)</span> that is decrypted by the decryption oracle, making use of the private key of the cryptosystem. The resulting decryption is given to the adversary; moreover, if the decryption algorithm fails, then this information is given to the adversary, and the attack continues. The adversary is free to construct these label/ciphertext pairs in an arbitrary way—it is certainly not required to compute them using the encryption algorithm.</p>

    <p class="text-gray-300">Third, the adversary prepares a label <span class="math">L^{<em>}</span> and two “target” messages <span class="math">M_{0},M_{1}</span> of equal length, and gives these to an encryption oracle. If the scheme supports any encryption options, the adversary also chooses these. The encryption oracle chooses <span class="math">b\\in\\{0,1\\}</span> at random, encrypts <span class="math">M_{b}</span> with label <span class="math">L^{</em>}</span>, and gives the resulting “target” ciphertext <span class="math">C^{*}</span> to the adversary.</p>

    <p class="text-gray-300">Fourth, the adversary continues to submit label/ciphertext pairs <span class="math">(L,C)</span> to the decryption oracle, subject only to the restriction that <span class="math">(L,C)\\neq(L^{<em>},C^{</em>})</span>.</p>

    <p class="text-gray-300">Just before the adversary terminates, it outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">That completes the description of the attack scenario.</p>

    <p class="text-gray-300">For a given adversary <span class="math">A</span>, and a given scheme PKE, we define the adversary’s guessing advantage</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\text{{Advantage}}_{PKE}(A)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\hat{b}=b]-1/2\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300"><span class="math">Advantage^{\\prime}_{PKE}(A)</span> is “acceptably” small for all adversaries <span class="math">A</span> that run in a “reasonable” amount of time.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">2.2.1 Alternative characterizations and implications</h4>

    <p class="text-gray-300">Note that in proving an encryption scheme secure, the definition we have given is usually the most convenient. However, in analyzing an encryption scheme in a larger context, a slightly different definition is usually more convenient. In this definition, the attack scenario proceeds just as before. However, instead of measuring the adversary’s guessing advantage, we measure its distinguishing advantage</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Advantage^{\\prime}_{PKE}(A)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\hat{b}=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b=1\\right]-\\Pr\\left[\\hat{b}=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b=0\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows directly from the definitions by a trivial calculation that for any adversary <span class="math">A</span>,</p>

    <p class="text-gray-300"><span class="math">Advantage^{\\prime}_{PKE}(A)=2\\cdot Advantage_{PKE}(A).</span></p>

    <p class="text-gray-300">Equivalently, one can view <span class="math">Advantage^{\\prime}_{PKE}(A)</span> as measuring how differently an adversary behaves in two different attack games: in one game, <span class="math">M_{0}</span> is always encrypted, and in the other, <span class="math">M_{1}</span> is always encrypted.</p>

    <p class="text-gray-300">In analyzing an encryption scheme in a larger context, one usually substitutes an encryption of a secret message by an encryption of a garbage message (all zeros, or random) of the same length, and then analyzes how the adversary behaves. Many secret messages may be replaced by garbage strings, and the distinguishing advantage simply sums (although for some schemes, one can exhibit an even tighter security reduction). A small distinguishing advantage implies that the adversary will not behave significantly differently when this substitution is made. See <em>[x1]</em> for more details.</p>

    <p class="text-gray-300">This definition, in slightly different form, was first proposed by Rackoff and Simon <em>[x20]</em>. It is generally agreed in the cryptographic research community that this is the “right” security property for a general-purpose public-key encryption scheme. This notion of security implies other useful properties, like non-malleability. See <em>[x10, x11, x3]</em> for more on notions of security for public-key encryption schemes.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">2.2.2 Hiding the message length</h4>

    <p class="text-gray-300">Note that in the attack game, the adversary is required to submit two target messages of equal length to the encryption oracle. This restriction on the adversary reflects the fact that we cannot expect to hide the length of an encrypted message from the adversary—for many cryptosystems, this will be evident from the length of the ciphertext. It is in general up to the application using the cryptosystem to ensure that the length of a message does not reveal sensitive information.</p>

    <p class="text-gray-300">For bounded-length public-key encryption schemes (see §2.1.2) the notion of security is the same as for the ordinary, unbounded case, except that the adversary is not required to submit target messages of equal length to the encryption oracle. This reflects the fact that such schemes in fact do hide the length of an encrypted message from the adversary.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">2.2.3 Failing streams</h4>

    <p class="text-gray-300">There is a subtle interaction between failing, as discussed in §2.1.7 and the notion of a stream, discussed in §2.1.3. An application reading the output stream of the decryption algorithm should take care not to leak any information about the message it has read from that stream, until the</p>

    <p class="text-gray-300">decryption process has finished without failing. If it does not do this, the application could potentially forfeit the security guarantees of the scheme.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.2.4 Security parameters and asymptotic security</h4>

    <p class="text-gray-300">Note that none of these definitions make explicit mention of a security parameter. Our point of view is concrete—not asymptotic. We assume that a scheme specifies a particular security parameter (or set of parameters). If one wants to translate these definitions into ones compatible with the “asymptotic complexity” point of view, then one can consider families of algorithms indexed by a parameter <span class="math">\\lambda=1,2,3,\\ldots</span> that run in time bounded by a polynomial in <span class="math">\\lambda</span>. Both the scheme and the adversary are viewed as families of algorithms. One can consider either uniform or non-uniform families of algorithms. Security means that the adversary’s advantage is “negligible” in <span class="math">\\lambda</span>, meaning that it goes to zero faster than the inverse of any polynomial in <span class="math">\\lambda</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">2.3 Benign malleability: a slightly weaker notion of security</h3>

    <p class="text-gray-300">The definition of security given in §2.2 is sometimes viewed as being unnecessarily strong. For example, suppose we take an encryption scheme PKE that satisfies the definition in §2.2, and modify it as follows, obtaining a new encryption scheme PKE^{′}: the scheme PKE^{′} is the same as PKE, except that it appends a random byte to the ciphertext upon encryption, and ignores this extra byte upon decryption. Technically speaking, PKE^{′} does not satisfy the definition in §2.2, yet this seems counter-intuitive. Indeed, although PKE^{′} is technically “malleable,” it is only malleable in a “benign” sort of way: one can create alternative encryptions of the same message, and these alternative encryptions are all clearly recognizable as such.</p>

    <p class="text-gray-300">We present here a formal notion of security that precisely captures the intuitive notion of “benign malleability.”</p>

    <p class="text-gray-300">For a particular encryption scheme PKE and any public-key/secret-key pair (PK, SK), we call a binary relation <span class="math">\\equiv_{PK}</span> on label/ciphertext pairs a compatible relation if for any and two label/ciphertext pairs <span class="math">(L,C)</span> and <span class="math">(L^{\\prime},C^{\\prime})</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(C,L)\\equiv_{PK}(C^{\\prime},L^{\\prime})</span> then <span class="math">L=L^{\\prime}</span>,</li>

      <li>if <span class="math">(C,L)\\equiv_{PK}(C^{\\prime},L^{\\prime})</span> then PKE.Decrypt(SK, <span class="math">L,C</span>) = PKE.Decrypt(SK, <span class="math">L^{\\prime},C^{\\prime}</span>), and</li>

      <li>it can be determined if <span class="math">(C,L)\\equiv_{PK}(C^{\\prime},L^{\\prime})</span> using an efficient algorithm that takes inputs PK, <span class="math">L,C,L^{\\prime},C^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Clearly, any compatible relation is an equivalence relation.</p>

    <p class="text-gray-300">We say that a public-key encryption scheme PKE is benignly malleable if there exists a compatible relation for PKE as above, and if it satisfies the definition of security given in §2.2, but with the following modification in the attack game: when the adversary submits a label/ciphertext pair <span class="math">(L,C)</span> to the decryption oracle subsequent to the invocation of the encryption oracle, then instead of requiring that <span class="math">(L,C)\\neq(L^{<em>},C^{</em>})</span>, we only require that <span class="math">(L,C)\\not\\equiv_{PK}(L^{<em>},C^{</em>})</span>.</p>

    <p class="text-gray-300">This definition of security is essentially just as useful as the definition in §2.2 for all applications of public-key encryption that we know of.</p>

    <h2 id="sec-31" class="text-2xl font-bold">3 Key encapsulation</h2>

    <p class="text-gray-300">In designing an efficient public-key encryption scheme, a useful approach is to design a “hybrid” scheme, where one uses public key cryptography to encrypt a key that can then be used to encrypt</p>

    <p class="text-gray-300">the actual payload using symmetric key cryptography.</p>

    <p class="text-gray-300">We will build a hybrid encryption scheme from two lower-level “building blocks.” The first is a method for using public key cryptography to “encapsulate” a symmetric key. We call such a scheme a key encapsulation mechanism. The second is a method to properly encrypt the message using symmetric-key cryptographic techniques applied to the the symmetric key obtained from the key encapsulation mechanism. We call such a scheme a data encapsulation method.</p>

    <p class="text-gray-300">In this section, we discuss key encapsulation mechanisms. Data encapsulation mechanisms are discussed in §4, and the construction of hybrid encryption schemes built out of key and data encapsulation mechanisms is discussed in §5.</p>

    <p class="text-gray-300">Briefly, a key encapsulation mechanism works just like a public-key encryption scheme, except that the encryption algorithm takes no input other than the recipient’s public key. Instead, the encryption algorithm generates a pair <span class="math">(K,C_{0})</span>, where <span class="math">K</span> is a bit string of some specified length, and <span class="math">C_{0}</span> is an encryption of <span class="math">K</span>, that is, the decryption algorithm applied to <span class="math">C_{0}</span> yields <span class="math">K</span>.</p>

    <p class="text-gray-300">One can always use a (possibly bounded-length) public-key encryption scheme for this purpose, generating a random bit string, and then encrypting it under the recipient’s public key. However, as we shall see, one can construct a key encapsulation scheme in other, more efficient, ways as well.</p>

    <p class="text-gray-300">Now the details.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.1 Abstract interface</h3>

    <p class="text-gray-300">A key encapsulation mechanism KEM consists of three algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A key generation algorithm KEM.KeyGen(), that outputs a public key/secret key pair (PK, SK). The structure of PK and SK depend on the particular scheme.</li>

      <li>An encryption algorithm KEM.Encrypt(PK, options) that takes as input a public key PK, along with an optional options argument, and outputs a key/ciphertext pair <span class="math">(K,C_{0})</span>. The role of options is analogous to that for public-key encryption (see §2.1.6).</li>

      <li>A decryption algorithm KEM.Decrypt(SK, <span class="math">C_{0}</span>) that takes as input a secret key SK and a ciphertext <span class="math">C_{0}</span>, and outputs a key <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">A key encapsulation mechanism also specifies a positive integer KEM.OutputKeyLen — the length of the key output by KEM.Encrypt and KEM.Decrypt.</p>

    <p class="text-gray-300">Any key encapsulation mechanism should satisfy a soundness property analogous to the soundness property of a public-key encryption scheme, as described in §2.1.1.</p>

    <p class="text-gray-300">Additionally, we need the following property. The set of all possible outputs of the encryption algorithm should be a subset of some an easy-to-recognize, prefix-free language. The prefix-freeness property is needed so that we can parse byte strings from left to right, and efficiently “strip off” a ciphertext. Note that if all ciphertexts have the same length, then the prefix-freeness property is trivially satisfied.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">3.2 Notion of security</h3>

    <p class="text-gray-300">We next define security against adaptive chosen ciphertext attack for a key encapsulation mechanism.</p>

    <p class="text-gray-300">We begin by describing the attack scenario.</p>

    <p class="text-gray-300">First, the key generation algorithm is run, generating the public key and private key for the cryptosystem. The adversary, of course, obtains the public key, but not the private key.</p>

    <p class="text-gray-300">Second, the adversary makes a series of arbitrary queries to a <em>decryption oracle</em>. Each query is a ciphertext <span class="math">C_{0}</span> that is decrypted by the decryption oracle, making use of the private key of the cryptosystem. The resulting decryption is given to the adversary; moreover, if the decryption algorithm fails, then this information is given to the adversary, and the attack continues.</p>

    <p class="text-gray-300">Third, the adversary invokes an <em>encryption oracle</em>, supplying an encryption option, if the scheme supports them. The encryption oracle does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the encryption algorithm, generating a pair <span class="math">(K^{<em>},C_{0}^{</em>})</span>.</li>

      <li>Generate a random string <span class="math">\\tilde{K}</span> of length <em>KEM.OutputKeyLen</em>.</li>

      <li>Choose <span class="math">b\\in\\{0,1\\}</span> at random.</li>

      <li>If <span class="math">b=0</span>, output <span class="math">(K^{<em>},C_{0}^{</em>})</span>; otherwise output <span class="math">(\\tilde{K},C_{0}^{*})</span>.</li>

    </ol>

    <p class="text-gray-300">Fourth, the adversary continues to submit ciphertexts <span class="math">C_{0}</span> to the decryption oracle, subject only to the restriction that <span class="math">C_{0}\\neq C_{0}^{*}</span>.</p>

    <p class="text-gray-300">Just before the adversary terminates, it outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">That completes the description of the attack scenario.</p>

    <p class="text-gray-300">For an adversary <span class="math">A</span>, the quantities <span class="math">Advantage_{KEM}(A)</span> and <span class="math">Advantage^{\\prime}_{KEM}(A)</span> are defined in exactly the same way (in terms of <span class="math">b</span> and <span class="math">\\hat{b}</span>) as <span class="math">Advantage_{PKE}(A)</span> and <span class="math">Advantage^{\\prime}_{PKE}(A)</span> for a public-key encryption scheme (see §2). Security means that <span class="math">Advantage_{KEM}(A)</span> is “acceptably” small for all adversaries <span class="math">A</span> that run in a “reasonable” amount of time.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">3.3 Further remarks</h3>

    <p class="text-gray-300">One can also define the notion of <em>benign malleability</em> for key encapsulation mechanisms, just as we did for public-key encryption schemes (§2.3).</p>

    <p class="text-gray-300">Although one could do so, we have chosen not to incorporate the notion of a <em>label</em> in the definition of a key encapsulation mechanism. The reason is that the only application we have of a key encapsulation mechanism in this paper is in the construction of a hybrid encryption scheme, and it is easier to implement labels in the data encapsulation mechanism than in the key encapsulation mechanism itself.</p>

    <h2 id="sec-35" class="text-2xl font-bold">4 Data encapsulation</h2>

    <p class="text-gray-300">A <em>data encapsulation mechanism</em> provides a “digital envelope” that protects the secrecy and integrity of data using symmetric-key cryptographic techniques; it also may bind the data to a public label. The definition of security for this primitive that we present here is appropriate for building hybrid public-key encryption schemes, but may not be appropriate for other applications.</p>

    <p class="text-gray-300">In this section we only describe the abstract interface and security properties that a data encapsulation mechanism should satisfy. Later, in §10, we present a fairly traditional and provably secure implementation of a data encapsulation mechanism. There may, however, be other interesting ways to implement this primitive.</p>

    <p class="text-gray-300">4.1 Abstract interface</p>

    <p class="text-gray-300">A data encapsulation mechanism DEM specifies a key length DEM.KeyLen, along with encryption and decryption algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The encryption algorithm DEM.Encrypt(<span class="math">K,L,M</span>) takes as input a key <span class="math">K</span>, a label <span class="math">L</span>, and and a message <span class="math">M</span>. It outputs a ciphertext <span class="math">C_{1}</span>. Here, <span class="math">K</span>, <span class="math">L</span>, <span class="math">M</span>, and <span class="math">C_{1}</span> are byte strings, and <span class="math">L</span> and <span class="math">M</span> may have arbitrary length, and <span class="math">K</span> is of length DEM.KeyLen.</li>

      <li>The decryption algorithm DEM.Decrypt(<span class="math">K,L,C_{1}</span>) takes as input a key <span class="math">K</span>, a label <span class="math">L</span>, and a ciphertext <span class="math">C_{1}</span>. It outputs a message <span class="math">M</span>.</li>

    </ul>

    <p class="text-gray-300">We assume that the encryption and decryption algorithms are deterministic, and that the scheme is (perfectly) sound, in the sense that for all keys <span class="math">K</span>, all labels <span class="math">L</span>, and all messages <span class="math">M</span>,</p>

    <p class="text-gray-300"><span class="math">\\text{{DEM.Decrypt}}(K,L,\\text{{DEM.Encrypt}}(K,L,M))=M.</span></p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.2 Notion of security</h3>

    <p class="text-gray-300">We shall need the following security property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the following attack scenario. The adversary generates two messages (byte strings) <span class="math">M_{0},M_{1}</span> of equal length, and a label <span class="math">L^{<em>}</span>. A random key <span class="math">K</span> is generated. A random bit <span class="math">b</span> is chosen, and <span class="math">M_{b}</span> is encrypted under key <span class="math">K</span>. The resulting ciphertext <span class="math">C_{1}^{</em>}</span> is given to the adversary. The adversary then submits a series of requests to a decryption oracle: each such request is a label/ciphertext pair <span class="math">(L,C_{1})\\neq(L^{<em>},C_{1}^{</em>})</span>, and the decryption oracle responds with the decryption of <span class="math">C_{1}</span> with label <span class="math">L</span> under key <span class="math">K</span>. The adversary makes a guess <span class="math">\\hat{b}</span> at <span class="math">b</span>. The adversary’s advantage is defined as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[\\hat{b}=b]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We denote this advantage by </span>\\text{{Advantage}}_{\\text{{DEM}}}(A)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Security means that this advantage is acceptably small.</p>

    <h2 id="sec-37" class="text-2xl font-bold">5 Hybrid encryption</h2>

    <p class="text-gray-300">We now propose a canonical way to compose a secure key encapsulation mechanism and a secure data encapsulation mechanism so as to obtain a secure public-key encryption scheme.</p>

    <p class="text-gray-300">Let KEM be a key encapsulation mechanism and let DEM be a data encapsulation mechanism. To compose these two mechanisms, we require that they are compatible, in the sense that KEM.OutputKeyLen = DEM.KeyLen. So let us assume that KEM and DEM are compatible in this sense.</p>

    <p class="text-gray-300">We now define a hybrid public-key encryption scheme H-PKE = H-PKE_{KEM,DEM} in terms of KEM and DEM as follows.</p>

    <p class="text-gray-300">The key generation algorithm, public key, and secret key for H-PKE are the same as that of KEM.</p>

    <p class="text-gray-300">Let (PK, SK) be a public key/secret key pair.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To encrypt a message <span class="math">M</span> with label <span class="math">L</span> and any encryption options under PK, the encryption algorithm for H-PKE does the following. First, it runs the encryption algorithm for KEM with the given options, generating a ciphertext <span class="math">C_{0}</span> and a key <span class="math">K</span>. Second, it encrypts <span class="math">M</span> with label <span class="math">L</span> under <span class="math">K</span> using the encryption algorithm for DEM. Third, it outputs the ciphertext $C=C_{0}\\mathbin{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}C_{1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To decrypt a ciphertext <span class="math">C</span> with label <span class="math">L</span> under SK, the decryption algorithm for H-PKE does the following. First, it parses <span class="math">C</span> as $C=C_{0}\\mathbin{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}C_{1}<span class="math">, using the prefix-freeness property of the ciphertexts associated with KEM. Second, it decrypts </span>C_{0}$ under SK using the decryption algorithm of KEM</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">to obtain a key <span class="math">K</span>. Third, it decrypts <span class="math">C_{1}</span> with label <span class="math">L</span> under <span class="math">K</span> using the decryption algorithm of DEM, and outputs the resulting message <span class="math">M</span>. Any of these steps may fail, in which case the decryption algorithm for H-PKE also fails.</p>

    <p class="text-gray-300">It is an easy matter to prove that for any adversary <span class="math">A</span>,</p>

    <p class="text-gray-300"><span class="math">\\text{{Advantage}}_{H\\text{-}\\text{{PKE}}}(A)</span> <span class="math">\\leq</span> <span class="math">\\text{{Advantage}}_{KEM}^{\\prime}(A_{1})\\ +</span> <span class="math">\\text{{Advantage}}_{DEM}(A_{2}),</span></p>

    <p class="text-gray-300">where <span class="math">A_{1}</span> and <span class="math">A_{2}</span> are adversaries that run in time roughly the same as that of <span class="math">A</span>. Actually, this estimate assumes that KEM is perfectly sound; however, if the soundness condition may be violated with some small probability, that probability must be added into this estimate as well.</p>

    <p class="text-gray-300">It follows that if KEM and DEM are secure, then so is H-PKE.</p>

    <p class="text-gray-300">For a detailed proof of a slight variant of this security claim, the reader is referred to <em>[x10]</em>. The situation in that paper is slightly different from the one here, because the notion corresponding to a DEM in that paper does not incorporate the use of a label. Nevertheless, the security proof in that paper can be applied almost verbatim to the situation here.</p>

    <h2 id="sec-38" class="text-2xl font-bold">6 Byte string/integer conversions</h2>

    <p class="text-gray-300">We simply adopt the functions OS2IP and I2OSP from the IEEE P1363 standard for conversions between byte (a.k.a., octet) strings and integers.</p>

    <p class="text-gray-300">The function OS2IP(<span class="math">x</span>) takes as input a byte string, and outputs an integer. If <span class="math">x=x_{l-1}\\parallel x_{l-2}\\parallel\\cdots\\parallel x_{0}</span>, where each <span class="math">x_{i}</span> is a byte, then</p>

    <p class="text-gray-300"><span class="math">\\text{{OS2IP}}(x)=\\sum_{i=0}^{l-1}x_{i}\\cdot 256^{i}.</span></p>

    <p class="text-gray-300">In this formula, each byte <span class="math">x_{i}</span> is interpreted as a base-256 digit. Note that the left-most byte represents the most-significant digit.</p>

    <p class="text-gray-300">The function I2OSP is essentially the inverse of OS2IP. The function I2OSP(<span class="math">m,l</span>) takes as input two non-negative integers <span class="math">m</span> and <span class="math">l</span>, and outputs the unique byte string <span class="math">x</span> of length <span class="math">l</span> such that <span class="math">\\text{{OS2IP}}(x)=m</span>, if such an <span class="math">x</span> exists. Otherwise, the function fails. Note that the function fails if and only if <span class="math">m\\geq 256^{l}</span>.</p>

    <h2 id="sec-39" class="text-2xl font-bold">7 Pseudo-random byte generator</h2>

    <p class="text-gray-300">A pseudo-random byte generator PRBG is a scheme with the following interface. It defines fixed seed length PRBG.SeedLen and a function PRBG.eval<span class="math">(s,l)</span> that takes as input a byte string <span class="math">s</span> of length PRBG.SeedLen and an integer <span class="math">l\\geq 0</span>, and produces as output a byte string of length <span class="math">l</span>.</p>

    <p class="text-gray-300">The assumption we make is that for a random seed <span class="math">s</span>, the output is computationally indistinguishable from a random byte string of the same length.</p>

    <p class="text-gray-300">One recommended way to implement a PRBG is to simply use a block cipher in counter mode.</p>

    <p class="text-gray-300">An alternative is to use a block cipher in counter mode, but to output the XOR of consecutive pairs of block cipher outputs. This approach yields a higher level of security when <span class="math">l</span> is very large (see <em>[x22]</em>).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">8 Symmetric key encryption</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">8.1 Abstract interface</h3>

    <p class="text-gray-300">A symmetric key encryption scheme SKE specifies a key length SKE.KeyLen, along with encryption and decryption algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The encryption algorithm SKE.Encrypt<span class="math">(k,M)</span> takes as input a key (byte string) <span class="math">k</span> of length SKE.KeyLen and a message <span class="math">M</span>. It outputs a ciphertext <span class="math">c</span>.</li>

      <li>The decryption algorithm SKE.Decrypt<span class="math">(k,c)</span> takes as input a key <span class="math">k</span> of length SKE.KeyLen and a ciphertext <span class="math">c</span>. It outputs a message <span class="math">M</span>.</li>

    </ul>

    <p class="text-gray-300">We assume that the encryption and decryption algorithms are deterministic, and that the scheme is (perfectly) sound, in the sense that for all keys <span class="math">K</span> and all messages <span class="math">M</span>,</p>

    <p class="text-gray-300"><span class="math">SKE.Decrypt(K,SKE.Encrypt(K,M))=M.</span></p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">8.2 Notion of security</h3>

    <p class="text-gray-300">We shall need the following security property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the following attack scenario. The adversary generates two messages (byte strings) <span class="math">M_{0},M_{1}</span> of equal length. A random key <span class="math">k</span> is generated. A random bit <span class="math">b</span> is chosen, and <span class="math">M_{b}</span> is encrypted under key <span class="math">k</span>. The resulting ciphertext <span class="math">c</span> is given to the adversary. The adversary makes a guess <span class="math">\\hat{b}</span> at <span class="math">b</span>. The adversary’s advantage is defined as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[\\hat{b}=b]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For an adversary <span class="math">A</span> that chooses <span class="math">M_{0},M_{1}</span> of length bounded by <span class="math">l</span>, we denote this advantage by Advantage_{SKE}(<span class="math">A,l</span>).</p>

    <p class="text-gray-300">Security means that the advantage is acceptably small.</p>

    <p class="text-gray-300">Note that one can build a secure symmetric key encryption scheme by using a pseudo-random byte generator (see §7) to generate a “one time pad,” which is then XORed with the message.</p>

    <p class="text-gray-300">Also, the IEEE P1363a standard specifies other methods based on block ciphers that could be used as well. The ISO working group should perhaps consider other methods as well.</p>

    <h2 id="sec-42" class="text-2xl font-bold">9 One-time MAC</h2>

    <p class="text-gray-300">A one-time message authentication code MAC is a scheme that defines two quantities MAC.KeyLen and MAC.TagLen, along with a function MAC.eval(<span class="math">k^{\\prime},T</span>) that takes a key <span class="math">k^{\\prime}</span> of length MAC.KeyLen and an arbitrary byte string <span class="math">T</span> as input, and computes as output a byte string tag of length MAC.TagLen. We shall need the following security property.</p>

    <p class="text-gray-300">Consider the following attack scenario. A byte string <span class="math">T^{<em>}</span> is chosen by the adversary. A key <span class="math">k^{\\prime}</span> is chosen at random. The MAC is evaluated at <span class="math">T^{</em>}</span> with key <span class="math">k^{\\prime}</span>, and the output tag^{∗} is given to the adversary. The adversary outputs a list of pairs (<span class="math">T,tag</span>), where <span class="math">T</span> is a byte string with <span class="math">T\\neq T^{<em>}</span> (and not necessarily of the same length as <span class="math">T^{</em>}</span>), and tag is a byte string of length MAC.TagLen. The adversary’s advantage is defined to be the probability that for one such pair (<span class="math">T,tag</span>), the MAC on input <span class="math">T</span> with key <span class="math">k^{\\prime}</span> is equal to tag.</p>

    <p class="text-gray-300">For an adversary <span class="math">A</span> that chooses <span class="math">T^{*}</span> of length bounded by <span class="math">l_{1}</span> and at most <span class="math">l_{3}</span> pairs (<span class="math">T,tag</span>) with <span class="math">T</span> of length bounded by <span class="math">l_{2}</span>, we denote this advantage by Advantage_{MAC}(<span class="math">A,l_{1},l_{2},l_{3}</span>).</p>

    <p class="text-gray-300">Security means that this advantage should be acceptably small.</p>

    <p class="text-gray-300">There are a number of acceptable one-time MAC schemes.</p>

    <p class="text-gray-300">Any of the schemes specified by the ISO MAC standard should be acceptable. IEEE P1363a standard also specifies a MAC that should be acceptable.</p>

    <h2 id="sec-43" class="text-2xl font-bold">10 DEM1</h2>

    <p class="text-gray-300">Given a symmetric encryption scheme SKE (see §8), and a one-time message authentication code MAC (see §9), here is how one can build a data encapsulation mechanism DEM1 = DEM1_{SKE,MAC}. We require that DEM1.KeyLen = SKE.KeyLen + MAC.KeyLen.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To encrypt a message <span class="math">M</span> with label <span class="math">L</span> under a key <span class="math">K</span>, we parse <span class="math">K</span> as $K = k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k'<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{SKE.KeyLen}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{MAC.KeyLen}<span class="math">. We encrypt </span>M<span class="math"> using SKE under key </span>k<span class="math">, obtaining its encryption </span>c<span class="math">. Then we apply MAC to the byte string string </span>T = c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I2OSP(8 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 8)<span class="math"> using </span>k'<span class="math">, obtaining tag. The entire ciphertext is </span>C_1 = c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{tag}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To decrypt a ciphertext <span class="math">C_1</span> with respect to a given label <span class="math">L</span>, we first parse <span class="math">C_1</span> as $c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{tag}<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{tag}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{MAC.TagLen}<span class="math">. This step may fail, of course, if </span>C_1<span class="math"> is too short. We then parse </span>K<span class="math"> as </span>K = k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k'<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{SKE.KeyLen}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{MAC.KeyLen}<span class="math">. Then we apply the MAC with key </span>k'<span class="math"> to the byte string string </span>T = c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I2OSP(8 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 8)<span class="math">, and test whether the resulting tag equals the given tag. If not, we report failure. Otherwise, decrypt </span>c<span class="math"> under </span>k<span class="math">, obtaining </span>M<span class="math">. It is possible that SKE.Decrypt fails. Finally, we output </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is straightforward to show that if the underlying components are secure, then the resulting data encapsulation mechanism DEM1 is secure. Moreover, the reduction is quite "tight" quantitatively.</p>

    <p class="text-gray-300">Specifically, we have the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Advantage}_{\\text{DEM1}}(A) \\leq \\text{Advantage}_{\\text{SKE}}(A_1, l_1) + \\\\ \\text{Advantage}_{\\text{MAC}}(A_2, l_2, l_3, q_D). \\end{array}</span></div>

    <p class="text-gray-300">Here,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A_1, A_2</span> are adversaries that run in about the same time as <span class="math">A</span>,</li>

      <li><span class="math">l_1</span> is a bound on the length of the target message,</li>

      <li><span class="math">l_2</span> is a bound on the length of the string <span class="math">T^*</span> corresponding to the target ciphertext,</li>

      <li><span class="math">l_3</span> is a bound on the length of the strings <span class="math">T</span> corresponding to ciphertexts submitted to the decryption oracle,</li>

      <li><span class="math">q_D</span> is a bound on the number of decryption oracle queries,</li>

      <li><span class="math">\\text{Advantage}_{\\text{SKE}}</span> is as defined in §8, and</li>

      <li><span class="math">\\text{Advantage}_{\\text{MAC}}</span> is as defined in §9.</li>

    </ul>

    <p class="text-gray-300">The proof of this is an easy exercise. However, the reader is referred to [CS01], where a detailed proof of a slight variant of this security claim is provided. Note, however, that the situation in that paper is slightly different than the one here, since that paper does not deal at all with the notion of a label. Nevertheless, the proof presented there can also be applied here, with only very minor changes.</p>

    <p class="text-gray-300">19</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that we pass an encoding of the length of <span class="math">L</span> to MAC. This is essential to ensure non-malleability (see §15.6.3). The particular mechanism used to encode the length was chosen so as to be compatible with the IEEE P1363a version of ECIES. In particular, we multiply $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by 8 so as to encode the length of </span>L$ in bits, rather than bytes, since the IEEE P1363a version of ECIES allows (in theory, but not really in practice) messages and labels that are bit strings rather than byte strings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We continue here the discussion started in §2.2.3. In our hybrid construction, there is a single tag that is checked at the end of the ciphertext stream. This is the simplest approach, and one that is already seen in practice (as in ECIES). In the ACE-Encrypt submission, there was actually a tag value inserted every kilobyte or so in the ciphertext stream. The reason for this was so that the decryption algorithm would fail as soon as it detected a “bad” ciphertext stream. This would greatly enhance the ability of an application to process the output stream of the decryption algorithm in a stream-like fashion — it would not have to wait until the end of the output stream to detect a “bad” stream. It would not be too difficult to specify such a scheme. This point should perhaps be discussed by the working group.</p>

    <h2 id="sec-44" class="text-2xl font-bold">11 Hash functions</h2>

    <p class="text-gray-300">We shall assume the availability of a cryptographic hash function. Let Hash denote the scheme. Then Hash.OutputLen denotes the length of the hash function output, and Hash.eval denotes the hash function itself, which maps arbitrary length byte strings to byte strings of length Hash.OutputLen.</p>

    <p class="text-gray-300">The invocation of Hash.eval may fail if the input length exceeds some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">In the security analysis, we shall make the following types of assumptions about Hash:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is collision resistant, i.e., it is hard to find two inputs <span class="math">x,y</span> with <span class="math">x\\neq y</span> such that Hash.eval<span class="math">(x)=</span> Hash.eval<span class="math">(y)</span>.</li>

      <li>It is second-preimage collision resistant, i.e., for a given set <span class="math">S</span> of byte strings together with a prescribed probability distribution on <span class="math">S</span>, if <span class="math">x\\in S</span> is chosen at random, then it is hard to find <span class="math">y\\in S</span> with <span class="math">x\\neq y</span> such that Hash.eval<span class="math">(x)=</span> Hash.eval<span class="math">(y)</span>. The set <span class="math">S</span> and the probability distribution depend on the application.</li>

      <li>It is a good entropy-smoothing hash function, i.e., for a given set <span class="math">S</span> of byte strings together with a prescribed probability distribution on <span class="math">S</span>, then if <span class="math">x\\in S</span> is chosen at random, the output Hash.eval<span class="math">(x)</span> is computationally indistinguishable from a random byte string of length Hash.OutputLen. Of course, for this assumption to be reasonable, it must be the case that the entropy of <span class="math">S</span> is sufficiently high.</li>

      <li>We might also choose to view it as a random oracle.</li>

    </ul>

    <p class="text-gray-300">Recommended choices for Hash are SHA-1 and RIPEMD-160.</p>

    <h2 id="sec-45" class="text-2xl font-bold">12 Key derivation functions</h2>

    <p class="text-gray-300">It is convenient to have a key derivation function KDF<span class="math">(x,l)</span> that takes as input a byte string <span class="math">x</span> and an integer <span class="math">l\\geq 0</span>, and outputs a byte string of length <span class="math">l</span>. The string <span class="math">x</span> is of arbitrary length.</p>

    <p class="text-gray-300">The invocation of KDF may fail if the input or output lengths exceed some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">In the security analysis, we will often model KDF as a random oracle.</p>

    <p class="text-gray-300">A specific security property that is sometimes desirable for a key derivation function is that it be a good entropy smoothing function. That is, the input <span class="math">x</span> is chosen at random from a distribution of byte strings with high entropy, then the output should be computationally indistinguishable from a random byte string of the same length.</p>

    <p class="text-gray-300">Sometimes the notion of a key derivation function is called a mask generating function (MGF); there seems to be no difference in meaning between the two terms.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">12.1 KDF1</h3>

    <p class="text-gray-300">This function is parameterized by a hash function Hash (see 11), and is defined as follows. On input <span class="math">(x,l)</span>, the output is the first <span class="math">l</span> bytes of</p>

    <p class="text-gray-300"><span class="math">\\text{\\emph{Hash.eval}(x\\parallel I2OSP(0,4))\\parallel\\cdots\\parallel Hash.eval(x\\parallel I2OSP(k-1,4))},</span></p>

    <p class="text-gray-300">where <span class="math">k=\\lceil l/\\text{\\emph{Hash.OutputLen}\\rceil}</span>.</p>

    <p class="text-gray-300">This function is the same as the function called MGF1 in IEEE P1363.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">12.2 KDF2</h3>

    <p class="text-gray-300">This function KDF2 is the same as KDF1, except that the counter runs from 1 to <span class="math">k</span>, rather than from 0 to <span class="math">k-1</span>.</p>

    <p class="text-gray-300">This function is the same as the function called KDF2 in IEEE P1363a, except that the latter allows for an output that is a bit string, rather than a byte string, and also allows for an extra key derivation parameter that we do not need here.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">12.3 Security critique of KDF1 and KDF2</h3>

    <p class="text-gray-300">Of course, if one chooses to model KDF1 (or KDF2) as a random oracle in a security analysis, one is free to do so. There is really not much of a rational basis to argue either for or against such a choice.</p>

    <p class="text-gray-300">However, we do not recommend the use of these functions in applications where one requires the entropy smoothing property discussed above. The only point in this document where this is significant is in the analysis of the variant of the ACE-Encrypt scheme discussed in §17, whose security analysis is not based on the random oracle heuristic.</p>

    <p class="text-gray-300">Our reasoning is as follows.</p>

    <p class="text-gray-300">If we were to believe that these were good entropy smoothing functions, this would suggest that the function <span class="math">F_{x}(y)</span> defined by</p>

    <p class="text-gray-300"><span class="math">F_{x}(y)=\\text{\\emph{Hash.eval}(x\\parallel y)}</span></p>

    <p class="text-gray-300">should be a “good” pseudo-random function with key <span class="math">x</span> and input <span class="math">y</span>. However, standard hash functions, like SHA-1, are built using a particular block cipher <span class="math">P_{a}(b)</span> — with key <span class="math">a</span> and input block <span class="math">b</span> — chained in a standard way. Indeed, suppose that Hash is SHA-1 with initial chaining value IV and that <span class="math">x</span> is 512-bits long. So in this case, <span class="math">P_{a}(b)</span> is a block cipher with a 512-bit key size, and a 160-bit block size. Then</p>

    <p class="text-gray-300"><span class="math">F_{x}(y)=P_{y}(z)\\oplus z,\\text{ where, }z=P_{x}(\\text{\\emph{IV})\\oplus\\text{\\emph{IV}.}}</span></p>

    <p class="text-gray-300">w</p>

    <p class="text-gray-300">Assuming that <span class="math">P_{a}(b)</span> is a good block cipher, and that <span class="math">x</span> is suitably random, then the value <span class="math">z</span> above should be pseudo-random. Therefore, the security of <span class="math">F_{x}(y)</span> as a pseudo-random function is equivalent to the security of the function <span class="math">G_{z}(y)</span> defined by</p>

    <p class="text-gray-300"><span class="math">G_{z}(y)=P_{y}(z)\\oplus z</span></p>

    <p class="text-gray-300">as a pseudo-random function with key <span class="math">z</span> and input <span class="math">y</span>. Is <span class="math">G_{z}(y)</span> a good pseudo-random function? This is not clear. But certainly, this is a quite unorthodox construction that does not appear to be based on any well-worn or otherwise sound principles.</p>

    <p class="text-gray-300">Because of this perceived potential weakness, we propose two further key derivation functions, KDF3 and KDF4. Either of these can be used in a situation where a random oracle is required. However, these functions seem more reasonable in applications where the entropy smoothing property is required.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">12.4 KDF3</h3>

    <p class="text-gray-300">This function is parameterized by a hash function Hash and a padding amount <span class="math">\\textit{pamt}\\geq 4</span>, and is defined as follows. On input <span class="math">(x,l)</span>, the output is the first <span class="math">l</span> bytes of</p>

    <p class="text-gray-300"><span class="math">\\textit{Hash.eval}(I2OSP(0,\\textit{pamt})\\left\\lVert\\,x\\right\\rVert\\,\\cdots\\,\\left\\lVert\\,\\textit{Hash.eval}(I2OSP(k-1,\\textit{pamt})\\left\\lVert\\,x\\right)\\right.,</span></p>

    <p class="text-gray-300">where <span class="math">k=\\left\\lceil l/\\textit{Hash.OutputLen}\\right\\rceil</span>.</p>

    <p class="text-gray-300">Recommended choices for the hash function are SHA-1 or RIPEMD-160. Recommended choices for <span class="math">\\textit{pamt}</span> are either 4, or the block size of the underlying hash (64 in the case of SHA-1 or RIPEMD-160).</p>

    <p class="text-gray-300">Based upon the way standard hash functions like SHA-1 or RIPEMD-160 are constructed, it seems like a reasonable assumption is that they are good pseudo-random functions, where we view the text input as the key of the function, and we view the initial vector IV as the input to the function. Typical implementations of these hash functions often do not provide an interface that allows the programmer to choose the IV. However, we get the equivalent effect by setting <span class="math">\\textit{pamt}</span> to the block size of the underlying hash.</p>

    <p class="text-gray-300">By setting <span class="math">\\textit{pamt}</span> to the block size of the underlying hash function, we are able to give a reasonable justification for the security of KDF3. If we set <span class="math">\\textit{pamt}</span> to another value, such as 4, this justification is no longer valid. Nevertheless, setting <span class="math">\\textit{pamt}=4</span> does not seem like a completely unreasonable choice, and certainly the arguments we made above against KDF1 and KDF2 no longer apply.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">12.5 KDF4</h3>

    <p class="text-gray-300">This function is parameterized by a hash function Hash and a pseudo-random byte generator PRBG (see §7). It is required that <span class="math">\\textit{Hash.OutputLen}=\\textit{PRBG.SeedLen}</span>.</p>

    <p class="text-gray-300">On input <span class="math">(x,l)</span>, this function outputs</p>

    <p class="text-gray-300"><span class="math">\\textit{PRBG.eval}(\\textit{Hash.eval}(x),l).</span></p>

    <p class="text-gray-300">For the hash function, one can use a standard function like SHA-1 or RIPEMD-160. If PRBG.SeedLen is less than 20, then one can simply truncate the output of the hash function.</p>

    <p class="text-gray-300">This function will be a good entropy smoothing function, provided Hash is a good entropy smoothing function, and provided PRBG is secure as a pseudo-random byte generator.</p>

    <p class="text-gray-300">13 Abstract groups</p>

    <p class="text-gray-300">We describe a group as an abstract data type. As a matter of convention, we shall always use additive notation for a group. Also, group elements will be typeset in boldface, and <span class="math">\\mathbf{0}</span> denotes the identity element of the group.</p>

    <p class="text-gray-300">A fully specified group Group is a tuple <span class="math">(\\mathcal{H},\\mathcal{G},\\mathbf{g},\\mu,\\nu,\\mathcal{E},\\mathcal{D},\\mathcal{E}^{\\prime},\\mathcal{D}^{\\prime})</span>, where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{H}</span> is a finite abelian group in which all group computations are actually performed. Note that this group need not be cyclic.</li>

      <li><span class="math">\\mathcal{G}</span> is a cyclic subgroup of <span class="math">\\mathcal{H}</span>. This is where the real “action” will normally take place in a cryptographic scheme.</li>

      <li><span class="math">\\mathbf{g}</span> is a generator for <span class="math">\\mathcal{G}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mu</span> is the order (size) of <span class="math">\\mathcal{G}</span>, and <span class="math">\\nu</span> is the index of <span class="math">\\mathcal{G}</span> in <span class="math">\\mathcal{H}</span>, i.e., $\\nu=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\mu$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We shall require that <span class="math">\\mu</span> is prime. For some cryptographic schemes, we make the stronger requirement that <span class="math">\\gcd(\\mu,\\nu)=1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}(\\mathbf{a},\\textit{format})</span> is an “encoding” function that maps a group element <span class="math">\\mathbf{a}\\in\\mathcal{H}</span> to a byte string.</li>

    </ul>

    <p class="text-gray-300">The second argument format may be used to choose from one of several possible formats for the encoding of a group element.</p>

    <p class="text-gray-300">We do not strongly recommend the use of multiple encoding formats, but it is in some cases an already established practice which we need to properly model here.</p>

    <p class="text-gray-300">We require that the set of all outputs of <span class="math">\\mathcal{E}</span> is a subset of some easy-to-recognize, prefix-free language.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{D}(x)</span> is a function that fails if <span class="math">x</span> is not a proper encoding of an element of <span class="math">\\mathcal{H}</span>; otherwise, it returns the group element <span class="math">\\mathbf{a}\\in\\mathcal{H}</span> such that <span class="math">\\mathcal{E}(\\mathbf{a})=x</span>.</li>

    </ul>

    <p class="text-gray-300">If a group supports multiple encoding formats, we require that the format value used to encode a group element is evident from the encoding itself.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}^{\\prime}(\\mathbf{a})</span> is a “partial encoding” function that maps a group element <span class="math">\\mathbf{a}\\in\\mathcal{H}</span> to a byte string.</li>

    </ul>

    <p class="text-gray-300">We require that the set of all outputs of <span class="math">\\mathcal{E}^{\\prime}</span> is a subset of some easy-to-recognize, prefix-free language.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{D}^{\\prime}(x)</span> is a function that either fails if <span class="math">x</span> is not a proper partial encoding of an element of <span class="math">\\mathcal{H}</span>; otherwise, it returns the set containing all group elements <span class="math">\\mathbf{a}\\in\\mathcal{H}</span> such that <span class="math">\\mathcal{E}^{\\prime}(\\mathbf{a})=x</span>. We will assume that the size of this set is bounded by a small constant.</li>

    </ul>

    <p class="text-gray-300">All of the above algorithms should have efficient implementations. The function <span class="math">\\mathcal{D}^{\\prime}</span> will never be used by any of the schemes, but the existence of this function is necessary to analyze their security.</p>

    <p class="text-gray-300">We of course assume that arithmetic in <span class="math">\\mathcal{H}</span> can be carried out efficiently.</p>

    <p class="text-gray-300">We also assume that we can efficiently test if an element of <span class="math">\\mathcal{H}</span> lies in the subgroup <span class="math">\\mathcal{G}</span>. If all elements in <span class="math">\\mathcal{H}</span> of order <span class="math">\\mu</span> lie in <span class="math">\\mathcal{G}</span>, then we can test if <span class="math">\\mathbf{a}\\in\\mathcal{G}</span> by testing if <span class="math">\\mu\\cdot\\mathbf{a}=\\mathbf{0}</span>. This test is therefore applicable of <span class="math">\\mathcal{H}</span> is itself cyclic, or if <span class="math">\\gcd(\\mu,\\nu)=1</span>. For specific groups, there may be more efficient tests of subgroup membership.</p>

    <p class="text-gray-300">This abstraction is meant to be flexible enough to model two important classes of groups: subgroups of <span class="math">\\mathbf{Z}_{p}^{*}</span>, and subgroups of elliptic curves.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">13.1 Subgroups of <span class="math">\\mathbf{Z}_{p}^{*}</span></h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">p</span> be a prime, and consider the multiplicative group of units modulo <span class="math">p</span>, denoted <span class="math">\\mathbf{Z}_{p}^{<em>}</span>. Let <span class="math">\\mathcal{H}</span> denote this group. Let <span class="math">\\mathcal{G}</span> denote any prime-order subgroup of <span class="math">\\mathbf{Z}_{p}^{</em>}</span>. Set $\\mu=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\nu=(p-1)/\\mu<span class="math">. Because </span>\\mathcal{H}<span class="math"> is itself cyclic, it follows that </span>\\mathcal{G}<span class="math"> contains all elements of </span>\\mathcal{H}<span class="math"> whose order divides </span>\\mu<span class="math">, even if </span>\\gcd(\\mu,\\nu)\\neq 1<span class="math">. The encoding map </span>\\mathcal{E}<span class="math"> can be implemented using the function I2OSP, where all group elements are encoded as byte strings of length </span>\\lceil\\log_{256}p\\rceil<span class="math">. The map </span>\\mathcal{D}<span class="math"> can be implemented using OS2IP. The function </span>\\mathcal{E}^{\\prime}<span class="math"> is the same as </span>\\mathcal{E}<span class="math">, and </span>\\mathcal{D}^{\\prime}<span class="math"> is the same as </span>\\mathcal{D}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that one can also work with subgroups of arbitrary finite fields, as is done in IEEE P1363.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">13.2 Subgroups of Elliptic Curves</h3>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve defined over a finite field <span class="math">\\mathbf{F}_{q}</span>. Let <span class="math">\\mathcal{H}</span> denote this group. Note that <span class="math">\\mathcal{H}</span> is not in general cyclic. Let <span class="math">\\mathcal{G}</span> denote a prime-order subgroup, and let <span class="math">\\mu</span> be its order, and <span class="math">\\nu</span> be its index in <span class="math">\\mathcal{H}</span>. The encoding/decoding maps <span class="math">\\mathcal{E}</span> and <span class="math">\\mathcal{D}</span> can be implemented using the techniques described in IEEE P1363. Note that these encoding techniques allow for a variety of formats: uncompressed, compressed, and hybrid. The partial encoding map <span class="math">\\mathcal{E}^{\\prime}</span> outputs a fixed length byte string encoding of the <span class="math">x</span>-coordinate of the point, provided the point is not the “point at infinity”; otherwise, it outputs, say, the all-zero byte string of the same fixed length. The partial decoding map <span class="math">\\mathcal{D}^{\\prime}</span> converts the given by string back into an element of <span class="math">\\mathbf{F}_{q}</span>, and then solves a polynomial equation to find the set of possible <span class="math">y</span>-coordinates (there are at most two).</p>

    <h2 id="sec-53" class="text-2xl font-bold">14 Intractability assumptions related to groups</h2>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300">Group <span class="math">=(\\mathcal{H},\\mathcal{G},\\mathbf{g},\\mu,\\nu,\\mathcal{E},\\mathcal{D},\\mathcal{E}^{\\prime},\\mathcal{D}^{\\prime})</span></p>

    <p class="text-gray-300">as in §13.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">14.1 The Computational Diffie-Hellman Problem</h3>

    <p class="text-gray-300">The Computational Diffie-Hellman (CDH) problem for this group is as follows. On input <span class="math">(x\\mathbf{g},y\\mathbf{g})</span>, where <span class="math">x,y\\in\\{0,\\ldots,\\mu-1\\}</span>, compute <span class="math">xy\\cdot\\mathbf{g}</span>. We assume the inputs are random, i.e., that <span class="math">x</span> and <span class="math">y</span> are randomly chosen from the set <span class="math">\\{0,\\ldots,\\mu-1\\}</span>.</p>

    <p class="text-gray-300">The CDH assumption is the assumption that this problem is intractable.</p>

    <p class="text-gray-300">Note that in general, it is not feasible to even identify a correct solution to the CDH problem (this is the Decisional Diffie-Hellman problem — see below). In analyzing cryptographic systems, the types of algorithms for solving the CDH that most naturally arise are algorithms that produce a list of candidate solutions to a given instance of the CDH problem. For any algorithm <span class="math">A</span> for the CDH problem that produces a list of length at most <span class="math">l</span>, we let <span class="math">Advantage_{CDH}(A,l)</span> denote the probability that this list contains a correct solution to the input problem instance.</p>

    <p class="text-gray-300">Note that in <em>[x20]</em>, it is shown how to take an algorithm <span class="math">A</span> with <span class="math">\\epsilon=Advantage_{CDH}(A,l)</span>, and transform this into an algorithm <span class="math">A^{\\prime}</span> that produces a single output that for all inputs is correct with probability <span class="math">1-\\delta</span>. The running time of <span class="math">A^{\\prime}</span> is roughly equal to <span class="math">O(\\epsilon^{-1}\\log(1/\\delta))</span> times that of <span class="math">A</span>, plus the time to perform</p>

    <p class="text-gray-300"><span class="math">O(\\epsilon^{-1}l\\log(1/\\delta)\\log\\mu+(\\log\\mu)^{2})</span></p>

    <p class="text-gray-300">additional group operations.</p>

    <p class="text-gray-300">It is well known that the CDH problem is “random self reducible.”</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">14.2 The Decisional Diffie-Hellman Problem</p>

    <p class="text-gray-300">The Decisional Diffie-Hellman (DDH) problem is as follows.</p>

    <p class="text-gray-300">We define two distributions.</p>

    <p class="text-gray-300">Distribution <span class="math">\\mathbf{R}</span> consists of triples <span class="math">(x\\mathbf{g},y\\mathbf{g},z\\mathbf{g})</span>, where <span class="math">x,y,z</span> are chosen at random from <span class="math">\\{0,\\ldots,\\mu-1\\}</span>. Let <span class="math">X_{\\mathbf{R}}</span> denote a random variable sampled from this distribution.</p>

    <p class="text-gray-300">Distribution <span class="math">\\mathbf{D}</span> consists of triples <span class="math">(x\\mathbf{g},y\\mathbf{g},z\\mathbf{g})</span>, where <span class="math">x,y</span> are chosen at random from <span class="math">\\{0,\\ldots,\\mu-1\\}</span>, and <span class="math">z=xy\\bmod\\mu</span>. Let <span class="math">X_{\\mathbf{D}}</span> denote a random variable sampled from this distribution.</p>

    <p class="text-gray-300">The problem is to distinguish these two distributions.</p>

    <p class="text-gray-300">For an algorithm <span class="math">A</span> that outputs either <span class="math">0</span> or <span class="math">1</span>, we define</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathit{Advantage}_{\\mathit{DDH}}(A)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A(X_{\\mathbf{R}})=1]-\\Pr[A(X_{\\mathbf{D}})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The DDH assumption is that this advantage is negligible for all efficient algorithms.</p>

    <p class="text-gray-300">The DDH problem is “random self-reducible” (see <em>[x20]</em> and <em>[x17]</em>). See <em>[x1]</em> and <em>[x17]</em> for further discussion of the DDH.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">14.3 The Gap-CDH Problem</h3>

    <p class="text-gray-300">The submitters of the PSEC scheme have proposed a new computational assumption, called the gap-CDH assumption. This is the assumption that it is hard to solve the CDH problem, even in the presence of an oracle for solving the DDH problem.</p>

    <p class="text-gray-300">This assumption is not entirely unreasonable, as it it is easily seen that there is no “black box” reduction from the CDH problem to the DDH problem. This can easily be proven in the “black box group” or “generic group” model of <em>[x18]</em>.</p>

    <p class="text-gray-300">For any algorithm <span class="math">A</span> that makes at most <span class="math">q</span> queries to a DDH oracle, we define <span class="math">\\mathit{Advantage}_{\\mathit{GapCDH}}(A,q)</span> to the the probability that <span class="math">A</span> solves a random instance of the CDH problem.</p>

    <p class="text-gray-300">See <em>[x13]</em> for more details about this assumption.</p>

    <h2 id="sec-56" class="text-2xl font-bold">15 ECIES-KEM</h2>

    <p class="text-gray-300">We present here an encryption scheme that is a slight variant of ECIES, and also bears many similarities to PSEC-3. What we describe is actually a key encapsulation mechanism, which we call ECIES-KEM.</p>

    <p class="text-gray-300">We have to describe the key generation, encryption, and decryption algorithms.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">15.1 Key Generation</h3>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">\\mathit{Group}=(\\mathcal{H},\\mathcal{G},\\mathbf{g},\\mu,\\nu,\\mathcal{E},\\mathcal{D},\\mathcal{E}^{\\prime},\\mathcal{D}^{\\prime})</span></p>

    <p class="text-gray-300">is chosen.</p>

    <p class="text-gray-300">Two additional parameters need to be chosen, which we call CofactorMode and CheckMode. Each of these parameters take <span class="math">0/1</span> values. These modes are used to deal with security problems that can arise when <span class="math">\\nu&gt;1</span>. Here are the rules which should be obeyed in setting these modes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\nu=1</span>, then both of these modes should be <span class="math">0</span>.</li>

      <li>If <span class="math">\\nu&gt;1</span>, both modes can be set to <span class="math">0</span>, provided <span class="math">\\gcd(\\mu,\\nu)=1</span> and <span class="math">\\nu</span> is very small. Note that security in this case degrades by a factor of <span class="math">\\nu</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\nu&gt;1</span>, CofactorMode may be set to 1 provided <span class="math">\\gcd(\\mu,\\nu)=1</span>.</li>

      <li>At most one of CofactorMode and CheckMode should be set to 1.</li>

    </ul>

    <p class="text-gray-300">In addition to Group, a key derivation function KDF needs to be selected.</p>

    <p class="text-gray-300">Next, a number <span class="math">x\\in\\{1,\\ldots,\\mu-1\\}</span> is chosen at random, and the group element <span class="math">\\mathbf{h}=x\\mathbf{g}</span> is computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group and <span class="math">\\mathbf{h}</span>, along with an indication of the choice of KDF. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key, together with the number <span class="math">x</span> and the values CofactorMode and CheckMode.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">15.2 Encryption</h3>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext <span class="math">C_{0}</span> that is an encryption of a key <span class="math">K</span>, where <span class="math">K</span> is a byte string of length KeyLen = ECIES-KEM.OutputKeyLen.</p>

    <p class="text-gray-300">In this scheme, the encryption algorithm may take an optional argument format that specifies the format to be used for encoding group elements. The algorithm runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">r\\in\\{1,\\ldots,\\mu-1\\}</span> at random.</li>

      <li>Compute <span class="math">\\hat{\\mathbf{g}}=r\\mathbf{g}</span> and <span class="math">\\tilde{\\mathbf{h}}=r\\mathbf{h}</span>.</li>

      <li>Output the ciphertext</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{0}=\\mathcal{E}(\\hat{\\mathbf{g}},\\textit{format}),</span></p>

    <p class="text-gray-300">and the key</p>

    <p class="text-gray-300"><span class="math">K=\\textit{KDF}(C_{0}\\parallel\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}}),\\textit{KeyLen}).</span></p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">15.3 Decryption</h3>

    <p class="text-gray-300">The decryption algorithm on input <span class="math">C_{0}</span> runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">C_{0}</span> as the encoding of a group element <span class="math">\\hat{\\mathbf{g}}\\in\\mathcal{H}</span>. This step fails is <span class="math">C_{0}</span> is not a proper encoding of an element of <span class="math">\\mathcal{H}</span>.</li>

      <li>If CheckMode = 1, test if <span class="math">\\tilde{\\mathbf{g}}\\in\\mathcal{G}</span>; if not, then fail.</li>

      <li>If CofactorMode = 1, set <span class="math">\\hat{\\mathbf{g}}=\\nu\\tilde{\\mathbf{g}}</span> and <span class="math">\\hat{x}=\\nu^{-1}x\\bmod\\mu</span>; otherwise, set <span class="math">\\hat{\\mathbf{g}}=\\tilde{\\mathbf{g}}</span> and <span class="math">\\hat{x}=x</span>.</li>

      <li>Compute <span class="math">\\tilde{\\mathbf{h}}=\\hat{x}\\hat{\\mathbf{g}}</span>.</li>

      <li>If <span class="math">\\tilde{\\mathbf{h}}=\\mathbf{0}</span>, then fail.</li>

      <li>Output the key</li>

    </ol>

    <p class="text-gray-300"><span class="math">K=\\textit{KDF}(C_{0}\\parallel\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}}),\\textit{KeyLen}).</span></p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">15.4 Some remarks</h3>

    <p class="text-gray-300">Using CofactorMode = 1 may yield a performance benefit if <span class="math">\\nu</span> is fairly small. Note that in this mode, an implementation could simply pre-compute and store the value <span class="math">\\hat{x}</span>, instead of the value <span class="math">x</span>.</p>

    <p class="text-gray-300">15.5 Security considerations</p>

    <p class="text-gray-300">This scheme can be proved secure against adaptive chosen ciphertext attack in the random oracle model under the gap-CDH assumption (see §14.3). Here, we model KDF as a random oracle.</p>

    <p class="text-gray-300">Indeed, it is straightforward to show that</p>

    <p class="text-gray-300"><span class="math">\\mathit{Advantage}_{\\mathit{ECIES\\text{-}KEM}}(A)=O(\\mathit{Advantage}_{\\mathit{GapCDH}}(A^{\\prime},q_{\\mathit{KDF}}))</span></p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A^{\\prime}</span> is an algorithm with access to a DDH oracle whose running time is about the same as that of <span class="math">A</span>,</li>

      <li><span class="math">q_{\\mathit{KDF}}</span> is a bound on the number of random oracle queries, and</li>

      <li><span class="math">\\mathit{Advantage}_{\\mathit{GapCDH}}</span> is as defined in §14.3.</li>

    </ul>

    <p class="text-gray-300">This estimate assumes that either <span class="math">\\mathit{CofactorMode}=1</span> or <span class="math">\\mathit{CheckMode}=1</span>; otherwise, the security bound is</p>

    <p class="text-gray-300"><span class="math">\\mathit{Advantage}_{\\mathit{ECIES\\text{-}KEM}}(A)=O(\\nu\\cdot\\mathit{Advantage}_{\\mathit{GapCDH}}(A^{\\prime},q_{\\mathit{KDF}})).</span></p>

    <p class="text-gray-300">A detailed proof of a slight variant of this security claim can be found in <em>[x10]</em>. Note, however, that the situation there is slightly different than the one here: that paper only considers the case where <span class="math">\\mathit{CheckMode}=1</span> and where group elements have unique encodings. Nevertheless, the proof in that paper can be easily adapted to the situation here.</p>

    <p class="text-gray-300">This scheme can also be proved secure under an appropriate “oracle hashing” assumption, as put forward in the DHAES paper <em>[x1]</em>.</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">15.6 Compatibility with the IEEE P1363a version of ECIES</h3>

    <p class="text-gray-300">The key encapsulation mechanism ECIES-KEM, when combined with the data encapsulation mechanism DEM1 described in §10, yields a hybrid encryption scheme that is compatible with the IEEE P1363a version of ECIES, provided the choice of group, KDF, MAC, SKE is restricted to be consistent with the IEEE P1363a version.</p>

    <p class="text-gray-300">To remain compatible with IEEE P1363a, we have restricted the group elements <span class="math">\\tilde{\\mathbf{g}}</span>, <span class="math">\\mathbf{h}</span>, and in particular <span class="math">\\tilde{\\mathbf{h}}</span> to not be the identity. In particular, this means that the partial encoding function <span class="math">\\mathcal{E}^{\\prime}</span> is never evaluated at <span class="math">\\mathbf{0}</span>, which is consistent with IEEE P1363a.</p>

    <p class="text-gray-300">Note that we have made a number of restrictions on the scheme that are not made in the IEEE P1363a version:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key derivation using <span class="math">C_{0}</span>: we insist that <span class="math">C_{0}</span> be passed to KDF, whereas this is optional in IEEE P1363a.</li>

      <li>No other key derivation parameters: we do not allow any key derivation parameters, whereas IEEE P1363a allows an arbitrary byte string as a key derivation parameter.</li>

      <li>Proper label formatting: we insist that the input to the MAC include the length of the label <span class="math">L</span>, whereas this is optional in IEEE P1363a.</li>

      <li>No stream cipher option: we insist on performing data encapsulation using the DEM1 scheme described in §10, whereas IEEE P1363a allows an alternative mechanism in which KDF is used directly as a stream cipher.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>No use of “old” cofactor mode: we insist on using the newer, “compatible” cofactor mode, whereas IEEE P1363a also allows the use of an “old” cofactor mode.</li>

      <li>Messages are byte strings: we insist that messages are byte strings, whereas IEEE P1363a allows these to be bit strings.</li>

      <li>Static selection of system parameters: we insist that all system parameters, including the choice of KDF, SKE, and MAC, be fixed at key generation time, whereas IEEE P1363a allows these to vary dynamically over the lifetime of the public key.</li>

      <li><span class="math">\\gcd(\\mu,\\nu)=1</span> if both CofactorMode and CheckMode are zero: we insist on this, whereas IEEE P1363a does not.</li>

    </ol>

    <p class="text-gray-300">Each of these restrictions is discussed in turn below. For each restriction, we discuss the rationale for the restriction, and also discuss the the option of easing the restriction so as to achieve greater compatibility with IEEE P1363a. Although in each case, we provide particular arguments for making the recommended restriction, one general argument that applies in all cases is the appeal for simplicity: the IEEE P1363a version of ECIES provides a fairly bewildering array of options, and it is not clear if all of these options are either desirable or useful.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">15.6.1 Key derivation using <span class="math">C_{0}</span></h4>

    <p class="text-gray-300">We insist that <span class="math">C_{0}</span> be passed to KDF, whereas this is optional in IEEE P1363a.</p>

    <p class="text-gray-300">We offer two reasons for this requirement.</p>

    <p class="text-gray-300">First, without this requirement, the scheme does not achieve security against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">There are a number of simple examples that illustrate why ECIES does not achieve this level of security. In particular, it is malleable. If the group is an elliptic curve, and the partial encoding function <span class="math">\\mathcal{E}^{\\prime}</span> encodes only the <span class="math">x</span>-coordinate of a point, then the derived key <span class="math">K</span> is the same if one takes a given ciphertext <span class="math">C_{0}</span> encoding a point <span class="math">\\tilde{\\mathbf{g}}</span> and replaces it with an encoding of <span class="math">-\\tilde{\\mathbf{g}}</span>. A similar problem arises if <span class="math">\\nu&gt;1</span> and CofactorMode <span class="math">=1</span> — in this case, one could add to <span class="math">\\tilde{\\mathbf{g}}</span> a non-zero element whose order divides <span class="math">\\nu</span>, and one obtains yet again a different ciphertext that decrypts to the same thing. Essentially the same problem arises again if the group supports multiple encoding formats.</p>

    <p class="text-gray-300">Of course, this does not represent a catastrophic failure of the system; it simply illustrates that the definition of adaptive chosen ciphertext security is not met in a strict sense. Indeed, the scheme is still secure in the sense of being only benignly malleable (see §2.3), which may be acceptable in many applications. Note, however, that if <span class="math">\\nu&gt;1</span> and both CofactorMode and CheckMode are zero, then the scheme does not even achieve our weaker notion of benign malleability: it still does not appear to be patently insecure, but it is not clear what useful abstract security properties one can establish for the scheme.</p>

    <p class="text-gray-300">The second reason for our requirement is that including <span class="math">C_{0}</span> as an input to KDF yields a much tighter reduction from the gap-CDH problem. If <span class="math">q_{D}</span> is the number of decryption requests, and <span class="math">q_{KDF}</span> is the number of random oracle requests, then without the hash of <span class="math">C_{0}</span>, the number of DDH oracle calls that must be made is <span class="math">q_{KDF}\\cdot q_{D}</span>, whereas with the hash of <span class="math">C_{0}</span>, this drops to <span class="math">q_{KDF}</span>. This security advantage is amplified even further in the multi-user/multi-message setting (see <em>[x1]</em>).</p>

    <p class="text-gray-300">The latest draft of IEEE P1363a allows for an optional “DHAES mode,” which (among other things) passes <span class="math">C_{0}</span> to KDF in just the same way we have done here. Thus, by making this requirement, the ISO standard would conform to the IEEE P1363a standard. Instead of just allowing it,</p>

    <p class="text-gray-300">we strongly recommended that the ISO standard requires it, so as to achieve full non-malleability, and perhaps more importantly, to obtain a much tighter security reduction, especially since the cost of hashing <span class="math">C_{0}</span> is negligible compared to the cost of the public-key operations. However, it would also be acceptable if the ISO standard allowed a variation of the scheme in which <span class="math">C_{0}</span> is not hashed, in order to achieve a greater degree of consistency between IEEE P1363a and the ISO standard.</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">15.6.2 No other key derivation parameters</h4>

    <p class="text-gray-300">We do not allow any key derivation parameters, whereas IEEE P1363a allows an arbitrary byte string as a key derivation parameter.</p>

    <p class="text-gray-300">The notion of a key derivation parameter does not fit well with the abstract interface for encryption proposed in this document, and since it is a quite unusual functionality, it seems likely that this is a feature of the IEEE P1363a version of ECIES that will quickly atrophy. Indeed, none of the other encryption scheme in IEEE P1363 support an analogous feature. Nevertheless, if this feature is desired, it could be included for backward compatibility’s sake.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">15.6.3 Proper label formatting</h4>

    <p class="text-gray-300">We insist that the input to the MAC include the length of the label <span class="math">L</span>, whereas this is optional in IEEE P1363a.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In an early draft of the IEEE P1363a version of ECIES, the MAC is evaluated (in our notation) on the string $c\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,L<span class="math">, instead of on the string </span>c\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,L\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,I2OSP(8\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,8)$, as we have proposed in §10.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The reason we insist on this adding this length information as input to MAC, is that without it, the scheme may be malleable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The problem is that without encoding the length of <span class="math">L</span> in MAC input, one can potentially choose any pair of strings <span class="math">(c^{\\prime},L^{\\prime})</span> such that $c^{\\prime}\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,L^{\\prime}=c\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,L<span class="math">, and then the decryption oracle in a chosen ciphertext attack when supplied with the same ciphertext but with label </span>L^{\\prime}<span class="math"> instead of </span>L$ may leak interesting information about the target message.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This problem was identified and brought to the attention to the IEEE P1363 working group by David Hopwood, as well as through an earlier version of this document. The latest version of the IEEE P1363a draft supports an optional “DHAES mode,” which (among other things) provides the same “fix” that we propose here. For compatibility reasons, one might allow variations without the fix, but then require a restriction, such as the restriction that the label must be empty, or that all messages are of a length that is fixed for the lifetime of the public key (which would also be consistent with the recommendation below in §15.6.4).</p>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">15.6.4 No stream cipher option</h4>

    <p class="text-gray-300">We insist on performing data encapsulation using the DEM1 scheme described in §10, whereas IEEE P1363a allows an alternative mechanism in which KDF is used directly as a stream cipher.</p>

    <p class="text-gray-300">The reason we insist on this restriction, is that without it, the scheme is malleable in a very strong sense.</p>

    <p class="text-gray-300">We first describe the “stream cipher option,” and then we describe the attack.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose the input to the encryption algorithm is a message <span class="math">M</span> of length <span class="math">l</span>, and a label <span class="math">L</span>. After the shared Diffie-Hellman key <span class="math">\\tilde{\\mathbf{h}}</span> is produced, a key derivation function is applied to obtain a string $k\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,k^{\\prime}<span class="math">, where </span>k<span class="math"> has length </span>l<span class="math"> and </span>k^{\\prime}$ has length MAC.KeyLen. The ciphertext is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C=(C_{0},c,\\text{\\emph{MAC.eval}}(k^{\\prime},c\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,L)),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">c=M\\oplus k</span> and <span class="math">C_{0}</span> is the encoding of the ephemeral Diffie-Hellman key <span class="math">\\mathbf{\\hat{g}}</span>.</p>

    <p class="text-gray-300">Now we describe the attack. Suppose</p>

    <p class="text-gray-300"><span class="math">C=(C_{0},c,\\text{\\it tag})</span></p>

    <p class="text-gray-300">is the encryption of a message <span class="math">M</span> with label <span class="math">L</span>, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the length <span class="math">l</span> of <span class="math">M</span> is equal to <span class="math">l^{\\prime}+\\text{\\it MAC.KeyLen}</span> for <span class="math">l^{\\prime}&gt;0</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">c=c_{1}\\parallel c_{2}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=l^{\\prime}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{\\it MAC.KeyLen}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_{2}</span> is known to the attacker.</li>

    </ul>

    <p class="text-gray-300">Then for any byte string <span class="math">\\Delta</span> of length <span class="math">l^{\\prime}</span>, and any label <span class="math">\\tilde{L}</span>, the ciphertext</p>

    <p class="text-gray-300"><span class="math">\\tilde{C}=(C_{0},\\tilde{c},\\text{\\it MAC.eval}(\\tilde{k},\\tilde{c}\\parallel\\tilde{L})),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\tilde{c}=c_{1}\\oplus\\Delta\\text{\\ and }\\tilde{k}=c_{2}\\oplus M_{2},</span></p>

    <p class="text-gray-300">is a valid encryption of <span class="math">M_{1}\\oplus\\Delta</span> with label <span class="math">\\tilde{L}</span>.</p>

    <p class="text-gray-300">Thus, the scheme is trivially malleable, in a very strong way: we can transform the encryption of <span class="math">M_{1}\\parallel M_{2}</span> with label <span class="math">L</span> into an encryption of <span class="math">M_{1}\\oplus\\Delta</span> with label <span class="math">\\tilde{L}</span>, for any <span class="math">\\Delta</span> and any <span class="math">\\tilde{L}</span>.</p>

    <p class="text-gray-300">This problem could easily have been avoided if the output of the key derivation function was parsed as <span class="math">k^{\\prime}\\parallel k</span> instead of <span class="math">k\\parallel k^{\\prime}</span>. Indeed, if this were done, the security of the data encapsulation method could be proven secure under standard assumptions.</p>

    <p class="text-gray-300">Because of this rather serious flaw in the design of ECIES, this mode of data encapsulation was not included in our proposal here, and it is strongly recommended that the ISO version of ECIES not allow this mode of data encapsulation.</p>

    <p class="text-gray-300">The only possible circumstances under which the stream cipher option would be acceptable as an option would be if the message length were fixed for the lifetime of a public key.</p>

    <p class="text-gray-300">The current IEEE P1363a draft document recommends using the stream cipher option only in applications where the message is short, such as key transport, but the reasons given are efficiency (decryption cannot be performed in a single pass) and the fact that the recommended instantiations of KDF have not traditionally been used as stream ciphers, and so there may be unforeseen security problems in their use as such. However, no recommendation is made in IEEE P1363a that the length of the message should be fixed for all ciphertexts. Thus, this appears to be an authentic, and perhaps serious, security hole in ECIES. The same problem appears in the versions of ECIES submitted to ISO, submitted to Crypto-Nessie, and in the draft of ANSI X9.63.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">15.6.5 No use of “old” cofactor mode</h4>

    <p class="text-gray-300">We insist on using the newer, “compatible” cofactor mode, whereas IEEE P1363a also allows the use of an “old” cofactor mode.</p>

    <p class="text-gray-300">The cofactor mode described in this document corresponds to what is called “compatible” cofactor mode in the IEEE P1363a version of ECIES. That version of ECIES also allows another mode, which we shall call here “old” cofactor mode. “Old” cofactor mode appeared in the ECIES</p>

    <p class="text-gray-300">submission to ISO, but “compatible” cofactor mode did not. Both of these modes deal quite effectively with the potential problem of small subgroup attacks when <span class="math">\\nu\\neq 1</span>. The advantage of “compatible” cofactor mode over “old” cofactor mode is that the encryption algorithm is oblivious to it in the former, while it needs to be aware of it in the latter. “Old” cofactor mode appears to offer no advantages at all, and so we recommend not including it in the ISO standard. However, we could include it for compatibility reasons, without any great harm.</p>

    <p class="text-gray-300">Note that “compatible” cofactor mode is not “just” an alternative implementation of the decryption algorithm: the behavior of the decryption algorithm is different when using this mode than it is when not, as some ciphertexts that would be rejected without this mode, will not be rejected with this mode.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">15.6.6 Messages are byte strings</h4>

    <p class="text-gray-300">We insist that messages are byte strings, whereas IEEE P1363a allows these to be bit strings.</p>

    <p class="text-gray-300">See §2.1.8 for a discussion of why we work only with byte strings. It is mentioned there that the IEEE P1363a version of ECIES allows bit strings, but even that is not entirely true, since the underlying symmetric-key encryption schemes that it currently allows do not support bit strings. The only exception to this is when the “stream cipher option” discussed in §15.6.4 is used, but as we have already argued, this option should anyway not be allowed in the ISO standard.</p>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">15.6.7 Static selection of system parameters</h4>

    <p class="text-gray-300">We insist that all system parameters, including the choice of KDF, SKE, and MAC be fixed at key generation time, whereas IEEE P1363a allows these to vary dynamically over the lifetime of the public key. Although the latter is not recommended in IEEE P1363a, due to possible security problems that may arise from “unintended interactions” of different options, it is nevertheless allowed.</p>

    <p class="text-gray-300">It is the opinion of this author that allowing such flexibility is entirely unacceptable: all hope of a meaningful security analysis vanishes if one allows for this, and there may indeed be real harm that could come from “unintended interactions.” This proposal recommends with the strongest possible urgency that the ISO standard should require all such options to be fixed at key generation time. In addition, all scheme options discussed above, such as not including <span class="math">C_{0}</span> in the key derivation function, allowing additional key derivation parameters, cofactor mode, check mode, etc., should be determined at key generation time and fixed for the lifetime of public key.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">15.6.8 <span class="math">\\gcd(\\mu,\\nu)=1</span> if both CofactorMode and CheckMode are zero</h4>

    <p class="text-gray-300">We insist on this, whereas IEEE P1363a does not.</p>

    <p class="text-gray-300">The reason is that without this restriction, it does not seem possible to reason about the security of the scheme, whereas with this restriction, it is possible.</p>

    <p class="text-gray-300">Without going into all the details, we just note that if <span class="math">\\gcd(\\mu,\\nu)=1</span>, then one can decompose <span class="math">\\mathcal{H}</span> as the direct sum of <span class="math">\\mathcal{G}</span> and the subgroup <span class="math">\\mathcal{G}^{\\prime}\\subset\\mathcal{H}</span> consisting of all elements of <span class="math">\\mathcal{H}</span> whose order divides <span class="math">\\nu</span>. This decomposition is effective, in the sense that given <span class="math">\\mathbf{a}\\in\\mathcal{H}</span>, one can efficiently compute <span class="math">\\mathbf{a}_{1}\\in\\mathcal{G}</span> and <span class="math">\\mathbf{a}_{2}\\in\\mathcal{G}^{\\prime}</span> such that <span class="math">\\mathbf{a}=\\mathbf{a}_{1}+\\mathbf{a}_{2}</span>. The existence of an effective decomposition such as this is critical to the proof of security.</p>

    <p class="text-gray-300">Making this requirement most likely will have little practical impact, since it is very unusual to have <span class="math">\\gcd(\\mu,\\nu)\\neq 1</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">15.7 Compatibility with the submitted version of ECIES</p>

    <p class="text-gray-300">There are a number of differences between the IEEE P1363a version of ECIES and the version of ECIES that was submitted to the ISO.</p>

    <p class="text-gray-300">First, and most prominently, the IEEE P1363a version allows subgroups of finite fields as groups in addition to just elliptic curve groups, as in the submitted version.</p>

    <p class="text-gray-300">Second, the IEEE P1363a version allows for a data encapsulation mechanism of the type described in §10 and recommended here, in addition to the “stream cipher option” (see §15.6.4) as in the submitted version. Note that the version of ECIES submitted to Crypto-Nessie allows for both modes of operations (although not with the same set of symmetric-key encryption schemes).</p>

    <p class="text-gray-300">Third, the IEEE P1363a version allows for a “compatible” cofactor mode, in addition to the “old” cofactor mode, as in the submitted version (see §15.6.5).</p>

    <p class="text-gray-300">Fourth, the IEEE P1363a version of ECIES provides a “DHAES option,” which when used, passes <span class="math">C_{0}</span> to KDF (see §15.6.1) and the length of <span class="math">L</span> to MAC (see §15.6.3).</p>

    <p class="text-gray-300">In preparing this document, based on discussions with ISO working group members, priority was given to consistency with the IEEE P1363a version, rather than to the submitted version.</p>

    <h2 id="sec-70" class="text-2xl font-bold">16 PSEC-KEM</h2>

    <p class="text-gray-300">We present here a variant of PSEC-2. This is a key encapsulation scheme, which we call PSEC-KEM, that can be combined with the general hybrid method in §5 to get a full public-key encryption scheme. While the scheme we present here differs in numerous details from the original PSEC-2, we believe it is similar in spirit to the PSEC-2 submission, preserves the main idea of <em>[x10]</em> on which it is based, and provides very nearly the same security/efficiency trade-off.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">16.1 Key Generation</h3>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">Group=({\\cal H},{\\cal G},{\\bf g},\\mu,\\nu,{\\cal E},{\\cal D},{\\cal E}^{\\prime},{\\cal D}^{\\prime}).</span></p>

    <p class="text-gray-300">Additionally, a key derivation function KDF (see §12) should be selected, along with a positive integer SeedLen.</p>

    <p class="text-gray-300">Next, a number <span class="math">x\\in\\{0,\\ldots,\\mu-1\\}</span> is chosen at random, and the group element <span class="math">{\\bf h}=x{\\bf g}</span> is computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group and <span class="math">{\\bf h}</span>, along with an indication of the choice of KDF and the value SeedLen. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key together with <span class="math">x</span>.</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">16.2 Encryption</h3>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext <span class="math">C_{0}</span> that is an encryption of a key <span class="math">K</span>, where <span class="math">K</span> is a byte string of length <span class="math">KeyLen=PSEC</span>-<span class="math">KEM.OutputKeyLen</span>.</p>

    <p class="text-gray-300">Let <span class="math">I0=I2OSP(0,4)</span> and <span class="math">I1=I2OSP(1,4)</span>.</p>

    <p class="text-gray-300">The encryption algorithm takes an optional argument format that specifies the format to be used to encode group elements, and runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a random byte string <span class="math">s</span> of length SeedLen.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$t=\\mathit{KDF(I0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,s,\\lceil\\log_{256}\\mu\\rceil+16+\\mathit{KeyLen)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a byte string of length <span class="math">\\lceil\\log_{256}\\mu\\rceil+16+\\mathit{KeyLen}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Parse <span class="math">t</span> as $t=u\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,K<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lceil\\log_{256}\\mu\\rceil+16<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathit{KeyLen}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">r=\\mathit{OS2IP(u)}</span> mod <span class="math">\\mu</span>.</li>

      <li>Compute <span class="math">\\tilde{\\mathbf{g}}=r\\mathbf{g}</span> and <span class="math">\\tilde{\\mathbf{h}}=r\\mathbf{h}</span>.</li>

      <li>Set <span class="math">\\mathit{EG=\\mathcal{E}(\\tilde{\\mathbf{g}},\\mathit{format})}</span> and <span class="math">\\mathit{PEH=\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}})}</span>.</li>

      <li>Compute</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v=s\\oplus\\mathit{KDF(I1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,EG\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathit{PEH},\\mathit{SeedLen)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">16.3 Decryption</h3>

    <p class="text-gray-300">The decryption algorithm takes the secret key as well as a ciphertext <span class="math">C_{0}</span> as input. It runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">C_{0}</span> as $C_{0}=\\mathit{EG}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,v<span class="math">, where </span>\\mathit{EG}<span class="math"> is an encoding a group element </span>\\tilde{\\mathbf{g}}<span class="math">, and </span>v<span class="math"> is a byte string of length </span>\\mathit{SeedLen}$. This step may, of course, fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\tilde{\\mathbf{h}}=x\\tilde{\\mathbf{g}}</span>.</li>

      <li>Set <span class="math">\\mathit{PEH=\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}})}</span>.</li>

      <li>Compute</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$s=v\\oplus\\mathit{KDF(I1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,EG\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathit{PEH},\\mathit{SeedLen)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$t=\\mathit{KDF(I0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,s,\\lceil\\log_{256}\\mu\\rceil+16+\\mathit{KeyLen)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a byte string of length <span class="math">\\lceil\\log_{256}\\mu\\rceil+16+\\mathit{KeyLen}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. Parse <span class="math">t</span> as $t=u\\,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,K<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lceil\\log_{256}\\mu\\rceil+16<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathit{KeyLen}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">r=\\mathit{OS2IP(u)}</span> mod <span class="math">\\mu</span>.</li>

      <li>Compute <span class="math">\\bar{\\mathbf{g}}=r\\mathbf{g}</span>.</li>

      <li>Test if <span class="math">\\bar{\\mathbf{g}}=\\tilde{\\mathbf{g}}</span>; if not, then fail.</li>

      <li>Output the key <span class="math">K</span>.</li>

    </ol>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">16.4 Some remarks</h3>

    <p class="text-gray-300">Note that in this scheme, we do not have to make an additional check to ensure that <span class="math">\\tilde{\\mathbf{g}}</span> lies in <span class="math">\\mathcal{G}</span> during the decryption process. This is already taken care of by the test in step 9 of the decryption algorithm.</p>

    <p class="text-gray-300">Also note that unlike ECIES, a value of <span class="math">\\mathbf{0}</span> for <span class="math">\\tilde{\\mathbf{h}}</span> is perfectly legal, and therefore, the function <span class="math">\\mathcal{E}^{\\prime}</span> must be well defined at <span class="math">\\mathbf{0}</span>. It was felt that making the restriction that <span class="math">\\tilde{\\mathbf{h}}\\neq\\mathbf{0}</span> would only complicate the scheme, with no tangible benefit.</p>

    <p class="text-gray-300">16.5 Changes from PSEC-2</p>

    <p class="text-gray-300">There are a number of substantial differences between PSEC-KEM and the PSEC-2.</p>

    <p class="text-gray-300">First and foremost is the fact that the above scheme is just a key encapsulation mechanism. As we discussed in §5, using this we can build a hybrid scheme.</p>

    <p class="text-gray-300">The PSEC-2 submission proposed a different kind of hybrid construction. We would recommend the hybrid construction here above the hybrid construction in the PSEC-2 for three reasons.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One of the goals of this document is to consolidate the various submissions, taking the best ideas from all of them, and obtaining a small set of schemes, each of which offers something unique. To that end, it seems like a good idea to use the same hybrid construction for all schemes.</li>

      <li>The hybrid construction proposed here has a distinct advantage over the hybrid construction proposed in PSEC-2. Namely, it facilitates the implementation of the encryption and decryption algorithms as filters (see §2.1.3). For the original PSEC-2 construction, this does not seem possible.</li>

      <li>The hybrid construction proposed here does not rely on random oracles, whereas that in PSEC-2 does. It is easy enough to build a hybrid scheme without random oracles, assuming the underlying key encapsulation mechanism is secure, so it seems worthwhile to do so. In particular, we want to be able to include schemes, like ACE-KEM, that do not use random oracles in their security analysis.</li>

    </ol>

    <p class="text-gray-300">The only disadvantages of our proposed hybrid construction are that the ciphertexts are slightly longer (an additional MAC tag is required), and additional code is required for its implementation (the MAC code). We feel that these disadvantages are outweighed by the advantages of conformity with the other schemes, and of facilitating “streaming.” This, of course, may be a point of discussion by the working group.</p>

    <p class="text-gray-300">There are some other differences as well. In our scheme, the value <span class="math">v</span> (in our notation) is computed by masking the seed <span class="math">s</span> with a cryptographic hash</p>

    <p class="text-gray-300"><span class="math">\\textit{KDF}(I1\\mathop{\\parallel}\\textit{EG}\\mathop{\\parallel}\\textit{PEH},\\textit{SeedLen}),</span></p>

    <p class="text-gray-300">whereas in PSEC-2, <span class="math">s</span> is masked directly with PEH — no hash at all. Our scheme thus has potentially more compact ciphertexts than PSEC-2. Also, by including EG in the hash, we get a a much more efficient security reduction in the multi-user/multi-message model (see <em>[x11]</em>), and we also deal properly with the multiple group encoding formats.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A serious criticism of the PSEC-2 scheme as submitted is that there is no detailed proof of the claimed security theorem, either in the submission or elsewhere in the literature. In fact, there is some doubt as to whether the scheme actually is secure under the stated assumptions. The problem is the way the value <span class="math">v</span> (our notation) is computed in PSEC-2. As mentioned above, this is computed as <span class="math">v=s\\oplus\\textit{PEH}</span>. The only requirement in the scheme is that SeedLen $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textit{PEH}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. However, if SeedLen </span><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textit{PEH}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then the ciphertext contains some of bits of PEH in the clear. To prove security of this scheme, then, one would (at least) need to show that one could not compute </span>\\tilde{\\mathbf{h}}<span class="math"> from </span>\\tilde{\\mathbf{g}}<span class="math"> and some of the bits of the partial encoding of </span>\\tilde{\\mathbf{h}}<span class="math">. It would appear that requiring that SeedLen </span>\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textit{PEH}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> solves the problem. Note that the stated requirement that SeedLen </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textit{PEH}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is apparently not a typographic error, since the examples of PSEC-2 in the appendix of the submission all have SeedLen </span><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textit{PEH}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">A similar, but more severe, criticism applies to the PSEC-1 submission. More specifically, in the PSEC-1 encryption algorithm, the ciphertext contains the XOR of the message with a substring of PEH. There is no way the semantic security of this scheme can be based upon the DDH assumption, since the DDH assumption does not imply that the bits of an encoding of a group element are pseudo-random.</p>

    <p class="text-gray-300">Also note that our proposed scheme works with any prime-order group, not just subgroups of elliptic curves.</p>

    <p class="text-gray-300">We should also mention that the scheme we have proposed here bears some similarities not only to the PSEC-2 submission, but also to a very similar scheme presented in <em>[x10]</em>.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">16.6 Security considerations</h3>

    <p class="text-gray-300">Since this proposed scheme differs significantly from PSEC-2 and other schemes in the literature, we sketch a security proof in the random oracle model assuming the CDH (see §14.1).</p>

    <p class="text-gray-300">We view KDF as a random oracle. Note that all relevant inputs to KDF start with either a “zero word” or a “one word.” This effectively gives us two independent random oracles,</p>

    <p class="text-gray-300"><span class="math">H_{0}</span> <span class="math">:</span> <span class="math">\\mathbf{B}^{SeedLen}\\rightarrow\\mathbf{B}^{[\\log_{256}\\mu]+16+KeyLen},</span> <span class="math">H_{1}</span> <span class="math">:</span> <span class="math">\\mathcal{E}(\\mathcal{H})\\times\\mathcal{E}^{\\prime}(\\mathcal{H})\\rightarrow\\mathbf{B}^{SeedLen}.</span></p>

    <p class="text-gray-300">Here, <span class="math">\\mathbf{B}</span> denotes the set of bytes. Also, <span class="math">\\mathcal{E}(\\mathcal{H})</span> denotes the set of all encodings of elements in <span class="math">\\mathcal{H}</span>, using all formats, and <span class="math">\\mathcal{E}^{\\prime}(\\mathcal{H})</span> denotes the set of all partial encodings of elements in <span class="math">\\mathcal{H}</span>. In the security analysis, we shall replace the calls to KDF by appropriate queries to <span class="math">H_{0}</span> and <span class="math">H_{1}</span>.</p>

    <p class="text-gray-300">Consider an adversary <span class="math">A</span> that makes <span class="math">q_{D}</span> calls to the decryption oracle, <span class="math">q_{0}</span> calls to <span class="math">H_{0}</span> and <span class="math">q_{1}</span> calls to <span class="math">H_{1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{G}_{0}</span> be the original attack game, and let <span class="math">S_{0}</span> be the event that the adversary correctly guesses the hidden bit <span class="math">b</span> in this game (see §3). We shall define a sequence of attack games <span class="math">\\mathbf{G}_{1},\\mathbf{G}_{2},\\ldots,\\mathbf{G}_{k}</span>. Each of these games should be viewed as operating on the same underlying probability space — only the rules for how certain random variables are computed differ. In each game <span class="math">\\mathbf{G}_{i}</span>, <span class="math">1\\leq i\\leq k</span>, there will be an event <span class="math">S_{i}</span> corresponding to <span class="math">S_{0}</span>. We shall show that for all <span class="math">1\\leq i\\leq k</span>, that the difference $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{i}]-\\Pr[S_{i-1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible, and moreover, it will be evident that in the last game, </span>\\Pr[S_{k}]=1/2.<span class="math"> This will imply that </span>Advantage_{PSEC\\text{-}KEM}(A)<span class="math">, which is equal to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We adopt the following convention. For an arbitrary ciphertext <span class="math">C_{0}</span>, we denote by</p>

    <p class="text-gray-300"><span class="math">EG,v,\\tilde{\\mathbf{g}},\\tilde{\\mathbf{h}},PEH,s,t,u,K,r,\\bar{\\mathbf{g}},</span></p>

    <p class="text-gray-300">the values computed by the decryption algorithm on this ciphertext. Some of these may be undefined if the algorithm would fail before the value was computed. We also denote the target ciphertext <span class="math">C_{0}^{<em>}</span>, and define corresponding values <span class="math">EG^{</em>},v^{<em>},\\tilde{\\mathbf{g}}^{</em>},\\ldots</span>.</p>

    <p class="text-gray-300">We classify ciphertexts <span class="math">C_{0}</span> submitted to the encryption oracle as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Type\\ I}\\ \\tilde{\\mathbf{g}}\\neq\\tilde{\\mathbf{g}}^{<em>};</span> <span class="math">\\mathbf{Type\\ II}\\ EG=EG^{</em>};</span> <span class="math">\\mathbf{Type\\ III}\\ \\tilde{\\mathbf{g}}=\\tilde{\\mathbf{g}}^{*},</span></p>

    <p class="text-gray-300">that all ciphertexts <span class="math">C_{0}</span> submitted to the decryption oracle before the encryption oracle has been invoked are classified as Type I. Notice that Type III ciphertexts can arise only if the group supports multiple encoding formats.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{S}</span> denote the set of points <span class="math">s</span> at which the oracle <span class="math">H_{0}</span> has been queried either (i) directly by the adversary, or (ii) by a Type III decryption oracle invocation. The set <span class="math">\\mathcal{S}</span> grows over time, as more queries to <span class="math">H_{0}</span> are made. For any byte string <span class="math">s</span> of length SeedLen, we define <span class="math">\\rho(s)</span> to be the number obtained by taking the first <span class="math">\\lceil\\log_{256}\\mu\\rceil+16</span> of <span class="math">H_{0}(s)</span>, converting to an integer, and reducing mod <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">The following trivial lemma will streamline our arguments.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Let <span class="math">E</span>, <span class="math">E^{\\prime}</span>, and <span class="math">F</span> be events defined on a probability space such that <span class="math">\\Pr[E\\wedge\\neg F]=\\Pr[E^{\\prime}\\wedge\\neg F]</span>. Then we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[E]-\\Pr[E^{\\prime}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof is a simple calculation, which we omit.</p>

    <p class="text-gray-300">We now define our sequence of games <span class="math">\\mathbf{G}_{1},\\mathbf{G}_{2},\\dots</span>.</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{1}</span>. We modify the decryption oracle as follows. If the adversary submits a Type II ciphertext <span class="math">C_{0}</span>, then in game <span class="math">\\mathbf{G}_{1}</span>, we summarily reject <span class="math">C_{0}</span>, without executing the decryption algorithm at all.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_{1}</span> be the event that in game <span class="math">\\mathbf{G}_{1}</span> such a ciphertext is rejected that would not have been rejected under the rules of game <span class="math">\\mathbf{G}_{0}</span>. Since these two games proceed identically until <span class="math">F_{1}</span> occurs, we have <span class="math">\\Pr[S_{0}\\wedge\\neg F_{1}]=\\Pr[S_{1}\\wedge\\neg F_{1}]</span>, and applying Lemma 1 with <span class="math">(S_{0},S_{1},F_{1})</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{1}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So it suffices to bound <span class="math">\\Pr[F_{1}]</span>. Consider a Type II ciphertext <span class="math">C_{0}</span> submitted to the decryption oracle in game <span class="math">\\mathbf{G}_{1}</span>. Since <span class="math">C_{0}\\neq C_{0}^{<em>}</span>, we must have <span class="math">v\\neq v^{</em>}</span>, which implies <span class="math">s\\neq s^{<em>}</span>. To accept under the rules of game <span class="math">\\mathbf{G}_{0}</span>, we must have <span class="math">r=r^{</em>}</span>.</p>

    <p class="text-gray-300">To make this happen, the adversary must find an input <span class="math">s\\neq s^{<em>}</span> to <span class="math">H_{0}</span> such that <span class="math">\\rho(s)=r^{</em>}</span>. Thus, <span class="math">\\Pr[F_{1}]\\leq(q_{0}+q_{D})\\mu^{-1}(1+2^{-128})</span>. The factor <span class="math">(1+2^{-128})</span> comes from the fact that the value <span class="math">r</span> is not exactly uniformly distributed over <span class="math">\\{0,\\dots,\\mu-1\\}</span>.</p>

    <p class="text-gray-300">So we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(q_{0}+q_{D})\\mu^{-1}(1+2^{-128}).$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{2}</span>. In this game, we modify the decryption oracle as follows. Suppose a Type I ciphertext <span class="math">C_{0}</span> is submitted, and suppose that <span class="math">s\\notin\\mathcal{S}</span>. Then we summarily reject this ciphertext, without ever proceeding past step 4 of the decryption algorithm.</p>

    <p class="text-gray-300">Note that in this game, Type I and II decryption oracle invocations never evaluate <span class="math">H_{0}</span> at points not already in <span class="math">\\mathcal{S}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_{2}</span> be the event that in game <span class="math">\\mathbf{G}_{2}</span> such a ciphertext is rejected that would not have been rejected under the rules of game <span class="math">\\mathbf{G}_{1}</span>. These two games proceed identically until <span class="math">F_{2}</span> occurs, and so <span class="math">\\Pr[S_{1}\\wedge\\neg F_{2}]=\\Pr[S_{2}\\wedge\\neg F_{2}]</span>, and applying Lemma 1 to <span class="math">(S_{1},S_{2},F_{2})</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{2}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So it suffices to bound <span class="math">\\Pr[F_{2}]</span>. Consider a ciphertext <span class="math">C_{0}</span> as above is submitted to the decryption oracle in game <span class="math">\\mathbf{G}_{2}</span>. On the one hand, if the encryption oracle was previously invoked and <span class="math">s=s^{<em>}</span>, then under the rules of game <span class="math">\\mathbf{G}_{1}</span>, we would certainly reject <span class="math">C_{0}</span>, since <span class="math">\\tilde{\\mathbf{g}}\\neq\\tilde{\\mathbf{g}}^{</em>}</span>. On the other hand, if the decryption oracle was not previously invoked or it was but <span class="math">s\\neq s^{*}</span>, then <span class="math">H_{0}</span> was never queried at <span class="math">s</span> either by the encryption oracle, the decryption oracle, or the adversary, and so the value <span class="math">r</span> is independent of everything in the adversary’s view. It follows that the probability that this ciphertext would not be rejected under the rules of game <span class="math">\\mathbf{G}_{1}</span> is at most <span class="math">\\mu^{-1}(1+2^{-128})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">From this, it follows that <span class="math">\\Pr[F_1] \\leq q_D \\mu^{-1}(1 + 2^{-128})</span>, and therefore,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_1] - \\Pr[S_2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_D \\mu^{-1}(1 + 2^{-128}). \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Game G₃.</strong> We make another modification to the decryption oracle. In this new game, we process all Type I ciphertexts <span class="math">C_0</span> as follows. If <span class="math">\\tilde{\\mathbf{g}}</span> is not equal to <span class="math">\\rho(s&#x27;)\\mathbf{g}</span> for any <span class="math">s&#x27; \\in \\mathcal{S}</span>, then we reject without any further processing. Otherwise, if <span class="math">\\tilde{\\mathbf{g}} = \\rho(s&#x27;)\\mathbf{g}</span> for some <span class="math">s&#x27; \\in \\mathcal{S}</span>, we compute <span class="math">\\tilde{\\mathbf{h}} = \\rho(s&#x27;)\\mathbf{h}</span>, and proceed to decrypt just as in game <span class="math">\\mathbf{G}_2</span>, but starting with step 3 of the decryption algorithm.</p>

    <p class="text-gray-300">We argue that games <span class="math">\\mathbf{G}_2</span> and <span class="math">\\mathbf{G}_3</span> are identical.</p>

    <p class="text-gray-300">Consider first a ciphertext for which <span class="math">\\tilde{\\mathbf{g}}</span> is not equal to <span class="math">\\rho(s&#x27;)\\mathbf{g}</span> for any <span class="math">s&#x27; \\in \\mathcal{S}</span>. This ciphertext would have anyway been rejected under the rules in game <span class="math">\\mathbf{G}_2</span>. To see this, let <span class="math">\\tilde{\\mathbf{g}} = \\hat{r}\\mathbf{g}</span>, where <span class="math">\\hat{r} \\in \\{0, \\dots, \\mu - 1\\}</span>. Now, <span class="math">\\hat{r} \\neq \\rho(s&#x27;)</span> for any <span class="math">s&#x27; \\in \\mathcal{S}</span>. Consider the value <span class="math">s</span>. If <span class="math">s \\in \\mathcal{S}</span>, then we would reject under the rules in game <span class="math">\\mathbf{G}_2</span>, since the test in step 9 would fail; otherwise, if <span class="math">s \\notin \\mathcal{S}</span>, we would also reject under the rules in game <span class="math">\\mathbf{G}_2</span>, since the special rejection rule introduced in game <span class="math">\\mathbf{G}_2</span> would apply.</p>

    <p class="text-gray-300">Next, consider the case where <span class="math">\\tilde{\\mathbf{g}} = \\rho(s&#x27;)\\mathbf{g}</span> for some <span class="math">s&#x27; \\in \\mathcal{S}</span>. It is clear that in this case, decryption proceeds exactly as in game <span class="math">\\mathbf{G}_2</span>.</p>

    <p class="text-gray-300">So we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[S_3] = \\Pr[S_2]. \\tag{3}</span></div>

    <p class="text-gray-300"><strong>Game G₄.</strong> We modify game <span class="math">\\mathbf{G}_3</span> to obtain an equivalent game <span class="math">\\mathbf{G}_4</span>. This rather technical step is a "bridging" step that will facilitate the analysis of more drastic modifications in game <span class="math">\\mathbf{G}_5</span>.</p>

    <p class="text-gray-300">In game <span class="math">\\mathbf{G}_4</span>, we introduce</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a random byte string <span class="math">s^+</span> of length SeedLen,</li>

      <li>a random byte string <span class="math">u^+</span> of length <span class="math">\\lceil \\log_{256} \\mu \\rceil + 16</span>,</li>

      <li>a random byte string <span class="math">K^+</span> of length KeyLen, and</li>

      <li>a random oracle</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">h^+: \\mathcal{E}(\\mathcal{H}) \\to \\mathbf{B}^{SeedLen}.</span></div>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_4</span> is identical to game <span class="math">\\mathbf{G}_3</span>, except that we apply the following special rules:</p>

    <p class="text-gray-300"><strong>R1:</strong> In the encryption oracle, we perform the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">r^+ = \\text{OS2IP}(u^+) \\mod \\mu</span>.</li>

      <li>Compute <span class="math">\\tilde{\\mathbf{g}}^* = r^+\\mathbf{g}</span>.</li>

      <li>Set <span class="math">EG^<em> = \\mathcal{E}(\\tilde{\\mathbf{g}}^</em>, \\text{format})</span>.</li>

      <li>Compute <span class="math">v^<em> = s^+ \\oplus h^+(EG^</em>)</span>.</li>

      <li>Output the key <span class="math">K^+</span> and the ciphertext <span class="math">C_0^<em> = EG^</em> \\parallel v^*</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>R2:</strong> In the decryption oracle, when processing a Type III ciphertext, we use the value <span class="math">h^+(EG)</span> in step 4, instead of <span class="math">H_1(EG, PEH)</span>.</p>

    <p class="text-gray-300"><strong>R3:</strong> Whenever the oracle <span class="math">H_0</span> is queried — by either the adversary or a Type III decryption oracle — at <span class="math">s^+</span> we respond with <span class="math">u^+ \\parallel K^+</span>, instead of <span class="math">H(s^+)</span>.</p>

    <p class="text-gray-300"><strong>R4:</strong> Whenever the oracle <span class="math">H_1</span> is queried — by either the adversary or a Type I decryption oracle — at a point <span class="math">(EG, PEH)</span>, where <span class="math">EG</span> is an encoding of <span class="math">\\tilde{\\mathbf{g}}^<em></span> and <span class="math">PEH</span> is a partial encoding of <span class="math">x\\tilde{\\mathbf{g}}^</em></span>, we respond with <span class="math">h^+(EG)</span> instead of <span class="math">H_1(EG, PEH)</span>.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">It is clear that games <span class="math">\\mathbf{G}_{3}</span> and <span class="math">\\mathbf{G}_{4}</span> are completely equivalent, since we have consistently replaced one set of random variables by another set of identically distributed random variables. In particular,</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{3}]=\\Pr[S_{4}].</span> (4)</p>

    <p class="text-gray-300">Game <span class="math">\\mathbf{G}_{5}</span>. Game <span class="math">\\mathbf{G}_{5}</span> is the same as game <span class="math">\\mathbf{G}_{4}</span>, except that we drop rules R3 and R4, while retaining R1 and R2.</p>

    <p class="text-gray-300">Note that in this game, we do not use the secret key of the cryptosystem at all. Also note that the ciphertext <span class="math">C_{0}^{<em>}</span> is no longer a valid ciphertext in general, nor does it hold in general that <span class="math">s^{</em>}=s^{+}</span>, or that <span class="math">t^{*}=u^{+}\\parallel K^{+}</span>, since the random oracles are no longer consistent with the modifications made in the encryption oracle. Indeed, <span class="math">K^{+}</span> and hence the hidden bit <span class="math">b</span> are independent of the adversary’s view in game <span class="math">\\mathbf{G}_{5}</span>. The string <span class="math">s^{+}</span> is also independent of the adversary’s view. Further, the behavior of Type III decryption oracle queries are also not consistent with the random oracles.</p>

    <p class="text-gray-300">Despite these differences, however, games <span class="math">\\mathbf{G}_{4}</span> and <span class="math">\\mathbf{G}_{5}</span> proceed identically until the string <span class="math">s^{+}</span> appears in <span class="math">\\mathcal{S}</span> or either the adversary or a Type I decryption oracle invocation queries <span class="math">H_{1}</span> on inputs (EG, PEH), where EG is an encoding of <span class="math">\\tilde{\\mathbf{g}}^{<em>}</span> and PEH is the partial encoding of <span class="math">x\\tilde{\\mathbf{g}}^{</em>}</span>.</p>

    <p class="text-gray-300">Let <span class="math">F_{5a}</span> be the event that in game <span class="math">\\mathbf{G}_{5}</span>, the string <span class="math">s^{+}</span> appears in <span class="math">\\mathcal{S}</span> at some point in time. Let <span class="math">F_{5b}</span> be the event that either the adversary or a Type I decryption oracle invocation queries <span class="math">H_{1}</span> on inputs (EG, PEH), where EG is an encoding of <span class="math">\\tilde{\\mathbf{g}}^{<em>}</span> and PEH is the partial encoding of <span class="math">x\\tilde{\\mathbf{g}}^{</em>}</span>. Let <span class="math">F_{5}=F_{5a}\\vee F_{5b}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since games <span class="math">\\mathbf{G}_{4}</span> and <span class="math">\\mathbf{G}_{5}</span> proceed identically until the point where <span class="math">F_{5}</span> occurs, we have <span class="math">\\Pr[S_{4}\\wedge\\neg F_{5}]=\\Pr[S_{5}\\wedge\\neg F_{5}]</span>. Applying Lemma 1 with <span class="math">(S_{4},S_{5},F_{5})</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{4}]-\\Pr[S_{5}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{5}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">s^{+}</span> is independent of the adversary’s view, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{5a}]\\leq(q_{0}+q_{D})2^{-SeedLen}.</span></p>

    <p class="text-gray-300">Now, <span class="math">\\Pr[F_{5b}]</span> is bounded by <span class="math">(1+2^{-128})</span> times the probability that an adversary <span class="math">A^{\\prime}</span> — running in expected time nearly the same as the running time of the original adversary <span class="math">A</span> — can construct a list of <span class="math">O(q_{1}+q_{D})</span> group elements, one of which contains a solution to a given instance of the CDH problem.</p>

    <p class="text-gray-300">This algorithm runs by taking a random instance <span class="math">(\\mathbf{g},\\mathbf{h},\\tilde{\\mathbf{g}}^{+})</span> of the CDH problem as input, and runs <span class="math">A</span> against a slightly modified version of game <span class="math">\\mathbf{G}_{5}</span>. In this modified game, we use the given values <span class="math">\\mathbf{g},\\mathbf{h}</span> to form the public key in game <span class="math">\\mathbf{G}_{5}</span>, Also, we use the given value <span class="math">\\tilde{\\mathbf{g}}^{+}</span>, instead of deriving it from <span class="math">u^{+}</span> (note that <span class="math">u^{+}</span> is not used anywhere else in game <span class="math">\\mathbf{G}_{5}</span>). Finally, to implement this algorithm, we simulate the random oracles in the usual way, using standard hash table techniques. We also use standard hash table techniques to implement the Type I decryption oracle queries, as modified in game <span class="math">\\mathbf{G}_{3}</span>. The factor <span class="math">(1+2^{-128})</span> comes from the fact that the distribution of <span class="math">\\tilde{\\mathbf{g}}+</span> in game <span class="math">\\mathbf{G}_{5}</span> is slightly non-uniform, whereas we assume the corresponding value in the CDH instance is uniformly distributed.</p>

    <p class="text-gray-300">From this, it follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\begin{array}[]{rcl}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{4}]-\\Pr[S_{5}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&\\leq&Advantage_{CDH}(A^{\\prime},O(q_{1}+q_{D}))(1+2^{-128})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&&(q_{0}+q_{D})2^{-SeedLen},\\end{array}+ \\] (5)</p>

    <p class="text-gray-300">where <span class="math">Advantage_{CDH}</span> is as defined in §14.1.</p>

    <p class="text-gray-300">It is also clear that in game <span class="math">\\mathbf{G}_{5}</span>, the hidden bit <span class="math">b</span> is independent of all values directly or indirectly accessible to the adversary. Hence,</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{5}]=1/2.</span> (6)</p>

    <p class="text-gray-300">Putting together (1), (2), (3), (4), (5), (6), we obtain</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{rcl}Advantage_{PSEC\\text{-}KEM}(A)&\\leq&(q_{0}+2q_{D})\\mu^{-1}(1+2^{-128})~{}+\\\\ &&Advantage_{CDH}(A^{\\prime},O(q_{1}+q_{D}))(1+2^{-128})~{}+\\\\ &&(q_{0}+q_{D})2^{-SeedLen}.\\end{array} \\] (7)</p>

    <h2 id="sec-77" class="text-2xl font-bold">17 ACE-KEM</h2>

    <p class="text-gray-300">In this section, we present a variant of the ACE-Encrypt submission. Several changes were made to the original submission, so that the resulting scheme fits into our frameworks for hybrid and Diffie-Hellman-based encryption. This variant is a key encapsulation mechanism that we call ACE-KEM.</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">17.1 Key Generation</h3>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">Group=({\\cal H},{\\cal G},{\\bf g},\\mu,\\nu,{\\cal E},{\\cal D},{\\cal E}^{\\prime},{\\cal D}^{\\prime})</span></p>

    <p class="text-gray-300">is chosen. In what follows, we let <span class="math">{\\bf g}_{1}={\\bf g}</span>.</p>

    <p class="text-gray-300">An additional parameter, CofactorMode, must be specified. This parameter takes the value 0 or 1. Here are the rules which should be obeyed in setting this parameter.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\nu=1</span>, then CofactorMode should be 0.</li>

      <li>If <span class="math">\\nu&gt;1</span>, CofactorMode may be set to 1 provided <span class="math">\\gcd(\\mu,\\nu)=1</span>.</li>

    </ul>

    <p class="text-gray-300">In addition to Group, a hash function Hash (see §11) and key derivation function KDF (see §12) must be chosen. It is required that and that Hash.OutputLen <span class="math">&lt;\\log_{256}\\mu</span>.</p>

    <p class="text-gray-300">Since we want KDF to be a good entropy smoothing function, one should select either KDF3 or KDF4. As discussed in §12, the functions KDF1 and KDF2 are not recommended.</p>

    <p class="text-gray-300">Next, numbers <span class="math">w,x,y,z\\in\\{0,\\ldots,\\mu-1\\}</span> are chosen at random, and the group elements</p>

    <p class="text-gray-300"><span class="math">{\\bf g}_{2}=w\\cdot{\\bf g}_{1},~{}{\\bf c}=x\\cdot{\\bf g}_{1},~{}{\\bf d}=y\\cdot{\\bf g}_{1},~{}{\\bf h}=z\\cdot{\\bf g}_{1}</span></p>

    <p class="text-gray-300">are computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group, the group elements <span class="math">{\\bf g}_{2},{\\bf c},{\\bf d},{\\bf h}</span>, and an indication of the choice of Hash and KDF. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key, together with the numbers <span class="math">w,x,y,z</span>, and the value of CofactorMode.</p>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">17.2 Encryption</h3>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext <span class="math">C_{0}</span> that is an encryption of a key <span class="math">K</span>, where <span class="math">K</span> is a byte string of length KeyLen = ACE-KEM.OutputKeyLen.</p>

    <p class="text-gray-300">In addition to the recipient’s public key, the encryption algorithm takes an optional format argument, which is used to specify the format for group element encodings.</p>

    <p class="text-gray-300">The encryption scheme works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">r\\in\\{0,\\ldots,\\mu-1\\}</span>.</li>

    </ol>

    <p class="text-gray-300">2.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute group elements</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{1}=r\\cdot\\mathbf{g}_{1},\\ \\mathbf{u}_{2}=r\\cdot\\mathbf{g}_{2},\\ \\tilde{\\mathbf{h}}=r\\cdot\\mathbf{h}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the byte strings</li>

    </ol>

    <p class="text-gray-300"><span class="math">EU1=\\mathcal{E}(\\mathbf{u}_{1},\\textit{format}),\\ EU2=\\mathcal{E}(\\mathbf{u}_{2},\\textit{format}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the number</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\alpha=\\textit{OS2IP}(\\textit{Hash.eval}(\\textit{EU1}\\parallel\\textit{EU2})).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the number</li>

    </ol>

    <p class="text-gray-300"><span class="math">r^{\\prime}=\\alpha\\cdot r\\ \\text{mod}\\ \\mu.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the group element</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{v}=r\\cdot\\mathbf{c}+r^{\\prime}\\cdot\\mathbf{d}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the ciphertext</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{0}=\\textit{EU1}\\parallel\\textit{EU2}\\parallel\\mathcal{E}(\\mathbf{v},\\textit{format})</span></p>

    <p class="text-gray-300">and the key</p>

    <p class="text-gray-300"><span class="math">K=\\textit{KDF}(\\textit{EU1}\\parallel\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}}),\\textit{KeyLen}).</span></p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">17.3 Decryption</h3>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext <span class="math">C_{0}</span> along with the private key.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the ciphertext as <span class="math">\\textit{EU1}\\parallel\\textit{EU2}\\parallel\\textit{EV}</span>, where EU1 encodes the group element <span class="math">\\mathbf{u}_{1}</span>, EU2 encodes the group element <span class="math">\\mathbf{u}_{2}</span>, and EV encodes the group element <span class="math">\\mathbf{v}</span>. If this step fails, then fail.</li>

    </ol>

    <p class="text-gray-300">Also, one must check that EU1, EU2, and EV are all encoded using the same format; if not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\textit{CofactorMode}=1</span>, set</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\hat{\\mathbf{u}}_{1}=\\nu\\cdot\\mathbf{u}_{1},\\ \\hat{w}=\\nu^{-1}w\\ \\text{mod}\\ \\nu,\\ \\hat{x}=\\nu^{-1}x\\ \\text{mod}\\ \\nu,\\ \\hat{y}=\\nu^{-1}y\\ \\text{mod}\\ \\nu,\\ \\hat{z}=\\nu^{-1}z\\ \\text{mod}\\ \\nu;</span></p>

    <p class="text-gray-300">otherwise, set</p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathbf{u}}_{1}=\\mathbf{u}_{1},\\ \\hat{w}=w,\\ \\hat{x}=x,\\ \\hat{y}=y,\\ \\hat{z}=z.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\textit{CofactorMode}\\neq 1</span> and <span class="math">\\nu&gt;1</span>, test if <span class="math">\\mathbf{u}_{1}\\in\\mathcal{G}</span>. If not, then fail.</li>

      <li>Compute the number</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\alpha=\\textit{OS2IP}(\\textit{Hash.eval}(\\textit{EU1}\\parallel\\textit{EU2}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the number</li>

    </ol>

    <p class="text-gray-300"><span class="math">t=\\hat{x}+\\hat{y}\\alpha\\ \\text{mod}\\ \\mu.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Test if</li>

    </ol>

    <p class="text-gray-300"><span class="math">w\\cdot\\hat{\\mathbf{u}}_{1}=\\mathbf{u}_{2}\\ \\text{and}\\ t\\cdot\\hat{\\mathbf{u}}_{1}=\\mathbf{v}.</span></p>

    <p class="text-gray-300">If not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the group element</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathbf{h}}=\\hat{z}\\cdot\\hat{\\mathbf{u}}_{1}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the key</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$K=\\mathit{KDF}(\\mathit{EU1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathcal{E}^{\\prime}(\\tilde{\\mathbf{h}}),\\mathit{KeyLen}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">17.4 Some remarks</h3>

    <p class="text-gray-300">For security reasons, one should always perform all of the computations in step 6 of the decryption algorithm; otherwise, some “timing” information could be gained by the adversary that is not available to it in the formal proof of security. Note, however, that we know of no actual attack based on such timing information, nor is such an attack at all likely.</p>

    <p class="text-gray-300">Also note that unlike <em>ECIES</em>, a value of <span class="math">\\mathbf{0}</span> for <span class="math">\\tilde{\\mathbf{h}}</span> is perfectly legal, and therefore, the function <span class="math">\\mathcal{E}^{\\prime}</span> must be well defined at <span class="math">\\mathbf{0}</span>. It was felt that making the restriction that <span class="math">\\tilde{\\mathbf{h}}\\neq\\mathbf{0}</span> would only complicate the scheme, with no tangible benefit.</p>

    <p class="text-gray-300">Using <span class="math">\\mathit{CofactorMode}=1</span> may yield a performance benefit if <span class="math">\\nu</span> is fairly small. Note that in this mode, an implementation could simply pre-compute and store the values <span class="math">\\hat{w},\\hat{x},\\hat{y},\\hat{z}</span>, instead of the values <span class="math">w,x,y,z</span>.</p>

    <h3 id="sec-82" class="text-xl font-semibold mt-8">17.5 Security considerations</h3>

    <p class="text-gray-300">This scheme differs in only very minor ways from schemes that have been rigorously analyzed in the literature. It most closely resembles the variation of the Cramer-Shoup scheme discussed in detail in <em>[x21]</em>.</p>

    <p class="text-gray-300">The security of the scheme is based on the DDH (see §14.2), and a few other <em>specific</em> assumptions about the hash and key derivation functions. The security reduction is quite tight. One can easily verify the following, using following the line of reasoning in <em>[x1]</em> and <em>[x21]</em>.</p>

    <p class="text-gray-300"><span class="math">\\mathit{Advantage}_{\\mathit{ACE\\text{-}KEM}}(A)</span> <span class="math">=O(</span> <span class="math">\\mathit{Advantage}_{\\mathit{DDH}}(A_{1})+</span> <span class="math">\\mathit{Advantage}_{\\mathit{Hash}}(A_{2})+</span> <span class="math">\\mathit{Advantage}_{\\mathit{KDF}}(A_{3})+</span> <span class="math">q_{D}\\cdot\\mu^{-1}\\ ),</span></p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A_{1},A_{2},A_{3}</span> denote adversaries that run in time essentially the same as <span class="math">A</span>.</li>

      <li><span class="math">\\mathit{Advantage}_{\\mathit{DDH}}</span> is as defined in §14.2.</li>

      <li><span class="math">\\mathit{Advantage}_{\\mathit{Hash}}(A)</span> denotes the probability that an adversary <span class="math">A</span>, given encodings <span class="math">\\mathit{EU1}^{<em>}</span> and <span class="math">\\mathit{EU2}^{</em>}</span> of two independent, random elements in <span class="math">\\mathcal{G}</span>, can find encodings <span class="math">\\mathit{EU1}</span> and <span class="math">\\mathit{EU2}</span> of elements in <span class="math">\\mathcal{G}</span>, such that <span class="math">(\\mathit{EU1},\\mathit{EU2})\\neq(\\mathit{EU1}^{<em>},\\mathit{EU2}^{</em>})</span>, but</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathit{Hash.eval}(\\mathit{EU1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathit{EU2})=\\mathit{Hash.eval}(\\mathit{EU1}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathit{EU2}^{*}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If the group supports multiple encodings, the adversary can choose the format it wants when <span class="math">\\mathit{EU1}^{<em>}</span> and <span class="math">\\mathit{EU2}^{</em>}</span> are generated; furthermore, the adversary may choose to use the same or</p>

    <p class="text-gray-300">different formats in its choice of EU1 and EU2; however, EU1^{∗} and EU2^{∗} must be encoded using the same format, and the same holds for EU1 and EU2.</p>

    <p class="text-gray-300">If CofactorMode <span class="math">=1</span>, then the adversary may choose EU1 to be an encoding of an element of <span class="math">\\mathcal{H}</span> that does not necessarily lie in <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">Note that this problem is a second-preimage collision problem, which is generally believed to be a much harder problem to solve than the problem of finding an arbitrary pair of colliding inputs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Advantage_{KDF}(<span class="math">A</span>) denotes the advantage that an adversary <span class="math">A</span> has in distinguishing between the following two distributions. Let <span class="math">\\mathbf{u}_{1}</span> and <span class="math">\\hat{\\mathbf{h}}</span> be independent, random elements of <span class="math">\\mathcal{G}</span>, and let EU1 be an encoding of <span class="math">\\mathbf{u}_{1}</span>. Let <span class="math">R</span> be a random byte string of length KeyLen. The first distribution is <span class="math">(R,\\text{EU1})</span>, and the second is $(KDF(\\text{EU1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathcal{E}^{\\prime}(\\hat{\\mathbf{h}}),\\text{KeyLen}),\\text{EU1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q_{D}</span> bounds the number of decryption oracle queries made by the adversary <span class="math">A</span>.</li>

    </ul>

    <p class="text-gray-300">The “O” above represents a very small constant, which we have not computed exactly.</p>

    <p class="text-gray-300">The reader is referred to <em>[x10]</em> for a detailed proof of a slight variant of this security claim. The situation in that paper is slightly different from the one here: in that paper, there is no notion of a label, no CofactorMode, and group elements are assumed to have unique encodings. Nevertheless, the proof presented there can be easily adapted to the situation here, with little change.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">17.6 Further remarks</h3>

    <h4 id="sec-84" class="text-lg font-semibold mt-6">17.6.1 Random oracles and interactive assumptions</h4>

    <p class="text-gray-300">We emphasize that this scheme can be proved secure under reasonable intractability assumptions, without resorting to either the random oracle heuristic, and without using “interactive” intractability assumptions as in done in <em>[x1]</em>.</p>

    <p class="text-gray-300">We stress that a proof of security in the random oracle model is not a proof with “just another assumption.” One is not assuming a hash function is a random function, since this assumption is patently false. The random oracle model is a heuristic, and a proof of security in the random oracle model does not directly imply anything about the security of a system “in the real world.”</p>

    <p class="text-gray-300">We also stress that interactive intractability assumptions, like in <em>[x1]</em>, are qualitatively much stronger than standard intractability assumptions. Indeed, it can be argued that the main activity of theoretical cryptography is to show that breaking a cryptosystem via some kind of subtle, interactive attack is at least as hard as solving some specific, non-interactive problem.</p>

    <p class="text-gray-300">ACE-KEM can also be proved secure in the random oracle model under the CDH assumption (see <em>[x27]</em>), although the reduction is not nearly as tight as for PSEC-KEM. Indeed, the tightness of the reduction for PSEC-KEM and the efficiency of PSEC-KEM are the main reasons for including PSEC-KEM in this proposal.</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">17.6.2 ACE-KEM and ECIES-KEM</h4>

    <p class="text-gray-300">One should also note that ACE-KEM is no less secure than ECIES-KEM in a very strong sense. Indeed, assuming the two cryptosystems use the same parameters, then one can show that any adversary <span class="math">A</span> that breaks ACE-KEM can be converted into an adversary <span class="math">A^{\\prime}</span> with about the same running time that breaks ECIES-KEM with the same advantage.</p>

    <p class="text-gray-300">To see this, consider an ECIES-KEM public key containing the group element <span class="math">\\mathbf{h}</span>. Upon obtaining this public key, <span class="math">A^{\\prime}</span> generates <span class="math">w,x,y</span> at random modulo <span class="math">\\mu</span>, and then chooses <span class="math">w,x,y\\in\\{0,\\ldots,\\mu-1\\}</span></p>

    <p class="text-gray-300">at random, and constructs the ACE-KEM public key <span class="math">(\\mathbf{g}_{2},\\mathbf{c},\\mathbf{d},\\mathbf{h})</span>, where <span class="math">\\mathbf{g}_{2}=w\\mathbf{g}</span>, <span class="math">\\mathbf{c}=x\\mathbf{g}</span>, and <span class="math">\\mathbf{d}=y\\mathbf{g}</span>. <span class="math">A^{\\prime}</span> then runs adversary <span class="math">A</span> using this public key.</p>

    <p class="text-gray-300">Now, whenever the adversary <span class="math">A</span> makes a decryption oracle query, then knowing <span class="math">w,x,y</span>, adversary <span class="math">A^{\\prime}</span> performs the extra validity tests of ACE-KEM, and if these pass, it uses the decryption oracle of ECIES-KEM to obtain the decrypted symmetric key, giving this to <span class="math">A</span>.</p>

    <p class="text-gray-300">When <span class="math">A</span> invokes the encryption oracle for ACE-KEM, <span class="math">A^{\\prime}</span> invokes the encryption oracle for ECIES-KEM, obtaining an encoding of a group element <span class="math">\\mathbf{u}_{1}^{*}</span>. Then using <span class="math">w,x,y</span>, <span class="math">A^{\\prime}</span> easily constructs the remaining components of a corresponding ACE-KEM ciphertext, and gives this to <span class="math">A</span>.</p>

    <p class="text-gray-300">One needs to check that <span class="math">A^{\\prime}</span> carries out a legal chosen ciphertext attack, i.e., that <span class="math">A^{\\prime}</span> never attempts to submit the target ciphertext to the decryption oracle subsequent to the invocation of the encryption oracle. But this follows easily from the following claim: for any two valid ACE-KEM ciphertexts <span class="math">C_{0}=EU1\\parallel EU2\\parallel EV</span> and <span class="math">C_{0}^{+}=EU1^{+}\\parallel EU2^{+}\\parallel EV^{+}</span>, if <span class="math">EU1=EU1^{+}</span>, then <span class="math">C_{0}=C_{0}^{+}</span>. Note that this claim relies on the fact that the validity test for a ciphertext <span class="math">C_{0}</span> as above ensures that <span class="math">EU1</span>, <span class="math">EU2</span>, and <span class="math">EV</span> are encoded using the same format. If this were not done, then simply by replacing <span class="math">EU2</span> or <span class="math">EV</span> by a different encoding of the same group element, one would violate the above claim.</p>

    <p class="text-gray-300">When <span class="math">A</span> terminates and outputs a bit <span class="math">\\hat{b}</span>, <span class="math">A^{\\prime}</span> also terminates and outputs the same thing.</p>

    <p class="text-gray-300">It is easily seen that this simulation is perfect, and that whatever advantage <span class="math">A</span> has in breaking ACE-KEM, <span class="math">A^{\\prime}</span> has the same advantage in breaking ECIES-KEM.</p>

    <p class="text-gray-300">We have left one detail out of the above proof: in ECIES-KEM, the Diffie-Hellman public keys may not be zero, whereas in ACE-KEM, they may be. We leave it to the reader to adjust the above proof to accommodate this detail.</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">17.6.3 ACE-Encrypt and ACE-KEM</h4>

    <p class="text-gray-300">We outline the major differences between ACE-Encrypt and ACE-KEM.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We have generalized the algorithm to work with an arbitrary, abstract group, and to work with an arbitrary message authentication code and symmetric key encryption scheme.</li>

      <li>We have chosen not to use the rather specialized universal one-way hash function to compute the quantity <span class="math">\\alpha</span>. Instead, we use a standard cryptographic hash, and make a specific — but reasonable — “second preimage collision resistance” assumption.</li>

    </ul>

    <p class="text-gray-300">The proposed standard need not necessarily preclude the possibility of using such a specialized hash function, so long as we allow such a hash to have a variable length key that is stored in the public key.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We have chosen not to use the rather specialized entropy-smoothing hash function to derive the key <span class="math">K</span>. Instead, we again use a standard cryptographic hash, and make a specific — but again, reasonable — “entropy smoothing” assumption.</li>

    </ul>

    <p class="text-gray-300">The proposed standard need not necessarily preclude the possibility of using such a specialized hash function, so long as we allow such a hash to have a variable length key that is stored in the public key.</p>

    <p class="text-gray-300">18 RSA-OAEP</p>

    <h3 id="sec-87" class="text-xl font-semibold mt-8">18.1 Message encoding functions</h3>

    <p class="text-gray-300">OAEP-EME is a fully specified version of Bellare and Rogaway’s original OAEP scheme for message encoding <em>[x1]</em>.</p>

    <p class="text-gray-300">In general, a message encoding scheme EME of this type specifies two algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EME.Encode(<span class="math">M,L,E</span>Len) takes as input a message <span class="math">M</span> and a label <span class="math">L</span>, and an output length ELen. Here, <span class="math">M</span> and <span class="math">L</span> are byte strings whose lengths are bounded, as described below. It outputs a byte string <span class="math">E</span> of length ELen.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- EME.Decode(<span class="math">E,L</span>) takes as input a byte string <span class="math">E</span> and a label <span class="math">L</span>. It attempts to find a message <span class="math">M</span> such that EME.Encode($M,L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=E.<span class="math"> It returns </span>M<span class="math"> if such an </span>M$ exists, and otherwise fails.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition to this, the mechanism should specify a bound EME.Bound such that when EME.Encode(<span class="math">M,L,E</span>Len) is invoked, the condition $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq<span class="math"> ELen</span>-EME.Bound<span class="math"> should hold; if not, the encoding algorithm fails. Additionally, the encoding algorithm may also fail if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ exceeds some (very large) implementation-defined bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The algorithm EME.Encode will in general be probabilistic, so that the same message can be encoded in a number of ways.</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">18.2 OAEP-EME</h3>

    <p class="text-gray-300">We now describe OAEP-EME.</p>

    <p class="text-gray-300">The scheme is parameterized by a hash function Hash (see §11) and a key derivation function KDF (see §12). Current standards, as well as the RSA-OAEP submission to ISO, recommend the use of the function KDF1 using Hash. Let HLen<span class="math">\\,=</span> Hash.OutputLen.</p>

    <p class="text-gray-300">The quantity OAEP-EME.Bound is defined as</p>

    <p class="text-gray-300"><span class="math">\\mbox{{OAEP-EME.Bound}}=2\\cdot\\mbox{{HLen}}+1.</span></p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">18.2.1 Encoding function</h4>

    <p class="text-gray-300">The algorithm OAEP-EME.Encode(<span class="math">M,L,E</span>Len) runs as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Check that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq<span class="math"> ELen</span>-2\\cdot\\mbox{{HLen}}-1$; if not, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a random byte string <span class="math">r</span> of length HLen.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Let pad be the byte string of length ELen$-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2\\cdot\\mbox{{HLen}}$ consisting of a sequence of 0-bytes, followed by a single 1-byte.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">x=\\mbox{{Hash.eval}}(L)\\parallel\\mbox{{pad}}\\parallel M</span>.</li>

      <li>Set <span class="math">s=\\mbox{{KDF}}(r,\\mbox{{ELen}}-\\mbox{{HLen}})\\oplus x</span>.</li>

      <li>Set <span class="math">t=\\mbox{{KDF}}(s,\\mbox{{HLen}})\\oplus r</span>.</li>

      <li>Output <span class="math">E=t\\parallel s</span>.</li>

    </ol>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">18.2.2 Decoding function</p>

    <p class="text-gray-300">The algorithm OAEP-EME.Decode<span class="math">(E,L)</span> runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let ELen = $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check if ELen <span class="math">\\geq 2\\cdot</span> HLen + 1; if not, then fail.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Parse <span class="math">E</span> as <span class="math">E=t\\parallel s</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> = HLen and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ = ELen - HLen.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">r</span> = KDF<span class="math">(s,\\text{HLen})\\oplus t</span>.</li>

      <li>Set <span class="math">x</span> = KDF<span class="math">(r,\\text{ELen}-\\text{HLen})\\oplus s</span>.</li>

      <li>Test that <span class="math">x</span> is of the form <span class="math">x</span> = Hash.eval<span class="math">(L)\\parallel\\text{pad}\\parallel M</span>, where pad is a byte string consisting of zero or more 0-bytes, followed by a 1-byte. If not, then fail.</li>

      <li>Output <span class="math">M</span>.</li>

    </ol>

    <h3 id="sec-90" class="text-xl font-semibold mt-8">18.3 RSA-OAEP</h3>

    <p class="text-gray-300">We describe a generic RSA encryption scheme, based on an arbitrary message encoding mechanism EME. If one uses OAEP-EME, the resulting scheme is called RSA-OAEP.</p>

    <p class="text-gray-300">RSA-OAEP is a bounded length public-key encryption scheme.</p>

    <h4 id="sec-91" class="text-lg font-semibold mt-6">18.3.1 Key generation</h4>

    <p class="text-gray-300">The public key consists of an RSA modulus <span class="math">n</span> that is the product of two large primes, and an exponent <span class="math">e</span>, where <span class="math">\\gcd(e,\\phi(n))=1</span>. It also specifies any parameters of EME (such as Hash and KDF, in the case of OAEP-EME). Let nLen denote the length, in bytes, of <span class="math">n</span>.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent <span class="math">d</span>, where <span class="math">ed\\equiv 1\\bmod\\phi(n)</span>.</p>

    <h4 id="sec-92" class="text-lg font-semibold mt-6">18.3.2 Encryption</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithm to encrypt a message <span class="math">M</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\text{nLen}-\\text{EME.Bound}-1<span class="math">, with label </span>L$ runs as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">E</span> = EME.Encode<span class="math">(M,L,\\text{nLen}-1)</span>.</li>

      <li>Set <span class="math">m</span> = OS2IP<span class="math">(E)</span>.</li>

      <li>Set <span class="math">c=m^{e}\\bmod n</span>.</li>

      <li>Output <span class="math">C</span> = I2OSP<span class="math">(c,\\text{nLen})</span>.</li>

    </ol>

    <h4 id="sec-93" class="text-lg font-semibold mt-6">18.3.3 Decryption</h4>

    <p class="text-gray-300">The algorithm to decrypt a ciphertext <span class="math">C</span> with label <span class="math">L</span> runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq\\text{nLen}$, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">c</span> = OS2IP<span class="math">(C)</span>.</li>

      <li>Check that <span class="math">c\\leq n-1</span>; if not, then fail.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">m=c^{d}</span> mod <span class="math">n</span>.</li>

      <li>Set <span class="math">E=I2OSP(m,nLen-1)</span>; note that this step may fail if <span class="math">m</span> is too large.</li>

      <li>Set <span class="math">M=EME.Decode(E,L)</span>; note that this step may fail.</li>

    </ol>

    <p class="text-gray-300">An implementation should take care not to reveal which of steps 5 or 6 fail. Such information could take the form of distinct error codes, or of timing information. In particular, it is recommended that both steps 5 and 6 should be performed, even if step 5 fails. If such precautions are not taken, an implementation may be vulnerable to Manger’s attack <em>[x18]</em>.</p>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">18.4 Defects of RSA-OAEP</h3>

    <p class="text-gray-300">RSA-OAEP suffers from two defects.</p>

    <p class="text-gray-300">The first is a security defect. It was a widely held belief that the general OAEP construction was secure against adaptive chosen ciphertext attack, assuming the underlying trapdoor permutation was one-way. This belief is based on a supposed random-oracle proof in <em>[x3]</em>. This of course would imply the security of RSA-OAEP in the random oracle model, assuming that RSA is one-way. However, it was recently shown in <em>[x23]</em> that the proof of security of the general OAEP construction was invalid, and further, the general construction can not be proven secure using standard proof techniques.</p>

    <p class="text-gray-300">This result by itself does not imply that RSA-OAEP is insecure; it simply invalidates the original justification of its security. In fact, in <em>[x23]</em>, it is shown that RSA-OAEP with <span class="math">e=3</span> is secure (in the random oracle model). This result is extended by <em>[x11]</em> to arbitrary <span class="math">e</span>. It should be noted however, that the security reduction is much less efficient in <em>[x11]</em> than that proposed in <em>[x3]</em> for OAEP.</p>

    <p class="text-gray-300">The fact that RSA-OAEP can be proved secure is essentially an accident. The proofs of security exploit particular algebraic properties of the RSA function.</p>

    <p class="text-gray-300">In <em>[x23]</em>, a slight variant of OAEP is presented, called OAEP+. A detailed proof of security is given, on the general assumption of a trapdoor one-way permutation. Moreover, the security reduction is much more efficient than that of <em>[x11]</em> or even <em>[x3]</em>.</p>

    <p class="text-gray-300">Another defect of RSA-OAEP is that it only encrypts messages of a bounded length. Because of this, RSA-OAEP is really only useful as a key encapsulation mechanism (see §3), and it is left to application engineers to implement a “digital envelope” for encrypting longer messages. See §2.1.2 for a discussion about why we believe that this standard should provide a complete solution to the “digital envelope” problem, rather than just a partial solution. Also, using RSA-OAEP for nothing more than key encapsulation completely wastes one of the main feature of OAEP, namely, its very good “message expansion” rate. Indeed, if all one wants to do with RSA is encapsulate a key, then one is better served using the RSA-KEM scheme in §20, as that method is both simpler and quantitatively more secure.</p>

    <p class="text-gray-300">Because of these two defects, we propose that the new ISO standard contain a variation of RSA-OAEP+ that offers both a higher level of security than RSA-OAEP, while at the same time introduces a standard for encrypting messages of arbitrary length using RSA.</p>

    <h2 id="sec-95" class="text-2xl font-bold">19 RSA-OAEP+</h2>

    <p class="text-gray-300">In this section, we propose a new encryption scheme, called RSA-OAEP+. It has better provable security properties than RSA-OAEP, and also provides a secure mechanism for encrypting messages</p>

    <p class="text-gray-300">of arbitrary length.</p>

    <h3 id="sec-96" class="text-xl font-semibold mt-8">19.1 Extended message encoding functions</h3>

    <p class="text-gray-300">To facilitate encryption of arbitrary length messages, we extend the notion of a message encoding scheme.</p>

    <p class="text-gray-300">In general, an extended message encoding scheme XEME specifies two algorithms:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- XEME.Encode(<span class="math">M,L,\\textit{ELen},\\textit{KeyLen}</span>) takes as input a message <span class="math">M</span>, a label <span class="math">L</span>, an encoding output length ELen, and a key output length KeyLen. Here, <span class="math">M</span> and <span class="math">L</span> are byte strings whose lengths are bounded, as described below. It outputs a pair <span class="math">(E,K)</span> of byte strings with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\textit{ELen}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\textit{KeyLen}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition to this, the mechanism should specify a bound XEME.Bound such that when XEME.Encode(<span class="math">M,L,\\textit{ELen},\\textit{KeyLen}</span>) is invoked, the condition $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\textit{ELen}-\\textit{XEME.Bound}<span class="math"> should hold; if not, the encoding algorithm fails. Additionally, the encoding algorithm may also fail if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ or KeyLen exceed some (very large) implementation-defined bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The algorithm XEME.Encode will in general be probabilistic, so that the same message can be encoded in a number of ways.</p>

    <h3 id="sec-97" class="text-xl font-semibold mt-8">19.2 OAEP+XEME</h3>

    <p class="text-gray-300">We now describe the extended message encoding scheme OAEP+XEME.</p>

    <p class="text-gray-300">The scheme is parameterized by a key derivation function KDF (see §12) and an integer MaskLen <span class="math">\\geq 1</span>. Any of the functions described in §12 are suitable.</p>

    <p class="text-gray-300">The quantity OAEP+XEME.Bound is defined as</p>

    <p class="text-gray-300"><span class="math">\\textit{OAEP+XEME.Bound}=2\\cdot\\textit{MaskLen}+1.</span></p>

    <p class="text-gray-300">Let <span class="math">(I0,I1,\\ldots)</span> denote the values <span class="math">(I2\\textit{OSP}(0,4),I2\\textit{OSP}(1,4),\\ldots)</span>.</p>

    <h4 id="sec-98" class="text-lg font-semibold mt-6">19.2.1 Encoding function</h4>

    <p class="text-gray-300">The algorithm OAEP+XEME.Encode(<span class="math">M,L,\\textit{ELen},\\textit{KeyLen}</span>) runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Check that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\textit{ELen}-2\\cdot\\textit{MaskLen}-1$; if not, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a random byte string <span class="math">r</span> of length MaskLen.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Let pad be the byte string of length $\\textit{ELen}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2\\cdot\\textit{MaskLen}$ consisting of a sequence of 0-bytes, followed by a single 1-byte.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">x=\\textit{pad}\\parallel M</span>.</li>

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\textit{check}=\\textit{KDF}(I0\\parallel r\\parallel x\\parallel I2\\textit{OSP}(\\textit{KeyLen},4)\\parallel L,\\textit{MaskLen}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">x^{\\prime}=KDF(I1\\mathop{\\parallel}r,\\text{\\it ELen}-2\\cdot\\text{\\it MaskLen})\\oplus x.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">s=\\text{\\it check}\\mathop{\\parallel}x^{\\prime}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">t=KDF(I2\\mathop{\\parallel}s,\\text{\\it MaskLen})\\oplus r.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output</li>

    </ol>

    <p class="text-gray-300"><span class="math">E=t\\mathop{\\parallel}s</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">K=KDF(I3\\mathop{\\parallel}r,\\text{\\it KeyLen}).</span></p>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">19.2.2 Decoding function</h4>

    <p class="text-gray-300">The algorithm OAEP+XEME.Decode(<span class="math">E,L</span>) runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let ELen $=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check if ELen <span class="math">\\geq 2\\cdot\\text{\\it MaskLen}+1</span>; if not, then fail.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Parse <span class="math">E</span> as <span class="math">E=t\\mathop{\\parallel}s</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math"> MaskLen and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math"> ELen </span>-$ MaskLen.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">r=KDF(I2\\mathop{\\parallel}s,\\text{\\it MaskLen})\\oplus t.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Parse <span class="math">s</span> as check <span class="math">\\mathop{\\parallel}x^{\\prime}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\\it check}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math"> MaskLen and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math"> ELen </span>-<span class="math"> </span>2\\cdot$ MaskLen.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set</li>

    </ol>

    <p class="text-gray-300"><span class="math">x=KDF(I1\\mathop{\\parallel}r,\\text{\\it ELen}-2\\cdot\\text{\\it MaskLen})\\oplus x^{\\prime}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Test if <span class="math">x</span> is of the form <span class="math">x=\\text{\\it pad}\\mathop{\\parallel}M</span>, where pad is a byte string consisting of zero or more 0-bytes, followed by a 1-byte; if not, then fail.</li>

      <li>Test if</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\text{\\it check}=KDF(I0\\mathop{\\parallel}r\\mathop{\\parallel}x\\mathop{\\parallel}I2\\text{\\it OSP}(\\text{\\it KeyLen},4)\\mathop{\\parallel}L,\\text{\\it MaskLen}).</span></p>

    <p class="text-gray-300">If not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">M</span> and</li>

    </ol>

    <p class="text-gray-300"><span class="math">K=KDF(I3\\mathop{\\parallel}r,\\text{\\it KeyLen}).</span></p>

    <p class="text-gray-300">This encoding scheme is very similar to that of <em>[x20]</em>. Besides a few inconsequential formatting changes, this scheme deals with a label <span class="math">L</span> and produces a key <span class="math">K</span> of length KeyLen. The scheme in <em>[x20]</em> does not deal with labels or key outputs at all. Notice that both KeyLen and <span class="math">L</span> are hashed into the value check — this is important for the security of the scheme.</p>

    <p class="text-gray-300">In general, we have kept the changes between OAEP-EME and OAEP+XEME minimal. But since some changes were anyway necessary, we took the liberty to propose a couple of further changes.</p>

    <p class="text-gray-300">The main change is that we use the function KDF in several places, and we insert the strings I0, I1, etc., into the different invocations of KDF. This is done so that these can be more properly modeled as independent random oracles, as required in the proof of security.</p>

    <p class="text-gray-300">19.3 RSA-OAEP+</p>

    <p class="text-gray-300">We describe a generic extended RSA encryption scheme that uses an arbitrary extended message encoding scheme XEME. If the OAEP+XEME encoding scheme is used, the resulting encryption scheme is called RSA-OAEP+. We call this an extended RSA encryption scheme, since it handles messages of arbitrary length.</p>

    <p class="text-gray-300">This scheme also makes use of a data encapsulation mechanism DEM (see §4); however, we do not require that DEM supports any labels.</p>

    <h4 id="sec-100" class="text-lg font-semibold mt-6">19.3.1 Key generation</h4>

    <p class="text-gray-300">Just as for RSA-OAEP, the public key consists of an RSA modulus <span class="math">n</span> that is the product of two large primes, and an exponent <span class="math">e</span>, where <span class="math">\\gcd(e,\\phi(n))=1</span>. It also specifies any parameters of XEME. Let nLen denote the length, in bytes, of <span class="math">n</span>.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent <span class="math">d</span>, where <span class="math">ed\\equiv 1\\bmod\\phi(n)</span>.</p>

    <h4 id="sec-101" class="text-lg font-semibold mt-6">19.3.2 Encrypting short messages</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To encrypt a message <span class="math">M</span> with label <span class="math">L</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\textit{nLen}-\\textit{XEME.Bound}-1$, one does the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">(E,K)=\\textit{XEME.Encode}(M,L,\\textit{nLen}-1,0)</span>; note that <span class="math">K</span> is the empty string.</li>

      <li>Set <span class="math">m=\\textit{OS2IP}(E)</span>.</li>

      <li>Set <span class="math">c=m^{e}\\bmod n</span>.</li>

      <li>Output <span class="math">C=\\textit{I2OSP}(c,\\textit{nLen})</span>.</li>

    </ol>

    <h4 id="sec-102" class="text-lg font-semibold mt-6">19.3.3 Decrypting short messages</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To decrypt a ciphertext <span class="math">C</span> with label <span class="math">L</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\textit{nLen}$, one does the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\textit{nLen}$, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">c=\\textit{OS2IP}(C)</span>.</li>

      <li>Check that <span class="math">c\\leq n-1</span>; if not, then fail.</li>

      <li>Set <span class="math">m=c^{d}\\bmod n</span>.</li>

      <li>Set <span class="math">E=\\textit{I2OSP}(m,\\textit{nLen}-1)</span>; note that this step may fail if <span class="math">m</span> is too large.</li>

      <li>Set <span class="math">(M,K)=\\textit{XEME.Decode}(E,L,0)</span>; note that this step may fail, and also that <span class="math">K</span> is the empty string.</li>

      <li>Output <span class="math">M</span>.</li>

    </ol>

    <p class="text-gray-300">As in the the case of RSA-OAEP, an implementation should reveal no information that would reveal to an adversary which of steps 5 or 6 fail.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">19.3.4 Encrypting long messages</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To encrypt a message <span class="math">M</span> with label <span class="math">L</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; nLen - XEME.Bound - 1$, one does the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let <span class="math">M = M_0 \\parallel M_1</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= nLen - XEME.Bound - 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">(E, K) = XEME.Encode(M_0, L, nLen - 1, DEM.KeyLen)</span>.</li>

      <li>Set <span class="math">m = OS2IP(E)</span>.</li>

      <li>Set <span class="math">c = m^e \\mod n</span>.</li>

      <li>Set <span class="math">C_0 = I2OSP(c, nLen)</span>.</li>

      <li>Encrypt <span class="math">M_1</span> under the key <span class="math">K</span> using <span class="math">DEM</span>, and let <span class="math">C_1</span> be the resulting ciphertext.</li>

      <li>Output the ciphertext <span class="math">C = C_0 \\parallel C_1</span>.</li>

    </ol>

    <p class="text-gray-300">19.3.5 Decrypting long messages</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To decrypt a ciphertext <span class="math">C</span> with label <span class="math">L</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; nLen$, one does the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">C</span> as <span class="math">C = C_0 \\parallel C_1</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= nLen$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">c = OS2IP(C_0)</span>.</li>

      <li>Check that <span class="math">c \\leq n - 1</span>; if not, then fail.</li>

      <li>Set <span class="math">m = c^d \\mod n</span>.</li>

      <li>Set <span class="math">E = I2OSP(m, nLen - 1)</span>; note that this step may fail if <span class="math">m</span> is too large.</li>

      <li>Set <span class="math">(M_0, K) = XEME.Decode(E, L, DEM.KeyLen)</span>. Note that this step may fail.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. Test if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= nLen - XEME.Bound - 1$; if not, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt <span class="math">C_1</span> under the key <span class="math">K</span> using <span class="math">DEM</span>, and let <span class="math">M_1</span> be the resulting message.</li>

      <li>Output <span class="math">M = M_0 \\parallel M_1</span>.</li>

    </ol>

    <p class="text-gray-300">As in the case of RSA-OAEP, an implementation should reveal no information that would reveal to an adversary which of steps 5 or 6 fail.</p>

    <p class="text-gray-300">19.4 Security considerations</p>

    <p class="text-gray-300">It is straightforward to adapt the proof of security in [Sho01] to show that this scheme is secure in the random oracle model against adaptive chosen ciphertext attack, assuming the RSA inversion problem is hard.</p>

    <p class="text-gray-300">That proof implies that for any adversary <span class="math">A</span>, its advantage in breaking the cryptosystem RSA-OAEP+ is bounded by</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Advantage}_{RSA-OAEP+} (A) = O\\left( \\begin{array}{l} \\text{Advantage}_{RSA} (A_1) + \\\\ \\text{Advantage}_{DEM} (A_2, l_1) + \\\\ q_D \\cdot q_{KDF} \\cdot 2^{-MaskLen} \\end{array} \\right) \\end{array}</span></div>

    <p class="text-gray-300">Here,</p>

    <p class="text-gray-300">50</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A_{1}</span> is an algorithm that runs in time roughly equivalent to that of <span class="math">A</span>, plus <span class="math">O(q_{KDF}^{2})</span> applications of the RSA function,</li>

      <li><span class="math">A_{2},A_{3}</span> are adversaries whose running times are about the same as <span class="math">A</span>,</li>

      <li><span class="math">Advantage_{RSA}(A)</span> denotes the success probability of an algorithm <span class="math">A</span> has in solving a random instance of the RSA inversion problem,</li>

      <li><span class="math">q_{D}</span> is a bound on the number of decryption oracle queries made by <span class="math">A</span>,</li>

      <li><span class="math">q_{KDF}</span> is a bound on the number of random oracle queries made by <span class="math">A</span>,</li>

      <li><span class="math">l_{1}</span> is a bound on the length of the target message, and</li>

      <li><span class="math">l_{2}</span> is a bound on the length of ciphertexts submitted to the decryption oracle.</li>

    </ul>

    <p class="text-gray-300">Note that this security reduction is actually somewhat more efficient than the original (and incorrect) security reduction for RSA-OAEP in <em>[x1]</em>. It is also far more efficient than the security reduction in <em>[x10]</em>. In that reduction, the algorithm <span class="math">A^{\\prime}</span> for inverting RSA is somewhat slower than that of RSA-OAEP+, but worse, if the advantage of <span class="math">A</span> is <span class="math">\\epsilon</span>, then the success probability of <span class="math">A^{\\prime}</span> is about <span class="math">\\epsilon^{2}</span>.</p>

    <p class="text-gray-300">Even though the security reduction for RSA-OAEP+ is tighter than that for RSA-OAEP, we should perhaps point out that because of the term <span class="math">O(q_{KDF}^{2})</span> in the running time of the RSA inversion algorithm, this reduction actually says very little about the security of, say, 1024-bit RSA. This is because one can (most likely) factor 1024-bit numbers in less time than that required by the implied RSA inversion algorithm. However, as pointed out in <em>[x27]</em>, for exponent <span class="math">e=3</span>, there is a much more efficient security reduction whose running time is linear in <span class="math">q_{KDF}</span>. Is this a reason recommend the use of <span class="math">e=3</span>? Perhaps. Alternatively, one can use the RSA-KEM scheme (see §20).</p>

    <p class="text-gray-300">Of course, if the security reduction for RSA-OAEP+ implies very little about concrete security, the security reduction for RSA-OAEP in <em>[x10]</em> says even less.</p>

    <h2 id="sec-103" class="text-2xl font-bold">20 RSA-KEM</h2>

    <p class="text-gray-300">We also suggest for possible inclusion in the ISO standard the following very simple version of RSA. It is based on the ideas in <em>[x1]</em>.</p>

    <p class="text-gray-300">The scheme we present is a key encapsulation mechanism (see §3), called RSA-KEM, which can be turned into an encryption scheme as described in §5.</p>

    <p class="text-gray-300">The main advantages of this scheme are its simplicity and the fact that it yields a much more efficient (and hence meaningful) security reduction compared to that for OAEP or OAEP+. The disadvantage is that ciphertexts are a little bit larger.</p>

    <h3 id="sec-104" class="text-xl font-semibold mt-8">20.1 Key generation</h3>

    <p class="text-gray-300">Just as for RSA-OAEP, the public key consists of an RSA modulus <span class="math">n</span> that is the product of two large primes, and an exponent <span class="math">e</span>, where <span class="math">\\gcd(e,\\phi(n))=1</span>. It also specifies a key derivation function KDF (see §12). Let nLen denote the length, in bytes, of <span class="math">n</span>.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent <span class="math">d</span>, where <span class="math">ed\\equiv 1\\bmod\\phi(n)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">20.2 Encryption</p>

    <p class="text-gray-300">Recall that RSA-KEM is a key encapsulation mechanism, and so the goal of the encryption algorithm is simply to produce a pseudo-random key <span class="math">K</span> of length <span class="math">\\mbox{{KeyLen}}=</span> RSA-KEM.OutputKeyLen and a ciphertext <span class="math">C_{0}</span> that encrypts <span class="math">K</span>.</p>

    <p class="text-gray-300">The encryption algorithm runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a random number <span class="math">r\\in\\{0,\\ldots,n-1\\}</span>.</li>

      <li>Compute <span class="math">y=r^{e}\\bmod n</span>.</li>

      <li>Compute <span class="math">K</span> = KDF(I2OSP(<span class="math">r,n</span>Len<span class="math">),</span> KeyLen$).</li>

      <li>Compute <span class="math">C_{0}</span> = I2OSP(<span class="math">y,n</span>Len<span class="math">)</span>.</li>

      <li>Output the ciphertext <span class="math">C_{0}</span> and the key <span class="math">K</span>.</li>

    </ol>

    <h3 id="sec-105" class="text-xl font-semibold mt-8">20.3 Decryption</h3>

    <p class="text-gray-300">Given a ciphertext <span class="math">C_{0}</span>, decryption runs as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Check that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ = nLen; if not, then fail.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">y</span> = OS2IP(<span class="math">C_{0}</span>).</li>

      <li>Check that <span class="math">y&lt;n</span>; if not, then fail.</li>

      <li>Compute <span class="math">r=y^{d}\\bmod n</span>.</li>

      <li>Compute <span class="math">K</span> = KDF(I2OSP(<span class="math">r,n</span>Len<span class="math">),</span> KeyLen$).</li>

      <li>Output the key <span class="math">K</span>.</li>

    </ol>

    <h3 id="sec-106" class="text-xl font-semibold mt-8">20.4 Security considerations</h3>

    <p class="text-gray-300">The security of RSA-KEM can be analyzed in the random oracle model in a manner very similar to that in <em>[x1]</em>, where we model the invocation of KDF as a random oracle query. It is easy to show that</p>

    <p class="text-gray-300"><span class="math">\\mbox{{Advantage}}_{RSA\\text{-}KEM}(A)\\leq\\mbox{{Advantage}}_{RSA}(A^{\\prime})+q_{D}/nBound,</span> (8)</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A^{\\prime}</span> is an algorithm for solving a random instance of the RSA problem that runs in time roughly the same as that of <span class="math">A</span>; more precisely, the running time is that of <span class="math">A</span>, plus the time to perform <span class="math">q_{KDF}</span> exponentiations modulo <span class="math">n</span>, where <span class="math">q_{KDF}</span> is a bound on the number of random oracle queries made by <span class="math">A</span>;</li>

      <li><span class="math">q_{D}</span> is a bound on the number of decryption oracle queries made by <span class="math">A</span>;</li>

      <li><span class="math">nBound</span> is an lower bound on <span class="math">n</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We sketch a proof of this. Let <span class="math">\\mathbf{G}_{0}</span> be the original attack game played by adversary <span class="math">A</span>, and let <span class="math">S_{0}</span> be the event that <span class="math">A</span> correctly guesses the hidden bit <span class="math">b</span> in game <span class="math">\\mathbf{G}_{0}</span>. Let <span class="math">H</span> denote the random oracle mapping elements of <span class="math">\\mathbf{Z}_{n}</span> to bit strings of length KeyLen. Let <span class="math">y^{<em>}\\in\\mathbf{Z}_{n}</span> denote the target ciphertext, and let <span class="math">r^{</em>}=(y^{*})^{1/e}\\in\\mathbf{Z}_{n}</span>.</p>

    <p class="text-gray-300">We next define a game <span class="math">\\mathbf{G}_{1}</span> that is the same as game <span class="math">\\mathbf{G}_{0}</span>, except that if the target ciphertext <span class="math">y^{*}</span> was submitted to the decryption oracle prior to the invocation of the encryption oracle, then the game is halted. Let <span class="math">S_{1}</span> be the event in game <span class="math">\\mathbf{G}_{1}</span> corresponding to the event <span class="math">S_{0}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_{1}</span> be the event that game <span class="math">\\mathbf{G}_{1}</span> is halted as above. Clearly, <span class="math">\\Pr[F_{1}]\\leq q_{D}/n\\textit{Bound}</span>, and since games <span class="math">\\mathbf{G}_{0}</span> and <span class="math">\\mathbf{G}_{1}</span> proceed identically until <span class="math">F_{1}</span> occurs, it follows by Lemma 1 that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_{D}/n\\textit{Bound}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We next define a game <span class="math">\\mathbf{G}_{2}</span> that is the same as <span class="math">\\mathbf{G}_{1}</span>, except that (1) the target ciphertext is generated at the beginning of the game, and (2) if the adversary ever queries <span class="math">H</span> at <span class="math">r^{*}</span>, we halt the game. Let <span class="math">S_{2}</span> be the event in game <span class="math">\\mathbf{G}_{2}</span> corresponding to the event <span class="math">S_{0}</span>.</p>

    <p class="text-gray-300">It is clear by construction that <span class="math">\\Pr[S_{2}]=1/2</span>, since the key <span class="math">H(r^{<em>})</span> is independent of everything else that is accessible to the adversary in game <span class="math">\\mathbf{G}_{2}</span>, either directly or indirectly. Indeed, only the encryption oracle evaluates <span class="math">H</span> at <span class="math">r^{</em>}</span> in this game.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">F_{2}</span> be the event that game <span class="math">\\mathbf{G}_{2}</span> is halted as above. It is clear that both games <span class="math">\\mathbf{G}_{1}</span> and <span class="math">\\mathbf{G}_{2}</span> proceed identically until <span class="math">F_{2}</span> occurs, and so by Lemma 1, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{2}]<span class="math">. Thus, it suffices to bound </span>\\Pr[F_{2}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{2}]\\leq\\textit{Advantage}_{RSA}(A^{\\prime})</span></p>

    <p class="text-gray-300">for an algorithm <span class="math">A^{\\prime}</span> that runs in time bounded as described above. The inequality (8) will follow immediately.</p>

    <p class="text-gray-300">Algorithm <span class="math">A^{\\prime}</span> runs as follows. It takes as input a random RSA modulus <span class="math">n</span>, an RSA exponent <span class="math">e</span>, and a random element <span class="math">y^{*}\\in\\mathbf{Z}_{n}</span>. It creates a public key using <span class="math">N</span> and <span class="math">e</span>, and then lets adversary <span class="math">A</span> run in game <span class="math">\\mathbf{G}_{2}</span>.</p>

    <p class="text-gray-300">When adversary <span class="math">A</span> invokes the encryption oracle, algorithm <span class="math">A^{\\prime}</span> responds to <span class="math">A</span> with the pair <span class="math">(K^{<em>},y^{</em>})</span>, where <span class="math">K^{<em>}</span> is a random bit string of length KeyLen, and <span class="math">y^{</em>}</span> is the above-mentioned input to <span class="math">A</span>.</p>

    <p class="text-gray-300">Algorithm <span class="math">A^{\\prime}</span> simulates the random oracle <span class="math">H</span> as well as the decryption oracle, as follows. For every input <span class="math">r\\in\\mathbf{Z}_{n}</span> to the random oracle, <span class="math">A^{\\prime}</span> computes <span class="math">y=r^{e}\\in\\mathbf{Z}_{n}</span>, and places the triple consisting of <span class="math">r</span>, <span class="math">y</span>, and the random value <span class="math">K=H(r)</span> in a table; however, if <span class="math">y=y^{*}</span>, algorithm <span class="math">A^{\\prime}</span> instead outputs <span class="math">r</span> and halts. When the adversary <span class="math">A</span> submits a ciphertext <span class="math">y\\in\\mathbf{Z}_{n}</span> to the decryption oracle, algorithm <span class="math">A^{\\prime}</span> looks up the value <span class="math">y</span> in the above table to determine if the random oracle has been evaluated at <span class="math">r=y^{1/e}\\in\\mathbf{Z}_{n}</span>. If so, algorithm <span class="math">A^{\\prime}</span> responds to the decryption oracle invocation with the value <span class="math">K=H(r)</span> stored in the table. Otherwise, algorithm <span class="math">A^{\\prime}</span> generates a fresh random key <span class="math">K</span>, and places the pair <span class="math">(y,K)</span> in a second table; moreover, if in the future the adversary <span class="math">A</span> should evaluate the random oracle at a point <span class="math">r\\in\\mathbf{Z}_{n}</span> such that <span class="math">r^{e}=y</span>, then the key <span class="math">K</span> generated above will be used for the value of <span class="math">H(r)</span>.</p>

    <p class="text-gray-300">It is clear that algorithm <span class="math">A^{\\prime}</span> perfectly simulates the view of <span class="math">A</span>, and that <span class="math">A^{\\prime}</span> outputs a solution to the given instance of the RSA problem with probability equal to <span class="math">\\Pr[F_{2}]</span>.</p>

    <p class="text-gray-300">That completes the proof of security.</p>

    <p class="text-gray-300">Quantitatively, it is clear that RSA-KEM provides a much better security reduction than RSA-OAEP+ (or RSA-OAEP). This advantage becomes even more pronounced when one analyzes the security of many messages encrypted under a single public key (as formally modeled in <em>[x1]</em>). In this setting, one can exploit the well-known random self-reducibility property of the</p>

    <p class="text-gray-300">RSA inversion problem to easily show that the security of RSA-KEM key encapsulation mechanism does not degrade at all as the number of ciphertexts increases. Note that this argument will be valid only if the number <span class="math">r</span> in the encryption algorithm for Simple RSA is chosen uniformly modulo <span class="math">n</span>, or at least with a distribution that is computationally indistinguishable from the uniform distribution.</p>

    <p class="text-gray-300">For RSA-OAEP+, the security degrades linearly with the number of ciphertexts, since one cannot use the random self-reducibility property, and must instead use a “hybrid argument.” The reason the random self-reducibility property cannot be used is that in RSA-OAEP+ (like RSA-OAEP) the ciphertext is not uniformly distributed modulo <span class="math">n</span>.</p>

    <p class="text-gray-300">We also mention that RSA-KEM does not appear to be as “fragile” as either RSA-OAEP or RSA-OAEP+, in the sense that there appears to be no possible attacks on an implementation, such as those in <em>[x11]</em>.</p>

    <h2 id="sec-107" class="text-2xl font-bold">21 Further actions</h2>

    <p class="text-gray-300">In this section, we summarize the next steps that must be taken to fully develop a standard.</p>

    <p class="text-gray-300">First, there are still a few gaps in the specifications that need to be filled in:</p>

    <p class="text-gray-300">We have yet to specify precisely what groups are allowed. One possibility is to simply adopt “wholesale” the choices allowable in IEEE P1363. We have yet to fully specify how group elements are to be encoded as byte strings. Again, one possibility is simply to adopt “wholesale” the encoding schemes in IEEE P1363. These choices are also yet to be specified. Again, one possibility is to simply adopt “wholesale” the choices allowable in IEEE P1363. However, the recommendations for KDF3 and KDF4 in the present proposal should be given some consideration. Also, for SKE’s, we might want to consider other choices than those available in IEEE P1363a, e.g., a “counter mode” use of a block cipher; further, we may wish to “harmonize” the notion of an SKE as used here with the symmetric-key encryption part of the larger ISO standard.</p>

    <p class="text-gray-300">Second, a decision must be made as to whether this standard should require or recommend a particular encoding for public keys, e.g., as ASN.1 encoded structures. An argument for doing this is that it could potentially greatly enhance adoption of the schemes in this standard.</p>

    <p class="text-gray-300">Third, a decision must be made as to whether the schemes proposed here are the ones we really want. There seemed to be some consensus at the ad hoc meeting in Santa Barbara that the selection proposed here was acceptable, with the understanding that the decision to include the schemes RSA-OAEP+ and RSA-KEM, which were proposed by the editor, should be taken later after further scrutiny and discussion. Also, a decision needs to be made as to whether all of the restrictions on ECIES discussed in §15.6 are appropriate, or whether some of these should be relaxed.</p>

    <p class="text-gray-300">Fourth, a full specification for EPOC-2, hopefully compatible with IEEE P1363a, needs to be developed for inclusion in a working draft.</p>

    <p class="text-gray-300">Fifth, this proposal must be converted to a proper draft standard. This entails separating out normative content (specifications) from informational content (rationale, security considerations, etc.), putting the latter in an annex. The intent is that the standard should contain almost all of the informational content that is in this proposal.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABR99] M. Abdalla, M. Bellare, and P. Rogaway. DHAES: an encryption scheme based on the Diffie-Hellma problem. Cryptology ePrint Archive, Report 1999/007, 1999. http://eprint.iacr.org.</li>

      <li>[BBM00] M. Bellare, A. Boldyreva, and S. Micali. Public-key encryption in a multi-user setting: security proofs and improvements. In Advances in Cryptology–Eurocrypt 2000, 2000.</li>

      <li>[BDPR98] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In Advances in Cryptology–Crypto ’98, pages 26–45, 1998.</li>

      <li>[BLK00] J. Baek, B. Lee, and K. Kim. Secure length-saving ElGamal encryption under the computational Diffie-Hellman assumption. In Proc. 5th Australian Conference on Information, Security, and Privacy, 2000.</li>

      <li>[Bon98] D. Boneh. The Decision Diffie-Hellman Problem. In Ants-III, pages 48–63, 1998. Springer LNCS 1423.</li>

      <li>[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</li>

      <li>[BR94] M. Bellare and P. Rogaway. Optimal asymmetric encryption. In Advances in Cryptology—Eurocrypt ’94, pages 92–111, 1994.</li>

      <li>[CGH98] R. Canetti, O. Goldreich, and S. Halevi. The random oracle model, revisited. In 30th Annual ACM Symposium on Theory of Computing, 1998.</li>

      <li>[CS98] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Advances in Cryptology–Crypto ’98, pages 13–25, 1998.</li>

      <li>[CS01] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. Cryptology ePrint Archive, Report 2001/108, 2001. http://eprint.iacr.org.</li>

      <li>[DDN91] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In 23rd Annual ACM Symposium on Theory of Computing, pages 542–552, 1991.</li>

      <li>[DDN98] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography, 1998. Manuscript (updated, full length version of STOC paper).</li>

      <li>[FO99] E. Fujisaki and T. Okamoto. Secure integration of asymmetric and symmetric encryption schemes. In Advances in Cryptology–Crypto ’99, pages 537–554, 1999.</li>

      <li>[FOPS01] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. In Advances in Cryptology–Crypto 2001, 2001.</li>

      <li>[JM96] D. Johnson and S. Matya. Asymmetric encryption: evolution and enhancements. Cryptobytes, 2(1), 1996. http://www.rsasecurity.com/rsalabs.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JN01] A. Joux and K. Nguyen. Separating Decision Diffie-Hellman from Diffie-Hellman in cryptographic groups. Cryptology ePrint Archive, Report 2001/003, 2001. http://eprint.iacr.org.</li>

      <li>[Luc00] S. Lucks. The sum of PRPs is a secure PRF. In Advances in Cryptology–Eurocrypt 2000, 2000.</li>

      <li>[Man01] J. Manger. A chosen ciphertext attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as standardized in PKCS # 1 v2.0. In Advances in Cryptology–Crypto 2001, pages 230–238, 2001.</li>

      <li>[NR97] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th Annual Symposium on Foundations of Computer Science, 1997.</li>

      <li>[OP01] T. Okamoto and D. Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Proc. 2001 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2001), 2001.</li>

      <li>[RS91] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In Advances in Cryptology–Crypto ’91, pages 433–444, 1991.</li>

      <li>[Sho97] V. Shoup. Lower bounds for discrete logarithms and related problems. In Advances in Cryptology–Eurocrypt ’97, 1997.</li>

      <li>[Sho00] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt 2000, 2000.</li>

      <li>[Sho01] V. Shoup. OAEP reconsidered. In Advances in Cryptology–Crypto 2001, 2001.</li>

      <li>[Sta96] M. Stadler. Publicly verifiable secret sharing. In Advances in Cryptology–Eurocrypt ’96, pages 190–199, 1996.</li>

    </ul>`;
---

<BaseLayout title="A Proposal for an ISO Standard for Public Key Encryption (2001/112)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2001 &middot; eprint 2001/112
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
