---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2001/112';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'A Proposal for an ISO Standard for Public Key Encryption';
const AUTHORS_HTML = 'Victor Shoup';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This document is an initial proposal for a draft for a forthcoming
ISO standard on public-key encryption.
It is hoped that this proposal will serve as a basis for discussion,
from which a consensus for a standard may be formed.</p>
    </section>

    <p class="text-gray-300">At its meeting on April 3-7 2000 in London, the ISO/IEC JTC 1/SC 27/WG 2 decided to put out a call for contributions for a proposed new project (NP 18033) on encryption algorithms. This call for contributions (document SC 27 N 2563) proposed four parts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>General</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Asymmetric Ciphers</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Block Ciphers</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Stream Ciphers</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The author of this document is currently the acting editor for the Asymmetric Ciphers part of the standard. This document deals exclusively with asymmetric ciphers, a.k.a., public-key encryption schemes.</p>

    <p class="text-gray-300">A number of submissions in response to the call for contributions were received, and are available as ISO document SC 27 N 2656. The author of the present document has carefully reviewed all of the submitted proposals for public-key encryption schemes.</p>

    <p class="text-gray-300">There were a number of different types of schemes submitted:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Some are based on the hardness of factoring integers or related problems.</li>
      <li>Some are Diffie-Hellman-based schemes of these, some are based on elliptic curves, and some are based on subgroups of Z &lowast; p .</li>
      <li>Some allow encryption of arbitrary length messages, and others only allow encryption of short messages.</li>
      <li>Some allow for additional data to be &quot;non-malleably bound&quot; to the ciphertext, while others do not.</li>
      <li>Some allow for messages and ciphertexts to be efficiently processed as &quot;streams,&quot; while others do not, requiring more than one pass over this data.</li>
      <li>Some have claims of &quot;provable&quot; security against adaptive chosen ciphertext attack some relying on the &quot;random oracle&quot; heuristic &mdash; some not. For several schemes, these claims of security have proven to be invalid upon closer scrutiny.</li>
    </ul>

    <p class="text-gray-300">Clearly, these submissions are quite incompatible in a number of respects, and one of the challenges of this project is to minimize these incompatibilities.</p>

    <p class="text-gray-300">Recently, an ad hoc meeting of the working group was held on August 21 in Santa Barbara, to further discuss the proposals in an earlier draft of this document. The current version of this proposal reflects the author's own vision for how this standard should develop, while at the same time, takes into account the discussions at the ad hoc meeting.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Goals of this document</h3>

    <p class="text-gray-300">The goals of this document are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To propose a standard functionality that a public-key encryption scheme should implement. This is essentially an abstract interface.</li>
      <li>To propose a &quot;unified framework&quot; for hybrid encryption. In order for a cryptosystem to be practical, it must be able to process messages that are arbitrary byte strings. There are traditional, and fairly well known &quot;hybrid&quot; schemes to do this: one first uses public-key techniques to derive a shared key, and then encrypts or decrypts the actual payload using symmetric-key techniques. We propose a fairly traditional and &quot;provably&quot; secure way of doing this.</li>
    </ul>

    <p class="text-gray-300">We shall refer to a method of generating a shared random key in this sense as a &quot;key encapsulation mechanism,&quot; and we shall refer to a method of encrypting the message using such a shared random key as a &quot;data encapsulation mechanism.&quot;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To propose a &quot;unified framework&quot; for Diffie-Hellman-based encryption schemes. This framework specifies an &quot;abstract group interface&quot; for a group so that any Diffie-Hellman-based encryption scheme can be specified with respect to an abstract group, but yet the group can be implemented in one of several ways, including as a subgroup of an elliptic curve group, and as a subgroup of Z &lowast; p . The interface is rich enough so as to support all of the subtleties and quirks found in many proposed cryptosystems, especially those using elliptic curves.</li>
      <li>To propose a set of encryption schemes such that each scheme    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>is &quot;provably&quot; secure against adaptive chosen ciphertext attack in some reasonable sense,</li>
      <li>conforms to the proposed abstract interface,</li>
      <li>conforms to the proposed unified framework for hybrid encryption (where applicable),</li>
      <li>conforms to the proposed unified framework for Diffie-Hellman-based encryption (where applicable),</li>
      <li>provides a fairly unique and attractive tradeoff between efficiency and security, and</li>
      <li>conforms to pre-existing standards (where applicable).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">In order to achieve the last goal of proposing a set of schemes meeting the stated requirements, we have taken several of the submitted schemes, and proposed modified schemes that meet the stated requirements. Some of these changes are quite minor, while others are more drastic. Some schemes were omitted altogether &mdash; given the limited amount of time and other resources available to construct this proposal for a standard, resources had to be concentrated on those schemes which appeared most likely to meet the stated objectives, either with or without minor modification.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Preliminary remarks on security</h3>

    <p class="text-gray-300">Typically, practical symmetric encryption schemes are designed &quot;from scratch,&quot; based partly on established design principles. The security of such a scheme is usually simply taken on faith there is no justification other than to demonstrate that reasonable design principles were employed in the design of the scheme, and to give (perhaps heuristic) arguments that the scheme resists known types of attacks.</p>

    <p class="text-gray-300">For public-key encryption schemes, the situation is somewhat different. Such a scheme is typically composed of a number of components: besides some kind of &quot;trapdoor&quot; cryptographic transform, there may also be various other components, such as hash functions, symmetric ciphers, etc. Because of this, it is customary nowadays to formally analyze the security of such a scheme relative to the security of its constituent components; that is, to prove the security of the scheme under the assumption that these components satisfy particular, explicit security requirements.</p>

    <p class="text-gray-300">Since proving the security of practical schemes in this way is often infeasible, a heuristic called the random oracle model is sometimes used in the proof. In this approach, a cryptographic hash function is modeled &mdash; for the purposes of analysis &mdash; as a &quot;black box&quot; containing a random function to which the adversary and the algorithms implementing the cryptosystem have &quot;oracle access.&quot; This approach has been used implicitly and informally for some time; however, it was formalized by Bellare and Rogaway [BR93], and has subsequently been used quite a bit in the cryptographic research community.</p>

    <p class="text-gray-300">We should stress, however, that the random oracle model is not just &quot;another assumption,&quot; like assuming that a hash function is collision resistant, or that a function is pseudo-random. It is a heuristic &quot;leap of faith&quot; &mdash; invoking this heuristic is qualitatively a much bigger step than making any particular cryptographic assumption. Indeed, in [CGH98], it is shown that there are cryptosystems that are secure in the random oracle model, but are insecure no matter what hash function is used to implement the random oracle.</p>

    <p class="text-gray-300">Despite these problems, the random oracle model is still a useful heuristic and design principle. A proof of security in the random oracle model is still much better than no proof at all, and certainly such a proof does rule out a large family of attacks.</p>

    <p class="text-gray-300">In judging the security of a &quot;provably secure&quot; scheme, there are several independent &quot;dimensions&quot;:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the use or non-use of the random oracle heuristic,</li>
      <li>the &quot;strength&quot; of the underlying assumptions, and</li>
      <li>the efficiency of the security reduction.</li>
    </ul>

    <p class="text-gray-300">Because of these several dimensions, the security of two &quot;provably secure&quot; schemes might be essentially incomparable. For example, one scheme might rely on the random oracle heuristic and a weak assumption, and the other might not use the random oracle heuristic but rely on a stronger assumption, or perhaps the assumptions are simply incomparable.</p>

    <p class="text-gray-300">The efficiency of a security reduction is an issue that is all too often ignored. However, it should be taken into account. For example, a scheme might be secure if RSA inversion is hard, but the security reduction may be so inefficient that for typical sizes of keys &mdash; say 1024-bit RSA modulus &mdash; the implied algorithm for solving the RSA inversion problem might be slower than the fastest currently known algorithm for factoring numbers.</p>

    <p class="text-gray-300">Even if the security reduction is very inefficient, it can still be argued that such a proof of security nevertheless provides a &quot;qualitative&quot; guarantee of security. Moreover, such a reduction does rule out attacks that would efficiently &quot;scale&quot; to larger sizes of keys.</p>

    <p class="text-gray-300">For public-key encryption schemes, it is widely agreed that the &quot;right&quot; notion of security for a scheme intended for general-purpose use is that of security against adaptive chosen ciphertext attack. This notion was introduced in [RS91], and implies other useful properties, like non-malleability. See [DDN91, DDN98, BDPR98] for further discussion. In this document, this will be the relevant notion of security used for judging the security of an encryption scheme.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 A summary of submissions and proposed schemes</h3>

    <p class="text-gray-300">In this section, we summarize the submissions that were made, give a very brief assessment of of the submissions, and briefly describe the schemes that we actually propose to be included in the standard.</p>

      <h4 id="sec-1.4.1" class="text-lg font-semibold mt-6">1.4.1 RSA-OAEP, RSA-OAEP+, and RSA-KEM</h4>

    <p class="text-gray-300">RSA-OAEP is the fairly well-established RSA encryption scheme, using the padding scheme OAEP invented by Bellare and Rogaway [BR94], with enhancements and refinements due to Johnson and Matyas [JM96].</p>

    <p class="text-gray-300">The submission coincides with the standards PKCS #1 v2.0 and IEEE P1363.<sup>1</sup></p>

    <p class="text-gray-300">One of the main supposed virtues of this scheme was an alleged proof in the random oracle model of security against adaptive chosen ciphertext attack, assuming RSA inversion is hard. This &quot;proof&quot; was published in [BR94], and despite years of public scrutiny, it was only recently observed in [Sho01] that not only is the proof invalid, but that there can be no standard proof via &quot;black box&quot; reduction for the OAEP construction in general, given an arbitrary one-way trapdoor permutation.</p>

    <p class="text-gray-300">This negative result does not necessarily imply that the specific instance RSA-OAEP is insecure. Indeed, as it turns out &mdash; essentially by accident, rather than design &mdash; RSA-OAEP is indeed secure in the random oracle model. This was proven for encryption exponent 3 in [Sho01], and for arbitrary encryption exponent in [FOPS01]. The security reduction is the latter paper is highly inefficient, however.</p>

    <p class="text-gray-300">Another problem with RSA-OAEP is that it only encrypts messages of short length. As such, many applications that use RSA-OAEP use it simply as a key encapsulation mechanism, which wastes one of the most attractive features of RSA-OAEP, namely, its fairly compact ciphertexts.</p>

    <p class="text-gray-300">To overcome these problems, we propose in this document a new scheme, called RSA-OAEP+. It is just as efficient as RSA-OAEP, but the general OAEP+ construction is provably secure in the random oracle model (as shown in [Sho01]). Moreover, even with RSA, the security reduction for OAEP+ is much more efficient than that in [FOPS01] for OAEP, making the scheme more attractive from a concrete security point of view. Also, RSA-OAEP+ is enhanced to deal with arbitrary-length messages in a very &quot;compact&quot; manner.</p>

    <p class="text-gray-300">Even with the security improvements provided by RSA-OAEP+, the security reduction is still so inefficient that the security guarantees provided are still not very meaningful in a strict, quantitative sense. For this reason, we also recommend an alternative RSA scheme which is both simpler and more secure, which we call RSA-KEM. This scheme is designed as a pure key encapsulation mechanism, and fits more nicely into our framework for hybrid encryption.</p>

      <h4 id="sec-1.4.2" class="text-lg font-semibold mt-6">1.4.2 ECIES</h4>

    <p class="text-gray-300">ECIES is the &quot;Elliptic Curve Integrated Encryption Scheme.&quot; It is a Diffie-Hellman-based scheme. It is a hybrid encryption scheme based on the hardness of the Computational Diffie-Hellman (CDH) problem for elliptic curves. It is closely related to the DHAES construction in [ABR99].</p>

    <p class="text-gray-300">The current draft of IEEE P1363a<sup>2</sup> also contains a version of ECIES, but this version differs in some significant respects from the submitted version of ECIES.</p>

    <p class="text-gray-300">As we shall point out, this scheme is not secure against adaptive chosen ciphertext attack, but can easily be made so with some small changes. Therefore, we have proposed a scheme ECIES-KEM,</p>

    <p class="text-gray-300"><sup>1</sup> In this document, all references to IEEE P1363 refer specifically to the final draft D13, dated November 12, 1999.</p>

    <p class="text-gray-300"><sup>2</sup> In this document, all references to IEEE P1363a refer specifically to the latest draft D9.9, dated July 21, 2001.</p>

    <p class="text-gray-300">which besides providing a higher level of security, also has been generalized to conform to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. The changes between ECIES and ECIES-KEM are the minimal changes required to ensure security.</p>

    <p class="text-gray-300">The ECIES-KEM scheme is a pure key encapsulation mechanism. It can be converted into a hybrid encryption scheme using the techniques standardized here. The resulting hybrid encryption scheme is consistent with the ECIES scheme proposed in IEEE P1363a, in the sense that the scheme proposed here conforms to that in IEEE P1363a; however, there are a number of variations and modes of operation of ECIES in P1363a that do not conform to the scheme proposed here. Thus, this standard for ECIES is a strict subset of the IEEE P1363a standard for ECIES.</p>

    <p class="text-gray-300">The main motivation for these restrictions are security concerns about the IEEE P1363a version of ECIES. The secondary motivation for these restrictions is to make this standard simpler, more uniform, and self-consistent.</p>

    <p class="text-gray-300">The ECIES-KEM scheme can be proven secure against adaptive chosen ciphertext attack, either by using the rather non-standard assumption in [ABR99], or by using the random oracle heuristic, combined with the (also not very standard) assumption that the CDH problem is hard, even when given access to an oracle for the Decisional Diffie-Hellman (DDH) problem. This latter assumption is called the gap-CDH assumption, and is studied in detail in [OP01].</p>

    <p class="text-gray-300">As for efficiency, encryption takes two group exponentiations, and decryption takes one or two (depending on the group, but usually one for elliptic curves).</p>

      <h4 id="sec-1.4.3" class="text-lg font-semibold mt-6">1.4.3 PSEC</h4>

    <p class="text-gray-300">PSEC is a family of Diffie-Hellman-based encryption schemes.</p>

    <p class="text-gray-300">It is claimed that these schemes are all provably secure in the random oracle model, under different assumptions. There are three schemes: PSEC-1, PSEC-2, and PSEC-3.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For PSEC-1, the DDH problem is assumed to be hard.</li>
      <li>For PSEC-2, the CDH problem is assumed to be hard.</li>
      <li>PSEC-3 is based on the gap-CDH assumption.</li>
    </ul>

    <p class="text-gray-300">We shall argue that actually, these security claims for PSEC-1 and PSEC-2 are unjustified (see &sect;16.5).</p>

    <p class="text-gray-300">We shall propose a scheme PSEC-KEM that is a variant of PSEC-2, and we provide a complete and detailed proof of security in the random oracle model based on the CDH assumption. Besides correcting the security problems of PSEC-2, other changes were made so that the resulting scheme conforms to our proposed abstract interface and to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. In particular, as the name implies, PSEC-KEM is a key encapsulation mechanism.</p>

    <p class="text-gray-300">As for efficiency, both PSEC-KEM encryption and decryption require two group exponentiations.</p>

    <p class="text-gray-300">PSEC-1 is based on stronger assumptions, is not significantly more efficient than the other schemes, and has some significant security problems. For these reasons, we have chosen not to include it (or a variant thereof) in this proposal.</p>

    <p class="text-gray-300">PSEC-3 is very similar to ECIES, offering an almost identical efficiency/security trade-off; since ECIES appears to be the more well-established scheme, we have chosen not to include PSEC-3 (or a variant thereof) in this proposal.</p>

      <h4 id="sec-1.4.4" class="text-lg font-semibold mt-6">1.4.4 ACE-Encrypt</h4>

    <p class="text-gray-300">ACE-Encrypt is a Diffie-Hellman-based hybrid encryption scheme that can be proven secure against adaptive chosen ciphertext attack assuming the DDH problem is hard. It is the only submission that can truly be proven secure &mdash; it does not rely on the random oracle heuristic. It is slightly less efficient than PSEC-2.</p>

    <p class="text-gray-300">The submission is based on the DDH problem for a subgroup of Z &lowast; p . We have proposed a variant, ACE-KEM. Several changes were made to the original ACE-Encrypt scheme so that the resulting scheme conforms to our proposed abstract interface and to our proposed unified frameworks for hybrid and Diffie-Hellman-based encryption. As the name suggests, ACE-KEM is a key encapsulation mechanism. ACE-KEM and the corresponding hybrid scheme are still provably secure &mdash; without the random oracle heuristic &mdash; based on the DDH, as well as a couple of other reasonable symmetric-key cryptographic assumptions.</p>

    <p class="text-gray-300">As for efficiency, ACE-KEM encryption requires five group exponentiations, and decryption requires either three or four (depending on the group, but usually three for elliptic curves). Several optimizations are available to reduce the effective costs of these exponentiations, however.</p>

    <p class="text-gray-300">We point out that, like PSEC-KEM, the scheme ACE-KEM can be proven secure in the random oracle model under the weaker CDH assumption, although the security reduction for ACE-KEM is much less efficient than that for PSEC-KEM. Additionally, it can be shown that ACE-KEM is no less secure than ECIES-KEM, in the sense that there is a very tight reduction from an attack on ECIES-KEM to an attack ACE-KEM. That is, any attack on ACE-KEM can be converted into an attack on ECIES-KEM, where the running time and success probability of the latter attack are essentially the same as for the former attack. This is discussed in detail in &sect;17.6.2. Thus, any fears that the DDH assumption is &quot;too strong&quot; (see [JN01]) can be safely put to rest.</p>

      <h4 id="sec-1.4.5" class="text-lg font-semibold mt-6">1.4.5 EPOC</h4>

    <p class="text-gray-300">EPOC is a family of encryption schemes based on factoring integers of the form n = p 2 q. There are three variants: EPOC-1, EPOC-2, and EPOC-3.</p>

    <p class="text-gray-300">Security of these schemes is claimed in the random oracle model under one of several assumptions (including the assumption that factoring is hard).</p>

    <p class="text-gray-300">It was the initial judgment of this author that these schemes should not be included in the standard, for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the theory on which these schemes are based has not been very widely scrutinized, nor have many of the implementation details;</li>
      <li>they do not seem to offer a particularly attractive efficiency/security tradeoff in relation to the other schemes (one drawback in particular is that it is not amenable &quot;stream processing&quot; &mdash; see &sect;2.1.3).</li>
    </ul>

    <p class="text-gray-300">However, at the ad hoc meeting in Santa Barbara, a consensus was reached that EPOC-2 should be included in the standard. The reasons given were that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>it is the only proposed scheme whose proof of security is based on factoring (as opposed to RSA inversion);</li>
      <li>the decryption operation may be somewhat faster than for RSA;</li>
      <li>it has been subjected to a certain amount of public scrutiny, and no security problems have yet been discovered;</li>
    </ul>

    <p class="text-gray-300">&bull; it is in IEEE P1363a, and so including it in the ISO standard increases the compatibility of these two standards.</p>

    <p class="text-gray-300">At the present time, we have not yet incorporated a specification EPOC-2 into this proposal, although the intention is that it will be a part of the first working draft. This specification should be consistent with the IEEE P1363a version of EPOC-2.</p>

      <h4 id="sec-1.4.6" class="text-lg font-semibold mt-6">1.4.6 HIME</h4>

    <p class="text-gray-300">HIME is a family of encryption schemes based on factoring integers.</p>

    <p class="text-gray-300">Security of these schemes is claimed in the random oracle model under one of several assumptions (including the assumption that factoring is hard).</p>

    <p class="text-gray-300">It was the judgment of this author that these schemes should not be included in the standard. The main reason for this is that the design of the schemes and the claims of security do not appear to stand on very firm ground. Indeed, many details are missing, and it is not at all clear that these gaps can be filled in. Moreover, none of these schemes have been published anywhere, and therefore have not been widely scrutinized.</p>

    <p class="text-gray-300">Also, it was the general consensus at the ad hoc meeting in Santa Barbara that this scheme should not be considered any further.</p>

      <h4 id="sec-1.4.7" class="text-lg font-semibold mt-6">1.4.7 Further references on the submissions</h4>

    <p class="text-gray-300">The schemes RSA-OAEP, ECIES, PSEC, EPOC, and ACE-Encrypt have also been submitted to the Crypto-Nessie evaluation project, and were presented at the first Crypto-Nessie workshop, held in Leuven on November 13-14, 2000.</p>

    <p class="text-gray-300">Besides the ISO document SC 27 N 2656, detailed descriptions of these algorithms are publicly available at www.cryptonessie.org/workshop.</p>

      <h4 id="sec-1.4.8" class="text-lg font-semibold mt-6">1.4.8 Summary of proposed schemes</h4>

    <p class="text-gray-300">So our proposed schemes are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Diffie-Hellman-based schemes:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>ECIES-KEM</li>
      <li>PSEC-KEM</li>
      <li>ACE-KEM</li>
    </ul></li>
      <li>RSA-based schemes:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>RSA-OAEP</li>
      <li>RSA-OAEP+</li>
      <li>RSA-KEM</li>
    </ul></li>
      <li>Factoring-based schemes:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>EPOC-2</li>
    </ul></li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">exponentiations</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">exponentiations</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">random oracle</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">main</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">per encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">per decryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">heuristic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">assumption</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ECIES-KEM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 (or 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">gap CDH</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PSEC-KEM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CDH</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ACE-KEM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 (or 4)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DDH</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Comparison of Diffie-Hellman-based schemes</p>

    <p class="text-gray-300">The reason for proposing three different RSA-based schemes is that they each offer a unique efficiency/security trade-off. While they are all based on the RSA problem, the security reduction for RSA-KEM is much tighter than that for RSA-OAEP+, and the security reduction for RSA-OAEP+ is much tighter than that of RSA-OAEP. Additionally, RSA-KEM is very simple, and fits more nicely into our general framework for hybrid encryption. The scheme RSA-OAEP+ is attractive as it yields more compact ciphertexts than the hybrid scheme arising from RSA-KEM. The scheme RSA-OAEP is included here mainly for compatibility with other standards: it offers no real security or performance benefit compared to the other RSA-based schemes.</p>

    <p class="text-gray-300">The reason for including three different Diffie-Hellman-based schemes is that they seem to each offer a unique efficiency/security trade-off, as summarized in Table 1.</p>

    <p class="text-gray-300">We first define the basic structure of a public-key encryption scheme.</p>

    <p class="text-gray-300">A public-key encryption scheme PKE consists of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A key generation algorithm PKE.KeyGen(), that outputs a public key/secret key pair (PK, SK). The structure of PK and SK depend on the particular scheme.</li>
      <li>An encryption algorithm PKE.Encrypt(PK, L, M, options) that takes as input a public key PK, a label L, a message M, and an optional options argument, and outputs a ciphertext C. Note that L, M, and C are byte strings. See &sect;2.1.4 below for more on labels. See &sect;2.1.6 below for more on the options argument.</li>
      <li>A decryption algorithm PKE.Decrypt(SK, L, C) that takes as input a secret key SK, a label L, and a ciphertext C, and outputs a message M.</li>
    </ul>

    <p class="text-gray-300">In general, the key generation and encryption algorithms will be probabilistic algorithms, while the decryption algorithm is deterministic.</p>

      <h4 id="sec-2.1.1" class="text-lg font-semibold mt-6">2.1.1 Soundness</h4>

    <p class="text-gray-300">A basic requirement of any public-key encryption scheme is soundness: for any public-key/secretkey pair (PK, SK), for any label/message pair (L, M), any encryption of M with label L under PK decrypts with label L under SK to the original message M. This requirement may be relaxed, so that it holds only for all but an acceptably negligible fraction of public-key/secret-key pairs, and even just for all but an acceptably negligible fraction of encryptions.</p>

      <h4 id="sec-2.1.2" class="text-lg font-semibold mt-6">2.1.2 Message length</h4>

    <p class="text-gray-300">It is important to note that messages may be of arbitrary and variable length, although a particular scheme may choose to impose a (very large) upper bound on this length. Thus, our proposed notion of a public-key encryption scheme is essentially a &quot;digital envelope.&quot;</p>

    <p class="text-gray-300">Some currently available public-key encryption schemes, like RSA-OAEP, only allow for very short messages, and leave it to application engineers to design their own &quot;hybrid&quot; scheme to encrypt long messages (i.e., by encrypting a session key and then using symmetric-key cryptography to encrypt the payload).</p>

    <p class="text-gray-300">However, it seems unrealistic to expect application engineers to correctly design such a secure hybrid scheme. Even PKCS#7 &mdash; the standard &quot;digital envelope&quot; mechanism &mdash; is not appropriate. The simplest version of this simply encrypts a session key using RSA-OAEP, and then encrypts the message using a standard symmetric cipher &mdash; no additional integrity checks are made. Because of this, straightforward application of PKCS#7 yields a trivially malleable encryption scheme.</p>

    <p class="text-gray-300">Despite all of the above potential problems and limitations, given that some very important existing encryption schemes do impose a small upper bound on the length of a message, we also introduce the notion of a bounded-length public-key encryption scheme. Such a scheme PKE supports the same interface as that of an ordinary (unbounded) scheme, but only allows messages of length bounded by PKE.MaxLen(PK).</p>

      <h4 id="sec-2.1.3" class="text-lg font-semibold mt-6">2.1.3 Stream processing</h4>

    <p class="text-gray-300">Given that messages may be arbitrarily long, a highly desirable property of any public-key encryption scheme should be that both the encryption and decryption algorithms can be efficiently implemented as filters. That is, the message may be presented to the encryption algorithm as an input stream, and the ciphertext should be written to an output stream. The algorithm should never have to rewind these streams, and should be able to process these streams using a small, bounded amount of internal storage, independent of the length of these streams. Similarly, the decryption algorithm should be given access to an input stream representing the ciphertext, and the message should be written to an output stream.</p>

    <p class="text-gray-300">All of the schemes proposed here are amenable to stream processing, with the sole exception of EPOC-2.</p>

      <h4 id="sec-2.1.4" class="text-lg font-semibold mt-6">2.1.4 The use of labels</h4>

    <p class="text-gray-300">A label is a byte string that is effectively bound to the ciphertext in a non-malleable way. It may contain data that is implicit from context and need not be encrypted, but that should nevertheless be bound to the ciphertext. We view a label to be a byte string that is meaningful to the application using the encryption scheme, and that is independent of the implementation of the encryption scheme.</p>

    <p class="text-gray-300">For example, there are key exchange protocols in which one party, say A, encrypts a session key K under the public key of the other party, say B. In order for the protocol to be secure, party A's identity (or public key or certificate) must be non-malleably bound to the ciphertext. One way to do this is simply to append this identity to the message. However, this creates an unnecessarily large ciphertext, since A's identity is typically already known to B in the context of such a protocol. A good implementation of the labeling mechanism achieves the same effect, without increasing the size of the ciphertext.</p>

    <p class="text-gray-300">Labels may also be of arbitrary and variable length, but we do not impose the restriction that the encryption and decryption algorithms should be able to process labels as streams.</p>

    <p class="text-gray-300">Both the ECIES and RSA-OAEP submissions include the notion of a label (where it is called an encoding parameter), although no indication was given as to the role or function of a label. Nevertheless, it seems to be a potentially useful feature, and so we include it here.</p>

      <h4 id="sec-2.1.5" class="text-lg font-semibold mt-6">2.1.5 Ciphertext format</h4>

    <p class="text-gray-300">The schemes proposed in this document describe precisely the format of a ciphertext. This is desirable for several reasons. First, it facilitates the inter-operability of different implementations of the same scheme. Second, it allows higher-level protocols to use public-key encryption as a &quot;black box&quot; in a way that is independent of the particular scheme. Third, it is necessary to even discuss the notion of security in a meaningful way.</p>

    <p class="text-gray-300">It is highly recommended that a general-purpose library offering public-key encryption implement the abstract interface in a way suitable for its particular programming environment, and that the ciphertexts conform to the prescribed format. Standardizing the abstract interface and the ciphertext format is meant to facilitate this type of software development.</p>

    <p class="text-gray-300">However, these specifications in no way dictate that such formatting must be preserved in a system using an encryption scheme, or that an implementation of the abstract interface must explicitly appear anywhere in the system. For example, in transporting a ciphertext over a network, it may be chopped up, and reformatted in an arbitrary way. Some transformations may be generic, i.e., independent of the encryption scheme, while others may be applicable only to a specific scheme. Indeed, it is not even necessary that a particular system using a scheme standardized here actually outputs (resp., inputs) ciphertexts in the prescribed format upon encryption (resp., decryption): the encryption and decryption algorithms may behave as if they performed such transformations on the ciphertext, even though the ciphertext may never really be represented in the prescribed format. In such a system, the prescribed format of the ciphertext plays a purely conceptual role in reasoning about the security of the system, even though it plays no direct role in the implementation of the system.</p>

      <h4 id="sec-2.1.6" class="text-lg font-semibold mt-6">2.1.6 Scheme-specific encryption options</h4>

    <p class="text-gray-300">Some schemes allow certain types of scheme-specific options to be passed to the encryption algorithm, which is why we have allowed for an extra argument options in our abstract interface.</p>

    <p class="text-gray-300">Allowing scheme-specific options in an abstract interface is clearly not such a good idea, as this runs counter to the very notion of an abstract interface. Also, since such options are scheme specific, their use will almost certainly atrophy over time, especially if more applications take advantage of the benefits provided by an abstract encryption interface.</p>

    <p class="text-gray-300">Although we strongly discourage the use of such options, we nevertheless allow them in our formal model for the sake of allowing us to cast some existing schemes into the model.</p>

    <p class="text-gray-300">The only place where we will actually use encryption options is in discussing encryption schemes based on elliptic curves: some of these scheme allows the encryptor to dynamically choose, from one of several formats, how it wants to format a point on the curve.</p>

    <p class="text-gray-300">For the sake of some notion of completeness or symmetry, one could also allow scheme-specific decryption options, but since we do not need such a notion, we do not attempt to formalize it.</p>

      <h4 id="sec-2.1.7" class="text-lg font-semibold mt-6">2.1.7 Algorithm failure</h4>

    <p class="text-gray-300">Throughout this document, algorithms will always compute a function on their inputs, except that instead of returning a value, they may <strong>fail</strong>. By convention, if an algorithm <strong>fails</strong>, then unless otherwise specified, an algorithm that invokes that algorithm as a sub-routine also <strong>fails</strong>. Thus, <strong>failing</strong> is analogous to &quot;throwing an exception&quot; in many programming languages.</p>

      <h4 id="sec-2.1.8" class="text-lg font-semibold mt-6">2.1.8 Bits vs. Bytes</h4>

    <p class="text-gray-300">Our abstract interface treats messages and labels as strings of bytes (a.k.a., octets), rather than strings of bits.</p>

    <p class="text-gray-300">We argue against allowing bit strings, for the following reasons.</p>

    <p class="text-gray-300">First, it seems unlikely that many, if indeed any, applications really work with data that is represented as bit strings, rather than byte strings.</p>

    <p class="text-gray-300">Second, even if an application does want to work with bit strings, it can be left to the application to encode these bit strings as byte strings. Anyway, an application may in general have to properly format its messages before encryption, for example, to hide any information that may be leaked just from the length of the message (see &sect;2.2.2).</p>

    <p class="text-gray-300">Third, we note that existing standards, such as IEEE P1363a, are themselves inconsistent in this regard, and so it does not seem advisable to propagate this inconsistency here as well. Indeed, while some encryption schemes in IEEE P1363a (ECIES) allow for bit strings, others (RSA-OAEP and EPOC-2) are byte oriented.</p>

    <p class="text-gray-300">We next recall the definition of security against adaptive chosen ciphertext attack, adapted to deal with labels.</p>

    <p class="text-gray-300">We begin by describing the attack scenario.</p>

    <p class="text-gray-300">First, the key generation algorithm is run, generating the public key and private key for the cryptosystem. The adversary, of course, obtains the public key, but not the private key.</p>

    <p class="text-gray-300">Second, the adversary makes a series of arbitrary queries to a decryption oracle. Each query is a label/ciphertext pair (L,C) that is decrypted by the decryption oracle, making use of the private key of the cryptosystem. The resulting decryption is given to the adversary; moreover, if the decryption algorithm <strong>fails</strong>, then this information is given to the adversary, and the attack continues. The adversary is free to construct these label/ciphertext pairs in an arbitrary way&mdash;it is certainly not required to compute them using the encryption algorithm.</p>

    <p class="text-gray-300">Third, the adversary prepares a label  <span class="math">L^*</span>  and two &quot;target&quot; messages  <span class="math">M_0, M_1</span>  of equal length, and gives these to an <em>encryption oracle</em>. If the scheme supports any encryption options, the adversary also chooses these. The encryption oracle chooses  <span class="math">b \\in \\{0,1\\}</span>  at random, encrypts  <span class="math">M_b</span>  with label  <span class="math">L^*</span> , and gives the resulting &quot;target&quot; ciphertext  <span class="math">C^*</span>  to the adversary.</p>

    <p class="text-gray-300">Fourth, the adversary continues to submit label/ciphertext pairs (L, C) to the decryption oracle, subject only to the restriction that  <span class="math">(L, C) \\neq (L^*, C^*)</span> .</p>

    <p class="text-gray-300">Just before the adversary terminates, it outputs  <span class="math">\\hat{b} \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">That completes the description of the attack scenario.</p>

    <p class="text-gray-300">For a given adversary A, and a given scheme PKE, we define the adversary's guessing advantage</p>

    <p class="text-gray-300"><span class="math">$Advantage_{PKE}(A) = \\left| \\Pr[\\hat{b} = b] - 1/2 \\right|.</span>$</p>

    <p class="text-gray-300">Security means that  <span class="math">Advantage_{PKE}(A)</span>  is &quot;acceptably&quot; small for all adversaries A that run in a &quot;reasonable&quot; amount of time.</p>

      <h4 id="sec-2.2.1" class="text-lg font-semibold mt-6">2.2.1 Alternative characterizations and implications</h4>

    <p class="text-gray-300">Note that in proving an encryption scheme secure, the definition we have given is usually the most convenient. However, in analyzing an encryption scheme in a larger context, a slightly different definition is usually more convenient. In this definition, the attack scenario proceeds just as before. However, instead of measuring the adversary's guessing advantage, we measure its distinguishing advantage</p>

    <p class="text-gray-300"><span class="math">$Advantage&#x27;_{PKE}(A) = \\left| \\Pr \\left[ \\hat{b} = 1 | b = 1 \\right] - \\Pr \\left[ \\hat{b} = 1 | b = 0 \\right] \\right|.</span>$</p>

    <p class="text-gray-300">It follows directly from the definitions by a trivial calculation that for any adversary A,</p>

    <p class="text-gray-300"><span class="math">$Advantage&#x27;_{PKE}(A) = 2 \\cdot Advantage_{PKE}(A).</span>$</p>

    <p class="text-gray-300">Equivalently, one can view  <span class="math">Advantage&#x27;_{PKE}(A)</span>  as measuring how differently an adversary behaves in two different attack games: in one game,  <span class="math">M_0</span>  is always encrypted, and in the other,  <span class="math">M_1</span>  is always encrypted.</p>

    <p class="text-gray-300">In analyzing an encryption scheme in a larger context, one usually substitutes an encryption of a secret message by an encryption of a garbage message (all zeros, or random) of the same length, and then analyzes how the adversary behaves. Many secret messages may be replaced by garbage strings, and the distinguishing advantage simply sums (although for some schemes, one can exhibit an even tighter security reduction). A small distinguishing advantage implies that the adversary will not behave significantly differently when this substitution is made. See [BBM00] for more details.</p>

    <p class="text-gray-300">This definition, in slightly different form, was first proposed by Rackoff and Simon [RS91]. It is generally agreed in the cryptographic research community that this is the &quot;right&quot; security property for a general-purpose public-key encryption scheme. This notion of security implies other useful properties, like <em>non-malleability</em>. See [DDN91, DDN98, BDPR98] for more on notions of security for public-key encryption schemes.</p>

      <h4 id="sec-2.2.2" class="text-lg font-semibold mt-6">2.2.2 Hiding the message length</h4>

    <p class="text-gray-300">Note that in the attack game, the adversary is required to submit two target messages of <em>equal</em> length to the encryption oracle. This restriction on the adversary reflects the fact that we cannot expect to hide the length of an encrypted message from the adversary&mdash;for many cryptosystems, this will be evident from the length of the ciphertext. It is in general up to the <em>application</em> using the cryptosystem to ensure that the length of a message does not reveal sensitive information.</p>

    <p class="text-gray-300">For bounded-length public-key encryption schemes (see &sect;2.1.2) the notion of security is the same as for the ordinary, unbounded case, except that the adversary <em>is not</em> required to submit target messages of equal length to the encryption oracle. This reflects the fact that such schemes in fact do hide the length of an encrypted message from the adversary.</p>

      <h4 id="sec-2.2.3" class="text-lg font-semibold mt-6">2.2.3 Failing streams</h4>

    <p class="text-gray-300">There is a subtle interaction between <strong>failing</strong>, as discussed in &sect;2.1.7 and the notion of a stream, discussed in &sect;2.1.3. An application reading the output stream of the decryption algorithm should take care not to leak any information about the message it has read from that stream, until the</p>

    <p class="text-gray-300">decryption process has finished without <strong>failing</strong>. If it does not do this, the application could potentially forfeit the security guarantees of the scheme.</p>

      <h4 id="sec-2.2.4" class="text-lg font-semibold mt-6">2.2.4 Security parameters and asymptotic security</h4>

    <p class="text-gray-300">Note that none of these definitions make explicit mention of a security parameter. Our point of view is concrete&mdash;not asymptotic. We assume that a scheme specifies a particular security parameter (or set of parameters). If one wants to translate these definitions into ones compatible with the &quot;asymptotic complexity&quot; point of view, then one can consider families of algorithms indexed by a parameter  <span class="math">\\lambda = 1, 2, 3, \\ldots</span>  that run in time bounded by a polynomial in  <span class="math">\\lambda</span> . Both the scheme and the adversary are viewed as families of algorithms. One can consider either uniform or non-uniform families of algorithms. Security means that the adversary's advantage is &quot;negligible&quot; in  <span class="math">\\lambda</span> , meaning that it goes to zero faster than the inverse of any polynomial in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">The definition of security given in  <span class="math">\\S 2.2</span>  is sometimes viewed as being unnecessarily strong. For example, suppose we take an encryption scheme PKE that satisfies the definition in  <span class="math">\\S 2.2</span> , and modify it as follows, obtaining a new encryption scheme PKE': the scheme PKE' is the same as PKE, except that it appends a random byte to the ciphertext upon encryption, and ignores this extra byte upon decryption. Technically speaking, PKE' does not satisfy the definition in  <span class="math">\\S 2.2</span> , yet this seems counter-intuitive. Indeed, although PKE' is technically &quot;malleable,&quot; it is only malleable in a &quot;benign&quot; sort of way: one can create alternative encryptions of the same message, and these alternative encryptions are all clearly recognizable as such.</p>

    <p class="text-gray-300">We present here a formal notion of security that precisely captures the intuitive notion of &quot;benign malleability.&quot;</p>

    <p class="text-gray-300">For a particular encryption scheme PKE and any public-key/secret-key pair (PK, SK), we call a binary relation  <span class="math">\\equiv_{PK}</span>  on label/ciphertext pairs a <em>compatible</em> relation if for any and two label/ciphertext pairs (L, C) and (L', C'),</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if  <span class="math">(C, L) \\equiv_{PK} (C&#x27;, L&#x27;)</span>  then L = L',</li>
      <li>if  <span class="math">(C, L) \\equiv_{PK} (C&#x27;, L&#x27;)</span>  then PKE.Decrypt(SK, L, C) = PKE.Decrypt(SK, L', C'), and</li>
      <li>it can be determined if  <span class="math">(C, L) \\equiv_{PK} (C&#x27;, L&#x27;)</span>  using an efficient algorithm that takes inputs PK, L, C, L', C'.</li>
    </ul>

    <p class="text-gray-300">Clearly, any compatible relation is an equivalence relation.</p>

    <p class="text-gray-300">We say that a public-key encryption scheme PKE is benignly malleable if there exists a compatible relation for PKE as above, and if it satisfies the definition of security given in &sect;2.2, but with the following modification in the attack game: when the adversary submits a label/ciphertext pair (L, C) to the decryption oracle subsequent to the invocation of the encryption oracle, then instead of requiring that  <span class="math">(L, C) \\neq (L^*, C^*)</span> , we only require that  <span class="math">(L, C) \\not\\equiv_{PK} (L^*, C^*)</span> .</p>

    <p class="text-gray-300">This definition of security is essentially just as useful as the definition in &sect;2.2 for all applications of public-key encryption that we know of.</p>

    <p class="text-gray-300">In designing an efficient public-key encryption scheme, a useful approach is to design a &quot;hybrid&quot; scheme, where one uses public key cryptography to encrypt a key that can then be used to encrypt</p>

    <p class="text-gray-300">the actual payload using symmetric key cryptography.</p>

    <p class="text-gray-300">We will build a hybrid encryption scheme from two lower-level &quot;building blocks.&quot; The first is a method for using public key cryptography to &quot;encapsulate&quot; a symmetric key. We call such a scheme a key encapsulation mechanism. The second is a method to properly encrypt the message using symmetric-key cryptographic techniques applied to the the symmetric key obtained from the key encapsulation mechanism. We call such a scheme a data encapsulation method.</p>

    <p class="text-gray-300">In this section, we discuss key encapsulation mechanisms. Data encapsulation mechanisms are discussed in &sect;4, and the construction of hybrid encryption schemes built out of key and data encapsulation mechanisms is discussed in &sect;5.</p>

    <p class="text-gray-300">Briefly, a key encapsulation mechanism works just like a public-key encryption scheme, except that the encryption algorithm takes no input other than the recipient's public key. Instead, the encryption algorithm generates a pair (K, C0), where K is a bit string of some specified length, and C<sup>0</sup> is an encryption of K, that is, the decryption algorithm applied to C<sup>0</sup> yields K.</p>

    <p class="text-gray-300">One can always use a (possibly bounded-length) public-key encryption scheme for this purpose, generating a random bit string, and then encrypting it under the recipient's public key. However, as we shall see, one can construct a key encapsulation scheme in other, more efficient, ways as well. Now the details.</p>

    <p class="text-gray-300">A key encapsulation mechanism KEM consists of three algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A key generation algorithm KEM.KeyGen(), that outputs a public key/secret key pair (PK, SK). The structure of PK and SK depend on the particular scheme.</li>
      <li>An encryption algorithm KEM.Encrypt(PK, options) that takes as input a public key PK, along with an optional options argument, and outputs a key/ciphertext pair (K, C0). The role of options is analogous to that for public-key encryption (see &sect;2.1.6).</li>
      <li>A decryption algorithm KEM.Decrypt(SK, C0) that takes as input a secret key SK and a ciphertext C0, and outputs a key K.</li>
    </ul>

    <p class="text-gray-300">A key encapsulation mechanism also specifies a positive integer KEM.OutputKeyLen &mdash; the length of the key output by KEM.Encrypt and KEM.Decrypt.</p>

    <p class="text-gray-300">Any key encapsulation mechanism should satisfy a soundness property analogous to the soundness property of a public-key encryption scheme, as described in &sect;2.1.1.</p>

    <p class="text-gray-300">Additionally, we need the following property. The set of all possible outputs of the encryption algorithm should be a subset of some an easy-to-recognize, prefix-free language.<sup>3</sup> The prefix-freeness property is needed so that we can parse byte strings from left to right, and efficiently &quot;strip off&quot; a ciphertext. Note that if all ciphertexts have the same length, then the prefix-freeness property is trivially satisfied.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Notion of security</h3>

    <p class="text-gray-300">We next define security against adaptive chosen ciphertext attack for a key encapsulation mechanism.</p>

    <p class="text-gray-300">We begin by describing the attack scenario.</p>

    <p class="text-gray-300"><sup>3</sup>A language L is prefix free if for any two x, y &isin; L, x is not a proper prefix of y.</p>

    <p class="text-gray-300">First, the key generation algorithm is run, generating the public key and private key for the cryptosystem. The adversary, of course, obtains the public key, but not the private key.</p>

    <p class="text-gray-300">Second, the adversary makes a series of arbitrary queries to a decryption oracle. Each query is a ciphertext  <span class="math">C_0</span>  that is decrypted by the decryption oracle, making use of the private key of the cryptosystem. The resulting decryption is given to the adversary; moreover, if the decryption algorithm <strong>fails</strong>, then this information is given to the adversary, and the attack continues.</p>

    <p class="text-gray-300">Third, the adversary invokes an <em>encryption oracle</em>, supplying an encryption option, if the scheme supports them. The encryption oracle does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run the encryption algorithm, generating a pair  <span class="math">(K^*, C_0^*)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a random string  <span class="math">\\tilde{K}</span>  of length KEM. Output Key Len.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose  <span class="math">b \\in \\{0,1\\}</span>  at random.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If b = 0, output  <span class="math">(K^*, C_0^*)</span> ; otherwise output  <span class="math">(\\tilde{K}, C_0^*)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Fourth, the adversary continues to submit ciphertexts  <span class="math">C_0</span>  to the decryption oracle, subject only to the restriction that  <span class="math">C_0 \\neq C_0^*</span> .</p>

    <p class="text-gray-300">Just before the adversary terminates, it outputs  <span class="math">\\hat{b} \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">That completes the description of the attack scenario.</p>

    <p class="text-gray-300">For an adversary A, the quantities  <span class="math">Advantage_{KEM}(A)</span>  and  <span class="math">Advantage&#x27;_{KEM}(A)</span>  are defined in exactly the same way (in terms of b and  <span class="math">\\hat{b}</span> ) as  <span class="math">Advantage_{PKE}(A)</span>  and  <span class="math">Advantage&#x27;_{PKE}(A)</span>  for a public-key encryption scheme (see &sect;2). Security means that  <span class="math">Advantage_{KEM}(A)</span>  is &quot;acceptably&quot; small for all adversaries A that run in a &quot;reasonable&quot; amount of time.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Further remarks</h3>

    <p class="text-gray-300">One can also define the notion of benign malleability for key encapsulation mechanisms, just as we did for public-key encryption schemes ( <span class="math">\\S 2.3</span> ).</p>

    <p class="text-gray-300">Although one could do so, we have chosen not to incorporate the notion of a <em>label</em> in the definition of a key encapsulation mechanism. The reason is that the only application we have of a key encapsulation mechanism in this paper is in the construction of a hybrid encryption scheme, and it is easier to implement labels in the data encapsulation mechanism than in the key encapsulation mechanism itself.</p>

    <p class="text-gray-300">A data encapsulation mechanism provides a &quot;digital envelope&quot; that protects the secrecy and integrity of data using symmetric-key cryptographic techniques; it also may bind the data to a public label. The definition of security for this primitive that we present here is appropriate for building hybrid public-key encryption schemes, but may not be appropriate for other applications.</p>

    <p class="text-gray-300">In this section we only describe the abstract interface and security properties that a data encapsulation mechanism should satisfy. Later, in &sect;10, we present a fairly traditional and provably secure implementation of a data encapsulation mechanism. There may, however, be other interesting ways to implement this primitive.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Abstract interface</h3>

    <p class="text-gray-300">A data encapsulation mechanism <em>DEM</em> specifies a key length <em>DEM.KeyLen</em>, along with encryption and decryption algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The encryption algorithm DEM.Encrypt(K, L, M) takes as input a key K, a label L, and and a message M. It outputs a ciphertext  <span class="math">C_1</span> . Here, K, L, M, and  <span class="math">C_1</span>  are byte strings, and L and M may have arbitrary length, and K is of length DEM.KeyLen.</li>
      <li>The decryption algorithm  <span class="math">DEM.Decrypt(K, L, C_1)</span>  takes as input a key K, a label L, and a ciphertext  <span class="math">C_1</span> . It outputs a message M.</li>
    </ul>

    <p class="text-gray-300">We assume that the encryption and decryption algorithms are deterministic, and that the scheme is (perfectly) sound, in the sense that for all keys K, all labels L, and all messages M,</p>

    <p class="text-gray-300"><span class="math">$DEM.Decrypt(K, L, DEM.Encrypt(K, L, M)) = M.</span>$</p>

    <p class="text-gray-300">We shall need the following security property.</p>

    <p class="text-gray-300">Consider the following attack scenario. The adversary generates two messages (byte strings)  <span class="math">M_0</span> ,  <span class="math">M_1</span>  of equal length, and a label  <span class="math">L^*</span> . A random key K is generated. A random bit b is chosen, and  <span class="math">M_b</span>  is encrypted under key K. The resulting ciphertext  <span class="math">C_1^*</span>  is given to the adversary. The adversary then submits a series of requests to a decryption oracle: each such request is a label/ciphertext pair  <span class="math">(L, C_1) \\neq (L^*, C_1^*)</span> , and the decryption oracle responds with the decryption of  <span class="math">C_1</span>  with label L under key K. The adversary makes a guess  <span class="math">\\hat{b}</span>  at b. The adversary's advantage is defined as  <span class="math">|Pr[\\hat{b}=b]-1/2|</span> . We denote this advantage by  <span class="math">Advantage_{DEM}(A)</span> .</p>

    <p class="text-gray-300">Security means that this advantage is acceptably small.</p>

    <p class="text-gray-300">We now propose a canonical way to compose a secure key encapsulation mechanism and a secure data encapsulation mechanism so as to obtain a secure public-key encryption scheme.</p>

    <p class="text-gray-300">Let KEM be a key encapsulation mechanism and let DEM be a data encapsulation mechanism. To compose these two mechanisms, we require that they are compatible, in the sense that KEM.OutputKeyLen = DEM.KeyLen. So let us assume that KEM and DEM are compatible in this sense.</p>

    <p class="text-gray-300">We now define a <em>hybrid</em> public-key encryption scheme  <span class="math">H\\text{-}PKE = H\\text{-}PKE_{KEM,DEM}</span>  in terms of KEM and DEM as follows.</p>

    <p class="text-gray-300">The key generation algorithm, public key, and secret key for H-PKE are the same as that of KEM.</p>

    <p class="text-gray-300">Let (PK, SK) be a public key/secret key pair.</p>

    <p class="text-gray-300">To encrypt a message M with label L and any encryption options under PK, the encryption algorithm for H-PKE does the following. First, it runs the encryption algorithm for KEM with the given options, generating a ciphertext  <span class="math">C_0</span>  and a key K. Second, it encrypts M with label L under K using the encryption algorithm for DEM. Third, it outputs the ciphertext  <span class="math">C = C_0 \\parallel C_1</span> .</p>

    <p class="text-gray-300">To decrypt a ciphertext C with label L under SK, the decryption algorithm for H-PKE does the following. First, it parses C as  <span class="math">C = C_0 \\parallel C_1</span> , using the prefix-freeness property of the ciphertexts associated with KEM. Second, it decrypts  <span class="math">C_0</span>  under SK using the decryption algorithm of KEM</p>

    <p class="text-gray-300">to obtain a key K. Third, it decrypts C<sup>1</sup> with label L under K using the decryption algorithm of DEM, and outputs the resulting message M. Any of these steps may fail, in which case the decryption algorithm for H-PKE also fails.</p>

    <p class="text-gray-300">It is an easy matter to prove that for any adversary A,</p>

    <p class="text-gray-300"><span class="math">$Advantage_{H\\text{-}PKE}(A) \\leq Advantage&#x27;_{KEM}(A_1) + Advantage_{DEM}(A_2),</span>$</p>

    <p class="text-gray-300">where A<sup>1</sup> and A<sup>2</sup> are adversaries that run in time roughly the same as that of A. Actually, this estimate assumes that KEM is perfectly sound; however, if the soundness condition may be violated with some small probability, that probability must be added into this estimate as well.</p>

    <p class="text-gray-300">It follows that if KEM and DEM are secure, then so is H-PKE.</p>

    <p class="text-gray-300">For a detailed proof of a slight variant of this security claim, the reader is referred to [CS01]. The situation in that paper is slightly different from the one here, because the notion corresponding to a DEM in that paper does not incorporate the use of a label. Nevertheless, the security proof in that paper can be applied almost verbatim to the situation here.</p>

    <p class="text-gray-300">We simply adopt the functions OS2IP and I2OSP from the IEEE P1363 standard for conversions between byte (a.k.a., octet) strings and integers.</p>

    <p class="text-gray-300">The function OS2IP(x) takes as input a byte string, and outputs an integer. If x = xl&minus;<sup>1</sup> k xl&minus;<sup>2</sup> k &middot; &middot; &middot; k x0, where each x<sup>i</sup> is a byte, then</p>

    <p class="text-gray-300"><span class="math">$OS2IP(x) = \\sum_{i=0}^{l-1} x_i \\cdot 256^i.</span>$</p>

    <p class="text-gray-300">In this formula, each byte x<sup>i</sup> is interpreted as a base-256 digit. Note that the left-most byte represents the most-significant digit.</p>

    <p class="text-gray-300">The function I2OSP is essentially the inverse of OS2IP. The function I2OSP(m, l) takes as input two non-negative integers m and l, and outputs the unique byte string x of length l such that OS2IP(x) = m, if such an x exists. Otherwise, the function fails. Note that the function fails if and only if m &ge; 256<sup>l</sup> .</p>

    <p class="text-gray-300">A pseudo-random byte generator PRBG is a scheme with the following interface. It defines fixed seed length PRBG.SeedLen and a function PRBG.eval(s, l) that takes as input a byte string s of length PRBG.SeedLen and an integer l &ge; 0, and produces as output a byte string of length l.</p>

    <p class="text-gray-300">The assumption we make is that for a random seed s, the output is computationally indistinguishable from a random byte string of the same length.</p>

    <p class="text-gray-300">One recommended way to implement a PRBG is to simply use a block cipher in counter mode. An alternative is to use a block cipher in counter mode, but to output the XOR of consecutive pairs of block cipher outputs. This approach yields a higher level of security when l is very large (see [Luc00]).</p>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Abstract interface</h3>

    <p class="text-gray-300">A symmetric key encryption scheme SKE specifies a key length SKE.KeyLen, along with encryption and decryption algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The encryption algorithm SKE.Encrypt(k, M) takes as input a key (byte string) k of length SKE.KeyLen and a message M. It outputs a ciphertext c.</li>
      <li>The decryption algorithm SKE.Decrypt(k, c) takes as input a key k of length SKE.KeyLen and a ciphertext c. It outputs a message M.</li>
    </ul>

    <p class="text-gray-300">We assume that the encryption and decryption algorithms are deterministic, and that the scheme is (perfectly) sound, in the sense that for all keys K and all messages M,</p>

    <p class="text-gray-300"><span class="math">$SKE.Decrypt(K, SKE.Encrypt(K, M)) = M.</span>$</p>

    <p class="text-gray-300">We shall need the following security property.</p>

    <p class="text-gray-300">Consider the following attack scenario. The adversary generates two messages (byte strings)  <span class="math">M_0, M_1</span>  of equal length. A random key k is generated. A random bit b is chosen, and  <span class="math">M_b</span>  is encrypted under key k. The resulting ciphertext c is given to the adversary. The adversary makes a guess  <span class="math">\\hat{b}</span>  at b. The adversary's advantage is defined as  <span class="math">|Pr[\\hat{b}=b]-1/2|</span> .</p>

    <p class="text-gray-300">For an adversary A that chooses  <span class="math">M_0, M_1</span>  of length bounded by l, we denote this advantage by  <span class="math">Advantage_{SKE}(A, l)</span> .</p>

    <p class="text-gray-300">Security means that the advantage is acceptably small.</p>

    <p class="text-gray-300">Note that one can build a secure symmetric key encryption scheme by using a pseudo-random byte generator (see &sect;7) to generate a &quot;one time pad,&quot; which is then XORed with the message.</p>

    <p class="text-gray-300">Also, the IEEE P1363a standard specifies other methods based on block ciphers that could be used as well. The ISO working group should perhaps consider other methods as well.</p>

    <p class="text-gray-300">A one-time message authentication code MAC is a scheme that defines two quantities MAC.KeyLen and MAC.TagLen, along with a function MAC.eval(k',T) that takes a key k' of length MAC.KeyLen and an arbitrary byte string T as input, and computes as output a byte string tag of length tag of length tag of length tag. We shall need the following security property.</p>

    <p class="text-gray-300">Consider the following attack scenario. A byte string  <span class="math">T^*</span>  is chosen by the adversary. A key k' is chosen at random. The MAC is evaluated at  <span class="math">T^*</span>  with key k', and the output  <span class="math">tag^*</span>  is given to the adversary. The adversary outputs a list of pairs (T, tag), where T is a byte string with  <span class="math">T \\neq T^*</span>  (and not necessarily of the same length as  <span class="math">T^*</span> ), and tag is a byte string of length MAC.TagLen. The adversary's advantage is defined to be the probability that for one such pair (T, tag), the MAC on input T with key k' is equal to tag.</p>

    <p class="text-gray-300">For an adversary A that chooses  <span class="math">T^*</span>  of length bounded by  <span class="math">l_1</span>  and at most  <span class="math">l_3</span>  pairs (T, tag) with T of length bounded by  <span class="math">l_2</span> , we denote this advantage by  <span class="math">Advantage_{MAC}(A, l_1, l_2, l_3)</span> .</p>

    <p class="text-gray-300">Security means that this advantage should be acceptably small.</p>

    <p class="text-gray-300">There are a number of acceptable one-time MAC schemes.</p>

    <p class="text-gray-300">Any of the schemes specified by the ISO MAC standard should be acceptable. IEEE P1363a standard also specifies a MAC that should be acceptable.</p>

    <section id="sec-10" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>10</strong> <em>DEM1</em></h2>

    <p class="text-gray-300">Given a symmetric encryption scheme SKE (see &sect;8), and a one-time message authentication code MAC (see &sect;9), here is how one can build a data encapsulation mechanism  <span class="math">DEM1 = DEM1_{SKE,MAC}</span> . We require that DEM1.KeyLen = SKE.KeyLen + MAC.KeyLen.</p>

    <p class="text-gray-300">To encrypt a message M with label L under a key K, we parse K as  <span class="math">K = k \\parallel k&#x27;</span> , where |k| = SKE.KeyLen and |k'| = MAC.KeyLen. We encrypt M using SKE under key k, obtaining its encryption c. Then we apply MAC to the byte string string  <span class="math">T = c \\parallel L \\parallel I2OSP(8 \\cdot |L|, 8)</span>  using k', obtaining tag. The entire ciphertext is  <span class="math">C_1 = c \\parallel tag</span> .</p>

    <p class="text-gray-300">To decrypt a a ciphertext  <span class="math">C_1</span>  with respect to a given label L, we first parse  <span class="math">C_1</span>  as  <span class="math">c \\parallel tag</span> , where |tag| = MAC.TagLen. This step may fail, of course, if  <span class="math">C_1</span>  is too short. We then parse K as  <span class="math">K = k \\parallel k&#x27;</span> , where |k| = SKE.KeyLen and |k'| = MAC.KeyLen. Then we apply the MAC with key k' to the byte string string  <span class="math">T = c \\parallel L \\parallel I2OSP(8 \\cdot |L|, 8)</span> , and test whether the resulting tag equals the given tag. If not, we report failure. Otherwise, decrypt c under k, obtaining M. It is possible that SKE.Decrypt fails. Finally, we output M.</p>

    <p class="text-gray-300">It is straightforward to show that if the underlying components are secure, then the resulting data encapsulation mechanism DEM1 is secure. Moreover, the reduction is quite &quot;tight&quot; quantitatively.</p>

    <p class="text-gray-300">Specifically, we have the following:</p>

    <p class="text-gray-300"><span class="math">$Advantage_{DEM1}(A) \\leq Advantage_{SKE}(A_1, l_1) + Advantage_{MAC}(A_2, l_2, l_3, q_D).</span>$</p>

    <p class="text-gray-300">Here,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">A_1, A_2</span>  are adversaries that run in about the same time as A,</li>
      <li><span class="math">l_1</span>  is a bound on the length of the target message,</li>
      <li><span class="math">l_2</span>  is a bound on the length of the string  <span class="math">T^*</span>  corresponding to the target ciphertext,</li>
      <li><span class="math">l_3</span>  is a bound on the length of the strings T corresponding to ciphertexts submitted to the decryption oracle,</li>
      <li><span class="math">q_D</span>  is a bound on the number of decryption oracle queries,</li>
      <li><span class="math">Advantage_{SKE}</span>  is as defined in &sect;8, and</li>
      <li><span class="math">Advantage_{MAC}</span>  is as defined in &sect;9.</li>
    </ul>

    <p class="text-gray-300">The proof of this is an easy exercise. However, the reader is referred to [CS01], where a detailed proof of a slight variant of this security claim is provided. Note, however, that the situation in that paper is slightly different than the one here, since that paper does not deal at all with the notion of a label. Nevertheless, the proof presented there can also be applied here, with only very minor changes.</p>

    <p class="text-gray-300">Note that we pass an encoding of the length of L to MAC. This is essential to ensure nonmalleability (see &sect;15.6.3). The particular mechanism used to encode the length was chosen so as to be compatible with the IEEE P1363a version of ECIES. In particular, we multiply |L| by 8 so as to encode the length of L in bits, rather than bytes, since the IEEE P1363a version of ECIES allows (in theory, but not really in practice) messages and labels that are bit strings rather than byte strings.</p>

    <p class="text-gray-300">We continue here the discussion started in &sect;2.2.3. In our hybrid construction, there is a single tag that is checked at the end of the ciphertext stream. This is the simplest approach, and one that is already seen in practice (as in ECIES). In the ACE-Encrypt submission, there was actually a tag value inserted every kilobyte or so in the ciphertext stream. The reason for this was so that the decryption algorithm would fail as soon as it detected a &quot;bad&quot; ciphertext stream. This would greatly enhance the ability of an application to process the output stream of the decryption algorithm in a stream-like fashion &mdash; it would not have to wait until the end of the output stream to detect a &quot;bad&quot; stream. It would not be too difficult to specify such a scheme. This point should perhaps be discussed by the working group.</p>

    <p class="text-gray-300">We shall assume the availability of a cryptographic hash function. Let Hash denote the scheme. Then Hash.OutputLen denotes the length of the hash function output, and Hash.eval denotes the hash function itself, which maps arbitrary length byte strings to byte strings of length Hash.OutputLen.</p>

    <p class="text-gray-300">The invocation of Hash.eval may fail if the input length exceeds some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">In the security analysis, we shall make the following types of assumptions about Hash:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It is collision resistant, i.e., it is hard to find two inputs x, y with x 6= y such that Hash.eval(x) = Hash.eval(y).</li>
      <li>It is second-preimage collision resistant, i.e., for a given set S of byte strings together with a prescribed probability distribution on S, if x &isin; S is chosen at random, then it is hard to find y &isin; S with x 6= y such that Hash.eval(x) = Hash.eval(y). The set S and the probability distribution depend on the application.</li>
      <li>It is a good entropy-smoothing hash function, i.e., for a given set S of byte strings together with a prescribed probability distribution on S, then if x &isin; S is chosen at random, the output Hash.eval(x) is computationally indistinguishable from a random byte string of length Hash.OutputLen. Of course, for this assumption to be reasonable, it must be the case that the entropy of S is sufficiently high.</li>
      <li>We might also choose to view it as a random oracle.</li>
    </ul>

    <p class="text-gray-300">Recommended choices for Hash are SHA-1 and RIPEMD-160.</p>

    <p class="text-gray-300">It is convenient to have a key derivation function KDF(x, l) that takes as input a byte string x and an integer l &ge; 0, and outputs a byte string of length l. The string x is of arbitrary length.</p>

    <p class="text-gray-300">The invocation of KDF may fail if the input or output lengths exceed some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">In the security analysis, we will often model KDF as a random oracle.</p>

    <p class="text-gray-300">A specific security property that is sometimes desirable for a key derivation function is that it be a good entropy smoothing function. That is, the input x is chosen at random from a distribution of byte strings with high entropy, then the output should be computationally indistinguishable from a random byte string of the same length.</p>

    <p class="text-gray-300">Sometimes the notion of a key derivation function is called a mask generating function (MGF); there seems to be no difference in meaning between the two terms.</p>

    <p class="text-gray-300">This function is parameterized by a hash function Hash (see 11), and is defined as follows. On input (x, l), the output is the first l bytes of</p>

    <p class="text-gray-300"><span class="math">$Hash.eval(x \\parallel I2OSP(0,4)) \\parallel \\cdots \\parallel Hash.eval(x \\parallel I2OSP(k-1,4)),</span>$</p>

    <p class="text-gray-300">where k = dl/Hash.OutputLene.</p>

    <p class="text-gray-300">This function is the same as the function called MGF1 in IEEE P1363.</p>

    <p class="text-gray-300">This function KDF2 is the same as KDF1, except that the counter runs from 1 to k, rather than from 0 to k &minus; 1.</p>

    <p class="text-gray-300">This function is the same as the function called KDF2 in IEEE P1363a, except that the latter allows for an output that is a bit string, rather than a byte string, and also allows for an extra key derivation parameter that we do not need here.</p>

      <h3 id="sec-12.3" class="text-xl font-semibold mt-8">12.3 Security critique of KDF1 and KDF2</h3>

    <p class="text-gray-300">Of course, if one chooses to model KDF1 (or KDF2) as a random oracle in a security analysis, one is free to do so. There is really not much of a rational basis to argue either for or against such a choice.</p>

    <p class="text-gray-300">However, we do not recommend the use of these functions in applications where one requires the entropy smoothing property discussed above. The only point in this document where this is significant is in the analysis of the variant of the ACE-Encrypt scheme discussed in &sect;17, whose security analysis is not based on the random oracle heuristic.</p>

    <p class="text-gray-300">Our reasoning is as follows.</p>

    <p class="text-gray-300">If we were to believe that these were good entropy smoothing functions, this would suggest that the function Fx(y) defined by</p>

    <p class="text-gray-300"><span class="math">$F_x(y) = Hash.eval(x \\parallel y)</span>$</p>

    <p class="text-gray-300">should be a &quot;good&quot; pseudo-random function with key x and input y. However, standard hash functions, like SHA-1, are built using a particular block cipher Pa(b) &mdash; with key a and input block b &mdash; chained in a standard way. Indeed, suppose that Hash is SHA-1 with initial chaining value IV and that x is 512-bits long. So in this case, Pa(b) is a block cipher with a 512-bit key size, and a 160-bit block size. Then</p>

    <p class="text-gray-300"><span class="math">$F_x(y) = P_y(z) \\oplus z</span>$
, where,  <span class="math">z = P_x(IV) \\oplus IV</span> .</p>

    <p class="text-gray-300">Assuming that Pa(b) is a good block cipher, and that x is suitably random, then the value z above should be pseudo-random. Therefore, the security of Fx(y) as a pseudo-random function is equivalent to the security of the function Gz(y) defined by</p>

    <p class="text-gray-300"><span class="math">$G_z(y) = P_y(z) \\oplus z</span>$</p>

    <p class="text-gray-300">as a pseudo-random function with key z and input y. Is Gz(y) a good pseudo-random function? This is not clear. But certainly, this is a quite unorthodox construction that does not appear to be based on any well-worn or otherwise sound principles.</p>

    <p class="text-gray-300">Because of this perceived potential weakness, we propose two further key derivation functions, KDF3 and KDF4. Either of these can be used in a situation where a random oracle is required. However, these functions seem more reasonable in applications where the entropy smoothing property is required.</p>

    <p class="text-gray-300">This function is parameterized by a hash function Hash and a padding amount pamt &ge; 4, and is defined as follows. On input (x, l), the output is the first l bytes of</p>

    <p class="text-gray-300"><span class="math">$Hash.eval(I2OSP(0, pamt) \\parallel x) \\parallel \\cdots \\parallel Hash.eval(I2OSP(k-1, pamt) \\parallel x),</span>$</p>

    <p class="text-gray-300">where k = dl/Hash.OutputLene.</p>

    <p class="text-gray-300">Recommended choices for the hash function are SHA-1 or RIPEMD-160. Recommended choices for pamt are either 4, or the block size of the underlying hash (64 in the case of SHA-1 or RIPEMD-160).</p>

    <p class="text-gray-300">Based upon the way standard hash functions like SHA-1 or RIPEMD-160 are constructed, it seems like a reasonable assumption is that they are good pseudo-random functions, where we view the text input as the key of the function, and we view the initial vector IV as the input to the function. Typical implementations of these hash functions often do not provide an interface that allows the programmer to choose the IV. However, we get the equivalent effect by setting pamt to the block size of the underlying hash.</p>

    <p class="text-gray-300">By setting pamt to the block size of the underlying hash function, we are able to give a reasonable justification for the security of KDF3. If we set pamt to another value, such as 4, this justification is no longer valid. Nevertheless, setting pamt = 4 does not seem like a completely unreasonable choice, and certainly the arguments we made above against KDF1 and KDF2 no longer apply.</p>

    <p class="text-gray-300">This function is parameterized by a hash function Hash and a pseudo-random byte generator PRBG (see &sect;7). It is required that Hash.OutputLen = PRBG.SeedLen.</p>

    <p class="text-gray-300">On input (x, l), this function outputs</p>

    <p class="text-gray-300">PRBG.eval(Hash.eval(x), l).</p>

    <p class="text-gray-300">For the hash function, one can use a standard function like SHA-1 or RIPEMD-160. If PRBG.SeedLen is less than 20, then one can simply truncate the output of the hash function.</p>

    <p class="text-gray-300">This function will be a good entropy smoothing function, provided Hash is a good entropy smoothing function, and provided PRBG is secure as a pseudo-random byte generator.</p>

    <p class="text-gray-300">We describe a group as an abstract data type. As a matter of convention, we shall always use additive notation for a group. Also, group elements will be typeset in boldface, and 0 denotes the identity element of the group.</p>

    <p class="text-gray-300">A fully specified group Group is a tuple (H, G, g, &micro;, &nu;, E, D, E 0 , D<sup>0</sup> ), where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H is a finite abelian group in which all group computations are actually performed. Note that this group need not be cyclic.</li>
      <li>G is a cyclic subgroup of H. This is where the real &quot;action&quot; will normally take place in a cryptographic scheme.</li>
      <li>g is a generator for G.</li>
      <li>&micro; is the order (size) of G, and &nu; is the index of G in H, i.e., &nu; = |H|/&micro;. We shall require that &micro; is prime. For some cryptographic schemes, we make the stronger requirement that gcd(&micro;, &nu;) = 1.</li>
      <li>E(a, format) is an &quot;encoding&quot; function that maps a group element a &isin; H to a byte string. The second argument format may be used to choose from one of several possible formats for the encoding of a group element.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We do not strongly recommend the use of multiple encoding formats, but it is in some cases an already established practice which we need to properly model here.</li>
      <li>We require that the set of all outputs of E is a subset of some easy-to-recognize, prefix-free language.</li>
    </ul></li>
      <li>D(x) is a function that fails if x is not a proper encoding of an element of H; otherwise, it returns the group element a &isin; H such that E(a) = x.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If a group supports multiple encoding formats, we require that the format value used to encode a group element is evident from the encoding itself.</li>
    </ul></li>
      <li>E<sup>0</sup> (a) is a &quot;partial encoding&quot; function that maps a group element a &isin; H to a byte string. We require that the set of all outputs of E 0 is a subset of some easy-to-recognize, prefix-free language.</li>
      <li>D<sup>0</sup> (x) is a function that either fails if x is not a proper partial encoding of an element of H; otherwise, it returns the set containing all group elements a &isin; H such that E 0 (a) = x. We will assume that the size of this set is bounded by a small constant.</li>
    </ul>

    <p class="text-gray-300">All of the above algorithms should have efficient implementations. The function D<sup>0</sup> will never be used by any of the schemes, but the existence of this function is necessary to analyze their security. We of course assume that arithmetic in H can be carried out efficiently.</p>

    <p class="text-gray-300">We also assume that we can efficiently test if an element of H lies in the subgroup G. If all elements in H of order &micro; lie in G, then we can test if a &isin; G by testing if &micro; &middot; a = 0. This test is therefore applicable of H is itself cyclic, or if gcd(&micro;, &nu;) = 1. For specific groups, there may be more efficient tests of subgroup membership.</p>

    <p class="text-gray-300">This abstraction is meant to be flexible enough to model two important classes of groups: subgroups of Z &lowast; p , and subgroups of elliptic curves.</p>

      <h3 id="sec-13.1" class="text-xl font-semibold mt-8">13.1 Subgroups of <span class="math">\\mathbf{Z}_{v}^{*}</span></h3>

    <p class="text-gray-300">Let p be a prime, and consider the multiplicative group of units modulo p, denoted  <span class="math">\\mathbf{Z}_p^*</span> . Let  <span class="math">\\mathcal{H}</span>  denote this group. Let  <span class="math">\\mathcal{G}</span>  denote any prime-order subgroup of  <span class="math">\\mathbf{Z}_p^*</span> . Set  <span class="math">\\mu = |\\mathcal{G}|</span>  and  <span class="math">\\nu = (p-1)/\\mu</span> . Because  <span class="math">\\mathcal{H}</span>  is itself cyclic, it follows that  <span class="math">\\mathcal{G}</span>  contains all elements of  <span class="math">\\mathcal{H}</span>  whose order divides  <span class="math">\\mu</span> , even if  <span class="math">\\gcd(\\mu,\\nu) \\neq 1</span> . The encoding map  <span class="math">\\mathcal{E}</span>  can be implemented using the function I2OSP, where all group elements are encoded as byte strings of length  <span class="math">\\lceil \\log_{256} p \\rceil</span> . The map  <span class="math">\\mathcal{D}</span>  can be implemented using OS2IP. The function  <span class="math">\\mathcal{E}&#x27;</span>  is the same as  <span class="math">\\mathcal{E}</span> , and  <span class="math">\\mathcal{D}&#x27;</span>  is the same as  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">Note that one can also work with subgroups of arbitrary finite fields, as is done in IEEE P1363.</p>

    <p class="text-gray-300">Let E be an elliptic curve defined over a finite field  <span class="math">\\mathbf{F}_q</span> . Let  <span class="math">\\mathcal{H}</span>  denote this group. Note that  <span class="math">\\mathcal{H}</span>  is not in general cyclic. Let  <span class="math">\\mathcal{G}</span>  denote a prime-order subgroup, and let  <span class="math">\\mu</span>  be its order, and  <span class="math">\\nu</span>  be its index in  <span class="math">\\mathcal{H}</span> . The encoding/decoding maps  <span class="math">\\mathcal{E}</span>  and  <span class="math">\\mathcal{D}</span>  can be implemented using the techniques described in IEEE P1363. Note that these encoding techniques allow for a variety of formats: uncompressed, compressed, and hybrid. The partial encoding map  <span class="math">\\mathcal{E}&#x27;</span>  outputs a fixed length byte string encoding of the x-coordinate of the point, provided the point is not the &quot;point at infinity&quot;; otherwise, it outputs, say, the all-zero byte string of the same fixed length. The partial decoding map  <span class="math">\\mathcal{D}&#x27;</span>  converts the given by string back into an element of  <span class="math">\\mathbf{F}_q</span> , and then solves a polynomial equation to find the set of possible y-coordinates (there are at most two).</p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">$Group = (\\mathcal{H}, \\mathcal{G}, \\mathbf{g}, \\mu, \\nu, \\mathcal{E}, \\mathcal{D}, \\mathcal{E}&#x27;, \\mathcal{D}&#x27;)</span>$</p>

    <p class="text-gray-300">as in  <span class="math">\\S 13</span> .</p>

      <h3 id="sec-14.1" class="text-xl font-semibold mt-8">14.1 The Computational Diffie-Hellman Problem</h3>

    <p class="text-gray-300">The Computational Diffie-Hellman (CDH) problem for this group is as follows. On input  <span class="math">(x\\mathbf{g}, y\\mathbf{g})</span> , where  <span class="math">x, y \\in \\{0, \\dots, \\mu - 1\\}</span> , compute  <span class="math">xy \\cdot \\mathbf{g}</span> . We assume the inputs are random, i.e., that x and y are randomly chosen from the set  <span class="math">\\{0, \\dots, \\mu - 1\\}</span> .</p>

    <p class="text-gray-300">The CDH assumption is the assumption that this problem is intractable.</p>

    <p class="text-gray-300">Note that in general, it is not feasible to even identify a correct solution to the CDH problem (this is the Decisional Diffie-Hellman problem &mdash; see below). In analyzing cryptographic systems, the types of algorithms for solving the CDH that most naturally arise are algorithms that produce a list of candidate solutions to a given instance of the CDH problem. For any algorithm A for the CDH problem that produces a list of length at most l, we let  <span class="math">Advantage_{CDH}(A, l)</span>  denote the probability that this list contains a correct solution to the input problem instance.</p>

    <p class="text-gray-300">Note that in [Sho97], it is shown how to take an algorithm A with  <span class="math">\\epsilon = Advantage_{CDH}(A, l)</span> , and transform this into an algorithm A' that produces a single output that for all inputs is correct with probability  <span class="math">1 - \\delta</span> . The running time of A' is roughly equal to  <span class="math">O(\\epsilon^{-1} \\log(1/\\delta))</span>  times that of A, plus the time to perform</p>

    <p class="text-gray-300"><span class="math">$O(\\epsilon^{-1}l\\log(1/\\delta)\\log\\mu + (\\log\\mu)^2)</span>$</p>

    <p class="text-gray-300">additional group operations.</p>

    <p class="text-gray-300">It is well known that the CDH problem is &quot;random self reducible.&quot;</p>

      <h3 id="sec-14.2" class="text-xl font-semibold mt-8">14.2 The Decisional Diffie-Hellman Problem</h3>

    <p class="text-gray-300">The Decisional Diffie-Hellman (DDH) problem is as follows.</p>

    <p class="text-gray-300">We define two distributions.</p>

    <p class="text-gray-300">Distribution R consists of triples (xg, yg, zg), where x, y, z are chosen at random from {0, . . . , &micro; &minus; 1}. Let X<sup>R</sup> denote a random variable sampled from this distribution.</p>

    <p class="text-gray-300">Distribution D consists of triples (xg, yg, zg), where x, y are chosen at random from {0, . . . , &micro;&minus; 1}, and z = xy mod &micro;. Let X<sup>D</sup> denote a random variable sampled from this distribution.</p>

    <p class="text-gray-300">The problem is to distinguish these two distributions.</p>

    <p class="text-gray-300">For an algorithm A that outputs either 0 or 1, we define</p>

    <p class="text-gray-300"><span class="math">$Advantage_{DDH}(A) = |\\Pr[A(X_{\\mathbf{R}}) = 1] - \\Pr[A(X_{\\mathbf{D}}) = 1]|.</span>$</p>

    <p class="text-gray-300">The DDH assumption is that this advantage is negligible for all efficient algorithms.</p>

    <p class="text-gray-300">The DDH problem is &quot;random self-reducible&quot; (see [Sta96] and [NR97]). See [Bon98] and [NR97] for further discussion of the DDH.</p>

    <p class="text-gray-300">The submitters of the PSEC scheme have proposed a new computational assumption, called the gap-CDH assumption. This is the assumption that it is hard to solve the CDH problem, even in the presence of an oracle for solving the DDH problem.</p>

    <p class="text-gray-300">This assumption is not entirely unreasonable, as it it is easily seen that there is no &quot;black box&quot; reduction from the CDH problem to the DDH problem. This can easily be proven in the &quot;black box group&quot; or &quot;generic group&quot; model of [Sho97].</p>

    <p class="text-gray-300">For any algorithm A that makes at most q queries to a DDH oracle, we define AdvantageGapCDH(A, q) to the the probability that A solves a random instance of the CDH problem. See [OP01] for more details about this assumption.</p>

    <p class="text-gray-300">We present here an encryption scheme that is a slight variant of ECIES, and also bears many similarities to PSEC-3. What we describe is actually a key encapsulation mechanism, which we call ECIES-KEM.</p>

    <p class="text-gray-300">We have to describe the key generation, encryption, and decryption algorithms.</p>

      <h3 id="sec-15.1" class="text-xl font-semibold mt-8">15.1 Key Generation</h3>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">$Group = (\\mathcal{H}, \\mathcal{G}, \\mathbf{g}, \\mu, \\nu, \\mathcal{E}, \\mathcal{D}, \\mathcal{E}&#x27;, \\mathcal{D}&#x27;)</span>$</p>

    <p class="text-gray-300">is chosen.</p>

    <p class="text-gray-300">Two additional parameters need to be chosen, which we call CofactorMode and CheckMode. Each of these parameters take 0/1 values. These modes are used to deal with security problems that can arise when &nu; &gt; 1. Here are the rules which should be obeyed in setting these modes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">If &nu; = 1, then both of these modes should be 0.</p></li>
      <li><p class="text-gray-300">If &nu; &gt; 1, both modes can be set to 0, provided gcd(&micro;, &nu;) = 1 and &nu; is very small. Note that security in this case degrades by a factor of &nu;.</p></li>
      <li><p class="text-gray-300">If &nu; &gt; 1, CofactorMode may be set to 1 provided gcd(&micro;, &nu;) = 1.</p></li>
      <li><p class="text-gray-300">At most one of CofactorMode and CheckMode should be set to 1.</p></li>
    </ul>

    <p class="text-gray-300">In addition to Group, a key derivation function KDF needs to be selected.</p>

    <p class="text-gray-300">Next, a number x &isin; {1, . . . , &micro; &minus; 1} is chosen at random, and the group element h = xg is computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group and h, along with an indication of the choice of KDF. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key, together with the number x and the values CofactorMode and CheckMode.</p>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext C<sup>0</sup> that is an encryption of a key K, where K is a byte string of length KeyLen = ECIES-KEM.OutputKeyLen.</p>

    <p class="text-gray-300">In this scheme, the encryption algorithm may take an optional argument format that specifies the format to be used for encoding group elements. The algorithm runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose r &isin; {1, . . . , &micro; &minus; 1} at random.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute g&tilde; = rg and h&tilde; = rh.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the ciphertext</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$C_0 = \\mathcal{E}(\\tilde{\\mathbf{g}}, format),</span>$</p>

    <p class="text-gray-300">and the key</p>

    <p class="text-gray-300"><span class="math">$K = KDF(C_0 \\parallel \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}}), KeyLen).</span>$</p>

    <p class="text-gray-300">The decryption algorithm on input C<sup>0</sup> runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse C<sup>0</sup> as the encoding of a group element g&tilde; &isin; H. This step fails is C<sup>0</sup> is not a proper encoding of an element of H.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If CheckMode = 1, test if g&tilde; &isin; G; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If CofactorMode = 1, set g&circ; = &nu;g&tilde; and &circ;x = &nu; <sup>&minus;</sup>1x mod &micro;; otherwise, set g&circ; = g&tilde; and &circ;x = x.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute h&tilde; = &circ;xg&circ;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If h&tilde; = 0, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$K = KDF(C_0 \\parallel \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}}), KeyLen).</span>$</p>

      <h3 id="sec-15.4" class="text-xl font-semibold mt-8">15.4 Some remarks</h3>

    <p class="text-gray-300">Using CofactorMode = 1 may yield a performance benefit if &nu; is fairly small. Note that in this mode, an implementation could simply pre-compute and store the value &circ;x, instead of the value x.</p>

      <h3 id="sec-15.5" class="text-xl font-semibold mt-8">15.5 Security considerations</h3>

    <p class="text-gray-300">This scheme can be proved secure against adaptive chosen ciphertext attack in the random oracle model under the gap-CDH assumption (see  <span class="math">\\S14.3</span> ). Here, we model KDF as a random oracle.</p>

    <p class="text-gray-300">Indeed, it is straightforward to show that</p>

    <p class="text-gray-300"><span class="math">$Advantage_{ECIES\\text{-}KEM}(A) = O(Advantage_{GanCDH}(A&#x27;, q_{KDF}))</span>$</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A' is an algorithm with access to a DDH oracle whose running time is about the same as that of A,</li>
      <li><span class="math">q_{KDF}</span>  is a bound on the number of random oracle queries, and</li>
      <li><span class="math">Advantage_{GanCDH}</span>  is as defined in &sect;14.3.</li>
    </ul>

    <p class="text-gray-300">This estimate assumes that either CofactorMode = 1 or CheckMode = 1; otherwise, the security bound is</p>

    <p class="text-gray-300"><span class="math">$Advantage_{ECIES\\text{-}KEM}(A) = O(\\nu \\cdot Advantage_{GapCDH}(A&#x27;, q_{KDF})).</span>$</p>

    <p class="text-gray-300">A detailed proof of a slight variant of this security claim can be found in [CS01]. Note, however, that the situation there is slightly different than the one here: that paper only considers the case where CheckMode = 1 and where group elements have unique encodings. Nevertheless, the proof in that paper can be easily adapted to the situation here.</p>

    <p class="text-gray-300">This scheme can also be proved secure under an appropriate &quot;oracle hashing&quot; assumption, as put forward in the DHAES paper [ABR99].</p>

      <h3 id="sec-15.6" class="text-xl font-semibold mt-8">15.6 Compatibility with the IEEE P1363a version of ECIES</h3>

    <p class="text-gray-300">The key encapsulation mechanism ECIES-KEM, when combined with the data encapsulation mechanism DEM1 described in &sect;10, yields a hybrid encryption scheme that is compatible with the IEEE P1363a version of ECIES, provided the choice of group, KDF, MAC, SKE is restricted to be consistent with the IEEE P1363a version.</p>

    <p class="text-gray-300">To remain compatible with IEEE P1363a, we have restricted the group elements  <span class="math">\\tilde{\\mathbf{g}}</span> ,  <span class="math">\\mathbf{h}</span> , and in particular  <span class="math">\\tilde{\\mathbf{h}}</span>  to <em>not</em> be the identity. In particular, this means that the partial encoding function  <span class="math">\\mathcal{E}&#x27;</span>  is never evaluated at  <span class="math">\\mathbf{0}</span> , which is consistent with IEEE P1363a.</p>

    <p class="text-gray-300">Note that we have made a number of restrictions on the scheme that are not made in the IEEE P1363a version:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Key derivation using</strong>  <span class="math">C_0</span> : we insist that  <span class="math">C_0</span>  be passed to KDF, whereas this is optional in IEEE P1363a.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>No other key derivation parameters: we do not allow any key derivation parameters, whereas IEEE P1363a allows an arbitrary byte string as a key derivation parameter.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Proper label formatting:</strong> we insist that the input to the MAC include the length of the label L, whereas this is optional in IEEE P1363a.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>No stream cipher option: we insist on performing data encapsulation using the DEM1 scheme described in &sect;10, whereas IEEE P1363a allows an alternative mechanism in which KDF is used directly as a stream cipher.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>No use of &quot;old&quot; cofactor mode: we insist on using the newer, &quot;compatible&quot; cofactor mode, whereas IEEE P1363a also allows the use of an &quot;old&quot; cofactor mode.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Messages are byte strings: we insist that messages are byte strings, whereas IEEE P1363a allows these to be bit strings.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Static selection of system parameters: we insist that all system parameters, including the choice of KDF, SKE, and MAC, be fixed at key generation time, whereas IEEE P1363a allows these to vary dynamically over the lifetime of the public key.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>gcd(&micro;, &nu;) = 1 if both CofactorMode and CheckMode are zero: we insist on this, whereas IEEE P1363a does not.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Each of these restrictions is discussed in turn below. For each restriction, we discuss the rationale for the restriction, and also discuss the the option of easing the restriction so as to achieve greater compatibility with IEEE P1363a. Although in each case, we provide particular arguments for making the recommended restriction, one general argument that applies in all cases is the appeal for simplicity: the IEEE P1363a version of ECIES provides a fairly bewildering array of options, and it is not clear if all of these options are either desirable or useful.</p>

    <p class="text-gray-300">We insist that C<sup>0</sup> be passed to KDF, whereas this is optional in IEEE P1363a.</p>

    <p class="text-gray-300">We offer two reasons for this requirement.</p>

    <p class="text-gray-300">First, without this requirement, the scheme does not achieve security against adaptive chosen ciphertext attack.</p>

    <p class="text-gray-300">There are a number of simple examples that illustrate why ECIES does not achieve this level of security. In particular, it is malleable. If the group is an elliptic curve, and the partial encoding function E 0 encodes only the x-coordinate of a point, then the derived key K is the same if one takes a given ciphertext C<sup>0</sup> encoding a point g&tilde; and replaces it with an encoding of &minus;g&tilde;. A similar problem arises if &nu; &gt; 1 and CofactorMode = 1 &mdash; in this case, one could add to g&tilde; a non-zero element whose order divides &nu;, and one obtains yet again a different ciphertext that decrypts to the same thing. Essentially the same problem arises again if the group supports multiple encoding formats.</p>

    <p class="text-gray-300">Of course, this does not represent a catastrophic failure of the system; it simply illustrates that the definition of adaptive chosen ciphertext security is not met in a strict sense. Indeed, the scheme is still secure in the sense of being only benignly malleable (see &sect;2.3), which may be acceptable in many applications. Note, however, that if &nu; &gt; 1 and both CofactorMode and CheckMode are zero, then the scheme does not even achieve our weaker notion of benign malleability: it still does not appear to be patently insecure, but it is not clear what useful abstract security properties one can establish for the scheme.</p>

    <p class="text-gray-300">The second reason for our requirement is that including C<sup>0</sup> as an input to KDF yields a much tighter reduction from the gap-CDH problem. If q<sup>D</sup> is the number of decryption requests, and qKDF is the number of random oracle requests, then without the hash of C0, the number of DDH oracle calls that must be made is qKDF &middot;qD, whereas with the hash of C0, this drops to qKDF. This security advantage is amplified even further in the multi-user/multi-message setting (see [BBM00]).</p>

    <p class="text-gray-300">The latest draft of IEEE P1363a allows for an optional &quot;DHAES mode,&quot; which (among other things) passes C<sup>0</sup> to KDF in just the same way we have done here. Thus, by making this requirement, the ISO standard would conform to the IEEE P1363a standard. Instead of just allowing it, we strongly recommended that the ISO standard requires it, so as to achieve full non-malleability, and perhaps more importantly, to obtain a much tighter security reduction, especially since the cost of hashing  <span class="math">C_0</span>  is negligible compared to the cost of the public-key operations. However, it would also be acceptable if the ISO standard allowed a variation of the scheme in which  <span class="math">C_0</span>  is not hashed, in order to achieve a greater degree of consistency between IEEE P1363a and the ISO standard.</p>

      <h4 id="sec-15.6.2" class="text-lg font-semibold mt-6">15.6.2 No other key derivation parameters</h4>

    <p class="text-gray-300">We do not allow any key derivation parameters, whereas IEEE P1363a allows an arbitrary byte string as a key derivation parameter.</p>

    <p class="text-gray-300">The notion of a key derivation parameter does not fit well with the abstract interface for encryption proposed in this document, and since it is a quite unusual functionality, it seems likely that this is a feature of the IEEE P1363a version of <em>ECIES</em> that will quickly atrophy. Indeed, none of the other encryption scheme in IEEE P1363 support an analogous feature. Nevertheless, if this feature is desired, it could be included for backward compatibility's sake.</p>

      <h4 id="sec-15.6.3" class="text-lg font-semibold mt-6">15.6.3 Proper label formatting</h4>

    <p class="text-gray-300">We insist that the input to the MAC include the length of the label L, whereas this is optional in IEEE P1363a.</p>

    <p class="text-gray-300">In an early draft of the IEEE P1363a version of <em>ECIES</em>, the <em>MAC</em> is evaluated (in our notation) on the string  <span class="math">c \\parallel L</span> , instead of on the string  <span class="math">c \\parallel L \\parallel I2OSP(8 \\cdot |L|, 8)</span> , as we have proposed in &sect;10.</p>

    <p class="text-gray-300">The reason we insist on this adding this length information as input to MAC, is that without it, the scheme may be malleable.</p>

    <p class="text-gray-300">The problem is that without encoding the length of L in MAC input, one can potentially choose any pair of strings (c', L') such that  <span class="math">c&#x27; \\parallel L&#x27; = c \\parallel L</span> , and then the decryption oracle in a chosen ciphertext attack when supplied with the same ciphertext but with label L' instead of L may leak interesting information about the target message.</p>

    <p class="text-gray-300">This problem was identified and brought to the attention to the IEEE P1363 working group by David Hopwood, as well as through an earlier version of this document. The latest version of the IEEE P1363a draft supports an optional &quot;DHAES mode,&quot; which (among other things) provides the same &quot;fix&quot; that we propose here. For compatibility reasons, one might allow variations without the fix, but then require a restriction, such as the restriction that the label must be <em>empty</em>, or that all messages are of a length that is fixed for the lifetime of the public key (which would also be consistent with the recommendation below in &sect;15.6.4).</p>

      <h4 id="sec-15.6.4" class="text-lg font-semibold mt-6">15.6.4 No stream cipher option</h4>

    <p class="text-gray-300">We insist on performing data encapsulation using the DEM1 scheme described in &sect;10, whereas IEEE P1363a allows an alternative mechanism in which KDF is used directly as a stream cipher.</p>

    <p class="text-gray-300">The reason we insist on this restriction, is that without it, the scheme is malleable in a very strong sense.</p>

    <p class="text-gray-300">We first describe the &quot;stream cipher option,&quot; and then we describe the attack.</p>

    <p class="text-gray-300">Suppose the input to the encryption algorithm is a message M of length l, and a label L. After the shared Diffie-Hellman key  <span class="math">\\tilde{\\mathbf{h}}</span>  is produced, a key derivation function is applied to obtain a string  <span class="math">k \\parallel k&#x27;</span> , where k has length l and k' has length MAC.KeyLen. The ciphertext is</p>

    <p class="text-gray-300"><span class="math">$C = (C_0, c, MAC.eval(k&#x27;, c \\parallel L)),</span>$</p>

    <p class="text-gray-300">where  <span class="math">c = M \\oplus k</span>  and  <span class="math">C_0</span>  is the encoding of the ephemeral Diffie-Hellman key  <span class="math">\\tilde{\\mathbf{g}}</span> . Now we describe the attack. Suppose</p>

    <p class="text-gray-300"><span class="math">$C = (C_0, c, tag)</span>$</p>

    <p class="text-gray-300">is the encryption of a message M with label L, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the length l of M is equal to l' + MAC.KeyLen for l' &gt; 0,</li>
      <li><span class="math">c = c_1 \\parallel c_2</span> , where  <span class="math">|c_1| = l&#x27;</span>  and  <span class="math">|c_2| = MAC.KeyLen</span></li>
      <li><span class="math">M = M_1 \\parallel M_2</span> , where  <span class="math">|M_1| = l&#x27;</span>  and  <span class="math">|M_2| = MAC.KeyLen</span> , and</li>
      <li><span class="math">M_2</span>  is known to the attacker.</li>
    </ul>

    <p class="text-gray-300">Then for any byte string  <span class="math">\\Delta</span>  of length l', and any label  <span class="math">\\tilde{L}</span> , the ciphertext</p>

    <p class="text-gray-300"><span class="math">$\\tilde{C} = (C_0, \\tilde{c}, MAC.eval(\\tilde{k}, \\tilde{c} \\parallel \\tilde{L})),</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\tilde{c} = c_1 \\oplus \\Delta \\text{ and } \\tilde{k} = c_2 \\oplus M_2,</span>$</p>

    <p class="text-gray-300">is a valid encryption of  <span class="math">M_1 \\oplus \\Delta</span>  with label  <span class="math">\\tilde{L}</span> .</p>

    <p class="text-gray-300">Thus, the scheme is trivially malleable, in a very strong way: we can transform the encryption of  <span class="math">M_1 \\parallel M_2</span>  with label L into an encryption of  <span class="math">M_1 \\oplus \\Delta</span>  with label  <span class="math">\\tilde{L}</span> , for any  <span class="math">\\Delta</span>  and any  <span class="math">\\tilde{L}</span> .</p>

    <p class="text-gray-300">This problem could easily have been avoided if the output of the key derivation function was parsed as  <span class="math">k&#x27; \\parallel k</span>  instead of  <span class="math">k \\parallel k&#x27;</span> . Indeed, if this were done, the security of the data encapsulation method could be proven secure under standard assumptions.</p>

    <p class="text-gray-300">Because of this rather serious flaw in the design of <em>ECIES</em>, this mode of data encapsulation was not included in our proposal here, and it is strongly recommended that the ISO version of <em>ECIES</em> not allow this mode of data encapsulation.</p>

    <p class="text-gray-300">The only possible circumstances under which the stream cipher option would be acceptable as an option would be if the message length were <em>fixed</em> for the lifetime of a public key.</p>

    <p class="text-gray-300">The current IEEE P1363a draft document recommends using the stream cipher option only in applications where the message is short, such as key transport, but the reasons given are efficiency (decryption cannot be performed in a single pass) and the fact that the recommended instantiations of KDF have not traditionally been used as stream ciphers, and so there may be unforeseen security problems in their use as such. However, no recommendation is made in IEEE P1363a that the length of the message should be <em>fixed</em> for all ciphertexts. Thus, this appears to be an authentic, and perhaps serious, security hole in ECIES. The same problem appears in the versions of ECIES submitted to ISO, submitted to Crypto-Nessie, and in the draft of ANSI X9.63.<sup>4</sup></p>

      <h4 id="sec-15.6.5" class="text-lg font-semibold mt-6">15.6.5 No use of &quot;old&quot; cofactor mode</h4>

    <p class="text-gray-300">We insist on using the newer, &quot;compatible&quot; cofactor mode, whereas IEEE P1363a also allows the use of an &quot;old&quot; cofactor mode.</p>

    <p class="text-gray-300">The cofactor mode described in this document corresponds to what is called &quot;compatible&quot; cofactor mode in the IEEE P1363a version of <em>ECIES</em>. That version of <em>ECIES</em> also allows another mode, which we shall call here &quot;old&quot; cofactor mode. &quot;Old&quot; cofactor mode appeared in the <em>ECIES</em></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>This refers to the draft of January 8, 1999.</p>

    <p class="text-gray-300">submission to ISO, but &quot;compatible&quot; cofactor mode did not. Both of these modes deal quite effectively with the potential problem of small subgroup attacks when &nu; 6= 1. The advantage of &quot;compatible&quot; cofactor mode over &quot;old&quot; cofactor mode is that the encryption algorithm is oblivious to it in the former, while it needs to be aware of it in the latter. &quot;Old&quot; cofactor mode appears to offer no advantages at all, and so we recommend not including it in the ISO standard. However, we could include it for compatibility reasons, without any great harm.</p>

    <p class="text-gray-300">Note that &quot;compatible&quot; cofactor mode is not &quot;just&quot; an alternative implementation of the decryption algorithm: the behavior of the decryption algorithm is different when using this mode than it is when not, as some ciphertexts that would be rejected without this mode, will not be rejected with this mode.</p>

      <h4 id="sec-15.6.6" class="text-lg font-semibold mt-6">15.6.6 Messages are byte strings</h4>

    <p class="text-gray-300">We insist that messages are byte strings, whereas IEEE P1363a allows these to be bit strings.</p>

    <p class="text-gray-300">See &sect;2.1.8 for a discussion of why we work only with byte strings. It is mentioned there that the IEEE P1363a version of ECIES allows bit strings, but even that is not entirely true, since the underlying symmetric-key encryption schemes that it currently allows do not support bit strings. The only exception to this is when the &quot;stream cipher option&quot; discussed in &sect;15.6.4 is used, but as we have already argued, this option should anyway not be allowed in the ISO standard.</p>

      <h4 id="sec-15.6.7" class="text-lg font-semibold mt-6">15.6.7 Static selection of system parameters</h4>

    <p class="text-gray-300">We insist that all system parameters, including the choice of KDF, SKE, and MAC be fixed at key generation time, whereas IEEE P1363a allows these to vary dynamically over the lifetime of the public key. Although the latter is not recommended in IEEE P1363a, due to possible security problems that may arise from &quot;unintended interactions&quot; of different options, it is nevertheless allowed.</p>

    <p class="text-gray-300">It is the opinion of this author that allowing such flexibility is entirely unacceptable: all hope of a meaningful security analysis vanishes if one allows for this, and there may indeed be real harm that could come from &quot;unintended interactions.&quot; This proposal recommends with the strongest possible urgency that the ISO standard should require all such options to be fixed at key generation time. In addition, all scheme options discussed above, such as not including C<sup>0</sup> in the key derivation function, allowing additional key derivation parameters, cofactor mode, check mode, etc., should be determined at key generation time and fixed for the lifetime of public key.</p>

      <h4 id="sec-15.6.8" class="text-lg font-semibold mt-6">15.6.8 gcd(&micro;, &nu;) = 1 if both CofactorMode and CheckMode are zero</h4>

    <p class="text-gray-300">We insist on this, whereas IEEE P1363a does not.</p>

    <p class="text-gray-300">The reason is that without this restriction, it does not seem possible to reason about the security of the scheme, whereas with this restriction, it is possible.</p>

    <p class="text-gray-300">Without going into all the details, we just note that if gcd(&micro;, &nu;) = 1, then one can decompose H as the direct sum of G and the subgroup G <sup>0</sup> &sub; H consisting of all elements of H whose order divides &nu;. This decomposition is effective, in the sense that given a &isin; H, one can efficiently compute a<sup>1</sup> &isin; G and a<sup>2</sup> &isin; G<sup>0</sup> such that a = a<sup>1</sup> + a2. The existence of an effective decomposition such as this is critical to the proof of security.</p>

    <p class="text-gray-300">Making this requirement most likely will have little practical impact, since it is very unusual to have gcd(&micro;, &nu;) 6= 1.</p>

      <h3 id="sec-15.7" class="text-xl font-semibold mt-8">15.7 Compatibility with the submitted version of ECIES</h3>

    <p class="text-gray-300">There are a number of differences between the IEEE P1363a version of ECIES and the version of ECIES that was submitted to the ISO.</p>

    <p class="text-gray-300">First, and most prominently, the IEEE P1363a version allows subgroups of finite fields as groups in addition to just elliptic curve groups, as in the submitted version.</p>

    <p class="text-gray-300">Second, the IEEE P1363a version allows for a data encapsulation mechanism of the type described in &sect;10 and recommended here, in addition to the &quot;stream cipher option&quot; (see &sect;15.6.4) as in the submitted version. Note that the version of ECIES submitted to Crypto-Nessie allows for both modes of operations (although not with the same set of symmetric-key encryption schemes).</p>

    <p class="text-gray-300">Third, the IEEE P1363a version allows for a &quot;compatible&quot; cofactor mode, in addition to the &quot;old&quot; cofactor mode, as in the submitted version (see &sect;15.6.5).</p>

    <p class="text-gray-300">Fourth, the IEEE P1363a version of ECIES provides a &quot;DHAES option,&quot; which when used, passes C<sup>0</sup> to KDF (see &sect;15.6.1) and the length of L to MAC (see &sect;15.6.3).</p>

    <p class="text-gray-300">In preparing this document, based on discussions with ISO working group members, priority was given to consistency with the IEEE P1363a version, rather than to the submitted version.</p>

    <p class="text-gray-300">We present here a variant of PSEC-2. This is a key encapsulation scheme, which we call PSEC-KEM, that can be combined with the general hybrid method in &sect;5 to get a full publickey encryption scheme. While the scheme we present here differs in numerous details from the original PSEC-2, we believe it is similar in spirit to the PSEC-2 submission, preserves the main idea of [FO99] on which it is based, and provides very nearly the same security/efficiency trade-off.</p>

      <h3 id="sec-16.1" class="text-xl font-semibold mt-8">16.1 Key Generation</h3>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">$Group = (\\mathcal{H}, \\mathcal{G}, \\mathbf{g}, \\mu, \\nu, \\mathcal{E}, \\mathcal{D}, \\mathcal{E}&#x27;, \\mathcal{D}&#x27;).</span>$</p>

    <p class="text-gray-300">Additionally, a key derivation function KDF (see &sect;12) should be selected, along with a positive integer SeedLen.</p>

    <p class="text-gray-300">Next, a number x &isin; {0, . . . , &micro; &minus; 1} is chosen at random, and the group element h = xg is computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group and h, along with an indication of the choice of KDF and the value SeedLen. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key together with x.</p>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext C<sup>0</sup> that is an encryption of a key K, where K is a byte string of length KeyLen = PSEC-KEM.OutputKeyLen.</p>

    <p class="text-gray-300">Let I0 = I2OSP(0, 4) and I1 = I2OSP(1, 4).</p>

    <p class="text-gray-300">The encryption algorithm takes an optional argument format that specifies the format to be used to encode group elements, and runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Choose a random byte string s of length SeedLen.</p></li>
      <li><p class="text-gray-300">Compute</p></li>
    </ol>

    <p class="text-gray-300"><span class="math">$t = KDF(I0 \\parallel s, \\lceil \\log_{256} \\mu \\rceil + 16 + KeyLen),</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a byte string of length  <span class="math">\\lceil \\log_{256} \\mu \\rceil + 16 + KeyLen</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse t as  <span class="math">t = u \\parallel K</span> , where  <span class="math">|u| = \\lceil \\log_{256} \\mu \\rceil + 16</span>  and |K| = KeyLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">r = OS2IP(u) \\mod \\mu</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\tilde{\\mathbf{g}} = r\\mathbf{g}</span>  and  <span class="math">\\tilde{\\mathbf{h}} = r\\mathbf{h}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">EG = \\mathcal{E}(\\tilde{\\mathbf{g}}, format)</span>  and  <span class="math">PEH = \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$v = s \\oplus KDF(I1 \\parallel EG \\parallel PEH, SeedLen).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key K and the ciphertext  <span class="math">C_0 = EG \\| v</span> .</li>
    </ol>

    <p class="text-gray-300">The decryption algorithm takes the secret key as well as a ciphertext  <span class="math">C_0</span>  as input. It runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">C_0</span>  as  <span class="math">C_0 = EG || v</span> , where EG is an encoding a group element  <span class="math">\\tilde{\\mathbf{g}}</span> , and v is a byte string of length SeedLen. This step may, of course, fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\tilde{\\mathbf{h}} = x\\tilde{\\mathbf{g}}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">PEH = \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$s = v \\oplus KDF(I1 \\parallel EG \\parallel PEH, SeedLen).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute</li>
    </ol>

    <p class="text-gray-300"><span class="math">$t = KDF(I0 || s, \\lceil \\log_{256} \\mu \\rceil + 16 + KeyLen),</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a byte string of length  <span class="math">\\lceil \\log_{256} \\mu \\rceil + 16 + KeyLen</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse t as t = u | K, where  <span class="math">|u| = \\lceil \\log_{256} \\mu \\rceil + 16</span>  and |K| = KeyLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">r = OS2IP(u) \\mod \\mu</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\bar{\\mathbf{g}} = r\\mathbf{g}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test if  <span class="math">\\bar{\\mathbf{g}} = \\tilde{\\mathbf{g}}</span> ; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key K.</li>
    </ol></li>
    </ul>

      <h3 id="sec-16.4" class="text-xl font-semibold mt-8">16.4 Some remarks</h3>

    <p class="text-gray-300">Note that in this scheme, we do not have to make an additional check to ensure that  <span class="math">\\tilde{\\mathbf{g}}</span>  lies in  <span class="math">\\mathcal{G}</span>  during the decryption process. This is already taken care of by the test in step 9 of the decryption algorithm.</p>

    <p class="text-gray-300">Also note that unlike <em>ECIES</em>, a value of  <span class="math">\\mathbf{0}</span>  for  <span class="math">\\tilde{\\mathbf{h}}</span>  is perfectly legal, and therefore, the function  <span class="math">\\mathcal{E}&#x27;</span>  must be well defined at  <span class="math">\\mathbf{0}</span> . It was felt that making the restriction that  <span class="math">\\tilde{\\mathbf{h}} \\neq \\mathbf{0}</span>  would only complicate the scheme, with no tangible benefit.</p>

      <h3 id="sec-16.5" class="text-xl font-semibold mt-8">16.5 Changes from PSEC-2</h3>

    <p class="text-gray-300">There are a number of substantial differences between PSEC-KEM and the PSEC-2.</p>

    <p class="text-gray-300">First and foremost is the fact that the above scheme is just a key encapsulation mechanism. As we discussed in &sect;5, using this we can build a hybrid scheme.</p>

    <p class="text-gray-300">The PSEC-2 submission proposed a different kind of hybrid construction. We would recommend the hybrid construction here above the hybrid construction in the PSEC-2 for three reasons.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>One of the goals of this document is to consolidate the various submissions, taking the best ideas from all of them, and obtaining a small set of schemes, each of which offers something unique. To that end, it seems like a good idea to use the same hybrid construction for all schemes.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The hybrid construction proposed here has a distinct advantage over the hybrid construction proposed in PSEC-2. Namely, it facilitates the implementation of the encryption and decryption algorithms as filters (see &sect;2.1.3). For the original PSEC-2 construction, this does not seem possible.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The hybrid construction proposed here does not rely on random oracles, whereas that in PSEC-2 does. It is easy enough to build a hybrid scheme without random oracles, assuming the underlying key encapsulation mechanism is secure, so it seems worthwhile to do so. In particular, we want to be able to include schemes, like ACE-KEM, that do not use random oracles in their security analysis.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The only disadvantages of our proposed hybrid construction are that the ciphertexts are slightly longer (an additional MAC tag is required), and additional code is required for its implementation (the MAC code). We feel that these disadvantages are outweighed by the advantages of conformity with the other schemes, and of facilitating &quot;streaming.&quot; This, of course, may be a point of discussion by the working group.</p>

    <p class="text-gray-300">There are some other differences as well. In our scheme, the value v (in our notation) is computed by masking the seed s with a cryptographic hash</p>

    <p class="text-gray-300"><span class="math">$KDF(I1 \\parallel EG \\parallel PEH, SeedLen),</span>$</p>

    <p class="text-gray-300">whereas in PSEC-2, s is masked directly with PEH &mdash; no hash at all. Our scheme thus has potentially more compact ciphertexts than PSEC-2. Also, by including EG in the hash, we get a a much more efficient security reduction in the multi-user/multi-message model (see [BBM00]), and we also deal properly with the multiple group encoding formats.</p>

    <p class="text-gray-300">A serious criticism of the PSEC-2 scheme as submitted is that there is no detailed proof of the claimed security theorem, either in the submission or elsewhere in the literature. In fact, there is some doubt as to whether the scheme actually is secure under the stated assumptions. The problem is the way the value v (our notation) is computed in PSEC-2. As mentioned above, this is computed as v = s &oplus; PEH. The only requirement in the scheme is that SeedLen &le; |PEH|. However, if SeedLen &lt; |PEH|, then the ciphertext contains some of bits of PEH in the clear. To prove security of this scheme, then, one would (at least) need to show that one could not compute h&tilde; from g&tilde; and some of the bits of the partial encoding of h&tilde;. It would appear that requiring that SeedLen &ge; |PEH| solves the problem. Note that the stated requirement that SeedLen &le; |PEH| is apparently not a typographic error, since the examples of PSEC-2 in the appendix of the submission all have SeedLen &lt; |PEH|.</p>

    <p class="text-gray-300">A similar, but more severe, criticism applies to the <em>PSEC-1</em> submission. More specifically, in the <em>PSEC-1</em> encryption algorithm, the ciphertext contains the XOR of the message with a substring of <em>PEH</em>. There is no way the semantic security of this scheme can be based upon the DDH assumption, since the DDH assumption does <em>not</em> imply that the bits of an encoding of a group element are pseudo-random.</p>

    <p class="text-gray-300">Also note that our proposed scheme works with any prime-order group, not just subgroups of elliptic curves.</p>

    <p class="text-gray-300">We should also mention that the scheme we have proposed here bears some similarities not only to the PSEC-2 submission, but also to a very similar scheme presented in [BLK00].</p>

    <p class="text-gray-300">Since this proposed scheme differs significantly from PSEC-2 and other schemes in the literature, we sketch a security proof in the random oracle model assuming the CDH (see  <span class="math">\\S14.1</span> ).</p>

    <p class="text-gray-300">We view KDF as a random oracle. Note that all relevant inputs to KDF start with either a &quot;zero word&quot; or a &quot;one word.&quot; This effectively gives us two independent random oracles,</p>

    <p class="text-gray-300"><span class="math">$H_0: \\mathbf{B}^{SeedLen} \\to \\mathbf{B}^{\\lceil \\log_{256} \\mu \\rceil + 16 + KeyLen},</span>$</p>

    <p class="text-gray-300"><span class="math">H_1: \\mathcal{E}(\\mathcal{H}) \\times \\mathcal{E}&#x27;(\\mathcal{H}) \\to \\mathbf{B}^{SeedLen}.</span></p>

    <p class="text-gray-300">Here, <strong>B</strong> denotes the set of bytes. Also,  <span class="math">\\mathcal{E}(\\mathcal{H})</span>  denotes the set of all encodings of elements in  <span class="math">\\mathcal{H}</span> , using all formats, and  <span class="math">\\mathcal{E}&#x27;(\\mathcal{H})</span>  denotes the set of all partial encodings of elements in  <span class="math">\\mathcal{H}</span> . In the security analysis, we shall replace the calls to KDF by appropriate queries to  <span class="math">H_0</span>  and  <span class="math">H_1</span> .</p>

    <p class="text-gray-300">Consider an adversary A that makes  <span class="math">q_D</span>  calls to the decryption oracle,  <span class="math">q_0</span>  calls to  <span class="math">H_0</span>  and  <span class="math">q_1</span>  calls to  <span class="math">H_1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{G}_0</span>  be the original attack game, and let  <span class="math">S_0</span>  be the event that the adversary correctly guesses the hidden bit b in this game (see &sect;3). We shall define a sequence of attack games  <span class="math">\\mathbf{G}_1, \\mathbf{G}_2, \\ldots, \\mathbf{G}_k</span> . Each of these games should be viewed as operating on the same underlying probability space &mdash; only the rules for how certain random variables are computed differ. In each game  <span class="math">\\mathbf{G}_i</span> ,  <span class="math">1 \\le i \\le k</span> , there will be an event  <span class="math">S_i</span>  corresponding to  <span class="math">S_0</span> . We shall show that for all  <span class="math">1 \\le i \\le k</span> , that the difference  <span class="math">|\\Pr[S_i] - \\Pr[S_{i-1}]|</span>  is negligible, and moreover, it will be evident that in the last game,  <span class="math">\\Pr[S_k] = 1/2</span> . This will imply that  <span class="math">Advantage_{PSEC\\text{-}KEM}(A)</span> , which is equal to  <span class="math">|\\Pr[S_0] - 1/2|</span> , is negligible.</p>

    <p class="text-gray-300">We adopt the following convention. For an arbitrary ciphertext  <span class="math">C_0</span> , we denote by</p>

    <p class="text-gray-300"><span class="math">$EG, v, \\tilde{\\mathbf{g}}, \\tilde{\\mathbf{h}}, PEH, s, t, u, K, r, \\bar{\\mathbf{g}},</span>$</p>

    <p class="text-gray-300">the values computed by the decryption algorithm on this ciphertext. Some of these may be undefined if the algorithm would fail before the value was computed. We also denote the target ciphertext  <span class="math">C_0^*</span> , and define corresponding values  <span class="math">EG^*, v^*, \\tilde{\\mathbf{g}}^*, \\dots</span></p>

    <p class="text-gray-300">We classify ciphertexts  <span class="math">C_0</span>  submitted to the encryption oracle as follows:</p>

    <p class="text-gray-300">Type I  <span class="math">\\tilde{\\mathbf{g}} \\neq \\tilde{\\mathbf{g}}^*</span> ;</p>

    <p class="text-gray-300">Type II  <span class="math">EG = EG^*</span> ;</p>

    <p class="text-gray-300">Type III  <span class="math">\\tilde{\\mathbf{g}} = \\tilde{\\mathbf{g}}^*</span> , but  <span class="math">EG \\neq EG^*</span> .</p>

    <p class="text-gray-300">Note that all ciphertexts  <span class="math">C_0</span>  submitted to the decryption oracle before the encryption oracle has been invoked are classified as Type I. Notice that Type III ciphertexts can arise only if the group supports multiple encoding formats.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{S}</span>  denote the set of points s at which the oracle  <span class="math">H_0</span>  has been queried either (i) directly by the adversary, or (ii) by a Type III decryption oracle invocation. The set  <span class="math">\\mathcal{S}</span>  grows over time, as more queries to  <span class="math">H_0</span>  are made. For any byte string s of length SeedLen, we define  <span class="math">\\rho(s)</span>  to be the number obtained by taking the first  <span class="math">\\lceil \\log_{256} \\mu \\rceil + 16</span>  of  <span class="math">H_0(s)</span> , converting to an integer, and reducing mod  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">The following trivial lemma will streamline our arguments.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> Let E, E', and F be events defined on a probability space such that  <span class="math">\\Pr[E \\land \\neg F] = \\Pr[E&#x27; \\land \\neg F]</span> . Then we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[E] - \\Pr[E&#x27;]| \\le \\Pr[F].</span>$</p>

    <p class="text-gray-300">The proof is a simple calculation, which we omit.</p>

    <p class="text-gray-300">We now define our sequence of games  <span class="math">G_1, G_2, \\ldots</span></p>

    <p class="text-gray-300"><strong>Game G</strong><sub>1</sub>. We modify the decryption oracle as follows. If the adversary submits a Type II ciphertext  <span class="math">C_0</span> , then in game  <span class="math">\\mathbf{G}_1</span> , we summarily reject  <span class="math">C_0</span> , without executing the decryption algorithm at all.</p>

    <p class="text-gray-300">Let  <span class="math">F_1</span>  be the event that in game  <span class="math">\\mathbf{G}_1</span>  such a ciphertext is rejected that would not have been rejected under the rules of game  <span class="math">\\mathbf{G}_0</span> . Since these two games proceed identically until  <span class="math">F_1</span>  occurs, we have  <span class="math">\\Pr[S_0 \\land \\neg F_1] = \\Pr[S_1 \\land \\neg F_1]</span> , and applying Lemma 1 with  <span class="math">(S_0, S_1, F_1)</span> , we have  <span class="math">|\\Pr[S_0] - \\Pr[S_1]| \\leq \\Pr[F_1]</span> .</p>

    <p class="text-gray-300">So it suffices to bound  <span class="math">\\Pr[F_1]</span> . Consider a Type II ciphertext  <span class="math">C_0</span>  submitted to the decryption oracle in game  <span class="math">\\mathbf{G}_1</span> . Since  <span class="math">C_0 \\neq C_0^*</span> , we must have  <span class="math">v \\neq v^*</span> , which implies  <span class="math">s \\neq s^*</span> . To accept under the rules of game  <span class="math">\\mathbf{G}_0</span> , we must have  <span class="math">r = r^*</span> .</p>

    <p class="text-gray-300">To make this happen, the adversary must find an input  <span class="math">s \\neq s^*</span>  to  <span class="math">H_0</span>  such that  <span class="math">\\rho(s) = r^*</span> . Thus,  <span class="math">\\Pr[F_1] \\leq (q_0 + q_D)\\mu^{-1}(1 + 2^{-128})</span> . The factor  <span class="math">(1 + 2^{-128})</span>  comes from the fact that the value r is not exactly uniformly distributed over  <span class="math">\\{0, \\ldots, \\mu - 1\\}</span> .</p>

    <p class="text-gray-300">So we have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_0] - \\Pr[S_1]| \\le (q_0 + q_D)\\mu^{-1}(1 + 2^{-128}).</span>$
(1)</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>2</sub>. In this game, we modify the decryption oracle as follows. Suppose a Type I ciphertext  <span class="math">C_0</span>  is submitted, and suppose that  <span class="math">s \\notin \\mathcal{S}</span> . Then we summarily reject this ciphertext, without ever proceeding past step 4 of the decryption algorithm.</p>

    <p class="text-gray-300">Note that in this game, Type I and II decryption oracle invocations never evaluate  <span class="math">H_0</span>  at points not already in S.</p>

    <p class="text-gray-300">Let  <span class="math">F_2</span>  be the event that in game  <span class="math">\\mathbf{G}_2</span>  such a ciphertext is rejected that would not have been rejected under the rules of game  <span class="math">\\mathbf{G}_1</span> . These two games proceed identically until  <span class="math">F_2</span>  occurs, and so  <span class="math">\\Pr[S_1 \\wedge \\neg F_2] = \\Pr[S_2 \\wedge \\neg F_2]</span> , and applying Lemma 1 to  <span class="math">(S_1, S_2, F_2)</span> , we have  <span class="math">|\\Pr[S_1] - \\Pr[S_2]| \\leq \\Pr[F_2]</span> .</p>

    <p class="text-gray-300">So it suffices to bound  <span class="math">\\Pr[F_2]</span> . Consider a ciphertext  <span class="math">C_0</span>  as above is submitted to the decryption oracle in game  <span class="math">\\mathbf{G}_2</span> . On the one hand, if the encryption oracle was previously invoked and  <span class="math">s=s^*</span> , then under the rules of game  <span class="math">\\mathbf{G}_1</span> , we would certainly reject  <span class="math">C_0</span> , since  <span class="math">\\tilde{\\mathbf{g}} \\neq \\tilde{\\mathbf{g}}^*</span> . On the other hand, if the decryption oracle was not previously invoked or it was but  <span class="math">s \\neq s^*</span> , then  <span class="math">H_0</span>  was never queried at s either by the encryption oracle, the decryption oracle, or the adversary, and so the value r is independent of everything in the adversary's view. It follows that the probability that this ciphertext would not be rejected under the rules of game  <span class="math">\\mathbf{G}_1</span>  is at most  <span class="math">\\mu^{-1}(1+2^{-128})</span> .</p>

    <p class="text-gray-300">From this, it follows that  <span class="math">\\Pr[F_1] \\leq q_D \\mu^{-1} (1 + 2^{-128})</span> , and therefore,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_1] - \\Pr[S_2]| \\le q_D \\mu^{-1} (1 + 2^{-128}).</span>$
(2)</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>3</sub>. We make another modification to the decryption oracle. In this new game, we process all Type I ciphertexts  <span class="math">C_0</span>  as follows. If  <span class="math">\\tilde{\\mathbf{g}}</span>  is not equal to  <span class="math">\\rho(s&#x27;)\\mathbf{g}</span>  for any  <span class="math">s&#x27; \\in \\mathcal{S}</span> , then we reject without any further processing. Otherwise, if  <span class="math">\\tilde{\\mathbf{g}} = \\rho(s&#x27;)\\mathbf{g}</span>  for some  <span class="math">s&#x27; \\in \\mathcal{S}</span> , we compute  <span class="math">\\tilde{\\mathbf{h}} = \\rho(s&#x27;)\\mathbf{h}</span> , and proceed to decrypt just as in game  <span class="math">\\mathbf{G}_2</span> , but starting with step 3 of the decryption algorithm.</p>

    <p class="text-gray-300">We argue that games  <span class="math">G_2</span>  and  <span class="math">G_3</span>  are identical.</p>

    <p class="text-gray-300">Consider first a ciphertext for which  <span class="math">\\tilde{\\mathbf{g}}</span>  is not equal to  <span class="math">\\rho(s&#x27;)\\mathbf{g}</span>  for any  <span class="math">s&#x27; \\in \\mathcal{S}</span> . This ciphertext would have anyway been rejected under the rules in game  <span class="math">\\mathbf{G}_2</span> . To see this, let  <span class="math">\\tilde{\\mathbf{g}} = \\hat{r}\\mathbf{g}</span> , where  <span class="math">\\hat{r} \\in \\{0, \\dots, \\mu - 1\\}</span> . Now,  <span class="math">\\hat{r} \\neq \\rho(s&#x27;)</span>  for any  <span class="math">s&#x27; \\in \\mathcal{S}</span> . Consider the value s. If  <span class="math">s \\in \\mathcal{S}</span> , then we would reject under the rules in game  <span class="math">\\mathbf{G}_2</span> , since the test in step 9 would fail; otherwise, if  <span class="math">s \\notin \\mathcal{S}</span> , we would also reject under the rules in game  <span class="math">\\mathbf{G}_2</span> , since the special rejection rule introduced in game  <span class="math">\\mathbf{G}_2</span>  would apply.</p>

    <p class="text-gray-300">Next, consider the case where  <span class="math">\\tilde{\\mathbf{g}} = \\rho(s&#x27;)\\mathbf{g}</span>  for some  <span class="math">s&#x27; \\in \\mathcal{S}</span> . It is clear that in this case, decryption proceeds exactly as in game  <span class="math">\\mathbf{G}_2</span> .</p>

    <p class="text-gray-300">So we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_3] = \\Pr[S_2]. \\tag{3}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>4</sub>. We modify game  <span class="math">G_3</span>  to obtain an equivalent game  <span class="math">G_4</span> . This rather technical step is a &quot;bridging&quot; step that will facilitate the analysis of more drastic modifications in game  <span class="math">G_5</span> .</p>

    <p class="text-gray-300">In game  <span class="math">G_4</span> , we introduce</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a random byte string  <span class="math">s^+</span>  of length SeedLen,</li>
      <li>a random byte string  <span class="math">u^+</span>  of length  <span class="math">\\lceil \\log_{256} \\mu \\rceil + 16</span> ,</li>
      <li>a random byte string  <span class="math">K^+</span>  of length KeyLen, and</li>
      <li>a random oracle</li>
    </ul>

    <p class="text-gray-300"><span class="math">$h^+: \\mathcal{E}(\\mathcal{H}) \\to \\mathbf{B}^{SeedLen}</span>$</p>

    <p class="text-gray-300">Game  <span class="math">G_4</span>  is identical to game  <span class="math">G_3</span> , except that we apply the following special rules:</p>

    <p class="text-gray-300">R1: In the encryption oracle, we perform the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">r^+ = OS2IP(u^+) \\mod u</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">\\tilde{\\mathbf{g}}^* = r^+ \\mathbf{g}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">EG^* = \\mathcal{E}(\\tilde{\\mathbf{g}}^*, format)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">v^* = s^+ \\oplus h^+(EG^*)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key  <span class="math">K^+</span>  and the ciphertext  <span class="math">C_0^* = EG^* \\parallel v^*</span> .</li>
    </ol></li>
      <li><strong>R2:</strong> In the decryption oracle, when processing a Type III ciphertext, we use the value  <span class="math">h^+(EG)</span>  in step 4, instead of  <span class="math">H_1(EG, PEH)</span> .</li>
      <li><strong>R3:</strong> Whenever the oracle  <span class="math">H_0</span>  is queried by either the adversary or a Type III decryption oracle at  <span class="math">s^+</span>  we respond with  <span class="math">u^+ \\parallel K^+</span> , instead of  <span class="math">H(s^+)</span> .</li>
      <li><strong>R4:</strong> Whenever the oracle  <span class="math">H_1</span>  is queried by either the adversary or a Type I decryption oracle at a point (EG, PEH), where EG is an encoding of  <span class="math">\\tilde{\\mathbf{g}}^*</span>  and PEH is a partial encoding of  <span class="math">x\\tilde{\\mathbf{g}}^*</span> , we respond with  <span class="math">h^+(EG)</span>  instead of  <span class="math">H_1(EG, PEH)</span> .</li>
    </ul>

    <p class="text-gray-300">It is clear that games  <span class="math">G_3</span>  and  <span class="math">G_4</span>  are completely equivalent, since we have consistently replaced one set of random variables by another set of identically distributed random variables. In particular,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_3] = \\Pr[S_4]. \\tag{4}</span>$</p>

    <p class="text-gray-300"><strong>Game G</strong><sub>5</sub>. Game  <span class="math">G_5</span>  is the same as game  <span class="math">G_4</span> , except that we drop rules R3 and R4, while retaining R1 and R2.</p>

    <p class="text-gray-300">Note that in this game, we do not use the secret key of the cryptosystem at all. Also note that the ciphertext  <span class="math">C_0^*</span>  is no longer a valid ciphertext in general, nor does it hold in general that  <span class="math">s^* = s^+</span> , or that  <span class="math">t^* = u^+ \\parallel K^+</span> , since the random oracles are no longer consistent with the modifications made in the encryption oracle. Indeed,  <span class="math">K^+</span>  and hence the hidden bit b are independent of the adversary's view in game  <span class="math">\\mathbf{G}_5</span> . The string  <span class="math">s^+</span>  is also independent of the adversary's view. Further, the behavior of Type III decryption oracle queries are also not consistent with the random oracles.</p>

    <p class="text-gray-300">Despite these differences, however, games  <span class="math">\\mathbf{G}_4</span>  and  <span class="math">\\mathbf{G}_5</span>  proceed identically until the string  <span class="math">s^+</span>  appears in  <span class="math">\\mathcal{S}</span>  or either the adversary or a Type I decryption oracle invocation queries  <span class="math">H_1</span>  on inputs (EG, PEH), where EG is an encoding of  <span class="math">\\tilde{\\mathbf{g}}^*</span>  and PEH is the partial encoding of  <span class="math">x\\tilde{\\mathbf{g}}^*</span> .</p>

    <p class="text-gray-300">Let  <span class="math">F_{5a}</span>  be the event that in game  <span class="math">\\mathbf{G}_5</span> , the string  <span class="math">s^+</span>  appears in  <span class="math">\\mathcal{S}</span>  at some point in time. Let  <span class="math">F_{5b}</span>  be the event that either the adversary or a Type I decryption oracle invocation queries  <span class="math">H_1</span>  on inputs (EG, PEH), where EG is an encoding of  <span class="math">\\tilde{\\mathbf{g}}^*</span>  and PEH is the partial encoding of  <span class="math">x\\tilde{\\mathbf{g}}^*</span> . Let  <span class="math">F_5 = F_{5a} \\vee F_{5b}</span> .</p>

    <p class="text-gray-300">Since games  <span class="math">G_4</span>  and  <span class="math">G_5</span>  proceed identically until the point where  <span class="math">F_5</span>  occurs, we have  <span class="math">\\Pr[S_4 \\land \\neg F_5] = \\Pr[S_5 \\land \\neg F_5]</span> . Applying Lemma 1 with  <span class="math">(S_4, S_5, F_5)</span> , we have  <span class="math">|\\Pr[S_4] - \\Pr[S_5]| \\le \\Pr[F_5]</span> . Since  <span class="math">s^+</span>  is independent of the adversary's view, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_{5a}] \\le (q_0 + q_D)2^{-SeedLen}.</span>$</p>

    <p class="text-gray-300">Now,  <span class="math">\\Pr[F_{5b}]</span>  is bounded by  <span class="math">(1+2^{-128})</span>  times the probability that an adversary A' &mdash; running in expected time nearly the same as the running time of the original adversary A &mdash; can construct a list of  <span class="math">O(q_1+q_D)</span>  group elements, one of which contains a solution to a given instance of the CDH problem.</p>

    <p class="text-gray-300">This algorithm runs by taking a random instance  <span class="math">(\\mathbf{g}, \\mathbf{h}, \\tilde{\\mathbf{g}}^+)</span>  of the CDH problem as input, and runs A against a slightly modified version of game  <span class="math">\\mathbf{G}_5</span> . In this modified game, we use the given values  <span class="math">\\mathbf{g}, \\mathbf{h}</span>  to form the public key in game  <span class="math">\\mathbf{G}_5</span> , Also, we use the given value  <span class="math">\\tilde{\\mathbf{g}}^+</span> , instead of deriving it from  <span class="math">u^+</span>  (note that  <span class="math">u^+</span>  is not used anywhere else in game  <span class="math">\\mathbf{G}_5</span> ). Finally, to implement this algorithm, we simulate the random oracles in the usual way, using standard hash table techniques. We also use standard hash table techniques to implement the Type I decryption oracle queries, as modified in game  <span class="math">\\mathbf{G}_3</span> . The factor  <span class="math">(1+2^{-128})</span>  comes from the fact that the distribution of  <span class="math">\\tilde{\\mathbf{g}}</span> + in game  <span class="math">\\mathbf{G}_5</span>  is slightly non-uniform, whereas we assume the corresponding value in the CDH instance is uniformly distributed.</p>

    <p class="text-gray-300">From this, it follows that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[S_4] - \\Pr[S_5]| \\le Advantage_{CDH}(A&#x27;, O(q_1 + q_D))(1 + 2^{-128}) + (q_0 + q_D)2^{-SeedLen},</span>$
(5)</p>

    <p class="text-gray-300">where  <span class="math">Advantage_{CDH}</span>  is as defined in &sect;14.1.</p>

    <p class="text-gray-300">It is also clear that in game  <span class="math">G_5</span> , the hidden bit b is independent of all values directly or indirectly accessible to the adversary. Hence,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_5] = 1/2. \\tag{6}</span>$</p>

    <p class="text-gray-300">Putting together (1), (2), (3), (4), (5), (6), we obtain</p>

    <p class="text-gray-300"><span class="math">$Advantage_{PSEC\\text{-}KEM}(A) \\leq (q_0 + 2q_D)\\mu^{-1}(1 + 2^{-128}) + Advantage_{CDH}(A&#x27;, O(q_1 + q_D))(1 + 2^{-128}) + (q_0 + q_D)2^{-SeedLen}.</span>$
(7)</p>

    <p class="text-gray-300">In this section, we present a variant of the ACE-Encrypt submission. Several changes were made to the original submission, so that the resulting scheme fits into our frameworks for hybrid and Diffie-Hellman-based encryption. This variant is a key encapsulation mechanism that we call ACE-KEM.</p>

    <p class="text-gray-300">A fully specified group</p>

    <p class="text-gray-300"><span class="math">$Group = (\\mathcal{H}, \\mathcal{G}, \\mathbf{g}, \\mu, \\nu, \\mathcal{E}, \\mathcal{D}, \\mathcal{E}&#x27;, \\mathcal{D}&#x27;)</span>$</p>

    <p class="text-gray-300">is chosen. In what follows, we let  <span class="math">\\mathbf{g}_1 = \\mathbf{g}</span> .</p>

    <p class="text-gray-300">An additional parameter, <em>CofactorMode</em>, must be specified. This parameter takes the value 0 or 1. Here are the rules which should be obeyed in setting this parameter.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\nu = 1</span> , then CofactorMode should be 0.</li>
      <li>If  <span class="math">\\nu &gt; 1</span> , CofactorMode may be set to 1 provided  <span class="math">gcd(\\mu, \\nu) = 1</span> .</li>
    </ul>

    <p class="text-gray-300">In addition to Group, a hash function Hash (see &sect;11) and key derivation function KDF (see &sect;12) must be chosen. It is required that and that  <span class="math">Hash.OutputLen &lt; \\log_{256} \\mu</span> .</p>

    <p class="text-gray-300">Since we want KDF to be a good entropy smoothing function, one should select either KDF3 or KDF4. As discussed in &sect;12, the functions KDF1 and KDF2 are not recommended.</p>

    <p class="text-gray-300">Next, numbers  <span class="math">w, x, y, z \\in \\{0, \\dots, \\mu - 1\\}</span>  are chosen at random, and the group elements</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{g}_2 = w \\cdot \\mathbf{g}_1, \\ \\mathbf{c} = x \\cdot \\mathbf{g}_1, \\ \\mathbf{d} = y \\cdot \\mathbf{g}_1, \\ \\mathbf{h} = z \\cdot \\mathbf{g}_1</span>$</p>

    <p class="text-gray-300">are computed.</p>

    <p class="text-gray-300">The public key consists of encodings of Group, the group elements  <span class="math">\\mathbf{g}_2</span> ,  <span class="math">\\mathbf{c}</span> ,  <span class="math">\\mathbf{d}</span> ,  <span class="math">\\mathbf{h}</span> , and an indication of the choice of Hash and KDF. The precise format of this encoding is not specified here.</p>

    <p class="text-gray-300">The private key consists of the public key, together with the numbers w, x, y, z, and the value of CofactorMode.</p>

      <h3 id="sec-17.2" class="text-xl font-semibold mt-8">17.2 Encryption</h3>

    <p class="text-gray-300">Recall that for a key encapsulation mechanism, the goal is to produce a ciphertext  <span class="math">C_0</span>  that is an encryption of a key K, where K is a byte string of length KeyLen = ACE-KEM.OutputKeyLen.</p>

    <p class="text-gray-300">In addition to the recipient's public key, the encryption algorithm takes an optional <em>format</em> argument, which is used to specify the format for group element encodings.</p>

    <p class="text-gray-300">The encryption scheme works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Choose  <span class="math">r \\in \\{0, \\dots, \\mu - 1\\}</span> .</p></li>
      <li><p class="text-gray-300">Compute group elements</p></li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathbf{u}_1 = r \\cdot \\mathbf{g}_1, \\ \\mathbf{u}_2 = r \\cdot \\mathbf{g}_2, \\ \\tilde{\\mathbf{h}} = r \\cdot \\mathbf{h}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the byte strings</li>
    </ol>

    <p class="text-gray-300"><span class="math">$EU1 = \\mathcal{E}(\\mathbf{u}_1, format), \\ EU2 = \\mathcal{E}(\\mathbf{u}_2, format).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the number</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\alpha = OS2IP(Hash.eval(EU1 || EU2)).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the number</li>
    </ol>

    <p class="text-gray-300"><span class="math">$r&#x27; = \\alpha \\cdot r \\mod \\mu</span>$
.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the group element</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\mathbf{v} = r \\cdot \\mathbf{c} + r&#x27; \\cdot \\mathbf{d}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the ciphertext</li>
    </ol>

    <p class="text-gray-300"><span class="math">$C_0 = EU1 \\parallel EU2 \\parallel \\mathcal{E}(\\mathbf{v}, format)</span>$</p>

    <p class="text-gray-300">and the key</p>

    <p class="text-gray-300"><span class="math">$K = KDF(EU1 \\parallel \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}}), KeyLen).</span>$</p>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext C<sup>0</sup> along with the private key.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse the ciphertext as EU1 kEU2 kEV, where EU1 encodes the group element u1, EU2 encodes the group element u2, and EV encodes the group element v. If this step fails, then fail.</li>
    </ol>

    <p class="text-gray-300">Also, one must check that EU1, EU2, and EV are all encoded using the same format; if not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If CofactorMode = 1, set</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\hat{\\mathbf{u}}_1 = \\nu \\cdot \\mathbf{u}_1, \\ \\hat{w} = \\nu^{-1} w \\mod \\nu, \\ \\hat{x} = \\nu^{-1} x \\mod \\nu, \\ \\hat{y} = \\nu^{-1} y \\mod \\nu, \\ \\hat{z} = \\nu^{-1} z \\mod \\nu;</span>$</p>

    <p class="text-gray-300">otherwise, set</p>

    <p class="text-gray-300"><span class="math">$\\hat{\\mathbf{u}}_1 = \\mathbf{u}_1, \\ \\hat{w} = w, \\ \\hat{x} = x, \\ \\hat{y} = y, \\ \\hat{z} = z.</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If CofactorMode 6= 1 and &nu; &gt; 1, test if u<sup>1</sup> &isin; G. If not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the number</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\alpha = OS2IP(Hash.eval(EU1 || EU2))</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the number</li>
    </ol>

    <p class="text-gray-300"><span class="math">$t = \\hat{x} + \\hat{y}\\alpha \\bmod \\mu.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test if</li>
    </ol>

    <p class="text-gray-300"><span class="math">$w \\cdot \\hat{\\mathbf{u}}_1 = \\mathbf{u}_2 \\text{ and } t \\cdot \\hat{\\mathbf{u}}_1 = \\mathbf{v}.</span>$</p>

    <p class="text-gray-300">If not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the group element</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\tilde{\\mathbf{h}} = \\hat{z} \\cdot \\hat{\\mathbf{u}}_1.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key</li>
    </ol>

    <p class="text-gray-300"><span class="math">$K = KDF(EU1 \\parallel \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}}), KeyLen).</span>$</p>

      <h3 id="sec-17.4" class="text-xl font-semibold mt-8">17.4 Some remarks</h3>

    <p class="text-gray-300">For security reasons, one should always perform all of the computations in step 6 of the decryption algorithm; otherwise, some &quot;timing&quot; information could be gained by the adversary that is not available to it in the formal proof of security. Note, however, that we know of no actual attack based on such timing information, nor is such an attack at all likely.</p>

    <p class="text-gray-300">Also note that unlike <em>ECIES</em>, a value of  <span class="math">\\mathbf{0}</span>  for  <span class="math">\\tilde{\\mathbf{h}}</span>  is perfectly legal, and therefore, the function  <span class="math">\\mathcal{E}&#x27;</span>  must be well defined at  <span class="math">\\mathbf{0}</span> . It was felt that making the restriction that  <span class="math">\\tilde{\\mathbf{h}} \\neq \\mathbf{0}</span>  would only complicate the scheme, with no tangible benefit.</p>

    <p class="text-gray-300">Using CofactorMode = 1 may yield a performance benefit if  <span class="math">\\nu</span>  is fairly small. Note that in this mode, an implementation could simply pre-compute and store the values  <span class="math">\\hat{w}, \\hat{x}, \\hat{y}, \\hat{z}</span> , instead of the values w, x, y, z.</p>

    <p class="text-gray-300">This scheme differs in only very minor ways from schemes that have been rigorously analyzed in the literature. It most closely resembles the variation of the Cramer-Shoup scheme discussed in detail in [Sho00].</p>

    <p class="text-gray-300">The security of the scheme is based on the DDH (see &sect;14.2), and a few other <em>specific</em> assumptions about the hash and key derivation functions. The security reduction is quite tight. One can easily verify the following, using following the line of reasoning in [CS98] and [Sho00].</p>

    <p class="text-gray-300"><span class="math">$Advantage_{ACE\\text{-}KEM}(A) = O(\\quad Advantage_{DDH}(A_1) + \\\\ Advantage_{Hash}(A_2) + \\\\ Advantage_{KDF}(A_3) + \\\\ q_D \\cdot \\mu^{-1}),</span>$</p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">A_1, A_2, A_3</span>  denote adversaries that run in time essentially the same as A.</li>
      <li><span class="math">Advantage_{DDH}</span>  is as defined in &sect;14.2.</li>
      <li><span class="math">Advantage_{Hash}(A)</span>  denotes the probability that an adversary A, given encodings  <span class="math">EU1^*</span>  and  <span class="math">EU2^*</span>  of two independent, random elements in  <span class="math">\\mathcal{G}</span> , can find encodings EU1 and EU2 of elements in  <span class="math">\\mathcal{G}</span> , such that  <span class="math">(EU1, EU2) \\neq (EU1^*, EU2^*)</span> , but</li>
    </ul>

    <p class="text-gray-300"><span class="math">$Hash.eval(EU1 \\parallel EU2) = Hash.eval(EU1^* \\parallel EU2^*).</span>$</p>

    <p class="text-gray-300">If the group supports multiple encodings, the adversary can choose the format it wants when  <span class="math">EU1^*</span>  and  <span class="math">EU2^*</span>  are generated; furthermore, the adversary may choose to use the same or</p>

    <p class="text-gray-300">different formats in its choice of EU1 and EU2; however,  <span class="math">EU1^*</span>  and  <span class="math">EU2^*</span>  must be encoded using the same format, and the same holds for EU1 and EU2.</p>

    <p class="text-gray-300">If CofactorMode = 1, then the adversary may choose EU1 to be an encoding of an element of  <span class="math">\\mathcal{H}</span>  that does not necessarily lie in  <span class="math">\\mathcal{G}</span> .</p>

    <p class="text-gray-300">Note that this problem is a second-preimage collision problem, which is generally believed to be a much harder problem to solve than the problem of finding an arbitrary pair of colliding inputs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">Advantage_{KDF}(A)</span>  denotes the advantage that an adversary A has in distinguishing between the following two distributions. Let  <span class="math">\\mathbf{u}_1</span>  and  <span class="math">\\tilde{\\mathbf{h}}</span>  be independent, random elements of  <span class="math">\\mathcal{G}</span> , and let EU1 be an encoding of  <span class="math">\\mathbf{u}_1</span> . Let R be a random byte string of length KeyLen. The first distribution is (R, EU1), and the second is  <span class="math">(KDF(EU1 || \\mathcal{E}&#x27;(\\tilde{\\mathbf{h}}), KeyLen), EU1)</span> .</li>
      <li><span class="math">q_D</span>  bounds the number of decryption oracle queries made by the adversary A.</li>
    </ul>

    <p class="text-gray-300">The &quot;O&quot; above represents a very small constant, which we have not computed exactly.</p>

    <p class="text-gray-300">The reader is referred to [CS01] for a detailed proof of a slight variant of this security claim. The situation in that paper is slightly different from the one here: in that paper, there is no notion of a label, no <em>CofactorMode</em>, and group elements are assumed to have unique encodings. Nevertheless, the proof presented there can be easily adapted to the situation here, with little change.</p>

      <h3 id="sec-17.6" class="text-xl font-semibold mt-8">17.6 Further remarks</h3>

      <h4 id="sec-17.6.1" class="text-lg font-semibold mt-6">17.6.1 Random oracles and interactive assumptions</h4>

    <p class="text-gray-300">We emphasize that this scheme can be proved secure under reasonable intractability assumptions, without resorting to either the random oracle heuristic, and without using &quot;interactive&quot; intractability assumptions as in done in [ABR99].</p>

    <p class="text-gray-300">We stress that a proof of security in the random oracle model is not a proof with &quot;just another assumption.&quot; One is not assuming a hash function is a random function, since this assumption is patently false. The random oracle model is a heuristic, and a proof of security in the random oracle model does not directly imply anything about the security of a system &quot;in the real world.&quot;</p>

    <p class="text-gray-300">We also stress that interactive intractability assumptions, like in [ABR99], are qualitatively much stronger than standard intractability assumptions. Indeed, it can be argued that the main activity of theoretical cryptography is to show that breaking a cryptosystem via some kind of subtle, interactive attack is at least as hard as solving some specific, non-interactive problem.</p>

    <p class="text-gray-300">ACE-KEM can also be proved secure in the random oracle model under the CDH assumption (see [Sho00]), although the reduction is not nearly as tight as for PSEC-KEM. Indeed, the tightness of the reduction for PSEC-KEM and the efficiency of PSEC-KEM are the main reasons for including PSEC-KEM in this proposal.</p>

      <h4 id="sec-17.6.2" class="text-lg font-semibold mt-6">17.6.2 ACE-KEM and ECIES-KEM</h4>

    <p class="text-gray-300">One should also note that ACE-KEM is no less secure than ECIES-KEM in a very strong sense. Indeed, assuming the two cryptosystems use the same parameters, then one can show that any adversary A that breaks ACE-KEM can be converted into an adversary A' with about the same running time that breaks ECIES-KEM with the same advantage.</p>

    <p class="text-gray-300">To see this, consider an <em>ECIES-KEM</em> public key containing the group element <strong>h</strong>. Upon obtaining this public key, A' generates w, x, y at random modulo  <span class="math">\\mu</span> , and then chooses  <span class="math">w, x, y \\in \\{0, \\dots, \\mu - 1\\}</span></p>

    <p class="text-gray-300">at random, and constructs the <em>ACE-KEM</em> public key  <span class="math">(\\mathbf{g}_2, \\mathbf{c}, \\mathbf{d}, \\mathbf{h})</span> , where  <span class="math">\\mathbf{g}_2 = w\\mathbf{g}</span> ,  <span class="math">\\mathbf{c} = x\\mathbf{g}</span> , and  <span class="math">\\mathbf{d} = y\\mathbf{g}</span> . A' then runs adversary A using this public key.</p>

    <p class="text-gray-300">Now, whenever the adversary A makes a decryption oracle query, then knowing w, x, y, adversary A' performs the extra validity tests of ACE-KEM, and if these pass, it uses the decryption oracle of ECIES-KEM to obtain the decrypted symmetric key, giving this to A.</p>

    <p class="text-gray-300">When A invokes the encryption oracle for ACE-KEM, A' invokes the encryption oracle for ECIES-KEM, obtaining an encoding of a group element  <span class="math">\\mathbf{u}_1^*</span> . Then using w, x, y, A' easily constructs the remaining components of a corresponding ACE-KEM ciphertext, and gives this to A.</p>

    <p class="text-gray-300">One needs to check that A' carries out a legal chosen ciphertext attack, i.e., that A' never attempts to submit the target ciphertext to the decryption oracle subsequent to the invocation of the encryption oracle. But this follows easily from the following claim: for any two valid ACE-KEM ciphertexts  <span class="math">C_0 = EU1 \\parallel EU2 \\parallel EV</span>  and  <span class="math">C_0^+ = EU1^+ \\parallel EU2^+ \\parallel EV^+</span> , if  <span class="math">EU1 = EU1^+</span> , then  <span class="math">C_0 = C_0^+</span> . Note that this claim relies on the fact that the validity test for a ciphertext  <span class="math">C_0</span>  as above ensures that EU1, EU2, and EV are encoded using the same format. If this were not done, then simply by replacing EU2 or EV by a different encoding of the same group element, one would violate the above claim.</p>

    <p class="text-gray-300">When A terminates and outputs a bit  <span class="math">\\hat{b}</span> , A' also terminates and outputs the same thing.</p>

    <p class="text-gray-300">It is easily seen that this simulation is perfect, and that whatever advantage A has in breaking ACE-KEM, A' has the same advantage in breaking ECIES-KEM.</p>

    <p class="text-gray-300">We have left one detail out of the above proof: in ECIES-KEM, the Diffie-Hellman public keys may not be zero, whereas in ACE-KEM, they may be. We leave it to the reader to adjust the above proof to accommodate this detail.</p>

      <h4 id="sec-17.6.3" class="text-lg font-semibold mt-6">17.6.3 ACE-Encrypt and ACE-KEM</h4>

    <p class="text-gray-300">We outline the major differences between ACE-Encrypt and ACE-KEM.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We have generalized the algorithm to work with an arbitrary, abstract group, and to work with an arbitrary message authentication code and symmetric key encryption scheme.</li>
      <li>We have chosen not to use the rather specialized universal one-way hash function to compute the quantity  <span class="math">\\alpha</span> . Instead, we use a standard cryptographic hash, and make a specific but reasonable &quot;second preimage collision resistance&quot; assumption.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The proposed standard need not necessarily preclude the possibility of using such a specialized hash function, so long as we allow such a hash to have a variable length key that is stored in the public key.</li>
    </ul></li>
      <li>We have chosen not to use the rather specialized entropy-smoothing hash function to derive the key K. Instead, we again use a standard cryptographic hash, and make a specific but again, reasonable &quot;entropy smoothing&quot; assumption.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The proposed standard need not necessarily preclude the possibility of using such a specialized hash function, so long as we allow such a hash to have a variable length key that is stored in the public key.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">OAEP-EME is a fully specified version of Bellare and Rogaway's original OAEP scheme for message encoding [BR94].</p>

    <p class="text-gray-300">In general, a message encoding scheme EME of this type specifies two algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>EME.Encode(M, L,ELen) takes as input a message M and a label L, and an output length ELen. Here, M and L are byte strings whose lengths are bounded, as described below. It outputs a byte string E of length ELen.</li>
      <li>EME.Decode(E, L) takes as input a byte string E and a label L. It attempts to find a message M such that EME.Encode(M, L, |E|) = E. It returns M if such an M exists, and otherwise fails.</li>
    </ul>

    <p class="text-gray-300">In addition to this, the mechanism should specify a bound EME.Bound such that when EME.Encode(M, L,ELen) is invoked, the condition |M| &le; ELen &minus; EME.Bound should hold; if not, the encoding algorithm fails. Additionally, the encoding algorithm may also fail if |L| exceeds some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">The algorithm EME.Encode will in general be probabilistic, so that the same message can be encoded in a number of ways.</p>

    <p class="text-gray-300">We now describe OAEP-EME.</p>

    <p class="text-gray-300">The scheme is parameterized by a hash function Hash (see &sect;11) and a key derivation function KDF (see &sect;12). Current standards, as well as the RSA-OAEP submission to ISO, recommend the use of the function KDF1 using Hash. Let HLen = Hash.OutputLen.</p>

    <p class="text-gray-300">The quantity OAEP-EME.Bound is defined as</p>

    <p class="text-gray-300"><span class="math">$OAEP</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">EME.Bound = 2 \\cdot HLen + 1.</span></li>
    </ul>

      <h4 id="sec-18.2.1" class="text-lg font-semibold mt-6">18.2.1 Encoding function</h4>

    <p class="text-gray-300">The algorithm OAEP-EME.Encode(M, L,ELen) runs as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that |M| &le; ELen &minus; 2 &middot; HLen &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a random byte string r of length HLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let pad be the byte string of length ELen&minus; |M| &minus;2 &middot;HLen consisting of a sequence of 0-bytes, followed by a single 1-byte.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x = Hash.eval(L) k pad k M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set s = KDF(r,ELen &minus; HLen) &oplus; x.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set t = KDF(s, HLen) &oplus; r.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output E = t k s.</li>
    </ol></li>
    </ul>

      <h4 id="sec-18.2.2" class="text-lg font-semibold mt-6">18.2.2 Decoding function</h4>

    <p class="text-gray-300">The algorithm OAEP-EME.Decode(E, L) runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let ELen = |E|.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check if ELen &ge; 2 &middot; HLen + 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse E as E = t k s, where |t| = HLen and |s| = ELen &minus; HLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set r = KDF(s, HLen) &oplus; t.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x = KDF(r,ELen &minus; HLen) &oplus; s.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test that x is of the form x = Hash.eval(L) k pad k M, where pad is a byte string consisting of zero or more 0-bytes, followed by a 1-byte. If not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output M.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We describe a generic RSA encryption scheme, based on an arbitrary message encoding mechanism EME. If one uses OAEP-EME, the resulting scheme is called RSA-OAEP.</p>

    <p class="text-gray-300">RSA-OAEP is a bounded length public-key encryption scheme.</p>

    <p class="text-gray-300">The public key consists of an RSA modulus n that is the product of two large primes, and an exponent e, where gcd(e, &phi;(n)) = 1. It also specifies any parameters of EME (such as Hash and KDF, in the case of OAEP-EME). Let nLen denote the length, in bytes, of n.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent d, where ed &equiv; 1 mod &phi;(n).</p>

      <h4 id="sec-18.3.2" class="text-lg font-semibold mt-6">18.3.2 Encryption</h4>

    <p class="text-gray-300">The algorithm to encrypt a message M, where |M| &le; nLen &minus; EME.Bound &minus; 1, with label L runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set E = EME.Encode(M, L, nLen &minus; 1).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = OS2IP(E).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set c = m<sup>e</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output C = I2OSP(c, nLen).</li>
    </ol></li>
    </ul>

      <h4 id="sec-18.3.3" class="text-lg font-semibold mt-6">18.3.3 Decryption</h4>

    <p class="text-gray-300">The algorithm to decrypt a ciphertext C with label L runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If |C| 6= nLen, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let c = OS2IP(C).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that c &le; n &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = c <sup>d</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set E = I2OSP(m, nLen &minus; 1); note that this step may fail if m is too large.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set M = EME.Decode(E, L); note that this step may fail.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">An implementation should take care not to reveal which of steps 5 or 6 fail. Such information could take the form of distinct error codes, or of timing information. In particular, it is recommended that both steps 5 and 6 should be performed, even if step 5 fails. If such precautions are not taken, an implementation may be vulnerable to Manger's attack [Man01].</p>

    <p class="text-gray-300">RSA-OAEP suffers from two defects.</p>

    <p class="text-gray-300">The first is a security defect. It was a widely held belief that the general OAEP construction was secure against adaptive chosen ciphertext attack, assuming the underlying trapdoor permutation was one-way. This belief is based on a supposed random-oracle proof in [BR94]. This of course would imply the security of RSA-OAEP in the random oracle model, assuming that RSA is oneway. However, it was recently shown in [Sho01] that the proof of security of the general OAEP construction was invalid, and further, the general construction can not be proven secure using standard proof techniques.</p>

    <p class="text-gray-300">This result by itself does not imply that RSA-OAEP is insecure; it simply invalidates the original justification of its security. In fact, in [Sho01], it is shown that RSA-OAEP with e = 3 is secure (in the random oracle model). This result is extended by [FOPS01] to arbitrary e. It should be noted however, that the security reduction is much less efficient in [FOPS01] than that proposed in [BR94] for OAEP.</p>

    <p class="text-gray-300">The fact that RSA-OAEP can be proved secure is essentially an accident. The proofs of security exploit particular algebraic properties of the RSA function.</p>

    <p class="text-gray-300">In [Sho01], a slight variant of OAEP is presented, called OAEP+. A detailed proof of security is given, on the general assumption of a trapdoor one-way permutation. Moreover, the security reduction is much more efficient than that of [FOPS01] or even [BR94].</p>

    <p class="text-gray-300">Another defect of RSA-OAEP is that it only encrypts messages of a bounded length. Because of this, RSA-OAEP is really only useful as a key encapsulation mechanism (see &sect;3), and it is left to application engineers to implement a &quot;digital envelope&quot; for encrypting longer messages. See &sect;2.1.2 for a discussion about why we believe that this standard should provide a complete solution to the &quot;digital envelope&quot; problem, rather than just a partial solution. Also, using RSA-OAEP for nothing more than key encapsulation completely wastes one of the main feature of OAEP, namely, its very good &quot;message expansion&quot; rate. Indeed, if all one wants to do with RSA is encapsulate a key, then one is better served using the RSA-KEM scheme in &sect;20, as that method is both simpler and quantitatively more secure.</p>

    <p class="text-gray-300">Because of these two defects, we propose that the new ISO standard contain a variation of RSA-OAEP+ that offers both a higher level of security than RSA-OAEP, while at the same time introduces a standard for encrypting messages of arbitrary length using RSA.</p>

    <p class="text-gray-300">In this section, we propose a new encryption scheme, called RSA-OAEP+. It has better provable security properties than RSA-OAEP, and also provides a secure mechanism for encrypting messages of arbitrary length.</p>

    <p class="text-gray-300">To facilitate encryption of arbitrary length messages, we extend the notion of a message encoding scheme.</p>

    <p class="text-gray-300">In general, an extended message encoding scheme XEME specifies two algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>XEME.Encode(M, L,ELen, KeyLen) takes as input a message M, a label L, an encoding output length ELen, and a key output length KeyLen. Here, M and L are byte strings whose lengths are bounded, as described below. It outputs a pair (E, K) of byte strings with |E| = ELen and |K| = KeyLen.</li>
      <li>XEME.Decode(E, L, KeyLen) takes as input a byte string E and a label L. It attempts to find a message M and a key K such that EME.Encode(M, L, |E|, KeyLen) = (E, K). It returns the pair (M, K) if it exists, and otherwise fails.</li>
    </ul>

    <p class="text-gray-300">In addition to this, the mechanism should specify a bound XEME.Bound such that when XEME.Encode(M, L,ELen, KeyLen) is invoked, the condition |M| &le; ELen &minus; XEME.Bound should hold; if not, the encoding algorithm fails. Additionally, the encoding algorithm may also fail if |L| or KeyLen exceed some (very large) implementation-defined bound.</p>

    <p class="text-gray-300">The algorithm XEME.Encode will in general be probabilistic, so that the same message can be encoded in a number of ways.</p>

    <p class="text-gray-300">We now describe the extended message encoding scheme OAEP+XEME.</p>

    <p class="text-gray-300">The scheme is parameterized by a key derivation function KDF (see &sect;12) and an integer MaskLen &ge; 1. Any of the functions described in &sect;12 are suitable.</p>

    <p class="text-gray-300">The quantity OAEP+XEME.Bound is defined as</p>

    <p class="text-gray-300"><span class="math">$OAEP + XEME.Bound = 2 \\cdot MaskLen + 1.</span>$</p>

    <p class="text-gray-300">Let (I0,I1, . . .) denote the values (I2OSP(0, 4),I2OSP(1, 4), . . .).</p>

      <h4 id="sec-19.2.1" class="text-lg font-semibold mt-6">19.2.1 Encoding function</h4>

    <p class="text-gray-300">The algorithm OAEP+XEME.Encode(M, L,ELen, KeyLen) runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that |M| &le; ELen &minus; 2 &middot; MaskLen &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a random byte string r of length MaskLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let pad be the byte string of length ELen &minus; |M| &minus; 2 &middot; MaskLen consisting of a sequence of 0-bytes, followed by a single 1-byte.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set x = pad k M.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$check = KDF(I0 \\parallel r \\parallel x \\parallel I2OSP(KeyLen, 4) \\parallel L, MaskLen).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol>

    <p class="text-gray-300"><span class="math">$x&#x27; = KDF(I1 || r, ELen - 2 \\cdot MaskLen) \\oplus x.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol>

    <p class="text-gray-300"><span class="math">$s = check \\parallel x&#x27;.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol>

    <p class="text-gray-300"><span class="math">$t = KDF(I2 \\parallel s, MaskLen) \\oplus r.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output</li>
    </ol>

    <p class="text-gray-300"><span class="math">$E = t \\parallel s</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$K = KDF(I3 || r, KeyLen).</span>$</p>

      <h4 id="sec-19.2.2" class="text-lg font-semibold mt-6">19.2.2 Decoding function</h4>

    <p class="text-gray-300">The algorithm OAEP+XEME.Decode(E, L) runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let ELen = |E|.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check if ELen &ge; 2 &middot; MaskLen + 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse E as E = t k s, where |t| = MaskLen and |s| = ELen &minus; MaskLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$r = KDF(I2 || s, MaskLen) \\oplus t.</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse s as check k x 0 , where |check| = MaskLen and |x 0 | = ELen &minus; 2 &middot; MaskLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$x = KDF(I1 \\parallel r, ELen - 2 \\cdot MaskLen) \\oplus x&#x27;.</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test if x is of the form x = pad k M, where pad is a byte string consisting of zero or more 0-bytes, followed by a 1-byte; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test if</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$check = KDF(I0 \\parallel r \\parallel x \\parallel I2OSP(KeyLen, 4) \\parallel L, MaskLen).</span>$</p>

    <p class="text-gray-300">If not, then fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output M and</li>
    </ol>

    <p class="text-gray-300"><span class="math">$K = KDF(I3 || r, KeyLen).</span>$</p>

    <p class="text-gray-300">This encoding scheme is very similar to that of [Sho01]. Besides a few inconsequential formatting changes, this scheme deals with a label L and produces a key K of length KeyLen. The scheme in [Sho01] does not deal with labels or key outputs at all. Notice that both KeyLen and L are hashed into the value check &mdash; this is important for the security of the scheme.</p>

    <p class="text-gray-300">In general, we have kept the changes between OAEP-EME and OAEP+XEME minimal. But since some changes were anyway necessary, we took the liberty to propose a couple of further changes.</p>

    <p class="text-gray-300">The main change is that we use the function KDF in several places, and we insert the strings I0,I1, etc., into the different invocations of KDF. This is done so that these can be more properly modeled as independent random oracles, as required in the proof of security.</p>

      <h3 id="sec-19.3" class="text-xl font-semibold mt-8">19.3 RSA-OAEP+</h3>

    <p class="text-gray-300">We describe a generic extended RSA encryption scheme that uses an arbitrary extended message encoding scheme XEME. If the OAEP+XEME encoding scheme is used, the resulting encryption scheme is called RSA-OAEP+. We call this an extended RSA encryption scheme, since it handles messages of arbitrary length.</p>

    <p class="text-gray-300">This scheme also makes use of a data encapsulation mechanism DEM (see &sect;4); however, we do not require that DEM supports any labels.</p>

      <h4 id="sec-19.3.1" class="text-lg font-semibold mt-6">19.3.1 Key generation</h4>

    <p class="text-gray-300">Just as for RSA-OAEP, the public key consists of an RSA modulus n that is the product of two large primes, and an exponent e, where gcd(e, &phi;(n)) = 1. It also specifies any parameters of XEME. Let nLen denote the length, in bytes, of n.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent d, where ed &equiv; 1 mod &phi;(n).</p>

      <h4 id="sec-19.3.2" class="text-lg font-semibold mt-6">19.3.2 Encrypting short messages</h4>

    <p class="text-gray-300">To encrypt a message M with label L, where |M| &le; nLen &minus; XEME.Bound &minus; 1, one does the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (E, K) = XEME.Encode(M, L, nLen &minus; 1, 0); note that K is the empty string.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = OS2IP(E).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set c = m<sup>e</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output C = I2OSP(c, nLen).</li>
    </ol></li>
    </ul>

      <h4 id="sec-19.3.3" class="text-lg font-semibold mt-6">19.3.3 Decrypting short messages</h4>

    <p class="text-gray-300">To decrypt a ciphertext C with label L, where |C| &le; nLen, one does the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If |C| &lt; nLen, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let c = OS2IP(C).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that c &le; n &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = c <sup>d</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set E = I2OSP(m, nLen &minus; 1); note that this step may fail if m is too large.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (M, K) = XEME.Decode(E, L, 0); note that this step may fail, and also that K is the empty string.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output M.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">As in the the case of RSA-OAEP, an implementation should reveal no information that would reveal to an adversary which of steps 5 or 6 fail.</p>

      <h4 id="sec-19.3.4" class="text-lg font-semibold mt-6">19.3.4 Encrypting long messages</h4>

    <p class="text-gray-300">To encrypt a message M with label L, where |M| &gt; nLen &minus; XEME.Bound &minus; 1, one does the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let M = M<sup>0</sup> k M1, where |M0| = nLen &minus; XEME.Bound &minus; 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (E, K) = XEME.Encode(M0, L, nLen &minus; 1, DEM.KeyLen).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = OS2IP(E).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set c = m<sup>e</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set C<sup>0</sup> = I2OSP(c, nLen).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Encrypt M<sup>1</sup> under the key K using DEM, and let C<sup>1</sup> be the resulting ciphertext.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the ciphertext C = C<sup>0</sup> k C1.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">To decrypt a ciphertext C with label L, where |C| &gt; nLen, one does the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse C as C = C<sup>0</sup> k C1, where |C0| = nLen.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let c = OS2IP(C0).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that c &le; n &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set m = c <sup>d</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set E = I2OSP(m, nLen &minus; 1); note that this step may fail if m is too large.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set (M0, K) = XEME.Decode(E, L, DEM.KeyLen). Note that this step may fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Test if |M0| = nLen &minus; XEME.Bound &minus; 1; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Decrypt C<sup>1</sup> under the key K using DEM, and let M<sup>1</sup> be the resulting message.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output M = M<sup>0</sup> k M1.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">As in the the case of RSA-OAEP, an implementation should reveal no information that would reveal to an adversary which of steps 5 or 6 fail.</p>

      <h3 id="sec-19.4" class="text-xl font-semibold mt-8">19.4 Security considerations</h3>

    <p class="text-gray-300">It is straightforward to adapt the proof of security in [Sho01] to show that this scheme is secure in the random oracle model against adaptive chosen ciphertext attack, assuming the RSA inversion problem is hard.</p>

    <p class="text-gray-300">That proof implies that for any adversary A, its advantage in breaking the cryptosystem RSA-OAEP+ is bounded by</p>

    <p class="text-gray-300"><span class="math">$Advantage_{RSA-OAEP+}(A) = O(Advantage_{RSA}(A_1) + Advantage_{DEM}(A_2, l_1) + q_D \\cdot q_{KDF} \\cdot 2^{-MaskLen})</span>$</p>

    <p class="text-gray-300">Here,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A<sup>1</sup> is an algorithm that runs in time roughly equivalent to that of A, plus O(q 2 KDF) applications of the RSA function,</li>
      <li>A2, A<sup>3</sup> are adversaries whose running times are about the same as A,</li>
      <li>AdvantageRSA(A) denotes the success probability of an algorithm A has in solving a random instance of the RSA inversion problem,</li>
      <li>q<sup>D</sup> is a bound on the number of decryption oracle queries made by A,</li>
      <li>qKDF is a bound on the number of random oracle queries made by A,</li>
      <li>l<sup>1</sup> is a bound on the length of the target message, and</li>
      <li>l<sup>2</sup> is a bound on the length of ciphertexts submitted to the decryption oracle.</li>
    </ul>

    <p class="text-gray-300">Note that this security reduction is actually somewhat more efficient than the original (and incorrect) security reduction for RSA-OAEP in [BR94]. It is also far more efficient than the security reduction in [FOPS01]. In that reduction, the algorithm A<sup>0</sup> for inverting RSA is somewhat slower than that of RSA-OAEP+, but worse, if the advantage of A is , then the success probability of A<sup>0</sup> is about 2 .</p>

    <p class="text-gray-300">Even though the security reduction for RSA-OAEP+ is tighter than that for RSA-OAEP, we should perhaps point out that because of the term O(q 2 KDF) in the running time of the RSA inversion algorithm, this reduction actually says very little about the security of, say, 1024-bit RSA. This is because one can (most likely) factor 1024-bit numbers in less time than that required by the implied RSA inversion algorithm. However, as pointed out in [Sho01], for exponent e = 3, there is a much more efficient security reduction whose running time is linear in qKDF. Is this a reason recommend the use of e = 3? Perhaps. Alternatively, one can use the RSA-KEM scheme (see &sect;20).</p>

    <p class="text-gray-300">Of course, if the security reduction for RSA-OAEP+ implies very little about concrete security, the security reduction for RSA-OAEP in [FOPS01] says even less.</p>

    <p class="text-gray-300">We also suggest for possible inclusion in the ISO standard the following very simple version of RSA. It is based on the ideas in [BR93].</p>

    <p class="text-gray-300">The scheme we present is a key encapsulation mechanism (see &sect;3), called RSA-KEM, which can be turned into an encryption scheme as described in &sect;5.</p>

    <p class="text-gray-300">The main advantages of this scheme are its simplicity and the fact that it yields a much more efficient (and hence meaningful) security reduction compared to that for OAEP or OAEP+. The disadvantage is that ciphertexts are a little bit larger.</p>

      <h3 id="sec-20.1" class="text-xl font-semibold mt-8">20.1 Key generation</h3>

    <p class="text-gray-300">Just as for RSA-OAEP, the public key consists of an RSA modulus n that is the product of two large primes, and an exponent e, where gcd(e, &phi;(n)) = 1. It also specifies a key derivation function KDF (see &sect;12). Let nLen denote the length, in bytes, of n.</p>

    <p class="text-gray-300">The secret key consists of the decryption exponent d, where ed &equiv; 1 mod &phi;(n).</p>

    <p class="text-gray-300">Recall that RSA-KEM is a key encapsulation mechanism, and so the goal of the encryption algorithm is simply to produce a pseudo-random key K of length KeyLen = RSA-KEM.OutputKeyLen and a ciphertext C<sup>0</sup> that encrypts K.</p>

    <p class="text-gray-300">The encryption algorithm runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate a random number r &isin; {0, . . . , n &minus; 1}.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute y = r <sup>e</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute K = KDF(I2OSP(r, nLen), KeyLen).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute C<sup>0</sup> = I2OSP(y, nLen).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the ciphertext C<sup>0</sup> and the key K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Given a ciphertext C0, decryption runs as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that |C0| = nLen; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set y = OS2IP(C0).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that y &lt; n; if not, then fail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute r = y <sup>d</sup> mod n.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute K = KDF(I2OSP(r, nLen), KeyLen).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the key K.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The security of RSA-KEM can be analyzed in the random oracle model in a manner very similar to that in [BR93], where we model the invocation of KDF as a random oracle query. It is easy to show that</p>

    <p class="text-gray-300"><span class="math">$Advantage_{RSA-KEM}(A) \\le Advantage_{RSA}(A&#x27;) + q_D/nBound,</span>$
(8)</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A<sup>0</sup> is an algorithm for solving a random instance of the RSA problem that runs in time roughly the same as that of A; more precisely, the running time is that of A, plus the time to perform qKDF exponentiations modulo n, where qKDF is a bound on the number of random oracle queries made by A;</li>
      <li>q<sup>D</sup> is a bound on the number of decryption oracle queries made by A;</li>
      <li>nBound is an lower bound on n.</li>
    </ul>

    <p class="text-gray-300">We sketch a proof of this. Let  <span class="math">\\mathbf{G}_0</span>  be the original attack game played by adversary A, and let  <span class="math">S_0</span>  be the event that A correctly guesses the hidden bit b in game  <span class="math">\\mathbf{G}_0</span> . Let H denote the random oracle mapping elements of  <span class="math">\\mathbf{Z}_n</span>  to bit strings of length KeyLen. Let  <span class="math">y^* \\in \\mathbf{Z}_n</span>  denote the target ciphertext, and let  <span class="math">r^* = (y^*)^{1/e} \\in \\mathbf{Z}_n</span> .</p>

    <p class="text-gray-300">We next define a game  <span class="math">\\mathbf{G}_1</span>  that is the same as game  <span class="math">\\mathbf{G}_0</span> , except that if the target ciphertext  <span class="math">y^*</span>  was submitted to the decryption oracle prior to the invocation of the encryption oracle, then the game is halted. Let  <span class="math">S_1</span>  be the event in game  <span class="math">\\mathbf{G}_1</span>  corresponding to the event  <span class="math">S_0</span> .</p>

    <p class="text-gray-300">Let  <span class="math">F_1</span>  be the event that game  <span class="math">\\mathbf{G}_1</span>  is halted as above. Clearly,  <span class="math">\\Pr[F_1] \\leq q_D/nBound</span> , and since games  <span class="math">\\mathbf{G}_0</span>  and  <span class="math">\\mathbf{G}_1</span>  proceed identically until  <span class="math">F_1</span>  occurs, it follows by Lemma 1 that  <span class="math">|\\Pr[S_0] - \\Pr[S_1]| \\leq q_D/nBound</span> .</p>

    <p class="text-gray-300">We next define a game  <span class="math">\\mathbf{G}_2</span>  that is the same as  <span class="math">\\mathbf{G}_1</span> , except that (1) the target ciphertext is generated at the beginning of the game, and (2) if the adversary ever queries H at  <span class="math">r^*</span> , we halt the game. Let  <span class="math">S_2</span>  be the event in game  <span class="math">\\mathbf{G}_2</span>  corresponding to the event  <span class="math">S_0</span> .</p>

    <p class="text-gray-300">It is clear by construction that  <span class="math">\\Pr[S_2] = 1/2</span> , since the key  <span class="math">H(r^*)</span>  is independent of everything else that is accessible to the adversary in game  <span class="math">\\mathbf{G}_2</span> , either directly or indirectly. Indeed, only the encryption oracle evaluates H at  <span class="math">r^*</span>  in this game.</p>

    <p class="text-gray-300">Let  <span class="math">F_2</span>  be the event that game  <span class="math">\\mathbf{G}_2</span>  is halted as above. It is clear that both games  <span class="math">\\mathbf{G}_1</span>  and  <span class="math">\\mathbf{G}_2</span>  proceed identically until  <span class="math">F_2</span>  occurs, and so by Lemma 1, we have  <span class="math">|\\Pr[S_1] - \\Pr[S_2]| \\leq \\Pr[F_2]</span> . Thus, it suffices to bound  <span class="math">\\Pr[F_2]</span> .</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_2] \\leq Advantage_{RSA}(A&#x27;)</span>$</p>

    <p class="text-gray-300">for an algorithm A' that runs in time bounded as described above. The inequality (8) will follow immediately.</p>

    <p class="text-gray-300">Algorithm A' runs as follows. It takes as input a random RSA modulus n, an RSA exponent e, and a random element  <span class="math">y^* \\in \\mathbf{Z}_n</span> . It creates a public key using N and e, and then lets adversary A run in game  <span class="math">\\mathbf{G}_2</span> .</p>

    <p class="text-gray-300">When adversary A invokes the encryption oracle, algorithm A' responds to A with the pair  <span class="math">(K^*, y^*)</span> , where  <span class="math">K^*</span>  is a random bit string of length KeyLen, and  <span class="math">y^*</span>  is the above-mentioned input to A.</p>

    <p class="text-gray-300">Algorithm A' simulates the random oracle H as well as the decryption oracle, as follows. For every input  <span class="math">r \\in \\mathbf{Z}_n</span>  to the random oracle, A' computes  <span class="math">y = r^e \\in \\mathbf{Z}_n</span> , and places the triple consisting of r, y, and the random value K = H(r) in a table; however, if  <span class="math">y = y^*</span> , algorithm A' instead outputs r and halts. When the adversary A submits a ciphertext  <span class="math">y \\in \\mathbf{Z}_n</span>  to the decryption oracle, algorithm A' looks up the value y in the above table to determine if the random oracle has been evaluated at  <span class="math">r = y^{1/e} \\in \\mathbf{Z}_n</span> . If so, algorithm A' responds to the decryption oracle invocation with the value K = H(r) stored in the table. Otherwise, algorithm A' generates a fresh random key K, and places the pair (y, K) in a second table; moreover, if in the future the adversary A should evaluate the random oracle at a point  <span class="math">r \\in \\mathbf{Z}_n</span>  such that  <span class="math">r^e = y</span> , then the key K generated above will be used for the value of H(r).</p>

    <p class="text-gray-300">It is clear that algorithm A' perfectly simulates the view of A, and that A' outputs a solution to the given instance of the RSA problem with probability equal to  <span class="math">\\Pr[F_2]</span> .</p>

    <p class="text-gray-300">That completes the proof of security.</p>

    <p class="text-gray-300">Quantitatively, it is clear that RSA-KEM provides a much better security reduction than RSA-OAEP+ (or RSA-OAEP). This advantage becomes even more pronounced when one analyzes the security of many messages encrypted under a single public key (as formally modeled in [BBM00]). In this setting, one can exploit the well-known random self-reducibility property of the</p>

    <p class="text-gray-300">RSA inversion problem to easily show that the security of RSA-KEM key encapsulation mechanism does not degrade at all as the number of ciphertexts increases. Note that this argument will be valid only if the number r in the encryption algorithm for Simple RSA is chosen uniformly modulo n, or at least with a distribution that is computationally indistinguishable from the uniform distribution.</p>

    <p class="text-gray-300">For RSA-OAEP+, the security degrades linearly with the number of ciphertexts, since one cannot use the random self-reducibility property, and must instead use a &quot;hybrid argument.&quot; The reason the random self-reducibility property cannot be used is that in RSA-OAEP+ (like RSA-OAEP) the ciphertext is not uniformly distributed modulo n.</p>

    <p class="text-gray-300">We also mention that RSA-KEM does not appear to be as &quot;fragile&quot; as either RSA-OAEP or RSA-OAEP+, in the sense that there appears to be no possible attacks on an implementation, such as those in [Man01].</p>

    <p class="text-gray-300">In this section, we summarize the next steps that must be taken to fully develop a standard. First, there are still a few gaps in the specifications that need to be filled in:</p>

    <p class="text-gray-300">choice of groups for Diffie-Hellman schemes: We have yet to specify precisely what groups are allowed. One possibility is to simply adopt &quot;wholesale&quot; the choices allowable in IEEE P1363.</p>

    <p class="text-gray-300">encoding of group elements: We have yet to fully specify how group elements are to be encoded as byte strings. Again, one possibility is simply to adopt &quot;wholesale&quot; the encoding schemes in IEEE P1363.</p>

    <p class="text-gray-300">choice of MAC's, SKE's, and KDF's: These choices are also yet to be specified. Again, one possibility is to simply adopt &quot;wholesale&quot; the choices allowable in IEEE P1363. However, the recommendations for KDF3 and KDF4 in the present proposal should be given some consideration. Also, for SKE's, we might want to consider other choices than those available in IEEE P1363a, e.g., a &quot;counter mode&quot; use of a block cipher; further, we may wish to &quot;harmonize&quot; the notion of an SKE as used here with the symmetric-key encryption part of the larger ISO standard.</p>

    <p class="text-gray-300">Second, a decision must be made as to whether this standard should require or recommend a particular encoding for public keys, e.g., as ASN.1 encoded structures. An argument for doing this is that it could potentially greatly enhance adoption of the schemes in this standard.</p>

    <p class="text-gray-300">Third, a decision must be made as to whether the schemes proposed here are the ones we really want. There seemed to be some consensus at the ad hoc meeting in Santa Barbara that the selection proposed here was acceptable, with the understanding that the decision to include the schemes RSA-OAEP+ and RSA-KEM, which were proposed by the editor, should be taken later after further scrutiny and discussion. Also, a decision needs to be made as to whether all of the restrictions on ECIES discussed in &sect;15.6 are appropriate, or whether some of these should be relaxed.</p>

    <p class="text-gray-300">Fourth, a full specification for EPOC-2, hopefully compatible with IEEE P1363a, needs to be developed for inclusion in a working draft.</p>

    <p class="text-gray-300">Fifth, this proposal must be converted to a proper draft standard. This entails separating out normative content (specifications) from informational content (rationale, security considerations, etc.), putting the latter in an annex. The intent is that the standard should contain almost all of the informational content that is in this proposal.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[ABR99] M. Abdalla, M. Bellare, and P. Rogaway. DHAES: an encryption scheme based on the Diffie-Hellma problem. Cryptology ePrint Archive, Report 1999/007, 1999. http: //eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[BBM00] M. Bellare, A. Boldyreva, and S. Micali. Public-key encryption in a multi-user setting: security proofs and improvements. In Advances in Cryptology&ndash;Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[BDPR98] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In Advances in Cryptology&ndash;Crypto '98, pages 26&ndash;45, 1998.</p></li>
      <li><p class="text-gray-300">[BLK00] J. Baek, B. Lee, and K. Kim. Secure length-saving ElGamal encryption under the computational Diffie-Hellman assumption. In Proc. 5th Australian Conference on Information, Security, and Privacy, 2000.</p></li>
      <li><p class="text-gray-300">[Bon98] D. Boneh. The Decision Diffie-Hellman Problem. In Ants-III, pages 48&ndash;63, 1998. Springer LNCS 1423.</p></li>
      <li><p class="text-gray-300">[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62&ndash;73, 1993.</p></li>
      <li><p class="text-gray-300">[BR94] M. Bellare and P. Rogaway. Optimal asymmetric encryption. In Advances in Cryptology&mdash;Eurocrypt '94, pages 92&ndash;111, 1994.</p></li>
      <li><p class="text-gray-300">[CGH98] R. Canetti, O. Goldreich, and S. Halevi. The random oracle model, revisited. In 30th Annual ACM Symposium on Theory of Computing, 1998.</p></li>
      <li><p class="text-gray-300">[CS98] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Advances in Cryptology&ndash;Crypto '98, pages 13&ndash;25, 1998.</p></li>
      <li><p class="text-gray-300">[CS01] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. Cryptology ePrint Archive, Report 2001/108, 2001. http://eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[DDN91] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In 23rd Annual ACM Symposium on Theory of Computing, pages 542&ndash;552, 1991.</p></li>
      <li><p class="text-gray-300">[DDN98] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography, 1998. Manuscript (updated, full length version of STOC paper).</p></li>
      <li><p class="text-gray-300">[FO99] E. Fujisaki and T. Okamoto. Secure integration of asymmetric and symmetric encryption schemes. In Advances in Cryptology&ndash;Crypto '99, pages 537&ndash;554, 1999.</p></li>
      <li><p class="text-gray-300">[FOPS01] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. In Advances in Cryptology&ndash;Crypto 2001, 2001.</p></li>
      <li><p class="text-gray-300">[JM96] D. Johnson and S. Matya. Asymmetric encryption: evolution and enhancements. Cryptobytes, 2(1), 1996. http://www.rsasecurity.com/rsalabs.</p></li>
      <li><p class="text-gray-300">[JN01] A. Joux and K. Nguyen. Separating Decision Diffie-Hellman from Diffie-Hellman in cryptographic groups. Cryptology ePrint Archive, Report 2001/003, 2001. http:// eprint.iacr.org.</p></li>
      <li><p class="text-gray-300">[Luc00] S. Lucks. The sum of PRPs is a secure PRF. In Advances in Cryptology&ndash;Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[Man01] J. Manger. A chosen ciphertext attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as standardized in PKCS # 1 v2.0. In Advances in Cryptology&ndash;Crypto 2001, pages 230&ndash;238, 2001.</p></li>
      <li><p class="text-gray-300">[NR97] M. Naor and O. Reingold. Number-theoretic constructions of efficient pseudo-random functions. In 38th Annual Symposium on Foundations of Computer Science, 1997.</p></li>
      <li><p class="text-gray-300">[OP01] T. Okamoto and D. Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Proc. 2001 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2001), 2001.</p></li>
      <li><p class="text-gray-300">[RS91] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In Advances in Cryptology&ndash;Crypto '91, pages 433&ndash;444, 1991.</p></li>
      <li><p class="text-gray-300">[Sho97] V. Shoup. Lower bounds for discrete logarithms and related problems. In Advances in Cryptology&ndash;Eurocrypt '97, 1997.</p></li>
      <li><p class="text-gray-300">[Sho00] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology&ndash;Eurocrypt 2000, 2000.</p></li>
      <li><p class="text-gray-300">[Sho01] V. Shoup. OAEP reconsidered. In Advances in Cryptology&ndash;Crypto 2001, 2001.</p></li>
      <li><p class="text-gray-300">[Sta96] M. Stadler. Publicly verifiable secret sharing. In Advances in Cryptology&ndash;Eurocrypt '96, pages 190&ndash;199, 1996.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="A Proposal for an ISO Standard for Public Key Encryption (2001/112)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2001 &middot; eprint 2001/112
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Background</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Goals of this document</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Preliminary remarks on security</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">A summary of submissions and proposed schemes</a></li>
            <li><a href="#sec-1.4.1" class="hover:text-white">RSA-OAEP, RSA-OAEP+, and RSA-KEM</a></li>
            <li><a href="#sec-1.4.2" class="hover:text-white">ECIES</a></li>
            <li><a href="#sec-1.4.3" class="hover:text-white">PSEC</a></li>
            <li><a href="#sec-1.4.4" class="hover:text-white">ACE-Encrypt</a></li>
            <li><a href="#sec-1.4.5" class="hover:text-white">EPOC</a></li>
            <li><a href="#sec-1.4.6" class="hover:text-white">HIME</a></li>
            <li><a href="#sec-1.4.7" class="hover:text-white">Further references on the submissions</a></li>
            <li><a href="#sec-1.4.8" class="hover:text-white">Summary of proposed schemes</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Public-key encryption and chosen ciphertext attack</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Abstract interface</a></li>
            <li><a href="#sec-2.1.1" class="hover:text-white">Soundness</a></li>
            <li><a href="#sec-2.1.2" class="hover:text-white">Message length</a></li>
            <li><a href="#sec-2.1.3" class="hover:text-white">Stream processing</a></li>
            <li><a href="#sec-2.1.4" class="hover:text-white">The use of labels</a></li>
            <li><a href="#sec-2.1.5" class="hover:text-white">Ciphertext format</a></li>
            <li><a href="#sec-2.1.6" class="hover:text-white">Scheme-specific encryption options</a></li>
            <li><a href="#sec-2.1.7" class="hover:text-white">Algorithm failure</a></li>
            <li><a href="#sec-2.1.8" class="hover:text-white">Bits vs. Bytes</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Notion of security</a></li>
            <li><a href="#sec-2.2.1" class="hover:text-white">Alternative characterizations and implications</a></li>
            <li><a href="#sec-2.2.2" class="hover:text-white">Hiding the message length</a></li>
            <li><a href="#sec-2.2.3" class="hover:text-white">Failing streams</a></li>
            <li><a href="#sec-2.2.4" class="hover:text-white">Security parameters and asymptotic security</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Benign malleability: a slightly weaker notion of security</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Key encapsulation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Abstract interface</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Notion of security</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Further remarks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Data encapsulation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Abstract interface</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Notion of security</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Hybrid encryption</a></li>
        <li><a href="#sec-6" class="hover:text-white">Byte string/integer conversions</a></li>
        <li><a href="#sec-7" class="hover:text-white">Pseudo-random byte generator</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">Symmetric key encryption</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Abstract interface</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Notion of security</a></li>
          </ol>
        </li>
        <li><a href="#sec-9" class="hover:text-white">One-time MAC</a></li>
        <li><a href="#sec-10" class="hover:text-white">DEM1</a></li>
        <li><a href="#sec-11" class="hover:text-white">Hash functions</a></li>
        <li>
          <a href="#sec-12" class="hover:text-white">Key derivation functions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-12.1" class="hover:text-white">KDF1</a></li>
            <li><a href="#sec-12.2" class="hover:text-white">KDF2</a></li>
            <li><a href="#sec-12.3" class="hover:text-white">Security critique of KDF1 and KDF2</a></li>
            <li><a href="#sec-12.4" class="hover:text-white">KDF3</a></li>
            <li><a href="#sec-12.5" class="hover:text-white">KDF4</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-13" class="hover:text-white">Abstract groups</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-13.1" class="hover:text-white">Subgroups of \mathbf&#123;Z&#125;_&#123;v&#125;^&#123;*&#125;</a></li>
            <li><a href="#sec-13.2" class="hover:text-white">Subgroups of Elliptic Curves</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-14" class="hover:text-white">Intractability assumptions related to groups</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-14.1" class="hover:text-white">The Computational Diffie-Hellman Problem</a></li>
            <li><a href="#sec-14.2" class="hover:text-white">The Decisional Diffie-Hellman Problem</a></li>
            <li><a href="#sec-14.3" class="hover:text-white">The Gap-CDH Problem</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-15" class="hover:text-white">ECIES-KEM</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-15.1" class="hover:text-white">Key Generation</a></li>
            <li><a href="#sec-15.2" class="hover:text-white">Encryption</a></li>
            <li><a href="#sec-15.3" class="hover:text-white">Decryption</a></li>
            <li><a href="#sec-15.4" class="hover:text-white">Some remarks</a></li>
            <li><a href="#sec-15.5" class="hover:text-white">Security considerations</a></li>
            <li><a href="#sec-15.6" class="hover:text-white">Compatibility with the IEEE P1363a version of ECIES</a></li>
            <li><a href="#sec-15.6.1" class="hover:text-white">Key derivation using C0</a></li>
            <li><a href="#sec-15.6.2" class="hover:text-white">No other key derivation parameters</a></li>
            <li><a href="#sec-15.6.3" class="hover:text-white">Proper label formatting</a></li>
            <li><a href="#sec-15.6.4" class="hover:text-white">No stream cipher option</a></li>
            <li><a href="#sec-15.6.5" class="hover:text-white">No use of &quot;old&quot; cofactor mode</a></li>
            <li><a href="#sec-15.6.6" class="hover:text-white">Messages are byte strings</a></li>
            <li><a href="#sec-15.6.7" class="hover:text-white">Static selection of system parameters</a></li>
            <li><a href="#sec-15.6.8" class="hover:text-white">gcd(&micro;, &nu;) = 1 if both CofactorMode and CheckMode are zero</a></li>
            <li><a href="#sec-15.7" class="hover:text-white">Compatibility with the submitted version of ECIES</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-16" class="hover:text-white">PSEC-KEM</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-16.1" class="hover:text-white">Key Generation</a></li>
            <li><a href="#sec-16.2" class="hover:text-white">Encryption</a></li>
            <li><a href="#sec-16.3" class="hover:text-white">Decryption</a></li>
            <li><a href="#sec-16.4" class="hover:text-white">Some remarks</a></li>
            <li><a href="#sec-16.5" class="hover:text-white">Changes from PSEC-2</a></li>
            <li><a href="#sec-16.6" class="hover:text-white">Security considerations</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-17" class="hover:text-white">ACE-KEM</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-17.1" class="hover:text-white">Key Generation</a></li>
            <li><a href="#sec-17.2" class="hover:text-white">Encryption</a></li>
            <li><a href="#sec-17.3" class="hover:text-white">Decryption</a></li>
            <li><a href="#sec-17.4" class="hover:text-white">Some remarks</a></li>
            <li><a href="#sec-17.5" class="hover:text-white">Security considerations</a></li>
            <li><a href="#sec-17.6" class="hover:text-white">Further remarks</a></li>
            <li><a href="#sec-17.6.1" class="hover:text-white">Random oracles and interactive assumptions</a></li>
            <li><a href="#sec-17.6.2" class="hover:text-white">ACE-KEM and ECIES-KEM</a></li>
            <li><a href="#sec-17.6.3" class="hover:text-white">ACE-Encrypt and ACE-KEM</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-18" class="hover:text-white">RSA-OAEP</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-18.1" class="hover:text-white">Message encoding functions</a></li>
            <li><a href="#sec-18.2" class="hover:text-white">OAEP-EME</a></li>
            <li><a href="#sec-18.2.1" class="hover:text-white">Encoding function</a></li>
            <li><a href="#sec-18.2.2" class="hover:text-white">Decoding function</a></li>
            <li><a href="#sec-18.3" class="hover:text-white">RSA-OAEP</a></li>
            <li><a href="#sec-18.3.1" class="hover:text-white">Key generation</a></li>
            <li><a href="#sec-18.3.2" class="hover:text-white">Encryption</a></li>
            <li><a href="#sec-18.3.3" class="hover:text-white">Decryption</a></li>
            <li><a href="#sec-18.4" class="hover:text-white">Defects of RSA-OAEP</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-19" class="hover:text-white">RSA-OAEP+</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-19.1" class="hover:text-white">Extended message encoding functions</a></li>
            <li><a href="#sec-19.2" class="hover:text-white">OAEP+XEME</a></li>
            <li><a href="#sec-19.2.1" class="hover:text-white">Encoding function</a></li>
            <li><a href="#sec-19.2.2" class="hover:text-white">Decoding function</a></li>
            <li><a href="#sec-19.3" class="hover:text-white">RSA-OAEP+</a></li>
            <li><a href="#sec-19.3.1" class="hover:text-white">Key generation</a></li>
            <li><a href="#sec-19.3.2" class="hover:text-white">Encrypting short messages</a></li>
            <li><a href="#sec-19.3.3" class="hover:text-white">Decrypting short messages</a></li>
            <li><a href="#sec-19.3.4" class="hover:text-white">Encrypting long messages</a></li>
            <li><a href="#sec-19.3.5" class="hover:text-white">Decrypting long messages</a></li>
            <li><a href="#sec-19.4" class="hover:text-white">Security considerations</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-20" class="hover:text-white">RSA-KEM</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-20.1" class="hover:text-white">Key generation</a></li>
            <li><a href="#sec-20.2" class="hover:text-white">Encryption</a></li>
            <li><a href="#sec-20.3" class="hover:text-white">Decryption</a></li>
            <li><a href="#sec-20.4" class="hover:text-white">Security considerations</a></li>
          </ol>
        </li>
        <li><a href="#sec-21" class="hover:text-white">Further actions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-proposal-for-an-iso-standard-for-public-key-encryption-2001" />
  </article>
</BaseLayout>
