---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/1159';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'SPECTRE: A Fast and Scalable Cryptocurrency Protocol';
const AUTHORS_HTML = 'Yonatan Sompolinsky, Yoad Lewenberg, Aviv Zohar';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">A growing body of research on Bitcoin and other permissionless cryptocurrencies that utilize Nakamoto&#x27;s blockchain has shown that they do not easily scale to process a high throughput of transactions, or to quickly approve individual transactions; blocks must be kept small, and their creation rates must be kept low in order to allow nodes to reach consensus securely. As of today, Bitcoin processes a mere 3-7 transactions per second, and transaction confirmation takes at least several minutes.

We present SPECTRE, a new protocol for the consensus core of cryptocurrencies that remains secure even under high throughput and fast confirmation times. At any throughput, SPECTRE is resilient to attackers with up to 50\\% of the computational power (up until the limit defined by network congestion and bandwidth constraints). SPECTRE can operate at high block creation rates, which implies that its transactions confirm in mere seconds (limited mostly by the round-trip-time in the network).

Key to SPECTRE&#x27;s achievements is the fact that it satisfies weaker properties than classic consensus requires. In the conventional paradigm, the order between any two transactions must be decided and agreed upon by all non-corrupt nodes. In contrast, SPECTRE only satisfies this with respect to transactions performed by honest users. We observe that in the context of money, two conflicting payments that are published concurrently could only have been created by a dishonest user, hence we can afford to delay the acceptance of such transactions without harming the usability of the system.
Our framework formalizes this weaker set of requirements for a cryptocurrency&#x27;s distributed ledger.
We then provide a formal proof that SPECTRE satisfies these requirements.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> cryptocurrencies &middot; Bitcoin &middot; distributed algorithms</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold"><em>C. The</em> T xO <em>protocol</em></h2>

    <p class="text-gray-300">Overview. As the block DAG may contain conflicting transactions, we must provide a method for nodes to interpret the DAG and extract from it the set of accepted transactions. Doing so in a way that will be agreed upon by all nodes (eventually) is the main challenge of SPECTRE. We now describe how this is done.</p>

    <p class="text-gray-300">The topology of a block DAG G induces a natural precedence-relation over blocks: if x is reachable from y (i.e., x &isin; past(y)) then x precedes y, as it was provably created before it. SPECTRE extends this relation into a complete relation over G's blocks, denoted &#8826;. This order is immediately translatable into an order over transactions in G: tx<sup>1</sup> precedes tx<sup>2</sup> if the block containing the former precedes that containing the latter. This relation, in turn, induces a natural subset of accepted transactions: tx is accepted if it precedes all of its conflicting transactions in G. The relation &#8826; is generated by a pairwise vote procedure that occurs independently for every pair of blocks. The operation of this layer will be explained in the next subsections.</p>

    <p class="text-gray-300">Although we may at times refer to &#8826; as though it orders blocks, we stress that &#8826; <em>is not necessarily a transitive relation</em>. It is possible to have a series of blocks that precede each other cyclically.<sup>2</sup> The lack of a total linear ordering over blocks is in fact the way SPECTRE utilizes the weaker consensus requirements of our framework, as a linear order is equivalent to solving the consensus problem [3].</p>

    <p class="text-gray-300">Pairwise ordering of blocks. The basic layer of SPECTRE involves deciding on a pairwise order over the block DAG. Fix two blocks x, y &isin; G. In order to decide if x &#8826; y or y &#8826; x, we interpret the structure of the DAG as representing an abstract vote. Every block z &isin; G is considered a voter with respect to the pair (x, y), and <em>its vote is inferred from the structure of the DAG</em>. We represent a vote by a number in {&minus;1, 0, +1}, and we denote z's voting-profile on all pairs by vote (z, G). votex,y (z, G) = &minus;1 represents x preceding y (x &#8826; y), votex,y (z, G) = +1 represents y preceding x, and votex,y (z, G) = 0 represents a tie. Importantly, vote (z, G) is an asymmetric relation: votey,x (z, G) = &minus;votex,y (z, G).</p>

    <p class="text-gray-300">To simplify presentation, we associate a vote with virtual(G) as well. Recall that the virtual block of G is a hypothetical block which satisfies past(virtual(G)) = G. The vote of virtual(G) represents essentially the aggregated vote of the entire block DAG. The basic rules of z's vote, for any z &isin; G &cup; {virtual(G)}, are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if z &isin; G is in future (x) but not in future (y) then it will vote in favour of x (i.e., for x &#8826; y).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if z &isin; G is in future (x)&cap;future (y) then z's vote will be determined recursively according to the DAG that is reduced to its past, i.e., it has the same vote as virtual(past(z)). If the result of this vote is a tie, z breaks it arbitrarily.<sup>3</sup></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if z &isin; G is not in the future of either blocks then it will vote the same way as the vote of the majority of blocks in its own future.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if z is the virtual block of G then it will vote the same way as the vote of the majority of blocks in G.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>finally, (for the case where z equals x or y), z votes for itself to succeed any block in past(z) and to precede any block outside past(z).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><sup>2</sup>This is related to the Condorcet paradox in social choice [2].</p>

    <p class="text-gray-300"><sup>3</sup>We can use information encoded in z's header, e.g., explicit instructions for tie-breaking, or use the lexicographical ordering of (hashes of) tied blocks, etc.</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: An example of the voting procedure on a simple DAG. Block x and blocks 6-8 vote  <span class="math">x \\prec y</span>  as they only see x in their past, and not y. Similarly, block y and blocks 9-11 vote  <span class="math">y \\prec x</span> . Block 12 votes according to a recursive call on the DAG that does not contain blocks 10,11,12. Any block from 1-5 votes  <span class="math">x \\prec y</span> , because it sees more  <span class="math">x \\prec y</span>  voters in its future than  <span class="math">y \\prec x</span>  voters.</p>

    <p class="text-gray-300">Intuitively, the first rule dictates that a block that was honestly published gain votes over blocks that are secretly withheld, as honest nodes keep adding new blocks to its future set. The second and fourth rules together guarantee majority amplification, as new blocks add votes that comply with and enhance previous decisions. The third rule is the most subtle; basically, it allows blocks in past(x) (in addition to those in future(x)) to vote in its favour against y, in case y was withheld for a long time. This is needed to counter a pre-mining attack scheme, which will be described in future sections. Notice that all votes respect the DAG's topology: If x is reachable from y then all blocks vote unanimously  <span class="math">x \\prec y</span> .</p>

    <p class="text-gray-300">Figure 1 illustrates the voting procedure with regards to a single pair of blocks (x,y). Additional examples along with intuition regarding this key algorithm are provided in Appendix A.</p>

    <p class="text-gray-300">The voting procedure is implemented in Algorithm 1 below. In the algorithm,  <span class="math">\\widetilde{sgn}(n) = -1</span>  for n &lt; 0,  <span class="math">\\widetilde{sgn}(n) = +1</span>  for n &gt; 0, and  <span class="math">\\widetilde{sgn}(0) = 0</span> . To see that the recursion calls from line 4 halt, observe that they take as inputs DAGs strictly smaller than G (because  <span class="math">past(z) \\subseteq G</span> ), and hence eventually all arrive at the base case  <span class="math">G = \\emptyset</span>  and return. The algorithm is written in its na&iuml;ve form, for the sake of readability, with a run time of  <span class="math">\\mathcal{O}(|G|^3)</span> . We have written a more sophisticated implementation of this procedure, which runs in expected time of  <span class="math">\\mathcal{O}(d \\cdot \\lambda)</span> . We will make the code available online in the full version.</p>

    <p class="text-gray-300">The pairwise ordering of SPECTRE has the following highly valuable property:</p>

    <p class="text-gray-300"><strong>Property 4.</strong> Once a block is published, the set of blocks that precede it in the pairwise ordering closes fast&mdash;w.h.p. it consists only of blocks published before or right after its publication.</p>

    <p class="text-gray-300">The implications of this guarantee to the security of transactions is immediate, at least at the intuitive level: A user whose transaction is embedded in some published block x can guarantee its safety by waiting some time after x's publication before accepting it; he is then guaranteed that any block published later on &ndash; and that might contain a conflicting transaction &ndash; will be preceded by x hence will not threaten the acceptance of his transaction. In Section 5 we will explain how this guarantee is achieved.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Algorithm 1 CalcV otes</h4>

    <pre><code class="language-text">Input: G &ndash; a block DAG
Output: vote (virtual(G)) &ndash; a pairwise ordering of blocks in G
 1: if G = &empty; then
 2: return an empty ordering
 3: for all z &isin; G do
 4: vote (z, past(z)) &larr; CalcV otes (past(z)) and break ties arbitrarily
 5: for all z &isin; G in some topological order (from leaves to root) do
 6: for all x, y &isin; G (x 6= y) do
 7: if
             x &isin; past (z) &and; y /&isin; past(z)

                                       &or; (x &isin; past(z), y = z) then
 8: votex,y (z, G) &larr; &minus;1
 9: else if
                 y &isin; past (z) &and; x /&isin; past(z)

                                           &or; (y &isin; past(z), x = z) then
10: votex,y (z, G) &larr; +1
11: else if x, y &isin; past(z) then
12: votex,y (z, G) &larr; votex,y (z, past(z))
13: else if x, y /&isin; past(z) then
14: votex,y (z, G) &larr; sgn g
                                 P
                                    z
                                     0&isin;future(z,G)
                                                 votex,y (z
                                                          0
                                                           , G)

15: vote (virtual(G), G) &larr; sgn g
                              P
                                 z&isin;G vote (z, G)

16: return vote (virtual(G), G)
</code></pre>

    <p class="text-gray-300">Accepting transactions. Equipped with the pairwise relation over blocks, we now turn to construct the set of accepted transactions. To maintain consistency, we mark a transaction as accepted iff all three conditions below hold true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>all of its inputs have been accepted.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>all conflicting transactions from its anticone set (i.e., that are not related to it topologically) are contained in blocks that are preceded by the block containing the transaction.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>all conflicting transactions from its past set (i.e., that precede it in the DAG, topologically) have been rejected.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Algorithm 2 implements these rules, and outputs a set of accepted transactions. It operates recursively, and should be initially called with T xO(G, G) (we later denote this simply by T xO(G)). In the algorithm, the notation ZG(tx) stands for all blocks in G that contain tx. Some complexity arises due to possible multiple copies of the same transaction in the DAG; we denote by [tx] the equivalence class containing all of tx's copies.</p>

    <p class="text-gray-300">The third part of the SPECTRE protocol, namely, the RobustT xO procedure, is rather involved. We defer its description to Appendix C.</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold">5. HIGH-LEVEL OVERVIEW OF THE PROOF</h2>

    <p class="text-gray-300">We now provide some intuition as to why SPECTRE's procedures indeed guarantee that transactions can be accepted safely, and that all transactions of honest users are quickly accepted. We aim at proving Property 4. As mentioned above, this property is easy to translate to the desired</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Algorithm 2 TxO</h4>

    <p class="text-gray-300">Input: G &ndash; a block DAG, subG &ndash; a subDAG of G which is the past of a (possibly virtual) block</p>

    <pre><code class="language-text">Output: Tx &ndash; a hyper-set of valid transactions in G
 1: vote\\left(virtual\\left(G\\right)\\right) \\leftarrow CalcVotes(G)
 2: Tx \\leftarrow \\emptyset
 3: for all z_1 \\in subG do
 4:
         for all tx \\in z_1 do
             for all tx_2 \\in G \\cap conflict(tx) do
 5:
                 for all z_2 \\in Z_G(tx_2) \\cap anticone(z_1, G) do
 6:
 7:
                      if vote_{z_1,z_2} (virtual(G)) \\geq 0 then
                          break (to line 4 and pick next tx)
 8:
                 if [tx_2] \\cap TxO(G, past(z_1)) \\neq \\emptyset then
 9:
                      break (to line 4 and pick next tx)
10:
             for all [tx_3] \\in inputs(tx) do
11:
                 if [tx_3] \\cap TxO(G, past(z_1)) = \\emptyset then
12:
13:
                      break (to line 4 and pick next tx)
             add tx to Tx
14:
15: return Tx
</code></pre>

    <p class="text-gray-300">security properties of transactions (as we do formally in Appendix E). Concretely, we wish to prove the following statement (in the proposition,  <span class="math">G_r^{pub} := \\bigcup_{u \\in honest} G_r^u</span> ):</p>

    <p class="text-gray-300"><strong>Proposition.</strong> Assume block x was published at time  <span class="math">t_{pub}</span>  ( <span class="math">x \\in G_{t_{pub}}^{pub}</span> ), and y not published before time  <span class="math">t_{acc}</span>  ( <span class="math">y \\notin G_{t_{acc}}^{pub}</span> ). Let  <span class="math">T = t_{acc} - t_{pub}</span> . Then the probability that x will not always precede y ( <span class="math">\\Pr(\\exists u \\in honest, \\exists s \\geq t_{acc} : vote_{x,y}(virtual(G_s^u)) \\geq 0</span> )) decreases exponentially in T.</p>

    <p class="text-gray-300"><em>Proof overview.</em> Assume that the event in which y comes to precede x in some future DAG occurs. Let s be the earliest moment in time that such an event occurred at some node. Notice that y cannot be in the past of x or in its future (otherwise their order is determined by the topology and cannot be reversed). We thus assume henceforth  <span class="math">y \\in anticone(x)</span> .</p>

    <p class="text-gray-300">The block race after x is published. We first consider the votes of blocks created after the publication of block x:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(Almost) all honest blocks created between  <span class="math">t_{pub}</span>  and  <span class="math">t_{acc}</span>  vote forever in favour of  <span class="math">x \\prec y</span> , as they have x in their past but not y. Denote by  <span class="math">n_1</span>  the number of such blocks.</li>
      <li>All honest blocks created between  <span class="math">t_{acc}</span>  and s vote in favour of  <span class="math">x \\prec y</span> , as well, by the choice of s. Denote by  <span class="math">n_2</span>  the number of such blocks.</li>
      <li>Denote by  <span class="math">m_1</span>  and  <span class="math">m_2</span>  the number of blocks created by the attacker in the time intervals corresponding to  <span class="math">n_1</span>  and  <span class="math">n_2</span> . Honest nodes possess a fraction  <span class="math">1 \\alpha &gt; \\alpha</span>  of the computational</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>Intuitively,  <span class="math">t_{acc}</span>  represents the time at which some node accepted a transaction which appears in block x.</p>

    <p class="text-gray-300">power. Consequently, for any positive constant C, the probability that the relation m<sup>1</sup> + m<sup>2</sup> + C &minus; (n<sup>1</sup> + n2) &ge; 0 will ever be satisfied decreases exponentially with n1. This is typically analyzed as the probability that a biased random walk on the integers, beginning at C, returns to the origin (see [13], [17], [18]).</p>

    <p class="text-gray-300">The term m<sup>1</sup> + m<sup>2</sup> &minus; (n<sup>1</sup> + n2) represents the aggregate vote between x and y, considering only blocks created after x's publication. We now show that blocks that the attacker prepared in advance before x's publication, in a preparatory &quot;pre-mining&quot; stage, do not give him more than some constant advantage (which will be counted into C above).</p>

    <p class="text-gray-300">The pre-mining stage. Honest blocks that were created before x was published are typically in its past (apart from a small set of blocks) and hence have their vote decided by the majority of votes in their future (as per Alg. 1). Their vote is thus possibly subject to change as the DAG grows, and as the attacker publishes blocks.</p>

    <p class="text-gray-300">For every block z in the past of x we must therefore consider the number of blocks above it that vote in favour of x and those that vote against it. Denote by X<sup>z</sup> the gap between the number of attacker blocks and honest blocks in the future of z, up to time tpub. In Lemma 24 we show that the worst case gap X<sup>z</sup> (over all blocks z &isin; past(x)) can be modeled as a reflecting random walk over the nonnegative integers, with bias towards the origin. Consequently, the best gap that the attacker can secretly gain over a block in past(x) has an exponentially decaying tail, and, in particular, is bounded by a constant w.h.p.</p>

    <p class="text-gray-300">All in all, as tacc &minus; tpub grows, the number n<sup>1</sup> of votes, or &quot;confirmations&quot;, that x receives increases linearly, and the probability that the attacker will be able to reveal enough blocks so that some z &isin; past(x) will have more y &#8826; x votes in its future than x &#8826; y votes, decreases exponentially in n1. Since this holds for all z &isin; past(x) uniformly, it implies in particular that the genesis block has more x &#8826; y votes in its future than y &#8826; x votes (unless an exponentially unlikely event occurred). The vote of the virtual block is determined by that of the genesis block (this is easy to see, and is proven in Lemma 13), completing the argument.</p>

    <p class="text-gray-300">The proposition above is the gist of Lemmas 14 and 15. In the above sketch, we abstracted out many additional subtleties and details. For instance, honest blocks that were created D seconds around tpub, tacc, or s may not have contributed votes in favour of x. In our formal analysis (Appendix E) we count these as attacker blocks, accounting for the worst case, and add them to the aforementioned constant C. We additionally show how the user can measure n<sup>1</sup> correctly, even if the attacker publishes his blocks in an attempt to delay acceptance.</p>

    <h2 id="sec-misc-5" class="text-2xl font-bold">6. RELATED WORK</h2>

    <p class="text-gray-300">Previous research has produced several suggestions for protocols that attempt to address the security-scalability challenge, but all protocols still provide a total order over blocks:</p>

    <p class="text-gray-300">GHOST is an alternative chain selection rule that gradually chooses a tree of blocks until converging on a single chain [18]. It can be shown that the Liveness property of GHOST can be attacked, as was demonstrated by [8]. The use of block DAGs was proposed in the Inclusive work [10], in which throughput was increased by integrating off-chain blocks into the ledger. Due to the reliance on a chain, Inclusive mitigates but does not avoid the security-scalability trade-off. The Inclusive paper further includes a game theoretic analysis of the incentives of nodes to embed different transactions in their blocks (without the ability to coordinate).<sup>5</sup></p>

    <p class="text-gray-300">Bitcoin-NG [6] provides a clever chain structure that is composed of two types of blocks: key blocks that require PoW but contain no transactions, and mini-blocks that do not require PoW but do contain transactions. Bitcoin-NG manages to obtain a significant scalability increase, but its key blocks are still generated slowly, hence, confirmation times remain high. Another line of work bootstraps PoW to instantiate a committee that is later used to run classical BFT protocols. Examples from this line of research include Byzcoin [9], a work by Decker <em>et. al.</em> [4], Hybrid Consensus [16], and recently Solidus [1]. Protocols built in this manner are highly scalable, building upon work in consensus protocols, but lack some of the properties achieved by Bitcoin. They typically require large committees and require committee members to remain online for long periods of time, making them susceptible to network isolation and DoS attacks. [9], [4], [1] additionally fail without recovering if the committee is ever composed of a high fraction of malicious entities (Bitcoin, on the other hand, is self-stabilizing). Moreover, they require forward secrecy. If the cryptographic keys of a sufficient fraction of the committee at any point in the past is compromised, the attacker can create an alternative equally acceptable version of events.</p>

    <p class="text-gray-300">The Algorand protocol [11] is a proof-of-stake based algorithm that uses the ownership of currency itself to achieve a scalable consensus protocol. It utilizes additional techniques (based on VRFs) to hide the committee members that take place in the consensus protocol. In contrast, miners in SPECTRE are not directly involved in any explicit consensus protocol and moreover can operate with little regard of other nodes' synchronization status. Honey Badger [12] is an atomic broadcast protocol that is oblivious to network parameters and does not require tuning under different network conditions (similarly to SPECTRE). It is set in the classical permissioned setting where identities of the participants are known.</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">7. CONCLUSION</h4>

    <p class="text-gray-300">In this work we presented SPECTRE, a new cryptocurrency protocol that is inherently scalable. Unlike Bitcoin and its many variants, SPECTRE is secure against attackers with less than 50% of the computational power, even when its throughput is increased and the propagation delay becomes non-negligible. Our results demonstrate that SPECTRE can achieve incredibly low confirmation times, especially compared to Nakamoto Consensus. Further work to improve and tighten the acceptance policy we derived can lower confirmation times further. Key to SPECTRE's achievements is its willingness to delay the decision regarding visibly double-spent transactions. It thus solves a weaker problem than traditional consensus protocols. This fact also makes it less suitable for systems like Ethereum, where a total order over transactions is required</p>

    <p class="text-gray-300">The core algorithm of SPECTRE &ndash; the pairwise voting procedure (Alg. 1) &ndash; is nontrivial. We encourage the reader to refer to Appendix A for intuition and illustrations about its operation.</p>

    <p class="text-gray-300"><sup>5</sup>We build on this argument, and indeed assume that nodes will maximize their profits by avoiding transaction &quot;collisions&quot; and will try to embed unique content in their blocks.</p>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">REFERENCES</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[1] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegelman. Solidus: An incentive-compatible cryptocurrency based on permissionless byzantine consensus. <em>arXiv preprint arXiv:1612.02916</em>, 2016.</li>
      <li>[2] Kenneth J Arrow, Amartya Sen, and Kotaro Suzumura. <em>Handbook of Social Choice &amp; Welfare</em>, volume 2. Elsevier, 2010.</li>
      <li>[3] Miguel Correia, Nuno Ferreira Neves, and Paulo Ver&acute;&#305;ssimo. From consensus to atomic broadcast: Time-free byzantine-resistant protocols without signatures. <em>The Computer Journal</em>, 49(1):82&ndash;96, 2006.</li>
      <li>[4] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In <em>Proceedings of the 17th International Conference on Distributed Computing and Networking</em>, page 13. ACM, 2016.</li>
      <li>[5] Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin network. In <em>13th IEEE International Conference on Peer-to-Peer Computing (P2P), Trento, Italy</em>, September 2013.</li>
      <li>[6] Ittay Eyal, Adem Efe Gencer, Emin Gun Sirer, and Robbert Van Renesse. Bitcoin-ng: A scalable blockchain &uml; protocol. In <em>13th USENIX Symposium on Networked Systems Design and Implementation (NSDI 16)</em>, pages 45&ndash;59, 2016.</li>
      <li>[7] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>, pages 281&ndash;310. Springer, 2015.</li>
      <li>[8] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. Cryptology ePrint Archive, Report 2016/545, 2016.</li>
      <li>[9] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. In <em>25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016.</em>, pages 279&ndash;296, 2016.</li>
      <li>[10] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain protocols. In <em>International Conference on Financial Cryptography and Data Security</em>, pages 528&ndash;547. Springer, 2015.</li>
      <li>[11] Silvio Micali. Algorand: the efficient and democratic ledger. <em>arXiv preprint arXiv:1607.01341</em>, 2016.</li>
      <li>[12] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of bft protocols. In <em>Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</em>, pages 31&ndash;42. ACM, 2016.</li>
      <li>[13] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</li>
      <li>[14] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. <em>IACR Cryptology ePrint Archive</em>, 2016:454, 2016.</li>
      <li>[15] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. <em>IACR Cryptology ePrint Archive</em>, 2016:454, 2016.</li>
      <li>[16] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permissionless model. Cryptology ePrint Archive, Report 2016/917, 2016.</li>
      <li>[17] Meni Rosenfeld. Analysis of hashrate-based double spending. <em>arXiv preprint arXiv:1402.2009</em>, 2014.</li>
      <li>[18] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In <em>International Conference on Financial Cryptography and Data Security</em>, pages 507&ndash;527. Springer, 2015.</li>
    </ul>

    <h2 id="sec-misc-7" class="text-2xl font-bold">APPENDIX A INTUITION AND EXAMPLES</h2>

    <p class="text-gray-300">In this section we provide some basic explanations and intuitions regarding the operation of SPECTRE. We focus primarily on explaining the ideas underlying Alg. 1 that is at the core of the protocol. We later go on to present examples for simple attacks that shed some light on how resilience is achieved.</p>

    <p class="text-gray-300">Intuition 1 (Vote in favour of visible blocks). If a block x is known by honest participants, their blocks will include it in their past. Given that blocks vote in favour of blocks in their past (over other unknown blocks), and given that honest nodes publish their blocks quickly, hidden attacker blocks lose votes.</p>

    <p class="text-gray-300">Intuition 2 (Majority amplification). Given blocks x, y that contain potential conflicts, blocks that are generated by honest participants after their publication reference both of them in the DAG. According to Alg. 1, these new blocks adopt the vote of the sub-DAG in their past with regards to x and y. Thus, if block x precedes block y, additional votes that support this decision are added, and the attacker will find it more difficult to reverse the vote.</p>

    <p class="text-gray-300">Intuition 3 (Referencing recent blocks is beneficial). Blocks from the past vote according to their future. Thus if an attacker creates a block that does not reference recent blocks, it is at a disadvantage compared to other blocks that do (it loses votes from recent blocks it did not reference and did not &quot;convince&quot;).</p>

    <p class="text-gray-300">Intuition 4 (Votes from the past counter pre-mining attacks). Consider an attacker that creates a block y, withholds it, and constructs many blocks on top of it over an extended period of time. After a long while, a conflicting transaction is released to the network, and eventually ends up in some block x. Block y has many blocks (built by the attacker) that reference it. Thus, if only votes from the future are counted, block y would prevail even if x is allowed to accumulate some votes. In SPECTRE, blocks that were created by honest nodes while y was withheld, look to their future for their votes. These will usually vote in favour of x and will usually outnumber the attacker blocks that were created when y was withheld (an example of pre-mining appears in Fig. 3).</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: SPECTRE coincides with the longest-chain rule when it is applied to &quot;simple&quot; chains of blocks. In the depicted DAG, the chain ending at block 8 is longer and would be selected in the longest chain protocol. In SPECTRE each one of the blocks 5,6,7,8 precedes each of the blocks in 9,10,11. Consider for instance blocks 6 and 10 and the pairwise vote that involves them. Blocks 6-8 vote strongly 6 &#8826; 10, as they see block 6 in their past but not block 10. Block 5 is a weak voter, as it sees neither 6 nor 10 in its past, hence it votes as the majority of its future (thus voting 6 &#8826; 10 as well). For similar reasons, blocks 9-11 all vote 10 &#8826; 6. Block 4, at the fork of the two chains, is a weak voters as well, as it sees neither 6 nor 10 in its past; it therefore votes according to the majority of future blocks. As block 4 sees four votes in favour of 6 &#8826; 10, and three votes in favour of 10 &#8826; 6, it will vote in favour of 6 &#8826; 10. Blocks 1-3 similarly vote according to their future, and see an increasing number of votes for 6 &#8826; 10, adding their own vote to the result. Thus, the end result is that 6 precedes 10.</p>

    <h2 id="sec-misc-8" class="text-2xl font-bold"><em>A. Equivalence to longest-chain</em></h2>

    <p class="text-gray-300">We now demonstrate how SPECTRE coincides with Bitcoin's longest-chain rule, in the case of a &quot;simple&quot; fork between two chains. Consider the DAG illustrated in Fig. 2. In Bitcoin, the longer chain would be selected. Similarly, in the pairwise ordering of SPECTRE, each of the blocks in the longest chain 5,6,7,8 would precede each of the blocks in the shorter one 9,10,11. To see why this is true refer to the caption of the figure.</p>

    <p class="text-gray-300">We now turn to examine two different attack scenarios, which we name <em>double-spending</em>, and <em>censorship</em>. Recall the requirement from our miner protocol: each miner is required to <em>(i)</em> reference recent blocks, and to <em>(ii)</em> publish his blocks immediately. Each attack is basically a violation of one of these requirements. In the double-spending attack, the attacker delays the publication of a set of blocks (that includes a conflicting transaction), and in the censorship attack he publishes blocks but &quot;ignores&quot; a certain block and transactions inside it, hoping to convince nodes that it did not secure enough votes, and thus cannot be accepted.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6"><em>B. Example of a double-spending attack</em></h4>

    <p class="text-gray-300">Fig. 3 depicts an (unsuccessful) double-spending attack. The attack is composed of three main phases:</p>

    <p class="text-gray-300">Phase I: Pre-mining. In phase I, the attacker begins building blocks and withholding them from the network. The first block that is constructed (named block y) contains a transaction that will later conflict with the transaction sent to the honest nodes. Blocks built by the attacker ideally</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: An example of the voting procedure on a DAG in which a double-spending attack is (unsuccessfully) attempted. Block x and blocks 6-8 vote strongly  <span class="math">x \\prec y</span>  as they only see x in their past, and not y. Similarly, block y and blocks 13-19 vote strongly  <span class="math">y \\prec x</span> . In the DAG which is the past of block 11, each of the blocks 1-5 sees more  <span class="math">x \\prec y</span>  voters in its future than  <span class="math">y \\prec x</span>  voters, hene each of them votes  <span class="math">x \\prec y</span> . Block 11 votes (as the virtual block of its past votes), according to the majority in its past, thus it too votes  <span class="math">x \\prec y</span> . A similar argument goes for the the vote of 11 and 12. Finally, aggregating the vote of all blocks in the DAG, x got more votes hence  <span class="math">x \\prec y</span> .</p>

    <p class="text-gray-300">form a chain, and due to the voting rules in SPECTRE, will all vote  <span class="math">y \\prec x</span>  (blocks y,13,14). Blocks built by the honest node are unaware of y (and also of x that is yet to be created), and will eventually vote according to the majority of future votes. During this phase, attacker blocks reference honest blocks that are built (in hopes of later convincing them to vote  <span class="math">y \\prec x</span> ). After some time, the attacker transmits the transaction to the network, and proceeds to phase II.</p>

    <p class="text-gray-300">Notice that at the exact time that phase I ends, the attacker has more blocks above block 4 than honest nodes have, so it starts at an advantage: it will more easily sway the vote of block 4 towards  <span class="math">y \\prec x</span>  (this advantage later disappears as honest nodes typically build blocks faster than the attacker).</p>

    <p class="text-gray-300"><strong>Phase II: Waiting for acceptance.</strong> The attacker now continues to build blocks in secret. If he publishes his blocks, then his conflicting transaction will be visible to all, and the double-spend will be detected. Instead, he waits for block x to receive sufficient weight (in the form of blocks built on top of it) so that the recipient of the transaction in x accepts it, and provides the attacker with some service or product. During this phase, attacker blocks that are created (blocks 15-17) vote  <span class="math">y \\prec x</span> , as the attacker is careful to have them reference only his secret chain, and never indirectly reference block x. Honest blocks created during this phase will typically vote  <span class="math">x \\prec y</span></p>

    <p class="text-gray-300">since y is hidden from them. Some small number of blocks (created before x propagated to the whole network &ndash; block 5 in this example) do not reference x, and so will vote according to the result of future votes.</p>

    <p class="text-gray-300">Phase III: Race to overtake. Once x was -accepted by the victim, the attacker wishes to publish his secret blocks in hopes of causing his conflicting transaction in y to precede x. In this case, the transaction in x will be considered rejected, and the payment will be canceled (leaving the attacker with an item he did not pay for). He publishes his secret chain (which from this point on is referenced by honest nodes), and continues to build upon it. Blocks that he builds, again do not reference x, and so they vote y &#8826; x, supporting his goal. New honest nodes are for the first time exposed to the conflicting transaction y, and thus vote according to the result in the sub-DAG in their past.</p>

    <p class="text-gray-300">Why the attack fails. First, notice that the attacker in the above example creates fewer blocks in each phase than the honest nodes. This will usually be the case if attackers have less computational power than all honest nodes. &quot;Poisson bursts&quot; in block creation by the attacker are possible, and this will allow him to overtake the network, but these are less likely if the attack lasts for a long period of time. The defender can control the length of phase II by waiting a long while before accepting the transaction, which decreases the probability of such bursts. If phase II is long enough, x will have more votes in this period than y. Weak blocks in the past of x will then vote in favour of x, according to this majority. Such blocks that look at their future begin a cascade: each block further in the past adds a vote that agrees with the majority of future blocks and thus strengthens the decision. The greater the majority obtained in Phase II, the less likely it is that the attacker will be able to catch up from behind in Phase III. The attack therefore depends heavily on successfully swaying the votes of blocks that were created just before x (e.g., block 4).</p>

    <p class="text-gray-300">It is important to note that an attacker that creates more blocks in expectation than the honest network will succeed in carrying out this attack. The blocks voting y &#8826; x would outnumber those who vote to the contrary. Hence the 50% threshold in Theorem 3.</p>

    <h2 id="sec-misc-10" class="text-2xl font-bold"><em>C. Example of a censorship attack</em></h2>

    <p class="text-gray-300">Fig. 4 depicts an (unsuccessful) censorship attack. The attack is composed of a single main phase during which an attacker creates his own blocks, publishes them instantly, but also ignores (and does not reference) recent blocks created by the honest network. The figure depicts (in stage I on the left side) the current state of the blockchain (where all blocks are published at this point). An honest participant that then observes the network and wishes to tell if a transaction in block x is secure, can see a large number of blocks that do not reference x. These blocks are not guaranteed to vote in favour of x. An attacker may later insert a conflicting transaction y and add blocks atop it (this projected attack is depicted on the right-hand side of the figure). These may potentially sway previously created attacker blocks to vote against x.</p>

    <p class="text-gray-300">The main risk from the censorship attack is that merchants, upon seeing the attacker's blocks, will consider transactions in block x not sufficiently secure. This could potentially delay the</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4: An example of the voting procedure on DAG in which an unsuccessful censorship attack is depicted. The left side depicts the current state of the block DAG. The right-hand side depicts its likely future development. Blocks 12-16 do not add strong votes to x. Can they be convinced to vote for block y when it appears? Will they further sway other blocks in their past? The vote of each block in this projected future are depicted: Blocks 2-9 vote strongly for x as they see it in their past (but not y). Blocks 17-18 similarly vote strongly for y. Block 16 is indeed convinced to vote for y as more blocks in its future vote for y than for x. Blocks 1, 12-15 vote for x. They each see more votes in favour of x than votes in favour of y in their future. Blocks 10-11 see more  <span class="math">x \\prec y</span>  voters in their past when they make a recursive call.</p>

    <p class="text-gray-300">acceptance of transactions forever. Our analysis of SPECTRE shows that even in this case the merchants accept transactions quickly (and securely).</p>

    <p class="text-gray-300">We implemented the SPECTRE protocol in Python along with an event-driven simulator of network dynamics. For each experiment we generated an Erd&#337;s-R&eacute;nyi random network topology with 20 nodes. Each node forms 5 outgoing links, in expectation. The delay on each link was uniformly distributed and later scaled linearly so that the diameter of the graph is D (for the given D). Every point represents the average outcome over at least 500 experiments.</p>

    <p class="text-gray-300">The main benefit of SPECTRE is fast transaction confirmation. The asymptotic waiting times derived from our formal analysis are in  <span class="math">\\mathcal{O}\\left(\\frac{\\ln(1/\\epsilon)}{\\lambda(1-2\\alpha)} + \\frac{D}{1-2\\alpha}\\right)</span> . In order to measure the actual waiting times, we utilized the online acceptance policy derived by Alg. 7. Accordingly, we stress that the merchant needs to wait additional D seconds in order to verify that no double-spend has been released in the past D seconds, as explained at the end of Appendix C.</p>

    <p class="text-gray-300">How does the delay diameter affect acceptance times? Given that block creation rate is high, most of the waiting time for acceptance is dominated by the block propagation delay. Fig. 5 depicts the transaction acceptance times of SPECTRE, for various values of the delay diameter D, and for different security thresholds . Note that, unlike the Nakamoto Consensus, D affects the acceptance time of transactions but not their security.</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5: The average time for a transaction to enter RobustT xO, assuming there's no visible double-spend, for &lambda; = 10 blocks per second and &alpha; = 0.25.</p>

    <p class="text-gray-300">How does the block creation rate affect acceptance times? Fig. 6 depicts the acceptance times for various values of the block creation rate &lambda;, under a constant delay d = 5 seconds. The graph reaffirms the role of &lambda; in our asymptotic bound: accelerating the block creation process allows for faster acceptance times. For comparison, Bitcoin's block creation rate of 1/600 implies waiting times that are orders of magnitudes higher (not plotted).</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6: The average time for a transaction to enter RobustTxO, assuming there's no visible double-spend, for d=5 seconds and  <span class="math">\\alpha=0.25</span> .</p>

    <p class="text-gray-300">Can an attacker delay acceptance? We now turn to demonstrate the effect of censorship attacks in which some dishonest nodes publish blocks that do not reference other miners' blocks. Recall that the Weak Liveness property of SPECTRE (Proposition 3) guarantees fast acceptance of transactions that are not visibly double-spent, even in the presence of a censorship attack. However, such an attack still causes some delay in transaction acceptance, but this delay is minor for small attackers. In Fig. 7 we quantify this effect, by comparing the acceptance times in &quot;peace days&quot; to those under an active censorship attack. The parameters here are d=5 seconds,  <span class="math">\\lambda=10</span>  blocks per second, and  <span class="math">\\epsilon=0.01</span> . The results display a modest effect of the attack, and they show that in order to delay transaction acceptance by more than 5 to 10 seconds an attacker must possess a significant share of the computational power in the network.</p>

    <p class="text-gray-300">    <img src="_page_20_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7: The average time for a transaction to enter RobustTxO, assuming there's no visible double-spend, for d=5 seconds,  <span class="math">\\lambda=10</span>  blocks per second, and  <span class="math">\\epsilon=0.01</span> , in the presence and in the absence of a censorship attack.</p>

    <p class="text-gray-300">How does  <span class="math">\\epsilon</span>  decrease for various sizes of the attacker? Once an honest node  <span class="math">\\epsilon</span> -accepts a transaction, there's still a small risk  <span class="math">(\\epsilon)</span>  that it would eventually be rejected. We show that the probability of this event vanishes quickly, even for an extremely capable attacker (e.g., with  <span class="math">\\alpha=0.4</span>  of the hashrate). This is illustrated in Fig. 8, assuming d=5 seconds and  <span class="math">\\lambda=10</span>  blocks per second (notice that the y-axis is in log scale).</p>

    <p class="text-gray-300">How tight is our security analysis? The analysis on which Alg. 3 relies makes several worst-case assumptions in order to bound the probability of a successful attack, e.g., that the attacker can broadcast blocks to and receive blocks from all nodes without any delay (see Appendix E, mainly Lemmas 14 and 20). Accordingly, the analysis is not tight, and in reality attacks are in fact less likely to succeed. In Fig. 9, we depict the comparison between the analytical bound and two different empirical simulations. In these simulations we explicitly generate blocks for the attacker and simulate the optimal double-spending attack. We repeat the experiment 10,000 times for each point in the graph, and measure the empirical success rate. The simulations assume two types of attackers: a worst-case attacker that is able to transmit and receive blocks with no delays, and a more realistic attacker that is connected to other nodes with typical delays. We compared the fraction of successful attacks under these setups to the analytical risk calculated by SPECTRE's policy (Alg. 7).</p>

    <p class="text-gray-300">The results show that the risk considered by SPECTRE's RiskTxAccept indeed upper bounds the actual risk, and that transactions are even safer than we guarantee formally.</p>

    <p class="text-gray-300">    <img src="_page_21_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8: The probability of a successful double-spending attack, as a function of the waiting time before acceptance, under d = 5 seconds and &lambda; = 10 blocks per second, for &alpha; = 0.1, 0.25, and 0.4. The probability here is the result of the calculation performed by Alg.3.</p>

    <p class="text-gray-300">    <img src="_page_21_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 9: The analytical vs. empirical probabilities of a successful double-spending attack, as a function of the waiting time before acceptance, under d = 5 seconds, &lambda; = 10, and &alpha; = 0.25.</p>

    <h2 id="sec-misc-11" class="text-2xl font-bold">APPENDIX C ADDITIONAL ALGORITHMS</h2>

    <p class="text-gray-300">In Sec. 4 we described the way SPECTRE pairwise orders blocks, and how this order is used to construct the subset of accepted transactions. In this section we describe the procedures of the second layer of SPECTRE, which allows users to measure the robustness of this order, and to translate this into the robustness of accepted transactions.</p>

    <h2 id="sec-misc-12" class="text-2xl font-bold">A. Robustness of the block pairwise ordering</h2>

    <p class="text-gray-300">Assume that in the order of the current observable DAG the block x precedes y. We need a method to measure how likely is it that this relation will persist forever. Algorithm 3 outputs an upper bound on the probability that an attacker will be able to reverse the relation  <span class="math">x \\prec y</span> . When the argument y is unspecified, the interpretation of the algorithm's output is x's robustness against an unseen block (withheld by an attacker or yet to be created). In the algorithm, gap(b,G) denotes the size of the set  <span class="math">\\{z \\in anticone(b,G) : vote_{z,b}(virtual(G)) \\geq 0\\}</span> . The notation  <span class="math">\\langle G, z, K \\rangle</span>  will be explained in the paragraphs that follow.</p>

    <p class="text-gray-300">In the algorithms below, we omit for the sake of brevity the following parameters which the user must set by himself:  <span class="math">\\alpha</span>  &ndash; maximal size of attacker, d &ndash; upper bound on D (the recent delay diameter in the network),  <span class="math">\\lambda</span>  &ndash; the block creation rate</p>

    <h2 id="sec-misc-13" class="text-2xl font-bold">Algorithm 3 Risk (offline)</h2>

    <pre><code class="language-text">Input: G = G^v_{time\\_now} &ndash; some node v&#x27;s current block DAG, x &ndash; a block in G, y (optional) &ndash; a block in anticone(x,G)
</code></pre>

    <p class="text-gray-300"><strong>Output:</strong> risk &ndash; an upper bound on the probability that x will not recede y in some point in the future  <span class="math">(\\Pr(\\exists u \\in honest, \\exists s \\geq time\\_now : vote_{x,y}(virtual(G_s^u)) \\geq 0))</span></p>

    <pre><code class="language-text">1: if time\\_now &lt; publication(x) + 2 \\cdot d then

2: return 1

3: K \\leftarrow \\lceil \\sqrt{|future(x,G)|} \\rceil

4: if NULL = y then

5: g \\leftarrow |future(x,G)|

6: M \\leftarrow 0

7: else

8: g \\leftarrow \\sum_{z&#x27; \\in future(x,G)} vote_{y,x}(z&#x27;,G)

9: M \\leftarrow \\left| \\left\\{ z \\in future(x,G) : vote_{x,y}(z,G) = +1 \\land gap(z,\\langle G,z,K\\rangle) = 0 \\right\\} \\right|

10: n_x \\leftarrow |future(x,G)| - M

11: j \\leftarrow gap(x,G) + K

12: l \\leftarrow K

13: risk \\leftarrow f_{pre\\_mine}(l) + f_{pre\\_pub}(K) + f_{post\\_pub}(M) + f_{post\\_mine}(n_x,g,j,l,M)

14: return risk
</code></pre>

    <p class="text-gray-300">In line 13 the algorithm uses several functions whose precise definitions we defer to later sections. An explicit formula for  <span class="math">f_{pre\\_pub}</span>  is given in (54), for  <span class="math">f_{post\\_pub}</span>  is given in (50) and (52), and for  <span class="math">f_{post\\_mine}</span>  is given in (5). Preceding Lemma 24, we provide a method to calculate  <span class="math">f_{pre\\_mine}</span>  numerically.</p>

    <p class="text-gray-300">Intuitively, the function  <span class="math">f_{pre\\_mine}</span>  upper bounds the probability that the attacker has gained an advantage larger than l during the pre-mining phase (i.e., up until the creation of x). The function  <span class="math">f_{post\\_mine}</span>  upper bounds the probability that the attacker will ever be able to create enough blocks so as to reverse the relation  <span class="math">x \\prec y</span> . In essence,  <span class="math">f_{post\\_mine}</span>  is an adaptation of a formula from [17]. According to our version of the formula, if during the interval  <span class="math">[time(x), t_{acc}]</span>  (where  <span class="math">t_{acc}</span>  represents the current time) honest nodes created n blocks, then  <span class="math">\\binom{n-1+m}{m} \\cdot \\alpha^m \\cdot (1-\\alpha)^n</span>  is the probability that the attacker has created during this interval m blocks. If g aggregates all the votes of blocks in future(x,G), then the probability that the attacker will be able to reverse the majority's vote is roughly  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{\\max\\{g-m,0\\}}</span> . The combined expressions produce an upper bound on the success-probability of an attack.</p>

    <p class="text-gray-300">The main challenge here is to correctly measure n. This is a difficult task, as Algorithm 3 uses only structural information (with the exception of making sure that x has been published for at least  <span class="math">2 \\cdot d</span>  seconds) and does not rely on measurements of blocks' timings. Na&iuml;vely one would use  <span class="math">n \\approx |future(x,G)|</span>  to upper bound blocks created after publication(x). However, there are two main difficulties:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>The block x might have been created by a dishonest node and withheld by it. In this case, there might have passed a long time between its creation and its publication, which implies that |future(x,G)| alone may be well below n. To avoid underestimating n, we upper bound the number of honest blocks in anticone(x,G), by the variable j, and add it to our count (the addition is done inside  <span class="math">f_{post\\_mine}(n_x,g,j,l,M)</span> ).    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>The function  <span class="math">f_{pre\\_pub}</span>  upper bounds the probability that we have underestimated j.</li>
    </ul></li>
      <li>By publishing his attack blocks, the attacker can increase the size of future(x,G) and cause us to overestimate n. This would result in an upper bound on the success-probability of an attack that is not tight enough, which would allow an attacker with a large value of  <span class="math">\\alpha</span>  to delay acceptance indefinitely. Risk overcomes this problem, by recognizing attacker blocks and excluding them from the count of n. This is done as follows.    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Let G be a block DAG, b a block in G, and K a whole number. The DAG  <span class="math">\\langle G, b, K \\rangle</span>  is obtained by creating a new chain  <span class="math">z_1, ..., z_K</span>  of K hypothetical blocks, connecting an edge from  <span class="math">z_1</span>  to b and replacing every edge  <span class="math">(z,b) \\in G</span>  with  <span class="math">(z,z_K) \\in G</span> . Essentially, this adds to the DAG K artificial voters which vote strongly  <span class="math">x \\prec y</span> , against any  <span class="math">y \\notin past(x,G)</span> . In line 9, the algorithm checks whether  <span class="math">gap(z,\\langle G,z,K\\rangle)=0</span> , i.e., whether there exists a block in anticone(z) that precedes z in the modified DAG  <span class="math">\\langle G,z,K\\rangle</span> . In the case of a negative answer, z is counted into n (in line 10).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The following property explains why this procedure is useful: If we add K voters in favour of an honest block, for some small K, then no other block will precede it in the pairwise ordering (apart from its past set). This is restated formally and proven in Lemma 29.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>The calculations we use are quite more involved, as will be detailed later on. The reason why we aggregate in g votes from future(x,G) alone &ndash; rather than votes from the entire DAG &ndash; was discussed in Sec. 5. Essentially, observe that counting all votes &ndash; including votes of blocks in past(x) &ndash; is not meaningful, as such voters might reverse their vote as future events unfold. Rather, it is useful to measure how robustly voters in past(x) support  <span class="math">x \\prec y</span> , which is captured by our calculations.</p>

    <p class="text-gray-300">The function fpost pub upper bounds the probability that we have underestimated the number of honest blocks in future (x, G).</p>

    <h2 id="sec-misc-14" class="text-2xl font-bold"><em>B. Robustness of transaction acceptance</em></h2>

    <p class="text-gray-300">The next step is to translate robustness of blocks (calculated by Risk) to robustness of transactions. This transition is implemented similarly to the transition from the (non-robust) ordering of blocks (Alg. 1) to the (non-robust) accepted set of transactions (Alg. 2).</p>

    <p class="text-gray-300">The RiskT xAccept procedure (Alg. 4) takes as input G and tx (and an additional argument) and returns an upper bound on the probability that some honest node will not -accept tx. The main task of RiskT xAccept is to properly account and aggregate the error bounds that Risk induces. As can be easily recognized, RiskT xAccept and RiskT xReject (Alg. 5) are mirror images of each other. While RiskT xAccept upper bounds the probability that a given transaction will ever be <em>removed</em> from the accepted transaction subset, RiskT xReject upper bounds the probability that a given transaction will ever be <em>included</em> in this subset. This is particularly vital for the case where two conflicting transactions are related topologically, i.e., tx<sup>2</sup> &isin; y and tx<sup>1</sup> &isin; x &isin; future (y), but tx<sup>2</sup> is not in the accepted set (due to some previous conflict). In this case, although the block containing tx<sup>2</sup> precedes that containing tx1, we accept tx1. It can be further -accepted if the rejection-status of tx<sup>2</sup> is robust, as calculated by RiskT xReject.</p>

    <h2 id="sec-misc-15" class="text-2xl font-bold">Algorithm 4 RiskT xAccept</h2>

    <pre><code class="language-text">Input: G = Gv
            time now &ndash; a block DAG,
Output: risk &ndash; an upper bound on the probability that some honest node
   in some future point in time will accept no transaction in [tx] &cap; subG
   (Pr (&exist;u &isin; honest, &exist;s &ge; time now, [tx] &cap; subG &cap; RobustT xOGu
                                                          s = &empty;))
 1: minrisk &larr; 1
 2: for all z1 &isin; ZG([tx]) &cap; subG do
 3: risk &larr; Risk (G, z1, &empty;)
 4: for all tx2 &isin; G &cap; conflict(tx) do
 5: for all z2 &isin; ZG(tx2) &cap; anticone (z1, G) do
 6: risk &larr; risk + Risk (G, z1, z2)
 7: risk &larr; risk + RiskT xReject(G, [tx2], past(z1))
 8: for all [tx3] &isin; inputs (tx) &cap; past(z1) do
 9: risk &larr; risk + RiskT xAccept(G, [tx3], past(z1))
10: minrisk &larr; min {minrisk, risk}
11: risk &larr; minrisk
12: return risk
</code></pre>

    <p class="text-gray-300">Building on these procedures, we now present the RobustT xO procedure of SPECTRE. The user should provide as input the entire DAG that he currently observes G, and the maximal error probability he is willing to tolerate . As mentioned above, the user should also set the &alpha;, d, &lambda; parameters; these will be used in the auxiliary proceudres of RobustT xO described above.</p>

    <h4 id="sec-misc-16" class="text-lg font-semibold mt-6">Algorithm 5 RiskT xReject</h4>

    <p class="text-gray-300">Input: G &ndash; a block DAG, subG &ndash; a subDAG of G which is the past of a (possibly virtual) block, tx &ndash; a copy of the transaction to defend</p>

    <p class="text-gray-300">Output: risk &ndash; an upper bound on the probability that some honest node in some future point in time will accept a transaction in [tx] &cap; subG.</p>

    <pre><code class="language-text">1: risk &larr; 0
2: for all z1 &isin; ZG([tx]) &cap; subG do
3: minrisk &larr; 1
4: for all tx2 &isin; G &cap; conflict(tx) do
5: for all z2 &isin; ZG(tx2) &cap; anticone (z, G) do
6: minrisk &larr; min {minrisk, Risk (G, z2, z1)}
7: minrisk &larr; min {minrisk, RiskT xAccept(G, [tx2], past(z1))}
8: for all [tx3] &isin; inputs (tx) do
9: minrisk &larr; min {minrisk, RiskT xReject(G, [tx3], past(z1))}
10: risk &larr; risk + minrisk
11: return risk
</code></pre>

    <h2 id="sec-misc-17" class="text-2xl font-bold">Algorithm 6 RobustT xO</h2>

    <p class="text-gray-300">Input: G = G<sup>v</sup> time now &ndash; a block DAG representing the current DAG observed by the node running the algorithm, &ndash; the maximum risk the user is willing to tolerate, &alpha; &ndash; maximal size of attacker, d &ndash; upper bound on network's delay diameter, &lambda; &ndash; the block creation rate</p>

    <p class="text-gray-300">Output: a set of transactions that are guaranteed to remain accepted, as defined by Property 2</p>

    <pre><code class="language-text">1: RobustT x &larr; &empty;
2: for all z &isin; G do
3: for all tx &isin; z do
4: if RiskT xAccept(G, [tx] &cap; G) &lt;  then
5: add tx to RobustT x
</code></pre>

    <h4 id="sec-misc-18" class="text-lg font-semibold mt-6"><em>C. Online policy</em></h4>

    <p class="text-gray-300">We now present an alternative implementation of Risk, which requires that the user be online at the time when his block gains confirmations. This assumption is highly reasonable for many practical scenarios, e.g., a cashier serving a continuous line of customers. The main benefit of the online version is that it relies on a tighter analysis, and therefore accepts transactions slightly faster. We now confine ourselves to the case where there is no visible double-spend (i.e., y = NULL).</p>

    <p class="text-gray-300">The fact that the user is online can be utilized in two ways: First, any block that the user receives after received<sup>v</sup> (b) + 2 &middot; d and does not belong to future (x) can be marked by him as an attacker block.<sup>7</sup> Second, the user can estimate the number of hidden attacker blocks by</p>

    <p class="text-gray-300"><sup>7</sup> received<sup>v</sup> b is the time at which node v received node b. Below, for all r, G pub <sup>r</sup> is defined G pub <sup>r</sup> := &cup;u&isin;N G u r .</p>

    <p class="text-gray-300">measuring the time that passed since the creation of x.</p>

    <p class="text-gray-300">Below we describe the online version of Risk. The algorithm takes as input node v's DAG and the block x to defend, and returns an upper bound on the probability that some block  <span class="math">y \\in G^{pub}_{\\infty} \\setminus G^{pub}_t</span>  will ever precede it.</p>

    <h4 id="sec-misc-19" class="text-lg font-semibold mt-6"><strong>Algorithm 7</strong> Risk (online)</h4>

    <pre><code class="language-text">Input: G_t^v &ndash; the block DAG that v observes at time t, x &ndash; a block in G_t^v
Output: risk &ndash; an upper bound on the probability of block x not preceding y at any point in
    the future, for some y \\in G^{pub}_{\\infty} \\setminus G^{pub}_t
 1: if time\\_now &lt; publication(x) + d then
         return 1
 3: T \\leftarrow time\\_now - received^v(x)
 4: G_x \\leftarrow G_{received^v(x)+2\\cdot d}^v \\cup future(x, G_x)
 5: g \\leftarrow \\min_{x&#x27; \\in \\overline{anticone}(x,G_x)} |future(x&#x27;,G_x)|
 6: risk \\leftarrow risk\\_hidden(T, g)
 7: if risk &lt; \\epsilon then
         return ACCEPT
 8:
 9: else
         return WAIT
10:
</code></pre>

    <p class="text-gray-300">The definition of  <span class="math">risk\\_hidden</span>  appears in (45)-(46). In practice, as node v may have a partial view of  <span class="math">G^{pub}_{\\infty} \\setminus G^{pub}_t</span> , in order to use Alg. 7 the user must wait additional d seconds and verify that  <span class="math">conflict(tx) \\cap G_{t+d}^v = \\emptyset</span> , i.e., that the attacker did not publish a double-spend in the interval [t-d,t]. The correctness of the online policy modification is proven in Corollary 27.</p>

    <h2 id="sec-misc-20" class="text-2xl font-bold">APPENDIX D IMPLEMENTATION DETAILS</h2>

    <p class="text-gray-300"><strong>Minting.</strong> In SPECTRE, any block whose target meets the required value TARGET &ndash; as will be defined below &ndash; receives the same minting reward. If its target is higher than TARGET (i.e., it is solved with an easier difficulty) by a factor of  <span class="math">(1+\\delta)</span>  at most, then its reward is reduced by the same factor. The parameter  <span class="math">\\delta</span>  represents the protocol's tolerance to blocks mined with an outdated difficulty. Thus, if for instance  <span class="math">\\delta</span>  is chosen to equal 2, then blocks with a target value of  <span class="math">2 \\cdot TARGET</span>  or  <span class="math">3 \\cdot TARGET</span>  are valid, and their minting rewards are reduced by a factor of 2 or 3, respectively; blocks with a target higher than  <span class="math">3 \\cdot TARGET</span>  are invalid and discarded. We now explain how TARGET is defined and readjusted.</p>

    <p class="text-gray-300"><strong>Retargeting.</strong> Similarly to Bitcoin and other PoW-based systems, the difficulty of block creation, represented by TARGET (Subsection 4.1), must be occasionally adapted. Varying network conditions, and changes in the amount of computational resources invested in the system, require we limit the number of blocks created per second, to avoid network congestion. In Bitcoin this is done as follows: Every 2016 blocks, the next block &ndash; which we call the reference block &ndash; is mined according to an adjusted difficulty. The new difficulty is obtained by taking the time that elapsed since the previous reference block (using the timestamps written inside each block) and plugging it into the retargeting formula. The output of this formula is the new value of TARGET that the new reference block should be mined with.</p>

    <p class="text-gray-300">We adapt this scheme to SPECTRE: Let  <span class="math">x_{n-1}</span>  be the previous reference block. Every new block  <span class="math">x_n</span>  that has the property that  <span class="math">|past(x_n) \\cap \\overline{future}(x_{n-1})| = 2016</span> , is a candidate to become the new reference block. In case additional candidates exist, we choose the one with the minimal  <span class="math">dist\\_gap</span> , with some arbitrary tie-breaking, where  <span class="math">dist\\_gap(b,G) := \\min_{K \\in \\mathbb{N}} gap(b, \\langle G, b, K \\rangle) = 0</span> . The variable  <span class="math">dist\\_gap(b,G)</span>  represents the minimal K such that adding K votes in favour of b makes its gap equal zero. This guarantees that among a set of candidates to become  <span class="math">x_n</span>  (satisfying the above property) one and only block would be chosen as the reference block succeeding  <span class="math">x_{n-1}</span> . In particular, as explained in Appendix A, an attacker block that was withheld for a while will have a large  <span class="math">dist\\_gap</span>  and will not be eligible as a reference block. Furthermore, an attacker block that was mined before  <span class="math">x_{n-1}</span>  will not affect the next retargeting, as it cannot belong to  <span class="math">future(x_{n-1})</span> .</p>

    <p class="text-gray-300">The new difficulty, with which the new reference block should be mined, is given again through the formula that uses the time that elapsed between  <span class="math">x_{n-1}</span>  and  <span class="math">x_n</span>  to update TARGET. The formula should aim for a predefined  <span class="math">\\lambda</span>  for which nodes are believed to have sufficient bandwidth, e.g., 1 MB per second. This difficulty dictates the difficulty for every block in  <span class="math">antipast(x_n) \\setminus \\overline{anticone}(x_{n+1})</span> , where  <span class="math">x_{n+1}</span>  is the next reference block. Every block in this set should be mined according to the same difficulty as  <span class="math">x_n</span> .</p>

    <p class="text-gray-300">If block  <span class="math">b \\in antipast(x_n) \\setminus \\overline{anticone}(x_{n+1})</span>  was solved with an easier difficulty than that dictated by the reference block  <span class="math">x_n</span> , then b is still considered valid, provided that its outdated target is at most  <span class="math">(1+\\delta)</span>  of the target of  <span class="math">x_n</span>  (i.e., a difficulty easier by at most  <span class="math">(1+\\delta)</span> ). The parameter  <span class="math">\\delta</span>  is the protocol's tolerance threshold. The minting reward of b is reduced by the corresponding factor, as explained above. Blocks whose target exceeds the required one by a factor higher of  <span class="math">(1+\\delta)</span>  are ignored and discarded.</p>

    <p class="text-gray-300"><strong>Block headers.</strong> In order to incorporate all blocks into the DAG, every block embeds in its header pointers to the hash of previous blocks. No redundancies are permitted, hence only leaf-blocks of past(b) should be pointed at by the header of b. The implication of this is that a block's header is of size  <span class="math">\\approx 50 + d \\cdot \\lambda \\cdot 32</span>  Byte. Therefore, there is a limit to the extent at which block size could be reduced and block creation rates increased &ndash; at extremely high rates, the overhead of the block header becomes significant relative to the number of included transactions. We note, additionally, that in case the current observable DAG has too many leaves (whether by a rare burst in block creations or by an attacker releasing many outdated blocks), the next block creator can cap the number of leaf-blocks it points at. Blocks left out by this block will later integrate into the DAG, as future blocks will have available space in their headers and will be able to point at these blocks and include them.</p>

    <p class="text-gray-300"><strong>Efficient implementation.</strong> Our current implementation of SPECTRE uses na&iuml;ve calculations which are usually inefficient, specifically, cascading the votes all the way to the <em>genesis</em></p>

    <p class="text-gray-300"><sup>8</sup> Some new notation is used in these paragraphs:  <span class="math">\\overline{future}\\,(x) := future\\,(x) \\cup \\{x\\}</span> , and similarly for  <span class="math">\\overline{past}\\,(x)</span>  and  <span class="math">\\overline{anticone}\\,(x)</span> . In addition,  <span class="math">antipast\\,(x) = future\\,(x) \\cup anticone\\,(x)</span> , and similarly for  <span class="math">antifuture\\,(x)</span> .</p>

    <p class="text-gray-300">block. Several efficient implementations are possible. Designing such an efficient implementation requires attention to CPU attacks, in which the attacker exposes peculiar structures of outdated blocks in order to cause other nodes to perform extensive computation. It can be shown that these attacks are highly costly to the attacker. We have an implementation of SPECTRE's procedures that works in O(d &middot; &lambda;) in expectation, compared to the na&uml;&#305;ve implementation with O(|G| 3 ). We leave its full specification, and a proof of the cost of CPU attacks on it, to future work.</p>

    <p class="text-gray-300">Transaction fees. The body of a transaction specifies the amount transferred from the payer to the payee. The transaction-fee specifies the payment from the payer to the miner whose block contains the transaction. We regard these two parts as separate transactions, in the following sense. Assume that tx &isin; x, and denote by fee(tx, x) the transaction representing the fee-payment of tx to the creator of block x. Assume now that two copies of tx appear in two different blocks x, y. Then the body is considered simply as a copy of the same transaction (recall the notation [tx] from Sec. 2), whereas the transactions fee(tx, x) and fee(tx, y) are considered a conflict, i.e., a double-spend. Accordingly, as in the ordinary scheme of SPECTRE, the fee is granted to (the creator of) block x iff tx &isin; T xO(G) and x defeats all other blocks that contain tx as well.</p>

    <p class="text-gray-300">This rule can potentially harm miners, in the special case when the relation between x and y does not become robust (SPECTRE does not guarantee robustness if these blocks were published in time proximity and an active attack is taking place). We address this problem by introducing <em>settlement transactions</em>. A settlement transaction is a voluntary transaction which both the creators of x and y sign after they observe that their blocks conflict. We denote it settlement(x, y). The interpretation of settlement(x, y) is that the fees from all of (or part of, if the parties involved so choose) the transactions in x&cap;y should be divided evenly between blocks x and y. settlement(x, y) essentially overrides fee(tx, x) and fee(tx, y). When settlement(x, y) appears in some block z in the DAG G, it is considered accepted (i.e., a member of T xO(G)) iff x, y &isin; past(z) and z precedes every block that contains a transaction <em>spending</em> fee(tx, x) or fee(tx, y). Therefore, once one party has spent its fee before it belonged to it robustly, it won't be able to settle later (w.h.p.). Miners are therefore advised to wait for their transaction-fee rewards to become robust, or to initiate a settlement, before spending these rewards.</p>

    <p class="text-gray-300">Note that this scheme can be used to settle conflicts between blocks of multiple parties simultaneously. Furthermore, the settlement scheme need not be confined to conflicts regarding fees, and can be applied to any double-spend.</p>

    <h2 id="sec-misc-21" class="text-2xl font-bold">APPENDIX E THE COMPLETE PROOF OF THEOREM 3</h2>

    <p class="text-gray-300">Theorem 3. <em>For any</em> D &middot; &lambda;<em>, SPECTRE's security threshold is 50%.</em></p>

    <h2 id="sec-misc-22" class="text-2xl font-bold"><em>A. Additional notation</em></h2>

    <p class="text-gray-300">&bull; While honest was defined as the set of honest nodes (Section 2), we here abuse notation and use it also to denote the of blocks created by honest nodes. The context will make our use of honest unambiguous.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">G_t^{oracle} := \\bigcup_{v \\in \\mathcal{N}} G_t^v</span> ; this is the DAG as observed by a hypothetical oracle node. Similarly,  <span class="math">G_t^{pub} := \\bigcup_{v \\in honest} G_t^v</span> ; this is the DAG as observed by a hypothetical node that has 0 delay from and to honest nodes.</li>
      <li><span class="math">node(b) \\in \\mathcal{N}</span>  the node that created block b, time(b) the time of its creation, publication(b) the time at which node(b) begun the transmission of b to some other honest node,  <span class="math">received^v(b)</span>  the time at which node v received b.</li>
      <li><span class="math">\\overline{future}(x) := future(x) \\cup \\{x\\}</span> , and similarly for  <span class="math">\\overline{past}(x)</span>  and  <span class="math">\\overline{anticone}(x)</span> . In addition,  <span class="math">antipast(x) = future(x) \\cup anticone(x)</span> , and similarly for antifuture(x)</li>
      <li><span class="math">\\widehat{\\mathcal{E}}_{s}^{u}(x,y) := \\text{the event where } vote_{y,x}\\left(virtual\\left(G_{s}^{u}\\right)\\right) = +1.</span></li>
      <li><span class="math">\\mathcal{E}^u_s(x,y,\\epsilon) :=</span>  the event where  <span class="math">Risk(G^u_s,x,y) &lt; \\epsilon</span> .</li>
      <li><span class="math">\\mathcal{A}^u_s(tx) := \\text{the event where } tx \\in TxO(G^u_s).</span></li>
      <li><span class="math">\\mathcal{A}_t^u(tx,\\epsilon) := \\text{the event where } TxO \\in RobustTxO(G_t^u,\\epsilon).</span></li>
      <li><span class="math">\\mathcal{E}^{all}_{t\\to\\infty}(x,y,\\epsilon) :=</span>  the event  <span class="math">\\cap_{u\\in honest} \\cap_{s\\in(t,\\infty)} \\mathcal{E}^u_s(x,y,\\epsilon)</span> , and similarly for  <span class="math">\\widehat{\\mathcal{E}}^{all}_{t\\to\\infty}(x,y)</span> ,  <span class="math">\\mathcal{A}^{all}_{t\\to\\infty}(tx,\\epsilon)</span> , and  <span class="math">\\widehat{\\mathcal{A}}^{all}_{t\\to\\infty}(tx)</span> .</li>
      <li><span class="math">past_h(z,G) := past(z,G) \\cap honest</span> , and similarly for the future and anticone sets.</li>
      <li><span class="math">V_{x \\prec y}(G) := \\{z \\in G | z \\text{ is a strong voter w.r.t. } (x,y) \\text{ and } vote_{x,y}(z) = -1\\}</span>   <span class="math">(V_{x \\prec y}(G) \\text{ depends on } x,y).</span></li>
      <li><span class="math">\\mathcal{P}_{oiss}(\\delta,j) := e^{-\\delta} \\cdot \\frac{\\delta^j}{i!}</span> .</li>
      <li><span class="math">\\bullet</span>  If  <span class="math">{\\mathcal E}</span>  is a set or an event, its complement set or event is denoted  <span class="math">{\\mathcal E}^\\complement</span> .</li>
      <li>If x is a real number,  <span class="math">x^+</span>  is defined by  <span class="math">\\max\\{0, x\\}</span> .</li>
    </ul>

    <h4 id="sec-misc-23" class="text-lg font-semibold mt-6">B. Formal claims</h4>

    <p class="text-gray-300">We now take apart Theorem 3 and write a separate proposition for each of the security properties Safety, Progress, and Weak Liveness, and for Consistency. In order to prove Theorem 3, we need to prove the following propositions:</p>

    <p class="text-gray-300"><strong>Proposition 4</strong> (Consistency). The accepted set is consistent: For any history G,</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>if  <span class="math">tx \\in TxO(G)</span>  and  <span class="math">tx_2 \\in inputs(tx)</span>  then  <span class="math">tx_2 \\in TxO(G)</span> .</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>if  <span class="math">tx \\in TxO(G)</span>  and  <span class="math">tx_2 \\in conflict(tx)</span>  then  <span class="math">tx_2 \\notin TxO(G)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><strong>Proposition 5</strong> (Safety). For any  <span class="math">v \\in honest</span>  and time t, if  <span class="math">tx \\in RobustTxO\\left(\\epsilon, G_t^v, d^v, \\alpha\\right)</span>  then, with probability of at least  <span class="math">1 - \\epsilon</span> , there exists a  <span class="math">\\tau \\geq t</span>  such that  <span class="math">\\forall u \\in honest, \\forall s \\geq \\tau</span> :  <span class="math">RiskTxAccept\\left(tx, G_s^u, d^u, \\alpha\\right) &lt; \\epsilon</span> , and the expectation of  <span class="math">\\tau - t</span>  is finite.</p>

    <p class="text-gray-300"><strong>Proposition 6</strong> (Weak Liveness). Let t be the current time, and assume that  <span class="math">tx \\in G_t^{pub}</span> . Let  <span class="math">\\psi \\geq t</span>  be the earliest time after t at which an honest node  <span class="math">\\epsilon</span> -accepts tx. Then, conditioned on the event where  <span class="math">conflict(tx) \\cap G_{\\psi}^{pub} = \\emptyset</span>  and on the event where for all  <span class="math">tx_2 \\in inputs(tx)</span> ,  <span class="math">tx_2</span>  remains  <span class="math">\\epsilon</span> -accepted forever (by some honest node), the expectation of  <span class="math">\\psi - t</span>  is finite.</p>

    <p class="text-gray-300">We add and prove another proposition, which states that after robustly accepting a transcation for a certain  <span class="math">\\epsilon</span> , it becomes (w.p. of at least  <span class="math">1 - \\epsilon</span> ) robustly accepted for all  <span class="math">\\epsilon&#x27; &lt; \\epsilon</span>  as well:</p>

    <p class="text-gray-300"><strong>Proposition 7</strong> (Progress). For any  <span class="math">v \\in honest</span>  and time t, if  <span class="math">tx \\in RobustTxO\\left(\\epsilon, G_t^v, d^v, \\alpha\\right)</span>  then, with probability of  <span class="math">1 - \\epsilon</span>  at least, for any  <span class="math">\\epsilon&#x27;</span>  there exists a  <span class="math">\\phi</span>  such that  <span class="math">\\forall s \\geq \\phi</span> :  <span class="math">RiskTxAccept\\left(tx, G_s^v, d^v, \\alpha\\right) &lt; \\epsilon</span> , and the expectation of  <span class="math">\\phi - t</span>  is finite.</p>

    <p class="text-gray-300">To each of the last three propositions we write a matching one which regards robustness of blocks (rather than that of transactions).</p>

    <p class="text-gray-300"><strong>Proposition 8</strong> (Safety (blocks)). For any  <span class="math">v \\in honest</span> , if  <span class="math">Risk(x, y, G_t^v) &lt; \\epsilon</span>  then, with probability of  <span class="math">1-\\epsilon</span>  at least, there exists a  <span class="math">\\tau</span>  such that  <span class="math">\\forall u \\in honest, \\forall s \\geq \\tau : Risk(x, y, G_s^u) &lt; \\epsilon</span> , and  <span class="math">\\mathbb{E}[\\tau - t] &lt; \\infty</span> .</p>

    <p class="text-gray-300"><strong>Proposition 9</strong> (Progress (blocks)). For any  <span class="math">v \\in honest</span> , if  <span class="math">Risk(x, y, G_t^v) &lt; \\epsilon</span>  then, with probability of  <span class="math">1-\\epsilon</span>  at least, for any  <span class="math">\\epsilon&#x27; &lt; \\epsilon</span>  there exists a  <span class="math">\\phi</span>  such that  <span class="math">\\forall s \\geq \\phi : Risk(x, y, G_s^u) &lt; \\epsilon</span> , and  <span class="math">\\mathbb{E}[\\phi - t] &lt; \\infty</span> .</p>

    <p class="text-gray-300"><strong>Proposition 10</strong> (Weak Liveness (blocks)). Let t be the current time, and assume that  <span class="math">x \\in G_t^{pub}</span> . Let  <span class="math">\\psi</span>  be the first time s at which for some honest node v:  <span class="math">Risk(x, y, G_s^v) &lt; \\epsilon</span> . Then, conditioned on the event where  <span class="math">y \\notin G_{\\psi}^{pub}</span> , the expectation of  <span class="math">\\psi - t</span>  is finite.</p>

    <p class="text-gray-300">We prove the correctness of these propositions in separate subsections below; Consistency will be proven in a later subsection. But first, we begin with three simple lemmas.</p>

    <h2 id="sec-misc-24" class="text-2xl font-bold">C. Basic properties</h2>

    <p class="text-gray-300">The two following lemmas are immediate from lines 7-14 of Algorithm 1.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> Topological relations are unanimously agreed: If G = (C, E) is a block DAG, and  <span class="math">(y, x) \\in E</span> , then  <span class="math">\\forall z \\in G : vote_{x,y}(z, G) = -1</span> .</p>

    <p class="text-gray-300"><strong>Lemma 12.</strong> A block's vote regarding block(s) in its past depends only on its past, hence remains fixed forever: Let  <span class="math">G_1</span>  and  <span class="math">G_2</span>  be two block DAGs, and assume  <span class="math">x, y, z \\in G_1 \\cap G_2</span> . If  <span class="math">\\{x, y\\} \\cap \\overline{past}(z) \\neq \\emptyset</span>  then  <span class="math">vote_{x,y}(z, G_1) = vote_{x,y}(z, G_2)</span> .</p>

    <p class="text-gray-300">Accordingly, we say that z is a strong voter w.r.t the pair (x,y) if  <span class="math">z \\in \\overline{future}(x) \\cup \\overline{future}(y)</span> , and otherwise it is a weak voter.</p>

    <p class="text-gray-300">The following Lemma shows that the vote of the <em>genesis</em> coincides with the vote of the virtual block. Intuitively, the <em>genesis</em> votes according to the majority vote in the DAG excluding itself, and amplifies this majority, which in turn dictates the virtual block's vote.</p>

    <p class="text-gray-300"><strong>Lemma 13.</strong> genesis's vote is the final vote: vote(virtual(G)) = vote(genesis, G).</p>

    <p class="text-gray-300"><em>Proof.</em> Suffice it show that if  <span class="math">vote_{x,y}</span>   <span class="math">(genesis, G) \\ge 0</span>  then  <span class="math">vote_{x,y}</span>   <span class="math">(virtual(G)) \\ge 0</span> . If (x,y) are related topologically then by Lemma 11 all votes agree unanimously on their ordering, and</p>

    <p class="text-gray-300">in particular  <span class="math">vote_{x,y}</span>  (virtual(G)) =  <span class="math">vote_{x,y}</span>  (genesis, G)  <span class="math">\\geq 0</span> . Otherwise, it cannot be the case that x or y are the genesis block, hence the genesis is a weak voter, and by line 14 we obtain</p>

    <p class="text-gray-300"><span class="math">$vote_{x,y}\\left(virtual\\left(G\\right)\\right) = \\widetilde{sgn}\\left(\\sum_{z\\in G}vote_{x,y}\\left(z,G\\right)\\right) =</span>$
(1)</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{sgn}\\left(vote_{x,y}\\left(genesis,G\\right) + \\sum_{z \\in future(genesis,G)} vote_{x,y}\\left(z,G\\right)\\right) \\ge</span>$</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{sgn}\\left(\\sum_{z \\in future(genesis,G)} vote_{x,y}\\left(z,G\\right)\\right) = vote_{x,y}\\left(genesis,G\\right) \\ge 0,</span>$</p>

    <p class="text-gray-300"><span class="math">$(3)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{sgn}\\left(\\sum_{z \\in future(genesis,G)} vote_{x,y}\\left(z,G\\right)\\right) = vote_{x,y}\\left(genesis,G\\right) \\ge 0,\\tag{3}</span>$</p>

    <p class="text-gray-300">hence
<span class="math">$vote_{x,y}\\left(virtual\\left(G\\right)\\right)\\geq0.</span>$</p>

    <h2 id="sec-misc-25" class="text-2xl font-bold">D. Overview of the proof of Safety (blocks)</h2>

    <p class="text-gray-300">Proposition 8 claims essentially that all nodes will forever agree on the (robustness of) the order  <span class="math">x \\prec y</span> , provided that it was sufficiently robust in the DAG observed by some honest node. This is the main and most involved part of the proof. The rest of the propositions follow from it, and their proofs are rather self explanatory. Since its proof is involved and occasionally technical, we begin with an overview of its structure.</p>

    <p class="text-gray-300">In order to simplify the analysis, we need to make some worst case assumptions regarding the behaviour of the attacker. Lemma 20 proves that these are indeed worst case assumptions, namely, that they indeed represent the optimal attack. The vote of each block under our modification is denoted  <span class="math">p\\_vote()</span> , a notion which we describe formally in Subsection E.6.</p>

    <p class="text-gray-300">In the next central lemma we show that, provided that the aggregate vote in future(x) is sufficiently biased in favour of  <span class="math">x \\prec y</span> , the <em>genesis</em> block &ndash; hence the virtual block (by Lemma 13) - will vote  <span class="math">x \\prec y</span> . This proves that, roughly speaking, the vote of recent weak voters cascades through the DAG and convinces older weak blocks, forming thus the genesis's vote. The way we prove this is by choosing a specific weak voter  <span class="math">z_{late}</span>  (in case x is an honest block,  <span class="math">z_{late} = x</span> ), and making sure that its vote is sufficiently robust so as to guarantee that (i) it will not be reversed, and (ii) it will cascade all the way to the <em>genesis</em>. Consequently, a successful attack (namely, a reversal of  <span class="math">x \\prec y</span>  in the DAG observed by some honest node) requires that the attacker add more blocks to  <span class="math">future(z_{late})</span>  than the honest network adds (up to some additive term), in some time interval.</p>

    <p class="text-gray-300">The following lemma formalizes these observations. It uses some parameters (h, j, etc.) that only an oracle can have full knowledge of. We will later show how in reality a node can infer the robustness of block relations without having access to these parameters.</p>

    <p class="text-gray-300"><strong>Lemma 14.</strong> Let  <span class="math">t \\ge publication(x) + 2 \\cdot d</span> . Let  <span class="math">z_{late}</span>  be the latest block in  <span class="math">\\overline{past}_h(x)</span> . Denote:</p>

    <p class="text-gray-300">&bull;  <span class="math">h := |anticone_h(z_{late}, G_t^{oracle})|</span> &bull;  <span class="math">j := |future_h(z_{late}, G_t^{oracle}) \\setminus future_h(x, G_t^v)|</span></p>

    <p class="text-gray-300">&bull;
<span class="math">$m := \\left|future_a\\left(z_{late}, G_t^{oracle}\\right) \\setminus future_a\\left(x, G_t^v\\right)\\right|</span>$
&bull;  <span class="math">k_1 := \\left|G_{[t-d,t]}^{oracle} \\cap honest\\right|</span>
&bull;  <span class="math">l := \\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{\\left|future_a\\left(z, G_{time(z_{late})}^u\\right)\\right| - \\left|future_h\\left(z, G_{time(z_{late})}^u\\right)\\right|\\right\\}</span>
&bull;  <span class="math">g := \\sum_{z \\in \\overline{future}\\left(x, G_t^v\\right)} vote_{y,x}\\left(z, G_t^v\\right)</span></p>

    <p class="text-gray-300">Then,
<span class="math">$\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)^{\\complement} \\subseteq \\left\\{\\exists s \\geq t, \\exists u \\in honest \\ s.t. \\ \\left|G_{[t,s]}^u \\cap malicious\\right|\\right\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{E}^{ull}_{t \\to \\infty}(x,y)</span>$
<span class="math">\\subseteq \\left\\{ \\exists s \\geq t, \\exists u \\in honest \\ s.t. \\ \\left| G^u_{[t,s]} \\cap malicious \\right. \\right.</span>   <span class="math">\\geq \\left| G^u_{[t,s]} \\cap honest \\right| + g - 2 \\cdot h - j - k_1 - l - m \\right\\}.</span></p>

    <p class="text-gray-300">Given the result of the previous lemma, we can upper bound the probability that the order of  <span class="math">x \\prec y</span>  will be reversed. This result resembles the conventional analysis of Bitcoin's security: The greater number of blocks currently pointing at x (and in SPECTRE: voting for  <span class="math">x \\prec y</span> ), the less likely it is that the attacker will be able to win the block-count race and reverse the decision.</p>

    <p class="text-gray-300">Lemma 15. Given the parameters of Lemma 14,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{h&#x27;=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\alpha \\cdot \\lambda, h&#x27;) \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-j-k_1-l-m-h&#x27;)^+}.</span>$</p>

    <p class="text-gray-300">An ordinary node does not typically know for sure the values of the parameters assumed in Lemma 14. The next corollary shows that the result of that lemma (and the one that follows) applies when replacing these parameters with proper bounds thereof. We will later discuss how a node can obtain such bounds.</p>

    <h4 id="sec-misc-26" class="text-lg font-semibold mt-6">Corollary 16. If</h4>

    <p class="text-gray-300">&bull;
<span class="math">$j \\ge \\left| anticone_h\\left(x, G_t^{oracle}\\right) \\right|</span>$</p>

    <p class="text-gray-300">&bull;  <span class="math">l \\ge \\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{ \\left| future_a\\left(z, G_{time(z_{late})}^u\\right) \\right| - \\left| future_h\\left(z, G_{time(z_{late})}^u\\right) \\right| \\right\\}</span>
&bull;  <span class="math">n_x \\ge future_h\\left(x, G_t^{oracle}\\right)</span>
&bull;  <span class="math">g \\le \\sum_{z \\in \\overline{future}(x, G_t^v)} vote_{y,x}\\left(z, G_t^v\\right)</span> .</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}((2-\\alpha)\\cdot d\\cdot \\lambda,k) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d\\cdot (1-\\alpha)\\cdot \\lambda,h) \\cdot \\sum_{m=0}^{\\infty} \\binom{n_x+j+h+m-1}{m} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-m)^+}</span>$</p>

    <p class="text-gray-300">We adjust the above results to the case where some blocks in future(x, G) are known to belong to the attacker. Here we assume that this knowledge is granted to us by a hypothetical oracle. Later on, we will see how attacker blocks are recognized by Algorithm 3, w.h.p.</p>

    <p class="text-gray-300"><strong>Corollary 17.</strong> If in addition to the assumptions of Corollary 16 we assume that  <span class="math">M \\leq |future_a(x, G_t^v)|</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement} \\mid |future_{a}(x,G_{t}^{v})| \\geq M\\right) \\leq \\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}((2-\\alpha) \\cdot d \\cdot \\lambda, k) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot (1-\\alpha) \\cdot \\lambda, h) \\cdot \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_{x}+j+h+m&#x27;-1}{m&#x27;} \\cdot (1-\\alpha)^{n_{x}+j+h} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\cdot \\sum_{m=M}^{\\infty} \\binom{n_{x}+j+h+m-1}{m} \\cdot (1-\\alpha)^{n_{x}+j+h} \\cdot \\alpha^{m} \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-(m-M))^{+}} \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-(m-M))^{+}} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-(m-M))^{+}} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m} \\cdot (1-\\alpha)^{m_{x}+j+h} \\cdot \\alpha^{m}</span>$</p>

    <p class="text-gray-300">We denote the RHS of this inequality by  <span class="math">f_{post\\_mine}(n_x, g, j, l, M)</span> .</p>

    <p class="text-gray-300">So far, our analysis assumed that we are given some proper bounds over the parameters from Lemma 14. Lemmas 24, 29, and 31 show how to appropriately bound these parameters. For each of these parameters, a separate error function is defined, which upper bounds the probability that it does not serve as a correct bound. These error functions deteriorate exponentially fast, by Lemmas 25, 30, and 32. Algorithm 3 aggregates these error functions into the total risk that it outputs.</p>

    <p class="text-gray-300">The parameters are:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>l the pre-mining lead that the attacker obtained before the publication of x, with error function  <span class="math">f_{pre\\_mine}(l(G_t^v))</span> , calculated numerically in Subsection E.6.1</li>
      <li><span class="math">n_x</span>  the number of honest blocks in  <span class="math">future(x, G_t^v)</span> , with error function  <span class="math">f_{post\\_pub}(|future(x, G_t^v)|)</span> , defined in Corollary 29 (Inequality (52)), and</li>
    </ul>

    <p class="text-gray-300">&bull; j &ndash; the number of honest blocks created after time(x), with error function  <span class="math">f_{pre\\_pub}(n_j(G_t^v))</span> , defined in Lemma 31 (Inequality (54)).</p>

    <p class="text-gray-300">While we have previously shown that  <span class="math">n_x</span>  properly counts all honest blocks, we now show that it does successfully exclude almost all attack blocks. Without such a guarantee, weaker attackers would have been able to publish their blocks and delay acceptance indefinitely.</p>

    <p class="text-gray-300"><strong>Lemma 18.</strong> Conditioned on the event  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span> , there exists a time  <span class="math">\\tau\\in[t,\\infty)</span>  such that  <span class="math">\\forall s\\geq \\tau\\colon M(oracle^u,s)\\geq \\left|future_a\\left(x,G_s^{oracle^u}\\right)\\cap G_{[t,s]}^{oracle}\\setminus V_{x\\prec y}(G_s^{oracle^u})\\right|-m^*</span> , for some  <span class="math">m^*</span>  that remains fixed after  <span class="math">\\tau</span>  (and with  <span class="math">\\mathbb{E}[m^*]</span>  determined by the events up to time t).</p>

    <p class="text-gray-300">The above analysis (particularly Lemma 14) has upper bounded the probability that the attacker would be able to reverse the relation  <span class="math">x \\prec y</span> . We now show that, conditioned on the order remaining  <span class="math">x \\prec y</span> , the error function  <span class="math">f_{post\\_mine}</span>  (which upper bounds the probability of this order ever reversing) vanishes as well, which in turn implies that their order would be considered robust by all honest nodes.</p>

    <p class="text-gray-300"><strong>Lemma 19.</strong> There exists a
<span class="math">$\\psi \\in [t, \\infty)</span>$
such that  <span class="math">\\Pr\\left(\\mathcal{E}^{all}_{t \\to \\infty}(x, y, \\epsilon)^{\\complement} \\mid \\mathcal{E}^{v}_{t}(x, y, \\epsilon)\\right) &lt; \\epsilon</span> . Moreover,  <span class="math">\\mathbb{E}\\left[\\psi - t\\right] &lt; \\epsilon</span> .</p>

    <p class="text-gray-300">We have thus shown that if the output of Algorithm 3, as run by some honest node, was smaller than  <span class="math">\\epsilon</span>  then with probability of at least  <span class="math">1-\\epsilon</span> , any honest node running Algorithm 3 (after some time) will get a result smaller than  <span class="math">\\epsilon</span> . This completes the proof of Safety w.r.t. blocks.</p>

    <h2 id="sec-misc-27" class="text-2xl font-bold">E. Proof of Consistency</h2>

    <p class="text-gray-300"><em>Proof. Part I:</em> We first prove that for any DAG G, and for any  <span class="math">tx_1, tx_2 \\in T</span> : if  <span class="math">tx_2 \\in inputs(tx_1)</span>  and  <span class="math">[tx_1] \\cap TxO(G) \\neq \\emptyset</span>  then  <span class="math">[tx_2] \\cap TxO(G) \\neq \\emptyset</span> .</p>

    <p class="text-gray-300">Assume  <span class="math">tx_2 \\in inputs (tx_1)</span>  and  <span class="math">[tx_1] \\cap TxO(G,G) \\neq \\emptyset</span>  and let  <span class="math">tx_1 \\in [tx_1] \\cap TxO(G,G)</span> . Consider the iteration of the second loop (line 4) over  <span class="math">tx = tx_1</span> . As  <span class="math">tx \\in TxO(G,G)</span>  it must be the case that during this iteration the algorithm has reached line 14. This means that for any  <span class="math">[tx_3] \\in inputs (tx_1)</span>  it hasn't visited line 13; in particular for  <span class="math">[tx_3] = [tx_2]</span> , the condition  <span class="math">[tx_2] \\cap TxO(G, past(x_1)) = \\emptyset</span>  has failed, i.e.,  <span class="math">[tx_2] \\cap TxO(G, past(x_1)) \\neq \\emptyset</span> . To see that  <span class="math">TxO(G, past(x_1)) \\subseteq TxO(G,G)</span>  observe that (i) during the run of the algorithm no transaction is ever removed from TX, and that (ii) for any  <span class="math">x_1 \\in G \\cap subG</span> , the operations (in lines 4-14) of TxO(G, subG) and TxO(G,G) are identical; thus any addition of a transaction in line 14 in TxO(G, subG) occurs in TxO(G,G) as well. In particular,  <span class="math">[tx_2] \\cap TxO(G,G) \\neq \\emptyset</span> .</p>

    <p class="text-gray-300"><strong>Part II:</strong> We now prove that for any DAG G, and for any  <span class="math">tx_1, tx_2 \\in T</span> : if  <span class="math">tx_2 \\in conflict(tx_1)</span>  and  <span class="math">[tx_1] \\cap TxO(G, G) \\neq \\emptyset</span>  then  <span class="math">[tx_2] \\cap TxO(G) = \\emptyset</span> .</p>

    <p class="text-gray-300">Assume that  <span class="math">tx_2 \\in conflict</span>   <span class="math">(tx_1)</span>  and  <span class="math">[tx_1] \\cap TxO(G,G) \\neq \\emptyset</span>  and let  <span class="math">tx_1</span>  be an element in the latter intersection. Assume by way of negation that there exists a  <span class="math">tx_2 \\in [tx_2] \\cap TxO(G,G)</span> . Then during the iteration of the first loop (line 3) over some instantiation  <span class="math">z_1^1</span>  of  <span class="math">z_1</span>  such that</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{9}\\&lt;/sup&gt;epsilon</span>  here simply represents a value greater than  <span class="math">f_{pre\\_mine} + f_{pre\\_pub} + f_{post\\_pub} + f_{post\\_mine}</span> .</p>

    <p class="text-gray-300"><span class="math">tx_1 \\in z_1^1</span> , and of the second loop (line 4) over  <span class="math">tx_1</span> , the algorithm has reached line 14. In particular, it did not reach line 10, hence  <span class="math">z_1^2 \\notin past\\left(z_1^1\\right)</span> . For the symmetrical argument,  <span class="math">z_1^1 \\notin past\\left(z_1^2\\right)</span> , which implies that  <span class="math">z_1^2 \\in anticone\\left(z_1^1,G\\right)</span>  (and  <span class="math">z_1^2 \\in anticone\\left(z_1^1,G\\right)</span> ). Now, either  <span class="math">vote_{z_1^1,z_1^2}\\left(virtual\\left(G\\right)\\right) \\geq 0</span>  or  <span class="math">vote_{z_1^2,z_1^1}\\left(virtual\\left(G\\right)\\right) \\geq 0</span> . Either way, line 8 was reached by either the run on  <span class="math">tx_1</span>  or the run on  <span class="math">tx_2</span> , which contradicts the assumption that both runs reached line 14.</p>

    <h2 id="sec-misc-28" class="text-2xl font-bold">F. Proof of Safety (blocks)</h2>

    <p class="text-gray-300">In order to simplify the analysis, we need to make some worst case assumptions regarding the behaviour of the attacker, namely, that it publishes all of its blocks immediately after time t (which represents the time at which some honest node accepted the transaction), and that before time(x) its blocks point at all available blocks. These assumptions essentially modify the DAG (in case the attacker does not carry out the optimal attack scheme). We need to prove that these modifications indeed represent the worst case. To this end we use the notion of a pseudo-vote. A pseudo-vote begins by first explicitly defining and fixing the pseudo-vote of some blocks, which we call the  <span class="math">initial\\ pseudo-voters</span> . Then we define the pseudo-vote of the rest of the blocks as in Algorithm 1. In more detail, we replace in Algorithm 1 the vote() notation by the  <span class="math">p\\_vote()</span>  notation, and whenever the algorithm references  <span class="math">p\\_vote(c)</span>  of an initial pseudo-voter c, we refer to its fixed predetermined value. Thus, the pseudo-vote of an initial pseudo-voter might change the pseudo-vote of other blocks.</p>

    <p class="text-gray-300"><strong>Lemma 20.</strong> Let  <span class="math">x, y \\in G = (C, E)</span>  such that  <span class="math">G_t^v \\subseteq G</span> . Let G' = (C, E') be the DAG resulting from adding the following edges to E:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">\\forall z_1 \\in G \\cap before(time(x)) \\cap malicious</span> ,  <span class="math">\\forall z_2 \\in G \\cap before(time(z_1)) \\setminus \\{z_1\\}</span> : add  <span class="math">(z_1, z_2)</span>  to E.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">\\forall z_1 \\in G \\cap malicious \\setminus G_t^v</span> ,  <span class="math">\\forall z_2 \\in G_{[publication(z_1),\\infty)}^{oracle} \\cap honest: add(z_2, z_1) to E.</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Let p_vote() be defined by specifying the following initial pseudo-voters (and their votes):</p>

    <p class="text-gray-300"><span class="math">\\textit{3)} \\ \\, \\forall z \\in (G \\cap malicious \\setminus G^v_t) \\cup G \\cap before(time(x)) \\cap malicious: p\\_vote_{x,y}\\left(z,G\\right) = +1.</span></p>

    <pre><code class="language-text">\\begin{aligned} &amp;\\textit{Then } vote_{x,y} \\left( virtual\\left(G\\right),G\\right) \\leq \\\\ &amp;p\\_vote_{x,y} \\left( virtual\\left(G&#x27;\\right),G&#x27;\\right) .^{10} \\end{aligned}
</code></pre>

    <p class="text-gray-300">Importantly, we assume here that blocks in  <span class="math">G \\cap malicious</span>  break ties in favour of  <span class="math">y \\prec x</span> .</p>

    <p class="text-gray-300"><em>Proof. Part I:</em> Assume by way of negation that  <span class="math">vote_{x,y}</span>  (virtual(G), G) = +1 yet nonetheless  <span class="math">p\\_vote_{x,y}</span>  (virtual(G), G') = -1 (observe that this is the only case in which the claim can fail, by definition, as a virtual vote cannot take the value of 0).</p>

    <p class="text-gray-300">Let b be a block in  <span class="math">\\overline{future}\\,(x,G)\\cup\\{virtual\\,(G)\\}</span>  such that  <span class="math">p\\_vote_{x,y}\\,(b,G&#x27;)=-1</span> . b cannot belong to  <span class="math">G\\setminus G_t^v</span>  or to  <span class="math">G\\cap before(time(x))\\cap malicious</span> , because blocks in these sets have a pseudo-vote of +1. Let z be a block in  <span class="math">past\\,(b,G)</span> . Since  <span class="math">b\\notin(G\\setminus G_t^v)\\cup(G\\cap before(time(x))\\cap malicious)</span> , there exists in G' a path from b to z that passes through</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;10</sup>Note that virtual(G) = virtual(G'), as they share the same vertex-set.</p>

    <p class="text-gray-300">an edge  <span class="math">(z_2, z_1)</span>  satisfying the conditions of the second modification to G, and through an edge  <span class="math">(z_1&#x27;, z_2&#x27;)</span>  satisfying those of the first modification. In particular,  <span class="math">time(z_2) \\geq publication(z_1) \\geq time(z_2)</span> t-d, and  <span class="math">time(x) \\geq time(z&#x27;_2) \\geq time(z&#x27;_1)</span> . As b and z are the end-vertices of this path,  <span class="math">time(b) \\ge time(z_2) \\ge t - d \\ge publication(x) + d \\ge time(x) + d \\ge time(z_1&#x27;) + d \\ge time(z) + d.</span> Since  <span class="math">z_2</span>  is honest,  <span class="math">z \\in past(z_2, G)</span> , hence  <span class="math">z \\in past(b, G)</span> . Combined with  <span class="math">E \\subset E&#x27;</span>  we obtain: past(b, G') = past(b, G).</p>

    <p class="text-gray-300"><strong>Part II:</strong> Let b be the earliest block in  <span class="math">\\overline{future}(x,G) \\cup \\{virtual(G)\\}\\</span>  for which  <span class="math">vote_{x,y}(b,G) =</span> +1 but  <span class="math">p\\_vote_{x,y}(b,G&#x27;) = -1</span> , and let z be the latest block in antifuture(x,G') for which  <span class="math">vote_{x,y}(z, past(b,G)) &gt; p\\_vote_{x,y}(z, past(b,G&#x27;))</span> . If such a z exists then, similarly to the previous part, we know that past(z, G') = past(z, G); this proves that z is a weak voter both in G and in G', hence that its pseudo-vote is the sign of the sum of pseudo-votes in its future. <sup>11</sup></p>

    <p class="text-gray-300">To see that such a z indeed exists, observe that the genesis satisfies these conditions: By Lemma 13  <span class="math">vote_{x,y}(b,G) = vote_{x,y}(virtual(past(b,G))) =</span> implies  <span class="math">vote_{x,y}\\left(genesis, past\\left(b,G\\right)\\right) \\geq 0</span> , and in a similar way  <span class="math">p\\_vote_{x,y}\\left(b,G&#x27;\\right) = p\\_vote_{x,y}\\left(virtual\\left(past\\left(b,G&#x27;\\right)\\right)\\right) = -1</span>  implies that  <span class="math">p\\_vote_{x,y}\\left(genesis, past\\left(b,G&#x27;\\right)\\right)</span> =-1.12</p>

    <p class="text-gray-300"><strong>Part III:</strong> By the choice of z, if  <span class="math">z&#x27; \\in future(z, past(b, G&#x27;))</span>  is weak with respect to (x,y) then  <span class="math">vote_{x,y}(z&#x27;,past(b,G)) \\leq p\\_vote_{x,y}(z&#x27;,past(b,G&#x27;))</span> . Moreover, by the choice of b, if  <span class="math">z&#x27; \\in past(b,G&#x27;)</span>  is strong w.r.t. (x,y) and  <span class="math">vote_{x,y}(z&#x27;,past(b,G)) = +1</span>  then  <span class="math">p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;)) = +1</span> . All in all, we have that for all  <span class="math">z&#x27; \\in future(z, past(b, G&#x27;))</span> ,  <span class="math">vote_{x,y}(z&#x27;, past(b, G)) \\leq p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;))</span> . Therefore:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(z, past(b,G))} vote_{x,y} \\left(z&#x27;, past(b,G)\\right) \\leq \\sum_{z&#x27; \\in future(z, past(b,G))} p\\_vote_{x,y} \\left(z&#x27;, past(b,G&#x27;)\\right) \\leq z&#x27; \\in future(z, past(b,G))</span>$</p>

    <p class="text-gray-300"><span class="math">$(6)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum p_{vote_{x,y}}(z&#x27;, past(b, G&#x27;)) \\le</span>$
(7)</p>

    <p class="text-gray-300"><span class="math">$\\sum \\qquad p\\_vote_{x,y}\\left(z&#x27;,past\\left(b,G&#x27;\\right)\\right) +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(z, past(b,G))} p\\_vote_{x,y} \\left(z&#x27;, past(b,G&#x27;)\\right) + \\sum_{z&#x27; \\in future(z, past(b,G&#x27;) \\setminus past(b,G))} p\\_vote_{x,y} \\left(z&#x27;, past(b,G&#x27;)\\right) =</span>$</p>

    <p class="text-gray-300"><span class="math">$z&#x27; \\in future(z, past(b,G&#x27;) \\setminus past(b,G))</span>$</p>

    <p class="text-gray-300"><span class="math">$(8)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(z, past(b, G&#x27;))} p\\_vote_{x,y} \\left(z&#x27;, past\\left(b, G&#x27;\\right)\\right). \\tag{9}</span>$</p>

    <p class="text-gray-300"><span class="math">$z&#x27; \\in future(z, past(b, G&#x27;))</span>$</p>

    <p class="text-gray-300">The last equality follows from  <span class="math">future(z, past(b, G)) \\subseteq future(z, past(b, G&#x27;))</span> , which holds because  <span class="math">E \\subseteq E&#x27;</span> . The inequality in (7) holds because if some z' has been added (by transforming</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>It cannot be the case that  <span class="math">y \\in past(z,G&#x27;)</span> , because we know that z is not an initial pseudo-voter (as its pseudo-vote is -1), and therefore the pseudo-vote procedure would have assigned its pseudo-vote to be +1, because y is in its past but x is not in it past, in the same way the ordinary procedure does.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;12</sup>The equality  <span class="math">p\\_vote_{x,y}(b,G&#x27;) = p\\_vote_{x,y}(virtual(past(b,G&#x27;)))</span>  holds because b is either a strong voter w.r.t. (x, y) or the virtual voter.</p>

    <p class="text-gray-300">G into G') to the future of some honest block, then z' must belong to the attacker, hence  <span class="math">p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;)) = +1 &gt; 0.</span></p>

    <p class="text-gray-300"><strong>Part IV:</strong> Consequently, since z is a weak voter with respect to (x, y), (6)-(9) imply that  <span class="math">vote_{x,y}(z, past(b, G)) \\le p\\_vote_{x,y}(z, past(b, G&#x27;)),</span>  which contradicts the choice of z.</p>

    <p class="text-gray-300"><strong>Lemma 14.</strong> Let  <span class="math">t \\ge publication(x) + 2 \\cdot d</span> . Let  <span class="math">z_{late}</span>  be the latest block in  <span class="math">\\overline{past_h}(x)</span> . Denote:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">\\begin{array}{l} \\textbf{ennia 14.} \\ \\ Let \\ t \\geq publication(x) + 2 \\cdot d. \\ \\ Let \\ z_{late} \\ be \\ me \\\\ &amp; \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\</span></li>
    </ul>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300"><span class="math">$\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement} \\subseteq \\left\\{ \\exists s \\geq t, \\exists u \\in honest \\ s.t. \\ \\left| G_{[t,s]}^{u} \\cap malicious \\right| \\right. \\\\ \\left. \\geq \\left| G_{[t,s]}^{u} \\cap honest \\right| + g - 2 \\cdot h - j - k_{1} - l - m \\right\\}.</span>$</p>

    <p class="text-gray-300"><span class="math">$(10)</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Part 1: In the proof below we make the following assumption: Any attacker-block z created before time(x) always votes in favour of  <span class="math">y \\prec x</span>  (even if it is supposed to vote otherwise according to Algorithm 1). We further assume that any such z satisfies  <span class="math">\\overline{past}\\left(z\\right)=G_{time\\left(z\\right)}^{oracle}</span> , i.e., it points at all blocks available at the time of its creation. Finally, we assume that the attacker releases all of his blocks to all nodes in  <span class="math">honest \\setminus \\{v\\}</span>  precisely at time t and onward. The previous lemma implies that these are indeed worst case assumptions: Take G to be any  <span class="math">G_s^u</span> . Then, what the lemma shows is that as long as  <span class="math">p\\_vote_{x,y}\\left(virtual\\left(G_{s}^{u}\\right)\\right)=-1</span> , also  <span class="math">vote_{x,y}\\left(virtual\\left(G_{s}^{u}\\right)\\right)=</span> -1 (under the worst case assumption that ties are always broken in favour of y). The analysis below applies, formally, to  <span class="math">p\\_vote()</span>  as formalized in the prevoius lemma (specifically in (3)). Nevertheless, now that the argument has been formally made, we omit this notation henceforth.</p>

    <p class="text-gray-300">Part II: Let us look at the following chain of implications:</p>

    <p class="text-gray-300"><span class="math">$vote_{x,y}\\left(virtual\\left(G_{s}^{u}\\right)\\right) \\geq 0 \\Rightarrow vote_{x,y}\\left(genesis, G_{s}^{u}\\right) \\geq 0 \\Rightarrow</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(genesis, G_{s}^{u})} vote_{x,y}\\left(z&#x27;, G_{s}^{u}\\right) \\geq 0</span>$</p>

    <p class="text-gray-300"><span class="math">$(11)</span>$</p>

    <p class="text-gray-300"><sup>13</sup>In fact, we use the lemma with a slight modification: The second modification does not apply to all such  <span class="math">(z_2,z_1)</span>  satisfying the specified conditions, rather to a subset thereof, since blocks created by node v between tand t+d need not point at all attacker blocks in  <span class="math">G\\setminus G_s^v</span> . It is easy to see, however, that the proof of the lemma remains intact (and it remains so when applying the second modification to any subset of  <span class="math">(G \\cap malicious \\setminus G_v^t)</span>  &times;  <span class="math">(G_{[publication(z_1),\\infty)}^{oracle} \\cap honest)).</span></p>

    <p class="text-gray-300">The first implication follows from Lemma 13. The second one follows from the definition of <em>genesis</em>'s vote.<sup>14</sup> Thus,</p>

    <p class="text-gray-300"><span class="math">$\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement} = \\bigcup_{u\\in honest, s\\in[t,\\infty)} \\widehat{\\mathcal{E}}_{s}^{u}(x,y)^{\\complement} = \\{\\exists u \\in honest, \\exists s \\geq t : vote_{x,y} \\left(virtual\\left(G_{s}^{u}\\right)\\right) \\geq 0\\}</span>$</p>

    <p class="text-gray-300">However, if there exists such an s as the latter event requires, then we can look at the first such s. With respect to it, between t and s all honest votes were in favour of  <span class="math">x \\prec y</span> ; this is because for any bonest block z' with  <span class="math">time(z&#x27;) \\in [t,s)</span> ,  <span class="math">past(z&#x27;) = G^{node(z&#x27;)}_{time(z&#x27;)}</span> , hence  <span class="math">vote(z&#x27;) = vote\\left(virtual\\left(G^{node(z&#x27;)}_{time(z&#x27;)}\\right)\\right)</span> , and by the choice of s as the earliest time for which an honest node's DAG's virtual block votes in favour of  <span class="math">y \\preceq x</span> , we know that  <span class="math">vote_{x,y}(z&#x27;, G^u_s) = -1</span> . Part III: Below, the notation  <span class="math">G^u_{[t_1,t_2]}</span>  stands for  <span class="math">G^u_s \\cap before(t_2) \\setminus before(t_1)</span> . We claim that for all  <span class="math">z \\in \\overline{past_h}(x)</span> :</p>

    <p class="text-gray-300"><span class="math">$vote_{x,y}\\left(z,G_{s}^{u}\\right) \\leq \\widetilde{sgn}\\left(\\left|G_{[t,s]}^{u}\\cap malicious\\right| - \\left|G_{[t,s]}^{u}\\cap honest\\right| + 2\\cdot h + l + k_{1} + j + m - g\\right).</span>$</p>

    <p class="text-gray-300">We prove the claim by a complete induction on  <span class="math">D(z) := \\left|future\\left(z,\\overline{past_h}\\left(x\\right)\\right)\\right|</span> . Assume we have proved the claim for any z with D(z) &lt; D. We now prove it for z with D(z) = D. If z = x then  <span class="math">vote_{x,y}\\left(z,G_s^u\\right) = -1</span>  hence the above inequality is satisfied trivially. Otherwise, z is a weak voter, and  <span class="math">vote_{x,y}\\left(z,G_s^u\\right)</span>  is given by the sign of the sum of votes in its future. We decompose these voters into three subsets: members of  <span class="math">future\\left(z,G_{time(z_{late})}^u\\right)</span> , members of  <span class="math">future\\left(z,G_{[time(z_{late}),t]}^u\\right)</span> , and members of  <span class="math">future\\left(z,G_{[t,s]}^u\\right)</span> .</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G^u_{time(z_{late})}\\right)</span> : By the induction hypothesis we know that all blocks in  <span class="math">future_h\\left(z,\\overline{past_h}\\left(z_{late}\\right)\\right)</span>  vote in favour of  <span class="math">x\\prec y</span> , and additionally we have  <span class="math">future_h\\left(z,G^u_{time(z_{late})}\\right)\\setminus\\overline{past}\\left(z_{late}\\right)\\subseteq anticone_h\\left(z_{late},G^u_{time(z_{late})}\\right)</span> . Thus,  <span class="math">\\sum_{z&#x27;\\in future_h\\left(z,G^u_{time(z_{late})}\\right)}vote_{x,y}\\left(z&#x27;,G^u_s\\right)\\le 2\\cdot\\left|anticone_h\\left(z_{late},G^u_{time(z_{late})}\\right)\\right|-\\left|future_h\\left(z,G^u_{time(z_{late})}\\right)\\right|</span> . We obtain:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G^{u}_{time(z_{late})}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) \\leq \\\\ 2 \\cdot \\left| anticone_{h}\\left(z_{late}, G^{u}_{time(z_{late})}\\right) \\right| \\\\ - \\left| future_{h}\\left(z, G^{u}_{time(z_{late})}\\right) \\right| + \\left| future_{a}\\left(z, G^{u}_{time(z_{late})}\\right) \\right|.</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;14</sup>Here we implicitly assume that x and y are not related topologically, which rules out the option that x = genesis or y = genesis, hence genesis is weak w.r.t. (x, y). If they are related topologically, the result is trivial, for all votes are then forever unanimous in the same direction (Lemma 11).</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G^{u}_{[time(z_{late}),t]}\\right)</span> :</li>
    </ul>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>a) Honest blocks: By  <span class="math">Part\\ I</span>  we have that  <span class="math">future_a\\left(z,G^u_{[time(z_{late}),t]}\\right)\\setminus future_a\\left(z_{late},G^u_{[time(z_{late}),t]}\\right)</span>  =  <span class="math">\\emptyset</span> . This implies that  <span class="math">anticone_h\\left(z_{late},G^u_{[time(z_{late}),time(z_{late})+d]}\\right)</span>   <span class="math">\\supseteq</span>   <span class="math">future\\left(z,G^u_{[time(z_{late}),t]}\\right)\\setminus future\\left(z_{late},G^u_t\\right)</span> . We obtain:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future_h\\left(\\mathbf{z}, G^u_{[time(z_{late}),t]}\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) \\leq \\\\ \\sum_{z&#x27; \\in future_h\\left(\\mathbf{z}_{late}, G^u_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\sum_{z&#x27; \\in future_h\\left(\\mathbf{z}_{late}, G^u_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\sum_{z&#x27; \\in future_h\\left(z_{late}, G^v_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\sum_{z&#x27; \\in future_h\\left(z_{late}, G^v_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\left| G^{oracle}_{[t-d,t]} \\cap honest \\right| \\leq \\\\ \\sum_{z&#x27; \\in future_h\\left(\\mathbf{x}, G^v_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\sum_{z&#x27; \\in future_h\\left(\\mathbf{x}, G^v_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ \\left| G^{oracle}_{[t-d,t]} \\cap honest \\right| + \\\\ \\left| G^{oracle}_{[t-d,t]} \\cap honest \\right| + \\\\ \\left| future_h\\left(z_{late}, G^v_t\\right) \\setminus future_h\\left(\\mathbf{x}, G^v_t\\right) \\right|.</span>$</p>

    <p class="text-gray-300">b) Attacker blocks: We utilize our worst case assumptions described in <em>Part I</em> to obtain:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future_a\\left(\\mathbf{z}, G^u_{[time(z_{late}), t]}\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) = \\\\ \\sum_{z&#x27; \\in future_a\\left(\\mathbf{z}_{late}, G^u_{[time(z_{late}), t]}\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) \\leq \\\\ \\sum_{z&#x27; \\in future_a\\left(\\mathbf{z}, G^v_t\\right)} vote_{x,y}\\left(z&#x27;, G^u_s\\right) + \\\\ z&#x27; \\in future_a\\left(\\mathbf{z}, G^v_t\\right) \\setminus future_a\\left(\\mathbf{z}, G^v_t\\right) |.</span>$</p>

    <p class="text-gray-300">c) All blocks: We combine the honest and attacker blocks in  <span class="math">future\\left(z, G^{u}_{[time(z_{late}),t]}\\right)</span>  to obtain:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G^{u}_{[time(z_{late}), t]}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) \\leq \\sum_{z&#x27; \\in future_{h}\\left(x, G^{v}_{t}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) + \\sum_{z&#x27; \\in future_{h}\\left(x, G^{v}_{t}\\right)} \\left| anticone_{h}\\left(z_{late}, G^{u}_{[time(z_{late}), time(z_{late}) + d]}\\right) \\right| + \\left| G^{oracle}_{[t-d,t]} \\cap honest \\right| + \\left| future_{h}\\left(z_{late}, G^{v}_{t}\\right) \\setminus future_{h}\\left(x, G^{v}_{t}\\right) \\right| + \\sum_{z&#x27; \\in future_{a}\\left(x, G^{v}_{t}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) + \\left| future_{a}\\left(z_{late}, G^{u}_{t}\\right) \\setminus future_{a}\\left(x, G^{v}_{t}\\right) \\right| =</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| future_{a}\\left(z_{late}, G^{u}_{t}\\right) \\setminus future_{a}\\left(x, G^{v}_{t}\\right) \\right| =</span>$</p>

    <p class="text-gray-300"><span class="math">$(12)</span>$</p>

    <p class="text-gray-300"><span class="math">$g + \\left| anticone_{h} \\left( z_{late}, G^{u}_{[time(z_{late}), time(z_{late}) + d]} \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| G^{oracle}_{[t-d,t]} \\cap honest \\right| + \\left| future_{h} \\left( z_{late}, G^{v}_{t} \\right) \\setminus future_{h} \\left( x, G^{v}_{t} \\right) \\right|</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\left| future_{a} \\left( z_{late}, G^{u}_{t} \\right) \\setminus future_{a} \\left( x, G^{v}_{t} \\right) \\right|.</span>$</p>

    <p class="text-gray-300"><span class="math">$(13)</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G^u_{[t,s]}\\right)</span> : Finally, by the choice of s, all honest blocks created between t and s vote in favour of  <span class="math">x \\prec y</span> , hence</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G_{[t,s]}^{u}\\right)} vote_{x,y}\\left(z&#x27;, G_{s}^{u}\\right) \\leq \\\\ -\\left|future_{h}\\left(z, G_{[t,s]}^{u}\\right)\\right| + \\left|future_{a}\\left(z, G_{[t,s]}^{u}\\right)\\right| \\leq \\\\ -\\left|G_{[t,s]}^{u} \\cap honest\\right| + \\left|G_{[t,s]}^{u} \\cap malicious\\right|,</span>$</p>

    <p class="text-gray-300">where we used again the fact that  <span class="math">t \\ge publication(x) + d \\ge publication(z) + d</span> .</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Combining all the above results we obtain:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(z,G_{s}^{u})} vote_{x,y} \\left(z&#x27;, G_{s}^{u}\\right) \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$2 \\cdot \\left| anticone_{h} \\left( z_{late}, G_{time(z_{late})}^{u} \\right) \\right|</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\left| future_{h} \\left( z, G_{time(z_{late})}^{u} \\right) \\right| + \\left| future_{a} \\left( z, G_{time(z_{late})}^{u} \\right) \\right|</span>$</p>

    <p class="text-gray-300"><span class="math">$- g + \\left| anticone_{h} \\left( z_{late}, G_{[time(z_{late}), time(z_{late}) + d]}^{u} \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| G_{[t-d,t]}^{oracle} \\cap honest \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| future_{h} \\left( z_{late}, G_{t}^{v} \\right) \\setminus future_{h} \\left( x, G_{t}^{v} \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| future_{a} \\left( z_{late}, G_{t}^{u} \\right) \\setminus future_{a} \\left( x, G_{t}^{v} \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\left| G_{[t,s]}^{u} \\cap honest \\right| + \\left| G_{[t,s]}^{u} \\cap malicious \\right| \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$(14)</span>$</p>

    <p class="text-gray-300">(18)</p>

    <p class="text-gray-300"><span class="math">$2 \\cdot h + l + k_{1} - g + \\left| G_{[t,s]}^{u} \\cap malicious \\right| - \\left| G_{[t,s]}^{u} \\cap honest \\right|</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\left| future_{h} \\left( z_{late}, G_{t}^{v} \\right) \\setminus future_{h} \\left( x, G_{t}^{v} \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| future_{a} \\left( z_{late}, G_{t}^{u} \\right) \\setminus future_{a} \\left( x, G_{t}^{v} \\right) \\right| \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$2 \\cdot h + l + k_1 - g + \\left| G_{[t,s]}^u \\cap malicious \\right| - \\left| G_{[t,s]}^u \\cap honest \\right|</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\left| future_h \\left( z_{late}, G_t^{oracle} \\right) \\setminus future_h \\left( x, G_t^v \\right) \\right| +</span>$</p>

    <p class="text-gray-300"><span class="math">$(19)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| future_a \\left( z_{late}, G_t^{oracle} \\right) \\setminus future_a \\left( x, G_t^v \\right) \\right| = \\tag{20}</span>$</p>

    <p class="text-gray-300"><span class="math">$2 \\cdot h + l + k_1 - g + j + m + \\left| G^u_{[t,s]} \\cap malicious \\right| - \\left| G^u_{[t,s]} \\cap honest \\right|.</span>$</p>

    <p class="text-gray-300"><span class="math">$(21)</span>$</p>

    <p class="text-gray-300">As z is a weak voter, we conclude that  <span class="math">vote_{x,y}\\left(z,G_{s}^{u}\\right) \\leq \\widetilde{sgn}\\left(\\left|G_{[t,s]}^{u}\\cap malicious\\right|-\\left|G_{[t,s]}^{u}\\cap honest\\right|+2\\cdot h+l+k_{1}+g+j+m\\right).</span>  <strong>Part IV:</strong> In particular, for z=genesis, the event  <span class="math">vote_{x,y}\\left(genesis,G_{s}^{u}\\right)\\geq0</span>  is contained in</p>

    <p class="text-gray-300"><strong>Part IV:</strong> In particular, for z = genesis, the event  <span class="math">vote_{x,y} (genesis, G^u_s) \\geq 0</span>  is contained in the event where  <span class="math">\\left|G^u_{[t,s]} \\cap malicious\\right| \\geq \\left|G^u_{[t,s]} \\cap honest\\right| + g - 2 \\cdot h - l - k_1 - j - m</span> . By (11), for all  <span class="math">u \\in honest</span>  and  <span class="math">s \\geq t</span>  this event contains also  <span class="math">\\widehat{\\mathcal{E}}^s_u(x,y)^{\\complement}</span> , hence it contains also their union  <span class="math">\\widehat{\\mathcal{E}}^{all}_{t \\to \\infty}(x,y)^{\\complement}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 15.</strong> Given the parameters of Lemma 14,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{h&#x27;=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\alpha \\cdot \\lambda, h&#x27;) \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-j-k_1-l-m-h&#x27;)^+}</span>$
(22)</p>

    <p class="text-gray-300"><em>Proof.</em> Since all nodes  <span class="math">u \\in honest</span>  receive honest blocks with a delay of d seconds at most, we have that  <span class="math">\\left|G^u_{[t,s]} \\cap malicious\\right| - \\left|G^u_{[t,s]} \\cap honest\\right| \\leq \\left|future_a\\left(z_{late}, G^{oracle}_{[t,s]}\\right)\\right| - \\left|future_h\\left(z_{late}, G^{oracle}_{[t,\\max\\{s-d,t\\}]}\\right)\\right|</span> . We further upper bound  <span class="math">\\left|future_a\\left(x, G^{oracle}_{[s&#x27;,s]}\\right)\\right|</span>  by  <span class="math">\\left|future_a\\left(x, G^{oracle}_{[s-d,s]}\\right)\\right|</span> , and observe that the latter follows a Poisson distribution with parameter  <span class="math">\\alpha \\cdot d \\cdot \\lambda</span> ; we denote this variable by h'. For any given value of h', the variable  <span class="math">\\left|future_a\\left(x,G_{s&#x27;}^{oracle}\\setminus G_t^{oracle}\\right)\\right|-\\left|future_h\\left(x,G_{s&#x27;}^{oracle}\\setminus G_t^{oracle}\\right)\\right|+h&#x27; \\text{ can be modeled as a}</span> random walk  <span class="math">X_i</span>  (where the <em>i</em>th step is the creation-time of the <em>i</em>th block after time t), with  <span class="math">X_0 = h&#x27;</span> , and with a drift of  <span class="math">\\alpha</span>  towards positive infinity. The probability that  <span class="math">X_i</span>  would ever reach the interval  <span class="math">[-h-j-k_1-h&#x27;-l-m+g,+\\infty)</span>  is  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{g-2\\cdot h-j-k_1-l-m-h&#x27;}</span>  if  <span class="math">g&gt;h+j+k_1+l+m+h&#x27;</span> , and 1 otherwise (see [18], [17]).</p>

    <h2 id="sec-misc-29" class="text-2xl font-bold">Corollary 16. If</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">j \\ge |anticone_h(x, G_t^{oracle})|</span></li>
      <li><span class="math">l \\ge \\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{ A_{time(x)}^z H_{time(x)}^z \\right\\}</span>   <span class="math">n_x \\ge future_h \\left( x, G_t^{oracle} \\right)</span></li>
      <li><span class="math">g \\leq \\sum_{z \\in \\overline{future}(x,G_{\\star}^{v})} vote_{y,x}(z,G_{t}^{v}).</span></li>
    </ul>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)\\right) \\leq \\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}((2-\\alpha)\\cdot d\\cdot \\lambda, k) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d\\cdot (1-\\alpha)\\cdot \\lambda, h) \\cdot \\sum_{m=0}^{\\infty} \\binom{n_x+j+h+m-1}{m} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-m)^+}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We build on the results of previous lemmas. The proof of Lemma 14, which is deterministic, remains intact when the corresponding parameters serve as bounds; see (14)-(21).</p>

    <p class="text-gray-300">The variables  <span class="math">k_1</span> ,  <span class="math">\\left|anticone_h\\left(z_{late}, G^u_{[time(z_{late}), time(z_{late}) + d]}\\right)\\right|</span> , and h' are the sum of independent Poisson processes; the parameter of the first two is  <span class="math">d \\cdot (1 - \\alpha) \\cdot \\lambda</span> , and the parameter of h' is  <span class="math">d \\cdot \\alpha \\cdot \\lambda</span> . Thus, their sum is a new Poisson variable k with parameter  <span class="math">(2 \\cdot (1 - \\alpha) + \\alpha) \\cdot d \\cdot \\lambda = (2 - \\alpha) \\cdot d \\cdot \\lambda</span> . The variable  <span class="math">\\left| anticone_h \\left( z_{late}, G^u_{time(z_{late})} \\right) \\right|</span>  is an additional Poisson variable with parameter  <span class="math">d \\cdot (1 - \\alpha) \\cdot \\lambda</span> . We denote it by h (thereby overriding its original meaning in Lemma 14).</p>

    <p class="text-gray-300">Lemma 14 uses the variable  <span class="math">m = |future_a(z_{late}, G_t^{oracle}) \\setminus future_a(x, G_t^v)|</span>  which is upper bounded by  <span class="math">|future_a\\left(z_{late},G_t^{oracle}\\right)|</span> . Provided that the honest network has created precisely n blocks since the creation of  <span class="math">z_{late}</span> , the number of blocks created by the attacker at the same time follows a negative binomial distribution (see [17]), i.e., it takes the value m with probability  <span class="math">\\binom{n+m-1}{m} \\cdot (1-\\alpha)^n \\cdot \\alpha^m</span> . In the worst case, all of these blocks belong to  <span class="math">future(z_{late}, G_t^{oracle})</span> . Here, again, it is sufficient to upper bound n, since increasing the parameter n results in a distribution over m that stochastically dominates (in first order) the original one. The number of honest blocks created after  <span class="math">time(z_{late})</span>  (up to time t) is upper bounded by  <span class="math">antipast_h(z_{late}, G_t^{oracle})</span> , since blocks in  <span class="math">past_h(z_{late})</span> . We thus have:  <span class="math">|n| \\leq |anticone_h(z_{late}, G_t^v)| + |future_h(z_{late}, G_t^v) \\setminus future_h(x, G_t^v)| + |future_h(x, G_t^v)| \\leq |anticone_h(z_{late}, G_t^v)| + |future_h(x, G_t^v)| \\leq |anticone_h(z_{late}, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| \\leq |anticone_h(z_{late}, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)| + |future_h(x, G_t^v)</span>  <span class="math">h+j+n_x</span> .</p>

    <p class="text-gray-300">Finally, as l and j are upper bounds and q is a lower bound to the corresponding variables from Lemma 14, one could simply turn all equalities in its proof (and in the proof of Lemma 15) into &quot;&lt;&quot; inequalities and the proof remains intact.</p>

    <p class="text-gray-300">Below we revisit previous results, regarding the case where x is known to be an honest block, and to the case where one needs to defend a group of blocks rather than an individual block.</p>

    <p class="text-gray-300"><strong>Lemma 21.</strong> Assume that  <span class="math">node(x) \\in honest</span>  and that  <span class="math">publication(y) \\geq publication(x) +</span> d. Let  <span class="math">z_{late}</span>  be the latest block in  <span class="math">\\overline{anticone_h}(x, G_t^v)</span>  and let  <span class="math">z_{early}</span>  be the earliest block in  <span class="math">\\overline{anticone_h}</span>   <span class="math">(x, G_t^v)</span> . Furthermore, assume:</p>

    <p class="text-gray-300">&bull;
<span class="math">$l := \\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{ \\left| future_a \\left( z, G_{time(z_{early})}^u \\right) \\right| - \\left| future_h \\left( z, G_{time(z_{early})}^u \\right) \\right| \\right\\}</span>$
&bull;  <span class="math">n &gt; \\max \\left\\{ \\left| future_t \\left( z&#x27;, G_t^{oracle} \\right) \\right| \\right\\}</span></p>

    <p class="text-gray-300">&bull;  <span class="math">l := \\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{ \\left| future_a \\left( z, G_{time(z_{early})}^u \\right) \\right| - \\left| future_h \\left( z, G_{time(z_{early})}^u \\right) \\right| \\right\\}</span> &bull;  <span class="math">n_x \\ge \\max_{x&#x27; \\in \\overline{anticone_h}(x)} \\left\\{ \\left| future_h \\left( x&#x27;, G_t^{oracle} \\right) \\right| \\right\\}</span> &bull;  <span class="math">g \\le \\max_{x&#x27; \\in \\overline{anticone_h}(x, G_t^v)} \\left\\{ z \\in \\overline{future} \\left( x&#x27;, G_t^v \\right) : vote_{y,x} \\left( z, G_t^v \\right) = -1 \\right\\} - \\min_{x&#x27; \\in \\overline{anticone_h}(x, G_t^v)} \\left\\{ z \\in \\overline{future} \\left( x&#x27;, G_t^v \\right) : vote_{y,x} \\left( z, G_t^v \\right) = +1 \\right\\}.</span></p>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\le \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\lambda, h) \\cdot \\tag{24}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}.</span>$
(25)</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">k_1 \\geq \\left|G_{[t-d,t]}^{oracle} \\cap honest\\right|</span> , and let  <span class="math">m := \\left|future_a\\left(z_{early}, G_t^{oracle}\\right) \\setminus future_a\\left(z_{late}, G_t^v\\right)\\right|</span> . We adjust the analysis from the proof of Lemma 14. We claim that for all  <span class="math">z \\in \\overline{anticone_h}\\left(x, G_t^v\\right)</span> :</p>

    <p class="text-gray-300"><span class="math">$vote_{x,y}\\left(z,G_{s}^{u}\\right) \\leq \\widetilde{sgn}\\left(\\left|G_{[t,s]}^{u}\\cap malicious\\right| - \\left|G_{[t,s]}^{u}\\cap honest\\right| + k_{1} + m - g\\right).</span>$</p>

    <p class="text-gray-300">We prove the claim by a complete induction on  <span class="math">D(z) := \\left|future\\left(z,\\overline{anticone_h}\\left(x\\right)\\right)\\right|</span> . Assume we have proved the claim for any z with D(z) &lt; D. We now prove it for z with D(z) = D. If z = x then  <span class="math">vote_{x,y}\\left(z,G_s^u\\right) = -1</span>  hence the above inequality is satisfied trivially. Otherwise, z is a weak voter, as  <span class="math">y \\notin \\overline{past}\\left(z\\right)</span>  by the assumption on publication(y), therefore  <span class="math">vote_{x,y}\\left(z,G_s^u\\right)</span>  is given by the sign of the sum of votes in its future. We decompose these voters into three subsets: members of  <span class="math">future\\left(z,G_{time(z_{late})}^u\\right)</span> , members of  <span class="math">future\\left(z,G_{[t,s]}^u\\right)</span> .</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G^u_{time(z_{late})}\\right)</span> : By the induction hypothesis we know that all blocks in  <span class="math">future_h\\left(z,\\overline{anticone_h}\\left(z_{late}\\right)\\right)</span>  vote in favour of  <span class="math">x \\prec y</span> , hence We obtain:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G^{u}_{time(z_{late})}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) \\leq \\\\ -\\left|future_{h}\\left(z, G^{u}_{time(z_{late})}\\right)\\right| + \\left|future_{a}\\left(z, G^{u}_{time(z_{late})}\\right)\\right|.</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G^{u}_{[time(z_{late}),t]}\\right)</span> : Every z' in this set belongs to  <span class="math">future\\left(x&#x27;\\right)</span>  for some  <span class="math">x&#x27;\\in\\overline{anticone_{h}}\\left(x,G^{v}_{t}\\right)</span> , therefore, by the definition of g:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G^{u}_{[time(z_{late}), t]}\\right)} vote_{x,y}\\left(z&#x27;, G^{u}_{s}\\right) \\leq \\\\ -g + \\left|future_{a}\\left(z_{early}, G^{oracle}_{t}\\right) \\setminus future_{a}\\left(z_{late}, G^{v}_{t}\\right)\\right| + \\\\ \\left|future_{h}\\left(z, G^{u}_{t}\\right) \\setminus future_{h}\\left(z, G^{v}_{t}\\right)\\right| \\leq \\\\ -g + \\left|future_{a}\\left(z_{early}, G^{oracle}_{t}\\right) \\setminus future_{a}\\left(z_{late}, G^{v}_{t}\\right)\\right| + \\left|G^{oracle}_{[t-d,t]} \\cap honest\\right| = \\\\ -g + m + k_{1}.</span>$</p>

    <p class="text-gray-300"><span class="math">$(26)</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Members of  <span class="math">future\\left(z,G_{[t,s]}^{u}\\right)</span> : By the choice of s, all honest blocks created between t and</li>
    </ul>

    <p class="text-gray-300">s vote in favour of  <span class="math">x \\prec y</span> , hence</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future\\left(z, G_{[t,s]}^{u}\\right)} vote_{x,y}\\left(z&#x27;, G_{s}^{u}\\right) \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$-\\left|future_{h}\\left(z, G_{[t,s]}^{u}\\right)\\right| + \\left|future_{a}\\left(z, G_{[t,s]}^{u}\\right)\\right| \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$-\\left|G_{[t,s]}^{u} \\cap honest\\right| + \\left|G_{[t,s]}^{u} \\cap malicious\\right|,</span>$</p>

    <p class="text-gray-300">where we used the fact that  <span class="math">t \\ge publication(x) + d \\ge publication(z) + d</span> .</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>All in all,</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{z&#x27; \\in future(z, G_s^u)} vote_{x,y} \\left( z&#x27;, G_s^u \\right) \\le \\tag{27}</span>$</p>

    <p class="text-gray-300"><span class="math">$|l + k_{1} + m - g - |G_{[t,s]}^{u} \\cap honest| + |G_{[t,s]}^{u} \\cap malicious| \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$|l + k_{1} + m - g - |future_{h} \\left(z_{late}, G_{[t, \\max\\{s-d, t\\}]}^{oracle}\\right)| +</span>$</p>

    <p class="text-gray-300"><span class="math">$|future_{a} \\left(z_{late}, G_{[t,s]}^{oracle}\\right)|</span>$</p>

    <p class="text-gray-300"><span class="math">$(29)</span>$</p>

    <p class="text-gray-300">Therefore, the event where for some s and some u,  <span class="math">vote_{x,y}\\left(virtual\\left(G_{s}^{u}\\right)\\right)\\geq 0</span>  is contained in the event where (29) is non-negative. As in the proof of Lemma 15, the probability of the latter event is upper bounded by  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(l+k_1+h&#x27;+m-g)^+}</span> , where h' equals  <span class="math">\\left|future_a\\left(x,G_{[s&#x27;,s]}^{oracle}\\right)\\right|</span> . We then combine  <span class="math">k_1</span>  and h' into one Poisson variable h with parameter  <span class="math">\\alpha \\cdot d \\cdot \\lambda + (1-\\alpha) \\cdot d \\cdot \\lambda = d \\cdot \\lambda</span> , to obtain:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\le \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\lambda, h) \\cdot \\tag{30}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}.</span>$
(31)</p>

    <p class="text-gray-300"><strong>Corollary 22.</strong> If in addition to Lemma 21's assumptions we know that  <span class="math">publication(y) \\ge t</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\le \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\alpha \\cdot \\lambda, h) \\cdot \\tag{32}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}.</span>$
(33)</p>

    <p class="text-gray-300"><em>Proof.</em> Given that y wasn't published until time t, we know that all honest blocks in  <span class="math">future\\left(x,G_{[t-d,t]}^{oracle}\\right)</span>  vote in favour of x, hence the reduction of  <span class="math">k_1=\\left|G_{[t-d,t]}^{oracle}\\cap honest\\right|</span>  in (26) is superfluous, and we thus only need to reduce h', the Poisson variable with parameter  <span class="math">d\\cdot\\alpha\\cdot\\lambda</span>  from Lemma 15.</p>

    <p class="text-gray-300"><strong>Corollary 23.</strong> Let  <span class="math">X \\subseteq G_t^v \\cap honest</span>  and  <span class="math">Y \\subseteq G_t^{oracle} \\setminus G_t^v</span> . Assume further that elements in X do not relate topologically to one another (i.e.,  <span class="math">\\forall x_1, x_2 \\in X, x_1 \\in anticone(x_2, G_t^v)</span> ). Let  <span class="math">z_{late}</span>  be the latest block in X, let  <span class="math">z_{early}</span>  be the earliest block in X.</p>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}((3-2\\cdot\\alpha)\\cdot d\\cdot\\lambda,h)\\cdot</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x+m-1}{m} \\cdot (1-\\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n_x-h-l-m)^+}.</span>$</p>

    <p class="text-gray-300">Proof. We adjust the result of Lemma 21. The main modification is that now g must relate to all pairs (x,y). Define:  <span class="math">g:=\\max_{x_1,x_2\\in X}\\left\\{z\\in\\overline{future}\\left(x_1,G_t^v\\right):vote_{y,x_2}\\left(z,G_t^v\\right)=-1\\right\\}-\\min_{x_1,x_2\\in X}\\left\\{z\\in\\overline{future}\\left(x_1,G_t^v\\right):vote_{y,x_2}\\left(z,G_t^v\\right)=+1\\right\\}</span> . Observe that in the interval  <span class="math">[time(z_{early})+2\\cdot d,t]</span>  all honest blocks belong to  <span class="math">\\bigcap_{x\\in X}\\overline{future}\\left(x,G_t^v\\right)</span> . In particular, if we denote  <span class="math">h&#x27;:=n_x-g</span>  we have that h' is upper bounded by a Poisson variable with parameter  <span class="math">2\\cdot d\\cdot \\lambda</span> . We then apply the analysis done in the proof of Lemma 21, with s being the first time at which for some  <span class="math">(x,y)\\in X\\times Y</span> ,  <span class="math">vote_{x,y}\\left(virtual\\left(G_s^u\\right)\\right)\\geq 0</span> . Combining the result of that lemma with the probability distribution over h' we conclude that the probability of the event  <span class="math">\\bigcup_{(x,y)\\in X\\times Y}\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span>  is at most</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{h&#x27;=0}^{\\infty} \\mathcal{P}_{oiss}(2 \\cdot d \\cdot (1-\\alpha) \\cdot \\lambda, h&#x27;) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\lambda, h) \\cdot \\sum_{h=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1-\\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n_x - h&#x27; - h - l - m)^+} = \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}((3-2 \\cdot \\alpha) \\cdot d \\cdot \\lambda, h) \\cdot \\sum_{h=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1-\\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n_x - h - l - m)^+}.</span>$</p>

    <p class="text-gray-300"><strong>Corollary 17.</strong> If in addition to the assumptions of Corollary 16 we assume that  <span class="math">M \\leq |future_a(x, G_t^v)|</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y) \\mid |future_a(x,G_t^v)| \\ge M\\right) \\le \\tag{34}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}((2-\\alpha) \\cdot d \\cdot \\lambda, k) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot (1-\\alpha) \\cdot \\lambda, h) \\cdot \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x + j + h + m&#x27; - 1}{m&#x27;} \\cdot (1-\\alpha)^{n_x + j + h} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\cdot \\sum_{m=M}^{\\infty} \\binom{n_x + j + h + m - 1}{m} \\cdot (1-\\alpha)^{n_x + j + h} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2 \\cdot h - k - j - l - (m-M))^+}</span>$</p>

    <p class="text-gray-300">We denote the RHS of this inequality by  <span class="math">f_{post\\_mine}(n_x, g, j, l, M)</span> . We note that from Lemmas 25, 32, and 30 it follows that, in order to compute  <span class="math">f_{post\\_mine}</span> , one can truncate these sums and suffer an exponentially low error.</p>

    <p class="text-gray-300">Proof. Under the assumption on M we have  <span class="math">\\left|future_a\\left(z_{late},G_t^{oracle}\\right)\\setminus future_a\\left(x,G_t^v\\right)\\right| = \\left|future_a\\left(z_{late},G_t^{oracle}\\right)\\right| - \\left|future_a\\left(x,G_t^v\\right)\\right| \\geq \\left|future_a\\left(z_{late},G_t^{oracle}\\right)\\right| - M.</span>  We then adjust the result of Corollary 16 and adjust (4) to account for the above</p>

    <p class="text-gray-300">We then adjust the result of Corollary 16 and adjust (4) to account for the above updated definition of m. Thus, in the exponent, we substitute m-M for m and write:  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-j-k-l-(m-M))^+}</span> . Next, the updated probability distribution over m-M can be obtained by conditioning the negative binomial distribution (described in the proof of Corollary 16) on its being larger than or equal to M; indeed, the M blocks of  <span class="math">future_a\\left(x,G_t^v\\right)</span>  were created after  <span class="math">z_{late}</span>  (and before time t), and  <span class="math">future_a\\left(x,G_t^v\\right)\\subseteq future_a\\left(z_{late},G_t^{oracle}\\right)</span> . Consequently, the probability distribution over m-M is given by</p>

    <p class="text-gray-300"><span class="math">$\\Pr(m-M) = \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x+j+h+m&#x27;-1}{m&#x27;} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\cdot \\binom{n_x+j+h+m-1}{m} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^m,</span>$</p>

    <p class="text-gray-300">and we arrive at the desired term. The rest of the arguments in the proof of Corollary 16 remain unaffected.  <span class="math">\\Box</span></p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Numerical method to calculate  <span class="math">f_{pre\\_mine}</span> :</li>
    </ul></li>
      <li>Put  <span class="math">\\delta := \\alpha \\cdot \\lambda \\cdot d</span> . Pick some  <span class="math">N \\gg 1</span> ,  <span class="math">^{15}</span>  and define a matrix  <span class="math">T \\in \\mathbb{R}_{N \\times N}</span>  as follows. For all  <span class="math">1 \\leq l &lt; N-1</span> ,  <span class="math">T_{l-1,l} = 1-\\alpha</span> ,  <span class="math">T_{l+1,l} = \\alpha</span> , and for l = N-1:  <span class="math">T_{l-1,l} = 1-\\alpha</span> ,  <span class="math">T_{l,l} = \\alpha</span> .</li>
    </ul>

    <p class="text-gray-300"><sup>15</sup>By Lemma 25, to achieve an error of at most  <span class="math">\\hat{\\epsilon}</span>  it suffices to choose N such that  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{N-1} &lt; \\hat{\\epsilon}/2</span>  and  <span class="math">e^{-d\\cdot\\alpha\\cdot\\lambda}\\cdot\\frac{(d\\cdot\\alpha\\cdot\\lambda)^N}{N!}&lt;\\hat{\\epsilon}/2</span> . In particular, N is logarithmic in  <span class="math">\\hat{\\epsilon}</span> .</p>

    <p class="text-gray-300">The first column of the matrix is defined by:  <span class="math">T_{0,0}:=(1-\\alpha)\\cdot e^{-\\delta},\\ T_{1,0}=e^{-\\delta}\\cdot \\alpha+e^{-\\delta}\\cdot \\delta,</span>  for 1&lt; l&lt; N-1:  <span class="math">T_{l,0}=e^{-\\delta}\\cdot \\frac{\\delta^l}{l!},</span>  and for l=N-1:  <span class="math">T_{l,0}=1-\\sum_{l=0}^{N-2}e^{-\\delta}\\cdot \\frac{\\delta^l}{l!}.</span></p>

    <p class="text-gray-300">&bull; Find the eigenvector of T corresponding to the eigenvalue 1, and denote it  <span class="math">\\pi</span> . Define  <span class="math">\\Pi(l) := \\sum_{l&#x27;=0}^{l} \\pi(l&#x27;)</span> , and, finally, define  <span class="math">f_{pre\\_mine}(l) := 1 - \\Pi((l-1)^+)</span> .</p>

    <p class="text-gray-300">The matrix T is the transition probability matrix of a special reflecting random walk  <span class="math">(X_k)</span>  over the nonnegative integers:  <span class="math">T_{i,j} := \\Pr\\left(X_{k+1} = i \\mid X_k = j\\right)</span> . At every position (apart from the edges 0 and N-1) the walk takes a step towards negative infinity w.p. <span class="math">(1-\\alpha)</span>  and towards positive infinity w.p. <span class="math">\\alpha</span> . Whenever it reaches the origin, it jumps to its next position in  <span class="math">\\{0,1,...,N-1\\}</span>  according to a (modified) Poisson distribution. It is easy to see that this random walk induces an ergodic Markov chain, hence it has a unique stationary distribution, which we denoted  <span class="math">\\pi</span> ;  <span class="math">\\Pi</span>  is the cumulative probability function of  <span class="math">\\pi</span> .</p>

    <p class="text-gray-300"><strong>Lemma 24.</strong> For all  <span class="math">\\hat{r} \\geq r</span>  and for all For all  <span class="math">l \\in \\mathbb{N}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\max_{z \\in G_{\\hat{r}}^{oracle} \\cap honest} \\left\\{ \\left| future_{a}\\left(z, G_{r}^{oracle}\\right) \\right| - \\left| future_{h}\\left(z, G_{r}^{oracle}\\right) \\right| \\right\\} &gt; l \\right) \\leq f_{pre\\_mine}(l).</span>$
(36)</p>

    <p class="text-gray-300">Proof. Part I: We prove the result assuming the maximum is taken over all  <span class="math">z \\in G_r^{oracle} \\cap honest</span> ; taking then the maximum over all  <span class="math">z \\in G_{\\hat{r}}^{oracle} \\cap honest</span>  does not change the result, because the variable  <span class="math">\\left\\{ \\left| future_a\\left(z,G_r^{oracle}\\right) \\right| - \\left| future_h\\left(z,G_r^{oracle}\\right) \\right| \\right\\}</span>  is nonnegative (as will be shown below), and its value for  <span class="math">z \\in G_{\\hat{r}}^{oracle} \\setminus G_r^{oracle}i</span>  is zero.</p>

    <p class="text-gray-300">We show that the variable  <span class="math">\\max_{z \\in G_s^{oracle} \\cap honest} \\left\\{ \\left| future_a\\left(z,G_s^{oracle}\\right) \\right| - \\left| future_a\\left(z,G_s^{oracle}\\right) \\right| \\right\\}</span></p>

    <p class="text-gray-300">We show that the variable  <span class="math">\\max_{z \\in G_s^{oracle} \\cap honest} \\left\\{ \\left| future_a\\left(z, G_s^{oracle}\\right) \\right| - \\left| future_h\\left(z, G_s^{oracle}\\right) \\right| \\right\\}</span>  can be modeled as a reflecting random walk (with some special behaviour when the walk visits the origin, due to the honest network's inner delay d).</p>

    <p class="text-gray-300">Intuitively, observe that whenever a new honest block b is created,  <span class="math">future_h\\left(z,G_{time(b)}^{oracle}\\right)</span>  increases by 1 for all z's in its past. For b itself, the value of this variable is 0. Thus, the value of  <span class="math">\\max_{z\\in G_s^{oracle}\\cap honest}\\left\\{future_a\\left(z,G_s^{oracle}\\right)-future_h\\left(z,G_s^{oracle}\\right)\\right\\}</span>  is lower bounded by 0. On the other hand, whenever a new attack block is created, the value of  <span class="math">future_a\\left(z,G_s^{oracle}\\right)</span>  increases by 1 for all honest blocks available to it at the time (following the worst case assumptions specified in Lemma 14,  <span class="math">Part\\ I</span> ). Therefore, the attacker's maximal advance over the honest network can be modeled as a reflecting random walk. Note that, since the creation of an honest block b increases  <span class="math">future_h\\left(z,G_s^{oracle}\\right)</span>  only for blocks in  <span class="math">past_h\\left(b\\right)</span> , which might be a proper subset of  <span class="math">before\\left(time(b)\\right)</span>  (when d&gt;0), there are certain situations where honest blocks do not &quot;work against&quot; attack blocks to decrease the value of  <span class="math">\\max\\left\\{\\left|future_a\\left(z,G_s^{oracle}\\right)\\right|-\\left|future_h\\left(z,G_s^{oracle}\\right)\\right|\\right\\}</span> . We take this into account by skewing the behviour of the walk whenever the origin is visited (and proving that in all other states the honest network's inner delay has no effect).</p>

    <p class="text-gray-300">In the following analysis, we assume the worst case scenario, namely, that if  <span class="math">z_1</span>  and  <span class="math">z_2</span>  are honest blocks such that  <span class="math">|time(z_1) - time(z_2)| &lt; d</span>  then  <span class="math">z_1 \\in anticone(z_2)</span> . That this is a worst case follows simply from the fact that omitting some edges between honest blocks</p>

    <p class="text-gray-300">can only decrease  <span class="math">future_h\\left(z,G_s^{oracle}\\right)</span>  hence increase the value of  <span class="math">\\left|future_a\\left(z,G_s^{oracle}\\right)\\right| - \\left|future_h\\left(z,G_s^{oracle}\\right)\\right|</span> .</p>

    <p class="text-gray-300">If the attacker is creating blocks in secret, it needs to decide upon a strategy regarding which blocks should its new block point at, for every new block it creates. Consider the following strategy: The attacker's new block b, created at time(b), points at  <span class="math">G_{time(b)}^{oracle}</span>  (except itself, of course). While we have already argued why this is a worst case assumption (Lemma 14, Part I), it is here easy to see that this strategy maximizes  <span class="math">\\max_{z \\in G_s^{oracle} \\cap honest} \\left\\{ \\left| future_a\\left(z, G_s^{oracle}\\right) \\right| - \\left| future_h\\left(z, G_s^{oracle}\\right) \\right| \\right\\}</span> .</p>

    <p class="text-gray-300"><strong>Part II:</strong> Denote by  <span class="math">t_i</span>  the creation time of the ith block in  <span class="math">G_r^{oracle}</span> . Denote by  <span class="math">z_s</span>  the variable  <span class="math">\\arg\\max_{z\\in G_s^{oracle}\\cap honest}\\left\\{\\left|future_a\\left(z,G_s^{oracle}\\right)\\right|-\\left|future_h\\left(z,G_s^{oracle}\\right)\\right|\\right\\}</span> . Define further  <span class="math">A_s^z:=\\left|future_a\\left(z,G_s^{oracle}\\right)\\right|</span> , and  <span class="math">H_s^z:=\\left|future_h\\left(z,G_s^{oracle}\\right)\\right|</span> . Abbreviate  <span class="math">A_s:=\\left|future_a\\left(z_s,G_s^{oracle}\\right)\\right|</span> , and  <span class="math">H_s:=\\left|future_h\\left(z_s,G_s^{oracle}\\right)\\right|</span> .</p>

    <p class="text-gray-300">We define a subseries  <span class="math">(s_k) \\subseteq (t_i)</span>  recursively:  <span class="math">s_0 = 0</span> , and for all k &gt; 0:  <span class="math">s_{k+1} = \\min_i \\{t_i : t_i \\ge time(z_{s_k}) + d\\}</span> . We claim that  <span class="math">(A_{s_k} - H_{s_k})</span>  has the same probability distribution as  <span class="math">X_k</span> . Assume this claim holds true, and let  <span class="math">s_k</span>  be the earliest  <span class="math">s_k</span>  with  <span class="math">s_k \\ge r</span> . Then  <span class="math">(A_r - H_r) \\le 1 + (A_{s_k} - H_{s_k})</span> . Consequently,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\max_{z \\in G_r^u \\cap honest} \\{|future_a(z, G_r^u)| - |future_h(z, G_r^u)|\\} &gt; l\\right) =</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(A_r - H_r &gt; l\\right) \\leq \\Pr\\left(A_{s_k} - H_{s_k} &gt; l - 1\\right) =</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(X_k &gt; l - 1\\right) = 1 - \\Pi((l - 1)^+).</span>$</p>

    <p class="text-gray-300"><strong>Part III:</strong> To complete the proof we prove our claim, by induction on k. For k=0,  <span class="math">s_0=0</span> . At time 0, following the creation of the genesis block, the value of  <span class="math">(A_0-H_0)</span>  is 0, as  <span class="math">future(genesis) \\cap G_0^{oracle} = \\emptyset</span> , and likewise  <span class="math">X_0=0</span> . Assume we have proved this for k, and we now prove it for k+1. Assume first that  <span class="math">(A_{s_k}-H_{s_k})&gt;0</span> . Assume by way of negation that  <span class="math">s_k &lt; time(z_{s_k}) + d</span> . Then, by the construction of  <span class="math">(s_k)</span> ,  <span class="math">s_k = time(z_{s_k})</span> . This implies that the honest network created  <span class="math">z_{s_k}</span>  in time  <span class="math">s_k</span> . Thus  <span class="math">(A_{s_k}-H_{s_k})=0</span> , because  <span class="math">z_{s_k}</span>  was created at time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  is supposed to be in  <span class="math">s_k</span>  and  <span class="math">s_k</span>  and  <span class="math">s_k</span>  and  <span class="math">s_k</span>  and  <span class="math">s_k</span>  and  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  is supposed to be in  <span class="math">s_k</span>  and  <span class="math">s_k</span>  and  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  is supposed to be in  <span class="math">s_k</span>  and  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  and  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . As  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> . Thus  <span class="math">s_k</span>  are time  <span class="math">s_k</span>  are time  <span class="math">s_k</span> .</p>

    <p class="text-gray-300">Consequently, if  <span class="math">(A_{s_k}-H_{s_k})&gt;0</span> , we are guaranteed that the entire honest network has learnt about the block  <span class="math">z_{s_k}</span> . Thence, the honest network adds blocks to  <span class="math">future(z_{s_k})</span>  at a rate of  <span class="math">(1-\\alpha\\cdot\\lambda)</span> , while the attacker adds them at a rate of  <span class="math">\\alpha</span> . Every block of the honest network then contributes 1 to  <span class="math">|future_h(z,G_s^{oracle})|</span> , whereas an attacker block contributes 1 to  <span class="math">|future_a(z,G_s^{oracle})|</span> . Thus,  <span class="math">(A_{s_k}-H_{s_k})</span>  increases by 1 by the addition of an attacker's block, that is, w.p. <span class="math">\\alpha</span> , and decreases by 1 w.p. <span class="math">(1-\\alpha)</span> . Indeed, conditioned on  <span class="math">X_k&gt;0</span> ,  <span class="math">X_{k+1}</span> 's distribution behaves the same:  <span class="math">\\Pr(X_{k+1}=X_k+1\\mid X_k&gt;0)=1-\\Pr(X_{k+1}=X_k-1\\mid X_k&gt;0)=\\alpha</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup>Indeed, if  <span class="math">r = s_k</span>  then this holds trivially. Otherwise, in the interval  <span class="math">(r, s_k)</span>  the honest network could have contributed at most one block to  <span class="math">future(z_{s_{k-1}})</span> , because  <span class="math">(X_i)</span>  can decrease by at most 1 at every step, according to its transition matrix, thus in the interval  <span class="math">(r, s_k) \\subseteq (s_{k-1}, s_k)</span>  the honest network created at most 1 block.</p>

    <p class="text-gray-300">Assume now that  <span class="math">(A_{s_k}-H_{s_k})=0</span> . It cannot be the case that the block that was created in time  <span class="math">s_k</span>  belongs to the attacker, since that would imply that the attacker has an advantage of at least 1 over the last block that was created by the honest network (up to time  <span class="math">s_k</span> ). Therefore, it belongs to the honest network. By the definition of  <span class="math">z_{s_k}</span> , it is precisely the block that was created in time  <span class="math">s_k</span> . Consequently, in the interval  <span class="math">(s_k, s_k + d)</span> , the honest network does not add blocks to  <span class="math">future(z_{s_k})</span>  (recall we are assuming that the worst case scenario is realized, i.e., a propagation time of d seconds per honest block). During this interval, the attacker creates blocks at following a Poisson process with parameter  <span class="math">\\alpha \\cdot \\lambda</span> . Thus,  <span class="math">(A_{s_k+d}^{z_{s_k}} - H_{s_k+d}^{z_{s_k}}) = i</span>  w.p.  <span class="math">\\mathcal{P}_{oiss}(\\alpha \\cdot \\lambda \\cdot d, i)</span> . Upon which, the next block in the system, created after  <span class="math">s_k+d</span> , is the attacker's w.p. <span class="math">\\alpha</span> , in case which the total gap increases by j+1, i.e.,  <span class="math">(A_{s_{k+1}}^{z_{s_{k+1}}} - H_{s_{k+1}}^{z_{s_{k+1}}}) = (A_{s_k+d}^{z_{s_k}} - H_{s_k+d}^{z_{s_k}}) + 1</span> ; alternatively, the next block after  <span class="math">s_k+d</span>  is the honest network's, w.p. <span class="math">(1-\\alpha)</span> , in case which  <span class="math">(A_{s_{k+1}}^{z_{s_{k+1}}} - H_{s_{k+1}}^{z_{s_{k+1}}}) = \\max\\{(A_{s_k+d}^{z_{s_k}} - H_{s_k+d}^{z_{s_k}}) - 1, 0\\}</span> . By comparing this to  <span class="math">\\Pr(X_{k+1} \\mid X_k = 0)</span> , we see that also in this case the variable  <span class="math">X_{k+1}</span>  behaves the same as  <span class="math">(A_{s_{k+1}}^{z_{s_{k+1}}} - H_{s_{k+1}}^{z_{s_{k+1}}})</span> .</p>

    <p class="text-gray-300"><strong>Lemma 25.</strong>  <span class="math">f_{pre\\_mine}(l) \\leq C_l \\cdot e^{-B_l \\cdot future_a(x,G_t^v)}</span>  for some positive constants  <span class="math">B_l, C_l</span> .</p>

    <p class="text-gray-300">To get the intuition of this result, notice that when d=0 the stationary distribution of the reflecting random walk is known to be proportionate to  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^l</span> , and if d&gt;0, this relation still holds for  <span class="math">l\\gg d\\cdot\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For n &gt; 1, the stationary distribution  <span class="math">\\pi</span>  satisfies the relation  <span class="math">\\pi(n) = (1 - \\alpha) \\cdot \\pi(n + 1) + \\alpha \\cdot \\pi(n - 1) + e^{-\\delta} \\cdot \\frac{\\delta^n}{n!} \\cdot \\pi(0)</span> . Let us write  <span class="math">\\pi(n) = C_n \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^n</span>  for  <span class="math">n \\ge 0</span> . We have:</p>

    <p class="text-gray-300"><span class="math">$C_n \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^n = (1-\\alpha) \\cdot C_{n+1} \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{n+1} + \\tag{37}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\cdot C_{n-1} \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{n-1} + e^{-\\delta} \\cdot \\frac{\\delta^n}{n!} \\cdot \\pi(0) \\Longrightarrow \\tag{38}</span>$</p>

    <p class="text-gray-300"><span class="math">$C_n = C_{n+1} \\cdot \\alpha + C_{n-1} \\cdot (1-\\alpha)^{-1} + e^{-\\delta} \\cdot \\frac{\\left(\\delta \\cdot \\frac{(1-\\alpha)}{\\alpha}\\right)^n}{n!} \\cdot \\pi(0).</span>$
(39)</p>

    <p class="text-gray-300">For large enough n's, the last summand in the above expression is negligible. Thus, when we write  <span class="math">\\forall n: C_n \\approx C</span> , the above relation will be satisfied for large n's (up to the negligible error of the last summand). Thus, for some constant C,  <span class="math">\\pi(n) \\leq C \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^n</span> , hence  <span class="math">1 - \\Pi((n-1)^+) = \\sum_{k=n}^{\\infty} \\pi(k) \\leq B_l \\cdot e^{-C_l \\cdot n}</span> , for some large enough n, and some constants  <span class="math">B_l</span> ,  <span class="math">C_l &gt; 0</span> .</p>

    <p class="text-gray-300">The following Corollary is immediate from Lemma 24.</p>

    <p class="text-gray-300"><strong>Corollary 26.</strong> In Lemma 21, if l is not known, then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\le \\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\lambda, h)</span>$
(40)</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}</span>$</p>

    <p class="text-gray-300"><span class="math">$(41)</span>$</p>

    <p class="text-gray-300">Similarly, in Corollary 22,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\le \\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\alpha\\lambda, h) \\cdot \\tag{42}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m. \\tag{43}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-h-l-m)^+}.\\tag{44}</span>$</p>

    <p class="text-gray-300">Finally, in Corollary 23,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right) \\leq \\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}((3-2\\cdot\\alpha)\\cdot d\\cdot\\lambda,h) \\cdot \\sum_{m=0}^{\\infty} \\binom{n_x+m-1}{m} \\cdot (1-\\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n_x-h-l-m)^+}.</span>$</p>

    <p class="text-gray-300">Using this corollary we can prove the bound that is used by the online policy described in Algorithm 7. Denote:</p>

    <p class="text-gray-300"><span class="math">$risk\\_hidden(T,g) := \\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{m=0}^{\\infty} \\mathcal{P}_{oiss}((T+2\\cdot d) \\cdot \\alpha \\cdot \\lambda) \\cdot \\tag{45}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-l-m)^+} \\tag{46}</span>$</p>

    <p class="text-gray-300"><strong>Corollary 27.</strong> If Algorithm 7 returns a value less than  <span class="math">\\epsilon</span>  then  <span class="math">\\Pr\\left(\\bigcup_{y \\in G_{\\infty}^{pub} \\backslash G_{t}^{pub}} \\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)^{\\complement}\\right) &lt; \\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> First, observe that the variable g used in Corollary 22 could be replaced (here and in that corollary) with  <span class="math">\\min_{x&#x27; \\in \\overline{anticone}_h(x,G_t^v)} |future(x&#x27;,G_t^v)|</span> , because all blocks in  <span class="math">future(x,G_t^v)</span>  vote in favour of x, by the assumption on y. The value assigned to g, in line 5 of Algorithm 7, is upper bounded by  <span class="math">\\min_{x&#x27; \\in \\overline{anticone}(x,G_x)} |future(x&#x27;,G_x)|</span> , because  <span class="math">G_x</span>  includes all honest blocks in  <span class="math">G_t^v</span> . Next, T is assigned the value  <span class="math">time\\_now-received^v(x)=t-received^v(x)</span> , in line 3. Observe</p>

    <p class="text-gray-300">that m is distributed according to  <span class="math">\\mathcal{P}_{oiss}(m, (t-time(x)) \\cdot \\alpha \\cdot \\lambda)</span> . <sup>17</sup> As  <span class="math">time(x) \\geq received^v(x) + d</span> , we can upper bound this by a Poisson variable with parameter  <span class="math">(T+d) \\cdot \\alpha \\cdot \\lambda</span> . We then adjust the result of the second term in Corollary 26; we combine the distributions over h and m (where h is taken from (42), to conclude that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\bigcup_{y \\in G_{\\infty}^{pub} \\setminus G_{t}^{pub}} \\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)^{\\complement}\\right) \\le \\tag{47}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{m=0}^{\\infty} \\mathcal{P}_{oiss}((T+2\\cdot d)\\cdot \\alpha \\cdot \\lambda) \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-l-m)^{+}} =</span>$
(48)</p>

    <p class="text-gray-300"><span class="math">$risk\\_hidden(T,g).</span>$
(49)</p>

    <p class="text-gray-300">Note that we do not need to apply here a union bound over the different y's in  <span class="math">G^{pub}_{\\infty}\\setminus G^{pub}_t</span> , because our analysis assumes that in the worst case all of the attacker blocks vote strongly in favour of  <span class="math">y \\prec x</span> , for all y in this set, and, additionally, all honest blocks in  <span class="math">G^v_t</span>  will always vote strongly in favour of  <span class="math">x \\prec y</span> , for all y's in this set (as they do not see y in their past). Thus, under our worst case analysis, the event where for some y in  <span class="math">G^{pub}_{\\infty}\\setminus G^{pub}_t</span>  the attacker manages to reverse the relation  <span class="math">x \\prec y</span>  is equivalent to the event where it manages to do so for a given y. In conclusion, if Algorithm 7 returned a value less than  <span class="math">\\epsilon</span> , we know that  <span class="math">\\Pr\\left(\\bigcup_{y\\in G^{pub}_{\\infty}\\setminus G^{pub}_t}\\widehat{\\mathcal{E}}^{all}_{t\\to\\infty}(x,y)^{\\complement}\\right)&lt;\\epsilon</span> .</p>

    <p class="text-gray-300">Denote by  <span class="math">dist\\_gap(b, G)</span>  the minimal k for which  <span class="math">gap(b, \\langle G, b, K \\rangle) = 0</span> .</p>

    <p class="text-gray-300"><strong>Lemma 28.</strong> Let b be an honest block. Then,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\bigcup_{u \\in honest, s \\in [time(b), \\infty)} dist\\_gap\\left(b, G_s^u\\right) &gt; K\\right) \\leq \\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot \\lambda, h) \\cdot \\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\binom{\\alpha}{1 - \\alpha}^{(K - h - l - m)^+}</span>$
(51)</p>

    <p class="text-gray-300">We denote the RHS of (50) by  <span class="math">f_{distqap}(K)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By its definition, the event where  <span class="math">dist\\_gap(b, G_s^u) &gt; K</span>  is equivalent to the event where some block in  <span class="math">anticone\\left(b, G_{time(b)}^{node(b)}\\right) \\cup \\left(G_s^u \\setminus G_{time(b)}^{node(b)}\\right)</span>  precedes b (or achieves a tie with it) according to  <span class="math">vote\\left(virtual\\left(\\langle G_s^u, b, K \\rangle\\right)\\right)</span> . In  <span class="math">\\langle G_s^u, b, K \\rangle</span> , b has additional K blocks  <span class="math">b_1, ..., b_K</span>  that vote in favour of it against any other  <span class="math">y \\notin \\overline{past}(b)</span> ; indeed, for any  <span class="math">y \\notin \\overline{past}(b)</span> ,  <span class="math">y \\notin \\overline{past}(b)</span> . Consequently, at  <span class="math">G_{time(b)}^{node(b)}</span> , K blocks in future(b) vote in its favour against any block in its anticone. We can thus apply the first part of Corollary 26 with  <span class="math">n_x = K</span> ,  <span class="math">K = \\{b\\}</span> , and  <span class="math">K = \\{b\\}</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;17</sup>Our previous analysis measured m using  <span class="math">n_x</span> , as it was structure-based and had no access to T.</p>

    <p class="text-gray-300"><span class="math">G^{oracle}_{\\infty} \\setminus \\overline{past}</span>  (b) to conclude that (50) is an upper bound on the probability that a block in  <span class="math">anticone\\left(b,G^{node(b)}_{time(b)}\\right)</span>  will ever precede b (or obtain a tie with it) in the pairwise order of  <span class="math">\\langle G^u_s,b,k\\rangle</span>  for any  <span class="math">s \\geq time(b)</span>  in the future.</p>

    <p class="text-gray-300"><strong>Lemma 29.</strong> For all  <span class="math">n_x \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\left|future_{h}\\left(x,G_{t}^{v}\\right)\\right|&gt;n_{x}\\right)\\leq\\tag{52}</span>$</p>

    <p class="text-gray-300"><span class="math">$|future(x, G_t^v)| \\cdot f_{distgap}\\left(\\sqrt{|future(x, G_t^v)|}\\right).</span>$
(53)</p>

    <p class="text-gray-300">The RHS of the last inequality is denoted  <span class="math">f_{post\\_pub}\\left(|future\\left(x,G_{t}^{v}\\right)|\\right)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> If y = NULL there is nothing to prove, since then  <span class="math">n_x = future(x, G_t^v) \\ge future_h(x, G_t^v)</span> . Assume  <span class="math">y \\ne NULL</span> .</p>

    <p class="text-gray-300">Denote  <span class="math">K:=\\sqrt{|future\\,(x,G^v_t)|}</span> .  <span class="math">n_x</span>  is obtained in Algorithm 3 by subtracting M, the number of blocks with  <span class="math">dist\\_gap&gt;K</span> , from  <span class="math">future\\,(x,G^v_t)</span> . Let b be an honest block in  <span class="math">future\\,(x,G)</span> . By Lemma 28, the probability that  <span class="math">dist\\_gap\\,(b,G^v_t)</span>  will be larger than K is at most  <span class="math">f_{distgap}\\,(K)</span> . By the union bound, the probability that for some b in  <span class="math">future_h\\,(x,G^v_t)</span> ,  <span class="math">dist\\_gap\\,(b,G^v_t)&gt;K</span> , is at most  <span class="math">|future_h\\,(x,G^v_t)|\\cdot f_{distgap}\\,(K)\\leq |future\\,(x,G^v_t)|\\cdot f_{distgap}\\,(K)=f_{post\\_pub}\\,(|future\\,(x,G^v_t)|)</span> .</p>

    <p class="text-gray-300">The RHS of Inequality (50) implies:</p>

    <p class="text-gray-300"><strong>Lemma 30.</strong>  <span class="math">f_{post\\_pub}\\left(|future\\left(x,G_{t}^{v}\\right)|\\right) \\leq C_{c} \\cdot e^{-B_{c} \\cdot future_{a}\\left(x,G_{t}^{v}\\right)}</span>  for some positive constants  <span class="math">B_{c}, C_{c}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 31.</strong> For  <span class="math">n_j \\in \\mathbb{N}</span>  put  <span class="math">j := gap(x, G) + n_j</span> .</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\left\\{\\left|anticone_{h}\\left(x, G_{t}^{oracle}\\right)\\right| &gt; j\\right\\}\\right) \\leq \\tag{54}</span>$</p>

    <p class="text-gray-300"><span class="math">$f_{pre\\_mine}\\left(\\sqrt{n_j}\\right) + \\sum_{h&#x27;=0}^{\\infty} \\mathcal{P}_{oiss}((1-\\alpha) \\cdot \\lambda \\cdot d, h&#x27;)</span>$
(55)</p>

    <p class="text-gray-300"><span class="math">$f_{post\\_mine}\\left(n_j, n_j - h&#x27; + 1, \\sqrt{n_j}\\right) \\tag{56}</span>$</p>

    <p class="text-gray-300">We denote the RHS of this inequality by  <span class="math">f_{pre\\_pub}(n_j)</span> . To understand the intuition behind this resul recall that w.h.p. a block defeats only blocks that were published close to its publication or after it.</p>

    <p class="text-gray-300">Proof. Part I: Let  <span class="math">t_x := publication(x)</span> . Define  <span class="math">L_n := \\{z \\in anticone_h(x, G_t^v) : future_h(z, anticone_h(x, G_{t_x}^v)) \\geq n\\}</span> . (Note the use of  <span class="math">t_x</span>  in this definition). Denote by  <span class="math">A_n</span>  the event  <span class="math">\\{\\exists z \\in L_n : z \\in X_{win}(x, G_t^v)\\}</span> . Finally, let  <span class="math">z_e</span>  be the earliest block in  <span class="math">L_{n&#x27;}^{\\mathbf{C}} \\cap anticone_h(x, G_t^{oracle})</span>  and put  <span class="math">n&#x27; := n_j - |\\overline{anticone_h(z_e, G_t^{oracle})}| + 1</span>  for  <span class="math">n_j := n_j - |\\overline{anticone_h(z_e, G_t^{oracle})}|</span></p>

    <p class="text-gray-300"><span class="math">\\sqrt{|future(x, G_t^v)|}</span> . Denote by  <span class="math">X_{win}(x, G)</span>  the set of blocks that x precedes (or obtains a tie with) in the pairwise order of G's virtual vote, and by  <span class="math">X_{lose}(x, G)</span>  the rest of blocks. Then:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\left\\{\\left|anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|&gt;gap\\left(x,G\\right)+n_{j}\\right\\}=\\\\ &amp;\\left\\{\\left|X_{win}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|+\\\\ &amp;\\left|X_{lose}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|&gt;gap\\left(x,G\\right)+n_{j}\\right\\}=\\\\ &amp;\\left\\{\\left|X_{win}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|+gap\\left(x,G_{t}^{v}\\right)&gt;gap\\left(x,G\\right)+n_{j}\\right\\}=\\\\ &amp;\\left\\{\\left|X_{win}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|+n_{j}\\right\\}=\\\\ &amp;\\left(\\left\\{\\left|X_{win}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|&gt;n_{j}\\right\\}\\cap A_{n&#x27;}\\right)\\cup\\\\ &amp;\\left(\\left\\{\\left|X_{win}\\left(x,G_{t}^{pub}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|&gt;n_{j}\\right\\}\\cap A_{n&#x27;}^{\\complement}\\right)\\subseteq\\\\ &amp;A_{n&#x27;}\\cup\\left\\{\\left|L_{n&#x27;}^{\\complement}\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right|&gt;n_{j}\\right\\}=\\\\ &amp;A_{n&#x27;}\\cup\\left\\{\\left|L_{n&#x27;}^{\\complement}\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap future_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|&gt;n_{j}\\right\\}=\\\\ &amp;A_{n&#x27;}\\cup\\left\\{\\left|L_{n&#x27;}^{\\complement}\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap future_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|&gt;n_{j}-\\left|L_{n&#x27;}^{\\complement}\\cap anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap anticone_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|\\right\\}\\subseteq\\\\ &amp;A_{n&#x27;}\\cup\\left\\{\\left|anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap future_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|\\right\\}=\\\\ &amp;n_{j}-\\left|anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap future_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|&gt;\\\\ &amp;n_{j}-\\left|anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\cap future_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|&gt;\\\\ &amp;n_{j}-\\left|anticone_{h}\\left(z_{e},G_{t}^{oracle}\\right)\\right|\\right\\}. \\end{split}</span>$</p>

    <p class="text-gray-300">As  <span class="math">z_e \\in L_{n&#x27;}</span> , and by the definition of n', it cannot be the case that  <span class="math">anticone_h\\left(x,G_t^{oracle}\\right) \\cap future_h\\left(z_e,G_t^{oracle}\\right)</span>  contains more than  <span class="math">n_j-\\left|\\overline{anticone_h}\\left(z_e,G_t^{oracle}\\right)\\right|</span>  blocks. Thus, the event  <span class="math">\\left\\{\\left|anticone_h\\left(x,G_t^{oracle}\\right)\\cap future_h\\left(z_e,G_t^{oracle}\\right)\\right|&gt;n_j-\\left|\\overline{anticone_h}\\left(z_e,G_t^{oracle}\\right)\\right|\\right\\}</span>  occurs w.p. 0, and we obtain:  <span class="math">\\Pr\\left(\\left\\{\\left|anticone_h\\left(x,G_t^{oracle}\\right)\\right|&gt;gap\\left(x,G\\right)+n_j\\right\\}\\right) \\leq \\Pr\\left(A_{n&#x27;}\\right)</span> .</p>

    <p class="text-gray-300">Observe that all blocks in  <span class="math">future\\left(z, anticone_h\\left(x, G_{t_x}^v\\right)\\right)</span>  vote strongly in favour of z against x, for any  <span class="math">z\\in L_{n&#x27;}</span> , and that by definition there are at least n' such votes at time  <span class="math">t_x</span> . Consequently, we can apply the result of Corollary 23 with respect to the following parameters:  <span class="math">v=pub,\\ t=t_x,\\ X=</span>  the leaf-blocks of  <span class="math">L_{n&#x27;},\\ Y=\\{x\\},\\ g:=n&#x27;,\\ n_x:=n_j,\\ \\text{and}\\ l&#x27;=\\max_{z\\in G_{t_x}^{oracle}\\cap honest}\\left\\{\\left|future_a\\left(z,G_{t_x}^{oracle}\\right)\\right|-\\left|future_h\\left(z,G_{t_x}^{oracle}\\right)\\right|\\right\\}</span> , to obtain:</p>

    <p class="text-gray-300"><span class="math">$\\Pr(A_{n&#x27;}) = \\Pr(\\exists z \\in L_{n&#x27;} : z \\in X_{win}(x, G_t^v)) \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr(\\exists s &gt; t_x, \\exists z \\in L_{n&#x27;} : z \\in X_{win}(x, G_s^v)) \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$f_{post\\_mine}(n_j, n&#x27;, l&#x27;).</span>$</p>

    <p class="text-gray-300">As the value of l' is unknown to us, we use Lemma 24 to conclude that with probability  <span class="math">\\geq 1 - f_{pre\\_mine}(l)</span>  its value is at most l. Fix  <span class="math">l = \\sqrt{n_j}</span> . Similarly, the value of n' is unknown to us. However, blocks in  <span class="math">\\overline{anticone_h}\\left(z_e, G_t^{oracle}\\right)</span>  are created in the time interval  <span class="math">[time(z_e), time(z_e) + d]</span>  (by its choice), hence  <span class="math">|\\overline{anticone_h}\\left(z_e, G_t^{oracle}\\right)|</span>  is a Poisson variable with parameter  <span class="math">(1 - \\alpha) \\cdot \\lambda \\cdot d</span> . We thus conclude that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(\\left\\{\\left|anticone_{h}\\left(x,G_{t}^{oracle}\\right)\\right| &gt; gap\\left(x,G\\right) + n_{j}\\right\\}\\right) \\leq f_{pre\\_mine}\\left(\\sqrt{n_{j}}\\right) + \\sum_{h&#x27;=0}^{\\infty} \\mathcal{P}_{oiss}((1-\\alpha) \\cdot \\lambda \\cdot d, h&#x27;) \\cdot f_{post\\_mine}\\left(n_{j}, n_{j} - h&#x27; + 1, \\sqrt{n_{j}}\\right) = f_{pre\\_pub}(n_{j}).</span>$</p>

    <p class="text-gray-300">It is easy to verify that  <span class="math">f_{post\\_mine}\\left(n_j, n_j - h&#x27; + 1, \\sqrt{n_j}\\right)</span>  decreases exponentially (we do this in fact in subsequent lemmas). Therefore:</p>

    <p class="text-gray-300"><strong>Lemma 32.</strong>  <span class="math">f_{pre\\_pub}(n_j) \\leq C_j \\cdot e^{-B_j \\cdot n_j}</span>  for some positive constants  <span class="math">B_j, C_j</span> .</p>

    <p class="text-gray-300">In the lemma below,  <span class="math">oracle^u</span>  is a (hypothetical) node such that  <span class="math">G_s^{oraclej} := G_s^u \\cup (G_s^{oracle} \\cap malicious)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 18.</strong> Conditioned on the event  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span> , there exists a time  <span class="math">\\tau\\in[t,\\infty)</span>  such that  <span class="math">\\forall s\\geq \\tau\\colon M(oracle^u,s)\\geq \\left|future_a\\left(x,G_s^{oracle^u}\\right)\\cap G_{[t,s]}^{oracle}\\setminus V_{x\\prec y}(G_s^{oracle^u})\\right|-m^*</span> , for some  <span class="math">m^*</span>  that remains fixed after  <span class="math">\\tau</span>  (and with  <span class="math">\\mathbb{E}[m^*]</span>  determined by the events up to time t).</p>

    <p class="text-gray-300">Proof. Part 1: If  <span class="math">y \\notin G_s^{oracle^u}</span>  then  <span class="math">M(oracle^u,s) = 0</span>  (line 6),  <span class="math">V_{x \\prec y}(G_s^{oracle^u}) = future(x,G_s^{oracle^u})</span> , and the required inequality follows trivially. Assume  <span class="math">y \\in G_s^{oracle^u}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\hat{G}</span>  be any block DAG that equals the past-set of some (possibly virtual) block. Observe that conditioned on  <span class="math">\\widehat{\\mathcal{E}}^{all}_{t\\to\\infty}(x,y)</span> , for some constant  <span class="math">C_t</span>  determined at time t, if  <span class="math">\\left|G_{[t,s]}\\cap malicious\\right| - \\left|G_{[t,s]}^{oracle^u}\\cap honest\\right| &lt; -C_t</span>  then  <span class="math">vote_{x,y}\\left(virtual\\left(G\\right)\\right) = -1</span> . This follows from the proof of Lemma 14: We take the LHS of (17), replace g by  <span class="math">\\sum_{z&#x27;\\in future(x,G_t)}vote_{x,y}\\left(z&#x27;,G\\right)</span> , and observe that the value of the remaining term  <span class="math">2\\cdot\\left|anticone_h\\left(z_{late},G_{time(z_{late})}^{oracle^u}\\right)\\right| - \\left|future_h\\left(z,G_{time(z_{late})}^{oracle^u}\\right)\\right| + \\left|future_a\\left(z,G_{time(z_{late})}^{oracle^u}\\right)\\right| + \\left|anticone_h\\left(z_{late},G_{[time(z_{late}),time(z_{late})+d]}^{oracle^u}\\right)\\right| + \\left|future_a\\left(z_{late},G_t^{oracle^u}\\right)\\setminus future_a\\left(x,G_t^v\\right)\\right|</span>  is determined by time t, hence we can denote it  <span class="math">C_t</span> .</p>

    <p class="text-gray-300">Let  <span class="math">z \\in future\\left(x,G_{t,s}^{oracle}\\right)</span> . By the conditioning on  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span> ,  <span class="math">z \\in malicious</span> . Fix the DAG  <span class="math">G^z := past\\left(z\\right)</span> . The above argument holds in particular for  <span class="math">G^z</span> : If  <span class="math">\\left|G_{[t,s]}^z \\cap malicious\\right| - \\left|G_{[t,s]}^z \\cap honest\\right| &lt; -C_t</span>  then  <span class="math">vote_{x,y}\\left(z\\right) = vote_{x,y}\\left(virtual\\left(past\\left(z\\right)\\right)\\right) = -1</span>  (since z is a</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;18</sup>We write here  <span class="math">G_{[t,s]}^z</span>  for  <span class="math">G^z \\cap before(s) \\setminus before(t)</span> .</p>

    <p class="text-gray-300">strong voter we do not need to specify the context of its vote). Consequently, if  <span class="math">z \\in G_{t,s}^{oracle}</span>  <span class="math">V_{x \\prec y}\\left(G_{s}^{oracle}\\right) \\text{ then } \\left|G_{[t,time(z)]}^{z} \\cap malicious\\right| - \\left|G_{[t,time(z)]}^{z} \\cap honest\\right| \\geq -C_{t}.^{19}</span>  We arrive at the following important implication: If  <span class="math">z \\in future\\left(x,G_{s}^{oracle^{u}}\\right) \\setminus V_{x \\prec y}\\left(G_{s}^{oracle^{u}}\\right)</span></p>

    <p class="text-gray-300">then:</p>

    <p class="text-gray-300"><span class="math">$\\left|anticone\\left(z, G_s^{pub}\\right)\\right| \\ge \\left|anticone\\left(z, G_{time(z)}^{pub}\\right)\\right| \\ge</span>$
(57)</p>

    <p class="text-gray-300"><span class="math">$\\left|anticone\\left(z, G_{time(z)}^{pub}\\right) \\setminus G_{t}^{oracle}\\right| = \\tag{58}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left| G_{time(z)}^{pub} \\setminus G_{t}^{oracle} \\right| - \\left| \\overline{past} \\left( z \\right) \\setminus G_{t}^{oracle} \\right| \\ge</span>$
(59)</p>

    <p class="text-gray-300"><span class="math">$\\left| G_{time(z)}^{pub} \\cap honest \\setminus G_{t}^{oracle} \\right| - G_{[t,time(z)]}^{z} \\cap honest \\ge</span>$
(60)</p>

    <p class="text-gray-300"><span class="math">$\\left| G_{[t,time(z)]}^{pub} \\cap honest \\right| - G_{[t,time(z)]}^{z} \\cap malicious - C_{t}. \\tag{61}</span>$</p>

    <p class="text-gray-300"><strong>Part II:</strong> Let  <span class="math">z_1, z_2, ...</span>  the order of creation of blocks in  <span class="math">future_a\\left(x, G_s^{oracle^u} \\setminus G_t^{oracle}\\right) \\setminus V_{x \\prec y}\\left(G_s^{oracle^u}\\right)</span> . Fix  <span class="math">z_m</span> , and let  <span class="math">b_m</span>  be the earliest block in  <span class="math">anticone_h\\left(z_m, future\\left(x, G_s^{oracle^u}\\right)\\right)</span> . With probability  <span class="math">\\mathcal{P}_{oiss}(d \\cdot (1 - \\alpha) \\cdot \\lambda, h&#x27;)</span> ,  <span class="math">\\left|anticone_h\\left(b_m,G_{\\infty}^{pub}\\right)\\right|=h&#x27;</span> . By the choice of  <span class="math">b_m</span>  together with (57) we obtain:</p>

    <p class="text-gray-300">$$\\left|future_{h}\\left(b_{m}, G_{time(z_{m})}^{pub}\\right)\\right| =
\\left|anticone_{h}\\left(z_{m}, G_{time(z_{m})}^{pub}\\right) \\setminus anticone_{h}\\left(b_{m}, G_{time(z_{m})}^{pub}\\right)\\right| \\geq
\\left|anticone_{h}\\left(z_{m}, G_{time(z_{m})}^{pub}\\right)\\right| - \\left|anticone_{h}\\left(b_{m}, G_{time(z_{m})}^{pub}\\right)\\right| \\geq
\\left|G_{[t,time(z_{m})]}^{pub} \\cap honest\\right| - \\left|G_{[t,time(z_{m})]}^{z_{m}} \\cap malicious\\right| - C_{t} - h' =
\\left|G_{[t,time(z_{m})]}^{pub} \\cap honest\\right| - m - C_{t} - h',$$
(62)</p>

    <p class="text-gray-300">where we used the fact that  <span class="math">past(b_m) \\cap anticone_h(z_m) = \\emptyset</span> , by the choice of  <span class="math">b_m</span> , and that  <span class="math">anticone_h\\left(z_m,G^{pub}_{time(z_m)}\\right) = antipast_h\\left(z_m,G^{pub}_{time(z_m)}\\right)</span> .</p>

    <p class="text-gray-300"><strong>Part III:</strong> Given m,  <span class="math">G_{[t,time(z_m)]}^{pub} \\cap honest</span>  is distributed according to a negative binomial distribution:  <span class="math">\\Pr\\left(\\left|G_{[t,time(z_m)]}^{pub} \\cap honest\\right| = n\\right) = \\binom{n+m-1}{n} \\cdot (1-\\alpha)^n \\cdot \\alpha^m</span> . We claim that the probability that the honest block is a simple state of the probability that the honest block is a simple state of the honest block is a simple state of the probability that the honest block is a simple state of the probability that the honest block is a simple state of the probability that the honest block is a simple state of the probability of the probability that the honest block is a simple state of the probability that the honest block is a simple state of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probability of the probabili the probability that the honest block  <span class="math">b_m</span>  will ever be preceded by  <span class="math">z_m</span>  in the order of  <span class="math">virtual\\left(\\langle G_s^{oracle^u}, z_m, K \\rangle\\right)</span>  is at most</p>

    <p class="text-gray-300"><span class="math">$\\sum_{l=0}^{\\infty} \\pi(l) \\cdot \\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}(5 \\cdot d \\cdot (1-\\alpha) \\cdot \\lambda, k) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot (1-\\alpha) \\cdot \\lambda, h) \\cdot \\sum_{h=0}^{\\infty} \\binom{n+m-1}{m} \\cdot (1-\\alpha)^n \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n-m-K-2\\cdot h-C_t-k-l)^+}.</span>$
(63)</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>Note that  <span class="math">G^z</span>  contains only blocks created up to time(z).</p>

    <p class="text-gray-300">This follows from a similar analysis to that made in the proof of Lemma 14 and of Corollary 23. Indeed, at  <span class="math">time(z_m)</span>  there were at least  <span class="math">n-m-h&#x27;-C_t</span>  blocks in  <span class="math">future(b_m)\\setminus \\overline{future}(z_m)</span> , by the above lower bound on  <span class="math">\\left|future_h\\left(b_m,G_{time(z_m)}^{pub}\\right)\\right|</span> ; and while  <span class="math">future_a\\left(b_m,G_{time(z_m)}^{pub}\\right)=\\emptyset</span> , as  <span class="math">b_m\\notin past(z_m)</span> , there are additional K hypothetical blocks that vote  <span class="math">y\\prec x</span> , by the construction of  <span class="math">\\langle G_s^{oracle^u},z_m,K\\rangle</span> . Instead of reducing h' in the exponent (as in the bound given in Corollary 23), we added  <span class="math">2\\cdot d\\cdot (1-\\alpha)\\cdot \\lambda</span>  to the variable k, as the sum of Poisson variables is a Poisson variable. Finally, we use the result of Lemma 24 to ensure that  <span class="math">\\pi(l)</span>  upper bounds the distribution over l, l0</p>

    <p class="text-gray-300">As  <span class="math">dist\\_gap(G_s^{oracle^u}, z_m) \\leq K</span>  requires  <span class="math">z_m</span>  to precede  <span class="math">b_m</span>  in the order of  <span class="math">virtual\\left(\\langle G_s^{oracle^u}, z_m, K \\rangle\\right)</span> , (63) serves as an upper bound also to the probability that  <span class="math">dist\\_gap(G_s^{oracle^u}, z_m) \\leq K</span> .</p>

    <p class="text-gray-300"><strong>Part IV:</strong> Using Lemma 25 it is easy to verify the existence of constants a, b, and W such that  <span class="math">\\Pr(k+l+2\\cdot h&gt;W)\\leq e^{-a\\cdot W+b}</span> .</p>

    <p class="text-gray-300">Put  <span class="math">K(oracle^u, s) = \\sqrt{|future(x, G_s^{oracle^u})|}</span> . The block  <span class="math">z_m</span>  is counted into  <span class="math">M(oracle^u, s)</span>  in line 9 of Algorithm 3 whenever  <span class="math">dist\\_gap(G_s^{oracle^u}, z_m) &gt; K(oracle^u, s)</span> . From (63) we conclude that the probability that  <span class="math">z_m</span>  does <em>not</em> increment by 1 the value of  <span class="math">M(oracle^u, s)</span>  is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left(dist\\_gap(G_s^{oracle^{u}}, z_m) \\leq K(oracle^{u}, s)\\right) \\leq</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum_{n=0}^{\\infty} \\binom{n+m-1}{m} \\cdot (1-\\alpha)^n \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n-m-K(oracle^{u}, s)-W-C_t)^+} &lt;</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{-W-C_t-K(oracle^{u}, s)} \\cdot \\sum_{n=0}^{\\infty} \\binom{n+m-1}{n} \\cdot (1-\\alpha)^n \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(n-m)^+} =</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{-W-C_t-K(oracle^{u}, s)} \\cdot \\left(\\Pr_{n\\sim Z(m, 1-\\alpha)}(n&gt;m) + \\Pr_{n\\sim Z(m, \\alpha)}(n\\leq m)\\right),</span>$</p>

    <p class="text-gray-300"><span class="math">$(64)</span>$</p>

    <p class="text-gray-300">where Z(n, p) denotes a negative binomial random variable.</p>

    <p class="text-gray-300">We now aim at showing that the last term is upper bounded by some  <span class="math">e^{-D \\cdot m}</span> . The proof is very similar to that given in Lemma 19 below.</p>

    <p class="text-gray-300"><strong>Part V:</strong> For large enough m's, a variable distributed according to  <span class="math">Z(1-\\alpha,m)</span>  converges to a normal variable with mean  <span class="math">m \\cdot \\frac{\\alpha}{1-\\alpha}</span>  and variance  <span class="math">m \\cdot \\frac{\\alpha}{(1-\\alpha)^2}</span> . The second multiplicand in (66)</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{20}&lt;/sup&gt;l \\text{ here represents } \\max_{z \\in G_{time(b_m)}^{oracle} \\cap honest} \\Big\\{ \\Big| future_a\\left(z, G_{time(b_m)}^{oracle^u}\\right) \\Big| - \\Big| future_h\\left(z, G_{time(b_m)}^{oracle^u}\\right) \\Big| \\Big\\}.</span></p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{21}&lt;/sup&gt;</span> We rely here on the assumption specified in the proof of Lemma 14 according to which, in the worst case, after time t the attacker publishes all his blocks to all nodes immediately after their creation.</p>

    <p class="text-gray-300">thus converges, as m grows, to</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\le \\frac{m - \\frac{1-\\alpha}{\\alpha} \\cdot m}{\\sqrt{\\frac{1-\\alpha}{\\alpha^2} \\cdot m}} \\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{m - \\frac{\\alpha}{1-\\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot m}} \\right) = \\tag{67}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{\\frac{1-\\alpha}{\\alpha} \\cdot m - m}{\\sqrt{\\frac{1-\\alpha}{\\alpha^2} \\cdot m}} \\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{m - \\frac{\\alpha}{1-\\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot m}} \\right). \\tag{68}</span>$</p>

    <p class="text-gray-300">The following inequality is due to Komatu (1955). Let  <span class="math">x \\geq 0</span>  and let  <span class="math">z \\sim \\mathcal{N}(0,1)</span> . Then:  <span class="math">\\Pr\\left(z &gt; x\\right) \\leq \\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x^2/2}}{x + \\sqrt{2 + x^2}}</span> . Put  <span class="math">x_1 := \\frac{\\frac{1 - 2 \\cdot \\alpha}{\\alpha} \\cdot m}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot m}}</span>  and  <span class="math">x_2 := \\frac{\\frac{1 - 2 \\cdot \\alpha}{1 - \\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot m}}</span> . We obtain an upper bound on (68):</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x_1^2/2}}{x_1 + \\sqrt{2 + x_1^2}} + \\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x_2^2/2}}{x_2 + \\sqrt{2 + x_2^2}} \\le \\tag{69}</span>$</p>

    <p class="text-gray-300"><span class="math">$C_1 \\cdot e^{-x_1^2/2} + C_2 \\cdot e^{-x_2^2/2} = C_1 \\cdot e^{-D_1 \\cdot m} + C_2 \\cdot e^{-D_2 \\cdot m} \\le C_3 \\cdot e^{-D_3 \\cdot m}</span>$</p>

    <p class="text-gray-300"><span class="math">$(70)</span>$</p>

    <p class="text-gray-300">for some positive constants  <span class="math">C_i, D_i</span>  that depend on  <span class="math">\\alpha</span>  (a property which applies to the constants below as well).</p>

    <p class="text-gray-300">When this term is multiplied by  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{-W-C_t-K(oracle^u,s)}</span>  we obtain</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{-W-C_t-K(oracle^u,s)} \\cdot C_3 \\cdot e^{-D_3 \\cdot m} \\le \\tag{71}</span>$</p>

    <p class="text-gray-300"><span class="math">$C_4 \\cdot e^{-D_3 \\cdot m + D_4 \\cdot K(oracle^u, s)} = C_4 \\cdot e^{-D_3 \\cdot m + D_4 \\cdot \\sqrt{|future(x, G_s^{oracle^u})|}}.</span>$
(72)</p>

    <p class="text-gray-300">There exists therefore an  <span class="math">M_1</span>  such that if  <span class="math">m &gt; \\left|future\\left(x,G_s^{oracle^u}\\right)\\right| &gt; M_1</span>  then the last expression is upper bounded by  <span class="math">C_5 \\cdot e^{-D_5 \\cdot m}</span>  for some  <span class="math">C_5,D_5</span> .</p>

    <p class="text-gray-300"><strong>Part VI:</strong> After some  <span class="math">\\psi</span>  (with expected value  <span class="math">M_1/\\lambda</span> ), the condition  <span class="math">|future(x, G_s^{oracle^u})| \\geq</span></p>

    <p class="text-gray-300"><span class="math">M_1</span>  is satisfied. Put  <span class="math">s_m:=time(z_m)</span>  and assume  <span class="math">s_m\\geq \\psi</span> . As  <span class="math">\\sum_{m=\\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}+1}C_5\\cdot e^{-D_5\\cdot m}&lt;\\infty</span> , Fatou's lemma implies that there exists (a.s.) an  <span class="math">m^* &gt; \\sqrt{\\left|future\\left(x, G_{s_m}^{oracle^u}\\right)\\right|}</span>  such that for all  <span class="math">m \\ge m^*</span> ,  <span class="math">dist\\_gap(z_m) &gt; K(oracle^u, s_m)</span> . The expected waiting time for  <span class="math">z_{m^*}</span>  is finite.<sup>22</sup> Define  <span class="math">\\tau = \\max\\{\\psi, time(z_{m^*})\\}</span> . Then, for any</p>

    <p class="text-gray-300"><sup>22</sup>We have  <span class="math">\\Pr(m^* \\ge r) \\le \\sum_{m=\\sqrt{|future(x,G_s^{oracle^u})|}+1}^{r-1} C_5 \\cdot e^{-D_5 \\cdot m}</span> . Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}\\left[m^*\\right] \\leq \\sum_{r=\\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}+1}^{\\infty} \\sum_{m=\\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}+1}^{r-1} C_5 \\cdot e^{-D_5 \\cdot m} = \\sum_{m=\\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}+1}^{\\infty} C_6 \\cdot e^{-D_6 \\cdot m} \\leq \\sum_{m=\\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}+1}^{\\infty} C_6 \\cdot e^{-D_6 \\cdot m} \\leq C_7 \\cdot e^{-D_7 \\cdot \\sqrt{\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|}}.</span>$</p>

    <p class="text-gray-300"><span class="math">$s \\ge \\tau</span>$
:  <span class="math">M(oracle^u, s) \\ge \\left| future_a\\left(x, G_s^{oracle^u}\\right) \\cap G_{[t,s]}^{oracle} \\setminus V_{x \\prec y}(G_s^{oracle^u}) \\right| - m^*.^{23}</span></p>

    <p class="text-gray-300"><strong>Lemma 19.</strong> There exists a  <span class="math">\\psi \\in [t, \\infty)</span>  such that  <span class="math">\\Pr\\left(\\mathcal{E}_{t\\to\\infty}^{all}(x,y,\\epsilon)^{\\complement} \\mid \\mathcal{E}_{t}^{v}(x,y,\\epsilon)\\right) &lt; \\epsilon</span> . Moreover,  <span class="math">\\mathbb{E}\\left[\\psi - t\\right] &lt; \\epsilon.</span></p>

    <p class="text-gray-300"><em>Proof.</em> Part 1: We show that if all honest blocks vote in favour of x then all error functions converge to zero. Indeed, the event  <span class="math">\\mathcal{E}^v_t(x,y,\\epsilon)</span>  implies that  <span class="math">f_{pre\\_mine}(l\\left(G^v_t\\right))</span>  +  <span class="math">f_{pre\\_pub}\\left(n_{j}\\left(G_{t}^{v}\\right)\\right)+f_{post\\_pub}\\left(\\left|future\\left(x,G_{t}^{v}\\right)\\right|\\right)+f_{post\\_mine}\\left(n_{x}\\left(G_{t}^{v}\\right),g\\left(G_{t}^{v}\\right),l\\left(G_{t}^{v}\\right)\\right)&lt;\\epsilon.</span>  By the union bound, and by Lemmas 24, 29, and 31 respectively, the following relations hold with probability  <span class="math">\\geq 1 - \\epsilon</span> :</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><span class="math">\\max_{z \\in G_t^{oracle} \\cap honest} \\left\\{ \\left| future_a\\left(z, G_{time(x)}^{oracle}\\right) \\right| \\left| future_h\\left(z, G_{time(x)}^{oracle}\\right) \\right| \\right\\} \\le l\\left(G_t^v\\right)</span>   <span class="math">\\left| future_h\\left(x, G_t^v\\right) \\right| \\le n_x</span>   <span class="math">\\left| anticone_h\\left(x, G_t^{oracle}\\right) \\right| \\le gap\\left(x, G\\right) + n_j =: j</span></li>
    </ul>

    <p class="text-gray-300">Conditioned on these relations, by Corollary 17 the event  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span>  occurs w.p.  <span class="math">\\geq 1-f_{post\\_mine}\\left(n_x\\left(G_t^v\\right),g\\left(G_t^v\\right),l\\left(G_t^v\\right)\\right)</span> . All in all, conditioned on  <span class="math">\\mathcal{E}_t^v(x,y,\\epsilon)</span> , the event  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span> occurs w.p.  <span class="math">\\geq 1 - \\epsilon</span> .</p>

    <p class="text-gray-300"><strong>Part II:</strong> We proceed to show that, conditioned on  <span class="math">\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span>  and on the above relations, the value of  <span class="math">Risk(G_s^u, x, y)</span>  goes (almost surely) to 0 as time develops, for all  <span class="math">u \\in honest.^{24}</span></p>

    <p class="text-gray-300">That  <span class="math">f_{pre\\_mine}(l\\left(G_{s}^{u}\\right)) + f_{pre\\_pub}\\left(n_{j}\\left(G_{s}^{u}\\right)\\right) + f_{post\\_pub}\\left(\\left|future\\left(x,G_{s}^{u}\\right)\\right|\\right)</span>  goes to 0 as s grows follows immediately from Lemmas 25, 32, and 30. Let  <span class="math">\\epsilon_0 &gt; 0</span> . We now prove that after some  <span class="math">\\tau</span>  of finite expectation,  <span class="math">f_{post\\_mine}\\left(n_x\\left(G_s^u\\right), g\\left(G_s^u\\right), l\\left(G_s^u\\right)\\right) &lt; \\epsilon_0</span> .</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">$M(oracle^{u}, s) + g(oracle^{u}, s) - n_{x}(oracle^{u}, s) \\ge -2 \\cdot \\left| G_{[time(x), t]}^{oracle} \\right| - m^{*}</span>$
(73)</p>

    <p class="text-gray-300">where  <span class="math">m^*</span>  is the variable described in Lemma 18. Assume first that  <span class="math">malicious \\cap G_s^{oracle} \\subseteq</span>  <span class="math">G_s^{oracle^u}</span> . Let us decompose  <span class="math">future\\left(x,G_s^{oracle^u}\\right)</span>  as follows:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">Blocks in  <span class="math">G_{[time(x),t]}^{oracle}</span> . Clearly, the number of blocks in this set does not grow with s. Their contribution is lower bounded by  <span class="math">-2 \\cdot \\left| G_{[time(x),t]}^{oracle} \\right|</span> .</p>

    <p class="text-gray-300">&bull; Blocks in  <span class="math">V_{x \\prec y}(G_s^{oracle^u}) \\setminus G_t^{oracle}</span> : Every z in this set adds (+1) to  <span class="math">g(oracle^u,s)</span> . As</p></li>
      <li><p class="text-gray-300">z cannot decrement the value of  <span class="math">M(oracle^u, s) n_x(oracle^u, s)</span>  by more than 1, the contribution of this set is at least 0. 25</p></li>
    </ul>

    <p class="text-gray-300">The expected waiting time for  <span class="math">z_{m^*}</span>  is the last term divided by  <span class="math">\\alpha \\cdot \\lambda</span> .</p>

    <p class="text-gray-300"><sup>23</sup>Note that  <span class="math">\\mathbb{E}[m^*]</span>  is determined by the events up to time t: take the expected value of the expression in the previous proof, where the distribution over the values of  <span class="math">\\left|future\\left(x,G_{s_m}^{oracle^u}\\right)\\right|</span>  (and of the  <span class="math">s_m</span> 's themselves) is conditioned on  <span class="math">\\left|future\\left(x,G_t^{oracle^u}\\right)\\right|</span>  (for the  <span class="math">oracle^u</span>  which maximizes the expected value).</p>

    <p class="text-gray-300"><sup>24</sup>In fact, we need to show that  <span class="math">\\max \\{Risk(G_s^u, x, y)\\}</span>  goes to 0. However, since our analysis below takes the worst case regarding u, namely, that messages from it and to it arrive at a delay of precisely d, these events are equivalent in the worst case, and thus we will relate to u as a fixed honest node.</p>

    <p class="text-gray-300"><sup>25</sup>In fact, by the conditioning on the relation  <span class="math">|future_h(x,G_v^v)| \\leq n_x</span> , we know that all honest blocks belong to this category, hence we can arrive at a tighter bound:  <span class="math">M(oracle^u, s) + g(oracle^u, s) - n_x(oracle^u, s) \\ge 1</span>  <span class="math">-\\left|G_{[time(x),t]}^{oracle} \\cap malicious\\right| - m^*.</span></p>

    <p class="text-gray-300">&bull; Blocks in  <span class="math">G_s^{oracle^u} \\setminus \\left(V_{x \\prec y}(G_s^{oracle^u}) \\cup G_t^{oracle}\\right)</span> : Lemma 18 guarantees that, conditioned on the event  <span class="math">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)</span> , at least  <span class="math">\\left|future_a\\left(x,G_s^{oracle^u}\\right) \\cap G_{[t,s]}^{oracle}\\right| - m^*</span>  of the blocks that are published after some  <span class="math">\\tau</span>  and that do not belong to  <span class="math">V_{x \\prec y}(G_s^{oracle^u})</span>  - hence that add (-1) to  <span class="math">g(oracle^u,s)^{26}</span>  - add (+1) to the value of  <span class="math">M(oracle^u,s)</span> . In other words, at most  <span class="math">m^*</span>  blocks from the set  <span class="math">future_a\\left(x,G_s^{oracle^u}\\right) \\cap G_{[t,s]}^{oracle} \\setminus V_{x \\prec y}(G_s^{oracle^u})</span>  add (-1) to  <span class="math">g(oracle^u,s)</span>  and are not canceled out by a (+1) increment to the value of  <span class="math">M(oracle^u,s)</span> . The contribution of this set is therefore lower bounded by  <span class="math">-m^*</span> .</p>

    <p class="text-gray-300">Part III: We now claim that</p>

    <p class="text-gray-300"><span class="math">$M\\left(G_{s}^{u}\\right)+g\\left(G_{s}^{u}\\right)-n_{x}\\left(G_{s}^{u}\\right)\\geq-2\\cdot\\left|G_{\\left[time\\left(x\\right),t\\right]}^{oracle}\\right|-m^{*}\\tag{74}</span>$</p>

    <p class="text-gray-300">Indeed, let C(z) be the contribution of z to (73) and let c(z) be its contribution to (74). First,  <span class="math">C(z) \\geq -2</span> , hence the contribution of all  <span class="math">z \\in G_{[time(x),t]}^{oracle}</span>  is at least  <span class="math">-2 \\cdot \\left| G_{[time(x),t]}^{oracle} \\right|</span> , as previously.</p>

    <p class="text-gray-300">Assume that  <span class="math">z \\in G_s^{oracle^u} \\setminus G_t^{oracle}</span>  and that it votes  <span class="math">x \\prec y</span> . Then z is not counted into  <span class="math">M(oracle^u, s)</span> , hence its contribution to  <span class="math">M(oracle^u, s) + g(oracle^u, s) - n_x(oracle^u, s)</span>  is 0 + 1 - 1 = 0, i.e., c(z) = 0. And for the same argument C(z) = 0.</p>

    <p class="text-gray-300">Assume that  <span class="math">z \\in G_s^{oracle^u} \\setminus G_t^{oracle}</span>  and that it votes  <span class="math">y \\prec x</span> . Then  <span class="math">z \\in malicious</span>  (by the conditioning on  <span class="math">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)</span> ). In the analysis of Lemma 18 we assumed the following worst case: that for any three blocks  <span class="math">v,z,w \\in G_s^{oracle^u}</span> , such that  <span class="math">v,z \\in malicious</span>  and  <span class="math">w \\in honest</span> , v votes strongly for  <span class="math">z \\prec w</span> .<sup>27</sup> Under this worst case assumption regarding the votes of attacker blocks,  <span class="math">dist\\_gap(z,G_s^{oracle^u}) \\leq dist\\_gap(z,G_s^u)</span> , as  <span class="math">G_s^{oracle^u} \\setminus G_s^u</span>  contains only attacker blocks. Thus, if z was counted in  <span class="math">M(oracle^u,s)</span>  then it is counted also in  <span class="math">M(G_s^u)</span> ; in particular,  <span class="math">C(z) \\geq c(z)</span> . Consequently, using the analysis from Lemma 18,</p>

    <p class="text-gray-300"><span class="math">$-m^* \\leq \\sum_{z \\in G_s^{oracle^u} \\backslash G_t^{oracle}} c(z) \\leq \\sum_{z \\in G_s^{oracle^u} \\backslash (G_t^{oracle} \\cup V_{x \\prec y}(G_s^{oracle^u}))} c(z) = \\sum_{z \\in G_s^{oracle^u} \\backslash (G_t^{oracle} \\cup V_{x \\prec y}(G_s^{oracle^u}))} c(z) + \\sum_{z \\in G_s^{oracle^u} \\backslash (G_s^{oracle} \\cup V_{x \\prec y}(G_s^{oracle^u}))} c(z) \\leq \\sum_{z \\in G_s^{u} \\backslash (G_t^{oracle} \\cup V_{x \\prec y}(G_s^{oracle^u}))} c(z).</span>$</p>

    <p class="text-gray-300">All in all,
<span class="math">$M\\left(G_{s}^{u}\\right)+g\\left(G_{s}^{u}\\right)-n_{x}\\left(G_{s}^{u}\\right)\\geq-2\\cdot\\left|G_{\\left[time\\left(x\\right),t\\right]}^{oracle}\\right|-m^{*}.</span>$</p>

    <p class="text-gray-300"><strong>Part IV:</strong> In the remainder of the proof we occasionally abbreviate  <span class="math">n_{x}\\left(G_{s}^{u}\\right)</span>  and write simply</p>

    <p class="text-gray-300"><strong>Part IV:</strong> In the remainder of the proof we occasionally abbreviate  <span class="math">n_x(G_s^u)</span>  and write simply  <span class="math">n_x</span> , and similarly for the rest of the variables, for convenience. Lemmas 25 and 32 imply further</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;26</sup>They cannot add 0 since only strong voters are counted into these variables.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;27</sup>Indeed, therein we only counted honest voters in favour of honest blocks. This could be formalized using pseudo-votes, as in Lemma 20.</p>

    <p class="text-gray-300">that there exist constants a, b, and W such that  <span class="math">\\Pr(k+l+2\\cdot h+j&gt;W) \\leq e^{-a\\cdot W+b}</span>  (as in the proof of the previous lemma, but not necessarily with the same constants). Take W such that  <span class="math">e^{-a\\cdot W+b} &lt; \\epsilon_0/4</span> . Thus, with probability  <span class="math">\\geq 1 - \\epsilon_0/4</span> :</p>

    <p class="text-gray-300"><span class="math">f_{post\\_mine}\\left(n_{x}\\left(G_{s}^{u}\\right),g\\left(G_{s}^{u}\\right),l\\left(G_{s}^{u}\\right)\\right)=</span></p>

    <p class="text-gray-300"><span class="math">$\\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}(3 \\cdot d \\cdot (1-\\alpha) \\cdot \\lambda, k) \\cdot \\sum_{k=0}^{\\infty} \\mathcal{P}_{oiss}(d \\cdot (1-\\alpha) \\cdot \\lambda, k)</span>$
(75)</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x+j+h+m&#x27;-1}{m&#x27;} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^{m&#x27;}\\right)^{-1}.</span>$
(76)</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=M}^{\\infty} \\binom{n_x+j+h+m-1}{m} \\cdot (1-\\alpha)^{n_x+j+h} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-(m-M))^+}.</span>$
(77)</p>

    <p class="text-gray-300">For large enough  <span class="math">n_x</span> 's, this term is at most  <span class="math">\\epsilon_0/4</span>  away from</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{g+M-n_x-W} \\cdot \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x+m&#x27;-1}{m&#x27;} \\cdot (1-\\alpha)^{n_x} \\cdot \\alpha^{m&#x27;}\\right)^{-1} .</span>$
(78)</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=M}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n_x - m)^+}.</span>$
(79)</p>

    <p class="text-gray-300"><strong>Part V:</strong> As for the first multiplicand of (78), by Part II of this proof, after some  <span class="math">\\tau</span>  of finite expectation:  <span class="math">M\\left(G_s^u\\right)+g\\left(G_s^u\\right)-n_x\\left(G_s^u\\right)\\geq -\\left|G_{[time(x),t]}^{oracle}\\right|-m^*=:D_2</span>  (a constant determined by time  <span class="math">\\tau</span> ). Assume  <span class="math">s\\geq \\tau</span> . We conclude that the term  <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{g+M-n_x-W}</span>  is upper bounded by  <span class="math">e^{D_3\\cdot D_4}</span>  (with  <span class="math">D_3=\\ln\\left(\\frac{1-\\alpha}{\\alpha}\\right)</span> ). Thus, in order to show that (78) vanishes suffice it to show that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x + m&#x27; - 1}{m&#x27;} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^{m&#x27;}\\right)^{-1}.</span>$
(80)</p>

    <p class="text-gray-300"><span class="math">$\\sum_{m=M}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n_x - m)^+}</span>$
(81)</p>

    <p class="text-gray-300">vanishes.</p>

    <p class="text-gray-300">The last term equals</p>

    <p class="text-gray-300"><span class="math">$\\left(\\Pr_{m \\sim Z(1-\\alpha, n_x)} \\left(m \\ge M\\right)\\right)^{-1} \\cdot \\left(\\Pr_{m \\sim Z(\\alpha, n_x)} \\left(m \\le n_x\\right) + \\Pr_{m \\sim Z(1-\\alpha, n_x)} \\left(m \\ge n_x\\right)\\right).</span>$
(82)</p>

    <p class="text-gray-300">For large enough  <span class="math">n_x</span> 's, a variable distributed according to  <span class="math">Z(1-\\alpha,n_x)</span>  converges to a normal variable with mean  <span class="math">n_x \\cdot \\frac{\\alpha}{1-\\alpha}</span>  and variance  <span class="math">n \\cdot \\frac{\\alpha}{(1-\\alpha)^2}</span> . The last term is therefore at most  <span class="math">\\epsilon_0/4</span> away from</p>

    <p class="text-gray-300"><span class="math">$\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{M - \\frac{\\alpha}{1-\\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot n_x}} \\right) \\right)^{-1} .</span>$
(83)</p>

    <p class="text-gray-300"><span class="math">$\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\le \\frac{n_x - \\frac{1-\\alpha}{\\alpha} \\cdot n_x}{\\sqrt{\\frac{1-\\alpha}{\\alpha^2} \\cdot n_x}} \\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{n_x - \\frac{\\alpha}{1-\\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot n_x}} \\right) \\right) =</span>$
(84)</p>

    <p class="text-gray-300"><span class="math">$\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{M - \\frac{\\alpha}{1-\\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot n_x}} \\right) \\right)^{-1} .</span>$
(85)</p>

    <p class="text-gray-300"><span class="math">$\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{\\frac{1-\\alpha}{\\alpha} \\cdot n_x - n_x}{\\sqrt{\\frac{1-\\alpha}{\\alpha^2} \\cdot n_x}} \\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left( z \\ge \\frac{n_x - \\frac{\\alpha}{1-\\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1-\\alpha)^2} \\cdot n_x}} \\right) \\right).</span>$
(86)</p>

    <p class="text-gray-300">We use the following inequalities due to Komatu (1955), for  <span class="math">x \\ge 0</span> , and a standard normal variable  <span class="math">z \\sim \\mathcal{N}(0,1)</span> :  <span class="math">\\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x^2/2}}{x + \\sqrt{4 + x^2}} \\le \\Pr\\left(z &gt; x\\right) \\le \\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x^2/2}}{x + \\sqrt{2 + x^2}}.</span>  Put  <span class="math">x_1 := \\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}, \\ x_2 := \\frac{1 - \\alpha}{\\sqrt{\\frac{\\alpha}{2^2} \\cdot n_x}}, \\ \\text{and} \\ x_3 := \\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}.</span></p>

    <p class="text-gray-300">Put
<span class="math">$x_1 := \\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}, x_2 := \\frac{\\frac{1 - \\alpha}{\\alpha} \\cdot n_x - n_x}{\\sqrt{\\frac{\\alpha}{0 - \\alpha}^2 \\cdot n_x}}, \\text{ and } x_3 := \\frac{n_x - \\frac{n_x}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{n_x}{(1 - \\alpha)^2} \\cdot n_x}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sqrt{\\pi/2} \\cdot \\left(x_1 + \\sqrt{4 + x_1^2}\\right) \\cdot e^{x_1^2/2} \\cdot \\left(\\frac{1}{\\sqrt{\\pi/2}} \\cdot \\frac{e^{-x_2^2/2}}{x_2} + \\frac{1}{\\sqrt{\\pi/2}} \\cdot \\frac{e^{-x_3^2/2}}{x_3}\\right) = \\tag{87}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left(x_1 + \\sqrt{4 + x_1^2}\\right) \\cdot e^{x_1^2/2} \\cdot \\left(\\frac{e^{-x_2^2/2}}{x_2} + \\frac{e^{-x_3^2/2}}{x_3}\\right) \\tag{88}</span>$</p>

    <p class="text-gray-300">We further observe that, for large  <span class="math">n_x</span> 's:  <span class="math">x_2 \\geq C_2 \\cdot \\sqrt{n_x}</span>  and  <span class="math">x_3 \\geq C_3 \\cdot \\sqrt{n_x}</span> , for some positive constants  <span class="math">C_i</span>  (this applies to all constants below as well). Therefore,  <span class="math">\\frac{\\left(x_1+\\sqrt{4+x_1^2}\\right)}{\\min\\{x_2,x_3\\}} \\leq C_1/\\max\\{C_2,C_3\\} =: D_1</span> . The above term is therefore upper bounded, up to a multiplicative factor of  <span class="math">D_1</span> , by</p>

    <p class="text-gray-300"><span class="math">$e^{x_1^2/2 - x_2^2/2} + e^{x_1^2/2 - x_3^2/2} = e^{0.5 \\cdot \\left(\\left(\\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)^2 - \\left(\\frac{\\frac{1 - \\alpha}{\\alpha} \\cdot n_x - n_x}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot n_x}}\\right)^2\\right)} + e^{0.5 \\cdot \\left(\\left(\\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)^2 - \\left(\\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)^2\\right)} \\le e^{0.5 \\cdot \\left(\\frac{(1 - \\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x\\right)^2 - \\frac{(1 - 2 \\cdot \\alpha)^2}{1 - \\alpha} \\cdot n_x\\right)} + e^{0.5 \\cdot \\left(\\frac{(1 - \\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x\\right)^2 - \\frac{(1 - 2 \\cdot \\alpha)^2}{\\alpha} \\cdot n\\right)}.</span>$
(89)</p>

    <p class="text-gray-300">Conditioned on the relation  <span class="math">\\left|future_h\\left(x,G_t^{oracle}\\right)\\right| \\leq n_x,\\ M \\leq future_a\\left(x,G_s^u\\right)</span> , hence its expected value is at most  <span class="math">\\frac{\\alpha}{1-\\alpha} \\cdot n_x</span> . For any  <span class="math">\\delta&gt;0</span> , by the Strong Law of Large Numbers, after some  <span class="math">\\tau</span>  (of finite expectation),  <span class="math">\\forall s \\geq \\tau: M \\leq (1+\\delta) \\cdot \\mathbb{E}\\left[M\\right] \\leq (1+\\delta) \\cdot \\frac{\\alpha}{1-\\alpha} \\cdot n_x</span> .</p>

    <p class="text-gray-300">Consequently, (89) is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$e^{0.5 \\cdot \\frac{(1-\\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1-\\alpha} \\cdot n_x\\right)^2 - 0.5 \\cdot \\frac{(1-2 \\cdot \\alpha)^2}{1-\\alpha} \\cdot n_x} + e^{0.5 \\cdot \\frac{(1-\\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1-\\alpha} \\cdot n_x\\right)^2 - 0.5 \\cdot \\frac{(1-2 \\cdot \\alpha)^2}{\\alpha} \\cdot n_x} \\le \\tag{90}</span>$</p>

    <p class="text-gray-300"><span class="math">$e^{0.5 \\cdot \\frac{(1-\\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(\\delta \\cdot \\frac{\\alpha}{1-\\alpha} \\cdot n_x\\right)^2 - 0.5 \\cdot \\frac{(1-2\\cdot\\alpha)^2}{1-\\alpha} \\cdot n_x} + e^{0.5 \\cdot \\frac{(1-\\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(\\delta \\cdot \\frac{\\alpha}{1-\\alpha} \\cdot n_x\\right)^2 - 0.5 \\cdot \\frac{(1-2\\cdot\\alpha)^2}{\\alpha} \\cdot n_x} \\le \\tag{91}</span>$</p>

    <p class="text-gray-300"><span class="math">$e^{R_1/n_x - R_2 \\cdot n_x} + e^{R^3/n_x - R_4 \\cdot n_x} &lt; e^{-R_5 \\cdot n_x}, \\tag{92}</span>$</p>

    <p class="text-gray-300">for some positive constants  <span class="math">R_i</span> , where the last inequality holds for large enough  <span class="math">n_x</span> 's, and the preceding inequality holds for small enough  <span class="math">\\delta</span> 's ( <span class="math">\\delta &lt; 1/n_x</span> ).</p>

    <p class="text-gray-300">Taking  <span class="math">n_x</span>  to be greater than  <span class="math">n_x &gt; \\ln \\left(4 \\cdot D_1/\\epsilon_0\\right)/R_5</span>  we conclude that for some large enough  <span class="math">n_x</span> :</p>

    <p class="text-gray-300"><span class="math">$f_{post\\_mine}\\left(n_x\\left(G_s^u\\right), g\\left(G_s^u\\right), l\\left(G_s^u\\right)\\right) &lt; 4 \\cdot \\epsilon_0/4 = \\epsilon_0. \\tag{93}</span>$</p>

    <p class="text-gray-300">(Note that the expected waiting time for the first  <span class="math">\\tau</span>  such that  <span class="math">\\forall j \\in honest : n_x(u, \\psi)</span>  is at least some  <span class="math">n_0</span>  is at most  <span class="math">n_0 \\cdot ((1 - \\alpha) \\cdot \\lambda)^{-1} + d</span> : it is  <span class="math">1/((1 - \\alpha) \\cdot \\lambda)</span>  for the creation of every honest block, and d for the last one to arrive at all nodes.)</p>

    <p class="text-gray-300">The same technique used in the proof of Lemma 19 is used below to prove the Progress property (Proposition 9); indeed, in the proof we see that the term that aggregates all the error functions vanishes as time develops, w.h.p., in the perspective of all honest nodes. In particular, for v (the node that originally  <span class="math">\\epsilon</span> -accepted the transaction), it becomes smaller than  <span class="math">\\epsilon&#x27;</span>  w.h.p. A yet similar usage of this argument is used below to prove Weak Liveness (Proposition 10); indeed, in the latter we only need to regard the case where y=NULL. In this case, all published blocks are strong voters in favour of x, and so we can guarantee the convergence of the error functions without going through Lemma 14 and the analysis that follows.</p>

    <h4 id="sec-misc-30" class="text-lg font-semibold mt-6">G. Proof of Weak Liveness (blocks)</h4>

    <p class="text-gray-300">We've seen that the error functions  <span class="math">f_{pre\\_mine}(l\\left(G_{s}^{u}\\right))</span> ,  <span class="math">f_{pre\\_pub}\\left(n_{j}\\left(G_{s}^{u}\\right)\\right)</span> , and  <span class="math">f_{post\\_pub}\\left(|future\\left(x,G_{s}^{u}\\right)|\\right)</span>  go to zero as s grows. For any  <span class="math">s&lt;\\psi,\\ y\\notin G_{s}^{pub}</span> , hence by line 5 of Algorithm 3,  <span class="math">g\\left(G_{s}^{v}\\right)=|future\\left(x,G\\right)|=n_{x}\\left(G_{s}^{u}\\right)</span> , and  <span class="math">M\\left(G_{s}^{v}\\right)=0</span> . In particular, the relation (73) is satisfied trivially, and the analysis in the proof of Lemma 19 applies, proving that the term  <span class="math">f_{post\\_mine}</span>  vanishes as time grows. In particular, since these functions decrease exponentially, it becomes smaller than  <span class="math">\\epsilon</span>  after a number of honest blocks in the order of  <span class="math">\\mathcal{O}(\\ln(1/\\epsilon))</span>  are created, and the expected waiting time for this is obtained by dividing this number by  <span class="math">(1-\\alpha)\\cdot\\lambda</span>  (and adding d for all honest blocks to receive these blocks).</p>

    <h4 id="sec-misc-31" class="text-lg font-semibold mt-6">H. Proof of Progress (blocks)</h4>

    <p class="text-gray-300">This follows immediately from the proof of Lemma 19, in which it was shown that, conditioned on the event  <span class="math">\\widehat{\\mathcal{E}}_{-\\infty}^{all}t(x,y)</span> ,  <span class="math">f_{pre\\_mine}(l\\left(G_s^v\\right))+f_{pre\\_pub}\\left(n_j\\left(G_s^u\\right)\\right)+f_{post\\_pub}\\left(|future\\left(x,G_t^u\\right)|\\right)+f_{post\\_mine}\\left(n_x\\left(G_s^u\\right),g\\left(G_s^u\\right),l\\left(G_s^u\\right)\\right)</span>  vanishes as s grows indefinitely. In Lemma 14 it was shown that, up to a probability of  <span class="math">\\epsilon</span> , the event  <span class="math">\\mathcal{E}_t^v(x,y,\\epsilon)</span>  is contained in  <span class="math">\\widehat{\\mathcal{E}}_{-\\infty}^{all}t(x,y)</span>  (i.e., when the former is intersected with an event of probability  <span class="math">\\geq 1-\\epsilon</span> ).</p>

    <h4 id="sec-misc-32" class="text-lg font-semibold mt-6">I. Proof of Safety</h4>

    <p class="text-gray-300"><strong>Part I:</strong> Denote by  <span class="math">risk_{acc}(G_s^u, tx, subG)</span>   <span class="math">(risk_{rej})</span>  the output of Algorithm 4 (respectively, Algorithm 5) when given the inputs  <span class="math">G_s^u</span>  (for some honest u), tx, and subG (such that subG is the past of some (possibly virtual) block). For any  <span class="math">z \\in [tx] \\cap subG</span> , denote by  <span class="math">risk_{acc}^z(G_s^u, tx, subG)</span>  the value of the risk variable as the loop in line 2 of RiskTxAccept terminates its run over z. Denote similarly  <span class="math">minrisk_{rej}^z(G_s^u, tx, subG)</span>  w.r.t. the variable minrisk in RiskTxReject.</p>

    <p class="text-gray-300">We claim that, with probability  <span class="math">&gt; 1 - risk_{acc}(G_t^v, tx, subG)</span> , there exists a  <span class="math">\\tau_{acc}</span>  of finite expectation such that for all  <span class="math">s \\ge \\tau_{acc}</span> , for all  <span class="math">u \\in honest</span> , and for all  <span class="math">subG&#x27; \\supseteq subG</span> :</p>

    <p class="text-gray-300"><span class="math">$risk_{acc}(G_t^v, tx, subG) \\ge risk_{acc}(G_s^u, tx, subG&#x27;)</span>$
(94)</p>

    <p class="text-gray-300">Similarly, we claim that, with probability  <span class="math">&gt; 1 - risk_{rej}(G_t^v, tx, subG)</span> , there exists a  <span class="math">\\tau_{rej}</span>  of finite expectation such that for all  <span class="math">s \\ge \\tau_{rej}</span> , for all  <span class="math">u \\in honest</span> :</p>

    <p class="text-gray-300"><span class="math">$risk_{rej}(G_t^v, tx, subG) \\ge risk_{rej}(G_s^u, tx, subG).</span>$
(95)</p>

    <p class="text-gray-300">Assume we have proved this for all subG of size &lt; k. We now prove this for  <span class="math">subG_k</span>  of size k.</p>

    <p class="text-gray-300">By the definition of  <span class="math">risk_{acc}</span> , there exists a  <span class="math">z_{tx} \\in subG_k \\cap [tx]</span>  such that  <span class="math">risk_{acc}(G_t^v, tx, subG&#x27;) = risk_{acc}^{z_{tx}}(G_t^v, tx, subG&#x27;)</span> .</p>

    <p class="text-gray-300"><strong>Part II:</strong> Denote by  <span class="math">Z_2</span>  the set of instantiations of the third-loop-variable  <span class="math">z_2</span> , inside the iteration of the first-loop with  <span class="math">z_1=z_{tx}</span> . By Propositions 8 and 9,  <span class="math">\\forall z_2\\in Z_2</span> , with probability  <span class="math">\\geq 1-Risk\\left(G_t^v,(vote(z&#x27;))_{z&#x27;\\in C},z_1,z_2\\right)</span> , for any  <span class="math">\\epsilon&#x27;</span> , after some  <span class="math">\\tau</span>  (of finite expectation),  <span class="math">\\forall z_2&#x27;\\in (G_s^u\\setminus G_t^v)\\cup\\{z_2\\}:Risk\\left(G_s^u,(vote(z))_{z\\in C},z_{tx},z_2&#x27;\\right)\\leq \\epsilon&#x27;</span> . Moreover, in the proof of Proposition 19 it was shown that the minimal  <span class="math">\\epsilon&#x27;</span>  for which this property holds at time s decreases exponentially with s (which grows linearly with s). Thus, for all s greater than some t,  <span class="math">\\sum_{z_2&#x27;\\in (G_s^u\\setminus G_t^v)\\cup Z_2}:Risk\\left(G_s^u,(vote(z))_{z\\in C},z_{tx},z_2&#x27;\\right)\\leq \\sum_{z_2&#x27;\\in Z_2}Risk\\left(G_t^v,(vote(z))_{z\\in C},z_{tx},z_2&#x27;\\right)</span> .</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{lll} \\textit{\\textit{Part}} &amp; \\textit{\\textit{III:}} &amp; \\text{Similarly,} &amp; \\text{by} &amp; \\text{Proposition} &amp; 8, &amp; \\text{with probability} &amp; \\text{of at least} \\\\ Risk\\left(G_t^v, (vote\\left(z\\right))_{z \\in C}, z_{tx}, \\emptyset\\right), &amp; \\text{after some} &amp; \\tau &amp; (\\text{of finite expectation}), \\\\ Risk\\left(G_s^u, (vote\\left(z\\right))_{z \\in C}, z_{tx}, \\emptyset\\right) \\leq Risk\\left(G_t^v, (vote\\left(z\\right))_{z \\in C}, z_{tx}, \\emptyset\\right). \\end{array}</span></p>

    <p class="text-gray-300"><strong>Part IV:</strong> Let  <span class="math">\\epsilon_i(G^u_s, tx, subG)</span>  be the series of values returned by the call to RiskTxAccept in line 7 of RiskTxAccept (when given the inputs  <span class="math">(G^u_s, tx, subG)</span> ) and to RiskTxReject in line 9 of RiskTxAccept (with these inputs). By the induction hypothesis, with probability  <span class="math">\\geq 1 - \\epsilon_i</span> , after some time  <span class="math">\\tau</span> ,  <span class="math">\\epsilon_i(G^u_s, tx, past(z_{tx})) \\leq \\epsilon_i(G^v_t, tx, past(z_{tx}))</span> .</p>

    <p class="text-gray-300"><strong>Part V:</strong> The above arguments show that, with probability  <span class="math">\\geq 1 - risk_{acc}^{z_{tx}}(G_t^v, tx, subG)</span> , the sum of increments to the value of  <span class="math">risk_{acc}^{z_{tx}}(G_s^u, tx, subG&#x27;)</span>  is upper bounded by the</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;28</sup>Technically, the indexes i on both hand-sides of this inequality should be described more carefully. To save cumbersome notation, we rely on the understanding of the reader. Informally, every instantiation of the loop-variables inside RiskTxAccept (when given the inputs  <span class="math">(G_s^v, tx, subG)</span> ) is also realized by future calls of RiskTxAccept (when given the inputs  <span class="math">(G_s^u, tx, subG&#x27;)</span> ). We thus compare the results of the increments in the former to those in the latter. This is also true vice versa (for  <span class="math">z_1 = z_{tx}</span> ): Inside the first-loop's iteration over  <span class="math">z_1 = z_{tx}</span> , the exact same calls to RiskTxAccept and RiskTxReject are made, because  <span class="math">past(z_{tx})</span>  does not evolve with time.</p>

    <p class="text-gray-300">the sum of increments to the value of  <span class="math">risk_{acc}^{z_{tx}}(G_t^v,tx,subG)</span> , for all  <span class="math">s \\geq \\tau</span> , where  <span class="math">\\tau</span>  is of finite expectation. As  <span class="math">risk_{acc}(G_s^u,tx,subG&#x27;) \\leq risk_{acc}^{z_{tx}}(G_s^u,tx,subG&#x27;)</span> , and as  <span class="math">risk_{acc}(G_t^v,tx,subG) = risk_{acc}^{z_{tx}}(G_t^v,tx,subG)</span> , this proves that, with probability  <span class="math">\\geq 1 - risk_{acc}^{z_{tx}}(G_t^v,tx,subG)</span>  the inequality  <span class="math">risk_{acc}(G_s^u,tx,subG&#x27;) \\leq risk_{acc}(G_t^v,tx,subG)</span>  holds.</p>

    <p class="text-gray-300"><strong>Part VI:</strong> Similar arguments prove the induction step w.r.t. RiskTxReject. The difference in the proof is that, since  <span class="math">risk_{rej}^{z_1}</span>  is not a sum, rather a minimum, hence we can ignore the fact that  <span class="math">anticone\\left(z_1,G_s^u\\right)</span>  may grow in time and add loop-iterations that might further reduce the value of  <span class="math">risk_{rej}^{z_1}</span> . Note further that the induction claim, w.r.t. RiskTxReject, is restricted to the case subG'=subG. Hence, the fact that the set  <span class="math">Z_G([tx])</span>  possibly grows with time is of no consequence, since the first loop-variable is chosen from  <span class="math">Z_G([tx]) \\cap subG</span> . We thus conclude that, with probability  <span class="math">\\geq 1-risk_{rej}(G_s^u,tx,subG_k)</span> , there exists a  <span class="math">\\tau</span>  of finite expectation such that for all  <span class="math">s \\geq \\tau</span>  and all  <span class="math">u \\in honest</span> :  <span class="math">risk_{rej}(G_s^u,tx,subG_k) \\leq risk_{rej}(G_t^v,tx,subG_k)</span> .</p>

    <p class="text-gray-300">This completes the proof of the induction claim.</p>

    <p class="text-gray-300"><strong>Part VII:</strong> Algorithm 6 returns a set that contains tx if and only if RiskTxAccept returned a value smaller than  <span class="math">\\epsilon</span> . The above claim implies that, if  <span class="math">risk_{acc}(G_t^v, tx, G_t^v) &lt; \\epsilon</span> , with probability  <span class="math">\\geq 1-\\epsilon</span> , for all  <span class="math">s \\geq \\tau</span> , for some  <span class="math">\\tau</span>  of finite expectation, for all  <span class="math">u \\in honest</span> :  <span class="math">risk_{acc}(G_s^u, tx, G_s^u) &lt; \\epsilon</span> . In other words, conditioned on  <span class="math">\\mathcal{A}_t^v(tx, \\epsilon)</span> , the event  <span class="math">\\cap_{u \\in honest, s \\in (\\tau(t), \\infty)} \\mathcal{A}_s^u(tx, \\epsilon)</span>  occurs with probability  <span class="math">\\geq 1-\\epsilon</span> .</p>

    <h2 id="sec-misc-33" class="text-2xl font-bold">J. Proof of Liveness</h2>

    <p class="text-gray-300">Fix some  <span class="math">z_1 \\in Z_G([tx])</span>  for  <span class="math">G = G_t^v</span> . The condition that until  <span class="math">\\psi(t)</span> :  <span class="math">conflict(tx) \\cap G_s^{pub} = \\emptyset</span> , implies that lines 6 and 7 of RiskTxAccept do not contribute to the value of  <span class="math">risk_{acc}(G_s^u, tx, subG)</span> . The assumption  <span class="math">\\sum_{[tx_i] \\in inputs(tx)} RiskTxAccept \\left(G_t^v, (vote(z))_{z \\in C}, [tx_i], G_t^v\\right) &lt; \\epsilon/2</span>  implies that, with probability  <span class="math">\\geq 1 - \\epsilon/2</span> , the overall contribution of the fourth loop to the value of  <span class="math">risk_{acc}^{z_1}(G_s^u, [tx], G_s^u)</span>  is at most  <span class="math">\\epsilon/2</span>  (after some  <span class="math">\\tau</span> ). Finally, by Proposition 10, the contribution of line 3 to  <span class="math">risk_{acc}^{z_1}</span>  is less than  <span class="math">\\epsilon/2</span> , after some  <span class="math">\\tau</span>  of finite expectation. We conclude that after some  <span class="math">\\tau</span>  of finite expectation, the value of  <span class="math">risk_{acc}^{z_1}(G_s^u, [tx], G_s^u)</span>  is smaller than  <span class="math">\\epsilon/2 + \\epsilon/2 = \\epsilon</span> , for all  <span class="math">s \\geq \\tau</span>  and  <span class="math">u \\geq s</span> , hence  <span class="math">risk_{acc}(G_s^u, [tx], G_s^u) &lt; \\epsilon</span> , which implies the event  <span class="math">\\cap_{u \\in honest, s \\in (\\tau(t), \\infty)} \\mathcal{A}_s^u(tx, \\epsilon)</span> .</p>

    <h4 id="sec-misc-34" class="text-lg font-semibold mt-6">K. Proof of Progress</h4>

    <p class="text-gray-300">The proof of this proposition is similar in structure to that of Proposition 2. Therein we have already argued that the contributions to the value of  <span class="math">risk_{acc}^{z_{tx}}</span>  (and similarly for  <span class="math">risk_{rej}^{z_{tx}}</span> ) of lines 3 and of 6 go to zero; and the increments of lines 7 and 9 go to zero by the induction hypothesis. Thus,  <span class="math">risk_{acc}(G_s^v, tx, G_s^v)</span>  goes to 0 as time develops, with probability  <span class="math">\\geq 1 - risk_{acc}(G_t^v, tx, G_t^v)</span> . As  <span class="math">\\epsilon &gt; risk_{acc}(G_t^v, tx, G_t^v)</span> , we conclude that, with probability  <span class="math">\\geq 1 - \\epsilon</span> , for all  <span class="math">G_s^v</span>  with  <span class="math">s \\geq \\tau</span>  and  <span class="math">u \\in honest</span> , Algorithm 6 returns a set that contains tx.</p>

    </section>
`;
---

<BaseLayout title="SPECTRE: A Fast and Scalable Cryptocurrency Protocol (2016/1159)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/1159
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="spectre-2016" />
  </article>
</BaseLayout>
