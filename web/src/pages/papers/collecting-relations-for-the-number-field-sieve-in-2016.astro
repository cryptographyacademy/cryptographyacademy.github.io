---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/124';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Collecting relations for the Number Field Sieve in $GF(p^6)$';
const AUTHORS_HTML = 'Pierrick Gaudry, Laurent Gr&eacute;my, Marion Videau';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In order to assess the security of cryptosystems based on the discrete logarithm problem in non-prime finite fields, as are the torus-based or pairing-based ones, we investigate thoroughly the case in $GF(p^6)$ with the Number Field Sieve. We provide new insights, improvements, and comparisons between different methods to select polynomials intended for a sieve in dimension 3 using a special-q strategy. We also take into account the Galois action to increase the relation productivity of the sieving phase. To validate our results, we ran several experiments and real computations for various selection methods and field sizes with our publicly available implementation of the sieve in dimension 3, with special-q and various enumeration strategies.</p>
    </section>

    <h2 id="sec-misc-1" class="text-2xl font-bold">4. Special-q sieve in dimension 3</h2>

    <p class="text-gray-300">For finite fields of the form  <span class="math">\\mathbb{F}_{p^6}</span>  of sizes that are within reach with current technology and algorithms, it is difficult to predict which polynomial selection method is the best. We will therefore rely on practical experiments, based on the runtime of a sieve implementation to decide and validate our criteria. In this setting, the optimal sieving dimension is 3. It might be 4 for small values of p, where it is unclear whether NFS is actually the best available algorithm; and for a sufficiently large value of p, the best sieving dimension will eventually become 2, but this will occur for sizes that are too large to run meaningful experiments. Therefore, we concentrate on the 3-dimensional sieving.</p>

    <p class="text-gray-300">In the factor base, most of the ideals are of inertia degree 1, so we describe our sieving procedure only for this case. In fact we consider a slightly more restrictive situation. From Section 2.3 the vectors c=(x,y,z) that yield elements divisible by a factor base ideal  <span class="math">\\mathfrak r</span>  are those whose coordinates verify a modular linear relation, and we assume that this relation is of the form</p>

    <p class="text-gray-300">
<span class="math">$x + By + Cz \\equiv 0 \\mod r,\\tag{4.1}</span>$</p>

    <p class="text-gray-300">where r is the norm of the ideal  <span class="math">\\mathfrak{r}</span> , and B is non-zero. This avoid complications due to projective roots (or generalizations thereof to dimension 3).</p>

    <p class="text-gray-300">In order to obtain elements  <span class="math">a=M_{\\mathfrak{q}}c</span>  in the target sieving region  <span class="math">\\mathcal{S}</span> , and norms of controlled sizes, we are interested in vectors c in the cuboid  <span class="math">\\mathcal{C}</span>  of size  <span class="math">I\\times J\\times K</span> . Our convention for the memory organization of this cuboid is z-major, and then y-major for each xy-plane (i.e. fixedz-plane). Hence, for fixed values of y and z, the corresponding x-line contains cells that are contiguous in memory. With this setting, for ideals of tiny norms r &lt; I, it makes sense to do line-sieving. When r becomes larger than I, the average number of hits per x-line is less than 1, and line-sieving is suboptimal: Franke-Kleijung's plane-sieving is then more appropriate. But then again, when r becomes larger than IJ, the average number of hits per xy-plane is less than 1, and it is better to switch to a space-sieve strategy.</p>

    <p class="text-gray-300">Line sieving is the most basic sieving strategy: after specializing all-but-one coordinates, this becomes a one-dimensional sieve, and one can jump from one hit location to the other by just adding r to the location index. For fixed y and z coordinates, finding the initial hit location amount to solving the linear equation 4.1 to get the smallest x solution within the given range. We remark furthermore that solving this problem for (y+1,z) after having solved it for (y,z) costs essentially no more than one addition modulo r.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">4.1. Plane sieve</h4>

    <p class="text-gray-300">The plane sieve is for sieving ideals whose norms r are of intermediate sizes. It works only for r &gt; I, and we assume this from now on. The general idea is to process all the xy-planes in turn, by increasing values of z. For a given value of z, there are two problems to solve: first, we need to find an initial hit location in the intersection of the given plane and the cuboid  <span class="math">\\mathcal{C}</span> , and second, we need to adapt Franke-Kleinjung's algorithm (FK-algorithm, for short) in order to visit efficiently all the other hit locations in the plane.</p>

    <p class="text-gray-300">We denote by  <span class="math">\\Lambda</span>  the lattice corresponding to the vectors c that verify Equation 4.1, or equivalently that corresponds to divisibility by the ideal  <span class="math">\\mathfrak{r}</span> . For any  <span class="math">z_0</span> , we denote by  <span class="math">\\Lambda_{z_0}</span>  the intersection of  <span class="math">\\Lambda</span>  and the plane of equation  <span class="math">z=z_0</span> . The set of points in  <span class="math">\\Lambda_0</span>  form a 2-dimensional lattice of volume r, and  <span class="math">\\Lambda_{z_0}</span>  is a translate of  <span class="math">\\Lambda_0</span> . The FK-algorithm relies on a particular basis for almost all 2-dimensional lattices, adapted to the bound I on the x-coordinate: in [10, Proposition 1], it is shown that there exists a unique basis  <span class="math">\\{(\\alpha, \\beta)^T, (\\gamma, \\delta)^T\\}</span>  of the lattice  <span class="math">\\Lambda_0</span> , called FK-basis, which can be efficiently computed using the extended Euclidean algorithm, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\beta &gt; 0</span>  and  <span class="math">\\gamma &gt; 0</span> ;</li>
      <li><span class="math">-I &lt; \\alpha \\le 0 \\le \\gamma &lt; I</span> ;</li>
      <li><span class="math">\\gamma \\alpha \\geqslant I</span> .</li>
    </ul>

    <p class="text-gray-300">Using this basis, the classical FK-algorithm allows to enumerate the elements of  <span class="math">\\Lambda_0</span>  whose x-coordinate is within an interval of size I, by increasing value of y. The following proposition shows that with a natural extension of the FK-algorithm, it is possible to enumerate the elements of  <span class="math">\\Lambda_{z_0}</span>  whose x-coordinate is within an interval of size I, by increasing and decreasing values of y; finding an initial point with the smallest y-value is therefore not necessary.</p>

    <p class="text-gray-300">PROPOSITION 4. Let I &gt; 0 be an integer and let  <span class="math">\\Lambda</span>  be a 3-dimensional lattice of volume r &gt; I. Let  <span class="math">\\{(\\alpha, \\beta)^T, (\\gamma, \\delta)^T\\}</span>  be the FK-basis of the intersection of  <span class="math">\\Lambda</span>  with the xy-plane. Let A be an integer, and A = [A, A + I[ the corresponding interval of length I. Let  <span class="math">z_0</span>  be a fixed third coordinate for elements of  <span class="math">\\Lambda</span> . Let  <span class="math">c = (x_0, y_0, z_0)</span>  be an element of  <span class="math">\\Lambda_{z_0}</span>  with  <span class="math">x_0 \\in A</span> . Then the point of  <span class="math">\\Lambda_{z_0}</span> , with an abscissa in A and with the smallest y-coordinate larger than  <span class="math">y_0</span>  is obtained by adding to c one of the following vector:</p>

    <p class="text-gray-300">
<span class="math">$\\begin{cases} (\\alpha, \\beta, 0)^T &amp; \\text{if } x_0 \\geqslant A - \\alpha, \\\\ (\\gamma, \\delta, 0)^T &amp; \\text{if } x_0 &lt; A + I - \\gamma, \\\\ (\\alpha, \\beta, 0)^T + (\\gamma, \\delta, 0)^T &amp; \\text{if } A + I - \\gamma \\leqslant x_0 &lt; A - \\alpha. \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$(4.2)</span>$</p>

    <p class="text-gray-300">Similarly, the point of  <span class="math">\\Lambda_{z_0}</span> , with an abscissa in  <span class="math">\\mathcal{A}</span>  and with the largest y-coordinate smaller than  <span class="math">y_0</span>  is obtained by subtracting to c one of the following vector:</p>

    <p class="text-gray-300">$$\\begin{cases}
(\\alpha, \\beta, 0)^T &amp; \\text{if } x_0 &lt; A + I + \\alpha, \\
(\\gamma, \\delta, 0)^T &amp; \\text{if } x_0 \\geqslant A + \\gamma, \\
(\\alpha, \\beta, 0)^T + (\\gamma, \\delta, 0)^T &amp; \\text{if } A + I + \\alpha \\leqslant x_0 &lt; A + \\gamma.
\\end{cases}$$
(4.3)</p>

    <p class="text-gray-300">Proof. Let  <span class="math">c=(x_0,y_0,z_0)</span>  be an element of  <span class="math">\\Lambda_{z_0}</span>  with  <span class="math">x_0 \\in \\mathcal{A}</span> . Let  <span class="math">c&#x27;=(x&#x27;_0,y&#x27;_0,z_0)</span>  be the vector obtained by applying Equation 4.2 to it, and  <span class="math">c&#x27;&#x27;=(x&#x27;&#x27;_0,y&#x27;&#x27;_0,z_0)</span>  be the vector of  <span class="math">\\Lambda_{z_0} \\cap (\\mathcal{A} \\times \\mathbb{Z} \\times \\{z_0\\})</span>  with the smallest y-coordinate that is larger than  <span class="math">y_0</span> . We want to show that c'' is equal to c'. Let  <span class="math">u \\in \\Lambda</span>  be defined by  <span class="math">u=(0,-C/B \\bmod r,1)</span> , with the notations of Equation 4.1. Subtracting  <span class="math">z_0u</span>  to c, c' and c'', we obtain three vectors  <span class="math">\\underline{c}</span> ,  <span class="math">\\underline{c}&#x27;</span>  and  <span class="math">\\underline{c}&#x27;&#x27;</span> , in  <span class="math">\\Lambda_0</span>  while preserving their x-coordinates, and translating their y-coordinates by a constant. Contrarily to  <span class="math">\\Lambda_{z_0}</span> ,  <span class="math">\\Lambda_0</span>  is a lattice, therefore we are exactly in the context of the 2-dimensional FK-algorithm, and by [10, Proposition 2], we must have  <span class="math">\\underline{c}&#x27;=\\underline{c}&#x27;&#x27;</span> , and, adding back  <span class="math">z_0u</span> , the result follows. The second case is obtained by symmetry.</p>

    <p class="text-gray-300">It remains to explain how to find a valid starting point for this variant of the FK-algorithm. Our strategy is to precompute a few lattice vectors with a z-coordinate equal to 1, and other coordinates as small as possible. Hence, from a point in  <span class="math">\\Lambda_{z_0}</span>  whose x- and y-coordinates are within the target intervals of length I and J, adding such a vector will give a point in  <span class="math">\\Lambda_{z_0+1}</span>  whose x- and y-coordinates are maybe not in the target interval, but probably not too far from it. In order to compute three small lattice vectors with z=1, we proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Select a lattice vector v with z = 1, for instance the one given in the proof above;</li>
      <li>(2) Find a reduced basis  <span class="math">(e_0, e_1)</span>  of  <span class="math">\\Lambda_0</span>  using Gauss algorithm;</li>
      <li>(3) Deduce the closest vector  <span class="math">u_0</span>  of the orthogonal projection of v in  <span class="math">\\Lambda_0</span> ;</li>
      <li>(4) Add or subtract  <span class="math">e_0</span>  and  <span class="math">e_1</span>  to  <span class="math">u_0</span> , to get three vectors  <span class="math">(u_0, u_1, u_2)</span>  of  <span class="math">\\Lambda_0</span>  that form the smallest triangle containing the projection of v;</li>
      <li>(5) Return the three vectors  <span class="math">v u_i</span>  for  <span class="math">0 \\le i &lt; 3</span> .</li>
    </ul>

    <p class="text-gray-300">Again, there is no guarantee that adding one of the small vectors with z=1 will keep the two other coordinates within the target intervals. If after having tried the three vectors we do not find a starting point, then by adding or subtracting the vector of the FK-basis with the largest x-coordinate, it is possible to quickly get the x-coordinate back into the target interval. Then, we apply the modified FK-algorithm to enumerate the hit locations for the current plane.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">4.2. Space sieve</h4>

    <p class="text-gray-300">When the volume r of the lattice  <span class="math">\\Lambda</span>  becomes large compared to the area IJ of the intersection of the sieving cuboid and the xy-plane, the plane sieve becomes inefficient, because in most of the planes, the modified FK-algorithm will not find any hit location. In that case, we have to find a way to jump quickly from one lattice point in the cuboid  <span class="math">\\mathcal C</span>  to the one with the smallest larger z-coordinate. This justifies the following definition.</p>

    <p class="text-gray-300">DEFINITION 5. Let  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{B}</span>  be two integral intervals of length I and J respectively. Let  <span class="math">\\Lambda</span>  be a lattice of volume r &gt; IJ. A transition vector v is a vector of  <span class="math">\\Lambda</span>  for which there exists a vector u of  <span class="math">\\Lambda</span>  in  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span>  such that u + v is the vector of  <span class="math">\\Lambda</span>  belonging to  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span>  and which is the one with the smallest z-coordinate that is larger than the one of u.</p>

    <p class="text-gray-300">For simplicity, we first assume that there is no lattice vector in  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\{0\\}</span> , so that for a given u, there is a unique transition vector associated to it.</p>

    <p class="text-gray-300">An analogue notion of transition vector can be defined for 2-dimensional sieving. The first statement of Proposition <a href="#page-8-1">4</a> says that the two vectors of the FK-basis and their sum are the only transition vectors. Unfortunately, in 3-dimensional sieving, the number of transition vectors is much less controlled. We give some examples, in the Appendix <a href="#page-16-1">D</a> . Still, the transition vectors have some simple properties that follow directly from their definition.</p>

    <p class="text-gray-300">Lemma 6. With the notation of Definition <a href="#page-9-0">5,</a> the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For a given lattice vector, the associated transition vector depends only on its x- and y-coordinates;</li>
      <li>The set of transition vectors depend only on &Lambda;, and on the length I and J of the intervals A and B, not on the intervals themselves;</li>
      <li>The x- and y-coordinates of a transition vector belong to s &acute; I, Ir and s &acute; J, Jr respectively.</li>
    </ul>

    <p class="text-gray-300">We do not try to compute the complete set of transition vectors, but only a subset that covers a large enough proportion of the I &circ; J area. In fact, we do not even insist on proving that we really have transition vectors: we accept the fact that in some not-too-frequent cases we will use a vector that makes us jump too far in the z-coordinate, thus missing a hit location. The general idea is that this step is in a very critical loop of the algorithm, and we cannot afford to spend too much time in it. Therefore, it is better to miss a few relations if the general rate of relations found per second is higher than with an algorithm that would try to be exhaustive.</p>

    <p class="text-gray-300">We resort to a heuristic but simple and efficient method to find candidate transition vectors: with a weighted-LLL algorithm, we find a reduced basis of &Lambda;, targeting vectors with x- and ycoordinates with sizes about I and J respectively (and then the target for the z-coordinate is about r{IJ). Then, we compute a few small linear combinations of the vectors of this reduced basis, and keep the list of the half-dozen vectors with the smallest z-coordinates and x- and y-coordinates of absolute value bounded by I and J respectively. There are certainly highly unbalanced lattices for which this method will fail, but we observed that in practice for most of the ideals it produces a list of transition vectors that covers a large xy-area.</p>

    <p class="text-gray-300">After computing this list L of candidate transition vectors, our space-sieve algorithm proceeds as follows. Let v be the current hit location that we initialize with the zero vector (assuming 0 belongs to the intervals A and B). To get the next hit location, we try to add, in turn, the elements of L, until this addition produces a vector in A &circ; B &circ; Z. We test the vectors of L in increasing order of their z-coordinates. If no appropriate vector is found after trying all vectors of L, we fallback to a plane sieve strategy: we use vectors with z &quot; 1 to go up by one plane, and if there is no hit in this plane, we continue until one is found. This slower process yields a new transition vector that is added to L before resuming with the space sieve.</p>

    <p class="text-gray-300">In this description, we have assumed that there were no lattice vector with z &quot; 0, |x| &#259; I and |y| &#259; J, which is certainly true in general provided that r is large enough, but we cannot exclude it to occur, especially when r is just marginally larger than IJ. It is not too difficult to handle those ideals that can hit several times in some planes: before trying to apply transition vectors, one must check whether the vectors with z &quot; 0 can yield hits, and if so, transition vectors can be tried on all these hits. A pseudo-code following these ideas can be found in Appendix, as Algorithm <a href="#page-17-0">3.</a> Experiments in the next section confirm that using the space sieve is indeed faster than the plane sieve for large ideals (see also Appendix <a href="#page-16-2">F)</a>.</p>

    <p class="text-gray-300">Remark 7. In the recent preprint [<a href="#page-13-16">17</a>], another 3-dimensional version of FK-algorithm is proposed. Although we did not manage to fully reproduce the work of this preprint, their strategy is not to precompute a set of transition vectors, but to try to compute them on the fly at each step, using a well reduced basis (when it exists).</p>

    <h2 id="sec-misc-4" class="text-2xl font-bold">5. Experimental results</h2>

    <p class="text-gray-300">The experiments in this section have been done with our C implementation of the 3-dimensional sieving that we made available as a branch called hd in the CADO-NFS official repository [31] (done with commit OaeO1dO...). In the file README.nfs-hd, instructions are given to reproduce all our experiments. The polynomial selection based on the criteria and constructions that we explained in Section 3 has been performed by Aurore Guillevic who has developed strategies to speed-up the exhaustive search that she will describe in an independent article in which  <span class="math">\\mathbb{F}_{p^6}</span>  will be just an example among many others. All the running times are given after normalization for a single core at 2 GHz.</p>

    <p class="text-gray-300">Our first experiment follows the two previous computations made by Zajac [32] and Hayasaka et al. [17] for a 40-bit prime p=1081034284409. They used different sieving algorithms but the same polynomial pair, the same smoothness bounds and the same sieving region for the polynomials a. With these parameters, the Murphy-E value computed with our description is about  <span class="math">2^{-24.5}</span>  with Zajac's parameters and  <span class="math">2^{-21.6}</span>  for Hayasaka's parameters. The difference between the two is due to the special- <span class="math">\\mathfrak{q}</span>  sieve.</p>

    <p class="text-gray-300">We have selected our own polynomials. In this small field, the best polynomial selection appears to be the asymmetric JLSV method with the explicit Galois action of order 6 given by  <span class="math">x\\mapsto -(2x+1)/(x-1)</span> . We chose  <span class="math">f_0=x^6+91354x^5+228370x^4-20x^3-228385x^2-91348x+1</span>  and  <span class="math">f_1=23667000x^6+6549182x^5-338632045x^4-473340000x^3-16372955x^2+135452818x+23667000</span> . We have selected the smoothness bounds and the sieving region in order to reduce the total sieving time. The sizes of norms are about 115 bits on the  <span class="math">f_0</span> -side and 117 bits on the  <span class="math">f_1</span> -side, after subtracting the contribution of the special-q. We sieved all the prime ideals  <span class="math">\\mathfrak r</span>  of inertia degree 1 less than  <span class="math">2^{19}</span> . The thresholds are set to  <span class="math">2^{65}</span> . We obtained 1312416 raw relations with 12.3% of duplicates. These results are summarized in Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Zajac [ <b>32</b> ]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hayasaka et al. [17]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Our work</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Special-q sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Enumeration algorithm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line sieve and<br>FK method in 3D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line, plane and space sieves</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sieving region (global or per q)<br>Smoothness bounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{19} \\times 2^{14} \\times 1149</span><br><span class="math">2^{22.64}, 2^{22.64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8} \\times 2^{8} \\times 2^{6}</span><br><span class="math">2^{22.64}, 2^{22.64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^7 \\times 2^7 \\times 2^6</span><br><span class="math">2^{23}, 2^{23}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha</span> values</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7, 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7, 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-1.8, -11.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Murphy-E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-20.1}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of special-q's</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{17.77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14.44}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Order of the Galois action</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of relations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1077984</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">937575</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1151099</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of needed relations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">854833</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">893773</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1128604</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Timing (days)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.90</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1. Experiments on sieving in  <span class="math">\\mathbb{F}_{p^6}</span>  with p = 1081034284409.</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">5.2. Experiments with a 300-bit finite field</h4>

    <p class="text-gray-300">In order to compare the polynomial selections described in Section 3, we have chosen a new  <span class="math">\\mathbb{F}_{p^6}</span>  field with a 50-bit prime p=1043035802846857. For this experiment, we worked with a reduced range of about 10000 special- <span class="math">\\mathfrak{q}</span>  up to  <span class="math">2^{20.5}</span> . Our tests were done with a sieving region of size  <span class="math">2^8 \\times 2^8 \\times 2^7</span>  and two smoothness bounds equal to  <span class="math">2^{25}</span> . The polynomials we used can be found in Appendix G. The results are summarized in Table 2. It allowed us to select the best suitable polynomials in order to find a complete set of relations. The numbers of relations per</p>

    <p class="text-gray-300">special-q are given without the use of the Galois action; therefore to get a fair comparison the entries of the last two lines of Table 2 should be multiplied together.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Asym. JLSV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Conjugation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sarkar-Singh (8, 6)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sarkar-Singh (9, 6)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha</span> values Murphy- <span class="math">E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-12, -4.9</span> <span class="math">2^{-19.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-0.8, -6.4</span> <span class="math">2^{-27.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1.2, -4.6</span> <span class="math">2^{-22.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{c} 1.9, -6.5 \\ 2^{-23.0} \\end{array} $</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Special-q side</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{1}{2^{128}}</span> , <span class="math">2^{139}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{c} 2\\ 1\\ 2^{153} \\cdot 2^{143} \\end{array} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1<br>2 <sup>186</sup> , 2 <sup>144</sup></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of norms<br>Galois action</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{251}, 2^{148}</span> <span class="math">6</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rels per q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.9</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2. Experiments on sieving with p = 1043035802846857.</p>

    <p class="text-gray-300">For the full sieving computation, we kept the sieving region and the smoothness bounds of the experiments and used the polynomials given by the asymmetric JLSV polynomial selection. They are  <span class="math">f_0 = x^6 - 867578x^5 - 2168960x^4 - 20x^3 + 2168945x^2 + 867584x + 1</span>  and  <span class="math">f_1 = 2404471680x^6 + 4874502674x^5 - 23880818515x^4 - 48089433600x^3 - 12186256685x^2 + 9552327406x + 2404471680</span> , with the same Galois action as for the smaller example. The  <span class="math">2^{14.7}</span>  special-q's are set on the  <span class="math">f_1</span> -side. The sieving bounds equal to  <span class="math">2^{20.5}</span>  and the thresholds were set to  <span class="math">2^{80}</span> . We obtained 4637772 raw relations that gave 4231562 unique relations after duplicate removal; there are 4129438 ideals in the factor bases. The relation collection time is 6.84 days.</p>

    <h2 id="sec-misc-6" class="text-2xl font-bold">5.3. Computation for a 389-bit finite field</h2>

    <p class="text-gray-300">We have selected a 65-bit prime p=31415926535897942161. For this computation, the asymmetric JLSV polynomial selection with the same Galois action of order 6 seems to give anew the best polynomials in terms of Murphy-E value. The polynomials are  <span class="math">f_0=x^6-218117072x^5-545292695x^4-20x^3+545292680x^2+218117078x+1</span>  and  <span class="math">f_1=288064804440x^6+1381090484642x^5-868245854995x^4-5761296088800x^3-3452726211605x^2+347298341998x+288064804440</span> . We selected the sieving region to be  <span class="math">2^{10}\\times 2^{10}\\times 2^8</span>  and two smoothness bounds equal to  <span class="math">2^{28}</span> . The  <span class="math">2^{18.7}</span>  special-q's are set on the  <span class="math">f_1</span>  side and the average value of the norms are  <span class="math">2^{160}</span>  on the  <span class="math">f_0</span> -side and  <span class="math">2^{173}</span>  on the  <span class="math">f_1</span> -side. The sieving bounds are equal to  <span class="math">2^{21}</span>  and the thresholds are set to  <span class="math">2^{90}</span> . The relation collection required 790 days to find 29428326 unique relations after the removal of less than 20.3% duplicates; this is greater than the 29261526 ideals in the factor bases. This computation was done with commit 4470e1....</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">6. Conclusion</h4>

    <p class="text-gray-300">In this article we investigated at length different strategies to improve the relation productivity of the sieving step in NFS in dimension 3 targeted for a discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span> . This involved adapting and comparing differents polynomial selection methods taking into account a special- <span class="math">\\mathfrak{q}</span>  sieve and a Galois action especially for dimension 3. We ran experiments on several real computations to compare with existing records and set new reference timings. Most notably, we ran a relation collection for a 50-bit p in about 7 normalized CPU-days and a 65-bit p in about 790 CPU-days. Our implementation is publicly available as part of CADO-NFS.</p>

    <p class="text-gray-300">In a near future, we plan to run a full discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span>  that includes the linear algebra and individual logarithm steps for a size as large as possible with our computing resources. It is possible that including some of the ideas of [17] would speed-up our implementation. Further work includes also studying the practical aspects of the Tower NFS variants [4, 21]; this would imply sieving in dimension at least 4.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. Bai, S., Brent, R., Thom&eacute;, E.: Root optimization of polynomials in the number field sieve. Math. Comp. 84, 2447&ndash;2457 (2015)</li>
      <li>2. Barbulescu, R., Gaudry, P., Guillevic, A., Morain, F.: Improving NFS for the discrete logarithm problem in non-prime finite fields. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 129&ndash;155. Springer (2015)</li>
      <li>3. Barbulescu, R., Gaudry, P., Joux, A., Thom&eacute;, E.: A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: Nguyen, P., Oswald, E. (eds.) EUROCRYPT 2014. LNCS, vol. 8441, pp. 1&ndash;16. Springer (2014)</li>
      <li>4. Barbulescu, R., Gaudry, P., Kleinjung, T.: The tower number field sieve. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9453, pp. 31&ndash;55. Springer (2015)</li>
      <li>5. Barbulescu, R., Lachand, A.: Some mathematical remarks on the polynomial selection in NFS (2014), <a href="https://hal.inria.fr/hal-00954365" target="_blank" rel="noopener noreferrer">https://hal.inria.fr/hal-00954365</a>, preprint, to appear in Math. Comp.</li>
      <li>6. Barbulescu, R., Pierrot, C.: The Multiple Number Field Sieve for Medium and High Characteristic Finite Fields. LMS J. Comput. Math 17, 230&ndash;246 (2014)</li>
      <li>7. Cohen, H.: A course in algorithmic algebraic number theory, GTM, vol. 138. Springer&ndash;Verlag (1993)</li>
      <li>8. Commeine, A., Semaev, I.: An algorithm to solve the discrete logarithm problem with the number field sieve. In: et al., M.Y. (ed.) PKC 2006. LNCS, vol. 3958, pp. 174&ndash;190. Springer (2006)</li>
      <li>9. Coppersmith, D.: Modifications to the number field sieve. J. of Cryptology 6(3), 169&ndash;180 (1993)</li>
      <li>10. Franke, J., Kleinjung, T.: Continued fractions and lattice sieving. In: SHARCS (2005)</li>
      <li>11. Freeman, D., Scott, M., Teske, E.: A taxonomy of pairing-friendly elliptic curves. J. of Cryptology 23, 224&ndash;280 (2010)</li>
      <li>12. Gonz&aacute;lez, &Aacute;.: Measurement of areas on a sphere using Fibonacci and latitude&ndash;longitude lattices. Math. Geosc. pp. 42&ndash;49 (2010)</li>
      <li>13. Gordon, D.M.: Discrete logarithms in GFppq using the number field sieve. SIAM Journal on Discrete Mathematics 6(1), 124&ndash;138 (1993)</li>
      <li>14. Guillevic, A.: Computing individual discrete logarithms faster in GFpp <sup>n</sup>q with the NFS-DL algorithm. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9452, pp. 149&ndash;173. Springer (2015)</li>
      <li>15. Hanrot, G., Pujol, X., Stehl&eacute;, D.: Algorithms for the shortest and closest lattice vector problems. In: Chee, Y.M., Guo, Z., Ling, S., Shao, F., Tang, Y., Wang, H., Xing, C. (eds.) Coding and Cryptology - Third International Workshop, IWCC 2011. LNCS, vol. 6639, pp. 159&ndash;190. Springer (2011)</li>
      <li>16. Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: An experiment of number field sieve for discrete logarithm problem over GF(p <sup>12</sup>). In: Fischlin, M., Katzenbeisser, S. (eds.) Number Theory and Cryptography. LNCS, vol. 8260, pp. 108&ndash;120. Springer (2013)</li>
      <li>17. Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: A construction of 3-dimensional lattice sieve for number field sieve over Fp<sup>n</sup> . Cryptology ePrint Archive, 2015/1179 (2015)</li>
      <li>18. Joux, A., Lercier, R.: Improvements to the general number field sieve for discrete logarithms in prime fields. Math. Comp. 72(242), 953&ndash;967 (2003)</li>
      <li>19. Joux, A., Lercier, R., Smart, N.P., Vercauteren, F.: The Number Field Sieve in the Medium Prime Case. In: Dwork, C. (ed.) CRYPTO 2006. LNCS, vol. 4117, pp. 326&ndash;344. Springer (2006)</li>
      <li>20. Joux, A., Pierrot, C.: The special number field sieve in Fp<sup>n</sup> &ndash; application to pairing-friendly constructions. In: Cao, Z., Zhang, F. (eds.) Pairing 2013. LNCS, vol. 8365, pp. 45&ndash;61. Springer (2013)</li>
      <li>21. Kim, T., Barbulescu, R.: Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, 2015/1027 (2015), preprint, to appear at CRYPTO 2016.</li>
      <li>22. Kleinjung, T.: On polynomial selection for the general number field sieve. Math. Comp. 75, 2037&ndash;2047 (2006)</li>
      <li>23. Lenstra, A.K., Verheul, E.R.: The XTR public key system. In: Bellare, M. (ed.) CRYPTO 2000. LNCS, vol. 1880, pp. 1&ndash;19. Springer (2000)</li>
      <li>24. Murphy, B.A.: Polynomial selection for the number field sieve integer factorisation algorithm. Ph.D. thesis, The Australian National University (1999)</li>
      <li>25. Pierrot, C.: The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 156&ndash;170. Springer (2015)</li>
      <li>26. Pollard, J.: The lattice sieve. In: Lenstra, A.K., Lenstra, Jr., H.W. (eds.) The development of the number field sieve, Lecture Notes in Math., vol. 1554, pp. 43&ndash;49. Springer (1993)</li>
      <li>27. Rubin, K., Silverberg, A.: Torus-based cryptography. In: Boneh, D. (ed.) CRYPTO 2003, LNCS, vol. 2729, pp. 349&ndash;365. Springer (2003)</li>
      <li>28. Sarkar, P., Singh, S.: New complexity trade-offs for the (multiple) number field sieve algorithm in nonprime fields. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016. LNCS, vol. 9665, pp. 429&ndash;458. Springer (2016)</li>
      <li>29. Schirokauer, O.: Virtual logarithms. J. Algorithms 57, 140&ndash;147 (2005)</li>
      <li>30. Schirokauer, O.: Discrete logarithms and local units. Philos. Trans. A 345(1676), 409&ndash;423 (1993)</li>
      <li>31. The CADO-NFS Development Team: CADO-NFS, an implementation of the number field sieve algorithm (2015), <a href="http://cado-nfs.gforge.inria.fr/" target="_blank" rel="noopener noreferrer">http://cado-nfs.gforge.inria.fr/</a>, release 2.2.0</li>
      <li>32. Zajac, P.: Discrete Logarithm Problem in Degree Six Finite Fields. Ph.D. thesis, Slovak University of Technology (2008), <a href="http://www.kaivt.elf.stuba.sk/kaivt/Vyskum/XTRDL" target="_blank" rel="noopener noreferrer">http://www.kaivt.elf.stuba.sk/kaivt/Vyskum/XTRDL</a></li>
      <li>33. Zajac, P.: On the use of the lattice sieve in the 3D NFS. Tatra Mt. Math. Publ. 45, 161&ndash;172 (2010)</li>
    </ul>

    <h2 id="sec-misc-8" class="text-2xl font-bold">Appendix A. Computing the average <span class="math">\\ell</span> -adic valuation</h2>

    <p class="text-gray-300">In the case of 2-dimensional sieving, the average  <span class="math">\\ell</span> -adic valuation can be computed with the small recursive lifting function given as Algorithm 1. This is what is done for instance in the CADO-NFS implementation. This is admittedly much simpler and faster that running a full factorization of f over the  <span class="math">\\ell</span> -adics, which is advantageous when many polynomials have to be tested.</p>

    <p class="text-gray-300">The equivalent for 3-dimensional sieving is not as simple, but can still be faster in many cases than a full  <span class="math">\\ell</span> -adic factorization. Let us give first the modifications to be done for computing the contribution of irreducible factors of degree 2 modulo  <span class="math">\\ell</span> . The normalization factor C must be changed to  <span class="math">\\ell^2/(\\ell^2 + \\ell + 1)</span> . Then, all the computations must no longer be done over the integers, but over the unramified extension  <span class="math">\\mathbb{Q}_{\\ell^2}</span>  of  <span class="math">\\mathbb{Q}_{\\ell}</span>  of degree 2. Only the roots genuinely over this extension are considered in the for loop, but their computation is still done modulo  <span class="math">\\ell</span> : in step 4, we are now doing polynomial factorization over  <span class="math">\\mathbb{F}_{\\ell^2}</span> . Finally, in step 6, the contribution to add is  <span class="math">1/(\\ell^2 - 1)</span> , and in step 8, the result of the recursive call must be multiplied by  <span class="math">C/\\ell^2</span>  instead of  <span class="math">C/\\ell</span> . We obtain Algorithm 2.</p>

    <p class="text-gray-300">We emphasize that this algorithm returns the correct answer, even in the case where the degree 2 factor is a multiple factor of f modulo  <span class="math">\\ell</span> ; knowing the nature of the  <span class="math">\\ell</span> -adic factorization above this multiple factor is not required.</p>

    <p class="text-gray-300">The case of a multiple factor of degree 1 is less straightforward, because the contribution to the average valuation will not be the same for a split, inert or ramified factor above this root. Still, in most cases, and in particular when the root is only a double root, it is possible to adapt Algorithm 1 and get the correct answer. We skip the details; the corresponding code is given in the hd branch of the CADO-NFS repository.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Algorithm 1: av_val_dim2 Average <span class="math">\\ell</span> -adic valuation, 2-dim. case. <strong>input</strong>: A polynomial f; a prime <span class="math">\\ell</span> . output: The average ( \\ell )-adic valuation of <span class="math">\\operatorname{Res}_x(f(x), a - bx).</span> 1 <span class="math">v \\leftarrow \\ell</span> -valuation of the content of f. <span class="math">f \\leftarrow f/\\ell^v</span> . <span class="math">C \\leftarrow \\ell/(\\ell+1); v \\leftarrow Cv</span> . 4 for r in Roots(f) modulo <span class="math">\\ell</span> do if r is a simple root then <span class="math">v \\leftarrow v + C/(\\ell - 1)</span> . 6 else <span class="math">v \\leftarrow v + \\frac{C}{\\ell}</span> av_val_dim2 <span class="math">(f(r + \\ell x), \\ell)</span> . end 10 end 11 return v.</h4>

    <pre><code class="language-text">input: A polynomial f over \\mathbb{Q}_{\\ell^2}; a prime \\ell.
    output: The contribution to the average \\ell-adic
                valuation of \\operatorname{Res}_x(f(x), ax^2 + bx + c), coming
                from irreducible factors of degree 2 mod \\ell.
 1 v \\leftarrow Minimum \\ell-valuation of the coefficients of f.
   f \\leftarrow f/\\ell^v
    C \\leftarrow \\ell^2/(\\ell^2 + \\ell + 1); v \\leftarrow Cv.
 4 for r in Roots(f) modulo \\ell do
          At top-level of recursion, if r is in \\mathbb{Q}_{\\ell}, skip it.
         if r is a simple root then
              v \\leftarrow v + C/(\\ell^2 - 1).
 7
 8
              v \\leftarrow v + \\frac{C}{\\ell^2} \\text{ av\\_val\\_dim3\\_deg2}(f(r + \\ell x), \\ell).
 9
         end
10
11 end
12 return v.
</code></pre>

    <p class="text-gray-300">Appendix B. Real and complex roots: shape of the isonorms</p>

    <p class="text-gray-300">In the classical 2-dimensional NFS, having many real roots in  <span class="math">f_0</span>  and  <span class="math">f_1</span>  tends to increase the Murphy-E value. This can be explained by the fact that when we sieve a degree 1 polynomial whose (rational) root is a good approximation of a root of f, then the corresponding norm will be small. In the case of 3-dimensional sieving, complex roots have to be taken into account as well.</p>

    <p class="text-gray-300">Let f be a polynomial to be used in NFS. A first order estimate of the sizes of the norms would imply that the surface of points corresponding to polynomials a(x) of degree 2 that yield a norm of a given size is a sphere (or an ellipsoid if there is skewness). A real root in f will</p>

    <p class="text-gray-300">correspond to a plane in the direction of which the isonorm sphere is deformed with a bump. Since we are now sieving polynomials of degree 2, they can also approximate complex roots (or irreducible real factors of degree 2). The iso-norm sphere is therefore also stretched in the direction of the lines corresponding to polynomials close to irreducible factors of degree 2.</p>

    <p class="text-gray-300">In Figure B.1, we give pictures illustrating how the sphere is modified in the directions corresponding to real and complex roots of f. This clearly shows that the spherical approximation is not accurate enough and justifies to use the more precise Murphy-E estimate. For these pictures, we used the following polynomials:</p>

    <pre><code class="language-text">- with no real roots: 1456x^6 - 170x^5 + 15810x^4 - 20x^3 - 1825x^2 + 2676x + 1774;

- with 2 real roots: 1456x^6 + 6330x^5 + 15810x^4 - 20x^3 - 15825x^2 - 6324x + 1771;

- with 4 real roots: 1067x^6 + 3757x^5 + 4277x^4 + 3637x^3 - 1789x^2 - 4876x + 603;

- with 6 real roots: 3267x^6 + 3251x^5 - 16174x^4 - 12508x^3 + 11988x^2 + 2084x - 531.
</code></pre>

    <p class="text-gray-300">    <img src="_page_15_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">FIGURE B.1. Isonorms for polynomials of degree 6 with 0, 2, 4 and 6 real roots. The red planes correspond to real roots and the green lines to complex roots.</p>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6">Appendix C. Sarkar-Singh polynomial selections</h4>

    <p class="text-gray-300">For the various choices of d in the case n=6, we report the sizes of the coefficients and the degrees of the two polynomials  <span class="math">f_0</span>  and  <span class="math">f_1</span>  according to Algorithm  <span class="math">\\mathcal{A}</span>  of [28].</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 1 (GJL)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 6 (Conjugation)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">}f0}8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">deg f0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">}f1}8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6{7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3{4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2{3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1{2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">deg f1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Galois</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table C.1. Sizes and degrees of polynomials with the Sarkar-Singh constructions for Fp<sup>6</sup> .</p>

    <p class="text-gray-300">The space sieve algorithm relies heavily on the notion of transition vectors, but the number of them is not easily controlled. From Lemma <a href="#page-10-0">6,</a> for a given lattice we can define the transition vector associated to a point in the I &circ; J plane. In Figure <a href="#page-16-3">D.1,</a> pictures are shown where a different color is associated to each transition vector. The example on the right is highly degenerate, in the sense that there are many different transition vectors; however, in this example, most of the area is covered by the vector with the smallest z-coordinate.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure D.1. Three examples of how transition vectors covers the I &circ; J plane. Each color correspond to a transition vector; below each picture, the colors are listed in the increasing order of the z-coordinate of the corresponding vector.</p>

    <p class="text-gray-300">We describe in Algorithm <a href="#page-17-0">3</a> a complete space sieve algorithm, that takes care about vectors with a z-coordinate equals to 0 that could be found during the weighted LLL and small combination processes. In this algorithm, L is a list that stores all the point we enumerate, L<sup>z</sup>&quot;<sup>0</sup> contains vectors with coordinates in s &acute; I, Ir&circ;s &acute; J, Jr&circ;t0u and L<sup>z</sup>&permil;<sup>0</sup> the transition vectors.</p>

    <p class="text-gray-300">We first tried to use an enumeration algorithm following Algorithm 10 of [<a href="#page-13-32">15</a>]; the plane sieve turned out to be about 120 times faster than our implementation of this enumeration algorithm.</p>

    <p class="text-gray-300">We also compared the efficiency of the space sieve compared to the plane sieve. We sampled 1600 special-q among those that we used during the computation detailed in Section <a href="#page-11-1">5.2</a> and sieved about 2 16.7 ideals of norm larger than IJ on each side. In average for each side, the</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6"><strong>Algorithm 3:</strong> Space sieve</h4>

    <pre><code class="language-text">input: a lattice \\Lambda and the target cuboid of size I \\times J \\times K.
output: list of visited points.
L \\leftarrow \\emptyset.
// Compute candidate transition vectors.
M^{SLR} \\leftarrow weighted LLL on \\Lambda, with non-negative z-coordinate.
L_z \\leftarrow \\text{linear combinations of the elements of } M^{SLR}
Split L_z into L_{z=0} \\cup L_{z\\neq 0} according to the z-coordinate of elements being zero or not.
Keep only the smallest non colinear vectors of L_{z=0} if they exist.
Sort L_{z\\neq 0} by increasing z coordinate.
// Main enumeration loop.
s \\leftarrow (0, 0, 0)^T.
while the z-coordinate of s is smaller than K do
    // Find elements in the plane of the z-coordinate of s.
    L_c \\leftarrow \\emptyset.
    for v \\in L_{z=0} do
     Add to L and L_c all the points in the intersection of the line s + \\lambda v and the cuboid, \\lambda \\in \\mathbb{Z}.
    // Find smallest next location.
    s_t \\leftarrow (0, 0, K)^T.
    for s_n \\in L_c do
         for v \\in L_{z\\neq 0} do
              if v + s_n is in the sieving region and (v + s_n)[2] &lt; s_t[2] then
               s_t \\leftarrow v + s_n.
              end
         \\mathbf{end}
    end
    // Use plane sieve as a fallback.
    if s_t was not updated then
         s_t \\leftarrow \\text{call the plane sieve with } L_c[0] as a starting point and stop when an element is found.
         Insert s_t - s in L_{z\\neq 0}, keeping the list sorted.
    end
    s \\leftarrow s_t.
end
return L
</code></pre>

    <p class="text-gray-300">plane sieve takes 5.23 seconds in a single core at 3.20 GHz against 1.60 seconds for the space sieve. This gives a 3.25 accelerating factor by using the space sieve instead of the plane sieve.</p>

    <p class="text-gray-300">Appendix G. Different polynomial selections for the field  <span class="math">\\mathbb{F}_{p^6}</span>  with a 50 bits p</p>

    <p class="text-gray-300">We report here the three different pairs of polynomials we used to build Table 2: - Conjugation:</p>

    <pre><code class="language-text">&bull; f_0 = x^{12} + 12x^{11} + 40x^{10} - 20x^9 - 245x^8 - 200x^7 + 344x^6 + 592x^5 + 250x^4 - 20x^3 - 26x^2 + 1;
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">f_1 = 31943784x^6 + 201177002x^5 + 23785745x^4 638875680x^3 502942505x^2 9514298x + 31943784</span> .</p></li>
      <li><p class="text-gray-300">Sarkar-Singh with d = 2, yielding degrees (8,6):  <span class="math">f_0 = 2x^8 2x^7 + 6x^6 4x^5 + 9x^4 4x^3 + 6x^2 2x + 2</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1 = 13305451020x^6 + 13068452527x^5 122274520263x^4 + 74260869388x^3 122274520263x^2 + 13068452527x + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 1227452066x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 12274</span> 13305451020.</li>
    </ul></li>
      <li><p class="text-gray-300">Sarkar-Singh with d = 3, yielding degrees (9,6):  <span class="math">f_0 = x^9 + 2x^8 5x^7 9x^6 + 13x^5 + 24x^4 2x^3 15x^2 7x 1</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1 = 10266423024x^6 6028238612x^5 67420797690x^4 2036172080x^3 + 116716740730x^2 + 67626776756x +</span> 10266423024.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Pierrick Gaudry and Laurent Gr&eacute;my Inria, CNRS, Universit&eacute; de Lorraine Nancy, France</p>

    <p class="text-gray-300">firstname.lastname@loria.fr</p>

    <p class="text-gray-300">Marion Videau Quarkslab, Paris, France Inria, CNRS, Universit&eacute; de Lorraine Nancy, France</p>

`;
---

<BaseLayout title="Collecting relations for the Number Field Sieve in $GF(p^6)$ (2016/124)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/124
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="collecting-relations-for-the-number-field-sieve-in-2016" />
  </article>
</BaseLayout>
