---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/124';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Collecting relations for the Number Field Sieve in $GF(p^6)$';
const AUTHORS_HTML = 'Pierrick Gaudry, Laurent Grémy, Marion Videau';

const CONTENT = `    <p class="text-gray-300">Collecting relations for the Number Field Sieve in <span class="math">GF(p^{6})</span></p>

    <p class="text-gray-300">Pierrick Gaudry, Laurent Grémy and Marion Videau</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In order to assess the security of cryptosystems based on the discrete logarithm problem in non-prime finite fields, as are the torus-based or pairing-based ones, we investigate thoroughly the case in <span class="math">\\mathbb{F}_{p^{6}}</span> with the Number Field Sieve. We provide new insights, improvements, and comparisons between different methods to select polynomials intended for a sieve in dimension 3 using a special-q strategy. We also take into account the Galois action to increase the relation productivity of the sieving phase. To validate our results, we ran several experiments and real computations for various polynomial selection methods and field sizes with our publicly available implementation of the sieve in dimension 3, with special-q and various enumeration strategies.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1. Introduction</h2>

    <p class="text-gray-300">The security of major cryptographic protocols relies heavily on the difficulty of two main number theoretic problems: large integer factorization and discrete logarithm computation in a finite group. Recently, the discrete logarithm problem on finite fields has received a lot of attention, bringing new results all related to the index calculus family of algorithms. If the small characteristic finite fields can be classified as a lost cause thanks to the quasi-polynomial algorithm <em>[3]</em> and the prime field case resorts to the <em>classical</em> Number Field Sieve (NFS) <em>[13, 30, 18]</em>, there is still room to understand better how to adapt variants of NFS to non-prime finite fields <em>[19, 2]</em>.</p>

    <p class="text-gray-300">Cryptosystems that would be affected by better complexity and practical results in this setting would be torus-based <em>[23, 27]</em> or pairing-based (see <em>[11]</em> for a survey). Although not widely deployed in everyday products, the specificity of their use makes it necessary to finely assess the security margin that one can expect from a given choice of parameters for an expected period of time as progress in cryptanalysis can spectacularly undermine their usability, as it was the case for pairing-based cryptography using small characteristic finite fields.</p>

    <p class="text-gray-300">In this context, today favorite finite fields targets are <span class="math">\\mathbb{F}_{p^{12}}</span> and <span class="math">\\mathbb{F}_{p^{6}}</span>. As already mentioned in <em>[19]</em>, the classical NFS whose relation search relies on polynomials of degree 1 (dimension 2) is not the best suited in those cases. Instead, if we want to optimize the number of relations found, we need to consider a variant of NFS in higher dimension, that is relying on polynomials of degree greater than 1. Although the complexity fits in the <span class="math">L(1/3,c)</span> class, these finite fields where higher dimensional sieving is required are those for which the constant <span class="math">c</span> is the highest compared to other finite fields, despite recent advances <em>[6, 25, 4, 21]</em>.</p>

    <p class="text-gray-300">The NFS algorithm is usually considered composed of four sub-algorithms: the <em>polynomial selection</em> which produces a pair of polynomials that define the number fields used in the <em>relation collection</em>, which in turn produces relations involving small elements of the number fields. When enough relations are produced, a <em>linear algebra</em> step provides the logarithms of the small elements. Then, an <em>individual logarithm</em> step computes the logarithm of the target element thanks to the logarithms of the small elements.</p>

    <p class="text-gray-300">In the literature, the two main computation examples using higher dimensional sieves which can serve as a reference to compare different variants and strategies are set in an <span class="math">\\mathbb{F}_{p^{6}}</span> of 240 bits and in an <span class="math">\\mathbb{F}_{p^{12}}</span> of 203 bits. The computation in <span class="math">\\mathbb{F}_{p^{12}}</span> is presented in <em>[16]</em>. It uses a sieve in</p>

    <p class="text-gray-300">dimension 7, a special-<span class="math">\\mathfrak{q}</span> strategy to divide the sieving region and a line sieve to enumerate the polynomials in each special-<span class="math">\\mathfrak{q}</span> lattice.</p>

    <p class="text-gray-300">There are several examples of computations in <span class="math">\\mathbb{F}_{p^{6}}</span>. In <em>[32]</em>, Zajac sets the first record computation. He uses a sieve in dimension 3, no special-<span class="math">\\mathfrak{q}</span> and a line sieve to enumerate the polynomials in the sieving region. In <em>[33]</em>, he also made experiments to apply a special-<span class="math">\\mathfrak{q}</span> strategy to divide the sieving region. He concluded that in his reference example it seemed too slow to provide any performance gain. In <em>[17]</em>, Hayasaka et al. targeted the same finite field but using both a special-<span class="math">\\mathfrak{q}</span> strategy and an adapted lattice-sieve enumeration inspired by Franke-Kleinung <em>[10]</em>. Their computation time is comparable, around 22-24 normalized CPU-days. Both results use the same polynomial pair which define the number fields.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">In this article we focus on improving the sieve in dimension 3, which is best suited to finite fields of the form <span class="math">\\mathbb{F}_{p^{6}}</span>. This is achieved by carefully analyzing the polynomial selection phase and adapt computations that are usually handled in dimension 2 to the case of dimension 3, for instance the <span class="math">\\alpha</span>-value and the Murphy-<span class="math">E</span> quantity. Besides, we compare different polynomial selection methods and take also into account that these polynomials will be used with a special-<span class="math">\\mathfrak{q}</span> strategy suggesting to introduce a controlled unbalance between them. We also consider the possibility of a Galois action for the polynomials which provide cheap relations, sparing some sieving time. Our goal is to output better polynomials to improve the relation productivity of the sieving phase.</p>

    <p class="text-gray-300">In order to validate these criteria for polynomial selection, in the end we have to rely on real computations. To that purpose, we implemented a 3-dimensional sieve with a special-<span class="math">\\mathfrak{q}</span> strategy and several adapted enumeration algorithms (line sieve, plane sieve and space sieve) to be able to run several experiments and compare different strategies.</p>

    <p class="text-gray-300">With our implementation, the improvements in the polynomial selection, and a Galois action of order 6, we were able to find a complete set of relations for the Zajac’s 40-bit <span class="math">p</span> in less than 1 normalized CPU-day. We ran two bigger computations in an <span class="math">\\mathbb{F}_{p^{6}}</span>, one with a 50-bit <span class="math">p</span> which ran in about 7 CPU-days and the second one with a 65-bit <span class="math">p</span> in about 790 CPU-days.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Background on special-<span class="math">\\mathfrak{q}</span> sieve, notation</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 The number field sieve</h3>

    <p class="text-gray-300">We recall briefly the general workflow of NFS in the context of finite fields <span class="math">\\mathbb{F}_{p^{n}}</span>, keeping in mind those of the form <span class="math">\\mathbb{F}_{p^{6}}</span> as our favorite targets. We take the occasion to fix the global notation used in the rest of the article.</p>

    <p class="text-gray-300">Using more than two polynomials in NFS (the so-called MNFS variants <em>[9, 8, 6, 25]</em>) has not yet been used for practical computations, even in the much easier case of integer factorization, so we stick to two polynomials. The setting starts therefore with two irreducible polynomials <span class="math">f_{0}</span> and <span class="math">f_{1}</span> over <span class="math">\\mathbb{Z}</span> that have a common irreducible factor of degree <span class="math">n</span> modulo <span class="math">p</span>. They define two number fields <span class="math">K_{f_{0}}</span> and <span class="math">K_{f_{1}}</span>. Then relations are collected by trying many content-free irreducible polynomials <span class="math">a</span>: each trial <span class="math">a</span> is viewed as an element of the field <span class="math">K_{f_{0}}</span> and one tests if the corresponding principal ideal is smooth, i.e. factors into prime ideals of norm less than a given smoothness bound. Similarly, a smoothness test is done in the other field <span class="math">K_{f_{1}}</span>, and if both sides are smooth, then we call it a relation. To detect that a principal ideal (<span class="math">a</span>) is smooth in a field <span class="math">K_{f}</span>, we start by testing the smoothness of its norm, which is an integer (or maybe a rational if <span class="math">f</span> is not monic) or simply the smoothness of its resultant with <span class="math">f</span>. In this article, we will talk indifferently about the norm and the resultant, keeping in mind that for steps of the algorithm after the relation collection, care must be taken if <span class="math">f</span> is not monic. Also, when a large prime power is involved, smoothness of the norm does not imply smoothness of the ideal.</p>

    <p class="text-gray-300">The set of polynomials <span class="math">a</span> that must be tried before finding enough relations is called the sieving region <span class="math">\\mathcal{S}</span>. The size of the coefficients of these is therefore <span class="math">(\\#\\mathcal{S})^{1/t}</span>, where <span class="math">t</span> is the number of coefficients of <span class="math">a</span> (that is its degree plus one), which is the dimension of the sieve.</p>

    <p class="text-gray-300">Since <span class="math">f_{0}</span> and <span class="math">f_{1}</span> must have degrees at least <span class="math">n</span>, this degree can be large compared to the size of <span class="math">p</span>, and then also to the size of the coefficients of the <span class="math">f_{i}</span>. At some point, <span class="math">n</span> becomes large enough so that the norms get smaller if we consider <span class="math">a</span>-polynomials with a larger value of <span class="math">t</span> and smaller coefficients: this is the reason why we have to sieve in dimension higher than <span class="math">2</span>.</p>

    <p class="text-gray-300">In order to speed-up the detection of smooth elements, a sieving procedure is used. For each prime ideal <span class="math">\\mathfrak{r}</span> in <span class="math">K_{f_{0}}</span> of norm less than a sieving bound (that is less than the smoothness bound), all the polynomials <span class="math">a</span> where <span class="math">\\mathfrak{r}</span> divides the corresponding principal ideal are marked as such. Storing the set of <span class="math">a</span>-polynomials in a <span class="math">t</span>-dimensional array, these locations are regularly spaced in memory, which speeds-up considerably the process. Once this has been done, the promising locations that have been hit many times are scrutinized more thoroughly for smoothness with the ECM algorithm. Of course this is also done with ideals in <span class="math">K_{f_{1}}</span>, and actually, the processing of the two sides is interleaved, so that ECM is run only if the <span class="math">a</span>-polynomial looks promising on both sides. We call threshold the bound on the number of bits left in the norm after sieving, used to define what “promising” means.</p>

    <p class="text-gray-300">Once we have collected more relations than the number of prime ideals less than the smoothness bound, the relations are interpreted as linear equations between the virtual logarithms <em>[29]</em> of those ideals thanks to Schirokauer maps. Then a sparse linear algebra step is performed to solve these equations. Finally, the so-called descent step <em>[14]</em> allows to deduce the discrete logarithm of any finite field element. Since we are mostly interested in sieving we do not say more about these steps. The overall complexity is in <span class="math">L_{p^{n}}(1/3,c+o(1))</span>, with a constant <span class="math">c</span> that varies from <span class="math">1.75</span> to <span class="math">2.21</span> depending on the variant that can be used (or from <span class="math">1.72</span> to <span class="math">2.16</span> with MNFS); but the practical consequence is unclear for the <span class="math">\\mathbb{F}_{p^{6}}</span> target for which the best algorithm to use for currently feasible sizes is still to be determined.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Using special-<span class="math">\\mathfrak{q}</span>’s</h3>

    <p class="text-gray-300">The special-<span class="math">\\mathfrak{q}</span> strategy introduced by Pollard <em>[26]</em> is a way to organize the exploration of the sieving region <span class="math">\\mathcal{S}</span>. Since most of the relations come from norms that are divisible by at least one not-so-small ideal, we do not lose much by exploring only locations with this property. Hence, we choose a list of prime ideals <span class="math">\\mathfrak{q}</span> of <span class="math">K_{f_{0}}</span> (we can choose <span class="math">K_{f_{1}}</span> instead) of norms less than the smoothness bound, but large enough (typically, above the sieving bound). We treat each <span class="math">\\mathfrak{q}</span> separately and consider the sublattice of <span class="math">a</span>-polynomials having divisibility by <span class="math">\\mathfrak{q}</span> in <span class="math">K_{f_{0}}</span>, that we call the <span class="math">\\mathfrak{q}</span>-lattice. For a given norm size, prime ideals of inertia degree more than <span class="math">1</span> are far less numerous than those of degree <span class="math">1</span>, so we consider only <span class="math">\\mathfrak{q}</span>’s of inertia degree <span class="math">1</span>. In <span class="math">K_{f_{0}}</span>, the element <span class="math">x</span> is not necessarily an integer; still, all but a tiny number of the <span class="math">\\mathfrak{q}</span>’s can be represented by two elements of the form <span class="math">(q,x-\\rho)</span>, where <span class="math">q</span> is the norm of <span class="math">\\mathfrak{q}</span> and <span class="math">\\rho</span> a root of <span class="math">f_{0}</span> modulo <span class="math">q</span>; a basis of the <span class="math">\\mathfrak{q}</span>-lattice is then given by <span class="math">(q,(x-\\rho),x(x-\\rho),\\ldots,x^{t-2}(x-\\rho))</span>. Applying the LLL algorithm, we obtain a reduced basis whose elements form a matrix <span class="math">M_{\\mathfrak{q}}</span>, such that for any vector <span class="math">c</span> with integral coefficients, the vector <span class="math">a=M_{\\mathfrak{q}}c</span> is in the <span class="math">\\mathfrak{q}</span>-lattice. Furthermore, taking all coefficients of <span class="math">c</span> bounded in absolute value by a bound <span class="math">H</span>, we get vectors <span class="math">a</span> that cover approximately the target sieving region <span class="math">\\mathcal{S}</span>. In fact, since two proportional <span class="math">a</span>-polynomials would give the same relation, we consider only <span class="math">c</span> vectors with a positive last coordinate. From now on, we will therefore always consider that the sieving region for <span class="math">c</span> is a cuboid <span class="math">\\mathcal{C}</span> of the form <span class="math">[-H_{0},H_{0}[\\times[-H_{1},H_{1}[\\times\\cdots\\times[0,H_{t-1}[</span>. To fit with the classical notation, in the case of <span class="math">3</span>-dimensional sieving that we will study at length, we will set <span class="math">I=2H_{0}</span>, <span class="math">J=2H_{1}</span>, and <span class="math">K=H_{2}</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Sieving in the special-<span class="math">\\mathfrak{q}</span>-lattice</h3>

    <p class="text-gray-300">For a given special-<span class="math">\\mathfrak{q}</span>, the sieving phase goes as follows. A <span class="math">t</span>-dimensional array corresponding to the cuboid <span class="math">\\mathcal{C}</span> is initialized with approximations of the logarithms of the norms. Then for each prime ideal <span class="math">\\mathfrak{r}</span> of norm less than the sieving bound, one has to find a description of the vectors <span class="math">c</span> that yield elements divisible by <span class="math">\\mathfrak{r}</span>, in order to enumerate and visit all the corresponding locations to subtract the logarithm of the norm of <span class="math">\\mathfrak{r}</span>. Only ideals of inertia degree less than <span class="math">t</span> can occur, so there is no need to consider the others.</p>

    <p class="text-gray-300">All but a tiny number of the ideals <span class="math">\\mathfrak{r}</span> of inertia degree <span class="math">d</span> are generated by two elements of the form <span class="math">(r,h(x))</span>, where <span class="math">r^{d}</span> is the norm of <span class="math">\\mathfrak{r}</span> and <span class="math">h</span> is a monic polynomial of degree <span class="math">d</span>. A basis of the lattice of <span class="math">a</span>-polynomials yielding divisibility by <span class="math">r</span> is <span class="math">(r,rx,\\ldots,rx^{d-1},h(x),xh(x),\\ldots,x^{t-d-1}h(x))</span>. Therefore, modulo <span class="math">r</span>, the first <span class="math">d</span> columns of the corresponding matrix are zero and its rank is <span class="math">t-d</span>. Hence this lattice can be described by a set of <span class="math">d</span> linear relations modulo <span class="math">r</span> between the coefficients of <span class="math">a</span>. We write these relations in a <span class="math">d\\times t</span> matrix <span class="math">U_{\\mathfrak{r}}</span> such that <span class="math">U_{\\mathfrak{r}}a\\equiv 0\\mod r</span> if and only if <span class="math">a</span> yields divisibility by <span class="math">\\mathfrak{r}</span>. This can be translated into a condition on the coefficients of <span class="math">c</span>: since <span class="math">a=M_{\\mathfrak{q}}c</span>, setting <span class="math">U_{\\mathfrak{q},\\mathfrak{r}}=U_{\\mathfrak{r}}M_{\\mathfrak{q}}</span>, we can identify the vectors <span class="math">c</span> yielding divisibility by <span class="math">\\mathfrak{r}</span> with the equation <span class="math">U_{\\mathfrak{q},\\mathfrak{r}}c\\equiv 0\\mod r</span>, where again, <span class="math">U_{\\mathfrak{q},\\mathfrak{r}}</span> is a <span class="math">d\\times t</span> matrix. In particular, in the most frequent case where <span class="math">\\mathfrak{r}</span> is of inertia degree <span class="math">1</span>, this becomes a single linear equation modulo <span class="math">r</span>. From this description, fast algorithms are described in Section 4; but before going into these details, we describe more thoroughly the polynomial selection step.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Polynomial selections</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Quality criteria</h3>

    <p class="text-gray-300">In the case of the classical NFS algorithm based on a <span class="math">2</span>-dimensional sieve, criteria to select the best polynomial pair among several candidates have been defined and refined over time <em>[24, 22, 1]</em>. Although the general idea remains the same, it is necessary to revisit them in the case of a <span class="math">t</span>-dimensional sieving for <span class="math">t&gt;2</span>, and in particular for <span class="math">t=3</span>.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.1.1 Size properties</h4>

    <p class="text-gray-300">The first and easiest criterion is to compute an upper bound on the sizes of the norms corresponding to both polynomials. This is enough for getting the optimal theoretical complexities, and can also be used as a first filter in practice.</p>

    <p class="text-gray-300">Let <span class="math">(f_{0},f_{1})</span> be the polynomial pair to be studied. In order to give a bound on the corresponding norms, it is first necessary to get an estimate on the size of the sieving region <span class="math">\\mathcal{S}</span>. Doing that from a theoretical point of view is classical, but often imprecise compared to what is obtained in practice. The strategy is therefore as follows: a crude estimate for <span class="math">\\#\\mathcal{S}</span> is made, which allows, taking other criteria into account, to select a not-so-bad pair; then running some sample sieving, it is possible to get a much better view of the actual sieving region size, and the polynomial selection is run again, possibly giving a better pair. This bootstrapping process does not have to be done again for each finite field: all the fields <span class="math">\\mathbb{F}_{p^{n}}</span> for fixed <span class="math">n</span> and <span class="math">p</span> of similar sizes will behave similarly. So from now on, we assume that an estimate for <span class="math">\\#\\mathcal{S}</span> is known.</p>

    <p class="text-gray-300">Then the skewness must be taken into account. If all the coefficients of <span class="math">f_{0}</span> (resp. of <span class="math">f_{1}</span>) are of similar sizes, the smallest upper bound is obtained by taking all the coefficients of <span class="math">a</span> bounded by the same value <span class="math">(\\#\\mathcal{S})^{1/t}</span>. On the other hand, if one of the <span class="math">f_{i}</span> is skewed, i.e. its coefficients have a size that decreases with the degree, then it is better to choose <span class="math">a</span>-polynomials with the same property. This is even more true if both <span class="math">f_{0}</span> and <span class="math">f_{1}</span> are skewed. The ratio between the size of two consecutive coefficients of the <span class="math">a</span>-polynomials is called the skewness.</p>

    <p class="text-gray-300">Finally, having taken into account the size of the sieving region and the skewness, it is possible to obtain an upper bound for each norm. It remains to subtract from one of them the size of the special-q that is planned to be used (again, it might be necessary to bootstrap with some crude sieving experiments to tune this size).</p>

    <p class="text-gray-300">The first criterion is then to select the polynomial pair for which the sum of the sizes of the norms on both sides is minimal. This can be refined to take into account the fact that the Dickman rho function is convex: in a list of polynomial pairs that yield a similar value for the sum of the sizes of the norms, it is better to choose the pair for which the norms have sizes as close as possible to each other.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.1.2 Local properties</h4>

    <p class="text-gray-300">We now study the effect of local properties, i.e. the fact that the polynomials can have many roots modulo small primes. This is done on each side independently. Therefore, we let <span class="math">f</span> be an irreducible polynomial in <span class="math">\\mathbb{Z}[x]</span>, that in the end will be either <span class="math">f_{0}</span> or <span class="math">f_{1}</span>. The <span class="math">\\alpha</span> quantity related to <span class="math">f</span>, that we denote <span class="math">\\alpha(f)</span>, measures the difference in terms of smoothness probability between an integer obtained by computing the resultant of <span class="math">f</span> and a polynomial of degree <span class="math">t-1</span> and a random integer of the same size. In other words, if a norm has size <span class="math">A</span>, it will be smooth with the same probability as a random integer of size <span class="math">A+\\alpha(f)</span>. A negative value for <span class="math">\\alpha(f)</span> is a characteristic of a good polynomial <span class="math">f</span>. In the following formal definition of <span class="math">\\alpha</span>, the size of an integer is given by the natural logarithm, in conformance with the traditional definition of <span class="math">\\alpha</span> in dimension <span class="math">2</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">f</span> be an irreducible polynomial in <span class="math">\\mathbb{Z}[x]</span>. Let <span class="math">\\mathcal{S}</span> be the set of content-free irreducible polynomials of degree <span class="math">t-1</span> over <span class="math">\\mathbb{Z}</span>. For a prime <span class="math">\\ell</span>, the local <span class="math">\\alpha</span>-value of <span class="math">f</span> at <span class="math">\\ell</span> is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\alpha_{\\ell}(f)=\\log(\\ell)\\Big{(}\\mathbb{A}\\big{(}\\operatorname{val}_{\\ell}(n)\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,n\\in\\mathbb{Z}\\big{)}-\\mathbb{A}\\big{(}\\operatorname{val}_{\\ell}(\\operatorname{Res}(f,a))\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,a\\in\\mathcal{S}\\big{)}\\Big{)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\operatorname{val}_{\\ell}</span> denotes the <span class="math">\\ell</span>-adic valuation and <span class="math">\\mathbb{A}()</span> is the average value. The <span class="math">\\alpha</span>-value of <span class="math">f</span> is then defined as the sum over all primes <span class="math">\\alpha(f)=\\sum_{\\ell}\\alpha_{\\ell}(f)</span>.</p>

    <p class="text-gray-300">In this definition, the average value <span class="math">\\mathbb{A}()</span> is defined by taking the limit of the average value of the quantity for increasingly large finite subsets of the whole considered set. To disambiguate this choice, we take these subsets as intersections of <span class="math">\\mathcal{S}</span> with centered balls of increasing radius. Another potential issue with this definition is the convergence of the series defining <span class="math">\\alpha(f)</span>. We leave it as a conjecture, since adapting the proof of <em>[5]</em> goes beyond the scope of this article.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The quantity $\\mathbb{A}\\big{(}\\operatorname{val}_{\\ell}(n)\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,n\\in\\mathbb{Z}\\big{)}<span class="math"> is equal to </span>1/(\\ell-1)<span class="math">. The other part of the formula defining </span>\\alpha_{\\ell}(f)<span class="math"> can be simplified when </span>\\ell<span class="math"> does not divide the leading coefficient of </span>f<span class="math"> nor its discriminant. The case of </span>t=2<span class="math"> is well known <em>[24]</em> and yields </span>\\alpha_{\\ell}(f)=\\frac{\\log(\\ell)}{\\ell-1}(1-\\frac{\\ell}{\\ell+1}n_{1})<span class="math">, where </span>n_{1}<span class="math"> is the number of roots of </span>f<span class="math"> modulo </span>\\ell<span class="math">. We derive the same kind of formula for the case </span>t=3$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proposition 2.</h6>

    <p class="text-gray-300">Let <span class="math">f</span> be an irreducible polynomial in <span class="math">\\mathbb{Z}[x]</span> and <span class="math">\\ell</span> be a prime not dividing the leading coefficient of <span class="math">f</span> nor its discriminant. Then, in the case of sieving in dimension <span class="math">t=3</span>,</p>

    <p class="text-gray-300"><span class="math">\\alpha_{\\ell}(f)=\\frac{\\log(\\ell)}{\\ell-1}\\ \\left(1\\,-\\,n_{1}\\frac{\\ell(\\ell+1)}{\\ell^{2}+\\ell+1}\\,-\\,2n_{2}\\frac{\\ell^{2}}{(\\ell+1)(\\ell^{2}+\\ell+1)}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">n_{1}</span> and <span class="math">n_{2}</span> are the number of linear (resp. degree 2) irreducible factors of <span class="math">f</span> modulo <span class="math">\\ell</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The condition on the leading coefficient allows to avoid questions about projective roots, and the condition on the discriminant implies that any irreducible factor of <span class="math">f</span> modulo <span class="math">\\ell</span> can be lifted to an irreducible factor of <span class="math">f</span> of the same degree over the <span class="math">\\ell</span>-adic ring <span class="math">\\mathbb{Z}_{\\ell}</span></p>

    <p class="text-gray-300">Let <span class="math">\\varphi</span> be a quadratic irreducible factor of <span class="math">f</span> over <span class="math">\\mathbb{Z}_{\\ell}</span>. Let <span class="math">a(x)</span> be a quadratic polynomial with coefficients in <span class="math">\\mathbb{Z}</span> whose content is not divisible by <span class="math">\\ell</span>. Then the <span class="math">\\ell</span>-adic valuation of the resultant of <span class="math">\\varphi</span> and <span class="math">a(x)</span> is <span class="math">2k</span>, where <span class="math">k</span> is the largest integer such that <span class="math">a(x)</span> is proportional to <span class="math">\\varphi</span> modulo <span class="math">\\ell^{k}</span>. The number of <span class="math">a(x)</span> with coefficients in <span class="math">[0,\\ell^{k}-1]</span> that satisfy this condition is <span class="math">\\ell^{k}-\\ell^{k-1}</span> since they are the polynomials of the form <span class="math">\\gamma\\varphi</span>, where <span class="math">\\gamma</span> is not divisible by <span class="math">\\ell</span>. Furthermore, the number of polynomials <span class="math">a(x)</span> with coefficients in <span class="math">[0,\\ell^{k}-1]</span> whose content is not divisible by <span class="math">\\ell</span> is <span class="math">\\ell^{3k}-\\ell^{3k-3}</span>. Hence the proportion of those polynomials for which the valuation of its resultant with <span class="math">\\varphi</span> is at least <span class="math">2k</span> is <span class="math">(\\ell^{k}-\\ell^{k-1})/(\\ell^{3k}-\\ell^{3k-3})</span>. Finally the contribution due to <span class="math">\\varphi</span> in the expected valuation of the resultant of <span class="math">f</span> and <span class="math">a</span> is <span class="math">\\sum_{k\\geqslant 1}2\\frac{\\ell^{k}-\\ell^{k-1}}{\\ell^{3k}-\\ell^{3k-3}}=\\frac{2\\ell^{2}}{(\\ell^{2}-1)(\\ell^{2}+\\ell+1)}</span>.</p>

    <p class="text-gray-300">The case of the contributions of roots of <span class="math">f</span> is handled similarly: the number of polynomials <span class="math">a(x)</span> with coefficients in <span class="math">[0,\\ell^{k}-1]</span> whose content is not divisible by <span class="math">\\ell</span> and that give a value divisible by <span class="math">\\ell^{k}</span> when evaluated at an <span class="math">\\ell</span>-adic root <span class="math">\\rho</span> of <span class="math">f</span> is <span class="math">\\ell^{2k}-\\ell^{2k-2}</span>, since they are all of the form <span class="math">(x-\\rho)(\\alpha x-\\beta)</span>, with <span class="math">\\alpha</span> and <span class="math">\\beta</span> in <span class="math">[0,\\ell^{k}-1]</span> and not simultaneously divisible by <span class="math">\\ell</span>. Therefore the contribution of a root <span class="math">\\rho</span> in the expected valuation of the resultant of <span class="math">f</span> and <span class="math">a</span> is <span class="math">\\sum_{k\\geqslant 1}\\frac{\\ell^{2k}-\\ell^{2k-2}}{\\ell^{3k}-\\ell^{3k-3}}=\\frac{\\ell^{2}+\\ell}{\\ell^{2}-1}</span>. ∎</p>

    <p class="text-gray-300">When the proposition does not apply, the natural workaround is to compute the factorization of <span class="math">f</span> over the <span class="math">\\ell</span>-adic field (see for instance <em>[7, Chapter 6.1]</em>) and for each factor do the same kind of study as in the proof of the proposition. One could argue that, anyway, since computing the <span class="math">\\ell</span>-maximal order is required for converting relations to rows of the matrix, this is appropriate. However, computing <span class="math">\\alpha</span> must be as fast as possible because we might want to investigate billions of polynomials. In the classical 2-dimensional case, a very simple lifting is enough to deduce the average <span class="math">\\ell</span>-adic valuation. In Appendix A, we sketch a similar approach that, in many cases, will give the average valuation without having to perform a full <span class="math">\\ell</span>-adic factorization.</p>

    <p class="text-gray-300">Finally, the case where <span class="math">\\ell</span> divides the leading coefficient of <span class="math">f</span> is dealt with by adding the contribution of the (possibly multiple) root <span class="math">0</span> in the reverted polynomial <span class="math">f(1/x)x^{\\deg f}</span>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">3.1.3 A 3-dimensional Murphy-<span class="math">E</span></h4>

    <p class="text-gray-300">The Murphy-<span class="math">E</span> quantity has been introduced in <em>[24]</em> as an estimate of the average smoothness probability of the norms corresponding to a sieving region. In the most precise variant the sieving region is replaced by a volume in <span class="math">\\mathbb{R}^{3}</span>, leading to the following definition, where we assume that the special-<span class="math">\\mathfrak{q}</span>’s are chosen in <span class="math">K_{f_{0}}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">Let <span class="math">(f_{0},f_{1})</span> be a pair of irreducible polynomials used in the NFS algorithm, <span class="math">\\mathcal{S}</span> a volume in <span class="math">\\mathbb{R}^{3}</span> approximating the sieving region, and <span class="math">B</span> the smoothness bound. Let <span class="math">Q</span> be the average size of the special-<span class="math">\\mathfrak{q}</span>’s on the <span class="math">f_{0}</span>-side. The Murphy-<span class="math">E</span> function is defined by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$E(f_{0},f_{1},\\mathcal{S},B,Q)=\\int_{a\\in\\mathcal{S}}\\rho\\left(\\frac{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}(f_{0},a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-Q+\\alpha(f_{0})}{\\log B}\\right)\\rho\\left(\\frac{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}(f_{1},a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\alpha(f_{1})}{\\log B}\\right),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\rho</span> is Dickman’s rho function.</p>

    <p class="text-gray-300">This 3-dimensional integral is in general too costly to compute when we have a large set of polynomial pair candidates to select from. Various approaches have been taken in dimension 2, and we follow the one taken in CADO-NFS (see <em>[31]</em>), which is inspired from Kleinjung’s code and Murphy’s thesis. The idea is to use a Monte-Carlo approach, not on <span class="math">\\mathcal{S}</span> itself but on its boundary, so that the dimension drops by one. The rationale is that when we multiply a polynomial <span class="math">a</span> by a scalar <span class="math">r</span>, the resultant with <span class="math">f</span> is multiplied by <span class="math">r^{\\deg f}</span>, and therefore the sizes of the norms on a line through the origin are well controlled once one value on it is known.</p>

    <p class="text-gray-300">With the special-<span class="math">\\mathfrak{q}</span> sieving strategy, since we are dealing with many ideals <span class="math">\\mathfrak{q}</span>, each of them favoring some direction, viewed globally the general shape of the sieving region will be a sphere, or an ellipsoid if there is some skewness in <span class="math">f_{0}</span> and <span class="math">f_{1}</span>. Hence, we will use this approximation</p>

    <p class="text-gray-300">for computing a Murphy-<span class="math">E</span> value and compare the polynomial pairs: we pick a sphere or an ellipsoid corresponding to our sieving region, and perform a Monte-Carlo evaluation of the integral on its surface. In practice, we found it convenient to use a Fibonacci sphere <em>[12]</em> as evaluation points.</p>

    <p class="text-gray-300">Finally, in the classical 2-dimensional NFS, having many real roots tends to increase the Murphy-<span class="math">E</span> value. We describe an analogue for 3-dimensional sieving in Appendix B, but this is not really another criterion, because it is already captured by Murphy-<span class="math">E</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">3.1.4 Explicit Galois action</h4>

    <p class="text-gray-300">An additional criterion that must be taken into account is the possible existence of an explicit Galois action that takes the same form for <span class="math">f_{0}</span> and <span class="math">f_{1}</span>. Examples are given in <em>[2]</em> and we also use some in our experiments. For a polynomial <span class="math">f</span>, and a homography <span class="math">\\sigma(x)=n(x)/d(x)</span>, we define <span class="math">f^{\\sigma}(x)=f(\\sigma(x))d(x)^{\\deg f}</span>. Then, <span class="math">\\sigma</span> is said to be an explicit Galois action for <span class="math">f</span> if <span class="math">f^{\\sigma}</span> is proportional to <span class="math">f</span>. In that case, <span class="math">\\sigma</span> is an automorphism of the number field <span class="math">K_{f}</span>. In this field, <span class="math">a(\\sigma(x))</span> is a conjugate of <span class="math">a(x)</span>: they have the same norm. In our context we need to work with polynomials, so we consider <span class="math">a^{\\sigma}=a(\\sigma(x))d(x)^{\\deg a}</span>. The norm is therefore multiplied by the norm of <span class="math">d(x)^{\\deg a}</span>, which is typically a small, smooth number.</p>

    <p class="text-gray-300">We have shown that if <span class="math">\\sigma</span> is an explicit Galois action for <span class="math">f_{0}</span> and <span class="math">f_{1}</span>, and if <span class="math">a</span> is a polynomial that has a smooth norm on both sides and hence yields a relation, then <span class="math">a^{\\sigma}</span> also yields a relation. And in fact, if <span class="math">\\sigma</span> is of order <span class="math">k</span>, then we can deduce <span class="math">k-1</span> additional relations from each relation obtained by sieving, by letting <span class="math">\\sigma</span> act on <span class="math">a</span>.</p>

    <p class="text-gray-300">In a special-<span class="math">\\mathfrak{q}</span> context, it is simple to organize the computation in order to save a factor <span class="math">k</span> in the relation collection phase. Indeed, the special-<span class="math">\\mathfrak{q}</span>’s can be organized in orbits of <span class="math">k</span> conjugate ideals, and if a polynomial <span class="math">a</span> yields a principal divisor divisible by <span class="math">\\mathfrak{q}</span>, then <span class="math">a^{\\sigma}</span> yields a principal divisor divisible by <span class="math">\\mathfrak{q}^{\\sigma}</span>. It is therefore enough to sieve only one of the special-<span class="math">\\mathfrak{q}</span>’s per orbit, and to derive relations for the other special-<span class="math">\\mathfrak{q}</span>’s with conjugation by <span class="math">\\sigma</span>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.2 Several strategies</h3>

    <p class="text-gray-300">We now review the different polynomial selection methods that could make sense for a finite field <span class="math">\\mathbb{F}_{p^{6}}</span>; we present them for any field <span class="math">\\mathbb{F}_{p^{n}}</span>, but we keep this target in mind. We do not discuss the SNFS case <em>[20]</em>, where the polynomials are directly derived from a special form of <span class="math">p</span>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">3.2.1 Adapting the JLSV strategy to special-<span class="math">\\mathfrak{q}</span> sieving</h4>

    <p class="text-gray-300">The most basic polynomial selection method adapted to our case is the one proposed by Joux-Lercier-Smart-Vercauteren in <em>[19]</em>: we pick first a polynomial <span class="math">f_{0}</span> of degree <span class="math">n</span> with small coefficients, that is irreducible modulo <span class="math">p</span>; then <span class="math">f_{1}</span> is set to <span class="math">f_{1}=f_{0}+p</span>. The polynomial <span class="math">f_{1}</span> resulting from this construction is skewed, while <span class="math">f_{0}</span> is not; but since <span class="math">f_{1}</span> is the polynomial that yields the largest norms, it make sense to sieve <span class="math">a</span>-polynomials with the skewness of <span class="math">f_{1}</span>, namely <span class="math">p^{1/n}</span>.</p>

    <p class="text-gray-300">A first improvement to this method was proposed in <em>[19]</em>, and was used in particular in <em>[6, 2, 25]</em>. The goal is to obtain polynomials <span class="math">f_{0}</span> and <span class="math">f_{1}</span>, without skewness and of similar sizes, so that the norms are balanced. We propose a modification of this polynomial selection to take into account the fact that we use a special-<span class="math">\\mathfrak{q}</span> sieving: the goal is now to obtain norms of slightly different sizes, so that after dividing out by the special-<span class="math">\\mathfrak{q}</span>, they become of the same size.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">Q</span> be the average value of <span class="math">q</span> for all the special-<span class="math">\\mathfrak{q}</span>’s we consider, and assume that we are going to take them on the <span class="math">f_{1}</span>-side. We first look for an irreducible polynomial <span class="math">f_{0}</span> such that <span class="math">f_{0}=\\pi+\\eta\\rho</span> with <span class="math">\\pi</span> and <span class="math">\\rho</span> two polynomials with small integer coefficients and of degree at most <span class="math">n</span>, with at least one of them of degree exactly <span class="math">n</span>, and with <span class="math">\\eta</span> an integer close to <span class="math">p^{1/2-\\epsilon}</span>, with <span class="math">0&lt;\\epsilon&lt;1/2</span>. Thanks to the extended Euclidean algorithm, we then compute <span class="math">\\kappa</span> and <span class="math">\\lambda</span> such that <span class="math">\\eta\\equiv\\kappa/\\lambda\\bmod p</span>, with <span class="math">\\kappa\\approx p^{1/2-\\epsilon}</span> and <span class="math">\\lambda\\approx p^{1/2+\\epsilon}</span>, to define <span class="math">f_{1}=\\lambda\\pi+\\kappa\\rho</span> with coefficients of size <span class="math">O\\big{(}p^{1/2+\\epsilon}\\big{)}</span>. Using a crude upper bound, the ratio between the norms on both sides is $N_{f_{1}}(a)/N_{f_{0}}(a)\\approx\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{1}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{t-1}/\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{0}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{t-1}\\approx p^{2\\epsilon(t-1)}<span class="math">. By taking </span>\\epsilon=\\log_{p}{(Q)}/(2(t-1))$, we can ensure</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">that this ratio is close to <span class="math">Q</span>, and therefore, we obtain balanced norms after taking the special-q sieving into account.</p>

    <p class="text-gray-300">As explained in <em>[2]</em>, by using specific <span class="math">\\pi</span> and <span class="math">\\rho</span> polynomials, it is possible to enforce a Galois action of order <span class="math">n</span>, at least for small values of <span class="math">n</span>. This is still true with our unbalanced version. Finally, for a given choice of <span class="math">f_{0}</span> and the <span class="math">f_{1}</span> following our construction, it is possible to find other choices for <span class="math">f_{1}</span> by adding to it a small multiple of <span class="math">f_{0}</span>. Since the coefficients of <span class="math">f_{0}</span> are smaller than those of <span class="math">f_{1}</span>, there are many choices that do not change the size properties, so that we can select the <span class="math">f_{1}</span> with the best other criteria, in particular its <span class="math">\\alpha</span> value.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">3.2.2 Sarkar-Singh constructions for <span class="math">\\mathbb{F}_{p^{6}}</span></h4>

    <p class="text-gray-300">We recall the Sarkar-Singh method, in a slightly less general setting than in <em>[28]</em>, since we always set <span class="math">r=k=n/d</span> in the Algorithm <span class="math">\\mathcal{A}</span> of this article; on the other hand we do not insist on having monic polynomials. The method is parametrized by a divisor <span class="math">d</span> of <span class="math">n</span>; for <span class="math">d=1</span> we recover the GJL construction and for <span class="math">d=n</span>, the Conjugation method (see <em>[2]</em> for the original description of GJL and Conjugation methods). For <span class="math">n=6</span>, we have two additional cases, <span class="math">d=2</span> and <span class="math">d=3</span>, to consider.</p>

    <p class="text-gray-300">The construction works as follows. Let <span class="math">\\pi</span> and <span class="math">\\rho</span> be two polynomials with small integer coefficients with <span class="math">\\pi</span> of degree <span class="math">d</span> and <span class="math">\\rho</span> of degree at most <span class="math">d-1</span>. Then, we pick a polynomial <span class="math">A</span> of degree <span class="math">1+n/d</span> with small integer coefficients, irreducible over <span class="math">\\mathbb{Z}</span>, and that admits an irreducible factor <span class="math">\\Phi</span> of degree <span class="math">n/d</span> modulo <span class="math">p</span>. The polynomial <span class="math">f_{0}</span> is then defined by <span class="math">f_{0}(x)=\\text{Res}_{y}(A(y),\\pi(x)+y\\rho(x))</span>; it is of degree <span class="math">n+d</span>, and has small coefficients. If it is not irreducible we restart the construction with other choices. The polynomial defining <span class="math">\\mathbb{F}_{p^{n}}</span> in this setting is <span class="math">\\varphi(x)=\\text{Res}_{y}(\\Phi(y),\\pi(x)+y\\rho(x))</span> mod <span class="math">p</span>, therefore, if it is not irreducible over <span class="math">\\mathbb{F}_{p}</span>, we have also to start over with other choices. To construct <span class="math">f_{1}</span>, we first use a lattice basis reduction to compute a polynomial <span class="math">\\Psi</span> over <span class="math">\\mathbb{F}_{p}</span> proportional to <span class="math">\\Phi</span> with coefficients represented by integers of sizes approximately <span class="math">p^{n/(n+d)}</span>. The polynomial <span class="math">f_{1}</span> is then defined by <span class="math">f_{1}=\\text{Res}_{y}(\\Psi(y),\\pi(x)+y\\rho(x))</span>; it is of degree <span class="math">n</span> and its coefficients have sizes about <span class="math">p^{n/(n+d)}</span>, and again we check its irreducibility over <span class="math">\\mathbb{Z}</span> and repeat the whole procedure if it is not the case. In Table 1 of the Appendix, we summarize the sizes of the coefficients and the degree of <span class="math">f_{0}</span> and <span class="math">f_{1}</span> for the case <span class="math">n=6</span>.</p>

    <p class="text-gray-300">Just as for the JLSV construction, it is possible to choose <span class="math">\\pi</span> and <span class="math">\\rho</span> in order to enforce a common explicit Galois action for <span class="math">f_{0}</span> and <span class="math">f_{1}</span> of order <span class="math">d</span>. A drawback of this method compared to JLSV is that there is less room to play for optimizing the <span class="math">\\alpha</span>-value of the polynomials.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 Special-q sieve in dimension 3</h2>

    <p class="text-gray-300">For finite fields of the form <span class="math">\\mathbb{F}_{p^{6}}</span> of sizes that are within reach with current technology and algorithms, it is difficult to predict which polynomial selection method is the best. We will therefore rely on practical experiments, based on the runtime of a sieve implementation to decide and validate our criteria. In this setting, the optimal sieving dimension is 3. It might be 4 for small values of <span class="math">p</span>, where it is unclear whether NFS is actually the best available algorithm; and for a sufficiently large value of <span class="math">p</span>, the best sieving dimension will eventually become 2, but this will occur for sizes that are too large to run meaningful experiments. Therefore, we concentrate on the 3-dimensional sieving.</p>

    <p class="text-gray-300">In the factor base, most of the ideals are of inertia degree 1, so we describe our sieving procedure only for this case. In fact we consider a slightly more restrictive situation. From Section 2.3 the vectors <span class="math">c=(x,y,z)</span> that yield elements divisible by a factor base ideal r are those whose coordinates verify a modular linear relation, and we assume that this relation is of the form</p>

    <p class="text-gray-300"><span class="math">x+By+Cz\\equiv 0\\mod r,</span> (1)</p>

    <p class="text-gray-300">where <span class="math">r</span> is the norm of the ideal r, and <span class="math">B</span> is non-zero. This avoid complications due to projective roots (or generalizations thereof to dimension 3).</p>

    <p class="text-gray-300">In order to obtain elements <span class="math">a=M_{\\mathfrak{q}}c</span> in the target sieving region <span class="math">\\mathcal{S}</span>, and norms of controlled sizes, we are interested in vectors <span class="math">c</span> in the cuboid <span class="math">\\mathcal{C}</span> of size <span class="math">I\\times J\\times K</span>. Our convention for the memory organization of this cuboid is <span class="math">z</span>-major, and then <span class="math">y</span>-major for each <span class="math">xy</span>-plane (i.e. fixed-<span class="math">z</span>-plane). Hence, for fixed values of <span class="math">y</span> and <span class="math">z</span>, the corresponding <span class="math">x</span>-line contains cells that are contiguous in memory. With this setting, for ideals of tiny norms <span class="math">r&lt;I</span>, it makes sense to do <em>line-sieving</em>. When <span class="math">r</span> becomes larger than <span class="math">I</span>, the average number of hits per <span class="math">x</span>-line is less than 1, and line-sieving is suboptimal: Franke-Kleijung’s <em>plane-sieving</em> is then more appropriate. But then again, when <span class="math">r</span> becomes larger than <span class="math">IJ</span>, the average number of hits per <span class="math">xy</span>-plane is less than 1, and it is better to switch to a <em>space-sieve</em> strategy.</p>

    <p class="text-gray-300">Line sieving is the most basic sieving strategy: after specializing all-but-one coordinates, this becomes a one-dimensional sieve, and one can jump from one hit location to the other by just adding <span class="math">r</span> to the location index. For fixed <span class="math">y</span> and <span class="math">z</span> coordinates, finding the initial hit location amount to solving the linear equation 4.1 to get the smallest <span class="math">x</span> solution within the given range. We remark furthermore that solving this problem for <span class="math">(y+1,z)</span> after having solved it for <span class="math">(y,z)</span> costs essentially no more than one addition modulo <span class="math">r</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.1 Plane sieve</h3>

    <p class="text-gray-300">The plane sieve is for sieving ideals whose norms <span class="math">r</span> are of intermediate sizes. It works only for <span class="math">r&gt;I</span>, and we assume this from now on. The general idea is to process all the <span class="math">xy</span>-planes in turn, by increasing values of <span class="math">z</span>. For a given value of <span class="math">z</span>, there are two problems to solve: first, we need to find an initial hit location in the intersection of the given plane and the cuboid <span class="math">\\mathcal{C}</span>, and second, we need to adapt Franke-Kleinjung’s algorithm (FK-algorithm, for short) in order to visit efficiently all the other hit locations in the plane.</p>

    <p class="text-gray-300">We denote by <span class="math">\\Lambda</span> the lattice corresponding to the vectors <span class="math">c</span> that verify Equation 4.1, or equivalently that corresponds to divisibility by the ideal <span class="math">\\mathfrak{r}</span>. For any <span class="math">z_{0}</span>, we denote by <span class="math">\\Lambda_{z_{0}}</span> the intersection of <span class="math">\\Lambda</span> and the plane of equation <span class="math">z=z_{0}</span>. The set of points in <span class="math">\\Lambda_{0}</span> form a 2-dimensional lattice of volume <span class="math">r</span>, and <span class="math">\\Lambda_{z_{0}}</span> is a translate of <span class="math">\\Lambda_{0}</span>. The FK-algorithm relies on a particular basis for almost all 2-dimensional lattices, adapted to the bound <span class="math">I</span> on the <span class="math">x</span>-coordinate: in <em>[10, Proposition 1]</em>, it is shown that there exists a unique basis <span class="math">\\{(\\alpha,\\beta)^{T},(\\gamma,\\delta)^{T}\\}</span> of the lattice <span class="math">\\Lambda_{0}</span>, called FK-basis, which can be efficiently computed using the extended Euclidean algorithm, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta&gt;0</span> and <span class="math">\\gamma&gt;0</span>;</li>

      <li><span class="math">-I&lt;\\alpha\\leqslant 0\\leqslant\\gamma&lt;I</span>;</li>

      <li><span class="math">\\gamma-\\alpha\\geqslant I</span>.</li>

    </ul>

    <p class="text-gray-300">Using this basis, the classical FK-algorithm allows to enumerate the elements of <span class="math">\\Lambda_{0}</span> whose <span class="math">x</span>-coordinate is within an interval of size <span class="math">I</span>, by increasing value of <span class="math">y</span>. The following proposition shows that with a natural extension of the FK-algorithm, it is possible to enumerate the elements of <span class="math">\\Lambda_{z_{0}}</span> whose <span class="math">x</span>-coordinate is within an interval of size <span class="math">I</span>, by increasing and decreasing values of <span class="math">y</span>; finding an initial point with the smallest <span class="math">y</span>-value is therefore not necessary.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 4.</h6>

    <p class="text-gray-300">Let <span class="math">I&gt;0</span> be an integer and let <span class="math">\\Lambda</span> be a 3-dimensional lattice of volume <span class="math">r&gt;I</span>. Let <span class="math">\\{(\\alpha,\\beta)^{T},(\\gamma,\\delta)^{T}\\}</span> be the FK-basis of the intersection of <span class="math">\\Lambda</span> with the <span class="math">xy</span>-plane. Let <span class="math">A</span> be an integer, and <span class="math">\\mathcal{A}=[A,A+I[</span> the corresponding interval of length <span class="math">I</span>. Let <span class="math">z_{0}</span> be a fixed third coordinate for elements of <span class="math">\\Lambda</span>. Let <span class="math">c=(x_{0},y_{0},z_{0})</span> be an element of <span class="math">\\Lambda_{z_{0}}</span> with <span class="math">x_{0}\\in\\mathcal{A}</span>. Then the point of <span class="math">\\Lambda_{z_{0}}</span>, with an abscissa in <span class="math">\\mathcal{A}</span> and with the smallest <span class="math">y</span>-coordinate larger than <span class="math">y_{0}</span> is obtained by adding to <span class="math">c</span> one of the following vector:</p>

    <p class="text-gray-300">\\[ \\begin{cases}(\\alpha,\\beta,0)^{T}&\\text{if }x_{0}\\geqslant A-\\alpha,\\\\ (\\gamma,\\delta,0)^{T}&\\text{if }x_{0}<A+I-\\gamma,\\\\ (\\alpha,\\beta,0)^{T}+(\\gamma,\\delta,0)^{T}&\\text{if }A+I-\\gamma\\leqslant x_{0}<A-\\alpha.\\end{cases} \\] (4.2)</p>

    <p class="text-gray-300">P. GAUDRY, L. GRÉMY AND M. VIDEAU</p>

    <p class="text-gray-300">Similarly, the point of <span class="math">\\Lambda_{z_0}</span>, with an abscissa in <span class="math">\\mathcal{A}</span> and with the largest <span class="math">y</span>-coordinate smaller than <span class="math">y_0</span> is obtained by subtracting to <span class="math">c</span> one of the following vector:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l l} (\\alpha , \\beta , 0) ^ {T} &amp;amp; \\text{if } x_0 &amp;lt; A + I + \\alpha , \\\\ (\\gamma , \\delta , 0) ^ {T} &amp;amp; \\text{if } x_0 \\geqslant A + \\gamma , \\\\ (\\alpha , \\beta , 0) ^ {T} + (\\gamma , \\delta , 0) ^ {T} &amp;amp; \\text{if } A + I + \\alpha \\leqslant x_0 &amp;lt; A + \\gamma . \\end{array} \\right. \\tag {4.3}</span></div>

    <p class="text-gray-300">Proof. Let <span class="math">c = (x_0, y_0, z_0)</span> be an element of <span class="math">\\Lambda_{z_0}</span> with <span class="math">x_0 \\in \\mathcal{A}</span>. Let <span class="math">c&#x27; = (x_0&#x27;, y_0&#x27;, z_0)</span> be the vector obtained by applying Equation 4.2 to it, and <span class="math">c&#x27;&#x27; = (x_0&#x27;&#x27;, y_0&#x27;&#x27;, z_0)</span> be the vector of <span class="math">\\Lambda_{z_0} \\cap (\\mathcal{A} \\times \\mathbb{Z} \\times \\{z_0\\})</span> with the smallest <span class="math">y</span>-coordinate that is larger than <span class="math">y_0</span>. We want to show that <span class="math">c&#x27;&#x27;</span> is equal to <span class="math">c&#x27;</span>. Let <span class="math">u \\in \\Lambda</span> be defined by <span class="math">u = (0, -C / B \\bmod r, 1)</span>, with the notations of Equation 4.1. Subtracting <span class="math">z_0u</span> to <span class="math">c</span>, <span class="math">c&#x27;</span> and <span class="math">c&#x27;&#x27;</span>, we obtain three vectors <span class="math">\\underline{c}</span>, <span class="math">\\underline{c}&#x27;</span> and <span class="math">\\underline{c}&#x27;&#x27;</span>, in <span class="math">\\Lambda_0</span> while preserving their <span class="math">x</span>-coordinates, and translating their <span class="math">y</span>-coordinates by a constant. Contrarily to <span class="math">\\Lambda_{z_0}</span>, <span class="math">\\Lambda_0</span> is a lattice, therefore we are exactly in the context of the 2-dimensional FK-algorithm, and by [10, Proposition 2], we must have <span class="math">\\underline{c}&#x27; = \\underline{c}&#x27;&#x27;</span>, and, adding back <span class="math">z_0u</span>, the result follows. The second case is obtained by symmetry.</p>

    <p class="text-gray-300">It remains to explain how to find a valid starting point for this variant of the FK-algorithm. Our strategy is to precompute a few lattice vectors with a <span class="math">z</span>-coordinate equal to 1, and other coordinates as small as possible. Hence, from a point in <span class="math">\\Lambda_{z_0}</span> whose <span class="math">x</span>- and <span class="math">y</span>-coordinates are within the target intervals of length <span class="math">I</span> and <span class="math">J</span>, adding such a vector will give a point in <span class="math">\\Lambda_{z_0 + 1}</span> whose <span class="math">x</span>- and <span class="math">y</span>-coordinates are maybe not in the target interval, but probably not too far from it. In order to compute three small lattice vectors with <span class="math">z = 1</span>, we proceed as follows:</p>

    <p class="text-gray-300">(1) Select a lattice vector <span class="math">v</span> with <span class="math">z = 1</span>, for instance the one given in the proof above; (2) Find a reduced basis <span class="math">(e_0, e_1)</span> of <span class="math">\\Lambda_0</span> using Gauss algorithm; (3) Deduce the closest vector <span class="math">u_0</span> of the orthogonal projection of <span class="math">v</span> in <span class="math">\\Lambda_0</span>; (4) Add or subtract <span class="math">e_0</span> and <span class="math">e_1</span> to <span class="math">u_0</span>, to get three vectors <span class="math">(u_0, u_1, u_2)</span> of <span class="math">\\Lambda_0</span> that form the smallest triangle containing the projection of <span class="math">v</span>; (5) Return the three vectors <span class="math">v - u_i</span> for <span class="math">0 \\leqslant i &amp;lt; 3</span>.</p>

    <p class="text-gray-300">Again, there is no guarantee that adding one of the small vectors with <span class="math">z = 1</span> will keep the two other coordinates within the target intervals. If after having tried the three vectors we do not find a starting point, then by adding or subtracting the vector of the FK-basis with the largest <span class="math">x</span>-coordinate, it is possible to quickly get the <span class="math">x</span>-coordinate back into the target interval. Then, we apply the modified FK-algorithm to enumerate the hit locations for the current plane.</p>

    <h2 id="sec-24" class="text-2xl font-bold">4.2. Space sieve</h2>

    <p class="text-gray-300">When the volume <span class="math">r</span> of the lattice <span class="math">\\Lambda</span> becomes large compared to the area <span class="math">IJ</span> of the intersection of the sieving cuboid and the <span class="math">xy</span>-plane, the plane sieve becomes inefficient, because in most of the planes, the modified FK-algorithm will not find any hit location. In that case, we have to find a way to jump quickly from one lattice point in the cuboid <span class="math">\\mathcal{C}</span> to the one with the smallest larger <span class="math">z</span>-coordinate. This justifies the following definition.</p>

    <p class="text-gray-300">DEFINITION 5. Let <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span> be two integral intervals of length <span class="math">I</span> and <span class="math">J</span> respectively. Let <span class="math">\\Lambda</span> be a lattice of volume <span class="math">r &amp;gt; IJ</span>. A transition vector <span class="math">v</span> is a vector of <span class="math">\\Lambda</span> for which there exists a vector <span class="math">u</span> of <span class="math">\\Lambda</span> in <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span> such that <span class="math">u + v</span> is the vector of <span class="math">\\Lambda</span> belonging to <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span> and which is the one with the smallest <span class="math">z</span>-coordinate that is larger than the one of <span class="math">u</span>.</p>

    <p class="text-gray-300">For simplicity, we first assume that there is no lattice vector in <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\{0\\}</span>, so that for a given <span class="math">u</span>, there is a unique transition vector associated to it.</p>

    <p class="text-gray-300">An analogue notion of transition vector can be defined for 2-dimensional sieving. The first statement of Proposition 4 says that the two vectors of the FK-basis and their sum are the only transition vectors. Unfortunately, in 3-dimensional sieving, the number of transition vectors is much less controlled. We give some examples, in the Appendix D . Still, the transition vectors have some simple properties that follow directly from their definition.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 6</h6>

    <p class="text-gray-300">With the notation of Definition 5, the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a given lattice vector, the associated transition vector depends only on its <span class="math">x</span>- and <span class="math">y</span>-coordinates;</li>

      <li>The set of transition vectors depend only on <span class="math">\\Lambda</span>, and on the length <span class="math">I</span> and <span class="math">J</span> of the intervals <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span>, not on the intervals themselves;</li>

      <li>The <span class="math">x</span>- and <span class="math">y</span>-coordinates of a transition vector belong to <span class="math">]\\,-I,I[</span> and <span class="math">]\\,-J,J[</span> respectively.</li>

    </ul>

    <p class="text-gray-300">We do not try to compute the complete set of transition vectors, but only a subset that covers a large enough proportion of the <span class="math">I\\times J</span> area. In fact, we do not even insist on proving that we really have transition vectors: we accept the fact that in some not-too-frequent cases we will use a vector that makes us jump too far in the <span class="math">z</span>-coordinate, thus missing a hit location. The general idea is that this step is in a very critical loop of the algorithm, and we cannot afford to spend too much time in it. Therefore, it is better to miss a few relations if the general rate of relations found per second is higher than with an algorithm that would try to be exhaustive.</p>

    <p class="text-gray-300">We resort to a heuristic but simple and efficient method to find candidate transition vectors: with a weighted-LLL algorithm, we find a reduced basis of <span class="math">\\Lambda</span>, targeting vectors with <span class="math">x</span>- and <span class="math">y</span>-coordinates with sizes about <span class="math">I</span> and <span class="math">J</span> respectively (and then the target for the <span class="math">z</span>-coordinate is about <span class="math">r/IJ</span>). Then, we compute a few small linear combinations of the vectors of this reduced basis, and keep the list of the half-dozen vectors with the smallest <span class="math">z</span>-coordinates and <span class="math">x</span>- and <span class="math">y</span>-coordinates of absolute value bounded by <span class="math">I</span> and <span class="math">J</span> respectively. There are certainly highly unbalanced lattices for which this method will fail, but we observed that in practice for most of the ideals it produces a list of transition vectors that covers a large <span class="math">xy</span>-area.</p>

    <p class="text-gray-300">After computing this list <span class="math">L</span> of candidate transition vectors, our space-sieve algorithm proceeds as follows. Let <span class="math">v</span> be the current hit location that we initialize with the zero vector (assuming 0 belongs to the intervals <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{B}</span>). To get the next hit location, we try to add, in turn, the elements of <span class="math">L</span>, until this addition produces a vector in <span class="math">\\mathcal{A}\\times\\mathcal{B}\\times\\mathbb{Z}</span>. We test the vectors of <span class="math">L</span> in increasing order of their <span class="math">z</span>-coordinates. If no appropriate vector is found after trying all vectors of <span class="math">L</span>, we fallback to a plane sieve strategy: we use vectors with <span class="math">z=1</span> to go up by one plane, and if there is no hit in this plane, we continue until one is found. This slower process yields a new transition vector that is added to <span class="math">L</span> before resuming with the space sieve.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this description, we have assumed that there were no lattice vector with <span class="math">z=0</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><J<span class="math">, which is certainly true in general provided that </span>r<span class="math"> is large enough, but we cannot exclude it to occur, especially when </span>r<span class="math"> is just marginally larger than </span>IJ<span class="math">. It is not too difficult to handle those ideals that can hit several times in some planes: before trying to apply transition vectors, one must check whether the vectors with </span>z=0$ can yield hits, and if so, transition vectors can be tried on all these hits. A pseudo-code following these ideas can be found in Appendix, as Algorithm 3. Experiments in the next section confirm that using the space sieve is indeed faster than the plane sieve for large ideals (see also Appendix F).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 7</h6>

    <p class="text-gray-300">In the recent preprint <em>[17]</em>, another 3-dimensional version of FK-algorithm is proposed. Although we did not manage to fully reproduce the work of this preprint, their strategy is not to precompute a set of transition vectors, but to try to compute them on the fly at each step, using a well reduced basis (when it exists).</p>

    <p class="text-gray-300">P. GAUDRY, L. GRÉMY AND M. VIDEAU</p>

    <p class="text-gray-300">The experiments in this section have been done with our C implementation of the 3-dimensional sieving that we made available as a branch called hd in the CADO-NFS official repository [31] (done with commit 0ae01d0...). In the file README.nfs-hd, instructions are given to reproduce all our experiments. The polynomial selection based on the criteria and constructions that we explained in Section 3 has been performed by Aurore Guillevic who has developed strategies to speed-up the exhaustive search that she will describe in an independent article in which  <span class="math">\\mathbb{F}_{p^6}</span>  will be just an example among many others. All the running times are given after normalization for a single core at  <span class="math">2\\mathrm{GHz}</span> .</p>

    <p class="text-gray-300">Our first experiment follows the two previous computations made by Zajac [32] and Hayasaka et al. [17] for a 40-bit prime  <span class="math">p = 1081034284409</span> . They used different sieving algorithms but the same polynomial pair, the same smoothness bounds and the same sieving region for the polynomials  <span class="math">a</span> . With these parameters, the Murphy-  <span class="math">E</span>  value computed with our description is about  <span class="math">2^{-24.5}</span>  with Zajac's parameters and  <span class="math">2^{-21.6}</span>  for Hayasaka's parameters. The difference between the two is due to the special-  <span class="math">\\mathfrak{q}</span>  sieve.</p>

    <p class="text-gray-300">We have selected our own polynomials. In this small field, the best polynomial selection appears to be the asymmetric JLSV method with the explicit Galois action of order 6 given by  <span class="math">x \\mapsto -(2x + 1) / (x - 1)</span> . We chose  <span class="math">f_0 = x^6 + 91354x^5 + 228370x^4 - 20x^3 - 228385x^2 - 91348x + 1</span>  and  <span class="math">f_1 = 23667000x^6 + 6549182x^5 - 338632045x^4 - 473340000x^3 - 16372955x^2 + 135452818x + 23667000</span> . We have selected the smoothness bounds and the sieving region in order to reduce the total sieving time. The sizes of norms are about 115 bits on the  <span class="math">f_0</span> -side and 117 bits on the  <span class="math">f_1</span> -side, after subtracting the contribution of the special-  <span class="math">\\mathfrak{q}</span> . We sieved all the prime ideals  <span class="math">\\mathfrak{r}</span>  of inertia degree 1 less than  <span class="math">2^{19}</span> . The thresholds are set to  <span class="math">2^{65}</span> . We obtained 1312416 raw relations with  <span class="math">12.3\\%</span>  of duplicates. These results are summarized in Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zajac [32]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hayasaka et al. [17]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Special-q sieve</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Enumeration algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">Line sieve</td>

            <td class="px-3 py-2 border-b border-gray-700">Line sieve and FK method in 3D</td>

            <td class="px-3 py-2 border-b border-gray-700">Line, plane and space sieves</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sieving region (global or per q)</td>

            <td class="px-3 py-2 border-b border-gray-700">219 × 214 × 1149</td>

            <td class="px-3 py-2 border-b border-gray-700">28 × 28 × 26</td>

            <td class="px-3 py-2 border-b border-gray-700">27 × 27 × 26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Smoothness bounds</td>

            <td class="px-3 py-2 border-b border-gray-700">222.64, 222.64</td>

            <td class="px-3 py-2 border-b border-gray-700">222.64, 222.64</td>

            <td class="px-3 py-2 border-b border-gray-700">223, 223</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α values</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7, 0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7, 0</td>

            <td class="px-3 py-2 border-b border-gray-700">-1.8, -11.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Murphy-E</td>

            <td class="px-3 py-2 border-b border-gray-700">2-24.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2-20.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of special-q's</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">217.77</td>

            <td class="px-3 py-2 border-b border-gray-700">214.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Order of the Galois action</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of relations</td>

            <td class="px-3 py-2 border-b border-gray-700">1077984</td>

            <td class="px-3 py-2 border-b border-gray-700">937575</td>

            <td class="px-3 py-2 border-b border-gray-700">1151099</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of needed relations</td>

            <td class="px-3 py-2 border-b border-gray-700">854833</td>

            <td class="px-3 py-2 border-b border-gray-700">893773</td>

            <td class="px-3 py-2 border-b border-gray-700">1128604</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Timing (days)</td>

            <td class="px-3 py-2 border-b border-gray-700">24.13</td>

            <td class="px-3 py-2 border-b border-gray-700">21.94</td>

            <td class="px-3 py-2 border-b border-gray-700">0.90</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE 1. Experiments on sieving in  <span class="math">{\\mathbb{F}}_{{p}^{6}}</span>  with  <span class="math">p = {1081034284409}</span>  .</p>

    <p class="text-gray-300">In order to compare the polynomial selections described in Section 3, we have chosen a new  <span class="math">\\mathbb{F}_{p^6}</span>  field with a 50-bit prime  <span class="math">p = 1043035802846857</span> . For this experiment, we worked with a reduced range of about 10000 special- <span class="math">\\mathfrak{q}</span>  up to  <span class="math">2^{20.5}</span> . Our tests were done with a sieving region of size  <span class="math">2^8 \\times 2^8 \\times 2^7</span>  and two smoothness bounds equal to  <span class="math">2^{25}</span> . The polynomials we used can be found in Appendix G. The results are summarized in Table 2. It allowed us to select the best suitable polynomials in order to find a complete set of relations. The numbers of relations per</p>

    <p class="text-gray-300">COLLECTING RELATIONS FOR NFS IN \\mathbb{F}_{p^6}</p>

    <p class="text-gray-300">special- <span class="math">\\mathfrak{q}</span>  are given without the use of the Galois action; therefore to get a fair comparison the entries of the last two lines of Table 2 should be multiplied together.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Asym. JLSV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjugation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sarkar-Singh (8, 6)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sarkar-Singh (9, 6)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α values</td>

            <td class="px-3 py-2 border-b border-gray-700">-12, -4.9</td>

            <td class="px-3 py-2 border-b border-gray-700">-0.8, -6.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2, -4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9, -6.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Murphy-E</td>

            <td class="px-3 py-2 border-b border-gray-700">2-19.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2-27.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2-22.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2-23.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Special-q side</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Size of norms</td>

            <td class="px-3 py-2 border-b border-gray-700">2128, 2139</td>

            <td class="px-3 py-2 border-b border-gray-700">2251, 2148</td>

            <td class="px-3 py-2 border-b border-gray-700">2153, 2143</td>

            <td class="px-3 py-2 border-b border-gray-700">2186, 2144</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Galois action</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rels per q</td>

            <td class="px-3 py-2 border-b border-gray-700">25.7</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE 2. Experiments on sieving with  <span class="math">p = {1043035802846857}</span>  .</p>

    <p class="text-gray-300">For the full sieving computation, we kept the sieving region and the smoothness bounds of the experiments and used the polynomials given by the asymmetric JLSV polynomial selection. They are  <span class="math">f_0 = x^6 - 867578x^5 - 2168960x^4 - 20x^3 + 2168945x^2 + 867584x + 1</span>  and  <span class="math">f_1 = 2404471680x^6 + 4874502674x^5 - 23880818515x^4 - 48089433600x^3 - 12186256685x^2 + 9552327406x + 2404471680</span> , with the same Galois action as for the smaller example. The  <span class="math">2^{14.7}</span>  special-q's are set on the  <span class="math">f_1</span> -side. The sieving bounds equal to  <span class="math">2^{20.5}</span>  and the thresholds were set to  <span class="math">2^{80}</span> . We obtained 4637772 raw relations that gave 4231562 unique relations after duplicate removal; there are 4129438 ideals in the factor bases. The relation collection time is 6.84 days.</p>

    <p class="text-gray-300">We have selected a 65-bit prime  <span class="math">p = 31415926535897942161</span> . For this computation, the asymmetric JLSV polynomial selection with the same Galois action of order 6 seems to give anew the best polynomials in terms of Murphy-  <span class="math">E</span>  value. The polynomials are  <span class="math">f_{0} = x^{6} - 218117072x^{5} - 545292695x^{4} - 20x^{3} + 545292680x^{2} + 218117078x + 1</span>  and  <span class="math">f_{1} = 288064804440x^{6} + 1381090484642x^{5} - 868245854995x^{4} - 5761296088800x^{3} - 3452726211605x^{2} + 347298341998x + 288064804440</span> . We selected the sieving region to be  <span class="math">2^{10} \\times 2^{10} \\times 2^{8}</span>  and two smoothness bounds equal to  <span class="math">2^{28}</span> . The  <span class="math">2^{18.7}</span>  special-q's are set on the  <span class="math">f_{1}</span>  side and the average value of the norms are  <span class="math">2^{160}</span>  on the  <span class="math">f_{0}</span> -side and  <span class="math">2^{173}</span>  on the  <span class="math">f_{1}</span> -side. The sieving bounds are equal to  <span class="math">2^{21}</span>  and the thresholds are set to  <span class="math">2^{90}</span> . The relation collection required 790 days to find 29428326 unique relations after the removal of less than  <span class="math">20.3\\%</span>  duplicates; this is greater than the 29261526 ideals in the factor bases. This computation was done with commit 4470e1...</p>

    <p class="text-gray-300">In this article we investigated at length different strategies to improve the relation productivity of the sieving step in NFS in dimension 3 targeted for a discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span> . This involved adapting and comparing different polynomial selection methods taking into account a special- <span class="math">\\mathfrak{q}</span>  sieve and a Galois action especially for dimension 3. We ran experiments on several real computations to compare with existing records and set new reference timings. Most notably, we ran a relation collection for a 50-bit  <span class="math">p</span>  in about 7 normalized CPU-days and a 65-bit  <span class="math">p</span>  in about 790 CPU-days. Our implementation is publicly available as part of CADO-NFS.</p>

    <p class="text-gray-300">In a near future, we plan to run a full discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span>  that includes the linear algebra and individual logarithm steps for a size as large as possible with our computing resources. It is possible that including some of the ideas of [17] would speed-up our implementation. Further work includes also studying the practical aspects of the Tower NFS variants [4, 21]; this would imply sieving in dimension at least 4.</p>

    <p class="text-gray-300">P. GAUDRY, L. GRÉMY AND M. VIDEAU</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Bai, S., Brent, R., Thomé, E.: Root optimization of polynomials in the number field sieve. Math. Comp. 84, 2447–2457 (2015)</li>

      <li>[2] Barbulescu, R., Gaudry, P., Guillevic, A., Morain, F.: Improving NFS for the discrete logarithm problem in non-prime finite fields. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 129–155. Springer (2015)</li>

      <li>[3] Barbulescu, R., Gaudry, P., Joux, A., Thomé, E.: A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: Nguyen, P., Oswald, E. (eds.) EUROCRYPT 2014. LNCS, vol. 8441, pp. 1–16. Springer (2014)</li>

      <li>[4] Barbulescu, R., Gaudry, P., Kleinjung, T.: The tower number field sieve. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9453, pp. 31–55. Springer (2015)</li>

      <li>[5] Barbulescu, R., Lachand, A.: Some mathematical remarks on the polynomial selection in NFS (2014), https://hal.inria.fr/hal-00954365, preprint, to appear in Math. Comp.</li>

      <li>[6] Barbulescu, R., Pierrot, C.: The Multiple Number Field Sieve for Medium and High Characteristic Finite Fields. LMS J. Comput. Math 17, 230–246 (2014)</li>

      <li>[7] Cohen, H.: A course in algorithmic algebraic number theory, GTM, vol. 138. Springer–Verlag (1993)</li>

      <li>[8] Commeine, A., Semaev, I.: An algorithm to solve the discrete logarithm problem with the number field sieve. In: et al., M.Y. (ed.) PKC 2006. LNCS, vol. 3958, pp. 174–190. Springer (2006)</li>

      <li>[9] Coppersmith, D.: Modifications to the number field sieve. J. of Cryptology 6(3), 169–180 (1993)</li>

      <li>[10] Franke, J., Kleinjung, T.: Continued fractions and lattice sieving. In: SHARCS (2005)</li>

      <li>[11] Freeman, D., Scott, M., Teske, E.: A taxonomy of pairing-friendly elliptic curves. J. of Cryptology 23, 224–280 (2010)</li>

      <li>[12] González, Á.: Measurement of areas on a sphere using Fibonacci and latitude–longitude lattices. Math. Geosc. pp. 42–49 (2010)</li>

      <li>[13] Gordon, D.M.: Discrete logarithms in GF(<span class="math">p</span>) using the number field sieve. SIAM Journal on Discrete Mathematics 6(1), 124–138 (1993)</li>

      <li>[14] Guillevic, A.: Computing individual discrete logarithms faster in GF(<span class="math">p^{n}</span>) with the NFS-DL algorithm. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9452, pp. 149–173. Springer (2015)</li>

      <li>[15] Hanrot, G., Pujol, X., Stehlé, D.: Algorithms for the shortest and closest lattice vector problems. In: Chee, Y.M., Guo, Z., Ling, S., Shao, F., Tang, Y., Wang, H., Xing, C. (eds.) Coding and Cryptology - Third International Workshop, IWCC 2011. LNCS, vol. 6639, pp. 159–190. Springer (2011)</li>

      <li>[16] Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: An experiment of number field sieve for discrete logarithm problem over GF(<span class="math">p^{12}</span>). In: Fischlin, M., Katzenbeisser, S. (eds.) Number Theory and Cryptography. LNCS, vol. 8260, pp. 108–120. Springer (2013)</li>

      <li>[17] Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: A construction of 3-dimensional lattice sieve for number field sieve over <span class="math">\\mathbb{F}_{p^{n}}</span>. Cryptology ePrint Archive, 2015/1179 (2015)</li>

      <li>[18] Joux, A., Lercier, R.: Improvements to the general number field sieve for discrete logarithms in prime fields. Math. Comp. 72(242), 953–967 (2003)</li>

      <li>[19] Joux, A., Lercier, R., Smart, N.P., Vercauteren, F.: The Number Field Sieve in the Medium Prime Case. In: Dwork, C. (ed.) CRYPTO 2006. LNCS, vol. 4117, pp. 326–344. Springer (2006)</li>

      <li>[20] Joux, A., Pierrot, C.: The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> – application to pairing-friendly constructions. In: Cao, Z., Zhang, F. (eds.) Pairing 2013. LNCS, vol. 8365, pp. 45–61. Springer (2013)</li>

      <li>[21] Kim, T., Barbulescu, R.: Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, 2015/1027 (2015), preprint, to appear at CRYPTO 2016.</li>

      <li>[22] Kleinjung, T.: On polynomial selection for the general number field sieve. Math. Comp. 75, 2037–2047 (2006)</li>

      <li>[23] Lenstra, A.K., Verheul, E.R.: The XTR public key system. In: Bellare, M. (ed.) CRYPTO 2000. LNCS, vol. 1880, pp. 1–19. Springer (2000)</li>

      <li>[24] Murphy, B.A.: Polynomial selection for the number field sieve integer factorisation algorithm. Ph.D. thesis, The Australian National University (1999)</li>

      <li>[25] Pierrot, C.: The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 156–170. Springer (2015)</li>

      <li>[26] Pollard, J.: The lattice sieve. In: Lenstra, A.K., Lenstra, Jr., H.W. (eds.) The development of the number field sieve, Lecture Notes in Math., vol. 1554, pp. 43–49. Springer (1993)</li>

      <li>[27] Rubin, K., Silverberg, A.: Torus-based cryptography. In: Boneh, D. (ed.) CRYPTO 2003, LNCS, vol. 2729, pp. 349–365. Springer (2003)</li>

      <li>[28] Sarkar, P., Singh, S.: New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016. LNCS, vol. 9665, pp. 429–458. Springer (2016)</li>

      <li>[29] Schirokauer, O.: Virtual logarithms. J. Algorithms 57, 140–147 (2005)</li>

      <li>[30] Schirokauer, O.: Discrete logarithms and local units. Philos. Trans. A 345(1676), 409–423 (1993)</li>

      <li>[31] The CADO-NFS Development Team: CADO-NFS, an implementation of the number field sieve algorithm (2015), http://cado-nfs.gforge.inria.fr/, release 2.2.0</li>

      <li>[32] Zajac, P.: Discrete Logarithm Problem in Degree Six Finite Fields. Ph.D. thesis, Slovak University of Technology (2008), http://www.kaivt.elf.stuba.sk/kaivt/Vyskum/XTRDL</li>

      <li>[33] Zajac, P.: On the use of the lattice sieve in the 3D NFS. Tatra Mt. Math. Publ. 45, 161–172 (2010)</li>

    </ul>

    <p class="text-gray-300">COLLECTING RELATIONS FOR NFS IN \\mathbb{F}_{p^6}</p>

    <p class="text-gray-300">In the case of 2-dimensional sieving, the average  <span class="math">\\ell</span> -adic valuation can be computed with the small recursive lifting function given as Algorithm 1. This is what is done for instance in the CADO-NFS implementation. This is admittedly much simpler and faster than running a full factorization of  <span class="math">f</span>  over the  <span class="math">\\ell</span> -adics, which is advantageous when many polynomials have to be tested.</p>

    <p class="text-gray-300">The equivalent for 3-dimensional sieving is not as simple, but can still be faster in many cases than a full  <span class="math">\\ell</span> -adic factorization. Let us give first the modifications to be done for computing the contribution of irreducible factors of degree 2 modulo  <span class="math">\\ell</span> . The normalization factor  <span class="math">C</span>  must be changed to  <span class="math">\\ell^2 / (\\ell^2 + \\ell + 1)</span> . Then, all the computations must no longer be done over the integers, but over the unramified extension  <span class="math">\\mathbb{Q}_{\\ell^2}</span>  of  <span class="math">\\mathbb{Q}_{\\ell}</span>  of degree 2. Only the roots genuinely over this extension are considered in the for loop, but their computation is still done modulo  <span class="math">\\ell</span> : in step 4, we are now doing polynomial factorization over  <span class="math">\\mathbb{F}_{\\ell^2}</span> . Finally, in step 6, the contribution to add is  <span class="math">1 / (\\ell^2 - 1)</span> , and in step 8, the result of the recursive call must be multiplied by  <span class="math">C / \\ell^2</span>  instead of  <span class="math">C / \\ell</span> . We obtain Algorithm 2.</p>

    <p class="text-gray-300">We emphasize that this algorithm returns the correct answer, even in the case where the degree 2 factor is a multiple factor of  <span class="math">f</span>  modulo  <span class="math">\\ell</span> ; knowing the nature of the  <span class="math">\\ell</span> -adic factorization above this multiple factor is not required.</p>

    <p class="text-gray-300">The case of a multiple factor of degree 1 is less straightforward, because the contribution to the average valuation will not be the same for a split, inert or ramified factor above this root. Still, in most cases, and in particular when the root is only a double root, it is possible to adapt Algorithm 1 and get the correct answer. We skip the details; the corresponding code is given in the hd branch of the CADO-NFS repository.</p>

    <p class="text-gray-300">|  Algorithm 1: av_val_dim2 Average ℓ-adic valuation, 2-dim. case.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  input : A polynomial f; a prime ℓ. output: The average ℓ-adic valuation of Resx(f(x),a-bx). 1 v← ℓ-valuation of the content of f. 2 f← f/ℓv. 3 C← ℓ/(ℓ+1); v← Cv. 4 for r in Roots(f) modulo ℓ do 5 if r is a simple root then 6 v← v+C/(ℓ-1). 7 else 8 v← v+C/ℓ 9 av_val_dim2(f(r+ℓx),ℓ). 10 end 11 end 12 return v.  |   |</p>

    <p class="text-gray-300">|  Algorithm 2: av_val_dim3_deg2  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Average ℓ-adic valuation, 3-dim. case;  |   |</p>

    <p class="text-gray-300">|  Contribution of irreducible factors of deg 2.  |   |</p>

    <p class="text-gray-300">|  input : A polynomial f over Qℓ2; a prime ℓ. output: The contribution to the average ℓ-adic valuation of Resx(f(x),ax2+bx+c), coming from irreducible factors of degree 2 mod ℓ.  |   |</p>

    <p class="text-gray-300">|  1 v← Minimum ℓ-valuation of the coefficients of f.  |   |</p>

    <p class="text-gray-300">|  2 f← f/ℓv.  |   |</p>

    <p class="text-gray-300">|  3 C← ℓ2/(ℓ2+ℓ+1); v← Cv.  |   |</p>

    <p class="text-gray-300">|  4 for r in Roots(f) modulo ℓ do  |   |</p>

    <p class="text-gray-300">|  5 At top-level of recursion, if r is in Qℓ, skip it.  |   |</p>

    <p class="text-gray-300">|  6 if r is a simple root then  |   |</p>

    <p class="text-gray-300">|  7 v← v+C/(ℓ2-1).  |   |</p>

    <p class="text-gray-300">|  8 else  |   |</p>

    <p class="text-gray-300">|  9 v← v+C/ℓ2 av_val_dim3_deg2(f(r+ℓx),ℓ).  |   |</p>

    <p class="text-gray-300">|  10 end  |   |</p>

    <p class="text-gray-300">|  11 end  |   |</p>

    <p class="text-gray-300">|  12 return v.  |   |</p>

    <p class="text-gray-300">In the classical 2-dimensional NFS, having many real roots in  <span class="math">f_0</span>  and  <span class="math">f_1</span>  tends to increase the Murphy-  <span class="math">E</span>  value. This can be explained by the fact that when we sieve a degree 1 polynomial whose (rational) root is a good approximation of a root of  <span class="math">f</span> , then the corresponding norm will be small. In the case of 3-dimensional sieving, complex roots have to be taken into account as well.</p>

    <p class="text-gray-300">Let  <span class="math">f</span>  be a polynomial to be used in NFS. A first order estimate of the sizes of the norms would imply that the surface of points corresponding to polynomials  <span class="math">a(x)</span>  of degree 2 that yield a norm of a given size is a sphere (or an ellipsoid if there is skewness). A real root in  <span class="math">f</span>  will</p>

    <p class="text-gray-300">P. GAUDRY, L. GRÉMY AND M. VIDEAU</p>

    <p class="text-gray-300">correspond to a plane in the direction of which the isonorm sphere is deformed with a bump. Since we are now sieving polynomials of degree 2, they can also approximate complex roots (or irreducible real factors of degree 2). The iso-norm sphere is therefore also stretched in the direction of the lines corresponding to polynomials close to irreducible factors of degree 2.</p>

    <p class="text-gray-300">In Figure B.1, we give pictures illustrating how the sphere is modified in the directions corresponding to real and complex roots of  <span class="math">f</span> . This clearly shows that the spherical approximation is not accurate enough and justifies to use the more precise Murphy- <span class="math">E</span>  estimate. For these pictures, we used the following polynomials:</p>

    <p class="text-gray-300">with no real root:  <span class="math">1456x^{6} - 170x^{5} + 15810x^{4} - 20x^{3} - 1825x^{2} + 2676x + 1774</span> with 2 real roots:  <span class="math">1456x^{6} + 6330x^{5} + 15810x^{4} - 20x^{3} - 15825x^{2} - 6324x + 1771</span> ; with 4 real roots:  <span class="math">1067x^{6} + 3757x^{5} + 4277x^{4} + 3637x^{3} - 1789x^{2} - 4876x + 603</span> ; with 6 real roots:  <span class="math">3267x^{6} + 3251x^{5} - 16174x^{4} - 12508x^{3} + 11988x^{2} + 2084x - 531</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> FIGURE B.1. Isonorms for polynomials of degree 6 with 0, 2, 4 and 6 real roots. The red planes correspond to real roots and the green lines to complex roots.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">For the various choices of  <span class="math">d</span>  in the case  <span class="math">n = 6</span> , we report the sizes of the coefficients and the degrees of the two polynomials  <span class="math">f_{0}</span>  and  <span class="math">f_{1}</span>  according to Algorithm  <span class="math">\\mathcal{A}</span>  of [28].</p>

    <p class="text-gray-300">COLLECTING RELATIONS FOR NFS IN \\mathbb{F}_{p^6}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=1 (GJL)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d=6 (Conjugation)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">f0</td>

            <td class="px-3 py-2 border-b border-gray-700">∞</td>

            <td class="px-3 py-2 border-b border-gray-700">small</td>

            <td class="px-3 py-2 border-b border-gray-700">small</td>

            <td class="px-3 py-2 border-b border-gray-700">small</td>

            <td class="px-3 py-2 border-b border-gray-700">small</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">deg f0</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">f1</td>

            <td class="px-3 py-2 border-b border-gray-700">∞</td>

            <td class="px-3 py-2 border-b border-gray-700">p6/7</td>

            <td class="px-3 py-2 border-b border-gray-700">p3/4</td>

            <td class="px-3 py-2 border-b border-gray-700">p2/3</td>

            <td class="px-3 py-2 border-b border-gray-700">p1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">deg f1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Galois</td>

            <td class="px-3 py-2 border-b border-gray-700">none</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE C.1. Sizes and degrees of polynomials with the Sarkar-Singh constructions for  <span class="math">{\\mathbb{F}}_{{p}^{6}}</span>  .</p>

    <p class="text-gray-300">The space sieve algorithm relies heavily on the notion of transition vectors, but the number of them is not easily controlled. From Lemma 6, for a given lattice we can define the transition vector associated to a point in the  <span class="math">I \\times J</span>  plane. In Figure D.1, pictures are shown where a different color is associated to each transition vector. The example on the right is highly degenerate, in the sense that there are many different transition vectors; however, in this example, most of the area is covered by the vector with the smallest  <span class="math">z</span> -coordinate.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> FIGURE D.1. Three examples of how transition vectors covers the  <span class="math">I \\times J</span>  plane. Each color corresponds to a transition vector; below each picture, the colors are listed in the increasing order of the  <span class="math">z</span> -coordinate of the corresponding vector.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">We describe in Algorithm 3 a complete space sieve algorithm, that takes care about vectors with a  <span class="math">z</span> -coordinate equals to 0 that could be found during the weighted LLL and small combination processes. In this algorithm,  <span class="math">L</span>  is a list that stores all the point we enumerate,  <span class="math">L_{z=0}</span>  contains vectors with coordinates in  <span class="math">[-I, I[\\times] - J, J[\\times\\{0\\}</span>  and  <span class="math">L_{z \\neq 0}</span>  the transition vectors.</p>

    <p class="text-gray-300">We first tried to use an enumeration algorithm following Algorithm 10 of [15]; the plane sieve turned out to be about 120 times faster than our implementation of this enumeration algorithm.</p>

    <p class="text-gray-300">We also compared the efficiency of the space sieve compared to the plane sieve. We sampled 1600 special- <span class="math">\\mathfrak{q}</span>  among those that we used during the computation detailed in Section 5.2 and sieved about  <span class="math">2^{16.7}</span>  ideals of norm larger than  <span class="math">IJ</span>  on each side. In average for each side, the</p>

    <p class="text-gray-300">COLLECTING RELATIONS FOR NFS IN \\mathbb{F}_{p^6}</p>

    <p class="text-gray-300">Algorithm 3: Space sieve input: a lattice  <span class="math">\\Lambda</span>  and the target cuboid of size  <span class="math">I\\times J\\times K</span> output: list of visited points. <span class="math">L\\gets \\emptyset</span> // Compute candidate transition vectors. <span class="math">M^{SLR}\\leftarrow</span>  weighted LLL on  <span class="math">\\Lambda</span>  , with non-negative  <span class="math">z</span>  -coordinate. <span class="math">L_{z}\\gets</span>  linear combinations of the elements of  <span class="math">MSLR</span> Split  <span class="math">L_{z}</span>  into  <span class="math">L_{z = 0}\\cup L_{z\\neq 0}</span>  according to the  <span class="math">z</span>  -coordinate of elements being zero or not. Keep only the smallest non colinear vectors of  <span class="math">L_{z = 0}</span>  if they exist. Sort  <span class="math">L_{z\\neq 0}</span>  by increasing  <span class="math">z</span>  coordinate. // Main enumeration loop. <span class="math">s\\gets (0,0,0)^T</span> while the  <span class="math">z</span>  -coordinate of s is smaller than K do // Find elements in the plane of the  <span class="math">z</span>  -coordinate of s. <span class="math">L_{c}\\gets \\emptyset</span> for  <span class="math">v\\in L_{z = 0}</span>  do Add to  <span class="math">L</span>  and  <span class="math">L_{c}</span>  all the points in the intersection of the line  <span class="math">s + \\lambda v</span>  and the cuboid,  <span class="math">\\lambda \\in \\mathbb{Z}</span> end // Find smallest next location. <span class="math">s_t\\gets (0,0,K)^T</span> for  <span class="math">s_n\\in L_c</span>  do for  <span class="math">v\\in L_{z\\neq 0}</span>  do if  <span class="math">v + s_n</span>  is in the sieving region and  <span class="math">(v + s_n)[2] &amp;lt;   s_t[2]</span>  then  <span class="math">s_t\\gets v + s_n.</span>  end end end // Use plane sieve as a fallback. if  <span class="math">s_t</span>  was not updated then  <span class="math">s_t\\gets</span>  call the plane sieve with  <span class="math">L_{c}[0]</span>  as a starting point and stop when an element is found. Insert  <span class="math">s_t - s</span>  in  <span class="math">L_{z\\neq 0}</span>  , keeping the list sorted. end <span class="math">s\\gets s_t</span> end return L</p>

    <p class="text-gray-300">plane sieve takes 5.23 seconds in a single core at  <span class="math">3.20\\mathrm{GHz}</span>  against 1.60 seconds for the space sieve. This gives a 3.25 accelerating factor by using the space sieve instead of the plane sieve.</p>

    <p class="text-gray-300">Appendix G. Different polynomial selections for the field  <span class="math">\\mathbb{F}_{p^6}</span>  with a 50 bits  <span class="math">p</span></p>

    <p class="text-gray-300">We report here the three different pairs of polynomials we used to build Table 2:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Conjugation:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{0} = x^{12} + 12x^{11} + 40x^{10} - 20x^{9} - 245x^{8} - 200x^{7} + 344x^{6} + 592x^{5} + 250x^{4} - 20x^{3} - 26x^{2} + 1</span> ;</li>

      <li><span class="math">f_{1} = 31943784x^{6} + 201177002x^{5} + 23785745x^{4} - 638875680x^{3} - 502942505x^{2} - 9514298x + 31943784</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sarkar-Singh with  <span class="math">d = 2</span> , yielding degrees (8,6):</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{0} = 2x^{8} - 2x^{7} + 6x^{6} - 4x^{5} + 9x^{4} - 4x^{3} + 6x^{2} - 2x + 2;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{1} = 13305451020x^{6} + 13068452527x^{5} - 122274520263x^{4} + 74260869388x^{3} - 122274520263x^{2} + 13068452527x + 13305451020</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sarkar-Singh with  <span class="math">d = 3</span> , yielding degrees (9,6):</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{0} = x^{9} + 2x^{8} - 5x^{7} - 9x^{6} + 13x^{5} + 24x^{4} - 2x^{3} - 15x^{2} - 7x - 1;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{1} = 10266423024x^{6} - 6028238612x^{5} - 67420797690x^{4} - 2036172080x^{3} + 116716740730x^{2} + 67626776756x + 10266423024</span> .</li>

    </ul>

    <p class="text-gray-300">Pierrick Gaudry and Laurent Grémy</p>

    <p class="text-gray-300">Inria, CNRS, Université de Lorraine</p>

    <p class="text-gray-300">Nancy, France</p>

    <p class="text-gray-300">firstname.lastname@loria.fr</p>

    <p class="text-gray-300">Marion Videau</p>

    <p class="text-gray-300">Quarkslab, Paris, France</p>

    <p class="text-gray-300">Inria, CNRS, Université de Lorraine</p>

    <p class="text-gray-300">Nancy, France</p>`;
---

<BaseLayout title="Collecting relations for the Number Field Sieve in $GF(p^6)$ (2016/124)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/124
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
