---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/124';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Collecting relations for the Number Field Sieve in $GF(p^6)$';
const AUTHORS_HTML = 'Unknown authors';

const CONTENT = `    <h4 id="sec-1" class="text-lg font-semibold mt-6">ABSTRACT</h4>

    <p class="text-gray-300">In order to assess the security of cryptosystems based on the discrete logarithm problem in non-prime finite fields, as are the torus-based or pairing-based ones, we investigate thoroughly the case in  <span class="math">\\mathbb{F}_{p^6}</span>  with the Number Field Sieve. We provide new insights, improvements, and comparisons between different methods to select polynomials intended for a sieve in dimension 3 using a special- <span class="math">\\mathfrak{q}</span>  strategy. We also take into account the Galois action to increase the relation productivity of the sieving phase. To validate our results, we ran several experiments and real computations for various polynomial selection methods and field sizes with our publicly available implementation of the sieve in dimension 3, with special- <span class="math">\\mathfrak{q}</span>  and various enumeration strategies.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1. Introduction</h4>

    <p class="text-gray-300">The security of major cryptographic protocols relies heavily on the difficulty of two main number theoretic problems: large integer factorization and discrete logarithm computation in a finite group. Recently, the discrete logarithm problem on finite fields has received a lot of attention, bringing new results all related to the index calculus family of algorithms. If the small characteristic finite fields can be classified as a lost cause thanks to the quasi-polynomial algorithm [3] and the prime field case resorts to the <em>classical</em> Number Field Sieve (NFS) [13, 30, 18], there is still room to understand better how to adapt variants of NFS to non-prime finite fields [19, 2].</p>

    <p class="text-gray-300">Cryptosystems that would be affected by better complexity and practical results in this setting would be torus-based [23, 27] or pairing-based (see [11] for a survey). Although not widely deployed in everyday products, the specificity of their use makes it necessary to finely assess the security margin that one can expect from a given choice of parameters for an expected period of time as progress in cryptanalysis can spectacularly undermine their usability, as it was the case for pairing-based cryptography using small characteristic finite fields.</p>

    <p class="text-gray-300">In this context, today favorite finite fields targets are  <span class="math">\\mathbb{F}_{p^{12}}</span>  and  <span class="math">\\mathbb{F}_{p^6}</span> . As already mentioned in [19], the classical NFS whose relation search relies on polynomials of degree 1 (dimension 2) is not the best suited in those cases. Instead, if we want to optimize the number of relations found, we need to consider a variant of NFS in higher dimension, that is relying on polynomials of degree greater than 1. Although the complexity fits in the L(1/3, c) class, these finite fields where higher dimensional sieving is required are those for which the constant c is the highest compared to other finite fields, despite recent advances [6, 25, 4, 21].</p>

    <p class="text-gray-300">The NFS algorithm is usually considered composed of four sub-algorithms: the <em>polynomial selection</em> which produces a pair of polynomials that define the number fields used in the <em>relation collection</em>, which in turn produces relations involving small elements of the number fields. When enough relations are produced, a <em>linear algebra</em> step provides the logarithms of the small elements. Then, an <em>individual logarithm</em> step computes the logarithm of the target element thanks to the logarithms of the small elements.</p>

    <p class="text-gray-300">In the literature, the two main computation examples using higher dimensional sieves which can serve as a reference to compare different variants and strategies are set in an  <span class="math">\\mathbb{F}_{p^6}</span>  of 240 bits and in an  <span class="math">\\mathbb{F}_{p^{12}}</span>  of 203 bits. The computation in  <span class="math">\\mathbb{F}_{p^{12}}</span>  is presented in [16]. It uses a sieve in</p>

    <p class="text-gray-300">dimension 7, a special-q strategy to divide the sieving region and a line sieve to enumerate the polynomials in each special-q lattice.</p>

    <p class="text-gray-300">There are several examples of computations in Fp&lt;sup&gt;6&lt;/sup&gt; . In [<a href="#page-13-14">32</a>], Zajac sets the first record computation. He uses a sieve in dimension 3, no special-q and a line sieve to enumerate the polynomials in the sieving region. In [<a href="#page-13-15">33</a>], he also made experiments to apply a special-q strategy to divide the sieving region. He concluded that in his reference example it seemed too slow to provide any performance gain. In [<a href="#page-13-16">17</a>], Hayasaka et al. targeted the same finite field but using both a special-q strategy and an adapted lattice-sieve enumeration inspired by Franke-Kleinung [<a href="#page-13-17">10</a>]. Their computation time is comparable, around 22-24 normalized CPU-days. Both results use the same polynomial pair which define the number fields.</p>

    <p class="text-gray-300">Our contributions. In this article we focus on improving the sieve in dimension 3, which is best suited to finite fields of the form Fp&lt;sup&gt;6&lt;/sup&gt; . This is achieved by carefully analyzing the polynomial selection phase and adapt computations that are usually handled in dimension 2 to the case of dimension 3, for instance the α-value and the Murphy-E quantity. Besides, we compare different polynomial selection methods and take also into account that these polynomials will be used with a special-q strategy suggesting to introduce a controlled unbalance between them. We also consider the possibility of a Galois action for the polynomials which provide cheap relations, sparing some sieving time. Our goal is to output better polynomials to improve the relation productivity of the sieving phase.</p>

    <p class="text-gray-300">In order to validate these criteria for polynomial selection, in the end we have to rely on real computations. To that purpose, we implemented a 3-dimensional sieve with a special-q strategy and several adapted enumeration algorithms (line sieve, plane sieve and space sieve) to be able to run several experiments and compare different strategies.</p>

    <p class="text-gray-300">With our implementation, the improvements in the polynomial selection, and a Galois action of order 6, we were able to find a complete set of relations for the Zajac's 40-bit p in less than 1 normalized CPU-day. We ran two bigger computations in an Fp&lt;sup&gt;6&lt;/sup&gt; , one with a 50-bit p which ran in about 7 CPU-days and the second one with a 65-bit p in about 790 CPU-days.</p>

    <p class="text-gray-300">We recall briefly the general workflow of NFS in the context of finite fields Fp&lt;sup&gt;n&lt;/sup&gt; , keeping in mind those of the form Fp&lt;sup&gt;6&lt;/sup&gt; as our favorite targets. We take the occasion to fix the global notation used in the rest of the article.</p>

    <p class="text-gray-300">Using more than two polynomials in NFS (the so-called MNFS variants [<a href="#page-13-18">9</a>, <a href="#page-13-19">8</a>, <a href="#page-13-9">6</a>, <a href="#page-13-10">25</a>]) has not yet been used for practical computations, even in the much easier case of integer factorization, so we stick to two polynomials. The setting starts therefore with two irreducible polynomials f&lt;sup&gt;0&lt;/sup&gt; and f&lt;sup&gt;1&lt;/sup&gt; over Z that have a common irreducible factor of degree n modulo p. They define two number fields K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;0&lt;/sup&gt; and K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; . Then relations are collected by trying many content-free irreducible polynomials a: each trial a is viewed as an element of the field K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;0&lt;/sup&gt; and one tests if the corresponding principal ideal is smooth, i.e. factors into prime ideals of norm less than a given smoothness bound. Similarly, a smoothness test is done in the other field K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; , and if both sides are smooth, then we call it a relation. To detect that a principal ideal paq is smooth in a field K&lt;sup&gt;f&lt;/sup&gt; , we start by testing the smoothness of its norm, which is an integer (or maybe a rational if f is not monic) or simply the smoothness of its resultant with f. In this article, we will talk indifferently about the norm and the resultant, keeping in mind that for steps of the algorithm after the relation collection, care must be taken if f is not monic. Also, when a large prime power is involved, smoothness of the norm does not imply smoothness of the ideal.</p>

    <p class="text-gray-300">The set of polynomials a that must be tried before finding enough relations is called the sieving region S. The size of the coefficients of these is therefore p#Sq 1{t , where t is the number of coefficients of a (that is its degree plus one), which is the dimension of the sieve.</p>

    <p class="text-gray-300">Since f&lt;sup&gt;0&lt;/sup&gt; and f&lt;sup&gt;1&lt;/sup&gt; must have degrees at least n, this degree can be large compared to the size of p, and then also to the size of the coefficients of the f&lt;sup&gt;i&lt;/sup&gt; . At some point, n becomes large enough so that the norms get smaller if we consider a-polynomials with a larger value of t and smaller coefficients: this is the reason why we have to sieve in dimension higher than 2.</p>

    <p class="text-gray-300">In order to speed-up the detection of smooth elements, a sieving procedure is used. For each prime ideal r in Kf&lt;sup&gt;0&lt;/sup&gt; of norm less than a sieving bound (that is less than the smoothness bound), all the polynomials a where r divides the corresponding principal ideal are marked as such. Storing the set of a-polynomials in a t-dimensional array, these locations are regularly spaced in memory, which speeds-up considerably the process. Once this has been done, the promising locations that have been hit many times are scrutinized more thoroughly for smoothness with the ECM algorithm. Of course this is also done with ideals in Kf&lt;sup&gt;1&lt;/sup&gt; , and actually, the processing of the two sides is interleaved, so that ECM is run only if the a-polynomial looks promising on both sides. We call threshold the bound on the number of bits left in the norm after sieving, used to define what &quot;promising&quot; means.</p>

    <p class="text-gray-300">Once we have collected more relations than the number of prime ideals less than the smoothness bound, the relations are interpreted as linear equations between the virtual logarithms [<a href="#page-13-20">29</a>] of those ideals thanks to Schirokauer maps. Then a sparse linear algebra step is performed to solve these equations. Finally, the so-called descent step [<a href="#page-13-21">14</a>] allows to deduce the discrete logarithm of any finite field element. Since we are mostly interested in sieving we do not say more about these steps. The overall complexity is in Lp&lt;sup&gt;n&lt;/sup&gt; p1{3, c \` op1qq, with a constant c that varies from 1.75 to 2.21 depending on the variant that can be used (or from 1.72 to 2.16 with MNFS); but the practical consequence is unclear for the Fp&lt;sup&gt;6&lt;/sup&gt; target for which the best algorithm to use for currently feasible sizes is still to be determined.</p>

    <p class="text-gray-300">The special-q strategy introduced by Pollard [<a href="#page-13-22">26</a>] is a way to organize the exploration of the sieving region S. Since most of the relations come from norms that are divisible by at least one not-so-small ideal, we do not lose much by exploring only locations with this property. Hence, we choose a list of prime ideals q of K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;0&lt;/sup&gt; (we can choose K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; instead) of norms less than the smoothness bound, but large enough (typically, above the sieving bound). We treat each q separately and consider the sublattice of a-polynomials having divisibility by q in K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;0&lt;/sup&gt; , that we call the q-lattice. For a given norm size, prime ideals of inertia degree more than 1 are far less numerous than those of degree 1, so we consider only q's of inertia degree 1. In K&lt;sup&gt;f&lt;/sup&gt;&lt;sup&gt;0&lt;/sup&gt; , the element x is not necessarily an integer; still, all but a tiny number of the q's can be represented by two elements of the form pq, x ´ ρq, where q is the norm of q and ρ a root of f&lt;sup&gt;0&lt;/sup&gt; modulo q; a basis of the q-lattice is then given by pq,px ´ ρq, xpx ´ ρq, . . . , x&lt;sup&gt;t&lt;/sup&gt;´&lt;sup&gt;2&lt;/sup&gt; px ´ ρqq. Applying the LLL algorithm, we obtain a reduced basis whose elements form a matrix Mq, such that for any vector c with integral coefficients, the vector a &quot; Mqc is in the q-lattice. Furthermore, taking all coefficients of c bounded in absolute value by a bound H, we get vectors a that cover approximately the target sieving region S. In fact, since two proportional a-polynomials would give the same relation, we consider only c vectors with a positive last coordinate. From now on, we will therefore always consider that the sieving region for c is a cuboid C of the form r´H0, H0rˆr´H1, H1rˆ ¨ ¨ ¨ ˆ r0, H&lt;sup&gt;t&lt;/sup&gt;´&lt;sup&gt;1&lt;/sup&gt;r. To fit with the classical notation, in the case of 3-dimensional sieving that we will study at length, we will set I &quot; 2H0, J &quot; 2H1, and K &quot; H2.</p>

    <p class="text-gray-300">For a given special-q, the sieving phase goes as follows. A t-dimensional array corresponding to the cuboid C is initialized with approximations of the logarithms of the norms. Then for each prime ideal r of norm less than the sieving bound, one has to find a description of the vectors c that yield elements divisible by r, in order to enumerate and visit all the corresponding locations to subtract the logarithm of the norm of r. Only ideals of inertia degree less than t can occur, so there is no need to consider the others.</p>

    <p class="text-gray-300">All but a tiny number of the ideals r of inertia degree d are generated by two elements of the form pr, hpxqq, where r d is the norm of r and h is a monic polynomial of degree d. A basis of the lattice of a-polynomials yielding divisibility by r is pr, rx, . . . , rxd´&lt;sup&gt;1&lt;/sup&gt; , hpxq, xhpxq, . . . , xt´d´1hpxqq. Therefore, modulo r, the first d columns of the corresponding matrix are zero and its rank is t ´ d. Hence this lattice can be described by a set of d linear relations modulo r between the coefficients of a. We write these relations in a d ˆ t matrix U&lt;sup&gt;r&lt;/sup&gt; such that Ura &quot; 0 mod r if and only if a yields divisibility by r. This can be translated into a condition on the coefficients of c: since a &quot; Mqc, setting Uq,&lt;sup&gt;r&lt;/sup&gt; &quot; UrMq, we can identify the vectors c yielding divisibility by r with the equation Uq,rc &quot; 0 mod r, where again, Uq,&lt;sup&gt;r&lt;/sup&gt; is a d ˆ t matrix. In particular, in the most frequent case where r is of inertia degree 1, this becomes a single linear equation modulo r. From this description, fast algorithms are described in Section <a href="#page-7-0">4;</a> but before going into these details, we describe more thoroughly the polynomial selection step.</p>

    <p class="text-gray-300">In the case of the classical NFS algorithm based on a 2-dimensional sieve, criteria to select the best polynomial pair among several candidates have been defined and refined over time [<a href="#page-13-23">24</a>, <a href="#page-13-24">22</a>, <a href="#page-13-25">1</a>]. Although the general idea remains the same, it is necessary to revisit them in the case of a t-dimensional sieving for t ą 2, and in particular for t &quot; 3.</p>

    <p class="text-gray-300">3.1.1. Size properties The first and easiest criterion is to compute an upper bound on the sizes of the norms corresponding to both polynomials. This is enough for getting the optimal theoretical complexities, and can also be used as a first filter in practice.</p>

    <p class="text-gray-300">Let pf0, f1q be the polynomial pair to be studied. In order to give a bound on the corresponding norms, it is first necessary to get an estimate on the size of the sieving region S. Doing that from a theoretical point of view is classical, but often imprecise compared to what is obtained in practice. The strategy is therefore as follows: a crude estimate for #S is made, which allows, taking other criteria into account, to select a not-so-bad pair; then running some sample sieving, it is possible to get a much better view of the actual sieving region size, and the polynomial selection is run again, possibly giving a better pair. This bootstrapping process does not have to be done again for each finite field: all the fields Fp&lt;sup&gt;n&lt;/sup&gt; for fixed n and p of similar sizes will behave similarly. So from now on, we assume that an estimate for #S is known.</p>

    <p class="text-gray-300">Then the skewness must be taken into account. If all the coefficients of f&lt;sup&gt;0&lt;/sup&gt; (resp. of f1) are of similar sizes, the smallest upper bound is obtained by taking all the coefficients of a bounded by the same value p#Sq 1{t . On the other hand, if one of the f&lt;sup&gt;i&lt;/sup&gt; is skewed, i.e. its coefficients have a size that decreases with the degree, then it is better to choose a-polynomials with the same property. This is even more true if both f&lt;sup&gt;0&lt;/sup&gt; and f&lt;sup&gt;1&lt;/sup&gt; are skewed. The ratio between the size of two consecutive coefficients of the a-polynomials is called the skewness.</p>

    <p class="text-gray-300">Finally, having taken into account the size of the sieving region and the skewness, it is possible to obtain an upper bound for each norm. It remains to subtract from one of them the size of the special- <span class="math">\\mathfrak{q}</span>  that is planned to be used (again, it might be necessary to bootstrap with some crude sieving experiments to tune this size).</p>

    <p class="text-gray-300">The first criterion is then to select the polynomial pair for which the sum of the sizes of the norms on both sides is minimal. This can be refined to take into account the fact that the Dickman rho function is convex: in a list of polynomial pairs that yield a similar value for the sum of the sizes of the norms, it is better to choose the pair for which the norms have sizes as close as possible to each other.</p>

    <p class="text-gray-300">3.1.2. Local properties We now study the effect of local properties, i.e. the fact that the polynomials can have many roots modulo small primes. This is done on each side independently. Therefore, we let f be an irreducible polynomial in  <span class="math">\\mathbb{Z}[x]</span> , that in the end will be either  <span class="math">f_0</span>  or  <span class="math">f_1</span> . The  <span class="math">\\alpha</span>  quantity related to f, that we denote  <span class="math">\\alpha(f)</span> , measures the difference in terms of smoothness probability between an integer obtained by computing the resultant of f and a polynomial of degree t-1 and a random integer of the same size. In other words, if a norm has size A, it will be smooth with the same probability as a random integer of size  <span class="math">A + \\alpha(f)</span> . A negative value for  <span class="math">\\alpha(f)</span>  is a characteristic of a good polynomial f. In the following formal definition of  <span class="math">\\alpha</span> , the size of an integer is given by the natural logarithm, in conformance with the traditional definition of  <span class="math">\\alpha</span>  in dimension 2.</p>

    <p class="text-gray-300">DEFINITION 1. Let f be an irreducible polynomial in  <span class="math">\\mathbb{Z}[x]</span> . Let  <span class="math">\\mathcal{S}</span>  be the set of content-free irreducible polynomials of degree t-1 over  <span class="math">\\mathbb{Z}</span> . For a prime  <span class="math">\\ell</span> , the local  <span class="math">\\alpha</span> -value of f at  <span class="math">\\ell</span>  is</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{\\ell}(f) = \\log(\\ell) \\Big( \\mathbb{A} \\big( \\operatorname{val}_{\\ell}(n) \\mid n \\in \\mathbb{Z} \\big) - \\mathbb{A} \\big( \\operatorname{val}_{\\ell}(\\operatorname{Res}(f, a)) \\mid a \\in \\mathcal{S} \\big) \\Big),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\operatorname{val}_{\\ell}</span>  denotes the  <span class="math">\\ell</span> -adic valuation and  <span class="math">\\mathbb{A}()</span>  is the average value. The  <span class="math">\\alpha</span> -value of f is then defined as the sum over all primes  <span class="math">\\alpha(f) = \\sum_{\\ell} \\alpha_{\\ell}(f)</span> .</p>

    <p class="text-gray-300">In this definition, the average value  <span class="math">\\mathbb{A}()</span>  is defined by taking the limit of the average value of the quantity for increasingly large finite subsets of the whole considered set. To disambiguate this choice, we take these subsets as intersections of  <span class="math">\\mathcal{S}</span>  with centered balls of increasing radius. Another potential issue with this definition is the convergence of the series defining  <span class="math">\\alpha(f)</span> . We leave it as a conjecture, since adapting the proof of [5] goes beyond the scope of this article.</p>

    <p class="text-gray-300">The quantity  <span class="math">\\mathbb{A}\\left(\\operatorname{val}_{\\ell}(n) \\mid n \\in \\mathbb{Z}\\right)</span>  is equal to  <span class="math">1/(\\ell-1)</span> . The other part of the formula defining  <span class="math">\\alpha_{\\ell}(f)</span>  can be simplified when  <span class="math">\\ell</span>  does not divide the leading coefficient of f nor its discriminant. The case of t=2 is well known [24] and yields  <span class="math">\\alpha_{\\ell}(f) = \\frac{\\log(\\ell)}{\\ell-1}(1-\\frac{\\ell}{\\ell+1}n_1)</span> , where  <span class="math">n_1</span>  is the number of roots of f modulo  <span class="math">\\ell</span> . We derive the same kind of formula for the case t=3.</p>

    <p class="text-gray-300">PROPOSITION 2. Let f be an irreducible polynomial in  <span class="math">\\mathbb{Z}[x]</span>  and  <span class="math">\\ell</span>  be a prime not dividing the leading coefficient of f nor its discriminant. Then, in the case of sieving in dimension t = 3,</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{\\ell}(f) = \\frac{\\log(\\ell)}{\\ell - 1} \\left( 1 - n_1 \\frac{\\ell(\\ell + 1)}{\\ell^2 + \\ell + 1} - 2n_2 \\frac{\\ell^2}{(\\ell + 1)(\\ell^2 + \\ell + 1)} \\right),</span>$</p>

    <p class="text-gray-300">where  <span class="math">n_1</span>  and  <span class="math">n_2</span>  are the number of linear (resp. degree 2) irreducible factors of f modulo  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The condition on the leading coefficient allows to avoid questions about projective roots, and the condition on the discriminant implies that any irreducible factor of f modulo  <span class="math">\\ell</span>  can be lifted to an irreducible factor of f of the same degree over the  <span class="math">\\ell</span> -adic ring  <span class="math">\\mathbb{Z}_{\\ell}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\varphi</span>  be a quadratic irreducible factor of f over  <span class="math">\\mathbb{Z}_\\ell</span> . Let a(x) be a quadratic polynomial with coefficients in  <span class="math">\\mathbb{Z}</span>  whose content is not divisible by  <span class="math">\\ell</span> . Then the  <span class="math">\\ell</span> -adic valuation of the resultant of  <span class="math">\\varphi</span>  and a(x) is 2k, where k is the largest integer such that a(x) is proportional to  <span class="math">\\varphi</span>  modulo  <span class="math">\\ell^k</span> . The number of a(x) with coefficients in  <span class="math">[0,\\ell^k-1]</span>  that satisfy this condition is  <span class="math">\\ell^k-\\ell^{k-1}</span>  since they are the polynomials of the form  <span class="math">\\gamma\\varphi</span> , where  <span class="math">\\gamma</span>  is not divisible by  <span class="math">\\ell</span> . Furthermore, the number of polynomials a(x) with coefficients in  <span class="math">[0,\\ell^k-1]</span>  whose content is not divisible by  <span class="math">\\ell</span>  is  <span class="math">\\ell^{3k}-\\ell^{3k-3}</span> . Hence the proportion of those polynomials for which the valuation of its resultant with  <span class="math">\\varphi</span>  is at least 2k is  <span class="math">(\\ell^k-\\ell^{k-1})/(\\ell^{3k}-\\ell^{3k-3})</span> . Finally the contribution due to  <span class="math">\\varphi</span>  in the expected valuation of the resultant of f and a is  <span class="math">\\sum_{k\\geqslant 1} 2\\frac{\\ell^k-\\ell^{k-1}}{\\ell^{3k}-\\ell^{3k-3}} = \\frac{2\\ell^2}{(\\ell^2-1)(\\ell^2+\\ell+1)}</span> . The case of the contributions of roots of f is handled similarly: the number of polynomials</p>

    <p class="text-gray-300">The case of the contributions of roots of f is handled similarly: the number of polynomials a(x) with coefficients in  <span class="math">[0, \\ell^k - 1]</span>  whose content is not divisible by  <span class="math">\\ell</span>  and that give a value divisible by  <span class="math">\\ell^k</span>  when evaluated at an  <span class="math">\\ell</span> -adic root  <span class="math">\\rho</span>  of f is  <span class="math">\\ell^{2k} - \\ell^{2k-2}</span> , since they are all of the form  <span class="math">(x - \\rho)(\\alpha x - \\beta)</span> , with  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  in  <span class="math">[0, \\ell^k - 1]</span>  and not simultaneously divisible by  <span class="math">\\ell</span> . Therefore the contribution of a root  <span class="math">\\rho</span>  in the expected valuation of the resultant of f and a is  <span class="math">\\sum_{k \\geqslant 1} \\frac{\\ell^{2k} - \\ell^{2k-2}}{\\ell^{3k} - \\ell^{3k-3}} = \\frac{\\ell^2 + \\ell}{\\ell^3 - 1}</span> .</p>

    <p class="text-gray-300">When the proposition does not apply, the natural workaround is to compute the factorization of f over the  <span class="math">\\ell</span> -adic field (see for instance [7, Chapter 6.1]) and for each factor do the same kind of study as in the proof of the proposition. One could argue that, anyway, since computing the  <span class="math">\\ell</span> -maximal order is required for converting relations to rows of the matrix, this is appropriate. However, computing  <span class="math">\\alpha</span>  must be as fast as possible because we might want to investigate billions of polynomials. In the classical 2-dimensional case, a very simple lifting is enough to deduce the average  <span class="math">\\ell</span> -adic valuation. In Appendix A, we sketch a similar approach that, in many cases, will give the average valuation without having to perform a full  <span class="math">\\ell</span> -adic factorization.</p>

    <p class="text-gray-300">Finally, the case where  <span class="math">\\ell</span>  divides the leading coefficient of f is dealt with by adding the contribution of the (possibly multiple) root 0 in the reverted polynomial  <span class="math">f(1/x)x^{\\deg f}</span> .</p>

    <p class="text-gray-300">3.1.3. A 3-dimensional Murphy-E The Murphy-E quantity has been introduced in [24] as an estimate of the average smoothness probability of the norms corresponding to a sieving region. In the most precise variant the sieving region is replaced by a volume in  <span class="math">\\mathbb{R}^3</span> , leading to the following definition, where we assume that the special- <span class="math">\\mathfrak{q}</span> 's are chosen in  <span class="math">K_{f_0}</span> .</p>

    <p class="text-gray-300">DEFINITION 3. Let  <span class="math">(f_0, f_1)</span>  be a pair of irreducible polynomials used in the NFS algorithm, S a volume in  <span class="math">\\mathbb{R}^3</span>  approximating the sieving region, and B the smoothness bound. Let Q be the average size of the special- <span class="math">\\mathfrak{q}</span> 's on the  <span class="math">f_0</span> -side. The Murphy-E function is defined by</p>

    <p class="text-gray-300"><span class="math">$E(f_0, f_1, \\mathcal{S}, B, Q) = \\int_{a \\in \\mathcal{S}} \\rho\\left(\\frac{\\log|\\operatorname{Res}(f_0, a)| - Q + \\alpha(f_0)}{\\log B}\\right) \\rho\\left(\\frac{\\log|\\operatorname{Res}(f_1, a)| + \\alpha(f_1)}{\\log B}\\right),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  is Dickman's rho function.</p>

    <p class="text-gray-300">This 3-dimensional integral is in general too costly to compute when we have a large set of polynomial pair candidates to select from. Various approaches have been taken in dimension 2, and we follow the one taken in CADO-NFS (see [31]), which is inspired from Kleinjung's code and Murphy's thesis. The idea is to use a Monte-Carlo approach, not on  <span class="math">\\mathcal{S}</span>  itself but on its boundary, so that the dimension drops by one. The rationale is that when we multiply a polynomial a by a scalar r, the resultant with f is multiplied by  <span class="math">r^{\\deg f}</span> , and therefore the sizes of the norms on a line through the origin are well controlled once one value on it is known.</p>

    <p class="text-gray-300">With the special- <span class="math">\\mathfrak{q}</span>  sieving strategy, since we are dealing with many ideals  <span class="math">\\mathfrak{q}</span> , each of them favoring some direction, viewed globally the general shape of the sieving region will be a sphere, or an ellipsoid if there is some skewness in  <span class="math">f_0</span>  and  <span class="math">f_1</span> . Hence, we will use this approximation</p>

    <p class="text-gray-300">for computing a Murphy-E value and compare the polynomial pairs: we pick a sphere or an ellipsoid corresponding to our sieving region, and perform a Monte-Carlo evaluation of the integral on its surface. In practice, we found it convenient to use a Fibonacci sphere [12] as evaluation points.</p>

    <p class="text-gray-300">Finally, in the classical 2-dimensional NFS, having many real roots tends to increase the Murphy-E value. We describe an analogue for 3-dimensional sieving in Appendix B, but this is not really another criterion, because it is already captured by Murphy-E.</p>

    <p class="text-gray-300">3.1.4. Explicit Galois action An additional criterion that must be taken into account is the possible existence of an explicit Galois action that takes the same form for  <span class="math">f_0</span>  and  <span class="math">f_1</span> . Examples are given in [2] and we also use some in our experiments. For a polynomial f, and a homography  <span class="math">\\sigma(x) = n(x)/d(x)</span> , we define  <span class="math">f^{\\sigma}(x) = f(\\sigma(x))d(x)^{\\deg f}</span> . Then,  <span class="math">\\sigma</span>  is said to be an explicit Galois action for f if  <span class="math">f^{\\sigma}</span>  is proportional to f. In that case,  <span class="math">\\sigma</span>  is an automorphism of the number field  <span class="math">K_f</span> . In this field,  <span class="math">a(\\sigma(x))</span>  is a conjugate of a(x): they have the same norm. In our context we need to work with polynomials, so we consider  <span class="math">a^{\\sigma} = a(\\sigma(x))d(x)^{\\deg a}</span> . The norm is therefore multiplied by the norm of  <span class="math">d(x)^{\\deg a}</span> , which is typically a small, smooth number.</p>

    <p class="text-gray-300">We have shown that if  <span class="math">\\sigma</span>  is an explicit Galois action for  <span class="math">f_0</span>  and  <span class="math">f_1</span> , and if a is a polynomial that has a smooth norm on both sides and hence yields a relation, then  <span class="math">a^{\\sigma}</span>  also yields a relation. And in fact, if  <span class="math">\\sigma</span>  is of order k, then we can deduce k-1 additional relations from each relation obtained by sieving, by letting  <span class="math">\\sigma</span>  act on a.</p>

    <p class="text-gray-300">In a special- <span class="math">\\mathfrak{q}</span>  context, it is simple to organize the computation in order to save a factor k in the relation collection phase. Indeed, the special- <span class="math">\\mathfrak{q}</span> 's can be organized in orbits of k conjugate ideals, and if a polynomial a yields a principal divisor divisible by  <span class="math">\\mathfrak{q}</span> , then  <span class="math">a^{\\sigma}</span>  yields a principal divisor divisible by  <span class="math">\\mathfrak{q}^{\\sigma}</span> . It is therefore enough to sieve only one of the special- <span class="math">\\mathfrak{q}</span> 's per orbit, and to derive relations for the other special- <span class="math">\\mathfrak{q}</span> 's with conjugation by  <span class="math">\\sigma</span> .</p>

    <h2 id="sec-3" class="text-2xl font-bold">3.2. Several strategies</h2>

    <p class="text-gray-300">We now review the different polynomial selection methods that could make sense for a finite field  <span class="math">\\mathbb{F}_{p^6}</span> ; we present them for any field  <span class="math">\\mathbb{F}_{p^n}</span> , but we keep this target in mind. We do not discuss the SNFS case [20], where the polynomials are directly derived from a special form of p.</p>

    <p class="text-gray-300">3.2.1. Adapting the JLSV strategy to special-q sieving The most basic polynomial selection method adapted to our case is the one proposed by Joux-Lercier-Smart-Vercauteren in [19]: we pick first a polynomial  <span class="math">f_0</span>  of degree n with small coefficients, that is irreducible modulo p; then  <span class="math">f_1</span>  is set to  <span class="math">f_1 = f_0 + p</span> . The polynomial  <span class="math">f_1</span>  resulting from this construction is skewed, while  <span class="math">f_0</span>  is not; but since  <span class="math">f_1</span>  is the polynomial that yields the largest norms, it make sense to sieve a-polynomials with the skewness of  <span class="math">f_1</span> , namely  <span class="math">p^{1/n}</span> .</p>

    <p class="text-gray-300">A first improvement to this method was proposed in [19], and was used in particular in [6, 2, 25]. The goal is to obtain polynomials  <span class="math">f_0</span>  and  <span class="math">f_1</span> , without skewness and of similar sizes, so that the norms are balanced. We propose a modification of this polynomial selection to take into account the fact that we use a special- <span class="math">\\mathfrak{q}</span>  sieving: the goal is now to obtain norms of slightly different sizes, so that after dividing out by the special- <span class="math">\\mathfrak{q}</span> , they become of the same size.</p>

    <p class="text-gray-300">Let Q be the average value of q for all the special-q's we consider, and assume that we are going to take them on the  <span class="math">f_1</span> -side. We first look for an irreducible polynomial  <span class="math">f_0</span>  such that  <span class="math">f_0 = \\pi + \\eta \\rho</span>  with  <span class="math">\\pi</span>  and  <span class="math">\\rho</span>  two polynomials with small integer coefficients and of degree at most n, with at least one of them of degree exactly n, and with  <span class="math">\\eta</span>  an integer close to  <span class="math">p^{1/2-\\epsilon}</span> , with  <span class="math">0 &lt; \\epsilon &lt; 1/2</span> . Thanks to the extended Euclidean algorithm, we then compute  <span class="math">\\kappa</span>  and  <span class="math">\\lambda</span>  such that  <span class="math">\\eta \\equiv \\kappa/\\lambda \\mod p</span> , with  <span class="math">\\kappa \\approx p^{1/2-\\epsilon}</span>  and  <span class="math">\\lambda \\approx p^{1/2+\\epsilon}</span> , to define  <span class="math">f_1 = \\lambda \\pi + \\kappa \\rho</span>  with coefficients of size  <span class="math">O(p^{1/2+\\epsilon})</span> . Using a crude upper bound, the ratio between the norms on both sides is  <span class="math">N_{f_1}(a)/N_{f_0}(a) \\approx \\|f_1\\|_{\\infty}^{t-1} / \\|f_0\\|_{\\infty}^{t-1} \\approx p^{2\\epsilon(t-1)}</span> . By taking  <span class="math">\\epsilon = \\log_p(Q)/(2(t-1))</span> , we can ensure</p>

    <p class="text-gray-300">that this ratio is close to Q, and therefore, we obtain balanced norms after taking the special- <span class="math">\\mathfrak{q}</span>  sieving into account.</p>

    <p class="text-gray-300">As explained in [2], by using specific  <span class="math">\\pi</span>  and  <span class="math">\\rho</span>  polynomials, it is possible to enforce a Galois action of order n, at least for small values of n. This is still true with our unbalanced version. Finally, for a given choice of  <span class="math">f_0</span>  and the  <span class="math">f_1</span>  following our construction, it is possible to find other choices for  <span class="math">f_1</span>  by adding to it a small multiple of  <span class="math">f_0</span> . Since the coefficients of  <span class="math">f_0</span>  are smaller than those of  <span class="math">f_1</span> , there are many choices that do not change the size properties, so that we can select the  <span class="math">f_1</span>  with the best other criteria, in particular its  <span class="math">\\alpha</span>  value.</p>

    <p class="text-gray-300">3.2.2. Sarkar-Singh constructions for  <span class="math">\\mathbb{F}_{p^6}</span>  We recall the Sarkar-Singh method, in a slightly less general setting than in [28], since we always set r = k = n/d in the Algorithm  <span class="math">\\mathcal{A}</span>  of this article; on the other hand we do not insist on having monic polynomials. The method is parametrized by a divisor d of n; for d = 1 we recover the GJL construction and for d = n, the Conjugation method (see [2] for the original description of GJL and Conjugation methods). For n = 6, we have two additional cases, d = 2 and d = 3, to consider.</p>

    <p class="text-gray-300">The construction works as follows. Let  <span class="math">\\pi</span>  and  <span class="math">\\rho</span>  be two polynomials with small integer coefficients with  <span class="math">\\pi</span>  of degree d and  <span class="math">\\rho</span>  of degree at most d-1. Then, we pick a polynomial A of degree 1+n/d with small integer coefficients, irreducible over  <span class="math">\\mathbb{Z}</span> , and that admits an irreducible factor  <span class="math">\\Phi</span>  of degree n/d modulo p. The polynomial  <span class="math">f_0</span>  is then defined by  <span class="math">f_0(x) = \\operatorname{Res}_y(A(y), \\pi(x) + y\\rho(x))</span> ; it is of degree n+d, and has small coefficients. If it is not irreducible we restart the construction with other choices. The polynomial defining  <span class="math">\\mathbb{F}_{p^n}</span>  in this setting is  <span class="math">\\varphi(x) = \\operatorname{Res}_y(\\Phi(y), \\pi(x) + y\\rho(x))</span>  mod p, therefore, if it is not irreducible over  <span class="math">\\mathbb{F}_p</span> , we have also to start over with other choices. To construct  <span class="math">f_1</span> , we first use a lattice basis reduction to compute a polynomial  <span class="math">\\Psi</span>  over  <span class="math">\\mathbb{F}_p</span>  proportional to  <span class="math">\\Phi</span>  with coefficients represented by integers of sizes approximately  <span class="math">p^{n/(n+d)}</span> . The polynomial  <span class="math">f_1</span>  is then defined by  <span class="math">f_1 = \\operatorname{Res}_y(\\Psi(y), \\pi(x) + y\\rho(x))</span> ; it is of degree n and its coefficients have sizes about  <span class="math">p^{n/(n+d)}</span> , and again we check its irreducibility over  <span class="math">\\mathbb{Z}</span>  and repeat the whole procedure if it is not the case. In Table C.1 of the Appendix, we summarize the sizes of the coefficients and the degree of  <span class="math">f_0</span>  and  <span class="math">f_1</span>  for the case n=6.</p>

    <p class="text-gray-300">Just as for the JLSV construction, it is possible to choose  <span class="math">\\pi</span>  and  <span class="math">\\rho</span>  in order to enforce a common explicit Galois action for  <span class="math">f_0</span>  and  <span class="math">f_1</span>  of order d. A drawback of this method compared to JLSV is that there is less room to play for optimizing the  <span class="math">\\alpha</span> -value of the polynomials.</p>

    <h2 id="sec-4" class="text-2xl font-bold">4. Special-q sieve in dimension 3</h2>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;For finite fields of the form  <span class="math">\\mathbb{F}_{p^6}</span>  of sizes that are within reach with current technology and algorithms, it is difficult to predict which polynomial selection method is the best. We will therefore rely on practical experiments, based on the runtime of a sieve implementation to decide and validate our criteria. In this setting, the optimal sieving dimension is 3. It might be 4 for small values of p, where it is unclear whether NFS is actually the best available algorithm; and for a sufficiently large value of p, the best sieving dimension will eventually become 2, but this will occur for sizes that are too large to run meaningful experiments. Therefore, we concentrate on the 3-dimensional sieving.</p>

    <p class="text-gray-300">In the factor base, most of the ideals are of inertia degree 1, so we describe our sieving procedure only for this case. In fact we consider a slightly more restrictive situation. From Section 2.3 the vectors c=(x,y,z) that yield elements divisible by a factor base ideal  <span class="math">\\mathfrak r</span>  are those whose coordinates verify a modular linear relation, and we assume that this relation is of the form</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;
<span class="math">$x + By + Cz \\equiv 0 \\mod r,\\tag{4.1}</span>$</p>

    <p class="text-gray-300">where r is the norm of the ideal  <span class="math">\\mathfrak{r}</span> , and B is non-zero. This avoid complications due to projective roots (or generalizations thereof to dimension 3).</p>

    <p class="text-gray-300">In order to obtain elements  <span class="math">a=M_{\\mathfrak{q}}c</span>  in the target sieving region  <span class="math">\\mathcal{S}</span> , and norms of controlled sizes, we are interested in vectors c in the cuboid  <span class="math">\\mathcal{C}</span>  of size  <span class="math">I\\times J\\times K</span> . Our convention for the memory organization of this cuboid is z-major, and then y-major for each xy-plane (i.e. fixedz-plane). Hence, for fixed values of y and z, the corresponding x-line contains cells that are contiguous in memory. With this setting, for ideals of tiny norms r &lt; I, it makes sense to do line-sieving. When r becomes larger than I, the average number of hits per x-line is less than 1, and line-sieving is suboptimal: Franke-Kleijung's plane-sieving is then more appropriate. But then again, when r becomes larger than IJ, the average number of hits per xy-plane is less than 1, and it is better to switch to a space-sieve strategy.</p>

    <p class="text-gray-300">Line sieving is the most basic sieving strategy: after specializing all-but-one coordinates, this becomes a one-dimensional sieve, and one can jump from one hit location to the other by just adding r to the location index. For fixed y and z coordinates, finding the initial hit location amount to solving the linear equation 4.1 to get the smallest x solution within the given range. We remark furthermore that solving this problem for (y+1,z) after having solved it for (y,z) costs essentially no more than one addition modulo r.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">4.1. Plane sieve</h4>

    <p class="text-gray-300">The plane sieve is for sieving ideals whose norms r are of intermediate sizes. It works only for r &gt; I, and we assume this from now on. The general idea is to process all the xy-planes in turn, by increasing values of z. For a given value of z, there are two problems to solve: first, we need to find an initial hit location in the intersection of the given plane and the cuboid  <span class="math">\\mathcal{C}</span> , and second, we need to adapt Franke-Kleinjung's algorithm (FK-algorithm, for short) in order to visit efficiently all the other hit locations in the plane.</p>

    <p class="text-gray-300">We denote by  <span class="math">\\Lambda</span>  the lattice corresponding to the vectors c that verify Equation 4.1, or equivalently that corresponds to divisibility by the ideal  <span class="math">\\mathfrak{r}</span> . For any  <span class="math">z_0</span> , we denote by  <span class="math">\\Lambda_{z_0}</span>  the intersection of  <span class="math">\\Lambda</span>  and the plane of equation  <span class="math">z=z_0</span> . The set of points in  <span class="math">\\Lambda_0</span>  form a 2-dimensional lattice of volume r, and  <span class="math">\\Lambda_{z_0}</span>  is a translate of  <span class="math">\\Lambda_0</span> . The FK-algorithm relies on a particular basis for almost all 2-dimensional lattices, adapted to the bound I on the x-coordinate: in [10, Proposition 1], it is shown that there exists a unique basis  <span class="math">\\{(\\alpha, \\beta)^T, (\\gamma, \\delta)^T\\}</span>  of the lattice  <span class="math">\\Lambda_0</span> , called FK-basis, which can be efficiently computed using the extended Euclidean algorithm, such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\beta &gt; 0</span>  and  <span class="math">\\gamma &gt; 0</span> ;</li>
      <li><span class="math">-I &lt; \\alpha \\le 0 \\le \\gamma &lt; I</span> ;</li>
      <li><span class="math">\\gamma \\alpha \\geqslant I</span> .</li>
    </ul>

    <p class="text-gray-300">Using this basis, the classical FK-algorithm allows to enumerate the elements of  <span class="math">\\Lambda_0</span>  whose x-coordinate is within an interval of size I, by increasing value of y. The following proposition shows that with a natural extension of the FK-algorithm, it is possible to enumerate the elements of  <span class="math">\\Lambda_{z_0}</span>  whose x-coordinate is within an interval of size I, by increasing and decreasing values of y; finding an initial point with the smallest y-value is therefore not necessary.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;PROPOSITION 4. Let I &gt; 0 be an integer and let  <span class="math">\\Lambda</span>  be a 3-dimensional lattice of volume r &gt; I. Let  <span class="math">\\{(\\alpha, \\beta)^T, (\\gamma, \\delta)^T\\}</span>  be the FK-basis of the intersection of  <span class="math">\\Lambda</span>  with the xy-plane. Let A be an integer, and A = [A, A + I[ the corresponding interval of length I. Let  <span class="math">z_0</span>  be a fixed third coordinate for elements of  <span class="math">\\Lambda</span> . Let  <span class="math">c = (x_0, y_0, z_0)</span>  be an element of  <span class="math">\\Lambda_{z_0}</span>  with  <span class="math">x_0 \\in A</span> . Then the point of  <span class="math">\\Lambda_{z_0}</span> , with an abscissa in A and with the smallest y-coordinate larger than  <span class="math">y_0</span>  is obtained by adding to c one of the following vector:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\begin{cases} (\\alpha, \\beta, 0)^T &amp; \\text{if } x_0 \\geqslant A - \\alpha, \\\\ (\\gamma, \\delta, 0)^T &amp; \\text{if } x_0 &lt; A + I - \\gamma, \\\\ (\\alpha, \\beta, 0)^T + (\\gamma, \\delta, 0)^T &amp; \\text{if } A + I - \\gamma \\leqslant x_0 &lt; A - \\alpha. \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$(4.2)</span>$</p>

    <p class="text-gray-300">Similarly, the point of  <span class="math">\\Lambda_{z_0}</span> , with an abscissa in  <span class="math">\\mathcal{A}</span>  and with the largest y-coordinate smaller than  <span class="math">y_0</span>  is obtained by subtracting to c one of the following vector:</p>

    <p class="text-gray-300">$$\\begin{cases}
(\\alpha, \\beta, 0)^T &amp; \\text{if } x_0 &lt; A + I + \\alpha, \\
(\\gamma, \\delta, 0)^T &amp; \\text{if } x_0 \\geqslant A + \\gamma, \\
(\\alpha, \\beta, 0)^T + (\\gamma, \\delta, 0)^T &amp; \\text{if } A + I + \\alpha \\leqslant x_0 &lt; A + \\gamma.
\\end{cases}$$
(4.3)</p>

    <p class="text-gray-300">Proof. Let  <span class="math">c=(x_0,y_0,z_0)</span>  be an element of  <span class="math">\\Lambda_{z_0}</span>  with  <span class="math">x_0 \\in \\mathcal{A}</span> . Let  <span class="math">c&#x27;=(x&#x27;_0,y&#x27;_0,z_0)</span>  be the vector obtained by applying Equation 4.2 to it, and  <span class="math">c&#x27;&#x27;=(x&#x27;&#x27;_0,y&#x27;&#x27;_0,z_0)</span>  be the vector of  <span class="math">\\Lambda_{z_0} \\cap (\\mathcal{A} \\times \\mathbb{Z} \\times \\{z_0\\})</span>  with the smallest y-coordinate that is larger than  <span class="math">y_0</span> . We want to show that c'' is equal to c'. Let  <span class="math">u \\in \\Lambda</span>  be defined by  <span class="math">u=(0,-C/B \\bmod r,1)</span> , with the notations of Equation 4.1. Subtracting  <span class="math">z_0u</span>  to c, c' and c'', we obtain three vectors  <span class="math">\\underline{c}</span> ,  <span class="math">\\underline{c}&#x27;</span>  and  <span class="math">\\underline{c}&#x27;&#x27;</span> , in  <span class="math">\\Lambda_0</span>  while preserving their x-coordinates, and translating their y-coordinates by a constant. Contrarily to  <span class="math">\\Lambda_{z_0}</span> ,  <span class="math">\\Lambda_0</span>  is a lattice, therefore we are exactly in the context of the 2-dimensional FK-algorithm, and by [10, Proposition 2], we must have  <span class="math">\\underline{c}&#x27;=\\underline{c}&#x27;&#x27;</span> , and, adding back  <span class="math">z_0u</span> , the result follows. The second case is obtained by symmetry.</p>

    <p class="text-gray-300">It remains to explain how to find a valid starting point for this variant of the FK-algorithm. Our strategy is to precompute a few lattice vectors with a z-coordinate equal to 1, and other coordinates as small as possible. Hence, from a point in  <span class="math">\\Lambda_{z_0}</span>  whose x- and y-coordinates are within the target intervals of length I and J, adding such a vector will give a point in  <span class="math">\\Lambda_{z_0+1}</span>  whose x- and y-coordinates are maybe not in the target interval, but probably not too far from it. In order to compute three small lattice vectors with z=1, we proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Select a lattice vector v with z = 1, for instance the one given in the proof above;</li>
      <li>(2) Find a reduced basis  <span class="math">(e_0, e_1)</span>  of  <span class="math">\\Lambda_0</span>  using Gauss algorithm;</li>
      <li>(3) Deduce the closest vector  <span class="math">u_0</span>  of the orthogonal projection of v in  <span class="math">\\Lambda_0</span> ;</li>
      <li>(4) Add or subtract  <span class="math">e_0</span>  and  <span class="math">e_1</span>  to  <span class="math">u_0</span> , to get three vectors  <span class="math">(u_0, u_1, u_2)</span>  of  <span class="math">\\Lambda_0</span>  that form the smallest triangle containing the projection of v;</li>
      <li>(5) Return the three vectors  <span class="math">v u_i</span>  for  <span class="math">0 \\le i &lt; 3</span> .</li>
    </ul>

    <p class="text-gray-300">Again, there is no guarantee that adding one of the small vectors with z=1 will keep the two other coordinates within the target intervals. If after having tried the three vectors we do not find a starting point, then by adding or subtracting the vector of the FK-basis with the largest x-coordinate, it is possible to quickly get the x-coordinate back into the target interval. Then, we apply the modified FK-algorithm to enumerate the hit locations for the current plane.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">4.2. Space sieve</h4>

    <p class="text-gray-300">When the volume r of the lattice  <span class="math">\\Lambda</span>  becomes large compared to the area IJ of the intersection of the sieving cuboid and the xy-plane, the plane sieve becomes inefficient, because in most of the planes, the modified FK-algorithm will not find any hit location. In that case, we have to find a way to jump quickly from one lattice point in the cuboid  <span class="math">\\mathcal C</span>  to the one with the smallest larger z-coordinate. This justifies the following definition.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;DEFINITION 5. Let  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{B}</span>  be two integral intervals of length I and J respectively. Let  <span class="math">\\Lambda</span>  be a lattice of volume r &gt; IJ. A transition vector v is a vector of  <span class="math">\\Lambda</span>  for which there exists a vector u of  <span class="math">\\Lambda</span>  in  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span>  such that u + v is the vector of  <span class="math">\\Lambda</span>  belonging to  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\mathbb{Z}</span>  and which is the one with the smallest z-coordinate that is larger than the one of u.</p>

    <p class="text-gray-300">For simplicity, we first assume that there is no lattice vector in  <span class="math">\\mathcal{A} \\times \\mathcal{B} \\times \\{0\\}</span> , so that for a given u, there is a unique transition vector associated to it.</p>

    <p class="text-gray-300">An analogue notion of transition vector can be defined for 2-dimensional sieving. The first statement of Proposition <a href="#page-8-1">4</a> says that the two vectors of the FK-basis and their sum are the only transition vectors. Unfortunately, in 3-dimensional sieving, the number of transition vectors is much less controlled. We give some examples, in the Appendix <a href="#page-16-1">D</a> . Still, the transition vectors have some simple properties that follow directly from their definition.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;Lemma 6. With the notation of Definition <a href="#page-9-0">5,</a> the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For a given lattice vector, the associated transition vector depends only on its x- and y-coordinates;</li>
      <li>The set of transition vectors depend only on Λ, and on the length I and J of the intervals A and B, not on the intervals themselves;</li>
      <li>The x- and y-coordinates of a transition vector belong to s ´ I, Ir and s ´ J, Jr respectively.</li>
    </ul>

    <p class="text-gray-300">We do not try to compute the complete set of transition vectors, but only a subset that covers a large enough proportion of the I ˆ J area. In fact, we do not even insist on proving that we really have transition vectors: we accept the fact that in some not-too-frequent cases we will use a vector that makes us jump too far in the z-coordinate, thus missing a hit location. The general idea is that this step is in a very critical loop of the algorithm, and we cannot afford to spend too much time in it. Therefore, it is better to miss a few relations if the general rate of relations found per second is higher than with an algorithm that would try to be exhaustive.</p>

    <p class="text-gray-300">We resort to a heuristic but simple and efficient method to find candidate transition vectors: with a weighted-LLL algorithm, we find a reduced basis of Λ, targeting vectors with x- and ycoordinates with sizes about I and J respectively (and then the target for the z-coordinate is about r{IJ). Then, we compute a few small linear combinations of the vectors of this reduced basis, and keep the list of the half-dozen vectors with the smallest z-coordinates and x- and y-coordinates of absolute value bounded by I and J respectively. There are certainly highly unbalanced lattices for which this method will fail, but we observed that in practice for most of the ideals it produces a list of transition vectors that covers a large xy-area.</p>

    <p class="text-gray-300">After computing this list L of candidate transition vectors, our space-sieve algorithm proceeds as follows. Let v be the current hit location that we initialize with the zero vector (assuming 0 belongs to the intervals A and B). To get the next hit location, we try to add, in turn, the elements of L, until this addition produces a vector in A ˆ B ˆ Z. We test the vectors of L in increasing order of their z-coordinates. If no appropriate vector is found after trying all vectors of L, we fallback to a plane sieve strategy: we use vectors with z &quot; 1 to go up by one plane, and if there is no hit in this plane, we continue until one is found. This slower process yields a new transition vector that is added to L before resuming with the space sieve.</p>

    <p class="text-gray-300">In this description, we have assumed that there were no lattice vector with z &quot; 0, |x| ă I and |y| ă J, which is certainly true in general provided that r is large enough, but we cannot exclude it to occur, especially when r is just marginally larger than IJ. It is not too difficult to handle those ideals that can hit several times in some planes: before trying to apply transition vectors, one must check whether the vectors with z &quot; 0 can yield hits, and if so, transition vectors can be tried on all these hits. A pseudo-code following these ideas can be found in Appendix, as Algorithm <a href="#page-17-0">3.</a> Experiments in the next section confirm that using the space sieve is indeed faster than the plane sieve for large ideals (see also Appendix <a href="#page-16-2">F)</a>.</p>

    <p class="text-gray-300">Remark 7. In the recent preprint [<a href="#page-13-16">17</a>], another 3-dimensional version of FK-algorithm is proposed. Although we did not manage to fully reproduce the work of this preprint, their strategy is not to precompute a set of transition vectors, but to try to compute them on the fly at each step, using a well reduced basis (when it exists).</p>

    <h2 id="sec-7" class="text-2xl font-bold">5. Experimental results</h2>

    <p class="text-gray-300">The experiments in this section have been done with our C implementation of the 3-dimensional sieving that we made available as a branch called hd in the CADO-NFS official repository [31] (done with commit OaeO1dO...). In the file README.nfs-hd, instructions are given to reproduce all our experiments. The polynomial selection based on the criteria and constructions that we explained in Section 3 has been performed by Aurore Guillevic who has developed strategies to speed-up the exhaustive search that she will describe in an independent article in which  <span class="math">\\mathbb{F}_{p^6}</span>  will be just an example among many others. All the running times are given after normalization for a single core at 2 GHz.</p>

    <p class="text-gray-300">Our first experiment follows the two previous computations made by Zajac [32] and Hayasaka et al. [17] for a 40-bit prime p=1081034284409. They used different sieving algorithms but the same polynomial pair, the same smoothness bounds and the same sieving region for the polynomials a. With these parameters, the Murphy-E value computed with our description is about  <span class="math">2^{-24.5}</span>  with Zajac's parameters and  <span class="math">2^{-21.6}</span>  for Hayasaka's parameters. The difference between the two is due to the special- <span class="math">\\mathfrak{q}</span>  sieve.</p>

    <p class="text-gray-300">We have selected our own polynomials. In this small field, the best polynomial selection appears to be the asymmetric JLSV method with the explicit Galois action of order 6 given by  <span class="math">x\\mapsto -(2x+1)/(x-1)</span> . We chose  <span class="math">f_0=x^6+91354x^5+228370x^4-20x^3-228385x^2-91348x+1</span>  and  <span class="math">f_1=23667000x^6+6549182x^5-338632045x^4-473340000x^3-16372955x^2+135452818x+23667000</span> . We have selected the smoothness bounds and the sieving region in order to reduce the total sieving time. The sizes of norms are about 115 bits on the  <span class="math">f_0</span> -side and 117 bits on the  <span class="math">f_1</span> -side, after subtracting the contribution of the special-q. We sieved all the prime ideals  <span class="math">\\mathfrak r</span>  of inertia degree 1 less than  <span class="math">2^{19}</span> . The thresholds are set to  <span class="math">2^{65}</span> . We obtained 1312416 raw relations with 12.3% of duplicates. These results are summarized in Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Zajac [ &lt;b&gt;32&lt;/b&gt; ]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hayasaka et al. [17]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Our work</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Special-q sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Enumeration algorithm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line sieve and&lt;br&gt;FK method in 3D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Line, plane and space sieves</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sieving region (global or per q)&lt;br&gt;Smoothness bounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{19} \\times 2^{14} \\times 1149</span>&lt;br&gt;<span class="math">2^{22.64}, 2^{22.64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8} \\times 2^{8} \\times 2^{6}</span>&lt;br&gt;<span class="math">2^{22.64}, 2^{22.64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^7 \\times 2^7 \\times 2^6</span>&lt;br&gt;<span class="math">2^{23}, 2^{23}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha</span> values</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7, 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.7, 0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-1.8, -11.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Murphy-E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-20.1}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of special-q's</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{17.77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14.44}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Order of the Galois action</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of relations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1077984</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">937575</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1151099</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Number of needed relations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">854833</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">893773</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1128604</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Timing (days)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.90</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;Table 1. Experiments on sieving in  <span class="math">\\mathbb{F}_{p^6}</span>  with p = 1081034284409.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;5.2. Experiments with a 300-bit finite field</h4>

    <p class="text-gray-300">In order to compare the polynomial selections described in Section 3, we have chosen a new  <span class="math">\\mathbb{F}_{p^6}</span>  field with a 50-bit prime p=1043035802846857. For this experiment, we worked with a reduced range of about 10000 special- <span class="math">\\mathfrak{q}</span>  up to  <span class="math">2^{20.5}</span> . Our tests were done with a sieving region of size  <span class="math">2^8 \\times 2^8 \\times 2^7</span>  and two smoothness bounds equal to  <span class="math">2^{25}</span> . The polynomials we used can be found in Appendix G. The results are summarized in Table 2. It allowed us to select the best suitable polynomials in order to find a complete set of relations. The numbers of relations per</p>

    <p class="text-gray-300">special-q are given without the use of the Galois action; therefore to get a fair comparison the entries of the last two lines of Table 2 should be multiplied together.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Asym. JLSV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Conjugation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sarkar-Singh (8, 6)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sarkar-Singh (9, 6)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\alpha</span> values Murphy- <span class="math">E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-12, -4.9</span> <span class="math">2^{-19.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">-0.8, -6.4</span> <span class="math">2^{-27.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1.2, -4.6</span> <span class="math">2^{-22.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{c} 1.9, -6.5 \\ 2^{-23.0} \\end{array} $</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Special-q side</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{1}{2^{128}}</span> , <span class="math">2^{139}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{c} 2\\ 1\\ 2^{153} \\cdot 2^{143} \\end{array} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1&lt;br&gt;2 &lt;sup&gt;186&lt;/sup&gt; , 2 &lt;sup&gt;144&lt;/sup&gt;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Size of norms&lt;br&gt;Galois action</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{251}, 2^{148}</span> <span class="math">6</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rels per q</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.9</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;Table 2. Experiments on sieving with p = 1043035802846857.</p>

    <p class="text-gray-300">For the full sieving computation, we kept the sieving region and the smoothness bounds of the experiments and used the polynomials given by the asymmetric JLSV polynomial selection. They are  <span class="math">f_0 = x^6 - 867578x^5 - 2168960x^4 - 20x^3 + 2168945x^2 + 867584x + 1</span>  and  <span class="math">f_1 = 2404471680x^6 + 4874502674x^5 - 23880818515x^4 - 48089433600x^3 - 12186256685x^2 + 9552327406x + 2404471680</span> , with the same Galois action as for the smaller example. The  <span class="math">2^{14.7}</span>  special-q's are set on the  <span class="math">f_1</span> -side. The sieving bounds equal to  <span class="math">2^{20.5}</span>  and the thresholds were set to  <span class="math">2^{80}</span> . We obtained 4637772 raw relations that gave 4231562 unique relations after duplicate removal; there are 4129438 ideals in the factor bases. The relation collection time is 6.84 days.</p>

    <h2 id="sec-9" class="text-2xl font-bold">5.3. Computation for a 389-bit finite field</h2>

    <p class="text-gray-300">We have selected a 65-bit prime p=31415926535897942161. For this computation, the asymmetric JLSV polynomial selection with the same Galois action of order 6 seems to give anew the best polynomials in terms of Murphy-E value. The polynomials are  <span class="math">f_0=x^6-218117072x^5-545292695x^4-20x^3+545292680x^2+218117078x+1</span>  and  <span class="math">f_1=288064804440x^6+1381090484642x^5-868245854995x^4-5761296088800x^3-3452726211605x^2+347298341998x+288064804440</span> . We selected the sieving region to be  <span class="math">2^{10}\\times 2^{10}\\times 2^8</span>  and two smoothness bounds equal to  <span class="math">2^{28}</span> . The  <span class="math">2^{18.7}</span>  special-q's are set on the  <span class="math">f_1</span>  side and the average value of the norms are  <span class="math">2^{160}</span>  on the  <span class="math">f_0</span> -side and  <span class="math">2^{173}</span>  on the  <span class="math">f_1</span> -side. The sieving bounds are equal to  <span class="math">2^{21}</span>  and the thresholds are set to  <span class="math">2^{90}</span> . The relation collection required 790 days to find 29428326 unique relations after the removal of less than 20.3% duplicates; this is greater than the 29261526 ideals in the factor bases. This computation was done with commit 4470e1....</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">6. Conclusion</h4>

    <p class="text-gray-300">In this article we investigated at length different strategies to improve the relation productivity of the sieving step in NFS in dimension 3 targeted for a discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span> . This involved adapting and comparing differents polynomial selection methods taking into account a special- <span class="math">\\mathfrak{q}</span>  sieve and a Galois action especially for dimension 3. We ran experiments on several real computations to compare with existing records and set new reference timings. Most notably, we ran a relation collection for a 50-bit p in about 7 normalized CPU-days and a 65-bit p in about 790 CPU-days. Our implementation is publicly available as part of CADO-NFS.</p>

    <p class="text-gray-300">In a near future, we plan to run a full discrete logarithm computation in  <span class="math">\\mathbb{F}_{p^6}</span>  that includes the linear algebra and individual logarithm steps for a size as large as possible with our computing resources. It is possible that including some of the ideas of [17] would speed-up our implementation. Further work includes also studying the practical aspects of the Tower NFS variants [4, 21]; this would imply sieving in dimension at least 4.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-13-25&quot;&gt;&lt;/span&gt;1. Bai, S., Brent, R., Thomé, E.: Root optimization of polynomials in the number field sieve. Math. Comp. 84, 2447–2457 (2015)</li>
      <li>&lt;span id=&quot;page-13-5&quot;&gt;&lt;/span&gt;2. Barbulescu, R., Gaudry, P., Guillevic, A., Morain, F.: Improving NFS for the discrete logarithm problem in non-prime finite fields. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 129–155. Springer (2015)</li>
      <li>&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;3. Barbulescu, R., Gaudry, P., Joux, A., Thomé, E.: A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: Nguyen, P., Oswald, E. (eds.) EUROCRYPT 2014. LNCS, vol. 8441, pp. 1–16. Springer (2014)</li>
      <li>&lt;span id=&quot;page-13-11&quot;&gt;&lt;/span&gt;4. Barbulescu, R., Gaudry, P., Kleinjung, T.: The tower number field sieve. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9453, pp. 31–55. Springer (2015)</li>
      <li>&lt;span id=&quot;page-13-26&quot;&gt;&lt;/span&gt;5. Barbulescu, R., Lachand, A.: Some mathematical remarks on the polynomial selection in NFS (2014), <a href="https://hal.inria.fr/hal-00954365">https://hal.inria.fr/hal-00954365</a>, preprint, to appear in Math. Comp.</li>
      <li>&lt;span id=&quot;page-13-9&quot;&gt;&lt;/span&gt;6. Barbulescu, R., Pierrot, C.: The Multiple Number Field Sieve for Medium and High Characteristic Finite Fields. LMS J. Comput. Math 17, 230–246 (2014)</li>
      <li>&lt;span id=&quot;page-13-27&quot;&gt;&lt;/span&gt;7. Cohen, H.: A course in algorithmic algebraic number theory, GTM, vol. 138. Springer–Verlag (1993)</li>
      <li>&lt;span id=&quot;page-13-19&quot;&gt;&lt;/span&gt;8. Commeine, A., Semaev, I.: An algorithm to solve the discrete logarithm problem with the number field sieve. In: et al., M.Y. (ed.) PKC 2006. LNCS, vol. 3958, pp. 174–190. Springer (2006)</li>
      <li>&lt;span id=&quot;page-13-18&quot;&gt;&lt;/span&gt;9. Coppersmith, D.: Modifications to the number field sieve. J. of Cryptology 6(3), 169–180 (1993)</li>
      <li>&lt;span id=&quot;page-13-17&quot;&gt;&lt;/span&gt;10. Franke, J., Kleinjung, T.: Continued fractions and lattice sieving. In: SHARCS (2005)</li>
      <li>&lt;span id=&quot;page-13-8&quot;&gt;&lt;/span&gt;11. Freeman, D., Scott, M., Teske, E.: A taxonomy of pairing-friendly elliptic curves. J. of Cryptology 23, 224–280 (2010)</li>
      <li>&lt;span id=&quot;page-13-29&quot;&gt;&lt;/span&gt;12. González, Á.: Measurement of areas on a sphere using Fibonacci and latitude–longitude lattices. Math. Geosc. pp. 42–49 (2010)</li>
      <li>&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;13. Gordon, D.M.: Discrete logarithms in GFppq using the number field sieve. SIAM Journal on Discrete Mathematics 6(1), 124–138 (1993)</li>
      <li>&lt;span id=&quot;page-13-21&quot;&gt;&lt;/span&gt;14. Guillevic, A.: Computing individual discrete logarithms faster in GFpp &lt;sup&gt;n&lt;/sup&gt;q with the NFS-DL algorithm. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015. LNCS, vol. 9452, pp. 149–173. Springer (2015)</li>
      <li>&lt;span id=&quot;page-13-32&quot;&gt;&lt;/span&gt;15. Hanrot, G., Pujol, X., Stehlé, D.: Algorithms for the shortest and closest lattice vector problems. In: Chee, Y.M., Guo, Z., Ling, S., Shao, F., Tang, Y., Wang, H., Xing, C. (eds.) Coding and Cryptology - Third International Workshop, IWCC 2011. LNCS, vol. 6639, pp. 159–190. Springer (2011)</li>
      <li>&lt;span id=&quot;page-13-13&quot;&gt;&lt;/span&gt;16. Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: An experiment of number field sieve for discrete logarithm problem over GF(p &lt;sup&gt;12&lt;/sup&gt;). In: Fischlin, M., Katzenbeisser, S. (eds.) Number Theory and Cryptography. LNCS, vol. 8260, pp. 108–120. Springer (2013)</li>
      <li>&lt;span id=&quot;page-13-16&quot;&gt;&lt;/span&gt;17. Hayasaka, K., Aoki, K., Kobayashi, T., Takagi, T.: A construction of 3-dimensional lattice sieve for number field sieve over Fp&lt;sup&gt;n&lt;/sup&gt; . Cryptology ePrint Archive, 2015/1179 (2015)</li>
      <li>&lt;span id=&quot;page-13-3&quot;&gt;&lt;/span&gt;18. Joux, A., Lercier, R.: Improvements to the general number field sieve for discrete logarithms in prime fields. Math. Comp. 72(242), 953–967 (2003)</li>
      <li>&lt;span id=&quot;page-13-4&quot;&gt;&lt;/span&gt;19. Joux, A., Lercier, R., Smart, N.P., Vercauteren, F.: The Number Field Sieve in the Medium Prime Case. In: Dwork, C. (ed.) CRYPTO 2006. LNCS, vol. 4117, pp. 326–344. Springer (2006)</li>
      <li>&lt;span id=&quot;page-13-30&quot;&gt;&lt;/span&gt;20. Joux, A., Pierrot, C.: The special number field sieve in Fp&lt;sup&gt;n&lt;/sup&gt; – application to pairing-friendly constructions. In: Cao, Z., Zhang, F. (eds.) Pairing 2013. LNCS, vol. 8365, pp. 45–61. Springer (2013)</li>
      <li>&lt;span id=&quot;page-13-12&quot;&gt;&lt;/span&gt;21. Kim, T., Barbulescu, R.: Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, 2015/1027 (2015), preprint, to appear at CRYPTO 2016.</li>
      <li>&lt;span id=&quot;page-13-24&quot;&gt;&lt;/span&gt;22. Kleinjung, T.: On polynomial selection for the general number field sieve. Math. Comp. 75, 2037–2047 (2006)</li>
      <li>&lt;span id=&quot;page-13-6&quot;&gt;&lt;/span&gt;23. Lenstra, A.K., Verheul, E.R.: The XTR public key system. In: Bellare, M. (ed.) CRYPTO 2000. LNCS, vol. 1880, pp. 1–19. Springer (2000)</li>
      <li>&lt;span id=&quot;page-13-23&quot;&gt;&lt;/span&gt;24. Murphy, B.A.: Polynomial selection for the number field sieve integer factorisation algorithm. Ph.D. thesis, The Australian National University (1999)</li>
      <li>&lt;span id=&quot;page-13-10&quot;&gt;&lt;/span&gt;25. Pierrot, C.: The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015. LNCS, vol. 9056, pp. 156–170. Springer (2015)</li>
      <li>&lt;span id=&quot;page-13-22&quot;&gt;&lt;/span&gt;26. Pollard, J.: The lattice sieve. In: Lenstra, A.K., Lenstra, Jr., H.W. (eds.) The development of the number field sieve, Lecture Notes in Math., vol. 1554, pp. 43–49. Springer (1993)</li>
      <li>&lt;span id=&quot;page-13-7&quot;&gt;&lt;/span&gt;27. Rubin, K., Silverberg, A.: Torus-based cryptography. In: Boneh, D. (ed.) CRYPTO 2003, LNCS, vol. 2729, pp. 349–365. Springer (2003)</li>
      <li>&lt;span id=&quot;page-13-31&quot;&gt;&lt;/span&gt;28. Sarkar, P., Singh, S.: New complexity trade-offs for the (multiple) number field sieve algorithm in nonprime fields. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016. LNCS, vol. 9665, pp. 429–458. Springer (2016)</li>
      <li>&lt;span id=&quot;page-13-20&quot;&gt;&lt;/span&gt;29. Schirokauer, O.: Virtual logarithms. J. Algorithms 57, 140–147 (2005)</li>
      <li>&lt;span id=&quot;page-13-2&quot;&gt;&lt;/span&gt;30. Schirokauer, O.: Discrete logarithms and local units. Philos. Trans. A 345(1676), 409–423 (1993)</li>
      <li>&lt;span id=&quot;page-13-28&quot;&gt;&lt;/span&gt;31. The CADO-NFS Development Team: CADO-NFS, an implementation of the number field sieve algorithm (2015), <a href="http://cado-nfs.gforge.inria.fr/">http://cado-nfs.gforge.inria.fr/</a>, release 2.2.0</li>
      <li>&lt;span id=&quot;page-13-14&quot;&gt;&lt;/span&gt;32. Zajac, P.: Discrete Logarithm Problem in Degree Six Finite Fields. Ph.D. thesis, Slovak University of Technology (2008), <a href="http://www.kaivt.elf.stuba.sk/kaivt/Vyskum/XTRDL">http://www.kaivt.elf.stuba.sk/kaivt/Vyskum/XTRDL</a></li>
      <li>&lt;span id=&quot;page-13-15&quot;&gt;&lt;/span&gt;33. Zajac, P.: On the use of the lattice sieve in the 3D NFS. Tatra Mt. Math. Publ. 45, 161–172 (2010)</li>
    </ul>

    <h2 id="sec-11" class="text-2xl font-bold">Appendix A. Computing the average <span class="math">\\ell</span> -adic valuation</h2>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;In the case of 2-dimensional sieving, the average  <span class="math">\\ell</span> -adic valuation can be computed with the small recursive lifting function given as Algorithm 1. This is what is done for instance in the CADO-NFS implementation. This is admittedly much simpler and faster that running a full factorization of f over the  <span class="math">\\ell</span> -adics, which is advantageous when many polynomials have to be tested.</p>

    <p class="text-gray-300">The equivalent for 3-dimensional sieving is not as simple, but can still be faster in many cases than a full  <span class="math">\\ell</span> -adic factorization. Let us give first the modifications to be done for computing the contribution of irreducible factors of degree 2 modulo  <span class="math">\\ell</span> . The normalization factor C must be changed to  <span class="math">\\ell^2/(\\ell^2 + \\ell + 1)</span> . Then, all the computations must no longer be done over the integers, but over the unramified extension  <span class="math">\\mathbb{Q}_{\\ell^2}</span>  of  <span class="math">\\mathbb{Q}_{\\ell}</span>  of degree 2. Only the roots genuinely over this extension are considered in the for loop, but their computation is still done modulo  <span class="math">\\ell</span> : in step 4, we are now doing polynomial factorization over  <span class="math">\\mathbb{F}_{\\ell^2}</span> . Finally, in step 6, the contribution to add is  <span class="math">1/(\\ell^2 - 1)</span> , and in step 8, the result of the recursive call must be multiplied by  <span class="math">C/\\ell^2</span>  instead of  <span class="math">C/\\ell</span> . We obtain Algorithm 2.</p>

    <p class="text-gray-300">We emphasize that this algorithm returns the correct answer, even in the case where the degree 2 factor is a multiple factor of f modulo  <span class="math">\\ell</span> ; knowing the nature of the  <span class="math">\\ell</span> -adic factorization above this multiple factor is not required.</p>

    <p class="text-gray-300">The case of a multiple factor of degree 1 is less straightforward, because the contribution to the average valuation will not be the same for a split, inert or ramified factor above this root. Still, in most cases, and in particular when the root is only a double root, it is possible to adapt Algorithm 1 and get the correct answer. We skip the details; the corresponding code is given in the hd branch of the CADO-NFS repository.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Algorithm 1: av_val_dim2 Average <span class="math">\\ell</span> -adic valuation, 2-dim. case. <strong>input</strong>: A polynomial f; a prime <span class="math">\\ell</span> . output: The average ( \\ell )-adic valuation of <span class="math">\\operatorname{Res}_x(f(x), a - bx).</span> 1 <span class="math">v \\leftarrow \\ell</span> -valuation of the content of f. <span class="math">f \\leftarrow f/\\ell^v</span> . <span class="math">C \\leftarrow \\ell/(\\ell+1); v \\leftarrow Cv</span> . 4 for r in Roots(f) modulo <span class="math">\\ell</span> do if r is a simple root then <span class="math">v \\leftarrow v + C/(\\ell - 1)</span> . 6 else <span class="math">v \\leftarrow v + \\frac{C}{\\ell}</span> av_val_dim2 <span class="math">(f(r + \\ell x), \\ell)</span> . end 10 end 11 return v.</h4>

    <pre><code class="language-text">input: A polynomial f over \\mathbb{Q}_{\\ell^2}; a prime \\ell.
    output: The contribution to the average \\ell-adic
                valuation of \\operatorname{Res}_x(f(x), ax^2 + bx + c), coming
                from irreducible factors of degree 2 mod \\ell.
 1 v \\leftarrow Minimum \\ell-valuation of the coefficients of f.
   f \\leftarrow f/\\ell^v
    C \\leftarrow \\ell^2/(\\ell^2 + \\ell + 1); v \\leftarrow Cv.
 4 for r in Roots(f) modulo \\ell do
          At top-level of recursion, if r is in \\mathbb{Q}_{\\ell}, skip it.
         if r is a simple root then
              v \\leftarrow v + C/(\\ell^2 - 1).
 7
 8
              v \\leftarrow v + \\frac{C}{\\ell^2} \\text{ av\\_val\\_dim3\\_deg2}(f(r + \\ell x), \\ell).
 9
         end
10
11 end
12 return v.
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-14-3&quot;&gt;&lt;/span&gt;Appendix B. Real and complex roots: shape of the isonorms</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;In the classical 2-dimensional NFS, having many real roots in  <span class="math">f_0</span>  and  <span class="math">f_1</span>  tends to increase the Murphy-E value. This can be explained by the fact that when we sieve a degree 1 polynomial whose (rational) root is a good approximation of a root of f, then the corresponding norm will be small. In the case of 3-dimensional sieving, complex roots have to be taken into account as well.</p>

    <p class="text-gray-300">Let f be a polynomial to be used in NFS. A first order estimate of the sizes of the norms would imply that the surface of points corresponding to polynomials a(x) of degree 2 that yield a norm of a given size is a sphere (or an ellipsoid if there is skewness). A real root in f will</p>

    <p class="text-gray-300">correspond to a plane in the direction of which the isonorm sphere is deformed with a bump. Since we are now sieving polynomials of degree 2, they can also approximate complex roots (or irreducible real factors of degree 2). The iso-norm sphere is therefore also stretched in the direction of the lines corresponding to polynomials close to irreducible factors of degree 2.</p>

    <p class="text-gray-300">In Figure B.1, we give pictures illustrating how the sphere is modified in the directions corresponding to real and complex roots of f. This clearly shows that the spherical approximation is not accurate enough and justifies to use the more precise Murphy-E estimate. For these pictures, we used the following polynomials:</p>

    <pre><code class="language-text">- with no real roots: 1456x^6 - 170x^5 + 15810x^4 - 20x^3 - 1825x^2 + 2676x + 1774;

- with 2 real roots: 1456x^6 + 6330x^5 + 15810x^4 - 20x^3 - 15825x^2 - 6324x + 1771;

- with 4 real roots: 1067x^6 + 3757x^5 + 4277x^4 + 3637x^3 - 1789x^2 - 4876x + 603;

- with 6 real roots: 3267x^6 + 3251x^5 - 16174x^4 - 12508x^3 + 11988x^2 + 2084x - 531.
</code></pre>

    <p class="text-gray-300">    <img src="_page_15_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;FIGURE B.1. Isonorms for polynomials of degree 6 with 0, 2, 4 and 6 real roots. The red planes correspond to real roots and the green lines to complex roots.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Appendix C. Sarkar-Singh polynomial selections</h4>

    <p class="text-gray-300">For the various choices of d in the case n=6, we report the sizes of the coefficients and the degrees of the two polynomials  <span class="math">f_0</span>  and  <span class="math">f_1</span>  according to Algorithm  <span class="math">\\mathcal{A}</span>  of [28].</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 1 (GJL)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d &quot; 6 (Conjugation)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">}f0}8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">deg f0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">}f1}8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6{7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3{4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2{3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1{2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">deg f1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Galois</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table C.1. Sizes and degrees of polynomials with the Sarkar-Singh constructions for Fp&lt;sup&gt;6&lt;/sup&gt; .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;The space sieve algorithm relies heavily on the notion of transition vectors, but the number of them is not easily controlled. From Lemma <a href="#page-10-0">6,</a> for a given lattice we can define the transition vector associated to a point in the I ˆ J plane. In Figure <a href="#page-16-3">D.1,</a> pictures are shown where a different color is associated to each transition vector. The example on the right is highly degenerate, in the sense that there are many different transition vectors; however, in this example, most of the area is covered by the vector with the smallest z-coordinate.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_6.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-3&quot;&gt;&lt;/span&gt;Figure D.1. Three examples of how transition vectors covers the I ˆ J plane. Each color correspond to a transition vector; below each picture, the colors are listed in the increasing order of the z-coordinate of the corresponding vector.</p>

    <p class="text-gray-300">We describe in Algorithm <a href="#page-17-0">3</a> a complete space sieve algorithm, that takes care about vectors with a z-coordinate equals to 0 that could be found during the weighted LLL and small combination processes. In this algorithm, L is a list that stores all the point we enumerate, L&lt;sup&gt;z&lt;/sup&gt;&quot;&lt;sup&gt;0&lt;/sup&gt; contains vectors with coordinates in s ´ I, Irˆs ´ J, Jrˆt0u and L&lt;sup&gt;z&lt;/sup&gt;‰&lt;sup&gt;0&lt;/sup&gt; the transition vectors.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;We first tried to use an enumeration algorithm following Algorithm 10 of [<a href="#page-13-32">15</a>]; the plane sieve turned out to be about 120 times faster than our implementation of this enumeration algorithm.</p>

    <p class="text-gray-300">We also compared the efficiency of the space sieve compared to the plane sieve. We sampled 1600 special-q among those that we used during the computation detailed in Section <a href="#page-11-1">5.2</a> and sieved about 2 16.7 ideals of norm larger than IJ on each side. In average for each side, the</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6"><strong>Algorithm 3:</strong> Space sieve</h4>

    <pre><code class="language-text">input: a lattice \\Lambda and the target cuboid of size I \\times J \\times K.
output: list of visited points.
L \\leftarrow \\emptyset.
// Compute candidate transition vectors.
M^{SLR} \\leftarrow weighted LLL on \\Lambda, with non-negative z-coordinate.
L_z \\leftarrow \\text{linear combinations of the elements of } M^{SLR}
Split L_z into L_{z=0} \\cup L_{z\\neq 0} according to the z-coordinate of elements being zero or not.
Keep only the smallest non colinear vectors of L_{z=0} if they exist.
Sort L_{z\\neq 0} by increasing z coordinate.
// Main enumeration loop.
s \\leftarrow (0, 0, 0)^T.
while the z-coordinate of s is smaller than K do
    // Find elements in the plane of the z-coordinate of s.
    L_c \\leftarrow \\emptyset.
    for v \\in L_{z=0} do
     Add to L and L_c all the points in the intersection of the line s + \\lambda v and the cuboid, \\lambda \\in \\mathbb{Z}.
    // Find smallest next location.
    s_t \\leftarrow (0, 0, K)^T.
    for s_n \\in L_c do
         for v \\in L_{z\\neq 0} do
              if v + s_n is in the sieving region and (v + s_n)[2] &lt; s_t[2] then
               s_t \\leftarrow v + s_n.
              end
         \\mathbf{end}
    end
    // Use plane sieve as a fallback.
    if s_t was not updated then
         s_t \\leftarrow \\text{call the plane sieve with } L_c[0] as a starting point and stop when an element is found.
         Insert s_t - s in L_{z\\neq 0}, keeping the list sorted.
    end
    s \\leftarrow s_t.
end
return L
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;plane sieve takes 5.23 seconds in a single core at 3.20 GHz against 1.60 seconds for the space sieve. This gives a 3.25 accelerating factor by using the space sieve instead of the plane sieve.</p>

    <p class="text-gray-300">Appendix G. Different polynomial selections for the field  <span class="math">\\mathbb{F}_{p^6}</span>  with a 50 bits p</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;We report here the three different pairs of polynomials we used to build Table 2: - Conjugation:</p>

    <pre><code class="language-text">• f_0 = x^{12} + 12x^{11} + 40x^{10} - 20x^9 - 245x^8 - 200x^7 + 344x^6 + 592x^5 + 250x^4 - 20x^3 - 26x^2 + 1;
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">f_1 = 31943784x^6 + 201177002x^5 + 23785745x^4 638875680x^3 502942505x^2 9514298x + 31943784</span> .</p></li>
      <li><p class="text-gray-300">Sarkar-Singh with d = 2, yielding degrees (8,6):  <span class="math">f_0 = 2x^8 2x^7 + 6x^6 4x^5 + 9x^4 4x^3 + 6x^2 2x + 2</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1 = 13305451020x^6 + 13068452527x^5 122274520263x^4 + 74260869388x^3 122274520263x^2 + 13068452527x + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 12274520263x^2 + 1227452066x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 122745206x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 1227456x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 122746x^2 + 12274</span> 13305451020.</li>
    </ul></li>
      <li><p class="text-gray-300">Sarkar-Singh with d = 3, yielding degrees (9,6):  <span class="math">f_0 = x^9 + 2x^8 5x^7 9x^6 + 13x^5 + 24x^4 2x^3 15x^2 7x 1</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1 = 10266423024x^6 6028238612x^5 67420797690x^4 2036172080x^3 + 116716740730x^2 + 67626776756x +</span> 10266423024.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Pierrick Gaudry and Laurent Grémy Inria, CNRS, Université de Lorraine Nancy, France</p>

    <p class="text-gray-300">firstname.lastname@loria.fr</p>

    <p class="text-gray-300">Marion Videau Quarkslab, Paris, France Inria, CNRS, Université de Lorraine Nancy, France</p>

`;
---

<BaseLayout title="Collecting relations for the Number Field Sieve in $GF(p^6)$ (2016/124)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/124
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="collecting-relations-for-the-number-field-sieve-in-2016" />
  </article>
</BaseLayout>
