---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/834';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Succinct Arguments in the Quantum Random Oracle Model';
const AUTHORS_HTML = 'Alessandro Chiesa, Peter Manohar, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley Peter Manohar pmanohar@cs.cmu.edu Carnegie Mellon University Nicholas Spooner nick.spooner@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Succinct non-interactive arguments (SNARGs) are highly efficient certificates of membership in non-deterministic languages. Constructions of SNARGs in the random oracle model are widely believed to be post-quantum secure, provided the oracle is instantiated with a suitable post-quantum hash function. No formal evidence, however, supports this belief.</p>

    <p class="text-gray-300">In this work we provide the first such evidence by proving that the SNARG construction of Micali is unconditionally secure in the <em>quantum</em> random oracle model. We also prove that, analogously to the classical case, the SNARG inherits the zero knowledge and proof of knowledge properties of the PCP underlying the Micali construction. We thus obtain the first zero knowledge SNARG of knowledge (zkSNARK) that is secure in the quantum random oracle model.</p>

    <p class="text-gray-300">Our main tool is a new lifting lemma that shows how, for a rich class of oracle games, we can <em>generically</em> deduce security against quantum attackers by bounding a natural classical property of these games. This means that in order to prove our theorem we only need to establish <em>classical</em> properties about the Micali construction. This approach not only lets us prove post-quantum security but also enables us to prove explicit bounds that are tight up to small factors.</p>

    <p class="text-gray-300">We additionally use our techniques to prove that SNARGs based on interactive oracle proofs (IOPs) with round-by-round soundness are unconditionally secure in the quantum random oracle model. This result establishes the post-quantum security of many SNARGs of practical interest.</p>

    <p class="text-gray-300">Keywords: succinct arguments; quantum random oracle model; probabilistically checkable proofs</p>

    <p class="text-gray-300">1 Introduction 1 1.1 SNARGs with random oracles 1 1.2 Our results 2 1.3 Related work 3</p>

    <p class="text-gray-300">2 Techniques 5 2.1 The construction of Micali 5 2.2 Challenges in the quantum setting 6 2.3 Outline of our approach 7 2.4 From oracle games to database games 7 2.5 A basic lifting lemma for database games 8 2.6 Stronger lifting via conditional instability 10 2.7 Instability of the Micali oracle game 11 2.8 zkSNARKs in the QROM 11 2.9 The BCS construction: succinct arguments beyond Micali 12</p>

    <p class="text-gray-300">3 Preliminaries 14 3.1 Quantum notation 14 3.2 Oracle algorithms 14 3.3 Non-interactive arguments in the quantum random oracle model 15 3.4 Probabilistically checkable proofs 15 3.5 Databases 16 3.6 Compressed phase oracle 16</p>

    <p class="text-gray-300">4 From oracle games to database games 18 4.1 The case of classical adversaries 18 4.2 The case of quantum adversaries 19</p>

    <p class="text-gray-300">5 A lifting lemma for database games 21 5.1 Database properties and the basic lifting lemma 21 5.2 Conditional instability and the lifting lemma 23 5.3 Proof of Lemma 5.10 25</p>

    <p class="text-gray-300">6 Soundness of the Micali construction 30 6.1 Some algorithms for Merkle trees 30 6.2 The oracle game for the Micali construction 31 6.3 Proof of Theorem 6.1 32</p>

    <p class="text-gray-300">7 zkSNARKs in the QROM 35 7.1 Zero knowledge 35 7.2 Proof of knowledge 36</p>

    <p class="text-gray-300">8 The BCS construction in the QROM 38 8.1 Interactive oracle proofs 38 8.2 The BCS construction and its oracle game 38 8.3 Round-by-round soundness and knowledge 39 8.4 Our result 40 8.5 Proof of Theorem 8.6 40 8.6 On the difference in hash chains 45</p>

    <p class="text-gray-300">A Proof of Lemma 3.2 47</p>

    <p class="text-gray-300">B Round-by-round vs. strong round-by-round soundness An appendix authored by James Hulett (jhulett@berkeley.edu) 48</p>

    <p class="text-gray-300">Acknowledgments 51</p>

    <p class="text-gray-300">References 51</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The design and analysis of cryptographic primitives that are plausibly secure against quantum attackers is an increasingly important goal. The expected advent of quantum computers demands the cryptography community to be prepared well in advance, so much so that the National Institute of Standards and Technology (NIST) is <em>already</em> in the process of selecting, from among many proposals, a new set of cryptography standards that are “post-quantum” <em>[x20]</em>. The proposals involve schemes for key agreement, public-key encryption, and digital signatures, and are intended to eventually replace existing standards based on the hardness of factoring or discrete logarithms.</p>

    <p class="text-gray-300">In this paper we study the post-quantum security of a cryptographic primitive that has recently received much attention across theoretical and applied communities: <em>succinct arguments</em> <em>[x11]</em>. These are argument systems for non-deterministic languages where the communication complexity between the prover and verifier is sublinear in the size of the non-deterministic witness. This notion originates in seminal works of Kilian <em>[x17]</em> and Micali <em>[x18]</em>, which construct succinct arguments for languages in <span class="math">\\mathsf{NTIME}(T(n))</span> where communication complexity is <span class="math">\\mathsf{poly}(\\lambda,\\log T(n))</span> and the time complexity of the verifier is <span class="math">\\mathsf{poly}(\\lambda,n,\\log T(n))</span>; here <span class="math">\\lambda</span> is the security parameter.</p>

    <p class="text-gray-300">Researchers have studied many aspects of succinct arguments in the last two decades, leading to numerous constructions with different tradeoffs <em>[x26]</em>, efficient realizations in code <em>[x22, bell15, x23, dalek18, stark18, x21, iden19]</em>, real-world deployments <em>[x31, x7]</em>, and standardization efforts <em>[x32]</em>. A particularly useful feature is that many succinct arguments can be made zero knowledge with minimal overhead. At present, however, <em>most approaches to obtain efficient succinct arguments are “pre-quantum”</em>, since they rely on the discrete logarithm problem (and more).</p>

    <p class="text-gray-300">A notable exception is a class of succinct arguments obtained by combining two ingredients: (a) probabilistic proof systems, which are unconditionally secure, and (b) cryptographic hash functions, for which we have post-quantum candidates. This class includes the succinct interactive argument of Kilian <em>[x17]</em>, which use probabilistically checkable proofs (PCPs) <em>[x3, x10, x2, x1]</em> and collision-resistant hash functions. It also includes the succinct non-interactive argument (SNARG) of Micali <em>[x18]</em>, which uses PCPs and random oracles. More generally, by using random oracles one can construct a SNARG from a multi-round generalization of PCPs known as interactive oracle proofs (IOPs) <em>[x2, x23]</em>. <em>All of these succinct arguments are widely believed to be post-quantum</em>, provided the hash function is suitably instantiated <em>[x5]</em>.</p>

    <p class="text-gray-300">There is, however, no formal evidence that supports the above widely-held belief. Since succinct arguments are a fundamental cryptographic primitive with both theoretical and real-world applications, it is important to prove guarantees on their post-quantum security.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 SNARGs with random oracles</h3>

    <p class="text-gray-300">In this paper we focus our attention on the SNARG construction of Micali <em>[x18]</em>, which is unconditionally secure in the random oracle model <em>[x4, x29]</em>. SNARGs in the random oracle model are not only plausibly post-quantum secure but also enjoy other desirable features. Namely, the random oracle can be heuristically instantiated via hash functions that avoid expensive public-key cryptographic operations. Moreover, the SNARG uses a transparent (public-coin) setup, because the only public parameter needed to produce/verify proofs is the choice of hash function.</p>

    <p class="text-gray-300">We are thus interested in asking: can we establish formal evidence that the SNARG construction of Micali is post-quantum secure? One way to establish formal evidence is to prove security in a quantum analogue of the random oracle model, as we now explain. A quantum attacker can, among other things, evaluate a hash function in superposition when given the hash function’s code. This enables the attacker, for instance, to find pre-images <em>[x10]</em> or collisions <em>[x4]</em> faster than a classical attacker. In light of this, Boneh et al. <em>[x2]</em> have argued that, in the quantum setting, the correct way to model a random oracle is to allow the attacker to query the random oracle in superposition. The resulting model is known as the <em>quantum random oracle model</em> (QROM), and a line of work has established post-quantum security within this model for a variety of cryptographic primitives; see, e.g., <em>[x2, x18, x20, x21]</em>.</p>

    <p class="text-gray-300">Our goal is to study the SNARG construction of Micali in the quantum random oracle model. We also study the SNARG construction of BCS <em>[x3]</em>, which yields SNARGs of practical interest.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Our results</h3>

    <p class="text-gray-300">The main result of this paper is establishing that the SNARG construction of Micali <em>[x16]</em> is unconditionally secure in the quantum random oracle model. This is the first formal evidence that supports the widely-held belief that this construction is post-quantum secure when the oracle is instantiated via a suitable post-quantum hash function.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">The non-interactive argument of Micali, when based on a PCP with soundness error <span class="math">\\epsilon</span>, has soundness error <span class="math">O(t^{2}\\epsilon+t^{3}/2^{\\lambda})</span> against quantum attackers that make <span class="math">t</span> queries to a random oracle with output size <span class="math">\\lambda</span>. This soundness error is tight up to small factors.</p>

    <p class="text-gray-300">A key step in our proof, of independent interest, is a <em>Lifting Lemma</em> that shows how, for a rich class of “oracle games”, we can <em>generically</em> deduce security against quantum attackers by bounding a natural classical property of these games, instability, that we introduce. This means that to prove Theorem 1 we only need to bound the instability of the Micali construction. This approach not only yields the theorem but also enables us to prove explicit bounds that are tight up to small factors.</p>

    <p class="text-gray-300">If we base the Micali construction on suitable PCPs, we obtain new statements about the existence of post-quantum non-interactive arguments. First, if the PCP achieves (honest-verifier) zero knowledge and proof of knowledge then through the Micali construction we obtain a zero knowledge non-interactive argument of knowledge that is <em>unconditionally</em> secure in the quantum random oracle model. This strengthens a result of Unruh <em>[x22]</em>, which assumes the existence of a post-quantum <span class="math">\\Sigma</span>-protocol for <span class="math">\\NP</span>. Moreover, if the PCP has polylogarithmic query complexity and verifier running time then we obtain the first construction of a zero knowledge succinct non-interactive argument of knowledge (zkSNARK) that is secure in the quantum random oracle model.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <p class="text-gray-300">There exists a zero knowledge non-interactive argument of knowledge for <span class="math">\\NP</span> in the quantum random oracle model. Moreover, the non-interactive argument is succinct, in the sense that arguments have size <span class="math">\\lambda^{c}</span> and can be verified in time <span class="math">(\\lambda\\cdot n)^{c}</span>, where <span class="math">\\lambda</span> is the random oracle’s security parameter, <span class="math">n</span> is instance size, and <span class="math">c\\geq 1</span> is a universal constant.</p>

    <p class="text-gray-300">The above theorem is stated for <span class="math">\\NP</span> only for simplicity. Analogously to the classical case, a more general statement holds for all non-deterministic time languages by relying on suitable PCPs for non-deterministic time. For example, the PCP in <em>[x5]</em> achieves proof of knowledge, can be made (honest-verifier) zero knowledge <em>[x7, x11]</em>, and supports general non-deterministic time computations.</p>

    <p class="text-gray-300">The BCS construction. We conclude with a result that demonstrates how the tools in this paper can be used to study the post-quantum security of protocols that are of practical interest. Since known PCP constructions are expensive, efficient constructions of succinct arguments in the random oracle model are typically based on the BCS construction <em>[x1]</em>, which instead uses interactive oracle proofs (IOPs) <em>[x2, x28]</em>, a multi-round extension of PCPs. This extension additionally captures IPs <em>[x1, x13]</em> and IPCPs <em>[x24]</em> as special cases.</p>

    <p class="text-gray-300">We prove that the BCS construction is unconditionally secure in the quantum random oracle model, if applied to public-coin IOPs that have round-by-round soundness <em>[x10]</em>. The resulting argument inherits proof of knowledge and zero knowledge properties of the underlying IOP.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 3 (informal).</h6>

    <p class="text-gray-300">The non-interactive argument of BCS, when based on a public-coin IOP with round-by-round soundness error <span class="math">\\epsilon</span>, has soundness error <span class="math">O(t^{2}\\epsilon+t^{3}/2^{\\lambda})</span> against quantum attackers that make <span class="math">t</span> queries to a random oracle with output size <span class="math">\\lambda</span>. Moreover, it is an argument of knowledge if the IOP has round-by-round proof of knowledge, and it is a (statistical) zero knowledge argument if the IOP is honest-verifier zero knowledge.</p>

    <p class="text-gray-300">Round-by-round proof of knowledge is a natural notion that we introduce, analogous to round-by-round soundness, and is satisfied by many natural protocols. In particular, Theorem 3 enables us to deduce the post-quantum security of succinct arguments based on well-known IPs such as the sumcheck protocol <em>[x21]</em> and the GKR protocol <em>[x12]</em>, as well as zkSNARKs based on recent IOPs such as <em>[x1, x2, x3]</em>. These protocols (among others) are of interest to practitioners, and our result can be used to guide parameter choices in practice.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.3 Related work</h3>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Argument systems that use random oracles.</h4>

    <p class="text-gray-300">Several works study the post-quantum security of zero knowledge non-interactive arguments of knowledge that use random oracles, most notably those obtained by applying the Fiat–Shamir transformation <em>[x15]</em> to a post-quantum <span class="math">\\Sigma</span>-protocol. These are used to achieve post-quantum digital signatures <em>[x10, x22, x16]</em>, and underlie constructions submitted to the NIST call for post-quantum cryptography <em>[x27]</em>.</p>

    <p class="text-gray-300">A security reduction for the Fiat–Shamir transformation in the quantum random oracle model has been recently achieved <em>[x11, x20]</em>. Obtaining a security reduction had been elusive, as the classical approach of rewinding the adversary to reduce to special soundness of the <span class="math">\\Sigma</span>-protocol does not work for quantum adversaries. Before, researchers were only able to prove security if the underlying <span class="math">\\Sigma</span>-protocol satisfies special properties <em>[x12, x26, x23]</em>, or resorted to proving security for alternative, less efficient, constructions such as the Unruh transformation <em>[x27]</em>.</p>

    <p class="text-gray-300">The question that we study in this paper is complementary to these prior works. On the one hand, prior works study the security of the Fiat–Shamir transformation <em>given</em> that the underlying <span class="math">\\Sigma</span>-protocol is secure against efficient quantum attackers. On the other hand, we study protocols such as the Micali construction and BCS construction that can be viewed as applying the Fiat–Shamir transformation to specific public-coin protocols that are known to be unconditionally secure in the (classical) random oracle model. In particular, we establish <em>unconditional</em> security in the</p>

    <p class="text-gray-300">quantum random oracle model via an approach that considers the protocol as a whole (similarly to the classical analysis of these protocols).</p>

    <p class="text-gray-300">The foregoing differences are reflected in a technical analysis that departs from prior works. Most of the effort in this paper is establishing <em>classical</em> security properties of the Micali and BCS constructions, which we then use to generically deduce their quantum security. This approach, besides being intuitive, yields tight bounds that can be used to guide parameter choices in practice.</p>

    <p class="text-gray-300">Succinct arguments based on lattices. Several lattice problems are presumed to remain hard even against quantum adversaries, and researchers have relied on such problems to propose numerous cryptographic constructions that are plausibly post-quantum. A handful of works have used lattices to achieve various notions of succinct arguments that are plausibly post-quantum. Baum et al. <em>[x1]</em> rely on the short integer solution (SIS) problem to obtain an argument system for arithmetic circuits where the communication complexity grows with the square-root of circuit size; the argument system is constant-round, public-coin, and honest-verifier zero knowledge. Boneh et al. <em>[x2, x3]</em> and Gennaro et al. <em>[x10]</em> rely on lattice knowledge assumptions to construct designated-verifier SNARGs for boolean circuits, in the preprocessing model <em>[x4]</em>. Whether one can use lattices to obtain publicly-verifiable SNARGs remains an open problem.</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We discuss the main ideas behind our results. In Section 2.1 we recall the construction of Micali, and then in Section 2.2 we explain the challenges that arise when trying to prove its security in the quantum random oracle model. In Section 2.3 we outline our approach to obtain a proof of security for the Micali construction (Theorem 1); we elaborate on our approach in Sections 2.4 to 2.7. Finally, in Section 2.8 we discuss how to further establish zero knowledge and proof of knowledge; we thus obtain the first zkSNARK secure in the quantum random oracle model (Theorem 2).</p>

    <p class="text-gray-300">We conclude in Section 2.9 by explaining how our techniques extend to establish post-quantum security for the BCS construction applied to many protocols of practical interest (Theorem 3).</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 The construction of Micali</h3>

    <p class="text-gray-300">The construction of Micali is a transformation that maps any <em>probabilistically checkable proof</em> (PCP) into a corresponding non-interactive argument in the random oracle model. (See Section 3.4 for the definition of a PCP, and Section 3.3 for that of a non-interactive argument.) The resulting non-interactive argument is <em>succinct</em>, i.e. a SNARG, provided the PCP has suitable parameters.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be a PCP for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span>, proof length <span class="math">\\ell</span> over alphabet <span class="math">\\Sigma</span>, and query complexity <span class="math">q</span>. The honest prover <span class="math">\\mathbf{P}</span> takes as input an instance-witness pair <span class="math">(\\mathtt{x},\\mathtt{w})</span> and outputs a proof string <span class="math">\\Pi\\colon[\\ell]\\to\\Sigma</span>. The honest verifier <span class="math">\\mathbf{V}</span> takes as input the instance <span class="math">\\mathtt{x}</span>, makes <span class="math">q</span> probabilistic queries to a (possibly malicious) proof string <span class="math">\\hat{\\Pi}\\colon[\\ell]\\to\\Sigma</span>, and then accepts or rejects.</p>

    <p class="text-gray-300">The PCP <span class="math">(\\mathbf{P},\\mathbf{V})</span> for <span class="math">\\mathcal{R}</span> is used to construct a SNARG <span class="math">(\\mathcal{P},\\mathcal{V})</span> for <span class="math">\\mathcal{R}</span>, as follows.</p>

    <p class="text-gray-300">The SNARG prover <span class="math">\\mathcal{P}</span> takes as input an instance <span class="math">\\mathtt{x}</span> and witness <span class="math">\\mathtt{w}</span>. First, <span class="math">\\mathcal{P}</span> uses the random oracle <span class="math">h</span> to commit to the proof string <span class="math">\\Pi:=\\mathbf{P}(\\mathtt{x},\\mathtt{w})</span> via a Merkle tree, obtaining a corresponding root <span class="math">\\mathsf{rt}</span>. Second, <span class="math">\\mathcal{P}</span> applies the random oracle <span class="math">h</span> to the root <span class="math">\\mathsf{rt}</span> in order to derive randomness <span class="math">\\mathsf{r}</span> for the PCP verifier <span class="math">\\mathbf{V}</span>. Third, <span class="math">\\mathcal{P}</span> simulates the PCP verifier <span class="math">\\mathbf{V}</span> with the proof string <span class="math">\\Pi</span>, input <span class="math">\\mathtt{x}</span>, and randomness <span class="math">\\mathsf{r}</span>, in order to deduce the queried locations of <span class="math">\\Pi</span>. Finally, <span class="math">\\mathcal{P}</span> assembles a SNARG proof <span class="math">\\pi</span> that contains the root <span class="math">\\mathsf{rt}</span>, answers to the queries, and an authentication path for each answer.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that the SNARG proof <span class="math">\\pi</span> is succinct because it is small (it has size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(q\\cdot(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\lambda\\log\\ell))=O_{\\lambda}(q)<span class="math"> for </span>\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{O(\\lambda)}$) and it is cheap to validate via the algorithm described next.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The SNARG verifier <span class="math">\\mathcal{V}</span> takes as input an instance <span class="math">\\mathtt{x}</span> and a (possibly malicious) SNARG proof <span class="math">\\tilde{\\pi}</span>. First, <span class="math">\\mathcal{V}</span> uses the random oracle <span class="math">h</span> to check that each answer in <span class="math">\\tilde{\\pi}</span> is certified by an authentication path relative to the claimed root <span class="math">\\tilde{\\mathsf{rt}}</span>. Next, <span class="math">\\mathcal{V}</span> applies the random oracle <span class="math">h</span> to the root <span class="math">\\tilde{\\mathsf{rt}}</span> in order to derive randomness <span class="math">\\tilde{\\mathsf{r}}</span>. Finally, <span class="math">\\mathcal{V}</span> runs the PCP verifier <span class="math">\\mathbf{V}</span> on the instance <span class="math">\\mathtt{x}</span> and randomness <span class="math">\\tilde{\\mathsf{r}}</span>, answering <span class="math">\\mathbf{V}</span>’s queries using the claimed answers in <span class="math">\\tilde{\\pi}</span>.</p>

    <p class="text-gray-300">The intuition behind the construction is that the soundness guarantee of a PCP holds only if the proof string <span class="math">\\tilde{\\Pi}</span> to be validated is <em>fixed</em> before the randomness <span class="math">\\tilde{\\mathsf{r}}</span> for the PCP verifier is known, and for this reason the SNARG prover must derive <span class="math">\\tilde{\\mathsf{r}}</span> by hashing a commitment <span class="math">\\tilde{\\mathsf{rt}}</span> to <span class="math">\\tilde{\\Pi}</span>.</p>

    <p class="text-gray-300">This construction is unconditionally secure in the random oracle model <em>[x13, x25, x1]</em>: The SNARG <span class="math">(\\mathcal{P},\\mathcal{V})</span> has soundness error <span class="math">O(t\\epsilon+t^{2}/2^{\\lambda})</span> against (classical) attackers that make at most <span class="math">t</span> queries to the random oracle. This soundness error is tight up to small factors.</p>

    <p class="text-gray-300">A SNARG obtained via the Micali construction also inherits zero knowledge and proof of knowledge properties of the underlying PCP. We discuss these additional properties and how we establish them in the quantum setting later on in Section 2.8. We focus on soundness first.</p>

    <p class="text-gray-300">2.2 Challenges in the quantum setting</p>

    <p class="text-gray-300">Our goal is to show that the SNARG construction of Micali is unconditionally secure in the quantum random oracle model. Suppose that <span class="math">\\tilde{\\mathcal{P}}</span> is a <span class="math">t</span>-query quantum prover that convinces the SNARG verifier <span class="math">\\mathcal{V}</span> with probability <span class="math">\\delta</span> (over the random oracle). We wish to construct a malicious PCP prover <span class="math">\\tilde{\\mathbf{P}}</span> that, using <span class="math">\\tilde{\\mathcal{P}}</span> as a subroutine, outputs a proof string <span class="math">\\tilde{\\Pi}\\colon[\\ell]\\to\\Sigma</span> that convinces the PCP verifier <span class="math">\\mathbf{V}</span> with related probability <span class="math">\\epsilon(\\delta,t)</span> (here the probability is over the randomness of <span class="math">\\tilde{\\mathbf{P}}</span> and <span class="math">\\mathbf{V}</span>).</p>

    <p class="text-gray-300">A natural approach to reduce the SNARG prover <span class="math">\\tilde{\\mathcal{P}}</span> to the PCP prover <span class="math">\\tilde{\\mathbf{P}}</span> would be to try to adapt to the quantum setting the reduction that is used for the classical setting. Below we recall the classical reduction, and then explain why adapting it to the quantum case is challenging.</p>

    <p class="text-gray-300">The reduction for classical attackers. The reduction from a classical SNARG prover <span class="math">\\tilde{\\mathcal{P}}</span> to a PCP prover <span class="math">\\tilde{\\mathbf{P}}</span> relies on a straightline extractor, as we now explain.</p>

    <p class="text-gray-300">While the SNARG prover <span class="math">\\tilde{\\mathcal{P}}</span> outputs a short proof <span class="math">\\pi</span> that contains a Merkle root and a few decommitted values, the PCP prover <span class="math">\\tilde{\\mathbf{P}}</span> must output a “long” proof string <span class="math">\\tilde{\\Pi}</span>. How can <span class="math">\\tilde{\\mathbf{P}}</span> obtain all this information from seeing only <span class="math">\\pi</span>? The answer is that, when running <span class="math">\\tilde{\\mathcal{P}}</span> as a subroutine, <span class="math">\\tilde{\\mathbf{P}}</span> observes the queries that <span class="math">\\tilde{\\mathcal{P}}</span> makes to the oracle, and these queries reveal the proof string <span class="math">\\tilde{\\Pi}</span>.</p>

    <p class="text-gray-300">This is only a caricature of how <span class="math">\\tilde{\\mathbf{P}}</span> actually works, though. The reason is that <span class="math">\\tilde{\\mathcal{P}}</span> need not produce a query sequence from which <span class="math">\\tilde{\\mathbf{P}}</span> can just read off a proof string <span class="math">\\tilde{\\Pi}</span> consistent with the Merkle root in <span class="math">\\pi</span>. For example, <span class="math">\\tilde{\\mathcal{P}}</span> could try to commit to many possible proof strings “in its head”, derive the corresponding randomness from each commitment, and then select which commitment to include in <span class="math">\\pi</span>. Even worse, <span class="math">\\tilde{\\mathcal{P}}</span> could try to commit to a partial proof string <span class="math">\\tilde{\\Pi}</span> via an incomplete Merkle tree and, because the PCP verifier inspects only a small fraction of a proof string, hope that queries will land to leaves of the Merkle tree that do exist.</p>

    <p class="text-gray-300">The proof of Theorem 2.1 shows that, despite these complications, there is a way for <span class="math">\\tilde{\\mathbf{P}}</span> to observe all queries and answers of a single execution of the SNARG prover <span class="math">\\tilde{\\mathcal{P}}</span>, and then run an algorithm on these to extract a suitable proof string <span class="math">\\tilde{\\Pi}</span>.</p>

    <p class="text-gray-300">How to deal with quantum attackers? If we now return to the case where the SNARG prover <span class="math">\\tilde{\\mathcal{P}}</span> is a quantum attacker, we are immediately confronted with a severe problem. Since <span class="math">\\tilde{\\mathcal{P}}</span> can query the random oracle in superposition, how can <span class="math">\\tilde{\\mathbf{P}}</span> “observe” queries and answers to the oracle? If <span class="math">\\tilde{\\mathbf{P}}</span> were to just measure <span class="math">\\tilde{\\mathcal{P}}</span>’s query register, <span class="math">\\tilde{\\mathcal{P}}</span> may detect this and stop working. This basic problem has made obtaining security reductions against quantum attackers that access random oracles exceedingly difficult when compared to the case of classical attackers. Papers that study the security of cryptographic primitives in the quantum random oracle model have had to develop clever techniques to somehow circumvent this problem in various settings of interest.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Most relevant to this paper is a work of Zhandry <em>[x20]</em> that introduces compressed oracles, a set of notions and techniques that enables a quantum algorithm to simulate access to a random oracle for a quantum attacker. This is achieved by replacing a random oracle <span class="math">h\\colon\\{0,1\\}^{m}\\to\\{0,1\\}^{n}</span> with the action of a specially-crafted unitary <span class="math">\\mathcal{O}</span> that implicitly keeps track of queries. This is a quantum analogue of when, in the classical setting, a simulator merely observes the queries made by the attacker and maintains a database of the query-answer pairs. Formally, the classical simulator keeps track of a database <span class="math">D</span>, which is a partial function <span class="math">D\\colon\\{0,1\\}^{m}\\rightharpoonup\\{0,1\\}^{n}</span>. The database represents the part of the random oracle that has been “revealed” to the attacker by answering its queries. In the quantum setting, the state space of the quantum attacker is augmented with registers to store the database, which (loosely) keep track of the database <span class="math">D</span> in superposition, as it evolves from query to query. Thus, while the original oracle <span class="math">h</span> operates on the state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{\\mathcal{A}}\\rangle$ of the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">adversary, the unitary <span class="math">\\mathcal{O}</span> operates on a bipartite state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{\\mathcal{A}},\\psi_{D}\\rangle<span class="math">. This extended state represents a purification of the mixed state of the adversary induced by choosing the oracle </span>h$ at random.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One may conjecture that the compressed oracle technique, by virtue of “exposing” a quantum attacker’s queries, makes proving the quantum security of the Micali construction, or indeed of any construction that uses random oracles, straightforward. This is, unfortunately, not the case.</p>

    <p class="text-gray-300">For example, the results of <em>[x20]</em> on compressed oracles allow us to argue directly that, given an adversary that outputs a convincing SNARG proof <span class="math">\\pi</span> with high probability, if we measure the database <span class="math">D</span> after the adversary terminates, then with high probability one can find a convincing <em>SNARG proof</em> <span class="math">\\pi</span> in the database <span class="math">D</span>. This does not allow us to reduce to soundness of the underlying PCP, however, because to do that we need to argue that one can extract a <em>PCP proof</em> <span class="math">\\Pi</span> from <span class="math">D</span> (containing a lot more information than <span class="math">\\pi</span>) that convinces the PCP verifier with high probability.</p>

    <p class="text-gray-300">While the techniques in <em>[x20]</em> suffice for analyzing simple protocols like collision finding, it is not clear how to analyze more complex protocols such as the Micali SNARG, as explained above. In the next section we describe a general framework for analyzing complex protocols in the quantum random oracle model.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Outline of our approach</h3>

    <p class="text-gray-300">The ideas that we use in this paper to analyze the Micali construction are almost entirely generic, and can be used to analyze any <em>oracle game</em>. Informally, given a “base game” <span class="math">G\\subseteq A^{k}\\times B^{k}\\times C</span>, an adversary with oracle access to a random oracle <span class="math">h</span> wins the oracle game for <span class="math">G</span> if it outputs a tuple <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span> where <span class="math">h(a_{i})=b_{i}</span> for each <span class="math">i\\in[k]</span>. Oracle games are a natural notion that captures many games of interest, such as finding pre-images or finding collisions. Producing a valid proof in the Micali construction can also be cast as an oracle game, and we shall view the soundness property of the Micali construction as stating that the value (maximum winning probability) of this game is small (when the statement being proved is false).</p>

    <p class="text-gray-300">Our proof of quantum security consists of two main parts. First, we <em>generically</em> reduce the value of any oracle game to the <em>instability</em> of the game, a purely classical property of the game that we introduce. Second, we analyze the instability of the oracle game induced by the Micali construction. The instability of this oracle game is not too difficult to analyze because it is a classical quantity, and the “hard work” is crisply, and conveniently, encapsulated within our generic reduction. We view bounding values of oracle games via instability as the main technical contribution of this paper.</p>

    <p class="text-gray-300">We now elaborate on our approach: in Section 2.4 we recast prior work in the language of oracle games; in Section 2.5 we explain what is instability and how we use it to bound game values; in Section 2.6 we introduce conditional instability and use it to prove tighter bounds on oracle game values; and in Section 2.7 we outline the analysis of instability for the Micali construction.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.4 From oracle games to database games</h3>

    <p class="text-gray-300">We begin with a sequence of three games whose values are closely related. These games play the role of hybrids in our analysis, and are all defined relative to the given base game <span class="math">G\\subseteq A^{k}\\times B^{k}\\times C</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle game. This is the game defined earlier that is played in the real world, using a random oracle <span class="math">h</span>. The adversary wins if it outputs a tuple <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span> with <span class="math">h(a_{i})=b_{i}</span> for each <span class="math">i\\in[k]</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulated oracle game. The simulator of Zhandry <em>[x20]</em> is used to run the adversary and its final state is measured, leading to a tuple <span class="math">(\\mathbf{a},\\mathbf{b},c)</span> <em>and</em> a database <span class="math">D</span>. The adversary wins if <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span> and <span class="math">D(a_{i})=b_{i}</span> for each <span class="math">i\\in[k]</span>. (The oracle <span class="math">h\\colon\\{0,1\\}^{m}\\to\\{0,1\\}^{n}</span> is now replaced by the database <span class="math">D\\colon\\{0,1\\}^{m}\\rightharpoonup\\{0,1\\}^{n}</span> stored by the simulator.)</li>

      <li>Database game. Again the simulator of Zhandry is used to run the adversary, leading to a tuple <span class="math">(\\mathbf{a},\\mathbf{b},c)</span> and a database <span class="math">D</span>. However, now we ignore <span class="math">(\\mathbf{a},\\mathbf{b},c)</span> and only consider <span class="math">D</span>. The adversary wins if there <em>exists</em> <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime},c^{\\prime})\\in G</span> such that <span class="math">D(a_{i})=b_{i}</span> for each <span class="math">i\\in[k]</span>.</li>

    </ul>

    <p class="text-gray-300">We let <span class="math">\\omega_{\\mathsf{O}}^{<em>}(G,t)</span>, <span class="math">\\omega_{\\mathsf{S}}^{</em>}(G,t)</span>, and <span class="math">\\omega_{\\mathsf{D}}^{*}(G,t)</span> denote the values of the oracle game, simulated oracle game, and database game against quantum adversaries that make at most <span class="math">t</span> oracle queries.</p>

    <p class="text-gray-300">A result of Zhandry <em>[x20, Lemma 5]</em>, when stated via the notions above, shows that <span class="math">\\sqrt{\\omega_{\\mathsf{O}}^{<em>}(G,t)}\\leq\\sqrt{\\omega_{\\mathsf{S}}^{</em>}(G,t)}+\\sqrt{k/2^{n}}</span>. Moreover, <span class="math">\\omega_{\\mathsf{S}}^{<em>}(G,t)\\leq\\omega_{\\mathsf{D}}^{</em>}(G,t)</span> holds trivially, because winning the simulated oracle game implies winning the database game, by taking <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime},c^{\\prime}):=(\\mathbf{a},\\mathbf{b},c)</span>. In sum:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.2.</h6>

    <p class="text-gray-300">For any base game <span class="math">G</span>,</p>

    <p class="text-gray-300"><span class="math">\\sqrt{\\omega_{\\mathsf{O}}^{<em>}(G,t)}\\leq\\sqrt{\\omega_{\\mathsf{D}}^{</em>}(G,t)}+\\sqrt{k/2^{n}}\\enspace.</span></p>

    <p class="text-gray-300">The above lemma is a conceptualization of prior work, and is the starting point for the technical contributions of this paper. In particular, the lemma tells us that in order to bound the maximum winning probability of a quantum adversary in an oracle game (played in the real world) it suffices to bound the maximum winning probability of the adversary in the corresponding database game.</p>

    <p class="text-gray-300">See Section 4 for more details.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.5 A basic lifting lemma for database games</h3>

    <p class="text-gray-300">We describe how we use a <em>classical</em> quantity <span class="math">\\mathbf{I}(\\mathcal{P}_{G},t)</span> to bound <span class="math">\\omega_{\\mathsf{D}}^{*}(G,t)</span>, the maximum winning probability of any <span class="math">t</span>-query quantum algorithm in the database game of <span class="math">G</span>. When combined with the hybrids in Section 2.4, this reduces the quantum security of oracle games to studying <span class="math">\\mathbf{I}(\\mathcal{P}_{G},t)</span>.</p>

    <p class="text-gray-300">Given a base game <span class="math">G</span>, we let <span class="math">\\mathcal{P}_{G}</span> be the set of databases that win the database game of <span class="math">G</span>. In the classical setting, a natural way to bound the maximum winning probability of the database game is to compute, for each possible database <span class="math">D\\notin\\mathcal{P}_{G}</span> (a database that is currently losing the game), the maximum probability that adding a query-answer pair to <span class="math">D</span> puts <span class="math">D</span> in <span class="math">\\mathcal{P}_{G}</span>. Assuming that the empty database is not in <span class="math">\\mathcal{P}_{G}</span> (for otherwise one can win trivially), this quantity characterizes the probability that the adversary gets lucky and ends up with a winning database <span class="math">D</span>.</p>

    <p class="text-gray-300">We define the <em>instability</em> of <span class="math">\\mathcal{P}_{G}</span> with query bound <span class="math">t</span>, denoted <span class="math">\\mathbf{I}(\\mathcal{P}_{G},t)</span>, to be the maximum probability that, for any database <span class="math">D</span> containing less than <span class="math">t</span> queries, making one additional (classical) query changes whether or not <span class="math">D</span> is in <span class="math">\\mathcal{P}_{G}</span>. <em>The foregoing argument explains that the classical value of the database game <span class="math">G</span> is bounded by <span class="math">t\\cdot\\mathbf{I}(\\mathcal{P}_{G},t)</span>.</em> Intuitively this is because each query can increase the probability that the database <span class="math">D</span> is in <span class="math">\\mathcal{P}_{G}</span> by at most <span class="math">\\mathbf{I}(\\mathcal{P}_{G},t)</span>.</p>

    <p class="text-gray-300">We prove that an analogous result holds for quantum adversaries as well. We call this lemma a lifting lemma, because it enables us to use the <em>classical</em> quantity of instability to prove a bound on the maximum winning probability of <em>quantum</em> adversaries. The version below is a “basic” version, because we shall ultimately need a stronger statement, as we discuss in Section 2.6. The result below extends an idea of Zhandry sketched in <em>[x20, Section 4.3]</em>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 2.3 (Basic lifting lemma).</h6>

    <p class="text-gray-300">For any base game <span class="math">G</span>,</p>

    <p class="text-gray-300"><span class="math">\\omega^{*}_{\\sf D}(G,t)\\leq O\\big{(}t^{2}\\cdot{\\bf I}({\\cal P}_{G},t)\\big{)}\\enspace.</span></p>

    <p class="text-gray-300">In particular, combining the above with Lemma 2.2, we get</p>

    <p class="text-gray-300"><span class="math">\\omega^{*}_{\\sf O}(G,t)\\leq O\\big{(}t^{2}\\cdot{\\bf I}({\\cal P}_{G},t)+k/2^{n}\\big{)}\\enspace.</span></p>

    <p class="text-gray-300">Even the above basic lifting lemma is a powerful tool. For example, suppose that <span class="math">G</span> is the collision game, where the adversary wins if it outputs an oracle collision. Then <span class="math">{\\bf I}({\\cal P}_{G},t)&lt;t/2^{n}</span>, because if <span class="math">D</span> is a database with no collisions and less than <span class="math">t</span> entries, then making one more query produces a collision with probability less than <span class="math">t/2^{n}</span>, and if <span class="math">D</span> has collisions then it is not possible to make an additional query and remove collisions. Then (since <span class="math">k=2</span> in the collision game) the lifting lemma immediately tells us that <span class="math">\\omega^{<em>}_{\\sf O}(G,t)\\leq O(t^{3}/2^{n})</span>, which shows that the probability that a <span class="math">t</span>-query quantum oracle algorithm finds a collision is bounded by <span class="math">O(t^{3}/2^{n})</span>. This further simplifies the analysis of this fact in </em>[x20]<em> and matches the bound of </em>[x1]<em> (which is tight </em>[x3]*).</p>

    <p class="text-gray-300">We now sketch the proof of the basic lifting lemma. The proof sketch differs slightly from the actual proof, as in the actual proof we do a slightly more complicated analysis that gives us smaller constants. The main ideas, however, remain the same.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">P_{G}</span> be the operator that projects onto databases that win the database game <span class="math">G</span>: for any basis state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> in the database register, </span>P_{G}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> if </span>D\\in{\\cal P}_{G}<span class="math">, and </span>P_{G}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle=0<span class="math"> if </span>D\\not\\in{\\cal P}_{G}<span class="math">; </span>P_{G}<span class="math"> acts as the identity on other registers. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle<span class="math"> is the final joint state of the quantum adversary and database, then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{G}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}<span class="math"> is the probability that </span>D\\in{\\cal P}_{G}<span class="math"> after measurement. We will assume that </span>\\emptyset\\notin{\\cal P}_{G}<span class="math">, i.e., that the empty database does not win the database game of </span>G$ (or else the adversary can win by doing nothing).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can represent any simulated quantum adversary making at most <span class="math">t</span> queries as a sequence of unitary operators <span class="math">U=A_{t}{\\cal O}A_{t-1}{\\cal O}\\ldots A_{1}{\\cal O}</span> applied to an initial state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0}\\rangle\\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\emptyset\\rangle<span class="math">, where </span>{\\cal O}<span class="math"> is the compressed oracle and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\emptyset\\rangle<span class="math"> is the state of the empty database. Each </span>A_{i}<span class="math"> acts non-trivially only on the registers of the adversary being simulated and </span>P_{G}<span class="math"> acts non-trivially only on the database registers, so </span>P_{G}<span class="math"> and </span>A_{i}<span class="math"> commute. So, if </span>P_{G}<span class="math"> and </span>{\\cal O}<span class="math"> were to also commute, then we could simply conclude that </span>P_{G}U\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle=UP_{G}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle=0<span class="math">, i.e., that the adversary never wins. (Here we used the fact that </span>\\emptyset\\not\\in{\\cal P}_{G}$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, it is <em>not</em> the case that <span class="math">P_{G}</span> and <span class="math">{\\cal O}</span> commute. This should be expected because in general an adversary can win with some positive probability. However, if we could show that they <em>almost</em> commute, then we could apply the previous argument to show that $P_{G}U\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle\\approx UP_{G}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle=0<span class="math">; i.e., the adversary wins with small probability. The notion of “almost” commuting we use is that the operator norm </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},{\\cal O}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the commutator </span>[P_{G},{\\cal O}]:=P_{G}{\\cal O}-{\\cal O}P_{G}$ is small.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unfortunately, for interesting games the operator norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},{\\cal O}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> may not be small. For example, if </span>G<span class="math"> is the collision game and </span>D<span class="math"> is a database with a pre-image of every </span>y\\in\\{0,1\\}^{n}<span class="math"> but no collisions, then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},{\\cal O}]\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,D\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">. Generally, this norm may be large if </span>D$ has many entries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Query-bounded adversaries, however, cannot produce nonzero amplitudes on databases with more entries than the query bound. Hence, intuitively we should not consider states that correspond to large databases when bounding the operator norm of the aforementioned commutator. We follow this intuition by introducing the notion of a <em>projected oracle</em>, which acts as the compressed oracle except that it discards databases that do not belong to a certain subset.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 2.4.</h6>

    <p class="text-gray-300">Let <span class="math">P</span> be the operator that projects onto databases that belong to a given subset <span class="math">{\\cal P}</span> of databases. A projected oracle is an operator of the form <span class="math">P{\\cal O}P</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus consider the projected oracle <span class="math">P_{t}\\mathcal{O}P_{t}</span>, where <span class="math">P_{t}</span> is operator that projects onto databases containing at most <span class="math">t</span> queries. For adversaries that make at most <span class="math">t</span> queries, replacing <span class="math">\\mathcal{O}</span> with <span class="math">P_{t}\\mathcal{O}P_{t}</span> has no effect because the adversary cannot create a database that contains more than <span class="math">t</span> entries. Moreover, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},P_{t}\\mathcal{O}P_{t}]\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\right\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=0<span class="math"> if </span>D<span class="math"> contains more than </span>t<span class="math"> entries, so the operator norm of </span>[P_{G},P_{t}\\mathcal{O}P_{t}]<span class="math"> accounts for the action of </span>\\mathcal{O}<span class="math"> <em>only</em> on databases containing at most </span>t$ entries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In sum, projected oracles allow us to cleanly compute the operator norm only over databases that are reachable by an adversary making a bounded number of queries. By carefully analyzing the action of <span class="math">\\mathcal{O}</span>, we show that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},P_{t}\\mathcal{O}P_{t}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq O\\big{(}\\mathbf{I}(\\mathcal{P}_{G},t)\\big{)}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We additionally prove that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{G}U\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\right\\rangle-UP_{G}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\right\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P_{G},P_{t}\\mathcal{O}P_{t}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Combining these two inequalities yields the lifting lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Section 5.1 for more details.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.6 Stronger lifting via conditional instability</h3>

    <p class="text-gray-300">The lifting lemma implies that to prove soundness of the Micali construction, it suffices to bound the instability of the Micali database game. Unfortunately, the instability of the Micali database game is actually large, even given the query bound. For example, suppose that <span class="math">D</span> is a database containing Merkle trees for many different proof strings, but each of these Merkle trees has (miraculously) the same root due to collisions. Then, the probability that querying the root yields a good randomness for the underlying PCP verifier is large, because the answer to the query only needs to be a good random string for any one of the many proofs that <span class="math">D</span> contains.</p>

    <p class="text-gray-300">This counterexample, however, should not be of concern because it relies on the database having many collisions, and we have already argued that creating even a single collision in the database is difficult. To deal with this issue, we introduce the notion of <em>conditional instability</em>: <span class="math">\\mathbf{I}(\\mathcal{P}\\mid\\mathcal{Q},t)</span>. This is a refined notion of instability that allows us to condition on events, e.g., that the database has no collisions. Our main technical contribution is the following stronger variant of Lemma 2.3.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 2.5.</h6>

    <p class="text-gray-300">A database property <span class="math">\\mathcal{P}</span> is a set of databases. The complement of <span class="math">\\mathcal{P}</span> is <span class="math">\\bar{\\mathcal{P}}</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 2.6 (Lifting lemma).</h6>

    <p class="text-gray-300">For any base game <span class="math">G</span> and database property <span class="math">\\mathcal{Q}</span>,</p>

    <p class="text-gray-300"><span class="math">\\omega^{*}_{\\mathbf{D}}(G,t)\\leq O\\Big{(}t^{2}\\cdot\\big{(}\\mathbf{I}(\\mathcal{P}_{G}\\mid\\bar{\\mathcal{Q}},t)+\\mathbf{I}(\\mathcal{Q},t)\\big{)}\\Big{)}\\enspace.</span></p>

    <p class="text-gray-300">In particular, combining the above with Lemma 2.2, we get</p>

    <p class="text-gray-300"><span class="math">\\omega^{*}_{\\mathbf{D}}(G,t)\\leq O\\Big{(}t^{2}\\cdot\\big{(}\\mathbf{I}(\\mathcal{P}_{G}\\mid\\bar{\\mathcal{Q}},t)+\\mathbf{I}(\\mathcal{Q},t)\\big{)}+k/2^{n}\\Big{)}\\enspace.</span></p>

    <p class="text-gray-300">The above statement is an “instability analogue” of the standard fact that for any two events <span class="math">E_{1}</span> and <span class="math">E_{2}</span>, <span class="math">\\Pr[E_{1}]\\leq\\Pr[E_{1}\\cup E_{2}]\\leq\\Pr\\big{[}E_{1}\\mid\\bar{E_{2}}\\big{]}+\\Pr[E_{2}]</span>.</p>

    <p class="text-gray-300">The proof of Lemma 2.6 has three steps. First, we relax the database game <span class="math">\\mathcal{P}_{G}</span> so that the adversary wins if the database is in <span class="math">\\mathcal{P}_{G}\\cup\\mathcal{Q}</span>. Clearly, winning the relaxed game is only easier than the original database game. Lemma 2.3 then implies that <span class="math">\\omega^{*}_{\\mathbf{D}}(G,t)\\leq O\\Big{(}t^{2}\\cdot\\mathbf{I}(\\mathcal{P}_{G}\\cup\\mathcal{Q},t)\\Big{)}</span>. Finally, we show that for any two database properties <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{Q}</span> it holds that <span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)\\leq\\mathbf{I}(\\mathcal{P}\\mid\\bar{\\mathcal{Q}},t)+\\mathbf{I}(\\mathcal{Q},t)</span>, which completes the proof.</p>

    <p class="text-gray-300">We remark that Lemma 2.6 cannot be proved by simply arguing that <span class="math">\\mathbf{I}(\\mathcal{P},t)\\leq\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)</span> and then applying Lemma 2.3. This is because <span class="math">\\mathbf{I}(\\mathcal{P},t)</span> and <span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)</span> are in general <em>incomparable</em> (see Proposition 5.12 for examples).</p>

    <p class="text-gray-300">See Section 5.2 for more details.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.7 Instability of the Micali oracle game</h3>

    <p class="text-gray-300">Armed with our lifting lemma, establishing the quantum security of the Micali construction is now relatively straightforward. Let <span class="math">\\mathcal{P}_{\\mathsf{Mic}}</span> be the database property for the Micali game, and let <span class="math">\\bar{\\mathcal{P}}_{\\mathsf{col}}</span> be the no-collision property (the set of databases that do not contain collisions). We show that, for a random oracle of the form <span class="math">h\\colon\\{0,1\\}^{2\\lambda}\\to\\{0,1\\}^{\\lambda}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{I}(\\mathcal{P}_{\\mathsf{col}},t)<t/2^{\\lambda}\\quad\\text{and}\\quad\\mathbf{I}(\\mathcal{P}_{\\mathsf{Mic}}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\bar{\\mathcal{P}}_{\\mathsf{col}},t)<\\varepsilon+O(t/2^{\\lambda})\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proving each of these inequalities is merely a classical argument.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathsf{col}},t)</span>: If <span class="math">D</span> is a database containing less than <span class="math">t</span> entries and has a collision, then adding an entry to <span class="math">D</span> cannot remove the collision, so the probability that adding a new entry to <span class="math">D</span> makes <span class="math">D</span> have no collisions is <span class="math">0</span>. Let <span class="math">D</span> be a database containing less than <span class="math">t</span> entries and no collisions. For any new query <span class="math">x</span>, adding the query-answer pair <span class="math">(x,y)</span> to <span class="math">D</span> for a random <span class="math">y</span> will contain a collision with probability less than <span class="math">t/2^{\\lambda}</span>. Thus, <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathsf{col}},t)&lt;t/2^{\\lambda}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathbf{I}(\\mathcal{P}_{\\mathsf{Mic}}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\bar{\\mathcal{P}}_{\\mathsf{col}},t)<span class="math">: It is impossible to go from a database </span>D<span class="math"> in </span>\\mathcal{P}_{\\mathsf{Mic}}<span class="math"> to a database </span>D<span class="math"> not in </span>\\mathcal{P}_{\\mathsf{Mic}}<span class="math"> by adding entries. Let </span>D<span class="math"> be a database not in </span>\\mathcal{P}_{\\mathsf{Mic}}<span class="math"> containing less than </span>t<span class="math"> entries that contains no collisions. There are two ways to make </span>D<span class="math"> in </span>\\mathcal{P}_{\\mathsf{Mic}}<span class="math">: either the new query is for the randomness of the PCP verifier in the Micali construction, in which case this finds a good choice of randomness with probability at most </span>\\varepsilon<span class="math">, or the new query extends one of the Merkle trees that the adversary is constructing. To extend the Merkle tree the adversary must find a pre-image, which happens with probability less than </span>O(t/2^{\\lambda})<span class="math">. Hence, </span>\\mathbf{I}(\\mathcal{P}_{\\mathsf{Mic}}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\bar{\\mathcal{P}}_{\\mathsf{col}},t)<\\varepsilon+O(t/2^{\\lambda})$, completing the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining these bounds on instability with the lifting lemma completes the proof of soundness, and completes a proof sketch for Theorem 1. See Section 6 for more details.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.8 zkSNARKs in the QROM</h3>

    <p class="text-gray-300">We have so far discussed how to establish soundness of the Micali construction in the quantum setting. We now discuss how to further establish zero knowledge and proof of knowledge, obtaining the first zkSNARKs secure in the quantum random oracle model (and thereby proving Theorem 2).</p>

    <p class="text-gray-300">Zero knowledge. In the classical setting, the Micali construction achieves statistical zero knowledge provided the underlying PCP is (honest-verifier) statistical zero knowledge (and leaves in the Merkle tree are suitably salted to ensure statistical hiding of unrevealed leaves) <em>[x13, x1]</em>. In the quantum setting, an analogous statement is immediate simply because the zero knowledge property holds against computationally unbounded verifiers <em>that make an unbounded number of queries to the random oracle</em>, and any quantum verifier can be simulated by an unbounded verifier.</p>

    <p class="text-gray-300">Proof of knowledge. In the classical setting, the Micali construction achieves proof of knowledge provided the underlying PCP is a proof of knowledge <em>[x27]</em>. The quantum analogue of this statement, however, does <em>not</em> immediately follow from our soundness analysis. Recall that our</p>

    <p class="text-gray-300">strategy was to bound the instability of the Micali property for <span class="math">x\\notin\\mathcal{L}</span>, conditioned on no collisions. But when <span class="math">x\\in\\mathcal{L}</span> this approach will not work, because the instability of the Micali property even conditioned on the absence of collisions is 1 (as witnessed by the existence of the honest prover).</p>

    <p class="text-gray-300">Nevertheless, the tools that we develop in this work are flexible enough that we can apply them to also establish proof of knowledge. We consider the following natural extractor strategy: run the prover until completion, and measure the database. Then, for each entry in the database, try to extract a PCP proof rooted at that entry, and then run the PCP extractor on this proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{P}</span> be the set of databases <span class="math">D</span> where there exists a root <span class="math">\\mathsf{rt}</span> such that <span class="math">D</span> wins the Micali game with a SNARG proof rooted at <span class="math">\\mathsf{rt}</span>, but the PCP extractor does not extract a valid witness from the PCP proof rooted at <span class="math">\\mathsf{rt}</span>. If the prover wins the Micali game but the extractor fails, then <span class="math">D</span> must be in <span class="math">\\mathcal{P}</span>. We then argue that $\\mathbf{I}(\\mathcal{P}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\hat{\\mathcal{P}}_{\\mathsf{col}},t)<span class="math"> is at most </span>\\mathsf{k}+O(t/2^{\\lambda})<span class="math">, where </span>\\mathsf{k}<span class="math"> is the knowledge error of the underlying PCP. Intuitively, this is because if the PCP extractor fails to extract a witness from the PCP proof </span>\\Pi<span class="math"> rooted at </span>\\mathsf{rt}<span class="math">, then </span>\\Pi<span class="math"> convinces the verifier with probability at most </span>\\mathsf{k}<span class="math">, and hence the probability of finding good randomness for </span>\\Pi<span class="math"> is at most </span>\\mathsf{k}<span class="math">. Combining this with Lemma 2.6 implies that the probability that the prover wins the Micali game but the extractor fails is at most </span>O(t^{2}\\mathsf{k}+t^{3}/2^{\\lambda})<span class="math">. Hence, if </span>\\mu<span class="math"> is the probability that the prover wins the Micali game, then the probability that the extractor succeeds is at least </span>\\Omega(\\mu-t^{2}\\mathsf{k}-t^{3}/2^{\\lambda})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Section 7 for more details.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.9 The BCS construction: succinct arguments beyond Micali</h3>

    <p class="text-gray-300">We apply our techniques to prove post-quantum security of the BCS construction <em>[x1]</em>, when the underlying public-coin IOP satisfies a notion of soundness achieved by many protocols of practical interest. The notion is <em>round-by-round soundness</em>, and was introduced for IPs in <em>[x11]</em> for the purposes of facilitating proofs of security of the Fiat–Shamir transformation for correlation-intractable hash functions. The notion can be extended in a straightforward way to any IOP, and this is the notion that we consider in this work. We further show that if the underlying IOP is honest-verifier zero knowledge and/or has round-by-round proof of knowledge, then the BCS argument inherits these properties. Round-by-round proof of knowledge is a type of knowledge property that is analogous to round-by-round soundness (and is also achieved by many protocols of practical interest). Below we sketch our analysis; see Section 8 for details.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">An IOP has round-by-round soundness if, for any partial transcript <span class="math">\\mathsf{tr}</span> of the protocol, one can tell if <span class="math">\\mathsf{tr}</span> is “doomed”, i.e., that it is highly unlikely to be accepted by the verifier when completed to a full transcript; a doomed full transcript is never accepted by the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the lifting lemma, in order to prove the post-quantum security of the BCS construction it suffices to bound the conditional instability of the database property <span class="math">\\mathcal{P}</span>, where <span class="math">D\\in\\mathcal{P}</span> if <span class="math">D</span> contains a partial transcript where the last verifier message has flipped the transcript from “doomed” to “not doomed”. We argue that $\\mathbf{I}(\\mathcal{P}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\hat{\\mathcal{P}}_{\\mathsf{col}},t)<\\epsilon+O(t/2^{\\lambda})<span class="math">, where </span>\\epsilon<span class="math"> is the round-by-round soundness error of the IOP. The proof is similar to the proof for the Micali construction. If </span>D\\notin\\mathcal{P}<span class="math">, there are two ways to add an entry and make </span>D\\in\\mathcal{P}<span class="math">: either the new query is for the randomness of the next verifier message in the IOP for some doomed transcript </span>\\mathsf{tr}<span class="math">, in which case we find a message that makes </span>\\mathsf{tr}<span class="math"> not doomed with probability </span>\\epsilon<span class="math">; or the new query extends one of the Merkle trees that the adversary is constructing, which happens with probability less than </span>O(t/2^{\\lambda})<span class="math"> as this implies finding a pre-image. Hence, </span>\\mathbf{I}(\\mathcal{P}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\hat{\\mathcal{P}}_{\\mathsf{col}},t)<\\epsilon+O(t/2^{\\lambda})$, which completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Zero knowledge.</h5>

    <p class="text-gray-300">As in the case of Micali, zero knowledge is straightforward, as the BCS construc</p>

    <p class="text-gray-300">tion classically achieves statistical zero knowledge when the IOP is honest-verifier zero knowledge.</p>

    <p class="text-gray-300">Proof of knowledge. Analogously to our analysis of the Micali construction, we define a property <span class="math">\\mathcal{Q}</span>, where <span class="math">D\\in\\mathcal{Q}</span> if <span class="math">D</span> contains a partial transcript that is in <span class="math">\\mathcal{P}</span> but the BCS extractor fails to extract a valid witness. We then argue that <span class="math">\\mathbf{I}(\\mathcal{Q}\\mid\\bar{\\mathcal{P}}_{\\mathsf{col}})&lt;\\mathsf{k}+O(t/2^{\\lambda})</span>, where <span class="math">\\mathsf{k}</span> is the round-by-round knowledge error of the IOP; the proof of this fact is similar to the proof of soundness. We conclude that if the prover causes the verifier to accept with probability at least <span class="math">\\mu</span>, then the probability that the extractor succeeds is at least <span class="math">\\Omega(\\mu-t^{2}\\mathsf{k}-t^{3}/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We denote by <span class="math">\\mathcal{R}</span> a binary relation of instance-witness pairs <span class="math">(\\mathbf{x},\\mathbf{w})</span>, and by <span class="math">\\mathcal{L}(\\mathcal{R})</span> its corresponding language, which is the set <span class="math">\\{\\mathbf{x} \\mid \\exists \\mathbf{w} \\text{ s.t. } (\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}\\}</span>. We denote by <span class="math">f \\colon X \\to Y</span> a function from a set <span class="math">X</span> to a set <span class="math">Y</span>; similarly, we denote by <span class="math">f \\colon X \\rightharpoonup Y</span> a partial function from a set <span class="math">X</span> to a set <span class="math">Y</span>, i.e., a function <span class="math">f \\colon X \\to Y \\cup \\{\\bot\\}</span>, where <span class="math">\\bot \\notin Y</span> is a special symbol indicating that <span class="math">f(x)</span> is undefined.</p>

    <h2 id="sec-27" class="text-2xl font-bold">3.1 Quantum notation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We briefly recall standard quantum notation. We let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle<span class="math"> denote an arbitrary quantum state, and let </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle<span class="math"> denote an element of the standard (computational) basis. The norm of a state </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle<span class="math"> is </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:= \\sqrt{\\langle\\phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle}<span class="math">. In general, the states that we consider will have norm 1. The operator norm of an operator </span>A<span class="math"> is </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:= \\max_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Note that if </span>A<span class="math"> is unitary then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">. The commutator of two operators </span>A<span class="math"> and </span>B<span class="math"> is </span>[A,B] := AB - BA$. The following proposition relates operator norms and commutators.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proposition 3.1.</strong> Let <span class="math">A, B, C</span> be operators with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ A, B C ] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ A, B ] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ A, C ] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> By definition, <span class="math">[A, BC] = ABC - BCA = ABC - BAC + BAC - BCA = [A, B]C + B[A, C]</span>. Therefore, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[A, BC] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[A, B]C \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B[A, C] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[A, B] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[A, C] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, as </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A projector <span class="math">P</span> is an idempotent linear operator (i.e., <span class="math">P^2 = P</span>). Throughout, we will only consider orthogonal projectors of the form $P_S := \\sum_{x \\in S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle \\langle x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>S<span class="math"> is a set of binary strings. Measuring a state </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle<span class="math"> in the standard basis results in an output that is in </span>S<span class="math"> with probability equal to </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2<span class="math">. Since all </span>P_S<span class="math"> are diagonal in the same basis, they commute with each other. Note that for any non-zero orthogonal projector </span>P<span class="math"> it holds that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">. In particular, since </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AB \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we see that if </span>A<span class="math"> is the product of projectors and unitaries then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-28" class="text-2xl font-bold">3.2 Oracle algorithms</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f \\colon \\{0,1\\}^m \\to \\{0,1\\}^n</span> be a function. The standard way to model oracle access to <span class="math">f</span> in the quantum setting is via a unitary operator <span class="math">O_f</span> that acts as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,y\\rangle \\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,y \\oplus f(x)\\rangle<span class="math"> for all </span>x \\in \\{0,1\\}^m<span class="math"> and </span>y \\in \\{0,1\\}^n<span class="math">. We label the input and output registers </span>\\mathsf{X}<span class="math"> and </span>\\mathsf{Y}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A <span class="math">t</span>-query quantum oracle algorithm <span class="math">\\mathcal{A}</span> is specified via <span class="math">m, n \\in \\mathbb{N}</span>, <span class="math">t</span> unitary operators <span class="math">A_1, \\ldots, A_t</span> and an initial state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0\\rangle<span class="math"> on four registers </span>\\mathsf{X}, \\mathsf{Y}, \\mathsf{S}, \\mathsf{T}<span class="math">. The register </span>\\mathsf{X}<span class="math"> is on </span>m<span class="math"> qubits and is for queries to the oracle; the register </span>\\mathsf{Y}<span class="math"> is on </span>n<span class="math"> qubits and is for answers from the oracle; the register </span>\\mathsf{S}<span class="math"> is for the output of </span>\\mathcal{A}<span class="math">; and the register </span>\\mathsf{T}<span class="math"> is for scratch space of </span>\\mathcal{A}<span class="math">. The initial state </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0\\rangle<span class="math"> and unitary operators </span>A_i$ need not be efficiently computable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We write $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}^f\\right\\rangle<span class="math"> to denote </span>A_{t}O_{f}A_{t - 1}O_{f}\\dots A_{1}O_{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0}\\rangle<span class="math">, the final state of the adversary before measurement. (We implicitly extend </span>O_{f}<span class="math"> to act as the identity on </span>\\mathsf{S},\\mathsf{T}<span class="math">.) We write </span>\\mathcal{A}^f<span class="math"> to denote the random variable which is the outcome of measuring the register </span>\\mathsf{S}<span class="math"> of </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}^f\\right\\rangle<span class="math"> in the computational basis. This is the output of </span>\\mathcal{A}<span class="math"> when accessing the oracle </span>f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A random oracle is a function <span class="math">h \\colon \\{0,1\\}^m \\to \\{0,1\\}^n</span> sampled from <span class="math">\\mathcal{U}(m,n)</span>, the uniform distribution over functions from <span class="math">\\{0,1\\}^m</span> to <span class="math">\\{0,1\\}^n</span>. We write <span class="math">h \\gets \\mathcal{U}(m,n)</span> to say that <span class="math">h</span> is sampled from <span class="math">\\mathcal{U}(m,n)</span>. In the quantum random oracle model [BDFLSZ11], we study <span class="math">\\mathcal{A}^h</span> for <span class="math">h \\gets \\mathcal{U}(m,n)</span>.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be two polynomial-time (classical) algorithms, known as the prover and verifier. We say that <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a non-interactive argument in the quantum random oracle model (QROM) with soundness error <span class="math">\\epsilon</span> for a relation <span class="math">\\mathcal{R}</span> if it satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For every <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}</span> and function <span class="math">h \\in \\mathcal{U}(2\\lambda, \\lambda)</span>, <span class="math">\\mathcal{P}^h(\\mathbf{x},\\mathbf{w})</span> outputs a (classical) proof string <span class="math">\\pi</span> for which <span class="math">\\mathcal{V}^h(\\mathbf{x},\\pi) = 1</span>.</li>

      <li><strong>Soundness.</strong> For every <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span> and <span class="math">t</span>-query quantum oracle algorithm <span class="math">\\tilde{\\mathcal{P}}</span>, the probability over a function <span class="math">h \\leftarrow \\mathcal{U}(2\\lambda, \\lambda)</span> and (classical) proof string <span class="math">\\tilde{\\pi} \\leftarrow \\tilde{\\mathcal{P}}^h</span> that <span class="math">\\mathcal{V}^h(\\mathbf{x}, \\tilde{\\pi}) = 1</span> is at most <span class="math">\\epsilon(t, \\lambda)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">(\\mathcal{P},\\mathcal{V})</span> has argument size <span class="math">s</span> if a proof <span class="math">\\pi</span> output by <span class="math">\\mathcal{P}^h(\\mathbf{x},\\mathbf{w})</span> consists of $s(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also consider non-interactive arguments that additionally achieve proof of knowledge and zero knowledge. The first property will hold against query-bounded adversaries (that are otherwise all-powerful), while the second property will hold against unbounded adversaries (and in particular need not refer to quantum algorithms). We define both of these properties below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Knowledge.</strong> The non-interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> is an argument of knowledge with extraction probability <span class="math">\\kappa</span> if there exists a polynomial-time quantum extractor <span class="math">\\mathcal{E}</span> such that, for every instance <span class="math">\\mathbf{x}</span> and <span class="math">t</span>-query quantum oracle algorithm <span class="math">\\tilde{\\mathcal{P}}</span>, if, over a random oracle <span class="math">h \\leftarrow \\mathcal{U}(2\\lambda, \\lambda)</span>, for <span class="math">\\pi := \\tilde{\\mathcal{P}}^h</span> it holds that <span class="math">\\mathcal{V}^h(\\mathbf{x}, \\pi) = 1</span> with probability <span class="math">\\mu</span>, the probability that <span class="math">\\mathcal{E}^{\\tilde{\\mathcal{P}}}(\\mathbf{x}, 1^t, 1^\\lambda)</span> outputs a valid witness for <span class="math">\\mathbf{x}</span> is at least <span class="math">\\kappa(t, \\mu, \\lambda)</span>. Here the notation <span class="math">\\mathcal{E}^{\\tilde{\\mathcal{P}}}</span> denotes that <span class="math">\\mathcal{E}</span> has black-box access to <span class="math">\\tilde{\\mathcal{P}}</span> as defined by Unruh [Unruh77]. Informally, this means that if <span class="math">\\tilde{\\mathcal{P}} = (A_1, \\ldots, A_t)</span> with initial state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0\\rangle<span class="math">, then </span>\\mathcal{E}<span class="math"> is given an auxiliary register containing </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0\\rangle<span class="math"> and may apply, in addition to any efficient quantum operation, any </span>A_i$ to any of its registers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> The non-interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator <span class="math">\\mathcal{S}</span> such that for every instance-witness pair <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}</span> the distributions below are statistically close (as a function of <span class="math">\\lambda</span>):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(h, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} h \\leftarrow \\mathcal {U} (2 \\lambda , \\lambda) \\\\ \\pi \\leftarrow \\mathcal {P} ^ {h} (\\mathbf {x}, \\mathbf {w}) \\end{array} \\right. \\right\\} \\quad \\text{and} \\quad \\left\\{(h [ \\mu ], \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} h \\leftarrow \\mathcal {U} (2 \\lambda , \\lambda) \\\\ (\\mu , \\pi) \\leftarrow \\mathcal {S} ^ {h} (\\mathbf {x}) \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Above, <span class="math">h[\\mu]</span> is the function that, on input <span class="math">x</span>, equals <span class="math">\\mu(x)</span> if <span class="math">\\mu</span> is defined on <span class="math">x</span>, or <span class="math">h(x)</span> otherwise. This definition uses explicitly-programmable random oracles [BR93]. (Non-interactive zero knowledge with non-programmable random oracles is impossible for non-trivial languages [Pas03; BCS16].)</p>

    <p class="text-gray-300"><strong>Succinctness for non-deterministic time.</strong> A zkSNARK for <span class="math">\\mathsf{NTIME}(T(n))</span> in the QROM is a non-interactive argument for <span class="math">\\mathsf{NTIME}(T(n))</span> in the QROM such that: (a) it has (statistical) zero knowledge; (b) it has extraction probability <span class="math">\\mathsf{poly}(\\mu, 1/t) - \\mathsf{poly}(\\mu, t)/2^{\\lambda}</span>; (c) arguments have size <span class="math">\\mathsf{poly}(\\lambda, \\log T(n))</span>, the prover runs in time <span class="math">\\mathsf{poly}(\\lambda, n, T(n))</span>, and the verifier runs in time <span class="math">\\mathsf{poly}(\\lambda, n, \\log T(n))</span>.</p>

    <p class="text-gray-300">A probabilistically checkable proof (PCP) for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span>, proof length <span class="math">\\ell</span>, and alphabet <span class="math">\\Sigma</span> is a pair of polynomial-time algorithms <span class="math">(\\mathbf{P},\\mathbf{V})</span> for which the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For every instance-witness pair <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}</span>, <span class="math">\\mathbf{P}(\\mathbf{x},\\mathbf{w})</span> outputs a proof string <span class="math">\\Pi \\colon [\\ell] \\to \\Sigma</span> such that <span class="math">\\operatorname*{Pr}\\left[\\mathbf{V}^{\\Pi}(\\mathbf{x}) = 1\\right] = 1</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bullet</span> Soundness. For every instance <span class="math">\\mathtt{x}\\not\\in\\mathcal{L}(\\mathcal{R})</span> and proof string <span class="math">\\Pi\\colon[\\ell]\\to\\Sigma</span>, <span class="math">\\Pr\\bigl{[}\\mathbf{V}^{\\Pi}(\\mathtt{x})=1\\bigr{]}\\leq\\epsilon</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The quantities <span class="math">\\epsilon,\\ell,\\Sigma</span> can be functions of the instance size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Probabilities are taken over the randomness of </span>\\mathbf{V}<span class="math">. The <em>randomness complexity</em> is the number of random bits used by </span>\\mathbf{V}<span class="math">, and the <em>query complexity</em> </span>q<span class="math"> is the number of locations of </span>\\Pi<span class="math"> read by </span>\\mathbf{V}<span class="math">. (Both can be functions of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also consider PCPs that achieve <em>proof of knowledge</em> and (honest-verifier) <em>zero knowledge</em>. We define both of these properties below.</p>

    <p class="text-gray-300">Proof of knowledge. The PCP <span class="math">(\\mathbf{P},\\mathbf{V})</span> has knowledge error <span class="math">\\mathtt{k}</span> if there exists a polynomial-time extractor <span class="math">\\mathbf{E}</span> such that for every instance <span class="math">\\mathtt{x}</span> and proof string <span class="math">\\Pi\\colon[\\ell]\\to\\Sigma</span> if <span class="math">\\Pr[\\mathbf{V}(\\mathtt{x},\\Pi)=1]&gt;\\mathtt{k}</span> then <span class="math">\\mathbf{E}(\\mathtt{x},\\Pi)</span> outputs a valid witness for <span class="math">\\mathtt{x}</span>.</p>

    <p class="text-gray-300">Zero knowledge. The PCP <span class="math">(\\mathbf{P},\\mathbf{V})</span> is (perfect) honest-verifier zero knowledge if there exists a probabilistic polynomial-time simulator <span class="math">\\mathbf{S}</span> such that for every instance-witness pair <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span> the view of <span class="math">\\mathbf{V}(\\mathtt{x})</span> when given access to a proof string sampled as <span class="math">\\Pi\\leftarrow\\mathbf{P}(\\mathtt{x},\\mathtt{w})</span> equals the view of <span class="math">\\mathbf{V}(\\mathtt{x})</span> when given access to <span class="math">\\mathbf{S}(\\mathtt{x})</span>. In the latter case, <span class="math">\\mathbf{S}(\\mathtt{x})</span> adaptively answers queries received from <span class="math">\\mathbf{V}(\\mathtt{x})</span>.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">3.5 Databases</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A <em>database</em> mapping <span class="math">X</span> to <span class="math">Y</span> is a partial function <span class="math">D\\colon X\\rightharpoonup Y</span>. The support of a database <span class="math">D</span> is <span class="math">\\operatorname{supp}(D):=\\{x\\in X\\colon D(x)\\neq\\bot\\}</span> and its image is <span class="math">\\operatorname{im}(D):=\\{D(x)\\colon x\\in\\operatorname{supp}(D)\\}</span>. The size of a database is the size of its support: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{supp}(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Given two databases </span>D<span class="math"> and </span>D^{\\prime}<span class="math">, we write </span>D\\subseteq D^{\\prime}<span class="math"> if </span>\\operatorname{supp}(D)\\subseteq\\operatorname{supp}(D^{\\prime})<span class="math"> and </span>D(x)=D^{\\prime}(x)<span class="math"> for every </span>x\\in\\operatorname{supp}(D)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define two operations on databases, corresponding to deletions and insertions. Given a database <span class="math">D</span>, input values <span class="math">x,x^{\\prime}\\in X</span>, and output value <span class="math">y\\in Y</span>, we define the two databases</p>

    <p class="text-gray-300">\\[ (D-x)(x^{\\prime}):=\\begin{cases}\\bot&\\text{if }x=x^{\\prime}\\\\ D(x^{\\prime})&\\text{if }x\\neq x^{\\prime}\\end{cases}\\quad\\text{and}\\quad(D+[x\\mapsto y])(x^{\\prime}):=\\begin{cases}y&\\text{if }x=x^{\\prime}\\\\ D(x^{\\prime})&\\text{if }x\\neq x^{\\prime}\\end{cases}\\quad. \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">D\\colon\\{0,1\\}^{m}\\rightharpoonup\\{0,1\\}^{n}</span> and <span class="math">t\\in\\mathbb{N}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t\\leq 2^{m}$, we define the pure quantum state</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{t}\\rangle\\,:=\\,\\bigl{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}x_{1},y_{1},\\ldots,x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},y_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\bigr{\\rangle}\\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bot,0^{n}\\rangle^{\\otimes(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-t)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $x_{1},\\ldots,x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> is the lexicographic ordering of </span>\\operatorname{supp}(D)<span class="math"> and </span>y_{i}:=D(x_{i})<span class="math"> for each </span>i\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. We will write </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{t}\\rangle<span class="math"> when the bound </span>t$ is clear from context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.6 Compressed phase oracle</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The standard method to encode a function <span class="math">h\\colon\\{0,1\\}^{m}\\to\\{0,1\\}^{n}</span> as a quantum operation is the unitary matrix <span class="math">O_{h}</span> defined in Section 3.2, which acts as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,y\\rangle\\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,y\\oplus h(x)\\rangle<span class="math">. Another method is to encode </span>h<span class="math"> in the <em>phase</em> of a quantum state, via the unitary matrix </span>O^{\\prime}_{h}<span class="math"> that acts as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u\\rangle\\mapsto(-1)^{u\\cdot h(x)}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u\\rangle<span class="math">. These two encodings are equivalent under an efficient change of basis: </span>O_{h}=(I^{m}\\otimes H^{n})O^{\\prime}_{h}(I^{m}\\otimes H^{n})<span class="math"> where </span>I^{m}<span class="math"> is the identity on the first </span>m<span class="math"> qubits and </span>H^{n}<span class="math"> is the Hadamard transformation on the other </span>n<span class="math"> qubits. Thus, choosing between the <em>standard oracle</em> </span>O_{h}<span class="math"> or the <em>phase oracle</em> </span>O^{\\prime}_{h}$ is a matter of convenience. For example, the Deutsch–Josza algorithm <em>[x10]</em> is easier to describe with a standard oracle, while Grover’s algorithm <em>[x16]</em> is easier with a phase oracle.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper it is more convenient to <em>always work with phase oracles</em>. All quantum query algorithms will thus have an oracle phase register <span class="math">\\mathsf{U}</span> instead of the oracle answer register <span class="math">\\mathsf{Y}</span>. Moreover, since <span class="math">h</span> is sampled at random from the set of all functions from <span class="math">m</span> bits to <span class="math">n</span> bits, we follow Zhand</p>

    <p class="text-gray-300">[Zha19] and extend the adversary's initial state with a random superposition of all functions  <span class="math">h</span> , which represents a purification of the adversary's mixed state relative to the random oracle.</p>

    <p class="text-gray-300">In fact, instead of considering a superposition of functions  <span class="math">h</span> , we will consider a superposition of databases  <span class="math">D</span> , according to the compressed oracle formalism of [Zha19]. Specifically, throughout this paper we will only deal with the compressed phase oracle with  <span class="math">m</span>  input bits and  <span class="math">n</span>  output bits, which we denote by  <span class="math">\\mathcal{O}</span> . We fix the database query bound of the compressed oracle to be  <span class="math">t</span>  in advance. For the purposes of this paper, we will only use the fact that  <span class="math">\\mathcal{O}</span>  is a certain unitary matrix, indistinguishable from a real random oracle, whose action is given by the following lemma, which we prove in Appendix A for completeness. We refer the reader to [Zha19] for more details.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 3.2 ([Zha19]). The compressed phase oracle  <span class="math">\\mathcal{O}</span>  (with query bound  <span class="math">t</span> ) acts on a quantum state  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle<span class="math"> , where  </span>x \\in \\{0,1\\}^m<span class="math"> ,  </span>u \\in \\{0,1\\}^n<span class="math"> ,  </span>z \\in \\{0,1\\}^*<span class="math"> , and  </span>D \\colon \\{0,1\\}^m \\rightharpoonup \\{0,1\\}^n<span class="math">  is a database with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t$ , as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t<span class="math">  or  </span>u = 0^n<span class="math"> , then  </span>\\mathcal{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle = (-1)^{u\\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle<span class="math"> , where  </span>u\\cdot \\bot := 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\rangle := \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y \\in \\{0, 1 \\} ^ {n}} (- 1) ^ {u \\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [ x \\mapsto y ] \\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If  <span class="math">D(x) \\neq \\bot</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , and  </span>u \\neq 0^n<span class="math"> , then  </span>\\mathcal{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z\\rangle \\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi\\rangle$  where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\rangle := (- 1) ^ {u \\cdot D (x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {(- 1) ^ {u \\cdot D (x)}}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D - x \\rangle + \\frac {1}{2 ^ {n}} \\sum_ {y \\in \\{0, 1 \\} ^ {n}} \\left(1 - (- 1) ^ {u \\cdot y} - (- 1) ^ {u \\cdot D (x)}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D - x + [ x \\mapsto y ] \\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a quantum algorithm  <span class="math">\\mathcal{A}</span>  described by unitaries  <span class="math">A_{1},\\ldots ,A_{t}</span>  and initial state  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0\\rangle<span class="math"> , we write  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Sim}^* (\\mathcal{A})\\rangle<span class="math">  to represent the final state of  </span>\\mathcal{A}<span class="math">  before measurement when simulated using  </span>\\mathcal{O}<span class="math">  as the oracle. Formally,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Sim}^* (\\mathcal{A})\\rangle = A_t\\mathcal{O}\\dots A_1\\mathcal{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_0,\\emptyset \\rangle<span class="math"> , where  </span>\\emptyset<span class="math">  denotes that the D register holds the empty database with  </span>t<span class="math">  slots, and we implicitly extend each  </span>A_{i}$  to act as the identity on D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following lemma of [Zha19] shows simulating  <span class="math">\\mathcal{A}</span>  by using  <span class="math">\\mathcal{O}</span>  as the oracle is perfectly indistinguishable from running  <span class="math">\\mathcal{A}</span>  with access to a random oracle.</p>

    <p class="text-gray-300">Lemma 3.3 ([Zha19, Lemma 4]). For any quantum oracle algorithm  <span class="math">\\mathcal{A}</span>  making at most  <span class="math">t</span>  queries,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {T r} _ {\\mathsf {D}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {S i m} ^ {<em>} (\\mathcal {A}) \\right\\rangle \\left\\langle \\operatorname {S i m} ^ {</em>} (\\mathcal {A}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) = \\frac {1}{\\left(2 ^ {n}\\right) ^ {2 ^ {m}}} \\sum_ {h: \\{0, 1 \\} ^ {m} \\rightarrow \\{0, 1 \\} ^ {n}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {A} ^ {h} \\right\\rangle \\left\\langle \\mathcal {A} ^ {h} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^* (\\mathcal{A})\\rangle<span class="math">  purifies the mixed state of  </span>\\mathcal{A}<span class="math">  when interacting with a random oracle  </span>h\\gets \\mathcal{U}(m,n)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The notation  <span class="math">\\mathrm{Tr}_{\\mathsf{D}}</span>  denotes the partial trace over the  <span class="math">\\mathsf{D}</span>  (database) register, defined as the unique linear operator such that  $\\mathrm{Tr}_{\\mathsf{D}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\rangle \\langle a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{Z}}\\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\rangle \\langle b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{D}}):= \\langle b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\rangle \\langle a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{Z}}<span class="math">  for all vectors  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\rangle ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\rangle<span class="math">  . Here  </span>\\mathsf{Z}$  denotes all the registers of the adversary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we formulate three distinct, but closely related, types of games that represent different hybrids in our proof of security. The material in this section is mostly a conceptualization of prior work, and forms the starting point for the technical contributions presented in later sections.</p>

    <p class="text-gray-300">The first type of games that we consider are oracle games, which correspond to when an adversary "in the real world" is granted access to a random oracle and must produce a certain output in order to win. The second type of games are simulated oracle games, which differ in that the adversary is executed by a probabilistic process that efficiently simulates the random oracle (without actually sampling a random function). The third type of games are database games, which differ in that we only consider properties of the query-answer pairs recorded in the simulation.</p>

    <p class="text-gray-300">We shall see that the value (i.e., the maximum winning probability) across all these games are closely related. In particular, in order to bound the value of an oracle game it suffices to bound the value of the corresponding database game. For this reason in Section 5 we shall focus our attention on developing new techniques to bound the values of database games.</p>

    <p class="text-gray-300">We now proceed to formalize the foregoing notions. We find it helpful to structure our exposition by first discussing the special case of classical adversaries (in Section 4.1), and then discussing the general case of quantum adversaries (Section 4.2). In either case, we will derive each type of game from a base game that represents a target set of "winning outputs".</p>

    <p class="text-gray-300">Definition 4.1. Let  <span class="math">A, B, C</span>  be finite sets,  <span class="math">k \\in \\mathbb{N}</span> . A base game is a set of tuples  <span class="math">G \\subseteq A^k \\times B^k \\times C</span> .</p>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{C}_t</span>  to denote the set of all classical algorithms that make at most  <span class="math">t</span>  queries to an oracle, and  <span class="math">\\mathcal{C}_t^*</span>  to denote the set of all quantum algorithms that make at most  <span class="math">t</span>  queries to an oracle.</p>

    <p class="text-gray-300">We associate to a base game  <span class="math">G</span>  three classical notions: the classical oracle game  <span class="math">G_{\\mathsf{O}}</span> , the classical simulated oracle game  <span class="math">G_{\\mathsf{S}}</span> , and the classical database game  <span class="math">G_{\\mathsf{D}}</span> . These notions are distinct, but they are also closely related as shown in Lemma 4.5 below.</p>

    <p class="text-gray-300">A classical algorithm  <span class="math">\\mathcal{A}</span>  plays the classical oracle game of  <span class="math">G</span>  as follows:  <span class="math">\\mathcal{A}</span>  has access to a random oracle  <span class="math">h\\colon \\{0,1\\}^m\\to \\{0,1\\}^n</span>  and wins if it outputs  <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span>  with  <span class="math">h(a_{i}) = b_{i}</span>  for all  <span class="math">i\\in [k]</span> .</p>

    <p class="text-gray-300">Definition 4.2. The value of the classical oracle game of  <span class="math">G</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">\\omega_ {\\mathsf {O}} (G, t) := \\max  _ {\\mathcal {A} \\in \\mathcal {C} _ {t}} \\Pr [ \\mathcal {A} \\text{ wins } G _ {\\mathsf {O}} ] = \\max  _ {\\mathcal {A} \\in \\mathcal {C} _ {t}} \\Pr \\left[ \\begin{array}{c c} (\\mathbf {a}, \\mathbf {b}, c) \\in G \\text{ and} &amp;amp; h \\leftarrow \\mathcal {U} (m, n) \\\\ \\forall i \\in [ k ], h (a _ {i}) = b _ {i} &amp;amp; (\\mathbf {a}, \\mathbf {b}, c) \\leftarrow \\mathcal {A} ^ {h} \\end{array} \\right] .</span></div>

    <p class="text-gray-300">Next, we discuss the classical simulated oracle game of  <span class="math">G</span> , which is defined via a simulator. We denote by  <span class="math">\\mathsf{Sim}(\\mathcal{A})</span>  the probabilistic process that executes the classical algorithm  <span class="math">\\mathcal{A}</span>  while simulating a random oracle with random consistent answers, and then outputs  <span class="math">((\\mathbf{a},\\mathbf{b},c),D)</span>  where  <span class="math">(\\mathbf{a},\\mathbf{b},c)</span>  is the output of  <span class="math">\\mathcal{A}</span>  and  <span class="math">D</span>  is the database containing all the simulated query-answer pairs. The classical algorithm  <span class="math">\\mathcal{A}</span>  wins if  <span class="math">((\\mathbf{a},\\mathbf{b},c),D)</span>  is such that  <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span>  and  <span class="math">D(a_{i}) = b_{i}</span>  for all  <span class="math">i\\in [k]</span> .</p>

    <p class="text-gray-300">Definition 4.3. The value of the classical simulated oracle game of  <span class="math">G</span>  is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega_ {\\mathsf {S}} (G, t) := \\max  _ {\\mathcal {A} \\in \\mathcal {C} _ {t}} \\Pr [ \\mathcal {A} \\text{ wins } G _ {\\mathsf {S}} ] = \\max  _ {\\mathcal {A} \\in \\mathcal {C} _ {t}} \\Pr \\left[ \\begin{array}{c} (\\mathbf {a}, \\mathbf {b}, c) \\in G \\text{ and} \\\\ \\forall i \\in [ k ], D (a _ {i}) = b _ {i} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big ((\\mathbf {a}, \\mathbf {b}, c), D \\big) \\leftarrow \\mathsf {S i m} (\\mathcal {A}) \\right] .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">5Initialize an empty database D : \\{0,1\\}^m \\rightharpoonup \\{0,1\\}^n . Whenever A queries the oracle at x \\in \\{0,1\\}^m , if x \\in \\operatorname{supp}(D) then answer D(x) ; else if x \\notin \\operatorname{supp}(D) then answer with a random y \\in \\{0,1\\}^n and update as D := D + [x \\mapsto y] .</p>

    <p class="text-gray-300">Finally, we discuss the classical database game of <span class="math">G</span>. We again simulate the classical algorithm <span class="math">\\mathcal{A}</span> using <span class="math">\\mathsf{Sim}(\\mathcal{A})</span> to obtain <span class="math">((\\mathbf{a},\\mathbf{b},c),D)</span>, but now we discard the tuple <span class="math">(\\mathbf{a},\\mathbf{b},c)</span> and only consider the database <span class="math">D</span>. Concretely, the classical algorithm <span class="math">\\mathcal{A}</span> wins if there exists a tuple <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime},c^{\\prime})</span>, possibly different from <span class="math">(\\mathbf{a},\\mathbf{b},c)</span>, such that <span class="math">(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime},c^{\\prime})\\in G</span> and <span class="math">D(a_{i}^{\\prime})=b_{i}^{\\prime}</span> for all <span class="math">i\\in[k]</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <p class="text-gray-300">The <em>value of the classical database game</em> of <span class="math">G</span> is</p>

    <p class="text-gray-300">\\[ \\omega_{\\mathsf{D}}(G,t):=\\max_{\\mathcal{A}\\in\\mathcal{C}_{t}}\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{D}}]=\\max_{\\mathcal{A}\\in\\mathcal{C}_{t}}\\ \\Pr\\left[\\begin{array}[]{c}\\exists\\,(\\mathbf{a}^{\\prime},\\mathbf{b}^{\\prime},c^{\\prime})\\in G\\text{ s.t.}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall\\,i\\in[k]\\,,\\ D(a_{i}^{\\prime})=b_{i}^{\\prime}\\end{array}\\right.\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\left((\\mathbf{a},\\mathbf{b},c),D\\right)\\leftarrow\\mathsf{Sim}(\\mathcal{A})\\right]\\,\\ . \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following lemma relates the three classical notions introduced above.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 4.5.</h6>

    <p class="text-gray-300">For every classical algorithm <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{O}}]</span> <span class="math">\\leq\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{S}}]+1/2^{n}\\,\\ ,</span> <span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{S}}]</span> <span class="math">\\leq\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{D}}]\\,\\ .</span></p>

    <p class="text-gray-300">In particular, the values of the three types of classical games are related:</p>

    <p class="text-gray-300"><span class="math">\\forall\\,t\\in\\mathbb{N}\\,,\\ \\omega_{\\mathsf{O}}(G,t)</span> <span class="math">\\leq\\omega_{\\mathsf{S}}(G,t)+1/2^{n}</span> <span class="math">\\text{and}\\quad\\omega_{\\mathsf{S}}(G,t)</span> <span class="math">\\leq\\omega_{\\mathsf{D}}(G,t)\\,\\ .</span></p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first compare <span class="math">G_{\\mathsf{O}}</span> and <span class="math">G_{\\mathsf{S}}</span>. Consider the adversary <span class="math">\\mathcal{A}^{\\prime}</span> for <span class="math">G_{\\mathsf{O}}</span> given by running <span class="math">\\mathsf{Sim}(\\mathcal{A})</span> and answering a query to <span class="math">x</span> with <span class="math">y:=h(x)</span>. Let <span class="math">(\\mathbf{a},\\mathbf{b},c)</span> be the output of <span class="math">\\mathcal{A}^{\\prime}</span>, and let <span class="math">i</span> be the first index such that <span class="math">(a_{i},b_{i})\\notin D</span>. Let <span class="math">E</span> be the event that <span class="math">h(a_{i})=b_{i}</span>. Then <span class="math">\\Pr[E]\\leq 1/2^{n}</span>, so <span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{O}}]\\leq\\Pr[\\mathcal{A}^{\\prime}\\text{ wins }G_{\\mathsf{O}}\\wedge\\neg E]+\\Pr[E]</span>. Observe that if <span class="math">\\mathcal{A}^{\\prime}</span> wins <span class="math">G_{\\mathsf{O}}</span> and <span class="math">\\neg E</span> holds, then the simulated <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{S}}</span>. Since the <span class="math">\\mathcal{A}</span> simulated by <span class="math">\\mathcal{A}^{\\prime}</span> is indistinguishable from <span class="math">\\mathsf{Sim}(\\mathcal{A})</span>, it follows that <span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{O}}]\\leq\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{S}}]+1/2^{n}</span>.</p>

    <p class="text-gray-300">We also note that <span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{S}}]\\leq\\Pr[\\mathcal{A}^{\\prime}\\text{ wins }G_{\\mathsf{O}}]=\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{O}}]</span>, which shows additionally that the first inequality is tight up to the additive term of <span class="math">1/2^{n}</span>.</p>

    <p class="text-gray-300">We now compare <span class="math">G_{\\mathsf{S}}</span> and <span class="math">G_{\\mathsf{D}}</span>. Let <span class="math">\\mathcal{A}</span> be an adversary, and let <span class="math">((\\mathbf{a},\\mathbf{b},c),D)</span> be the output of <span class="math">\\mathsf{Sim}(\\mathcal{A})</span>. Observe that if <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{S}}</span> then <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{D}}</span> trivially, by taking <span class="math">\\mathbf{a}^{\\prime}=\\mathbf{a}</span>, <span class="math">\\mathbf{b}^{\\prime}=\\mathbf{b}</span>, and <span class="math">c^{\\prime}=c</span>. Hence, <span class="math">\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{S}}]\\leq\\Pr[\\mathcal{A}\\text{ wins }G_{\\mathsf{D}}]</span>.</p>

    <p class="text-gray-300">We additionally note that <span class="math">\\omega_{\\mathsf{S}}(G,t)=\\omega_{\\mathsf{D}}(G,t)</span>. This is because if <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{D}}</span>, then <span class="math">\\mathcal{A}^{\\prime}</span> (the adversary that runs <span class="math">\\mathsf{Sim}(\\mathcal{A})</span> and uses <span class="math">h</span> to answer oracle queries) can search over all satisfying tuples in <span class="math">G</span> and see if any of them win <span class="math">G_{\\mathsf{S}}</span>. Since the database stored by <span class="math">\\mathcal{A}^{\\prime}</span> is equal to the database stored by <span class="math">\\mathsf{Sim}(\\mathcal{A}^{\\prime})</span>, it follows that <span class="math">\\mathcal{A}^{\\prime}</span> wins <span class="math">G_{\\mathsf{S}}</span> whenever <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{D}}</span>, and hence <span class="math">\\omega_{\\mathsf{S}}(G,t)=\\omega_{\\mathsf{D}}(G,t)</span>. ∎</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">4.2 The case of quantum adversaries</h3>

    <p class="text-gray-300">This section extends the notions and statements of Section 4.1 to the quantum setting, and provides a conceptualization of results of Zhandry <em>[x20]</em> that is useful in this paper. Analogously to the classical setting, we associate to a base game <span class="math">G</span> three notions: its quantum oracle game <span class="math">G_{\\mathsf{O}}^{<em>}</span>, its quantum simulated oracle game <span class="math">G_{\\mathsf{S}}^{</em>}</span>, and its quantum database game <span class="math">G_{\\mathsf{D}}^{<em>}</span>. Similarly to before, these notions are distinct, but they are also closely related as shown in Lemma 4.9 below. Unlike before, however, the notions and statements are </em>not* elementary because executing a quantum algorithm while recording its queries and answers to the oracle into a database <span class="math">D</span> is not a simple problem.</p>

    <p class="text-gray-300">A quantum algorithm <span class="math">A</span> plays the <em>quantum oracle game</em> of <span class="math">G</span> as follows: <span class="math">A</span> has access to a random oracle <span class="math">h\\colon\\{0,1\\}^{m}\\to\\{0,1\\}^{n}</span> and wins if it outputs <span class="math">(\\mathbf{a},\\mathbf{b},c)\\in G</span> with <span class="math">h(a_{i})=b_{i}</span> for all <span class="math">i\\in[k]</span>.</p>

    <p class="text-gray-300">Definition 4.6. The value of the quantum oracle game of <span class="math">G</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\omega_{\\mathsf{O}}^{*}(G, t) := \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{*}} \\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{O}}^{*}] = \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{*}} \\Pr\\left[ \\begin{array}{c c} (\\mathbf{a}, \\mathbf{b}, c) \\in G \\text{ and} &amp;amp; h \\leftarrow \\mathcal{U}(m, n) \\\\ \\forall i \\in [k], \\, h(a_{i}) = b_{i} &amp;amp; (\\mathbf{a}, \\mathbf{b}, c) \\leftarrow \\mathcal{A}^{h} \\end{array} \\right]  .</span></div>

    <p class="text-gray-300">Next, we discuss the quantum simulated oracle game of <span class="math">G</span>. One can simulate the interaction of a quantum algorithm <span class="math">\\mathcal{A}</span> with a random oracle via the compressed phase oracle <span class="math">\\mathcal{O}</span> of Zhandry [Zha19]. (See Section 3.6 for the definition of <span class="math">\\mathcal{O}</span>.) We denote by <span class="math">\\operatorname{Sim}^*(\\mathcal{A})</span> the probabilistic process that executes <span class="math">\\mathcal{A}</span> while answering its queries with <span class="math">\\mathcal{O}</span>, and then outputs <span class="math">((\\mathbf{a}, \\mathbf{b}, c), D)</span> where <span class="math">(\\mathbf{a}, \\mathbf{b}, c)</span> is the output of <span class="math">\\mathcal{A}</span> (obtained by measuring its output register in the computational basis) and <span class="math">D</span> is the result of measuring the database registers in the computational basis after <span class="math">\\mathcal{A}</span> has halted. The quantum algorithm <span class="math">\\mathcal{A}</span> wins if <span class="math">((\\mathbf{a}, \\mathbf{b}, c), D)</span> is such that <span class="math">(\\mathbf{a}, \\mathbf{b}, c) \\in G</span> and <span class="math">D(a_{i}) = b_{i}</span> for all <span class="math">i \\in [k]</span>.</p>

    <p class="text-gray-300">Definition 4.7. The value of the quantum simulated oracle game of <span class="math">G</span> is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega_{\\mathsf{S}}^{<em>}(G, t) := \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{</em>}} \\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{S}}^{<em>}] = \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{</em>}} \\Pr\\left[ \\begin{array}{c c} (\\mathbf{a}, \\mathbf{b}, c) \\in G \\text{ and} \\\\ \\forall i \\in [k], \\, D(a_{i}) = b_{i} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big((\\mathbf{a}, \\mathbf{b}, c), D \\big) \\leftarrow \\operatorname{Sim}^{*}(\\mathcal{A}) \\right]  .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Finally, we discuss the quantum database game of <span class="math">G</span>. We again simulate the quantum algorithm <span class="math">\\mathcal{A}</span> using <span class="math">\\operatorname{Sim}^*(\\mathcal{A})</span> to obtain <span class="math">((\\mathbf{a}, \\mathbf{b}, c), D)</span> but now we discard the tuple <span class="math">(\\mathbf{a}, \\mathbf{b}, c)</span> and only consider the database <span class="math">D</span>. Concretely, the quantum algorithm <span class="math">\\mathcal{A}</span> wins if there exists a tuple <span class="math">(\\mathbf{a}&#x27;, \\mathbf{b}&#x27;, c) \\in G</span> such that <span class="math">D(a_{i}&#x27;) = b_{i}&#x27;</span> for all <span class="math">i \\in [k]</span>.</p>

    <p class="text-gray-300">Definition 4.8. The value of the quantum database game of <span class="math">G</span> is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega_{\\mathsf{D}}^{<em>}(G, t) := \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{</em>}} \\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{D}}^{<em>}] = \\max_{\\mathcal{A} \\in \\mathcal{C}_{t}^{</em>}} \\Pr\\left[ \\begin{array}{c c} \\exists (\\mathbf{a}', \\mathbf{b}', c') \\in G \\text{ s.t.} \\\\ \\forall i \\in [k], \\, D(a_{i}') = b_{i}' \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big((\\mathbf{a}, \\mathbf{b}, c), D \\big) \\leftarrow \\operatorname{Sim}^{*}(\\mathcal{A}) \\right]  .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The following lemma relates the three quantum notions introduced above.</p>

    <p class="text-gray-300">Lemma 4.9 ([Zha19]). For every quantum algorithm <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\sqrt{\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{O}}^{*}]} \\leq \\sqrt{\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{S}}^{*}]} + \\sqrt{k / 2^{n}} \\, ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{S}}^{*}] \\leq \\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{D}}^{*}] \\, .</span></div>

    <p class="text-gray-300">In particular, the values of the three types of quantum games are related:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall t \\in \\mathbb{N}, \\, \\sqrt{\\omega_{\\mathsf{O}}^{*}(G, t)} \\leq \\sqrt{\\omega_{\\mathsf{S}}^{*}(G, t)} + \\sqrt{k / 2^{n}} \\, .</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{and} \\quad \\omega_{\\mathsf{S}}^{*}(G, t) \\leq \\omega_{\\mathsf{D}}^{*}(G, t) \\, .</span></div>

    <p class="text-gray-300">Proof. We first compare <span class="math">G_{\\mathsf{O}}^{<em>}</span> and <span class="math">G_{\\mathsf{S}}^{</em>}</span>. The fact that <span class="math">\\sqrt{\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{O}}^{<em>}]} \\leq \\sqrt{\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{S}}^{</em>}]} + \\sqrt{k / 2^{n}}</span> is a restatement of [Zha19, Lemma 5].</p>

    <p class="text-gray-300">We now compare <span class="math">G_{\\mathsf{S}}^{<em>}</span> and <span class="math">G_{\\mathsf{D}}^{</em>}</span>. As in the classical setting, if <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{S}}^{<em>}</span> then <span class="math">\\mathcal{A}</span> wins <span class="math">G_{\\mathsf{D}}^{</em>}</span> trivially, so <span class="math">\\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{S}}^{<em>}] \\leq \\Pr[\\mathcal{A} \\text{ wins } G_{\\mathsf{D}}^{</em>}]</span>. Note that in the classical case the value of the simulated oracle and database games are the same by a simple simulation argument, but in the quantum setting the simulation argument does not go through due to the no-cloning theorem.</p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">5 A lifting lemma for database games</p>

    <p class="text-gray-300">In this section we show how to bound the value of a (classical or quantum) database game via the instability of the game, a purely classical quantity that we introduce in this paper. As we will see shortly, it is straightforward to argue that for any base game <span class="math">G</span> (Definition 4.1), the value <span class="math">\\omega_{\\mathsf{D}}(G,t)</span> is at most <span class="math">t</span> times the instability of <span class="math">G</span>. The goal of this section is to to prove that the (quantum) value <span class="math">\\omega_{\\mathsf{D}}^{<em>}(G,t)</span> is at most <span class="math">t^{2}</span> times the instability of <span class="math">G</span>. In particular, we enable lifting a bound on the (classical) instability of <span class="math">G</span> to a bound on the (quantum) value <span class="math">\\omega_{\\mathsf{D}}^{</em>}(G,t)</span>. Combining the lifting lemma with the fact that oracle games can be generically reduced to database games (as described in Section 4.2), we are able to establish the post-quantum security of the Micali construction solely by analyzing classical properties of it.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">5.1 Database properties and the basic lifting lemma</h3>

    <p class="text-gray-300">A database property is a more general notion of a database game.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">A database property <span class="math">\\mathcal{P}</span> is a set of databases <span class="math">D\\colon X\\rightharpoonup Y</span>. The negation of <span class="math">\\mathcal{P}</span>, denoted <span class="math">\\bar{\\mathcal{P}}</span>, is the set <span class="math">(X\\rightharpoonup Y)\\setminus\\mathcal{P}</span>.</p>

    <p class="text-gray-300">Given a base game, we define a corresponding database property as follows.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 5.2.</h6>

    <p class="text-gray-300">The database property of a base game <span class="math">G\\subseteq A^{k}\\times B^{k}\\times C</span> is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{G}:=\\left\\{D:\\exists\\,(\\mathbf{a},\\mathbf{b},c)\\in G\\text{ with }D(a_{i})=b_{i}\\ \\forall\\,i\\in[k]\\right\\}\\ .</span></p>

    <p class="text-gray-300">For a base game <span class="math">G</span>, the database property <span class="math">\\mathcal{P}_{G}</span> is closely related to the database game of <span class="math">G</span>. This is because winning the database game is equivalent to the database outputted by <span class="math">\\mathsf{Sim}^{*}(\\mathcal{A})</span> being in <span class="math">\\mathcal{P}_{G}</span>. In particular, the following proposition holds.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proposition 5.3.</h6>

    <p class="text-gray-300">For every base game <span class="math">G\\subseteq A^{k}\\times B^{k}\\times C</span> and quantum algorithm <span class="math">\\mathcal{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\mathcal{A}\\text{ wins }G^{*}_{\\mathsf{D}}]=\\Pr\\left[D\\in\\mathcal{P}_{G}\\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\big{(}(\\mathbf{a},\\mathbf{b},c),D\\big{)}\\leftarrow\\mathsf{Sim}^{*}(\\mathcal{A})\\right]\\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define the flip probability of a pair of database properties.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 5.4.</h6>

    <p class="text-gray-300">The flip probability <span class="math">\\mathrm{flip}(\\mathcal{P}\\to\\mathcal{Q},t)</span> from property <span class="math">\\mathcal{P}</span> to property <span class="math">\\mathcal{Q}</span> is the quantity</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{flip}(\\mathcal{P}\\to\\mathcal{Q},t):=\\max_{D\\colon\\{0,1\\}^{m}\\rightharpoonup\\{0,1\\}^{n}\\atop</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><t\\,,\\,D\\in\\mathcal{P}}\\max_{x\\notin\\mathrm{supp}(D)}\\Pr_{y}\\left[D+[x\\mapsto y]\\in\\mathcal{Q}\\right]\\ ,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and <span class="math">\\mathrm{flip}(\\emptyset\\to\\mathcal{Q},t):=0</span>.</p>

    <p class="text-gray-300">Intuitively, this is the maximum probability over all databases <span class="math">D\\in\\mathcal{P}</span> with less than <span class="math">t</span> entries that making an additional query puts <span class="math">D\\in\\mathcal{Q}</span>. The following properties can be obtained easily from the above definition.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proposition 5.5 (Properties of the flip probability).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P},\\mathcal{P}^{\\prime},\\mathcal{Q},\\mathcal{Q}^{\\prime}</span> be database properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{P}\\subseteq\\mathcal{P}^{\\prime}</span> and <span class="math">\\mathcal{Q}\\subseteq\\mathcal{Q}^{\\prime}</span> then <span class="math">\\mathrm{flip}(\\mathcal{P}\\to\\mathcal{Q})\\leq\\mathrm{flip}(\\mathcal{P}^{\\prime}\\to\\mathcal{Q}^{\\prime})</span>.</li>

      <li><span class="math">\\mathrm{flip}(\\mathcal{P}\\cup\\mathcal{P}^{\\prime}\\to\\mathcal{Q})=\\max\\big{(}\\mathrm{flip}(\\mathcal{P}\\to\\mathcal{Q}),\\mathrm{flip}(\\mathcal{P}^{\\prime}\\to\\mathcal{Q})\\big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">(iii) <span class="math">\\mathrm{flip}(\\mathcal{P}\\to \\mathcal{Q}\\cup \\mathcal{Q}^{\\prime})\\leq \\mathrm{flip}(\\mathcal{P}\\to \\mathcal{Q}) + \\mathrm{flip}(\\mathcal{P}\\to \\mathcal{Q}^{\\prime}).</span></p>

    <p class="text-gray-300">The instability of a database property is the following classical quantity.</p>

    <p class="text-gray-300"><strong>Definition 5.6.</strong> The instability <span class="math">\\mathbf{I}(\\mathcal{P},t)</span> of a database property <span class="math">\\mathcal{P}</span> with query bound <span class="math">t</span> is the maximum probability that, for any database <span class="math">D</span> containing less than <span class="math">t</span> queries, making one additional (classical) query changes whether or not <span class="math">D</span> has the property <span class="math">\\mathcal{P}</span>. Formally, we let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {I} (\\mathcal {P}, t) := \\max  \\{\\mathrm {f l i p} (\\bar {\\mathcal {P}} \\to \\mathcal {P}, t), \\mathrm {f l i p} (\\mathcal {P} \\to \\bar {\\mathcal {P}}, t) \\}.</span></div>

    <p class="text-gray-300">Note that instability is symmetric: <span class="math">\\mathbf{I}(\\mathcal{P},t) = \\mathbf{I}(\\bar{\\mathcal{P}},t)</span>. There is a direct argument that shows that <span class="math">\\omega_{\\mathsf{D}}(G,t)</span> is bounded by <span class="math">t\\mathbf{I}(\\mathcal{P}_G,t)</span>. Similarly, our basic lifting lemma shows that <span class="math">\\omega_{\\mathsf{D}}^{*}(G,t)</span> is bounded by the instability of the database property <span class="math">\\mathcal{P}_G</span>. Thus, it lifts a classical notion to prove a bound on the quantum value of a database game.</p>

    <p class="text-gray-300"><strong>Lemma 5.7 (Basic lifting lemma).</strong> For any base game <span class="math">G</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\omega_ {\\mathsf {D}} ^ {*} (G, t) \\leq t ^ {2} \\cdot 6 \\mathbf {I} (\\mathcal {P} _ {G}, t).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Before we proceed to the proof of Lemma 5.7, we first introduce some quantum notation. Recall that we let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^*(\\mathcal{A})\\rangle<span class="math"> denote the final quantum state of the simulated adversary. Using the definition of measurement, we can express the probability that the final measured database </span>D<span class="math"> is in a database property </span>\\mathcal{P}<span class="math"> in terms of the state </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^*(\\mathcal{A})\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proposition 5.8.</strong> For every database property <span class="math">\\mathcal{P}</span> and quantum adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ D \\in \\mathcal {P} \\mid ((\\mathbf {a}, \\mathbf {b}, c), D) \\leftarrow \\operatorname {S i m} ^ {*} (\\mathcal {A}) \\right] = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {S i m} ^ {*} (\\mathcal {A}) \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $P \\coloneqq I \\otimes \\sum_{D \\in \\mathcal{P}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle \\langle D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the projector that maps all basis states of the form </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z\\rangle \\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> to 0 if </span>D \\notin \\mathcal{P}$, and is otherwise the identity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We learn that in order to bound <span class="math">\\omega_{\\mathsf{D}}^{*}(G,t)</span> it suffices to bound $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Sim}^* (\\mathcal{A})\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for every </span>\\mathcal{A}\\in \\mathcal{C}_t^*$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, define $P_{t} \\coloneqq I \\otimes \\sum_{D:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle \\langle D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to be the projector that maps all basis states of the form </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> to 0 if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; t$, and is otherwise the identity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof of Lemma 5.7 follows from two lemmas. The first lemma shows that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Sim}^* (\\mathcal{A})\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is bounded by </span>t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(P_t\\mathcal{O}P_t)\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Intuitively, this is because if </span>P<span class="math"> and </span>P_{t}\\mathcal{O}P_{t}<span class="math"> almost commute (i.e., </span>P<span class="math"> and </span>\\mathcal{O}<span class="math"> almost commute when acting on databases with at most </span>t<span class="math"> entries) then each oracle query cannot change the probability that the database is in </span>\\mathcal{P}<span class="math"> by too much. The second lemma shows that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(P_t\\mathcal{O}P_t)\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2<span class="math"> is bounded by </span>\\mathbf{I}(\\mathcal{P},t)$. Combining the two lemmas with Proposition 5.8 completes the proof of Lemma 5.7.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 5.9.</strong> Let <span class="math">\\mathcal{P}</span> be a database property with <span class="math">\\emptyset \\notin \\mathcal{P}</span>. For every <span class="math">\\mathcal{A} \\in \\mathcal{C}_t^*</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {S i m} ^ {*} (\\mathcal {A}) \\right\\rangle \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t \\cdot \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\left(P _ {t} \\mathcal {O} P _ {t}\\right) \\bar {P} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Lemma 5.10.</strong> For any database property <span class="math">\\mathcal{P}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\left(P _ {t} \\mathcal {O} P _ {t}\\right) \\bar {P} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\leq 6 \\mathbf {I} (\\mathcal {P}, t).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6Let <span class="math">\\mathcal{A}</span> be a classical adversary, and let <span class="math">\\mathcal{A}_i</span> be the adversary obtained by stopping <span class="math">\\mathcal{A}</span> immediately before its <span class="math">i</span>-th query. Then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[\\mathcal{A}_{i+1} \\text{ wins } G_{\\mathsf{D}}] - \\operatorname</em>{Pr}[\\mathcal{A}_i \\text{ wins } G_{\\mathsf{D}}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathbf{I}(\\mathcal{P}, t)<span class="math"> holds for each </span>i \\in [t]<span class="math"> by definition of instability, and </span>\\operatorname<em>{Pr}[\\mathcal{A}_1 \\text{ wins } G_{\\mathsf{D}}] = 0<span class="math"> since </span>\\emptyset \\notin \\mathcal{P}_G<span class="math">. Therefore, </span>\\operatorname</em>{Pr}[\\mathcal{A} \\text{ wins } G_{\\mathsf{D}}] \\leq t\\mathbf{I}(\\mathcal{P}, t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">22</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemmas 5.9 and 5.10 strengthen the proof sketch outlined in Section 2.5. This is because for any operator <span class="math">A</span> and projector <span class="math">P</span>, <span class="math">[P,A]=PA-AP=(PAP+PA\\bar{P})-(PAP+\\bar{P}AP)=PA\\bar{P}-\\bar{P}AP</span>, and so $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P,A]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PA\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{P}AP\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}<span class="math">. Hence, Lemma 5.9 implies that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A})\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P,P_{t}\\mathcal{O}P_{t}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and Lemma 5.10 implies that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[P,P_{t}\\mathcal{O}P_{t}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq 12\\mathbf{I}(\\mathcal{P},t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now prove Lemma 5.9, and postpone the proof of Lemma 5.10 to Section 5.3.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof of Lemma 5.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that the quantum algorithm <span class="math">\\mathcal{A}</span> is described by some unitaries <span class="math">(A_{1},\\ldots,A_{t})</span> and initial state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0}\\rangle<span class="math">. We can thus describe the quantum algorithm </span>\\mathsf{Sim}^{*}(\\mathcal{A})<span class="math"> via the cumulative unitary </span>U:=A_{t}\\mathcal{O}A_{t-1}\\cdots\\mathcal{O}A_{1}\\mathcal{O}<span class="math"> acting on the initial state </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle<span class="math"> where </span>\\emptyset<span class="math"> denotes the empty database. (We abuse notation and implicitly extend </span>A_{i}<span class="math"> to act as the identity on the database register.) The final state is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A})\\rangle\\ :=U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">U^{\\prime}:=A_{t}(P_{t}\\mathcal{O}P_{t})A_{t-1}\\cdots(P_{t}\\mathcal{O}P_{t})A_{1}(P_{t}\\mathcal{O}P_{t})</span>. We have that $U^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle=U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle<span class="math">, as applying each </span>P_{t}<span class="math"> has no effect, since the database can only have at most </span>t<span class="math"> queries when </span>P_{t}$ is applied.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any operators <span class="math">C_{1},\\ldots,C_{t}</span> and projector <span class="math">P</span>, we have that</p>

    <p class="text-gray-300"><span class="math">C_{t}\\cdots C_{1}=\\bar{P}C_{t}\\bar{P}C_{t-1}\\bar{P}\\cdots C_{1}\\bar{P}+\\sum_{i=0}^{t}(C_{t}\\cdots C_{i+1})\\cdot P\\cdot(C_{i}\\bar{P}\\cdots C_{1}\\bar{P})\\enspace.</span> (1)</p>

    <p class="text-gray-300">To see this, we observe that</p>

    <p class="text-gray-300"><span class="math">C_{t}\\cdots C_{1}=(C_{t}\\cdots C_{2})(C_{1}\\bar{P})+(C_{t}\\cdots C_{1})\\cdot P\\enspace,</span></p>

    <p class="text-gray-300">which implies Eq. (1) by induction.</p>

    <p class="text-gray-300">Let <span class="math">C_{i}=A_{i}(P_{t}\\mathcal{O}P_{t})</span>. Then we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A})\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PU^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Big{(}P\\bar{P}C_{t}\\bar{P}C_{t-1}\\bar{P}\\cdots C_{1}\\bar{P}+\\sum_{i=0}^{t}P(C_{t}\\cdots C_{i+1})\\cdot P\\cdot(C_{i}\\bar{P}\\cdots C_{1}\\bar{P})\\Big{)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0},\\emptyset\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq\\</td>

            <td class="px-3 py-2 border-b border-gray-700">P(C_{t}\\cdots C_{1})\\cdot P</td>

            <td class="px-3 py-2 border-b border-gray-700">\\phi_{0},\\emptyset\\rangle\\</td>

            <td class="px-3 py-2 border-b border-gray-700">+\\sum_{i=1}^{t}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">P(C_{t}\\cdots C_{i+1})\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot\\</td>

            <td class="px-3 py-2 border-b border-gray-700">P\\cdot(C_{i}\\bar{P}\\cdots C_{1}\\bar{P})</td>

            <td class="px-3 py-2 border-b border-gray-700">\\phi_{0},\\emptyset\\rangle\\</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq 0+\\sum_{i=1}^{t}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">PC_{i}\\bar{P}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot\\</td>

            <td class="px-3 py-2 border-b border-gray-700">(C_{i}\\bar{P}\\cdots C_{1}\\bar{P})</td>

            <td class="px-3 py-2 border-b border-gray-700">\\phi_{0},\\emptyset\\rangle\\</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq\\sum_{i=1}^{t}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">PA_{i}(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\enspace,$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we use the fact that the operator norm of a product of unitaries/projectors is at most <span class="math">1</span>, and that <span class="math">\\emptyset\\notin\\mathcal{P}</span>. Since <span class="math">P</span> and <span class="math">A_{i}</span> commute for every <span class="math">i</span>, we get that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PA_{i}(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i}P(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A})\\rangle\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(P_{t}\\mathcal{O}P_{t})\\bar{P}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">5.2 Conditional instability and the lifting lemma</h3>

    <p class="text-gray-300">Lemma 5.7 is not quite sufficient to analyze the database game that corresponds to the Micali construction. In fact, the instability of this game is high because we take a maximum over all</p>

    <p class="text-gray-300">bounded databases, including those which contain collisions. If we were to only take the maximum over databases that do not contain collisions, then the instability would be low. Moreover, the instability of the “no collision” property is itself low.</p>

    <p class="text-gray-300">In this section, we strengthen the results of the previous section by introducing the notion of <em>conditional</em> instability, which allows us to analyze the value <span class="math">\\omega_{\\mathbf{D}}^{*}(G,t)</span> by splitting its database property <span class="math">\\mathcal{P}_{G}</span> into subproperties and analyzing the subproperties separately, analogous to conditioning in probability. In particular, we can then analyze the Micali game by analyzing the no collision property and the instability of the Micali database property conditioned on the no collision property.</p>

    <p class="text-gray-300">For the entirety of this section we will let <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{Q}</span> be database properties, and we will analyze quantities about <span class="math">\\mathcal{P}</span> conditioned on <span class="math">\\mathcal{Q}</span>. These results strengthen the results of Section 5.1, as the previous results can be recovered by setting <span class="math">\\mathcal{Q}</span> to be the database property containing all databases.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 5.11.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{Q}</span> be two database properties, and let <span class="math">t</span> be a query bound. We define</p>

    <p class="text-gray-300"><span class="math">\\mathrm{flip}(\\mathcal{P}\\mid\\mathcal{Q},t):=\\mathrm{flip}(\\bar{\\mathcal{P}}\\cap\\mathcal{Q}\\to\\mathcal{P}\\cap\\mathcal{Q},t)\\enspace.</span></p>

    <p class="text-gray-300">The conditional instability <span class="math">\\mathbf{I}(\\mathcal{P}\\mid\\mathcal{Q},t)</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{I}(\\mathcal{P}\\mid\\mathcal{Q},t):=\\max\\{\\mathrm{flip}(\\mathcal{P}\\mid\\mathcal{Q},t),\\ \\mathrm{flip}(\\bar{\\mathcal{P}}\\mid\\mathcal{Q},t)\\}\\enspace.</span></p>

    <p class="text-gray-300">Before we state the lifting lemma, we observe the following properties of instability.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proposition 5.12.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{Q}</span> be two database properties. Then</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{I}(\\mathcal{P},t)</span> and <span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)</span> are incomparable.</li>

      <li><span class="math">\\mathrm{flip}(\\mathcal{P}\\mid\\mathcal{Q},t)\\leq\\mathrm{flip}(\\bar{\\mathcal{P}}\\to\\mathcal{P},t)</span>, and therefore <span class="math">\\mathbf{I}(\\mathcal{P}\\mid\\mathcal{Q},t)\\leq\\mathbf{I}(\\mathcal{P},t)</span>.</li>

      <li><span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)\\leq\\mathbf{I}(\\mathcal{P}\\mid\\bar{\\mathcal{Q}},t)+\\mathbf{I}(\\mathcal{Q},t)</span>.</li>

    </ol>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To show Item 1, we give database properties <span class="math">\\mathcal{P},\\mathcal{Q}</span> such that <span class="math">\\mathbf{I}(\\mathcal{P},t)&gt;\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)</span> and properties <span class="math">\\mathcal{P}^{\\prime},\\mathcal{Q}^{\\prime}</span> such that <span class="math">\\mathbf{I}(\\mathcal{P}^{\\prime},t)&lt;\\mathbf{I}(\\mathcal{P}^{\\prime}\\cup\\mathcal{Q}^{\\prime},t)</span>. Let <span class="math">\\mathcal{P}</span> be the property that <span class="math">D\\neq\\emptyset</span>. Then clearly <span class="math">\\mathbf{I}(\\mathcal{P},t)\\geq\\mathrm{flip}(\\bar{\\mathcal{P}}\\to\\mathcal{P},t)=1</span>. Let <span class="math">\\mathcal{Q}</span> be the property that <span class="math">D=\\emptyset</span>. Now <span class="math">\\mathcal{P}\\cup\\mathcal{Q}</span> is the set of all databases, so <span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q},t)=0</span>.</p>

    <p class="text-gray-300">On the other hand, let <span class="math">\\mathcal{P}^{\\prime}=\\emptyset</span> be the empty property, and let <span class="math">\\mathcal{Q}^{\\prime}</span> be the property that <span class="math">D=\\emptyset</span>. Then, <span class="math">\\mathbf{I}(\\mathcal{P}^{\\prime},t)=0</span>, and <span class="math">\\mathbf{I}(\\mathcal{P}^{\\prime}\\cup\\mathcal{Q}^{\\prime},t)=\\mathbf{I}(\\mathcal{Q}^{\\prime},t)=1</span>.</p>

    <p class="text-gray-300">Item 2 holds since</p>

    <p class="text-gray-300"><span class="math">\\mathrm{flip}(\\mathcal{P}\\mid\\mathcal{Q},t)=\\mathrm{flip}(\\bar{\\mathcal{P}}\\cap\\mathcal{Q}\\to\\mathcal{P}\\cap\\mathcal{Q},t)\\leq\\mathrm{flip}(\\bar{\\mathcal{P}}\\to\\mathcal{P},t)\\enspace.</span></p>

    <p class="text-gray-300">Finally, for Item 3 we observe that</p>

    <p class="text-gray-300"><span class="math">\\mathrm{flip}(\\overline{\\mathcal{P}\\cup\\mathcal{Q}}\\to\\mathcal{P}\\cup\\mathcal{Q},t)</span> <span class="math">=\\mathrm{flip}(\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}}\\to\\mathcal{P}\\cup\\mathcal{Q},t)\\leq\\mathrm{flip}(\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}}\\to\\mathcal{P}\\cap\\bar{\\mathcal{Q}},t)+\\mathrm{flip}(\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}}\\to\\mathcal{Q},t)</span> <span class="math">\\leq\\mathrm{flip}(\\mathcal{P}\\mid\\bar{\\mathcal{Q}},t)+\\mathrm{flip}(\\bar{\\mathcal{Q}}\\to\\mathcal{Q},t)\\enspace.</span></p>

    <p class="text-gray-300">On the other hand,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{flip}(\\mathcal{P}\\cup\\mathcal{Q}\\to\\overline{\\mathcal{P}\\cup\\mathcal{Q}},t)</span> <span class="math">=\\mathrm{flip}(\\mathcal{P}\\cup\\mathcal{Q}\\to\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}},t)=\\max(\\mathrm{flip}(\\mathcal{P}\\cap\\bar{\\mathcal{Q}}\\to\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}},t),\\mathrm{flip}(\\mathcal{Q}\\to\\bar{\\mathcal{P}}\\cap\\bar{\\mathcal{Q}},t))</span> <span class="math">\\leq\\max(\\mathrm{flip}(\\bar{\\mathcal{P}}\\mid\\bar{\\mathcal{Q}},t),\\mathrm{flip}(\\mathcal{Q}\\to\\bar{\\mathcal{Q}},t))\\enspace.</span></p>

    <p class="text-gray-300">Therefore, we get that <span class="math">\\mathbf{I}(\\mathcal{P}\\cup\\mathcal{Q})\\leq\\max\\big{(}\\mathrm{flip}(\\mathcal{P}\\mid\\bar{\\mathcal{Q}},t)+\\mathrm{flip}(\\bar{\\mathcal{Q}}\\to\\mathcal{Q},t),\\mathrm{flip}(\\bar{\\mathcal{P}}\\mid\\bar{\\mathcal{Q}},t),\\mathrm{flip}(\\mathcal{Q}\\to\\bar{\\mathcal{Q}},t)\\big{)}</span>, which is at most <span class="math">\\mathbf{I}(\\mathcal{P}\\mid\\bar{\\mathcal{Q}},t)+\\mathbf{I}(\\mathcal{Q},t)</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We now state the lifting lemma.</p>

    <p class="text-gray-300"><strong>Lemma 5.13</strong> (Lifting lemma). Let <span class="math">G</span> be a base game. Then for any database property <span class="math">\\mathcal{Q}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\omega_{\\mathsf{D}}^{*}(G, t) \\leq t^{2} \\cdot 6 \\left(\\mathbf{I}(\\mathcal{P}_{G} \\mid \\bar{\\mathcal{Q}}, t) + \\mathbf{I}(\\mathcal{Q}, t)\\right).</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{Q}</span> be two database properties. We show that for every <span class="math">\\mathcal{A} \\in \\mathcal{C}_t^*</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A}) \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\leq t^{2} \\cdot 6 \\left(\\mathbf{I}(\\mathcal{P} \\mid \\bar{\\mathcal{Q}}, t) + \\mathbf{I}(\\mathcal{Q}, t)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R} = \\mathcal{P} \\cup \\mathcal{Q}</span>. Then by Lemmas 5.9 and 5.10 we have that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A}) \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{A}) \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\leq t^{2} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[R, P_{t} \\mathcal{O} P_{t}] \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\leq t^{2} \\cdot 6 \\mathbf{I}(\\mathcal{R}, t),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the first inequality holds since <span class="math">\\mathcal{P} \\subseteq \\mathcal{R}</span>. Finally, we use the fact that <span class="math">\\mathbf{I}(\\mathcal{R}, t) = \\mathbf{I}(\\mathcal{P} \\cup \\mathcal{Q}, t) \\leq \\mathbf{I}(\\mathcal{P} \\mid \\bar{\\mathcal{Q}}, t) + \\mathbf{I}(\\mathcal{Q}, t)</span>, which completes the proof.</p>

    <p class="text-gray-300">We dedicate the remainder of the section to proving Lemma 5.10.</p>

    <h2 id="sec-50" class="text-2xl font-bold">5.3 Proof of Lemma 5.10</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi\\rangle<span class="math"> be an arbitrary state in the image of </span>P_{t}\\tilde{P}<span class="math">, i.e. </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi\\rangle = \\sum_{x,u,z,D} \\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle<span class="math">, where the sum is over all </span>D\\colon \\{0,1\\}^{m} \\rightharpoonup \\{0,1\\}^{n}<span class="math"> such that </span>D \\in \\tilde{\\mathcal{P}}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t$. By Lemma 3.2,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{O} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi \\right\\rangle = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{1} \\right\\rangle + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{2} \\right\\rangle + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{3} \\right\\rangle + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{4} \\right\\rangle + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{5} \\right\\rangle,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_1\\rangle<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_2\\rangle<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_3\\rangle<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_4\\rangle<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_5\\rangle$ are the following states:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{1}\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D\\in \\tilde{\\mathcal{P}} \\\\ (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t\\text{ or } u = 0^{n})}}\\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes (-1)^{u\\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle \\ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{2}\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D(x) = \\bot ,D\\in \\tilde{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^{n}}}\\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes \\frac{1}{\\sqrt{2^{n}}}\\sum_{y}(-1)^{u\\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [x\\mapsto y]\\rangle \\ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{3}\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\bot ,D\\in \\tilde{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^{n}}}\\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes (-1)^{u\\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle \\ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{4}\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\bot ,D\\in \\tilde{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^{n}}}\\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes \\frac{(-1)^{u\\cdot D(x)}}{\\sqrt{2^{n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D - x\\rangle \\ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{5}\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\bot ,D\\in \\tilde{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0}}\\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes \\frac{1}{2^{n}}\\sum_{y}\\left(1 - (-1)^{u\\cdot D(x)} - (-1)^{u\\cdot y}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D - x + [x\\mapsto y]\\rangle \\ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_i\\rangle = PP_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_i\\rangle<span class="math"> for </span>i\\in [5]$. We have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <p class="text-gray-300">|\\Psi_1\\rangle = 0, \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_2\\rangle = \\sum_{\\substack{x,u,z,D \\\\ D(x) = \\perp ,D\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t, u\\neq 0^n}} \\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes \\frac{1}{\\sqrt{2^n}} \\sum_{\\substack{y \\\\ D + [x\\mapsto y]\\in \\mathcal{P}}} (-1)^{u\\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [x\\mapsto y]\\rangle , \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|\\Psi_3\\rangle = 0, \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_4\\rangle = \\sum_{\\substack{x,u,z,D \\\\ D(x)\\neq \\perp ,D\\in \\bar{\\mathcal{P}},D - x\\in \\mathcal{P} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^n}} \\alpha_{x,u,z,D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\rangle \\otimes \\frac{(-1)^{u\\cdot D(x)}}{\\sqrt{2^n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D - x\\rangle \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\Psi_5\\rangle = \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\perp ,D\\in \\bar{\\mathcal{P}} \\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t,u\\neq 0^n}}\\alpha_{x,u,z,D}</td>

            <td class="px-3 py-2 border-b border-gray-700">x,u,z\\rangle \\otimes \\frac{1}{2^n}\\sum_{\\substack{y\\\\ D - x + [x\\mapsto y]\\in \\mathcal{P}}}\\left(1 - (-1)^{u\\cdot D(x)} - (-1)^{u\\cdot y}\\right)</td>

            <td class="px-3 py-2 border-b border-gray-700">D - x + [x\\mapsto y]\\rangle \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp \\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\sum_{\\substack{y\\\\ D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}}}\\Bigl{(}\\sum_{\\substack{w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}^{w}\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{1}{2^{n}}\\bigl{(}1 - (-1)^{u\\cdot w} - (-1)^{u\\cdot y}\\bigr{)}\\Bigr{)}</td>

            <td class="px-3 py-2 border-b border-gray-700">x,u,z\\rangle \\otimes \\bigl{</td>

            <td class="px-3 py-2 border-b border-gray-700">}D^{\\prime} + [x\\mapsto y]\\bigr{)} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S_{\\bar{\\mathcal{P}}}(D&#x27;, x) \\coloneqq \\{y \\in \\{0,1\\}^n : D&#x27; + [x \\mapsto y] \\in \\bar{\\mathcal{P}}\\}</span>, and let <span class="math">S_{\\mathcal{P}}(D&#x27;, x) \\coloneqq \\{y \\in \\{0,1\\}^n : D&#x27; + [x \\mapsto y] \\in \\mathcal{P}\\}</span>. Observe that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_4\\rangle<span class="math"> is orthogonal to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_2\\rangle<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_5\\rangle<span class="math">, as every database </span>D<span class="math"> with nonzero amplitude in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_4\\rangle<span class="math"> has </span>D(x) = \\perp$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{1}:= \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\perp ,D\\in \\bar{\\mathcal{P}},D - x\\in \\mathcal{P}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{2}:= \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t - 1,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{3}:= \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t - 1,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{4}:= \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\perp ,D\\in \\bar{\\mathcal{P}},D - x\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that by normalization, we have that <span class="math">s_1 + s_2 + s_3 + s_4 \\leq 1</span>.</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">By Cauchy-Schwarz, we have that</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_4\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\mathcal{P}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t - 1,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\substack{w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{(-1)^{u\\cdot w}}{\\sqrt{2^{n}}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\operatorname {flip}(\\mathcal{P}\\to \\bar{\\mathcal{P}},t)\\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{\\substack{w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\operatorname {flip}(\\mathcal{P}\\to \\bar{\\mathcal{P}},t)\\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\perp ,D\\in \\bar{\\mathcal{P}},D - x\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t,u\\neq 0^{n}}}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\operatorname {flip} (\\mathcal {P} \\rightarrow \\bar {\\mathcal {P}}, t) \\cdot s _ {1}. \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\beta_{w,y} = 1 - (-1)^{u\\cdot w} - (-1)^{u\\cdot y}</span> . Observe that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_2\\rangle +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_5\\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_1\\rangle +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_2\\rangle +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_3\\rangle<span class="math"> , where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_1\\rangle<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_2\\rangle<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_3\\rangle$  are the following orthogonal states:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{1}\\rangle = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t - 1,u\\neq 0^{n}}}\\alpha_{x,u,z,D^{\\prime}}\\frac{1}{\\sqrt{2^{n}}}\\sum_{\\substack{y\\\\ D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}}}(-1)^{u\\cdot y}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z\\right\\rangle \\otimes \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime} + [x\\mapsto y]\\right\\rangle \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\Xi_{3}\\rangle = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}}  D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\sum_{\\substack{y\\\\ D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}}}\\Big(\\frac{(-1)^{u\\cdot y}\\alpha_{x,u,z,D^{\\prime}}}{\\sqrt{2^{n}}}+\\sum_{\\substack{w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{1}{2^{n}}\\beta_{w,y}\\Big)\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">x,u,z\\right\\rangle \\otimes \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime} + [x\\mapsto y]\\right\\rangle .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We also observe that  $\\sum_{y}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{2^n}\\beta_{w,y}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 = \\frac{3 - 2(-1)^{u\\cdot w}}{2^n} \\leq \\frac{5}{2^n}<span class="math"> , and  </span>\\sum_{w}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{2^n}\\beta_{w,y}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2 = \\frac{3 - 2(-1)^{u\\cdot y}}{2^n} \\leq \\frac{5}{2^n}$ . We have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{1}\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}}  D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t - 1,u\\neq 0^{n}}}\\sum_{\\substack{y\\\\ D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime}}\\frac{1}{\\sqrt{2^{n}}}(-1)^{u\\cdot y}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\perp ,D^{\\prime}\\in \\bar{\\mathcal{P}}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t - 1,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\mathcal{P}}(D^{\\prime},x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{n}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">By Cauchy-Schwarz, we get that</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{2}\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t - 1,u\\neq 0^{n}}}\\sum_{y}\\sum_{D^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{w}\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{1}{2^{n}}\\beta_{w,y}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\sum_{y}\\big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\big)\\Big(\\sum_{w}\\big)\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\substack{x\\mapsto w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">\\frac{1}{2^{n}}\\beta_{w,y}\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\Big(\\sum_{w}\\big)\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\substack{x\\mapsto w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">\\frac{1}{2^{n}}\\beta_{w,y}\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\Big(\\sum_{w}\\big)\\bigg</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\substack{x\\mapsto w\\\\ D^{\\prime} + [x\\mapsto w]\\in \\bar{\\mathcal{P}}}}\\frac{5}{2^{n}} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big)\\frac{5\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">S_{\\bar{\\mathcal{P}}}(\\bar{D^{\\prime}},x)\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">}{2^{n}} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq 5 \\cdot \\operatorname{flip}(\\mathcal{P} \\to \\bar{\\mathcal{P}}, t) \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t - 1,u\\neq 0^{n}}}\\Big(\\sum_{w}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\big</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\Big) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= 5 \\cdot \\operatorname{flip}(\\mathcal{P} \\to \\bar{\\mathcal{P}}, t) \\sum_{\\substack{x,u,z,D\\\\ D(x)\\neq \\bot ,D\\in \\bar{\\mathcal{P}},D - x\\in \\mathcal{P}\\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt; t,u\\neq 0^{n}}}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= 5 \\cdot \\operatorname{flip}(\\mathcal{P} \\to \\bar{\\mathcal{P}}, t) \\cdot s_{1}. \\end{array} $$</p>

    <p class="text-gray-300">Finally, we have that by the (square of the) triangle inequality,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{3}\\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}}\\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t - 1,u\\neq 0^{n}}}\\sum_{y}\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{(-1)^{w}y\\alpha_{x,u,z,D^{\\prime}}}{\\sqrt{2^{n}}} +\\sum_{w}\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{1}{2^{n}}\\beta_{w,y}\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq \\varepsilon + \\varepsilon^{\\prime} + 2 \\sqrt{\\varepsilon \\cdot \\varepsilon^{\\prime}}. \\end{array} $$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   t - 1,u\\neq 0^{n}}}\\sum_{y}l^{\\prime} + [x\\mapsto y]\\in \\mathcal{P}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{(-1)^{u\\cdot y}\\alpha_{x,u,z,D^{\\prime}}}{\\sqrt{2^{n}}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   t - 1,u\\neq 0^{n}}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{x,u,z,D^{\\prime}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\mathcal{P}}(D^{\\prime},x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{n}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon^{\\prime} = \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   t - 1,u\\neq 0^{n}}}\\sum_{y}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{w}\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\frac{1}{2^{n}}\\beta_{w,y}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt;   t - 1,u\\neq 0^{n}}}\\sum_{y}\\left(\\sum_{w}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2}\\right)\\cdot \\frac{5}{2^{n}} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sum_{\\substack{x,u,z,D^{\\prime}\\\\ D^{\\prime}(x) = \\bot ,D^{\\prime}\\in \\bar{\\mathcal{P}} \\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt;   t - 1,u\\neq 0^{n}}}\\frac{5</td>

            <td class="px-3 py-2 border-b border-gray-700">S_{\\mathcal{P}}(D^{\\prime},x)</td>

            <td class="px-3 py-2 border-b border-gray-700">}{2^{n}}\\sum_{w}\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_{x,u,z,D^{\\prime} + [x\\mapsto w]}\\right</td>

            <td class="px-3 py-2 border-b border-gray-700">^{2} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq 5 \\cdot \\operatorname {flip} (\\bar {\\mathcal {P}} \\to \\mathcal {P}, t) \\sum_ {\\substack {x, u, z, D \\\\ D (x) \\neq \\bot , D \\in \\bar {\\mathcal {P}}, D - x \\in \\bar {\\mathcal {P}} \\\\</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">&lt;   t, u \\neq 0 ^ {n}}}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha_ {x, u, z, D ^ {\\prime}}</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {2} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= 5 \\cdot \\operatorname {f l i p} (\\bar {\\mathcal {P}} \\to \\mathcal {P}, t) \\cdot s _ {4}. \\end{array} $$</p>

    <p class="text-gray-300">Hence,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_ {3} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\leq \\operatorname {f l i p} (\\bar {\\mathcal {P}} \\to \\mathcal {P}, t) \\left(s _ {3} + 5 s _ {4} + 2 \\sqrt {5 s _ {3} s _ {4}}\\right) \\leq 6 \\cdot \\operatorname {f l i p} (\\bar {\\mathcal {P}} \\to \\mathcal {P}, t) \\cdot (s _ {3} + s _ {4}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Putting it all together (and recalling that  <span class="math">s_1 + s_2 + s_3 + s_4 \\leq 1</span> ), we get that</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {Q} P _ {t} \\mathcal {O} \\Phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Psi_ {4} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_ {1} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_ {2} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_ {3} \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq \\operatorname {f l i p} (\\mathcal {P} \\rightarrow \\bar {\\mathcal {P}}, t) \\cdot s _ {1} + \\operatorname {f l i p} (\\bar {\\mathcal {P}} \\rightarrow \\mathcal {P}, t) \\cdot s _ {2} + \\operatorname {f l i p} (\\mathcal {P} \\rightarrow \\bar {\\mathcal {P}}, t) \\cdot 5 s _ {1} + \\operatorname {f l i p} (\\bar {\\mathcal {P}} \\rightarrow \\mathcal {P}, t) \\cdot 6 (s _ {3} + s _ {4}) \\\\ \\leq \\mathbf {I} (\\mathcal {P}, t) \\left(6 s _ {1} + s _ {2} + 6 s _ {3} + 6 s _ {4}\\right) \\\\ \\leq 6 \\mathbf {I} (\\mathcal {P}, t), \\end{array} $$</p>

    <p class="text-gray-300">which completes the proof.</p>

    <p class="text-gray-300">6 Soundness of the Micali construction</p>

    <p class="text-gray-300">We use the lifting lemma to prove that the Micali construction is sound in the quantum random oracle model. First, we show that convincing the Micali verifier amounts to winning a corresponding oracle game, in the sense of Definition 4.6. Second, we show that the database property induced by this game is stable when conditioned on the database having no collisions. Both of these are <em>classical</em> properties of the Micali construction. Indeed, our results show how the <em>existing</em> proof of soundness for this protocol fits into our instability framework, making quantum security immediate.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be a PCP for a relation <span class="math">\\mathcal{R}</span> that has soundness error <span class="math">\\epsilon</span>, proof length <span class="math">\\ell</span>, and query complexity <span class="math">q</span>. The Micali construction, when based on <span class="math">(\\mathbf{P},\\mathbf{V})</span>, is a non-interactive argument for <span class="math">\\mathcal{R}</span> that has soundness error <span class="math">O(t^{2}\\epsilon+t^{3}/2^{\\lambda})</span> against quantum attackers that make at most <span class="math">t-O(q\\log\\ell)</span> queries to the random oracle. This soundness error is tight up to small factors.</p>

    <p class="text-gray-300">The rest of this section is organized as follows: in Section 6.1 we describe the properties of Merkle trees used in the proof of security; in Section 6.2 we describe the oracle game that corresponds to the Micali construction; and in Section 6.3 we prove Theorem 6.1.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">6.1 Some algorithms for Merkle trees</h3>

    <p class="text-gray-300">The Micali construction uses Merkle trees <em>[x13]</em> based on random oracles as succinct commitments to lists of values that permit cheaply decommitting to chosen entries in the list. While Merkle trees are well known, we rely on properties of Merkle trees that, while simple, are less well known. In this section we introduce notations needed to specify these properties.</p>

    <p class="text-gray-300">Given a domain <span class="math">Z</span> and a power of two <span class="math">\\ell=2^{d}</span>, a <em>Merkle tree</em> on a list <span class="math">\\mathbf{v}=(v_{i})_{i\\in[\\ell]}\\in Z^{\\ell}</span> with respect to the function <span class="math">h\\colon Z\\times Z\\to Z</span> is a list of values <span class="math">(z_{k,i})_{k\\in\\{0,\\ldots,d\\},i\\in[2^{k}]}\\in Z^{2\\ell}</span>, where</p>

    <p class="text-gray-300"><span class="math">\\forall\\,i\\in[\\ell]\\,,\\;z_{d,i}</span> <span class="math">:=v_{i}\\;\\;,</span> <span class="math">\\forall\\,k\\in\\{d-1,\\ldots,1,0\\}\\,,\\;\\forall\\,i\\in[2^{k}]\\,,\\;z_{k,i}</span> <span class="math">:=h(z_{k+1,2i-1},z_{k+1,2i})\\;\\;.</span></p>

    <p class="text-gray-300">The <em>root</em> of the Merkle tree, denoted <span class="math">\\mathsf{rt}</span>, is <span class="math">z_{0,1}</span>. Given <span class="math">i\\in[\\ell]</span>, the <em>authentication path</em> for the <span class="math">i</span>-th leaf in the Merkle tree is the list of values <span class="math">\\mathsf{ap}:=(a_{k})_{k\\in[d]}\\in Z^{d}</span> where <span class="math">a_{k}</span> is the sibling of the <span class="math">k</span>-th node on the path from <span class="math">v_{i}=z_{d,i}</span> to the root <span class="math">\\mathsf{rt}=z_{0,1}</span>. An authentication path is <em>valid</em> for <span class="math">v</span> at <span class="math">i</span> with respect to <span class="math">\\mathsf{rt},h</span> if “hashing up” the path from <span class="math">v</span> at index <span class="math">i</span> to the root using <span class="math">\\mathsf{ap}</span> yields <span class="math">\\mathsf{rt}</span>. We denote by <span class="math">\\mathsf{CheckPath}^{h}(\\mathsf{rt},i,v,\\mathsf{ap})</span> the (efficient) algorithm that checks this condition.</p>

    <p class="text-gray-300">Below we describe two algorithms that will be used in the proof of security.</p>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">Expanding paths.</h4>

    <p class="text-gray-300">We define an algorithm <span class="math">\\mathsf{Expand}</span> that outputs all the input-output pairs that arise when validating a given authentication path. The name “expand” denotes the fact the algorithm outputs not only the authentication path but also the nodes from the given leaf to the root. The algorithm <span class="math">\\mathsf{Expand}</span> is used in Section 6.2 to define the oracle game for the Micali construction.</p>

    <p class="text-gray-300">In more detail, <span class="math">\\mathsf{Expand}</span> is granted oracle access to a function <span class="math">h\\colon Z\\times Z\\to Z</span> and receives as input an index <span class="math">i\\in[2^{d}]</span>, a value <span class="math">v\\in Z</span>, and an authentication path <span class="math">\\mathsf{ap}:=(a_{k})_{k\\in[d]}\\in Z^{d}</span>. Then <span class="math">\\mathsf{Expand}</span> sets <span class="math">y_{d}:=v</span> and proceeds as follows for <span class="math">k=d-1,\\ldots,0</span>: if the <span class="math">k</span>-th bit of <span class="math">i</span> is <span class="math">0</span>, set <span class="math">x_{k}:=(y_{k+1},a_{k+1})</span>; else if the <span class="math">k</span>-th bit of <span class="math">i</span> is <span class="math">1</span>, set <span class="math">x_{k}:=(a_{k+1},y_{k+1})</span>; set <span class="math">y_{k}:=h(x_{k})</span>. Finally, <span class="math">\\mathsf{Expand}</span> outputs the <span class="math">d</span> input-output pairs <span class="math">(\\mathbf{x},\\mathbf{y}):=((x_{i})_{i=0}^{d-1},(y_{i})_{i=0}^{d-1})</span>. The following property holds.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proposition 6.2.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{CheckPath}^{h}(\\mathsf{rt},i,v,\\mathsf{ap})=1</span> if and only if <span class="math">(\\mathbf{x},\\mathbf{y})\\leftarrow\\mathsf{Expand}^{h}(i,v,\\mathsf{ap})</span> has <span class="math">y_{0}=\\mathsf{rt}</span>.</p>

    <p class="text-gray-300">Extracting trees. We define an algorithm Extract that is used to obtain a Merkle tree rooted at a chosen entry in a database. This algorithm is similar to the one presented in <em>[x21, x1]</em>, and below we give a description of it because we use it in Section 6.3 within the security proof.</p>

    <p class="text-gray-300">In more detail, Extract, receives a database <span class="math">D\\colon Z\\times Z\\rightharpoonup Z</span>, a root value <span class="math">\\mathsf{rt}\\in Z</span>, and a height bound <span class="math">d</span>, and outputs a rooted binary tree <span class="math">T=(V,E)</span> of depth at most <span class="math">d</span> where <span class="math">V\\subseteq Z\\times\\{0,1\\}^{\\leq d}</span>. The algorithm Extract is defined as follows.</p>

    <p class="text-gray-300">Extract<span class="math">(D,\\mathsf{rt},d)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize the vertex set with the root <span class="math">V:=\\{(\\mathsf{rt},\\varnothing)\\}</span> and the edge set to be empty <span class="math">E:=\\emptyset</span>.</li>

      <li>While there exists an unmarked vertex <span class="math">(u,s)\\in V</span> such that <span class="math">u\\in\\mathrm{im}(D)</span> and <span class="math">s\\in\\{0,1\\}^{&lt;d}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mark the vertex <span class="math">(u,s)</span>.</li>

      <li>If <span class="math">u</span> is the result of a collision <span class="math">(D(x)=D(x^{\\prime})=u</span> for distinct <span class="math">x</span> and <span class="math">x^{\\prime})</span>, return <span class="math">\\bot</span>.</li>

      <li>Let <span class="math">x_{0},x_{1}\\in Z</span> be the unique values such that <span class="math">D(x_{0},x_{1})=u</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Update the vertex set $V:=V\\cup\\{(x_{0},s\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0),(x_{1},s\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the tree <span class="math">T:=(V,E)</span>.</li>

    </ol>

    <p class="text-gray-300">Given a tree <span class="math">T:=\\mathsf{Extract}(D,\\mathsf{rt},d)</span>, we can define a string <span class="math">\\mathsf{leaves}(T)</span> where for each <span class="math">i\\in[2^{d}]\\cong\\{0,1\\}^{d}</span> if there exists a vertex <span class="math">(x,i)\\in T</span> then <span class="math">\\mathsf{leaves}(T)_{i}:=x</span> else <span class="math">\\mathsf{leaves}(T)_{i}:=\\bot</span>.</p>

    <p class="text-gray-300">It will be useful in the analysis of Merkle tree algorithms to define the set <span class="math">S(D)</span> of “half-preimages” in a database <span class="math">D</span>:</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 6.3.</h6>

    <p class="text-gray-300">Let <span class="math">D\\colon Z\\times Z\\rightharpoonup Z</span> be a database. Then <span class="math">S(D):=\\{u:\\exists\\,u^{\\prime}\\in Z\\text{ s.t. }(u,u^{\\prime})\\in\\mathrm{supp}(D)\\vee(u^{\\prime},u)\\in\\mathrm{supp}(D)\\}</span>.</p>

    <p class="text-gray-300">The following two lemmas are about properties of the algorithm Extract. The first lemma follows from the algorithm description, and the second one is proved below.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Lemma 6.4.</h6>

    <p class="text-gray-300">Let <span class="math">D\\colon Z\\times Z\\rightharpoonup Z</span> be a database, <span class="math">x\\in Z\\times Z</span> an input with <span class="math">x\\notin\\mathrm{supp}(D)</span>, <span class="math">y\\in Z</span> an output, <span class="math">\\mathsf{rt}\\in Z</span>, and <span class="math">d\\in\\mathbb{N}</span>. For the rooted binary trees <span class="math">T_{1}:=\\mathsf{Extract}(D,\\mathsf{rt},d)</span> and <span class="math">T_{2}:=\\mathsf{Extract}(D+[x\\mapsto y],\\mathsf{rt},d)</span>, if the database <span class="math">D+[x\\mapsto y]</span> has no collisions then <span class="math">T_{1}</span> is a subtree of <span class="math">T_{2}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 6.5.</h6>

    <p class="text-gray-300">Let <span class="math">D</span> be a database and let <span class="math">x\\notin\\mathrm{supp}(D)</span>. Let <span class="math">D^{\\prime}=D+[x\\mapsto y]</span>. Suppose that <span class="math">D,D^{\\prime}\\in\\bar{\\mathcal{P}}_{\\mathsf{col}}</span>. For any <span class="math">\\mathsf{rt}\\in Z</span>, if <span class="math">\\mathsf{Extract}(D,\\mathsf{rt},d)\\neq\\mathsf{Extract}(D^{\\prime},\\mathsf{rt},d)</span>, then <span class="math">y\\in\\{\\mathsf{rt}\\}\\cup S(D)</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{rt}\\in Z</span>, and let <span class="math">T_{1}:=\\mathsf{Extract}(D,\\mathsf{rt},d)</span> and <span class="math">T_{2}:=\\mathsf{Extract}(D+[x\\mapsto y],\\mathsf{rt},d)</span>, and suppose that <span class="math">T_{1}\\neq T_{2}</span>. By Lemma 6.4, we get that <span class="math">T_{1}\\subsetneq T_{2}</span>. Therefore, there must be a vertex <span class="math">(z,s)</span> that is marked in <span class="math">T_{2}</span> but unmarked in <span class="math">T_{1}</span>. This means that <span class="math">z\\notin\\mathrm{im}(D)</span> but <span class="math">z\\in\\mathrm{im}(D^{\\prime})</span>, and hence that <span class="math">z=y</span>. If <span class="math">(z,s)=(\\mathsf{rt},\\emptyset)</span>, then <span class="math">y=z=\\mathsf{rt}</span>. If <span class="math">(z,s)\\neq(\\mathsf{rt},\\emptyset)</span>, then there exists <span class="math">z^{\\prime}\\in Z</span> such that either <span class="math">(z,z^{\\prime})\\in\\mathrm{supp}(D)</span> or <span class="math">(z^{\\prime},z)\\in\\mathrm{supp}(D)</span>, and hence <span class="math">y\\in S(D)</span>. ∎</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">6.2 The oracle game for the Micali construction</h3>

    <p class="text-gray-300">We have summarized the Micali construction in Section 2.1. In order to define the oracle game that represents it, though, we need to recall in more detail how the verifier works. The Micali verifier <span class="math">\\mathcal{V}</span> receives as input an instance <span class="math">\\mathsf{x}</span> and proof <span class="math">\\pi=(\\mathsf{rt},(\\mathsf{ap}_{i})_{i\\in[q]},(v_{i})_{i\\in[q]})</span>, and has oracle access to a function <span class="math">h\\colon\\{0,1\\}^{2\\lambda}\\to\\{0,1\\}^{\\lambda}</span>. First, <span class="math">\\mathcal{V}</span> ensures that all authentication paths are for a Merkle tree with <span class="math">\\ell</span> leaves (recall that <span class="math">\\ell</span> is the PCP proof length). After that, <span class="math">\\mathcal{V}</span> runs the underlying PCP verifier <span class="math">\\mathbf{V}</span> on input <span class="math">\\mathsf{x}</span> and random string <span class="math">h(\\mathsf{rt},0^{\\lambda})</span>. When <span class="math">\\mathbf{V}</span> makes its <span class="math">i</span>-th query to location <span class="math">j\\in[\\ell]</span>, <span class="math">\\mathcal{V}</span> runs</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CheckPath}^{h}(\\mathsf{rt},\\mathsf{ap}_{i},v_{i},j)</span> and answers with <span class="math">v_{i}</span> if this check passes (if not then it rejects). Once <span class="math">\\mathbf{V}</span> halts, <span class="math">\\mathcal{V}</span> accepts if and only if <span class="math">\\mathbf{V}</span> accepted.</p>

    <p class="text-gray-300">Given a proof <span class="math">\\pi</span> as above, we define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Expand}^{h}(\\pi) := \\left(\\left(\\mathbf{x}_{1}, \\dots, \\mathbf{x}_{q}, (\\mathsf{rt}, 0^{\\lambda})\\right), \\left(\\mathbf{y}_{1}, \\dots, \\mathbf{y}_{q}, \\mathsf{r}\\right)\\right) \\in (\\{0, 1\\}^{2\\lambda})^{a} \\times (\\{0, 1\\}^{\\lambda})^{a}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{r} := h(\\mathsf{rt}, 0^{\\lambda})</span> is the derived randomness, each <span class="math">(\\mathbf{x}_i, \\mathbf{y}_i) := \\mathsf{Expand}^h(j_i, \\mathsf{ap}_i, v_i)</span> is an expanded authentication path, and <span class="math">j_i \\in [\\ell]</span> is the location of the <span class="math">i</span>-th query of <span class="math">\\mathbf{V}(\\mathbf{x}; \\mathsf{r})</span>. Note that <span class="math">a := O(q \\log \\ell)</span>.</p>

    <p class="text-gray-300"><strong>Definition 6.6.</strong> Let <span class="math">\\mathbf{V}</span> be a PCP verifier for a relation <span class="math">\\mathcal{R}</span> and let <span class="math">\\mathbf{x}</span> be an instance. The <em>Micali game</em> for <span class="math">(\\mathbf{V}, \\mathbf{x})</span> is the set <span class="math">G_{\\mathbf{V}, \\mathbf{x}}^{\\mathrm{Mic}} := \\{\\mathsf{Expand}^h(\\pi) : h \\colon \\{0,1\\}^{2\\lambda} \\to \\{0,1\\}^{\\lambda}, \\pi \\in \\{0,1\\}^s, \\mathcal{V}^h(\\mathbf{x}, \\pi) = 1\\}</span>.</p>

    <h2 id="sec-60" class="text-2xl font-bold">6.3 Proof of Theorem 6.1</h2>

    <p class="text-gray-300">In order to show that the Micali construction is sound in the (quantum) random oracle model, it suffices to show that the oracle-game value of <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}</span> is small whenever <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span>.</p>

    <p class="text-gray-300"><strong>Proposition 6.7.</strong> The probability that a <span class="math">t</span>-query classical adversary <span class="math">\\mathcal{A}</span> causes the Micali verifier <span class="math">\\mathcal{V}</span> to accept <span class="math">\\mathbf{x}</span> is at most <span class="math">\\omega_{\\mathsf{O}}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}, t + O(q \\log \\ell))</span>. The probability that a <span class="math">t</span>-query quantum adversary <span class="math">\\mathcal{A}</span> causes the Micali verifier <span class="math">\\mathcal{V}</span> to accept <span class="math">\\mathbf{x}</span> is at most <span class="math">\\omega_{\\mathsf{O}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}, t + O(q \\log \\ell))</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathcal{B}</span> be the algorithm that, when given access to an oracle <span class="math">h</span>, runs <span class="math">\\mathcal{A}^h</span> to obtain <span class="math">\\pi</span> and then outputs <span class="math">\\mathsf{Expand}^h(\\pi)</span>. The query complexity of <span class="math">\\mathcal{B}</span> is <span class="math">t + O(q\\log \\ell)</span> because <span class="math">\\mathcal{A}</span> makes <span class="math">t</span> queries and <span class="math">\\mathsf{Expand}</span> makes <span class="math">O(q\\log \\ell)</span> queries. Let <span class="math">((\\mathbf{x}_i)_{i=1}^q, (\\mathsf{rt}, 0^\\lambda), (\\mathbf{y}_i)_{i=1}^q, \\mathsf{r})</span> be the output of <span class="math">\\mathcal{B}</span>. By definition of <span class="math">\\mathsf{Expand}</span>, <span class="math">h((\\mathbf{x}_i)_j) = (\\mathbf{y}_i)_j</span> for all <span class="math">i, j</span>. Hence <span class="math">\\mathcal{B}^h</span> wins <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathsf{Mic}}</span> if and only if <span class="math">\\mathcal{V}^h(\\mathbf{x}, \\pi) = 1</span>.</p>

    <p class="text-gray-300">We now need to establish an upper bound on <span class="math">\\omega_{\\mathsf{O}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathsf{Mic}}, t)</span> given that <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span>. By Lemmas 4.9 and 5.13, it suffices to study the instability of the database property <span class="math">\\mathcal{P}_{\\mathsf{Mic}} := \\mathcal{P}_{G_{\\mathbf{V},\\mathbf{x}}^{\\mathsf{Mic}}}</span> associated with the oracle game <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathsf{Mic}}</span> (in the sense of Definition 5.2). In particular, we upper bound the instability of <span class="math">\\mathcal{P}_{\\mathsf{Mic}}</span> conditioned on the absence of collisions in the database. To simplify this task, we first "break down" <span class="math">\\mathcal{P}_{\\mathsf{Mic}}</span> as the union of simpler database properties, at least for databases that do not contain collisions. Below we assume that the PCP length <span class="math">\\ell</span> equals <span class="math">2^d</span> for some <span class="math">d \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300"><strong>Definition 6.8.</strong> For <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\lambda}</span>, <span class="math">\\mathcal{P}_{\\mathsf{rt}}</span> is the set of databases <span class="math">D</span> such that <span class="math">(\\mathsf{rt}, 0^{\\lambda}) \\in \\operatorname{supp}(D)</span> and for <span class="math">T := \\operatorname{Extract}(D, \\mathsf{rt}, d)</span> the PCP verifier <span class="math">\\mathbf{V}^{\\text{leaves}(T)}(\\mathbf{x}; D(\\mathsf{rt}, 0^{\\lambda}))</span> accepts (where the verifier immediately rejects if it queries a location <span class="math">i</span> with <span class="math">\\text{leaves}(T)_i = \\bot</span>).</p>

    <p class="text-gray-300"><strong>Proposition 6.9.</strong> <span class="math">\\mathcal{P}_{\\mathrm{Mic}} \\subseteq \\mathcal{P}_{\\mathrm{col}} \\cup \\bigcup_{\\mathsf{rt} \\in \\{0,1\\}^{\\lambda}} \\mathcal{P}_{\\mathsf{rt}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By definition, a database <span class="math">D</span> is in <span class="math">\\mathcal{P}_{\\mathrm{Mic}}</span> if and only if there exists <span class="math">(\\mathbf{x}, \\mathbf{y}) \\in G_{\\mathbf{V}, \\mathbf{x}}^{\\mathrm{Mic}}</span> such that for all <span class="math">i \\in [k]</span>, <span class="math">D(x_i) = y_i</span>. Suppose that <span class="math">D \\in \\mathcal{P}_{\\mathrm{Mic}}</span>, and let <span class="math">w = ((\\mathbf{x}_1, \\ldots, \\mathbf{x}_q, (\\mathsf{rt}, 0^\\lambda)), (\\mathbf{y}_1, \\ldots, \\mathbf{y}_q, \\mathsf{r})) \\in G_{\\mathbf{V}, \\mathbf{x}}^{\\mathrm{Mic}}</span> be a witness to this. If <span class="math">D \\in \\mathcal{P}_{\\mathrm{col}}</span> then we are done, so suppose <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>. Then <span class="math">D \\in \\mathcal{P}_{\\mathrm{rt}}</span>, because if <span class="math">D</span> has no collisions then the proof <span class="math">\\pi</span> extracted from root <span class="math">\\mathsf{rt}</span> must be consistent with <span class="math">w</span>; in particular <span class="math">\\mathbf{V}^{\\mathrm{leaves}(T)}(\\mathbf{x}; D(\\mathsf{rt}, 0^\\lambda))</span> accepts.</p>

    <p class="text-gray-300">We now prove two lemmas about instability: first we bound the instability of <span class="math">\\mathcal{P}_{\\mathrm{Mic}}</span> when conditioned on databases having no collisions; then we bound the instability for the set of databases that contain collisions. We denote the latter property by <span class="math">\\mathcal{P}_{\\mathrm{col}}</span>.</p>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">Lemma 6.10. If <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span> then <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{Mic}} \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t) &amp;lt; \\varepsilon + (2t + 1)/2^{\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix a database <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> and fix an input </span>(x_0, x_1) \\in (\\{0, 1\\}^\\lambda)^2<span class="math">. To bound the instability </span>\\mathbf{I}(\\mathcal{P}_{\\mathrm{Mic}} \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t)<span class="math">, it suffices to bound </span>\\operatorname{Pr}_y[D + [(x_0, x_1) \\mapsto y] \\in \\mathcal{P}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}]<span class="math"> because if </span>D \\in \\mathcal{P}_{\\mathrm{Mic}}<span class="math"> then </span>D' \\in \\mathcal{P}_{\\mathrm{Mic}}<span class="math"> for any </span>D'<span class="math"> with </span>D \\subseteq D'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">S&#x27; = \\{r \\in \\{0,1\\}^\\lambda : \\mathbf{V}^{\\Pi}(\\mathbf{x}; r) \\text{ accepts}, \\Pi = \\text{leaves}(\\text{Extract}(D, x_0, d))\\}</span>. We will show that if <span class="math">D + [(x_0, x_1) \\mapsto y] \\in \\mathcal{P}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>, then <span class="math">y \\in S(D) \\cup \\{x_0\\} \\cup S&#x27;</span>.</p>

    <p class="text-gray-300">Let <span class="math">D&#x27; := D + [(x_0, x_1) \\mapsto y]</span>. Proposition 6.9 implies that if <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> then <span class="math">D&#x27;</span> belongs to the set <span class="math">\\mathcal{P}_{\\mathrm{rt}}</span> for some <span class="math">\\mathrm{rt} \\in \\{0,1\\}^\\lambda</span> and the database <span class="math">D</span> does not belong to the set <span class="math">\\mathcal{P}_{\\mathrm{rt}}</span>. Consider the two rooted binary trees <span class="math">T_1 := \\text{Extract}(D, \\mathrm{rt}, d)</span> and <span class="math">T_2 := \\text{Extract}(D&#x27;, \\mathrm{rt}, d)</span>. We have two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">T_1 \\neq T_2</span>. By Lemma 6.5 we get that <span class="math">y \\in S(D) \\cup \\{\\mathrm{rt}\\}</span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathrm{rt}}</span>, we see that <span class="math">(\\mathrm{rt}, 0^\\lambda) \\in \\operatorname{supp}(D&#x27;)</span>. Thus, either <span class="math">\\mathrm{rt} \\in S(D)</span> or <span class="math">(x_0, x_1) = (\\mathrm{rt}, 0^\\lambda)</span>. Hence, <span class="math">y \\in S(D) \\cup \\{x_0\\}</span>.</li>

      <li>Case 2: <span class="math">T_1 = T_2</span>. It must be that <span class="math">(\\mathsf{rt},0^{\\lambda})\\notin \\operatorname {supp}(D)</span> but <span class="math">(\\mathsf{rt},0^{\\lambda})\\in \\operatorname {supp}(D&#x27;)</span>. Hence <span class="math">x_0 = \\mathsf{rt}</span> and <span class="math">x_{1} = 0^{\\lambda}</span>. Letting <span class="math">\\Pi_1\\coloneqq \\mathsf{leaves}(T_1)</span> and <span class="math">\\Pi_2\\coloneqq \\mathsf{leaves}(T_2)</span>, we have that <span class="math">\\Pi_1 = \\Pi_2</span>. Now because <span class="math">D^{\\prime}\\in \\mathcal{P}_{\\mathrm{rt}}</span>, <span class="math">\\mathbf{V}^{\\Pi_2}(\\mathbf{x};y)</span> accepts, so <span class="math">\\mathbf{V}^{\\Pi_1}(\\mathbf{x};y)</span> accepts, and <span class="math">y\\in S^{\\prime}</span> as <span class="math">\\Pi_1 = \\mathsf{leaves}(\\mathsf{Extract}(D,\\mathsf{rt},d))</span> and <span class="math">x_0 = \\mathsf{rt}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We deduce that either <span class="math">y \\in S(D)</span>, <span class="math">y = x_0</span>, or <span class="math">y \\in S&#x27;</span>. Note that these three sets are independent of <span class="math">\\mathsf{rt}</span>, so that in particular this holds for all choices of <span class="math">\\mathsf{rt}</span>. Hence, <span class="math">\\operatorname{Pr}_y[D + [(x_0, x_1) \\mapsto y] \\in \\mathcal{P}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] \\leq \\operatorname{Pr}_y[y \\in S(D) \\cup \\{x_0\\} \\cup S&#x27;]</span>. Clearly, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2t<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x_0\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">. We have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon 2^{\\lambda}<span class="math">, by the soundness of the PCP, as </span>\\Pi = \\text{leaves}(\\text{Extract}(D, x_0, d))<span class="math"> depends only on </span>x_0<span class="math"> and </span>D<span class="math">, and in particular is independent of </span>y<span class="math">. Thus, we conclude that </span>\\operatorname{Pr}_y[D + [(x_0, x_1) \\mapsto y] \\in \\mathcal{P}_{\\mathrm{Mic}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] &lt; \\varepsilon + (2t + 1)/2^{\\lambda}<span class="math">, so </span>\\mathbf{I}(\\mathcal{P}_{\\mathrm{Mic}} \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t) &lt; \\varepsilon + (2t + 1)/2^{\\lambda}$, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 6.11. <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t) &amp;lt; t / 2^{\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix <span class="math">D \\notin \\mathcal{P}_{\\mathrm{col}}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> and </span>x \\in \\{0,1\\}^{2\\lambda}<span class="math">. We have that </span>\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\mathcal{P}_{\\mathrm{col}}] &lt; t / 2^{\\lambda}<span class="math">, as in order for this event to occur it must be that </span>y \\in \\operatorname{im}(D)<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{im}(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">. For any </span>D \\in \\mathcal{P}_{\\mathrm{col}}<span class="math">, we trivially have that </span>\\operatorname{Pr}_y[D + [x \\mapsto y] \\notin \\mathcal{P}_{\\mathrm{col}}] = 0$, which completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can now deduce the following statements:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Lemma 4.9} \\quad \\longrightarrow \\quad \\sqrt{\\omega_{\\mathsf{O}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}, t)} \\leq \\sqrt{\\omega_{\\mathsf{D}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}, t)} + O\\left(\\sqrt{q \\log \\ell / 2^{\\lambda}}\\right) \\quad , \\\\ \\text{Lemma 5.13} \\quad \\longrightarrow \\quad \\omega_{\\mathsf{D}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}, t) \\leq t^{2} \\cdot 6\\left(\\mathbf{I}(\\mathcal{P}_{\\mathrm{Mic}} \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t) + \\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t)\\right) \\quad . \\end{array}</span></div>

    <p class="text-gray-300">By combining the above statements, we get that <span class="math">\\omega_{\\mathsf{O}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}},t) = O(t^{2}\\varepsilon +t^{3} / 2^{\\lambda} + q\\log \\ell /2^{\\lambda})</span>, from which we obtain the stated upper bound on the soundness error via Proposition 6.7.</p>

    <p class="text-gray-300">Tightness. For simplicity we assume that the leaves in the Merkle tree commitments are salted, as is the case when one wishes to preserve zero knowledge (Section 7.1). We prove tightness of the <span class="math">t^2\\varepsilon</span> term, which is the term that dominates in the expression for the soundness error.</p>

    <p class="text-gray-300">Consider the following adversary. The adversary starts with a proof <span class="math">\\Pi</span> that is accepted by the PCP with probability <span class="math">\\varepsilon</span> and, by making <span class="math">O(\\ell)</span> classical queries, builds a Merkle tree for <span class="math">\\Pi</span>. Let <span class="math">\\mathsf{rt}</span> be the root of the tree. By changing the salt for one of the leaves in the tree and "hashing up", the adversary can construct another valid Merkle tree for <span class="math">\\Pi</span> with a newly sampled root <span class="math">\\mathsf{rt}&#x27;</span> by making</p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300">only <span class="math">O(\\log \\ell)</span> additional queries. The adversary then uses Grover's algorithm [Gro96] to search for a new salt so that the new root <span class="math">\\mathsf{rt}&#x27;</span> has <span class="math">\\mathbf{V}^{\\Pi}(\\mathbf{x};h(\\mathsf{rt}&#x27;,0^{\\lambda})) = 1</span>.</p>

    <p class="text-gray-300">With high probability over the choice of <span class="math">h</span>, it holds that at least <span class="math">(\\varepsilon / 2)</span>-fraction of the choices of salt will have a root <span class="math">\\mathsf{rt}&#x27;</span> with <span class="math">\\mathbf{V}^{\\Pi}(\\mathbf{x}; h(\\mathsf{rt}&#x27;, 0^{\\lambda})) = 1</span>. By running Grover's algorithm with <span class="math">t</span> queries, the adversary thus finds a good salt with probability <span class="math">\\Omega(t^{2}\\varepsilon)</span>. Each of the <span class="math">t</span> queries made by Grover's algorithm corresponds to <span class="math">O(t \\log \\ell)</span> queries to <span class="math">h</span>. The adversary makes <span class="math">O(\\ell)</span> queries initially to construct the tree, so this gives us a quantum adversary that wins with probability <span class="math">\\Omega(t^{2}\\varepsilon)</span> by making <span class="math">O(t \\log \\ell + \\ell)</span> queries.</p>

    <p class="text-gray-300">34</p>

    <p class="text-gray-300">7 zkSNARKs in the QROM</p>

    <p class="text-gray-300">We prove the existence of zkSNARKs that are unconditionally secure in the quantum random oracle model, based on the Micali construction.</p>

    <p class="text-gray-300">First, we prove that the Micali construction is a zero knowledge non-interactive argument of knowledge if the underlying PCP is both honest-verifier zero knowledge and a proof of knowledge.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Theorem 7.1.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be a PCP for a relation <span class="math">\\mathcal{R}</span> that is honest-verifier zero knowledge and has knowledge error <span class="math">\\mathsf{k}</span>, and suppose that <span class="math">(\\mathbf{P},\\mathbf{V})</span> has proof length <span class="math">\\ell</span> and query complexity <span class="math">q</span>. The Micali construction, when based on <span class="math">(\\mathbf{P},\\mathbf{V})</span>, is a non-interactive argument in the QROM for <span class="math">\\mathcal{R}</span> that is (statistical) zero knowledge and is an argument of knowledge with extraction probability <span class="math">\\kappa(\\mu,\\lambda,t+O(q\\log\\ell))=\\Omega(\\mu-t^{2}\\mathsf{k}-t^{3}/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">We separately prove zero knowledge and proof of knowledge, respectively in Lemma 7.3 and in Lemma 7.4 below, thereby establishing the above theorem. Observe that the extraction probability <span class="math">\\kappa</span> achieved in the theorem statement <em>implies</em> the soundness bound given Theorem 6.1, because the extraction probability is positive when the verifier’s acceptance probability <span class="math">\\mu</span> is <span class="math">\\Omega(t^{2}\\mathsf{k}+t^{3}/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">If we additionally ensure that the PCP in the Micali construction has small query complexity and verifier running time (via standard PCPs), then we obtain zkSNARKs that are unconditionally secure in the quantum random oracle model (see definition in Section 3.3).</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Corollary 7.2.</h6>

    <p class="text-gray-300">There exist zkSNARKs for <span class="math">\\mathsf{NTIME}(T(n))</span> in the quantum random oracle model.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The PCP in <em>[x1]</em> supports <span class="math">\\mathsf{NTIME}(T(n))</span> with query complexity <span class="math">\\mathsf{poly}(\\log T(n))</span>, a prover that runs in time <span class="math">\\mathsf{poly}(n,T(n))</span>, and a verifier that runs in time <span class="math">\\mathsf{poly}(n,\\log T(n))</span>. The PCP is a proof of knowledge, and can be modified to achieve honest-verifier zero knowledge and a negligible soundness error <em>[x10, x24]</em>. We can then apply Theorem 7.1 to the resulting PCP. ∎</p>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">7.1 Zero knowledge</h3>

    <p class="text-gray-300">In the classical setting, the Micali construction achieves statistical zero knowledge if the underlying PCP is <em>honest-verifier zero knowledge</em> (see definition in Section 3.4), and if leaves in the Merkle tree are salted to ensure statistical hiding of unrevealed leaves <em>[x16, x3]</em>. The following lemma states that the same is true in the quantum setting.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 7.3.</h6>

    <p class="text-gray-300">The construction of Micali (modified to use salted Merkle trees), when based on an honest-verifier zero knowledge PCP, is a zero knowledge non-interactive argument in the QROM.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">A straightforward adaptation of Theorem 6.1 establishes soundness in the case where leaves in the Merkle tree are salted by the prover with fresh randomness. Moreover, the classical zero knowledge guarantee of the Micali construction is statistical, i.e., it holds against verifiers that are unbounded, in computation <em>and</em> in queries to the random oracle. Such verifiers can in particular simulate any quantum adversary (including queries in superposition). This means that the zero knowledge guarantee also holds in the quantum setting. (Indeed, the definition of zero knowledge that we provide in Section 3.3 for non-interactive arguments in the QROM does not even have to mention quantum algorithms; it requires the real view and ideal view to be statistically close.) ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.2 Proof of knowledge</p>

    <p class="text-gray-300">In the classical setting, the Micali construction is an argument of knowledge if the underlying PCP is a proof of knowledge (see definition in Section 3.4). The following lemma states that the same is true in the quantum setting.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 7.4.</h6>

    <p class="text-gray-300">The Micali construction, when based on a PCP of knowledge with knowledge error <span class="math">\\mathsf{k}</span>, is a non-interactive argument of knowledge in the QROM with extraction probability <span class="math">\\Omega(\\mu-t^{2}\\mathsf{k}-t^{3}/2^{\\lambda})</span> against quantum attackers that make at most <span class="math">t-O(q\\log\\ell)</span> queries and win with probability at least <span class="math">\\mu</span>. In particular, the extraction probability is positive for large enough <span class="math">\\mu=\\Omega(t^{2}\\mathsf{k}+t^{3}/2^{\\lambda})</span>.</p>

    <p class="text-gray-300">We prove the lemma by building on ideas in the proof of Section 6, and also on some additional generic machinery. Below we assume that the proof length <span class="math">\\ell</span> equals <span class="math">2^{d}</span> for some <span class="math">d\\in\\mathbb{N}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a <span class="math">t^{\\prime}</span>-query quantum adversary <span class="math">\\mathcal{A}</span> that causes the Micali verifier to accept an instance <span class="math">\\mathsf{x}</span> with probability at least <span class="math">\\mu</span>. Following the proof of Proposition 6.7, we obtain a <span class="math">t</span>-query quantum adversary <span class="math">\\mathcal{B}</span> that wins the Micali oracle game <span class="math">G_{\\mathbf{V},\\mathsf{x}}^{\\mathsf{Mic}}</span> with probability at least <span class="math">\\mu</span>, for <span class="math">t:=t^{\\prime}+O(q\\log\\ell)</span>. This transformation can be efficiently performed with black-box access to <span class="math">\\mathcal{A}</span>, because <span class="math">\\mathcal{B}</span> merely extends <span class="math">\\mathcal{A}</span> with some classical computation that depends on <span class="math">\\mathcal{A}</span>’s (classical) output.</p>

    <p class="text-gray-300">We now describe the quantum extractor <span class="math">\\mathcal{E}</span> for the Micali game, and then argue why it works.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}^{\\mathcal{A}}(\\mathsf{x},1^{t^{\\prime}},1^{\\lambda}):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">t:=t^{\\prime}+O(q\\log\\ell)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute the quantum state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^{*}(\\mathcal{B})\\rangle<span class="math">, by simulating </span>\\mathcal{B}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathsf{w}\\leftarrow\\mathbf{E}(\\mathsf{x},0^{\\ell})</span>, where <span class="math">0^{\\ell}</span> denotes the all <span class="math">0</span>’s proof. If <span class="math">\\mathsf{w}</span> is a valid witness, return it, otherwise continue.</li>

      <li>For each <span class="math">\\mathsf{rt}\\in\\mathrm{im}(D)</span>:</li>

    </ol>

    <p class="text-gray-300">Run <span class="math">T\\leftarrow\\mathsf{Extract}(D,\\mathsf{rt},d)</span>, Set <span class="math">\\Pi_{T}</span> equal to <span class="math">\\mathsf{leaves}(T)</span> on all points where <span class="math">\\mathsf{leaves}(T)</span> is not <span class="math">\\perp</span>, and <span class="math">0</span> otherwise. Run <span class="math">\\mathsf{w}\\leftarrow\\mathbf{E}(\\mathsf{x},\\Pi_{T})</span>. If <span class="math">\\mathsf{w}</span> is a valid witness, return it, otherwise continue.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}_{\\mathbf{E},\\mathsf{rt}}</span> be the set of databases <span class="math">D</span> where running <span class="math">T\\leftarrow\\mathsf{Extract}(D,\\mathsf{rt},d)</span> and then <span class="math">\\mathsf{w}\\leftarrow\\mathbf{E}(\\mathsf{x},\\Pi_{T})</span> yields <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, where <span class="math">\\Pi_{T}</span> is defined as above. Note that <span class="math">\\mathcal{E}^{\\mathcal{A}}(\\mathsf{x},1^{t^{\\prime}},1^{\\lambda})</span> outputs a valid witness if and only if <span class="math">D\\in\\cup_{\\mathsf{rt}\\in\\{0,1\\}^{\\lambda}}\\mathcal{P}_{\\mathbf{E},\\mathsf{rt}}</span>. This is because if <span class="math">\\mathsf{rt}\\in\\mathrm{im}(D)</span> then <span class="math">\\mathcal{E}</span> tries to extract from <span class="math">\\mathsf{rt}</span>, and if <span class="math">\\mathsf{rt}\\notin\\mathrm{im}(D)</span> then <span class="math">T\\leftarrow\\mathsf{Extract}(D,\\mathsf{rt},d)</span> has one vertex (just <span class="math">\\mathsf{rt}</span>), and so <span class="math">\\Pi_{T}=0^{\\ell}</span>.</p>

    <p class="text-gray-300">We can lower bound the probability that the extractor succeeds as follows:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\mathcal{E}^{\\mathcal{A}}(\\mathsf{x},1^{t^{\\prime}},1^{\\lambda})\\text{ outputs a valid witness}\\Big{]}=\\Pr\\Big{[}D\\in\\cup_{\\mathsf{rt}\\in\\{0,1\\}^{\\lambda}}\\mathcal{P}_{\\mathbf{E},\\mathsf{rt}}\\Big{]}</span> <span class="math">\\geq\\Pr[D\\in\\cup_{\\mathsf{rt}}\\mathcal{P}_{\\mathbf{E},\\mathsf{rt}}\\cap\\mathcal{P}_{\\mathsf{Mic}}]=\\Pr[D\\in\\mathcal{P}_{\\mathsf{Mic}}]-\\Pr\\big{[}D\\in\\cap_{\\mathsf{rt}}\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}\\cap\\mathcal{P}_{\\mathsf{Mic}}\\big{]}</span> <span class="math">\\geq\\Pr[D\\in\\mathcal{P}_{\\mathsf{Mic}}]-\\Pr\\Big{[}D\\in\\cap_{\\mathsf{rt}\\in\\{0,1\\}^{\\lambda}}\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}\\cap((\\cup_{\\mathsf{rt}}\\mathcal{P}_{\\mathsf{rt}})\\cup\\mathcal{P}_{\\mathsf{col}})\\Big{]}</span> <span class="math">\\geq\\Pr[D\\in\\mathcal{P}_{\\mathsf{Mic}}]-\\Pr\\big{[}D\\in\\mathcal{P}_{\\mathsf{col}}\\cup(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}))\\big{]}</span> <span class="math">\\geq\\Pr[\\mathcal{B}\\text{ wins the Micali database game}]-t^{2}\\cdot 6\\mathbf{I}(\\mathcal{P}_{\\mathsf{col}}\\cup(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})),t)\\enspace,</span></p>

    <p class="text-gray-300">where the second inequality follows by Proposition 6.9 and the third by the fact that <span class="math">\\cap_{\\mathsf{rt}\\in\\{0,1\\}^{\\lambda}}\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}\\cap((\\cup_{\\mathsf{rt}}\\mathcal{P}_{\\mathsf{rt}})\\cup\\mathcal{P}_{\\mathsf{col}})\\subseteq\\mathcal{P}_{\\mathsf{col}}\\cup(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}))</span>. This latter property can be interpreted as follows: either there is a collision, or there is some <span class="math">\\mathsf{rt}\\in\\mathrm{supp}(D)</span> such that we can produce a correct SNARG proof rooted at <span class="math">\\mathsf{rt}</span> but the PCP extractor cannot extract a valid witness from the PCP proof rooted at <span class="math">\\mathsf{rt}</span>.</p>

    <p class="text-gray-300">We have that the probability that <span class="math">\\mathcal{B}</span> wins the quantum database game of <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}</span> is <span class="math">\\Omega (\\mu -q\\log \\ell /2^{\\lambda})</span> by Lemma 4.9. Hence, in order to complete the proof it suffices to show the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 7.5.</strong> <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}\\cup (\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})),t) &amp;lt; \\mathsf{k} + (2t + 1) / 2^{\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We have that <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}} \\cup (\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})), t) \\leq \\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t) + \\mathbf{I}(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}) \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t)</span>. By Lemma 6.11, we have that <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t) &amp;lt; t / 2^{\\lambda}</span>.</p>

    <p class="text-gray-300">We now bound <span class="math">\\mathbf{I}(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})\\mid \\bar{\\mathcal{P}}_{\\mathsf{col}},t)</span>. Let <span class="math">D\\in \\bar{\\mathcal{P}}_{\\mathsf{col}}</span> be a database, and fix <span class="math">x = (x_0,x_1)\\notin \\operatorname {supp}(D)</span>. Let <span class="math">S^{\\prime} = \\{r\\in \\{0,1\\}^{\\lambda}:\\mathbf{V}^{\\Pi}(\\mathbf{x};r)</span> accepts, <span class="math">\\Pi = \\mathrm{leaves}(\\mathrm{Extract}(D,x_0,d))</span>}.</p>

    <p class="text-gray-300">Suppose first that <span class="math">D \\notin \\cup_{\\mathsf{rt}} (\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})</span>; we bound <span class="math">\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\cup_{\\mathsf{rt}} (\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}}) \\cap \\bar{\\mathcal{P}}_{\\mathsf{col}}]</span>. Fix a <span class="math">y</span> such that this holds, and let <span class="math">D&#x27; := D + [x \\mapsto y]</span>. Then there exists <span class="math">\\mathsf{rt}^<em></span> such that <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathsf{rt}^</em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}^<em>}</span> and <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathsf{rt}^</em>} \\cup \\mathcal{P}_{\\mathbf{E},\\mathsf{rt}^*}</span>. There are two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">D \\in \\mathcal{P}_{\\mathbf{E}, \\mathbf{r}^<em>}</span>. Since <span class="math">D&#x27; \\notin \\mathcal{P}_{\\mathbf{E}, \\mathbf{r}^</em>}</span>, we get that <span class="math">\\text{Extract}(D, \\mathbf{r}^<em>, d) \\neq \\text{Extract}(D&#x27;, \\mathbf{r}^</em>, d)</span>. Hence, by Lemma 6.5 we get that <span class="math">y \\in S(D)</span> or <span class="math">y = \\mathbf{r}^<em></span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{r}^</em>}</span>, we have that <span class="math">(\\mathbf{r}^<em>, 0^\\lambda) \\in \\operatorname{supp}(D&#x27;)</span>, and hence either <span class="math">\\mathbf{r}^</em> \\in S(D)</span> or <span class="math">\\mathbf{r}^* = x_0</span>. Thus, either <span class="math">y \\in S(D)</span> or <span class="math">y = x_0</span>.</li>

      <li>Case 2: <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{r}^<em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathbf{r}^</em>}</span>. We have that <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{r}^<em>}</span>. If <span class="math">\\text{Extract}(D, \\mathbf{r}^</em>, d) \\neq \\text{Extract}(D&#x27;, \\mathbf{r}^<em>, d)</span>, then again we get that <span class="math">y \\in S(D)</span> or <span class="math">y = x_0</span>. If <span class="math">\\text{Extract}(D, \\mathbf{r}^</em>, d) = \\text{Extract}(D&#x27;, \\mathbf{r}^<em>, d)</span>, then by Case 2 of Lemma 6.10 we get that <span class="math">x_0 = \\mathbf{r}^</em></span> and <span class="math">y \\in S&#x27;</span>. In particular, this implies that <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E}, x_0}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We conclude that either <span class="math">y \\in S(D) \\cup \\{x_0\\}</span>, or <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E}, x_0}</span> and <span class="math">y \\in S&#x27;</span>. We know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(D) \\cup \\{x_0\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2t + 1<span class="math">. We show that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k \\cdot 2^{\\lambda}<span class="math"> if </span>D \\in \\bar{\\mathcal{P}}_{\\mathbf{E}, x_0}<span class="math">. Let </span>T = \\text{Extract}(D, x_0, d)<span class="math">, </span>\\Pi = \\text{leaves}(T)<span class="math">, and </span>\\Pi_T<span class="math"> be as defined earlier. Suppose that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^{\\lambda} = \\operatorname{Pr}_r[\\mathbf{V}^{\\Pi}(\\mathbf{x}; r) \\text{ accepts}] &gt; k<span class="math">. Then, </span>\\operatorname{Pr}_r[\\mathbf{V}^{\\Pi_T}(\\mathbf{x}; r) \\text{ accepts}] \\geq \\operatorname{Pr}_r[\\mathbf{V}^{\\Pi}(\\mathbf{x}; r) \\text{ accepts}] &gt; k<span class="math"> and so </span>\\mathbf{E}(\\mathbf{x}, \\Pi_T)<span class="math"> outputs a valid witness for </span>\\mathbf{x}<span class="math">. Therefore, </span>D \\in \\mathcal{P}_{\\mathbf{E}, x_0}<span class="math">, a contradiction, and so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k \\cdot 2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We thus conclude that if <span class="math">D \\in \\mathcal{P}_{\\mathbf{E}, x_0}</span> then <span class="math">\\operatorname{Pr}_y[D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}} \\cap (\\cup_{\\mathbf{r}} (\\mathcal{P}_{\\mathbf{r}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathbf{r}}))] &amp;lt; (2t + 1)/2^{\\lambda}</span>, and if <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E}, x_0}</span> then <span class="math">\\operatorname{Pr}_y[D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}} \\cap (\\cup_{\\mathbf{r}} (\\mathcal{P}_{\\mathbf{r}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathbf{r}}))] &amp;lt; k + (2t + 1)/2^{\\lambda}</span>. Hence, <span class="math">\\mathrm{flip}(\\cup_{\\mathbf{r}} (\\mathcal{P}_{\\mathbf{r}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathbf{r}})) \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t) &amp;lt; k + (2t + 1)/2^{\\lambda}</span>.</p>

    <p class="text-gray-300">Now suppose that <span class="math">D \\in \\cup_{\\mathsf{rt}} (\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathsf{rt}})</span>; we bound <span class="math">\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\overline{\\cup_{\\mathsf{rt}} (\\mathcal{P}_{\\mathsf{rt}} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathsf{rt}})} \\cap \\bar{\\mathcal{P}}_{\\mathsf{col}}]</span>. Fix a <span class="math">y</span> such that this holds, and let <span class="math">D&#x27; := D + [x \\mapsto y]</span>. Then there exists <span class="math">\\mathsf{rt}^<em></span> such that <span class="math">D \\in \\mathcal{P}_{\\mathsf{rt}^</em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathsf{rt}^<em>}</span> and <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathsf{rt}^</em>} \\cup \\mathcal{P}_{\\mathbf{E}, \\mathsf{rt}^*}</span>. There are two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathbf{r}^<em>}</span>. This is impossible: since <span class="math">D \\in \\mathcal{P}_{\\mathbf{r}^</em>} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> and <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>, it follows by Lemma 6.4 that <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{r}^*}</span>.</li>

      <li>Case 2: <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{r}^<em>} \\cap \\mathcal{P}_{\\mathbf{E}, \\mathbf{r}^</em>}</span>. Since <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E}, \\mathbf{r}^<em>}</span> and <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{E}, \\mathbf{r}^</em>}</span>, it follows that <span class="math">\\text{Extract}(D, \\mathbf{r}^<em>, d) \\neq \\text{Extract}(D&#x27;, \\mathbf{r}^</em>, d)</span>. Hence, by Lemma 6.5 we get that <span class="math">y \\in S(D)</span> or <span class="math">y = \\mathbf{r}^<em></span>. Since <span class="math">D \\in \\mathcal{P}_{\\mathbf{r}^</em>}</span>, it follows that <span class="math">(\\mathbf{r}^<em>, 0^\\lambda) \\in \\operatorname{supp}(D)</span>, so <span class="math">\\mathbf{r}^</em> \\in S(D)</span>. Hence, <span class="math">y \\in S(D)</span>.</li>

    </ul>

    <p class="text-gray-300">We conclude that <span class="math">\\mathrm{flip}(\\overline{\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap\\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})}\\mid \\bar{\\mathcal{P}}_{\\mathsf{col}},t) &amp;lt; 2t / 2^{\\lambda}</span>.</p>

    <p class="text-gray-300">Putting it together, we get that <span class="math">\\mathbf{I}(\\cup_{\\mathsf{rt}}(\\mathcal{P}_{\\mathsf{rt}}\\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\mathsf{rt}})\\mid \\bar{\\mathcal{P}}_{\\mathsf{col}},t) &amp;lt; \\mathsf{k} + (2t + 1) / 2^{\\lambda}</span>.</p>

    <p class="text-gray-300">8 The BCS construction in the QROM</p>

    <p class="text-gray-300">We prove that non-interactive arguments obtained via the BCS construction applied to IOPs with round-by-round soundness are unconditionally secure in the quantum random oracle model. Moreover, if the IOP is honest-verifier zero knowledge and has round-by-round knowledge then BCS construction yields a zero knowledge non-interactive argument of knowledge. This section is organized as follows: in Section 8.1 we define IOPs; in Section 8.2 we define the oracle game that corresponds to the BCS construction; in Section 8.3 we define round-by-round soundness and round-by-round knowledge; in Section 8.4 we state our result; and in Section 8.5 we prove our result.</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">8.1 Interactive oracle proofs</h3>

    <p class="text-gray-300">A (public-coin) <em>interactive oracle proof</em> (IOP) <em>[x1, x18]</em> is a multi-round extension of the notion of a PCP where in each round the verifier sends a random message <span class="math">m_{i}</span> and the prover replies with a proof string <span class="math">\\Pi_{i}</span>. After the interaction, the verifier queries the proof strings <span class="math">(\\Pi_{1},\\Pi_{2},\\dots)</span> received from the prover, and then accepts or rejects. A PCP is then a non-interactive IOP.</p>

    <p class="text-gray-300">An IOP for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span> is a pair of polynomial-time interactive algorithms <span class="math">(\\mathbf{P},\\mathbf{V})</span> for which the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every instance-witness pair <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span>, the probability that <span class="math">\\mathbf{P}(\\mathtt{x},\\mathtt{w})</span> convinces <span class="math">\\mathbf{V}(\\mathtt{x})</span> to accept is 1.</li>

      <li>Soundness. For every instance <span class="math">\\mathtt{x}\\notin\\mathcal{L}(\\mathcal{R})</span> and unbounded malicious prover <span class="math">\\tilde{\\mathbf{P}}</span>, the probability that <span class="math">\\tilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}(\\mathtt{x})</span> to accept is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <p class="text-gray-300">Like the IP model, a fundamental measure of efficiency is the round complexity <span class="math">k</span>. Like the PCP model, two additional fundamental measures of efficiency are the <em>proof length</em> <span class="math">\\ell</span>, which is the total number of alphabet symbols in all of the prover’s messages, and the <em>query complexity</em> <span class="math">q</span>, which is the total number of locations queried by the verifier across all of the prover’s messages.</p>

    <p class="text-gray-300">Transcripts. We denote by <span class="math">\\mathtt{tr}</span> a <em>transcript</em> of <span class="math">(\\mathbf{P},\\mathbf{V})</span>, which means all verifier messages and proof strings up to a point where either the prover or the verifier is about to move. In more detail, <span class="math">\\mathtt{tr}</span> is one of the following cases (with <span class="math">\\Pi_{0}</span> defined as the empty string):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>the empty transcript, denoted by the symbol <span class="math">\\emptyset</span> (the verifier is about to move);</li>

      <li>a partial transcript where the prover is about to move, which is a pair of the form <span class="math">(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{i}),(\\Pi_{1},\\dots,\\Pi_{i-1}))</span> for some <span class="math">i\\in[k]</span>;</li>

      <li>a partial transcript where the verifier is about to move, which is a pair of the form <span class="math">(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{i}),(\\Pi_{1},\\dots,\\Pi_{i}))</span> for some <span class="math">i\\in[k]</span>;</li>

      <li>a full transcript, which is a pair of the form <span class="math">(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{k+1}),(\\Pi_{1},\\dots,\\Pi_{k}))</span>.</li>

    </ul>

    <p class="text-gray-300">We allow the proof strings <span class="math">\\Pi_{i}</span> to be partial functions, i.e., databases (Section 3.5).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a transcript <span class="math">\\mathtt{tr}=(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{i}),(\\Pi_{1},\\dots,\\Pi_{i-1}))</span> where the prover is about to move, we let $\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi<span class="math"> denote the transcript </span>((m_{1},\\dots,m_{i}),(\\Pi_{1},\\dots,\\Pi_{i-1},\\Pi))<span class="math">. Similarly, given a transcript </span>\\mathtt{tr}=(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{i}),(\\Pi_{1},\\dots,\\Pi_{i}))<span class="math"> where the verifier is about to move, we let </span>\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m<span class="math"> denote the transcript </span>(\\mathbf{m},\\mathbf{\\Pi})=((m_{1},\\dots,m_{i},m),(\\Pi_{1},\\dots,\\Pi_{i}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-69" class="text-xl font-semibold mt-8">8.2 The BCS construction and its oracle game</h3>

    <p class="text-gray-300">The BCS construction transforms a public-coin IOP into a corresponding non-interactive argument, using random oracles. Informally, this is achieved by repeating the idea of the Micali construction</p>

    <p class="text-gray-300">in each round, and then forcing rounds to be in order via a hash chain; see <em>[x1]</em> for details.</p>

    <p class="text-gray-300">In order to define the oracle game that represents the BCS construction, we need to recall how its verifier works. The BCS verifier <span class="math">\\mathcal{V}</span> receives as input an instance <span class="math">\\mathtt{x}</span> and proof</p>

    <p class="text-gray-300"><span class="math">\\pi=(\\sigma,(\\mathtt{rt}_{j})_{j\\in[k]},(\\mathtt{ap}_{i})_{i\\in[q]},(v_{i})_{i\\in[q]})\\enspace,</span></p>

    <p class="text-gray-300">and has oracle access to a function <span class="math">h\\colon\\{0,1\\}^{2\\lambda}\\to\\{0,1\\}^{\\lambda}</span>. First, <span class="math">\\mathcal{V}</span> checks the hash chain: it initializes <span class="math">\\sigma_{0}:=0^{\\lambda}</span>; then, for each <span class="math">j\\in[k]</span>, it computes <span class="math">m_{j}:=h(\\sigma_{j-1},&quot;j&quot;)</span> and <span class="math">\\sigma_{j}:=h(m_{j},\\mathtt{rt}_{j})</span>, where <span class="math">\`\`j&#x27;&#x27;\\in\\{0,1\\}^{\\lambda}</span> is some unique encoding of the integer <span class="math">j</span>; finally, <span class="math">\\mathcal{V}</span> checks that <span class="math">\\sigma=\\sigma_{k}</span>. Next, <span class="math">\\mathcal{V}</span> computes the randomness for the query phase as <span class="math">m_{k+1}:=h(\\sigma,&quot;\\mathtt{k+1}&quot;)</span>. The randomness for the IOP verifier <span class="math">\\mathbf{V}</span> is <span class="math">\\mathbf{m}:=(m_{1},\\ldots,m_{k},m_{k+1})</span>. Finally, <span class="math">\\mathcal{V}</span> simulates the IOP verifier <span class="math">\\mathbf{V}</span> on <span class="math">\\mathbf{m}</span> by answering its queries using the values contained in <span class="math">\\pi</span>. In more detail, it runs <span class="math">\\mathbf{V}(\\mathtt{x};\\mathbf{m})</span> and answers its <span class="math">i</span>-th query, for <span class="math">i\\in[q]</span>, as follows: if the query is to the <span class="math">j</span>-th proof string at a location <span class="math">s</span> then check that <span class="math">\\mathsf{CheckPath}^{h}(\\mathtt{rt}_{j},s,v_{i},\\mathtt{ap}_{i})</span> accepts and answer with <span class="math">v_{i}</span> if this check passes (else reject). Once <span class="math">\\mathbf{V}</span> halts, <span class="math">\\mathcal{V}</span> accepts if and only if <span class="math">\\mathbf{V}</span> accepted. (The BCS verifier <span class="math">\\mathcal{V}</span> should also do basic syntactic checks such as ensuring that if the <span class="math">j</span>-th proof string is supposed to have length <span class="math">\\ell_{j}</span> then authentication paths relative to the <span class="math">j</span>-th root have an appropriate length.)</p>

    <p class="text-gray-300">Given a BCS proof <span class="math">\\pi</span> as above, we define</p>

    <p class="text-gray-300"><span class="math">\\mathsf{BCSExpand}^{h}(\\pi):=\\Big{(}\\big{(}(\\mathtt{x}_{i})_{i\\in[q]},(\\sigma_{j-1},&quot;j&quot;)_{j\\in[k+1]},(m_{j},\\mathtt{rt}_{j})_{j\\in[k]}\\big{)},\\big{(}(\\mathtt{y}_{i})_{i\\in[q]},(m_{j})_{j\\in[k+1]},(\\sigma_{j})_{j\\in[k]}\\big{)}\\Big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\sigma_{0}:=0^{\\lambda}</span>, <span class="math">m_{j}:=h(\\sigma_{j-1},&quot;j&quot;)</span> for <span class="math">j\\in[k+1]</span> is the derived message of the verifier in the <span class="math">j</span>-th round, <span class="math">\\sigma_{j}:=h(m_{j},\\mathtt{rt}_{j})</span> for <span class="math">j\\in[k]</span>, each <span class="math">(\\mathtt{x}_{i},\\mathtt{y}_{i}):=\\mathsf{Expand}^{h}(s_{i},\\mathtt{ap}_{i},v_{i})</span> is an expanded authentication path, and <span class="math">s_{i}</span> is the location of the <span class="math">i</span>-th query of <span class="math">\\mathbf{V}(\\mathtt{x};\\mathbf{m})</span>. Note that <span class="math">\\mathsf{BCSExpand}^{h}(\\pi)\\in(\\{0,1\\}^{2\\lambda})^{a}\\times(\\{0,1\\}^{\\lambda})^{a}</span> for <span class="math">a:=O(q\\log\\ell)</span> where <span class="math">\\ell:=\\sum_{j=1}^{k}\\ell_{j}</span> is the proof length of the IOP.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 8.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{V}</span> be an IOP verifier for a relation <span class="math">\\mathcal{R}</span> and let <span class="math">\\mathtt{x}</span> be an instance. The BCS game for <span class="math">(\\mathbf{V},\\mathtt{x})</span> is the set <span class="math">\\mathcal{O}_{\\mathbf{V},\\mathtt{x}}^{\\mathrm{BCS}}:=\\{\\mathsf{BCSExpand}^{h}(\\pi):h\\colon\\{0,1\\}^{2\\lambda}\\to\\{0,1\\}^{\\lambda},\\pi\\in\\{0,1\\}^{s},\\mathcal{V}^{h}(\\mathtt{x},\\pi)=1\\}</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Remark 8.2.</h6>

    <p class="text-gray-300">Our definition of the BCS construction uses a slightly different hash chain from the one used in <em>[x1]</em>. This is due to our proof technique. Soundness against quantum attackers also holds for the hash chain in <em>[x1]</em>, provided that the underlying IOP satisfies a slightly stronger variant of round-by-round soundness. This issue is discussed in Section 8.6.</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">8.3 Round-by-round soundness and knowledge</h3>

    <p class="text-gray-300">We define round-by-round soundness (adapted from <em>[x11]</em>) and round-by-round knowledge (introduced in this work), which are the notions of soundness and knowledge that we consider in Theorem 8.6 below. We first define an IOP state function, and then give the two definitions.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition 8.3.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be an IOP for a relation <span class="math">\\mathcal{R}</span>. A state function for <span class="math">(\\mathbf{P},\\mathbf{V})</span> is a deterministic (possibly inefficient) function <span class="math">\\mathtt{state}</span> that receives as input an instance <span class="math">\\mathtt{x}</span> and a transcript <span class="math">\\mathtt{tr}=(\\mathbf{m},\\mathbf{\\Pi})</span> and outputs a bit for which the following holds. <span class="math">\\bullet</span> Empty transcript: if <span class="math">\\mathtt{tr}=\\emptyset</span> is the empty transcript then <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>. <span class="math">\\bullet</span> Prover moves: if <span class="math">\\mathtt{tr}</span> is a transcript where the prover is about to move and <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>, then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall\\ \\Pi,\\ \\mathtt{state}(\\mathtt{x},\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi)=0\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> Full transcript: if <span class="math">\\mathtt{tr}</span> is a full transcript and <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>, then <span class="math">\\mathbf{V}^{\\mathbf{II}}(\\mathtt{x};\\mathbf{m})=0</span>.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Definition 8.4 (<em>[x10]</em>.</h6>

    <p class="text-gray-300">An IOP <span class="math">(\\mathbf{P},\\mathbf{V})</span> for a relation <span class="math">\\mathcal{R}</span> has round-by-round soundness error <span class="math">\\epsilon</span> if there exists a state function <span class="math">\\mathtt{state}</span> such that for all <span class="math">\\mathtt{x}\\notin\\mathcal{L}(\\mathcal{R})</span> and every transcript <span class="math">\\mathtt{tr}</span> where the verifier is about to move and <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{m}[\\mathtt{state}(\\mathtt{x},\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)=1]\\leq\\epsilon\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-75" class="text-base font-medium mt-4">Definition 8.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An IOP <span class="math">(\\mathbf{P},\\mathbf{V})</span> for a relation <span class="math">\\mathcal{R}</span> has round-by-round knowledge error <span class="math">\\mathsf{k}</span> if there exists a polynomial-time extractor <span class="math">\\mathbf{E}</span> and state function <span class="math">\\mathtt{state}</span> such that for all <span class="math">\\mathtt{x}</span> and every transcript <span class="math">\\mathtt{tr}</span> where the verifier is about to move and <span class="math">\\mathtt{state}(\\mathtt{x},\\mathtt{tr})=0</span>, if $\\Pr_{m}[\\mathtt{state}(\\mathtt{x},\\mathtt{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)=1]>\\mathsf{k}<span class="math"> then </span>(\\mathtt{x},\\mathbf{E}(\\mathtt{x},\\mathtt{tr}))\\in\\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">8.4 Our result</h3>

    <p class="text-gray-300">We prove that the BCS construction is sound in the quantum random oracle model if the underlying IOP has round-by-round soundness, is a proof of knowledge if the IOP has round-by-round knowledge, and is statistical zero knowledge if the IOP is honest-verifier zero knowledge. Our result establishes the post-quantum security of many zkSNARKs of practical interest, which rely on zero knowledge IOPs (and IPs) that have round-by-round soundness and round-by-round knowledge.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Theorem 8.6.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be an IOP for a relation <span class="math">\\mathcal{R}</span> with proof length <span class="math">\\ell</span> and query complexity <span class="math">q</span>. Then the BCS construction, when based on <span class="math">(\\mathbf{P},\\mathbf{V})</span>, is a non-interactive argument for <span class="math">\\mathcal{R}</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Soundness) if <span class="math">(\\mathbf{P},\\mathbf{V})</span> has round-by-round soundness error <span class="math">\\epsilon</span>, then the argument has soundness error <span class="math">O(t^{2}\\epsilon+t^{3}/2^{\\lambda})</span> against quantum attackers that make at most <span class="math">t-O(q\\log\\ell)</span> queries to the random oracle.</li>

      <li>(Knowledge) if <span class="math">(\\mathbf{P},\\mathbf{V})</span> has round-by-round knowledge error <span class="math">\\mathsf{k}</span>, then the argument is an argument of knowledge with extraction probability <span class="math">\\Omega(\\mu-t^{2}\\mathsf{k}-t^{3}/2^{\\lambda})</span> against quantum attackers that make at most <span class="math">t-O(q\\log\\ell)</span> queries and win with probability at least <span class="math">\\mu</span>. The extraction probability is positive for large enough <span class="math">\\mu=\\Omega(t^{2}\\mathsf{k}+t^{3}/2^{\\lambda})</span>.</li>

      <li>(Zero Knowledge) if <span class="math">(\\mathbf{P},\\mathbf{V})</span> is honest-verifier zero knowledge, then the argument is (statistical) zero knowledge.</li>

    </ol>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">8.5 Proof of Theorem 8.6</h3>

    <p class="text-gray-300">We begin by noting that preservation of zero knowledge is straightforward. This is because, analogous to the Micali construction Section 7.1, the BCS construction achieves statistical zero knowledge provided the underlying IOP is honest-verifier zero knowledge. See <em>[x1]</em> for details.</p>

    <p class="text-gray-300">Next, we prove soundness in Section 8.5.1 and knowledge in Section 8.5.2. To start, we define two extraction algorithms that operate on databases, which are similar to those defined in Section 6.1.</p>

    <h4 id="sec-79" class="text-lg font-semibold mt-6">Extracting hash chains.</h4>

    <p class="text-gray-300">We define an algorithm <span class="math">\\mathsf{HExtract}</span> that is used to extract a hash chain ending at a chosen entry in a database. <span class="math">\\mathsf{HExtract}</span> receives a database <span class="math">D\\colon Z\\times Z\\rightharpoonup Z</span>, an end value <span class="math">y\\in Z</span>, and a length bound <span class="math">k</span>, and outputs an integer <span class="math">\\ell</span> and two tuples <span class="math">(x_{1},\\ldots,x_{\\ell}),(y_{0},\\ldots,y_{\\ell})</span> where <span class="math">\\ell\\in[k]</span>, each <span class="math">x_{i}</span> and <span class="math">y_{i}\\in Z</span>, <span class="math">D(y_{i-1},x_{i})=y_{i}</span> for each <span class="math">i\\in[\\ell]</span>, and <span class="math">y_{\\ell}=y</span>.</p>

    <p class="text-gray-300">Formally, the algorithm <span class="math">\\mathsf{HExtract}</span> is defined as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{HExtract}(D,y,k)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize two lists <span class="math">\\mathsf{chain} = (y)</span> and <span class="math">\\mathsf{input} = ()</span>, and a counter <span class="math">\\ell \\gets 0</span>.</li>

      <li>While <span class="math">\\ell &amp;lt; k</span>:</li>

    </ol>

    <p class="text-gray-300">(a) If <span class="math">y</span> is the result of a collision <span class="math">(D(z,x) = D(z&#x27;,x&#x27;) = y</span> for distinct <span class="math">(z,x),(z&#x27;,x&#x27;)</span> in <span class="math">Z^2)</span>, return <span class="math">\\bot</span>. (b) Let <span class="math">z, x \\in Z</span> be the unique values such that <span class="math">D(z, x) = y</span>. If none exist, then exit the loop. (c) Prepend <span class="math">z</span> to chain: chain := <span class="math">\\{z\\} \\cup \\text{chain}</span>. (d) Prepend <span class="math">x</span> to input: input := <span class="math">\\{x\\} \\cup \\text{input}</span>. (e) Update <span class="math">y \\gets z</span> and increment <span class="math">\\ell \\gets \\ell + 1</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\ell, \\text{input}, \\text{chain})</span>.</li>

    </ol>

    <p class="text-gray-300">The BCS extractor. We now define the BCS extractor, which finds a transcript where the hash chain of roots ends at a chosen entry in the database. The algorithm BCSEextract is given below.</p>

    <p class="text-gray-300">BCSEextract <span class="math">(D,\\sigma ,k,d_{1},\\ldots ,d_{k})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\ell, (x_{1}, \\ldots, x_{\\ell}), (y_{0}, \\ldots, y_{\\ell})) \\gets \\mathsf{HExtract}(D, \\sigma, k)</span>. If <span class="math">\\mathsf{HExtract}(D, \\sigma, k)</span> outputs <span class="math">\\perp</span> instead, output <span class="math">\\perp</span>.</li>

      <li>If <span class="math">y_0 \\neq 0^\\lambda</span> or <span class="math">x_{2i-1} \\neq &quot;i&quot;</span> for some <span class="math">i \\in \\{1, \\dots, \\lfloor (\\ell + 1) / 2 \\rfloor\\}</span>, output the empty transcript <span class="math">\\mathsf{tr} = \\emptyset</span>.</li>

      <li>Let <span class="math">\\mathsf{rt}_i = x_{2i}</span> for <span class="math">i \\in \\{1, \\dots, \\lfloor \\ell / 2 \\rfloor\\}</span>, let <span class="math">m_i = y_{2i-1}</span> for <span class="math">i \\in \\{1, \\dots, \\lfloor (\\ell + 1) / 2 \\rfloor\\}</span>.</li>

      <li>Let <span class="math">T_{i} = \\mathsf{Extract}(D, \\mathsf{rt}_{i}, d_{i})</span> for each <span class="math">i \\in \\{1, \\dots, \\lfloor \\ell / 2 \\rfloor\\}</span>. If <span class="math">T_{i} = \\bot</span> for some <span class="math">i</span>, output <span class="math">\\bot</span>.</li>

      <li>Output the transcript <span class="math">\\mathsf{tr} = \\Big(\\big(m_1,\\ldots ,m_{\\lfloor (\\ell +1) / 2\\rfloor}\\big),\\big(\\mathsf{leaves}(T_1),\\ldots ,\\mathsf{leaves}(T_{\\lfloor \\ell /2\\rfloor})\\big)\\Big)</span>.</li>

    </ol>

    <p class="text-gray-300">Lemma 8.7. Let <span class="math">D</span> be a database, and suppose that <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>. Then <span class="math">\\mathsf{BCSEextract}(D, \\sigma, k, d_1, \\ldots, d_k)</span> always outputs a valid transcript <span class="math">\\mathsf{tr}</span>. In particular, <span class="math">\\mathsf{tr} \\neq \\bot</span>.</p>

    <p class="text-gray-300">The following is an analogue of Lemma 6.5 for the BCS extractor.</p>

    <p class="text-gray-300">Lemma 8.8. Let <span class="math">D</span> be a database and let <span class="math">x \\notin \\operatorname{supp}(D)</span>. Let <span class="math">D&#x27; = D + [x \\mapsto y]</span>, and suppose that <span class="math">D, D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>. Let <span class="math">\\sigma \\in Z</span>. If <span class="math">\\mathsf{BCSEextract}(D, \\sigma, k, d_1, \\ldots, d_k) \\neq \\mathsf{BCSEextract}(D&#x27;, \\sigma, k, d_1, \\ldots, d_k)</span>, then <span class="math">y \\in \\{\\sigma\\} \\cup S(D)</span>.</p>

    <p class="text-gray-300">Lemma 8.8 follows immediately from the following two claims.</p>

    <p class="text-gray-300">Claim 8.9. If <span class="math">\\mathsf{HExtract}(D,\\sigma ,k)\\neq \\mathsf{HExtract}(D^{\\prime},\\sigma ,k)</span> for some <span class="math">\\sigma \\in Z</span>, then <span class="math">y\\in S(D)</span> or <span class="math">y = \\sigma</span>.</p>

    <p class="text-gray-300">Claim 8.10. If <span class="math">\\mathsf{BCSEextract}(D, \\sigma, k, d_1, \\ldots, d_k) \\neq \\mathsf{BCSEextract}(D&#x27;, \\sigma, k, d_1, \\ldots, d_k)</span> and <span class="math">\\mathsf{HExtract}(D, \\sigma, k) = \\mathsf{HExtract}(D&#x27;, \\sigma, k)</span>, then <span class="math">y \\in S(D)</span>.</p>

    <p class="text-gray-300">Proof of Claim 8.9. Let <span class="math">(\\ell, (x_1, \\ldots, x_\\ell), (y_0, \\ldots, y_\\ell))</span> be the output of <span class="math">\\mathsf{HExtract}(D&#x27;, \\sigma, k)</span>. Since <span class="math">D, D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>, it follows that <span class="math">\\mathsf{HExtract}(D, \\sigma, k)</span> outputs <span class="math">(\\ell - i, (x_{i+1}, \\ldots, x_\\ell), (y_i, \\ldots, y_\\ell))</span> for some <span class="math">i \\in [\\ell]</span>. Therefore, the entry <span class="math">((y_{i-1}, x_i), y_i)</span> is in <span class="math">D&#x27;</span> but not in <span class="math">D</span>. Hence, <span class="math">x = (y_{i-1}, x_i)</span> and <span class="math">y = y_i</span>. If <span class="math">i = \\ell</span> then <span class="math">y = y_\\ell = \\sigma</span>, and if <span class="math">i &amp;lt; \\ell</span>, then the entry <span class="math">((y_i, x_{i+1}), y_{i+1})</span> is in <span class="math">D</span>, so <span class="math">y = y_i \\in S(D)</span>.</p>

    <p class="text-gray-300">Proof of Claim 8.10. If <span class="math">\\mathsf{HExtract}(D, \\sigma, k) = \\mathsf{HExtract}(D&#x27;, \\sigma, k)</span>, then there must exist some root <span class="math">\\mathsf{rt}_i</span> in the execution of BCSEextract such that <span class="math">\\mathsf{Extract}(D, \\mathsf{rt}_i, d_i) \\neq \\mathsf{Extract}(D&#x27;, \\mathsf{rt}_i, d_i)</span>. Hence, by Lemma 6.5 we get that <span class="math">y \\in S(D)</span> or <span class="math">y = \\mathsf{rt}_i</span>. Assume that <span class="math">y = \\mathsf{rt}_i</span>. We must have that <span class="math">(u, \\mathsf{rt}_i) \\in \\operatorname{supp}(D)</span> for some <span class="math">u \\in Z</span>, as <span class="math">\\mathsf{rt}_i = x_{2i}</span> in the hash chain extracted by <span class="math">\\mathsf{HExtract}</span>, so <span class="math">(y_{2i-1}, x_{2i}) \\in \\operatorname{supp}(D)</span>. Since <span class="math">(u, \\mathsf{rt}_i) \\in \\operatorname{supp}(D)</span>, it follows that <span class="math">y \\in S(D)</span>.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">8.5.1 Soundness</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a relation, and let <span class="math">\\mathbb{x} \\notin \\mathcal{L}(\\mathcal{R})</span>. Let <span class="math">(\\mathbf{P}, \\mathbf{V})</span> be an IOP for a relation <span class="math">\\mathcal{R}</span> that has round-by-round error <span class="math">\\epsilon</span>, proof length <span class="math">\\ell</span>, query complexity <span class="math">q</span>, and <span class="math">k</span> rounds. Let <span class="math">\\ell_1, \\ldots, \\ell_k</span> be the proof lengths of the individual rounds. Without loss of generality assume that for each <span class="math">i</span>, <span class="math">\\ell_i = 2^{d_i}</span> for some <span class="math">d_i</span>. For ease of notation, we will omit the arguments <span class="math">k, d_1, \\ldots, d_k</span> from the input to BCSExtract.</p>

    <p class="text-gray-300">We first show the following simple proposition.</p>

    <p class="text-gray-300"><strong>Proposition 8.11.</strong> The probability that a <span class="math">t</span>-query classical adversary <span class="math">\\mathcal{A}</span> causes the BCS verifier <span class="math">\\mathcal{V}</span> to accept <span class="math">\\mathbb{x}</span> is at most <span class="math">\\omega_{\\mathbb{O}}(G_{\\mathbf{V},\\mathbb{x}}^{\\mathrm{BCS}}, t + O(q \\log \\ell))</span>. The probability that a <span class="math">t</span>-query quantum adversary <span class="math">\\mathcal{A}</span> causes the BCS verifier <span class="math">\\mathcal{V}</span> to accept <span class="math">\\mathbb{x}</span> is at most <span class="math">\\omega_{\\mathbb{O}}^{*}(G_{\\mathbf{V},\\mathbb{x}}^{\\mathrm{BCS}}, t + O(q \\log \\ell))</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathcal{A}</span> be a (either classical or quantum) oracle algorithm. Let <span class="math">\\mathcal{B}</span> be the algorithm that, when given access to an oracle <span class="math">h</span>, runs <span class="math">\\mathcal{A}^h</span> to obtain <span class="math">\\pi</span> and then outputs <span class="math">\\mathsf{BCSExpand}^h(\\pi)</span>. The query complexity of <span class="math">\\mathcal{B}</span> is <span class="math">t + O(q\\log \\ell)</span> because <span class="math">\\mathcal{A}</span> makes <span class="math">t</span> queries and <span class="math">\\mathsf{BCSExpand}</span> makes <span class="math">O(q\\log \\ell)</span> queries. Let <span class="math">((x_i)_{i=1}^a, (y_i)_{i=1}^a)</span> be the output of <span class="math">\\mathcal{B}</span>. By definition of <span class="math">\\mathsf{BCSExpand}</span>, <span class="math">h(x_i) = y_i</span> for all <span class="math">i \\in [a]</span>. Hence <span class="math">\\mathcal{B}^h</span> wins <span class="math">G_{\\mathbf{V},\\mathbb{x}}^{\\mathrm{BCS}}</span> if and only if <span class="math">\\mathcal{V}^h(\\mathbb{x}, \\pi) = 1</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}_{\\mathrm{BCS}} := \\mathcal{P}_{G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}}</span>. Let <span class="math">\\mathcal{P}_{\\mathrm{col}}</span> be the collision property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">\\mathcal{P} := \\cup_{\\sigma} \\mathcal{P}_{\\sigma}</span>, where for <span class="math">\\sigma \\in \\{0,1\\}^{\\lambda}</span>, <span class="math">\\mathcal{P}_{\\sigma}</span> is the set of databases <span class="math">D</span> where (1) <span class="math">D</span> contains no collisions, (2) <span class="math">\\operatorname{tr} = \\mathsf{BCSExtract}(D,\\sigma)</span> is a transcript where the verifier is about to move, (3) <span class="math">\\mathsf{state}(\\mathbf{x},\\mathbf{tr}) = 0</span>, (4) <span class="math">D(\\sigma, &quot;i+1&quot;) \\neq \\bot</span>, where <span class="math">i</span> is the number of rounds in <span class="math">\\mathbf{tr}</span>, and (5) $\\mathsf{state}(\\mathbf{x},\\mathbf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\sigma, "i+1")) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proposition 8.12.</strong> <span class="math">\\mathcal{P}_{\\mathrm{BCS}} \\subseteq \\mathcal{P}_{\\mathrm{col}} \\cup \\mathcal{P}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Suppose <span class="math">D \\in \\mathcal{P}_{\\mathrm{BCS}}</span>. If <span class="math">D</span> has a collision, then <span class="math">D \\in \\mathcal{P}_{\\mathrm{col}}</span>. Suppose <span class="math">D</span> has no collisions. Since <span class="math">D \\in \\mathcal{P}_{\\mathrm{BCS}}</span>, there exists <span class="math">w = \\left( \\left( (\\mathbf{x}_i)_{i \\in [q]}, (\\sigma_{j-1}, &quot;j&quot;)_{j \\in [k+1]}, (m_j, r t_j)_{j \\in [k]} \\right), \\left( (\\mathbf{y}_i)_{i \\in [q]}, (m_j)_{j \\in [k+1]}, (\\sigma_j)_{j \\in [k]} \\right) \\right) \\in G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}</span> consistent with <span class="math">D</span>. Let <span class="math">\\mathbf{tr} = \\mathsf{BCSExtract}(D, m_{k+1})</span>. Since <span class="math">D</span> has no collisions the transcript <span class="math">\\mathbf{tr}</span> extracted from <span class="math">m_{k+1}</span> by <span class="math">\\mathsf{BCSExtract}</span> is a full transcript and consistent with <span class="math">w</span>, i.e., <span class="math">\\mathbf{tr} = ((m_1, \\ldots, m_{k+1}), (\\Pi_1, \\ldots, \\Pi_k))</span>. Since <span class="math">w \\in G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}</span> the IOP verifier accepts <span class="math">\\mathbf{tr}</span>. Therefore, <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathbf{tr}) = 1</span>. Since <span class="math">\\mathsf{state}(\\mathbf{x}, \\emptyset) = 0</span> and adding a prover message cannot change <span class="math">\\mathsf{state}</span> from 0 to 1, there exists <span class="math">i</span> such that <span class="math">\\mathbf{tr}_1 = ((m_1, \\ldots, m_i), (\\Pi_1, \\ldots, \\Pi_i))</span> and <span class="math">\\mathbf{tr}_2 = ((m_1, \\ldots, m_{i+1}), (\\Pi_1, \\ldots, \\Pi_i))</span> satisfy <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathbf{tr}_1) = 0</span> and <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathbf{tr}_2) = 1</span>. Note that by Item 2 of Definition 8.3 it must be that <span class="math">\\mathbf{tr}_1</span> is a transcript where the verifier is about to move. We have that <span class="math">\\mathbf{tr}_1 = \\mathsf{BCSExtract}(\\sigma_i, D)</span>, and <span class="math">D(\\sigma_i, &quot;i+1&quot;) = m_{i+1}</span>, so $\\mathbf{tr}_2 = \\mathbf{tr}_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\sigma_i, "i+1")<span class="math">. Hence, </span>D \\in \\mathcal{P}_{\\sigma_i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 8.13.</strong> <span class="math">\\mathbf{I}(\\mathcal{P} \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t) &amp;lt; \\varepsilon + (2t + 1)/2^{\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Fix a database <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">, and fix an input </span>x \\in \\{0,1\\}^{2\\lambda}<span class="math">. Suppose that </span>D \\in \\mathcal{P} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}<span class="math">. Then, </span>\\operatorname*{Pr}_y[D + [x \\mapsto y] \\in \\bar{\\mathcal{P}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] &lt; 2t / 2^{\\lambda}<span class="math">. This is because since </span>D \\in \\mathcal{P}<span class="math">, </span>D \\in \\mathcal{P}_{\\sigma}<span class="math"> for some </span>\\sigma<span class="math">. Hence, if </span>D + [x \\mapsto y] \\in \\bar{\\mathcal{P}}<span class="math"> then </span>D + [x \\mapsto y] \\notin \\mathcal{P}_{\\sigma}<span class="math">, and so </span>\\mathsf{BCSExtract}(D, \\sigma) \\neq \\mathsf{BCSExtract}(D + [x \\mapsto y], \\sigma)<span class="math">. It follows by Lemma 8.8 that </span>y \\in S(D) \\cup \\{\\sigma\\}<span class="math">. Since </span>D \\in \\mathcal{P}_{\\sigma}<span class="math">, we see that </span>\\sigma \\in S(D)<span class="math">. Thus, </span>y \\in S(D)<span class="math">. Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2t<span class="math">, we see that </span>\\operatorname*{Pr}_y[D + [x \\mapsto y] \\in \\bar{\\mathcal{P}} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}] &lt; 2t / 2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, suppose that <span class="math">D \\notin \\mathcal{P}</span>. We bound <span class="math">\\operatorname*{Pr}_y[D + [x \\mapsto y] \\in \\mathcal{P} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}]</span>. Proposition 8.12 implies that, if the event inside the probability statement occurs, then the database <span class="math">D&#x27; := D + [x \\mapsto y]</span> belongs to the set <span class="math">\\mathcal{P}_{\\sigma}</span> for some <span class="math">\\sigma \\in \\{0,1\\}^{\\lambda}</span> and the database <span class="math">D</span> does not belong to the set <span class="math">\\mathcal{P}_{\\sigma&#x27;}</span> for all <span class="math">\\sigma&#x27;</span>.</p>

    <p class="text-gray-300">42</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">z</span> denote the first <span class="math">\\lambda</span> bits of <span class="math">x</span>, and let <span class="math">\\mathsf{tr} := \\mathsf{BCSExtract}(D, z)</span>. If <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathsf{tr}) = 1</span> then set <span class="math">S&#x27; := \\emptyset</span>; otherwise set $S' := \\{m : \\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 1\\}<span class="math">, where we use the convention that </span>\\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 0<span class="math"> if </span>\\mathsf{tr}<span class="math"> is not a transcript where the verifier is about to move, i.e. that </span>\\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m<span class="math"> is a malformed transcript. Note that this implies that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon 2^{\\lambda}<span class="math">, since the IOP has round-by-round soundness error </span>\\epsilon$. We have two cases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\mathsf{BCSExtract}(D, \\sigma) \\neq \\mathsf{BCSExtract}(D&#x27;, \\sigma)</span>. By Lemma 8.8, we see that <span class="math">y \\in S(D)</span> or <span class="math">y = \\sigma</span>. Suppose that <span class="math">y = \\sigma</span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma}</span>, we get that <span class="math">(\\sigma, u&#x27;) \\in \\operatorname{supp}(D&#x27;)</span> for some <span class="math">u&#x27; \\in \\{0,1\\}^{\\lambda}</span>. Hence, either <span class="math">\\sigma \\in S(D)</span> or <span class="math">\\sigma = z</span>, and so either <span class="math">y \\in S(D)</span> or <span class="math">y = z</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2: <span class="math">\\mathsf{BCSExtract}(D, \\sigma) = \\mathsf{BCSExtract}(D&#x27;, \\sigma)</span>. Let <span class="math">\\mathsf{tr}</span> be equal to <span class="math">\\mathsf{BCSExtract}(D&#x27;, \\sigma)</span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma}</span>, we have that <span class="math">\\mathsf{tr}</span> is a transcript where the verifier is about to move and <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathsf{tr}) = 0</span>. Let <span class="math">i</span> be the number of rounds in <span class="math">\\mathsf{tr}</span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma}</span>, we also have that <span class="math">D&#x27;(\\sigma, &quot;i+1&quot;) \\neq \\bot</span> and $\\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'(\\sigma, "i+1")) = 1<span class="math">. Since </span>D \\notin \\mathcal{P}_{\\sigma}<span class="math">, we must have that </span>D(\\sigma, "i+1") = \\bot<span class="math">. Hence, </span>z = \\sigma<span class="math">, so it follows that </span>y \\in S'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We deduce that in all cases, either <span class="math">y \\in S(D)</span>, <span class="math">y = z</span>, or <span class="math">y \\in S&#x27;</span>. Note that these events are independent of <span class="math">\\sigma</span>, so in particular this holds for all choices of <span class="math">\\sigma</span>. Clearly, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2t<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{z\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">. As discussed above, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon 2^{\\lambda}<span class="math">. Hence </span>\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\mathcal{P}_{\\mathsf{BCS}} \\cap \\bar{\\mathcal{P}}_{\\mathsf{col}}] \\leq \\operatorname{Pr}_y[y \\in S(D) \\cup \\{z\\} \\cup S'] &lt; \\varepsilon + (2t + 1)/2^{\\lambda}<span class="math">. It follows that </span>\\mathbf{I}(\\mathcal{P}_{\\mathsf{BCS}} \\mid \\bar{\\mathcal{P}}_{\\mathsf{col}}, t) &lt; \\varepsilon + (2t + 1)/2^{\\lambda}$, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Finishing the proof of soundness.</strong> Since <span class="math">\\mathcal{P}_{\\mathsf{BCS}} \\subseteq \\mathcal{P}_{\\mathsf{col}} \\cup \\mathcal{P}</span>, we get that for any <span class="math">\\mathcal{A} \\in \\mathcal{C}_t^<em></span>, $\\operatorname</em>{Pr}_{\\mathcal{A}}[\\mathcal{A} \\text{ wins } G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}] \\leq \\operatorname*{Pr}\\big[D \\in \\mathcal{P}_{\\mathsf{col}} \\cup \\mathcal{P} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">((\\mathbf{a}, \\mathbf{b}, c), D) \\leftarrow \\mathsf{Sim}^<em>(\\mathcal{A})\\big]<span class="math">. We also have that </span>\\mathbf{I}(\\mathcal{P}_{\\mathsf{col}} \\cup \\mathcal{P} \\mid \\bar{\\mathcal{P}}_{\\mathsf{col}}, t) = \\mathbf{I}(\\mathcal{P} \\mid \\bar{\\mathcal{P}}_{\\mathsf{col}}, t)<span class="math"> and </span>\\emptyset \\notin \\mathcal{P} \\cup \\mathcal{P}_{\\mathsf{col}}<span class="math"> (as </span>\\mathsf{state}(\\mathbf{x}, \\emptyset) = 0<span class="math">). Therefore, by Lemmas 5.9 and 5.10 we have that </span>\\operatorname</em>{Pr}\\big[D \\in \\mathcal{P}_{\\mathsf{col}} \\cup \\mathcal{P} \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">((\\mathbf{a}, \\mathbf{b}, c), D) \\leftarrow \\mathsf{Sim}^*(\\mathcal{A})\\big] \\leq t^2 \\cdot 6\\big(\\mathbf{I}(\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathsf{col}}, t) + \\mathbf{I}(\\mathcal{P}_{\\mathsf{col}}, t)\\big) \\leq 6(t^2\\epsilon + 4t^3/2^\\lambda)<span class="math">. Thus, </span>\\omega_{\\mathsf{D}}^*(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}, t) \\leq 6(t^2\\epsilon + 4t^3/2^\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 4.9, we have that <span class="math">\\sqrt{\\omega_{\\mathsf{O}}^{<em>}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}},t)}\\leq \\sqrt{\\omega_{\\mathsf{D}}^{</em>}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}},t)} +O\\left(\\sqrt{q\\log\\ell / 2^{\\lambda}}\\right)</span>. We thus conclude that <span class="math">\\omega_{\\mathsf{O}}^{*}(G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}},t) = O(t^{2}\\varepsilon +t^{3} / 2^{\\lambda} + q\\log \\ell /2^{\\lambda})</span>. Applying Proposition 8.11 completes the proof of soundness in Theorem 8.6.</p>

    <h2 id="sec-80" class="text-2xl font-bold">8.5.2 Knowledge</h2>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a relation, and let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be an IOP for a relation <span class="math">\\mathcal{R}</span> that has round-by-round knowledge error <span class="math">\\mathbf{k}</span>, proof length <span class="math">\\ell</span>, query complexity <span class="math">q</span>, and <span class="math">k</span> rounds. Let <span class="math">\\ell_1,\\ldots ,\\ell_k</span> be the proof lengths of the individual rounds. Without loss of generality assume that for each <span class="math">i</span>, <span class="math">\\ell_{i} = 2^{d_{i}}</span> for some <span class="math">d_{i}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be a <span class="math">t^{\\prime}</span>-query quantum adversary <span class="math">\\mathcal{A}</span> that causes the BCS verifier to accept an instance <span class="math">\\mathbf{x}</span> with probability at least <span class="math">\\mu</span>. Following the proof of Proposition 8.11, we obtain a <span class="math">t</span>-query quantum adversary <span class="math">\\mathcal{B}</span> that wins the BCS oracle game <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{BCS}}</span> with probability at least <span class="math">\\mu</span>, for <span class="math">t := t&#x27; + O(q\\log \\ell)</span>. This transformation can be efficiently performed with black-box access to <span class="math">\\mathcal{A}</span>, because <span class="math">\\mathcal{B}</span> merely extends <span class="math">\\mathcal{A}</span> with some classical computation that depends on <span class="math">\\mathcal{A}</span>'s (classical) output.</p>

    <p class="text-gray-300">We now describe the quantum extractor <span class="math">\\mathcal{E}</span> for the BCS game, and then argue why it works.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}^{\\mathcal{A}}(\\mathbf{x},1^{t&#x27;},1^{\\lambda})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">t \\coloneqq t&#x27; + O(q\\log \\ell)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute the quantum state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Sim}^*(\\mathcal{B})\\rangle<span class="math">, by simulating </span>\\mathcal{B}<span class="math"> via </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathsf{w} \\gets \\mathbf{E}(\\mathbf{x}, \\emptyset)</span>. If <span class="math">\\mathsf{w}</span> is a valid witness, return it, otherwise continue.</li>

      <li>For each <span class="math">\\sigma \\in \\mathrm{im}(D)</span>:</li>

    </ol>

    <p class="text-gray-300">Run <span class="math">\\mathsf{tr} \\gets \\mathsf{BCSExtract}(D, \\sigma)</span>, then run <span class="math">\\mathsf{w} \\gets \\mathbf{E}(\\mathbf{x}, \\mathsf{tr})</span>. If some <span class="math">\\Pi</span> in <span class="math">\\mathsf{tr}</span> has an entry that is <span class="math">\\perp</span>, treat it as if it were 0.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{w}</span> is a valid witness, return it, otherwise continue.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}_{\\mathbf{E},\\sigma}</span> be the set of databases <span class="math">D</span> where running <span class="math">\\mathsf{tr} \\gets \\mathsf{BCSExtract}(D, \\sigma)</span> and then <span class="math">\\mathsf{w} \\gets \\mathbf{E}(\\mathbf{x}, \\mathsf{tr})</span> has <span class="math">(\\mathbf{x}, \\mathsf{w}) \\in \\mathcal{R}</span>. Note that <span class="math">\\mathcal{E}^{\\mathcal{A}}(\\mathbf{x}, 1^{t&#x27;}, 1^{\\lambda})</span> outputs a valid witness if and only if <span class="math">D \\in \\cup_{\\sigma \\in \\{0,1\\}^{\\lambda}} \\mathcal{P}_{\\mathbf{E},\\sigma}</span>. This is because if <span class="math">\\sigma \\in \\mathrm{im}(D)</span> then <span class="math">\\mathcal{E}</span> tries to extract from <span class="math">\\sigma</span>, and if <span class="math">\\sigma \\notin \\mathrm{im}(D)</span> then <span class="math">\\mathsf{BCSExtract}(D, \\sigma)</span> is the empty transcript, and <span class="math">\\mathcal{E}</span> always tries to extract from the empty transcript.</p>

    <p class="text-gray-300">As in the case of Micali, we lower bound the probability that the extractor succeeds as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\mathcal{E}^{\\mathcal{A}}(\\mathbf{x}, 1^{t&#x27;}, 1^{\\lambda}) \\text{ outputs a valid witness} \\right] = \\Pr \\left[ D \\in \\cup_{\\sigma \\in \\{0,1\\}^{\\lambda}} \\mathcal{P}_{\\mathbf{E},\\sigma} \\right] \\\\ \\geq \\Pr \\left[ D \\in \\cup_{\\sigma} \\mathcal{P}_{\\mathbf{E},\\sigma} \\cap \\mathcal{P}_{\\mathrm{BCS}} \\right] = \\Pr \\left[ D \\in \\mathcal{P}_{\\mathrm{BCS}} \\right] - \\Pr \\left[ D \\in \\cap_{\\sigma} \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma} \\cap \\mathcal{P}_{\\mathrm{BCS}} \\right] \\\\ \\geq \\Pr \\left[ D \\in \\mathcal{P}_{\\mathrm{BCS}} \\right] - \\Pr \\left[ D \\in \\cap_{\\sigma \\in \\{0,1\\}^{\\lambda}} \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma} \\cap \\left((\\cup_{\\sigma} \\mathcal{P}_{\\sigma}) \\cup \\mathcal{P}_{\\mathrm{col}}\\right) \\right] \\\\ \\geq \\Pr \\left[ D \\in \\mathcal{P}_{\\mathrm{BCS}} \\right] - \\Pr \\left[ D \\in \\mathcal{P}_{\\mathrm{col}} \\cup \\left( \\cup_{\\sigma} \\left( \\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma} \\right) \\right) \\right] \\\\ \\geq \\Pr \\left[ \\mathcal{B} \\text{ wins the BCS database game} \\right] - t^{2} \\cdot 6 \\mathbf{I} \\left( \\mathcal{P}_{\\mathrm{col}} \\cup \\left( \\cup_{\\sigma} \\left( \\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma} \\right) \\right), t \\right), \\end{array}</span></div>

    <p class="text-gray-300">where the second inequality follows by Proposition 8.12 and the third by the fact that <span class="math">\\cap_{\\sigma \\in \\{0,1\\}^{\\lambda}} \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma} \\cap ((\\cup_{\\sigma} \\mathcal{P}_{\\sigma}) \\cup \\mathcal{P}_{\\mathrm{col}}) \\subseteq \\mathcal{P}_{\\mathrm{col}} \\cup (\\cup_{\\sigma} (\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}))</span>.</p>

    <p class="text-gray-300">We have that the probability that <span class="math">\\mathcal{B}</span> wins the quantum database game of <span class="math">G_{\\mathbf{V},\\mathbf{x}}^{\\mathrm{Mic}}</span> is <span class="math">\\Omega (\\mu -q\\log \\ell /2^{\\lambda})</span> by Lemma 4.9. Hence, in order to complete the proof it suffices to show the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 8.14.</strong> <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}} \\cup (\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})), t) &amp;lt; k + (2t + 1)/2^{\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We have that <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}} \\cup (\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})), t) \\leq \\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t) + \\mathbf{I}(\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}) \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t)</span>. By Lemma 6.11, we have that <span class="math">\\mathbf{I}(\\mathcal{P}_{\\mathrm{col}}, t) &amp;lt; t / 2^{\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now bound <span class="math">\\mathbf{I}(\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}) \\mid \\bar{\\mathcal{P}}_{\\mathrm{col}}, t)</span>. Let <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> be a database, and let <span class="math">x \\notin \\operatorname{supp}(D)</span>. Let <span class="math">z</span> be the first <span class="math">\\lambda</span> bits of <span class="math">x</span>. Let <span class="math">\\mathsf{tr} := \\mathsf{BCSExtract}(D, z)</span>. If <span class="math">\\mathsf{state}(\\mathbf{x}, \\mathsf{tr}) = 1</span> then set <span class="math">S&#x27; := \\emptyset</span>; otherwise let $S' := \\{m : \\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 1\\}<span class="math">, where we use the convention that </span>\\mathsf{state}(\\mathbf{x}, \\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 0<span class="math"> if </span>\\mathsf{tr}<span class="math"> is not a transcript where the verifier is about to move, i.e. that </span>\\mathsf{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m$ is a malformed transcript.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose first that <span class="math">D \\notin \\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})</span>; we bound <span class="math">\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}) \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}]</span>. Fix a <span class="math">y</span> such that this holds, and let <span class="math">D&#x27; := D + [x \\mapsto y]</span>. Then there exists <span class="math">\\sigma^<em></span> such that <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma^</em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma^<em>}</span> and <span class="math">D \\in \\bar{\\mathcal{P}}_{\\sigma^</em>} \\cup \\mathcal{P}_{\\mathbf{E},\\sigma^*}</span>. There are two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">D \\in \\mathcal{P}_{\\mathbf{E},\\sigma^<em>}</span>. Since <span class="math">D&#x27; \\notin \\mathcal{P}_{\\mathbf{E},\\sigma^</em>}</span>, we get that <span class="math">\\mathsf{BCSExtract}(D, \\sigma^<em>) \\neq \\mathsf{BCSExtract}(D&#x27;, \\sigma^</em>)</span>. Hence, by Lemma 8.8 we get that <span class="math">y \\in S(D)</span> or <span class="math">y = \\sigma^<em></span>. Since <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma^</em>}</span>, we have that <span class="math">(\\sigma^<em>, u&#x27;) \\in \\operatorname{supp}(D&#x27;)</span> for some <span class="math">u&#x27; \\in \\{0,1\\}^\\lambda</span>, and hence either <span class="math">\\sigma^</em> \\in S(D)</span> or <span class="math">\\sigma^* = z</span>. Thus, either <span class="math">y \\in S(D)</span> or <span class="math">y = z</span>.</li>

      <li>Case 2: <span class="math">D \\in \\bar{\\mathcal{P}}_{\\sigma^<em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma^</em>}</span>. We have that <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma^<em>}</span>. If <span class="math">\\mathsf{BCSExtract}(D, \\sigma^</em>) \\neq \\mathsf{BCSExtract}(D&#x27;, \\sigma^<em>)</span>, then again we get that <span class="math">y \\in S(D)</span> or <span class="math">y = z</span>. If <span class="math">\\mathsf{BCSExtract}(D, \\sigma^</em>) = \\mathsf{BCSExtract}(D&#x27;, \\sigma^<em>)</span>, then by Case 2 of Lemma 8.13 we get that <span class="math">z = \\sigma^</em></span> and <span class="math">y \\in S&#x27;</span>. In particular, this implies that <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E},z}</span>.</li>

    </ul>

    <p class="text-gray-300">44</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We conclude that either <span class="math">y \\in S(D) \\cup \\{z\\}</span>, or it holds that <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E},z}</span> and <span class="math">y \\in S&#x27;</span>. We know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(D) \\cup \\{z\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2t + 1<span class="math">. We show that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k \\cdot 2^{\\lambda}<span class="math"> if </span>D \\in \\bar{\\mathcal{P}}_{\\mathbf{E},z}<span class="math">. If </span>\\text{state}(x, tr) = 1<span class="math"> then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 0 &lt; k \\cdot 2^{\\lambda}<span class="math">, so suppose otherwise. Suppose that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^{\\lambda} = \\operatorname{Pr}_m[\\text{state}(x, tr \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m) = 1] &gt; k<span class="math">. Then, since </span>\\text{state}(x, tr) = 0<span class="math">, by the definition of round-by-round knowledge we get that </span>\\mathbf{E}(x, tr)<span class="math"> outputs a valid witness for </span>x<span class="math">. Therefore, </span>D \\in \\mathcal{P}_{\\mathbf{E},z}<span class="math">, a contradiction, and so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k \\cdot 2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus conclude that if <span class="math">D \\in \\mathcal{P}_{\\mathbf{E},z}</span> then <span class="math">\\operatorname{Pr}_y[D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}} \\cap (\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}))] &amp;lt; (2t + 1)/2^{\\lambda}</span>, and if <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E},z}</span> then <span class="math">\\operatorname{Pr}_y[D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}} \\cap (\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma}))] &amp;lt; k + (2t + 1)/2^{\\lambda}</span>. Hence, $\\mathrm{flip}(\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{P}}_{\\mathrm{col}}, t) &lt; k + (2t + 1)/2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now suppose that <span class="math">D \\in \\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})</span>. We bound <span class="math">\\operatorname{Pr}_y[D + [x \\mapsto y] \\in \\overline{\\cup_{\\sigma}(\\mathcal{P}_{\\sigma} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})} \\cap \\bar{\\mathcal{P}}_{\\mathrm{col}}]</span>. Fix a <span class="math">y</span> such that this holds, and let <span class="math">D&#x27; := D + [x \\mapsto y]</span>. Then there exists <span class="math">\\sigma^<em></span> such that <span class="math">D \\in \\mathcal{P}_{\\sigma^</em>} \\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma^<em>}</span> and <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\sigma^</em>} \\cup \\mathcal{P}_{\\mathbf{E},\\sigma^*}</span>. There are two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\sigma^<em>}</span>. Since <span class="math">D \\in \\mathcal{P}_{\\sigma^</em>} \\cup \\bar{\\mathcal{P}}_{\\mathrm{col}}</span> and <span class="math">D&#x27; \\in \\bar{\\mathcal{P}}_{\\mathrm{col}}</span>, it follows that <span class="math">\\text{BCSExtract}(D, \\sigma^<em>) \\neq \\text{BCSExtract}(D&#x27;, \\sigma^</em>)</span>. Hence, by Lemma 8.8 we get that <span class="math">y \\in S(D) \\cup \\{\\sigma^<em>\\}</span>. Since <span class="math">D \\in \\mathcal{P}_{\\sigma^</em>}</span>, we see that <span class="math">\\sigma \\in S(D)</span>, and so <span class="math">y \\in S(D)</span>.</li>

      <li>Case 2: <span class="math">D&#x27; \\in \\mathcal{P}_{\\sigma^<em>} \\cap \\mathcal{P}_{\\mathbf{E},\\sigma^</em>}</span>. Since <span class="math">D \\in \\mathcal{P}_{\\sigma^<em>}</span>, we have that <span class="math">\\sigma^</em> \\in \\mathrm{im}(D)</span>, and hence also in <span class="math">\\mathrm{im}(D&#x27;)</span>. Since <span class="math">\\sigma^<em></span> is in both <span class="math">\\mathrm{im}(D)</span> and <span class="math">\\mathrm{im}(D&#x27;)</span> and that <span class="math">D \\in \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma^</em>}</span> and <span class="math">D&#x27; \\in \\mathcal{P}_{\\mathbf{E},\\sigma^<em>}</span>, it follows that <span class="math">\\text{BCSExtract}(D, \\sigma^</em>) \\neq \\text{BCSExtract}(D&#x27;, \\sigma^<em>)</span>. Hence, by Lemma 8.8 we get that <span class="math">y \\in S(D)</span> or <span class="math">y = \\sigma^</em></span>. Since <span class="math">D \\in \\mathcal{P}_{\\sigma^<em>}</span>, it follows that <span class="math">(\\sigma^</em>, u&#x27;) \\in \\operatorname{supp}(D)</span> for some <span class="math">u&#x27; \\in \\{0,1\\}^\\lambda</span>, so <span class="math">\\sigma^* \\in S(D)</span>. Hence, <span class="math">y \\in S(D)</span>.</li>

    </ul>

    <p class="text-gray-300">We conclude that <span class="math">\\mathrm{flip}(\\overline{\\cup_{\\sigma}(\\mathcal{P}_{\\sigma}\\cap\\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})}\\mid \\bar{\\mathcal{P}}_{\\mathrm{col}},t) &amp;lt; 2t / 2^{\\lambda}</span>.</p>

    <p class="text-gray-300">Putting it together, we get that <span class="math">\\mathbf{I}(\\cup_{\\sigma}(\\mathcal{P}_{\\sigma}\\cap \\bar{\\mathcal{P}}_{\\mathbf{E},\\sigma})\\mid \\bar{\\mathcal{P}}_{\\mathrm{col}},t) &amp;lt; k + (2t + 1) / 2^{\\lambda}</span>.</p>

    <h2 id="sec-81" class="text-2xl font-bold">8.6 On the difference in hash chains</h2>

    <p class="text-gray-300">In the original BCS construction, the messages are generated "outside" of the hash chain. In the modified construction in this paper, we consider the messages as part of the hash chain. This is used by our proof technique, which forces the prover to "fix" the message in a given round before moving to the next, which allows us to argue from round-by-round soundness as defined in [CCHLRR18].</p>

    <p class="text-gray-300">We now describe how to prove soundness for the hash chain in [BCS16], provided that the underlying IOP satisfies a slightly stronger (and arguably natural) notion of round-by-round soundness. We change Definition 8.4 as follows (we make analogous modifications to Definition 8.5). We allow the verifier messages in a partial transcript to be <span class="math">\\perp</span> (i.e., undefined), and instead we now enforce that for transcripts <span class="math">\\mathbf{tr}</span> where the verifier is about to move, <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr}) = \\text{state}(\\mathbf{x},\\mathbf{tr} \\parallel \\perp)</span>, and that for any transcript <span class="math">\\mathbf{tr}</span> that has <span class="math">m_i = \\perp</span> for some <span class="math">i</span> and <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr}) = 0</span>, then with probability at most <span class="math">\\epsilon</span> it holds that <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr}&#x27;) = 1</span>, where <span class="math">\\mathbf{tr}&#x27;</span> is the transcript obtained by "filling in" <span class="math">m_i</span> with a uniformly random message. We note that this is a stronger notion of round-by-round soundness, as we can recover Definition 8.4 in the following way. For any transcript <span class="math">\\mathbf{tr}</span> where the verifier is about to move and <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr}) = 0</span>, one can first consider <span class="math">\\mathbf{tr} \\parallel \\perp</span>, which has <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr}) = 0</span>, and then "fill in" the last verifier message, which then shows that <span class="math">\\text{state}(\\mathbf{x},\\mathbf{tr} \\parallel m_i) = 1</span> with probability at most <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Like round-by-round soundness, this stronger definition is also satisfied by many natural protocols, such as the sumcheck protocol. Indeed, it seems that any natural protocol that is round-by-round sound should also be sound under this stronger definition. However, there exists a (contrived) protocol that has a large gap between its round-by-round soundness and "strong" round-by-round</p>

    <p class="text-gray-300">soundness, and one can show in general that this gap is maximal (this fact, proved in Appendix B, is due to James Hulett).</p>

    <p class="text-gray-300">Given this stronger soundness guarantee, the proof then proceeds as follows. The algorithm BCSExtract is modified to fit the new hash chain, and also so that it extracts the verifier messages (which are now not in the hash chain), including the verifier message for the next round. We then define <span class="math">\\mathcal{P}_{\\sigma}</span> to be the set of databases where <span class="math">D\\in\\bar{\\mathcal{P}}_{\\mathsf{col}}</span> and <span class="math">\\mathsf{state}(\\mathbf{x},\\mathsf{BCSExtract}(D,\\sigma))=1</span>. The rest of the proof is then nearly identical to the proof in Section 8.5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall from [Zha19] that the compressed phase oracle  <span class="math">\\mathcal{O}</span>  is defined as  <span class="math">\\mathsf{Dec} \\circ \\mathcal{O}&#x27; \\circ \\mathsf{Dec}</span>  where  <span class="math">\\mathcal{O}&#x27;</span>  is the unitary that acts as  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle \\mapsto (-1)^{u \\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle<span class="math">  (where  </span>u \\cdot \\bot \\coloneqq 0<span class="math"> ),  </span>\\mathsf{Dec}<span class="math">  is the unitary that acts as  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle \\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z\\rangle \\mathsf{Dec}_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle<span class="math"> , and  </span>\\mathsf{Dec}_x$  is defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {D e c} _ {x} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\right\\rangle := \\left\\{ \\begin{array}{l l} \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [ x \\mapsto y ] \\right\\rangle &amp; \\text {i f} D (x) = \\bot \\text {a n d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   t \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle &amp; \\text {i f} D (x) = \\bot \\text {a n d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\right\\rangle - \\frac {1}{\\sqrt {2 ^ {n}}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {0 ^ {n}} \\right\\rangle &amp; \\text {i f} D (x) \\neq \\bot \\end{array} \\right.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">D^{\\prime}\\coloneqq D - x</span>  , and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_w\\rangle \\coloneqq \\frac{1}{\\sqrt{2^n}}\\sum_y(-1)^{y\\cdot w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D' + [x\\mapsto y]\\rangle<span class="math">  , so that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D\\rangle = \\frac{1}{\\sqrt{2^n}}\\sum_w(-1)^{w\\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_w\\rangle<span class="math">  Note that  </span>\\mathsf{Dec}_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_w\\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_w\\rangle +\\left(\\frac{1}{2^n}\\sum_y(-1)^{y\\cdot w}\\right)(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'\\rangle -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{0^n}\\rangle)<span class="math">  , which equals  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_w\\rangle<span class="math">  for  </span>w\\neq 0^n<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\prime}\\rangle<span class="math">  for  </span>w = 0^n$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now prove each of the cases in the statement of Lemma 3.2. If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= t<span class="math"> , then  </span>\\mathsf{Dec}_x<span class="math">  does nothing, so  </span>\\mathcal{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle = \\mathcal{O}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle = (-1)^{u\\cdot D(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle<span class="math"> . If  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">  and  </span>u = 0^n<span class="math"> , then  </span>\\mathcal{O}'<span class="math">  does nothing. Since  </span>\\mathsf{Dec}_x \\circ \\mathsf{Dec}_x<span class="math">  is the identity, we get that  </span>\\mathcal{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,0^n,z,D\\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,0^n,z,D\\rangle$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, assume that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">  and  </span>u \\neq 0^n<span class="math"> . We first consider the case where  </span>D(x) = \\bot<span class="math"> . We apply Dec, then  </span>\\mathcal{O}'<span class="math"> , and then Dec again to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z, D\\rangle$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel {\\mathrm {D e c}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [ x \\mapsto y ] \\rangle</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel {\\mathcal {O} ^ {\\prime}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y} (- 1) ^ {u \\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [ x \\mapsto y ] \\rangle</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel {\\mathrm {D e c}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y} (- 1) ^ {u \\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + [ x \\mapsto y ] \\rangle ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">as the second application of Dec does nothing since  <span class="math">u \\neq 0^n</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, suppose  <span class="math">D(x) = y^{*}</span> . As before, we apply Dec, then  <span class="math">\\mathcal{O}&#x27;</span> , and then Dec again to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,u,z,D\\rangle$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\stackrel {\\mathrm {D e c}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle - \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {0 ^ {n}} \\rangle\\right) \\\\ =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle - \\frac {1}{2 ^ {n}} \\sum_ {y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} + [ x \\mapsto y ] \\rangle\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\stackrel {\\mathcal {O} ^ {\\prime}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left((- 1) ^ {u \\cdot y ^ {*}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle - \\frac {1}{2 ^ {n}} \\sum_ {y} (- 1) ^ {u \\cdot y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} + [ x \\mapsto y ] \\rangle\\right) \\\\ =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left((- 1) ^ {u \\cdot y ^ {*}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle - \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {u} \\rangle\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\stackrel {\\mathrm {D e c}} {\\longrightarrow}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left((- 1) ^ {u \\cdot y ^ {*}} \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle - \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {0 ^ {n}} \\rangle\\right) + \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {0 ^ {n}} \\rangle - \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {u} \\rangle\\right) \\\\ =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left((- 1) ^ {u \\cdot y ^ {*}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {(- 1) ^ {u \\cdot y ^ {*}}}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle + \\frac {(1 - (- 1) ^ {u \\cdot y ^ {*}})}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {0 ^ {n}} \\rangle - \\frac {1}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_ {u} \\rangle\\right) \\\\ =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x, u, z \\rangle \\otimes \\left((- 1) ^ {u \\cdot y ^ {*}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\rangle + \\frac {(- 1) ^ {u \\cdot y ^ {*}}}{\\sqrt {2 ^ {n}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} \\rangle + \\frac {1}{2 ^ {n}} \\sum_ {y} (1 - (- 1) ^ {u \\cdot y ^ {*}} - (- 1) ^ {u \\cdot y})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ^ {\\prime} + [ x \\mapsto y ] \\rangle\\right), \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">which completes the proof.</p>

    <p class="text-gray-300">B Round-by-round vs. strong round-by-round soundness</p>

    <p class="text-gray-300">An appendix authored by James Hulett (jhulett@berkeley.edu)</p>

    <p class="text-gray-300">We show a tight relation between the round-by-round soundness of an IOP and its “strong” round-by-round soundness (Section 8.6). First, we show a relationship between standard soundness and strong round-by-round soundness.</p>

    <p class="text-gray-300"><strong>Definition B.1.</strong> A (partial or full) transcript <span class="math">\\mathfrak{tr}</span> is complete if none of the verifier messages in <span class="math">\\mathfrak{tr}</span> are <span class="math">\\perp</span>.</p>

    <p class="text-gray-300"><strong>Lemma B.2.</strong> A <span class="math">k</span>-round IOP with soundness <span class="math">\\mu</span> has strong round-by-round soundness <span class="math">\\mu^{\\frac{1}{k + 1}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">(\\mathbf{P},\\mathbf{V})</span> be an IOP for a relation <span class="math">\\mathcal{R}</span> with soundness error at most <span class="math">\\mu</span>. For any <span class="math">\\mathbf{x} \\in \\mathcal{L}(\\mathcal{R})</span>, we let <span class="math">\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 1</span> if and only if <span class="math">\\mathfrak{tr}</span> has at least one verifier message that is not <span class="math">\\perp</span>. For any <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span>, we define <span class="math">\\text{state}</span> inductively as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every complete and full transcript <span class="math">\\mathfrak{tr} = (\\mathbf{m},\\mathbf{\\Pi})</span>, we set <span class="math">\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 1</span> if <span class="math">\\mathbf{V}^{\\Pi}(\\mathbf{x};\\mathbf{m}) = 1</span>.</li>

      <li>For <span class="math">j = 2k + 1, \\ldots, 0</span> and for <span class="math">i = 0, 1, \\ldots, k + 1</span>, for every <span class="math">\\mathfrak{tr}</span> with exactly <span class="math">j</span> messages (verifier and prover messages) and exactly <span class="math">i \\perp</span>'s, we set <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 1</span> if one of the following holds:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the last message in <span class="math">\\mathfrak{tr}</span> is a prover message and $\\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists some <span class="math">\\ell</span> such that <span class="math">m_{\\ell} = \\perp</span> and</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{m_{\\ell}}[\\text{state}(\\mathbf{x}, \\operatorname{tr}[m_{\\ell}]) = 1] &amp;gt; \\mu^{\\frac{1}{k + 1}} \\ ,</span></div>

    <p class="text-gray-300">where <span class="math">\\operatorname{tr}[m_{\\ell}]</span> is the transcript where we fill in <span class="math">m_{\\ell}</span> for the <span class="math">\\ell</span>-th verifier message in <span class="math">\\tau</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all other <span class="math">\\mathfrak{tr}</span>, <span class="math">\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathbf{x} \\in \\mathcal{L}(\\mathcal{R})</span>, we observe that <span class="math">\\text{state}</span> trivially satisfies all requirements for (strong) round-by-round soundness: the conditions of Definition 8.3 are satisfied, and we also trivially have that $\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = \\text{state}(\\mathbf{x}, \\mathfrak{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp)<span class="math">. Hence, for the remainder of the proof we will only consider </span>\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})<span class="math">. First, note that the function </span>\\text{state}<span class="math"> is well-defined, as the definition of </span>\\text{state}(\\mathbf{x}, \\mathfrak{tr})<span class="math"> always depends on </span>\\text{state}(\\mathbf{x}, \\mathfrak{tr}')<span class="math"> for </span>\\mathfrak{tr}'<span class="math"> that has either one more message or one fewer </span>\\perp<span class="math">, so </span>\\mathfrak{tr}'<span class="math"> will already be defined. We next show that this state function satisfies the stronger requirements of Definition 8.3 (as defined in Section 8.6). Items 2 and 3 are immediately satisfied by the definition of </span>\\text{state}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now show that $\\text{state}(\\mathbf{x},\\mathfrak{tr}) = \\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp)<span class="math">. We have by definition that if </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1<span class="math"> then </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 1<span class="math">. We show the other direction by induction on the number of </span>\\perp<span class="math">&#x27;s in </span>\\mathfrak{tr}<span class="math">. If </span>\\mathfrak{tr}<span class="math"> has no </span>\\perp<span class="math"> and </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 1<span class="math">, then it must be the case that </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1<span class="math">. For the induction step, if </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}) = 1<span class="math"> then either </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1<span class="math">, in which case we are done, or there exists </span>\\ell<span class="math"> such that </span>m_{\\ell} = \\perp<span class="math"> and </span>\\operatorname{Pr}_{m_{\\ell}}[\\text{state}(\\mathbf{x},\\mathfrak{tr}[m_{\\ell}]) = 1] &gt; \\mu^{\\frac{1}{k + 1}}<span class="math">. By the induction hypothesis, we have </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}[m_{\\ell}]) = \\text{state}(\\mathbf{x},\\mathfrak{tr}[m_{\\ell}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp)<span class="math">, which implies that </span>\\operatorname{Pr}_{m_{\\ell}}[\\text{state}(\\mathbf{x},\\mathfrak{tr}[m_{\\ell}]\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1] &gt; \\mu^{\\frac{1}{k + 1}}<span class="math">, and so </span>\\text{state}(\\mathbf{x},\\mathfrak{tr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7We note that this lemma is a strengthening of Proposition 5.5 from [CCHLRR18], and the proof here is a modification of the original.</p>

    <p class="text-gray-300">48</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It remains to show that Item 1 of Definition 8.3 is satisfied. Suppose for contradiction that it is not, so that there exists some <span class="math">\\mathbf{x} \\notin \\mathcal{L}(\\mathcal{R})</span> such that <span class="math">\\text{state}(\\mathbf{x}, \\emptyset) = 1</span>. We use this to create a malicious prover <span class="math">\\tilde{\\mathbf{P}}</span> as follows. <span class="math">\\tilde{\\mathbf{P}}</span> keeps track of an internal transcript <span class="math">\\mathfrak{tr}</span>, starting with <span class="math">\\mathfrak{tr} = \\emptyset</span>, and keeps track of a list of all the messages that the verifier has sent so far. Intuitively, <span class="math">\\tilde{\\mathbf{P}}</span> follows the definition of <span class="math">\\text{state}</span> and updates <span class="math">\\mathfrak{tr}</span> so that <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 1</span>. In what follows, we assume that <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr})</span> is always 1, and <span class="math">\\tilde{\\mathbf{P}}</span> aborts if this is not the case. When the verifier sends the message <span class="math">m_j</span> in the <span class="math">j</span>-th round, the internal transcript of <span class="math">\\tilde{\\mathbf{P}}</span> is some <span class="math">\\mathfrak{tr}</span> that has <span class="math">j - 1</span> rounds, and possibly some <span class="math">\\perp</span> verifier messages. <span class="math">\\tilde{\\mathbf{P}}</span> updates $\\mathfrak{tr} \\gets \\mathfrak{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp<span class="math"> (which has </span>\\text{state}(\\mathbf{x}, \\mathfrak{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\perp) = \\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 1<span class="math">), and then does the following loop: while there exists some </span>\\ell<span class="math"> such that </span>m_\\ell = \\perp$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{m_\\ell}[\\text{state}(\\mathbf{x}, \\mathfrak{tr}[m_\\ell]) = 1] &amp;gt; \\mu^{\\frac{1}{k + 1}} \\ ,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\tilde{\\mathbf{P}}</span> updates <span class="math">\\mathfrak{tr} \\gets \\mathfrak{tr}[m_\\ell]</span>, where <span class="math">m_\\ell</span> is the message sent by the verifier in the <span class="math">\\ell</span>-th round (<span class="math">\\ell \\leq j</span>) that <span class="math">\\tilde{\\mathbf{P}}</span> has stored. Let <span class="math">\\mathfrak{tr}</span> be the internal transcript after this loop terminates (which it must, as every iteration decreases the number of <span class="math">\\perp</span>'s in <span class="math">\\mathfrak{tr}</span> by 1). <span class="math">\\tilde{\\mathbf{P}}</span> then has a transcript <span class="math">\\mathfrak{tr}</span> where the prover is about to send the <span class="math">j</span>-th message, and the above does not apply. If <span class="math">j = k + 1</span>, then <span class="math">\\mathfrak{tr}</span> must be full and complete (as otherwise we would have <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 0</span>), so we are done. If <span class="math">j &amp;lt; k + 1</span>, then by definition of <span class="math">\\text{state}</span> there exists <span class="math">\\Pi_j</span> such that $\\text{state}(\\mathbf{x}, \\mathfrak{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_j) = 1<span class="math">. </span>\\tilde{\\mathbf{P}}<span class="math"> then updates </span>\\mathfrak{tr} \\gets \\mathfrak{tr} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_j<span class="math"> and sends </span>\\Pi_j$ to the verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We observe that the final transcript <span class="math">\\mathfrak{tr}</span> of the interaction of <span class="math">\\tilde{\\mathbf{P}}</span> with <span class="math">\\mathbf{V}</span> is the same as <span class="math">\\tilde{\\mathbf{P}}</span>'s final transcript. Hence, <span class="math">\\mathbf{V}</span> accepts if and only if <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 1</span>. We claim that this happens with probability greater than <span class="math">\\mu</span>. Indeed, for the internal execution of <span class="math">\\tilde{\\mathbf{P}}</span>, we see that for every iteration of the loop, the probability that the new transcript has state 1 is greater than <span class="math">\\mu^{\\frac{1}{k + 1}}</span>. This is because until we "fill in" the message <span class="math">m_j</span> in the internal transcript, the execution of <span class="math">\\tilde{\\mathbf{P}}</span> is independent of <span class="math">m_j</span>. Every iteration increases the number of non-<span class="math">\\perp</span> verifier messages in the internal transcript by 1, so this can only happen <span class="math">k + 1</span> times. Every time a prover message <span class="math">\\Pi_j</span> is sent, the resulting internal transcript always has state 1. Hence, <span class="math">\\operatorname{Pr}[\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 1] &amp;gt; \\left( \\mu^{\\frac{1}{k + 1}} \\right)^{k + 1} = \\mu</span>, which contradicts the soundness of the IOP.</p>

    <p class="text-gray-300">All that remains is to show that state satisfies the stronger version of Definition 8.4 (as defined in Section 8.6) with <span class="math">\\epsilon = \\mu^{\\frac{1}{k + 1}}</span>. For any incomplete transcript <span class="math">\\mathfrak{tr}</span> that has <span class="math">\\text{state}(\\mathbf{x}, \\mathfrak{tr}) = 0</span>, we have by definition of state that for every <span class="math">\\ell</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{m_\\ell}[\\text{state}(\\mathbf{x}, \\mathfrak{tr}[m_\\ell]) = 1] \\leq \\mu^{\\frac{1}{k + 1}} \\ ,</span></div>

    <p class="text-gray-300">which is exactly the requirement for strong round-by-round soundness.</p>

    <p class="text-gray-300">Using Lemma B.2, we now bound the strong round-by-round soundness of an IOP from its round-by-round soundness.</p>

    <p class="text-gray-300">Theorem B.3. A <span class="math">k</span>-round IOP with round-by-round soundness <span class="math">\\epsilon</span> has strong round-by-round soundness <span class="math">(k + 1)^{\\frac{1}{k + 1}} \\epsilon^{\\frac{1}{k + 1}}</span>.</p>

    <p class="text-gray-300">Proof. Suppose that <span class="math">(\\mathbf{P}, \\mathbf{V})</span> has round-by-round soundness <span class="math">\\epsilon</span>. By Proposition 5.4 of [CCHLRR18], <span class="math">(\\mathbf{P}, \\mathbf{V})</span> has standard soundness <span class="math">(k + 1)\\epsilon</span>. Applying Lemma B.2, we get that <span class="math">(\\mathbf{P}, \\mathbf{V})</span> has strong round-by-round soundness <span class="math">(k + 1)^{\\frac{1}{k + 1}} \\epsilon^{\\frac{1}{k + 1}}</span> as desired.</p>

    <p class="text-gray-300">8Note that this does not exactly match the proposition in [CCHLRR18] — but this is only because their notation has the prover going last, and thus omits the <span class="math">(k + 1)</span>-st verifier message.</p>

    <p class="text-gray-300">The following proposition shows that this bound is tight up to the factor of <span class="math">(k + 1)^{\\frac{1}{k + 1}}</span>. We note that <span class="math">(k + 1)^{\\frac{1}{k + 1}}</span> is always smaller than 1.5 (and approaches 1 as <span class="math">k \\to \\infty</span>), so this analysis is, in particular, tight up to a constant factor.</p>

    <p class="text-gray-300"><strong>Proposition B.4.</strong> For any <span class="math">k</span>, there exists a <span class="math">k</span>-round IOP with round-by-round soundness <span class="math">\\left(\\frac{1}{2}\\right)^{k+1}</span> that does not have strong round-by-round soundness <span class="math">\\frac{1}{2} - \\delta</span> for any <span class="math">\\delta &amp;gt; 0</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider the following protocol for the empty language. The first <span class="math">k</span> verifier messages consist of a single random bit <span class="math">b_{i}</span>. The final (ie, <span class="math">(k + 1)</span>-st) verifier message consists of <span class="math">k + 2</span> random bits, denoted <span class="math">b_{k + 1}</span> and <span class="math">b_1&#x27;, b_2&#x27;, \\ldots, b_{k + 1}&#x27;</span>. The verifier accepts iff <span class="math">b_{i} = b_{i}&#x27;</span> for every <span class="math">i</span>. This protocol has round-by-round soundness <span class="math">\\left(\\frac{1}{2}\\right)^{k + 1}</span>, as we can define <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}) = 1</span> if <span class="math">\\mathbf{tr}</span> is a full transcript that causes the verifier to accept, and <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}) = 0</span> otherwise.</p>

    <p class="text-gray-300">Now suppose this protocol had strong round-by-round soundness <span class="math">\\frac{1}{2} - \\delta</span> for some <span class="math">\\delta &amp;gt; 0</span>, and let <span class="math">\\text{state}</span> be the state function that witnesses this. Fixing some <span class="math">\\mathbf{x}</span> (certainly not in the empty language), we let <span class="math">\\mathbf{tr}_0</span> be the transcript that has all empty prover messages and <span class="math">\\perp</span> for every verifier message. Because <span class="math">\\text{state}(\\mathbf{x}, \\emptyset)</span> must be 0, <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_0)</span> must be 0 as well in order to have a valid state function. If we now sample the <span class="math">(k + 1)</span>-st verifier message, we will get <span class="math">b_{k + 1} = b_{k + 1}&#x27;</span> with probability <span class="math">\\frac{1}{2}</span>. However, we know the probability over <span class="math">m_{k + 1}</span> that <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_0[m_{k + 1}]) = 1</span> is at most <span class="math">\\frac{1}{2} - \\delta &amp;lt; \\frac{1}{2}</span>, so there must exist an <span class="math">m_{k + 1}</span> such that <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_0[m_{k + 1}]) = 0</span> and <span class="math">b_{k + 1} = b_{k + 1}&#x27;</span>. Let <span class="math">\\mathbf{tr}_1 := \\mathbf{tr}_0[m_{k + 1}]</span>.</p>

    <p class="text-gray-300">We now repeat this process for each round in reverse order. We start with some transcript <span class="math">\\mathbf{tr}_i</span> such that <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_i) = 0</span> and consider sampling randomness for the <span class="math">(k + 1 - i)</span>-th verifier message. With probability <span class="math">\\frac{1}{2}</span> we will sample an <span class="math">m_{k + 1 - i}</span> such that <span class="math">b_{k + 1 - i} = b_{k + 1 - i}&#x27;</span>, and with probability <span class="math">\\frac{1}{2} - \\delta</span> we will have <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_i[m_{k + 1 - i}]) = 1</span>, so there must exist an <span class="math">m_{k + 1 - i}</span> where the former holds but the latter does not. We then define <span class="math">\\mathbf{tr}_{i + 1} := \\mathbf{tr}_i[m_{k + 1 - i}]</span>. At the end, we get a (complete) transcript <span class="math">\\mathbf{tr}_{k + 1}</span> that causes the verifier to accept but has <span class="math">\\text{state}(\\mathbf{x}, \\mathbf{tr}_{k + 1}) = 0</span>. Hence, <span class="math">\\text{state}</span> cannot be a valid state function, and so our protocol does not have strong round-by-round soundness <span class="math">\\frac{1}{2} - \\delta</span>.</p>

    <p class="text-gray-300">Finally, we note that the constant <span class="math">\\frac{1}{2}</span> in Proposition B.4 was arbitrary. Indeed, for any rational <span class="math">\\epsilon = \\frac{p}{q}</span>, we could have gotten the same effect by (instead of sampling bits <span class="math">b_i</span>, <span class="math">b_i&#x27;</span> and checking if <span class="math">b_i = b_i&#x27;</span>) sampling <span class="math">x_i</span>, <span class="math">x_i&#x27;</span> from <span class="math">[q]</span> and checking if <span class="math">x_i - x_i&#x27;</span> (mod <span class="math">q</span>) &lt; <span class="math">p</span>.</p>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Chinmay Nirkhe for taking part in early stages of this research, and for providing valuable feedback. This research was supported in part by: a Google Faculty Award; the UC Berkeley Center for Long-Term Cybersecurity; the NSF Graduate Research Fellowship Program (under Grant No. DGE1745016); the ARCS Foundation; and donations from the Ethereum Foundation and the Interchain Foundation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.</p>

    <h2 id="sec-83" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[ALMSS98] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. “Proof verification and the hardness of approximation problems”. In: Journal of the ACM 45.3 (1998). Preliminary version in FOCS ’92., pp. 501–555.</li>

      <li>[ARU14] Andris Ambainis, Ansis Rosmanis, and Dominique Unruh. “Quantum Attacks on Classical Proof Systems: The Hardness of Quantum Rewinding”. In: Proceedings of the 55th Annual IEEE Symposium on Foundations of Computer Science. FOCS ’14. 2014, pp. 474–483.</li>

      <li>[AS04] Scott Aaronson and Yaoyun Shi. “Quantum lower bounds for the collision and the element distinctness problems”. In: Journal of the ACM 51.4 (2004), pp. 595–605.</li>

      <li>[AS98] Sanjeev Arora and Shmuel Safra. “Probabilistic checking of proofs: a new characterization of NP”. In: Journal of the ACM 45.1 (1998). Preliminary version in FOCS ’92., pp. 70–122.</li>

      <li>[BBCPGL18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyuba- shevsky. “Sub-linear Lattice-Based Zero-Knowledge Arguments for Arithmetic Circuits”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 669–699.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Scalable Zero Knowledge with No Trusted Setup”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: Proceedings of the 10th Theory of Cryptography Conference. TCC ’13. 2013, pp. 315–333.</li>

      <li>[BCRSVW19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. Full version available at https://eprint.iacr.org/2018/828. 2019, pp. 103–128.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BDFLSZ11] Dan Boneh, Özgür Dagdelen, Marc Fischlin, Anja Lehmann, Christian Schaffner, and Mark Zhandry. “Random Oracles in a Quantum World”. In: Proceedings of the 17th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’11. 2011, pp. 41–69.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. “Checking computations in polylogarithmic time”. In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing. STOC ’91. 1991, pp. 21–32.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BHT98] Gilles Brassard, Peter Høyer, and Alain Tapp. “Quantum Cryptanalysis of Hash and Claw-Free Functions”. In: Proceedings of the 3rd Latin American Symposium on Theoretical Informatics. LATIN ’98. 1998, pp. 163–169.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BISW17] Dan Boneh, Yuval Ishai, Amit Sahai, and David J. Wu. “Lattice-Based SNARGs and Their Application to More Efficient Obfuscation”. In: Proceedings of the 36th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’17. 2017, pp. 247–277.</li>

      <li>[BISW18] Dan Boneh, Yuval Ishai, Amit Sahai, and David J. Wu. “Quasi-Optimal SNARGs via Linear Multi-Prover Interactive Proofs”. In: Proceedings of the 37th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’18. 2018, pp. 222–255.</li>

      <li>[BN19] Carsten Baum and Ariel Nof. Concretely-Efficient Zero-Knowledge Arguments for Arithmetic Circuits and Their Application to Lattice-Based Cryptography. Cryptology ePrint Archive, Report 2019/532. 2019.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</li>

      <li>[Bab85] László Babai. “Trading group theory for randomness”. In: Proceedings of the 17th Annual ACM Symposium on Theory of Computing. STOC ’85. 1985, pp. 421–429.</li>

      <li>[CCHLRR18] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, and Ron D. Rothblum. Fiat–Shamir From Simpler Assumptions. Cryptology ePrint Archive, Report 2018/1004. 2018.</li>

      <li>[CDGORRSZ17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. “Post-Quantum Zero-Knowledge and Signatures from Symmetric-Key Primitives”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 1825–1842.</li>

      <li>[Co17] O(1) Labs. Coda Cryptocurrency. https://codaprotocol.com/. 2017.</li>

      <li>[DFG13] Özgür Dagdelen, Marc Fischlin, and Tommaso Gagliardoni. “The Fiat-Shamir Transformation in a Quantum World”. In: Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’13. 2013, pp. 62–81.</li>

      <li>[DFKNS92] Cynthia Dwork, Uriel Feige, Joe Kilian, Moni Naor, and Shmuel Safra. “Low Communication 2-Prover Zero-Knowledge Proofs for NP”. In: Proceedings of the 11th Annual International Cryptology Conference. CRYPTO ’92. 1992, pp. 215–227.</li>

      <li>[DFMS19] Jelle Don, Serge Fehr, Christian Majenz, and Christian Schaffner. “Security of the Fiat–Shamir Transformation in the Quantum Random-Oracle Model”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 356–383.</li>

      <li>[DJ92] David Deutsch and Richard Jozsa. “Rapid solution of problems by quantum computation”. In: Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439.1907 (1992), pp. 553–558.</li>

      <li>[Eat17] Edward Eaton. “Leighton-Micali Hash-Based Signatures in the Quantum Random-Oracle Model”. In: Proceedings of the 24th International Conference on Selected Areas in Cryptography. SAC ’17. 2017, pp. 263–280.</li>

      <li>[FGLSS96] Uriel Feige, Shafi Goldwasser, Laszlo Lovász, Shmuel Safra, and Mario Szegedy. “Interactive proofs and the hardness of approximating cliques”. In: Journal of the ACM 43.2 (1996). Preliminary version in FOCS ’91., pp. 268–292.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: Proceedings of the 6th Annual International Cryptology Conference. CRYPTO ’86. 1986, pp. 186–194.</li>

      <li>[GH98] Oded Goldreich and Johan Håstad. “On the complexity of interactive proofs with bounded communication”. In: Information Processing Letters 67.4 (1998), pp. 205–214.</li>

      <li>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: Journal of the ACM 62.4 (2015), 27:1–27:64.</li>

    </ul>

    <p class="text-gray-300">[GMNO18] Rosario Gennaro, Michele Minelli, Anca Nitulescu, and Michele Orrù. “Lattice-Based zk-SNARKs from Square Span Programs”. In: <em>Proceedings of the 25th ACM Conference on Computer and Communications Security</em>. CCS ’18. 2018, pp. 556–573.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. “The knowledge complexity of interactive proof systems”. In: <em>SIAM Journal on Computing</em> 18.1 (1989). Preliminary version appeared in STOC ’85., pp. 186–208.</li>

      <li>[GVW02] Oded Goldreich, Salil Vadhan, and Avi Wigderson. “On interactive proofs with a laconic prover”. In: <em>Computational Complexity</em> 11.1/2 (2002), pp. 1–53.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. “Separating Succinct Non-Interactive Arguments From All Falsifiable Assumptions”. In: <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>. STOC ’11. 2011, pp. 99–108.</li>

      <li>[Gro96] Lov K. Grover. “A Fast Quantum Mechanical Algorithm for Database Search”. In: <em>Proceedings of the 28th Annual ACM Symposium on Theory of Computing</em>. STOC ’96. 1996, pp. 212–219.</li>

      <li>[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. <em>On Zero-Knowledge PCPs: Limitations, Simplifications, and Applications</em>. Available at http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf. 2015.</li>

      <li>[KKW18] Jonathan Katz, Vladimir Kolesnikov, and Xiao Wang. “Improved Non-Interactive Zero Knowledge with Applications to Post-Quantum Signatures”. In: <em>Proceedings of the 25th ACM Conference on Computer and Communications Security</em>. CCS ’18. 2018, pp. 525–537.</li>

      <li>[KLS18] Eike Kiltz, Vadim Lyubashevsky, and Christian Schaffner. “A Concrete Treatment of Fiat-Shamir Signatures in the Quantum Random-Oracle Model”. In: <em>Proceedings of the 37th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’17. 2018, pp. 552–586.</li>

      <li>[KPT97] Joe Kilian, Erez Petrank, and Gábor Tardos. “Probabilistically checkable proofs with zero knowledge”. In: <em>Proceedings of the 29th Annual ACM Symposium on Theory of Computing</em>. STOC ’97. 1997, pp. 496–505.</li>

      <li>[KR08] Yael Kalai and Ran Raz. “Interactive PCP”. In: <em>Proceedings of the 35th International Colloquium on Automata, Languages and Programming</em>. ICALP ’08. 2008, pp. 536–547.</li>

      <li>[Kil92] Joe Kilian. “A note on efficient zero-knowledge proofs and arguments”. In: <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>. STOC ’92. 1992, pp. 723–732.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: <em>Journal of the ACM</em> 39.4 (1992), pp. 859–868.</li>

      <li>[LZ19] Qipeng Liu and Mark Zhandry. “Revisiting Post-Quantum Fiat–Shamir”. In: <em>Proceedings of the 39th Annual International Cryptology Conference</em>. CRYPTO ’19. 2019, pp. 326–355.</li>

      <li>[Mer89] Ralph C. Merkle. “A certified digital signature”. In: <em>Proceedings of the 9th Annual International Cryptology Conference</em>. CRYPTO ’89. 1989, pp. 218–238.</li>

      <li>[Mic00] Silvio Micali. “Computationally Sound Proofs”. In: <em>SIAM Journal on Computing</em> 30.4 (2000). Preliminary version appeared in FOCS ’94., pp. 1253–1298.</li>

      <li>[NIS16] NIST. <em>Post-Quantum Cryptography</em>. 2016. url: https://csrc.nist.gov/Projects/Post-Quantum-Cryptography.</li>

      <li>[PS96] David Pointcheval and Jacques Stern. “Security Proofs for Signature Schemes”. In: <em>Proceedings of the 14th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’96. 1996, pp. 387–398.</li>

      <li>[Pas03] Rafael Pass. “On Deniability in the Common Reference String and Random Oracle Model”. In: <em>Proceedings of the 23rd Annual International Cryptology Conference</em>. CRYPTO ’03. 2003, pp. 316–337.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: <em>Proceedings of the 48th ACM Symposium on the Theory of Computing</em>. STOC ’16. 2016, pp. 49–62.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[SCI14] SCIPR Lab. <em>libsnark: a C++ library for zkSNARK proofs</em>. 2014. url: https://github.com/scipr-lab/libsnark.</li>

      <li>[SCI18] SCIPR Lab. <em>DIZK: Java library for distributed zero knowledge proof systems</em>. 2018. url: https://github.com/scipr-lab/dizk.</li>

      <li>[SCI19] SCIPR Lab. <em>libiop: C++ library for IOP-based zkSNARKs</em>. 2019. url: https://github.com/scipr-lab/libiop.</li>

      <li>[TU16] Ehsan Ebrahimi Targhi and Dominique Unruh. “Post-Quantum Security of the Fujisaki–Okamoto and OAEP Transforms”. In: <em>Proceedings of the 14th Theory of Cryptography Conference</em>. TCC ’16-B. 2016, pp. 192–216.</li>

      <li>[Unr15] Dominique Unruh. “Non-Interactive Zero-Knowledge Proofs in the Quantum Random Oracle Model”. In: <em>Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’15. 2015, pp. 755–784.</li>

      <li>[Unr17] Dominique Unruh. “Post-quantum Security of Fiat-Shamir”. In: <em>Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security</em>. ASIACRYPT ’17. 2017, pp. 65–95.</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: <em>Proceedings of the 5th Theory of Cryptography Conference</em>. TCC ’08. 2008, pp. 1–18.</li>

      <li>[WB15] Michael Walfish and Andrew J. Blumberg. “Verifying Computations Without Reexecuting Them”. In: <em>Communications of the ACM</em> 58.2 (Jan. 2015), pp. 74–84.</li>

      <li>[Wat09] John Watrous. “Zero-Knowledge against Quantum Attacks”. In: <em>SIAM Journal on Computing</em> 39.1 (2009). Preliminary version appeared in STOC ’06., pp. 25–58.</li>

      <li>[ZKP17] ZKP Standards. <em>Zero Knowledge Proof Standardization</em>. https://zkproof.org/. 2017.</li>

      <li>[Zc14] Electric Coin Company. <em>Zcash Cryptocurrency</em>. https://z.cash/. 2014.</li>

      <li>[Zha12] Mark Zhandry. “Secure Identity-Based Encryption in the Quantum Random Oracle Model”. In: <em>Proceedings of the 32nd Annual International Cryptology Conference</em>. CRYPTO ’12. 2012, pp. 758–775.</li>

      <li>[Zha15] Mark Zhandry. “A note on the quantum collision and set equality problems”. In: <em>Quantum Information &amp; Computation</em> 15.7&amp;8 (2015), pp. 557–567.</li>

      <li>[Zha19] Mark Zhandry. “How to Record Quantum Queries, and Applications to Quantum Indifferentiability”. In: <em>Proceedings of the 39th Annual International Cryptology Conference</em>. CRYPTO ’19. 2019, pp. 239–268.</li>

      <li>[bell15] Sean Bowe. <em>bellman: a zk-SNARK library</em>. 2015. url: https://github.com/zkcrypto/bellman.</li>

      <li>[dalek18] dalek cryptography. <em>A pure-Rust implementation of Bulletproofs using Ristretto</em>. 2018. url: https://github.com/dalek-cryptography/bulletproofs.</li>

      <li>[iden19] iden3. <em>websnark: A fast zkSNARK proof generator written in native Web Assembly</em>. 2019. url: https://github.com/iden3/websnark.</li>

      <li>[stark18] libstark. <em>libstark: a C++ library for zkSTARK systems</em>. 2018. url: https://github.com/elibensasson/libSTARK.</li>

    </ul>`;
---

<BaseLayout title="Succinct Arguments in the Quantum Random Oracle Model (2019/834)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/834
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
