---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1038';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Reinforced Concrete: A Fast Hash Function for Verifiable Computation';
const AUTHORS_HTML = 'Lorenzo Grassi, Dmitry Khovratovich, Reinhard L&uuml;ftenegger, Christian Rechberger, Markus Schofnegger, Roman Walch';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We propose a new hash function Reinforced Concrete, which is the first generic purpose hash that is fast both for a zero-knowledge prover and in native x86 computations. It is suitable for a various range of zero-knowledge proofs and protocols, from set membership to generic purpose verifiable computation. Being up to 15x faster than its predecessor Poseidon hash, Reinforced Concrete inherits security from traditional time-tested schemes such as AES, whereas taking the zero-knowledge performance from a novel and efficient decomposition of a prime field into compact buckets.

The new hash function is suitable for a wide range of applications like privacy-preserving cryptocurrencies, verifiable encryption, protocols with state membership proofs, or verifiable computation. It may serve as a drop-in replacement for various prime-field hashes such as variants of MiMC, Poseidon, Pedersen hash, and others.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> hash functions &middot; verifiable computation &middot; zk- snarks &middot; finite fields</p>
    </section>

    <p class="text-gray-300">SNARKs and hash functions. The recent years have been marked as a thrive of distributed verifiable computation, where the outcome of some algorithm  <span class="math">\\mathcal A</span>  is accompanied with a succinct proof of correctness, widely known as a SNARK [47, 58, 62]. Performance of those protocols, however, remains a major bottleneck for applications. The reasons are manyfold, but one crucial point is that SNARKs are constructed for statements formulated over prime fields whereas regular computer programs are written for and executed over bitstrings. The necessary translation of code into finite field arithmetic carries a significant overhead. A notable example is the cost of computing 70 SHA-256 hash function calls, which were needed to transfer Zcash [3] cryptocurrency privately back in 2017,</p>

    <p class="text-gray-300">CCS '22, November 7&ndash;11, 2022, Los Angeles, CA, USA</p>

    <p class="text-gray-300">This is the author's version of the work. It is posted here for your personal use. Not for redistribution. The definitive Version of Record was published in <em>Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (CCS '22), November 7&ndash;11, 2022, Los Angeles, CA, USA</em>, https://doi.org/10.1145/3548606.3560686.</p>

    <p class="text-gray-300">and which took over 40 seconds to create such a SNARK, compared to 10 microseconds of native computation on a PC. Thus, the design of various cryptographic primitives tailored for operating over finite fields is an active research area [6, 7, 41].</p>

    <p class="text-gray-300">In this paper we remove one of such bottlenecks by offering a hash function that is fast both for SNARKs and native computation. There already exist functions that excel in either of those areas, but not in both. The motivation for such a swissarmy tool is the following. To scale, parallelize, and aggregate proofs we employ what is called a recursive proof protocol [21, 25-27], where a party can prove their share of computation together with a verification of proof coming from the predecessor. This also enables wrapping multiple proofs into a single succinct check. Notably, however, many such recursive protocols require both hashing the input of a party with Merkle tree and proving some openings of the tree in zeroknowledge (ZK). Thus, whatever hash function is selected for the tree, it must be fast in both scenarios. To make a concrete example, one of the most ZK-efficient hash functions to date, Poseidon [41], when plugged into the Fractal recursive protocol, makes the prover 100 times more expensive just because it is slow in the native x86 computation [27, Section 13.2].</p>

    <p class="text-gray-300"><em>Summary of use cases.</em> In more details, our new hash function will address, among others, the following use cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Fast and efficient set membership proofs based on Merkle tree accumulators. Immensely popular in cryptocurrency protocols [2, 3, 61], this case requires a hash function for the tree. Parties  <span class="math">P_1, P_2, \\ldots, P_n</span>  add entries  <span class="math">V_1, V_2, \\ldots, V_k</span>  to some public accumulator  <span class="math">\\mathfrak{A}</span> . Then at any point any party  <span class="math">P_j</span>  can prove that  <span class="math">V_i \\in \\mathfrak{A}</span> . For instance, in Zcash [3]  <span class="math">V_i</span>  are unspent transactions and  <span class="math">\\mathfrak{A}</span>  is a Merkle tree over them, so that in order to spend transaction V an owner is required to provide a proof of knowledge that  <span class="math">V \\in \\mathfrak{A}</span>  as well as a proof of knowledge of some secret committed within V. Its ZK circuit should minimize the proof creation time.</li>
      <li><strong>Verifiable computation</strong> based on recursive proofs. Here the entire computation is a chain of functions  <span class="math">F_1, F_2, \\dots, F_k</span>  applied consecutively to some state. Starting with X, for each i Party  <span class="math">P_i</span>  computes  <span class="math">F_i</span>  and carries an intermediate result and a proof of correctness to the next  <span class="math">P_{i+1}</span>  so that the last  <span class="math">P_k</span>  provides Y and attests X  <span class="math">\\xrightarrow{F_k \\circ F_{k-1} \\circ \\cdots \\circ F_1} Y</span>  being actually aware</li>
    </ul>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;\\&lt;/sup&gt;label{lem:condition} {\\it \`Author list in alphabetical order; see https://www.ams.org/profession/leaders/CultureStatement04.pdf.}</span></p>

    <p class="text-gray-300"><sup>&copy; 2022</sup> Copyright held by the owner/author(s).</p>

    <p class="text-gray-300">only of their own computation and the proof of correctness  <span class="math">\\pi_{k-1}</span>  from  <span class="math">P_{k-1}</span> . Verifiable computation frameworks such as Halo Infinite [21] or Fractal [27] instruct that the proof  <span class="math">\\pi_k</span>  asserts the correctness of  <span class="math">F_k</span>  and that the code  <span class="math">C_k</span>  that verifies  <span class="math">\\pi_{k-1}</span>  outputs a success. If the inner commitment scheme is Merkle-tree-based (such as FRI [12]), then  <span class="math">\\pi_{k-1}</span>  consists of several Merkle tree openings, so that  <span class="math">C_k</span>  makes a number of calls to the hash function that comprises the tree. Here we minimize both native computation time and the prover time.</p>

    <p class="text-gray-300">Both use cases require a cryptographically secure hash function, i.e., it should resist preimage and collision attacks.</p>

    <p class="text-gray-300"><em>Summary of requirements.</em> We summarize the requirements stemming from the use cases as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Minimal prover time. For many ZK proof systems it is a (super)linear function of the gate count, where each gate is usually a basic field arithmetic operation or, in some systems, a table lookup [13, 34, 35, 47, 62]. Though the actual performance depends significantly on the proof system chosen and an application, the mere number of standard gates is a good approximation. It is known that custom gates (lookup high-degree polynomials) may increase the performance up to the factor of 10, but those are function-specific and can't be reasonably compared across distinct proof systems. In Table 1 we provide a count in R1CS constraints (roughly, the number of field multiplications), in standard Plookup gates (each gate contains either a single multiplication and an arity-4 addition, or a table lookup), and in area-degree product (each custom gate contributes to the cost additively with the product of input size and the degree of the polynomial that describes the gate constraint). Unfortunately, we can't provide a sound prover time benchmark since at the moment of submission no production-ready proof system that supports lookups is available though specifications</li>
      <li>Native performance. A hash function is supposed to run as fast as possible on typical hardware where proofs are created, which are regular laptops and desktops nowadays. The Fractal use case [27] implies that it should be at least 10x faster than Poseidon.</li>
      <li>Security. The common approach [6, 41] is to provide evidence that the existing attacks fail. However, as algebraic attacks [4, 40] are the most natural for finite-field-based designs, it becomes increasingly difficult to estimate the security as the performance of those attacks is highly volatile [11, 64]. It is thus desirable to base the security of a new hash function on a more traditional [60] rather than algebraic security analysis.</li>
    </ul>

    <p class="text-gray-300">State of the art. There already exist several hash functions crafted for the first use-case with the number of circuit gates (or equivalently low-degree polynomial constraints) being the primary metric. Examples include prime-field (Feistel) MiMC versions [5, 6], FRIDAY [8], POSEIDON [41], RESCUE [7] (and its updated version RESCUE-Prime [7]), Griffin [39], Grendel [65], and NEPTUNE [43]. Many of these hash functions share some common features, as the fact that</p>

    <p class="text-gray-300">the non-linear layer is instantiated via a simple power map. Focusing on Poseidon, it is based on the Hades design strategy [42], which makes use of an uneven distribution of the S-boxes, namely, full S-box layers in the external rounds and partial S-box layers in the middle ones, in order to minimize the multiplicative complexity. The external rounds provide security against statistical attacks, while the internal rounds have the goal of increasing the degree of the permutation. A rather recent addition to this set is SINSEMILLA [3, Sec. 5.4.1.9], an instance of the Pedersen hash function[3, Sec. 5.4.1.7] optimized for table lookups in custom gates.</p>

    <p class="text-gray-300">While most of them have withstood public scrutiny [4, 11, 16, 33, 46, 51], the plain performance is not satisfactory (see last column of Table 1), since each round of such schemes requires a finite field multiplication, which is relatively expensive (hundreds of CPU cycles) compared to bit operations utilized in traditional hash functions.</p>

    <p class="text-gray-300">Our design: Reinforced Concrete. We present a new sponge hash function Reinforced Concrete, in short RC, over  <span class="math">\\mathbb{F}_p</span>  exploiting all the advantages of lookup-equipped proof systems and suitable for both membership proofs and verifiable computation use cases. The permutation that instantiates RC is composed of two types of components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) outer ones for preventing statistical attacks;</li>
      <li>(2) an inner one for preventing algebraic attacks.</li>
    </ul>

    <p class="text-gray-300">The inner part strengthens the whole construction like steel bars strengthen concrete, hence the name of the function and its components.</p>

    <p class="text-gray-300">For the inner component, instead of using simple power maps as in Poseidon and Rescue, we use a single building block with a complex algebraic structure, which we call Bars. A Bars layer can be seen as a non-linear layer composed of independent high-degree and dense S-boxes. The Bars function combines a layer of S-boxes (such as in AES) with a field element decomposition in just a handful of small operations (or table gates in the circuit), and it admits a very simple representation when using look-up tables, as e.g. in the case of AES [32] and AES-like ciphers. As a result, the security argument we propose for preventing algebraic attacks including interpolation [50] and Grobner basis attacks [30] resembles the one well known and accepted in the literature for AES and more generally AES-like ciphers, for which the algebraic attacks can attack only a tiny fraction of the rounds compared to the statistical attacks [28, 29].</p>

    <p class="text-gray-300">Even if it prevents algebraic attacks, it can be broken by more traditional statistical attacks such as rebound attacks [55, 60]. As those are much better studied, we instantiated the external rounds with other layers which are known to protect against statistical attacks, including affine layers called Concrete that provides full diffusion and low-degree non-linear layer called Bricks, which both provides (non-linear) diffusion and ensure security against statistical attacks.</p>

    <p class="text-gray-300">Our approach to performance. We tackle the performance issue by making the Bars layer fast in the native computation. For this we managed to avoid field multiplications altogether in this layer and do only a bunch modular reductions by small moduli instead, followed by compact S-boxes. The performance of our design varies for different fields we operate on, but is in the range of 2-9x overhead over the popular SHA-256.</p>

    <p class="text-gray-300"><em>Our approach to compactness.</em> We tackle the prover time issue by providing an efficient lookup-based implementation of highly-nonlinear Bars, which is therefore one of <em>main contributions</em> of this submission. Concretely, it is the first primitive that is highly nonlinear, compact, and fast at the same time. For S-boxes of size  <span class="math">2^{9.5}</span> , we make only 126 lookups to process 510 bits of data, which is not far from the optimal  <span class="math">510/9.5 \\approx 53</span> .</p>

    <p class="text-gray-300">Comparison to other designs. When compared to the hash functions tailored to the same use cases, we are on par in the gate metric and are much faster in the native performance.</p>

    <p class="text-gray-300">The performance can be improved in certain fields, and we show how to craft a prime to increase performance further. Even over generic prime fields (such as the scalar fields of the BLS12-381 or BN254 elliptic curves) RC is faster by a factor of 5 compared to Poseidon and by a factor of 140 compared to Rescue and 120 compared to Rescue-Prime. Using specially crafted fields increases these factors to 16, 357, and 289 respectively. RC is, thereby, only by a factor of 5 slower than Blake2, the fastest traditional hash algorithm we benchmarked, but requires 7 times less gates when encoded into a circuit.</p>

    <p class="text-gray-300">Compared to Pedersen hash/SINSEMILLA we provide pre-image resistance in addition to collision resistance. Also we rely on the public scrutiny rather than on (pre-quantum) hardness assumptions.</p>

    <p class="text-gray-300">From the design perspective, one can view the collision resistant but slower Sinsemilla as an alternative to the Bars layer, as both are not preimage resistant in isolation. Whether it is possible to take the best from both designs, remains the subject of future work.</p>

    <p class="text-gray-300">Regarding security analysis, the new design offers reasonably big security margin against statistical attacks, but at the same time much bigger margin against algebraic attacks. Since the latter are less explored, we conclude that RC is more robust against possible breakthroughs in algebraic analysis. On the other hand, the most recent algebraic cryptanalysis of weakened Poseidon and Rescue-Prime [11] has proven to be memory-intensive and thus less practical than can be expected.</p>

    <p class="text-gray-300">Supported proof systems. Whereas some ZK proof systems explicitly work with arithmetic gates (i.e. field additions and multiplications) only [47, 62], a number of protocols also support lookup tables. Those include Arya [22], Plookup [34, 63], Halo2 [3], Cairo [37]. As lookup gates also speed up traditional hash functions like SHA-2, we expect such protocols to become widespread in the near future.</p>

    <p class="text-gray-300">Restrictions and Future Work. Whereas RC clearly brings high native and ZK performance, it also has its own restrictions. First of all, a proof system should support lookup gates, as otherwise the RC circuit would be quite big (we estimate it to be around 5000 constraints). Secondly the Bar's component is specific for each field, which implies a bit of work when carrying it to a proof system with a new curve. Devising a more generic Bar's is the subject of the future work. Another interesting direction is non-sponge instances of RC.</p>

    <p class="text-gray-300">    <img src="_page_2_Picture_11.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: A sponge hash function with a fixed-size output. In our case IV is a 3-tuple of zero  <span class="math">\\mathbb{F}_p</span>  elements,  <span class="math">m_i</span>  are message chunks to be hashed (2  <span class="math">\\mathbb{F}_p</span>  elements each),  <span class="math">\\oplus</span>  is the elementwise addition in the field,  <span class="math">h_i</span>  are hash outputs.</p>

    <p class="text-gray-300">Summary of the paper. We describe RC on a high level in Section 2. Then we give formal security definitions and claims regarding the security of RC in Section 3. A more detailed rationale and specification follows in Section 4. We proceed with a summary of our own cryptanalysis in Section 5 (which is detailed in Appendix). Then we present a constraint system (needed to build a circuit for ZK proofs) for RC and prove its correctness and soundness (Section 6). We conclude the main body of the paper with the benchmarks. Details of RC instances for different fields and details of cryptanalysis are presented in Appendix.</p>

    <p class="text-gray-300">The RC hash function operates in the sponge framework (Fig. 1). The sponge converts a fixed length bijective function (called RC permutation) to a variable-length hash function, which is collision- and preimage-resistant as long as the underlying permutation does not exhibit any 'non-random' properties up to the bound defined by the security level  <span class="math">2^{\\lambda}</span>  (in our case  <span class="math">\\lambda</span>  is universally set to 128).</p>

    <p class="text-gray-300">The RC permutation illustrated in Fig. 2, can be considered as a modified 7-round SP network, where input, output and intermediate state elements are from  <span class="math">\\mathbb{F}_p^3</span>  for a prime number p. More formally,</p>

    <p class="text-gray-300">RC := Concrete<sup>(8)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(7)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(6)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(5)</sup>  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete<sup>(4)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(3)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(2)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(1)</sup></p>

    <p class="text-gray-300">In the following, we refer to Concrete o Bricks as &quot;round&quot;.</p>

    <p class="text-gray-300">We define RC for different p, with two (-BN and -BLS) being scalar fields of the curves BN254 [69] and BLS12-381<sup>1</sup> and another one (-ST) crafted for a specially chosen field in order to deliver the highest performance. We elaborate how to craft an instance in Section 4.</p>

    <p class="text-gray-300">We reserve 1 field element for the capacity in sponge, thus aiming for the 128-bit security against collision and preimage attacks for all instances. A single call to RC thus suffices for a 2-to-1 compression function.</p>

    <p class="text-gray-300"><em>Design.</em> The RC design depicted in Figure 2 is a modification of a traditional word-oriented SP-network (SPN) for constructing (keyed</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>https://electriccoin.co/blog/new-snark-curve/</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Performance</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Native</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">R1CS   Plookup   Area-degree</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">eq-s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">reg. gates</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">product</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(&micro;s)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">243</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">633</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9495</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">288</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7200</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">480</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue-Prime</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">252</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">252 420 6300</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">415</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Feistel-MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1326</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1326</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19890</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Griffin</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">186</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2790</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Neptune</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">228</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1137</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17055</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27534</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.32</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21006</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.21</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pedersen hash</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">869</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13035</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sinsemilla</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">510</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1530</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Reinforced Concrete-BN/BLS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">378</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5670</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Reinforced Concrete-ST</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">360</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5400</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.09</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Performance of various hash functions in the zero knowledge (preimage proof) and native (hashing 512 bits of data) settings. All native benchmarks are ours (Section 8.2). Poseidon, Rescue, Rescue-Prime, Feistel-MIMC, Neptune, and Griffin gate counts are ours (Section 8.1.2). SHA-256 and Blake2s R1CS gate counts are from Hopwood's notes [49], and their Plookup costs as well as the area-degree product is taken from the report by Williamson [68]. Pedersen hash gate count is taken from the Zcash protocol [3], and the area-degree product is calculated using the same factor of 15 as for Poseidon. The Sinsemilla regular gate count by us is Section 8.1.2, whereas the area-degree optimized version is from [24].</p>

    <p class="text-gray-300">or keyless) cryptographic permutations. The RC design differs from a traditional SPN in two aspects:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the middle layer of the SP network is replaced by a special component called Bars. This special component effectively reinforces the permutation against cryptanalytic approaches that would cover many more rounds without Bars. It does not admit a low-degree polynomial description but can be implemented as a circuit with reasonable costs in ZK.</li>
      <li>instead of applying independent non-linear transformations on single words, RC uses (low-degree) non-linear layers, called Bricks, that additionally mix different words. Bricks used the same construction as Horst [39]. It provides resistance against statistical cryptanalysis and is cheap in the zero knowledge, i.e. via gate counting.</li>
    </ul>

    <p class="text-gray-300">The third component, Concrete, is an analog of the traditional affine layer but over  <span class="math">\\mathbb{F}</span> . It ensures diffusion to make statistical or algebraic properties expand to the entire state, and is also cheap in ZK.</p>

    <p class="text-gray-300">Layout. The Bricks and Concrete layers interleave exactly as in traditional SPN designs [32]. As RC is used in a sponge framework, the Bricks components at either end would bring no security against collision or preimage attacks, so we start and end with Concrete. The middle call to Bricks is replaced with Bars. The rationale behind putting all Bar into a single layer is that start-fromthe-middle attacks are somewhat easier to find and thus we plan to detect them all in the design phase.</p>

    <p class="text-gray-300">Our high-level security claims, which determine the parameter selection for RC, are the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the sponge hash function with RC, we aim for a collision and preimage resistance up to 2<sup>128</sup> field operations for 256-bit fields. We want to be able to instantiate a random oracle in protocols up to 2<sup>128</sup> calls.</li>
      <li>For the authenticated encryption scheme using RC, we aim for confidentiality and integrity up to 2<sup>128</sup> encrypted messages for 256-bit fields.</li>
      <li>When using the RC in other future schemes, we aim for a 1-element CICO security [48] up to  <span class="math">2^{128}</span>  field operations. More concretely, it should be infeasible to find such  <span class="math">x_1, x_2, y_1, y_2</span>  such that</li>
    </ul>

    <p class="text-gray-300"><span class="math">$RC(0, x_1, x_2) = (0, y_1, y_2)</span>$</p>

    <p class="text-gray-300">The story behind the design of RC, which has determined its inner components is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We wanted to design a hash function which has a high degree as a polynomial and would not allow a treatment with algebraic methods such as Grobner basis.</li>
      <li>We were aware how table lookups can be used to implement hash functions that are highly non-linear and resistant to algebraic attacks &ndash; such as Blake2 and SHA-256. We seek to have similar functionality but applied to finite field elements rather than 32/64/128/256-bit words. For this we had to design an efficient way to decompose a field element into smaller chunks, apply some nonlinear transformation, and then wrap it back (composition). This was to become Bars.</li>
      <li>It turned out that in order to avoid overflows at composition, the nonlinear transformation within Bars should have a certain number of fixed points, and there must not be many of them for security. This yielded an heuristic method for finding a decomposition.</li>
    </ul>

    <p class="text-gray-300">    <img src="_page_4_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: The RC permutation. The middle Br-C-B-C-Br part is secure against algebraic attacks whereas C-Br-C-Br-C-Br-C-Br-C-Br-C-Br-C is secure against rebounds (more generally, statistical) attacks.</p>

    <p class="text-gray-300">&bull; In order to protect against non-algebraic attacks, we had to wrap Bars with additional confusion and diffusion layers. The number of those was derived from traditional attacks on SPN-based designs such as rebound [60].</p>

    <p class="text-gray-300">The function Bricks :  <span class="math">\\mathbb{F}_p^3 \\to \\mathbb{F}_p^3</span>  is a non-linear permutation of degree d=5 (with the requirement  <span class="math">\\gcd(p-1,d)=1</span> ). Following [39], we define Bricks as</p>

    <p class="text-gray-300">Bricks
<span class="math">$(x_1, x_2, x_3)</span>$</p>

    <p class="text-gray-300">=  <span class="math">(x_1^d, x_2(x_1^2 + \\alpha_1 x_1 + \\beta_1), x_3(x_2^2 + \\alpha_2 x_2 + \\beta_2)),</span></p>

    <p class="text-gray-300">where  <span class="math">\\alpha_1, \\alpha_2, \\beta_1, \\beta_2 \\in \\mathbb{F}_p</span>  such that  <span class="math">\\alpha_i^2 - 4\\beta_i</span>  is not a quadratic residue modulo p. We refer to [39, Section 3] for a proof regarding its invertibility, which relies on the fact that  <span class="math">z^2 + \\alpha z + \\beta \\neq 0</span>  for each  <span class="math">z \\in \\mathbb{F}_p</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 The Concrete function</h3>

    <p class="text-gray-300">The function  <span class="math">\\mathsf{Concrete}^{(j)}: \\mathbb{F}^3_p \\to \\mathbb{F}^3_p</span>  denotes the multiplication of the state by a 3  <span class="math">\\times</span>  3 MDS matrix  <span class="math">M = \\mathsf{circ}(2,1,1)</span>  with subsequent</p>

    <p class="text-gray-300">addition of the <em>j</em>-th round constant vector  <span class="math">c^{(j)} \\in \\mathbb{F}_p^3</span> , that is</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Concrete}^{(j)}(x) \\coloneqq \\begin{pmatrix} 2 &amp; 1 &amp; 1 \\\\ 1 &amp; 2 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 \\end{pmatrix} \\times \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{pmatrix} + c^{(j)}.</span>$</p>

    <p class="text-gray-300">Note that M is invertible and MDS for each  <span class="math">p \\geq 3</span> . The elements  <span class="math">c_1^{(j)}, c_2^{(j)}, c_3^{(j)}</span>  are certain pseudo-random constants, generated using e.g. Shake-128 with rejection sampling.</p>

    <p class="text-gray-300">The function Bars :  <span class="math">\\mathbb{F}^3_p \\to \\mathbb{F}^3_p</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$Bars(x_1, x_2, x_3) = (Bar(x_1), Bar(x_2), Bar(x_3)).</span>$</p>

    <p class="text-gray-300">The function  <span class="math">\\operatorname{Bar}: \\mathbb{F}_p \\to \\mathbb{F}_p</span>  is designed to be a permutation of  <span class="math">\\mathbb{F}_p</span>  coming from n smaller permutations acting <em>independently</em> on n smaller domains  <span class="math">\\mathbb{Z}_{s_1}, \\ldots, \\mathbb{Z}_{s_n}</span> , where  <span class="math">s_1, \\ldots, s_n</span>  are defined for each prime p separately, see Section 7. The independence requirement is crucial for the performance of Bar. For this we decompose a field element  <span class="math">x \\in \\mathbb{F}_p</span>  into n smaller  <span class="math">digits\\ x_1, \\ldots, x_n</span>  with  <span class="math">x_i \\in \\mathbb{Z}_{s_i}</span>  with the function Comp, and then compose it back with Decomp. Overall,  <span class="math">\\operatorname{Bar}: \\mathbb{F}_p \\to \\mathbb{F}_p</span>  is defined as</p>

    <p class="text-gray-300">
<span class="math">$Bar = Comp \\circ SBox \\circ Decomp. \\tag{1}</span>$</p>

    <p class="text-gray-300">In the following, we define all these components. The invertibility of Bar is proved in Appendix A.2.</p>

    <p class="text-gray-300">4.3.1 Decomposition and Composition. We choose the standard representation  <span class="math">\\mathbb{F}_p = \\{0, 1, \\dots, p-1\\}</span>  for  <span class="math">\\mathbb{F}_p</span> , thus identifying an element  <span class="math">x \\in \\mathbb{F}_p</span>  with an integer  <span class="math">0 \\le x \\le p-1</span> . Our decomposition  <span class="math">\\mathbb{P}_p \\to \\mathbb{F}_p \\to \\mathbb{F}_p \\to \\mathbb{F}_p</span>  as</p>

    <p class="text-gray-300"><span class="math">$x = x_1 \\cdot s_2 s_3 \\cdots s_n + x_2 \\cdot s_3 s_4 \\cdots s_n + \\cdots</span>$
<span class="math">$+ x_{n-1} \\cdot s_n + x_n = \\sum_{i=1}^n x_i \\prod_{i&gt;i} s_j.</span>$</p>

    <p class="text-gray-300">with  <span class="math">0 \\le x_i &lt; s_i</span>  and where the  <span class="math">s_i</span>  are chosen such that  <span class="math">\\prod_{i=1}^n s_i &gt; p</span> . The digits  <span class="math">x_i \\in \\mathbb{Z}_{s_i}</span>  are determined similarly to ordinary base-b expansion:</p>

    <p class="text-gray-300">
<span class="math">$x_n := x \\mod s_n,</span>$</p>

    <p class="text-gray-300"><span class="math">$x_i := \\frac{x - \\sum_{j&gt;i} x_j \\prod_{k&gt;j} s_k}{\\prod_{j&gt;i} s_j} \\mod s_i.</span>$
(2)</p>

    <p class="text-gray-300">It follows directly from the definition in Eq. (2) that the digits  <span class="math">x_i</span>  are <em>unique</em>. Because of the strong analogy with ordinary base-b expansion and for ease of notation in the following part, we define for  <span class="math">1 \\le i \\le n</span>  the elements</p>

    <p class="text-gray-300"><span class="math">$b_i := \\prod_{j&gt;i} s_j = s_{i+1}s_{i+2}\\dots s_n,</span>$</p>

    <p class="text-gray-300">where  <span class="math">b_n</span>  is defined by the empty product and thus  <span class="math">b_n:=1</span> . The inverse process, the composition  <span class="math">\\mathsf{Comp}:\\mathbb{Z}_{s_1}\\times\\cdots\\times\\mathbb{Z}_{s_n}\\to\\mathbb{F}_p</span>  is computed as</p>

    <p class="text-gray-300">
<span class="math">$Comp(y_1, \\dots, y_n) := \\sum_{i=1}^n y_i b_i \\mod p. \\tag{3}</span>$</p>

    <p class="text-gray-300">4.3.2 SBox. Let  <span class="math">(v_1, v_2, \\ldots, v_n) = \\text{Decomp}(p-1)</span>  and let  <span class="math">p&#x27; \\leq \\min_{1 \\leq i \\leq n} v_i</span> . Then  <span class="math">x_i</span>  is converted as follows:</p>

    <p class="text-gray-300">
<span class="math">$y_i := S(x_i) = \\begin{cases} f(x_i) &amp; \\text{if } x_i &lt; p&#x27;, \\\\ x_i &amp; \\text{if } x_i \\ge p&#x27;, \\end{cases}</span>$
(4)</p>

    <p class="text-gray-300">where f denotes a permutation of  <span class="math">\\mathbb{Z}_{p&#x27;}</span> . In Lemma 3 we prove that Bar is indeed a permutation of  <span class="math">\\mathbb{F}_p</span> . The value p' is selected for each p separately.</p>

    <p class="text-gray-300">The f function is derived from the MiMC cipher (which implicitly requires p' being prime). Reference values of p' for various p and tables for f are given in full in the Appendix.</p>

    <p class="text-gray-300">We suggest the bijective transformation RC being used in the sponge framework [14] similarly to Poseidon [41] and Rescue [7]. The parameters are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Rate is two  <span class="math">\\mathbb{F}_p</span>  elements, capacity is one  <span class="math">\\mathbb{F}_p</span>  element.</li>
      <li>Claimed preimage and collision security level of 128 bits.</li>
      <li>The padding rule is simply to add the 0 element to any input of odd length. The very first capacity value is initialized by the length-depending constant, e.g. just length <em>l</em>. This does not violate the sponge security proof as long as only short lengths (say up to 2<sup>32</sup>) are allowed.</li>
    </ul>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>5 SECURITY ANALYSIS</strong></h2>

    <p class="text-gray-300">In this section we summarize our own analysis of RC security and connect it with the requirements outlined in Section 3.</p>

    <p class="text-gray-300">For the latter, we customarily reduce the security of RC hash to its resistance against known cryptanalytic attacks. In particular, we focus on the following two classes of attacks, respectively statistical and algebraic attacks. As already mentioned in the introduction, we make use of the Hades/Poseidon design strategy in order to provide security:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Statistical attacks (including differential, linear, rebound, truncated, impossible, MiTM, boomerang) cannot be mounted on RC even with the middle component Bricks-Concrete-Bars-Concrete-Bricks replaced with a single Bricks layer up 2<sup>128</sup> field operations.</li>
      <li>The middle component Bricks-Concrete-Bars-Concrete-Bricks resists invariant subspace and algebraic (e.g., Gr&ouml;bner basis) attacks up to 2<sup>128</sup> field operations. Due to the high degree and because we are working over prime fields, we also expect ample resistance against higher-order differential attacks (e.g., zero-sum distinguishers or cube attacks).</li>
    </ul>

    <p class="text-gray-300">We give a detailed overview of statistical attack approaches in Appendix B.1, and we focus on algebraic attacks in Appendix B.4. The short summary is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Differential and linear attacks do not work as long as the Bricks layer is involved.</li>
      <li>We cannot mount rebound attacks for 5 or more rounds thus having at least 2 rounds of security margin.</li>
      <li>No invariant subspace attacks have been found.</li>
      <li>Groebner basis cryptanalysis fails at greatly weakened versions (10-bit fields) already.</li>
    </ul>

    <p class="text-gray-300">    <img src="_page_5_Figure_21.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: Finite-state automaton  <span class="math">\\mathcal{A}</span>  representing all valid sequences  <span class="math">c_1, c_2, \\ldots, c_n</span> .</p>

    <p class="text-gray-300">In this section we create tables and a set of constraints such that for  <span class="math">x, y \\in \\mathbb{F}_p</span>  it holds y = Bar(x) if and only if this set of constraints is satisfied. We face two challenges:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) The S-box  <span class="math">S_i</span>  acts on a domain of size  <span class="math">s_i</span> , which makes each S-box potentially unique. If we specify the behavior of each S-box separately, the table would have  <span class="math">\\sum_i s_i</span>  entries, which renders it inefficient.</li>
      <li>(2) Since  <span class="math">\\prod_i s_i &gt; p</span> , there exist distinct elements  <span class="math">(x_1, \\ldots, x_n) \\neq (x&#x27;_1, \\ldots, x&#x27;_n)</span>  in  <span class="math">\\mathbb{Z}_{s_1} \\times \\ldots \\mathbb{Z}_{s_n}</span>  that produce the same  <span class="math">x \\in \\mathbb{F}_p</span> , i.e., for which it holds</li>
    </ul>

    <p class="text-gray-300"><span class="math">$x = \\operatorname{Comp}(x_1, \\dots, x_n) = \\sum_{i=1}^n x_i b_i \\mod p =</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{i=1}^n x_i&#x27; b_i \\mod p = \\operatorname{Comp}(x_1&#x27;, \\dots, x_n&#x27;).</span>$</p>

    <p class="text-gray-300">We have to ensure that our table and set of constraints prevents this collision from happening.</p>

    <p class="text-gray-300">We address these challenges with two additional sets of variables  <span class="math">(z_1, \\ldots, z_n)</span>  and  <span class="math">(c_1, \\ldots, c_n)</span> , respectively. The variable  <span class="math">z_i</span>  encodes if  <span class="math">x_i &lt; p&#x27;</span>  ( <span class="math">S_i</span>  is non-linear function) or  <span class="math">x_i \\ge p&#x27;</span>  ( <span class="math">S_i</span>  is identity function) and is defined as</p>

    <p class="text-gray-300"><span class="math">$z_{i} := \\begin{cases} 0, &amp; \\text{if } x_{i} &lt; p&#x27;; \\\\ 1, &amp; \\text{if } x_{i} \\ge p&#x27;. \\end{cases}</span>$
(5)</p>

    <p class="text-gray-300">The purpose of variables  <span class="math">(c_1,\\ldots,c_n)</span>  is to indicate if a tuple  <span class="math">(x_1,\\ldots,x_n)\\in\\mathbb{Z}_{s_1}\\times\\ldots\\times\\mathbb{Z}_{s_n}</span>  has the property  <span class="math">\\sum_{i=1}^n x_ib_i\\geq p</span> , or not. If  <span class="math">\\sum_{i=1}^n x_ib_i\\geq p</span> , the tuple  <span class="math">(x_1,\\ldots,x_n)</span>  &quot;overflows&quot; p and thus it is a potential candidate for a collision since by definition composition is unique for all  <span class="math">(x_1,\\ldots,x_n)</span>  with  <span class="math">\\sum_{i=1}^n x_ib_i&lt; p</span> . With our set of constraints we need to exclude all those tuples &quot;overflowing&quot; p. For  <span class="math">(v_1,\\ldots,v_n)=</span>  Decomp(p-1), we therefore define</p>

    <p class="text-gray-300"><span class="math">$c_i := \\begin{cases} 0, &amp; \\text{if } x_j = v_j \\text{ for all } 1 \\le j \\le i; \\\\ 1, &amp; \\text{if } x_i &lt; v_i; \\\\ 2, &amp; \\text{if } x_i \\ge v_i \\text{ and } x_j \\ne v_j \\text{ for some } 1 \\le j \\le i; \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$(6)</span>$</p>

    <p class="text-gray-300">By definition of  <span class="math">c_i</span> , only sequences  <span class="math">c_1, c_2, \\ldots, c_n</span>  of length n output by the finite-state automaton  <span class="math">\\mathcal{A}</span>  in Fig. 3 are allowed; they characterize all tuples  <span class="math">(x_1, \\ldots, x_n) \\in \\mathbb{N}^n</span>  with  <span class="math">\\sum_{i=1}^n x_i b_i &lt; p</span> .</p>

    <p class="text-gray-300">We create the following 4-ary tables for our set of constraints:</p>

    <p class="text-gray-300">&bull; Table  <span class="math">T_2</span>  contains all binary sequences of length 4 (Fig. 4) thus providing a means to encode all possible sequences  <span class="math">(z_1, \\ldots, z_n)</span>  by concatenating as many 4-ary sequences as needed:</p>

    <p class="text-gray-300">
<span class="math">$T_2 = \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; &amp; &amp; \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">Figure 4: Lookup Table  <span class="math">T_2</span> .</p>

    <p class="text-gray-300">
<span class="math">$T_1 = \\begin{bmatrix} 0 &amp; 0 &amp; f(0) &amp; 1 \\\\ 1 &amp; 0 &amp; f(1) &amp; 1 \\\\ p&#x27; &amp; 1 &amp; 0 &amp; f(p&#x27;-1) &amp; 1 \\\\ p&#x27; &amp; 1 &amp; p&#x27; &amp; 1 \\\\ p&#x27; + 1 &amp; 1 &amp; p&#x27; + 1 &amp; 1 \\\\ \\cdots &amp; &amp; &amp; &amp; &amp; \\\\ v_1 - 1 &amp; 1 &amp; v_1 - 1 &amp; 1 \\\\ v_1 &amp; 1 &amp; v_1 &amp; 0 \\\\ p&#x27; &amp; 2 &amp; p&#x27; &amp; 1 \\\\ \\cdots &amp; &amp; &amp; &amp; \\\\ v_2 - 1 &amp; 2 &amp; v_2 - 1 &amp; 1 \\\\ v_2 &amp; 2 &amp; v_2 &amp; 2 \\\\ v_2 + 1 &amp; 2 &amp; v_2 + 1 &amp; 2 \\\\ \\cdots &amp; &amp; &amp; &amp; \\\\ s_2 - 1 &amp; 2 &amp; s_2 - 1 &amp; 2 \\\\ \\cdots &amp; &amp; &amp; &amp; \\\\ r_0 &amp; n &amp; p&#x27; &amp; 1 \\\\ \\cdots &amp; &amp; &amp; &amp; \\\\ v_{n} - 1 &amp; n &amp; v_{n} - 1 &amp; 1 \\\\ v_{n} &amp; n &amp; v_{n} &amp; 0 \\\\ v_{n} &amp; n &amp; v_{n} &amp; 2 \\\\ v_{n} + 1 &amp; n &amp; v_{n} + 1 &amp; 2 \\\\ \\vdots &amp; \\ddots &amp; &amp; &amp; \\\\ s_{n} - 1 &amp; n &amp; s_{n} - 1 &amp; 2 \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">Figure 5: Lookup Tables  <span class="math">T_1</span>  and  <span class="math">T_3</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Table  <span class="math">T_3</span>  contains all outputs of length 4 of the finite-state automaton  <span class="math">\\mathcal{A}</span>  in Fig. 3. They are chained together with the last element of one 4-ary sequence matching the first element of the next 4-ary sequence to encode all possible outputs of  <span class="math">\\mathcal{A}</span>  of length n, see constraints (8),(9);</li>
      <li>Table  <span class="math">T_1</span>  encodes the output of the S-Boxes  <span class="math">S_1, \\ldots, S_n</span>  and indicates whether for an input to S-Box  <span class="math">S_i</span>  the non-linear function f or the identity function is applied (Fig. 5).</li>
    </ul>

    <p class="text-gray-300">We claim that y = Bar(x) holds if and only if for  <span class="math">x, y \\in \\mathbb{F}_p</span>  and  <span class="math">(x_1, \\dots, x_n), (y_1, \\dots, y_n) \\in \\mathbb{N}^n</span>  the following constraints are</p>

    <p class="text-gray-300">satisfied:</p>

    <p class="text-gray-300"><span class="math">$\\forall n \\ge i \\ge 1: (x_i, i \\cdot z_i, y_i, c_i) \\in T_1,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\forall \\lceil (n-1)/3 \\rceil - 1 \\ge i \\ge 1:</span>$
(7)</p>

    <p class="text-gray-300">
<span class="math">$(c_{3i-2}, c_{3i-1}, c_{3i}, c_{3i+1}) \\in T_3,</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$(c_{n-3}, c_{n-2}, c_{n-1}, c_n) \\in T_3,</span>$
(9)</p>

    <p class="text-gray-300"><span class="math">\\forall \\lceil n/4 \\rceil - 1 \\ge i \\ge 1:</span></p>

    <p class="text-gray-300">
<span class="math">$(z_{4i-3}, z_{4i-2}, z_{4i-1}, z_{4i}) \\in T_2, \\tag{10}</span>$</p>

    <p class="text-gray-300"><span class="math">$(z_{n-3}, z_{n-2}, z_{n-1}, z_n) \\in T_2, \\tag{11}</span>$</p>

    <p class="text-gray-300"><span class="math">$x = \\sum_{i=1}^{n} x_i b_i \\bmod p, \\tag{12}</span>$</p>

    <p class="text-gray-300"><span class="math">$y = \\sum_{i=1}^{n} y_i b_i \\bmod p. \\tag{13}</span>$</p>

    <p class="text-gray-300">In particular, we claim for  <span class="math">x \\in \\mathbb{F}_p</span>  there doesn't exist any collision in  <span class="math">\\mathbb{Z}_{s_1} \\times \\ldots \\mathbb{Z}_{s_n}</span> . I.e., there is exactly one element  <span class="math">(x_1, \\ldots, x_n)</span>  in  <span class="math">\\mathbb{Z}_{s_1} \\times \\ldots \\mathbb{Z}_{s_n}</span>  with  <span class="math">\\mathsf{Comp}(x_1, \\ldots, x_n) = x</span> . We prove these assertions in Lemma 1 and Lemma 2. As a result, the total number of lookup constraints is</p>

    <p class="text-gray-300"><span class="math">$n + \\lceil (n-1)/3 \\rceil + \\lceil n/4 \\rceil \\approx n + n/3 + n/4 \\approx 1.59n</span>$</p>

    <p class="text-gray-300">table lookups with tables of total size  <span class="math">p&#x27; + \\sum_i (s_i - p&#x27; + 1) + 16 + 23</span> .</p>

    <p class="text-gray-300">Lemma 1. The set of constraints (7) &ndash; (13) is complete, i.e., for any  <span class="math">x,y\\in\\mathbb{F}_p</span>  with  <span class="math">y=\\mathsf{Bar}(x)</span>  it is possible to construct  <span class="math">\\{x_i,y_i,c_i,z_i:1\\leq i\\leq n\\}</span>  that satisfy them.</p>

    <p class="text-gray-300"><em>Proof.</em> We work with the standard representation of  <span class="math">\\mathbb{F}_p</span> , that is,  <span class="math">\\mathbb{F}_p=\\{0,1,\\ldots,p-1\\}</span> . Suppose for  <span class="math">x,y\\in\\mathbb{F}_p</span>  it holds  <span class="math">y=\\mathsf{Bar}(x)</span> . Our proof works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We construct  <span class="math">x_i, y_i</span>  and show that constraints (12) and (13) are satisfied:</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>we define  <span class="math">z_i</span>  that satisfy constraints (10) and (11) regarding Table  <span class="math">T_2</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>we define  <span class="math">c_i</span>  that satisfy constraints (8) and (9) regarding Table  <span class="math">T_3</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>we show that  <span class="math">(x_i, i \\cdot z_i, y_i, c_i)</span>  satisfy the constraints (7) regarding Table  <span class="math">T_1</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Ist Step. We define  <span class="math">(x_1,\\ldots,x_n):=\\mathsf{Decomp}(x)</span>  and  <span class="math">(y_1,\\ldots,y_n):=\\mathsf{SBox}(x_1,\\ldots,x_n)=(\\mathsf{SBox}\\circ\\mathsf{Decomp})(x);</span>  then constraint (12) holds by definition of Decomp and constraint (13) by definition of Bar, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} y &amp;= (\\mathsf{Comp} \\circ \\mathsf{SBox} \\circ \\mathsf{Decomp})(x) \\\\ &amp;= \\mathsf{Comp} \\left( \\mathsf{SBox} \\circ \\mathsf{Decomp}(x) \\right) \\\\ &amp;= \\mathsf{Comp}(y_1, \\dots, y_n) = \\sum_{i=1}^n y_i b_i \\bmod p. \\end{split}</span>$</p>

    <p class="text-gray-300">2nd Step. Let p' be according to the definition of the Bar function, i.e., p' is the largest prime smaller than or equal to  <span class="math">v = \\min_{1 \\le i \\le n} v_i</span> , where  <span class="math">(v_1, \\dots, v_n) = \\mathsf{Decomp}(p-1)</span> . For  <span class="math">1 \\le i \\le n</span>  we define</p>

    <p class="text-gray-300"><span class="math">$z_i := \\begin{cases} 0, &amp; \\text{if } x_i &lt; p&#x27;; \\\\ 1, &amp; \\text{if } x_i \\ge p&#x27;; \\end{cases}</span>$</p>

    <p class="text-gray-300">that indicate if  <span class="math">x_i &lt; p&#x27;</span>  or  <span class="math">x_i \\ge p&#x27;</span> . The sequence  <span class="math">(z_1, \\ldots, z_n)</span>  is a binary sequence of length n, where all  <span class="math">2^n</span>  combinations are possible: every digit  <span class="math">x_i</span>  can be strictly smaller or greater than p'. Since  <span class="math">T_2</span>  contains all binary sequences of length 4, we have that the constraints (10) and (11) regarding  <span class="math">T_2</span>  are satisfied.</p>

    <p class="text-gray-300">3rd Step. If x = p - 1, or equivalently, if  <span class="math">x_i = v_i</span>  for all  <span class="math">1 \\le i \\le n</span> , we define  <span class="math">c_i := 0</span> , for all  <span class="math">1 \\le i \\le n</span> . Thus  <span class="math">(c_1, \\ldots, c_n) = (0, \\ldots, 0)</span>  and the corresponding constraints (8) and (9) in Table  <span class="math">T_3</span>  are satisfied. If  <span class="math">x , there exists at least one index &lt;math&gt;1 \\le i \\le n</span>  with  <span class="math">x_i &lt; v_i</span> . Let j be the minimal index with that property. We set</p>

    <p class="text-gray-300"><span class="math">$c_i := \\begin{cases} 0, &amp; \\text{if } i &lt; j; \\\\ 1, &amp; \\text{if } i \\ge j \\text{ and } x_i &lt; v_i; \\\\ 2, &amp; \\text{if } i &gt; j \\text{ and } x_i \\ge v_i. \\end{cases}</span>$</p>

    <p class="text-gray-300">Note that the case i=j and  <span class="math">x_i \\ge v_i</span>  cannot happen, since this would on the one hand mean  <span class="math">x_j \\ge v_j</span>  and on the other hand  <span class="math">x_j &lt; v_j</span>  (by definition of j), a contradiction. Thus, the above three cases cover all possible situations regarding i. Next, we list all subsequences of  <span class="math">c_1, \\ldots, c_n</span>  that are <em>not</em> possible:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) (2,...); since  <span class="math">c_1 = 2</span>  this would mean  <span class="math">1 \\le j &lt; i = 1</span> , a contradiction.</li>
      <li>(b)  <span class="math">(\\ldots, 0, 2, \\ldots)</span> ; this would imply i &lt; j  <span class="math">(c_i = 0)</span>  and i + 1 &gt; j  <span class="math">(c_{i+1} = 2)</span> , a contradiction.</li>
      <li>(c)  <span class="math">(\\ldots, 1, 0, \\ldots)</span> ; a contradiction, since  <span class="math">i \\ge j</span>   <span class="math">(c_i = 1)</span>  and i+1 &lt; j  <span class="math">(c_{i+1} = 0)</span> .</li>
      <li>(d) (..., 2, 0, ...); a contradiction, since i &gt; j  <span class="math">(c_i = 2)</span>  and i+1 &lt; j  <span class="math">(c_{i+1} = 0)</span> .</li>
    </ul>

    <p class="text-gray-300">We explicitly note, all other subsequences are valid. In a next step, we model a finite-state automaton  <span class="math">\\mathcal B</span>  whose outputs of length n characterize all possible sequences  <span class="math">(c_1,\\ldots,c_n)</span> . Clearly,  <span class="math">\\mathcal B</span>  has the states 0, 1, 2 with only 0, 1 being accepting states: due to (a) no sequence can start with 2. According to (b), (c) and (d), all possible transitions are given by</p>

    <p class="text-gray-300"><span class="math">$\\{(0,0),(0,1),(1,1),(1,2),(2,1),(2,2)\\}.</span>$</p>

    <p class="text-gray-300">But this means, that automaton  <span class="math">\\mathcal{B}</span>  is identical to automaton  <span class="math">\\mathcal{A}</span>  depicted in Fig. 3. Hence we conclude, all possible sequences  <span class="math">(c_1,\\ldots,c_n)</span>  of elements as defined above are precisely the outputs of length n of the finite-state automaton  <span class="math">\\mathcal{A}</span> . If we divide the sequence  <span class="math">(c_1,\\ldots,c_n)</span>  into chunks of 4 elements such that the last element of one chunk matches the first element of the next chunk, we see that constraints (8) and (9) regarding  <span class="math">T_3</span>  are satisfied.</p>

    <p class="text-gray-300">4th Step. Constraints (7) regarding  <span class="math">T_1</span>  are satisfied as well: by definition of  <span class="math">x_i, z_i, y_i, c_i</span>  we have  <span class="math">0 \\le x_i \\le s_i - 1, z_i \\in \\{0, 1\\}, y_i = S_i(x_i)</span>  and  <span class="math">c_i \\in \\{0, 1, 2\\}</span> , respectively. This means, the domains of  <span class="math">x_i, i \\cdot z_i, y_i, c_i</span>  agree with the general conditions in  <span class="math">T_1</span> . Not all combinations are allowed, however. The following arguments show that indeed all possible 4-ary chunks  <span class="math">(x_i, i \\cdot z_i, y_i, c_i)</span>  satisfy the constraints in  <span class="math">T_1</span> . As in the 3rd Step, for x = p - 1 we define  <span class="math">c_i := 0</span>  and thus have  <span class="math">(x_i, i \\cdot z_i, y_i, c_i) = (v_i, i, v_i, 0)</span>  for  <span class="math">1 \\le i \\le n</span> . Hence, for x = p - 1 the corresponding constraints (7) in Table  <span class="math">T_1</span>  are satisfied. Therefore let x and let again <math>j be the minimal index with  <span class="math">x_i &lt; v_i</span> .</p>

    <p class="text-gray-300">&bull; For  <span class="math">0 \\le x_i &lt; p&#x27;</span> , we have  <span class="math">z_i = 0</span> ,  <span class="math">i \\cdot z_i = 0</span> ,  <span class="math">y_i = S(x_i) = f(x_i)</span>  and  <span class="math">c_i = 1</span>  (since  <span class="math">x_i &lt; p&#x27; \\le v_i</span> ) by construction of  <span class="math">x_i</span> ,  <span class="math">z_i</span> ,  <span class="math">y_i</span></p>

    <p class="text-gray-300">and  <span class="math">c_i</span> , respectively. Thus the first p' constraints in  <span class="math">T_1</span>  are satisfied.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">p&#x27; \\le x_i = v_i</span>  two cases can happen: if i &lt; j, then  <span class="math">c_i = 0</span> ; if i &gt; j, then  <span class="math">c_i = 2</span> . In both cases the corresponding 4-ary chunk  <span class="math">x_i, i \\cdot z_i = i, y_i = x_i, c_i \\in \\{0, 2\\}</span>  is contained in  <span class="math">T_1</span> . We note, the case  <span class="math">x_i = v_i</span>  and i = j cannot happen due to the definition of j.</li>
      <li>For  <span class="math">p&#x27; \\le x_i &lt; v_i</span> , we have  <span class="math">z_i = 1</span> ,  <span class="math">i \\cdot z_i = i</span> ,  <span class="math">y_i = S(x_i) = x_i</span>  and  <span class="math">c_i = 1</span>  (since  <span class="math">x_i &lt; v_i</span> ). Thus the corresponding  <span class="math">v_i p&#x27;</span>  constraints in  <span class="math">T_1</span>  are satisfied.</li>
      <li>For  <span class="math">v_i + 1 \\le x_i \\le s_i 1</span>  it holds  <span class="math">z_i = 1</span> ,  <span class="math">i \\cdot z_i = i</span> ,  <span class="math">y_i = S(x) = x_i</span>  and  <span class="math">c_i = 2</span> , which shows that the corresponding  <span class="math">s_i v_i 1</span>  constraints in  <span class="math">T_1</span>  are fulfilled.</li>
    </ul>

    <p class="text-gray-300">Specifically, for i = 1 there is no entry  <span class="math">(x_1, i \\cdot z_1, y_1, 2)</span>  in  <span class="math">T_1</span> , therefore we have to argue that this case cannot happen; this is clear, however, since we have already shown that automaton  <span class="math">\\mathcal{B}</span> , which represents all valid sequences  <span class="math">(c_1, \\ldots, c_n)</span> , guarantees  <span class="math">c_1 \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">LEMMA 2. The set of constraints (7)&ndash;(13) is sound, i.e., for any  <span class="math">x, y \\in \\mathbb{F}_p</span>  and any  <span class="math">\\{x_i, y_i, z_i, c_i \\in \\mathbb{N} : 1 \\le i \\le n\\}</span>  that satisfy them all it holds  <span class="math">y = \\mathsf{Bar}(x)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We work with the standard representation of  <span class="math">\\mathbb{F}_p</span> . For  <span class="math">\\mathcal{R}:=\\mathbb{Z}_{s_1}\\times\\ldots\\times\\mathbb{Z}_{s_n}</span>  let</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{&lt; p} := \\{(z_1, \\dots, z_n) \\in \\mathcal{R} : \\sum_{i=1}^n z_i b_i &lt; p\\}.</span>$</p>

    <p class="text-gray-300">Our proof consists of the following parts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Show that  <span class="math">(x_1, ..., x_n)</span>  is a valid decomposition of x, i.e.,  <span class="math">(x_1, ..., x_n) = Decomp(x)</span> .</li>
      <li>(2) Show that for all  <span class="math">1 \\le i \\le n</span>  we have  <span class="math">y_i = S_i(x_i)</span>  according to (4) and deduce  <span class="math">(y_1, \\ldots, y_n) = (\\mathsf{SBox} \\circ \\mathsf{Decomp})(x)</span> .</li>
      <li>(3) Use the above two facts and deduce y = Bar(x).</li>
    </ul>

    <p class="text-gray-300">Ist Step. Let  <span class="math">(x&#x27;_1,\\ldots,x&#x27;_n):=\\mathsf{Decomp}(x)</span>  and  <span class="math">\\hat{x}:=\\sum_{i=1}^n x_ib_i</span> . Suppose  <span class="math">\\hat{x}&lt; p</span> , or in other words  <span class="math">(x_1,\\ldots,x_n)\\in\\mathcal{R}_{&lt; p}</span> . Then by (12) we have  <span class="math">\\hat{x}=\\hat{x} \\bmod p=\\sum_{i=1}^n x_ib_i \\bmod p=x&lt; p</span> , and thus</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\mathsf{Decomp}(x) = \\mathsf{Decomp}\\left(\\sum_{i=1}^n x_i b_i \\bmod p\\right) \\\\ &amp; = (\\mathsf{Decomp} \\circ \\mathsf{Comp})(x_1, \\dots, x_n) = (x_1, \\dots, x_n) \\end{aligned}</span>$</p>

    <p class="text-gray-300">The last equality uses the fact, that Decomp and Comp are inverse to each other on  <span class="math">\\mathcal{R}_{&lt; p}</span>  and  <span class="math">\\mathbb{F}_p</span> ; we proved this in more detail in Lemma 3.</p>

    <p class="text-gray-300">We show that the case  <span class="math">\\hat{x} \\ge p</span>  leads to a contradiction. For this, suppose  <span class="math">\\hat{x} \\ge p</span> . This implies that there exists  <span class="math">1 \\le k \\le n</span>  with</p>

    <p class="text-gray-300"><span class="math">$x_i = v_i</span>$
for all  <span class="math">1 \\le i &lt; k</span>  and  <span class="math">x_k &gt; v_k</span> .</p>

    <p class="text-gray-300">Note that k&gt;1 as  <span class="math">x_1\\leq v_1</span>  by Table  <span class="math">T_1</span>  (constraint (7)). Also, by constraint (7) it holds  <span class="math">c_i\\in\\{0,2\\}</span>  for all  <span class="math">1\\leq i&lt; k</span>  and in particular  <span class="math">c_1=0</span> . Therefore, constraints (8) and (9) regarding Table  <span class="math">T_3</span>  ensure that actually all  <span class="math">c_i=0</span>  for  <span class="math">1\\leq i&lt; k</span>  since there is no sequence with  <span class="math">(\\ldots,0,2,\\ldots)</span>  in  <span class="math">T_3</span> . Therefore, again by constraints (8) and (9), we have that  <span class="math">c_k\\in\\{0,1\\}</span> . By constraint (7) this is only possible if  <span class="math">x_k\\leq v_k</span> . A contradiction.</p>

    <p class="text-gray-300">2nd Step. Let  <span class="math">1 \\le i \\le n</span> . We show  <span class="math">y_i = S(x_i)</span> . By constraints (10) and (11) it holds  <span class="math">z_i \\in \\{0, 1\\}</span> . If  <span class="math">z_i = 0</span>  then  <span class="math">i \\cdot z_i = 0</span>  and by constraint (7) we have  <span class="math">x_i &lt; p&#x27;</span>  and  <span class="math">y_i = f(x_i)</span> . If  <span class="math">z_i = 1</span> , we have  <span class="math">i \\cdot z_i = i &gt; 1</span> ,</p>

    <p class="text-gray-300">and again by constraint (7) it holds  <span class="math">x_i \\ge p&#x27;</span>  and  <span class="math">y_i = x_i</span> . Altogether we get that  <span class="math">y_i = S_i(x_i)</span>  and thus</p>

    <p class="text-gray-300"><span class="math">$(y_1, \\dots, y_n) = \\operatorname{SBox}(x_1, \\dots, x_n)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{\\operatorname{Part1}}{=} \\operatorname{SBox}(\\operatorname{Decomp}(x)) = (\\operatorname{SBox} \\circ \\operatorname{Decomp})(x)</span>$</p>

    <p class="text-gray-300"><span class="math">$(14)</span>$</p>

    <p class="text-gray-300"><em>3rd Step.</em> For the last part we use the definition of Bar, Part 2, the definition of Comp and constraint (13), which yields</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\operatorname{Bar}(x) &amp;\\stackrel{\\text{(1)}}{=} (\\operatorname{Comp} \\circ \\operatorname{SBox} \\circ \\operatorname{Decomp})(x) \\\\ &amp;= \\operatorname{Comp}(\\operatorname{SBox} \\circ \\operatorname{Decomp}(x)) \\\\ &amp;\\stackrel{\\operatorname{Part}}{=} {}^2 \\operatorname{Comp}(y_1, \\dots, y_n) \\\\ &amp;\\stackrel{\\text{(3)}}{=} \\sum_{i=1}^n y_i b_i \\bmod p \\stackrel{\\text{(13)}}{=} y. \\end{split}</span>$</p>

    <p class="text-gray-300">The values of  <span class="math">\\alpha_1, \\alpha_2, \\beta_1, \\beta_2</span>  are given by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">p = p_{\\text{BLS381}}</span> : (1,3,2,4).</li>
      <li><span class="math">p = p_{\\text{BN254}}</span> : (1,3,2,4)</li>
      <li><span class="math">p = p_{ST}</span> : (1,2,3,4).</li>
    </ul>

    <p class="text-gray-300">For the Bar function we choose a decomposition into n=27 small S-boxes for p being the order of BLS12-381 or BN254 curves.</p>

    <p class="text-gray-300"><em>BLS12-381</em>. The prime p is given by</p>

    <p class="text-gray-300"><span class="math">p_{\\rm BLS381} = 0</span> x73eda753299d7d483339d80809a1d80 553bda402fffe5bfefffffff00000001.</p>

    <p class="text-gray-300">The bucket sizes</p>

    <p class="text-gray-300">for the Bar layer are given by</p>

    <p class="text-gray-300">If  <span class="math">(v_1, \\ldots, v_{27})</span>  denotes the decomposition of p-1, the largest prime p' smaller than or equal to  <span class="math">v=\\min_{1\\leq i\\leq 27}v_i</span>  is p'=659. The values  <span class="math">s_i</span>  were found by a variant of branch-and-bound process where we recursively determine from  <span class="math">s_{27}</span>  to  <span class="math">s_1</span>  under the constraint that  <span class="math">s_i-v_i</span>  is not too large for any i.</p>

    <p class="text-gray-300">BN254. The prime p is given by</p>

    <p class="text-gray-300"><span class="math">p_{\\rm BN254} = 0</span> x30644e72e131a029b85045b68181585 d2833e84879b9709143e1f593f0000001.</p>

    <p class="text-gray-300">The bucket sizes for the Bar layer are given by</p>

    <p class="text-gray-300">If  <span class="math">(v_1, \\ldots, v_{27})</span>  denotes the decomposition of p-1, the largest prime p' smaller than or equal to  <span class="math">v=\\min_{1\\leq i\\leq 27}v_i</span>  is p'=641. Decomposition was found in the same way.</p>

    <p class="text-gray-300"><em>Special prime.</em> We have crafted a special prime for the proof systems that are not elliptic curve based, so that the decomposition and modular reduction are extremely fast. Concretely, we found out that a 250-bit prime</p>

    <p class="text-gray-300"><span class="math">$p_{ST} = 0x3fa000...001</span>$</p>

    <p class="text-gray-300">admits the following representation:</p>

    <p class="text-gray-300"><span class="math">$p_{ST} = 2^{250} - 3 \\cdot 2^{241} + 1 = \\sum_{i=0}^{24} (2^{10} - 6)2^{10i} + 1,</span>$</p>

    <p class="text-gray-300">i.e..</p>

    <p class="text-gray-300"><span class="math">$s_2 = s_3 = \\dots = s_{24} = 1024,</span>$
(15)</p>

    <p class="text-gray-300"><span class="math">$s_{25} = 1023, v_1 = v_2 = \\dots = v_{25} = 1018.</span>$
(16)</p>

    <p class="text-gray-300">For this decomposition we first selected  <span class="math">s_i</span>  to be almost all powers of two, prepared constraints that (p-1) is divisible by  <span class="math">2^{30}</span>  for Discrete Fourier Transform, and then tried a few values for  <span class="math">v_i</span>  until we find a prime.</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 PERFORMANCE</h2>

    <p class="text-gray-300">In this section we consider performance of plain and zero knowledge (circuit) implementations of RC. As the application, we consider a single call to permutation RC, which corresponds to hashing of two  <span class="math">\\mathbb F</span>  elements, or computing one node of a Merkle tree.</p>

    <p class="text-gray-300">8.1.1 Circuit metrics. So far many circuit implementations of hash functions are tailored to the proof system implementation they will be used, so it is extremely difficult to compare apples to apples by just measuring prover time. This is more complicated for proof systems that support lookups as only reference implementations are available<sup>2</sup>.</p>

    <p class="text-gray-300">Thus we turned to different metrics. First one just count gates and assumes that there are two types of gates: an arithmetic gate and a lookup gate, with the former implementing a quadratic constraint of form</p>

    <p class="text-gray-300"><span class="math">$a_1x_1x_2 + a_3x_3 + a_4x_4 + a_5x_5 = a_6</span>$</p>

    <p class="text-gray-300">with  <span class="math">x_i</span>  being witness variables and  <span class="math">a_i</span>  being values of selector polynomials. It can handle a 2-ary addition. A lookup gate has form</p>

    <p class="text-gray-300"><span class="math">$(x_1, x_2, x_3, x_4) \\in T</span>$</p>

    <p class="text-gray-300">where T is the lookup table. These two gates are the ones defined in the Plonk and Plookup papers [34, 35] and thus we call it <em>regular gates</em> metric.</p>

    <p class="text-gray-300">The second metric applies to custom gates, which implement arbitrary polynomial lookup constraints, and attempts to estimate the prover cost by assuming it is approximated as</p>

    <p class="text-gray-300"><span class="math">$C_{prover} \\sim \\text{(number of gates)} \\times</span>$</p>

    <p class="text-gray-300">(max degree of a gate constraint) &times; (gate arity)</p>

    <p class="text-gray-300">We call it <em>area-degree</em> product. The maximum degree of a regular gate constraint is 3, the arity is 5, so each gate contributes with cost 15.</p>

    <p class="text-gray-300">8.1.2 Measuring hash functions.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^2 \\&lt;/sup&gt;hbox{E.g. Plonkup https://github.com/dusk-network/plonkup}</span></p>

    <p class="text-gray-300">RC.. The regular gates count for the BLS/BN primes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Bricks: 8 gates per round (7 for  <span class="math">p_{ST}</span>  with d = 3);</li>
      <li>Concrete: 2 gates per element, 6 per round.</li>
      <li>Bars: 94 gates per element, 282 per round    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>decomposition: 26 gates</li>
      <li>composition: 26 gates</li>
      <li>table: 42 gates.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Total:  <span class="math">8 \\cdot 6 + 6 \\cdot 8 + 282 = 378</span>  gates to process two  <span class="math">\\mathbb{F}_p</span>  elements of data. The  <span class="math">p_{ST}</span>  case uses only 25  <span class="math">s_i</span>  so the total number of gates is 360.</p>

    <p class="text-gray-300">The area-degree product is thus  <span class="math">378 \\cdot 15 = 5670</span> .</p>

    <p class="text-gray-300"><em>Poseidon.</em> Poseidon-128 [41] with 2 inputs, which needs 633 gates for the same setting: each full round needs 9 quadratic gates and 6 addition gates, whereas each partial round needs 3 quadratic and 6 addition gates. Total count is  <span class="math">15 \\cdot 8 + 57 \\cdot 9 = 633</span> .</p>

    <p class="text-gray-300">Rescue. Rescue with 2 inputs requires 16 full founds, which together utilize 288 quadratic gates. In addition, each (out of 16) round carries two matrix multiplications, i.e.  <span class="math">2\\cdot 6</span>  addition gates per round. The total regular gate count is then 480. Rescue-Prime, a new variant of Rescue, requires only 14 rounds and, thus, is 12% cheaper.</p>

    <p class="text-gray-300">Sinsemilla. Sinsemilla is parameterized by k that determines the lookup table length  <span class="math">2^k</span>  and the same number of EC generators  <span class="math">P_0, P_1, \\ldots, P_{2k-1}</span> . A hash of tk-bit  <span class="math">M = (M_1, M_2, \\ldots, M_t), t &lt; 254</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$H(M) = (Q + \\sum_{i &lt; t} [2^{t-i}] P_{M_i})_x,</span>$</p>

    <p class="text-gray-300">where Q is some EC point, + is EC addition, [a] is the EC scalar multiplication by a,  <span class="math">()_x</span>  is the x-coordinate of the curve.</p>

    <p class="text-gray-300">To make a regular gate measurement, we take their system [24] of 5t quadratic equations and a single t-ary addition of message decomposition. Measuring in regular gates, we obtain that SINSEMILLA needs 9t arithmetic gates, and t lookup gates. For k=10 and t=51 we obtain 510-bit message input, for which the total gate count is about 510 regular gates.</p>

    <p class="text-gray-300">The authors also provide an optimized version with 51 custom gates of degree 6 and arity 5. This yields the area-degree product of  <span class="math">51 \\cdot 6 \\cdot 5 = 1530</span> .</p>

    <p class="text-gray-300">We implemented RC in pure Rust using the ff_ce library<sup>3</sup> for field operations. Further, we re-implemented Poseidon, Rescue, and Griffin with a statesize of 3 words, Neptune using a statesize of 4 words, and Feistel-MiMC using ff_ce to compare them to RC in a fair setting. We further compare RC to pure Rust implementations of traditional hash algorithms<sup>4</sup>, and compare it to Sinsemilla using an implementation found in the Zcash/Orchard repository on Github<sup>5</sup>, and to a Pedersen Hash implementation from librustzcash<sup>6</sup>. We benchmark input sizes of at least 512-bit (i.e., two field elements in RC). We, thus, benchmark one permutation call for all symmetric hash functions, except for Feistel-MiMC for which we require two.</p>

    <p class="text-gray-300">All benchmarks were obtained on a Linux Desktop PC with an Intel i7-4790 CPU (3.6 GHz) and 16 GB RAM using stable Rust version 1.58 and the target-cpu=native flag. The resulting benchmarks can be found in Table 2, code to reproduce them is publicly available at [1].</p>

    <p class="text-gray-300">Table 2: Plain performance comparison in nano-seconds (ns) of different hash functions over prime fields with primes  <span class="math">p_{\\rm BN254}, p_{\\rm BLS381}, p_{\\rm ST}</span> . Implemented in Rust.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hashing algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BN</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ST</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ns</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ns</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ns</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ns</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 419</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 538</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 087</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Concrete Layer</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bricks Layer</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">172.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">188.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">101.67</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bars Layer</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 063</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2062</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">204.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19 944</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20.423</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18 185</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RESCUE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">470030</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">498 210</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">388 430</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue-Prime</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">408 780</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">431 130</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">314 660</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Feistel-MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37 980</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39 883</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31 894</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Griffin</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">113 670</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120450</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90 455</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Neptune</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20 265</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20 453</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18 825</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sinsemilla</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137 600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pedersen Hash</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54027</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">319.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">213.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA3-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">419.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">As Table 2 shows, the plain performance of RC highly depends on the choice of the prime field, more specifically, how elements can be decomposed. The Bars-layer for  <span class="math">p_{ST}</span>  can be evaluated by using only one big-integer division<sup>7</sup>, whereas a generic decomposition, i.e., for  <span class="math">p_{BN254}</span>  and  <span class="math">p_{BLS12}</span> , requires significantly more. The result is a runtime difference by a factor of 3 for the total hashing time. Compared to the previous state-of-the-art one can observe that RC is significantly faster. More concretely, RC is faster than the previously fastest hash function over finite fields (i.e., Poseidon) by a factor of 5 for  <span class="math">p_{BN254}</span>  and  <span class="math">p_{BLS12}</span> , and by a factor 16 for the  <span class="math">p_{ST}</span>  prime field. The Sinsemilla hash algorithm, which also leverages lookup tables for a faster plain evaluation, is thereby slower than RC by a factor of up to 125, while the traditional Pedersen Hash is only slower by a factor of 49. Compared to fast binary hash function, RC is only slower by a factor of 5 than Blake2, the fastest benchmarked hashing algorithm. Blake2 in turn however requires 7 times more Plookup gates than RC.</p>

    <p class="text-gray-300">To further highlight the requirement for fast plain performance of ZK-friendly hash functions, we compare the runtime to accumulate a Merkle tree with  <span class="math">2^{20}</span>  elements in Table 3. One can observer, that using traditional hash function, accumulating the Merkle tree already requires 3 s, the runtime is significantly worse when using ZK-friendly hash functions, such as POSEIDON and RESCUE. RC with</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup>https://docs.rs/ff_ce/0.13.1/ff ce/</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^4&lt;/sup&gt; https://github.com/RustCrypto/hashes \\\\</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>https://github.com/zcash/orchard, uses lookup tables to speed up performance.</p>

    <p class="text-gray-300"><sup>6</sup>https://github.com/zcash/librustzcash</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>We implemented divisions using precomputed reciprocals for all prime fields.</p>

    <p class="text-gray-300">Table 3: Performance comparison in seconds (s) of different hash functions over prime fields with primes  <span class="math">p_{\\rm BN254}, p_{\\rm BLS381}, p_{\\rm ST}</span>  for computing a Merkle tree with  <span class="math">2^{20}</span>  elements. Implemented in Rust.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hashing algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BN</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ST</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.91</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.97</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.36</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RESCUE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">497.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">520.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">396.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue-Prime</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">436.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">458.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">324.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Feistel-MiMC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Griffin</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">122.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">95.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Neptune</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sinsemilla</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">144.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Pedersen Hash</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.624</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.225</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.222</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA3-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.439</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">its fast plain performance, however, is only insignificantly slower then traditional hash functions, making it the optimal choice for use case which require fast plain performance, as well as fast ZK-proof generation.</p>

    <p class="text-gray-300"><strong>Acknowledgements.</strong> We express our special thanks to Ferdinand Sauer for valuable discussion on Gr&ouml;bner basis computations and for his assistance in conducting the practical experiments. We thank Alex Vlasov (Matter Labs) for his modular math optimizations and comments on the earlier version of the paper.</p>

    <p class="text-gray-300">Lorenzo Grassi is supported by the European Research Council under the ERC advanced grant agreement under grant ERC-2017-ADG Nr. 788980 ESCADA. Roman Walch is supported by the &quot;DDAI&quot; COMET Module within the COMET &ndash; Competence Centers for Excellent Technologies Programme, funded by the Austrian Federal Ministry for Transport, Innovation and Technology (bmvit), the Austrian Federal Ministry for Digital and Economic Affairs (bmdw), the Austrian Research Promotion Agency (FFG), the province of Styria (SFG) and partners from industry and academia. The COMET Programme is managed by FFG.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"> Hash functions for zero-knowledge applications zoo. https://extgit.iaik.tugraz.at/ krypto/zkfriendlyhashzoo (Aug 2021), IAIK, Graz University of Technology</p></li>
      <li><p class="text-gray-300">[2] Tornado cash privacy solution version 1.4 (2021), https://tornado.cash/Tornado.cash_whitepaper_v1.4.pdf</p></li>
      <li><p class="text-gray-300">[3] ZCash protocol specification (2022, 1st February), https://github.com/zcash/zips/blob/master/protocol/protocol.pdf</p></li>
      <li><p class="text-gray-300">[4] Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., L&uuml;ftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC. In: ASIACRYPT. LNCS, vol. 11923, pp. 371&ndash;397 (2019)</p></li>
      <li><p class="text-gray-300">[5] Albrecht, M.R., Grassi, L., Perrin, L., Ramacher, S., Rechberger, C., Rotaru, D., Roy, A., Schofnegger, M.: Feistel Structures for MPC, and More. In: ESORICS. LNCS,</p></li>
      <li><p class="text-gray-300">vol. 11736, pp. 151-171. Springer (2019)</p></li>
      <li><p class="text-gray-300">[6] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In: ASIACRYPT 2016. LNCS, vol. 10031, pp. 191&ndash;219 (2016)</p></li>
      <li><p class="text-gray-300">[7] Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. IACR Trans. Symmetric Cryptol. 2020(3), 1&ndash;45 (2020)</p></li>
      <li><p class="text-gray-300">[8] Ashur, T., Dhooghe, S.: MARVELlous: a STARK-Friendly Family of Cryptographic Primitives. Cryptology ePrint Archive, Report 2018/1098 (2018)</p></li>
      <li><p class="text-gray-300">Baign&egrave;res, T., Stern, J., Vaudenay, S.: Linear Cryptanalysis of Non Binary Ciphers.
In: Adams, C.M., Miri, A., Wiener, M.J. (eds.) Selected Areas in Cryptography &ndash;
SAC 2007. LNCS, vol. 4876, pp. 184&ndash;211. Springer (2007)</p></li>
      <li><p class="text-gray-300">[10] Bardet, M., Faugere, J., Salvy, B., Yang, B.: Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems. In: The Effective Methods in Algebraic Geometry Conference (MEGA). pp. 1&ndash;14 (2005)</p></li>
      <li><p class="text-gray-300">[11] Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Practical algebraic attacks against some arithmetization-oriented hash functions (2022), available at https://hal. archives-ouvertes.fr/hal-03518757/document</p></li>
      <li><p class="text-gray-300">[12] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Fast Reed-Solomon interactive oracle proofs of proximity. In: ICALP. LIPIcs, vol. 107, pp. 14:1&ndash;14:17. Schloss Dagstuhl - Leibniz-Zentrum f&uuml;r Informatik (2018)</p></li>
      <li><p class="text-gray-300">[13] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for R1CS. In: EUROCRYPT (1). Lecture Notes in Computer Science, vol. 11476, pp. 103&ndash;128. Springer (2019)</p></li>
      <li><p class="text-gray-300">[14] Bertoni, G., Daemen, J., Peeters, M., Assche, G.V.: On the Indifferentiability of the Sponge Construction. In: EUROCRYPT 2008. LNCS, vol. 4965, pp. 181&ndash;197 (2008)</p></li>
      <li><p class="text-gray-300">[15] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On alignment in Keccak. https://keccak.team/files/KeccakAlignment.pdf</p></li>
      <li><p class="text-gray-300">[16] Beyne, T., Canteaut, A., Dinur, I., Eichlseder, M., Leander, G., Leurent, G., Naya-Plasencia, M., Perrin, L., Sasaki, Y., Todo, Y., Wiemer, F.: Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems. In: CRYPTO. LNCS, vol. 12172, pp. 299&ndash;328 (2020)</p></li>
      <li><p class="text-gray-300">[17] Biham, E., Biryukov, A., Shamir, A.: Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In: EUROCRYPT. LNCS, vol. 1592, pp. 12&ndash;23. Springer (1999)</p></li>
      <li><p class="text-gray-300">[18] Biham, E., Shamir, A.: Differential Cryptanalysis of DES-like Cryptosystems. In: Advances in Cryptology - CRYPTO 1990. LNCS, vol. 537, pp. 2&ndash;21. Springer (1990)</p></li>
      <li><p class="text-gray-300">[19] Biham, E., Shamir, A.: Differential Cryptanalysis of the Data Encryption Standard. Springer (1993)</p></li>
      <li><p class="text-gray-300">[20] Bogdanov, A., Wang, M.: Zero Correlation Linear Cryptanalysis with Reduced Data Complexity. In: FSE. LNCS, vol. 7549, pp. 29&ndash;48. Springer (2012)</p></li>
      <li><p class="text-gray-300">[21] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo infinite: Proof-carrying data from additive polynomial commitments. In: CRYPTO 2021. LNCS, vol. 12825, pp. 649&ndash;680 (2021)</p></li>
      <li><p class="text-gray-300">[22] Bootle, J., Cerulli, A., Groth, J., Jakobsen, S.K., Maller, M.: Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In: ASIACRYPT (1). Lecture Notes in Computer Science, vol. 11272, pp. 595&ndash;626. Springer (2018)</p></li>
      <li><p class="text-gray-300">[23] Boura, C., Canteaut, A., De Canni&egrave;re, C.: Higher-Order Differential Properties of Keccak and Luffa. In: FSE 2011. LNCS, vol. 6733, pp. 252&ndash;269 (2011)</p></li>
      <li><p class="text-gray-300">[24] Bowe, S., Hopwood, D.: Zcash Orchard: Sinsemilla Gadget (2021), available at https://zcash.github.io/orchard/design/circuit/gadgets/sinsemilla.html</p></li>
      <li><p class="text-gray-300">[25] B&uuml;nz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: CRYPTO (1). Lecture Notes in Computer Science, vol. 12825, pp. 681&ndash;710. Springer (2021)</p></li>
      <li><p class="text-gray-300">[26] B&uuml;nz, B., Chiesa, A., Mishra, P., Spooner, N.: Recursive proof composition from accumulation schemes. In: TCC (2). Lecture Notes in Computer Science, vol. 12551, pp. 1&ndash;18. Springer (2020)</p></li>
      <li><p class="text-gray-300">[27] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: EUROCRYPT (1). Lecture Notes in Computer Science, vol. 12105, pp. 769&ndash;793. Springer (2020)</p></li>
      <li><p class="text-gray-300">[28] Cid, C., Leurent, G.: An Analysis of the XSL Algorithm. In: Advances in Cryptology - ASIACRYPT 2005. LNCS, vol. 3788, pp. 333&ndash;352. Springer (2005)</p></li>
      <li><p class="text-gray-300">[29] Courtois, N.T., Pieprzyk, J.: Cryptanalysis of Block Ciphers with Overdefined Systems of Equations. In: ASIACRYPT. LNCS, vol. 2501, pp. 267&ndash;287. Springer (2002)</p></li>
      <li><p class="text-gray-300">[30] Cox, D.A., Little, J., O'Shea, D.: Ideals, varieties, and algorithms - an introduction to computational algebraic geometry and commutative algebra (2. ed.). Undergraduate texts in mathematics, Springer (1997)</p></li>
      <li><p class="text-gray-300">[31] Daemen, J., Knudsen, L.R., Rijmen, V.: The Block Cipher Square. In: FSE. LNCS, vol. 1267, pp. 149&ndash;165 (1997)</p></li>
      <li><p class="text-gray-300">[32] Daemen, J., Rijmen, V.: The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography, Springer (2002)</p></li>
      <li><p class="text-gray-300">[33] Eichlseder, M., Grassi, L., L&uuml;ftenegger, R., &Oslash;ygarden, M., Rechberger, C., Schofnegger, M., Wang, Q.: An algebraic attack on ciphers with low-degree round functions: Application to full mimc. In: ASIACRYPT. LNCS, vol. 12491, pp. 477&ndash;506. Springer (2020)</p></li>
      <li><p class="text-gray-300">[34] Gabizon, A., Williamson, Z.J.: plookup: A simplified polynomial protocol for lookup tables. IACR Cryptol. ePrint Arch. 2020, 315 (2020)</p></li>
      <li><p class="text-gray-300">[35] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over lagrangebases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint Arch. 2019, 953 (2019)</p></li>
      <li><p class="text-gray-300">[36] Genovese, G.: Improving the algorithms of berlekamp and niederreiter for factoring polynomials over finite fields. J. Symb. Comput. 42(1-2), 159&ndash;177 (2007)</p></li>
      <li><p class="text-gray-300">[37] Goldberg, L., Papini, S., Riabzev, M.: Cairo-a turing-complete stark-friendly cpu architecture. Cryptology ePrint Archive (2021)</p></li>
      <li><p class="text-gray-300">[38] Grassi, L.: Mixture Differential Cryptanalysis: a New Approach to Distinguishers and Attacks on round-reduced AES. IACR Trans. Symmetric Cryptol. 2018(2), 133&ndash;160 (2018)</p></li>
      <li><p class="text-gray-300">[39] Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: A New Feistel Approach Meets Fluid-SPN: Griffin for Zero-Knowledge Applications. Cryptology ePrint Archive, Report 2022/403 (2022), https://ia.cr/2022/403</p></li>
      <li><p class="text-gray-300">[40] Grassi, L., Khovratovich, D., R&oslash;njom, S., Schofnegger, M.: The legendre symbol and the modulo-2 operator in symmetric schemes over  <span class="math">\\mathbb{F}_p^n</span> . Cryptology ePrint Archive (2021)</p></li>
      <li><p class="text-gray-300">[41] Grassi, L., Khovratovich, D., Roy, A., Rechberger, C., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. Usenix Security 2021 (2021)</p></li>
      <li><p class="text-gray-300">[42] Grassi, L., L&uuml;ftenegger, R., Rechberger, C., Rotaru, D., Schofnegger, M.: On a generalization of substitution-permutation networks: The HADES design strategy. In: EUROCRYPT (2). Lecture Notes in Computer Science, vol. 12106, pp. 674&ndash;704. Springer (2020)</p></li>
      <li><p class="text-gray-300">[43] Grassi, L., Onofri, S., Pedicini, M., Sozzi, L.: Invertible Quadratic Non-Linear Layers for MPC-/FHE-/ZK-Friendly Schemes over F<sup>n</sup><sub>p</sub>. Cryptology ePrint Archive, Report 2021/1695 (2021), https://ia.cr/2021/1695</p></li>
      <li><p class="text-gray-300">[44] Grassi, L., Rechberger, C., R&oslash;njom, S.: Subspace Trail Cryptanalysis and its Applications to AES. IACR Trans. Symmetric Cryptol. 2016(2), 192&ndash;225 (2016)</p></li>
      <li><p class="text-gray-300">[45] Grassi, L., Rechberger, C., R&oslash;njom, S.: A New Structural-Differential Property of 5-Round AES. In: EUROCRYPT. LNCS, vol. 10211, pp. 289&ndash;317 (2017)</p></li>
      <li><p class="text-gray-300">[46] Grassi, L., Rechberger, C., Schofnegger, M.: Proving Resistance Against Infinitely Long Subspace Trails: How to Choose the Linear Layer. IACR Trans. Symmetric Cryptol. 2021(2) (2021)</p></li>
      <li><p class="text-gray-300">[47] Groth, J.: On the size of pairing-based non-interactive arguments. In: EURO-CRYPT (2). Lecture Notes in Computer Science, vol. 9666, pp. 305&ndash;326. Springer (2016)</p></li>
      <li><p class="text-gray-300">[48] Guido, B., Joan, D., Micha&euml;l, P., Gilles, V.: Cryptographic sponge functions (2011)</p></li>
      <li><p class="text-gray-300">[49] Hopwood, D.: Zcon0 conference notes (2019), available at https://www.zfnd.org/ zcon/0/workshop-notes/Zcon0%20Circuit%20Optimisation%20handout.pdf</p></li>
      <li><p class="text-gray-300">[50] Jakobsen, T., Knudsen, L.R.: The Interpolation Attack on Block Ciphers. In: FSE 1997. LNCS, vol. 1267, pp. 28&ndash;40 (1997)</p></li>
      <li><p class="text-gray-300">[51] Keller, N., Rosemarin, A.: Mind the Middle Layer: The HADES Design Strategy Revisited. In: EUROCRYPT. LNCS, vol. 12697, pp. 35&ndash;63. Springer (2021)</p></li>
      <li><p class="text-gray-300">[52] Knudsen, L.R.: Truncated and Higher Order Differentials. In: FSE 1994. LNCS, vol. 1008, pp. 196&ndash;211 (1994)</p></li>
      <li><p class="text-gray-300">[53] Knudsen, L.R.: DEAL - A 128-bit Block Cipher. (1998)</p></li>
      <li><p class="text-gray-300">[54] Lai, X.: Higher order derivatives and differential cryptanalysis. In: Communications and Cryptography: Two Sides of One Tapestry. pp. 227&ndash;233. Springer US (1994)</p></li>
      <li><p class="text-gray-300">[55] Lamberger, M., Mendel, F., Rechberger, C., Rijmen, V., Schl&auml;ffer, M.: Rebound Distinguishers: Results on the Full Whirlpool Compression Function. In: ASIACRYPT 2009. LNCS, vol. 5912, pp. 126&ndash;143 (2009)</p></li>
      <li><p class="text-gray-300">[56] Leander, G., Abdelraheem, M.A., AlKhzaimi, H., Zenner, E.: A Cryptanalysis of PRINTcipher: The Invariant Subspace Attack. In: CRYPTO. LNCS, vol. 6841, pp. 206&ndash;221 (2011)</p></li>
      <li><p class="text-gray-300">[57] Leander, G., Minaud, B., R&oslash;njom, S.: A Generic Approach to Invariant Subspace Attacks: Cryptanalysis of Robin, iSCREAM and Zorro. In: EUROCRYPT. LNCS, vol. 9056, pp. 254&ndash;283 (2015)</p></li>
      <li><p class="text-gray-300">[58] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. In: CCS. pp. 2111&ndash;2128. ACM (2019)</p></li>
      <li><p class="text-gray-300">[59] Matsui, M.: Linear Cryptanalysis Method for DES Cipher. In: EUROCRYPT 1993. LNCS, vol. 765, pp. 386&ndash;397 (1993)</p></li>
      <li><p class="text-gray-300">[60] Mendel, F., Rechberger, C., Schl&auml;ffer, M., Thomsen, S.S.: The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Gr&oslash;stl. In: FSE 2009. LNCS, vol. 5665, pp. 260&ndash;276 (2009)</p></li>
      <li><p class="text-gray-300">[61] Ozdemir, A., Wahby, R., Whitehat, B., Boneh, D.: Scaling verifiable computation using efficient set accumulators. In: 29th {USENIX} Security Symposium ({USENIX} Security 20). pp. 2075&ndash;2092 (2020)</p></li>
      <li><p class="text-gray-300">[62] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: IEEE Symposium on Security and Privacy. pp. 238&ndash;252. IEEE Computer Society (2013)</p></li>
      <li><p class="text-gray-300">[63] Pearson, L., Fitzgerald, J., Masip, H., Bell&eacute;s-Mu&ntilde;oz, M., Mu&ntilde;oz-Tapia, J.L.: Plonkup: Reconciling plonk with plookup. Cryptology ePrint Archive (2022)</p></li>
      <li><p class="text-gray-300">[64] Sauer, J.F., Szepieniec, A.: Sok: Gr&ouml;bner basis algorithms for arithmetization</p></li>
      <li><p class="text-gray-300">oriented ciphers. Cryptology ePrint Archive (2021) [65] Szepieniec, A.: On the use of the legendre symbol in symmetric cipher design. Cryptology ePrint Archive (2021)</p></li>
      <li><p class="text-gray-300">[66] Tram&egrave;r, F., Boneh, D., Paterson, K.: Remote side-channel attacks on anonymous transactions. In: USENIX Security Symposium. pp. 2739&ndash;2756. USENIX Association (2020)</p></li>
      <li><p class="text-gray-300">[67] Wagner, D.A.: The Boomerang Attack. In: FSE 1999. LNCS, vol. 1636, pp. 156&ndash;170 (1999)</p></li>
      <li><p class="text-gray-300">[68] Williamson, Z.: zkSummit: Plookup (2020), available at https://youtu.be/ Vdlc1CmRYRY?t=1564</p></li>
      <li><p class="text-gray-300">[69] Wood, G., et al.: Ethereum: A secure decentralised generalised transaction ledger. ethereum project yellow paper. (2014) (2014)</p></li>
    </ul>

    <p class="text-gray-300">Given  <span class="math">\\alpha_1, \\alpha_2, \\beta_1, \\beta_2 \\in \\mathbb{F}_p</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\alpha_i^2 - 4 \\cdot \\beta_i</span>$
is a <strong>non</strong>-quadratic residue mod  <span class="math">p</span> ,</p>

    <p class="text-gray-300">for each  <span class="math">i \\in \\{1,2\\}</span> , the generalized Bricks function is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$Bricks(x_1, x_2, x_3)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (x_1^d, x_2(x_1^2 + \\alpha_1 x_1 + \\beta_1), x_3(x_2^2 + \\alpha_2 x_2 + \\beta_2)).</span>$</p>

    <p class="text-gray-300">This function is invertible. Indeed, given  <span class="math">Bricks(x_1, x_2, x_3) = (y_1, y_2, y_3)</span> , we have</p>

    <p class="text-gray-300"><span class="math">$x_1 = y_1^{1/d}, \\quad x_2 = \\frac{y_2}{(x_1^2 + \\alpha_1 \\cdot x_1 + \\beta_1)},</span>$
<span class="math">$x_3 = \\frac{y_3}{(x_2^2 + \\alpha_2 \\cdot x_2 + \\beta_2)},</span>$</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">x \\mapsto x^d</span>  is invertible due to the assumption on d,</li>
      <li>(2)  <span class="math">z^2 + \\alpha_i \\cdot z + \\beta_i \\neq 0</span>  for each  <span class="math">z \\in \\mathbb{F}_p</span>  due to the definition of  <span class="math">\\alpha_i, \\beta_i</span> . In particular, the only possible solutions of this equation would be</li>
    </ul>

    <p class="text-gray-300"><span class="math">$z_{\\pm} = \\left(-\\alpha_i \\pm \\sqrt{\\alpha_i^2 - 4 \\cdot \\beta_i}\\right)/2,</span>$</p>

    <p class="text-gray-300">which do not exist due to the fact that  <span class="math">\\alpha_i^2 - 4 \\cdot \\beta_i</span>  is not a square.</p>

    <p class="text-gray-300">LEMMA 3. The function Bar permutes  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We work with the standard representations of  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">\\mathbb{Z}_{s_1}, \\ldots, \\mathbb{Z}_{s_n}</span> . For  <span class="math">\\mathcal{R} := \\mathbb{Z}_{s_1} \\times \\ldots \\times \\mathbb{Z}_{s_n}</span>  let</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_{&lt; p} := \\{(z_1, \\dots, z_n) \\in \\mathcal{R} : \\sum_{i=1}^n z_i b_i &lt; p\\}.</span>$</p>

    <p class="text-gray-300">The idea of the proof reads as follows: we show that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Decomp is injective and  <span class="math">\\mathsf{Decomp}(\\mathbb{F}_p) \\subseteq \\mathcal{R}_{&lt; p}</span> ;</li>
      <li>(2)  <span class="math">\\operatorname{SBox}(\\mathcal{R}_{&lt; p}) \\subseteq \\mathcal{R}_{&lt; p}</span>  and deduce that  <span class="math">\\operatorname{SBox}</span>  permutes  <span class="math">\\mathcal{R}_{&lt; p}</span> ;</li>
      <li>(3) Comp is injective on  <span class="math">\\mathcal{R}_{&lt; p}</span> .</li>
    </ul>

    <p class="text-gray-300">With these statements, it follows at once that the function Bar :  <span class="math">\\mathbb{F}_p \\to \\mathbb{F}_p</span>  given by</p>

    <p class="text-gray-300"><span class="math">$Bar = Comp \\circ SBox \\circ Decomp</span>$</p>

    <p class="text-gray-300">is injective and hence surjective as well. In particular, we see that Decomp and Comp are indeed inverse functions over  <span class="math">\\mathcal{R}_{&lt; p}</span>  and  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Ad (1), (3): the statement  <span class="math">\\mathsf{Decomp}(\\mathbb{F}_p) \\subseteq \\mathcal{R}_{&lt; p}</span>  is a direct consequence of the definition of  <span class="math">\\mathsf{Decomp}</span> . For the injectivity of  <span class="math">\\mathsf{Decomp}</span>  we</p>

    <p class="text-gray-300">show that it has a left inverse function on  <span class="math">\\mathcal{R}_{&lt; p}</span>  which is precisely given by Comp restricted to  <span class="math">\\mathcal{R}_{&lt; p}</span> . Indeed, for  <span class="math">x \\in \\mathbb{F}_p</span>  it holds</p>

    <p class="text-gray-300"><span class="math">$(Comp \\circ Decomp)(x) = Comp(x_1, \\dots, x_n)</span>$</p>

    <p class="text-gray-300"><span class="math">$=\\sum_{i=1}^{n} x_i b_i \\mod p = \\sum_{i=1}^{n} x_i b_i = x.</span>$</p>

    <p class="text-gray-300">The second equality is just the definition of Comp, the third equality uses the fact that  <span class="math">\\mathsf{Decomp}(\\mathbb{F}_p) \\subseteq \\mathcal{R}_{&lt; p}</span> , and the fourth equality is true by definition of  <span class="math">\\mathsf{Decomp}</span> . Similarly, we obtain for  <span class="math">(z_1, \\ldots, z_n) \\in \\mathcal{R}_{&lt; p}</span></p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;(\\mathsf{Decomp} \\circ \\mathsf{Comp})(z_1, \\dots, z_n) \\\\ &amp;= \\mathsf{Decomp}(\\sum_{i=1}^n z_i b_i \\bmod p) \\\\ &amp;= \\mathsf{Decomp}(\\sum_{i=1}^n z_i b_i) = (z_1, \\dots, z_n) \\end{split}</span>$</p>

    <p class="text-gray-300">and hence that Comp restricted to  <span class="math">\\mathcal{R}_{&lt; p}</span>  has the left inverse Decomp. Ad (2): Since SBox is the parallel application of n smaller bijections it is clearly injective. The only assertion to prove is hence the inclusion  <span class="math">\\operatorname{SBox}(\\mathcal{R}_{&lt; p}) \\subseteq \\mathcal{R}_{&lt; p}</span> . Let  <span class="math">(x_1, x_2, \\ldots, x_n) \\in \\mathcal{R}_{&lt; p}</span>  and let  <span class="math">(y_1, \\ldots, y_n) = (S(x_1), \\ldots, S(x_n))</span>  denote the image under SBox. Now recall that  <span class="math">v = \\min_i v_i</span>  where  <span class="math">(v_1, v_2, \\ldots, v_n) = \\operatorname{Decomp}(p-1)</span> , and let m be the smallest index such that  <span class="math">x_m &lt; v</span> . If there is no such m, then all S-boxes S are identity functions and the assertion holds. If such an m exists, then for all i &lt; m we have  <span class="math">y_i = S(x_i) = x_i</span>  by the definition of the  <span class="math">S_i</span> . Moreover, for i = m we have  <span class="math">y_m = S(x_m) &lt; v \\le v_m</span> . For the remaining part we highlight the following property of our decomposition (which has an analogous counterpart in ordinary base-b expansion): for every  <span class="math">1 \\le k \\le n</span>  it holds</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{i=k+1}^{n}(s_{i}-1)b_{i} = \\sum_{i=k+1}^{n}(s_{i}-1)\\prod_{l&gt;i}s_{l} \\\\ &amp;= \\sum_{i=k+1}^{n}\\left(\\prod_{l&gt;i-1}s_{l}-\\prod_{l&gt;i}s_{l}\\right) = \\prod_{l&gt;k}s_{l}-1 = b_{k}-1. \\end{split}</span>$</p>

    <p class="text-gray-300">Informally speaking, this translates to the statement &quot;the sum of the maximal values of the first l = n - k least significant positions equals the value of the next greater significant position minus 1&quot;. We use this fact and deduce</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{n} y_i b_i = \\sum_{i=1}^{m-1} y_i b_i + y_m b_m + \\sum_{i=m+1}^{n} y_i b_i</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; \\sum_{i=1}^{m-1} x_i b_i + (y_m + 1) b_m \\le \\sum_{i=1}^{m-1} x_i b_i + v_m b_m</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\sum_{i=1}^{m-1} v_i b_i + v_m b_m \\le p - 1.</span>$</p>

    <p class="text-gray-300">Hence,  <span class="math">\\operatorname{SBox}(x_1,\\ldots,x_n)\\in\\mathcal{R}_{&lt; p}</span>  which implies that SBox permutes  <span class="math">\\mathcal{R}_{&lt; p}</span> . The second last inequality uses the property that for  <span class="math">u\\in\\mathbb{F}_p</span>  with  <span class="math">u\\leq p-1</span> , the decompositions  <span class="math">(u_1,\\ldots,u_n)</span>  and  <span class="math">(v_1,\\ldots,v_n)=</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Decomp}(p-1) \\in \\mathcal{R}</span>  satisfy for any  <span class="math">1 \\le k \\le n</span>  the inequality</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^k u_i b_i \\le \\sum_{i=1}^k v_i b_i.</span>$</p>

    <p class="text-gray-300">In other words, &quot;if u is smaller than or equal to v, the sum of the values of any first k most significant digits of u is smaller than or equal to the corresponding sum for v.&quot; For u = v, the statement is obvious. For  <span class="math">u \\neq v</span> , there is at least one index  <span class="math">1 \\leq i \\leq n</span>  with  <span class="math">u_i &lt; v_i</span> ; let t denote the minimal index with this property. If k &lt; t, then  <span class="math">\\sum_{i=1}^k u_i b_i = \\sum_{i=1}^k v_i b_i</span>  by definition of t. If  <span class="math">k \\geq t</span>  then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{k} u_i b_i = \\sum_{i=1}^{t-1} u_i b_i + u_t b_t + \\sum_{i=t+1}^{k} u_i b_i</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; \\sum_{i=1}^{t-1} u_i b_i + (u_t + 1) b_t \\le \\sum_{i=1}^{t-1} v_i b_i + v_t b_t</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\sum_{i=1}^{k} v_i b_i.</span>$</p>

    <p class="text-gray-300">In Eq. (4),  <span class="math">f: \\mathbb{F}_{p&#x27;} \\to \\mathbb{F}_{p&#x27;}</span>  denotes the non-identity part of each S-box  <span class="math">S_i</span> . Since  <span class="math">S_i</span>  shall be a permutation of  <span class="math">\\mathbb{Z}_{s_i}</span> , we also need f to be a permutation of  <span class="math">\\mathbb{F}_{p&#x27;}</span> . In particular, when f is represented as a univariate polynomial over  <span class="math">\\mathbb{F}_{p&#x27;}</span>  it needs to have a high degree and a dense polynomial description (i.e., many non-zero coefficients). Other properties (e.g., high nonlinearity) are not needed in this context, because security against the corresponding attacks is already achieved using the Bricks layer (through large-word operations). We apply the following technique to choose the function f.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) We choose the smallest  <span class="math">d \\in \\mathbb{N}</span>  such that d is prime,  <span class="math">d = 2^n 1</span>  for some  <span class="math">n \\in \\mathbb{N}</span> , and  <span class="math">\\gcd(d, p&#x27; 1) = 1</span> . The last requirement ensures that the resulting polynomial is a permutation polynomial over  <span class="math">\\mathbb{F}_{p&#x27;}</span> .</li>
      <li>(2) we compute the r-fold composition</li>
    </ul>

    <p class="text-gray-300"><span class="math">$f(X) := (f_r \\circ f_{r-1} \\circ \\cdots \\circ f_1)(X) \\in \\mathbb{F}_{p&#x27;} \\left[ X \\right],</span>$</p>

    <p class="text-gray-300">where
<span class="math">$f_i(X) := (X + c_i)^d</span>$
for random  <span class="math">c_i \\in \\mathbb{F}_{p&#x27;}</span> .</p>

    <p class="text-gray-300">In the second step, we set  <span class="math">r = 2 \\lceil \\log_d(p&#x27;) \\rceil</span> , and we want to reach a degree of p' - 2 and p' - 1 non-zero coefficients. If either of these conditions is not fulfilled, we sample a new set of r constants  <span class="math">c_1, c_2, \\ldots, c_r</span>  and apply the above function f again until the resulting polynomial is dense and of maximum degree. In our experiments, both conditions are fulfilled after only a small number of trials. We note that the final representation of f is similar to the polynomial representation of the MiMC permutation [6], where the key is set to a known constant.</p>

    <p class="text-gray-300">We practically evaluated the algebraic properties of the resulting S-box  <span class="math">S_i</span>  when embedded in  <span class="math">\\mathbb{F}_2^{n&#x27;}</span> , where  <span class="math">n&#x27; := \\lceil \\log_2(p&#x27;) \\rceil</span> . As expected, in our experiments we observed that the algebraic degree of  <span class="math">S_i</span>  is n' (note that  <span class="math">S_i</span>  embedded in  <span class="math">\\mathbb{F}_2^{n&#x27;}</span>  is not a permutation).<sup>8</sup></p>

    <p class="text-gray-300">For the sake of completeness, the  <span class="math">\\bar{\\text{full}}</span>  S-box definition is given in auxiliary files.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>The algebraic degree refers to the maximum degree of all component functions.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B</strong> SECURITY ANALYSIS</h2>

    <p class="text-gray-300">In this section, we analyze the security of our design against known attacks on bijective transformations relevant in the hash function and encryption settings.</p>

    <p class="text-gray-300">Firstly, we show that our design is secure against statistical attacks, including the differential one and its variants, the linear attack and the rebound attack. In order to achieve this goal, we make use of the same strategy originally proposed for HADESMIMC and POSEIDON. That is, we make use only of the Bricks and of the Concrete components in order to guarantee security against statistical attack. In particular, here we consider a variant of the RC permutation denoted by RC' in which the middle component Bricks-Concrete-Bars-Concrete-Bricks is replaced with a single Bricks, i.e.,</p>

    <p class="text-gray-300">RC' := Concrete<sup>(8)</sup>
<span class="math">$\\circ</span>$
Bricks  <span class="math">\\circ</span>  Concrete<sup>(7)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(6)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(3)</sup>  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Concrete<sup>(1)</sup>.</p>

    <p class="text-gray-300">We claim that if a sponge hash function instantiated with RC' is secure against the statistical attacks proposed in this section, then it is also secure if it is instantiated with the full RC permutation RC instead. This is a reasonable assumption, since RC exhibits the same structure, but increases the number of nonlinear components.</p>

    <p class="text-gray-300">B.1.1 Differential Cryptanalysis. Differential cryptanalysis [18, 19] and its variations are the most widely used techniques to analyze symmetric-key primitives. Given pairs of inputs with some fixed input differences, differential cryptanalysis considers the probability distribution of the corresponding output differences produced by the cryptographic primitive. Let  <span class="math">\\delta_I</span> ,  <span class="math">\\delta_O \\in \\mathbb{F}_p^t</span>  be respectively the input and the output differences through a function F over  <span class="math">\\mathbb{F}_p^t</span> . The differential probability (DP) of having a certain output difference  <span class="math">\\delta_O</span>  given a particular input difference  <span class="math">\\delta_I</span>  is equal to</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Prob}(\\delta_I \\to \\delta_O) = \\frac{|\\{x \\in \\mathbb{F}_p^t \\mid F(x + \\delta_I) - F(x) = \\delta_O\\}|}{p^t}.</span>$</p>

    <p class="text-gray-300">As our design is an iterated scheme, a cryptanalyst searches for ordered sequences of differences over any number of rounds that are called differential characteristics/trails. Assuming the independence of the rounds, the DP of a differential trail is the product of the DPs of its one-round differences. We claim that the security against differential attacks is achieved if every differential characteristic has a probability smaller than  <span class="math">p^{-2}</span> . This is due to the fact that many characteristics can be used together in order to set up the attack, which means that a probability of  <span class="math">p^{-1}</span>  may not be sufficient to provide security.</p>

    <p class="text-gray-300">To show that our scheme is secure against this attack, we start by considering the maximum differential probability ( <span class="math">DP_{max}</span> ) of each component of the Bar. As it is well known,</p>

    <p class="text-gray-300"><span class="math">$DP_{\\max}(x \\mapsto x^d) = (d-1)/p.</span>$</p>

    <p class="text-gray-300">In the Bricks layer, the maximum differential probability of  <span class="math">F(x,y) = x(y^2 + \\alpha y + \\beta)</span>  for an input difference  <span class="math">\\delta_I = (\\delta_{I,x}, \\delta_{I,y}) \\in \\mathbb{F}_p^2 \\setminus \\{(0,0)\\}</span>  and an output difference  <span class="math">\\delta_O \\in \\mathbb{F}_p</span>  (where  <span class="math">\\alpha, \\beta \\in \\mathbb{F}_p \\setminus \\{0\\}</span>  s.t.  <span class="math">\\alpha^2 - 4\\beta</span></p>

    <p class="text-gray-300">is not a square modulo p) is</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Prob}(\\delta_I \\to \\delta_O) \\leq \\left\\{ \\begin{array}{ll} \\frac{2}{p} &amp; \\text{if} \\quad \\delta_{I,y} = 0 \\quad \\text{or} \\quad \\delta_{I,x} = \\delta_O = 0, \\\\ \\frac{p-1}{p^2} &lt; \\frac{1}{p} &amp; \\text{otherwise}. \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">In particular,  <span class="math">\\delta_{I,y}=0 \\implies \\delta_O \\neq 0</span> . We refer to [39, Lemma 4] for this result. Here we show that the best differential characteristic over two rounds has probability at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{4(d-1)^2}{p^4} \\ll p^{-3}.</span>$</p>

    <p class="text-gray-300">Roughly speaking, this is due to the facts that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>at least four words are active (due to the branch number of the matrix that defines the linear layer),</li>
      <li>each active word affects the overall probability by a factor proportional to  <span class="math">p^{-1}</span> .</li>
    </ul>

    <p class="text-gray-300">Examples of differential characteristics that achieve a probability of  <span class="math">\\approx p^{-4}</span>  are the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) The third word at the input of the first round is active, while all words at the input of the second round are active, i.e.,  <span class="math">\\begin{pmatrix} 0 \\\\ 0 \\\\ \\delta_1 \\end{pmatrix} \\xrightarrow{\\text{Br.}(\\cdot)} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\delta_2 \\end{pmatrix} \\xrightarrow{\\text{Conc.}(\\cdot)} \\begin{pmatrix} \\delta_2 \\\\ \\delta_2 \\\\ 2\\delta_2 \\end{pmatrix} \\xrightarrow{\\text{Br.}(\\cdot)} \\begin{pmatrix} \\delta_3 \\\\ \\delta_4 \\\\ \\delta_5 \\end{pmatrix} \\text{ for fixed differences } \\delta_1, \\ldots, \\delta_5 \\in \\mathbb{F}_p. \\text{ Note that if } \\delta_2 \\text{ is not fixed, then the probability increases by a factor } p \\text{ (but it is still much smaller than } p^{-2} \\text{)}.}</span></li>
      <li>(2) At the input of both rounds, the second and the third words are active, i.e.,  <span class="math">\\begin{pmatrix} 0 \\\\ \\delta_1 \\\\ \\delta_2 \\end{pmatrix} \\xrightarrow{\\mathsf{Br.}(\\cdot)} \\begin{pmatrix} 0 \\\\ \\delta_3 \\\\ \\delta_4 \\end{pmatrix} \\xrightarrow{\\mathsf{Conc.}(\\cdot)} \\begin{pmatrix} \\delta_3 + \\delta_4 \\\\ 2\\delta_3 + \\delta_4 \\end{pmatrix} \\xrightarrow{\\mathsf{Br.}(\\cdot)} \\begin{pmatrix} \\delta_5 \\\\ \\delta_6 \\\\ \\delta_7 \\end{pmatrix} \\text{ for fixed differences } \\delta_1, \\dots, \\delta_7 \\in \\mathbb{F}_p \\text{ such that } \\delta_3 + \\delta_4 = \\delta_5 = 0.</span>  Note that if  <span class="math">\\delta_3</span>  is not fixed, then the probability increases by a factor p (but it is still much smaller than  <span class="math">p^{-2}</span> );</li>
      <li>(3) The first word at the input of the first round is active, while the second and third word at the input of the second round are active, i.e.,  <span class="math">\\begin{pmatrix} \\delta_1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\xrightarrow{\\text{Br.}(\\cdot)} \\begin{pmatrix} \\delta_2 \\\\ \\delta_3 \\\\ 0 \\end{pmatrix} \\xrightarrow{\\text{Conc.}(\\cdot)} \\begin{pmatrix} 2\\delta_2 + \\delta_3 \\\\ \\delta_2 + 2\\delta_3 \\end{pmatrix} \\xrightarrow{\\text{Br.}(\\cdot)} \\begin{pmatrix} \\delta_4 \\\\ \\delta_5 \\\\ \\delta_6 \\end{pmatrix}</span>  for fixed differences  <span class="math">\\delta_1, \\ldots, \\delta_6 \\in \\mathbb{F}_p</span>  such that  <span class="math">2 \\cdot \\delta_2 + \\delta_3 = \\delta_4 = 0</span> . Note that if  <span class="math">\\delta_2</span>  is not fixed, then the probability increases by a factor p (but it is still much smaller than  <span class="math">p^{-2}</span> ).</li>
    </ul>

    <p class="text-gray-300">Note that this last case is consistent with the branch number of the matrix. Indeed, note that if the first word is active at the input of Bricks, then the two first words in output are active. This means that the number of active input and output words of the matrix is four</p>

    <p class="text-gray-300">If the difference in the first words is non-zero in both rounds, then the probability of the differential characteristic is much smaller than  <span class="math">p^{-4}</span> , since at least other three words (for a total of five active words) are active at the input of the Bricks layer (in order to satisfy the branch number of the matrix, and due to the definition of the Bricks layer).</p>

    <p class="text-gray-300">As a result, two (consecutive) rounds are sufficient to provide security against differential attacks.</p>

    <p class="text-gray-300">B.1.2 Truncated and Impossible Differential Attacks. Truncated differential cryptanalysis [52] is a variant of classical differential cryptanalysis, in which the attacker can specify only part of the difference between pairs of texts. Impossible differential cryptanalysis was introduced by Biham et al. [17] and Knudsen [53]. It exploits differentials that occur with probability zero.</p>

    <p class="text-gray-300">Working over a single round, we have that</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} 0 \\\\ 0 \\\\ \\Delta_1 \\end{pmatrix} \\xrightarrow{\\text{Bricks}(\\cdot)} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\Delta_2 \\end{pmatrix} \\xrightarrow{\\text{Concrete}(\\cdot)} \\begin{pmatrix} \\Delta_2 \\\\ \\Delta_2 \\\\ 2 \\cdot \\Delta_2 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} \\Delta_1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\xrightarrow{\\mathsf{Bricks}(\\cdot)} \\begin{pmatrix} \\Delta_2 \\\\ \\Delta_3 \\\\ 0 \\end{pmatrix} \\xrightarrow{\\mathsf{Concrete}(\\cdot)} \\begin{pmatrix} 2 \\cdot \\Delta_2 + \\Delta_3 \\\\ \\Delta_2 + 2 \\cdot \\Delta_3 \\\\ \\Delta_2 + \\Delta_3 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">with probability 1 for (unknown) differences  <span class="math">\\Delta_1, \\Delta_2, \\Delta_3 \\in \\mathbb{F}_p</span>  (the case in which the middle word is active is analogous). In a similar way, if we activate the second and the third words in input, we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} 0 \\\\ \\Delta_1 \\\\ \\Delta_2 \\end{pmatrix} \\xrightarrow{\\mathsf{Bricks}(\\cdot)} \\begin{pmatrix} 0 \\\\ \\Delta_3 \\\\ \\Delta_4 \\end{pmatrix} \\xrightarrow{\\mathsf{Concrete}(\\cdot)} \\begin{pmatrix} \\Delta_3 + \\Delta_4 \\\\ 2 \\cdot \\Delta_3 + \\Delta_4 \\\\ \\Delta_3 + 2 \\cdot \\Delta_4 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">with probability 1 for (unknown) differences  <span class="math">\\Delta_1, \\ldots, \\Delta_4 \\in \\mathbb{F}_p</span> . If the two active words are in a different position in the input, then no truncated differential with probability 1 exists.</p>

    <p class="text-gray-300">Note that in both these cases, we we have a linear relation among the output differences. Such linear relation is then broken/lost after the next Bricks layer. The only way to extend them is that one output word is equal to zero. However, this happens with with probability 1/p, exactly as in the case in which the outputs are generated by a pseudo-random permutation (besides the fact that p is our security level). Due to this fact and since the Concrete layer is defined via the multiplication with a MDS matrix, it is not possible to extend the truncated differentials just given over more rounds (even when working with a nonzero probability  <span class="math">\\in (1/p, 1)</span> ). See also the analysis given in the previous section for the case of differential cryptanalysis in which the middle differences are not fixed.</p>

    <p class="text-gray-300">At the same time, it is possible to set up an impossible differential over two rounds, since  <span class="math">\\begin{pmatrix} 0 \\\\ 0 \\\\ \\Delta_1 \\end{pmatrix} \\xrightarrow{\\mathsf{Conc.oBr.}(\\cdot)} \\begin{pmatrix} \\Delta_2 \\\\ \\Delta_2 \\\\ 2\\Delta_2 \\end{pmatrix} \\neq \\begin{pmatrix} 0 \\\\ 0 \\\\ \\Delta_3 \\end{pmatrix} \\xrightarrow{\\mathsf{Conc.oBr.}(\\cdot)} \\begin{pmatrix} \\Delta_4 \\\\ \\Delta_4 \\\\ 2\\Delta_4 \\end{pmatrix}</span>  holds with probability 0 for (unknown) differences  <span class="math">\\Delta_1,\\ldots,\\Delta_4 \\in \\mathbb{F}_p</span> . It follows that three rounds are sufficient to provide security against truncated and impossible differential attacks.</p>

    <p class="text-gray-300">B.1.3 Meet-in-the-Middle and Boomerang Attacks. Meet-in-the-Middle and boomerang [67] distinguishers (and their variants) rely on chaining two good differential/linear trails. Due to the differential/linear analysis just proposed, we claim that our analyzed scheme RC' with six rounds (composed of Bricks layers) is secure against these attacks.</p>

    <p class="text-gray-300">B.1.4 Rebound Attacks. Rebound attacks were first presented in [55, 60]. The goal of this attack is to find two (input, output) pairs such that the two inputs satisfy a certain (truncated) input difference and the corresponding outputs satisfy a certain (truncated) output difference. The rebound attack consists of two phases, called inbound and outbound phase. According to these phases, the internal permutation of the hash function is split into three subparts. Let  <span class="math">P:\\mathbb{F}_p^t\\to\\mathbb{F}_p^t</span>  be the target permutation, then  <span class="math">P=P_{fw}\\circ P_{in}\\circ P_{bw}</span> . The inbound phase is in the middle of the permutation and the two outbound phases are next to the inbound part. In this inbound part, the attacker tries to cover a middle part in the construction</p>

    <p class="text-gray-300">separately, which would otherwise be expensive in a classical differential attack. Having found input and output differences such that this part is covered in the inbound phase, the attacker now extends the trail in both directions in the outbound phase.</p>

    <p class="text-gray-300">Here we show that RC' (namely, the 6-round variant of the RC permutation in which the middle component is replaced with a single Bricks layer) is secure against the rebound attack.</p>

    <p class="text-gray-300">Inbound Phase. From Appendix B.1.2 we know that there exist truncated differentials with a probability of 1 over a single round. However, these cannot be extended over more rounds, not even when considering probabilities between 1/p and 1. Hence, using an inside-out approach, the attacker can cover two rounds in the inbound phase.</p>

    <p class="text-gray-300">In order to apply the outbound phase and due to the truncated differential trails that we found, it is desirable that the difference in at least one word of the trail found by the inbound phase is equal to zero. Again, this cannot be achieved with a probability larger than 1/p. Hence, we claim that the attacker cannot cover three (or more) rounds in the inbound phase.</p>

    <p class="text-gray-300">Outbound Phase. In order to extend the trails found in the inbound phase, we make use of the results regarding the truncated differentials presented before. Since one round can always be covered with a truncated differential characteristic of probability 1, the attacker can skip two rounds (one in each direction).</p>

    <p class="text-gray-300">Conclusion. Due to the analysis just proposed, we claim that RC' instantiated with six rounds is secure against the rebound attack as we can't find an attack on five rounds or more. Since the hash sponge function instantiated with this weaker permutation is secure with respect to this attack, the same result holds when considering the original permutation RC.</p>

    <p class="text-gray-300">B.1.5 Linear and Zero-Correlation Cryptanalysis. In the case of Boolean functions, linear cryptanalysis [59] searches for a linear combination of input, output and (if present) key bits that is unbalanced, i.e., biased towards 0 or towards 1. In the  <span class="math">\\mathbb{F}_p</span>  case, linear cryptanalysis [9] consists in the search of a linear combination of input, output, and (if present) key words that is unbalanced, i.e., biased towards an element of  <span class="math">\\mathbb{F}_p</span>  with probability higher than  <span class="math">1/|\\mathbb{F}_p|=1/p</span> . Linear attacks pose no threat to our design instantiated with the same number of rounds previously defined for classical differential cryptanalysis.</p>

    <p class="text-gray-300">Similar to impossible differential attack, zero-correlation attacks are a variant of linear attacks that exploit linear hulls with a zero correlation [20]. In general, those linear hulls are found by a missin-the-middle approach. E.g., the approach is to combine two trails that propagate some deterministic properties in order to ensure that the property cannot be fulfilled. Due to our security analysis against linear and differential cryptanalysis and since our analyzed scheme RC' has four Bricks layers, we claim that finding impossible differentials or zero-correlation linear hulls is infeasible.</p>

    <p class="text-gray-300">B.1.6 Square/Integral &amp; Mixture Differential Attacks. Integral cryptanalysis is an attack first applied on SQUARE [31] and is particularly efficient against block ciphers based on strong-aligned SPN schemes [15], as AES and AES-like schemes. It is based on the analysis the propagation of sums of values. In the case of our</p>

    <p class="text-gray-300">scheme, only one round can be covered with such an attack, e.g.9</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} C \\\\ C \\\\ A \\end{pmatrix} \\xrightarrow{\\mathsf{Bricks}(\\cdot)} \\begin{pmatrix} C \\\\ C \\\\ A \\end{pmatrix} \\xrightarrow{\\mathsf{Concrete}(\\cdot)} \\begin{pmatrix} A \\\\ A \\\\ A \\end{pmatrix} \\xrightarrow{\\mathsf{Bricks}(\\cdot)} \\begin{pmatrix} ? \\\\ ? \\\\ ? \\end{pmatrix}, \\text{ since both Bricks and }</span>$</p>

    <p class="text-gray-300">Concrete mix the components of the state.</p>

    <p class="text-gray-300">Other distinguishers that are particular efficient against strongaligned schemes are the &quot;multiple-of-n&quot; one [45] and the mixture differential cryptanalysis [38]. By appropriate choices of a number of input pairs (related by particular linear/differential relations), it is possible to make sure that the number of times that the difference of the resulting output pairs lie in a particular subspace is always a multiple of n. Since both Bricks and Concrete mix the components of the state, we claim that these attacks pose no threat to our design.</p>

    <p class="text-gray-300">B.2.1 Invariant Subspaces. Following [44], we say that a subspace  <span class="math">S \\subseteq \\mathbb{F}_p^t</span>  is invariant for a function F over  <span class="math">\\mathbb{F}_p^t</span>  if and only if for each  <span class="math">a \\in \\mathbb{F}_p^t</span>  there exists  <span class="math">b \\in \\mathbb{F}_p^t</span>  such that</p>

    <p class="text-gray-300"><span class="math">$F(S+a) = S+b</span>$</p>

    <p class="text-gray-300">For completeness, we mention that this definition is a slightly different from the one proposed in [56, 57], which is based on the existence of weak keys.</p>

    <p class="text-gray-300">Here we analyze the security of our scheme against this attack, since recent proposals have shown vulnerabilities [16, 46]. We start with the Bars layer. Since Bars operates independently on each input word, we have the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>All subspaces in which only a single word is active (e.g.,  <span class="math">S = \\langle (0, 1, 0) \\rangle</span>  are invariant through it. In other words, if the difference in one word is equal to zero, it remains equal to zero after Bars.</li>
      <li>The subspaces of the form  <span class="math">\\langle (1,1,0) \\rangle</span> , or  <span class="math">\\langle (1,0,1) \\rangle</span> , or  <span class="math">\\langle (0,1,1) \\rangle</span> , or  <span class="math">\\langle (1,1,1) \\rangle</span>  are invariant since the same function f defined in Eq. (4) is applied on each word.</li>
    </ul>

    <p class="text-gray-300">At the same time, note that the subspaces of the form e.g.  <span class="math">\\langle (1, a, 0) \\rangle</span>  for fixed  <span class="math">a \\in \\mathbb{F}_p \\setminus \\{0, 1\\}</span>  cannot be invariant due to the fact that the initial linear relation is destroyed by the function SBox.</p>

    <p class="text-gray-300">We point out that there are invariant <em>affine</em> subspaces even if no word is fully active. In particular, remember that  <span class="math">\\mathsf{Bars} = \\mathsf{Comp} \\circ \\mathsf{SBox} \\circ \\mathsf{Decomp}</span> , where both  <span class="math">\\mathsf{Comp} : \\mathbb{Z}_{s_1} \\times \\ldots \\times \\mathbb{Z}_{s_n} \\to \\mathbb{F}_p</span>  and  <span class="math">\\mathsf{Decomp} : \\mathbb{F}_p \\to \\mathbb{Z}_{s_1} \\times \\ldots \\times \\mathbb{Z}_{s_n}</span>  are linear operations that work at word level, where  <span class="math">\\mathsf{Comp}(x) = (x_1, \\ldots, x_n) \\in \\mathbb{Z}_{s_1} \\times \\ldots \\times \\mathbb{Z}_{s_n}</span>  and where  <span class="math">\\sum_{i=1}^n x_i \\cdot b_i = x</span>  for given  <span class="math">b_i</span> . Furthermore, SBox operates independently on each  <span class="math">x_i</span> . Hence, the affine subspace I defined as</p>

    <p class="text-gray-300"><span class="math">$I := \\left\\{ \\sum_{i} x_i \\cdot b_i \\in \\mathbb{F}_p : x_1 \\in \\mathbb{Z}_{s_1} \\text{ and } x_2, \\dots, x_n \\text{ fixed } \\right\\}</span>$</p>

    <p class="text-gray-300">is an invariant affine subspace through Bars (note that the values of  <span class="math">x_i</span>  for  <span class="math">i \\ge 2</span>  change, but this would only change the coset and not the subspace itself). Other invariant affine subspaces can be defined similarly.</p>

    <p class="text-gray-300">Due to the analysis just proposed, there is no invariant subspace for Bricks. This means that our scheme is secure against the invariant subspace attack.</p>

    <p class="text-gray-300"><em>B.2.2 Fixed Points.</em> For completeness, we also discuss the case of fixed points. We say that a function F over  <span class="math">\\mathbb{F}_p^t</span>  has a fixed point  <span class="math">x \\in \\mathbb{F}_p^t</span>  if F(x) = x.</p>

    <p class="text-gray-300">The only fixed points for Bricks are (0,0,0),  <span class="math">(\\pm 1,0,0)</span>  and  <span class="math">(\\pm \\sqrt{-1},0,0)</span> . Indeed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">the only fixed points for  <span class="math">x \\mapsto x^5</span>  are the ones that satisfy  <span class="math">x \\cdot (x^4 1) = 0</span> , that is  <span class="math">\\{0, \\pm 1, \\pm \\sqrt{-1}\\}</span> . Note that -1 is a quadratic residue modulo p if and only if  <span class="math">p = 1 \\mod 4</span> , which is exactly the case of  <span class="math">p_{\\text{BLS381}}</span>  and  <span class="math">p_{\\text{BN254}}</span> .</p></li>
      <li><p class="text-gray-300">which is exactly the case of  <span class="math">p_{\\text{BLS381}}</span>  and  <span class="math">p_{\\text{BN254}}</span> .</p>

    <p class="text-gray-300">the only fixed points for  <span class="math">x \\mapsto x \\cdot (y^2 + \\alpha \\cdot y + \\beta)</span>  for a given fixed  <span class="math">y \\in \\mathbb{F}_p^3</span>  are (1)  <span class="math">\\{(0,y) \\in \\mathbb{F}_p^2 \\mid \\forall y \\in \\mathbb{F}_p\\}</span>  and (2)  <span class="math">\\{(x,y) \\in \\mathbb{F}_p^2 \\mid \\forall x \\in \\mathbb{F}_p \\text{ and } y \\in \\mathbb{F}_p \\text{ s.t. } (y^2 + \\alpha \\cdot y + \\beta) = 1\\}</span> . Since this second condition is never satisfied for  <span class="math">y \\in \\{0, \\pm 1, \\pm \\sqrt{-1}\\}</span>  (that is, the fixed points of the first component), it follows that the only fixed points are the ones given before.</p></li>
    </ul>

    <p class="text-gray-300">In the case of Bar, there are several fixed points for each S-box  <span class="math">S_i</span>  as defined in Eq. (4). In particular, the input x of  <span class="math">S_i</span>  remains unchanged if  <span class="math">x \\ge p&#x27;</span> . Since there are n independent S-boxes  <span class="math">S_i</span>  for each one of the three words, it follows that the number of fixed points for Bar are</p>

    <p class="text-gray-300"><span class="math">$\\left(\\prod_{i=1}^n (s_i - p&#x27;)\\right)^3,</span>$</p>

    <p class="text-gray-300">over  <span class="math">p^3</span> . As a concrete example, when using  <span class="math">p_{\\text{BLS381}} \\approx 2^{256}</span> , the probability for a random point to be a fixed point is</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{2^{134.54}}{2^{256}}\\right)^3 \\approx 2^{-364.4}.</span>$</p>

    <p class="text-gray-300">Recall that the Bar's layer plays no role in our security arguments for RC regarding statistical attacks. When considering algebraic attacks on the middle layer, we have not found a way to exploit these fixed points in attacks on the middle part of RC. Since the fixed point property is not described by a low-degree equation, we expect that, for instance, finding a solution to the CICO problem with Bar inputs being fixed points is much higher than without these restrictions.</p>

    <p class="text-gray-300">Gr&ouml;bner Basis Cryptanalysis usually proceeds in two stages: first, one models the (cryptographic) permutation as a system of equations with unknown parameters as variables. Subsequently, a Gr&ouml;bner basis for the (zero-dimensional) ideal defined by the polynomials describing the equation system is computed. In practice, the second step is divided into a triad of computations, namely</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Compute a Gr&ouml;bner basis for the (zero-dimensional) ideal with respect to a fast term ordering, usually <em>degrevlex</em>;</li>
      <li>(2) convert the <em>degrevlex</em>-Gr&ouml;bner basis into a <em>lex</em>-Gr&ouml;bner basis using the FGLM algorithm;</li>
      <li>(3) factor the univariate polynomial in the lex-Gr&ouml;bner basis and determine the solutions for the corresponding variable. Backsubstitute those solutions, if needed, to determine solutions for other variables.</li>
    </ul>

    <p class="text-gray-300">Each of the above three steps comes with its own complexity estimate. Under the assumption of a semi-regular input system  <span class="math">f_1, \\ldots, f_k</span>  in l variables with degrees  <span class="math">d_1, \\ldots, d_m</span> , it is well-known</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>We use the standard notation <em>A</em>, <em>C</em>, <em>B</em>,? to denote respectively an active word, a constant one, a balanced one, and an unknown one. We recall that an active word is also balanced.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">41</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">61</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">79</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">97</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">107</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">113</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">127</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">l, n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18,20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&upsilon;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s <sub>1</sub> , s <sub>2</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7,7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8,9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9,10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10,11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11,12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12,13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13,13</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\mathrm{reg}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\mathrm{mag}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\text{reg}}: d_{\\text{mag}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">T(s)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">344</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">462</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1020</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1625</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C <sub>bit</sub> : 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Results of Gr&ouml;bner basis computations on small-scale instances of Concrete  <span class="math">\\circ</span> Bars  <span class="math">\\circ</span> Concrete in the CICO-setting for various primes p and decompositions into n=2 buckets. The degree of regularity  <span class="math">d_{\\text{reg}}</span>  is computed under the assumption that the input system is semi-regular, the timings of the Gr&ouml;bner basis computations T are given in seconds, and the estimated bit complexity  <span class="math">C_{\\text{bit}} := \\log_2(C_{GB})</span>  is divided by 2 (to reflect practical runtimes).</p>

    <p class="text-gray-300">that the Hilbert series of the ideal corresponding to the input system is related to its Gr&ouml;bner basis, see [10]. The first index with non-positive coefficient of the expression</p>

    <p class="text-gray-300"><span class="math">$S_{k,l}(z) = \\frac{\\prod_{i=1}^k (1-z^{d_i})}{(1-z)^l}</span>$</p>

    <p class="text-gray-300">is the degree of regularity  <span class="math">d_{\\rm reg}</span>  and it is an upper bound for the highest degree element in a Gr&ouml;bner basis with respect to a graded ordering. Thus,  <span class="math">d_{\\rm reg}</span>  helps to establish the following upper bound for the complexity C (counting finite field operations) of computing a Gr&ouml;bner basis of a semi-regular input system:</p>

    <p class="text-gray-300">
<span class="math">$C_{GB}(l, d_{reg}) \\in O\\left(\\binom{l + d_{reg}}{l}^{\\omega}\\right),</span>$
(17)</p>

    <p class="text-gray-300">where  <span class="math">\\omega</span>  denotes the linear algebra constant. The terms hidden by  <span class="math">O(\\cdot)</span>  are relatively small, that's why for our analysis we drop the  <span class="math">O(\\cdot)</span>  and use the expression directly. Our security analysis consists of following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) We present a system of algebraic equations for the Bar function.</li>
      <li>(2) We give an algebraic model for the three-layer version Concreteo Bars o Concrete in the CICO-setting.</li>
      <li>(3) We run a series of Gr&ouml;bner basis attacks on the three-layer version Concrete  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete instantiated with much smaller primes p and argue that already for this small-scale versions the attack complexity is at least  <span class="math">(C_{GB}(l, d_{reg}/3))^{1/2}</span> .</li>
    </ul>

    <p class="text-gray-300">Algebraic Representation of Bar. For an algebraic model of Bar, we &quot;embed&quot;  <span class="math">\\mathbb{Z}_{s_i}</span>  in  <span class="math">\\mathbb{F}_p</span>  for all  <span class="math">1 \\leq i \\leq n</span> . This embedding is not an embedding in the strict mathematical sense of a structure preserving injective map. Instead, given the respective standard representations of  <span class="math">\\mathbb{Z}_{s_i}</span>  and  <span class="math">\\mathbb{F}_p</span> , we treat the elements  <span class="math">0, 1, \\ldots, s_i - 1 \\in \\mathbb{Z}_{s_i}</span>  as elements in  <span class="math">\\mathbb{F}_p</span> . As a result, we suggest the following system of 2n + 2 equations over  <span class="math">\\mathbb{F}_p</span>  in the 2n + 2 variables  <span class="math">x, y, x_1, \\ldots, x_n, y_1, \\ldots, y_n \\in \\mathbb{F}_p</span>  to model the Bar function:</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} x = x_1b_1 + x_2b_2 + \\dots + x_nb_n \\\\ 0 = p_{s_i}(x_i), &amp; 1 \\le i \\le n \\\\ y_i = L_i(x_i), &amp; 1 \\le i \\le n \\\\ y = y_1b_1 + y_2b_2 + \\dots + y_nb_n \\end{cases}</span>$</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">p_{s_i}(x_i) := \\prod_{k=0}^{s_i-1} (x_i k)</span>  is a polynomial of degree  <span class="math">s_i</span>  that vanishes at  <span class="math">\\{0, 1, \\dots, s_i 1\\}</span> ;  <span class="math">p_{s_i}</span>  ensures that  <span class="math">x_i \\in \\mathbb{Z}_{s_i}</span> ;</li>
      <li><span class="math">L_i(x_i)</span>  is the interpolation polynomial of degree  <span class="math">s_i 1</span>  for S-box  <span class="math">S_i</span>  (&quot;embedded&quot; in  <span class="math">\\mathbb{F}_p</span> ), i.e.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$L_i(x_i) := \\sum_{0 \\le k \\le s_i - 1} S_i(k) \\prod_{\\substack{0 \\le j \\le s_i - 1 \\ j \\ne k}} \\frac{x_i - j}{k - j}.</span>$</p>

    <p class="text-gray-300">Under regularity assumptions, the entire system has an expected degree of regularity</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} d_{\\text{reg}}^{\\text{Bar}} &amp;= 1 + \\sum_{i=1}^{n} (s_i - 1) + \\sum_{i=1}^{n} (s_i - 2) \\\\ &amp;= 1 - n + 2 \\sum_{i=1}^{n} (s_i - 1) \\approx 2n \\sqrt[n]{p}. \\end{split}</span>$</p>

    <p class="text-gray-300">Algebraic Representation of Concrete  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete. In this part we argue that already the computational cost of the <em>first</em> step (i.e., computing a <em>degrevlex</em>-Gr&ouml;bner basis) of Concrete  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete in the CICO-setting far exceeds the 128-bit security requirement. Our arguments are based on empirical observations on small-scale instances of this truncated version.</p>

    <p class="text-gray-300">We model the composition Concrete  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete in the CICO-setting  <span class="math">^{10}</span>  and suggest the following system of 6n+8 equations in 6n+6 variables as algebraic model:</p>

    <p class="text-gray-300"><span class="math">$\\text{CBC}_{cico} = \\left\\{ \\begin{array}{l} y_1 = \\text{Bar}(x_1) \\\\ y_2 = \\text{Bar}(x_2) \\\\ y_3 = \\text{Bar}(x_3) \\\\ 0 = \\text{Concrete}^{-1}(x_1, x_2, x_3)[1] \\\\ 0 = \\text{Concrete}(y_1, y_2, y_3)[1] \\end{array} \\right. ,</span>$</p>

    <p class="text-gray-300">Here, Concrete( <span class="math">\\cdot</span> ,  <span class="math">\\cdot</span> ,  <span class="math">\\cdot</span> )[i] denotes the i-th word of the state (for  <span class="math">1 \\le i \\le 3</span> ) and n describes the number of buckets  <span class="math">\\mathbb{Z}_{s_1}, \\ldots, \\mathbb{Z}_{s_n}</span>  in the decomposition Decomp. The variables  <span class="math">x_1, x_2, x_3</span>  and  <span class="math">y_1, y_2, y_3</span> , respectively, denote the input and output to Bars.</p>

    <p class="text-gray-300">Discussion of Practical Results. In our practical experiments we computed Gr&ouml;bner bases of small-scale instances of  <span class="math">CBC_{cico}</span>  for various primes p and decompositions into n=2 buckets. Table 4 we present the results of our experiments. Instead of taking  <span class="math">d_{reg}</span>  for establishing the complexity estimates, we computed Gr&ouml;bner basis of several small-scale instances and observed the maximum degree  <span class="math">d_{mag}</span>  reached during these computations using the CAS Magma. Substituting  <span class="math">d_{reg}</span>  with  <span class="math">d_{mag}</span>  in (17), results in our complexity estimate C. We use  <span class="math">\\omega=2</span>  and, furthermore, we take the bit-complexity  <span class="math">C_{bit}:=\\log_2(C)</span>  to write down the complexity estimates in Table 4.</p>

    <p class="text-gray-300">Our practical findings can be summarized as follows: (i) the ratio of the theoretical estimate for the maximum degree  <span class="math">d_{\\rm reg}</span>  and the maximum degree  <span class="math">d_{\\rm mag}</span>  reached by Magma during the Gr&ouml;bner basis computations is approximately (and conservatively estimated) 3; (ii) using the empirical values  <span class="math">d_{\\rm mag}</span>  for establishing complexity estimates, we observed that our practical experiments run about as</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{10}\\text{See}}</span>  Appendix B.6.1 for further details.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>We conducted our experiments on a machine with Intel&reg; Xeon&reg; E5-2630 v3 @ 2.40GHz (32 cores) and 378GB RAM under Debian 11 using Magma V2.26-2.</p>

    <p class="text-gray-300">fast as the square root of the complexity estimates. This yields the following estimate for attacking a full-scale instance of  <span class="math">CBC_{cico}</span>  with  <span class="math">p=p_{BN254}</span>  or  <span class="math">p=p_{BST381}</span>  and n=27 via a Groebner basis approach:</p>

    <p class="text-gray-300"><span class="math">$(C_{GB}(l=170, d_{reg}/3))^{1/2} &gt; 2^{1360},</span>$</p>

    <p class="text-gray-300">far exceeding the generic CICO security level of  <span class="math">2^{256}</span>  function calls (which amounts to  <span class="math">\\approx 2^{267}</span>  finite field operations for Concrete  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete) and the security level of  <span class="math">2^{128}</span>  function calls for collision and preimage resistance. In our experiments we observed that hybrid approaches (guessing certain variables and computing the Gr&ouml;bner basis for a reduced polynomial system) reduced the above mentioned complexities but never had a complexity close to the generic CICO security level of  <span class="math">2^{\\log_2 p}</span>  function calls.</p>

    <p class="text-gray-300">Finally we claim that our design is secure against other algebraic attacks, including interpolation as well as higher-order differential distinguishers (we highlight that we do not claim security against zero-sum partitions).</p>

    <p class="text-gray-300">To achieve this goal, we argue that all mentioned methods cannot penetrate Middle. In particular, this implies that the full permutation provides security with respect to above mentioned cryptanalytical methods.</p>

    <p class="text-gray-300">To rule out algebraic attacks, we introduce the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">d_B</span>  is the degree of the Bar transformation as an operation over  <span class="math">\\mathbb{F}_p</span> .</li>
      <li><span class="math">d_S</span>  is the maximum degree of the component functions of the Bricks layer as an operation over  <span class="math">\\mathbb{F}_p</span> .</li>
    </ul>

    <p class="text-gray-300"><em>B.4.1 Interpolation Analysis.</em> In its basic form, interpolation analysis aims at constructing the polynomial representation of a given (cryptographic) function [50]. To provide resistance against interpolation, a function must exhibit maximal degree (or a degree close to its maximum) and a dense polynomial representation (i.e., a description with many non-zero coefficients).</p>

    <p class="text-gray-300">The total degree of one word of the permutation RC over  <span class="math">\\mathbb{F}_p</span>  is  <span class="math">d_B \\cdot d_S^6</span> . It is enough to require  <span class="math">d_B &gt; 2^{127}</span>  for 128-bit security.</p>

    <p class="text-gray-300">A heuristic argument that  <span class="math">d_B &gt; 2^{127}</span>  is that the we define Bars on at least  <span class="math">p&#x27;^{27}</span>  points in a nonlinear way. This accounts to at least  <span class="math">2^{251}</span>  points, so the degree should exceed  <span class="math">2^{251}</span> .</p>

    <p class="text-gray-300">We also computed the degree  <span class="math">d_B</span>  for small-scale instances of Bar with  <span class="math">f(x) = x^{-1}</span>  as internal function f for the small S-Boxes  <span class="math">S_1, \\ldots, S_n</span>  and n = 2, 3. For every instance we tested, the degree of Bar was maximal, i.e. p-2, with almost all coefficients of the polynomial being non-zero. Extrapolating this trend and since  <span class="math">\\log_2(p) \\approx 256</span>  for the full-scale permutation RC, we conclude that above requirement is far exceeded.</p>

    <p class="text-gray-300">B.4.2 Higher-Order Differential Attack and Zero-Sum Distinguishers. Given a vectorial Boolean function  <span class="math">\\mathcal{F}</span>  over  <span class="math">\\mathbb{F}_2^n</span>  of degree d, the higher-order differential attack [52, 54] exploits the fact that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\mathcal{V} + v} x = \\sum_{x \\in \\mathcal{V} + v} F(x) = 0</span>$</p>

    <p class="text-gray-300">for each affine subspace  <span class="math">\\mathcal{V}+v\\subseteq\\mathbb{F}_2^n</span>  of dimension strictly bigger than d (that is,  <span class="math">\\dim(\\mathcal{V})\\geq d+1</span> ). The corresponding attack in the case of a prime field  <span class="math">\\mathbb{F}_p</span>  has been recently proposed by Beyne et al. [16]. Since this result is related to the degree of the polynomial that describes the permutation, we claim that the security against the interpolation attack implies security against this attack as well.</p>

    <p class="text-gray-300">A possible variant of higher-order sum in the case of permutations is the zero-sum partition distinguisher [23]. Here we explicitly state that we do not make claims about the security of our scheme against zero-sum partitions. This choice is motivated by the gap present in the literature between the number of rounds of the internal permutation that can be covered by a zero-sum partition and by the number of rounds in the corresponding sponge hash function that can be broken e.g. via a preimage or a collision attack.</p>

    <p class="text-gray-300">Whereas it is clear that ZK protocols might fall apart in the presence of a side-channel adversary, the available literature is scarce ([66] being an exception). Most primitives are not strengthened against side-channels. The reason probably being that performance is critical, and a side-channel protection would slow down and make the protocol less practical. In addition, constant-time implementations of prime arithmetic are hard and not available in many frameworks used by deployed ZK protocols. Naturally, many protocols are competitors and are afraid to lose a market share.</p>

    <p class="text-gray-300">For the RC design, its native execution can be run <em>without table lookups</em> as the table is computed as a polynomial. If the prime field operations were implemented in constant-time, our function would be leakage-free. We also note that ZK-friendly hash functions, in contrast to AES, are much less exposed to an attacker as the input messages are rather short.</p>

    <p class="text-gray-300">B.6.1 The Necessity of Bars. We first focus on a design which excludes the Bars layer, and we show that a much higher number of rounds is needed to provide security. In order to do this, we use a Gr&ouml;bner basis approach. Further, as our permutation is used in a Sponge setting, we consider the CICO (constrained input, constrained output) problem. More specifically, our goal is to find t-k variables such that the first k words of both the input and the output of RC are zero. For a good hash transformation, we expect this to take a workload of  <span class="math">p^k</span>  operations when working over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">In more detail, we want that</p>

    <p class="text-gray-300"><span class="math">$x = 0 \\| \\cdots \\| 0 \\| x_{k+1} \\| \\cdots \\| x_t</span>$</p>

    <p class="text-gray-300">is the input of the function (where  <span class="math">\\cdot || \\cdot</span>  denotes the concatenation) and</p>

    <p class="text-gray-300"><span class="math">$y = RC(x) = 0 \\| \\cdots \\| 0 \\| y_{k+1} \\| \\cdots \\| y_t</span>$</p>

    <p class="text-gray-300">is the output, and our goal is to find  <span class="math">x_{k+1}, \\dots, x_t</span> .</p>

    <p class="text-gray-300">Focusing on our function with t=3 and using a single element of approximately 256 bits for the capacity (for a 128-bit security level), let us consider k=1. We then have 2 variables and only one equation. This system is underdetermined, but we can arbitrarily fix one of the variables. In the end, we arrive at a single equation in a single variable.</p>

    <p class="text-gray-300">Full-Round Equations. Using this straight-forward approach, we note that our Bricks layer has a degree of 3. Without further considering the density of the resulting polynomials, our final goal is to find the roots of a univariate equation of degree  <span class="math">3^r</span> , where r is the number of rounds. Since this cost is approximately an element in  <span class="math">O(d^3)</span>  [36], we want that</p>

    <p class="text-gray-300"><span class="math">$3^{3r} \\ge p \\implies r \\ge \\log_{27}(p).</span>$</p>

    <p class="text-gray-300">For example, if  <span class="math">p \\approx 2^{256}</span> , this results in  <span class="math">r \\ge 54</span> , which is much larger than what our current proposal needs.</p>

    <p class="text-gray-300">Intermediate Variables and Equations. Another possible approach is to keep the degrees low by introducing additional variables. In order to do this, we introduce 3 new variables in each round and we arrive at a system of degree-3 equations.</p>

    <p class="text-gray-300">Let us again assume that we use r rounds. Then, we introduce 3(r-1) new variables and equations. In the end, we arrive at  <span class="math">n_e = 3(r-1) + 1</span>  degree-3 equations and the same number of variables  <span class="math">n_v</span>  (one additional equation for the final zero element, and the original variable  <span class="math">x_t</span>  at the beginning). Generically, the complexity of solving such a system is then in</p>

    <p class="text-gray-300"><span class="math">$O\\left(\\binom{D_{\\text{reg}}+n_v}{n_v}\\right)^{\\omega}\\right),</span>$</p>

    <p class="text-gray-300">where we set  <span class="math">\\omega = 2</span>  and where</p>

    <p class="text-gray-300"><span class="math">$D_{\\text{reg}} = 1 + \\sum_{i=1}^{n_e} 2 = 1 + 2 \\cdot (3(r-1) + 1).</span>$</p>

    <p class="text-gray-300">In this case, we want that</p>

    <p class="text-gray-300"><span class="math">$\\binom{1+6(r-1)+2+3(r-1)+1}{3(r-1)+1}^2 = \\binom{9r-5}{3r-2}^2 \\ge p,</span>$</p>

    <p class="text-gray-300">which results in  <span class="math">r \\ge 33</span>  for  <span class="math">p \\approx 2^{256}</span> . Note that we are not exploiting the density and general structure of the polynomials. Indeed, when using equations which cover single rounds, we can assume that they do not exhibit strong pseudo-random properties, which means that the above estimation is actually a pessimistic one (from the attacker's perspective). However, this is sufficient to show the efficiency of our current proposal, since any faster attack would only further increase the number of rounds needed for security in the design without the Bars layer.</p>

    <p class="text-gray-300"><em>B.6.2 The Necessity of</em> Concrete. Without the Concrete layer, we would have a weaker diffusion over the 3 words. In particular, note that the Bricks layer does not provide any mixing in the first word. Hence, when omitting the Concrete layer, the subspaces  <span class="math">\\langle (0,1,0), (0,0,1) \\rangle</span>  and  <span class="math">\\langle (0,0,1) \\rangle</span>  are invariant through the whole permutation, independent of the number of rounds.</p>

    <p class="text-gray-300">B.6.3 The Necessity of Bricks. Without the Bricks layer, an attacker could work with a system of equations over the smaller fields of the Bars layer. Moreover, the in-word diffusion (i.e., the diffusion in a single word) would only happen in the Bars layer, which is weak. Further, we need the Bricks layer for statistical arguments, since e.g. in a rebound attack both outbound phases would be linear otherwise (when considering the Bars layer in the inbound phase).</p>

    </section>
`;
---

<BaseLayout title="Reinforced Concrete: A Fast Hash Function for Verifiable Com... (2021/1038)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1038
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">INTRODUCTION</a></li>
        <li><a href="#sec-2" class="hover:text-white">RC IN A NUTSHELL</a></li>
        <li><a href="#sec-3" class="hover:text-white">SECURITY REQUIREMENTS AND CLAIMS</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">SPECIFICATION AND RATIONALE</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The Bricks function</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">The Concrete function</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">The Bars Function</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Sponge framework parameters</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">SECURITY ANALYSIS</a></li>
        <li>
          <a href="#sec-6" class="hover:text-white">LOOKUP TABLES AND SYSTEM OF CONSTRAINTS FOR BAR</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Soundness and Completeness</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">CONCRETE INSTANCES</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">PERFORMANCE</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Proof System Performance</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Plain Implementation Performance</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">BIJECTIVITY OF RC COMPONENTS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Bijectivity of Bricks</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Bijectivity of Bar</a></li>
            <li><a href="#app-a.3" class="hover:text-white">The SBox function</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">SECURITY ANALYSIS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Statistical Attacks</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Invariant Subspace Attack and Fixed Points</a></li>
            <li><a href="#app-b.3" class="hover:text-white">Gr&ouml;bner Basis Cryptanalysis</a></li>
            <li><a href="#app-b.4" class="hover:text-white">Other Algebraic Attacks</a></li>
            <li><a href="#app-b.5" class="hover:text-white">Side-channel attacks</a></li>
            <li><a href="#app-b.6" class="hover:text-white">Every Building Block is Necessary</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="reinforced-concrete-a-fast-hash-function-for-verifiable-2021" />
  </article>
</BaseLayout>
