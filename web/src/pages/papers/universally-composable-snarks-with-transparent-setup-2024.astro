---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1549';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Universally Composable SNARKs with Transparent Setup without Programmable Random Oracle';
const AUTHORS_HTML = 'Christian Badertscher, Matteo Campanelli, Michele Ciampi, Luigi Russo, Luisa Siniscalchi';

const CONTENT = `    <p class="text-gray-300">Christian Badertscher [ ZG1] Matteo Campanelli [ ZG2] Michele Ciampi [ ZG3] Luigi Russo [ ZG4] Luisa Siniscalchi [ ZG5]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Non-interactive zero-knowledge (NIZK) proofs enable a prover to convince a verifier of an NP statement’s validity using a single message, without disclosing any additional information. These proofs are widely studied and deployed, especially in their <em>succinct</em> form, where proof length is sublinear in the size of the NP relation. However, efficient succinct NIZKs typically require an idealized setup, such as a a common reference string, which complicates real-world deployment. A key challenge is developing NIZKs with simpler, more transparent setups.</p>

    <p class="text-gray-300">A promising approach is the random-oracle (RO) methodology, which idealizes hash functions as public random functions. It is commonly believed that UC NIZKs cannot be realized using a non-programmable global RO—the simplest incarnation of the RO as a form of setup—since existing techniques depend on the ability to program the oracle.</p>

    <p class="text-gray-300">We challenge this belief and present a methodology to build UC-secure NIZKs based solely on a global, non-programmable RO. By applying our framework we are able to construct a NIZK that achieves witness-succinct proofs of logarithmic size, breaking both the programmability barrier and polylogarithmic proof size limitations for UC-secure NIZKs with transparent setups. We further observe that among existing global RO formalizations put forth by Camenisch et al. <em>(Eurocrypt 2018)</em>, our choice of setup is necessary to achieve this result.</p>

    <p class="text-gray-300">From the technical standpoint, our contributions span both modeling and construction. We leverage the shielded (super-poly) oracle model introduced by Broadnax et al. <em>(Eurocrypt 2017)</em> to define a UC NIZK functionality that can serve as a drop-in replacement for its standard variant—it preserves the usual soundness and zero-knowledge properties while ensuring its compositional guarantees remain intact. To instantiate this functionality under a non-programmable RO setup, we follow the framework of Ganesh et al. <em>(Eurocrypt 2023)</em> and provide new building blocks for it, around which are some of our core technical contributions: a novel polynomial encoding technique and the leakage analysis of its companion polynomial commitment, based on Bulletproofs-style folding. We also provide a second construction, based on a recent work by Chiesa and Fenzi <em>(TCC 2024)</em>, and show that it achieves a slightly weaker version of the NIZK functionality.</p>

    <p class="text-gray-300">1 Introduction 2 1.1 Technical Overview 4 1.2 Discussion: Comparing UC-SNARK Compilers and Our Instantiation Choices 9 1.3 Future Work and Alternative Instantiations 9</p>

    <p class="text-gray-300">2 Preliminaries 10 2.1 Public-Key Encryption 10 2.2 Secret Sharing 11 2.3 Non-interactive Arguments 11 2.4 Succinct Polynomial Commitment Schemes and Polynomial Encoding Schemes 14 2.5 Dense Sampled Puzzle system 16</p>

    <p class="text-gray-300">3 The NIZK Functionality with an Adjoined Oracle 17 3.1 Global Random Oracles 17 3.2 Constructions with Setup 18 3.3 Weakening the Ideal Functionality 19 3.4 Definition of the Oracle-Adjoined NIZK Functionality 20</p>

    <p class="text-gray-300">4 Protocol for Realizing our UC NIZK Functionality 21 4.1 Description of the UC Protocol <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span> 21</p>

    <p class="text-gray-300">5 Concrete Realizations 26 5.1 Constructing the Argument System via the Modified Compiler 27 5.2 Instantiation of the Polynomial Encoding Scheme 28 5.3 Instantiation of the Succinct Polynomial Commitment Scheme 30 5.4 Instantiation of the Succinct Simulation-Extractable NIZK 31</p>

    <p class="text-gray-300">A The Shielded Oracle Framework [BDH⁺17] 35 B Main Definitions and Compilers to Witness-Succinct UC-NIZKs 36 B.1 On the Differences between our Definitions and [GKO⁺23] 36 B.2 The compiler <span class="math">\\Pi_{\\mathrm{GKOPTT}}</span> of [GKO⁺23] in an RO-only world 37</p>

    <p class="text-gray-300">C Our Polynomial Encoding Scheme 38 C.1 Further leakage-resilience properties of additive secret sharing 38 C.2 Further Analysis of <span class="math">\\mathsf{adm}_{\\mathrm{det}}</span>-Linear Leakage 40 C.3 Secret-Sharing Based Polynomial Encoding Scheme 40</p>

    <p class="text-gray-300">D Proofs for the Security of BP-PC 41 D.1 Proof of Theorem 5 41 D.2 Proof of Theorem 6 43 D.3 Proof of Theorem 8 43 D.4 Proof of Theorem 9 52</p>

    <p class="text-gray-300">E On Simulation-Extractable NIZKs from UC-secure Protocols 52 E.1 From Weaker UC NIZK 52 E.2 From Standard UC NIZK 54</p>

    <p class="text-gray-300">A proof system allows two entities, a prover and a verifier, to interact so that, at the end of the interaction, the verifier can be convinced of the validity of some NP statement. Informally, a proof system is zero-knowledge (ZK) [GMR85] if the verifier, upon receiving the proof, learns nothing more than the fact that the statement is true (e.g., any secret/witness the prover may need to issue the proof is protected). In the non-interactive scenario, a proof consists of one message sent from the prover to the verifier. These kinds of proofs, introduced in [BFM88], are called Non-Interactive Zero-Knowledge (NIZK) proofs. NIZK proofs are particularly useful and easy to use due to their publicly-verifiable nature. This means that any verifier that has access to a proof, can verify it. This flexibility of NIZK proofs has been proven to be remarkably useful in privacy-preserving applications or to instantiate more complex cryptographic primitives.</p>

    <p class="text-gray-300">Succinctness and setup in NIZKs. Nowadays we have quite efficient NIZK schemes with strong succinctness properties, i.e., the size of the proofs is extremely small compared to the size of the statement being proven. Unfortunately, there is a big catch in the use of NIZK proofs: the security of a NIZK protocol holds as long as the prover and the verifier have access to a pre-agreed setup. Most commonly deployed NIZKs are based on the existence of a common reference string (CRS). A common reference string is a bitstring that must be generated by a third party that is trusted to: 1) generate the CRS according to a predetermined randomized algorithm; and 2) never reveal the random coins used to generate the CRS.</p>

    <p class="text-gray-300">The requirement of a CRS inherently introduces a critical point of failure. This is because <em>[x12]</em> shows that we can trust neither the prover nor the verifier to generate such a CRS. One way to generate the CRS without relying on a single trusted party could be via a distributed protocol, e.g., via a multi-party computation (MPC) protocol <em>[x18, x13]</em>. There are two problems with this approach: 1) it is not clear what incentives the parties running the MPC protocol have in being honest (and so which proportion of them we can reliably assume to be honest); and 2) if we want to securely generate the CRS in the case where the majority of the parties may be corrupted, then we may need a CRS to run the MPC protocol itself. Even in the case where we can securely run an MPC protocol, in practice, things can go wrong. For example, ZCash generated the CRS for their NIZK scheme, using an MPC protocol, but it was later discovered that an adversary that had access to the transcript of the MPC protocol could break the soundness of the NIZK proof <em>[x20]</em>, and hence, double-spend coins.</p>

    <p class="text-gray-300">A better form of setup is one that is transparent, in the sense that its generation procedure should be simple, not contain any trapdoor and such that it should be easy to convince users that the setup was indeed generated correctly. A type of setup widely accepted to be transparent is the Random Oracle (RO). In this model, the security of the NIZK protocol is proven assuming that the prover and verifier have access to a trusted party that behaves like a random function. In practice, the RO is heuristically replaced by a cryptographic hash function (e.g., SHA-256), hence, there is no need to generate any ad hoc CRS as described in the previous paragraph.</p>

    <p class="text-gray-300">Most of the approaches based on the RO methodology rely on the unrealistic assumption that the RO (hence the hash function) is used by only one instance of the cryptographic protocol. Technically speaking, the security of NIZK is guaranteed only as long as the RO is used as a local resource. This makes the usage of this ideal setup non-transparent, and furthermore, in practice, the RO is replaced by a single hash function which is used in many other applications as well (for example SHA-256). Therefore, it would be much more desirable and realistic to consider NIZK protocols that remain secure even if the same hash function is used across different sessions, following for example the Global RO model introduced by Canetti et al. <em>[x7]</em>.</p>

    <p class="text-gray-300">How to design NIZK in the Global RO. What makes it difficult to prove results in the Global RO setting, is that the simulator cannot program the random oracle. Indeed, as recalled in <em>[x10]</em>, it is impossible to realize a NIZK proof system in the non-programmable RO (NPRO) model unless we introduce additional setup assumptions (e.g., a CRS). In the same work the authors show that it is in fact possible to build NIZKs assuming the existence of a NPRO if we allow the simulator to run in super-polynomial time. The notion of super-polynomial time simulation (SPS) was introduced in <em>[x14]</em>, and allowed to already circumvent known impossibility results, yielding to a two-round zero-knowledge protocol, assuming no setup and no RO. In <em>[x14]</em> it is shown that two rounds are necessary and sufficient for quasi-polynomial time simulatable arguments, hence, super-polynomial time alone does not suffice to obtain NIZK. Despite <em>[x10]</em> providing a positive result, their NIZK proof is secure only in the standalone setting (non-composable), and it does not enjoy any form of succinctness.</p>

    <p class="text-gray-300">Our research question. In this work, we investigate whether the same result can be obtained in a composable setting while providing a scheme with succinct proof size.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Is it possible to construct a <em>composable</em> NIZK proof system, where the only available setup is a Global (non-programmable) Random Oracle?</p>
    </blockquote>

    <p class="text-gray-300">In this work, we answer the above question in a positive sense by considering a relaxed (but still meaningful) version of the zero-knowledge functionality. We formally prove our results in the UC with shielded oracles <em>[BDH^{+}17]</em> (more details on this follow), providing a scheme that relies only on standard polynomial-time falsifiable assumptions. Given the above positive findings, we make a step forward and</p>

    <p class="text-gray-300">we ask whether our NIZK satisfies some form of succinctness. Only very recently thanks to the results of <em>[GKO^{+}23, 24, 23]</em> we had constructions of UC-NIZK that have proof size sub-linear in both the theorem and the witness size. However, these constructions need to rely on an additional local setup (e.g., programming the random oracle or a structured local CRS) due to the impossibility mentioned above. Our final scheme is witness succinct and makes use only of a Global RO as its setup. In a bit more detail, we prove the following.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">Assuming the hardness of the Discrete Logarithm and Decisional Diffie-Hellman assumptions against probabilistic-polynomial time adversaries, there exists a composable NIZK proof system with succinct proofs—specifically, logarithmic in the witness size—assuming that the only available setup is a Global (non-programmable) Random Oracle.</p>

    <p class="text-gray-300">Our results break both the barrier of programmability of the random oracle and of polylogarithmic proof size for UC-secure NIZKs with transparent setups (see Table 1).</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Technical Overview</h3>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Circumventing the impossibility.</h4>

    <p class="text-gray-300">We study the security of NIZK proofs in the Universal Composable (UC) <em>[21]</em> setting. In this, the NIZK properties are captured by an ideal functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span> parametrized by an NP-relation <span class="math">\\mathcal{R}</span>. This functionality, upon receiving a statement-witness pair (denoted with <span class="math">(x,w)</span>) from a prover, checks if the pair belongs to <span class="math">\\mathcal{R}</span>, and if this is the case, it generates a string (the proof) <span class="math">\\pi</span>. The functionality then records the entry <span class="math">(x,\\pi)</span> and sends <span class="math">\\pi</span> to the verifier. If the functionality is invoked with the pair <span class="math">(x^{\\prime},\\pi^{\\prime})</span> by any party (verifier), and this pair is recorded, then the functionality returns <span class="math">1</span>, else it returns <span class="math">0</span>.</p>

    <p class="text-gray-300">This functionality, in a nutshell, generates a special certificate/proof about the validity of an NP statement <span class="math">x</span>, only if <span class="math">x</span> comes with a valid witness <span class="math">w</span>. A natural question now is: How is <span class="math">\\pi</span> generated? In the standard NIZK functionality, <span class="math">\\pi</span> is completely generated by the ideal-world adversary (aka the simulator). This is quite important, as in the real world, the protocol that realizes the NIZK functionality will generate <span class="math">\\pi</span>, hence, to argue indistinguishability between real and ideal worlds, the ideal and the real proof must be the same (or at least belong to computational indistinguishable distributions).</p>

    <p class="text-gray-300">The soundness property of a real-world protocol is captured by the fact that no adversary can generate a proof <span class="math">\\pi</span> for a false statement <span class="math">x</span>. This comes from the fact that no pair <span class="math">(x,\\pi)</span> for a false statement <span class="math">x</span> will ever be recorded by the ideal functionality. At the same time, to prove that the scheme is zero knowledge, we need to design a simulator that can somehow generate a valid proof <span class="math">\\pi</span> without knowing the witness. Hence, we need a real-world efficient procedure, that allows the simulator to create valid proof <span class="math">\\pi</span>, without knowing the witness. But it is important to stress that for soundness to hold we need to guarantee that a corrupted prover cannot use this process. This inherent contradiction is usually broken by allowing the simulator an additional power that the real-world adversary does not have. This is done by assuming that the real-world protocol relies on some trusted setup that helps only the simulator generate fake proofs, but it does not provide any help to the real-world prover. This goes against the concept of what a global setup is. Indeed, a global setup should expose the same interface and the same capabilities to all the parties. In the case of random oracles, this additional power is represented by the ability of the simulator to program the queries made to the RO, a capability that instead the real-world adversary cannot exploit.</p>

    <p class="text-gray-300">To avoid this common problem, we start from this basic observation. A zero-knowledge simulator is invoked for a theorem <span class="math">x</span> only when in the ideal world a proof query <span class="math">(x,w)</span> is issued, with <span class="math">(x,w)\\in\\mathcal{R}</span>. Our idea is to give a proof <span class="math">\\pi</span> to the simulator (the ideal world adversary) any time that a valid theorem-witness pair is generated. But as observed before, in standard NIZK functionality, <span class="math">\\pi</span> is generated by the ideal adversary and this is quite crucial to argue indistinguishability between real and ideal world. However, we observe that <span class="math">\\pi</span> can indeed be generated by the NIZK functionality. For example let us consider an ideal NIZK functionality that, upon receiving a valid statement-witness pair, samples a special string <span class="math">\\pi</span> and sends it to the adversary and the verifier. This NIZK functionality still captures the basic properties of zero-knowledge and soundness, but unfortunately, it is not clear how to realize it. This is because an honest prover in the real-world protocol should be able to generate the same string <span class="math">\\pi</span>, when creating a proof.</p>

    <p class="text-gray-300">To make this functionality realizable, we parametrize the functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span> by a helper oracle. This oracle can only be invoked on a statement <span class="math">x</span>, for which a valid witness <span class="math">w</span> exists. When the oracle is correctly invoked and receives only the statement <span class="math">x</span>, it can run in time <span class="math">T</span> to generate a proof <span class="math">\\pi</span>,</p>

    <p class="text-gray-300">that looks like a real-world proof. Note that the property of zero-knowledge is still captured, as <span class="math">\\pi</span> is generated without using the witness, but how <span class="math">T</span> is implemented will determine how <em>meaningful</em> is the zero-knowledge achieved. For example, in the case when <span class="math">T</span> is exponential, we face a situation where the helper oracle could potentially generate the witness <span class="math">\\pi=w</span> directly. Specifically, the trivial real proof system in which the prover outputs the witness itself would realize this functionality. To avoid this problematic scenario that undermines the meaningfulness of the zero-knowledge property, we can restrict <span class="math">T</span> to be just quasi-polynomial time. Indeed, if we can design a protocol that realizes this new NIZK functionality to prove statements that require more than quasi-polynomial time to be decided then we have again a useful and meaningful zero-knowledge protocol.</p>

    <p class="text-gray-300">In a nutshell, we are enhancing the NIZK functionality with a helper-oracle that can be invoked both in the ideal and in the real world, which is useful to produce valid proofs only for statements with valid witnesses. Crucially, this means that the real-world adversary would never be able to use this helper unless he provides a valid statement-witness pair. Indeed, the helper can be invoked by parties that have a valid witness for a statement <span class="math">x</span> (hence, in this case, the helper is useless for the party) and cannot be invoked for statements for which no witness exists (the helper cannot be used to forge a proof).</p>

    <p class="text-gray-300">We will argue that such a NIZK functionality can be realized assuming as the only form of setup a global (non-programmable) random oracle. Before showing how our construction works, we need to describe how to modify the UC framework to enable this quasi-polynomial time helpers/oracles.</p>

    <p class="text-gray-300">Designing the UC-NIZK functionality with shielded oracles. Luckily for us, a modified version of the UC framework that allows to properly model our new NIZK functionality already exists, and it is called UC with <em>shielded oracle model</em> <em>[BDH^{+}17]</em>. Intuitively, shielded oracles transform a functionality <span class="math">\\mathcal{F}</span> into a weaker functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> that gives additional power at the adversarial interface. Notably, the oracle is allowed to perform quasi-polynomial time computations and assist the functionality and/or the simulator in simulating. This makes the functionality easier to realize as the simulator has more power: the simulator has (controlled) access to results that stem from a quasi-polynomial time computation. However, in view of composition, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> is now the functionality one has to deal with in further protocol design steps and it is weaker than <span class="math">\\mathcal{F}</span>. In particular, whatever output <span class="math">\\mathcal{O}</span> gives at the adversarial interface must be carefully inspected as it impacts composition with other protocols. That is, the additional power could be “abused” to attack other protocols, since it is, presumably indirectly, the output of a computation that cannot be emulated by a polytime environment. Protocols must now be secure against a new class of environments beyond quasi-polynomial time, denoted by <span class="math">\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}]</span>, which are all poly-time processes <span class="math">\\mathcal{Z}</span> with black-box access to different sessions of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>.</p>

    <p class="text-gray-300">Our first goal is to define an adjoined oracle <span class="math">\\mathcal{O}</span> for UC-NIZKs that “weakens” the standard zero-knowledge functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span> in the above sense in a controlled way that plausibly does not impact the soundness property and enables composition in other contexts where the zero-knowledge functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span> would be used. We have already given a high-level intuition about how we relax <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span>, but before describing it in more detail we provide a high-level overview of our construction. This will help to understand how the simulator works and in particular the motivations behind the design of our new NIZK functionality and oracle.</p>

    <p class="text-gray-300">A starting point for building a NIZK protocol. Our construction is inspired by <em>[x10]</em>, where the authors construct a standalone (i.e., not composable) NIZK protocol in the SPS + NPRO model. The scheme proposed in <em>[x10]</em> works as follows. To prove that a statement <span class="math">x</span> belongs to some NP-language <span class="math">L</span>, the prover runs a witness-indistinguishable (WI) proof of knowledge (PoK) protocol <span class="math">\\Pi^{\\textsf{PoK}}</span>, proving either the knowledge of the witness for <span class="math">x</span> or the solution of a puzzle puzz. This puzzle is sampled by querying the random oracle on input the statement <span class="math">x</span>, thus obtaining a string that is parsed as a random group element. The solution of the puzzle is represented by its discrete logarithm.</p>

    <p class="text-gray-300">Crucially <span class="math">\\Pi^{\\textsf{PoK}}</span> is proven secure in the NPRO, and the PoK extractor is <em>straight-line</em> (i.e., it does not perform any rewind to the adversary). The hardness of the puzzle is parametrized in such a way that it is hard to solve by a polynomial time algorithm, but it is easy to solve by a quasi-polynomial time algorithm. To simulate a proof, the simulator computes the solution to the puzzle running in quasi-polynomial time and generates a valid proof using the solution of the puzzle as the witness. This simulated proof, due to the WI property of the underlying scheme, will be guaranteed to be indistinguishable from the honestly generated proof.</p>

    <p class="text-gray-300">The scheme of <em>[x10]</em> that we have just sketched seems to be a promising candidate for our goal. This is because both the zero-knowledge simulator and the PoK extractor are straight-line, and neither the simulator nor the PoK extractor need to program the RO. Unfortunately, this is not the case. The</p>

    <p class="text-gray-300">reason is that to hope to get some composability properties, we need to argue that the PoK extractor successfully extracts the witness for the statement proven by a corrupted prover, while at the same time, simulated proofs are generated and provided to the adversary. In a nutshell, we need the property of <em>simulation extractability</em> <em>[DDO^{+}01]</em>, and <em>[CV22]</em> does not satisfy this strong notion of security. On top of that, the scheme of <em>[CV22]</em> does not provide any form of succinctness.</p>

    <p class="text-gray-300">Towards SIM-EXT and succinctness. For the reasons above we will have to follow a slightly different approach. Instead of using a WI-PoK scheme, we take as our main building block a simulation-extractable NIZK protocol <span class="math">\\Pi</span> with the following two properties: 1) no CRS is needed (hence, the zero-knowledge simulator may need to program the RO) and 2) the PoK extractor only needs to access the RO queries made by the adversary, and it works in a straight-line manner (i.e., no rewind is performed).</p>

    <p class="text-gray-300">Equipped with this stronger tool, we can follow the same approach as before, but using <span class="math">\\Pi</span> to prove either the knowledge of a witness for <span class="math">x\\in L</span>, or the solution of puzz. The puzzle in this case is sampled by querying the RO on input the session identifier and the theorem to be proven. Our simulator crucially will not use the simulator of the underlying <span class="math">\\Pi</span>, instead, it issues proofs that are generated by running the prover algorithm of <span class="math">\\Pi</span>, but using the solution of puzz as the witness. To perform extraction from proofs generated by the adversary, our simulator runs the straight line extractor of <span class="math">\\Pi</span>, which by definition does not program the RO.</p>

    <p class="text-gray-300">Note that in our proof we rely on the security of <span class="math">\\Pi</span>, specifically, we will have a hybrid experiment in which the simulator (who programs the RO) of <span class="math">\\Pi</span> will actually be used. However, this will constitute just a step in our proof, and the simulator of <span class="math">\\Pi</span> will never be used in the final simulation of the ideal world.</p>

    <p class="text-gray-300">Intermezzo: how to design <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span>. In the next paragraph, we will argue how to obtain <span class="math">\\Pi</span>, but let us first explain our design choice for our NIZK functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span>. As explained above, in the shielded oracle, our NIZK functionality <span class="math">\\mathcal{F}_{\\textsf{NIZK}}</span> has access to an oracle <span class="math">\\mathcal{O}</span> that can do quasi-polynomial time work. A simple solution would be to ask <span class="math">\\mathcal{O}</span> to solve the puzzles and give the solutions back to the simulator. This clearly does not work, as the adversary is also allowed to access <span class="math">\\mathcal{O}</span>, and as such he could use the solutions to the puzzle to generate accepting proofs for false statements (thus breaking the soundness). Instead, we design our ideal functionality and oracle to work as follows. Upon receiving a prove query (prove, <span class="math">\\mathsf{sid},x,w</span>), <span class="math">\\mathcal{F}_{\\textsf{NIZK}}^{\\mathcal{O}}</span> checks that <span class="math">w</span> is a witness for the NP statement <span class="math">x</span>, and if this is the case, it sends (<span class="math">\\mathsf{sid},x</span>) to <span class="math">\\mathcal{O}</span>. <span class="math">\\mathcal{O}</span> now queries the random oracle with input (<span class="math">\\mathsf{sid},x</span>), thus obtaining the puzzle puzz, solves the puzzle running in quasi-polynomial time, and computes a proof <span class="math">\\pi</span> running <span class="math">\\Pi</span> on input the solution of the puzzle as a witness. Then it returns the obtained proof back to functionality, which records <span class="math">(x,\\pi)</span>, and forwards <span class="math">\\pi</span> to the adversary. A verifier can check if the proof <span class="math">\\pi</span> for a statement <span class="math">x</span> is valid by querying <span class="math">\\mathcal{F}_{\\textsf{NIZK}}^{\\mathcal{O}}</span> on input (verify, <span class="math">\\mathsf{sid},x,\\pi</span>). If the entry <span class="math">(x,\\pi)</span> has been recorded by <span class="math">\\mathcal{F}_{\\textsf{NIZK}}^{\\mathcal{O}}</span>, then the functionality returns 1, else it returns 0.</p>

    <p class="text-gray-300">The high-level idea here is that the simulator will receive a simulated proof <span class="math">\\pi</span> from the ideal functionality, any time that in the ideal world, an honest party issues a query (prove, <span class="math">\\mathsf{sid},x,w</span>) to <span class="math">\\mathcal{F}_{\\textsf{NIZK}}^{\\mathcal{O}}</span>. At the same time, this mechanism does not help a malicious prover, as simulated proofs can be issued only for statements that in the ideal world come with a valid witness. For more detail on how our ideal functionality is formalized, we refer to Section 3.4.</p>

    <p class="text-gray-300">We end this paragraph by recalling from <em>[BDH^{+}17]</em> that UC with shielded oracles implies security in the SPS model, it therefore remains impossible in the shielded oracle model to construct a NIZK proof without additional setup. We note that other UC models have been considered where quasi-polynomial time resources are available, such as <em>UC with helpers (or angels)</em> <em>[PS04, CLP10]</em>. However, these notions are stronger than the shielded oracle framework, hence we naturally decided to go with the weakest notion, which notably is fully compatible with the UC framework, i.e., protocols proven secure in the UC framework remain secure in our framework.</p>

    <p class="text-gray-300">Implementing a weaker functionality. We are left to argue how we design one of our main building blocks <span class="math">\\Pi</span>. We recall that we want a simulation-extractable NIZK that only uses a RO as its setup, and that has a straight-line PoK extractor that <em>does not</em> program the RO. Moreover, we need <span class="math">\\Pi</span> to be succinct. The recent result of Chiesa and Fenzi <em>[CF24]</em> suggests that we could use the Micali <em>[Mic94]</em> and the BCS <em>[BCS16]</em> zkSNARKs as possible instantiations. However, we can argue that both these constructions achieve a slightly weaker notion of simulation extractability, thus our protocol would UC-realize a weaker NIZK functionality <span class="math">\\mathcal{F}_{w\\textsf{NIZK}}</span> (we elaborate more in Section 3.4). Whether the weak or the strong form is more useful depends on the use case: as an analogy, some applications of signatures only require existential unforgeability while others require full-fledged strong unforgeability.</p>

    <p class="text-gray-300">Implementing the standard functionality. The scheme that comes near to our ideal candidate is the one proposed in <em>[GKO+23]</em> . The protocol <em>[GKO+23]</em> is described as a compiler that takes as input 1) a succinct (non-UC) simulation-extractable NIZK argument, and 2) a <em>special</em> polynomial commitment. The output of the compiler is a UC NIZK in the global RO model, whose setup consists of the setups of the input protocols. Since the underlying tools proposed by <em>[GKO+23]</em> assume the existence of a structured CRS (i.e., a CRS that cannot be generated by simply querying the RO), in order to obtain <span class="math">\\Pi</span>, we need to propose different instantiations of these tools based on <em>transparent</em> building blocks, as we elaborate hereafter.</p>

    <p class="text-gray-300">Constructing the right building blocks. We start by observing that we can adopt as a succinct (non-UC) simulation-extractable NIZK the version of Bulletproofs <em>[BBB+18]</em> presented in <em>[DG23]</em>. As a consequence, our main efforts is on obtaining a new <em>special</em> polynomial commitment, whose only setup is the RO. We call the polynomial commitment <em>special</em> because <em>[GKO+23]</em> adds certain additional properties compared to standard ones for polynomial commitments (e.g., evaluation binding). The first of these properties is specific to the polynomial commitment scheme (or, PCS) alone and requires that the <em>polynomial opening proofs should be unique</em>, i.e., it should be infeasible for an adversary to come up with two valid proofs for the same evaluation point. The second required property is a form of hiding. In order to state it, we first recall the methodology followed in the compiler in <em>[GKO+23]</em>, which can be thought of as an <em>encode&commit</em> approach where the prover computes the following:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cm}_{f}\\leftarrow\\mathsf{PCS.Com}(f_{\\mathbf{w}}),\\text{ where }f_{\\mathbf{w}}\\leftarrow\\mathsf{PES.Enc}(\\mathbf{w})</span></p>

    <p class="text-gray-300">That is, it first encodes the witness into a polynomial—using a “polynomial encoding scheme” <span class="math">\\mathsf{PES}</span>—to which it then commits using a polynomial commitment <span class="math">\\mathsf{PCS}</span>. The encoding algorithm is randomized and its role is to <em>mask</em> the witness, so that the latter is still hidden to the verifier even after seeing several—approximately <span class="math">\\lambda</span>—polynomial evaluation proofs. If this is the case we say that the polynomial commitment <span class="math">\\mathsf{PCS}</span> is “<em>evaluation-hiding</em>” with respect to the encoding scheme <span class="math">\\mathsf{PES}</span>. This property—which can be thought of as a form of as a <em>leakage-resilience feature</em> of <span class="math">\\mathsf{PCS}</span> when used in conjunction ot <span class="math">\\mathsf{PES}</span>—is the second special requirement of the compiler in <em>[GKO+23]</em>.</p>

    <p class="text-gray-300">To the best of our knowledge, there is no polynomial commitment scheme relying only on the RO in literature with all of the above properties (with respect to some PES). In our work, we prove that a polynomial commitment scheme based on Bulletproofs of <em>[BBB+18, DG23]</em> does satisfy all the properties we need when paired with an appropriate PES based on secret sharing (or SS-PES) which we also introduce in this work and which was the main source of technical challenges (discussed also in Remark 6). We provide further details in Section 5.3, while below we give a high-level overview.</p>

    <p class="text-gray-300">A stepping-stone observation is that a building block of Bulletproofs itself—its inner-product argument, or <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{IPA}</span>—has several properties that we can use <em>as a bridge</em> to our desired features. After formalizing a simple polynomial commitment based on <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{IPA}</span> we can prove evaluation binding (the standard minimal property for polynomial commitments) through standard techniques based on DLOG and the unique-proofs property by leveraging previous results in <em>[DG23]</em>.</p>

    <p class="text-gray-300">Polynomial encodings from new techniques. A more substantial challenge is finding a suitable polynomial encoding scheme that, together with the PCS above, would satisfy evaluation hiding. The approach to polynomial encoding from <em>[GKO+23]</em> cannot unfortunately work in our setting. Here are some intuitions on why. The building blocks used in <em>[GKO+23]</em> are, respectively, KZG <em>[KZG10]</em>, as a PCS and a simple PES, called the Lagrange encoding, based on parsing a vector as a tuple of evaluations of a polynomial in a known domain and extending it with random evaluations (the same paper proposes also another encoding scheme but this is not important for our discussion). The authors of <em>[GKO+23]</em> are able to prove that KZG with the Lagrange PES satisfies evaluation hiding . Unfortunately for us, it is easy to observe that the polynomial encoding(s) proposed in <em>[GKO+23]</em> cannot achieve evaluation hiding when used with a Bulletproofs-flavored PCS like ours (see rest of this overview and Remark 6).</p>

    <p class="text-gray-300">This leaves us with the task of building a PES from a different approach. Our setting has in fact a number of additional challenges compared to <em>[GKO+23]</em>, which we now sketch. Their starting point</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UC Model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NIZK Functionality</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GKO+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">NPRO</td>

            <td class="px-3 py-2 border-b border-gray-700">xPKE+SDH</td>

            <td class="px-3 py-2 border-b border-gray-700">standard</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">standard</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CF24]</td>

            <td class="px-3 py-2 border-b border-gray-700">Transp.</td>

            <td class="px-3 py-2 border-b border-gray-700">RO</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">standard</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(polylog(n))</td>

            <td class="px-3 py-2 border-b border-gray-700">weak</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BFKT24]</td>

            <td class="px-3 py-2 border-b border-gray-700">Trusted</td>

            <td class="px-3 py-2 border-b border-gray-700">GGM</td>

            <td class="px-3 py-2 border-b border-gray-700">Pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">standard</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">weak</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Transp.</td>

            <td class="px-3 py-2 border-b border-gray-700">NPRO</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">shielded oracles</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(polylog(n))</td>

            <td class="px-3 py-2 border-b border-gray-700">weak</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">Transp.</td>

            <td class="px-3 py-2 border-b border-gray-700">NPRO</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG+PKE</td>

            <td class="px-3 py-2 border-b border-gray-700">shielded oracles</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">standard</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison with other works on UC witness-succinct NIZKs. xPKE stands for eXtended Power Knowledge of Exponent, GGM stands for Generic Group Model, NPRO stands for Non-Programmable Random Oracle and RO stands for Programmable Random Oracle. PKE denotes the existence of public-key encryption (with mild efficiency requirements; see Section 5.2).</p>

    <p class="text-gray-300">as a PCS is KZG, which is a completely non-interactive polynomial commitment relying on DLOG hardness (plus more) whose proof consists of a constant number of group elements. In contrast, our design based on BP-IPA, is highly interactive before applying Fiat-Shamir and its transcript consists of "folded" versions of previous transcript elements, creating non-trivial connections among them, this makes it harder to argue a hiding property like the one we are interested in.</p>

    <p class="text-gray-300">As a consequence of the above, we need to use completely different techniques from the ones in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> . Our approach to build the encoding scheme is described in Section 5.2. Internally, it uses additive secret sharing and an encryption scheme. Ignoring many details, given a vector  <span class="math">\\mathbf{w}</span> , its polynomial encoding consists of a polynomial  <span class="math">f_{\\mathbf{w}}</span>  whose coefficients include  <span class="math">(s_1,\\ldots ,s_\\ell ,s_{\\ell +1},\\ldots)</span> , where the  <span class="math">s_i</span> -s are additive secret shares of some secret value. Being able to show evaluation hiding properties for PES and PCS eventually boils down to showing that the leakage from polynomial evaluation proofs for  <span class="math">f_{\\mathbf{w}}</span>  does not allow an adversary to distinguish whether  <span class="math">s_i</span> -s are shares of a given secret or they are random values.</p>

    <p class="text-gray-300">We first observe that the type of leakage in our polynomial commitment (based on BP-IPA) can be reduced to the leakage of linear combinations of the coefficients  <span class="math">(s_1, \\ldots, s_\\ell, s_{\\ell+1}, \\ldots)</span>  of the evaluated polynomial. Therefore, we define a "leakage-resilience" flavored game for additive secret sharing (Definition 26 in the Appendix) that captures this type of leakage: an adversary  <span class="math">\\mathcal{A}</span>  can query the vector of (alleged) shares and try to gather information on them receiving a linear combination of its choice. In a few more details,  <span class="math">\\mathcal{A}</span>  has access to an oracle that, on input a vector  <span class="math">\\pmb{\\theta}</span> , returns the linear combination  <span class="math">\\sum_{i} \\theta_{i} s_{i}</span> ; the adversary can ask at most  <span class="math">\\ell</span>  such queries; at the end of the game, the adversary wins if it is able to guess whether the  <span class="math">s_i</span> -s are random or shares of a given secret.</p>

    <p class="text-gray-300">With this notion under our belt, we can then prove our desired security if we are able  <span class="math">i)</span>  to reason about what type of constraint on the vectors  <span class="math">\\pmb{\\theta}</span>  would be sufficient for an adversary not to win in the above game, and  <span class="math">(ii)</span>  to later show that the "linear combination" leakage in BP-IPA satisfies the constraints identified in step  <span class="math">(i)</span> . It is relatively straightforward to identify a general meta-property of such constraints for  <span class="math">(i)</span> , but it is quite more challenging to realize step  <span class="math">(ii)</span> . The resulting analysis is highly non-trivial and requires showing that with overwhelming probability a determinant  <span class="math">\\operatorname{det}(M)</span>  is non-zero, where the matrix  <span class="math">M</span>  is (intuitively) derived by the vectors  <span class="math">\\pmb{\\theta}</span>  describing the leakage of the BP-IPA protocol. In Lemma 4 (in the Appendix) we prove this core result. We leave as future work further applications of our techniques and formal connections between them and computational or leakage-resilient secret sharing.</p>

    <p class="text-gray-300">Related work. Other than the prior works we have already mentioned, in concurrent and independent work [CF24] the authors design a succinct NIZK in the global programmable random oracle of  <span class="math">\\left[\\mathrm{CDG}^{+}18\\right]</span> . In this, everyone can program the random oracle, but honest parties can detect if a query has been programmed. This verification is done via a special command that the parties issue to the random oracle that should be used on any query. In our work instead, we rely on the simpler (and strictly less powerful) global random oracle of [CJS14] that does not allow anyone to program hence, it does not require the parties to verify every query during the execution of the real-world protocol.</p>

    <p class="text-gray-300">1.2 Discussion: Comparing UC-SNARK Compilers and Our Instantiation Choices</p>

    <p class="text-gray-300">We chose two flavors of instantiations in our work: one from <em>[x10]</em> and the other adapting the compiler in <em>[GKO^{+}23]</em>. The advantages of the approach in <em>[x10]</em> include its simplicity, the fact that one can obtain “unconditional” security (relying only on the ROM) and the fact that it introduces no prover overhead. The compiler from <em>[GKO^{+}23]</em> is technically more complicated and incurs an overhead for the prover (e.g., the correct encoding and commitment of the witness needs to be proven through the underlying NIZK). On the other hand the latter compiler has also several advantages that, in our opinion, make it a more viable choice scientifically in the long term (and motivate its prominent role in the main text of this work).</p>

    <p class="text-gray-300">As discussed above, a first limitation of the framework from <em>[x10]</em> is that it can yield only a limited form of the NIZK functionality since this weaker notion could be realized by schemes that are possibly malleable, thus one should be careful when designign a protocol that uses it as inner building block. We notice that a similar limitation holds for the setting studied by Bobolz et al. <em>[x3]</em> as they prove the UC-security of Groth16 <em>[x16]</em>, a zkSNARK whose proof can be re-randomized and hence is malleable.</p>

    <p class="text-gray-300">Second, the compiler from <em>[GKO^{+}23]</em> is fully general, in that it can in principle be used to lift any simulation-extractable zkSNARK; in contrast, the approach in <em>[x10]</em> requires to assume specific forms of zkSNARKs that are already straight-line extractable, such as Interactive Oracle Proofs <em>[x5]</em>. This implies that one cannot use their work to lift the vast pool of efficient SNARKs based on frameworks with polynomial oracles <em>[GKKB12, CFF^{+}21, x14, x11]</em>. Another disadvantage of the approach in <em>[x10]</em> is that, by relying on Merkle Trees as an almost essential tool, it cannot inherently go below the logarithmic barrier for proof size. On the other hand a set of techniques based on PCS may enable future works building on ours to apply the next-generation of transparent SNARKs and PCS with smaller proof sizes.</p>

    <p class="text-gray-300">Besides what has already been mentioned above, these two types of instantiations obtain different tradeoffs for proof size and verification time. In fact, our instantiation from <em>[GKO^{+}23]</em> obtains the smallest proof size (logarithmic) at the cost of a slower verifier (running in linear time, due to Bulletproofs). In contrast, our instantiation from <em>[x10]</em> features a larger proof—of size <span class="math">O(\\log^{2}(N))</span>—but a more efficient verifier—running in time <span class="math">O(\\log^{2}(N))</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Future Work and Alternative Instantiations</h3>

    <p class="text-gray-300">The instantiations we obtain achieve logarithmic proof size but verification time linear in the witness. In order to obtain a more balanced efficiency profile (e.g., poly-logarithmic proof size and poly-logarithmic verification time) one would need to look for different instantiations of the polynomial commitment and NIZK with the required properties.</p>

    <p class="text-gray-300">For polynomial commitments, we see as a plausible candidate the Dory commitment scheme <em>[x21]</em>, which is transparent and achieves both logarithmic opening size and logarithmic verification time. Dory is, at its heart, a Bulletproofs-based polynomial commitment but reduces the verification time through an appropriately crafted verification key and the use of commitments to vectors of group elements in a bilinear setting. It may be possible to prove unique-response of variants of Dory using some of the techniques in <em>[x13]</em>, but at the moment this is still an open problem. We find it plausible that the <span class="math">\\phi</span>-evaluation hiding profile of Dory is similar to that of the Bulletproofs polynomial commitment scheme presented here.</p>

    <p class="text-gray-300">A line of research <em>[GM17, GKK^{+}22, x12, KPT23, FFK^{+}23, FFR24, x12]</em> has shown that notable zkSNARKs are simulation-extractable, but none of these works is suitable for our setting since either the schemes are non-transparent or the results are rewinding-based. For what concerns <em>transparent</em> simulation-extractable NIZKs with succinct proofs, we see as a possible candidate the NIZK Spartan <em>[x20]</em>. As of now, however, the only version of Spartan explicitly proved as simulation-extractable uses Hyrax <em>[WTs^{+}18]</em> with openings of size square root and square root verification time <em>[x12]</em> We</p>

    <p class="text-gray-300">find it plausible that the techniques in [DG23] may be generalized to instantiations with  <span class="math">n^{1/c}</span>  efficiency for  <span class="math">c \\geq 2</span> . We leave this as an open problem for future work which could potentially lead to a first transparent UC-NIZK with sublinear verification time, full non-malleability and secure without programming the RO.</p>

    <p class="text-gray-300">Paper outline In Section 2, we present the necessary preliminaries, including background on publickey encryption, secret sharing, and polynomial commitment schemes. Our formal definition of the NIZK functionality in the global random oracle model appears in Section 3. In Section 4, we describe our main UC NIZK protocol and its realization. Section 5 provides concrete instantiations of our scheme, including our approach to polynomial encoding and polynomial commitments. Most of the security proofs and additional technical discussions are deferred to the appendices.</p>

    <p class="text-gray-300">We use the notation  <span class="math">[x,y]</span>  to denote  <span class="math">\\{x,x + 1,\\ldots ,y\\}</span> , for some positive integer  <span class="math">x,y</span>  where  <span class="math">x &amp;lt; y</span> . The notation  <span class="math">x\\gets \\# X</span>  indicates sampling  <span class="math">x</span>  from the uniform distribution defined over  <span class="math">X</span> . We write  <span class="math">\\mathbb{F}[X]</span>  to denote polynomials over a finite field  <span class="math">\\mathbb{F}</span> . For an integer  <span class="math">d\\geq 1</span> , we denote the polynomials with degree  <span class="math">\\leq d</span>  as  <span class="math">\\mathbb{F}_{&amp;lt; d}[X]\\subseteq \\mathbb{F}[X]</span> . The security parameter is denoted with  <span class="math">\\lambda</span> . If  <span class="math">f</span>  is some function (possibly in other parameters), we denote by  <span class="math">O_{\\lambda}(f)</span>  the class  <span class="math">O(\\mathsf{poly}(\\lambda)\\cdot f)</span> . Given two vectors  <span class="math">\\mathbf{a},\\mathbf{b}\\in \\mathbb{F}^n</span>  we denote by  <span class="math">c = \\mathbf{a}\\circ \\mathbf{b}</span>  their Hadamard product, that is  <span class="math">c_{i} = a_{i}\\cdot b_{i}</span>  for  <span class="math">i\\in [n]</span> . For  <span class="math">m\\in [n]</span>  we denote by  <span class="math">\\mathbf{v}_{[:m]}</span>  the prefix  <span class="math">(v_{1},\\dots,v_{m - 1})</span>  and by  <span class="math">\\mathbf{v}_{[m:]}</span>  the suffix  <span class="math">(v_{m},\\dots,v_{n})</span> . Let  <span class="math">\\mathbb{G}</span>  be a multiplicative group. If  <span class="math">\\mathbf{g}</span>  and  <span class="math">\\mathbf{v}</span>  are vectors of  <span class="math">n</span>  elements in  <span class="math">\\mathbb{G}</span>  and  <span class="math">\\mathbb{F}</span> , respectively, then we denote by  <span class="math">\\mathbf{g}^{\\mathbf{v}}</span>  the product  <span class="math">\\prod_{i}g_{i}^{v_{i}}</span> . We denote by  <span class="math">M^{\\intercal}</span>  the transpose of a matrix  <span class="math">M</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\varPi=(P,V)</span>  is an interactive argument system in the random oracle model, we denote by  <span class="math">\\varPi_{\\mathsf{FS}}=(P_{\\mathsf{FS}},V_{\\mathsf{FS}})</span>  the non-interactive version of that argument compiled in the standard manner through Fiat-Shamir transform [FS87]. We refer the reader to [DG23, Section 2] for additional details.</p>

    <p class="text-gray-300">Discrete Logarithm Assumption. In our constructions we make use of a variant of the discrete logarithm (DLOG) assumption for multiple generators. Below  <span class="math">\\mathcal{G}</span>  denotes a group generator.</p>

    <p class="text-gray-300">Assumption 1 (Generalized DLOG [BBB+18]) For all PPT  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\lambda \\in \\mathbb{N}</span>  and  <span class="math">m \\geq 2</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathbb {G} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) &amp;amp; \\exists j ^ {*} \\in [ m ] a _ {j ^ {*}} \\neq 0 \\wedge \\\\ (g _ {1}, \\ldots , g _ {m}) \\leftarrow \\sharp \\mathbb {G}: &amp;amp; \\prod_ {j \\in [ m ]} g _ {j} ^ {a _ {j}} = 1 _ {\\mathbb {G}} \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Diffie-Hellman Assumption. Below  <span class="math">\\mathcal{G}</span>  denotes a group generator.</p>

    <p class="text-gray-300">Assumption 2 (DDH) For all  <span class="math">PPT\\mathcal{A}</span> ,  <span class="math">\\lambda \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{c c} \\mathbb {G} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) &amp; \\\\ g \\leftarrow \\sharp \\mathbb {G} &amp; \\\\ a, b, c \\leftarrow \\sharp \\{1, \\ldots ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} &amp; \\beta \\leftarrow \\sharp \\{0, 1 \\} &amp; : \\beta^ {\\prime} = \\beta \\\\ z := \\beta a b + (1 - \\beta) c &amp; \\\\ \\beta^ {\\prime} \\leftarrow \\mathcal {A} (\\mathbb {G}, g, g ^ {a}, g ^ {b}, g ^ {z}) &amp; \\end{array} \\right] \\leq \\frac {1}{2} + \\mathsf {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a field. We consider public-key encryption schemes whose input is a vector of field elements and output a vector of field elements (of a different size).</p>

    <p class="text-gray-300">Definition 1. A PKE scheme consists of a tuple of algorithms  <span class="math">\\mathsf{PKE} = (\\mathsf{KG},\\mathsf{Enc},\\mathsf{Dec})</span>  with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KG}(1^{\\lambda})\\to(\\mathsf{pk}\\in\\mathbb{F}^{\\kappa},\\mathsf{sk}\\in\\mathbb{F})</span>: generates a key pair (the algorithm is randomized).</li>

      <li><span class="math">\\mathsf{Enc}(\\mathsf{pk}\\in\\mathbb{F}^{n},\\mathbf{m}\\in\\mathbb{F}^{n})\\to\\mathbf{ct}\\in\\mathbb{F}^{n^{\\prime}}</span>: produces a ciphertext corresponding to a message <span class="math">m</span> through the public key (the algorithm is randomized).</li>

      <li><span class="math">\\mathsf{Dec}(\\mathsf{sk}\\in\\mathbb{F},\\mathbf{ct}\\in\\mathbb{F}^{n^{\\prime}})\\to\\mathbf{m}\\in\\mathbb{F}^{n}</span>: decrypts a ciphertext through the secret key (the algorithm is deterministic).</li>

    </ul>

    <p class="text-gray-300">We require the following properties:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Correctness.</h6>

    <p class="text-gray-300">For any <span class="math">\\lambda,n\\in\\mathbb{N}</span>, any plaintext <span class="math">\\mathbf{m}\\in\\mathbb{F}^{n}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{Dec}(\\mathsf{sk},\\mathbf{ct})=\\mathbf{m}\\right]=1</span></p>

    <p class="text-gray-300">where <span class="math">(\\mathsf{pk},\\mathsf{sk})\\leftarrow\\mathsf{KG}(1^{\\lambda})</span> and <span class="math">\\mathbf{ct}\\leftarrow\\mathsf{Enc}(\\mathsf{pk},\\mathbf{m})</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Semantic security.</h6>

    <p class="text-gray-300">For all <span class="math">\\lambda\\in\\mathbb{N}</span>, for any PPT adversary <span class="math">\\mathcal{A}=(\\mathcal{A}^{1},\\mathcal{A}^{2})</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\begin{matrix}(\\mathsf{pk},\\mathsf{sk})\\leftarrow\\mathsf{KG}(1^{\\lambda}),(\\mathsf{st},\\mathbf{m}_{0},\\mathbf{m}_{1})\\leftarrow\\mathcal{A}^{1}(\\mathsf{pk})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.2 Secret Sharing</h3>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2 (Additive <span class="math">m</span>-out-of-<span class="math">m</span> Secret Sharing).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field. An additive secret sharing scheme consists of a pair of algorithms <span class="math">\\mathsf{SS}=(\\mathsf{Share},\\mathsf{Reconstr})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Share}(m\\in\\mathbb{N},s^{\\prime}\\in\\mathbb{F}):</span> Sample <span class="math">s_{1},\\ldots,s_{m}</span> s.t. <span class="math">s_{m}:=s^{\\prime}+\\sum_{i=1}^{m-1}s_{i}</span>. Return <span class="math">(s_{1},\\ldots,s_{m})</span>.</li>

      <li><span class="math">\\mathsf{Reconstr}(m\\in\\mathbb{N},\\mathsf{s}\\in\\mathbb{F}^{m}):</span> Return <span class="math">s_{m}-\\sum_{i=1}^{m-1}s_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">Two basic facts (which we will use in our proofs) regarding the construction above:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the reconstruction algorithm is always able to reconstruct the secret from its shares.</li>

      <li>to any (potentially unbounded) adversary, a set of up to <span class="math">m-1</span> shares of any secret will look as if randomly distributed.</li>

    </ul>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.3 Non-interactive Arguments</h3>

    <p class="text-gray-300">A <em>non-interactive argument system</em> (NARG) for relation <span class="math">\\mathcal{R}</span> in the random oracle model, denoted by <span class="math">\\Pi_{\\mathcal{R}}</span>, consists of a tuple of algorithms <span class="math">(\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span> having black-box access to a random oracle <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span>, with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{PGen}(1^{\\lambda})</span>: Takes as input the security parameter <span class="math">1^{\\lambda}</span> and outputs public parameters <span class="math">\\mathsf{pp}</span>. Once <span class="math">\\mathsf{PGen}</span> is invoked we assume that all of the following algorithms take <span class="math">\\mathsf{pp}</span> as an implicit input. In this work, we have consider transparent setup and <span class="math">\\mathsf{pp}</span> can be generated with a call to the random oracle.</li>

      <li><span class="math">\\pi\\leftarrow\\mathcal{P}^{\\mathcal{H}}(x,w)</span>: Takes as input a statement <span class="math">x</span> and witness <span class="math">w</span>, and outputs a proof <span class="math">\\pi</span> if <span class="math">(x,w)\\in\\mathcal{R}</span>.</li>

      <li><span class="math">b\\leftarrow\\mathcal{V}^{\\mathcal{H}}(x,\\pi)</span>: Takes as input a statement <span class="math">x</span> and proof <span class="math">\\pi</span>, and outputs a bit <span class="math">b</span>, indicating “accept” or “reject”.</li>

    </ul>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3 (Completeness).</h6>

    <p class="text-gray-300">A NARG <span class="math">\\Pi_{\\mathcal{R}}</span> satisfies <em>completeness</em> if for every <span class="math">(x,w)\\in\\mathcal{R}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[b=1\\ :\\ \\mathsf{pp}\\leftarrow\\mathsf{PGen}(1^{\\lambda});\\pi\\leftarrow\\mathcal{P}^{\\mathcal{H}}(x,w);b\\leftarrow\\mathcal{V}^{\\mathcal{H}}(x,\\pi)\\right]=1.</span></p>

    <p class="text-gray-300">Besides completeness, basic security properties of (zk)NARGs are zero-knowledge and knowledge-soundness. Informally, an argument is zero-knowledge if a proof reveals no information about the witness, and it is knowledge-sound if from a prover producing a valid proof it is possible to <em>extract</em> a valid witness: this extraction procedure, denoted by an algorithm <span class="math">\\mathcal{E}</span>, may either “rewind” the prover or not: in the latter case the extractor is said to be <em>straight-line</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Definition 4 (Knowledge-soundness). A NARG  <span class="math">\\Pi_{\\mathcal{R}}</span>  is (adaptively) knowledge sound (KS) if there exists an extractor  <span class="math">\\mathcal{E}</span>  running in expected polynomial time such that for every PPT adversary  <span class="math">\\mathcal{P}^*</span> , the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {A d v} _ {\\Pi_ {\\mathcal {R}}, \\mathcal {R}} ^ {\\mathrm {K S}} (\\mathcal {E}, \\mathcal {P} ^ {*}) := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathrm {K S} _ {0, \\Pi_ {\\mathcal {R}}} ^ {\\mathcal {P} ^ {<em>}} (\\lambda) \\right] - \\Pr \\left[ \\mathrm {K S} _ {1, \\Pi_ {\\mathcal {R}}, \\mathcal {R}} ^ {\\mathcal {E}, \\mathcal {P} ^ {</em>}} (\\lambda) \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The knowledge soundness games are defined in Fig. 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game KS0,ΠR(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game KSε,PT1,ΠR, R(λ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">pp← PGen (1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">pp← PGen (1λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(x,π)← (P*)H(pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">(x,π)← (P*)H(pp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b← VH(pp, x, π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b← VH(pp, x, π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b</td>

            <td class="px-3 py-2 border-b border-gray-700">w← EP*(pp, x, π)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | return b ∧ (pp, x, w) ∈ R  |</p>

    <p class="text-gray-300">Fig. 1: Knowledge soundness security games. Here the extractor  <span class="math">\\mathcal{E}</span>  is given black-box access to  <span class="math">\\mathcal{P}^<em></span> . In particular,  <span class="math">\\mathcal{E}</span>  implements  <span class="math">\\mathcal{H}</span>  for  <span class="math">\\mathcal{P}^</em></span>  and can rewind  <span class="math">\\mathcal{P}^*</span>  to any point.</p>

    <p class="text-gray-300">Definition 5 (Straight-line Knowledge Soundness). Protocol  <span class="math">\\Pi_{\\mathcal{R}}</span>  is knowledge-extractable if for any PPT adversary  <span class="math">\\mathcal{A}</span> , there exists a PPT extractor  <span class="math">\\mathcal{E}^{\\mathcal{O}_{\\mathrm{ext}}}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ b = 1 \\wedge (x, w) \\notin \\mathcal {R}: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {P G e n} (1 ^ {\\lambda}); (x, \\pi) \\leftarrow \\mathcal {A} ^ {\\mathcal {H}} (\\mathsf {p p}); \\\\ b \\leftarrow \\mathcal {V} ^ {\\mathcal {H}} (x, \\pi); w \\leftarrow \\mathcal {E} ^ {\\mathcal {O} _ {\\mathrm {e x t}}} (x, \\pi) \\end{array} \\right] &amp;lt;   \\nu (\\lambda)</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathcal{O}_{\\mathrm{ext}}</span>  is a stateful oracle which stores the list  <span class="math">\\mathcal{L}</span>  all the input-output (in, out) queries made to  <span class="math">\\mathcal{H}</span>  by  <span class="math">\\mathcal{A}</span> , and upon being queried it provides  <span class="math">\\mathcal{L}</span> .</p>

    <p class="text-gray-300">Zero-Knowledge. We define zero-knowledge by following the syntax of [FKMV12, GOP+22]. A zero-knowledge simulator  <span class="math">S</span>  is defined as a stateful algorithm with initial state  <span class="math">\\mathsf{st} = \\mathsf{pp}</span>  that operates in two modes. The first mode,  <span class="math">(\\mathsf{out},\\mathsf{st}^{\\prime})\\gets S(1,\\mathsf{st},\\mathsf{in})</span>  takes care of handling calls to the oracle  <span class="math">\\mathcal{H}</span>  on input in; specifically  <span class="math">S_{1}(\\mathsf{in})</span>  can reprogram the random oracle  <span class="math">\\mathcal{H}</span> , and observe the query made to  <span class="math">\\mathcal{H}</span>  by the adversary. The second mode,  <span class="math">(\\pi ,\\mathsf{st}^{\\prime})\\gets S(2,\\mathsf{st},x)</span>  simulates a proof for the input statement  <span class="math">x</span> . For convenience we define three "wrapper" oracles. These oracles are stateful and share the internal state st, which initially contains an empty string.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{1}(\\mathsf{in})</span>  to denote the oracle that returns the first output of  <span class="math">S(1, \\mathsf{st}, \\mathsf{in})</span> ;</li>

      <li><span class="math">S_{2}(x, w)</span>  that returns the first output of  <span class="math">S(2, \\mathsf{st}, x)</span>  if  <span class="math">(x, w) \\in \\mathcal{R}</span>  and  <span class="math">\\bot</span>  otherwise;</li>

      <li><span class="math">S_2&#x27;(x)</span>  that returns the first output of  <span class="math">S(2, \\mathsf{st}, x)</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 6 (Zero-Knowledge). Protocol  <span class="math">\\Pi_{\\mathcal{R}}</span>  is unbounded non-interactive zero-knowledge (NIZK), if there exists a PPT simulator  <span class="math">S</span>  with wrapper oracles  <span class="math">S_{1}</span>  and  <span class="math">S_{2}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span>  it holds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 1: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {P G e n} (1 ^ {\\lambda}); \\\\ b \\leftarrow \\mathcal {A} ^ {\\mathcal {H}, \\mathcal {P}} (\\mathsf {p p}) \\end{array} \\right] - \\Pr \\left[ b = 1: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {P G e n} (1 ^ {\\lambda}); \\\\ b \\leftarrow \\mathcal {A} ^ {S _ {1}, S _ {2}} (\\mathsf {p p}) \\end{array} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   \\nu (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Simulation extractability. A stronger security property is simulation extractability, which roughly speaking captures knowledge-soundness in presence of simulated proofs (provided by a simulator).</p>

    <p class="text-gray-300">In this work, we consider different flavors of simulation extractability depending on the type of algorithm or the conditions under which the extractor  <span class="math">\\mathcal{E}</span>  is required to succeed.</p>

    <p class="text-gray-300">First, similarly to the knowledge-soundness setting, we make a distinction between straight-line and rewinding-based simulation extractability depending on the behavior of the extractor. Moreover, we have true-simulation extractability [DHLW10] if the adversary can see simulated proofs only by providing a pair  <span class="math">(x,w)\\in \\mathcal{R}</span>  to the simulator.</p>

    <p class="text-gray-300">We formalize these properties hereafter.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 7 (Simulation Extractability).</h6>

    <p class="text-gray-300">Consider a non-interactive proof system <span class="math">\\Pi_{\\mathcal{R}}=(\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span> in the random oracle model <span class="math">\\mathcal{H}</span> for relation <span class="math">\\mathcal{R}</span> with an <span class="math">NIZK</span> simulator <span class="math">\\mathcal{S}</span>. Let <span class="math">(\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime})</span> be wrapper oracles for <span class="math">\\mathcal{S}</span> as defined in Definition 6. <span class="math">\\Pi_{\\mathcal{R}}</span> is simulation-extractable (SIM-EXT) with respect to <span class="math">\\mathcal{S}</span>, if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a <span class="math">\\mathsf{PPT}</span> extractor <span class="math">\\mathcal{E}^{\\mathcal{A}}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(x,\\pi)\\notin\\mathcal{Q}\\land(x,w)\\notin\\mathcal{R}&\\text{pp}\\leftarrow\\mathsf{PGen}(1^{\\lambda});(x,\\pi)\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime}}(\\mathsf{pp});\\\\ \\land b=1&b\\leftarrow\\mathcal{V}^{\\mathcal{S}_{1}}(x,\\pi);w\\leftarrow\\mathcal{E}^{\\mathcal{A}}(x,\\pi,\\mathsf{st})\\end{matrix}\\right]<\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{st}</span> is the final state of the simulator <span class="math">\\mathcal{S}</span>, and <span class="math">\\mathcal{Q}</span> is a set of statement-proof pairs <span class="math">(x,\\pi)</span> with <span class="math">x</span> being a statement queried by <span class="math">\\mathcal{A}</span> to the proof simulation wrapper oracle <span class="math">\\mathcal{S}_{2}^{\\prime}</span>, and <span class="math">\\pi</span> being the corresponding simulated proof, respectively.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 8 (Straight-line Simulation Extractability).</h6>

    <p class="text-gray-300">Consider a non-interactive proof system <span class="math">\\Pi_{\\mathcal{R}}=(\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> in the random oracle model <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{\\lambda}</span> with an associated NIZK simulator <span class="math">\\mathcal{S}</span>, where <span class="math">(\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime})</span> denote the wrapper oracles for <span class="math">\\mathcal{S}</span> as defined above. Let further <span class="math">\\mathcal{O}_{\\mathsf{ext}}</span> be a stateful oracle which stores the list <span class="math">\\mathcal{L}</span> all the input-output <span class="math">(\\mathsf{in},\\mathsf{out})</span> queries made to <span class="math">\\mathcal{S}_{1}</span>, and upon being queried it provides <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathcal{R}}</span> is simulation-extractable (SIM-EXT) with respect to <span class="math">\\mathcal{S}</span>, if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a <span class="math">\\mathsf{PPT}</span> extractor <span class="math">\\mathcal{E}^{\\mathcal{O}_{\\mathsf{ext}}}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(x,\\pi)\\notin\\mathcal{Q}\\land(x,w)\\notin\\mathcal{R}&\\text{pp}\\leftarrow\\mathsf{PGen}(1^{\\lambda});(x,\\pi)\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime}}(\\mathsf{pp});\\\\ \\land b=1&b\\leftarrow\\mathcal{V}^{\\mathcal{S}_{1}}(x,\\pi);w\\leftarrow\\mathcal{E}^{\\mathcal{O}_{\\mathsf{ext}}}(x,\\pi,\\mathsf{st})\\end{matrix}\\right]<\\nu(\\lambda) \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{st}</span> is the final state of the simulator <span class="math">\\mathcal{S}</span>, and <span class="math">\\mathcal{Q}</span> is a set of statement-proof pairs <span class="math">(x,\\pi)</span> with <span class="math">x</span> being a statement queried by <span class="math">\\mathcal{A}</span> to the proof simulation wrapper oracle <span class="math">\\mathcal{S}_{2}^{\\prime}</span>, and <span class="math">\\pi</span> being the corresponding simulated proof, respectively.</p>

    <p class="text-gray-300">We observe that the notion of straight-line simulation extractability implies the notion of straight-line knowledge soundness. The definition of simulation extractability reported above is also referred to as the <em>strong</em> variant of (straight-line) simulation extractability, whereas the <em>weak</em> variant restricts the adversary to provide a proof for a <em>fresh</em> statement for which has never queried the simulator. Interestingly, Kosba et al. <em>[KZM^{+}15]</em> show that it suffices for a typical UC application.</p>

    <p class="text-gray-300">We recall a weaker version introduced by Dodis et al. <em>[x10]</em> and dubbed <em>true-simulation extractability</em>. We adapt it to the context of straight-line extractors in the random oracle model.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 9 (Straight-line True-Simulation Extractability).</h6>

    <p class="text-gray-300">Consider a non-interactive proof system <span class="math">\\Pi_{\\mathcal{R}}=(\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> in the random oracle model <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{\\lambda}</span> with an NIZK simulator <span class="math">\\mathcal{S}</span>, where <span class="math">(\\mathcal{S}_{1},\\mathcal{S}_{2})</span> denote the wrapper oracles for <span class="math">\\mathcal{S}</span> as defined above. Let further <span class="math">\\mathcal{O}_{\\mathsf{ext}}</span> be a stateful oracle which stores the list <span class="math">\\mathcal{L}</span> all the input-output <span class="math">(\\mathsf{in},\\mathsf{out})</span> queries made to <span class="math">\\mathcal{S}_{1}</span>, and upon being queried it provides <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathcal{R}}</span> is true-simulation-extractable (TRUE-SIM-EXT) with respect to <span class="math">\\mathcal{S}</span>, if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a <span class="math">\\mathsf{PPT}</span> extractor <span class="math">\\mathcal{E}^{\\mathcal{O}_{\\mathsf{ext}}}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(x,\\pi)\\notin\\mathcal{Q}\\land(x,w)\\notin\\mathcal{R}&\\text{pp}\\leftarrow\\mathsf{PGen}(1^{\\lambda});(x,\\pi)\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1},\\mathcal{S}_{2}}(\\mathsf{pp});\\\\ \\land b=1&b\\leftarrow\\mathcal{V}^{\\mathcal{S}_{1}}(x,\\pi);w\\leftarrow\\mathcal{E}^{\\mathcal{O}_{\\mathsf{ext}}}(x,\\pi,\\mathsf{st})\\end{matrix}\\right]<\\nu(\\lambda) \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{st}</span> is the final state of the simulator <span class="math">\\mathcal{S}</span>, and <span class="math">\\mathcal{Q}</span> is a set of statement-proof pairs <span class="math">(x,\\pi)</span> with <span class="math">x</span> being a statement queried by <span class="math">\\mathcal{A}</span> to the proof simulation wrapper oracle <span class="math">\\mathcal{S}_{2}^{\\prime}</span>, and <span class="math">\\pi</span> being the corresponding simulated proof, respectively.</p>

    <p class="text-gray-300">Similarly, one can weaken the above definition by requiring the adversary to provide a proof for a <em>fresh</em> statement for which has never queried the simulator: this definition is referred to as the <em>weak</em> variant of the straight-line true-simulation extractability.</p>

    <p class="text-gray-300">Finally, we can consider a weaker version of true-simulation extractability in which <span class="math">\\mathcal{E}</span> is required to work only on statements for which the adversary has never queried the simulation oracle, whereas the <em>strong</em> variant does not restrict this.</p>

    <p class="text-gray-300">Unique response. We finally state an important definition regarding non-interactive proofs derived via the Fiat-Shamir Transform <em>[x14]</em>. We refer the reader to <em>[x11]</em> (Sections 2.3 and 2.4) for additional details.</p>

    <p class="text-gray-300">Definition 10 (k-Unique Response). Let  <span class="math">\\Pi = (\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span>  be a  <span class="math">(2r + 1)</span> -message public-coin interactive argument, with  <span class="math">\\Pi_{\\mathrm{FS}} = (\\mathsf{PGen},\\mathcal{P}_{\\mathrm{FS}},\\mathcal{V}_{\\mathrm{FS}})</span>  its associated FS-transformed NARG and  <span class="math">k\\in [0,r]</span> . We say  <span class="math">\\Pi_{\\mathrm{FS}}</span>  satisfies  <span class="math">k</span> -unique response ( <span class="math">k</span> -UR) if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the following probability (defined with respect to the game in Fig. 2) is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\Pi_ {\\mathrm {F S}}} ^ {k - \\mathrm {U R}} (\\mathcal {A}) := \\Pr \\left[ k - \\operatorname {U R} _ {\\Pi_ {\\mathrm {F S}}} ^ {\\mathcal {A}} (\\lambda) \\right].</span></div>

    <p class="text-gray-300">When  <span class="math">k = 0</span> , we say that  <span class="math">\\Pi_{\\mathrm{FS}}</span>  has (computationally) unique proofs.</p>

    <pre><code class="language-latex">Game  $k$  -UR  $\\mathcal{A}_{\\Pi_{\\mathrm{FS}}}(\\lambda)$ $\\mathrm{pp}\\gets \\mathsf{PGen}\\left(1^{\\lambda},\\mathrm{pp}_{\\mathcal{G}}\\right)$ $(x,\\pi ,\\pi^{\\prime},c)\\gets \\mathcal{A}^{\\mathcal{H}}(\\mathrm{pp})$ $b\\gets \\mathcal{V}_{\\mathrm{FS}}^{\\mathcal{H}\\left[\\left(\\mathrm{pp},x,\\pi |_k\\right)\\mapsto c\\right]}(\\mathrm{pp},x,\\pi) = 1$ $b^{\\prime}\\gets \\mathcal{V}_{\\mathrm{FS}}^{\\mathcal{H}\\left[\\left(\\mathrm{pp},x,\\pi^{\\prime}|_k\\right)\\mapsto c\\right]}(\\mathrm{pp},x,\\pi^{\\prime}) = 1$ $\\mathrm{return}b\\wedge b^{\\prime}\\wedge \\pi \\neq \\pi^{\\prime}\\wedge \\pi |_{k} = \\pi^{\\prime}|_{k}$</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 2: Security game for  <span class="math">k</span> -unique response. Here  $\\mathcal{H}[(\\mathrm{pp}, x, \\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_k) \\mapsto c]<span class="math">  denotes the random oracle where the input  </span>(\\mathrm{pp}, x, \\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_k)<span class="math">  is reprogrammed to output  </span>c$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following definition is adapted from  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> , which in turns adapts it from the full version of  <span class="math">\\left[\\mathrm{CHM}^{+}20\\right]</span> . In Appendix B.1, we elaborate on the difference between our minor adaptations and the definitions in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> .</p>

    <p class="text-gray-300">Definition 11 (Polynomial Commitment Scheme). A polynomial commitment scheme in the random oracle model  <span class="math">\\mathcal{H}:\\{0,1\\}^*\\to \\{0,1\\}^\\lambda</span>  over field  <span class="math">\\mathbb{F}</span> , denoted by PCS, is a tuple of algorithms (PCGen, Com, Eval, Check):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{ck} \\gets \\mathsf{PCGen}(1^{\\lambda}, d)</span> : Takes as input the security parameter  <span class="math">\\lambda</span>  and the maximum degree bound  <span class="math">d</span>  and generates the public parameters  <span class="math">\\mathsf{ck}</span>  as output.</li>

      <li><span class="math">c\\gets \\operatorname {Com}(\\mathsf{ck},f)</span>  : Takes as input ck, the polynomial  <span class="math">f\\in \\mathbb{F}_{&amp;lt; d}[X]</span>  and outputs a commitment  <span class="math">c</span></li>

      <li><span class="math">\\pi \\gets \\mathsf{Eval}^{\\mathcal{H}}(\\mathsf{ck},c,z,y,f)</span> : Has oracle access to  <span class="math">\\mathcal{H}</span>  and takes as input ck, the commitment  <span class="math">c</span> , evaluation point  <span class="math">z\\in \\mathbb{F}</span> , claimed polynomial evaluation  <span class="math">y\\in \\mathbb{F}</span> , the polynomial  <span class="math">f</span> , and outputs a non-interactive proof of evaluation  <span class="math">\\pi</span> .</li>

      <li><span class="math">b \\gets \\operatorname{Check}^{\\mathcal{H}}(\\mathsf{ck}, c, z, y, \\pi)</span> : Has oracle access to  <span class="math">\\mathcal{H}</span>  and takes as input statement  <span class="math">(\\mathsf{ck}, c, z, y)</span>  and the proof of evaluation  <span class="math">\\pi</span>  and outputs a bit  <span class="math">b</span> .</li>

    </ol>

    <p class="text-gray-300">satisfying the following properties:</p>

    <p class="text-gray-300">Completeness. For any integer  <span class="math">d</span> , for all polynomials  <span class="math">f \\in \\mathbb{F}_{&amp;lt;d}[X]</span> , for all evaluation points  <span class="math">z \\in \\mathbb{F}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {P C G e n} (1 ^ {\\lambda}, d); c \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f); \\\\ b = 1: &amp;amp; y := f (z); \\pi \\leftarrow \\mathsf {E v a l} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y, f); \\\\ &amp;amp; b \\leftarrow \\mathsf {C h e c k} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y, \\pi) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Evaluation Binding. For any integer  <span class="math">d</span> , for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} y \\neq y ^ {\\prime} &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {P C G e n} (1 ^ {\\lambda}, d); (c, z, y, y ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} ^ {\\mathcal {H}} (\\mathsf {c k}); \\\\ \\wedge b = 1: &amp;amp; b \\leftarrow \\mathsf {C h e c k} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y, \\pi); \\\\ \\wedge b ^ {\\prime} = 1 &amp;amp; b ^ {\\prime} \\leftarrow \\mathsf {C h e c k} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y ^ {\\prime}, \\pi^ {\\prime}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Following  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span>  we require that a  <span class="math">PCS</span>  satisfies also the following additional properties.</p>

    <p class="text-gray-300">Definition 12 (Unique Proof). For all PPT adversaries  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {P C G e n} (1 ^ {\\lambda}, d); \\\\ \\pi \\neq \\pi^ {\\prime} &amp;amp; (c, z, y, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} ^ {\\mathcal {H}} (\\mathsf {c k}); \\\\ \\wedge b = 1: &amp;amp; b \\leftarrow \\mathsf {C h e c k} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y, \\pi); \\\\ \\wedge b ^ {\\prime} = 1 &amp;amp; b ^ {\\prime} \\leftarrow \\mathsf {C h e c k} ^ {\\mathcal {H}} (\\mathsf {c k}, c, z, y, \\pi^ {\\prime}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">We adopt a minor variant of the definition of polynomial encoding scheme given in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> . In some respect we specialize it, in others we generalize it (see Appendix B.1). At its essence, a polynomial encoding scheme takes a vector of field elements and outputs an appropriate randomized polynomial.</p>

    <p class="text-gray-300">Definition 13 (Polynomial Encoding Scheme). A polynomial encoding scheme, denoted by PES, is a tuple of algorithms (Enc, Dec)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f \\gets \\mathsf{Enc}(1^{\\lambda}, \\mathbf{w}, n, \\ell; \\rho)</span> : Takes as inputs a security parameter,  <span class="math">\\mathbf{w} \\in \\mathbb{F}^n</span> , dimension of the vector  <span class="math">n &amp;gt; 0</span> , evaluation bound  <span class="math">\\ell &amp;gt; 0</span> , and randomness  <span class="math">\\rho \\in \\mathbb{F}^\\ell</span> , and outputs a polynomial  <span class="math">f \\in \\mathbb{F}_{&lt;d}[x]</span> <span class="math">f=&quot;&quot; </span>d<span class="math">=&quot;&quot; </span>f\\in="" <span class="math">n=&quot;&quot; </span>n<span class="math">=&quot;&quot; </span>p\\in="" <span class="math">p\\in\\mathbb{f}^{\\ell}</span>="" <span class="math">r\\in\\mathbb{f}_{&lt;n+\\ell}[x]</span>="" <span class="math">x</span>="" <span class="math">x</span>="" <span class="math">x^i\\in\\mathbb{f}^n</span>="" <span class="math">x^i\\in\\mathbb{f}^n</span>="" <span class="math">x^i\\in\\mathbb{f}^n</span>="" (2="" ,="" .="" a="" afe_{<n+\\ell}[x]<span class="math">=&quot;&quot; afe_{&lt;n+\\ell}[x]</span>,="" afe_{<n+\\ell}[x]<span class="math">.=&quot;&quot; afe_{&lt;n+\\ell}[x]</span>.="" afe_{<n+\\ell}[x]<span class="math">.=&quot;&quot; afe_{&lt;n+\\ell}[x]</span>.="" afe_{<n+\\ell}[x]<span class="math">.=&quot;&quot; afe_{&lt;n+\\ell}[x]</span>.="" afe_{<n}="\\mathcal{A}_{1}^{\\mathcal{H}}(\\mathsf{ck});\\mathbf{z}\\leftarrow\\mathsf{s}\\mathbb{F}^{r}$" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" afe_{<n}="" a</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We only consider polynomial encoding schemes where the size of the field domain is exponential in the security parameter, i.e.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in O(2^{\\lambda})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Advanced properties. We further state two properties adapted from  <span class="math">\\mathrm{[GKO^{+}23]}</span></p>

    <p class="text-gray-300">Definition 14 ( <span class="math">\\phi</span> -Evaluation Hiding). Let  <span class="math">PCS = (\\mathsf{PCGen}, \\mathsf{Com}, \\mathsf{Eval}, \\mathsf{Check})</span>  be a polynomial commitment scheme in the random oracle model  <span class="math">\\mathcal{H}</span>  and  <span class="math">PES = (\\mathsf{Enc}, \\mathsf{Dec})</span>  be a polynomial encoding scheme. We say  <span class="math">PCS</span>  is  <span class="math">\\phi</span> -evaluation hiding with respect to  <span class="math">\\mathsf{PES}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , for all  <span class="math">\\lambda, n, r \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\ell := \\phi (\\lambda , n, r); d := n + \\mathsf {s t r e t c h} (\\lambda , n, \\ell); \\\\ &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {P C G e n} (1 ^ {\\lambda}, d); \\\\ &amp;amp; \\mathbb {F} ^ {n} \\ni \\mathbf {w} \\leftarrow \\mathcal {A} _ {1} ^ {\\mathcal {H}} (\\mathsf {c k}); \\mathbf {z} \\leftarrow \\mathbb {S} \\mathbb {F} ^ {r} \\\\ &amp;amp; \\rho_ {w} \\leftarrow \\mathbb {S} \\mathbb {F} ^ {\\ell}; b \\leftarrow \\mathbb {S} \\{0, 1 \\}; \\\\ b = b ^ {\\prime}: &amp;amp; f \\leftarrow \\mathsf {E n c} (1 ^ {\\lambda}, b \\cdot \\mathbf {w}, n, \\ell ; \\rho_ {w}); \\\\ &amp;amp; c \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f); \\\\ &amp;amp; \\mathbf {y} := f (\\mathbf {z}); \\\\ &amp;amp; \\boldsymbol {\\pi} \\leftarrow \\mathsf {E v a l} ^ {\\mathcal {H}} (\\mathsf {c k}, c, \\mathbf {z}, \\mathbf {y}, f); \\\\ &amp;amp; b ^ {\\prime} \\leftarrow \\mathcal {A} _ {2} ^ {\\mathcal {H}} (c, \\mathbf {y}, \\boldsymbol {\\pi}) \\end{array} \\right] \\leq \\frac {1}{2} + \\mathsf {n e g l} (\\lambda)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span>  share the internal states,  <span class="math">\\mathbf{y} := f(\\mathbf{z})</span>  denotes setting  <span class="math">y_i := f(z_i)</span>  for all  $i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> , and  </span>\\pi \\gets \\operatorname{Eval}^{\\mathcal{H}}(\\mathsf{ck}, c, \\mathbf{z}, \\mathbf{y}, f)<span class="math">  denotes setting  </span>\\pi_i \\gets \\operatorname{Eval}^{\\mathcal{H}}(\\mathsf{ck}, c, z_i, y_i, f)<span class="math">  for all  </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 15 ( <span class="math">\\phi</span> -Non-Extrapolation). Let  <span class="math">PCS = (\\mathsf{PCGen}, \\mathsf{Com}, \\mathsf{Eval}, \\mathsf{Check})</span>  be a polynomial commitment scheme in the random oracle model  <span class="math">\\mathcal{H}</span>  and  <span class="math">PES = (\\mathsf{Enc}, \\mathsf{Dec})</span>  be a polynomial encoding scheme. We say  <span class="math">PCS</span>  supports  <span class="math">\\phi</span> -non-extrapolation with respect to  <span class="math">\\mathsf{PES}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A}</span> ,</d}[x]$></p>

    <p class="text-gray-300">for all  <span class="math">\\lambda, n, r \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c c} &amp;amp; \\ell := \\phi (\\lambda , n, r); d := n + \\text {s t r e t c h} (\\lambda , n, \\ell); \\\\ &amp;amp; \\quad \\text {c k} \\leftarrow \\text {P C G e n} (1 ^ {\\lambda}, d); \\\\ &amp;amp; \\quad \\mathbf {z} \\leftarrow \\mathbb {S} \\mathbb {F} ^ {r}; \\rho_ {w} \\leftarrow \\mathbb {S} \\mathbb {F} ^ {\\ell}; \\\\ &amp;amp; f \\leftarrow \\operatorname {E n c} (1 ^ {\\lambda}, 0 ^ {n}, n, \\ell ; \\rho_ {w}); \\\\ v = 1 \\wedge z ^ {*} \\notin \\mathbf {z}: &amp;amp; c \\leftarrow \\operatorname {C o m} (\\operatorname {c k}, f); \\\\ &amp;amp; \\quad \\mathbf {y} := f (\\mathbf {z}); \\\\ &amp;amp; \\pi \\leftarrow \\operatorname {E v a l} ^ {\\mathcal {H}} (\\operatorname {c k}, c, \\mathbf {z}, \\mathbf {y}, f); z ^ {*} \\leftarrow \\mathbb {S} \\mathbb {F} \\\\ &amp;amp; (y ^ {*}, \\pi^ {*}) \\leftarrow \\mathcal {A} ^ {\\mathcal {H}} (\\operatorname {c k}, c, \\mathbf {z}, \\mathbf {y}, \\pi , z ^ {*}); \\\\ &amp;amp; v \\leftarrow \\operatorname {C h e c k} ^ {\\mathcal {H}} (\\operatorname {c k}, c, z ^ {*}, y ^ {*}, \\pi^ {*}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">We use the following bundle definition that is going to allow us to simplify the very general statement of theorem Theorem 2; the specific assumption over the efficiency of the encoding algorithm is not crucial but it simplifies our treatment.</p>

    <p class="text-gray-300">Definition 16 ( <span class="math">\\phi</span> -admissibility). We say that a polynomial commitment  <span class="math">PCS</span>  is  <span class="math">\\phi</span> -admissible with respect to a polynomial encoding  <span class="math">PES</span>  if it satisfies both  <span class="math">\\phi</span> -evaluation hiding and  <span class="math">\\phi</span> -non-extrapolation and the encoding algorithm of  <span class="math">PES</span>  runs in linear time, i.e.  <span class="math">O_{\\lambda}(n + \\ell)</span> .</p>

    <p class="text-gray-300">Remark 1. In this work, we focus on PCS with a transparent setup, therefore  <span class="math">\\mathsf{ck}</span>  can be generated with a call to the random oracle.</p>

    <h2 id="sec-21" class="text-2xl font-bold">2.5 Dense Samplable Puzzle system</h2>

    <p class="text-gray-300">We adopt the notion of puzzle system  <span class="math">\\mathsf{PuzSys}</span>  defined in [BKZZ16], and the following definitions are taken almost verbatim from [CV22].</p>

    <p class="text-gray-300">We denote the puzzle space as  <span class="math">\\mathcal{PS}_{\\lambda}</span> , the solution space as  <span class="math">SS_{\\lambda}</span> , and the hardness space as  <span class="math">\\mathcal{HS}_{\\lambda}</span> .</p>

    <p class="text-gray-300">Definition 17. A Dense Samplable Puzzle (DSP) system  <span class="math">\\mathsf{PuzSys} = (\\mathsf{Sample},\\mathsf{Solve},\\mathsf{Verify})</span>  is a triple of algorithms with the following properties, where  <span class="math">\\nu(.)</span>  denotes a negligible function.</p>

    <p class="text-gray-300">Completeness. A puzzle system  <span class="math">\\mathsf{PuzSys}</span>  is complete, if for every  <span class="math">h</span>  in the hardness space  <span class="math">\\mathcal{HS}_{\\lambda}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text {p u z} \\leftarrow \\text {S a m p l e} \\left(1 ^ {\\lambda}, h\\right), \\text {s o l} \\leftarrow \\text {S o l v e} \\left(1 ^ {\\lambda}, h, \\text {p u z}\\right): \\text {V e r i f y} \\left(1 ^ {\\lambda}, h, \\text {p u z}, \\text {s o l}\\right) = 0 \\right] \\leq \\nu (\\lambda).</span></div>

    <p class="text-gray-300">The number of steps that Solve takes to run is monotonically increasing in the hardness factor  <span class="math">h</span>  and may exponentially depend on  <span class="math">\\lambda</span> , while Verify and Sample run in time polynomial in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">g-Hardness. Let  <span class="math">\\mathsf{Steps}_B(\\cdot)</span>  be the number of steps (i.e., machine/operation cycles) executed by algorithm  <span class="math">B</span> . We say that a puzzle system  <span class="math">\\mathsf{PuzSys}</span>  is  <span class="math">g</span> -hard for some function  <span class="math">g</span> , if for every adversary  <span class="math">\\mathcal{A}</span>  there exists a negligible function  <span class="math">\\nu</span>  such that for every auxiliary tape  <span class="math">z \\in \\{0,1\\}^*</span>  and for every  <span class="math">h \\in \\mathcal{HS}_{\\lambda}</span>  the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P r o b} [ \\text {p u z} \\leftarrow \\text {S a m p l e} (1 ^ {\\lambda}, h), \\text {s o l} \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, z, \\text {p u z}): \\text {V e r i f y} (1 ^ {\\lambda}, h, \\text {p u z}, \\text {s o l}) = 1 \\wedge \\\\ \\operatorname {S t e p s} _ {\\mathcal {A}} \\left(1 ^ {\\lambda}, z, h, \\text {p u z}\\right) \\leq g \\left(\\operatorname {S t e p s} _ {\\text {S o l v e}} \\left(1 ^ {\\lambda}, h, \\text {p u z}\\right)\\right) ] \\leq \\nu (\\lambda). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Dense Puzzles. Given  <span class="math">\\lambda, h \\in \\mathbb{Z}^+</span>  and a polynomial function  <span class="math">\\ell</span> , there exists a negligible function  <span class="math">\\nu</span>  such that  <span class="math">\\Delta[\\text{Sample}(1^\\nu, h), \\mathsf{U}_{\\ell(\\lambda, h)})] \\leq \\nu(\\lambda)</span>  where  <span class="math">\\mathsf{U}_{\\ell(\\lambda, h)}</span>  stands for the uniform distribution over  <span class="math">\\{0, 1\\}^{\\ell(\\lambda, h)}</span> .</p>

    <p class="text-gray-300">As observed in [CV22] the properties of density and g-hardness imply that for every adversary  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\nu</span>  such that for every auxiliary tape  <span class="math">z\\in \\{0,1\\}^{\\star}</span>  and for every  <span class="math">h\\in \\mathcal{HS}_{\\lambda}</span>  the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P r o b} [ \\text {s o l} \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, z, \\eta): \\eta \\leftarrow \\{0, 1 \\} ^ {\\ell (\\lambda , h)} \\wedge \\text {V e r i f y} (1 ^ {\\lambda}, h, \\eta , \\text {s o l}) = 1 \\wedge \\\\ \\operatorname {S t e p s} _ {\\mathcal {A}} \\left(1 ^ {\\lambda}, z, h, \\eta\\right) \\leq g \\left(\\operatorname {S t e p s} _ {\\text {S o l v e}} \\left(1 ^ {\\lambda}, h, \\eta\\right)\\right) ] \\leq \\nu (\\lambda). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Following [BKZZ16] we also require the existence of the following algorithm and respective properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{SampleSol}(1^{\\lambda},h)</span> is a probabilistic solved puzzle instance sampling algorithm. On input the security parameter <span class="math">1^{\\lambda}</span> and a hardness factor <span class="math">\\mathcal{HS}_{\\lambda}</span>, it outputs a puzzle instance and solution pair <span class="math">(\\mathsf{puz},\\mathsf{sol})\\in\\mathcal{PS}_{\\lambda}\\times\\mathcal{SS}_{\\lambda}</span>.</li>

    </ul>

    <p class="text-gray-300">Correctness of Sampling: We say that a puzzle system <span class="math">\\mathsf{PuzSys}</span> is correct with respect to sampling, if for every <span class="math">h\\in\\mathcal{HS}_{\\lambda}</span>, we have that:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}(\\mathsf{puz},\\mathsf{sol})\\leftarrow\\mathsf{SampleSol}(1^{\\lambda},h),:\\mathsf{Verify}(1^{\\lambda},h,\\mathsf{puz},\\mathsf{sol})=0\\big{]}=\\nu(\\lambda).</span></p>

    <p class="text-gray-300">Efficiency of Sampling: We say <span class="math">\\mathsf{SampleSol}</span> is efficient with respect to the puzzle <span class="math">g</span>-hardness, if for every <span class="math">\\lambda\\in\\mathbb{Z}^{+}</span>, <span class="math">h\\in\\mathcal{HS}_{\\lambda}</span> and <span class="math">\\mathsf{puz}\\in\\mathcal{PS}_{\\lambda}</span>, we have that:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Steps}_{\\mathsf{SampleSol}}(1^{\\lambda},h)&lt;g(\\mathsf{Steps}_{\\mathsf{Solve}}(1^{\\lambda},h,\\mathsf{puz}))</span></p>

    <p class="text-gray-300">Statistical Indistinguishability: We define the following two probability distributions</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_{s,\\lambda,h}=\\big{\\{}(\\mathsf{puz},\\mathsf{sol})\\leftarrow\\mathsf{SampleSol}(1^{\\lambda},h)\\big{\\}}\\text{ and }</span> <span class="math">\\mathcal{D}_{p,\\lambda,h}=\\big{\\{}\\mathsf{puz}\\leftarrow\\mathsf{Sample}(1^{\\lambda},h),\\mathsf{sol}\\leftarrow\\mathsf{Solve}(1^{\\lambda},h,\\mathsf{puz}):(\\mathsf{puz},\\mathsf{sol})\\big{\\}}</span></p>

    <p class="text-gray-300">We say a <span class="math">\\mathsf{PuzSys}</span> is statistically indistinguishable, if for every <span class="math">\\lambda\\in\\mathbb{Z}^{+}</span> and <span class="math">h\\in\\mathcal{HS}_{\\lambda}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Delta[\\mathcal{D}_{s,\\lambda,h},\\mathcal{D}_{p,\\lambda,h})]=\\nu(\\lambda)</span></p>

    <p class="text-gray-300">In <em>[x1]</em> the authors show how to construct puzzles assuming the hardness of the discrete logarithm (DLOG) problem. In particular, at the end of page 37 (full version) the authors argue that it is possible to obtain a puzzle by randomly sampling an instance of the DLOG problem. The solution to this puzzle is simply the DLOG of the instance.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3 The NIZK Functionality with an Adjoined Oracle</h2>

    <p class="text-gray-300">In this work, we use the <em>Universal Composability</em> (UC) framework <em>[x10]</em> to formulate our security claims. UC follows the simulation-based paradigm where the security of a protocol is defined with respect to an ideal world where a trusted party, the functionality <span class="math">\\mathcal{F}</span>, performs an idealized computation. A protocol <span class="math">\\Pi</span> securely realizes <span class="math">\\mathcal{F}</span> in the real world if for any real world adversary <span class="math">\\mathcal{A}</span>, there exists an ideal world adversary <span class="math">\\mathsf{Sim}</span>, called the simulator, such that the real-world protocol execution, and the ideal-world protocol execution are indistinguishable to any environment:</p>

    <p class="text-gray-300"><span class="math">\\forall\\mathcal{A}\\exists\\mathsf{Sim}\\,\\forall\\mathcal{Z}:\\mathrm{Exec}(\\mathcal{F},\\mathsf{Sim},\\mathcal{Z})\\approx\\mathrm{Exec}(\\Pi,\\mathcal{A},\\mathcal{Z}).</span></p>

    <p class="text-gray-300">Since the ideal functionality <span class="math">\\mathcal{F}</span> is by definition what we want to achieve in terms of security, the real world must thus be secure too. On an intuitive level, this notion is composable: if a higher-level protocol uses <span class="math">\\mathcal{F}</span> to achieve some task, then <span class="math">\\mathcal{F}</span> can be safely replaced by the protocol realizing it, as this must go unnoticed to the higher level protocol as otherwise, we would have found a distinguisher. Finally, we point out that simulating for the dummy adversary is complete; that is, if there exists a simulator for the adversary that just follows the environment’s instructions, then the above statement is implied.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Global Random Oracles</h3>

    <p class="text-gray-300">We are going to use one version of the global random oracle defined in <em>[CDG^{+}18]</em>, that is not programmable but observable. The random oracle functionality <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> can be invoked with two commands: query and observe. <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> answers all new query command via “lazy sampling” from the domain and stores them locally in a list <span class="math">\\mathcal{Q}</span>. A repeated query requires a simple lookup in <span class="math">\\mathcal{Q}</span>. Some query queries are marked “illegitimate” and can be observed via observe command. We now recall the definition of an illegitimate query. Each party is associated with its party identifier <span class="math">\\mathsf{pid}</span> and a session identifier <span class="math">\\mathsf{sid}</span>. When a party queries <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> with the command <span class="math">(\\mathsf{query},x)</span>, the query is parsed as <span class="math">(s,x^{\\prime})</span> where <span class="math">s</span> denotes the session identifier associated with the party. A query is marked as illegitimate if the <span class="math">\\mathsf{sid}</span> field of the query differs from the <span class="math">\\mathsf{sid}</span> associated with the party making the query. In other words, these are the queries made outside the context of the current session execution. We formally define</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 3: Functionality for Global Random Oracle  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  [CDG+18]</p>

    <p class="text-gray-300">the functionality  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  in Fig. 3. Intuitively, observing these illegitimate queries is helpful for proving security of protocols. The ideal adversary (or the simulator) can a priori only observe queries made by the corrupt party during the protocol session (and of course query as it pleases to emulate honest parties in this session). However, the environment has direct access to the random oracle also outside the current session and without observability, the simulator would remain oblivious to these additional queries. Therefore, the formulation in  <span class="math">[\\mathrm{CDG}^{+}18]</span>  discloses such queries to the simulator via OBSERVE command. Note that any  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  query for session sid made by a party (or the simulator) participating in the session identified by sid will never be marked as illegitimate. Thus, any query made by the simulator itself is not recorded by the functionality and hence cannot be observed by anyone. This is crucial for proving UC security (as this gives an edge to the simulator over the real-world adversary: the simulator "knows" all queries, while the real-world adversary does not).</p>

    <p class="text-gray-300">As shown in  <span class="math">\\left[\\mathrm{BCH}^{+}20\\right]</span> , with a specific treatment of random oracles in [BHZ21] as global setup, a global subroutine can be fully captured in standard UC. A global subroutine can be imagined as a module that a protocol uses as a subroutine, but which might be available to more than this protocol only. In a nutshell, if  <span class="math">\\pi</span>  is proven to realize  <span class="math">\\phi</span>  in the presence of a global subroutine  <span class="math">\\gamma</span> , then the environment can access this subroutine in both, the ideal and the real world, which must be taken care of by the protocol. The framework presented in  <span class="math">\\left[\\mathrm{BCH}^{+}20\\right]</span>  defines a new UC-protocol  <span class="math">\\mathsf{M}[\\pi, \\gamma]</span>  that is an execution enclave of  <span class="math">\\pi</span>  and  <span class="math">\\gamma</span> .  <span class="math">\\mathsf{M}[\\pi, \\gamma]</span>  provides the environment access to the main parties of  <span class="math">\\pi</span>  and  <span class="math">\\gamma</span>  in a way that does not change the behavior of the protocol or the set of machines. The clue is that  <span class="math">\\mathsf{M}[\\pi, \\gamma]</span>  itself is a normal UC protocol and the emulation is perfect under certain mild conditions on  <span class="math">\\pi</span>  and  <span class="math">\\gamma</span>  that are met for the comparably simple case of a GRO [BHZ21]. UC-emulation in the presence of a global subroutine can be stated as follows:12</p>

    <p class="text-gray-300">Definition 18 (UC emulation with global subroutines  <span class="math">\\left[\\mathrm{BCH}^{+}20\\right]</span> ). Let  <span class="math">\\pi</span> ,  <span class="math">\\phi</span>  and  <span class="math">\\gamma</span>  be protocols. We say that  <span class="math">\\pi</span>  UC-emulates  <span class="math">\\phi</span>  in the presence of  <span class="math">\\gamma</span>  if protocol  <span class="math">\\mathsf{M}[\\pi, \\gamma]</span>  UC-emulates protocol  <span class="math">\\mathsf{M}[\\phi, \\gamma]</span> .</p>

    <p class="text-gray-300">While the above is a general formulation, in our work we are mainly considering  <span class="math">\\gamma \\coloneqq \\mathsf{IDEAL}(\\mathcal{F}^{\\mathcal{O}})</span>  as well as  <span class="math">\\phi \\coloneqq \\mathsf{IDEAL}(\\mathcal{F})</span> , for which we can use the shorthand notation  <span class="math">\\mathsf{M}[\\pi ,\\mathcal{G}_{\\mathsf{RO}}]</span>  and  <span class="math">\\mathsf{M}[\\mathcal{F},\\mathcal{G}_{\\mathsf{RO}}]</span> , respectively to say that  <span class="math">\\pi</span>  realizes  <span class="math">\\mathcal{F}</span>  in the presence of global setup  <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> .</p>

    <p class="text-gray-300">When realizing NIZKs, we typically rely on setup assumptions, that is, any protocol  <span class="math">\\Pi_{\\mathsf{NIZK}}</span>  realizing  <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span>  needs some setup to give the simulator some edge in simulating. Intuitively, if  <span class="math">\\varPi</span>  worked in the plain model, then the simulator, who needs to extract a witness from valid proofs generated by an attacker, would imply that the protocol cannot be zero-knowledge, as the extraction strategy would be a simple poly-time algorithm that could be equivalently run in the real world. Likewise, the simulator is expected to come up with valid proofs for honest parties without knowing their witnesses. If this</p>

    <p class="text-gray-300">was possible by a plain poly-time algorithm, the NIZK system would not be a knowledge argument. Therefore, constructing a NIZK typically requires some non-trivial setup, such as a common reference string or a random oracle that the simulator could program. In the former case, the simulator can embed a trapdoor in the ideal world (which is not possible in the real world), and in the latter case, the simulator can tune random-oracle outputs to its liking. We can denote this construction of <span class="math">\\Pi_{\\mathsf{NIZK}}</span> as <span class="math">\\mathcal{F}_{\\mathsf{Setup}}\\stackrel{{\\scriptstyle\\Pi_{\\mathsf{NIZK}}}{{\\Longrightarrow}}\\mathcal{F}_{\\mathsf{NIZK}}</span>, where the right-hand side indicates the constructed functionality, while the left-hand side depicts the setup assumption.</p>

    <p class="text-gray-300">When viewing cryptographic protocols as constructions as above, it is apparent that a weaker left-hand side would be more beneficial. For example, a programmable CRS as a setup is a strong assumption and has furthermore undesirable consequences when deploying a protocol in practice: the CRS must be generated in a trustworthy ceremony (as otherwise, some malicious party might apply the simulator’s trick). Likewise, a programmable random oracle is a session-specific random function, however in reality a hash function is not tied to a specific session but is global. Therefore, it would be beneficial in theory and practice, if we could work with transparent setups, especially non-programmable (and global) random oracle as the (heuristic) ideal model of a hash function. However, in this model, realizing <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> is not possible <em>[x23]</em>.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.3 Weakening the Ideal Functionality</h3>

    <p class="text-gray-300">When insisting on a non-programmable and global RO as a setup, the only option is therefore to weaken the right-hand side of the construction, i.e., aiming at a statement of the form <span class="math">\\mathcal{G}_{\\mathsf{RO}}\\stackrel{{\\scriptstyle\\Pi_{\\mathsf{NIZK}}}{{\\Longrightarrow}}\\mathcal{F}_{\\mathsf{NIZK}}^{<em>}</span>, where <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}^{</em>}</span> is a NIZK-like functionality that must admit more capabilities at the adversarial interface than <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span>. But what “weakening” is reasonable and still reflects a reasonable UC-NIZK that can be used in applications? It appears that the standard UC-NIZK functionality (cf. Fig. 15 for reference in the Appendix) cannot, at first sight, be reasonably weakened in a straightforward sense, as its guarantees (soundness and zero-knowledge) seem pretty minimal.</p>

    <p class="text-gray-300">In a foundational paper <em>[BDH^{+}17]</em>, which we survey in Appendix A, Broadnax et al. introduced a concept called <em>shielded oracles</em>. Shielded oracles, intuitively speaking, transform a functionality <span class="math">\\mathcal{F}</span> into a weaker functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> that gives additional power at the adversarial interface. Notably, the oracle is allowed to perform quasi-polynomial time computations and assist the functionality and/or the simulator in simulating. This makes the functionality easier to realize as the simulator has more power: the simulator has (controlled) access to results that stem from a quasi-polynomial time computation. However, in view of composition, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> is now the functionality one has to deal with in further protocol design steps and it is weaker than <span class="math">\\mathcal{F}</span>. In particular, whatever output <span class="math">\\mathcal{O}</span> gives at the adversarial interface must be carefully inspected as it impacts composition with other protocols. That is, the additional power could be “abused” to attack other protocols, since it is, presumably indirectly, the output of a computation that cannot be emulated by a poly-time environment. Protocols must now be secure against a new class of environments beyond quasi-polynomial time, denoted by <span class="math">\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}]</span>, which are all poly-time processes <span class="math">\\mathcal{Z}</span> with black-box access to different sessions of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>.</p>

    <p class="text-gray-300">The objective in this work is to define an adjoined oracle <span class="math">\\mathcal{O}</span> for UC-NIZKs that “weakens” <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> in the above sense in a controlled way that plausibly does not impact its use when composed in other contexts where <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> would be used. Perhaps surprisingly, we achieve this by having the oracle only compute specifically crafted proofs for selected statements that preserve the zero-knowledge property (simulation without knowing the honest user’s witness), leveraging some quasi-polynomial power. The resulting functionality <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}^{\\mathcal{O}}</span> is described in Section 3.4 below.</p>

    <p class="text-gray-300">As for the other property, soundness, we must ensure that for <span class="math">\\mathcal{Z}[\\mathcal{F}_{\\mathsf{NIZK}}^{\\mathcal{O}}]</span> (1) it is non-trivial to generate proofs for any statement, jeopardizing soundness of the protocol itself, and (2) the additional power is essentially useless to attack other protocols, as it is easy to foil the additional power. We do this by restricting the quasi-polynomial time computations to specific instances that are verifiably tied to a session (using proper domain separation). Thus, all additional power <span class="math">\\mathcal{Z}[\\mathcal{F}_{\\mathsf{NIZK}}^{\\mathcal{O}}]</span> has compared to <span class="math">\\mathcal{Z}</span> alone is a proof-generation oracle for statements that are tied to certain sessions and thus easy to shield against.</p>

    <p class="text-gray-300">We note that the above intuition of not harming other sessions can be captured by a formal definition coined <em>polynomial simultability</em> and put forth in <em>[BDH^{+}17]</em>. When satisfied, it formally implies that the presence of the oracle-adjoined functionality, despite its super-poly power, does not harm composition with other (standard) UC protocols. The intuitive reason is that the powerful oracle is sufficiently</p>

    <p class="text-gray-300">shielded to prevent adverse effects on the rest of the system. Our functionality fulfills this notion (cf. Definition 25).</p>

    <p class="text-gray-300">On the choice of the GRO. There exist several variants of the global random oracle <em>[CDG^{+}18]</em> of different strengths and for our final construction statement, <span class="math">\\mathcal{G}_{\\textsf{RO}}\\xrightarrow{\\text{\\emph{ID}_{\\textsf{NIZK}}}}{\\mathcal{F}}^{\\mathcal{O}}_{\\textsf{NIZK}}</span> we would like to pick the weakest possible version such that we can obtain a UC succinct argument system for NP-relations. A folklore argument reveals that with a plain global random oracle (no observability, no programmability) one cannot get succinct UC arguments for general NP-relations, even with an adjoined oracle with runtime say <span class="math">T</span> (unless <span class="math">T</span> is defined to enable brute forcing any witness for any relation, which is however a meaningless notion).</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">In the above setting with a plain GRO, some adjoined oracle <span class="math">\\mathcal{O}^{\\prime}</span> with time bound <span class="math">T</span>, and an oracle-adjoined UC NIZK-functionality <span class="math">\\mathcal{F}^{\\mathcal{O}^{\\prime}}_{\\textsf{NIZK}}</span> (for some relation <span class="math">\\mathcal{R}</span>) which forces the simulator to provide a witness upon the first verification query for some statement <span class="math">x</span> (which is accompanied by a presumably succinct proof string <span class="math">\\pi</span> of length at most <span class="math">k</span>), then the existence of a good UC simulator (required to prove the UC realization statement) implies that deciding whether a statement <span class="math">x</span> is in the language induced by <span class="math">\\mathcal{R}</span> is possible in time no more than <span class="math">T+2^{k}</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In general, any choice of the adjoined oracle’s time bound <span class="math">T</span> yields an upper bound on the extraction runtime: the simulator can make use of the adjoined oracle to do the extraction task and of course query the random oracle like a hash function. Assume we have a UC-secure construction for a general relation and the proofs are of size <span class="math">k</span>. This directly implies that we can decide whether any statement x is in the language or not in time no more than <span class="math">T+2^{k}</span> (by iterating over all proof strings, finding an accepting one, and extracting from there in time at most <span class="math">T</span> by assumption). ∎</p>

    <p class="text-gray-300">Since there are relations that require more time to decide, yet we want succinct proofs, this rules out the existence of the simulator in the above setting aiming at a succinct argument system for any NP-relation. The next “most light-weight” assumption among the RO variants is hence the observable global RO, which is what our paper uses to obtain succinct proofs.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.4 Definition of the Oracle-Adjoined NIZK Functionality</h3>

    <p class="text-gray-300">The description of the functionality is given in Fig. 4 and the adjoined oracle that we define is given in Fig. 5. The functionality presents the same interface as a standard UC NIZK functionality, with the exception that upon input (prove, <span class="math">\\mathsf{sid},x,w</span>) from an honest party, the proof string is generated by the oracle without the knowledge of the witness <span class="math">w</span>. Therefore, the proof string <span class="math">\\pi</span> does not contain information on <span class="math">w</span>. However, the proof string is only generated if <span class="math">w</span> is a valid witness for <span class="math">x</span>. The fact that the adjoined oracle only helps the simulator for valid statements is very crucial. This ensures that the super-poly power is only exercised in circumstances where one could, as a thought experiment, generate the proof string efficiently (namely by using <span class="math">w</span>). This feature is useful when arguing that the functionality remains poly-time simulatable.</p>

    <p class="text-gray-300">Upon verification, we distinguish two versions of the functionality: the strong version, which is what we denote by <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\textsf{NIZK}}</span>, requires that for every new pair <span class="math">(x,\\pi)</span> the simulator is required to know and provide the witness to allow successful verification. In the weak version dubbed <span class="math">\\mathcal{F}^{\\mathcal{O}}_{w\\textsf{NIZK}}</span>, the simulator is not required to provide a witness if the statement has already been proven in this session in a prior invocation. The differences relate to different notions of malleability, where the latter, inspired from <em>[x10]</em>, is capturing that once a statement is proven, other proof strings for the same statement are easy to generate, while the former (and stronger version) requires that the explicit association of pairs <span class="math">(x,\\pi)</span> to witnesses <span class="math">w</span> is known to the simulator.</p>

    <p class="text-gray-300">Adjoined oracles and global ROs. We note that the presence of global subroutines, in particular our case of an GRO, is compatible with the shielded oracle framework, since it builds on standard UC concepts and global subroutines can be represented in standard UC too as described above. We observe that <span class="math">\\mathcal{F}</span> can always have subroutines in standard UC and applying the transformation <span class="math">\\mathsf{M}[\\mathcal{F},\\mathcal{G}_{\\textsf{RO}}]</span> does merely expose that particular subroutine to the environment <span class="math">\\mathcal{Z}</span>, but leaving the input-output behavior identical as well as imposing only a minor runtime overhead. That is, UC-emulation with shielded oracles and global subroutines is obtained by considering the UC protocol <span class="math">\\mathsf{M}[\\mathcal{F}^{\\mathcal{O}},\\mathcal{G}_{\\textsf{RO}}]</span> instead of the UC protocol <span class="math">\\mathsf{IDEAL}(\\mathcal{F}^{\\mathcal{O}})</span> in the definitions above, which leaves in particular the composition theorem <em>[BDH^{+}17, Thm. 9]</em> intact as it only relies on the properties of standard UC protocol execution. One minor detail to clarify here is also that the standard definition of an adjoined oracle does not</p>

    <p class="text-gray-300">consider (explicitly) subroutines of the adjoined oracle, while we call the GRO as a subroutine. This change is however immaterial: it is easy to see that one could formally instruct the functionality  <span class="math">\\mathcal{F}</span>  to do RO queries instead and pass the return value back and hence drop the explicitly call from  <span class="math">\\mathcal{O}</span>  to GRO. This also is not impacting the runtime considerations  <span class="math">[\\mathrm{BDH}^{+}17]</span>  since the random oracle itself has a very simple query-response structure as is idealizing a hash-function evaluation.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{= \\mathrm{NIZK}}^{\\mathcal{O}}</span>  is parametrized by polynomial-time-decidable relation  <span class="math">\\mathcal{R} \\in \\{0,1\\}^{<em>} \\times \\{0,1\\}^{</em>}</span>  and runs with parties  <span class="math">\\mathsf{P}_1, \\ldots, \\mathsf{P}_N</span>  and an ideal process adversary Sim. It stores an initially empty proof table  <span class="math">\\mathcal{Q}</span> , and a list of statements queried  <span class="math">\\mathcal{Q}_x</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof Upon receiving input (PROVE, sid,  <span class="math">x, w</span> ) from an honest party  <span class="math">\\mathsf{P}_i</span> , do the following: if  <span class="math">(x, w) \\notin \\mathcal{R}</span>  return the activation to the environment. Otherwise, proceed as follows:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid,  <span class="math">x</span> , puzzle)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to obtain instance puz. Send (PROVE, sid,  <span class="math">x</span> , puz) to  <span class="math">\\mathcal{O}</span> .</li>

      <li>Upon receiving the reply  <span class="math">\\pi</span>  from  <span class="math">\\mathcal{O}</span> , store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  and give back the activation to  <span class="math">\\mathcal{O}</span> .</li>

      <li>Upon receiving (OUT, sid,  <span class="math">x</span> ,  <span class="math">\\pi</span> ) from  <span class="math">\\mathcal{O}</span> , output (PROOF, sid,  <span class="math">x</span> ,  <span class="math">\\pi</span> ) to  <span class="math">\\mathsf{P}_i</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification Upon receiving input (VERIFY, sid,  <span class="math">x, \\pi</span> ) from a party  <span class="math">\\mathsf{P}_i</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">(x, \\pi) \\in \\mathcal{Q}</span>  return (VERIFICATION, sid, 1) to the party  <span class="math">\\mathsf{P}_i</span></li>

      <li>else, if  <span class="math">\\mathcal{Q}_x</span>  contains  <span class="math">x</span> , send (VERIFY-REPLAY, sid,  <span class="math">x, \\pi</span> ) to Sim. Upon receiving (VERIFICATION, sid,  <span class="math">x, \\pi, b</span> ) from Sim, store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  if  <span class="math">b = 1</span></li>

      <li>else, send (VERIFY, sid,  <span class="math">x</span> ,  <span class="math">\\pi</span> ) to Sim. Upon receiving (WITNESS,  <span class="math">x</span> ,  <span class="math">w</span> ) from Sim store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  if  <span class="math">(x, w) \\in \\mathcal{R}</span></li>

    </ul>

    <p class="text-gray-300">Finally, return (VERIFICATION, sid,  <span class="math">(x,\\pi)\\in ?\\mathcal{Q})</span>  to the party  <span class="math">\\mathsf{P}_i</span></p>

    <p class="text-gray-300">Fig. 4: Functionality for non-interactive zero-knowledge  <span class="math">\\mathcal{F}_{= \\mathrm{NIZK}}^{\\mathcal{O}}</span>  with an adjoined oracle. The functionality without the highlighted parts (i.e., dropping the set  <span class="math">\\mathcal{Q}_x</span>  as well as the second bullet point under Verification) is the stronger version  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}^{\\mathcal{O}}</span> , the one that includes those highlighted parts is the weaker version  <span class="math">\\mathcal{F}_{= \\mathrm{NIZK}}^{\\mathcal{O}}</span> .</p>

    <p class="text-gray-300">We give a UC protocol denoted  <span class="math">\\Pi_{\\mathrm{TS - R}}</span>  that realizes the functionality  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}^{\\mathcal{O}}</span> . Our protocol is built on top of two main building blocks: non-interactive arguments (cf. Section 2.3) and a puzzle system (cf. Section 2.5). As we will see, depending on the strength of the underlying argument system satisfies, the protocol either UC-realizes  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}^{\\mathcal{O}}</span>  or  <span class="math">\\mathcal{F}_{= \\mathrm{NIZK}}^{\\mathcal{O}}</span> .</p>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{TS - R}}</span> , for an NP-relation  <span class="math">\\mathcal{R}</span> , makes use of the following tools:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A NIZK  <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span>  for the NP-relation  <span class="math">\\mathcal{R}&#x27; = \\{((x,\\mathsf{puz},h),w):(x,w)\\in \\mathcal{R}\\lor \\mathsf{Verify}(1^{\\lambda},h,</span> <span class="math">\\mathsf{puz},w) = 1\\}</span> , where as discussed above, the parameters are generated via a call to the random oracle.</li>

      <li>A dense samplable puzzle system  <span class="math">\\mathsf{PuzSys} = (\\mathsf{Sample},\\mathsf{Solve},\\mathsf{Verify},\\mathsf{SampleSol})</span>  such that for every hardness factor  <span class="math">h\\in \\mathcal{HS}_{\\lambda}</span>  there exists a negligible function  <span class="math">\\nu</span>  such that the following holds:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Pr}\\left[\\mathsf{puz} \\leftarrow \\mathsf{s}\\left(1^{\\lambda}, h\\right): g\\left(\\mathsf{Steps}_{\\mathsf{Solve}}\\left(1^{\\lambda}, h, \\mathsf{puz}\\right)\\right) \\leq \\lambda^{\\log \\lambda}\\right] \\leq \\nu(\\lambda)</span> ;</li>

      <li>the worst-case running time of  <span class="math">\\mathsf{Solve}(1^{\\lambda},h,\\cdot)</span>  is  <span class="math">\\lambda^{\\mathrm{poly}(\\log \\lambda)}</span></li>

    </ol>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 5: The adjoined oracle  <span class="math">\\mathcal{O}</span> .</p>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{TS - R}}</span>  is described below and is parameterized by the security parameter  <span class="math">\\lambda</span> . We assume domain separating suffixes that we denote genparams, proof, puzzle in the invocations to the  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> , so separate the generation of parameters, proofs of the underlying argument system  <span class="math">\\Pi</span>  and puzzle instances.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof: Upon receiving (PROVE, sid,  <span class="math">x, w</span> ), where  <span class="math">(x, w) \\in \\mathcal{R}</span> ,  <span class="math">\\mathsf{P}_i</span>  does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparams)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back pp.</li>

      <li>Send (QUERY, (sid,  <span class="math">x</span> , puzzle)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back  <span class="math">v</span> , set  <span class="math">\\mathsf{p}uz = v</span> .</li>

      <li>Define  <span class="math">x&#x27; = (x, \\mathsf{p}uz)</span>  and run the prover  <span class="math">\\mathcal{P}</span>  of  <span class="math">\\Pi</span>  on input  <span class="math">\\mathsf{pp}, x&#x27;</span> , and  <span class="math">w</span>  to obtain a proof  <span class="math">\\pi</span> . Whenever  <span class="math">\\mathcal{P}</span>  makes a call to  <span class="math">\\mathcal{H}</span>  with input in, send (QUERY, (sid, in, proof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to receive a response out which is forwarded to  <span class="math">\\mathcal{P}</span> .</li>

      <li>Output (PROOF, sid,  <span class="math">\\pi</span> ).</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification: Upon receiving input (VERIFY, sid,  <span class="math">x, \\pi</span> )  <span class="math">\\mathsf{P}_i</span>  does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparams)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back pp.</li>

      <li>Send (QUERY, (sid,  <span class="math">x</span> , puzzle)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back  <span class="math">v</span> , and set  <span class="math">x&#x27; = (x, v)</span></li>

      <li>Output (VERIFICATION, sid,1) if the following condition is satisfied, else output (VERIFICATION, sid,0):</li>

    </ol>

    <p class="text-gray-300">(a) The verifier  <span class="math">\\mathcal{V}</span>  of  <span class="math">\\varPi</span>  on input  <span class="math">\\mathsf{pp},x^{\\prime},\\pi</span>  outputs 1. Whenever  <span class="math">\\mathcal{V}</span>  makes a call to  <span class="math">\\mathcal{H}</span>  with input in, send (QUERY, (sid, in, proof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to receive a response out which is forwarded to  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">Hereafter, we state the conditions under which  <span class="math">\\Pi_{\\mathrm{TS - R}}</span>  realizes the  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}^{\\mathcal{O}}</span>  and the  <span class="math">\\mathcal{F}_{w\\mathrm{NIZK}}^{\\mathcal{O}}</span>  functionalities described in Fig. 4, and we highlight the parts needed only for the weaker functionality.</p>

    <p class="text-gray-300">Theorem 1. Let  <span class="math">\\Pi</span>  be a succinct straight-line weak true-simulation-extractable NIZK, as captured in Definition 9, for the relation  <span class="math">\\mathcal{R}&#x27;</span> . Let PuzSys be a dense samplable puzzle system as defined in Definition 17. Let  <span class="math">\\Pi_{\\mathrm{TS - R}}</span>  be the protocol defined in Section 4.1 and let  <span class="math">\\mathcal{O}</span>  be the oracle defined in Fig. 5. Then  <span class="math">\\Pi_{\\mathrm{TS - R}} \\geq_{\\mathcal{F}_{w\\mathrm{NIZK}}^{\\mathcal{O}}} \\mathcal{F}_{w\\mathrm{NIZK}}^{\\mathcal{O}}</span>  in the  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> -hybrid model.</p>

    <p class="text-gray-300">Proof intuition. The main idea of the proof is to consider a sequence of hybrid experiments for a PPT environment  <span class="math">\\mathcal{Z}</span>  that may externally invoke polynomially many  <span class="math">\\mathcal{F}_{w\\mathrm{NIZK}}^{\\mathcal{O}}</span> -sessions and iteratively replace those ideal sessions by the real protocol  <span class="math">\\Pi_{\\mathrm{TS - R}}</span> : in particular, the ideal-world honest proof will be computed by  <span class="math">\\mathcal{O}</span>  (see Fig. 5) using (puz, sol) as witness for  <span class="math">\\Pi</span> , while in the real-world experiment, the witness  <span class="math">w</span>  for the relation  <span class="math">\\mathcal{R}</span>  will be used. This is done by leveraging the fact that the superpolynomial computation of  <span class="math">\\mathcal{O}</span>  is shielded and thus the replacement is unnoticeable by  <span class="math">\\mathcal{Z}</span> , as otherwise we would obtain a PPT adversary against the witness-indistinguishability (which is implied by the zero-knowledge) of  <span class="math">\\Pi</span> .</p>

    <p class="text-gray-300">We stress that, in this proof, we consider only polynomial time adversaries and we do not rely on any assumption that is sub-exponentially secure. In the intermediate hybrids, we internally emulate the random oracle; therefore, in the intermediate hybrids where we switch witness and we need a pair (puz, sol) as a witness for  <span class="math">\\Pi</span> , it is possible to sample them using SampleSol and program the random</p>

    <p class="text-gray-300">oracle accordingly, avoiding in this way to compute in the hybrids and (consequently in the security reductions) a solution for <span class="math">\\mathsf{puz}</span> in quasi-polynomial time.</p>

    <p class="text-gray-300">Proof of Theorem 1 In what follows, we highlight the parts of the proof that are needed for the weaker NIZK functionality.</p>

    <p class="text-gray-300">By Proposition 1 it suffices to find a simulator for the dummy adversary (cf. Definition 24). We start by describing the simulator <span class="math">\\mathsf{Sim}</span> for <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving <span class="math">(\\mathrm{proof},\\mathsf{sid},x,\\pi)</span> from <span class="math">\\mathcal{O}</span>, send back <span class="math">(\\mathrm{ack},\\mathsf{sid},x,\\pi)</span> to <span class="math">\\mathcal{O}</span></li>

      <li>Upon receiving <span class="math">(\\mathrm{verify},\\mathsf{sid},x,\\pi)</span> from <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>, <span class="math">\\mathsf{Sim}</span> acts as a honest verifier in the execution of <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span> with the adversary. If the proof <span class="math">\\pi</span> is accepting then <span class="math">\\mathsf{Sim}</span> executes the knowledge-soundness extractor <span class="math">\\mathcal{E}_{ks}</span> of <span class="math">\\Pi</span> in order to obtain <span class="math">w^{\\prime}</span>. Whenever <span class="math">\\mathcal{E}_{ks}</span> makes a call to <span class="math">\\mathcal{O}_{\\mathsf{ext}}</span>, <span class="math">\\mathsf{Sim}</span> queries (observe, <span class="math">\\mathsf{sid}</span>) to <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> and forwards the response to <span class="math">\\mathcal{E}_{ks}</span>. If <span class="math">(x,w^{\\prime})\\notin\\mathcal{R}</span> then <span class="math">\\mathsf{Sim}</span> sets <span class="math">w=\\bot</span>, otherwise, she sets <span class="math">w=w^{\\prime}</span> and sends <span class="math">(\\mathrm{witness},w)</span> to <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>.</li>

      <li>Upon receiving <span class="math">(\\mathrm{verify}\\text{-replay},\\mathsf{sid},x,\\pi)</span> from <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>, <span class="math">\\mathsf{Sim}</span> acts as a honest verifier in the execution of <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span> and sends <span class="math">(\\mathrm{verification},\\mathsf{sid},x,\\pi,b)</span> to <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>, where <span class="math">b</span> is the output of the verifier <span class="math">\\vee</span> of <span class="math">\\Pi</span> on <span class="math">(x,\\pi)</span>.</li>

    </ul>

    <p class="text-gray-300">We show a sequence of hybrid experiments for a PPT environment <span class="math">\\mathcal{Z}</span> that can invoke externally many sessions of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span> and replace internally these executions with the real protocol <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span>. Without loss of generality, we consider the case in which there is one prover and one verifier in each session.</p>

    <p class="text-gray-300">Step 1: Let <span class="math">\\mathrm{Exec}(\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}},\\mathsf{Sim},\\mathcal{Z})</span> be the random variable that denotes the output of the experiment where the PPT environment <span class="math">\\mathcal{Z}</span> invokes many sessions of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span> and interacts with the simulator <span class="math">\\mathsf{Sim}</span>. Let <span class="math">\\mathrm{Exec}(\\Pi_{\\mathrm{TS}-\\mathcal{R}},\\mathcal{A},\\mathcal{Z})</span> be the random variable that denotes the output of the experiment where the executions of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span> are replaced with invocations of <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span> in which the dummy adversary <span class="math">\\mathcal{A}</span> is playing. We will proceed to show that:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Exec}(\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}},\\mathsf{Sim},\\mathcal{Z})\\approx\\mathrm{Exec}(\\Pi_{\\mathrm{TS}-\\mathcal{R}},\\mathcal{A},\\mathcal{Z})</span></p>

    <p class="text-gray-300">If both parties are corrupted then the <span class="math">\\mathcal{O}</span>-adjoinded functionalities can be treated as part of the environment. Therefore, we only consider the case where <span class="math">\\mathcal{Z}</span> participates in sessions with a corrupted prover (prover sessions) or with a corrupted verifier (verifier session).</p>

    <p class="text-gray-300">Let us denote with <em>bad</em> the event that in any prover session, the simulator <span class="math">\\mathsf{Sim}</span> given a proof <span class="math">\\pi</span> w.r.t. statement <span class="math">x</span> fails to extract <span class="math">w</span> s.t. <span class="math">(x,w)\\in\\mathcal{R}</span>.</p>

    <p class="text-gray-300">We distinguish two cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The event <em>bad</em> occurs with non-negligible probability.</li>

      <li>The event <em>bad</em> occurs with negligible probability;</li>

    </ol>

    <p class="text-gray-300"><em>Case 1:</em> Let the <span class="math">j^{<em>}</span>-th prover session be the first prover session of the real-world execution (i.e. where protocol <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span> is executed) where </em>bad<em> happens with non-negligible probability. Since the environment <span class="math">\\mathcal{Z}</span> opens a polynomial number <span class="math">q^{\\prime}</span> of prover sessions, the index <span class="math">j^{</em>}</span> can be guessed with non-negligible probability. Therefore it is sufficient to focus on an environment <span class="math">\\mathcal{Z}^{\\prime}</span> which internally runs <span class="math">\\mathcal{Z}</span> and opens all verifier sessions that <span class="math">\\mathcal{Z}</span> wants to participate in, while opening only one prover session (the <span class="math">j^{<em>}</span>-th prover session) and emulates internally the other prover sessions that <span class="math">\\mathcal{Z}^{\\prime}</span> wants to open. Let us assume that <span class="math">\\mathcal{Z}</span> opens <span class="math">q</span> verifier sessions (this number can be guessed with non-negligible probability since <span class="math">\\mathcal{Z}</span> is polynomially bounded). Since <span class="math">j^{</em>}</span> can be guessed with non-negligible probability, then <span class="math">\\mathcal{Z}^{\\prime}</span> participates in a prover session where <em>bad</em> occurs with non-negligible probability. More specifically, in the prover session <span class="math">\\mathsf{Sim}</span> receives an accepting proof <span class="math">\\bar{\\pi}</span> w.r.t. theorem <span class="math">\\bar{x}^{\\prime}=(\\bar{x},\\overline{\\mathsf{puz}})</span> from <span class="math">\\mathcal{A}</span> and in the ideal world it fails with non-negligible probability to extract a witness <span class="math">w</span> s.t <span class="math">(\\overline{x},w)\\in\\mathcal{R}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We are going to argue now that the probability that the event <em>bad</em> happens is non-negligible even when the calls to the ideal functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span> are replaced with execution of <span class="math">\\Pi_{\\mathrm{TS}-\\mathcal{R}}</span>. To do so, let us consider the following hybrid experiments, where the simulator defined in the hybrid H acts with <span class="math">\\mathcal{Z}^{\\prime}</span> in the <span class="math">j</span>-th verifier session, for <span class="math">j\\in[1,q]</span>, using as a session identifier the value $\\mathsf{sid}_{\\mathrm{H}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j<span class="math">, and in the unique prover session using as session identifier the value </span>\\mathsf{sid}_{\\mathrm{H}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0<span class="math">. Moreover, let </span>p_{\\mathit{bad}}(\\mathrm{H})$ be the probability that the event <em>bad</em> happens in the hybrid H.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}^{1}</span> be equivalent to the ideal experiment but <span class="math">\\mathrm{H}^{1}</span> additionally emulates the calls to <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> in the eyes of <span class="math">\\mathcal{Z}^{\\prime}</span>. In particular, on input a query <span class="math">(\\mathsf{query},(\\mathsf{sid},\\mathsf{in}))</span>, the hybrid <span class="math">\\mathrm{H}^{1}</span> answers in the following way:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check if there is a pair <span class="math">(\\mathsf{in},\\mathsf{out})</span> for some <span class="math">\\mathsf{out}\\in\\{0,1\\}^{\\ell(\\lambda)}</span> in the (initially empty) list <span class="math">\\mathcal{Q}</span> of past queries. Else choose uniformly <span class="math">\\mathsf{out}\\in\\{0,1\\}^{\\ell(\\lambda)}</span> and store the pair <span class="math">(\\mathsf{in},\\mathsf{out})</span> in <span class="math">\\mathcal{Q}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Parse in as <span class="math">(s,\\mathsf{in}^{\\prime},\\mathsf{prefix})</span>. If <span class="math">\\mathsf{sid}\\neq s</span> then add <span class="math">(s,\\mathsf{in}^{\\prime},\\mathsf{out})</span> to the (initially empty) list of illegitimate queries for SID <span class="math">s</span>, that is denoted by $\\mathcal{Q}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return out</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, if a request (observe, sid) is received, the hybrid (emulating <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span>) sends the list $\\mathcal{Q}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sid}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This hybrid is indistinguishable from the ideal execution since <span class="math">\\mathrm{H}^{1}</span> perfectly emulates <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> in the eyes of <span class="math">\\mathcal{Z}^{\\prime}</span>. Thus we have that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}^{1})=p_{bad}(\\mathrm{Exec}(\\mathcal{F}^{\\mathcal{O}}_{= \\mathsf{NIZK}},\\mathsf{Sim},\\mathcal{Z}))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}^{1}_{0}</span> be equivalent to <span class="math">\\mathrm{H}^{1}</span>. For all <span class="math">i\\in[1,q]</span>, let <span class="math">\\mathrm{H}^{1}_{i}</span> be equivalent to <span class="math">\\mathrm{H}^{1}_{i-1}</span> but the following modification is made:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{H}^{1}_{i}</span> additionally runs <span class="math">(\\mathsf{puz}_{i},\\mathsf{sol}_{i})\\leftarrow\\mathsf{SampleSol}(1^{\\lambda},h)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- when emulating the calls to <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span>, on input a new query <span class="math">(\\mathsf{query},(\\mathsf{sid},\\mathsf{in}))</span>, the hybrid <span class="math">\\mathrm{H}^{1}_{i}</span> additionally does the following: If there is not a pair <span class="math">(\\mathsf{in},\\mathsf{out})</span> for some <span class="math">\\mathsf{out}\\in\\{0,1\\}^{t(\\lambda)}</span> in the (initially empty) list <span class="math">\\mathcal{Q}</span> of past queries, parse <span class="math">\\mathsf{in}</span> as <span class="math">(s,\\mathsf{in}^{\\prime},\\mathsf{prefix})</span> and if <span class="math">\\mathsf{prefix}=\\mathsf{puzzle}</span> and $\\mathsf{sid}=\\mathsf{sid}_{\\mathrm{H}^{1}_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i<span class="math"> then send </span>\\mathsf{puz}_{i}<span class="math">, otherwise choose uniformly </span>\\mathsf{out}\\in\\{0,1\\}^{t(\\lambda)}<span class="math"> and store the pair </span>(\\mathsf{in},\\mathsf{out})<span class="math"> in </span>\\mathcal{Q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we observe that two consecutive hybrids <span class="math">\\mathrm{H}^{1}_{i}</span> and <span class="math">\\mathrm{H}^{1}_{i-1}</span> behave the same way except on how they program <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> to output the puzzle for the <span class="math">i</span>-th verifier session. The probability of distinguishing two consecutive hybrids is then negligible due to the statistical indistinguishability of PuzSys. Moreover, we notice that for the prover session, the adversary has a session identifier that is different from $\\mathsf{sid}_{\\mathrm{H}^{1}_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j<span class="math">, for all </span>i,j\\in[q]<span class="math">, therefore in the prover session the puzzle </span>\\overline{\\mathsf{puz}}$ is generated honestly by sampling a string uniformly at random (for which the hybrid does not know the solution). Therefore we have that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}^{1}_{q})\\geq p_{bad}(\\mathrm{H}^{1})-q\\cdot\\nu_{\\mathsf{PuzSys}}</span></p>

    <p class="text-gray-300">where <span class="math">\\nu_{\\mathsf{PuzSys}}\\in\\mathsf{negl}</span> is the statistical distance between the uniform distribution and the puzzle distribution output by SampleSol.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}^{2}_{0}</span> be equivalent to <span class="math">\\mathrm{H}^{1}_{q}</span>. For all <span class="math">i\\in[1,q]</span>, let <span class="math">\\mathrm{H}^{2}_{i}</span> be equivalent to <span class="math">\\mathrm{H}^{2}_{i-1}</span> except on how it computes the solution to the puzzle for the <span class="math">i</span>-th verifier session: in particular, the hybrid <span class="math">\\mathrm{H}^{2}_{i}</span> computes the proof <span class="math">\\pi_{i}</span> running the (honest) prover of <span class="math">\\varPi</span> w.r.t. statement <span class="math">x^{\\prime}_{i}=(x_{i},\\mathsf{puz}_{i})</span> and the witness <span class="math">\\mathsf{sol}_{i}</span>, where the pair <span class="math">(\\mathsf{sol}_{i},\\mathsf{puz}_{i})</span> is generated as output of SampleSol, instead of executing Solve (as done by <span class="math">\\mathcal{O}</span> in <span class="math">\\mathcal{F}^{\\mathcal{O}}_{= \\mathsf{NIZK}}</span>).</li>

    </ul>

    <p class="text-gray-300">The view of <span class="math">\\mathcal{Z}^{\\prime}</span> in two consecutive hybrids is identically distributed since <span class="math">\\mathcal{Z}^{\\prime}</span> has only black-box access (i.e. only to the input/output behaviors) to the functionality. Therefore we have that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}^{2}_{q})=p_{bad}(\\mathrm{H}^{1}_{q})</span></p>

    <p class="text-gray-300">Due to the knowledge-soundness of <span class="math">\\varPi</span> and the fact that <span class="math">p_{bad}</span> is non-negligible, we can conclude that from the prover session the hybrid <span class="math">\\mathrm{H}^{2}_{q}</span> extracts with non-negligible probability a solution <span class="math">\\overline{\\mathsf{sol}}</span> for <span class="math">\\overline{\\mathsf{puz}}</span>, where <span class="math">\\overline{\\mathsf{puz}}</span> is generated honestly in the experiment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}^{3}_{0}</span> be equivalent to <span class="math">\\mathrm{H}^{2}_{q}</span>. For all <span class="math">i\\in[q]</span> let <span class="math">\\mathrm{H}^{3}_{i}</span> be equivalent to <span class="math">\\mathrm{H}^{3}_{i-1}</span> except on how the proof <span class="math">\\pi_{i}</span> is generated: specifically, when the hybrid <span class="math">\\mathrm{H}^{3}_{i}</span> computes the proof <span class="math">\\pi_{i}</span> running the zero-knowledge simulator <span class="math">\\mathcal{S}_{\\varPi}=(\\mathcal{S}_{1},\\mathcal{S}_{2})</span> of <span class="math">\\varPi</span> w.r.t. statement <span class="math">x^{\\prime}_{i}=(x_{i},\\mathsf{puz}_{i})</span>; whenever <span class="math">\\mathcal{S}_{1}</span> wants to handle a query to <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> with a specific <span class="math">(\\mathsf{in},\\mathsf{out})</span> the hybrid sees it and casts this pair <span class="math">(\\mathsf{in},\\mathsf{out})</span> in his emulation of the <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span>.</li>

    </ul>

    <p class="text-gray-300">The probability of distinguishing two consecutive hybrids is negligible due to the zero-knowledge property of <span class="math">\\varPi</span>. Moreover, we can argue that <span class="math">\\forall i\\in[q]</span>:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}^{3}_{i})\\geq p_{bad}(\\mathrm{H}^{3}_{i-1})-\\mathsf{negl}</span></p>

    <p class="text-gray-300">Let us assume by contradiction that this is not the case for some <span class="math">i^{*}\\in[q]</span>. We show a reduction <span class="math">\\mathcal{B}</span> that breaks the zero-knowledge of <span class="math">\\varPi</span>, as follows.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{CH}</span> be the challenger of the zero-knowledge game of <span class="math">\\varPi</span>, i.e., <span class="math">\\mathcal{CH}</span> samples a bit <span class="math">b\\in\\{0,1\\}</span> and offers a proving oracle that on input a pair <span class="math">(x,w)\\in\\mathcal{R}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=0</span>, run <span class="math">\\pi\\leftarrow\\mathcal{P}(\\mathsf{pp},x,w)</span></li>

      <li>If <span class="math">b=1</span>, run <span class="math">\\pi\\leftarrow\\mathcal{S}_{2}(x,w)</span></li>

    </ul>

    <p class="text-gray-300">and output the proof <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{B}</span> internally runs <span class="math">\\mathcal{Z}^{\\prime}</span> and when <span class="math">\\mathcal{Z}^{\\prime}</span> opens the <span class="math">i</span>-th verifier session w.r.t. theorem <span class="math">x_{i}</span> the reduction runs <span class="math">(\\mathsf{puz}_{i},\\mathsf{sol}_{i})\\leftarrow\\mathsf{SampleSol}(1^{\\lambda},h)</span> emulating <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span>, as explained above, programming the output of the <span class="math">\\mathsf{puzzle}</span> queries. Moreover, on input a <span class="math">\\mathsf{proof}</span> query to <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> of the form (query, (<span class="math">\\mathsf{sid}</span>, <span class="math">\\mathsf{in}</span>, <span class="math">\\mathsf{proof}</span>)), where <span class="math">\\mathsf{sid}</span> is associated with the <span class="math">i</span>-th verifier session:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=i^{*}</span>, forward the query to <span class="math">\\mathcal{S}_{1}</span> and output whatever it gives as result</li>

      <li>Else, internally emulate the call to <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> as done in <span class="math">\\mathrm{H}_{q}^{2}</span></li>

    </ul>

    <p class="text-gray-300">In the <span class="math">i</span>-th verifier session, on input (prove, <span class="math">\\mathsf{sid},x,w</span>) the reduction sets <span class="math">x^{\\prime}=(x,\\mathsf{puz}_{i})</span>, and obtains the proof <span class="math">\\pi_{i}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i&lt;i^{*}</span> then run the honest prover algorithm <span class="math">\\pi_{i}\\leftarrow\\mathcal{P}(\\mathsf{pp},x^{\\prime},\\mathsf{sol}_{i})</span> using <span class="math">\\mathsf{sol}_{i}</span> as witness, as done in <span class="math">\\mathrm{H}_{q}^{2}</span></li>

      <li>If <span class="math">i&gt;i^{*}</span> then run the simulator of <span class="math">\\Pi</span>, i.e. <span class="math">\\pi_{i}\\leftarrow\\mathcal{S}_{2}(x^{\\prime},\\mathsf{sol}_{i})</span></li>

      <li>If <span class="math">i=i^{*}</span> send to <span class="math">\\mathcal{CH}</span> the pair <span class="math">(x^{\\prime},\\mathsf{sol}_{i})</span> and receive the proof <span class="math">\\pi_{i}</span></li>

    </ul>

    <p class="text-gray-300">Upon receiving <span class="math">\\bar{\\pi}</span> w.r.t. instance <span class="math">\\bar{x}^{\\prime}=(\\bar{x},\\overline{\\mathsf{puz}})</span> from the prover session the reduction runs the straight-line weak true-simulation extractor <span class="math">\\mathcal{E}_{tse}</span> of <span class="math">\\Pi</span> to obtain the witness <span class="math">\\bar{w}</span>. The extractor <span class="math">\\mathcal{E}_{tse}</span> needs oracle access to the list of RO queries, which the reduction can provide.</p>

    <p class="text-gray-300">If the reduction fails to extract a valid witness, then aborts. If the reduction obtains as a witness the solution of the puzzle <span class="math">\\overline{\\mathsf{puz}}</span> then the reduction outputs <span class="math">1</span> and <span class="math">0</span> otherwise.</p>

    <p class="text-gray-300">The idea is that the reduction <span class="math">\\mathcal{B}</span> embeds in her emulation of <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> towards <span class="math">\\mathcal{Z}^{\\prime}</span> the list of queries made by <span class="math">\\mathcal{CH}</span> to the random oracle to compute the possibly simulated proof <span class="math">\\pi_{i^{<em>}}</span>. We observe that if <span class="math">b=0</span> then <span class="math">\\pi_{i^{</em>}}</span> is computed using the simulator of <span class="math">\\Pi</span> and the experiment is distributed as <span class="math">\\mathrm{H}_{i^{<em>}}^{3}</span>, and as <span class="math">\\mathrm{H}_{i^{</em>}-1}^{3}</span> otherwise. Since <span class="math">\\Pi</span> is weak true-simulation-extractable, the probability to abort is at most negligible if the statement <span class="math">x^{\\prime}</span> is fresh, namely the reduction has never issued a simulation query for <span class="math">x^{\\prime}</span> to the simulator of <span class="math">\\Pi</span>. Moreover, the probability that <span class="math">x^{\\prime}</span> is not fresh is at most negligible: this is because <span class="math">\\overline{\\mathsf{puz}}</span> is the output of a random oracle query on input the session id of the prover, and thus a collision between two puzzles across different sessions, with distinct session ids, is only negligible.</p>

    <p class="text-gray-300">If the difference between <span class="math">p_{bad}(\\mathrm{H}_{i^{<em>}}^{3})</span> and <span class="math">p_{bad}(\\mathrm{H}_{i^{</em>}-1}^{3})</span> is non-negligible, then <span class="math">\\mathcal{B}</span> retains a non-negligible advantage in the zero-knowledge security game.</p>

    <p class="text-gray-300">By union bound we derive that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}_{q}^{3})\\geq p_{bad}(\\mathrm{H}_{q}^{2})-q\\cdot\\mathsf{negl}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}_{0}^{4}</span> be equivalent to <span class="math">\\mathrm{H}_{q}^{3}</span>. For all <span class="math">i\\in[1,q]</span>, let <span class="math">\\mathrm{H}_{i}^{4}</span> be equivalent to <span class="math">\\mathrm{H}_{i-1}^{4}</span> except on how the the <span class="math">i</span>-th puzzle <span class="math">\\mathsf{puz}_{i}</span> is computed: in particular, the hybrid <span class="math">\\mathrm{H}_{i}^{4}</span> samples a string uniformly at random rather than running <span class="math">\\mathsf{SampleSol}</span>.</li>

    </ul>

    <p class="text-gray-300">Similarly to the switch made in the hybrids <span class="math">\\mathrm{H}_{i}^{1}</span>, we observe that the probability of distinguishing two consecutive hybrids is negligible due to the statistical indistinguishability of <span class="math">\\mathsf{PuzSys}</span>. Therefore, we have that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}_{q}^{4})\\geq p_{bad}(\\mathrm{H}_{q}^{3})-q\\cdot\\nu_{\\mathsf{PuzSys}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}_{0}^{5}</span> be equivalent to <span class="math">\\mathrm{H}_{q}^{4}</span>. For all <span class="math">i\\in[1,q]</span> let <span class="math">\\mathrm{H}_{i}^{5}</span> be equivalent to the hybrid <span class="math">\\mathrm{H}_{i-1}^{5}</span> except on how the <span class="math">i</span>-th verifier session is handled: specifically, in the hybrid <span class="math">\\mathrm{H}_{i}^{5}</span> the <span class="math">i</span>-th verifier session is run like the real world protocol <span class="math">\\Pi_{\\mathrm{TS}\\text{-}\\mathcal{R}}</span>, but the <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> is still emulated by the hybrid.</li>

    </ul>

    <p class="text-gray-300">The probability of distinguishing two consecutive hybrids is negligible due to the zero-knowledge property of <span class="math">\\Pi</span>. Similarly to the switch made in <span class="math">\\mathrm{H}_{i}^{3}</span>, we can claim that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}_{q}^{5})\\geq p_{bad}(\\mathrm{H}_{q}^{4})-q\\cdot\\mathsf{negl}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathrm{H}_{0}^{6}</span> be equivalent to <span class="math">\\mathrm{H}_{q}^{5}</span>. For all <span class="math">i\\in[1,q]</span>, let <span class="math">\\mathrm{H}_{i}^{6}</span> be the same as <span class="math">\\mathrm{H}_{i-1}^{6}</span> except on how the queries to <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> are handlded: in particular, in the hybrid <span class="math">\\mathrm{H}_{i}^{6}</span> the environment <span class="math">\\mathcal{Z}^{\\prime}</span> interatcs directly with the functionality <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span> (that is not emulated anymore by the hybrid)</li>

    </ul>

    <p class="text-gray-300">With a similar argument shown for the proof of hybrid <span class="math">\\mathrm{H}_{i}^{1}</span> we can claim that:</p>

    <p class="text-gray-300"><span class="math">p_{bad}(\\mathrm{H}_{q}^{6})=p_{bad}(\\mathrm{H}_{q}^{5})</span></p>

    <p class="text-gray-300">Finally, we observe that the hybrid <span class="math">\\mathrm{H}_{q}^{6}</span> corresponds to the real-world experiment.</p>

    <p class="text-gray-300">From the above arguments, it follows that in the real-world experiment, the probability that the event bad happens is non-negligible. Specifically, in the prover session <span class="math">\\mathsf{Sim}</span> receives a proof <span class="math">\\bar{\\pi}</span> w.r.t. theorem <span class="math">\\bar{x}^{\\prime}=(\\bar{x},\\overline{\\mathsf{p}\\mathsf{u}\\mathsf{z}})</span> from <span class="math">\\mathcal{A}</span> from which she fails to extract <span class="math">w</span> such that <span class="math">(x,w)\\in\\mathcal{R}</span>. Due to the soundness of <span class="math">\\varPi</span>, <span class="math">\\mathsf{Sim}</span> successfully extracts, unless with negligible probability, a witness <span class="math">\\bar{w}^{\\prime}</span> for the relation <span class="math">\\mathcal{R}^{\\prime}</span>. Since <span class="math">p_{bad}(\\mathrm{Exec}(\\varPi_{\\mathrm{TS}\\text{-}\\mathcal{R}},\\mathcal{A},\\mathcal{Z}))</span> is non-negligible, <span class="math">\\bar{w}^{\\prime}</span> corresponds to the solution of <span class="math">\\overline{\\mathsf{p}\\mathsf{u}\\mathsf{z}}</span>. If this is the case, we can show a polynomial time reduction that breaks the fact that a random instance of <span class="math">\\mathsf{PuzSys}</span> can not be solved in less than <span class="math">\\lambda^{\\log\\lambda}</span> steps.</p>

    <p class="text-gray-300">The reduction runs the real-world experiment with <span class="math">\\mathcal{Z}^{\\prime}</span>, acting as an honest prover in the verifier sessions and as a verifier in the prover session. Upon receiving <span class="math">\\bar{\\pi}</span> w.r.t. instance <span class="math">\\bar{x}^{\\prime}=(\\bar{x},\\overline{\\mathsf{p}\\mathsf{u}\\mathsf{z}})</span> from the prover session, the reduction applies the extractor <span class="math">\\mathcal{E}_{ks}</span> of <span class="math">\\varPi</span> to obtain the witness <span class="math">\\hat{w}</span>. Since by contradiction in the real-world experiment <span class="math">\\mathsf{Sim}</span> extracts a solution <span class="math">\\overline{\\mathsf{s}\\mathsf{o}\\mathsf{l}}</span> for the puzzle <span class="math">\\overline{\\mathsf{p}\\mathsf{u}\\mathsf{z}}</span> from <span class="math">\\bar{\\pi}</span>, then the reduction forwards <span class="math">\\overline{\\mathsf{s}\\mathsf{o}\\mathsf{l}}</span> to <span class="math">\\mathcal{CH}</span>. The reduction runs in polynomial time while <span class="math">\\mathsf{PuzSys}</span> cannot be solved in less than <span class="math">\\lambda^{\\log\\lambda}</span> steps, hence we reach a contradiction that concludes the proof.</p>

    <p class="text-gray-300"><em>Case 2:</em> First, we notice that the distribution of the prover sessions in the ideal world and the real world are statistically close. Therefore, we can focus only on the verifier sessions. It follows from the same chains of hybrids (and similar arguments) shown in Case 1 that the real-world execution of the verifier sessions can be replaced with calls to the ideal functionality, therefore the distribution of the output of <span class="math">\\mathcal{Z}</span> is indistinguishable in the real and ideal world.</p>

    <p class="text-gray-300">Step 2: We will now argue that:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Exec}(\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}},\\mathsf{Sim},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}])\\approx\\mathrm{Exec}(\\varPi_{\\mathrm{TS}\\text{-}\\mathcal{R}},\\mathcal{A},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}])</span></p>

    <p class="text-gray-300">If the prover is corrupted, by Step 1 Case 2 the probability that the event bad happens is negligible, therefore the distribution of the output of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>- augmented is indistinguishable in the real and ideal world.</p>

    <p class="text-gray-300">If the verifier is corrupted, by Step 1 the real-world execution of the prover and verifier sessions can be replaced with calls to the ideal functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>. Therefore the distribution of the output of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>- augmented is indistinguishable in the real and ideal world.</p>

    <p class="text-gray-300">If both parties are corrupted then the distribution of the views of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>- augmented environment in the real and ideal experiments is identical.</p>

    <p class="text-gray-300">If no party is corrupted it is possible to obtain a polynomial-time adversary following Step 1, then one can argue that the distribution of the output of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>- augmented is indistinguishable in the real and ideal world due to the zero-knowledge property of <span class="math">\\varPi</span>. ∎</p>

    <h2 id="sec-32" class="text-2xl font-bold">5 Concrete Realizations</h2>

    <p class="text-gray-300">We observe that Theorem 1 comes in two flavors and states under which assumptions we are able to realize the stronger functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\mathsf{NIZK}}</span> or the weaker version <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\circ\\textsf{NIZK}}</span>. We describe how to instantiate the main critical assumption in Theorem 1, namely the required argument system in the RO model, that either satisfies Definition 9 (for the stronger version) or its weaker version (that is sufficient to realize the weaker functionality).</p>

    <p class="text-gray-300">Realizing the weaker version. The weaker version follows from the work by Chiesa and Fenzi <em>[2]</em> by proving that their construction, which UC-realizes functionality <span class="math">\\mathcal{F}_{\\mathsf{ARG}}</span> depicted in Fig. 14, implies a succinct non-interactive straight-line weak true-simulation-extractable argument in the RO model. We prove this in Theorem 10 in Appendix E. This result allows us to plug the Micali and BCS zkSNARKs into Theorem 1 obtaining a construction with the same efficiency profile as that in <em>[2]</em>.</p>

    <p class="text-gray-300">Realizing the stronger version. Getting the stronger version requires substantially more work and does not follow from existing results. In a nutshell, to construct the desired succinct non-interactive straight-line true-simulation-extractable argument in the RO model meeting Definition 9, our starting point is the compiler of <em>[GKO+23]</em>. This compiler takes as input three main building blocks: a polynomial commitment (with some additional properties), a polynomial encoding scheme, as well as a simulation-extractable NIZK for a specific relation. All of these building blocks are allowed to make use</p>

    <p class="text-gray-300">of a local setup (like a CRS) in their compiler which is the main obstacle to overcome in this section and requires developing new building blocks and an adjusted compiler. In more detail, we achieve the required SNARK for the stronger version of Theorem 1 in a sequence of steps (we note in passing that we actually achieve here the stronger property Definition 8 that implies Definition 9):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As a first step in Section 5.1, we reformulate the compiler from <em>[GKO+23]</em> in a simpler model just assuming a standard (local) random oracle. We show that as intuitively expected, the resulting protocol UC-realizes <span class="math">\\mathcal{F}_{\\text{NIZK}}</span> based on well-defined building blocks that need to meet specific requirements stated as assumptions in Theorem 2.</li>

      <li>Armed with the above, a technical step is to formally extract the SNARK required by Theorem 1 from the UC protocol obtained from the previous step. We show this as a general statement in Theorem 11 in Appendix E. While this might appear as a technicality at first, this step is needed to bridge the gap to Theorem 1 which is intentionally left more general and based on standard definitions (i.e., a tuple of algorithms satisfying game-based notions) rather than an already UC-secure protocol as a starting point.</li>

      <li>Clearly, the final step is to finally construct the new building blocks: as a consequence of using the RO only, we are constraint to realize the underlying building blocks in a transparent way, yet still satisfy the requirements needed for the compiler to retain security. We construct these three building blocks:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The polynomial encoding scheme in Section 5.2.</li>

      <li>The polynomial commitment scheme in Section 5.3.</li>

      <li>The underlying simulation-extractable NIZK in Section 5.4.</li>

    </ol>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">5.1 Constructing the Argument System via the Modified Compiler</h3>

    <p class="text-gray-300">We defer the formal definition of our compiler to Appendix B.2 as it follows from adopting in a straightforward manner the techniques of <em>[GKO+23]</em> to the RO-only setting.</p>

    <p class="text-gray-300">We are now ready for the main statement for our instantiation.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Assume the following building blocks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi_{\\textsf{NIZK}}</span> be a simulation-extractable NIZK (Definition 7), for the relation <span class="math">\\mathcal{R}</span> with proof size <span class="math">O_{\\lambda}(f(n))</span> for a witness of size <span class="math">n</span>.</li>

      <li><span class="math">\\Pi_{\\textsf{PCS}}</span> be a polynomial commitment scheme with <span class="math">O_{\\lambda}(g(d))</span> size commitments and evaluation proofs (for a polynomial of degree <span class="math">d</span>), evaluation binding, unique proofs (Definition 11).</li>

      <li><span class="math">\\textsf{PES}=(\\textsf{Enc},\\textsf{Dec})</span> be an <span class="math">n\\to_{\\lambda}d</span> encoding scheme (Definition 13) such that <span class="math">\\Pi_{\\textsf{PCS}}</span> is <span class="math">\\phi</span>-admissible (Definition 16) w.r.t. <span class="math">\\textsf{PES}</span> for some function <span class="math">\\phi(\\cdot,\\cdot,\\cdot)</span>.</li>

    </ul>

    <p class="text-gray-300">Then we can construct a straight-line simulation-extractable NIZK in the random oracle model satisfying Definition 8 with proof size <span class="math">O_{\\lambda}\\big{(}f(n+\\phi_{n,\\lambda})+g(d)\\big{)}</span> where <span class="math">\\phi_{n,\\lambda}:=\\phi(\\lambda,n,\\lambda)</span>. Furthermore, if <span class="math">\\Pi_{\\textsf{NIZK}}</span> and <span class="math">\\Pi_{\\textsf{PCS}}</span> both have transparent setups, then the final NIZK also has a transparent setup.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is clear that once the modified compiler is UC-secure, we can apply Theorem 11 to extract the NIZK that is secure according to Definition 8. Furthermore, from the definition of the compiler of <em>[GKO+23]</em>, it is clear that if the underlying components are transparent (only make use of the random oracle as an assumption), then the final protocol has a transparent setup too. Therefore, the only thing remaining is to show that the compiler ported to the RO-only world does preserve UC-security which we do in Lemma 2 in Appendix B.2. ∎</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Putting it all together.</h4>

    <p class="text-gray-300">Looking ahead, we can instantiate <span class="math">\\Pi_{\\textsf{NIZK}}</span> and <span class="math">\\Pi_{\\textsf{PCS}}</span> in the random oracle model under the DLOG assumption; we are able to instantiate PES under the DDH assumption. As explained in Section 2.5 also PuzSys can be instantiated under the DLOG assumption. To show how we precisely can instantiate Theorem 2 using the concrete building blocks in the following sections, we</p>

    <p class="text-gray-300">provide here a qualitative and quantitative overview of their main features regarding transparency (and use of the RO); efficiency of the building blocks as well as parameter choice and final succinctness.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Transparent setup and use of the RO</h4>

    <p class="text-gray-300">The setups of both our instantiations are transparent: they both require sampling a Pedersen basis in a group where DLOG is hard which can be done by invoking the random oracle (e.g., <span class="math">g_{i}=\\mathcal{H}(i)</span>, etc.). Notice that, crucially, the commitment algorithm in Fig. 7 does not use the random oracle. This is important to instantiate our scheme since in the construction from <em>[GKO+23]</em> invokes a NIZK to prove that the commitment has been computed correctly. The only other property, besides the ROM, required for the security of the building blocks is DLOG and DDH.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Efficiency of our building blocks</h4>

    <p class="text-gray-300">The construction BP-PC inherits the efficiency properties of Bulletproofs <em>[BBB+18]</em>. The key property we are interested in this paper is degree-succinctness, in particular the size of the opening is <span class="math">O_{\\lambda}(\\log d)</span> where <span class="math">d</span> is the degree of the committed polynomial. We point out that the verification complexity for the polynomial opening proof is, however, linear in the degree of the polynomial. The commitment has constant size, i.e. <span class="math">O_{\\lambda}(1)</span>. The prover has running time <span class="math">O_{\\lambda}(d)</span>. Our NIZK instantiation has similar properties: its proofs are of size <span class="math">O_{\\lambda}(\\log n)</span> for a witness of size <span class="math">n</span>, while the verifier runs in linear time in <span class="math">n</span>. Using the language of Theorem 2 we can then conclude that our building blocks are such that <span class="math">f(n)=\\log n</span> and <span class="math">g(d)=\\log d</span>.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Parameter Choice and Final Succinctness</h4>

    <p class="text-gray-300">We recall, staying at a very high-level, that the compiler in <em>[GKO+23]</em> works by applying an “extractable proof of work” <em>[x10]</em> through multiple evaluations of a committed polynomial. The latter polynomial is an encoding of the witness (whose size is <span class="math">n</span>) of final degree <span class="math">d&gt;n</span>. Some of the key parameters in the compiler are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r</span>: the number of iterations in which the prover shows an evaluation of the committed polynomial.</li>

      <li><span class="math">T</span>: the maximum number of “grinding” attempts for the prover per iteration.</li>

      <li><span class="math">b</span>: the hardness factor of the proof-of-work.</li>

    </ul>

    <p class="text-gray-300">The authors of <em>[GKO+23]</em> show that a possible choice of parameters is:</p>

    <p class="text-gray-300"><span class="math">r=\\lambda\\in O_{\\lambda}(1),\\quad T=O_{\\lambda}(d),\\quad b=O_{\\lambda}(\\log d)</span></p>

    <p class="text-gray-300">Of the above parameters, only the first is relevant for us for proof succinctness (while the choices <span class="math">b</span> and <span class="math">T</span> above simply provide bounds for the proving running time). This parameter choice is the one giving us the statement in Theorem 2.</p>

    <p class="text-gray-300">We now first argue how to appropriately choose <span class="math">\\phi</span> for our polynomial encoding scheme so that we can argue security and then discuss its implications for the final proof size. In order to obtain <span class="math">\\phi</span>-evaluation hiding, we need to have <span class="math">\\phi</span> satisfying the requirements of Theorem 8. We observe that, for an appropriately chosen constant <span class="math">c&gt;0</span>, the function <span class="math">\\phi_{n,\\lambda}=c\\cdot\\lambda^{2}\\log^{2}(\\lambda n)</span> satisfies this requirement. From Remark 3, we know that our choice of PES transforms a string of size <span class="math">n</span> into one with size <span class="math">d=\\phi_{n,\\lambda}+O(n\\lambda)</span>. We can then plug all our observations so far into the statement of Theorem 2 and conclude that our total proof size is then <span class="math">O_{\\lambda}(\\log\\left(poly(\\lambda)\\cdot d\\right))</span> which can be shown to stay <span class="math">O_{\\lambda}(\\log(n))</span>.</p>

    <p class="text-gray-300">We conclude this section by a succinct theorem of our main result combining Theorem 1 and Theorem 2. (We stress that the requirement of “compactness” for the PKE below is extremely mild and related to efficiency-only. One could lift it to “secure PKE” and directly obtain a secure but less tight analysis in our technical lemmas)</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Under the DLOG assumption and the existence of a mildly compact PKE (Definition 19) <span class="math">\\Pi_{\\mathrm{TS}\\text{-}\\mathcal{R}}\\geq_{\\mathcal{F}_{\\text{NIZK}}^{\\mathcal{O}}}\\mathcal{F}_{\\text{NIZK}}^{\\mathcal{O}}</span> in the <span class="math">\\mathcal{G}_{\\text{RO}}</span>-hybrid model, where <span class="math">\\Pi_{\\mathrm{TS}\\text{-}\\mathcal{R}}</span> is the protocol defined in Section 4.1.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.2 Instantiation of the Polynomial Encoding Scheme</h3>

    <p class="text-gray-300">Here we describe our new polynomial encoding scheme. We require two main ingredients: an additive secret-sharing scheme and a public-key encryption scheme. Let <span class="math">\\mathbf{w}</span> be the vector we are aiming to encode and let <span class="math">\\ell\\in\\mathbb{N}</span> be a parameter (intuitively the number of evaluations of the polynomial allowed to the adversary in the <span class="math">\\phi</span>-evaluation hiding game). At the high-level, our construction works as follows (a full formal description is in Appendix C):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample a key pair <span class="math">(\\mathsf{pk},\\mathsf{sk})</span> for the encryption scheme;</li>

      <li>encrypt the vector <span class="math">\\mathbf{w}</span> using <span class="math">\\mathsf{pk}</span> obtaining a tuple of field elements <span class="math">\\mathbf{ct_{w}}</span>;</li>

      <li>secret share the decryption key <span class="math">\\mathsf{sk}</span> (through additive secret sharing) obtaining <span class="math">\\ell+1</span> shares, each a field element;</li>

      <li>let <span class="math">\\mathbf{v}</span> be the vector of scalars obtained by concatenating the ciphertext <span class="math">\\mathbf{ct_{w}}</span>, the public key <span class="math">\\mathsf{pk}</span> and the secret shares. The output of the encoding is the polynomial <span class="math">f</span> whose coefficients are defined by the vector <span class="math">\\mathbf{v}</span>.</li>

    </ul>

    <p class="text-gray-300">The decoding process is straightforward: on input the coefficients of <span class="math">f</span>, parse them appropriately, reconstruct the secret key <span class="math">\\mathsf{sk}</span>, decrypt <span class="math">\\mathbf{ct_{w}}</span> and return the resulting plaintext.</p>

    <p class="text-gray-300">Below we further expand on some requirements and parameters for the encryption scheme. The definition below bundles together some efficiency requirements that simplify our treatment. The specific concrete bounds are not crucial for our approach to work (they mostly stem from the instantiation in Remark 2); our efficiency profile would still follow with <span class="math">O(\\mathsf{poly}(\\lambda))</span> larger parameters and there exist instantiations other than the ones in Remark 2 satisfying them.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 19 (Mildly Compact PKE).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a PKE scheme over a field <span class="math">\\mathbb{F}_{\\lambda}</span> parametrized by <span class="math">\\lambda\\in\\mathbb{N}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\lambda})$ if it is correct and secure and if it satisfies the following efficiency parameters (in field elements):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the secret key $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ consists of a single field element</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\kappa=2</span> (public-key size)</li>

      <li><span class="math">n^{\\prime}=4\\lambda n</span> (ciphertext size, for a plaintext of size <span class="math">n</span>)</li>

      <li>the encryption algorithm runs in time <span class="math">O_{\\lambda}(n)</span></li>

    </ul>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 2 (Possible instantiations of the PKE).</h6>

    <p class="text-gray-300">For simplicity (it makes part of the treatment easier) we require a PKE whose secret key can be represented as a field element, while its public key and ciphertexts can be described as vectors of field elements <em>in the same field</em>. We observe that El Gamal encryption can be instantiated with some care to satisfy this syntax. In particular it is possible to use an elliptic curve where DDH is hard, whose elliptic curve points can be described as pairs of the type <span class="math">\\mathbb{F}^{2}</span> and whose discrete logarithms can be described as elements in the same field <span class="math">\\mathbb{F}</span> (the last two requirements can be summarized as: the scalar field and the base field of the elliptic curve should be roughly the same). An example of such an instantiation would be through the 2-tower of curves provided by the Jabberwock curve on top of Ristretto25519 described in <em>[x10]</em>. For efficient decryption we can use bit-by-bit El Gamal encryption.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 3 (Size of the encoding).</h6>

    <p class="text-gray-300">Let <span class="math">\\phi</span> and <span class="math">\\phi_{n,\\lambda}</span> as in Theorem 2. When choosing <span class="math">\\ell=\\phi_{n,\\lambda}</span>, the encoding a string of size <span class="math">n</span> through the construction in this section has size <span class="math">d=\\phi_{n,\\lambda}+O(\\lambda n)</span> when we instantiate the underlying encryption scheme in our PES with one satisfying Definition 19.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark 4 (Efficiency of proving encryption in zero-knowledge).</h6>

    <p class="text-gray-300">The choice of fields as described in Remark 2 is also particularly useful because it allows to prove encryption (and the whole encoding of the polynomial) through efficient techniques using Bulletproofs (our choice of instantiation for the simulation-extractable NIZK) as described in <em>[x10]</em> and <em>[x11]</em>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 5 (On secret-key encryption as an alternative approach).</h6>

    <p class="text-gray-300">We stress that, from a security standpoint, our techniques in this section do not strictly require <em>public</em>-key encryption. Secret-key encryption with (multi-)message indistinguishability could actually be enough with straightforward adaptations of our construction. The reasons we decided to express our solution through public-key encryption lie essentially in Remark 2 and Remark 4: it is easy to come up with instantiations of public-key schemes where the secret key, the plaintexts and ciphertexts can be embedded in a field keeping the overall scheme efficient. Secret-key solutions are usually bit-string based and would require some form of embedding. This would simply be slightly more awkward to capture in a fully formal way. Moreover, we would not be able to exploit algebraic properties of efficient SNARKs for efficiency in the secret-key setting.</p>

    <p class="text-gray-300">We consider a variant of the Bulletproofs polynomial commitment scheme [BBB+18]. Since we require special properties to satisfy the hypothesis of Theorem 2, we build it starting from the inner-product argument described by Dao and Grubbsin [DG23]. We then observe that we can use several properties proven by [DG23] as a bridge to obtain all the special polynomial commitment features required by [GKO+23].</p>

    <p class="text-gray-300">5.3.1 Building Block: Inner-Product Argument We describe the inner-product argument based on Bulletproofs in Fig. 6. We will use the following result to prove properties of our polynomial commitment:</p>

    <p class="text-gray-300">Theorem 4 ([BBB+18, DG23]). The construction BP-IPA <span class="math">_{\\text{FS}}</span>  (i.e., the protocol in Fig. 6 compiled with Fiat-Shamir) is complete, knowledge-sound, 0-unique response under the DLOG assumption in the random-oracle model (see Appendix for definitions).</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 6: Bulletproofs' Inner Product Argument BP-IPA</p>

    <p class="text-gray-300">5.3.2 The Polynomial Commitment Scheme We describe our polynomial commitment BP-PC in Fig. 7 and its core building block, the inner-product argument BP-IPA <span class="math">^{18}</span> , in Fig. 6.</p>

    <p class="text-gray-300">The following theorems summarize the security properties we use to instantiate Theorem 2. We refer the reader to Appendix C and Appendix D for details on the proofs. The PES from Section 5.2 is described in full formal details in Definition 28 in Appendix C.3. The specific bounds in Theorem 6 come from our leakage analysis</p>

    <p class="text-gray-300">Theorem 5. The construction BP-PC in Fig. 7 is a polynomial commitment scheme satisfying correctness, evaluation binding and unique-response (see Section 2.4) under the DLOG assumption in the random-oracle model (Assumption 1 in the Appendix).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PCGen(1^λ, d) → ck: Sample random generators g ∈ G^d, h ∈ G^d, u ∈ G. Output ck := (g, h, u).</li>

      <li>Com(ck, f ∈ F<d[X]) → cm: Output cm := g^a where f(X) := ∑_{i=0}^{d-1} a_i X^i</li>

      <li>Eval(ck, f ∈ F<d[X], x ∈ F) → π: Let y = f(x), b = (x^0, ..., x^{d-1}) recompute cm ← Commit(ck, f). Let P = g^a h^b u^y. Run BP-IPA_FS, the (Fiat-Shamir version of the) protocol in Fig. 6 between P(ck, P, (a, b)) and V(ck, P). Return π, the resulting transcript.</li>

      <li>Check(ck, cm, x ∈ F, y ∈ F, π): Compute b = (x^0, ..., x^{d-1}). Let P = cm · h^b u^y. Check that proof π for BP-IPA_FS verifies on public input P; reject otherwise.</li>

    </ul>

    <p class="text-gray-300">Fig. 7: Bulletproofs-based Polynomial Commitment BP-PC. All algorithms have implicitly access to the random oracle. For simplicity, we describe PCGen as explicitly sampling the Pedersen basis, but it can be sampled using the RO.</p>

    <p class="text-gray-300">Theorem 6. Under the DLOG assumption and the existence of a mildly compact PKE (Definition 19) the construction BP-PC in Fig. 7 is <span class="math">\\phi</span>-admissible with respect to the PES from Section 5.2, where <span class="math">\\phi</span> satisfies the bound <span class="math">\\phi(\\lambda, n, r) &amp;gt; 1 + 2r(1 + 2\\lceil \\log (\\phi(\\lambda, n, r) + 7\\lambda n) \\rceil)</span>.</p>

    <h2 id="sec-48" class="text-2xl font-bold">5.4 Instantiation of the Succinct Simulation-Extractable NIZK</h2>

    <p class="text-gray-300">In order to instantiate our framework we consider the full-blown version for arithmetic circuits of Bulletproofs [BBB+18].</p>

    <p class="text-gray-300">Theorem 7 ([DG23]). Non-Interactive Bulletproofs compiled with Fiat-Shamir is a simulation-extractable NIZK under the DLOG assumption in the random oracle model. The resulting scheme has proofs of size <span class="math">O_{\\lambda}(\\log n)</span> where <span class="math">n</span> is the multiplicative complexity of the arithmetic circuit describing the relation.</p>

    <p class="text-gray-300">Remark 6 (On the technical challenges around suitable building blocks). As mentioned in the introduction, the compiler in [GKO+23] requires a polynomial commitment with unique proofs and satisfying a weak form of hiding, evaluation hiding, when paired with an encoding scheme. Although these are relatively unstudied properties for polynomial commitments (the second notion was introduced in their work) Ganesh et al. are able to use KZG [KZG10], a polynomial commitment with a trusted setup, for their instantiations. Since our goal was to achieve a transparent proof system, this changed the pool of candidate proof systems. While there exist several transparent schemes in literature, to the best of our knowledge, only Bulletproofs-based techniques [BBB+18] have been studied in terms under a lens similar to that of unique proofs [DG23], which made it a natural starting point. On the other hand, Bulletproofs had a completely different leakage profile than KZG and therefore none of the simple encoding techniques in [GKO+23] were applicable (or even pointed in the right directions)—we had to try completely different approaches. After several false starts, we landed on the potentially suitable technique based on secret sharing. Yet, this still required analyzing it under the lens of the inner-product-flavored leakage that is specific to Bulletproofs. The latter contained a large part of our technical challenges: none of the existing literature on secret sharing (to the best of our knowledge) could offer insights on how to approach this; we therefore had to rely on and develop our own tools (mainly in Appendix C and Appendix D.3).</p>

    <p class="text-gray-300">Remark 7 (Differences between the "NIZK" Bulletproofs and our "Bulletproofs-based polynomial commitment"). We clarify some differences between the construction in this sub-section and the one in Section 5.3. First, for polynomial commitments we require only a very basic component of Bulletproofs, namely its inner-product argument. On the other hand, for the NIZK we need the whole machinery of the argument system: it needs to be able to handle arbitrary arithmetic circuits. Second, in order to satisfy the requirements of Theorem 2 the two—the NIZK and the polynomial commitment—need to satisfy very different requirements: the NIZK needs to be simulation-extractable (and zero-knowledge); for the polynomial commitment scheme full-blown zero-knowledge and extractability are not required—we require instead weaker properties such as evaluation-binding, hiding with respect to some polynomial encoding schemes, et cetera. We remark for example that BP-IPA is completely deterministic and</p>

    <p class="text-gray-300">31</p>

    <p class="text-gray-300">does not satisfy zero-knowledge as it is. Further implications of these fine-grained requirements had to do with the technical work required to prove the respective requirements: for NIZK Bulletproofs, these came out-of-the-box from <em>[x10]</em>, whereas for the polynomial commitment scheme they required additional observations (see also discussion in the Technical Overview).</p>

    <h2 id="sec-49" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors would like to thank Mahak Pancholi, Chaya Ganesh, Yashvanth Kondi and Akira Takahashi for fruitful discussions around this topic. Thanks to Dario Fiore for conversations about polynomial encoding schemes. Matteo Campanelli would like to thank Alessio Sammartano for being an extremely helpful linear algebraic oracle and for having spotted a flaw in an early version of the analysis of linear leakage resistance. Thanks to Mahak Pancholi for giving feedback on early drafts of our work.</p>

    <p class="text-gray-300">This work is supported in part by the Input Output Research Hub (IORH) of the University of Edinburgh and by the Sunday Group Inc.</p>

    <h2 id="sec-50" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AC20. Thomas Attema and Ronald Cramer. Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug & play secure algorithmics. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 513–543. Springer, Cham, August 2020.</li>

      <li>AGL^{+}23. Arasu Arun, Chaya Ganesh, Satya V. Lokam, Tushar Mopuri, and Sriram Sridhar. Dew: A transparent constant-sized polynomial commitment scheme. In Alexandra Boldyreva and Vladimir Kolesnikov, editors, PKC 2023, Part II, volume 13941 of LNCS, pages 542–571. Springer, Cham, May 2023.</li>

      <li>BBB^{+}18. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>BCH^{+}20. Christian Badertscher, Ran Canetti, Julia Hesse, Björn Tackmann, and Vassilis Zikas. Universal composition with global subroutines: Capturing global setup within plain UC. In Rafael Pass and Krzysztof Pietrzak, editors, TCC 2020, Part III, volume 12552 of LNCS, pages 1–30. Springer, Cham, November 2020.</li>

      <li>BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Berlin, Heidelberg, October / November 2016.</li>

      <li>BDH^{+}17. Brandon Broadnax, Nico Döttling, Gunnar Hartung, Jörn Müller-Quade, and Matthias Nagel. Concurrently composable security with shielded super-polynomial simulators. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part I, volume 10210 of LNCS, pages 351–381. Springer, Cham, April / May 2017.</li>

      <li>BFKT24. Jan Bobolz, Pooya Farshim, Markulf Kohlweiss, and Akira Takahashi. The brave new world of global generic groups and UC-secure zero-overhead SNARKs. In Elette Boyle and Mohammad Mahmoody, editors, TCC 2024, Part I, volume 15364 of LNCS, pages 90–124. Springer, Cham, December 2024.</li>

      <li>BFM88. Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In 20th ACM STOC, pages 103–112. ACM Press, May 1988.</li>

      <li>BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Cham, May 2020.</li>

      <li>BHZ21. Christian Badertscher, Julia Hesse, and Vassilis Zikas. On the (ir)replaceability of global setups, or how (not) to use a global ledger. In Kobbi Nissim and Brent Waters, editors, TCC 2021, Part II, volume 13043 of LNCS, pages 626–657. Springer, Cham, November 2021.</li>

      <li>BKZZ16. Foteini Baldimtsi, Aggelos Kiayias, Thomas Zacharias, and Bingsheng Zhang. Indistinguishable proofs of work or knowledge. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 902–933. Springer, Berlin, Heidelberg, December 2016.</li>

      <li>Can01. Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS, pages 136–145. IEEE Computer Society Press, October 2001.</li>

      <li>CDG^{+}18. Jan Camenisch, Manu Drijvers, Tommaso Gagliardoni, Anja Lehmann, and Gregory Neven. The wonderful world of global random oracles. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 280–312. Springer, Cham, April / May 2018.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">CF24. Alessandro Chiesa and Giacomo Fenzi. zkSNARKs in the ROM with unconditional UC-security. In Elette Boyle and Mohammad Mahmoody, editors, TCC 2024, Part I, volume 15364 of LNCS, pages 67–89. Springer, Cham, December 2024.</p>

    <p class="text-gray-300">CFF^{+}21. Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: A toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 3–33. Springer, Cham, December 2021.</p>

    <p class="text-gray-300">CFR24. Matteo Campanelli, Antonio Faonio, and Luigi Russo. SNARKs for virtual machines are non-malleable. Cryptology ePrint Archive, Paper 2024/1551, 2024.</p>

    <p class="text-gray-300">CHA22. Matteo Campanelli and Mathias Hall-Andersen. Veksel: Simple, efficient, anonymous payments with large anonymity sets from well-studied assumptions. In Yuji Suga, Kouichi Sakurai, Xuhua Ding, and Kazue Sako, editors, ASIACCS 22, pages 652–666. ACM Press, May / June 2022.</p>

    <p class="text-gray-300">CHAK23. Matteo Campanelli, Mathias Hall-Andersen, and Simon Holmgaard Kamp. Curve trees: Practical and transparent {Zero-Knowledge} accumulators. In 32nd USENIX Security Symposium (USENIX Security 23), pages 4391–4408, 2023.</p>

    <p class="text-gray-300">CHM^{+}20. Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Cham, May 2020.</p>

    <p class="text-gray-300">CJS14. Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC security with a global random oracle. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 2014, pages 597–608. ACM Press, November 2014.</p>

    <p class="text-gray-300">CLP10. Ran Canetti, Huijia Lin, and Rafael Pass. Adaptive hardness and composable security in the plain model from standard assumptions. In 51st FOCS, pages 541–550. IEEE Computer Society Press, October 2010.</p>

    <p class="text-gray-300">CV22. Michele Ciampi and Ivan Visconti. Efficient NIZK arguments with straight-line simulation and extraction. In Alastair R. Beresford, Arpita Patra, and Emanuele Bellini, editors, CANS 22, volume 13641 of LNCS, pages 3–22. Springer, Cham, November 2022.</p>

    <p class="text-gray-300">DDO^{+}01. Alfredo De Santis, Giovanni Di Crescenzo, Rafail Ostrovsky, Giuseppe Persiano, and Amit Sahai. Robust non-interactive zero knowledge. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 566–598. Springer, Berlin, Heidelberg, August 2001.</p>

    <p class="text-gray-300">DG23. Quang Dao and Paul Grubbs. Spartan and bulletproofs are simulation-extractable (for free!). In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part II, volume 14005 of LNCS, pages 531–562. Springer, Cham, April 2023.</p>

    <p class="text-gray-300">DHLW10. Yevgeniy Dodis, Kristiyan Haralambiev, Adriana López-Alt, and Daniel Wichs. Efficient public-key cryptography in the presence of key leakage. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 613–631. Springer, Berlin, Heidelberg, December 2010.</p>

    <p class="text-gray-300">FFK^{+}23. Antonio Faonio, Dario Fiore, Markulf Kohlweiss, Luigi Russo, and Michal Zajac. From polynomial IOP and commitments to non-malleable zkSNARKs. In Guy N. Rothblum and Hoeteck Wee, editors, TCC 2023, Part III, volume 14371 of LNCS, pages 455–485. Springer, Cham, November / December 2023.</p>

    <p class="text-gray-300">FFR24. Antonio Faonio, Dario Fiore, and Luigi Russo. Real-world universal zkSNARKs are non-malleable. In Bo Luo, Xiaojing Liao, Jun Xu, Engin Kirda, and David Lie, editors, ACM CCS 2024, pages 3138–3151. ACM Press, October 2024.</p>

    <p class="text-gray-300">Fis05. Marc Fischlin. Communication-efficient non-interactive proofs of knowledge with online extractors. In Victor Shoup, editor, CRYPTO 2005, volume 3621 of LNCS, pages 152–168. Springer, Berlin, Heidelberg, August 2005.</p>

    <p class="text-gray-300">FKMV12. Sebastian Faust, Markulf Kohlweiss, Giorgia Azzurra Marson, and Daniele Venturi. On the non-malleability of the Fiat-Shamir transform. In Steven D. Galbraith and Mridul Nandi, editors, INDOCRYPT 2012, volume 7668 of LNCS, pages 60–79. Springer, Berlin, Heidelberg, December 2012.</p>

    <p class="text-gray-300">FS87. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Berlin, Heidelberg, August 1987.</p>

    <p class="text-gray-300">GKK^{+}22. Chaya Ganesh, Hamidreza Khoshakhlagh, Markulf Kohlweiss, Anca Nitulescu, and Michal Zajac. What makes fiat-shamir zkSNARKs (updatable SRS) simulation extractable? In Clemente Galdi and Stanislaw Jarecki, editors, SCN 22, volume 13409 of LNCS, pages 735–760. Springer, Cham, September 2022.</p>

    <p class="text-gray-300">GKKB12. Aditi Gupta, Sam Kerr, Michael S. Kirkpatrick, and Elisa Bertino. Marlin: making it harder to fish for gadgets. In Ting Yu, George Danezis, and Virgil D. Gligor, editors, ACM CCS 2012, pages 1016–1018. ACM Press, October 2012.</p>

    <p class="text-gray-300">GKO^{+}23. Chaya Ganesh, Yashvanth Kondi, Claudio Orlandi, Mahak Pancholi, Akira Takahashi, and Daniel Tschudi. Witness-succinct universally-composable SNARKs. In Carmit Hazay and Martijn Stam,</p>

    <p class="text-gray-300">editors, EUROCRYPT 2023, Part II, volume 14005 of LNCS, pages 315–346. Springer, Cham, April 2023.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GM17] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable SNARKs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 581–612. Springer, Cham, August 2017.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304. ACM Press, May 1985.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In Alfred Aho, editor, 19th ACM STOC, pages 218–229. ACM Press, May 1987.</li>

      <li>[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, December 1994.</li>

      <li>[GOP^{+}22] Chaya Ganesh, Claudio Orlandi, Mahak Pancholi, Akira Takahashi, and Daniel Tschudi. Fiat-shamir bulletproofs are non-malleable (in the algebraic group model). In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 397–426. Springer, Cham, May / June 2022.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Berlin, Heidelberg, May 2016.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019.</li>

      <li>[KPT23] Markulf Kohlweiss, Mahak Pancholi, and Akira Takahashi. How to compile polynomial IOP into simulation-extractable SNARKs: A modular approach. In Guy N. Rothblum and Hoeteck Wee, editors, TCC 2023, Part III, volume 14371 of LNCS, pages 486–512. Springer, Cham, November / December 2023.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Berlin, Heidelberg, December 2010.</li>

      <li>[KZM^{+}15] Ahmed Kosba, Zhichao Zhao, Andrew Miller, Yi Qian, Hubert Chan, Charalampos Papamanthou, Rafael Pass, abhi shelat, and Elaine Shi. C<span class="math">\\o$$\\cC</span>\\o$: A framework for building composable zero-knowledge proofs. Cryptology ePrint Archive, Report 2015/1093, 2015.</li>

      <li>[Lee21] Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. In Kobbi Nissim and Brent Waters, editors, TCC 2021, Part II, volume 13043 of LNCS, pages 1–34. Springer, Cham, November 2021.</li>

      <li>[Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>[Pas03] Rafael Pass. Simulation in quasi-polynomial time, and its application to protocol composition. In Eli Biham, editor, EUROCRYPT 2003, volume 2656 of LNCS, pages 160–176. Springer, Berlin, Heidelberg, May 2003.</li>

      <li>[Pas04] Rafael Pass. Bounded-concurrent secure multi-party computation with a dishonest majority. In László Babai, editor, 36th ACM STOC, pages 232–241. ACM Press, June 2004.</li>

      <li>[PS04] Manoj Prabhakaran and Amit Sahai. New notions of security: Achieving universal composability without trusted setup. In László Babai, editor, 36th ACM STOC, pages 242–251. ACM Press, June 2004.</li>

      <li>[SB23] István András Seres and Péter Burcsi. Behemoth: transparent polynomial commitment scheme with constant opening proof size and verifier time. Cryptology ePrint Archive, Report 2023/670, 2023.</li>

      <li>[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Cham, August 2020.</li>

      <li>[Swi19] Josh Swihart. Zcash counterfeiting vulnerability successfully remediated. 2019.</li>

      <li>[WTs^{+}18] Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943. IEEE Computer Society Press, May 2018.</li>

      <li>[Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In 27th FOCS, pages 162–167. IEEE Computer Society Press, October 1986.</li>

    </ul>

    <p class="text-gray-300">Supplementary Material</p>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix A The Shielded Oracle Framework <em>[BDH+17]</em></h2>

    <p class="text-gray-300">We give here a brief overview of the main definitions of the framework of <em>[BDH+17]</em>. The main ingredients compared to standard UC are threefold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The definition of a shielded oracle <span class="math">\\mathcal{O}</span> and the definition of adjoined functionalities <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>.</li>

      <li>The definition of a new environment class <span class="math">\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}]</span>.</li>

      <li>A composable UC-realization notion <span class="math">\\pi\\geq_{\\mathcal{F}^{\\mathcal{O}}}\\phi</span>.</li>

    </ol>

    <p class="text-gray-300">We give first give the definitions from <em>[BDH+17]</em> for completeness here:</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 20 (Shielded oracles).</h6>

    <p class="text-gray-300">A shielded oracle is a stateful oracle <span class="math">\\mathcal{O}</span> that can be implemented in quasi-polynomial time. By convention, the outputs of a shielded oracle <span class="math">\\mathcal{O}</span> are of the form <span class="math">(\\mathsf{output\\text{-}to\\text{-}fnct},y)</span> or <span class="math">(\\mathsf{output\\text{-}to\\text{-}adv},y)</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 21 (<span class="math">\\mathcal{O}</span>-adjoined functionalities).</h6>

    <p class="text-gray-300">Given a functionality <span class="math">\\mathcal{F}</span> and a shielded oracle <span class="math">\\mathcal{O}</span>, define the interaction of the <span class="math">\\mathcal{O}</span>-adjoined functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> an ideal protocol execution with a session identifier <span class="math">\\mathsf{sid}</span> as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{F}^{\\mathcal{O}}</span> internally runs an instance of <span class="math">\\mathcal{F}</span> with session identifier <span class="math">\\mathsf{sid}</span></li>

      <li>When receiving the first message <span class="math">x</span> from the adversary, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> internally invokes <span class="math">\\mathcal{O}</span> with input <span class="math">(\\mathsf{sid},x)</span>. All subsequent messages from the adversary are passed to <span class="math">\\mathcal{O}</span>.</li>

      <li>Messages between the honest parties and <span class="math">\\mathcal{F}</span> are forwarded.</li>

      <li>Corruption messages are forwarded to <span class="math">\\mathcal{F}</span> and <span class="math">\\mathcal{O}</span>.</li>

      <li>When <span class="math">\\mathcal{F}</span> sends a message <span class="math">y</span> to the adversary, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> passes <span class="math">y</span> to <span class="math">\\mathcal{O}</span>.</li>

      <li>The external write operations of <span class="math">\\mathcal{O}</span> are treated as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{O}</span> sends <span class="math">(\\mathsf{output\\text{-}to\\text{-}fnct},y)</span>, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> sends <span class="math">y</span> to <span class="math">\\mathcal{F}</span>.</li>

      <li>If <span class="math">\\mathcal{O}</span> sends <span class="math">(\\mathsf{output\\text{-}to\\text{-}adv},y)</span>, <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> sends <span class="math">y</span> to the adversary.</li>

    </ul>

    <p class="text-gray-300">UC-realization notion. Let <span class="math">\\mathsf{IDEAL}(\\mathcal{F}^{\\mathcal{O}})</span> be the ideal protocol with functionality <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> as defined in <em>[x10]</em>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 22 ( The <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> execution experiment).</h6>

    <p class="text-gray-300">An execution of a protocol <span class="math">\\sigma</span> with adversary <span class="math">\\mathcal{A}</span> and an <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environment <span class="math">\\mathcal{Z}</span> on input <span class="math">a\\in\\{0,1\\}^{*}</span> and with security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> is a run of a system of interactive Turing machines (ITMs) with the following restrictions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">\\mathcal{Z}</span> is activated on input <span class="math">a\\in\\{0,1\\}^{*}</span>.</li>

      <li>The first ITM to be invoked by <span class="math">\\mathcal{Z}</span> is the adversary <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{Z}</span> may invoke a single instance of a challenge protocol, which is set to be <span class="math">\\sigma</span> by the experiment. The session identifier of <span class="math">\\sigma</span> is determined by <span class="math">\\mathcal{Z}</span> upon invocation.</li>

      <li><span class="math">\\mathcal{Z}</span> may pass inputs to the adversary or the protocol parties of <span class="math">\\sigma</span>.</li>

      <li><span class="math">\\mathcal{Z}</span> may invoke, send inputs to and receive outputs from instances of <span class="math">\\mathsf{IDEAL}(\\mathcal{F}^{\\mathcal{O}})</span> as long as the session identifiers of these instances as well as the session identifier of the instance of <span class="math">\\sigma</span> are not extensions of one another.</li>

      <li>The adversary <span class="math">\\mathcal{A}</span> may send messages to protocol parties of <span class="math">\\sigma</span> as well as to the environment.</li>

      <li>The protocol parties of <span class="math">\\sigma</span> may send messages to <span class="math">\\mathcal{A}</span>, pass inputs to and receive outputs from subparties, and give outputs to <span class="math">\\mathcal{Z}</span>.</li>

    </ul>

    <p class="text-gray-300">Denote by <span class="math">\\mathrm{Exec}(\\sigma,\\mathcal{A},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])(\\lambda,a)</span> the output of the <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environment <span class="math">\\mathcal{Z}</span> on input <span class="math">a\\in\\{0,1\\}^{<em>}</span> and with security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> when interacting with <span class="math">\\sigma</span> and <span class="math">\\mathcal{A}</span> according to the above definition. Define <span class="math">\\mathrm{Exec}(\\sigma,\\mathcal{A},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])=\\{\\mathrm{Exec}(\\sigma,\\mathcal{A},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])(\\lambda,a)\\}_{a\\in\\{0,1\\}^{</em>},\\lambda\\in\\mathbb{N}}</span></p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 23.</h6>

    <p class="text-gray-300">Let <span class="math">\\pi</span> and <span class="math">\\phi</span> be protocols. <span class="math">\\pi</span> is said to emulate <span class="math">\\phi</span> in the presence of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environments, denote by <span class="math">\\pi\\geq_{\\mathcal{F}^{\\mathcal{O}}}\\phi</span>, if for any PPT adversary <span class="math">\\mathcal{A}</span> there exists a PPT adversary (called simulator) <span class="math">\\mathsf{Sim}</span> such that for every <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented PPT environment <span class="math">\\mathcal{Z}</span> it holds that:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Exec}(\\pi,\\mathcal{A},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])\\approx\\{\\mathrm{Exec}(\\phi,\\mathsf{Sim},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}]).</span></p>

    <p class="text-gray-300">The definition is shown to be composable in the sense of <em>[x10]</em> when considering the richer class of environments.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 24</h6>

    <p class="text-gray-300">(The <span class="math">\\mathcal{F}^{\\mathcal{O}}</span> emulation with respect to the dummy adversary <em>[BDH^{+}17]</em>).</p>

    <p class="text-gray-300">The dummy adversary <span class="math">D</span> is an adversary that when receiving a message <span class="math">(\\mathsf{sid},\\mathsf{pid},m)</span> from the environment, sends <span class="math">m</span> to the party with party identifier <span class="math">\\mathsf{pid}</span> and session identifier <span class="math">\\mathsf{sid}</span>, and that, when receiving <span class="math">m</span> from the party with party identifier <span class="math">\\mathsf{pid}</span> and session identifier <span class="math">\\mathsf{sid}</span>, sends <span class="math">(\\mathsf{sid},\\mathsf{pid},m)</span> to the environment. Let <span class="math">\\pi</span> and <span class="math">\\phi</span> be protocols. <span class="math">\\pi</span> is said to emulate <span class="math">\\phi</span> in the presence of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environments with respect to the dummy adversary</p>

    <p class="text-gray-300"><span class="math">\\exists\\mathsf{Sim}_{D}\\forall\\mathcal{Z}:\\mathrm{Exec}(\\pi,D,\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])\\approx\\{\\mathrm{Exec}(\\phi,\\mathsf{Sim}_{D},\\mathcal{Z}[\\mathcal{F}^{\\mathcal{O}}])</span></p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proposition 1 (<em>[BDH^{+}17]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\pi</span> and <span class="math">\\phi</span> be protocols. <span class="math">\\pi</span> is said to emulate <span class="math">\\phi</span> in the presence of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environments if and only if <span class="math">\\phi</span> emulates <span class="math">\\pi</span> in the presence of <span class="math">\\mathcal{F}^{\\mathcal{O}}</span>-augmented environments with respect to the dummy adversary.</p>

    <p class="text-gray-300">Finally, we report the definition of polynomial simultability introduced in <em>[BDH^{+}17]</em>. This notion is useful in <em>[BDH^{+}17]</em> to prove the compatibility of the UC framework. In particular, it implies that the presence of the augmented functionality, despite its super-poly power, does not harm composition with standard UC. The intuitive reason is that the powerful oracle is sufficiently shielded to prevent adverse effects on the rest of the system.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 25.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{O}</span> be a shielded oracle, <span class="math">\\mathcal{F}</span> a functionality. Say that <span class="math">\\mathcal{O}</span> adjoined to <span class="math">\\mathcal{F}</span> is polynomially simulatable if there exists a (PPT) functionality <span class="math">\\mathcal{M}</span> such that for all <span class="math">\\mathcal{F}</span> <span class="math">\\mathcal{O}</span>-augmented environments <span class="math">\\mathcal{Z}</span> it holds that <span class="math">\\mathcal{F}^{\\mathcal{O}}\\geq_{\\mathcal{F}^{\\mathcal{O}}}\\mathcal{M}</span>.</p>

    <p class="text-gray-300">We note that the <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\mathsf{NIZK}}</span> defined in Fig. 4 enjoys this property this follows from Theorem 1. This is because the only output of the adjoined oracle visible via the attacker’s interface is proof strings for problem instances <span class="math">x</span> for which the functionality has seen the witness <span class="math">w</span>, even if it does not use <span class="math">w</span> to generate them (as per zero-knowledge requirements). Therefore, the execution of the adjoined oracle could be replaced by a PPT machine <span class="math">\\mathcal{M}</span> that generates the proof following the honest prover procedure on input <span class="math">(x,w)</span>. Using Theorem 1 it is possible to argue that a polynomial attacker can not distinguish how the proof is generated assuming the <span class="math">\\mathcal{G}_{\\mathsf{RO}}</span>-hybrid model. Further, the above argument can be carried out even for parallel executions of <span class="math">\\mathcal{F}^{\\mathcal{O}}_{\\mathsf{NIZK}}</span> since a proof issued in a session is rejected in any session that is not the one in which the proof is generated.</p>

    <h2 id="sec-59" class="text-2xl font-bold">Appendix B Main Definitions and Compilers to Witness-Succinct UC-NIZKs</h2>

    <p class="text-gray-300">In Appendix B.1, we give a comparison between the definitions in <em>[GKO^{+}23]</em> and our minor adaptions in Section 2.4. Finally, we show the compiler of <em>[GKO^{+}23]</em> for the sake of self-containment.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">B.1 On the Differences between our Definitions and <em>[GKO^{+}23]</em></h3>

    <p class="text-gray-300">We applied the following changes compared to the original framework in <em>[GKO^{+}23]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we removed the explicit randomness in the polynomial commitment (our focus is on deterministic commitments);</li>

      <li>we explicitly add the RO to the algorithms and adversaries of the polynomial commitments;</li>

      <li>more generally, the polynomial encoding scheme takes as input a parameter <span class="math">\\lambda</span> (we use this in our construction);</li>

      <li>for evaluation hiding and non-extrapolation, we let <span class="math">\\phi</span> be a function of both <span class="math">n</span> and the size of <span class="math">\\mathbf{z}</span> rather than only the latter. We also let it be a function of <span class="math">\\lambda</span>. This is more general and it is actually necessary in our constructions.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we generalize the “stretch” introduced by the encoding through the function stretch. The quantity <span class="math">\\textsf{stretch}(\\lambda,n,\\ell)</span> reflects how much larger than <span class="math">\\mathbf{w}</span> is the encoding of <span class="math">\\mathbf{w}\\in\\mathbb{F}^{n}</span> when using <span class="math">\\ell</span> additional randomness and with security parameter <span class="math">\\lambda</span>. This was assumed to be always <span class="math">\\ell</span> in <em>[GKO^{+}23]</em>. We stress that this change does not affect the proofs and does not impact the efficiency analysis in any substantial way: our stretch stays <span class="math">O_{\\lambda}(n)</span> as in <em>[GKO^{+}23]</em>;</li>

      <li>we let some parameters such as <span class="math">n</span> and <span class="math">r</span> be quantified universally rather than being provided by the adversary;</li>

      <li>we simplify the definition by removing the explicit evaluation domain and just sampling points randomly from the field (in both our construction and the one in <em>[GKO^{+}23]</em> this is sufficient for security because of the asymptotic size of the field);</li>

      <li>we removed bounded independence as an essential property of polynomial encoding schemes. This is used in <em>[GKO^{+}23]</em> to prove <span class="math">\\phi</span>-evaluation hiding, but we do not need it.</li>

    </ul>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">B.2 The compiler <span class="math">\\boldsymbol{\\Pi_{\\textsf{GKOPTT}}}</span> of <em>[GKO^{+}23]</em> in an RO-only world.</h3>

    <p class="text-gray-300">In this section, we describe the compiler, UC protocol <span class="math">\\Pi_{\\textsf{GKOPTT}}</span>, of <em>[GKO^{+}23]</em> for NP-relation <span class="math">\\mathcal{R}</span>. This section is taken almost verbatim from <em>[GKO^{+}23]</em> with the adjustments related to our instantiations based on the random oracle with transparent setups and to other cosmetic changes as pointed out in Section 5. Specifically, recall that the compiler makes use of the following tools:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Pi_{\\textsf{NIZK}}</span> be a simulation-extractable NIZK in the RO model (Definition 7), for the relation <span class="math">\\mathcal{R}_{\\textsf{NIZK}}=\\{((x,\\textsf{ck},n,\\ell),(w,\\boldsymbol{\\rho}_{w})):(x,w)\\in\\mathcal{R}\\wedge c=\\textsf{Com}\\left(\\textsf{ck},\\textsf{Enc}\\left(\\mathbf{w},n,\\ell;\\boldsymbol{\\rho}_{w}\\right)\\right)\\}</span> where <span class="math">\\mathbf{w}</span> denotes the witness <span class="math">w</span> parsed as a vector of field elements in <span class="math">\\mathbb{F}^{n}</span>.</li>

      <li>Let <span class="math">\\Pi_{\\textsf{PCS}}</span> be a polynomial commitment scheme with evaluation binding, unique proofs (Definition 11), <span class="math">\\phi</span>-evaluation hiding (Definition 14), and supports <span class="math">\\phi</span>-non-extrapolation (Definition 15) with respect to the encoding scheme <span class="math">PES=\\left(\\textsf{Enc},\\textsf{Dec}\\right)</span> (Definition 13).</li>

    </ul>

    <p class="text-gray-300">Protocol parameters. The protocol is parameterized by:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Security parameter <span class="math">\\lambda</span></li>

      <li>Finite field <span class="math">\\mathbb{F}</span></li>

      <li>Evaluation hiding factor <span class="math">\\phi:\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}</span> and stretch <span class="math">\\textsf{stretch}:\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}</span></li>

      <li>Number of parallel repetitions <span class="math">r=r(\\lambda)&gt;0</span></li>

      <li>Proof-of-work parameter <span class="math">b(\\lambda)&gt;0</span></li>

      <li>Bound <span class="math">T(\\lambda)&gt;0</span></li>

      <li>Maximum degree bound <span class="math">D&gt;0</span> for <span class="math">\\Pi_{\\textsf{PCS}}</span></li>

    </ol>

    <p class="text-gray-300">Protocol description. The protocol in UC is formulated with <span class="math">\\mathcal{F}_{\\text{RO}}</span> as its hybrid functionality, which is the usual UC RO functionality. We use the notation <span class="math">\\mathcal{F}_{\\text{RO}}</span> to clearly distinguish it from a global random oracle used in other parts of this work. Furthermore, the underlying NIIZK <span class="math">\\Pi_{\\textsf{NIZK}}</span> is defined in the standalone model w.r.t. to a random oracle which is denoted <span class="math">\\mathcal{H}</span> as per Definitions in Section 2.3. Not surprisingly, the UC protocol will use its hybrid functionality to answer the RO-invocations made by <span class="math">\\Pi_{\\textsf{NIZK}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof: On input (prove, sid, <span class="math">x,w</span>), ignore if <span class="math">(x,w)\\notin\\mathcal{R}</span>; otherwise, <span class="math">\\mathrm{P}_{i}</span> does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (query, (sid, <span class="math">x,\\textsf{genparamsproof})</span>) to <span class="math">\\mathcal{F}_{\\text{RO}}</span> receiving back pp.</li>

      <li>Send (query, (sid, <span class="math">x,\\textsf{genparamspc})</span>) to <span class="math">\\mathcal{F}_{\\text{RO}}</span> receiving back ck.</li>

      <li>Parse <span class="math">w=\\mathbf{w}\\in\\mathbb{F}^{n}</span>. Let <span class="math">\\ell:=\\phi(\\lambda,n,r)</span> and <span class="math">d:=\\textsf{stretch}(\\lambda,n,\\ell)+n</span>. If <span class="math">d&gt;D</span>, abort by outputting (proof, sid, <span class="math">\\bot</span>).</li>

      <li>Generate a polynomial encoding of the witness vector: <span class="math">f\\leftarrow\\textsf{Enc}\\left(1^{\\lambda},\\mathbf{w},n,\\ell;\\boldsymbol{\\rho}_{w}\\right)</span>, where <span class="math">\\boldsymbol{\\rho}_{w}\\leftarrow\\mathbb{F}^{\\ell}</span>.</li>

      <li>Generate a commitment to the polynomial encoding: <span class="math">\\textsf{cm}\\leftarrow\\textsf{Com}\\left(\\textsf{ck},f\\right)</span></li>

      <li>Run the prover <span class="math">\\mathcal{P}</span> of <span class="math">\\Pi_{\\textsf{NIZK}}</span> on input <span class="math">x^{\\prime}=\\left(\\textsf{pp},(x,\\textsf{ck},n,\\ell)\\right)</span> and <span class="math">w^{\\prime}=(w,\\boldsymbol{\\rho}_{w})</span> to obtain a proof <span class="math">\\pi^{\\prime}</span>. Whenever <span class="math">\\mathcal{P}</span> makes a call to <span class="math">\\mathcal{H}</span> with input in, send (query, (sid, in, proof)) to <span class="math">\\mathcal{F}_{\\text{RO}}</span> to receive a response out which is forwarded to <span class="math">\\mathcal{P}</span>.</li>

      <li>Initialize empty sets <span class="math">\\mathbf{z},\\mathbf{y}</span>, and <span class="math">\\boldsymbol{\\pi}_{\\text{PCS}}</span>.</li>

      <li>For each iteration <span class="math">i\\in[r]</span> do:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize counter <span class="math">\\textsf{ctr}:=0</span> and set of used evaluation points <span class="math">\\mathcal{D}_{i}:=\\emptyset</span>.</li>

      <li>If <span class="math">\\textsf{ctr}=T</span>, abort by outputting (proof, sid, runout_eval).</li>

      <li>Sample an evaluation point: <span class="math">z_{i}\\leftarrow\\textsf{s}\\;\\mathbb{F}\\backslash\\mathcal{D}_{i}</span>. Update <span class="math">\\textsf{ctr}:=\\textsf{ctr}+1</span>. Update <span class="math">\\mathcal{D}_{i}:=\\mathcal{D}_{i}\\cup\\{z_{i}\\}</span>.</li>

    </ol>

    <h2 id="sec-62" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">(d) Compute <span class="math">y_{i} = f(z_{i})</span> and evaluation proof <span class="math">\\pi_i \\gets \\text{Eval}(\\mathsf{ck}, \\mathsf{cm}, z_i, y_i, f)</span>, whenever Eval makes a call to <span class="math">\\mathcal{H}</span> with input in, send (QUERY, (sid, in, proofpcs)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span> to receive a response out, forwarded to Eval. (e) Send (QUERY, (sid, <span class="math">(\\mathcal{C}&#x27;, \\mathsf{cm}, z_i, y_i, \\pi_i, i)</span>)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span>. Upon receiving <span class="math">v</span> from <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span>, if the first <span class="math">b</span> bits of <span class="math">v</span> are not <span class="math">0^b</span>, go to step 8b. Otherwise, store <span class="math">z_i, y_i</span>, and <span class="math">\\pi_i</span> in <span class="math">\\mathbf{z}, \\mathbf{y}</span>, and <span class="math">\\pi_{\\mathrm{PCS}}</span>, respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output (PROOF, sid, <span class="math">\\pi</span>), where <span class="math">\\pi := (\\pi&#x27;, \\mathsf{cm}, \\mathbf{z}, \\mathbf{y}, \\pi_{\\mathrm{PCS}})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification: Upon receiving input (VERIFY, sid, <span class="math">\\mathcal{C}</span>, <span class="math">\\pi</span>), <span class="math">P_i</span> does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid, <span class="math">x</span>, genparamsproof)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span> receiving back pp.</li>

      <li>Send (QUERY, (sid, <span class="math">x</span>, genparamspc)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span> receiving back ck.</li>

      <li>Parse <span class="math">\\pi = (\\pi&#x27;, \\mathsf{cm}, \\mathbf{z}, \\mathbf{y}, \\pi_{\\mathrm{PCS}})</span>. Derive the witness size <span class="math">n</span> from the description of <span class="math">\\mathcal{C}</span>. Compute <span class="math">\\ell</span> and <span class="math">d</span> as Proof would and if <span class="math">d &amp;gt; D</span> abort by outputting (VERIFICATION, sid, 0).</li>

      <li>Define the statement <span class="math">x&#x27;</span> as the Proof step would.</li>

      <li>Parse <span class="math">\\mathbf{z} = (z_i)_{i\\in [r]},\\mathbf{y} = (y_i)_{i\\in [r]}</span>, and <span class="math">\\pi_{\\mathrm{PCS}} = (\\pi_i)_{i\\in [r]}</span>.</li>

      <li>Output (VERIFICATION, sid,1) if all of the following checks pass, otherwise output (VERIFICATION, sid, 0):</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\Pi_{\\mathcal{R}} \\cdot \\mathcal{V}(\\mathsf{pp}, x&#x27;, \\pi&#x27;)</span> outputs 1. (Calls to <span class="math">\\mathcal{H}</span> by <span class="math">\\mathcal{V}</span> handled like above). (b) For all <span class="math">i \\in [r] : 1 = \\text{Check}(\\mathsf{ck}, \\mathsf{cm}, d, z_i, y_i, \\pi_i)</span>, whenever Check makes a call to <span class="math">\\mathcal{H}</span> with input in, send (QUERY, (sid, in, checkpcs)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span> to receive a response out which is forwarded to Check. (c) For all <span class="math">i \\in [r]</span>: send (QUERY, (sid, <span class="math">(\\mathcal{C}&#x27;, \\mathsf{cm}, z_i, y_i, \\pi_i, i)</span>)) to <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span>, and the first <span class="math">b</span> bits of the return value <span class="math">v_i</span> are <span class="math">0^b</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> The above compiler adapted from [GKO+23] to the RO-only world preserves UC-security.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First, we observe that the definition of simulation-extractability in Definition 7 that we assume above is slightly different from the one used in [GKO+23], as we are in the random oracle model and we let the extractor access the adversary in a black-box way (instead of providing the code to the extractor). We observe that the original proof is not affected by this change: this is because their results hold in the RO and the only point in the proof where they rely on simulation extractability property is in a reduction where the random oracle can be programmed accordingly.[20]</p>

    <p class="text-gray-300">Finally, we also observe that their simulator can be modified to work in the RO-only world. From the description of the simulator-extractor of <span class="math">\\Pi_{\\mathrm{GKOPTT}}</span> at page 18 (Figure 5) of the full-version of [GKO+23], it is possible to conclude that the extraction relies on the observability of the random oracle, which is obviously true for our RO-only version of the compiler, since we only need the RO to be local. Furthermore, the simulator relies on the simulator of the underlying <span class="math">\\Pi_{\\mathrm{NIZK}}</span>. While in [GKO+23], this is based on an extra functionality <span class="math">\\mathcal{F}_{\\mathrm{Setup}}</span>, we simply emulate that functionality using the local RO. This is fine, since our building blocks are defined w.r.t. the random oracle only.</p>

    <h2 id="sec-63" class="text-2xl font-bold">C Our Polynomial Encoding Scheme</h2>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">C.1 Further leakage-resilience properties of additive secret sharing</h3>

    <p class="text-gray-300">In this section we describe and prove some properties that will be useful to prove security of our polynomial encoding scheme (both alone and when combined with our polynomial commitment). The set of properties we will rely on can be described as a form of leakage-resilience of the secret sharing scheme when the adversary is allowed to query (appropriately distributed) linear combinations of the shares.</p>

    <p class="text-gray-300">We start by defining the following game.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 26 (Linear leakage resilience).</strong> Let <span class="math">\\mathsf{adm} : \\{0,1\\}^* \\to \\{0,1\\}</span> be a predicate (which we will call it "admissibility" predicate from now on). Let <span class="math">\\mathsf{SS}</span> be the secret sharing scheme in Definition 2. Let <span class="math">(\\mathbb{F}_{\\lambda})_{\\lambda \\in \\mathbb{N}}</span> be a family of finite fields such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in O(2^{\\lambda})<span class="math">. We say that </span>\\mathsf{SS}<span class="math"> is resistant against </span>\\mathsf{adm}<span class="math">-linear leakage if for any (possibly unbounded) </span>\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)<span class="math"> for any </span>\\lambda \\in \\mathbb{N}<span class="math">, </span>\\ell \\geq 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {G} _ {S S - l i n} (\\mathcal {A}, \\lambda , \\ell) = 1 \\right] \\leq \\frac {1}{2} + \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">[20] This was confirmed by private communication with the authors. Note also that at page 20 of the full version of [GKO+23] it is indeed discussed that their result can be instantiated using [BBB+18], which satisfies the above definition as proven in [DG23].</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{G}_{SS - lin}</span>  is described in Fig. 8 and we use  <span class="math">\\mathbb{F}_{\\lambda}</span>  as a field for SS.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 8: Game  <span class="math">\\mathcal{G}_{\\mathrm{SS - lin}}</span></p>

    <p class="text-gray-300">We now provide a definition that will make more sense in light the proof of Lemma 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 27. Let  $\\Theta = (\\pmb{\\theta}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{\\theta}^{(\\ell)})<span class="math">  be the queries made by an adversary during an execution of  </span>\\mathcal{G}_{SS - lin}<span class="math">  (Fig. 8) where for each  </span>i\\in [\\ell ]<span class="math"> </span>\\pmb{\\theta}^{(i)}\\in \\mathbb{F}^{\\ell +1}<span class="math">  Consider the following  </span>\\ell<span class="math">  -by-  </span>\\ell<span class="math">  matrix  </span>M_{\\Theta}$  ..</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">We define the admissibility predicate  <span class="math">\\mathsf{adm}_{\\text{det}}</span>  as the one that is true iff  <span class="math">\\det(M_{\\Theta}) \\neq 0</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 3. Let  <span class="math">(\\mathbb{F}_{\\lambda})_{\\lambda \\in \\mathbb{N}}</span>  be a family of finite fields such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(2^{\\lambda})<span class="math">  and let SS be defined as in Definition 2 and  </span>\\mathsf{adm}_{\\text{det}}<span class="math">  as in Definition 27. Then SS is resistant against  </span>\\mathsf{adm}_{\\text{det}}$ -linear leakage.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Consider the adversary's oracle queries  <span class="math">\\pmb{\\theta}^{(1)},\\dots,\\pmb{\\theta}^{(\\ell)}</span>  in the game in Fig. 8. For each  <span class="math">i\\in [\\ell ]</span> , let  <span class="math">\\pmb{\\theta}^{(i)} = \\left(\\theta_1^{(i)},\\dots,\\theta_{\\ell +1}^{(i)}\\right)</span> . By definition of the sharing algorithm in SS, after the  <span class="math">i</span> -th query, the adversary receives</p>

    <div class="my-4 text-center"><span class="math-block">y ^ {(i)} = \\left(\\theta_ {1} ^ {(i)} + \\theta_ {\\ell + 1} ^ {(i)}\\right) \\cdot s _ {1} + \\dots \\left(\\theta_ {\\ell} ^ {(i)} + \\theta_ {\\ell + 1} ^ {(i)}\\right) \\cdot s _ {\\ell} + \\theta_ {\\ell + 1} ^ {(i)} s ^ {\\prime}</span></div>

    <p class="text-gray-300">In order to prove our statement, we proceed as it is common in secret sharing: we claim that for any guess on  <span class="math">s&#x27;</span>  a certain system of equations defined by the linear combination queries will always have exactly one solution. This allows us to claim that the information received by the adversaries does not allow them to discern among different possible values of  <span class="math">s&#x27;</span> . Thus, for each  <span class="math">i</span> , let  <span class="math">\\hat{y}^{(i)} \\coloneqq y^{(i)} - \\theta_{\\ell + 1}^{(i)} s&#x27;</span>  and consider the following system of equations:</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">Notice that the <span class="math">\\ell</span>-by-<span class="math">\\ell</span> matrix <span class="math">M</span> on the left in Eq. (1) is the transpose of the one defined in Definition 27. This allows us to conclude that the system of equations above admits exactly one solution (regardless of the value of <span class="math">s^{\\prime}</span>) if and only if <span class="math">\\det(M)\\neq 0</span>. Observing that the latter property matches the definition of <span class="math">\\mathsf{adm}_{\\mathrm{det}}</span> in Definition 27 concludes the proof. ∎</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">C.2 Further Analysis of <span class="math">\\mathsf{adm}_{\\mathrm{det}}</span>-Linear Leakage</h3>

    <p class="text-gray-300">In this section we make further observations on the structure of <span class="math">\\mathsf{adm}_{\\mathrm{det}}</span> (Definition 27). In particular we will observe when the matrix <span class="math">M_{\\Theta}</span> in Eq. (1) has a non-zero determinant.</p>

    <p class="text-gray-300">Recall that if we add or subtract a multiple of a row/column from a matrix, its determinant will not change. We then first subtract the first row from all others obtaining:</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}\\theta_{1}^{(1)}+\\theta_{\\ell+1}^{(1)}&\\theta_{1}^{(2)}+\\theta_{\\ell+1}^{(2)}&\\cdots&\\theta_{1}^{(\\ell-1)}+\\theta_{\\ell+1}^{(\\ell-1)}&\\theta_{1}^{(\\ell)}+\\theta_{\\ell+1}^{(\\ell)}\\\\ \\theta_{2}^{(1)}-\\theta_{1}^{(1)}&\\theta_{2}^{(2)}-\\theta_{1}^{(2)}&\\cdots&\\theta_{2}^{(\\ell-1)}-\\theta_{1}^{(\\ell-1)}&\\theta_{2}^{(\\ell)}-\\theta_{1}^{(\\ell)}\\\\ \\vdots&\\ddots&\\ddots&\\ddots&\\vdots\\\\ \\theta_{\\ell-1}^{(1)}-\\theta_{1}^{(1)}&\\theta_{\\ell-1}^{(2)}-\\theta_{1}^{(2)}&\\cdots&\\theta_{\\ell-1}^{(\\ell-1)}-\\theta_{1}^{(\\ell-1)}&\\theta_{\\ell-1}^{(\\ell)}-\\theta_{1}^{(\\ell)}\\\\ \\theta_{\\ell}^{(1)}-\\theta_{1}^{(1)}&\\theta_{\\ell}^{(2)}-\\theta_{1}^{(2)}&\\cdots&\\theta_{\\ell}^{(\\ell-1)}-\\theta_{1}^{(\\ell-1)}&\\theta_{\\ell}^{(\\ell)}-\\theta_{1}^{(\\ell)}\\end{pmatrix} \\] (2)</p>

    <p class="text-gray-300">We can then apply Laplace expansion to the first row and observe that:</p>

    <p class="text-gray-300"><span class="math">\\det(M_{\\Theta})=\\sum_{k\\in[\\ell]}(-1)^{k+1}\\cdot\\left(\\theta_{1}^{(k)}+\\theta_{\\ell+1}^{(k)}\\right)\\cdot\\det(M_{\\Theta,(1,k)})</span></p>

    <p class="text-gray-300">where <span class="math">M_{\\Theta,(1,k)}</span> is defined as the matrix obtained removing the first row and the <span class="math">k</span>-th column in <span class="math">M_{\\Theta}</span>. By continuing expanding each minor one row at the time we can convince ourselves that <span class="math">\\det(M_{\\Theta})</span> has the following form:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\pi}\\pm\\left(\\theta_{1}^{(\\pi(1))}+\\theta_{\\ell+1}^{(\\pi(1))}\\right)\\left(\\theta_{2}^{(\\pi(2))}-\\theta_{1}^{(\\pi(2))}\\right)\\ldots\\left(\\theta_{\\ell}^{(\\pi(\\ell))}-\\theta_{1}^{(\\pi(\\ell))}\\right)</span> (1)</p>

    <p class="text-gray-300">where above <span class="math">\\pi</span> is enumerated over all possible permutations of <span class="math">[\\ell]</span> and <span class="math">\\pm</span> denotes a plus or minus sign that is a function of <span class="math">\\pi</span> (we leave it unspecified since it will not be necessary for our observations later on).</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">C.3 Secret-Sharing Based Polynomial Encoding Scheme</h3>

    <p class="text-gray-300">We are now ready to describe our polynomial encoding scheme. We apply a different encoding scheme (see Definition 13) than the one in the work in <em>[GKO^{+}23]</em>. The reason is that we will need additional properties, namely that the adversary cannot learn any useful information by a bounded number of (appropriately distributed) linear combinations of the coefficients of the output of the encoding. Our polynomial encoding scheme can be seen as defining a polynomial whose coefficients are partly the output of a secret sharing of a secret key, partly ciphertexts of the original string to be encoded (plus the public key).</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition 28 (Secret-Sharing Based Encoding).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PKE}</span> be a public-key encryption scheme and let <span class="math">\\mathsf{SS}</span> be a secret sharing scheme, then we define <span class="math">\\mathsf{PES}_{ss}=(\\mathsf{Enc},\\mathsf{Dec})</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Enc}(1^{\\lambda},\\mathsf{w},n,\\ell):</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{(pk,sk)}\\leftarrow\\mathsf{PKE.KG}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{ct_{w}}\\leftarrow\\mathsf{PKE.Enc(pk,w)}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{s}\\leftarrow\\mathsf{SS.Share}(\\ell+1,\\mathsf{sk})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $d:=\\ell+1+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ct_{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f(X):=\\sum_{0\\leq i&lt;d}f_{i+1}X^{i}</span> where $\\mathbf{f}:=(\\mathsf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{ct_{w}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">return <span class="math">f</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Dec}(1^{\\lambda},f,n,\\ell):</span></li>

    </ul>

    <p class="text-gray-300">// the sizes of the subvectors below is known</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parse the coefficients of  <span class="math">f</span>  as  $\\mathbf{f} = (\\mathbf{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{p}\\mathbf{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{c}\\mathbf{t}_{\\mathbf{w}})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{sk}\\gets \\mathbf{SS}.\\mathbf{Reconstr}(\\ell ,\\mathbf{s})</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{w}\\gets \\mathrm{PKE}.Dec(\\mathbf{sk},\\mathbf{ct}_{\\mathbf{w}})</span></p>

    <p class="text-gray-300">return w</p>

    <p class="text-gray-300">The stretch is  <span class="math">\\operatorname{stretch}(\\lambda, n, \\ell) = (\\ell + 1) + \\kappa + n&#x27;(n) - n</span> , where  <span class="math">\\kappa</span>  and  <span class="math">n&#x27;</span>  are as in Definition 1 (i.e., they are respectively the size of the public key and of the ciphertext in field elements).</p>

    <p class="text-gray-300">Proof. Correctness. Correctness follows immediately from the completeness of the BP-IPA construction and by inspection: we are reducing polynomial evaluation to checking the inner product between the coefficient of the polynomial (vector  <span class="math">\\mathbf{a}</span> ) and the vector of powers of the evaluation point (vector  <span class="math">\\mathbf{b}</span> ).</p>

    <p class="text-gray-300">Evaluation binding. To show evaluation binding, consider an adversary  <span class="math">\\mathcal{A}</span>  providing a tuple  <span class="math">(\\mathsf{cm},z,y,\\pi ,y^{\\prime},\\pi^{\\prime})</span>  In order for the adversary to win in the experiment the following conditions need to hold:  <span class="math">y\\neq y^{\\prime}</span>  BP-IPAFS.Verify  <span class="math">(\\mathsf{ck},P,\\pi) = 1</span>  BP-IPAFS.Verify  <span class="math">(\\mathsf{ck},P^{\\prime},\\pi^{\\prime}) = 1</span>  , where  <span class="math">P = \\mathsf{cm}\\cdot \\mathbf{h}^{\\mathbf{b}}u^{y}</span> <span class="math">P^{\\prime} = \\mathsf{cm}\\cdot \\mathbf{h}^{\\mathbf{b}}u^{y^{\\prime}}</span> <span class="math">\\mathbf{b} = (z^0,\\dots ,z^{d - 1})</span></p>

    <p class="text-gray-300">Now consider the following adversary for the DLOG experiment (Assumption 1) for  <span class="math">2n + 1</span>  generators  <span class="math">g_{1},\\ldots ,g_{n},h_{1},\\ldots ,h_{n},u</span> :</p>

    <pre><code class="language-latex">$\\mathcal{A}_{\\mathrm{DLOG}}(\\mathbb{G},g_1,\\ldots ,g_n,h_1,\\ldots ,h_n,u)$
Let  $\\mathsf{ck}\\coloneqq (\\mathbf{g},\\mathbf{h},u)$ $(\\mathsf{cm},z,y,\\pi ,y^{\\prime},\\pi^{\\prime})\\gets \\mathcal{A}(\\mathsf{ck})$ $(\\hat{\\mathbf{a}},\\hat{\\mathbf{b}})\\gets \\mathcal{B}(\\mathsf{ck},\\mathsf{cm},z,y,\\pi)$ $(\\hat{\\mathbf{a}}^{\\prime},\\hat{\\mathbf{b}}^{\\prime})\\gets \\mathcal{B}^{\\prime}(\\mathsf{ck},\\mathsf{cm},z,y^{\\prime},\\pi^{\\prime})$
Let  $\\mathbf{a}&#x27;&#x27;\\coloneqq \\hat{\\mathbf{a}} -\\hat{\\mathbf{a}} &#x27;$
Let  $y&#x27;&#x27;\\coloneqq \\hat{y} -\\hat{y}&#x27; - y + y&#x27;$  where  $\\hat{y}\\coloneqq \\langle \\hat{\\mathbf{a}},\\hat{\\mathbf{b}}\\rangle ,\\hat{y} &#x27;\\coloneqq \\langle \\hat{\\mathbf{a}}&#x27;,\\hat{\\mathbf{b}} &#x27;\\rangle$
Let  $\\mathbf{b}&#x27;&#x27;\\coloneqq \\hat{\\mathbf{b}} -\\hat{\\mathbf{b}} &#x27;$
Return  $\\left(\\mathbf{a}&#x27;&#x27;||\\mathbf{b}&#x27;&#x27;||y&#x27;&#x27;\\right)$</code></pre>

    <p class="text-gray-300">Above  <span class="math">\\mathcal{B}</span>  (resp.  <span class="math">\\mathcal{B}&#x27;</span> ) compute  <span class="math">P \\gets \\mathsf{cm} \\cdot \\mathbf{h}^{\\mathbf{b}} u^{y}</span>  (resp.  <span class="math">P \\gets \\mathsf{cm} \\cdot \\mathbf{h}^{\\mathbf{b}} u^{y&#x27;}</span> ) where  <span class="math">\\mathbf{b} = (z^0, \\ldots, z^{d-1})</span>  and return the output of the BP-IPA extractor  <span class="math">\\mathcal{E}_{\\mathrm{BP - IPA_{FL}}}</span>  on  <span class="math">(P, \\pi)</span>  (resp.  <span class="math">(P&#x27;, \\pi&#x27;)</span> ).</p>

    <p class="text-gray-300">Throughout the remainder of this proof we will make use of this fact: if  <span class="math">\\operatorname<em>{Pr}[A]</span>  is non-negligible then it must be that  <span class="math">\\operatorname</em>{Pr}[A \\wedge B]</span>  is non-negligible or  <span class="math">\\operatorname*{Pr}[A \\wedge \\neg B]</span>  is non-negligible.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{E}^<em></span>  the event "A winning the evaluation binding game". Now assume  <span class="math">\\mathcal{A}</span>  breaks evaluation binding, that is  <span class="math">\\operatorname</em>{Pr}[\\mathbf{E}^*]</span>  is non-negligible. We consider two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1:  <span class="math">\\operatorname<em>{Pr}[\\hat{\\mathbf{a}} = \\hat{\\mathbf{a}}&#x27; \\wedge \\mathbf{E}^</em>]</span>  is non-negligible: We now consider two sub-cases:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 1a:  <span class="math">\\operatorname<em>{Pr}[\\hat{\\mathbf{a}} = \\hat{\\mathbf{a}}&#x27; \\wedge \\hat{\\mathbf{b}} = \\hat{\\mathbf{b}}&#x27; \\wedge \\mathbf{E}^</em>]</span>  is non-negligible: We can show that this case leads to a contradiction as follows. First, observe that whenever  <span class="math">\\mathcal{A}</span>  wins the evaluation binding game we have that  <span class="math">P \\neq P&#x27;</span>  by their definition in the polynomial commitment verifier. Therefore  $\\operatorname*{Pr}[P \\neq P'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{E}^<em>] = 1<span class="math"> . We proceed to show a contradiction by showing that  </span>\\operatorname</em>{Pr}[P = P'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{E}^*] &gt; 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observation: that whenever the extractors work correctly we have that  <span class="math">\\hat{\\mathbf{a}} = \\hat{\\mathbf{a}}&#x27; \\wedge \\hat{\\mathbf{b}} = \\hat{\\mathbf{b}}&#x27;</span>  implies  <span class="math">P = P&#x27;</span>  since:</p>

    <div class="my-4 text-center"><span class="math-block">P = \\mathbf {g} ^ {\\hat {\\mathbf {a}}} \\cdot \\mathbf {h} ^ {\\mathbf {b}} \\cdot u ^ {\\langle \\hat {\\mathbf {a}}, \\mathbf {b} \\rangle} \\wedge P ^ {\\prime} = \\mathbf {g} ^ {\\hat {\\mathbf {a}}} \\cdot \\mathbf {h} ^ {\\mathbf {b}} \\cdot u ^ {\\langle \\hat {\\mathbf {a}}, \\mathbf {b} \\rangle}</span></div>

    <p class="text-gray-300">Let us denote by  <span class="math">\\mathbf{E}_{\\mathrm{ext}}</span>  the event that extractor works correctly when invoked both in  <span class="math">\\mathcal{B}</span>  and in  <span class="math">\\mathcal{B}&#x27;</span> . By knowledge soundness we know that  <span class="math">\\operatorname<em>{Pr}[\\mathbf{E}_{\\mathrm{ext}}]</span>  is overwhelming. Notice that  <span class="math">\\operatorname</em>{Pr}[P = P&#x27;] &amp;gt; 0</span></p>

    <p class="text-gray-300">implies that <span class="math">\\operatorname{Pr}[P = P&#x27; \\mid \\mathbf{E}^*]</span>. We observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[P = P&#x27;] \\geq \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}_{\\text{ext}}] = \\tag{4}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\mid \\mathbf{E}_{\\text{ext}}] \\cdot \\operatorname{Pr}[\\mathbf{E}_{\\text{ext}}] \\geq \\tag{5}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\mid \\mathbf{E}_{\\text{ext}}] - \\text{negl} \\tag{6}</span></div>

    <p class="text-gray-300">where the first inequality follows from the first observation; the last inequality follows from knowledge soundness. It remains now to show that <span class="math">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\mid \\mathbf{E}_{\\text{ext}}]</span> is non-negligible. Recall that by hypothesis <span class="math">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}^*]</span> is non-negligible. Let us denote the latter probability by <span class="math">\\mu</span>. Then:</p>

    <div class="my-4 text-center"><span class="math-block">\\mu = \\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\mid \\mathbf{E}_{\\text{ext}}] \\cdot \\operatorname{Pr}[\\mathbf{E}_{\\text{ext}}] + \\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}^* \\wedge \\mathbf{E}_{\\text{ext}}]</span></div>

    <p class="text-gray-300">By applying knowledge soundness and denoting through <span class="math">\\epsilon</span> and <span class="math">\\epsilon&#x27;</span> two negligible functions, the above implies:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} = \\mathbf{\\hat{b}}&#x27; \\mid \\mathbf{E}_{\\text{ext}}] = \\frac{\\mu - \\epsilon}{\\operatorname{Pr}[\\mathbf{E}_{\\text{ext}}]} \\\\ = \\frac{\\mu}{\\operatorname{Pr}[\\mathbf{E}_{\\text{ext}}]} - \\epsilon&#x27; \\\\ \\geq \\mu - \\epsilon&#x27; \\\\ \\geq \\text{non-negligible} \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1b: <span class="math">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}&#x27; \\wedge \\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}^<em>]</span> is non-negligible: Under the assumptions of case 1b, we can show the following: if <span class="math">\\mathcal{A}</span> wins the evaluation-binding game with non-negligible probability <span class="math">p^</em></span>, then <span class="math">\\mathcal{A}_{\\text{DLOG}}</span> wins the DLOG game with non-negligible probability. In order to see this, it is sufficient to combine the following two claims:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Claim (i): if <span class="math">p^<em></span> is non-negligible then <span class="math">\\operatorname{Pr}[\\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}^</em>]</span> is non-negligible</li>

      <li>Claim (ii): the winning probability of <span class="math">\\mathcal{A}_{\\text{DLOG}}</span> is negligibly close to <span class="math">\\operatorname{Pr}[\\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}&#x27; \\wedge \\mathbf{E}^*]</span>.</li>

    </ul>

    <p class="text-gray-300">To prove Claim (i), it is sufficient to observe that:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\operatorname{Pr}[\\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}' \\wedge \\mathbf{E}^*] = \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[\\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{E}^<em>] \\cdot \\operatorname{Pr}[\\mathbf{E}^</em>] \\geq \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\operatorname{Pr}[\\mathbf{\\hat{a}} = \\mathbf{\\hat{a}}' \\wedge \\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}' \\mid \\mathbf{E}^<em>] \\cdot \\operatorname{Pr}[\\mathbf{E}^</em>] \\\\ \\left(\\frac{1}{q(\\lambda)}\\right) \\cdot p^* \\geq \\text{non-negligible} \\end{array} $$</p>

    <p class="text-gray-300">were <span class="math">q</span> is some polynomial in <span class="math">\\lambda</span>. We now prove Claim (ii). We first observe that, by knowledge-soundness of BP-IPA the following holds with overwhelming probability:</p>

    <div class="my-4 text-center"><span class="math-block">P = \\mathbf{g}^{\\mathbf{\\hat{a}}} \\cdot \\mathbf{h}^{\\mathbf{\\hat{b}}} \\cdot u^{\\hat{y}} \\wedge P&#x27; = \\mathbf{g}^{\\mathbf{\\hat{a}}&#x27;} \\cdot \\mathbf{h}^{\\mathbf{\\hat{b}}&#x27;} \\cdot u^{\\hat{y}&#x27;} \\tag{7}</span></div>

    <p class="text-gray-300">where all variables are as defined in the code of <span class="math">\\mathcal{A}_{\\text{DLOG}}</span>. Applying Eq. (7) we can conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{P}{P&#x27;} = \\mathbf{g}^{\\mathbf{a}&#x27;&#x27;} \\cdot \\mathbf{h}^{\\mathbf{b}&#x27;&#x27;} \\cdot u^{\\hat{y} - \\hat{y}&#x27;} \\tag{8}</span></div>

    <p class="text-gray-300">At the same time, by construction of the polynomial commitment verifier we know that:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{P}{P&#x27;} = \\frac{\\operatorname{cm} \\cdot \\mathbf{h}^{\\mathbf{b}} \\cdot u^y}{\\operatorname{cm} \\cdot \\mathbf{h}^{\\mathbf{b}} \\cdot u^{y&#x27;}} = u^{y - y&#x27;} \\tag{9}</span></div>

    <p class="text-gray-300">Combining Eq. (8) and Eq. (9) we can conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{g}^{\\mathbf{a}&#x27;&#x27;} \\cdot \\mathbf{h}^{\\mathbf{b}&#x27;&#x27;} \\cdot u^{\\hat{y} - \\hat{y}&#x27; - y + y&#x27;} = \\mathbf{g}^{\\mathbf{a}&#x27;&#x27;} \\cdot \\mathbf{h}^{\\mathbf{b}&#x27;&#x27;} \\cdot u^{y&#x27;&#x27;} = 1_{\\mathbb{G}} \\tag{10}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, we observe that whenever <span class="math">\\mathcal{A}</span> wins the evaluation binding game and <span class="math">\\mathbf{\\hat{b}} \\neq \\mathbf{\\hat{b}}&#x27;</span> at least one entry in the vector $(\\mathbf{a}''</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}''</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y'')$ will be non-zero, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">42</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">\\Pr[\\mathbf{\\hat{a}}\\neq\\mathbf{\\hat{a}}^{\\prime}\\wedge\\mathbf{E}^{<em>}]</span> is non-negligible: here we reason similarly to case 1b and argue that the winning probability of <span class="math">\\mathcal{A}_{\\text{DLOG}}</span> is negligibly close to <span class="math">\\Pr[\\mathbf{\\hat{a}}\\neq\\mathbf{\\hat{a}}^{\\prime}\\wedge\\mathbf{E}^{</em>}]</span>.</li>

    </ul>

    <p class="text-gray-300">Unique-Response. Unique-response (Definition 12) follows directly from the 0-unique-response property of <span class="math">\\mathsf{BP\\text{-}IPA_{FS}}</span> (Theorem 4).</p>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">D.2 Proof of Theorem 6</h3>

    <p class="text-gray-300">The theorem follows directly by combining the following two results (proved in the rest of this section).</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">The construction <span class="math">\\mathsf{BP\\text{-}PC}</span> is <span class="math">\\phi</span>-evaluation hiding with respect to the PES from Section 5.2 under DLOG and the existence of an mildly compact PKE, where <span class="math">\\phi</span> satisfies the bound <span class="math">\\phi(\\lambda,n,r)&gt;1+2r\\left(1+2\\lceil\\log(\\phi(\\lambda,n,r)+7\\lambda n)\\rceil\\right)</span>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">The construction <span class="math">\\mathsf{BP\\text{-}PC}</span> satisfies <span class="math">\\phi</span>-non-extrapolation with respect to the PES from Section 5.2 under DLOG and the existence of an mildly compact PKE, where <span class="math">\\phi</span> satisfies the bound <span class="math">\\phi(\\lambda,</span> <span class="math">n,r)&gt;1+2r\\left(1+2\\lceil\\log(\\phi(\\lambda,n,r)+7\\lambda n)\\rceil\\right)</span>.</p>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">D.3 Proof of Theorem 8</h3>

    <h6 id="sec-74" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an adversary <span class="math">\\mathcal{A}_{\\phi}=(\\mathcal{A}_{\\phi,1},\\mathcal{A}_{\\phi,2})</span> against the <span class="math">\\phi</span>-evaluation game. We define a series of hybrids. The first hybrid <span class="math">\\mathcal{H}_{0}</span> (Fig. 9) corresponds to the <span class="math">\\phi</span>-hiding game where we encode the vector <span class="math">\\mathbf{w}</span> provided by the adversary. We fully expand the encoding step of the polynomial encoding scheme since this is where the changes will occur between hybrids. The last hybrid <span class="math">\\mathcal{H}_{3}</span> (Fig. 9) corresponds to the same game as <span class="math">\\mathcal{H}_{0}</span> but where we encode the vector of all zeros instead of what is provided by the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{1}</span> : the difference between these two games has to do with the coefficients of <span class="math">f</span> from secret sharing: in one case (<span class="math">\\mathcal{H}_{0}</span>) they are actually shares of the secret encryption key; in another (<span class="math">\\mathcal{H}_{1}</span>) they are random values. In order to show that an adversary will have only a negligible change in output distribution, we can rely on this intuition: the leakage provided by the polynomial commitment proofs and the evaluation outputs can be reduced to a linear leakage on the secret shares. As a consequence, if <span class="math">\\mathcal{H}_{0}\\not\\approx\\mathcal{H}_{1}</span> then we can build an adversary against the linear leakage game for additive secret sharing. This adversary would emulate all the parts of the execution that are not derived from the alleged secret shares (the ciphertexts, the polynomial commitment proofs, etc.) and then use the output of <span class="math">\\mathcal{A}_{\\phi}</span> to identify whether it is interacting with random field elements or with actual shares. We formalize this intuition in Lemma 4.</li>

      <li><span class="math">\\mathcal{H}_{1}\\approx\\mathcal{H}_{2}</span> : the only difference between these two hybrids is what is actually encrypted in the output of <span class="math">\\mathsf{PES}_{ss}.\\mathsf{Enc}</span> (<span class="math">\\mathbf{w}</span> or <span class="math">\\mathbf{0}</span>). We can rely on semantic security to claim that the difference in the advantage of the adversary is negligible. We construct an adversary <span class="math">\\mathcal{A}_{\\text{sem}}</span> against semantic security (Definition 1) in Fig. 10. By inspection, it follows immediately that a noticeable difference in output between the two hybrids corresponds to a noticeable advantage against the semantic security experiment (implied by the security of PKE from Definition 19), leading to a contradiction.</li>

      <li><span class="math">\\mathcal{H}_{2}\\approx\\mathcal{H}_{3}</span> : here we can argue exactly as we did to show <span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Since we have shown that <span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{3}</span>, we can immediately conclude that the advantage of any PPT adversary against <span class="math">\\phi</span>-hiding would be negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H0: ck←BP-PC.PCGen(1λ,d)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H1: ck←BP-PC.PCGen(1λ,d)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F^n ⊥ w←A^N_{φ,1}(ck); z←$ F^r</td>

            <td class="px-3 py-2 border-b border-gray-700">F^n ⊥ w←A^N_{φ,1}(ck); z←$ F^r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←PKE.KG(1^λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←PKE.KG(1^λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ctw←PKE.Enc(pk,w)</td>

            <td class="px-3 py-2 border-b border-gray-700">ctw←PKE.Enc(pk,w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s←SS.Share(ℓ+1,sk)</td>

            <td class="px-3 py-2 border-b border-gray-700">s←F^ℓ+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let f(X) := ∑_{0≤i<d} fi+1X^i</td>

            <td class="px-3 py-2 border-b border-gray-700">Let f(X) := ∑_{0≤i<d} fi+1X^i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">where f := (s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ctw)</td>

            <td class="px-3 py-2 border-b border-gray-700">where f := (s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ctw)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c←BP-PC.Com(ck,f)</td>

            <td class="px-3 py-2 border-b border-gray-700">c←BP-PC.Com(ck,f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y := f(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y := f(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">π←Eval^N(ck,c,z,y,f)</td>

            <td class="px-3 py-2 border-b border-gray-700">π←Eval^N(ck,c,z,y,f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b'←A^N_{φ,2}(c,z,y,π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b'←A^N_{φ,2}(c,z,y,π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b' = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">return b' = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">H2: ck←BP-PC.PCGen(1^λ,d)</td>

            <td class="px-3 py-2 border-b border-gray-700">H3: ck←BP-PC.PCGen(1^λ,d)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F^n ⊥ w←A^N_{φ,1}(ck); z←$ F^r</td>

            <td class="px-3 py-2 border-b border-gray-700">F^n ⊥ w←A^N_{φ,1}(ck); z←$ F^r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←PKE.KG(1^λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">(pk,sk)←PKE.KG(1^λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ct0←PKE.Enc(pk,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">ct0←PKE.Enc(pk,0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s←F^ℓ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">s←SS.Share(ℓ+1,sk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let f(X) := ∑_{0≤i<d} fi+1X^i</td>

            <td class="px-3 py-2 border-b border-gray-700">Let f(X) := ∑_{0≤i<d} fi+1X^i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">where f := (s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ct0)</td>

            <td class="px-3 py-2 border-b border-gray-700">where f := (s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ct0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c←BP-PC.Com(ck,f)</td>

            <td class="px-3 py-2 border-b border-gray-700">c←BP-PC.Com(ck,f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y := f(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y := f(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">π←Eval^N(ck,c,z,y,f)</td>

            <td class="px-3 py-2 border-b border-gray-700">π←Eval^N(ck,c,z,y,f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b'←A^N_{φ,2}(c,z,y,π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b'←A^N_{φ,2}(c,z,y,π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b' = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">return b' = 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 9: Hybrids in the proof of evaluation hiding (changes compared to the previous hybrid are hinted in blue). Hybrids are parametrized by  <span class="math">\\lambda, n, r</span> . Above  <span class="math">d := n + \\text{stretch}(\\lambda, n, \\ell)</span>  where  <span class="math">\\ell := \\phi(\\lambda, n, r)</span>  and stretch as in Definition 28.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 10: Reduction to semantic security for showing  <span class="math">\\mathcal{H}_1 \\approx \\mathcal{H}_2</span> . We assume that the  <span class="math">\\mathcal{A}_{\\mathrm{sem}}</span>  appropriately simulates each RO invocation with a random function. Notice that we can compute  <span class="math">\\ell</span>  and  <span class="math">d</span>  appropriately from  <span class="math">\\lambda, n, r</span> , which we assume are known to the adversary.</p>

    <p class="text-gray-300">The following lemma shows that <span class="math">\\mathcal{H}_{0}\\not\\approx\\mathcal{H}_{1}</span> in the proof of Theorem 8 implies violating Lemma 3.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{H}_{0}\\not\\approx\\mathcal{H}_{1}</span> in the proof of Theorem 8 then there exists an adversary with non-negligible advantage against the <span class="math">\\mathsf{adm}_{det}</span>-linear leakage of <span class="math">\\mathrm{SS}</span> whenever <span class="math">\\ell:=\\phi(\\lambda,n,r)&gt;1+2r\\left(1+2\\lceil\\log(\\phi(\\lambda,n,r)+7\\lambda n)\\rceil\\right)</span>.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In Fig. 11 we describe an adversary <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> against the game in Definition 26 whose advantage is the same as the distinguishing advantage of <span class="math">\\mathcal{A}_{\\phi}</span> between <span class="math">\\mathcal{H}_{0}</span> and <span class="math">\\mathcal{H}_{1}</span>.</p>

    <p class="text-gray-300">At the high-level <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> works by emulating the view of <span class="math">\\mathcal{A}_{\\phi}</span>. The basic approach of <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> is to sample Pedersen basis <span class="math">\\mathbf{g},\\mathbf{h},u</span> so that it knows their discrete logarithm and can properly apply this knowledge when using the linear combination queries of <span class="math">\\mathcal{G}_{\\mathrm{SS-lin}}</span>. Naturally the information obtained by <span class="math">\\mathcal{A}_{\\phi}</span> in the hybrids <span class="math">\\mathcal{H}_{0}</span> and <span class="math">\\mathcal{H}_{1}</span> is derived not only by the alleged secret shares but also by the coefficients due to the public key and ciphertexts. The algorithm <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> can perfectly emulate the latter and then combine it with the response from the linear share queries. This logic is abstracted away in the definition of the pseudo-oracle <span class="math">\\mathcal{O}^{\\prime}</span> in Fig. 11.</p>

    <p class="text-gray-300">One of the key challenges in constructing <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> is that it should be able to express all the “update” operations during the polynomial opening proofs without knowledge of <span class="math">\\mathbf{a}</span>, the prefix of polynomial coefficients related to the secret shares. Additionally, <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> has to be able to express the whole view of <span class="math">\\mathcal{A}_{\\phi}</span> in terms of linear combinations of <span class="math">\\mathbf{a}</span> based on terms of which it has knowledge. The details of the code of <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> do exactly that. Instead of updating the vector <span class="math">\\mathbf{a}</span> as in the code of <span class="math">\\mathsf{BP}</span>-<span class="math">\\mathsf{IPA}</span>, it appropriately updates a “query” vector <span class="math">\\mathbf{q}_{a}</span>. It also uses two additional auxiliary vectors which roughly correspond to <span class="math">\\mathbf{g}</span> and <span class="math">\\mathbf{b}</span> in the same code. In order to do this we use some type of “index book-keeping” in order to appropriately combine the information in <span class="math">\\mathbf{q}_{a}</span> and the auxiliary vectors.</p>

    <p class="text-gray-300">By inspection, it is easy to observe that for any <span class="math">\\mathbf{g},\\mathbf{h},u</span>, vector of evaluations <span class="math">\\mathbf{z}</span>, encoded polynomial <span class="math">f(X):=\\sum_{i}a_{i}X^{i}</span>, the output of the <span class="math">\\mathcal{A}_{\\phi}</span> in <span class="math">\\mathcal{H}_{0}</span> (resp. <span class="math">\\mathcal{H}_{1}</span>) will be the same as that of <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> when <span class="math">b=0</span> (resp. <span class="math">b=1</span>) in <span class="math">\\mathcal{G}_{\\mathrm{SS-lin}}</span> <em>conditioned to the queries of <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> being admissible</em>. In the remainder of this proof we will claim this occurs with overwhelming probability.</p>

    <p class="text-gray-300">We now observe some basic facts on the queries to <span class="math">\\mathcal{O}</span> by <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span>. We can bound the number of queries <span class="math">q</span> to the oracle <span class="math">\\mathcal{O}</span> as <span class="math">q\\leq 1+2r(1+2\\lceil\\log d\\rceil)</span> by inspection of Fig. 11. We have:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commitment to the polynomial: <span class="math">1</span> query (of the form <span class="math">\\mathbf{r}^{(g)}</span>);</li>

      <li>Polynomial evaluations: <span class="math">r</span> queries (of the form <span class="math">\\left(z^{0},z^{1},z^{2},\\ldots,z^{\\ell}\\right)</span> for each evaluation point <span class="math">z</span>);</li>

      <li>For each of the <span class="math">r</span> polynomial opening proofs:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each of the <span class="math">\\log d</span> rounds:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Two queries—for <span class="math">L_{i,g},R_{i,g}</span>—such that only half of the elements are non-zero. A non-zero element in position <span class="math">j</span> has the form <span class="math">r_{j}^{(g)}\\cdot P_{j}^{x,x^{-1}}</span> where <span class="math">P_{j}^{x,x^{-1}}</span> is defined as in Item 4 (in the list at the end of this proof) using the challenges in the protocol up to that round.</li>

      <li>Two queries—for <span class="math">L_{i,u},R_{i,u}</span>—such that only half of the elements are non-zero. A non-zero element in position <span class="math">j</span> has the form <span class="math">r^{(u)}\\cdot b_{j}\\cdot P_{j}^{x,x^{-1}}</span> where <span class="math">P_{j}^{x,x^{-1}}</span> is defined as in Item 4 (in the list at the end of this proof) using the challenges in the protocol up to that round.</li>

      <li>A final query for <span class="math">a^{(k)}</span> where each element is of the form <span class="math">P_{j}^{x,x^{-1}}</span> where <span class="math">P_{j}^{x,x^{-1}}</span> is defined as in Item 4 (in the list at the end of this proof) using all the challenges in the protocol.</li>

    </ul>

    <p class="text-gray-300">Without loss of generality we will assume in the rest of this proof that the number of queries <span class="math">q</span> is identical to <span class="math">\\ell</span>. The case <span class="math">q&gt;\\ell</span> will not occur given our bound in the statement of the lemma. If instead <span class="math">\\ell&gt;q</span> we can always modify <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> to “pad” its oracle queries at the end of its execution with some dummy ones of which it will discard the output. The only constraint on these additional queries is that they do not substantially increase the probability of the whole query set being not admissible. This is not a problem since with overwhelming probability random evaluation queries will not make the set inadmissible (this will be an implication of some of the observations we make below).</p>

    <p class="text-gray-300">Recall that admissibility can essentially be reduced to the fact that the determinant of a matrix associated with the queries is non-zero (Lemma 3 and Definition 27). Let us now consider Eq. 1 from Appendix C.2. Recall this states that the polynomial describing the determinant has this form:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\pi}\\pm\\left(\\theta_{1}^{(\\pi(1))}+\\theta_{\\ell+1}^{(\\pi(1))}\\right)\\left(\\theta_{2}^{(\\pi(2))}-\\theta_{1}^{(\\pi(2))}\\right)\\ldots\\left(\\theta_{\\ell}^{(\\pi(\\ell))}-\\theta_{1}^{(\\pi(\\ell))}\\right)</span></p>

    <p class="text-gray-300">where the sum is over all possible permutations <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Our goal is now to claim that the determinant above is non-zero with overwhelming probability. We proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We observe that it is sufficient to show that the above can be reduced to the evaluation of a non-zero multivariate polynomial where each variable is sampled randomly from the field. The degree of the polynomial is of polynomial size while the size of the field is exponential. We can then apply Schwartz-Zippel to conclude that with overwhelming probability the determinant is non-zero.</li>

      <li>We show that, under certain assumptions on the parameters of the encoding scheme (required by statement of the lemma) we can show that there exists at least one monomial among the summands in Eq. (1) that is non-zero.</li>

      <li>It is then sufficient to show that this monomial is not “cancelled out” by contributions of other summands in Eq. (1).</li>

    </ul>

    <p class="text-gray-300">We observe that the sum above yields (among others) the following monomial:</p>

    <p class="text-gray-300"><span class="math">\\theta_{\\ell+1}^{(\\pi^{<em>}(1))}\\theta_{2}^{(\\pi^{</em>}(2))}\\dots\\theta_{\\ell}^{(\\pi^{*}(\\ell))}</span></p>

    <p class="text-gray-300">for some permutation <span class="math">\\pi^{*}</span>. The coefficient in front of this monomial will be either <span class="math">1</span> or <span class="math">-1</span>, but this is irrelevant for our argument.</p>

    <p class="text-gray-300">Let us first observe that there must exist a permutation <span class="math">\\pi^{<em>}</span> such that all those terms are non-zero with overwhelming probability given the sampling in the definition of <span class="math">\\mathcal{A}_{\\text{lin}}</span>. The only queries with some zero elements are the “internal” ones during the polynomial opening proof <span class="math">(L_{i,g},L_{i,u},R_{i,g},R_{i,u})</span>. How many of these queries are there? Approximately <span class="math">4r\\log d</span>. Each of these queries, moreover, has exactly <span class="math">\\ell/2</span> non-zero elements. We can guarantee the existence of <span class="math">\\pi^{</em>}</span> as long as <span class="math">\\ell</span> is large enough to guarantee that each of the <span class="math">O(r\\log d)</span> “internal” queries can be mapped to some index <span class="math">j\\in[\\ell]</span> so that the query is non-zero in <span class="math">j</span> (plus leaving enough space for the other types of queries of which there are <span class="math">O(r)</span>). This is the case for the <span class="math">\\phi</span> (and therefore the <span class="math">\\ell</span>) we are requiring in the statement of Theorem 8.</p>

    <p class="text-gray-300">Without loss of generality we assume that <span class="math">\\pi^{<em>}(1)</span> refers to the query for <span class="math">r_{\\text{cm}}</span>. This implies that <span class="math">\\theta_{\\ell+1}^{(\\pi^{</em>}(1))}=r_{\\ell+1}^{(g)}</span>. This fact will be handy later.</p>

    <p class="text-gray-300">Let us now make some observations on the structure of the monomial of the form above given by <span class="math">\\pi^{*}</span>. We will be able to factor it according to the type of queries that contribute to each factor. In particular we can write it as follows:</p>

    <p class="text-gray-300">(11)</p>

    <p class="text-gray-300">Some explanations on the notation above:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we write in underbraces the type of queries each factor refers to.</li>

      <li>The indices <span class="math">j,j^{\\prime},j^{\\prime\\prime}</span> are enumerated so that together they cover the set <span class="math">\\{2,\\dots,\\ell\\}</span>.</li>

      <li>the <span class="math">k</span>-s are indices from <span class="math">1</span> to <span class="math">r</span> and refer to the evaluation points for the polynomial.</li>

      <li>The notation <span class="math">P_{j}^{x,x^{-1}}</span> refers to some product (the exact product depends on <span class="math">j</span>) of the challenges <span class="math">x</span> sampled through the random oracle at every round of the polynomial opening proof. We use the notation <span class="math">x,x^{-1}</span> to refer to the fact that these products are a mixture of products of challenges and of inverses of challenges.</li>

    </ol>

    <p class="text-gray-300">We now want to argue that a monomial with the structure above cannot be obtained “in any other way” than by <span class="math">\\pi^{<em>}</span>. We first make two easy observations to exclude the possibility that the same permutation may yield the same monomial (through the <span class="math">\\theta_{1}</span>-s in Eq. (1)) and that two different permutations may yield the same set of individual factors of <span class="math">\\pi^{</em>}</span>.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Observation 1</h6>

    <p class="text-gray-300">for all queries <span class="math">\\theta^{(j)}</span> we have that <span class="math">\\theta_{i}^{(j)}\\neq\\theta_{1}^{(j)}</span> with overwhelming probability (for <span class="math">i\\neq 1</span> and conditioned to <span class="math">\\theta_{i}^{(j)}\\neq 0</span>).</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Observation 2</h6>

    <p class="text-gray-300">let <span class="math">j\\neq j^{\\prime}</span>, for <span class="math">i\\neq i^{\\prime}</span> with <span class="math">i,i^{\\prime}\\neq 1</span>, then <span class="math">\\theta_{i}^{(j)}\\neq\\theta_{i^{\\prime}}^{(j^{\\prime})}</span> with overwhelming probability (conditioned to <span class="math">\\theta_{i}^{(j)},\\theta_{i^{\\prime}}^{(j^{\\prime})}\\neq 0</span>).</p>

    <p class="text-gray-300">The important implication of the observations above is that the only hope of obtaining the same monomial is by a different permutation <span class="math">\\tilde{\\pi}</span> that, despite having different factors <span class="math">\\theta_{\\ell+1}^{(\\tilde{\\pi}(1))},\\theta_{2}^{(\\tilde{\\pi}(2))},\\ldots,\\theta_{\\ell}^{(\\tilde{\\pi}(\\ell))}</span>, obtains the same monomial through their product.</p>

    <p class="text-gray-300">Observe that in 11:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>No evaluation point <span class="math">z_{k}</span> can appear twice (even with different exponents).</li>

      <li>All of the <span class="math">r_{j^{\\prime\\prime}}^{(g)}</span> are distinct.</li>

    </ol>

    <p class="text-gray-300">We can now start observing constraints on the hypothetical permutation <span class="math">\\tilde{\\pi}</span> yielding the same monomial. Observe that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tilde{\\pi}</span> must contribute exactly the same elements <span class="math">r_{j^{\\prime\\prime}}^{(g)}</span> in the product indexed by <span class="math">j^{\\prime\\prime}</span> although they can appear from different polynomial evaluation proofs. The reason is that this is item (2) above (on the distinct <span class="math">r_{j^{\\prime\\prime}}^{(g)}</span>-s) and that the only product in which they are contributed is the rightmost one. (the leftmost factor <span class="math">r_{\\ell+1}^{(g)}</span> cannot appear here since otherwise some other element with index <span class="math">\\ell+1</span> would have to be <span class="math">\\theta_{\\ell+1}^{(\\tilde{\\pi}(1))}</span> but no such element appears in 11).</li>

      <li>An implication of the previous item is that the set of <span class="math">r_{j^{\\prime\\prime}}^{(g)}</span> appearing must be exactly the same and it must be that they are “swapped” among different polynomial proofs. However, this implies that they have different products <span class="math">P_{j^{\\prime\\prime}}^{x,x^{-1}}</span> since each polynomial opening has disjoint sets of challenges with overwhelming probability. By inspection, we can convince ourselves, that there is no way to compensate these differences in challenges products in some other way.</li>

      <li>Assume that there is some difference in <span class="math">\\tilde{\\pi}</span> in the set of contributing factors indexed by <span class="math">j^{\\prime}</span>. This, however, can occur only if the number of factors is exactly the same (otherwise the exponent for <span class="math">r^{(u)}</span> would be different) and each of the <span class="math">z_{k_{j^{\\prime}}}</span> is swapped with some other <span class="math">z_{k_{j}}</span> in the second product and with the same exponent (otherwise there would not be the same set of evaluations being contributed). This would require <span class="math">\\tilde{\\pi}</span> to “compensate” the difference in <span class="math">P_{j^{\\prime}}^{x,x^{-1}}</span>-s from the swaps. Nonetheless, by inspecting the ways challenges are indexed, we can convince ourselves that this is not possible.</li>

    </ul>

    <p class="text-gray-300">The above shows that with high probability there exists a monomial with non-zero coefficients in the determinant polynomial and it concludes the proof.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 11: Adversary  <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span> . Recall that the adversary has access to a linear combination oracle  <span class="math">\\mathcal{O}</span>  as defined in Fig. 8. Auxiliary functions are defined in Fig. 12 and Fig. 13.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 12: Auxiliary function MakeProof for adversary  <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 13: Further auxiliary functions for adversary  <span class="math">\\mathcal{A}_{\\mathrm{lin}}</span></p>

    <p class="text-gray-300">D.4 Proof of Theorem 9</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We closely follow the corresponding proof of non-extrapolation of KZG in <em>[GKO^{+}23]</em>. Consider the following hybrids:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{0}</span>: this is the same as the game in Definition 15 where an all-zero vector of length <span class="math">n</span> is encoded as a polynomial and we provide the adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> with up to <span class="math">r</span> evaluation points and corresponding evaluation proofs.</li>

      <li><span class="math">\\mathsf{Hyb}_{1}</span>: we now change part of the challenger’s code. Instead of encoding an all-zero vector, we proceed by sampling a set of random evaluations and then using (in part) the evaluation points required by the adversary to interpolate the polynomial. More in detail:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we first sample <span class="math">d</span> random evaluations <span class="math">y_{i}\\leftarrow\\S\\E</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let <span class="math">\\mathbf{z}</span> be the sampled evaluation points and let <span class="math">\\mathbf{z}^{\\prime}</span> a vector of unique points in <span class="math">\\mathbf{z}</span>. Let $r^{\\prime}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and let </span>n^{\\prime}:=d-r^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">n^{\\prime}</span> points <span class="math">\\mathbf{z}^{\\prime\\prime}</span> from <span class="math">\\E^{n^{\\prime}}</span>.</li>

      <li>Interpolate <span class="math">f</span> so that <span class="math">f(z^{\\prime}_{i})=y_{i}</span> for <span class="math">i\\in[r^{\\prime}]</span> and <span class="math">f(z^{\\prime\\prime}_{j})=y_{j+r^{\\prime}}</span> for <span class="math">j\\in[n^{\\prime}]</span></li>

      <li>Compute commitments and evaluation proofs as before.</li>

    </ul>

    <p class="text-gray-300">By applying <span class="math">\\phi</span>-evaluation hiding we can conclude that the two hybrids are indistinguishable and therefore the polynomial <span class="math">f</span> looks random to <span class="math">\\mathcal{A}</span> after requesting <span class="math">r</span> evaluations. Let us now consider <span class="math">(y^{<em>},\\pi^{</em>})</span>, the output of <span class="math">\\mathcal{A}_{2}</span> for <span class="math">z^{<em>}\\leftarrow\\S\\E</span>. By the previous observation, the probability that <span class="math">\\Pr[y^{</em>}=f(z^{<em>})]</span> is negligible. If <span class="math">y^{</em>}\\neq f(z^{*})</span> and <span class="math">\\mathcal{A}</span> wins it is then possible to break evaluation binding since we can produce two valid evaluation proofs for two distinct points for the same committed polynomial. This concludes the proof.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-80" class="text-2xl font-bold">Appendix E On Simulation-Extractable NIZKs from UC-secure Protocols</h2>

    <p class="text-gray-300">In this section, we show that from protocols UC-realizing specific NIZK functionalities, and under various setups, we can instantiate true-simulation-extractable zkSNARKs, which is the main building block for Theorem 1.</p>

    <p class="text-gray-300">In particular, in Section E.1 we consider the weaker functionality <span class="math">\\mathcal{F}_{\\mathsf{ARG}}</span> (Fig. 14) in the observable and restricted programmable GROM, and in Section E.2 we focus on protocols that UC-realize the standard NIZK functionality <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> (Fig. 15).</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">E.1 From Weaker UC NIZK</h3>

    <p class="text-gray-300">Chiesa and Fenzi <em>[x10]</em> study the UC-security for succinct non-interactive arguments in the global observable and restricted programmable random oracle model <em>[CDG^{+}18]</em>. They define an ARG ideal functionality, explicitly adapting the standard NIZK functionality in Fig. 15 to the (G)ROM.</p>

    <p class="text-gray-300">Briefly, their functionality has a proving interface that produces simulated proofs and a verification interface that extracts the witness, which capture zero-knowledge and (simulation) straight-line knowledge-soundness respectively. Additionally, the environment has a GRO interface that allows the parties to query, program, and detect programmed outputs of the random oracle. The programming/detection interface is limited, in the sense that the parties can only program/detect programming of RO outputs in their session, thus preventing the environment to directly access the GRO interface and allowing the UC simulator to intercept these queries. We give in Fig. 14 a slightly simplified definition of the ARG functionality in the GROM without considering adaptive corruptions as it is not needed for our analysis. We refer to <em>[x10]</em> for a more detailed treatment.</p>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathsf{ARG}}</span> be the following protocol, parametrized by a zkSNARK <span class="math">\\Pi</span> and a relation <span class="math">\\mathcal{R}\\in\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof: Upon receiving input (prove, <span class="math">\\mathsf{sid}</span>, <span class="math">x,w</span>), ignore if <span class="math">(x,w)\\notin\\mathcal{R}</span>. Otherwise, the prover party <span class="math">M_{P}</span> does:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{ARG}}</span>  is parametrized by polynomial-time-decidable relation  <span class="math">\\mathcal{R} \\in \\{0,1\\}^<em> \\times \\{0,1\\}^</em></span>  and runs with a prover party  <span class="math">M_P</span> , a verifier party  <span class="math">M_V</span> , and an ideal process adversary Sim. It stores proof table  <span class="math">\\mathcal{Q}</span>  which is initially empty, the list  <span class="math">\\mathcal{Q}_x</span>  of the instances queried, the list of honestly programmed points hProgrammed, and the list extTrace of queries of the adversary to the GRO interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof Upon receiving input (PROVE, sid,  <span class="math">x, w</span> ) from the prover party  <span class="math">M_P</span> , do the following. If  <span class="math">(x, w) \\notin \\mathcal{R}</span>  return the activation to the environment. Otherwise, invoke the Observe interface, with sid sid, of the GRO functionality, and get the list of illegitimate queries  <span class="math">\\mathcal{Q}_{\\mathrm{sid}}</span>  associated with sid sid and add them to extTrace. Send (PROVE, sid,  <span class="math">x</span> ) to Sim. Upon receiving (PROOF, sid,  <span class="math">x, \\pi</span> ) from Sim, invoke the Program interface with sid sid for all the points that Sim programmed to generate  <span class="math">\\pi</span> : output FAIL if the Program interface rejects. Store the list of these programmed points to hProgrammed. Store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  and output (PROOF, sid,  <span class="math">x, \\pi</span> ) to  <span class="math">M_P</span> .</li>

      <li>Verification Upon receiving input (VERIFY, sid,  <span class="math">x, \\pi</span> ) from the verifier party  <span class="math">M_V</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">(x, \\pi) \\in \\mathcal{Q}</span>  return (VERIFICATION, sid, 1) to the party  <span class="math">M_V</span></li>

      <li>else, if  <span class="math">\\mathcal{Q}_x</span>  contains  <span class="math">x</span> , send (VERIFY-REPLAY, sid,  <span class="math">x, \\pi</span> ) to Sim. Upon receiving (VERIFICATION,  <span class="math">x</span> ,  <span class="math">\\pi, b</span> ) from Sim, store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  if  <span class="math">b = 1</span></li>

      <li>else, send (VERIFY, sid,  <span class="math">x</span> ,  <span class="math">\\pi</span> , extTrace') to Sim, where extTrace' is obtained by removing the queries in extTrace that are not detected as programmed. Upon receiving (WITNESS,  <span class="math">x</span> ,  <span class="math">w</span> ) from Sim store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  if  <span class="math">(x, w) \\in \\mathcal{R}</span></li>

    </ul>

    <p class="text-gray-300">Finally, return (VERIFICATION, sid,  <span class="math">(x,\\pi)\\in ?\\mathcal{Q})</span>  to the party  <span class="math">M_V</span> .</p>

    <p class="text-gray-300">Fig. 14: The ARG functionality. The ideal adversary is a pair of simulator/extractor algorithms, namely  <span class="math">\\mathsf{Sim} = (\\mathcal{S}_{uc},\\mathcal{E})</span> , where  <span class="math">\\mathcal{S}_{uc}</span>  is the UC-friendly zero-knowledge simulator. The extractor  <span class="math">\\mathcal{E}</span>  is straight-line and receives as input a query-answer trace extTrace consisting of the query-answer pairs to the GRO by the environment and the simulator, filtered to exclude queries whose answers were previously programmed by the environment; in particular,  <span class="math">\\mathcal{E}</span>  may receive queries to the random oracle that were previously programmed by the simulator, which are stored in hProgrammed.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the prover  <span class="math">\\mathcal{P}</span>  of  <span class="math">\\varPi</span>  on input  <span class="math">(x,w)</span>  to obtain a proof  <span class="math">\\pi</span> . Whenever  <span class="math">\\mathcal{P}</span>  makes a call to  <span class="math">\\mathcal{H}</span>  with input in, send (QUERY, (sid, in, proof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to receive a response out which is forwarded to  <span class="math">\\mathcal{P}</span> .</li>

      <li>Output (PROOF, sid,  <span class="math">x, \\pi</span> ).</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification: Upon input (VERIFY, sid,  <span class="math">x, \\pi</span> ), the verifier party  <span class="math">M_V</span>  outputs (VERIFICATION, sid, 1) if the following conditions are satisfied, otherwise outputs (VERIFICATION, sid, ,0):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\mathcal{V}</span>  of  <span class="math">\\varPi</span>  on input  <span class="math">x, \\pi</span>  outputs 1. Whenever  <span class="math">\\mathcal{V}</span>  makes a call to  <span class="math">\\mathcal{H}</span>  with input in, send (QUERY, (sid, in, proof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to receive a response out which is forwarded to  <span class="math">\\mathcal{V}</span> .</li>

      <li>Check that none of the outputs out obtained in the previous step is programmed, by querying the GRO interface.</li>

    </ul>

    <p class="text-gray-300">What [CF24] shows is that the Micali [Mic94] and the BCS [BCS16] constructions, when instantiated with suitable PCPs and IOPs respectively, yield zkSNARKs that are UC-secure in the observable and restricted programmable GROM. Formally, by this we mean that the associated protocol  <span class="math">\\Pi_{\\mathrm{ARG}}</span>  when instantiated with one of these zkSNARKs, UC-realizes  <span class="math">\\mathcal{F}_{\\mathrm{ARG}}</span>  in the observable and restricted programmable GROM.</p>

    <p class="text-gray-300">We can plug these zkSNARKs into Theorem 1 if we show that they are straight-line weak true-simulation-extractable in the random oracle, as we do.</p>

    <p class="text-gray-300">Theorem 10. Let  <span class="math">\\Pi</span>  be a zkSNARK and let  <span class="math">\\Pi_{\\mathsf{ARG}}</span>  be the associated protocol defined in Appendix E.1. If  <span class="math">\\Pi_{\\mathsf{ARG}}</span>  UC-realizes  <span class="math">\\mathcal{F}_{\\mathsf{ARG}}</span>  in Fig. 14 assuming the observable and restricted programmable GROM, then  <span class="math">\\Pi</span>  achieves straight-line weak true-simulation extractability in the random oracle model (cf. Definition 9).</p>

    <p class="text-gray-300">Proof. If  <span class="math">\\Pi_{\\mathsf{ARG}}</span>  UC-realizes  <span class="math">\\mathcal{F}_{\\mathsf{ARG}}</span>  in the GROM, then it is UC-friendly zero-knowledge with respect to a simulator  <span class="math">S_{uc}</span> , according to [CF24]. First, we need to reconcile our definition of zero-knowledge (cf. Def</p>

    <p class="text-gray-300">inition 6) with the UC-friendly counterpart of <em>[x10]</em>. We define a natural stateful NIZK simulator <span class="math">\\mathcal{S}_{\\Pi}</span> associated with <span class="math">\\mathcal{S}_{uc}</span> that does the following:</p>

    <p class="text-gray-300">initializes the state <span class="math">\\mathsf{st}=\\mathsf{pp}</span> and initializes an empty list of RO input-output queries. on input <span class="math">(1,\\mathsf{in})</span>, returns a uniformly random element from the codomain of <span class="math">\\mathcal{H}</span> if <span class="math">\\mathcal{A}</span> never queried <span class="math">(1,\\mathsf{in})</span>, otherwise outputs the value out such that <span class="math">(\\mathsf{in},\\mathsf{out})</span> is in the list of RO queries. on input <span class="math">(2,x)</span>, where <span class="math">x</span> is in the language, returns the first output of <span class="math">\\mathcal{S}_{uc}(x)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}_{\\Pi}</span> be an adversary for the weak true-simulation-extractability experiment of the scheme <span class="math">\\Pi</span> with respect to the NIZK simulator <span class="math">\\mathcal{S}_{\\Pi}</span>. Without loss of generality, we assume that <span class="math">\\mathcal{A}_{\\Pi}</span> outputs a pair <span class="math">(x,\\pi)</span> such that <span class="math">x</span> is a fresh statement and <span class="math">V(x,\\pi)=1</span> with probability 1. Let <span class="math">\\epsilon_{\\mathsf{t-SE}}</span> be the minimum advantage of <span class="math">\\mathcal{A}</span>, for any PPT extractor algorithm, against the weak true-simulation-extractability experiment. We show how to construct an environment <span class="math">\\mathcal{Z}</span> that distinguishes the real-world experiment from the ideal one with probability at least <span class="math">\\epsilon_{\\mathsf{t-SE}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">M_{P}</span> and <span class="math">M_{V}</span> be a prover and a verifier party respectively. The reduction <span class="math">\\mathcal{Z}</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any RO query issued by <span class="math">\\mathcal{A}_{\\Pi}</span>, it invokes the GRO interface and forwards the output to the adversary.</li>

      <li>For any simulation query issued by <span class="math">\\mathcal{A}_{\\Pi}</span>, it invokes the proving interface of the ARG ideal functionality and forwards the output to the adversary.</li>

      <li>When the adversary outputs the forgery <span class="math">(x,\\pi)</span>, <span class="math">\\mathcal{Z}</span> aborts if <span class="math">(x,\\pi)</span> is not valid; otherwise, it invokes the verification interface of the ARG ideal functionality. If the verification interface fails, <span class="math">\\mathcal{Z}</span> outputs 0, otherwise outputs 1.</li>

    </ul>

    <p class="text-gray-300">Since the adversary outputs a pair <span class="math">(x,\\pi)</span> such that <span class="math">V(x,\\pi)=1</span>, <span class="math">\\mathcal{Z}</span> never aborts and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathcal{Z}</span> is in the real-world experiment, it outputs 1 with probability 1: this is because <span class="math">\\mathcal{Z}</span> never issues programming queries and then the verification interface equals the verification algorithm of <span class="math">\\Pi</span>;</li>

      <li>if <span class="math">\\mathcal{Z}</span> is in the ideal experiment, it outputs 1 unless the verification interface fails, which happens when the extractor algorithm <span class="math">\\mathcal{E}</span> fails at extracting a valid witness <span class="math">w</span> for <span class="math">x</span>. By definition, this happens with probability at least <span class="math">\\epsilon_{\\mathsf{t-SE}}</span>.</li>

    </ul>

    <p class="text-gray-300">Hence we have that <span class="math">\\mathcal{Z}</span> distinguishes with probability at least <span class="math">\\epsilon_{\\mathsf{t-SE}}</span> the real-world experiment from the ideal one.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">E.2 From Standard UC NIZK</h3>

    <p class="text-gray-300">In this section, we show how to instantiate (strong) true-simulation-extractable zkSNARKs from protocols that UC-realize, in the <span class="math">\\mathcal{F}_{\\mathsf{RO}}</span>-hybrid model, the standard NIZK functionality <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> depicted in Fig. 15.</p>

    <p class="text-gray-300">First, we observe that there is a natural way to instantiate a zkSNARK <span class="math">\\Pi</span> from a protocol <span class="math">\\Pi_{\\mathsf{NIZK}}</span> that UC-realizes <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> in the <span class="math">\\mathcal{F}_{\\mathsf{RO}}</span>-hybrid model.</p>

    <p class="text-gray-300">In particular, let <span class="math">\\mathsf{sid}</span> be a dummy session id, <span class="math">\\Pi=(\\mathsf{PGen},\\mathcal{P},\\mathcal{V})</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PGen}(1^{\\lambda})</span> generates public parameters <span class="math">\\mathsf{pp}</span> by querying <span class="math">\\mathcal{H}</span> on input the same string(s) used by the parties in <span class="math">\\Pi_{\\mathsf{NIZK}}</span> to generate the parameters.</li>

      <li><span class="math">\\mathcal{P}(x,w)</span> runs the code of the prover in <span class="math">\\Pi_{\\mathsf{NIZK}}</span>. Any query to the RO interface is cast to a call to the random oracle <span class="math">\\mathcal{H}</span>. When the prover outputs <span class="math">(\\mathsf{proof},\\mathsf{sid},\\pi)</span>, it outputs the proof <span class="math">\\pi</span></li>

      <li><span class="math">\\mathcal{V}(x,\\pi)</span> runs the code of the verifier party in <span class="math">\\Pi_{\\mathsf{NIZK}}</span>. Any query to the RO interface is cast to a call to the random oracle <span class="math">\\mathcal{H}</span>. When the verifier outputs <span class="math">(\\mathsf{verification},\\mathsf{sid},x,b)</span>, it returns the bit <span class="math">b</span></li>

    </ul>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be the zkSNARK associated with the protocol <span class="math">\\Pi_{\\mathsf{NIZK}}</span>, as defined in Appendix E.2. If <span class="math">\\Pi_{\\mathsf{NIZK}}</span> UC-realizes in the <span class="math">\\mathcal{F}_{\\mathsf{RO}}</span>-hybrid model the functionality <span class="math">\\mathcal{F}_{\\mathsf{NIZK}}</span> in Fig. 15, then <span class="math">\\Pi</span> achieves straight-line true-simulation extractability in the random oracle model (cf. Definition 9).</p>

    <p class="text-gray-300">The proof is similar to that of Theorem 10 and we state it for completeness.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the UC-secuurity of <span class="math">\\Pi_{\\mathsf{NIZK}}</span>, we know that there is an ideal process simulator <span class="math">\\mathsf{Sim}</span>, which we can use to define a natural stateful NIZK simulator <span class="math">\\mathcal{S}_{\\Pi}</span> and a straigh-line extractor. Since the protocol UC-realizes the standard NIZK functionality in the <span class="math">\\mathcal{F}_{\\mathsf{RO}}</span>-hybrid model, the simulator is allowed to program the RO, and hence so does the simulator <span class="math">\\mathcal{S}_{\\Pi}</span>.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}_{\\Pi}</span>  be an adversary for the true-simulation-extractability experiment of the scheme  <span class="math">\\varPi</span>  with respect to the NIZK simulator  <span class="math">S_{\\varPi}</span> . Without loss of generality, we assume that  <span class="math">\\mathcal{A}_{\\varPi}</span>  outputs a pair  <span class="math">(x,\\pi)</span>  such that  <span class="math">\\mathcal{V}(x,\\pi) = 1</span>  with probability 1. Let  <span class="math">\\epsilon_{\\mathrm{t - SE}}</span>  be the minimum advantage of  <span class="math">\\mathcal{A}</span> , for any PPT extractor algorithm, against the true-simulation-extractability experiment. We show how to construct an environment  <span class="math">\\mathcal{Z}</span>  that distinguishes the real-world experiment from the ideal one with probability at least  <span class="math">\\epsilon_{\\mathrm{t - SE}}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">P_{1}</span>  and  <span class="math">P_{2}</span>  be a prover and a verifier party respectively. The reduction  <span class="math">\\mathcal{Z}</span>  is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any RO query issued by  <span class="math">\\mathcal{A}_{\\Pi}</span> , it invokes the (local) RO interface  <span class="math">\\mathcal{F}_{\\mathrm{RO}}</span>  and forwards the output to the adversary.</li>

      <li>For any simulation query issued by  <span class="math">\\mathcal{A}_{\\Pi}</span> , it invokes the proving interface of the NIZK ideal functionality and forwards the output to the adversary.</li>

      <li>When the adversary outputs the forgery  <span class="math">(x, \\pi)</span> ,  <span class="math">\\mathcal{Z}</span>  aborts if  <span class="math">(x, \\pi)</span>  is not valid; otherwise, it invokes the verification interface of the NIZK ideal functionality. If the verification interface fails,  <span class="math">\\mathcal{Z}</span>  outputs 0, otherwise outputs 1.</li>

    </ul>

    <p class="text-gray-300">Since the adversary outputs a pair  <span class="math">(x,\\pi)</span>  such that  <span class="math">V(x,\\pi) = 1</span> ,  <span class="math">\\mathcal{Z}</span>  never aborts and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\mathcal{Z}</span>  is in the real-world experiment, it outputs 1 with probability 1: this is because the verification interface equals the verification algorithm of  <span class="math">\\varPi</span> ;</li>

      <li>if  <span class="math">\\mathcal{Z}</span>  is in the ideal experiment, it outputs 1 unless the verification interface fails, which happens when Sim fails at extracting a valid witness  <span class="math">w</span>  for  <span class="math">x</span> . By definition, this happens with probability at least  <span class="math">\\epsilon_{\\mathrm{t - SE}}</span> .</li>

    </ul>

    <p class="text-gray-300">Hence we have that  <span class="math">\\mathcal{Z}</span>  distinguishes with probability at least  <span class="math">\\epsilon_{\\mathrm{t - SE}}</span>  the real-world experiment from the ideal one.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span>  is parametrized by polynomial-time-decidable relation  <span class="math">\\mathcal{R} \\in \\{0,1\\}^<em> \\times \\{0,1\\}^</em></span>  and runs with parties  <span class="math">\\mathsf{P}_1, \\ldots, \\mathsf{P}_N</span>  and an ideal process adversary Sim. It stores proof table  <span class="math">\\mathcal{Q}</span>  which is initially empty.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof Upon receiving input (PROVE, sid,  <span class="math">x, w</span> ) from an honest party  <span class="math">\\mathsf{P}_i</span> , do the following: if  <span class="math">(x, w) \\notin \\mathcal{R}</span>  return the activation to the environment. Otherwise, send (PROVE, sid,  <span class="math">x</span> ) to Sim. Upon receiving (PROOF, sid,  <span class="math">x, \\pi</span> ) from Sim, store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  and output (PROOF, sid,  <span class="math">x, \\pi</span> ) to  <span class="math">\\mathsf{P}_i</span> .</li>

      <li>Verification Upon receiving input (VERIFY, sid,  <span class="math">x, \\pi</span> ) from a party  <span class="math">\\mathsf{P}_i</span> , if  <span class="math">(x, \\pi)</span>  is not stored in  <span class="math">\\mathcal{Q}</span> , then send (VERIFY, sid,  <span class="math">x, \\pi</span> ) to Sim. Upon receiving (WITNESS,  <span class="math">w</span> ) from Sim, if  <span class="math">(x, w) \\in \\mathcal{R}</span> , store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span> . Finally, return (VERIFICATION, sid,  <span class="math">(x, \\pi) \\in_? \\mathcal{Q}</span> ) to  <span class="math">\\mathsf{P}_i</span> .</li>

    </ul>

    <p class="text-gray-300">Fig. 15: Standard functionality for non-interactive zero-knowledge.</p>`;
---

<BaseLayout title="Universally Composable SNARKs with Transparent Setup without... (2024/1549)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1549
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
