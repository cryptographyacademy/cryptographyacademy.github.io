---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/456';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Delegation of Computation without Rejection Problem from Designated Verifier CS-Proofs';
const AUTHORS_HTML = 'Shafi Goldwasser, Huijia Lin, Aviad Rubinstein';

const CONTENT = `    <p class="text-gray-300">1</p>

    <p class="text-gray-300">Shafi Goldwasser†    Huijia Lin‡    Aviad Rubinstein §</p>

    <h2 id="sec-2" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">We present a designated verifier CS proof system for polynomial time computations. The proof system can only be verified by a designated verifier: one who has published a public-key for which it knows a matching secret key unknown to the prover. Whereas Micali's CS proofs require the existence of random oracles, we can base soundness on computational assumptions: the existence of leveled fully homomorphic encryption (FHE) schemes, the DDH assumption and a new knowledge of exponent assumption.</p>

    <p class="text-gray-300">Using our designated verifier CS proof system, we construct two schemes for delegating (polynomial-time) computation. In such schemes, a delegator outsources the computation of a function <span class="math">F</span> on input <span class="math">x</span> to a polynomial time worker, who computes the output <span class="math">y = F(x)</span> and proves to the delegator the correctness of the output.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">T</span> be the complexity of computing <span class="math">F</span> on inputs of length $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and let </span>k<span class="math"> be a security parameter. Our first scheme calls for an one-time off-line stage where the delegator sends a message to the worker, and a non-interactive on-line stage where the worker sends the output together with a certificate of correctness to the prover per input </span>x<span class="math">. The total computational complexity of the delegator during off-line and on-line stages is </span>\\mathrm{poly}(k,n,\\log T)<span class="math">. Compared with previous constructions by Gennaro-Gentry-Parno and Chung-Kalai-Vadhan [GGP10, CKV10] based on FHE, their on-line stage consists of two messages and their off-line stage has (delegator&#x27;s) complexity of </span>\\mathrm{poly}(k,n,T)<span class="math">. Thus, they achieve delegator complexity </span>\\mathrm{poly}(k,n,\\log T)<span class="math"> only in an amortized sense. Compared with the construction of [GKR08] based on poly-log PIR, our first construction can handle any polynomial-time computable </span>F<span class="math"> rather than being restricted to </span>\\mathcal{NC}<span class="math"> computable </span>F<span class="math">. Our second scheme requires no off-line stage and has a two-message &quot;on-line&quot; stage with complexity of </span>\\mathrm{poly}(k,n,\\log T)<span class="math">. Most importantly, it achieves robust soundness that guarantees that it is infeasible for a cheating worker to convince the delegator of an invalid output even if the worker learns whether the delegator accepts or rejects previous outputs and proofs. Previously the only two-round protocol that achieves robust soundness under a computational assumption appeared in [GKR08] and is restricted to only </span>\\mathcal{NC}$ computations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">*This material is based on research sponsored in part by NSF Contract CCF-1018064, NSF Contract CCF-0729011, and the Air Force Research Laboratory under agreement number FA8750-11-2-0225. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Air Force Research Laboratory or the U.S. Government.</p>

    <p class="text-gray-300">†MIT, E-Mail: shafi@theory.csail.mit.edu. ‡MIT, E-Mail: huijia@csail.mit.edu. §Tel Aviv University aviadrub@mail.tau.ac.il</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Efficient proof verification lies at the heart of complexity theory and the definition of the class <span class="math">\\mathcal{NP}</span>. Classically, this was captured by the idea of having a deterministic polynomial time (in the size of the statement to be proved) verification procedure which receives a proof—a polynomial size certificate—and checks for correctness. Extending classical proof systems, interactive proof systems (IP) provided a model in which the polynomial time verification procedure—the <em>verifier</em> algorithm—is randomized and can interact with an all powerful <em>prover</em> algorithm which may employ an adaptive strategy in answering the verifier’s messages. This strenghening enables efficient verification of all <span class="math">\\mathcal{PSPACE}</span> computation. In another notion of probabilistically-checkable proof systems (PCPs), the verifier is similarily randomized, but the prover is restricted to utilize a non-adaptive strategy and the soundness of the proof is guaranteed only with respect to such provers. As a result, PCPs can be used to prove any computation in <span class="math">\\mathcal{NEXP}</span>. In yet a different line of work, interactive argument systems and CS proof systems restricted the cheating provers in another way: they consider only cheating provers that run in time bounded by some function in the complexity of the statement to be proved. By relaxing the soundness requirement to hold only against computationally bounded provers, CS proofs can handle computation up to <span class="math">\\mathcal{NEXP}</span>. Overall, the works on efficient verifiability throughout the 70’s and 80’s—from the works on <span class="math">\\mathcal{NP}</span> to interactive proofs, PCPs to arguments and CS proofs—dedicated the bulk of their attention <em>“upwards”</em>, trying to achieve efficient (polynomial-time) verifiability for larger and larger classes of intractable (super polynomial-time) languages.</p>

    <p class="text-gray-300">In contrast, more recent developments starting with the work of Goldwasser, Kalai, and Rothblum <em>[x14]</em> have focused on “looking downwards”, trying to obtain <em>extremely efficient</em> (say, linear time) proof verification for <em>tractable</em> languages. This line of research is motivated by real-world applications, in particular, the application of outsourcing computation: In today’s network, there are computational devices of vastly different computational capabilities interacting with each other over the network. Some of these devices are computationally weak due to various resource constraints. To potentially allow a weak device to support a larger range of applications, including those that are beyond its reach computationally, a natural solution is to have a weak device—called the <em>delegator</em> in this case—to delegate computations that are too expensive to a more powerful device—called the <em>worker</em>—that is connected with the weak device via a network. Then the delegation problem is: how can a delegator be assured using its meager powers that the worker performed the computation correctly?</p>

    <p class="text-gray-300">The connection between the delegation problem and efficient proof verification is clear. View the delegator as a verifier and the worker as a prover that computes the result of a (pre-specified) polynomial time algorithm <span class="math">M</span> on some input <span class="math">x</span> and prove to the verifier that <span class="math">M(x)=y</span>. The input <span class="math">x</span> is thought of as dictated to the prover by an outside source, or by the verifier itself. The challenge of the delegation problem is to design a proof system which achieves “two-fold” efficiency: (1) relative efficiency of the prover, that is, the prover (i.e., the worker) can convince the verifier (i.e., the delegator) that <span class="math">M(x)=y</span> <em>without doing much more work</em> than evaluating <span class="math">M</span> on <span class="math">x</span> and (2) absolute efficiency of the verifier, that is, the verification requires <em>significantly less work</em> than evaluating <span class="math">M</span> on <span class="math">x</span>.</p>

    <p class="text-gray-300">More formally, a delegation system consists of a pair of polynomial time interactive Turing machines <span class="math">(D,W)</span> which, on input a polynomial time Turing machine <span class="math">M</span> , an input <span class="math">x</span>, and a security parameter <span class="math">1^{k}</span>, satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The computational complexity of the Workder/Prover <span class="math">W</span> is polynomial in the computational complexity of the algorithm <span class="math">M</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The computational complexity of the Delegator/Verifier <span class="math">D</span> is polynomial in the size of the input <span class="math">x</span> and poly-logarithmic in the computational complexity of <span class="math">M</span>.</li>

      <li>The communication complexity of the system is poly-logarithmic in the size of the input <span class="math">x</span> and poly-logarithmic in the computational complexity of <span class="math">M</span>.</li>

      <li>Completeness: If <span class="math">y</span> is the valid output of <span class="math">M(x)</span>, then the Worker <span class="math">W</span> convinces the Delegator <span class="math">D</span> of the correctness of <span class="math">y</span> with probability close to <span class="math">1</span>.</li>

      <li>Soundness: No cheating worker <span class="math">W^{\\prime}</span> can convince the (honest) verifier to accept an incorrect output <span class="math">y^{\\prime}\\neq M(x)</span> with non-negligible probability in the security parameter <span class="math">k</span>.</li>

    </ul>

    <p class="text-gray-300">Some remarks are in order. First, in the above formalization, we phrased the delegation problem as receiving the input <span class="math">x</span> as an input provided from the outside. In previous works, the input <span class="math">x</span> is often provided in a first message from verifer to prover, which allowed solutions in which the communication complexity was linear in <span class="math">n</span> beyond the need to communicate <span class="math">x</span>. We thus purposely stated <span class="math">x</span> as an outside input to properly count the communication complexity requirement of protocols. Obviously, if an application calls for the verifier to send the input <span class="math">x</span> to the prover such a message can be added. See Remark 2 in Section 5.2 for more detials. Second, in some settings it may be required to keep <span class="math">x</span> secret from the worker. We consider this a fundamentally different problem which we do not address in this work. Finally, we allow the verifier to run in time polynomial in the length of the input <span class="math">x</span>. One can actually remove this restriction and allow the verifier to run in time poly-logarithmic in the length of the input if it has access to an encoding of the input using an error correcting code. See Remark 3 in Section 6.1 for more details.</p>

    <p class="text-gray-300">Below for convenience, we will use the name delegator and verifier, as well as worker and prover, interchangeably. We will also assume that the running time <span class="math">t_{x}</span> of the delegated algorithm <span class="math">M</span> on input <span class="math">x</span> is bigger than the length of the input <span class="math">x</span> and that of the output <span class="math">y=M(x)</span>.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">The delegation problem is the focus of our work. To this end, we propose two solutions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.1.1 Solution 1: Non-Interactive Delegation—Designated Verifier CS-Proofs</h4>

    <p class="text-gray-300">The notion of Computationally-Sound (CS) proofs of <em>[x13]</em> when restricted to the case of polynomiall time computation is indeed the holy-grail of the delegation problem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">k</span> be a security parameter and <span class="math">n</span> is the size of the input <span class="math">x</span>. CS-proofs provide a non-interactive delegation system where to prove that <span class="math">y=M(x)</span>, the worker in time <span class="math">\\mathrm{poly}(k,t_{x})</span> can generate a certificate <span class="math">\\sigma</span> of the correctness of <span class="math">y</span> that has size poly-logarithmic in the running time <span class="math">t_{x}</span> of <span class="math">M</span> on input <span class="math">x</span>. The verifier on input <span class="math">x</span>, after receiving the certificate <span class="math">\\sigma</span>, verifies the correctness of the output <span class="math">y</span> in time $\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\mathrm{poly}(k,n,\\log t_{x})<span class="math"> (actually, the verifier runs in time quasi-linear in the input length </span>\\tilde{O}(n)\\cdot\\mathrm{poly}(k,\\log t_{x})<span class="math">). Additionally, the prover generates the certificate in time </span>\\mathrm{poly}(k,t_{x})<span class="math">. We note that the CS proof provides a delegation scheme that achieves instance-based , complexity that requires the running time of the worker, who is delegated the computation of </span>M<span class="math"> on an input </span>x<span class="math">, to depend on the running time </span>t_{x}<span class="math"> of </span>M<span class="math"> on that particular instance </span>x<span class="math"> (instead of the worst-case complexity of </span>M<span class="math">). A CS-proof is publically verifiable by any algorithm with access to </span>x<span class="math">, </span>M<span class="math"> and </span>\\sigma$, whereas no such requirement is enforced in a delegation scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Micali’s notion of CS proofs <em>[x13]</em> achieves such wondrous non-interactive delegation system, but, with a heavy price: The construction of CS proofs needs to revert to the random oracle model. In essence, the construction of CS proofs crushes the 4-round public-coin interactive argument system of Kilian <em>[x11]</em> into a single message by relying on the random oracle to serve both as a</p>

    <p class="text-gray-300">CRHF (to compress a PCP proof as in <em>[x10]</em>), and in addition as a Fiat-Shamir-hash-functions to remove interaction as in <em>[x5]</em>. Unfortunately, the possibility of implementing Fiat-Shamir-hash-functions by any hash function ensemble has been shown to be highly questionable <em>[x2, x11, x12]</em>, and remains to be a significant open problem in cryptography. On the other hand, outside the random oracle model, no non-interactive delegation system is known for full polynomial time computations, even if the delegation system can use a specific, designated, verifier.</p>

    <p class="text-gray-300">The possibility of non-interactive delegation is clearly most appealing. One may envision a delegator, using the computer facilities at a cloud to compute the result of an algorithm <span class="math">M</span>, receives later the result via an e-mail with a very short “certificate” of correctness that can be written down in its entirty. Toward this goal, several works, starting with <em>[x11]</em> and followed by the work of Gennaro, Gentry and Parno <em>[x12]</em>, and that by Chung, Kalai, and Vadhan <em>[x7]</em>, have considered a relaxation in which the verifier is a designated verifier. Namely, the verifier may register as a client of the worker and establish some information in an off-line stage (or even engage in an interactive protocol with the worker in an off-line stage) which will enable him to verify the correctness of the proofs provided by the prover later in an on-line stage. Intuitively, what distinguishes a designated verifier from any other algorithm is that it knows some secret which will enable him (and only him) to verify the correctness of the proofs and catch a cheating prover (who does not know the secret) if it tries to prove a false statement.</p>

    <p class="text-gray-300">Unfortunately, even with the relaxation of using a designated verifier, previous works do not match CS proofs. Let <span class="math">T</span> be the worst case complexity of computing <span class="math">M</span>. The construction of <em>[x11]</em> consists of one-time off-line stage with delegator complexity <span class="math">\\mathrm{poly}(\\log T,k)</span> in which the delegator posts one message to the worker of size <span class="math">\\mathrm{poly}(\\log T,k)</span>; then for every input <span class="math">x</span> the on-line stage is non-interactive (the worker sends a certificate <span class="math">\\sigma</span> of size <span class="math">\\mathrm{poly}(\\log T,k)</span> certifying the value of <span class="math">M(x)</span> which the delegator can verify), and is a function of the instance-based efficiency of the worker. But, it can only handle delegation of uniform <span class="math">\\mathcal{NC}</span>-computable algorithms. The designated verifier delegation schemes of <em>[x12, x7]</em> handle any <span class="math">P</span> time computation. However, they consist of a one-time off-line stage with delegator complexity <span class="math">\\mathrm{poly}(T,k)</span> , and then an on-line two-round interactive protocol of comunication complexity <span class="math">\\mathrm{poly}(\\log T,k,n)</span>. Thus, they only achieve amortized delegator computation complexity (and communication complexity) <span class="math">\\mathrm{poly}(\\log T,k,n)</span> over many inputs <span class="math">x</span>. The computational complexity of the worker in <em>[x12, x7]</em> depends on the worst-case complexity of the algorithm being delegated rather than instance-based complexity.</p>

    <p class="text-gray-300">Our first delegation system is a non-interactive designated verifier delegation scheme for all computation in <span class="math">\\mathcal{P}</span>. Additionally, the prover complexity is instance-based <span class="math">\\mathrm{poly}(k,t_{x})</span>. The delegators complexity in the off-line and on-line stages are respectively is <span class="math">\\tilde{O}(n)\\cdot\\mathrm{poly}(\\log t,k)</span> and <span class="math">\\tilde{O}(n)\\log\\mathrm{poly}(\\log T,k)</span>. Thus, the complexity guarantee is per input (not amortized).</p>

    <p class="text-gray-300">The soundness of our protocol is based on the assumption that leveled Fully Homomorphic Encryption (FHE) schemes exist, the intractability of DDH, and a new Knowledge of Exponent Assumption (KEA), called <span class="math">q</span>-KEA. The recent result of Brakersky and Vaikuntanathan <em>[x3]</em>, followed by Gentry <em>[x13]</em>, provides a leveled FHE scheme (that is, the scheme can homorphically evaluate over ciphtertexts any circuits of depth bounded by a prior polynomial) based on the intractability of the Learning With Errors (LWE) assumption. In fact, rather than assuming FHE, our construction can easily be transformed to use a PIR with receiver computation and communication complexities poly-logarithmic in the size of the database. For simplicity, we use FHE for the presentation.</p>

    <p class="text-gray-300">The knowledge of exponent assumption was originally introduced by Damgard <em>[x10]</em>, and later extended by Bellare and Palacio <em>[x4]</em> for showing the existence of 3-round zero-knowledge proofs. Our <span class="math">q</span>-KEA assumption generalizes their assumptions so that we say <span class="math">q</span>-KEA holds for a group <span class="math">G</span>, if it is infeasible for a challenger, given a random generator <span class="math">g=g_{0}</span>, <span class="math">q</span> random elements <span class="math">g_{1},\\ldots,g_{q}</span> in the group, along with their <span class="math">\\alpha^{\\text{th}}</span> powers (i.e., <span class="math">g_{0}^{\\alpha},\\ldots,g_{q}^{\\alpha}</span>), to generate a pair <span class="math">c,\\hat{c}=c^{\\alpha}</span>, without actually “knowing” coefficients <span class="math">a_{0},\\ldots,a_{q}</span> such that <span class="math">c=\\prod_{i=0}^{q}g_{i}^{a_{i}}</span>. Here, “knowing” is captured by requiring that there exists a non-black-box extractor, who can depends on the code of the challenger, to extract out these <span class="math">a_{i}</span>’s. Our assumption is similar and in fact inspired by the assumption made by Groth <em>[x16]</em>. However, the actual assumption is incomparable with that of Groth.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (Informal, Non-Interactive Designed Verifier Delegation Scheme)</h6>

    <p class="text-gray-300">Assume the existence of a leveled fully homomorphic encryption scheme, the intractability of DDH and that <span class="math">q</span>-KEA holds. Then, there exists a delegation scheme <span class="math">(D,W)</span> with the following properties: Let <span class="math">k</span> be a security parameter,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a polynomial time computable function (algorithm) <span class="math">M:\\{0,1\\}^{n}\\to\\{0,1\\}^{*}</span> of worst casr complexity T, the delegator in an off-line stage sends to the worker one message and keeps some secret information for later on-line stage. The computation complexity of the delegator in the off-line stage is <span class="math">\\tilde{O}(n)\\text{poly}(k,\\log T)</span> and the commnication complexity is <span class="math">\\text{poly}(k,\\log T)</span></li>

      <li>For any input <span class="math">x\\in\\{0,1\\}^{n}</span>, the worker in an on-line stage sends the output of the computation <span class="math">y=M(x)</span> and a proof of size <span class="math">\\text{poly}(k,\\log t_{x})</span>, where <span class="math">t_{x}</span> is the running time of <span class="math">M</span> on <span class="math">x</span>. Furthermore, the worker runs in time <span class="math">\\text{poly}(k,t_{x})</span> and the delegator runs in time <span class="math">\\tilde{O}(n)\\text{poly}(k,\\log t_{x})</span>.</li>

    </ol>

    <p class="text-gray-300">Compared with the original CS proofs of Micali, proofs of the delegation scheme of Theorem 1 can only be verify by a verifier who holds the secret information generated in the off-line stage, whereas the CS proofs are publically verifiable in the random oracle model. Therefore, we also call such proof system a designated verifier CS proof system.</p>

    <p class="text-gray-300">There is one issue with the soundness of our designated verifier delegation schemes which seems – so far– to be an inherent problem in all existing (including <em>[x15, x12, x11]</em>) designed verifier delegation schemes: the soundness of the system holds only under the restriction that the cheating worker does not learn whether the verifier accepts or rejects previous proofs from the prover. Alternatively stated, as soon as the delegator rejects one proof from the worker (and the worker is aware of that), soundness can no longer be claimed. The problem is that the worker can deviate from the protocol and generates messages to the verifier “improperly” so that by learning the verdicts of the verifier as a feedback, it can learn some information about the secret held by the designated verifier, which will then enable it to prove invalid statements later. We note that this is reminiscent of the problem encountered in the context of chosen ciphertext secure encryption schemes: Access to a decryption protocol with improperly formed ciphertexts may reveal information about the secret key and thus can compromise the security of the scheme. In the context of delegation, we call this the verifier rejection problem.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.1.2 Solution 2: Two-Message Interactive Argument System</h4>

    <p class="text-gray-300">Our second solution is a two-message delegation scheme for all of <span class="math">\\mathcal{P}</span> that addresses the verifier rejection problem. Compared with our first scheme (which does suffer from the verifier rejection problem), this scheme is interactive (consisting of two messages) and the delegator only has worst-case complexity (the worker still has instance-based complexity). More formally, we obtain:</p>

    <p class="text-gray-300">Theorem 2 (Informal, Delegation Scheme without Verifier Rejection Problem) Assume the existence of a leveled fully homomorphic encryption scheme, the intractability of DDH, and that <span class="math">q</span>-KEA holds. Then, there exists a delegation system <span class="math">(D,W)</span> with the following properties: Let <span class="math">k</span> be a security parameter,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a polynomial time computable function (algorithm) <span class="math">M:\\{0,1\\}^{n}\\to\\{0,1\\}^{*}</span> of worst case complexity <span class="math">T</span>, and an input <span class="math">x\\in\\{0,1\\}^{n}</span>, the worker and the delegator interacts with each other in a 2-rounds protocol. The communication complexity of the protocol is <span class="math">\\mathrm{poly}(k,\\log T)</span>. The computational complexity of the worker and the delegator are respectively, <span class="math">\\mathrm{poly}(k,t_{x})</span> and <span class="math">\\tilde{O}(n)\\mathrm{poly}(k,\\log T)</span>, where <span class="math">t_{x}</span> is the running time of <span class="math">M</span> on <span class="math">x</span>.</li>

      <li>Soundness holds even against a cheating worker that is aware of the verdicts of the delegator. That is, it is infeasible for a cheating worker to convince the honest verifier to accept an incorrect output <span class="math">y\\neq M(x)</span> even if the worker learns whether the delegator accept or reject previous proofs for other inputs.</li>

    </ol>

    <p class="text-gray-300">Let us briefly compare our interactive solution to previous interactive arguments which can be used as delegation systems. Kilian <em>[x11, x12]</em> gives an 4-round argument system for any <span class="math">\\mathcal{NP}</span> computation, with communication complexity that is polylogarithmic, and verifier runtime which is linear in the input length (up to polylogarithmic factors), This is achieved by a constant round (four rounds) protocol, in which the prover first constructs a PCP for the correctness of the computation, and then Merkle-hashes it down to a short string and sends it to the verifier. To prove the soundness of his scheme, Kilian must assume the existence of strong collision-intractable hash functions: where collisions cannot be formed in sub-exponential time.</p>

    <p class="text-gray-300">For uniform <span class="math">\\mathcal{NC}</span> computations, <em>[x10]</em> shows how to combine their interactive proofs with a technique of Kalai and Raz <em>[x13]</em> to give a two round delegation system for polynomial time bounded provers for <span class="math">\\mathcal{NC}</span> computations based on the existence of a private information retrieval system (PIR) which achieves poly-logarithmic communication. Such PIR were first proposed by Cachin, Micali, and Stadler <em>[x4]</em> based on the <span class="math">\\phi</span>-hiding assumption and most recently by Brakersky and Vaikuntanathan <em>[x5]</em> based on the intractability of the LWE assumption.</p>

    <p class="text-gray-300">We note that a 2008 paper by Di Crescenzo and Lipmaa <em>[x5]</em> proposes a two-round argument with prover and verifier complexity and communication complexity as required for a delegation solution, but they do not prove soundness based on a computational assumption but rather, essentially their soundness proof assumes a restriction on the cheating prover: essentially if an efficient cheating prover can convince the verifier to accept the statement <span class="math">x\\in L</span> it must be able to reconstruct a PCP proof of the statement. The question of two-round delegation argument systems for general <span class="math">\\mathcal{P}</span> time computations and for (unrestricted class) polynomial time adversaries under computational assumptions thus remained open.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Our Techniques</h3>

    <p class="text-gray-300">The key tool that enables our construciton is an extractable collision resistant hash function. A collision resistent hash function (CRHF) is, informally speaking, a polynomial-time computable function <span class="math">\\mathcal{H}</span> mapping binary strings of arbitrary length into reasonably short strings, so that it is computationally infeasible to find any collision (for <span class="math">\\mathcal{H}</span>), that is, any two different strings <span class="math">x</span> and <span class="math">y</span> for which <span class="math">\\mathcal{H}(x)=\\mathcal{H}(y)</span>. In this work, we will consider CRHF that are additionally “extractable”: Given a hash value, a preimage can be extracted efficiently. However, in general, such a construct cannot exist, since CRHF is one-way. To circumvent this problem, we will consider non-black-box extraction, that is, a preimage of a hash value can be extracted if the extractor “sees” the “code” of</p>

    <p class="text-gray-300">the machine that outputs that hash value. However, this relaxation alone is not sufficient to allow us to circumvent the impossibility. Consider, for instance, a hash function whose range is the set of all <span class="math">k</span>-bit binary strings. In this case, a random hash value can be generated by simply tossing <span class="math">k</span> random coins. But, given the code of such a sampling algorithm does not help invert the hash value at all. Instead, we require that values output by an extractable CRHF have some special structure; then, only for those valid hash values, a preimage can be extracted (in a non-black-box way).</p>

    <p class="text-gray-300">Not surprisingly, we can construct such an extractable CRHF based on the <span class="math">q</span>-KEA assumption. Our construction is similar to the construction of commitments with knowledge by Groth <em>[x11]</em>, which in turn is based on a variant of the Pedersen commitment scheme. Let <span class="math">G</span> be a group in which DDH and <span class="math">q</span>-KEA holds, meaning that given properly sampled <span class="math">g_{0},\\ldots,g_{q}</span> in <span class="math">G</span>, along with their <span class="math">\\alpha^{\\text{th}}</span> powers <span class="math">\\hat{g}_{0},\\ldots,\\hat{g}_{q}</span>, if a challenger generates a pair <span class="math">c,\\hat{c}=c^{\\alpha}</span>, then, there exists an extractor that extracts coefficients <span class="math">a_{0},\\ldots,a_{q}</span> such that <span class="math">c=\\prod_{i=0}^{q}g_{i}^{a_{i}}</span>. Then to hash a vector of elements <span class="math">e_{0},\\ldots,e_{q}</span>, our CRHF simply outputs a pair <span class="math">c=\\prod_{i=0}^{q}g_{i}^{a_{i}}</span> and <span class="math">\\hat{c}=\\prod_{i=0}^{q}(\\hat{g}_{i})^{a_{i}}</span>. The collision resistence property of the hash function follows from the DDH assumption, and the extractability follows from <span class="math">q</span>-KEA, since every valid output of the hash function satisfies that <span class="math">\\hat{c}=c^{\\alpha}</span>, then by <span class="math">q</span>-KEA, a pre-image <span class="math">e_{0},\\ldots,e_{q}</span> can be extracted. Given such an extractable CRHF, next we provide an overview of our construction of delegation schemes.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.2.1 Overview of Our Approach</h4>

    <p class="text-gray-300">Similar to CS proofs in <em>[x12]</em>, the overall approach to our construction is also to collapse rounds of the 4-message public-coin zero-knowledge argument of Kilian <em>[x10]</em>, which in turn relies on PCP proofs and the notion of Merkle trees. So let us start by briefly reviewing them:</p>

    <p class="text-gray-300">Probabilistic Checkable Proofs: Loosely speaking, a probabilistically checkable proof system (PCP) for a language consists of a probabilistic polynomial-time verifier having direct access to individual bits of a binary string. This string (called oracle) represents a proof, and typically will be accessed only partially by the verifier. Queries to the oracle are positions on the bit string and will be determined by the verifier’s input and coin tosses. The verifier is supposed to decide whether a given input belongs to the language. If the input belongs to the language, the requirement is that the verifier will always accept given access to an adequate oracle. On the other hand, if the input does not belong to the language, then the verifier will reject with probability at least 1- <span class="math">\\varepsilon</span> for some small error bound <span class="math">\\varepsilon</span>, no matter which oracle is used. A formal definition of PCP can be found in section 3.3. We care about the complexity of the PCP verifier, in particular, the number of random coins it tosses <span class="math">p_{r}(n)</span> and the number of queries <span class="math">p_{q}(n)</span> it issues on input a statement of length <span class="math">n</span>. Below we use polynomials <span class="math">p_{r}</span> and <span class="math">p_{q}</span> to denote the complexity of the PCP verifier.</p>

    <p class="text-gray-300">Merkle Trees: A Merkle tree <em>[x13]</em> is a binary tree whose nodes are associated with values. A leaf node can store any value, but each internal node stores a value that is the hash of the concatenation of the values in its children through a collision-resistent hash function <span class="math">\\mathcal{H}</span>. Thus, if <span class="math">\\mathcal{H}</span> produces <span class="math">k</span>-bit outputs, each internal node of a Merkle tree, including the root, stores a <span class="math">k</span>-bit value.</p>

    <p class="text-gray-300">The crucial property of a Merkle tree is that, unless one succeeds in finding a collision for <span class="math">\\mathcal{H}</span>, it is computationally hard to change any value in the tree without also changing the root value. This property allows a party <span class="math">A</span> to “commit” to <span class="math">n</span> values, <span class="math">v_{1},\\ldots,v_{l}</span> (for simplicity assume <span class="math">l=2^{d}</span> for some integer <span class="math">d</span>), by means of a single <span class="math">k</span>-bit value. That is, <span class="math">A</span> stores value <span class="math">v_{i}</span> in the <span class="math">i^{\\text{th}}</span> leaf of a full binary tree of depth <span class="math">d=\\log l</span>, and uses a collision-free hash function <span class="math">\\mathcal{H}</span> to build a Merkle tree, thereby obtaining a <span class="math">k</span>-bit value, <span class="math">rv</span>, stored in the root.</p>

    <p class="text-gray-300">More interestingly, <span class="math">A</span> may “prove” what a particular <span class="math">v_{i}</span> was “locally” by revealing just <span class="math">d+1</span></p>

    <p class="text-gray-300">values: <span class="math">v_{i}</span> together with its authentication path <span class="math">ap_{i}</span>, that is, the values stored in the siblings of the nodes along the path from leaf <span class="math">i</span> (included) to the root (excluded), <span class="math">Y_{1},\\ldots,Y_{d}</span>. It follows from the collision resistance property of <span class="math">\\mathcal{H}</span> again that it is infeasible for <span class="math">A</span> to come up with two different pairs of values and authentication paths that are both consistent with <span class="math">rv</span>.</p>

    <p class="text-gray-300">Kilian’s Construction: In <em>[x10]</em> Kilian presents a special zero-knowledge argument for <span class="math">\\mathcal{NP}</span>, <span class="math">(P_{k},V_{k})</span>, exhibiting a polylogarithmic amount of communication, where prover <span class="math">P_{k}</span> uses a Merkle tree in order to provide to <span class="math">V_{k}</span> “virtual access” to a PCP proof. Below we describe the Kilian’s protocol disregards the ZK property; our description is based on that presented in <em>[x2]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prove a statement <span class="math">x\\in L</span>, the verifier <span class="math">V_{k}</span> starts by sending the prover a CRHF <span class="math">\\mathcal{H}</span> with output length <span class="math">k</span>. The prover on private input a witness <span class="math">w</span>, constructs a PCP-proof <span class="math">\\pi</span>. In order to yield efficient verifiability, <span class="math">P_{k}</span> cannot send <span class="math">V_{k}</span> the witness <span class="math">w</span> nor <span class="math">\\pi</span>. Rather, <span class="math">P_{k}</span> builds a Merkle tree with the proof <span class="math">\\pi</span> as the leaf values (using the collision-free hash function <span class="math">\\mathcal{H}</span> from the verifier) producing a <span class="math">k</span>-bit root value <span class="math">rv</span>. It then “commits” itself to <span class="math">\\pi</span> by sending <span class="math">rv</span> to the verier <span class="math">V_{k}</span>. Since the Merkle tree is a full binary tree, the depth of the tree generated will be $d=\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; as the length of the proof is in turn bounded polynomially by the length of the witness, we have </span>d=O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The verier </span>V_{k}<span class="math"> then tosses </span>p_{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> random coins </span>r<span class="math"> and sends them to the prover. Both the prover </span>P_{k}<span class="math"> and the verifier </span>V_{k}<span class="math"> computes the queries </span>q_{1},\\ldots,q_{s}<span class="math"> (</span>s=p_{q}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">) by internally running the PCP verifier on input </span>x<span class="math"> and </span>r<span class="math">. The prover </span>P_{k}<span class="math"> answers those queries by sending back answers </span>a_{1},\\ldots,a_{s}<span class="math"> together with their authentication paths </span>ap_{1},\\ldots,ap_{s}<span class="math">. </span>V_{k}<span class="math"> then checks whether </span>a_{j}<span class="math">’s authentication path is consistent with </span>rv<span class="math">, and, if so, it is assured that </span>a_{j}<span class="math"> is the original value because the prover, being polynomial-time, cannot find a collision for </span>\\mathcal{H}<span class="math">. Finally, if any query answers and its corresponding authentication path are not consistent with </span>rv<span class="math">, </span>V_{k}<span class="math"> rejects. Otherwise, it runs the PCP verifier on these answers </span>(x,a_{1},\\ldots,a_{s})<span class="math"> and accepts if and only if the PCP verifier accepts. Because </span>V_{pcp}<span class="math"> only makes </span>p_{q}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> queries and each query will be answered by </span>kd=O(k\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> bits of authentication path, the overall amount of communication is polylogarithmic in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At a very high-level, the soundness of Kilian’s protocol follows from the fact that the Merkle tree provides the verifier “virtual access” to the PCP proof, in the sense that given the root value of the Merkle tree, for every query <span class="math">q</span>, it is infeasible for a cheating prover to answer <span class="math">q</span> differently depending on the queries. Therefore, interacting with the prover is “equivalent” to having access to a PCP proof oracle. Then it follows from the soundness of the PCP system that Kilian’s protocol is sound.</p>

    <p class="text-gray-300">Our Approach: We collapse rounds of the Kilian’s protocol in two steps. First, we “compress” the two verifier’s messages into one, which turns the protocol into a two-message protocol <span class="math">(P_{2},V_{2})</span>, using a leveled FHE scheme and assuming DDH and <span class="math">q</span>-KEA. This two-message protocol essentially yields our second delegation solution. It does not suffer from the verifier rejection problem since it does not have an off-line stage and thus the delegator does not rely on any secret information. Therefore, even if the worker learns the verdicts of the verifier, soundness still holds for the soundness of interactive arguments is closed under sequential composition.</p>

    <p class="text-gray-300">More precisely, let <span class="math">E=(\\text{KeyGen},\\text{Enc},\\text{Dec})</span> be a leveled FHE scheme. To prove a statement <span class="math">x</span>, the prover <span class="math">P_{2}</span> and the verifier <span class="math">V_{2}</span> proceed as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">V_{2}</span> samples a random public and private key pair, <span class="math">(pk,sk)\\leftarrow\\text{KeyGen}(1^{k},1^{L})</span> (where <span class="math">L</span> is polylogarithmic in a bound on the length of the PCP proof of <span class="math">x</span>), and a random $p_{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-bit string </span>r<span class="math"> that will work as the random tape of the PCP verifier. It then sends a CRHF </span>\\mathcal{H}<span class="math">, </span>pk<span class="math"> and an encryption </span>c<span class="math"> of </span>r<span class="math"> under </span>pk<span class="math">, i.e., </span>c=\\text{Enc}_{pk}(r)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">P_{2}</span> first computes the PCP proof <span class="math">\\pi</span> and builds a Merkle tree <span class="math">\\mathcal{T}</span> using <span class="math">\\mathcal{H}</span> from <span class="math">\\pi</span> as in Kilian’s protocol, producing a root value <span class="math">rv</span>. It then tries to compute the PCP queries <span class="math">(q_{1},\\ldots,q_{s})</span> based on the input <span class="math">x</span> and the random coins <span class="math">r</span>; however, since it</li>

    </ul>

    <p class="text-gray-300">only receives an encryption <span class="math">c</span> of <span class="math">r</span>, it cannot evaluate <span class="math">q_{1},\\ldots,q_{s}</span> directly. Instead, it computes those queries fully homomorphically over <span class="math">x</span> and <span class="math">c</span>, producing encryptions <span class="math">c^{\\prime}</span> of <span class="math">q_{1},\\ldots,q_{s}</span>. It further computes answers <span class="math">a_{1},\\ldots,a_{s}</span> and the corresponding authentication paths <span class="math">ap_{1},\\ldots,ap_{s}</span> again fully homomorphically (over <span class="math">\\pi</span>, <span class="math">\\mathcal{T}</span>, and <span class="math">c^{\\prime}</span>), yielding encryptions <span class="math">c^{\\prime\\prime}</span>. Finally it sends back <span class="math">rv</span> and <span class="math">c^{\\prime\\prime}</span>. The verifier after receiving <span class="math">rv</span> and <span class="math">c^{\\prime\\prime}</span>, decrypts <span class="math">c^{\\prime\\prime}</span> to obtain <span class="math">a_{1},\\ldots,a_{s}</span> and <span class="math">ap_{1},\\ldots,ap_{s}</span>. It then runs the same decision procedure as <span class="math">V_{k}</span> in Kilian’s protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given the two-message protocol <span class="math">(P_{2},V_{2})</span>, notice that the verifier’s message is almost “oblivious” of the input <span class="math">x</span>, and only depends on its length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (for deciding a bound on the length of the PCP proof for </span>x<span class="math"> and the number of coins tosses needed). Thus the first message can be generated beforehand by a trusted third party and the two-message protocol can be turned into a designated verifier delegatio system </span>(P_{1},V_{1})<span class="math">—or a desigated verifier CS proof system—yielding our first delegation solution. More precisely, the delegator </span>V_{1}<span class="math"> in the off-line stage generates a message </span>(\\mathcal{H},pk,\\mathrm{Enc}_{pk}(r))<span class="math"> as </span>V_{2}<span class="math"> does in the first round; </span>V_{1}<span class="math"> sends the message to the worker and keeps </span>r<span class="math"> and the secret key </span>sk<span class="math"> as its secret information. Later in the on-line stage, the worker </span>P_{1}<span class="math"> proceeds the same as </span>P_{2}<span class="math"> does in the second round; then the delegator decides whether to accept or reject as </span>V_{2}$ does.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The soundness of the designated verifier CS proof <span class="math">(D,P,V)</span> follows directly from the soundness of the protocol <span class="math">(P_{2},V_{2})</span>. Intuitively, it seems that the latter should follow from the semantically security of the level FHE scheme. By the soundness of the PCP system, it is infeasible for a cheating prover to generate a proof for a false statement that convinces an honest PCP verifier (except from negligible probability). Furthermore, by the semantic security of the leveled FHE scheme, even if the cheating prover additionally receives an encryption of the random tape of the PCP verifier, it is still infeasible to generate an accepting proof. Then, as argued above for Kilian’s protocol, since the Merkle tree provides “virtual access” to the proof, the cheating prover fails with overwhelming probability. The above argument is indeed very tempting. However, we do not manage to make it go through. The problem lies in the last part of the argument: unlike the case in Kilian’s protocol where the verifier gets direct “virtual access” to the PCP proof, in our protocol, the verifier gets encrypted answers to the PCP queries and their corresponding authenticating paths back. Then suddenly, the cheating prover may be able to create some “rogue” connection between the encryption of the verifier’s random tape, the root value of the Merkle tree and its encrypted answers.</p>

    <p class="text-gray-300">To overcome this problem, we instantiate our designated verifier CS proof system with an extractable CRHF. We claim that such a proof system is sound. At a very high level, assume for contradiction that there exists a cheating prover that can prove a false statement, that is, given an encryption of the randomness of the PCP verifier, it manages to produce a root value <span class="math">rv</span>, sends back encrypted answers to the PCP verifier’s queries together with authentication paths (also encrypted) that are consistent with <span class="math">rv</span>, and its answers convince the PCP verifier. Since the CRHF is extractable, one can extract out the values associated with the children of the root that hash to <span class="math">rv</span>. Furthermore, by applying the extractability property recursively, we can further, level by level, extract out the values associated with the whole Merkle tree that hashes to <span class="math">rv</span>. It then follows from the collision resistence property of the hash function that this extracted tree must “agree” with the prover’s answers, that is, the authentication paths sent by the prover must be the same as the corresponding paths in the tree. Thus we obtain a machine that (given an encryption of the randomness of the verifier), outputs convincing answers to PCP queries in plaintext. This contradicts with either the soundness of PCP or the semantic security of the fully homomorphic encryption scheme.</p>

    <p class="text-gray-300">There is one caveat in the argumentment above. When applying the extractablity of the CRHF to extract out a Merkle tree from a root value <span class="math">rv</span>, the time of extraction soon explode. Consider,</p>

    <p class="text-gray-300">for instance, that if extracting the preimage of a hash value output by a <span class="math">t</span>-time machine takes time <span class="math">t^{2}</span>. Then, after applying extraction recursively for <span class="math">d</span> times, the total extraction time grows double exponentially to <span class="math">t^{2^{d}}</span>. In comparison, we need to keep the extraction time “tamed”—in polynomial time—so that the FHE scheme remains semantically secure. We resolve this problem by utilizing the fact that our extractable CRHF has a very high “compression” rate: The ratio between the length of the input and that of the output is <span class="math">k</span> (assuming <span class="math">q</span>-KEA with <span class="math">q=2k-1</span>). Therefore, we can build a very “flat” Merkle tree by allowing each internal nodes to have <span class="math">k</span> children. In this way, we can “commit” to any polynomial length string (or proof for delegation) into a root value of a constant depth Merkle tree. As a result, the extraction time for such a Merkle tree is still bounded by a polynomial. Finally, we remark that since the extraction time is bounded by a polynomial, it suffices to require our extractable CRHF to be collision resistant against polynomial time adversaries. On the other hand, Kilian’s 4-round interactive argument system rely on a CRHF that is collision resistant against even sub-exponential adversaries. On a very high level, this difference stems from the fact that in our security proof, we use a strategy that finds a collision in polynomial time (by comparing the encrypted authentication paths from the cheating prover with that in the extracted Merkle tree from the root value from the prover), whereas the collision-finding strategy in Kilian’s proof runs in sub-exponential time.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.3 Other Related Works</h3>

    <p class="text-gray-300">Scaling down classical works on interactive proofs to address polynomial time languages result in non-polynomial time provers. In particular, the work of Lund, Fortnow, Karloff and Nissan <em>[x14]</em> and that of Shamir <em>[x20]</em>, the honest prover runs in super-polynomial time even for <span class="math">log</span>-space languages. The work of Fortnow and Lund <em>[x11]</em>, using algebraic methods extending <em>[x14, x20]</em>, does explicitly address the question of interactive proofs for polynomial time languages and in particular <span class="math">\\mathcal{NC}</span>. Their protocol, however, has a non-polynomial time prover as in <em>[x14, x20]</em>.</p>

    <p class="text-gray-300">The more recent work of Goldwasser, Kalai, and Rothblum <em>[x12]</em> provided an interactive proof to the delegation problem with a polynomial time prover, and verifier computation and communication complexity poly-logarithmic in the time of the computation, for uniform <span class="math">\\mathcal{NC}</span> algorithms. Their protocol requires poly-logarithmic rounds of communication for <span class="math">\\mathcal{NC}</span> computations. More generally, for general (non <span class="math">\\mathcal{NC}</span>) uniform circuit families, they provide an interactive protocol where the verifier time complexity, round complexity, and total communication complexity is a polynomial in the depth of the circut rather than its size.</p>

    <p class="text-gray-300">The work of Babai, Fortnow, Levin and Szegedy <em>[x3]</em> on Holographic Proofs for <span class="math">\\mathcal{NP}</span>—namely, PCP-proofs where the input is assumed to be presented to the verifier in an error-correcting-code format—raise similar complexity goals as in the delegation problem, requiring super-efficient verifiability (linear time in the input length and poly-logarithmic in the computation time), and efficient provability (polynomial time in the non-deterministic time complexity of accepting the input). However, the model of PCP in which they can obtain their results does not provide a solution to the delegation problem, as it proves soundness only against non-adaptive provers. Let us elaborate. <em>[x3]</em> shows how to achieve verification time that is polylogarithmic in the length of the computation (on top of the time taken to convert the input into an error correcting code format), and a PCP-proof-string of length close to the computation time itself. However the soundness of proofs in the PCP model (as well as its more efficient descendants <em>[x22, BSGH^{+}06, BSGH^{+}05, x10]</em>) requires that the verifier/delegator will either ‘poses’ the entire PCP-proof-string (although the verifier will only read a few bits of it), or somehow have a guarantee that the prover/delegatee cannot change any bit of the PCP-proof-string after the verifier has started to request bits of it. Such guarantee is not achievable over a network as required in the delegation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">off-line</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">on-line</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ref</td>

            <td class="px-3 py-2 border-b border-gray-700">Assumption</td>

            <td class="px-3 py-2 border-b border-gray-700"># msgs</td>

            <td class="px-3 py-2 border-b border-gray-700">D complexity</td>

            <td class="px-3 py-2 border-b border-gray-700"># msgs</td>

            <td class="px-3 py-2 border-b border-gray-700">D complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">W complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">Rejection</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GKR08</td>

            <td class="px-3 py-2 border-b border-gray-700">none</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(d, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(n, d, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BFL91, BFLS91</td>

            <td class="px-3 py-2 border-b border-gray-700">none</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(n, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kil92, Mic00</td>

            <td class="px-3 py-2 border-b border-gray-700">CRH</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kil92, Mic00</td>

            <td class="px-3 py-2 border-b border-gray-700">RO-Heur</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GKR08, KR09</td>

            <td class="px-3 py-2 border-b border-gray-700">PIR</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, d, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GGP09</td>

            <td class="px-3 py-2 border-b border-gray-700">FHE</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, T)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, T)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CKV10-Thm5</td>

            <td class="px-3 py-2 border-b border-gray-700">FHE</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, T)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, T)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CKV10-Thm6</td>

            <td class="px-3 py-2 border-b border-gray-700">FHE</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, T)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Del1</td>

            <td class="px-3 py-2 border-b border-gray-700">PIR, DDH, q-KEA</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log t)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Del2</td>

            <td class="px-3 py-2 border-b border-gray-700">PIR, DDH, q-KEA</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(k, n, t)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Results on Delegating Computation.  <span class="math">D =</span>  delegator/verier,  <span class="math">W =</span>  worker/prover,  <span class="math">k =</span>  security parameter. Parameters of computation  <span class="math">f</span>  being delegated:  <span class="math">n =</span>  input length,  <span class="math">T =</span>  maximum running time of  <span class="math">f</span> ,  <span class="math">t = t_x =</span>  running time of  <span class="math">f</span>  on input  <span class="math">x</span> ,  <span class="math">d =</span>  depth/parallel time (we assume  <span class="math">n \\leq T \\leq 2^d</span> ).</p>

    <p class="text-gray-300">setting.</p>

    <p class="text-gray-300">Another related work is the recent work Chung, Kalai, Liu and Raz <em>[x1]</em>, relying on the existence of FHE scheme, addresses the question of memory delegation. Here, a delegator sends the entire content of its memory to a worker in an initial stage and from there on can issue some editing commands and can quickly verify the result of computations done by the worker on the memory. Our protocol can be used on top of the memory delegation scheme to enable the efficient verification of <span class="math">\\mathcal{P}</span> time computations on the memory either using our first or second solution.</p>

    <p class="text-gray-300">A related construct to our extractable collision resistant hash functions is the one-way extractable functions of Canetti and Dakdouk <em>[x2]</em> which required that any party that manages to compute a value in the range of the function “knows” a corresponding preimage.</p>

    <p class="text-gray-300">We summarize the known results in Table 1.3.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Outline</h2>

    <p class="text-gray-300">In Section 3 we provide some preliminaries and definitions of assumptions and primitives that we rely on. In Section 4, we introduce the notion of extractable collision resistant hash funcitons and provide a construction based on a new knowledge of exponent assumption called <span class="math">q</span>-KEA in Section 4.1. Using extractable collision resistent hash functions, we construct a designated verifier CS proof system in Section 5. Finally, we obtain two schemes for delegating computation from a designated verifer CS proof system in Section 6.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">N</span> denote the set of all positive integers. For any integer <span class="math">n\\in N</span>, let <span class="math">[n]</span> denote the set <span class="math">\\{1,2,\\ldots,n\\}</span>, We denote by <span class="math">\\{0,1\\}^{n}</span> the set of binary strings of length <span class="math">n</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the length of a binary string. We denote by </span>\\mathcal{PPT}$ probabilistic polynomial time Turing machines. We assume familiarity with interactive Turing machines, denoted ITM, interactive protocols, and computational indistinguishability; the formal definitions of interactive protocols and comutational indistinguishability are provided in Appendix A.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 The DDH Assumption</h3>

    <p class="text-gray-300">let <span class="math">\\mathcal{G}</span> take a security parameter <span class="math">k</span> written in unary and output a description of a group <span class="math">(p,G)\\leftarrow\\mathcal{G}(1^{k})</span> such that <span class="math">p</span> is a <span class="math">k</span> bit prime and <span class="math">G</span> is a cyclic group of order <span class="math">p</span>. The DDH assumption holds for <span class="math">\\mathcal{G}</span> if the following two ensembles are computationally indistinguishable.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left\\{(p,G)\\leftarrow\\mathcal{G}(1^{k}),\\ g\\leftarrow_{R}G-\\{0\\}\\,,\\ (a,x)\\leftarrow_{R}\\mathbb{Z}_{p}^{2}\\ :\\ (g,g^{x},g^{a},g^{ax})\\right\\}_{k\\in N}</span></li>

      <li><span class="math">\\left\\{(p,G)\\leftarrow\\mathcal{G}(1^{k}),\\ g\\leftarrow_{R}G-\\{0\\}\\,,\\ (a,x,r)\\leftarrow_{R}\\mathbb{Z}_{p}^{3}\\ :\\ (g,g^{x},g^{a},g^{r})\\right\\}_{k\\in N}</span></li>

    </ul>

    <p class="text-gray-300">The DDH assumption implies that for every polynomial <span class="math">q</span>, the following ensembles are indistinguishable.</p>

    <p class="text-gray-300">\\[ \\left\\{(p,G)\\leftarrow\\mathcal{G}(1^{k}),\\ g\\leftarrow_{R}G-\\{0\\}\\,,\\ a\\leftarrow_{R}\\mathbb{Z}_{p},\\ (x_{1},\\ldots,x_{q(k)})\\leftarrow_{R}\\mathbb{Z}_{p}^{q(k)}:\\right.\\\\ \\left.\\left.(g,g^{x_{1}},\\ldots,g^{x_{q(k)}},g^{a},g^{ax_{1}},\\ldots,g^{ax_{q}(k)})\\right.\\right\\}_{k\\in N} \\]</p>

    <p class="text-gray-300"><span class="math">\\Big{\\{}(p,G)\\leftarrow\\mathcal{G}(1^{k}),\\ g\\leftarrow_{R}G-\\{0\\}\\,,\\ a\\leftarrow_{R}\\mathbb{Z}_{p},\\ (x_{1},\\ldots,x_{q(k)})\\leftarrow_{R}\\mathbb{Z}_{p}^{q(k)},\\ (r_{1},\\ldots,r_{q(k)})\\leftarrow_{R}\\mathbb{Z}_{p}^{q(k)}:</span></p>

    <p class="text-gray-300"><span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span></p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 Fully Homomorphic Encryption Schemes</h3>

    <p class="text-gray-300">A public-key encryption scheme <span class="math">\\mathrm{E}=</span> (KeyGen; Enc; Dec) is said to be fully homomorphic if it is associated with an additional polynomial-time algorithm <span class="math">\\mathrm{Eval}</span>, that takes as input a public key <span class="math">pk</span>, a ciphertext <span class="math">\\hat{x}=\\mathrm{Enc}_{pk}(x)</span> and a circuit <span class="math">C</span>, and outputs, a new ciphertext <span class="math">c=\\mathrm{Eval}_{pk}(\\hat{x};C)</span>, such that <span class="math">\\mathrm{Dec}_{sk}(c)=C(x)</span>, where <span class="math">sk</span> is the secret key corresponding to the public key <span class="math">pk</span>. It is required that the size of <span class="math">c=\\mathrm{Eval}_{pk}(\\mathrm{Enc}_{pk}(x);C)</span> depends polynomially on the security parameter and the length of <span class="math">C(x)</span>, but is otherwise independent of the size of the circuit <span class="math">C</span>. We also require that <span class="math">\\mathrm{Eval}</span> is deterministic, and the the scheme has perfect correctness (i.e. it always holds that <span class="math">\\mathrm{Dec}_{sk}(\\mathrm{Enc}_{pk}(x))=x</span> and that <span class="math">\\mathrm{Dec}_{sk}(\\mathrm{Eval}_{pk}(\\mathrm{Enc}_{pk}(x);C))=C(x)</span>). For security, we simply require that <span class="math">\\mathrm{E}</span> is semantically secure.</p>

    <p class="text-gray-300">In a recent breakthrough, Gentry <em>[x10]</em> proposed a fully homomorphic encryption scheme based on ideal lattices. Following this, Dijk, Gentry, Halevi and Vaikuntanathan<em>[x13]</em> proposed an alternative construction based on the extended GCD assumption. Very recently, Brakerski and Vaikuntanathan <em>[x5]</em> proposed a new scheme based solely on the (standard) Learning With Error (LWE) assumption, which is in turn based on the worst-case hardness of short vector problems on arbitrary lattices. Immediately following that, Gentry <em>[x11]</em> further simplied their construction and greatly improved the efficiency of fully homomorhpic encryptions schemes. In all these schemes, the complexity of the algorithms (KeyGen; Enc; Dec) depends linearly on the depth <span class="math">d</span> of the circuit <span class="math">C</span>, where <span class="math">d</span> is an upper bound on the depth of the circuit <span class="math">C</span> that are allowed as inputs to <span class="math">\\mathrm{Eval}</span>. However, under the additional assumption that these schemes are circular secure (i.e., remain secure even given an encryption of the secret key), the complexity of these algorithms are independent of <span class="math">C</span>.</p>

    <p class="text-gray-300">Our designated verifer CS proofs rely on the existence of a level FHE scheme. For simplicity of our presentation, we assume that the FHE scheme has perfect completeness. We note that the FHE schemes of both <em>[x10]</em> and <em>[x13]</em> indeed have perfect completeness. Furthermore, even if the FHE scheme does not have perfect completeness, it only causes the resulting designated verifier CS proofs to have an additional negligible completeness and soundness error.</p>

    <p class="text-gray-300">Below, when referring to a FHE, we mean a leveled FHE with perfect completeness.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">3.2.1 Private Information Retrieval</h4>

    <p class="text-gray-300">Rather than assuming FHE, our construction can easily be transformed to use a PIR with receiver computation and communication complexities poly-logarithmic in the size of the database. In <em>[x5]</em>, such a PIR scheme is constructed from LWE-based FHE. Therefore PIR is, in some sense, a weaker assumption than FHE, and yet it suffices for our construction.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.3 Probabilistically Checkable Proofs</h3>

    <p class="text-gray-300">Loosely speaking, a probabilistically checkable proof system (PCP) for a language consists of a probabilistic polynomial-time verifier having direct access to individual bits of a binary string. This string (called oracle) represents a proof, and typically will be accessed only partially by the verifier. Queries to the oracle are positions on the bit string and will be determined by the verifier’s input and coin tosses. The verifier is supposed to decide whether a given input belongs to the language. If the input belongs to the language, the requirement is that the verifier will always</p>

    <p class="text-gray-300">accept given access to an adequate oracle. On the other hand, if the input does not belong to the language, then the verifier will reject with probability at least 1- <span class="math">\\varepsilon</span> for some small error bound <span class="math">\\varepsilon</span>, no matter which oracle is used. Below we present the formal definition of PCP.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 1 (Probabilistically Checkable Proofs).</h6>

    <p class="text-gray-300">A probabilistically checkable proof system with error bound <span class="math">\\varepsilon</span> for a language <span class="math">L</span> consists of probabilistic polynomial-time oracle machine (called verifier) <span class="math">V</span> and two polynomials <span class="math">p_{r}</span>, <span class="math">p_{q}</span> satisfying</p>

    <p class="text-gray-300">Completeness: For every <span class="math">x\\in L</span> there exists an oracle <span class="math">\\pi_{x}</span> such that, <span class="math">\\Pr\\left[V^{\\pi_{x}}(x)=1\\right]=1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness: For every <span class="math">x\\not\\in L</span> and every oracle <span class="math">\\pi</span>, $\\Pr\\left[V^{\\pi}(x)=1\\right]\\leq\\varepsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity: On any input of length <span class="math">n</span>, <span class="math">V</span> makes at most <span class="math">p_{r}(n)</span> coin tosses and at most <span class="math">p_{q}(n)</span> oracle queries.</p>

    <p class="text-gray-300">In this work, we do not care about the refined complexity <span class="math">p_{r}</span> and <span class="math">p_{q}</span> of the PCP system. Instead, we will care about that a set <span class="math">\\mathcal{N}\\subseteq\\mathcal{NEXP}</span> (the non-deterministic CS language defined in Section 5.1) has a PCP system with a negligible error bound, and satisfies the following additional proprieties defined in <em>[x1]</em>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 2 (Additional Properties for PCP <em>[x1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">V</span> be a PCP verifier with error bound <span class="math">\\varepsilon</span> and complexity <span class="math">p_{r}</span> <span class="math">p_{q}</span>, for a language <span class="math">\\mathcal{N}\\subseteq\\mathcal{NEXP}</span>, and let <span class="math">\\mathcal{R}</span> be a corresponding witness relation. Consider the following properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Relatively-efficient oracle-construction: There exists a deterministic polynomial time machine <span class="math">P</span>, such that, for every <span class="math">(x,w)\\in\\mathcal{R}</span>, <span class="math">\\Pr\\left[\\pi_{x}=P(x,w)\\;:\\;V^{\\pi_{x}}(x)=1\\right]=1</span>. As a result, there exists a polynomial <span class="math">p_{p}</span> such that the proof <span class="math">\\pi_{x}</span> has length bounded by $p_{p}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-adaptive Verifier: The verifier algorithm <span class="math">V</span> can be decomposed into a pair of algorithms <span class="math">Q</span> and <span class="math">D</span>, such that, on input <span class="math">x</span> and a random tape <span class="math">r</span> of length $p_{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the verifier runs </span>Q(x,r)<span class="math"> to generate </span>s=p_{q}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> queries </span>q_{1},\\ldots,q_{s}<span class="math">, obtains answers </span>a_{1},\\ldots,a_{s}<span class="math"> to those queries from the oracle, and decides by computing and outputting </span>D(x,r,a_{1},\\ldots,a_{s})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above properties are known to hold for many PCP systems. Below, we consider only PCP system with the above properties, and denote it as <span class="math">(P,V=(Q,D))</span> with complexity <span class="math">p_{p},p_{r},p_{q}</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4 Extractable Collision Resistence Hash Function</h2>

    <p class="text-gray-300">In this section, we formally define the notion of extractable collision resistant hash functions (CRHF) and construct such a hash function based on a new knowledge of exponent assumption called <span class="math">q</span>-KEA introduced in Section 4.1.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3 (Extractable Collision Resistence Hash Function).</h6>

    <p class="text-gray-300">Let <span class="math">\\left\\{I_{k}\\right\\}_{k\\in N}</span> be a sequences of sets of indexes. A tuple <span class="math">\\mathcal{H}=\\left(\\left\\{H_{k,id}\\right\\}_{k\\in N,id\\in I_{k}},\\left\\{\\mathsf{valid}_{k}\\right\\}_{k\\in N}\\right)</span>, is an extractable collision resistence hash function if <span class="math">\\left\\{H_{k,id}\\right\\}</span> is a family of collision resistent hash functions, <span class="math">\\left\\{\\mathsf{valid}_{k}\\right\\}</span> with <span class="math">\\mathsf{valid}_{k}:I_{k}\\times\\left\\{0,1\\right\\}^{*}\\to\\left\\{0,1\\right\\}</span> is a sequence of functions that decides the validity of a hash value, and satisfies the following:</p>

    <p class="text-gray-300">Extractability: For every non-uniform deterministic polynomial time machine <span class="math">A</span>, there exists a non-uniform deterministic polynomial time machine <span class="math">E</span> and a negligible function <span class="math">\\mu</span>, such that, for every <span class="math">k\\in N</span> and every auxiliary input <span class="math">z\\in\\left\\{0,1\\right\\}^{*}</span>, the following holds.</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[id\\leftarrow I_{k},\\ \\vec{v}=A(1^{k},id,z);\\ \\vec{o}=E(1^{k},id,z)\\right.:</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left.\\exists j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">],\\ \\mathsf{valid}_{k}(id,\\vec{v}_{j})=1\\ \\text{and}\\ H_{k,id}(\\vec{o}_{j})\\neq v\\right]\\leq\\mu(k)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, an CRHF is extractable if for every machine <span class="math">A</span> there exists an extractor <span class="math">E</span> that can extract out a pre-image for every valid hash value that <span class="math">A</span> outputs. Next we proceed to construct an extractable CRHF. Our construction relies on a new knowledge of exponent assumption introduced below.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 <span class="math">q</span>-Knowledge of Exponent Assumption</h3>

    <p class="text-gray-300">The knowledge of exponent (KEA) assumption introduced by Damgård <em>[x10]</em> says that given <span class="math">g,g^{\\alpha}</span> it is infeasible to create <span class="math">c,\\hat{c}</span> so that <span class="math">\\hat{c}=c^{\\alpha}</span> without knowing <span class="math">a</span> so <span class="math">c=g^{a}</span> and <span class="math">\\hat{c}=(g^{\\alpha})^{a}</span>. Bellare and Palacio <em>[x4]</em> extended this to the KEA3 assumption, which says that given <span class="math">g,g^{x},g^{\\alpha},g^{x\\alpha}</span>, it is infeasible to create <span class="math">c</span> and <span class="math">\\hat{c}</span> so that <span class="math">\\hat{c}=c^{\\alpha}</span> without knowing <span class="math">a</span>, <span class="math">b</span> such that <span class="math">c=g^{a}(g^{x})^{b}</span> and <span class="math">\\hat{c}=(g^{\\alpha})^{a},(g^{x\\alpha})^{b}</span>. This assumption has been used also in bilinear groups by Abe and Fehr <em>[x2]</em> who called it the extended knowledge of exponent assumption.</p>

    <p class="text-gray-300">Our <span class="math">q</span>-Knowledge of Exponent (<span class="math">q</span>-KEA) Assumption generalizes the KEA and KEA3 assumptions in the following aspect: Instead of receiving only a pair of elements <span class="math">g,g^{x}</span> and their <span class="math">\\alpha^{\\text{th}}</span> powers, a challenger now is given <span class="math">q</span> random elements <span class="math">g,g^{x_{1}},\\ldots g^{x_{q}}</span> and their corresponding <span class="math">\\alpha^{\\text{th}}</span> powers. The assumption states that it is infeasible to create <span class="math">c</span> and <span class="math">\\hat{c}</span> so that <span class="math">\\hat{c}=c^{\\alpha}</span> without knowing <span class="math">a_{0},a_{1},\\ldots,a_{1}</span> such that <span class="math">c=g^{a_{0}}\\prod_{i=1}^{q}g^{x_{i}a_{i}}</span>. A similar assumption, called the <span class="math">q</span>-power knowledge of exponent assumption for bilinear groups, was introduced by Groth <em>[x16]</em> for constructing a short (sublinear length) pairing-based Non-interactive Zero-Knowledge Arguments. Their assumption is almost the same except that the challenger receives <span class="math">q</span> elements of a special form <span class="math">g,g^{x_{1}},\\ldots g^{x_{q}}</span> and their <span class="math">\\alpha^{\\text{th}}</span> powers. We note that the two assumptions are incomparable.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 4 (<span class="math">q</span>-Knowledge of Exponent Assumption).</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be any polynomial. The <span class="math">q</span>-KEA assumption holds for a family of groups <span class="math">\\mathcal{G}</span> if for every deterministic polynomial time machine <span class="math">A</span>, there exists a deterministic polynomial time machine <span class="math">E</span> and a negligible function <span class="math">\\mu</span>, such that, for every <span class="math">k\\in N</span> and every auxiliary input <span class="math">z\\in\\{0,1\\}^{*}</span>, the advantage of <span class="math">A</span> in the following experiment <span class="math">Exp^{q}_{A,E}(k,z)</span> is bounded by <span class="math">\\mu(k)</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Experiment</h6>

    <p class="text-gray-300"><span class="math">Exp^{q}_{A,E}(1^{k},z)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(p,G)=\\mathcal{G}(1^{k})</span>, <span class="math">g_{0}</span> a random generator in <span class="math">G</span>, <span class="math">g_{1}\\ldots g_{q(k)}</span> random elements in <span class="math">G</span>, and <span class="math">\\alpha</span> a random element in <span class="math">\\mathbb{Z}_{p}</span>; let <span class="math">\\delta=(g_{0},\\ldots,g_{q(k)},g_{0}^{\\alpha},g_{1}^{\\alpha},\\ldots,g_{q(k)}^{\\alpha})</span>.</li>

      <li><span class="math">A</span>, on inputs <span class="math">1^{k},\\delta</span> and auxiliary input <span class="math">z</span>, outputs <span class="math">(s,(c_{1},\\hat{c}_{1}),\\ldots,(c_{s},\\hat{c}_{s}))</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">E</span>, on inputs <span class="math">1^{k},\\delta</span> and auxiliary input <span class="math">z</span>, outputs <span class="math">s^{\\prime}</span> and a sequence of exponents <span class="math">(a_{0}^{j},\\ldots a_{q(k)}^{j})</span> for <span class="math">j\\in[s^{\\prime}]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The experiement outputs 1 if and only if there exists a <span class="math">j\\in[s]</span>, such that, <span class="math">\\hat{c}_{j}=c_{j}^{\\alpha}</span> but <span class="math">c_{j}\\neq\\prod_{i=0}^{q(k)}g_{i}^{a_{i}^{j}}</span>.</li>

    </ol>

    <p class="text-gray-300">The advantage of <span class="math">A</span> in the above experiment equals to the probability that the experiment outputs 1.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 Constructing Extractable CRHF</h3>

    <p class="text-gray-300">Our construction of extractable CRHF is essentially the same as the construction of commitments with knowledge by Groth <em>[x16]</em>, which in turn is based on a variant of the Pedersen commitment scheme. Consider the following CRHF:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}=\\Big{(}\\{H_{k,id}\\}_{k\\in N,id\\in I_{k}}\\,,\\{\\mathsf{valid}_{k}\\}_{k\\in N}\\Big{)}:\\hskip 14.22636pt</span></p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Sampling: Let <span class="math">(p,G)=\\mathcal{G}(1^{n})</span> and <span class="math">q=q(k)</span>. The <span class="math">k^{\\text{th}}</span> index set is defined as follows:</p>

    <p class="text-gray-300"><span class="math">I_{k}=\\Big{\\{}\\left(g_{0},\\ldots,g_{q},\\hat{g}_{0},\\ldots,\\hat{g}_{n}\\right)\\ :</span> <span class="math">g_{0}\\in G-\\left\\{0\\right\\},\\ g_{1},\\ldots,g_{q}\\in G,\\ \\exists\\alpha\\in Z_{p}\\ \\text{s.t.}\\ \\forall i,\\ \\hat{g}_{i}=g_{i}^{\\alpha}\\Big{\\}}</span></p>

    <p class="text-gray-300">In other words, to sample a random hash function <span class="math">H_{k,id}</span>, simply sample <span class="math">g_{0},\\ldots,g_{k}</span> at random from <span class="math">G</span> as specified above, sample <span class="math">\\alpha</span> at ranodm from <span class="math">\\mathbb{Z}_{p}</span>, and output <span class="math">id=(g_{0},\\ldots,g_{q},g_{0}^{\\alpha},\\ldots,g_{q}^{\\alpha})</span>. For every <span class="math">k</span> and <span class="math">id=(g_{0},\\ldots,g_{q},\\hat{g}_{0},\\ldots,\\hat{g}_{q})\\in I_{k}</span>, hash function <span class="math">H_{k,id}:\\mathbb{Z}_{p}^{q+1}\\to G^{2}</span>, on input <span class="math">(a_{0},\\ldots,a_{q})\\in Z_{p}^{n}</span>, outputs <span class="math">c=\\prod_{i=0}^{q}g_{i}^{a_{i}}</span> and <span class="math">\\hat{c}=\\prod_{i=0}^{q}\\hat{g}_{i}^{a_{i}}</span>. On input a hash value <span class="math">(c,\\hat{c})\\in G^{2}</span> and an index <span class="math">id=(g_{0},\\ldots,g_{q},\\hat{g}_{0},\\ldots,\\hat{g}_{q})\\in I_{k}</span>, the function <span class="math">\\mathsf{valid}_{k}</span> outputs <span class="math">1</span> if there exists a <span class="math">\\alpha\\in\\mathbb{Z}_{p}</span> such that <span class="math">\\hat{g}_{i}=g_{i}^{\\alpha}</span> for all <span class="math">i</span> and <span class="math">\\hat{c}=c^{\\alpha}</span>.</p>

    <p class="text-gray-300">The hash function <span class="math">H_{k,id}</span> maps <span class="math">q+1</span> elements in <span class="math">Z_{p}</span> to two elements in <span class="math">G</span>, achieving a “compression rate” of <span class="math">(q+1)/2</span>. It follows from stardard technique that <span class="math">\\mathcal{H}</span> is collision resistent assuming that the DDH assumption holds on <span class="math">\\mathcal{G}</span>; here we omit the proof.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Assume that the DDH assumption holds on <span class="math">\\mathcal{G}</span>. Then, <span class="math">\\left\\{H_{k,id}\\right\\}_{k\\in N,id\\in I_{n}}</span> is a family of collision resistent hash function.</p>

    <p class="text-gray-300">Furthermore, it follows directly from <span class="math">q</span>-KEA that the hash function is also extractable. That is,</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be any polynomial. Assume that the DDH assumption and <span class="math">q</span>-KEA hold on <span class="math">\\mathcal{G}</span>. Then, <span class="math">\\mathcal{H}</span> is a extractable CRHF with compression rate <span class="math">(q(k)+1)/2</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By construction, hash function <span class="math">\\mathcal{H}_{k,id}</span> has compression rate <span class="math">(q(k)+1)/2</span>. Then, following Lemma 1, it only remains to show that <span class="math">\\mathcal{H}</span> is extractable. Fix any non-uniform deterministic polynomial-time machine <span class="math">A</span>. It follows from <span class="math">q</span>-KEA that there exists an extractor <span class="math">E</span> (also non-uniform deterministic polynomial-time) such that, for every <span class="math">k</span>, <span class="math">z</span>, it holds that, except from negligible probability, whenever <span class="math">A</span> on input a random <span class="math">id=(g_{0},\\ldots,g_{q},g_{0}^{\\alpha},\\ldots,g_{q}^{\\alpha})\\in I_{k}</span>, outputs a valid hash value <span class="math">(c_{j},\\hat{c}_{j}=c_{j}^{\\alpha})</span>, <span class="math">E</span> on the same input, outputs <span class="math">(a_{0}^{j}\\ldots a_{q}^{j})</span> such that <span class="math">c_{j}=\\prod_{i=0}^{q}g_{i}^{a_{i}^{j}}</span>. Since <span class="math">(a_{0}^{j}\\ldots a_{q}^{j})</span> is a valid preimage for <span class="math">(c_{j},\\hat{c}_{j})</span>, <span class="math">E</span> is a valid extractor for <span class="math">A</span> w.r.t. <span class="math">\\mathcal{H}</span>. ∎</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 Extractable Merkle Trees</h3>

    <p class="text-gray-300">Recall that Merkle tree is a full binary tree whose nodes are associated with value generated in a special way according to a CRHF such that the value of an internal node is the hash of the concatenation of the values of its children. We show that by instantiating the Merkle tree with an extractable CRHF, we obtain a Merkle tree that is also <em>extractable</em>, that is, given only the root value <span class="math">rv</span> of a Merkle tree, one can extract out a Merkle tree that is consistent with <span class="math">rv</span>.</p>

    <p class="text-gray-300">Recall that our extractable CRHF <span class="math">\\mathcal{H}</span> achieves a high “compression rate” <span class="math">(q(k)+1)/2</span>. When using such a CRHF, we can afford to let each internal node have more than two children. More precisely, a <span class="math">n</span>-ary (for now, consider <span class="math">n</span> to be even) Merkle tree is a <span class="math">n</span>-ary tree built in the same way as a classical Merkle tree, except that each internal node can have up to <span class="math">n</span> children and its associated value is the hash of the concatenation of the values of its <span class="math">n</span> children through a hash function with “compression rate” <span class="math">n</span>. As classical (binary) Merkle trees, the root value of a <span class="math">k</span>-ary Merkle tree is a good “commitment” of the original values associated with the leaves, and a</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">particular value <span class="math">v_{i}</span> can be “decommited” by revealing <span class="math">d(n-1)+1</span> values: <span class="math">v_{i}</span> together with its authentication path <span class="math">ap_{i}</span> consisting of the values stored in the <span class="math">d(n-1)</span> siblings of the nodes along the path from leaf <span class="math">i</span> (inclusive) to the root (exclusive). To check the consistency of a pair of value <span class="math">v_{i}</span> and authentication path <span class="math">ap_{i}</span> with a root value <span class="math">rv</span>, the verify procedure proceeds as follows: On input <span class="math">v_{i}</span> and <span class="math">ap_{i}=(Y_{1},\\ldots,Y_{d})</span> where each <span class="math">Y_{j}</span> consists of <span class="math">n-1</span> values <span class="math">Y_{j}^{1},\\ldots,Y_{j}^{n-1}</span>, verify sets <span class="math">X_{1}=v_{i}</span> and computes the values <span class="math">X_{j}</span> for <span class="math">j</span> from <span class="math">2</span> to <span class="math">d</span> by setting $X_{j+1}=\\mathcal{H}(Y_{j}^{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{j}^{t-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{j}^{t}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{j}^{n-1})<span class="math"> if </span>i_{j}<span class="math"> (the </span>j^{\\text{th}}<span class="math"> bit of </span>i<span class="math"> in </span>k<span class="math">-ary representation) is </span>t<span class="math">; finally, verify checks whether </span>X_{d}=rv<span class="math"> and outputs </span>1$ if and only if this holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that Merkle trees constructed using an extractable collision resisent hash function <span class="math">\\mathcal{H}</span> is also “extractable”. This means, for every efficient challenger <span class="math">A</span>, and every constant <span class="math">D</span>, there exists an efficient extractor <span class="math">E_{D}</span> such that whenever <span class="math">A</span> on input a random index <span class="math">id</span>, outputs a valid root value <span class="math">rv</span>, <span class="math">E_{D}</span> on receiving the same index <span class="math">id</span> outputs a labeled tree <span class="math">\\mathcal{T}</span> of depth <span class="math">D</span> that is consistent with <span class="math">rv</span>. A tree <span class="math">\\mathcal{T}</span> is consistent with a root value <span class="math">rv</span>, if the following procedure outputs <span class="math">1</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{merkle}_{k}(id,D,rv,\\mathcal{T})</span> check:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{T}</span> has depth at most <span class="math">D</span>.</li>

      <li>The value associated with the root of <span class="math">\\mathcal{T}</span> equals to <span class="math">rv</span>.</li>

      <li>The value <span class="math">v</span> associated with every internal node equals to the hash of the concatenation of the values associated with its children.</li>

      <li>The value <span class="math">v</span> associated with every leaf on depth <span class="math">d&lt;D</span> is not a valid hash value, that is, <span class="math">\\mathsf{valid}_{k}(1^{k},id,v)=0</span>. (A node is at depth <span class="math">d</span> if its distance from the root is <span class="math">d</span>.)</li>

    </ol>

    <p class="text-gray-300">Output <span class="math">1</span> if all the above conditions hold, and <span class="math">0</span> otherwise.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}=\\left(\\{H_{k,id}\\}_{k\\in N,id\\in I_{k}},\\{\\mathsf{valid}_{k}\\}_{k\\in N}\\right)</span> be an extractable CRHF with compression rate <span class="math">l</span>. Then for every non-uniform deterministic polynomial time machine <span class="math">A</span> and every constant <span class="math">D</span>, there exists a non-uniform deterministic polynomial time machine <span class="math">E_{D}</span> and a negligible function <span class="math">\\mu_{D}</span>, such that, for every <span class="math">k\\in N</span> and every auxiliary input <span class="math">z\\in\\{0,1\\}^{*}</span>, the following holds.</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[id\\leftarrow I_{k},\\ rv=A(1^{k},id,z);\\ \\mathcal{T}=E(1^{k},id,z)\\ \\right.</span> : <span class="math">\\left.\\mathsf{valid}_{k}(id,rv)=1\\ \\text{and}\\ \\mathsf{merkle}_{k}(id,D,\\mathcal{T},rv)\\neq 1\\right]\\ \\leq\\mu(k)</span></p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This lemma follows essentially by applying the extractability property of the CRHF <span class="math">\\mathcal{H}</span> recursively. Since the lemma only cares about extracting constant depth Merkle trees, we only need to apply the extractability property for a constant number of times and thus the resulting extractor for the Merkle tree is efficient. More precisely, fix any non-uniform deterministic polynomial time machine <span class="math">A</span>; we prove by induction that for every constant <span class="math">D</span> there exists an extractor <span class="math">E_{D}</span> and a negligible function <span class="math">\\mu_{D}</span> satisfying the lemma. When <span class="math">D=1</span>, it follows immediately from the extractability of the CRHF <span class="math">\\mathcal{H}</span> that such <span class="math">E_{1}</span> and <span class="math">\\mu_{1}</span> exist. Then assuming that <span class="math">E_{d}</span> and <span class="math">\\mu_{d}</span> exist for <span class="math">D=d</span> a constant, we want to exhibit an extractor <span class="math">E_{d+1}</span> and a negligible function <span class="math">\\mu_{d+1}</span> for <span class="math">D=d+1</span>. Fix any <span class="math">k\\in N</span> and an auxiliary input <span class="math">z\\in\\{0,1\\}^{*}</span>. By our hypothesis, it holds that except from a <span class="math">\\mu_{d}</span> fraction of indexes <span class="math">id\\in I_{k}</span>, it holds that whenever the output of <span class="math">rv</span> of the challenger <span class="math">A(1^{k},id,z)</span> is valid, the extractor <span class="math">E_{d}(1^{k},id,z)</span> outputs a labeled tree <span class="math">\\mathcal{T}_{d}</span> of depth bounded by <span class="math">d</span> that is consistent with <span class="math">rv</span>, (i.e., <span class="math">\\mathsf{merkle}(id,d,rv,\\mathcal{T}_{d})=1</span>). Then consider a machine <span class="math">E_{d}^{\\prime}</span> which simply runs <span class="math">E_{d}</span> internally and outputs only the values associated with the leaves at depth <span class="math">d</span> in <span class="math">\\mathcal{T}_{d}</span> (output by <span class="math">E_{d}</span>). By the extractability of <span class="math">\\mathcal{H}</span>, there exists a deterministic polynomial time machine <span class="math">X_{d}</span></p>

    <p class="text-gray-300">a negligible function <span class="math">\\mu</span> such that, except from a <span class="math">\\mu</span> fraction of <span class="math">id\\in I_{k}</span>, for every valid hash value <span class="math">v</span> output by <span class="math">E_{d}^{\\prime}(1^{k},id,z)</span>, <span class="math">X_{d}(1^{k},id,z)</span> outputs a corresponding preimage <span class="math">(v_{1}\\ldots v_{l(k)})</span>. Using <span class="math">X_{d}</span> we construct <span class="math">E_{d+1}</span> as follows. Machine <span class="math">E_{d+1}(1^{k},id,z)</span> internally runs <span class="math">E_{d}(1^{k},id,z)</span> and <span class="math">X_{d}(1^{k},id,z)</span>, obtaining outputs <span class="math">\\mathcal{T}_{d}</span> and <span class="math">w</span> resepctively; it then constructs a depth <span class="math">d+1</span> tree <span class="math">T_{d+1}</span> by extending <span class="math">\\mathcal{T}_{d}</span>: For every leaf node of <span class="math">\\mathcal{T}_{d}</span> at depth <span class="math">d</span>, if <span class="math">w</span> contains a valid preimage <span class="math">(v_{1}\\ldots v_{l(k)})</span> of the value associated with it, extend that leaf with <span class="math">l(k)</span> children with values <span class="math">v_{1}</span> to <span class="math">v_{l(k)}</span> respectively. If <span class="math">\\mathcal{T}_{d}</span> is consistent with <span class="math">rv</span> and <span class="math">X_{d}</span> extracts a pre-image for every valid hash value associated with nodes at depth <span class="math">d</span> of <span class="math">\\mathcal{T}_{d}</span>, <span class="math">\\mathcal{T}_{d+1}</span> is also consistent with <span class="math">rv</span>. Therefore <span class="math">E_{d+1}</span> “fails” only if <span class="math">E_{d}</span> or <span class="math">X_{d}</span> “fails”. By our hypothesis and and the extractability of <span class="math">\\mathcal{H}</span>, we obtain <span class="math">E_{d+1}</span> fails with probability at most <span class="math">\\mu_{d+1}(k)=\\mu_{d}(k)+\\mu(k)</span>. ∎</p>

    <h2 id="sec-30" class="text-2xl font-bold">5 Designated Verifier CS Proofs</h2>

    <p class="text-gray-300">Our designated verifier CS proofs, like CS proofs, has efficient instance-based provability and verifiablity (resepctively, polynomial and polylogarithmically in the time of the computation to be proved). However, it is weaker in the following two aspects: First, proofs of our protocol are only verifable by a designated verifier (whereas CS proofs are publicly verifiable), and second, our protocol only achieves a weaker (computational) soundness guarantee, that is, soundness only holds if the (computationally bounded) cheating prover tries to prove an invalid polynomial-time computation (whereas no invalid, even exponential-time, computation can be proved using CS proofs).</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">5.1 Defining Designated Verifier CS Proofs</h3>

    <p class="text-gray-300">We first recall the definition of CS language introduced by Micali <em>[x11]</em></p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 5 (CS language <em>[x11]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The CS language, denoted by <span class="math">\\mathcal{L}</span>, is the set of all quadruples <span class="math">q=(M,x,y,t)</span>, such that <span class="math">M</span> is (the description of) a Turing machine, <span class="math">x</span> and <span class="math">y</span> are a binary strings, and <span class="math">t</span> a binary integer such that it holds that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">, </span>M(x)=y<span class="math"> and </span>\\texttt{steps}(M(x))=t<span class="math">, where </span>\\texttt{steps}(M(x))<span class="math"> denote the number of steps that </span>M<span class="math"> takes on input </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The CS language essentially includes all quadruples that correspond to a valid deterministic computation. In fact, the CS proofs are capable of proving all valid non-deterministic computation as well. Formally, it corresponds to the following language.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 6 (Non-deterministic CS language).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The non-deterministic CS language, denoted by <span class="math">\\mathcal{N}</span>, is the set of all quadruples <span class="math">q=(M,x,t)</span>, such that <span class="math">M</span> is (the description of) a Turing machine, <span class="math">x</span> is a binary string, and <span class="math">t</span> a binary integer, it holds that there exists a witness <span class="math">w</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">, </span>M(x,w)=1<span class="math"> and </span>\\texttt{steps}(M(x,w))=t<span class="math">. Denote by </span>\\mathcal{R}<span class="math"> the witness relation of </span>\\mathcal{N}$, that is,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}=\\left\\{\\left((M,x,t),w\\right)\\;:\\;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t,\\;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t,\\;M(x,w)=1,\\;\\texttt{steps}(M(x,w))=t\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also denote by <span class="math">\\mathcal{R}(X)</span> the set of witnesses <span class="math">w</span> such that <span class="math">\\mathcal{R}(X,w)=1</span>.</p>

    <p class="text-gray-300">In the designated verifier model, a non-interactive proof system has an associated polynomial-time sampleable distribution <span class="math">D</span> over binary strings of the form <span class="math">(pp,sp)</span>. During a setup phase, a trusted party samples from <span class="math">D</span>, publishes <span class="math">pp</span> and privately hands the Verifier <span class="math">sp</span>. The Prover and Verifier then use their respective values during the proof phase.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 7 (Designated Verifier CS Proofs).</h6>

    <p class="text-gray-300">A triple of algorithms, <span class="math">(D,P,V)</span>, is called a designated verifier CS proof system, if <span class="math">D</span> is probablistic polynomial time, <span class="math">P</span> and <span class="math">V</span> are deterministic, the second of which runs in polynomial time, and the following properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. There exists polynomials <span class="math">t_{P}</span> and <span class="math">\\ell</span>, such that for every <span class="math">X=(M,x,t)\\in\\mathcal{N}</span> and every <span class="math">w\\in\\mathcal{R}(x)</span>, every <span class="math">k\\in N</span>, and every possible output <span class="math">(pp,sp)</span> of $D(1^{k},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, </span>P(1^{k},pp,X,w)<span class="math"> halts within </span>t_{p}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,t)<span class="math"> computational steps, outputting a proof </span>\\pi<span class="math"> of length smaller than </span>\\ell(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Furthermore, it holds that,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[(pp,sp)\\leftarrow D(1^{k},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">});\\ \\pi\\leftarrow P(1^{k},pp,X,w)\\ :\\ V(1^{k},pp,sp,X,\\pi)=1\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For every deterministic polynomial time machine <span class="math">P^{*}</span>, there exists a negligible function <span class="math">\\mu</span>, such that for every <span class="math">k\\in N</span> and every <span class="math">n</span> that is polynomially bounded by <span class="math">k</span>, it holds that:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(pp,sp)\\leftarrow D(1^{k},1^{n});\\ (X,\\pi)\\leftarrow P^{*}(1^{k},pp)\\ :\\ X\\not\\in\\mathcal{N}\\ \\text{and}\\ V(1^{k},pp,sp,X,\\pi)=1\\right]\\leq\\mu(k)</span></p>

    <p class="text-gray-300">The above defintion adapts the original notion of CS proofs <em>[x13]</em> into the designated verifier model. In this model, the property of public verifiability no longer holds; instead, only verifiers holding certain secret information <span class="math">sp</span> can verify the validity of the proof. Next, we further relax the soundness property to only require it to hold when the cheating prover is trying to prove an invalid but polynomial-time computation.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 8 (Weak Soundness).</h6>

    <p class="text-gray-300">We say that a designated verifier CS proof system <span class="math">(D,P,V)</span> has weak soundness if the computational soundess property is replaced by the following:</p>

    <p class="text-gray-300">For every deterministic polynomial time machine <span class="math">P^{*}</span>, and every constant <span class="math">c\\in N</span>, there exists a negligible function <span class="math">\\mu</span>, such that for every <span class="math">k\\in N</span> and every <span class="math">n</span> that is polynomially bounded by <span class="math">k</span>, it holds that:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(pp,sp)\\leftarrow D(1^{k},1^{n});\\ (X,\\pi)\\leftarrow P^{*}(1^{k},pp)\\ :\\right.</span> <span class="math">\\left.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ X=(M,x,t)\\ \\text{and}\\ t\\leq k^{c}\\ \\text{and}\\ X\\not\\in\\mathcal{N}\\ \\text{and}\\ V(1^{k},pp,sp,X,\\pi)=1\\right]\\leq\\mu(k)</span></p>

    <p class="text-gray-300">Below, when referring to a designated verifier CS proof system, we mean such a proof system with weak soundness.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">We remark that in our definition of computational soundness, the cheating prover only sees the public string <span class="math">pp</span>. This is different from the case in the definition of designated verifier non-interactive zero-knowledge proof system in the context of constructing CCA2 secure encryption schemes, where the soundness needs to hold even if the cheating prover has access to a verification oracle, which on input a statement and a proof tells the cheating prover whether this is an accepting proof or not. One consequence of this difference is that soundness of our proof system may not hold when a cheating prover participates in a game where it interacts with the honest verifier in many rounds proving many statements and may learn the decision of the verifier in each round. As we shall see later, this is relevant to the soundness of the delegation schemes that we construct from designated verifier CS proof systems.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">5.2 Constructing Designated Verifier CS Proofs</h3>

    <p class="text-gray-300">Our designated verifier CS proof system <span class="math">(D,P,V)</span> for the non-deterministic CS language <span class="math">\\mathcal{N}</span> rely on the following building blocks:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An extractable collision resistant hash functions <span class="math">\\mathcal{H} = (\\{H_{n,id}\\}_{n\\in N,id\\in I_n},\\{\\mathrm{valid}_k\\}_{k\\in N})</span> be with output length <span class="math">k</span> and compression rate <span class="math">l(k) = k</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A fully homomorphic encryption scheme <span class="math">E = (\\mathrm{KeyGen}, \\mathrm{Enc}, \\mathrm{Dec})</span> with perfect completeness.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. A PCP system <span class="math">(P_{pcp}, V_{pcp} = (Q, D))</span> with complexity <span class="math">p_p, p_r, p_q</span> for <span class="math">\\mathcal{N}</span>, such that, the number of random coins tossed by the verifier on an input <span class="math">X = (M, x, t) \\in \\mathcal{N}</span> is $p_r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log t)<span class="math">, and the number of queries generated is </span>p_q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">k</span> be a security parameter. To prove a statement <span class="math">X \\in \\mathcal{N}</span>, our scheme proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Set-up:</strong> <span class="math">D</span> on input <span class="math">1^k</span> and $1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, do:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Sample at random a hash function <span class="math">H_{k,id}</span>, a $p_r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-bit string </span>r<span class="math">, and a pair of public and private keys of </span>E<span class="math">, </span>(pk, sk) \\gets \\mathrm{KeyGen}(1^k, 1^L)<span class="math">, where </span>L = \\log(\\mathrm{poly}(p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)))<span class="math"> is a bound on the depth of the section circuit (introduced shortly below) on input vectors and trees of length </span>\\mathrm{poly}(p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the encryption of <span class="math">r</span> under <span class="math">pk</span>, <span class="math">c = \\operatorname{Enc}_{pk}(r)</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">pp = (id, pk, c)</span> and <span class="math">sp = (sk, r)</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Prover's Message:</strong> <span class="math">P</span> on input <span class="math">1^k</span>, <span class="math">X = (M, x, t)</span>, a witness <span class="math">w</span>, and <span class="math">pp = (id, pk, c)</span>, do:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Internally run <span class="math">P_{pcp}</span> on input <span class="math">X</span> and <span class="math">w</span> to generate a PCP-proof <span class="math">\\pi</span>; the length of the proof is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> bounded by </span>p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, t)<span class="math"> as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Build a <span class="math">l(k) = k</span>-ary Merkle tree <span class="math">\\mathcal{T}</span> by setting the value associated with the <span class="math">i^{\\text{th}}</span> leaf node to be equal to <span class="math">\\pi_i^4</span>, and computing the values of the internal nodes using the hash function <span class="math">H_{k,id}</span>; let <span class="math">rv</span> be the root value generated and <span class="math">d</span> be the depth of the Merkle tree;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Evaluate homomorphically the circuit <span class="math">Q</span> over <span class="math">X</span> and <span class="math">c</span> to compute the PCP queries, yielding <span class="math">c&#x27; = \\operatorname{Eval}_{pk}(Q; (X, c))</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Select homomorphically the answers and their corresponding authentication paths according to <span class="math">c&#x27;</span>, yielding <span class="math">c&#x27;&#x27; = \\operatorname{Eval}_{pk}(S; (\\pi, \\mathcal{T}, c&#x27;))</span>, where <span class="math">S</span> is a selection circuit which on input a string <span class="math">str</span>, a tree <span class="math">T</span>, and a vector of indexes <span class="math">\\vec{q}</span>, returns for every $i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, </span>str_{q[i]}<span class="math"> and the path leading from the root to the </span>q[i]^{\\text{th}}<span class="math"> leaf in </span>T$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs <span class="math">\\pi = (rv, d, c&#x27;&#x27;)</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Verifier's Decision:</strong> <span class="math">V</span> on input <span class="math">1^k</span>, <span class="math">X = (M, x, t)</span>, <span class="math">pp = (id, pk, c)</span>, <span class="math">sp = (sk, r)</span> and <span class="math">\\pi = (rv, d, c&#x27;&#x27;)</span>, do:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Verify that the depth of the Merkle tree is correctly bounded, that is, $d \\leq \\log_k(p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, t))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let $s = p_q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; Decrypt </span>c''<span class="math"> using the secret key </span>sk<span class="math">, yielding </span>(a_1, \\ldots, a_s, ap_1, \\ldots, ap_s) = \\mathrm{Dec}_{sk}(c'')$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check for every <span class="math">i \\in [s]</span>, whether <span class="math">a_i</span>, <span class="math">ap_i</span> are consistent with <span class="math">rv</span>; if for any <span class="math">i \\in [S]</span>, verify <span class="math">(id, a_i, ap_i) \\neq 1</span>, reject and abort;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">D</span> on input <span class="math">X</span>, <span class="math">r</span>, <span class="math">a_1, \\ldots, a_s</span>; accept if and only if <span class="math">D</span> outputs 1.</li>

    </ul>

    <p class="text-gray-300">4We assume w.l.o.g. that the length of the PCP proof <span class="math">\\pi</span> is a power of <span class="math">k</span>. Otherwise, we can always make it to be the case by padding <span class="math">\\pi</span> with 0's.</p>

    <p class="text-gray-300">19</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We analyze the efficinecy of the above scheme as follows: By construction and the relatively efficient oracle construction property of the PCP system, the prover <span class="math">P</span> runs in time $\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t)<span class="math">. It is easy to check that the set-up algorithm runs in time </span>\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verifier runs in </span>\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math">. Finally, we bound the length of the public information </span>pp<span class="math"> and the proof generated by the prover. Since the PCP verifier tosses </span>p_r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math"> number of coins, the length of the public information </span>pp<span class="math"> is bounded by </span>\\mathrm{poly}(k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math">. Then, since the PCP proof has length </span>\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t)<span class="math">, the Merkle tree generated by the prover has depth </span>d = O(\\log_k(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t))<span class="math">, and thus the length of the answers to the </span>s<span class="math"> PCP queries where </span>s = p_q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math"> is </span>s(d(k - 1) + 1)k = \\mathrm{poly}(k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math">. Therefore, the size of the proof is indeed </span>\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ as required in Definition 7.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 2.</strong> As we shall see later, when constructing delegation schemes using the above designated verifier CS proof system. We utilize the fact that the lengths of the public information <span class="math">pp</span> and the CS proof generated are both in fact $\\mathrm{poly}(k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math">, depending polylogarithmically in the length of the input. Correspondingly, this will yield a delegation scheme with communication complexity bounded poly-logarithmically in the complexity of the computation being delegated and length of the input </span>x'<span class="math"> of the computation, provided that the delegator and the worker receives the input </span>x'$ from outside. From another perspective, this separates the communication complexity needed for transferring the input (from the delegator to the worker), from that needed for verifying the correctness of the output, which is only polylogarithmic in the input length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-38" class="text-2xl font-bold">5.2.1 <span class="math">(D, P, V)</span> works</h2>

    <p class="text-gray-300"><strong>Theorem 1.</strong> <span class="math">(D, P, V)</span> is a designated verifier CS proof system.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The completeness of the system follows from the perfect completeness of the fully homomorphic encryption scheme and the completeness of the PCP system. The computation and communication complexity of the system satisfies the definition of designated verifier CS proofs as analyzed above. Thus it only remains to show that <span class="math">(D, P, V)</span> satisfies weak soundness.</p>

    <p class="text-gray-300">We need to show that no prover can prove a false statement that has a polynomial time bound. That is, for every constant <span class="math">C</span> and every cheating prover <span class="math">P^{<em>}</span>, there exists a negligible function <span class="math">\\mu</span>, such that the following holds for every <span class="math">k \\in N</span> and <span class="math">n \\in \\{0,1\\}^{</em>}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ (pp, sp) \\leftarrow D \\left(1^{k}, 1^{n}\\right); (X, \\pi) \\leftarrow P^{*} \\left(1^{k}, pp\\right) : \\right. \\\\ \\left. X = (M, x, t) \\text{ and } t \\leq k^{c} \\text{ and } X \\notin \\mathcal{N} \\text{ and } V \\left(1^{k}, pp, sp, X, \\pi\\right) = 1 \\right] \\leq \\operatorname{neg}(k) \\tag{1}</span></div>

    <p class="text-gray-300">Recall that a proof <span class="math">\\pi</span> of <span class="math">(D, P, V)</span> consists of three components <span class="math">(rv, d, c&#x27;&#x27;)</span>, where <span class="math">rv</span> is the root value of a Merkle tree and <span class="math">d</span> is the depth of the tree. Towards proving the weak soundness, we show that no prover can "cheat" by giving a proof with a constant depth <span class="math">d</span>. That is, for every constant <span class="math">D</span> and every cheating prover <span class="math">P^*</span>, there exists a negligible function <span class="math">\\mu</span>, such that the following holds</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ (pp, sp) \\leftarrow D \\left(1^{k}, 1^{n}\\right); (X, \\pi) \\leftarrow P^{*} \\left(1^{k}, pp\\right) : \\right. \\\\ \\left. \\pi = (rv, d, c&#x27;&#x27;) \\text{ and } d \\leq D \\text{ and } X \\notin \\mathcal{N} \\text{ and } V \\left(1^{k}, pp, sp, X, \\pi\\right) = 1 \\right] \\leq \\mu(k) \\tag{2}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We claim that if the above holds, then so does weak soundness. Assume for contradiction that the above holds but there exists a cheating prover <span class="math">P^*</span> and a constant <span class="math">C</span> such that (1) is false. Recall that on input a statement <span class="math">X = (M, x, t)</span> and <span class="math">\\pi = (rv, d, c&#x27;&#x27;)</span>, the verifier checks whether the depth <span class="math">d</span> is correctly bounded by $\\log_k(p_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, t))<span class="math">. When </span>t \\leq k^C<span class="math">, </span>d<span class="math"> is bounded by a constant, since both </span>t<span class="math"> and </span>k$ are not equal.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are polynomially bounded by </span>k<span class="math">. Thus there must exist a particular constant </span>D<span class="math">, such that the probability that </span>P^{*}<span class="math"> cheats successfully while giving a proof with depth exactly </span>D$ is polynomial, which violates (2). Therefore, it suffice to show that no prover can prove a false statement by giving a proof with a constant depth.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assume for contradiction that there exists a deterministic polynomial-time cheating prover <span class="math">P^{<em>}</span> a constant <span class="math">D</span> and a polynomial function <span class="math">p</span> such that there exists an infinite sequence of <span class="math">k\\in N</span> and <span class="math">n\\in\\{0,1\\}^{</em>}</span>, such that, <span class="math">P^{*}</span> succeeds in convincing the honest verifier <span class="math">V</span> of some false statement <span class="math">X=(M,x,t)\\not\\in\\mathcal{N}</span> by outputting a proof with <span class="math">d\\leq D</span>, with probability at least <span class="math">1/p(k)</span>. Then we construct another deterministic polynomial time machine <span class="math">B</span> that distinguishes encryption to a random value <span class="math">r</span> and encryption to <span class="math">0</span> with non-negligible probability. This violates the semantic security of the fully homomorphic encryption scheme and then the theorem follows.</p>

    <p class="text-gray-300">Fix any <span class="math">k</span>, <span class="math">n</span> for which <span class="math">P^{<em>}</span> succeeds in cheating with probability <span class="math">1/p(k)</span>. <span class="math">P^{</em>}</span>, on input <span class="math">1^{k}</span> and <span class="math">pp=(id,pk,c)</span>, outputs a statement <span class="math">X=(M,x,t)</span> together with a proof <span class="math">\\pi=(rv,d,c^{\\prime\\prime})</span>. Consider a wrapper machine <span class="math">A</span> that on input <span class="math">(1^{k},id,z)</span>, runs <span class="math">P^{<em>}(1^{k},(id,z))</span> internally, and outputs only the first part <span class="math">rv</span> of <span class="math">P^{</em>}</span>’s output. Since the CRHF <span class="math">\\mathcal{H}</span> is extractable, it follows from Lemma 2 that there exists a deterministic polynomial time machine <span class="math">E_{D}</span>, such that, there exists a negligible function <span class="math">\\mu</span> such that for every <span class="math">z\\in\\{0,1\\}^{*}</span>, except from a <span class="math">\\mu(k)</span> fraction of <span class="math">id\\in I_{k}</span>, when <span class="math">A(1^{k},id,z)</span> outputs a valid hash value <span class="math">rv</span>, <span class="math">E_{D}(1^{k},id,z)</span> outputs a tree <span class="math">\\mathcal{T}</span> that is consistent with <span class="math">rv</span>, that is, <span class="math">\\mathsf{merkle}_{k}(id,D,\\mathcal{T},rv)=1</span>. Given <span class="math">E_{D}</span>, we are now ready to construct machine <span class="math">B</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{machine}\\ B\\ \\text{on input}\\ 1^{k}\\ \\text{and}\\ pp=(id,pk,c)</span>, internally runs both <span class="math">P^{<em>}(1^{k},pp)</span> and <span class="math">E_{D}(1^{k},id,z=(pk,c))</span> and outputs both the outputs of <span class="math">P^{</em>}</span> and <span class="math">E_{D}</span>, that is, <span class="math">(X,\\pi=(rv,d,c^{\\prime\\prime}))</span> and <span class="math">\\mathcal{T}</span>.</p>

    <p class="text-gray-300">Let <span class="math">r</span> be the value encrypted in <span class="math">c</span> under <span class="math">pk</span>, and <span class="math">(q_{1},\\ldots,q_{s})=Q(X,r)</span> the PCP queries computed from <span class="math">X</span> and <span class="math">r</span>. We show that the probability that <span class="math">\\mathcal{T}</span> contains a valid answer for PCP queries <span class="math">(q_{1},\\ldots,q_{s})</span> with respect to <span class="math">X</span> is at least <span class="math">1/2p(k)</span>. In other words, machine <span class="math">B</span> is able to prove a false statement “in plaintext” with probability at least <span class="math">1/2p(k)</span>. This is proved through the following two Claims, which respectively says that except from negligible probabilities, i) whenever the root value <span class="math">rv</span> output by <span class="math">B</span> is a valid hash value, the tree <span class="math">\\mathcal{T}</span> is consistent (w.r.t. <span class="math">\\mathsf{merkle}</span>) with <span class="math">rv</span> (in Claim 1), and ii) whenever the proof <span class="math">\\pi</span> output by <span class="math">B</span> contains in the encryption <span class="math">c^{\\prime\\prime}</span> an authentication path <span class="math">(a,ap)</span> consistent (w.r.t. <span class="math">\\mathsf{verify}</span>) with <span class="math">rv</span>, and <span class="math">\\mathcal{T}</span> is consistent with <span class="math">rv</span>, then <span class="math">\\mathcal{T}</span> contains <span class="math">(a,ap)</span> (in Claim 2).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Claim}\\ 1.\\ \\text{There exists a negligible function}\\ \\mu_{1},\\ \\text{such that for all}\\ k\\in N\\ \\text{and}\\ n\\in\\{0,1\\}^{*},</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(pp,sp)\\leftarrow D(1^{k},1^{n}),\\ (X,\\pi,\\mathcal{T})=B(1^{k},pp)\\ :</span></p>

    <p class="text-gray-300"><span class="math">pp=(id,pk,c),\\ \\pi=(rv,d,c^{\\prime\\prime}),\\ \\mathsf{valid}_{k}(id,rv)=1,\\ \\mathsf{merkle}_{k}(id,D,rv,\\mathcal{T})\\neq 1\\Big{]}\\leq\\mu_{1}(k)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Claim}\\ 2.\\ \\text{There exists a negligible function}\\ \\mu_{1},\\ \\text{such that for all}\\ k\\in N\\ \\text{and}\\ n\\in\\{0,1\\}^{*},</span></p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(pp=(id,pk,c),sp=(sk,r))\\leftarrow D(1^{k},1^{n}),\\ (X,\\pi=(rv,d,c^{\\prime\\prime}),\\mathcal{T})=B(1^{k},pp)\\ :</span></p>

    <p class="text-gray-300"><span class="math">(\\vec{a},\\vec{a p})=\\text{Dec}_{sk}(c^{\\prime\\prime}),\\ \\mathsf{merkle}_{k}(id,D,rv,\\mathcal{T})=1,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\exists j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]\\ \\mathsf{verify}_{k}(id,a_{j},ap_{j})=1\\ \\text{but}\\ \\mathcal{T}\\ \\text{does not contain}\\ a_{j},ap_{j}\\Big{]}\\leq\\mu_{2}(k)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 1 follows from the fact that by construction, the tree <span class="math">\\mathcal{T}</span> output by <span class="math">B</span> is from <span class="math">E_{D}</span>, which is a good extractor for wrapper <span class="math">A</span> that outputs the root value from <span class="math">P^{*}</span>. Thus it follows directly from the extractability of the Merkle tree that except from negligible probability whenever <span class="math">rv</span> is valid, <span class="math">\\mathcal{T}</span> is consistent. Claim 2 essentially follows from the collision resistence property of the hash</p>

    <p class="text-gray-300">function <span class="math">\\mathcal{H}</span>. Assume for contradiction that with some polynomial probability, the proof <span class="math">\\pi</span> output by <span class="math">B</span> contains in the encryption <span class="math">c^{\\prime\\prime}</span> an authentication path <span class="math">(a,ap)</span> consistent with <span class="math">rv</span> that does not appear in the tree <span class="math">\\mathcal{T}</span>. Let <span class="math">q</span> be the leaf node corresponding to <span class="math">(a,ap)</span>. Then consider the path <span class="math">(a^{\\prime},ap^{\\prime})</span> from root to leaf <span class="math">q</span> in <span class="math">\\mathcal{T}</span>. As long as <span class="math">\\mathcal{T}</span> is consistent with <span class="math">rv</span>, we must find a collision of the hash function <span class="math">H_{k,id}</span> on <span class="math">(a,ap)</span> and <span class="math">(a^{\\prime},ap^{\\prime})</span>. This violates the collision resistence property of <span class="math">\\mathcal{H}</span>. Thus Claim 2 holds.</p>

    <p class="text-gray-300">Combining Claim 1 and 2, we have that except from probability <span class="math">\\mu_{1}(k)+\\mu_{2}(k)</span>, the output <span class="math">(X,\\pi=(rv,d,c^{\\prime\\prime}),\\mathcal{T})</span> of <span class="math">B(1^{k},pp=(id,pk,c))</span> satisfies that when <span class="math">\\pi</span> is a convincing proof for <span class="math">X</span>, the following two conditions hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">rv</span> is valid and thus <span class="math">\\mathcal{T}</span> is consistent with <span class="math">rv</span> (by Claim 1).</li>

      <li><span class="math">c^{\\prime\\prime}</span> is an encryption to authentication paths <span class="math">(a_{j},ap_{j})</span> for <span class="math">j\\in[s]</span> satisfying that each <span class="math">a_{j},ap_{j}</span> is consistent and <span class="math">(a_{1},\\ldots,a_{s})</span> convinces a PCP verifier with random tape <span class="math">r</span> (where <span class="math">r</span> is the encrypted value in <span class="math">c</span>). Thus <span class="math">\\mathcal{T}</span> contains all <span class="math">(a_{j},ap_{j})</span> (by Claim 2 and the first condition).</li>

    </ol>

    <p class="text-gray-300">Therefore <span class="math">\\mathcal{T}</span> contains “in plaintext” the answers that convinces a PCP verifer with random tape <span class="math">r</span>. Then by our hypothesis, <span class="math">B</span> on input <span class="math">1^{k}</span>, <span class="math">id</span>, <span class="math">pk</span> and an encryption to <span class="math">r</span> under <span class="math">pk</span>, is able to convince a PCP verifer with random tape <span class="math">r</span> with probability at least <span class="math">1/2p(k)</span>. However, when <span class="math">B</span> receives instead (<span class="math">1^{k}</span>, <span class="math">id</span>, <span class="math">pk</span> and) an encryption to <span class="math">0</span> under <span class="math">pk</span>, by the soundness of the PCP system, except from negligible probability, it cannot output answers that convinces a PCP verifier (since the verifier now has completely private random tape). Thus <span class="math">B</span> distinguishes encryption to a random string <span class="math">r</span> and encryption to <span class="math">0</span> with probability at least <span class="math">1/3p(k)</span>. This violates the semantic security of the fully homomorphic encryption scheme, and gives a contradiction. ∎</p>

    <h2 id="sec-39" class="text-2xl font-bold">6 Delegation without Rejection Problem</h2>

    <p class="text-gray-300">Loosely speaking, a delegation scheme is a 2-stage protocol between a delegator <span class="math">D</span> and a worker <span class="math">W</span>. In an off-line stage, the delegator does some pre-processing based on the function <span class="math">F</span> it wants to compute and generates some public and secret information <span class="math">pp</span> and <span class="math">sp</span>. Later in an on-line stage, the delegator can delegate the computation of <span class="math">F</span> on many inputs to the worker efficiently; the worker evaluates the function and proves to the delegator that the output it returns is correct. The key property of a delegation scheme is that the computation and communication complexity of the delegator in the on-line stage is polylogarithmic in the computation complexity of the function. In other words, the delegator can verify the computation done by the untrusted worker much (polylogarithmically) more efficiently than evaluating the function on its own. Recently, Genenaro, Gentry and Parno <em>[x10]</em> and Chung, Kalai and Vadhan <em>[x7]</em> presented two constructions of delegation schemes, both relying on fully homomorphic encryption schemes. Their schemes, however, share one restriction, known as the rejection problem, that is, a cheating worker can break the soundness of the scheme if it learns the verdict of the delegator on whether it accepts or rejects a proof from the worker. Their solution is either to assume that the worker does not learn the verdict or to perform the off-line stage fresh again after every time the delegator rejects a proof. In Section 6.2.2, we construct a two-message delegation scheme that does not suffer the rejection problem. Furthermore, the soundness of previous schemes relies on the use of fully homomorphic encryption schemes, which makes the computational complexity of their scheme depends on the worst case complexity of the function being computed. In Section 6.2.1, we construct a designated verifier delegation scheme, whose soundness relies on the use of designated verifier CS proof and as a result has instance-based complexity for the worker and the delegator in the on-line stage. That is, the complexity of the delegator and the worker in the on-line stage depends on the complexity of the compuation on the particular input being delegated.</p>

    <p class="text-gray-300">6.1 Delegation Schemes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we formally describe the model of delegation that we consider. Our model is essentially the same as that in <em>[x10, x11]</em>, except from the following three aspects. First, we require that the computational complexity of the worker and the delegator in the on-line stage, computing a function <span class="math">F</span> (represented as a Turing machine <span class="math">M</span>) on input <span class="math">x</span>, to depend solely on the running time <span class="math">t</span> of <span class="math">M</span> on this particular input <span class="math">x</span>, instead of the worst case running time of <span class="math">M</span>; we call this property <em>instance-based complexity</em>. Second, we require soundness of the delegation scheme to hold even if a cheating worker learns the verdicts of the delegator in the on-line stage; we call this property <em>robust soundness</em>. Third, our scheme only handles delegation of <em>polynomial-time computation</em>. The latter seems counter-intuitive: the computational complexity of the delegator (in the on-line stage) is at least polynomial in the length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the input (the delegator needs to at least read the input); if delegation can only handle computation in time polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then what does the delegator gain by engaging in delegation at all? We note that the delegator still gains since the computational complexity of delegation is of a <em>fixed</em> polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (and logarithm of the time of the computation), while the complexity of the delegated computation can be of an <em>arbitrary</em> polynomial. Furthermore, we remark that this restriction is actually inherent for all delegation schemes whose soundness is based on some polynomial time hardness assumptions. The reason is that since soundness only holds against computationally bounded workers (otherwise a cheating worker can break the polynomial time hardness assumption that soundness is based on), then the worker, being computationally bounded, can only compute polynomial time computable functions for the delegator. (We note that this restriction also applies to previous constructions <em>[x10, x11]</em>, although it is not stated explicitly.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 9 (Delegation with Robust Soundness).</h6>

    <p class="text-gray-300">A delegation scheme is an interactive protocol <span class="math">\\mathsf{Del}=(D=(A_{1},A_{2}),W)</span> consisting of the following two stages:</p>

    <p class="text-gray-300">The delegator <span class="math">A_{1}</span> on input a security parameter <span class="math">k</span> and a polynomial-time computable function <span class="math">F:\\{0,1\\}^{n}\\to\\{0,1\\}^{m}</span>, represented as a Turing machine <span class="math">M</span> and a polynomial time bound <span class="math">T=k^{c}</span> for <span class="math">M</span>, outputs a public string <span class="math">pp</span> and a private string <span class="math">sp</span>, that is, <span class="math">(pp,sp)=A_{1}(1^{k},F)</span>. We will use the notation <span class="math">M</span>, <span class="math">n</span>, <span class="math">m</span>, and <span class="math">T</span> as the Turing machine and parameters associated with <span class="math">F</span> below. The delegator <span class="math">A_{2}</span> and the worker <span class="math">W</span> on input <span class="math">1^{k}</span>, <span class="math">F</span> and an input <span class="math">x\\in\\{0,1\\}^{n}</span>, interacts in an interactive protocol. At the end of the protocol, the delegator <span class="math">A_{2}</span> decides to accept or reject; if it accepts, then it additionally outputs a value <span class="math">y</span>.</p>

    <p class="text-gray-300">Furthermore, <span class="math">\\mathsf{Del}</span> satisfies the following properties.</p>

    <p class="text-gray-300">The computational complexity of worker <span class="math">W</span> and the delegator <span class="math">A_{2}</span> in the on-line stage is bounded by <span class="math">\\mathrm{poly}(k,T)</span> and <span class="math">\\mathrm{poly}(k,n,m,\\log T)</span> respectively. The total communication complexity of the on-line and off-line stage is bounded by <span class="math">\\mathrm{poly}(k,\\log n,m,\\log T)</span>.</p>

    <p class="text-gray-300">Furthermore if the computational complexity of <span class="math">W</span> and <span class="math">A_{2}</span> depends on the running time <span class="math">t</span> of <span class="math">M</span> on input <span class="math">x</span> (i.e., resepctively <span class="math">\\mathrm{poly}(k,t)</span> and <span class="math">\\mathrm{poly}(k,n,m,\\log t)</span>), instead of the worst case running time <span class="math">T</span> of <span class="math">M</span>, we say that the delegation scheme has instance-basec complexity. For all <span class="math">k</span>, <span class="math">n</span>, <span class="math">m</span>, <span class="math">T</span>, <span class="math">F</span> and <span class="math">x</span>, after running the delegation scheme <span class="math">(D,W)</span> on these inputs as specified above, <span class="math">A_{2}</span> accepts with probability 1. For every cheating <span class="math">\\mathcal{PPT}</span> worker <span class="math">W^{<em>}</span>, every constant <span class="math">C</span>, there exists a negligible function <span class="math">\\mu</span>, such that for every <span class="math">k\\in N</span>, every <span class="math">F=(M,n,m,T)</span> with <span class="math">T\\leq k^{C}</span>, the probability that <span class="math">W^{</em>}</span> wins in the following security game <span class="math">Sec(W^{*},1^{k},F)</span> is bounded by <span class="math">\\mu(k)</span>.</p>

    <p class="text-gray-300">##</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The delegator <span class="math">A_{1}</span> executes the off-line stage by generating <span class="math">(pp,sp)\\leftarrow A_{1}(1^{k},F)</span>.</li>

      <li>The cheating worker <span class="math">W^{<em>}</span> interacts with <span class="math">A_{2}</span> in an arbitrary number of iterations of its choice. In the <span class="math">i^{\\text{th}}</span> iteration, <span class="math">W^{</em>}</span> selects an input <span class="math">x_{i}\\in\\{0,1\\}^{n}</span> and interacts with <span class="math">A_{2}</span> on input <span class="math">(1^{k},F,x_{i},pp,sp)</span>; after <span class="math">A_{2}</span> outputs a verdict <span class="math">b_{i}</span>, <span class="math">W^{*}</span> learns <span class="math">b_{i}</span>. If <span class="math">A_{2}</span> accepts in round <span class="math">i</span>, that is <span class="math">b_{i}=1</span>, let <span class="math">y_{i}</span> be value <span class="math">A_{2}</span> outputs at the end of the protocol.</li>

    </ol>

    <p class="text-gray-300"><span class="math">W^{*}</span> wins in the game, if there exists an <span class="math">i</span> in which <span class="math">A_{2}</span> accepts (i.e., <span class="math">b_{i}=1</span>) but <span class="math">y_{i}\\neq F(x_{i})</span>.</p>

    <p class="text-gray-300">In the above defined soundness game <span class="math">Sec</span>, the cheating worker learns the verdict of the delegator immediately after each execution of the on-line stage. In contrast, previous works <em>[x10, x11]</em> consider a soundness game that terminates once the delegator rejects a proof from the cheating worker; we call delegation scheme with such soundness guarantee a delegation scheme without verification oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this work, we will also consider the following additional properties. We say that a delegation scheme is a one-message delegation scheme, if the on-line stage contains only a single message from the worker to the delegator (that is, <span class="math">A_{2}</span> does not send any message). We say that a delegation scheme is on-line if the off-line stage is empty. Furthermore, we say that a delegation scheme has an efficient off-line stage if the computational complexity of the delegator <span class="math">A_{1}</span> in the off-line stage is $\\operatorname{poly}(k,n,m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log T)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-41" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">In the above definition, the verifier runs in time polynomial in the length <span class="math">n</span> of the input <span class="math">x</span> (beyond running in time polylogarithmic in the running time of the computation <span class="math">T</span>). This seems necessarily, since the verifier needs to at least read the entire input <span class="math">x</span>. However, if one is willing to assumes that the input <span class="math">x</span> is given in an error correcting code (as is done in <em>[x3]</em> and some follow-up works), it would be possible to achieve verifier’s computational complexity that is poly-logarithmic in the length of <span class="math">x</span>. Such a delegation scheme can be constructed using essentially the same method below from a designated verifier CS proof that has verifier’s complexity of polylogarithmic in the length of the input, which in turn can be constructed almost identically as in Section 5 but relying on a PCP of proximity system for the non-deterministic CS language <span class="math">\\mathcal{N}</span> as in <em>[x12]</em>.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.2 Our Constructions</h3>

    <p class="text-gray-300">We present two delegation schemes. The first scheme <span class="math">\\mathsf{Del}_{1}=(W_{1},D_{1})</span>, as previous constructions, only satisfies soundness without verification oracle; but it improves previous works on that it has an efficient off-line stage, a one-message on-line stage, and instance-based complexity. The second scheme <span class="math">\\mathsf{Del}_{2}=(W_{2},D_{2})</span> satisfies soundness with verification oracle and is further completely on-line.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">6.2.1 Designated Verifier CS Proofs for CS Language <span class="math">\\mathcal{L}</span></h4>

    <p class="text-gray-300">Our delegation schemes will rely on a designated verifier CS proof system for the (deterministic) CS language <span class="math">\\mathcal{L}</span>, which includes all quadruples <span class="math">X=(M,x,y,t)</span> such that <span class="math">M(x)=y</span> in <span class="math">t</span> steps. (See Definition 5 for a formal definition.) In section 5.2, we constructed a designated verifier CS proof system <span class="math">(D_{N},P_{N},V_{N})</span> for the non-deterministic CS language <span class="math">\\mathcal{N}</span>. We show how to transform that scheme to a designated verifier CS proof system <span class="math">(D_{L},P_{L},V_{L})</span> for <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Towards this, we first show that every statement <span class="math">X=(M,x,y,t)\\in\\mathcal{L}</span> can be converted efficiently into a statement <span class="math">X^{\\prime}\\in\\mathcal{N}</span> together with a corresponding witness <span class="math">w</span>. The conversion algorithm <span class="math">\\mathsf{convert}(X)</span> proceeds as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{convert}(X=(M,x,y,t))</span>: Run <span class="math">M</span> on input <span class="math">x</span>, producing the output <span class="math">y</span> and a <span class="math">t</span>-step history <span class="math">\\sigma</span> of a computation of <span class="math">M</span> outputting <span class="math">y</span> on input <span class="math">x</span>. Consider the following relation <span class="math">R</span>.</p>

    <p class="text-gray-300"><span class="math">R(X,\\sigma)=1</span> if and only if <span class="math">\\sigma</span> is the <span class="math">t</span>-step history of a computation of <span class="math">M</span> outputting <span class="math">y</span> on input <span class="math">x</span>.</p>

    <p class="text-gray-300">Evaluates <span class="math">R((M,x,y,t),\\sigma)</span> and records the number of steps <span class="math">t^{\\prime}</span> taken by <span class="math">R</span>. Then set the statement <span class="math">X^{\\prime}\\in\\mathcal{N}</span> to <span class="math">(R,(M,x,y,t),t^{\\prime})</span> and the witness <span class="math">w=\\sigma</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that <span class="math">R</span> is polynomial time computable. Thus $t^{\\prime}=\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,t)<span class="math"> bounded by </span>t^{\\beta}<span class="math"> for some constant </span>\\beta<span class="math">. Therefore, the length of the new statement </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is bounded by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\gamma}<span class="math"> for some constant </span>\\gamma<span class="math">, and the computational complexity of </span>\\mathsf{convert}<span class="math"> is </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,t)<span class="math">. Then the designated verifier CS proof system </span>(D_{L},P_{L},V_{L})<span class="math"> for </span>\\mathcal{L}$ proceeds as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Set-up:}</span> <span class="math">D_{L}</span>, on input <span class="math">1^{k}</span> and $1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, sets </span>n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\gamma}<span class="math"> and runs </span>D_{N}(1^{k},1^{n})<span class="math"> producing </span>(pp,sp)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Prover&#x27;s Message:}</span> <span class="math">P_{L}</span> on input <span class="math">1^{k}</span>, <span class="math">X=(M,x,y,t)</span>, and <span class="math">pp</span>, converts <span class="math">X</span> into a statement <span class="math">X^{\\prime}\\in\\mathcal{N}</span> and its witness <span class="math">w</span> using the conversion algorithm <span class="math">\\mathsf{convert}</span>, runs the honest prover strategy <span class="math">P_{N}(1^{k},pp,X^{\\prime},w)</span> to generate a proof <span class="math">\\pi^{\\prime}</span> and outputs <span class="math">\\pi=(X^{\\prime},\\pi)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Verifier&#x27;s Decision:}</span> <span class="math">V_{L}</span> on input <span class="math">1^{k}</span>, <span class="math">X=(M,x,y,t)</span>, <span class="math">pp</span>, <span class="math">sp</span> and <span class="math">\\pi=(X^{\\prime},\\pi^{\\prime})</span>, first checks whether <span class="math">X^{\\prime}</span> is well formed and consists of <span class="math">R</span>, <span class="math">(M,x,y,t)</span> and <span class="math">t^{\\prime}</span>; furthermore, it checks whether <span class="math">t^{\\prime}\\leq t^{\\beta}</span>. It aborts if any of the conditions does not hold. Otherwise, it runs the honest verifies strategy <span class="math">V_{N}(1^{k},pp,sp,X^{\\prime},\\pi^{\\prime})</span> and accepts if and only if <span class="math">V_{N}</span> accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(D_{L},P_{L},V_{L})</span> is a designated verifier CS proof system for <span class="math">\\mathcal{L}</span>. It is easy to see that the computational complexity of the prover is $\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,,t)<span class="math"> and the length of the proof is </span>\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Completeness follows from the completeness of </span>(D_{N},P_{N},V_{N})<span class="math">. Furthermore, weak soundness follows from the weak soundness of </span>(D_{N},P_{N},V_{N})<span class="math"> and the fact that </span>V_{L}<span class="math"> checks that the time </span>t^{\\prime}<span class="math"> sent by </span>P_{L}<span class="math"> is correctly bounded by </span>t^{\\beta}<span class="math">; this is because if a cheating prover </span>P_{L}^{*}<span class="math"> is able to prove a false statement </span>X<span class="math"> with </span>t\\leq k^{C}<span class="math"> for some </span>C<span class="math">, it must prove a false statement </span>X^{\\prime}\\in\\mathcal{L}<span class="math"> with some </span>t^{\\prime}\\leq t^{\\beta}\\leq k^{C\\beta}<span class="math"> using </span>(D_{N},P_{N},V_{N})<span class="math">. This violates the weak soundness of </span>(D_{N},P_{N},V_{N})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">6.2.2 One-Message Delegation with Instance-based Complexity</h4>

    <p class="text-gray-300">Let <span class="math">(D,P,V)</span> be a designated verifier CS proof system for the non-deterministic CS language <span class="math">\\mathcal{L}</span>. The delegation scheme <span class="math">(D_{1},W_{1})</span> proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Off-Line Stage:}</span> The delegator <span class="math">D_{1}</span>, on input <span class="math">1^{k}</span> and a function <span class="math">F=(M,n,m,T)</span>, runs the set-up algorithm <span class="math">D</span> on input <span class="math">(1^{k},1^{l})</span> with $l=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+n+m+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, producing </span>(pp,sp)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{On-Line Stage:}</span> The worker <span class="math">W_{1}</span> on input <span class="math">1^{k}</span>, <span class="math">F</span>, <span class="math">pp</span> and an input <span class="math">x\\in\\{0,1\\}^{n}</span>, first evaluates <span class="math">M</span> on input <span class="math">x</span> to obtain the output <span class="math">y=M(x)</span> and measure the time <span class="math">t</span> taken by the computation. It then runs the honest prover strategy <span class="math">P(1^{k},pp,X=(M,x,y,t))</span> to generate a proof <span class="math">\\pi</span>. Finally, <span class="math">W_{1}</span> outputs <span class="math">y,(t,\\pi)</span>.</p>

    <p class="text-gray-300">The delegator <span class="math">D_{1}</span> after receiving <span class="math">y</span> and <span class="math">(t,\\pi)</span>, checks whether <span class="math">t\\leq T</span>. It aborts if <span class="math">t&gt;T</span>; otherwise, it runs the honest verifier strategy <span class="math">V(1^{k},pp,sp,X,\\pi)</span> to verify the proof, and accepts if and only if <span class="math">V</span> accepts.</p>

    <p class="text-gray-300">The completeness of <span class="math">\\mathsf{Del}_{1}</span> follows directly from that of the designated verifier CS proof. Furthermore, since the designated verifier CS proof system has instance based complexity. That is, the computational complexity of the prover and verifier on input <span class="math">X=(M,x,y,t)</span> are respectively</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathrm{poly}(k,t)</span> and $\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t)=\\mathrm{poly}(k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math">, and the total length of the public information and the CS proof is </span>\\mathrm{poly}(k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)=\\mathrm{poly}(k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math"> (See Remark 2), all independent the worst case running time of </span>M<span class="math">. The delegation scheme </span>\\mathsf{Del}_{1}<span class="math"> derived from it also has instance based complexity. More precisely, in the on-line stage, the deletagor and the worker on input </span>F<span class="math"> and </span>x<span class="math"> runs in time </span>\\mathrm{poly}(k,n,m,\\log t)<span class="math"> and </span>\\mathrm{poly}(k,t)<span class="math">, where </span>t<span class="math"> is the running time of </span>M<span class="math"> on input </span>x<span class="math">; in the off-line stage, the delegator runs in time </span>\\mathrm{poly}(k,n,m,\\log T)<span class="math">, where </span>T<span class="math"> is the worst case running time of </span>M<span class="math">. Furthermore, the total communication complexity including the public key and the on-line proof is </span>\\mathrm{poly}(k,\\log n,m,\\log T)<span class="math">. The soundness of the scheme follows from the weak soundness of the designated verifier CS proof. However, since the latter only holds against a cheating prover who does not see the verdict of the verifier. Scheme </span>\\mathsf{Del}_{1}<span class="math"> only achieves soundness without verification oracle. Finally, we remark that </span>\\mathsf{Del}_{1}<span class="math"> has an efficient off-line stage with computational complexity </span>\\mathrm{poly}(k,\\log n,m,\\log T)$ independent of the complexity of the compuation, and the on-line stage contains only a single message from the worker to the delegator.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">6.2.3 On-Line Delegation Satisfying Soundness with Verification Oracle</h4>

    <p class="text-gray-300">Soundness without verification oracle means that every time after the delegator rejects a proof, it needs to execute the off-line stage fresh again to prevent a cheating worker (aware of its decision) from cheating in later proofs. Although the delegation scheme <span class="math">\\mathsf{Del}_{1}</span> satisfies only soundness without verification oracle, it has a very efficient off-line stage, with computational complexity <span class="math">\\mathrm{poly}(k,n,m,\\log T)</span>. Therefore, the delegator can, in fact, afford to run the off-line stage every time before delegating a computation. By doing so, soundness holds even if the cheating worker learns the delegator’s decisions, yielding a two-message delegation scheme satisfying robust soundness.</p>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Off-Line Stage:</h5>

    <p class="text-gray-300">Empty. The delegator <span class="math">D_{2}</span>, on input <span class="math">1^{k}</span> and a function <span class="math">F=(M,n,m,T)</span>, runs <span class="math">D_{1}(1^{k},F)</span> in off-line stage to generate <span class="math">(pp,sp)</span>; it sends <span class="math">pp</span> to the worker.</p>

    <p class="text-gray-300">The worker <span class="math">W_{2}</span> on input <span class="math">1^{k}</span>, <span class="math">F</span>, <span class="math">pp</span> and an input <span class="math">x\\in\\{0,1\\}^{n}</span>, sends back <span class="math">(y,\\pi)=W_{1}(1^{k},pp,F,x)</span>.</p>

    <p class="text-gray-300"><span class="math">D_{2}</span> reaches a decision exactly as <span class="math">D_{1}</span> does.</p>

    <h2 id="sec-47" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AF07] Masayuki Abe and Serge Fehr. Perfect nizk with adaptive soundness. In TCC, pages 118–136, 2007.</li>

      <li>[BCC88] Gilles Brassard, David Chaum, and Claude Crépeau. Minimum disclosure proofs of knowledge. J. Comput. Syst. Sci., 37(2):156–189, 1988.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In STOC, pages 21–31, 1991.</li>

      <li>[BG08] Boaz Barak and Oded Goldreich. Universal arguments and their applications. SIAM J. Comput., 38(5):1661–1694, 2008.</li>

      <li>[BP04] Mihir Bellare and Adriana Palacio. Towards plaintext-aware public-key encryption without random oracles. In ASIACRYPT, pages 48–62, 2004.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BSGH^{+}05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Short pcps verifiable in polylogarithmic time. In IEEE Conference on Computational Complexity, pages 120–134, 2005.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BSGH^{+}06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust pcps of proximity, shorter pcps, and applications to coding. SIAM J. Comput., 36(4):889–974, 2006.</li>

      <li>[BV11] Z. Brakerski and V. Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. To appear in TCC 2010, 2011.</li>

      <li>[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In ICALP (2), pages 449–460, 2008.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557–594, 2004.</li>

      <li>[CKLR11] Kai-Min Chung, Yael Tauman Kalai, Feng-Hao Liu, and Ran Raz. Memory delegation. Cryptology ePrint Archive, Report 2011/273, 2011. http://eprint.iacr.org/.</li>

      <li>[CKV10] Kai-Min Chung, Yael Kalai, and Salil P. Vadhan. Improved delegation of computation using fully homomorphic encryption. In CRYPTO, pages 483–501, 2010.</li>

      <li>[CL08] Giovanni Di Crescenzo and Helger Lipmaa. Succinct np proofs from an extractability assumption. In CiE, pages 175–185, 2008.</li>

      <li>[CMS99] Christian Cachin, Silvio Micali, and Markus Stadler. Computationally private information retrieval with polylogarithmic communication. In EUROCRYPT, pages 402–414, 1999.</li>

      <li>[Dam91] Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In CRYPTO, pages 445–456, 1991.</li>

      <li>[Din07] Irit Dinur. The pcp theorem by gap amplification. J. ACM, 54(3):12, 2007.</li>

      <li>[DNRS03] Cynthia Dwork, Moni Naor, Omer Reingold, and Larry J. Stockmeyer. Magic functions. J. ACM, 50(6):852–921, 2003.</li>

      <li>[FL93] Lance Fortnow and Carsten Lund. Interactive proof systems and alternating time-space complexity. Theor. Comput. Sci., 113(1):55–73, 1993.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: practical solutions to identification and signature problems. In Proceedings on Advances in cryptology—CRYPTO ’86, pages 186–194, London, UK, 1987. Springer-Verlag.</li>

      <li>[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In STOC, pages 169–178, 2009.</li>

      <li>[Gen11] Craig Gentry. Fully homomorphic encryption without bootstrapping. Manuscript, 2011.</li>

      <li>[GGP10] Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In CRYPTO, pages 465–482, 2010.</li>

    </ul>

    <p class="text-gray-300">[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the fiat-shamir paradigm. In FOCS, pages 102–, 2003.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In STOC, pages 113–122, 2008.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</li>

      <li>[Gol01] Oded Goldreich. Foundations of Cryptography — Basic Tools. Cambridge University Press, 2001.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASI-ACRYPT, pages 321–340, 2010.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, pages 723–732, 1992.</li>

      <li>[Kil95] Joe Kilian. Improved efficient arguments (preliminary version). In CRYPTO, pages 311–324, 1995.</li>

      <li>[KR08] Yael Tauman Kalai and Ran Raz. Interactive pcp. In ICALP (2), pages 536–547, 2008.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859–868, 1992.</li>

      <li>[Mer89] Ralph C. Merkle. A certified digital signature. In CRYPTO, pages 218–238, 1989.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253–1298, 2000.</li>

      <li>[PS94] Alexander Polishchuk and Daniel A. Spielman. Nearly-linear size holographic proofs. In STOC, pages 194–203, 1994.</li>

      <li>[Sha92] Adi Shamir. Ip = pspace. J. ACM, 39(4):869–877, 1992.</li>

      <li>[vDGHV10] Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. Fully homomorphic encryption over the integers. In EUROCRYPT, pages 24–43, 2010.</li>

    </ul>

    <h2 id="sec-48" class="text-2xl font-bold">Appendix A General Definitions</h2>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">A.1 Witness Relations</h3>

    <p class="text-gray-300">We recall the definition of a witness relation for a <span class="math">\\mathcal{NP}</span> language <em>[x11]</em>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 10 (Witness relation).</h6>

    <p class="text-gray-300">A witness relation for a language <span class="math">L\\in\\mathcal{NEXP}</span> is a binary relation <span class="math">R_{L}</span> that characterizes <span class="math">L</span> by <span class="math">L=\\{x:\\exists y\\,s.t.\\,(x,y)\\in R_{L}\\}</span></p>

    <p class="text-gray-300">We say that <span class="math">y</span> is a witness for the membership <span class="math">x\\in L</span> if <span class="math">(x,y)\\in R_{L}</span>.</p>

    <p class="text-gray-300">A.2 Indistinguishability</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 11 (Computational Indistinguishability).</h6>

    <p class="text-gray-300">Let <span class="math">Y</span> be a countable set. Two ensembles <span class="math">\\{A_{k,y}\\}_{k\\in N,y\\in Y}</span> and <span class="math">\\{B_{k,y}\\}_{k\\in N,y\\in Y}</span> are said to be computationally indistinguishable (denoted by <span class="math">\\{A_{k,y}\\}_{k\\in N,y\\in Y}\\approx\\{B_{k,y}\\}_{k\\in N,y\\in Y}</span>), if for every <span class="math">\\mathcal{PPT}</span> “distinguishing” machine <span class="math">D</span>, there exists a negligible function <span class="math">\\nu(\\cdot)</span> so that for every <span class="math">k\\in N,y\\in Y</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[a\\leftarrow A_{k,y}\\ :\\ D(1^{k},y,a)=1\\right]-\\Pr\\left[b\\leftarrow B_{k,y}\\ :\\ D(1^{k},y,b)=1\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\nu(k)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.3 Interactive Proofs</h3>

    <p class="text-gray-300">We use the standard definitions of interactive proofs (and interactive Turing machines) <em>[x10]</em> and arguments (a.k.a. computationally-sound proofs) <em>[x3]</em>. Given a pair of interactive Turing machines, <span class="math">P</span> and <span class="math">V</span>, we denote by <span class="math">\\langle P(w),V\\rangle(x)</span> the random variable representing the (local) output of <span class="math">V</span>, on common input <span class="math">x</span>, when interacting with machine <span class="math">P</span> with private input <span class="math">w</span>, when the random input to each machine is uniformly and independently chosen.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 12 (Interactive Proof System).</h6>

    <p class="text-gray-300">A pair of interactive machines <span class="math">\\langle P,V\\rangle</span> is called an interactive proof system for a language <span class="math">L</span> if there is a negligible function <span class="math">\\nu(\\cdot)</span> such that the following two conditions hold :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For every <span class="math">x\\in L</span>, and every <span class="math">w\\in R_{L}(x)</span>, <span class="math">\\Pr\\left[\\langle P(w),V\\rangle(x)=1\\right]=1</span></li>

      <li>Soundness: For every <span class="math">x\\in\\{0,1\\}^{n}-L</span>, and every interactive machine <span class="math">B</span>, <span class="math">\\Pr\\left[\\langle B,V\\rangle(x)=1\\right]\\leq\\nu(n)</span></li>

    </ul>

    <p class="text-gray-300">In case that the soundness condition is required to hold only with respect to a computationally bounded prover, the pair <span class="math">\\langle P,V\\rangle</span> is called an interactive argument system.</p>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Delegation of Computation without Rejection Problem from Des... (2011/456)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/456
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
