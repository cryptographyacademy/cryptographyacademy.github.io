---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/456';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Delegation of Computation without Rejection Problem from Designated Verifier CS-Proofs';
const AUTHORS_HTML = 'Shafi Goldwasser, Huijia Lin, Aviad Rubinstein';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We present a designated verifier CS proof system for polynomial time computations. The proof system can only be verified by a designated verifier: one who has published a public-key for which it knows a matching secret key unknown to the prover. Whereas Micali&#x27;s CS proofs require the existence of random oracles, we can base soundness on computational assumptions: the existence of leveled fully homomorphic encryption (FHE) schemes, the DDH assumption and a new knowledge of exponent assumption.

Using our designated verifier CS proof system, we construct two schemes for delegating (polynomial-time) computation. In such schemes, a delegator outsources the computation of a function $F$ on input $x$ to a polynomial time worker, who computes the output $y=F(x)$ and proves to the delegator the correctness of the output.

Let $T$ be the complexity of computing $F$ on inputs of length $n=\\abs x $ and let $k$ be a security parameter.  Our first scheme calls for an one-time off-line stage where the delegator sends a message to the worker, and a non-interactive on-line stage where the worker sends the output together with a certificate of correctness to the prover per input $x$. The total computational complexity of the delegator during off-line and on-line stages is $ \\poly(k, n, \\log T)$. Compared with previous constructions by Gennaro-Gentry-Parno and Chung-Kalai-Vadhan~\\cite{GGP10, CKV10} based on FHE, their on-line stage consists of two messages and their off-line stage has (delegator&#x27;s) complexity of $\\poly(k,n, T)$. Thus, they achieve delegator complexity $\\poly(k, n, \\log T)$ only in an amortized sense. Compared with the construction of \\cite{GKR08} based on poly-log PIR, our first construction can handle any polynomial-time computable $F$ rather than being restricted to $\\NC$ computable $F$.  Our second scheme requires no off-line stage and has a two-message \`\`on-line&#x27;&#x27; stage with complexity of $\\poly(k, n, \\log T)$. Most importantly, it achieves {\\em robust soundness} that guarantees that it is infeasible for a cheating worker to convince the delegator of an invalid output even if the worker learns whether the delegator accepts or rejects previous outputs and proofs. Previously the only two-round protocol that achieves robust soundness under a computational assumption appeared in \\cite{GKR08} and is restricted to only $\\NC$ computations.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Designated Verifier CS Proofs &middot; Delegation &middot; Knowledge of Exponent Assumption</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Efficient proof verification lies at the heart of complexity theory and the definition of the class N P. Classically, this was captured by the idea of having a deterministic polynomial time (in the size of the statement to be proved) verification procedure which receives a proof&mdash;a polynomial size certificate&mdash;and checks for correctness. Extending classical proof systems, interactive proof systems (IP) provided a model in which the polynomial time verification procedure&mdash;the verifier algorithm is randomized and can interact with an all powerful prover algorithm which may employ an adaptive strategy in answering the verifier's messages. This strenghening enables efficient verification of all PSPACE computation. In another notion of probabilistically-checkable proof systems (PCPs), the verifier is similarily randomized, but the prover is restricted to utilize a non-adaptive strategy and the soundness of the proof is guaranteed only with respect to such provers. As a result, PCPs can be used to prove any computation in N EX P. In yet a different line of work, interactive argument systems and CS proof systems restricted the cheating provers in another way: they consider only cheating provers that run in time bounded by some function in the complexity of the statement to be proved. By relaxing the soundness requirement to hold only against computationally bounded provers, CS proofs can handle computation up to N EX P. Overall, the works on efficient verifiability throughout the 70's and 80's&mdash;from the works on N P to interactive proofs, PCPs to arguments and CS proofs&mdash;dedicated the bulk of their attention &quot;upwards&quot;, trying to achieve efficient (polynomialtime) verifiability for larger and larger classes of intractable (super polynomial-time) languages.</p>

    <p class="text-gray-300">In contrast, more recent developments starting with the work of Goldwasser, Kalai, and Rothblum [GKR08] have focused on &quot;looking downwards&quot;, trying to obtain extremely efficient (say, linear time) proof verification for tractable languages. This line of research is motivated by realworld applications, in particular, the application of outsourcing computation: In today's network, there are computational devices of vastly different computational capabilities interacting with each other over the network. Some of these devices are computationally weak due to various resource constraints. To potentially allow a weak device to support a larger range of applications, including those that are beyond its reach computationally, a natural solution is to have a weak device&mdash;called the delegator in this case&mdash;to delegate computations that are too expensive to a more powerful device&mdash;called the worker&mdash;that is connected with the weak device via a network. Then the delegation problem is: how can a delegator be assured using its meager powers that the worker performed the computation correctly?</p>

    <p class="text-gray-300">The connection between the delegation problem and efficient proof verification is clear. View the delegator as a verifier and the worker as a prover that computes the result of a (pre-specified) polynomial time algorithm M on some input x and prove to the verifier that M(x) = y. The input x is thought of as dictated to the prover by an outside source, or by the verifier itself. <sup>1</sup> The challenge of the delegation problem is to design a proof system which achieves &quot;two-fold&quot; efficiency: (1) relative efficiency of the prover, that is, the prover (i.e., the worker) can convince the verifier (i.e., the delegator) that M(x) = y without doing much more work than evaluating M on x and (2) absolute efficiency of the verifier, that is, the verification requires significantly less work than evaluating M on x.</p>

    <p class="text-gray-300">More formally, a delegation system consists of a pair of polynomial time interactive Turing machines (D, W) which, on input a polynomial time Turing machine M , an input x, and a security parameter 1<sup>k</sup> , satisfy the following properties:</p>

    <p class="text-gray-300">&bull; The computational complexity of the Workder/Prover W is polynomial in the computational complexity of the algorithm M.</p>

    <p class="text-gray-300"><sup>1</sup>The honest prover is restricted to be a polynomial time algorithm without having access to an auxiliary oracle or auxiliary input to help in the proving process, as was the case in argument systems in the cryptographic area.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The computational complexity of the Delegator/Verifier D is polynomial in the size of the input x and poly-logarithmic in the computational complexity of M.</li>
      <li>The communication complexity of the system is poly-logarithmic in the size of the input x and poly-logarithmic in the computational complexity of M.</li>
      <li>Completeness: If y is the valid output of M(x), then the Worker W convinces the Delegator D of the correctness of y with probability close to 1.</li>
      <li>Soundness: No cheating worker W<sup>0</sup> can convince the (honest) verifier to accept an incorrect output y <sup>0</sup> 6= M(x) with non-negligible probability in the security parameter k.</li>
    </ul>

    <p class="text-gray-300">Some remarks are in order. First, in the above formalization, we phrased the delegation problem as receiving the input x as an input provided from the outside. In previous works, the input x is often provided in a first message from verifer to prover, which allowed solutions in which the communication complexity was linear in n beyond the need to communicate x. We thus purposely stated x as an outside input to properly count the communication complexity requirement of protocols. Obviously, if an application calls for the verifier to send the input x to the prover such a message can be added. See Remark 2 in Section 5.2 for more detials. Second, in some settings it may be required to keep x secret from the worker. We consider this a fundamentally different problem which we do not address in this work. Finally, we allow the verifier to run in time polynomial in the length of the input x. One can actually remove this restriction and allow the verifier to run in time poly-logarithmic in the length of the input if it has access to an encoding of the input using an error correcting code. See Remark 3 in Section 6.1 for more details.</p>

    <p class="text-gray-300">Below for convenience, we will use the name delegator and verifier, as well as worker and prover, interchangeably. We will also assume that the running time t<sup>x</sup> of the delegated algorithm M on input x is bigger than the length of the input x and that of the output y = M(x).</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">The delegation problem is the focus of our work. To this end, we propose two solutions.</p>

      <h4 id="sec-1.1.1" class="text-lg font-semibold mt-6">1.1.1 Solution 1: Non-Interactive Delegation&mdash;Designated Verifier CS-Proofs</h4>

    <p class="text-gray-300">The notion of Computationally-Sound (CS) proofs of [Mic00] when restricted to the case of polynomiall time computation is indeed the holy-grail of the delegation problem.</p>

    <p class="text-gray-300">Let k be a security parameter and n is the size of the input x. CS-proofs provide a non-interactive delegation system where to prove that y = M(x), the worker in time poly(k, tx) can generate a certificate &sigma; of the correctness of y that has size poly-logarithmic in the running time t<sup>x</sup> of M on input x. The verifier on input x, after receiving the certificate &sigma;, verifies the correctness of the output y in time poly(k, |x| , |&sigma;|) = poly(k, n, log tx) (actually, the verifier runs in time quasi-linear in the input length O&tilde;(n)&middot; poly(k, log tx)). Additionally, the prover generates the certificate in time poly(k, tx). We note that the CS proof provides a delegation scheme that achieves instance-based , complexity that requires the running time of the worker, who is delegated the computation of M on an input x, to depend on the running time t<sup>x</sup> of M on that particular instance x (instead of the worst-case complexity of M). A CS-proof is publically verifiable by any algorithm with access to x, M and &sigma;, whereas no such requirement is enforced in a delegation scheme.</p>

    <p class="text-gray-300">Micali's notion of CS proofs [Mic00] achieves such wondrous non-interactive delegation system, but, with a heavy price: The construction of CS proofs needs to revert to the random oracle model. In essence, the construction of CS proofs crushes the 4-round public-coin interactive argument system of Kilian [Kil92] into a single message by relying on the random oracle to serve both as a CRHF (to compress a PCP proof as in [Kil92]), and in addition as a Fiat-Shamir-hash-functions to remove interaction as in [FS87]. Unfortunately, the possibility of implementing Fiat-Shamir-hash-functions by any hash function ensemble has been shown to be highly questionable [CGH04, DNRS03, GK03], and remains to be a significant open problem in cryptography. On the other hand, outside the random oracle model, no non-interactive delegation system is known for full polynomial time computations, even if the delegation system can use a specific, designated, verifier.</p>

    <p class="text-gray-300">The possibility of non-interactive delegation is clearly most appealing. One may envision a delegator, using the computer facilities at a cloud to compute the result of an algorithm M, receives later the result via an e-mail with a very short &quot;certificate&quot; of correctness that can be written down in its entirty. Toward this goal, several works, starting with [GKR08] and followed by the work of Gennaro, Gentry and Parno [GGP10], and that by Chung, Kalai, and Vadhan [CKV10], have considered a relaxation in which the verifier is a designated verifier. Namely, the verifier may register as a client of the worker and establish some information in an off-line stage (or even engage in an interactive protocol with the worker in an off-line stage) which will enable him to verify the correctness of the proofs provided by the prover later in an on-line stage. Intuitively, what distinguishes a designated verifier from any other algorithm is that it knows some secret which will enable him (and only him) to verify the correctness of the proofs and catch a cheating prover (who does not know the secret) if it tries to prove a false statement.</p>

    <p class="text-gray-300">Unfortunately, even with the relaxation of using a designated verifier, previous works do not match CS proofs. Let T be the worst case complexity of computing M. The construction of [GKR08] consists of one-time off-line stage with delegator complexity poly(log T, k) in which the delegator posts one message to the worker of size poly(log T, k); then for every input x the online stage is non-interactive (the worker sends a certificate  <span class="math">\\sigma</span>  of size poly(log T, k) certifying the value of M(x) which the delegator can verify), and is a function of the instance-based efficiency of the worker. But, it can only handle delegation of uniform  <span class="math">\\mathcal{NC}</span> -computable algorithms. The designated verifier delegation schemes of [GGP10, CKV10] handle any P time computation. However, they consist of a one-time off-line stage with delegator complexity poly(T, k), and then an on-line two-round interactive protocol of comunication complexity poly(log T, k, n). Thus, they only achieve amortized delegator computation complexity (and communication complexity) poly(log T, k, n) over many inputs x. The computational complexity of the worker in [GGP10, CKV10] depends on the worst-case complexity of the algorithm being delegated rather than instance-based complexity.</p>

    <p class="text-gray-300">Our first delegation system is a non-interactive designated verifier delegation scheme for all computation in  <span class="math">\\mathcal{P}</span> . Additionally, the prover complexity is instance-based  <span class="math">\\operatorname{poly}(k, t_x)</span> . The delegators complexity in the off-line and on-line stages are respectively is  <span class="math">\\tilde{O}(n) \\cdot \\operatorname{poly}(\\log t, k)</span>  and  <span class="math">\\tilde{O}(n) \\log \\operatorname{poly}(\\log T, k)</span> . Thus, the complexity guarantee is per input (not amortized).</p>

    <p class="text-gray-300">The soundness of our protocol is based on the assumption that leveled Fully Homomorphic Encryption (FHE) schemes exist, the intractability of DDH, and a new Knowledge of Exponent Assumption (KEA), called q-KEA. The recent result of Brakersky and Vaikuntanathan [BV11], followed by Gentry [Gen11], provides a leveled FHE scheme (that is, the scheme can homorphically evaluate over ciphtertexts any circuits of depth bounded by a prior polynomial) based on the intractability of the Learning With Errors (LWE) assumption<sup>2</sup>. In fact, rather than assuming FHE, our construction can easily be transformed to use a PIR with receiver computation and communication complexities poly-logarithmic in the size of the database. For simplicity, we use FHE for the presentation.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>To achieve full homomorphism (without a prior bound on the depth of the circuits that the homomorphic evaluation procedure can take as input), Brakersky and Vaikuntanathan [BV11] need to additionally assume that their scheme is circular secure, that is, it is secure to encrypt the secret key using the encryption scheme itself. However, for our application, the function to be homomorphically evaluated is fixed and thus it suffices to use a leveled FHE scheme.</p>

    <p class="text-gray-300">The knowledge of exponent assumption was originally introduced by Damgard [Dam91], and later extended by Bellare and Palacio [BP04] for showing the existence of 3-round zero-knowledge proofs. Our q-KEA assumption generalizes their assumptions so that we say q-KEA holds for a group G, if it is infeasible for a challenger, given a random generator  <span class="math">g = g_0</span> , q random elements  <span class="math">g_1, \\ldots, g_q</span>  in the group, along with their  <span class="math">\\alpha^{\\text{th}}</span>  powers (i.e.,  <span class="math">g_0^{\\alpha}, \\ldots, g_q^{\\alpha}</span> ), to generate a pair  <span class="math">c, \\hat{c} = c^{\\alpha}</span> , without actually &quot;knowing&quot; coefficients  <span class="math">a_0, \\ldots, a_q</span>  such that  <span class="math">c = \\prod_{i=0}^q g_i^{a_i}</span> . Here, &quot;knowing&quot; is captured by requiring that there exists a non-black-box extractor, who can depends on the code of the challenger, to extract out these  <span class="math">a_i</span> 's. Our assumption is similar and in fact inspired by the assumption made by Groth [Gro10]. However, the actual assumption is incomparable with that of Groth.</p>

    <p class="text-gray-300">Theorem 1 (Informal, Non-Interactive Designed Verifier Delegation Scheme) Assume the existence of a leveled fully homomorphic encryption scheme, the intractability of DDH and that q-KEA holds. Then, there exists a delegation scheme (D, W) with the following properties: Let k be a security parameter,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For a polynomial time computable function (algorithm)  <span class="math">M : \\{0,1\\}^n \\to \\{0,1\\}^*</span>  of worst casr complexity T, the delegator in an off-line stage sends to the worker one message and keeps some secret information for later on-line stage. The computation complexity of the delegator in the off-line stage is  <span class="math">\\tilde{O}(n)</span>  poly <span class="math">(k, \\log T)</span>  and the commication complexity is poly <span class="math">(k, \\log T)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any input  <span class="math">x \\in \\{0,1\\}^n</span> , the worker in an on-line stage sends the output of the computation y = M(x) and a proof of size  <span class="math">poly(k, \\log t_x)</span> , where  <span class="math">t_x</span>  is the running time of M on x. Furthermore, the worker runs in time  <span class="math">poly(k, t_x)</span>  and the delegator runs in time  <span class="math">\\tilde{O}(n)poly(k, \\log t_x)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Compared with the original CS proofs of Micali, proofs of the delegation scheme of Theorem 1 can only be verify by a verifier who holds the secret information generated in the off-line stage, whereas the CS proofs are publically verifiable in the random oracle model. Therefore, we also call such proof system a designated verifier CS proof system.</p>

    <p class="text-gray-300">There is one issue with the soundness of our designated verifier delegation schemes which seems &ndash; so far&ndash; to be an inherent problem in all existing (including [GKR08, CKV10, GGP10]) designed verifier delegation schemes: the soundness of the system holds only under the restriction that the cheating worker does not learn whether the verifier accepts or rejects previous proofs from the prover. Alternatively stated, as soon as the delegator rejects one proof from the worker (and the worker is aware of that), soundness can no longer be claimed. The problem is that the worker can deviate from the protocol and generates messages to the verifier &quot;improperly&quot; so that by learning the verdicts of the verifier as a feedback, it can learn some information about the secret held by the designated verifier, which will then enable it to prove invalid statements later. We note that this is reminiscent of the problem encountered in the context of chosen ciphertext secure encryption schemes: Access to a decryption protocol with improperly formed ciphertexts may reveal information about the secret key and thus can compromise the security of the scheme. In the context of delegation, we call this the <em>verifier rejection</em> problem.</p>

      <h4 id="sec-1.1.2" class="text-lg font-semibold mt-6">1.1.2 Solution 2: Two-Message Interactive Argument System</h4>

    <p class="text-gray-300">Our second solution is a two-message delegation scheme for all of  <span class="math">\\mathcal{P}</span>  that addresses the verifier rejection problem. Compared with our first scheme (which does suffer from the verifier rejection problem), this scheme is interactive (consisting of two messages) and the delegator only has worst-case complexity (the worker still has instance-based complexity). More formally, we obtain:</p>

    <p class="text-gray-300">Theorem 2 (Informal, Delegation Scheme without Verifier Rejection Problem) Assume the existence of a leveled fully homomorphic encryption scheme, the intractability of DDH, and that q-KEA holds. Then, there exists a delegation system (D, W) with the following properties: Let k be a security parameter,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For a polynomial time computable function (algorithm) M : {0, 1} <sup>n</sup> &rarr; {0, 1} <sup>&lowast;</sup> of worst case complexity T, and an input x &isin; {0, 1} n , the worker and the delegator interacts with each other in a 2-rounds protocol. The communication complexity of the protocol is poly(k, log T). The computational complexity of the worker and the delegator are respectively, poly(k, tx) and O&tilde;(n)poly(k, log T), where t<sup>x</sup> is the running time of M on x.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Soundness holds even against a cheating worker that is aware of the verdicts of the delegator. That is, it is infeasible for a cheating worker to convince the honest verifier to accept an incorrect output y 6= M(x) even if the worker learns whether the delegator accept or reject previous proofs for other inputs.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let us briefly compare our interactive solution to previous interactive arguments which can be used as delegation systems. Kilian [Kil92, Kil95] gives an 4-round argument system for any N P computation, with communication complexity that is polylogarithmic, and verifier runtime which is linear in the input length (up to polylogarithmic factors), This is achieved by a constant round (four rounds) protocol, in which the prover first constructs a PCP for the correctness of the computation, and then Merkle-hashes it down to a short string and sends it to the verifier. To prove the soundness of his scheme, Kilian must assume the existence of strong collision-intractable hash functions: where collisions cannot be formed in sub-exponential time<sup>3</sup> .</p>

    <p class="text-gray-300">For uniform N C computations, [GKR08] shows how to combine their interactive proofs with a technique of Kalai and Raz [KR08] to give a two round delegation system for polynomial time bounded provers for N C computations based on the existence of a private information retrieval system (PIR) which achieves poly-logarithmic communication. Such PIR were first proposed by Cachin, Micali, and Stadler [CMS99] based on the &phi;-hiding assumption and most recently by Brakersky and Vaikuntanathan [BV11] based on the intractability of the LWE assumption.</p>

    <p class="text-gray-300">We note that a 2008 paper by Di Crescenzo and Lipmaa [CL08] proposes a two-round argument with prover and verifier complexity and communication complexity as required for a delegation solution, but they do not prove soundness based on a computational assumption but rather, essentially their soundness proof assumes a restriction on the cheating prover: essentially if an efficient cheating prover can convince the verifier to accept the statement x &isin; L it must be able to reconstruct a PCP proof of the statement. The question of two-round delegation argument systems for general P time computations and for (unrestricted class) polynomial time adversaries under computational assumptions thus remained open.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Our Techniques</h3>

    <p class="text-gray-300">The key tool that enables our construciton is an extractable collision resistant hash function. A collision resistent hash function (CRHF) is, informally speaking, a polynomial-time computable function H mapping binary strings of arbitrary length into reasonably short strings, so that it is computationally infeasible to find any collision (for H), that is, any two different strings x and y for which H(x) = H(y). In this work, we will consider CRHF that are additionally &quot;extractable&quot;: Given a hash value, a preimage can be extracted efficiently. However, in general, such a construct cannot exist, since CRHF is one-way. To circumvent this problem, we will consider non-black-box extraction, that is, a preimage of a hash value can be extracted if the extractor &quot;sees&quot; the &quot;code&quot; of</p>

    <p class="text-gray-300"><sup>3</sup>With standard intractability assumptions, one could get arguments of linear size communication complexity.</p>

    <p class="text-gray-300">the machine that outputs that hash value. However, this relaxation alone is not sufficient to allow us to circumvent the impossibility. Consider, for instance, a hash function whose range is the set of all k-bit binary strings. In this case, a random hash value can be generated by simply tossing k random coins. But, given the code of such a sampling algorithm does not help invert the hash value at all. Instead, we require that values output by an extractable CRHF have some special structure; then, only for those valid hash values, a preimage can be extracted (in a non-black-box way).</p>

    <p class="text-gray-300">Not surprisingly, we can construct such an extractable CRHF based on the q-KEA assumption. Our construction is similar to the construction of commitments with knowledge by Groth [Gro10], which in turn is based on a variant of the Pedersen commitment scheme. Let G be a group in which DDH and q-KEA holds, meaning that given properly sampled  <span class="math">g_0, \\ldots, g_q</span>  in G, along with their  <span class="math">\\alpha^{\\text{th}}</span>  powers  <span class="math">\\hat{g}_0, \\ldots, \\hat{g}_q</span> , if a challenger generates a pair  <span class="math">c, \\hat{c} = c^{\\alpha}</span> , then, there exists an extractor that extracts coefficients  <span class="math">a_0, \\ldots, a_q</span>  such that  <span class="math">c = \\prod_{i=0}^q g_i^{a_i}</span> . Then to hash a vector of elements  <span class="math">e_0, \\ldots, e_q</span> , our CRHF simply outputs a pair  <span class="math">c = \\prod_{i=0}^q g_i^{a_i}</span>  and  <span class="math">\\hat{c} = \\prod_{i=0}^q (\\hat{g}_i)^{a_i}</span> . The collision resistence property of the hash function follows from the DDH assumption, and the extractability follows from q-KEA, since every valid output of the hash function satisfies that  <span class="math">\\hat{c} = c^{\\alpha}</span> , then by q-KEA, a pre-image  <span class="math">e_0, \\ldots, e_q</span>  can be extracted. Given such an extractable CRHF, next we provide an overview of our construction of delegation schemes.</p>

      <h4 id="sec-1.2.1" class="text-lg font-semibold mt-6">1.2.1 Overview of Our Approach</h4>

    <p class="text-gray-300">Similar to CS proofs in [Mic00], the overall approach to our construction is also to collapse rounds of the 4-message public-coin zero-knowledge argument of Kilian [Kil92], which in turn relies on PCP proofs and the notion of Merkle trees. So let us start by briefly reviewing them:</p>

    <p class="text-gray-300"><strong>Probabilistic Checkable Proofs:</strong> Loosely speaking, a probabilistically checkable proof system (PCP) for a language consists of a probabilistic polynomial-time verifier having direct access to individual bits of a binary string. This string (called oracle) represents a proof, and typically will be accessed only partially by the verifier. Queries to the oracle are positions on the bit string and will be determined by the verifier's input and coin tosses. The verifier is supposed to decide whether a given input belongs to the language. If the input belongs to the language, the requirement is that the verifier will always accept given access to an adequate oracle. On the other hand, if the input does not belong to the language, then the verifier will reject with probability at least 1-  <span class="math">\\varepsilon</span>  for some small error bound  <span class="math">\\varepsilon</span> , no matter which oracle is used. A formal definition of PCP can be found in section 3.3. We care about the complexity of the PCP verifier, in particular, the number of random coins it tosses  <span class="math">p_r(n)</span>  and the number of queries  <span class="math">p_q(n)</span>  it issues on input a statement of length n. Below we use polynomials  <span class="math">p_r</span>  and  <span class="math">p_q</span>  to denote the complexity of the PCP verifier.</p>

    <p class="text-gray-300"><strong>Merkle Trees:</strong> A Merkle tree [Mer89] is a binary tree whose nodes are associated with values. A leaf node can store any value, but each internal node stores a value that is the hash of the concatenation of the values in its children through a collision-resistent hash function  <span class="math">\\mathcal{H}</span> . Thus, if  <span class="math">\\mathcal{H}</span>  produces k-bit outputs, each internal node of a Merkle tree, including the root, stores a k-bit value.</p>

    <p class="text-gray-300">The crucial property of a Merkle tree is that, unless one succeeds in finding a collision for  <span class="math">\\mathcal{H}</span> , it is computationally hard to change any value in the tree without also changing the root value. This property allows a party A to &quot;commit&quot; to n values,  <span class="math">v_1, \\ldots, v_l</span>  (for simplicity assume  <span class="math">l = 2^d</span>  for some integer d), by means of a single k-bit value. That is, A stores value  <span class="math">v_i</span>  in the i<sup>th</sup> leaf of a full binary tree of depth  <span class="math">d = \\log l</span> , and uses a collision-free hash function  <span class="math">\\mathcal{H}</span>  to build a Merkle tree, thereby obtaining a k-bit value, rv, stored in the root.</p>

    <p class="text-gray-300">More interestingly, A may &quot;prove&quot; what a particular  <span class="math">v_i</span>  was &quot;locally&quot; by revealing just d+1</p>

    <p class="text-gray-300">values: v<sup>i</sup> together with its authentication path ap<sup>i</sup> , that is, the values stored in the siblings of the nodes along the path from leaf i (included) to the root (excluded), Y1, . . . , Yd. It follows from the collision resistance property of H again that it is infeasible for A to come up with two different pairs of values and authentication paths that are both consistent with rv.</p>

    <p class="text-gray-300">Kilian's Construction: In [Kil92] Kilian presents a special zero-knowledge argument for N P, (Pk, Vk), exhibiting a polylogarithmic amount of communication, where prover P<sup>k</sup> uses a Merkle tree in order to provide to V<sup>k</sup> &quot;virtual access&quot; to a PCP proof. Below we describe the Kilian's protocol disregards the ZK property; our description is based on that presented in [BG08].</p>

    <p class="text-gray-300">To prove a statement x &isin; L, the verifier V<sup>k</sup> starts by sending the prover a CRHF H with output length k. The prover on private input a witness w, constructs a PCP-proof &pi;. In order to yield efficient verifiability, P<sup>k</sup> cannot send V<sup>k</sup> the witness w nor &pi;. Rather, P<sup>k</sup> builds a Merkle tree with the proof &pi; as the leaf values (using the collision-free hash function H from the verifier) producing a k-bit root value rv. It then &quot;commits&quot; itself to &pi; by sending rv to the verier Vk. Since the Merkle tree is a full binary tree, the depth of the tree generated will be d = log |&pi;|; as the length of the proof is in turn bounded polynomially by the length of the witness, we have d = O(log |w|). The verier V<sup>k</sup> then tosses pr(|x|) random coins r and sends them to the prover. Both the prover P<sup>k</sup> and the verifier V<sup>k</sup> computes the queries q1, . . . , q<sup>s</sup> (s = pq(|x|)) by internally running the PCP verifier on input x and r. The prover P<sup>k</sup> answers those queries by sending back answers a1, . . . , a<sup>s</sup> together with their authentication paths ap<sup>1</sup> , . . . , ap<sup>s</sup> . V<sup>k</sup> then checks whether a<sup>j</sup> 's authentication path is consistent with rv, and, if so, it is assured that a<sup>j</sup> is the original value because the prover, being polynomial-time, cannot find a collision for H. Finally, if any query answers and its corresponding authentication path are not consistent with rv, V<sup>k</sup> rejects. Otherwise, it runs the PCP verifier on these answers (x, a1, . . . , as) and accepts if and only if the PCP verifier accepts. Because Vpcp only makes pq(|x|) = poly(|x|) queries and each query will be answered by kd = O(k log |w|) bits of authentication path, the overall amount of communication is polylogarithmic in |w|.</p>

    <p class="text-gray-300">At a very high-level, the soundness of Kilian's protocol follows from the fact that the Merkle tree provides the verifier &quot;virtual access&quot; to the PCP proof, in the sense that given the root value of the Merkle tree, for every query q, it is infeasible for a cheating prover to answer q differently depending on the queries. Therefore, interacting with the prover is &quot;equivalent&quot; to having access to a PCP proof oracle. Then it follows from the soundness of the PCP system that Kilian's protocol is sound.</p>

    <p class="text-gray-300">Our Approach: We collapse rounds of the Kilian's protocol in two steps. First, we &quot;compress&quot; the two verifier's messages into one, which turns the protocol into a two-message protocol (P2, V2), using a leveled FHE scheme and assuming DDH and q-KEA. This two-message protocol essentially yields our second delegation solution. It does not suffer from the verifier rejection problem since it does not have an off-line stage and thus the delegator does not rely on any secret information. Therefore, even if the worker learns the verdicts of the verifier, soundness still holds for the soundness of interactive arguments is closed under sequential composition.</p>

    <p class="text-gray-300">More precisely, let E = (KeyGen,Enc, Dec) be a leveled FHE scheme. To prove a statement x, the prover P<sup>2</sup> and the verifier V<sup>2</sup> proceed as follows:</p>

    <p class="text-gray-300">Verifer's message: V<sup>2</sup> samples a random public and private key pair, (pk, sk) &larr; KeyGen(1<sup>k</sup> , 1 L) (where L is polylogarithmic in a bound on the length of the PCP proof of x), and a random pr(|x|)-bit string r that will work as the random tape of the PCP verifier. It then sends a CRHF H, pk and an encryption c of r under pk, i.e., c = Encpk(r).</p>

    <p class="text-gray-300">Prover's message: The prover P<sup>2</sup> first computes the PCP proof &pi; and builds a Merkle tree T using H from &pi; as in Kilian's protocol, producing a root value rv. It then tries to compute the PCP queries (q1, . . . , qs) based on the input x and the random coins r; however, since it only receives an encryption c of r, it cannot evaluate  <span class="math">q_1, \\ldots, q_s</span>  directly. Instead, it computes those queries fully homomorphically over x and c, producing encryptions c' of  <span class="math">q_1, \\ldots, q_s</span> . It further computes answers  <span class="math">a_1, \\ldots, a_s</span>  and the corresponding authentication paths  <span class="math">ap_1, \\ldots, ap_s</span>  again fully homomorphically (over  <span class="math">\\pi</span> ,  <span class="math">\\mathcal{T}</span> , and c'), yielding encryptions c''. Finally it sends back rv and c''.</p>

    <p class="text-gray-300"><strong>Verifier's decision:</strong> The verifier after receiving rv and c'', decrypts c'' to obtain  <span class="math">a_1, \\ldots, a_s</span>  and  <span class="math">ap_1, \\ldots, ap_s</span> . It then runs the same decision procedure as  <span class="math">V_k</span>  in Kilian's protocol.</p>

    <p class="text-gray-300">Given the two-message protocol  <span class="math">(P_2, V_2)</span> , notice that the verifier's message is almost &quot;oblivious&quot; of the input x, and only depends on its length |x| (for deciding a bound on the length of the PCP proof for x and the number of coins tosses needed). Thus the first message can be generated beforehand by a trusted third party and the two-message protocol can be turned into a designated verifier delegatio system  <span class="math">(P_1, V_1)</span> &mdash;or a designated verifier CS proof system&mdash;yielding our first delegation solution. More precisely, the delegator  <span class="math">V_1</span>  in the off-line stage generates a message  <span class="math">(\\mathcal{H}, pk, \\operatorname{Enc}_{pk}(r))</span>  as  <span class="math">V_2</span>  does in the first round;  <span class="math">V_1</span>  sends the message to the worker and keeps r and the secret key sk as its secret information. Later in the on-line stage, the worker  <span class="math">P_1</span>  proceeds the same as  <span class="math">P_2</span>  does in the second round; then the delegator decides whether to accept or reject as  <span class="math">V_2</span>  does.</p>

    <p class="text-gray-300">The soundness of the designated verifier CS proof (D, P, V) follows directly from the soundness of the protocol  <span class="math">(P_2, V_2)</span> . Intuitively, it seems that the latter should follow from the semantically security of the level FHE scheme. By the soundness of the PCP system, it is infeasible for a cheating prover to generate a proof for a false statement that convinces an honest PCP verifier (except from negligible probability). Furthermore, by the semantic security of the leveled FHE scheme, even if the cheating prover additionally receives an encryption of the random tape of the PCP verifier, it is still infeasible to generate an accepting proof. Then, as argued above for Kilian's protocol, since the Merkle tree provides &quot;virtual access&quot; to the proof, the cheating prover fails with overwhelming probability. The above argument is indeed very tempting. However, we do not manage to make it go through. The problem lies in the last part of the argument: unlike the case in Kilian's protocol where the verifier gets direct &quot;virtual access&quot; to the PCP proof, in our protocol, the verifier gets encrypted answers to the PCP queries and their corresponding authenticating paths back. Then suddenly, the cheating prover may be able to create some &quot;rogue&quot; connection between the encryption of the verifier's random tape, the root value of the Merkle tree and its encrypted answers.</p>

    <p class="text-gray-300">To overcome this problem, we instantiate our designated verifier CS proof system with an extractable CRHF. We claim that such a proof system is sound. At a very high level, assume for contradiction that there exists a cheating prover that can prove a false statement, that is, given an encryption of the randomness of the PCP verifier, it manages to produce a root value rv, sends back encrypted answers to the PCP verifier's queries together with authentication paths (also encrypted) that are consistent with rv, and its answers convince the PCP verifier. Since the CRHF is extractable, one can extract out the values associated with the children of the root that hash to rv. Furthermore, by applying the extractability property recursively, we can further, level by level, extract out the values associated with the whole Merkle tree that hashes to rv. It then follows from the collision resistence property of the hash function that this extracted tree must &quot;agree&quot; with the prover's answers, that is, the authentication paths sent by the prover must be the same as the corresponding paths in the tree. Thus we obtain a machine that (given an encryption of the randomness of the verifier), outputs convincing answers to PCP queries in plaintext. This contradicts with either the soundness of PCP or the semantic security of the fully homomorphic encryption scheme.</p>

    <p class="text-gray-300">There is one caveat in the argumentment above. When applying the extractability of the CRHF to extract out a Merkle tree from a root value rv, the time of extraction soon explode. Consider,</p>

    <p class="text-gray-300">for instance, that if extracting the preimage of a hash value output by a t-time machine takes time t 2 . Then, after applying extraction recursively for d times, the total extraction time grows double exponentially to t 2 d . In comparison, we need to keep the extraction time &quot;tamed&quot;&mdash;in polynomial time&mdash;so that the FHE scheme remains semantically secure. We resolve this problem by utilizing the fact that our extractable CRHF has a very high &quot;compression&quot; rate: The ratio between the length of the input and that of the output is k (assuming q-KEA with q = 2k&minus;1). Therefore, we can build a very &quot;flat&quot; Merkle tree by allowing each internal nodes to have k children. In this way, we can &quot;commit&quot; to any polynomial length string (or proof for delegation) into a root value of a constant depth Merkle tree. As a result, the extraction time for such a Merkle tree is still bounded by a polynomial. Finally, we remark that since the extraction time is bounded by a polynomial, it suffices to require our extractable CRHF to be collision resistant against polynomial time adversaries. On the other hand, Kilian's 4-round interactive argument system rely on a CRHF that is collision resistant against even sub-exponential adversaries. On a very high level, this difference stems from the fact that in our security proof, we use a strategy that finds a collision in polynomial time (by comparing the encrypted authentication paths from the cheating prover with that in the extracted Merkle tree from the root value from the prover), whereas the collision-finding strategy in Kilian's proof runs in sub-exponential time.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Other Related Works</h3>

    <p class="text-gray-300">Scaling down classical works on interactive proofs to address polynomial time languages result in non-polynomial time provers. In particular, the work of Lund, Fortnow, Karloff and Nissan [LFKN92] and that of Shamir [Sha92], the honest prover runs in super-polynomial time even for log-space languages. The work of Fortnow and Lund [FL93], using algebraic methods extending [LFKN92, Sha92], does explicitly address the question of interactive proofs for polynomial time languages and in particular N C. Their protocol, however, has a non-polynomial time prover as in [LFKN92, Sha92].</p>

    <p class="text-gray-300">The more recent work of Goldwasser, Kalai, and Rothblum [GKR08] provided an interactive proof to the delegation problem with a polynomial time prover, and verifier computation and communication complexity poly-logarithmic in the time of the computation, for uniform N C algorithms. Their protocol requires poly-logarithmic rounds of communication for N C computations. More generally, for general (non N C) uniform circuit families, they provide an interactive protocol where the verifier time complexity, round complexity, and total communication complexity is a polynomial in the depth of the circut rather than its size.</p>

    <p class="text-gray-300">The work of Babai, Fortnow, Levin and Szegedy [BFLS91] on Holographic Proofs for N P namely, PCP-proofs where the input is assumed to be presented to the verifier in an error-correctingcode format&mdash;raise similar complexity goals as in the delegation problem, requiring super-efficient verifiability (linear time in the input length and poly-logarithmic in the computation time), and efficient provability (polynomial time in the non-deterministic time complexity of accepting the input). However, the model of PCP in which they can obtain their results does not provide a solution to the delegation problem, as it proves soundness only against non-adaptive provers. Let us elaborate. [BFLS91] shows how to achieve verification time that is polylogarithmic in the length of the computation (on top of the time taken to convert the input into an error correcting code format), and a PCP-proof-string of length close to the computation time itself. However the soundness of proofs in the PCP model (as well as its more efficient descendants [PS94, BSGH+06, BSGH+05, Din07]) requires that the verifier/delegator will either 'poses' the entire PCP-proofstring (although the verifier will only read a few bits of it), or somehow have a guarantee that the prover/delegatee cannot change any bit of the PCP-proof-string after the verifier has started to request bits of it. Such guarantee is not achievable over a network as required in the delegation</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">off-line</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">on-line</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ref</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Assumption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s&szlig;su #</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s&szlig;sw #</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">W complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rejection</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GKR08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(d, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(n, d, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BFL91, BFLS91</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(n, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kil92, Mic00</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k,t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kil92, Mic00</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RO-Heur</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k,t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GKR08, KR09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PIR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, d, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k,t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">N_{\\rm O}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GGP09</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, T)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, T)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CKV10-Thm5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\operatorname{poly}(k,T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, T)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CKV10-Thm6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, n, log T)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\operatorname{poly}(k,T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\rm Yes</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Del <sub>1</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PIR, DDH, q-KEA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, n, log T)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">poly(k, n, \\log t)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, n, t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Del <sub>2</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PIR, DDH, <span class="math">q</span> -KEA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\operatorname{poly}(k, n, \\log T)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(k, n, t)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">^{\\rm ON}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Results on Delegating Computation. D = delegator/verier, W = worker/prover, k = security parameter. Parameters of computation f being delegated: n = input length, T = maximum runnning time of f,  <span class="math">t = t_x = \\text{running time of } f</span>  on input x, d = depth/parallel time (we assume  <span class="math">n \\le T \\le 2^d</span> ).</p>

    <p class="text-gray-300">setting.</p>

    <p class="text-gray-300">Another related work is the recent work Chung, Kalai, Liu and Raz [CKLR11], relying on the existence of FHE scheme, addresses the question of memory delegation. Here, a delegator sends the entire content of its memory to a worker in an initial stage and from there on can issue some editing commands and can quickly verify the result of computations done by the worker on the memory. Our protocol can be used on top of the memory delegation scheme to enable the efficient verification of P time computations on the memory either using our first or second solution.</p>

    <p class="text-gray-300">A related construct to our extractable collision resistant hash functions is the one-way extractable functions of Canetti and Dakdouk [CD08] which required that any party that manages to compute a value in the range of the function &quot;knows&quot; a corresponding preimage.</p>

    <p class="text-gray-300">We summarize the known results in Table 1.3.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Outline</h2>

    <p class="text-gray-300">In Section 3 we provide some preliminaries and definitions of assumptions and primitives that we rely on. In Section 4, we introduce the notion of extractable collision resistant hash funcitons and provide a construction based on a new knowledge of exponent assumption called q-KEA in Section 4.1. Using extractable collision resistent hash functions, we construct a designated verifier CS proof system in Section 5. Finally, we obtain two schemes for delegating computation from a designated verifer CS proof system in Section 6.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">Let N denote the set of all positive integers. For any integer n &isin; N, let [n] denote the set {1, 2, . . . , n}, We denote by {0, 1} n the set of binary strings of length n, and |x| the length of a binary string. We denote by PPT probabilistic polynomial time Turing machines. We assume familiarity with interactive Turing machines, denoted ITM, interactive protocols, and computational indistinguishability; the formal definitions of interactive protocols and comutational indistinguishability are provided in Appendix A.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 The DDH Assumption</h3>

    <p class="text-gray-300">let G take a security parameter k written in unary and output a description of a group (p, G) &larr; G(1<sup>k</sup> ) such that p is a k bit prime and G is a cyclic group of order p. The DDH assumption holds for G if the following two ensembles are computationally indistinguishable.</p>

    <p class="text-gray-300">&bull;
<span class="math">$\\{(p,G) \\leftarrow \\mathcal{G}(1^k), g \\leftarrow_R G - \\{0\\}, (a,x) \\leftarrow_R \\mathbb{Z}_p^2 : (g,g^x,g^a,g^{ax})\\}_{k \\in N}</span>$</p>

    <p class="text-gray-300">&bull;
<span class="math">$\\{(p,G) \\leftarrow \\mathcal{G}(1^k), g \\leftarrow_R G - \\{0\\}, (a,x,r) \\leftarrow_R \\mathbb{Z}_p^3 : (g,g^x,g^a,g^r)\\}_{k \\in \\mathbb{N}}</span>$</p>

    <p class="text-gray-300">The DDH assumption implies that for every polynomial q, the following ensembles are indistinguishable.</p>

    <p class="text-gray-300"><span class="math">$\\left\\{ (p,G) \\leftarrow \\mathcal{G}(1^k), \\ g \\leftarrow_R G - \\{0\\}, \\ a \\leftarrow_R \\mathbb{Z}_p, \\ (x_1, \\dots, x_{q(k)}) \\leftarrow_R \\mathbb{Z}_p^{q(k)} : \\\\ (g, g^{x_1}, \\dots, g^{x_{q(k)}}, g^a, g^{ax_1}, \\dots, g^{ax_q(k)}) \\right\\}_{k \\in \\mathbb{N}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left\\{ (p,G) \\leftarrow \\mathcal{G}(1^k), \\ g \\leftarrow_R G - \\{0\\}, \\ a \\leftarrow_R \\mathbb{Z}_p, \\ (x_1, \\dots, x_{q(k)}) \\leftarrow_R \\mathbb{Z}_p^{q(k)}, \\ (r_1, \\dots, r_{q(k)}) \\leftarrow_R \\mathbb{Z}_p^{q(k)} : (g, g^{x_1}, \\dots, g^{x_{q(k)}}, g^a, g^{r_1}, \\dots, g^{r_{q(k)}}) \\right\\}_{k \\in \\mathbb{N}}</span>$</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Fully Homomorphic Encryption Schemes</h3>

    <p class="text-gray-300">A public-key encryption scheme E = (KeyGen; Enc; Dec) is said to be fully homomorphic if it is associated with an additional polynomial-time algorithm Eval, that takes as input a public key pk, a ciphertext &circ;x = Encpk(x) and a circuit C, and outputs, a new ciphertext c = Evalpk(&circ;x; C), such that Decsk(c) = C(x), where sk is the secret key corresponding to the public key pk. It is required that the size of c = Evalpk(Encpk(x); C) depends polynomially on the security parameter and the length of C(x), but is otherwise independent of the size of the circuit C. We also require that Eval is deterministic, and the the scheme has perfect correctness (i.e. it always holds that Decsk(Encpk(x)) = x and that Decsk(Evalpk(Encpk(x); C)) = C(x)). For security, we simply require that E is semantically secure.</p>

    <p class="text-gray-300">In a recent breakthrough, Gentry [Gen09] proposed a fully homomorphic encryption scheme based on ideal lattices. Following this, Dijk, Gentry, Halevi and Vaikuntanathan[vDGHV10] proposed an alternative construction based on the extended GCD assumption. Very recently, Brakerski and Vaikuntanathan [BV11] proposed a new scheme based solely on the (standard) Learning With Error (LWE) assumption, which is in turn based on the worst-case hardness of short vector problems on arbitrary lattices. Immediately following that, Gentry [Gen11] further simplied their construction and greatly improved the efficiency of fully homomorhpic encryptions schemes. In all these schemes, the complexity of the algorithms (KeyGen; Enc; Dec) depends linearly on the depth d of the circuit C, where d is an upper bound on the depth of the circuit C that are allowed as inputs to Eval. However, under the additional assumption that these schemes are circular secure (i.e., remain secure even given an encryption of the secret key), the complexity of these algorithms are independent of C.</p>

    <p class="text-gray-300">Our designated verifer CS proofs rely on the existence of a level FHE scheme. For simplicity of our presentation, we assume that the FHE scheme has perfect completeness. We note that the FHE schemes of both [Gen09] and [vDGHV10] indeed have perfect completeness. Furthermore, even if the FHE scheme does not have perfect completeness, it only causes the resulting designated verifier CS proofs to have an additional negligible completeness and soundness error.</p>

    <p class="text-gray-300">Below, when referring to a FHE, we mean a leveled FHE with perfect completeness.</p>

      <h4 id="sec-3.2.1" class="text-lg font-semibold mt-6">3.2.1 Private Information Retrieval</h4>

    <p class="text-gray-300">Rather than assuming FHE, our construction can easily be transformed to use a PIR with receiver computation and communication complexities poly-logarithmic in the size of the database. In [BV11], such a PIR scheme is constructed from LWE-based FHE. Therefore PIR is, in some sense, a weaker assumption than FHE, and yet it suffices for our construction.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Probabilistically Checkable Proofs</h3>

    <p class="text-gray-300">Loosely speaking, a probabilistically checkable proof system (PCP) for a language consists of a probabilistic polynomial-time verifier having direct access to individual bits of a binary string. This string (called oracle) represents a proof, and typically will be accessed only partially by the verifier. Queries to the oracle are positions on the bit string and will be determined by the verifier's input and coin tosses. The verifier is supposed to decide whether a given input belongs to the language. If the input belongs to the language, the requirement is that the verifier will always accept given access to an adequate oracle. On the other hand, if the input does not belong to the language, then the verifier will reject with probability at least 1-  <span class="math">\\varepsilon</span>  for some small error bound  <span class="math">\\varepsilon</span> , no matter which oracle is used. Below we present the formal definition of PCP.</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (Probabilistically Checkable Proofs). A probabilistically checkable proof system with error bound  <span class="math">\\varepsilon</span>  for a language L consists of probabilistic polynomial-time oracle machine (called verifier) V and two polynomials  <span class="math">p_r</span> ,  <span class="math">p_q</span>  satisfying</p>

    <p class="text-gray-300">Completeness: For every  <span class="math">x \\in L</span>  there exists an oracle  <span class="math">\\pi_x</span>  such that,  <span class="math">\\Pr[V^{\\pi_x}(x) = 1] = 1</span></p>

    <p class="text-gray-300"><strong>Soundness:</strong> For every  <span class="math">x \\notin L</span>  and every oracle  <span class="math">\\pi</span> ,  <span class="math">\\Pr[V^{\\pi}(x) = 1] \\leq \\varepsilon(|x|)</span></p>

    <p class="text-gray-300"><strong>Complexity:</strong> On any input of length n, V makes at most  <span class="math">p_r(n)</span>  coin tosses and at most  <span class="math">p_q(n)</span>  oracle queries.</p>

    <p class="text-gray-300">In this work, we do not care about the refined complexity  <span class="math">p_r</span>  and  <span class="math">p_q</span>  of the PCP system. Instead, we will care about that a set  <span class="math">\\mathcal{N} \\subseteq \\mathcal{NEXP}</span>  (the non-deterministic CS language defined in Section 5.1) has a PCP system with a negligible error bound, and satisfies the following additional proprieties defined in [BG08].</p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Additional Properties for PCP [BG08]). Let V be a PCP verifier with error bound  <span class="math">\\varepsilon</span>  and complexity  <span class="math">p_r</span>   <span class="math">p_q</span> , for a language  <span class="math">\\mathcal{N} \\subseteq \\mathcal{NEXP}</span> , and let  <span class="math">\\mathcal{R}</span>  be a corresponding witness relation. Consider the following properties.</p>

    <p class="text-gray-300">Relatively-efficient oracle-construction: There exists a deterministic polynomial time machine P, such that, for every  <span class="math">(x, w) \\in \\mathcal{R}</span> ,  <span class="math">\\Pr\\left[\\pi_x = P(x, w) : V^{\\pi_x}(x) = 1\\right] = 1</span> . As a result, there exists a polynomial  <span class="math">p_p</span>  such that the proof  <span class="math">\\pi_x</span>  has length bounded by  <span class="math">p_p(|x|, |w|)</span> .</p>

    <p class="text-gray-300"><strong>Non-adaptive Verifier:</strong> The verifier algorithm V can be decomposed into a pair of algorithms Q and D, such that, on input x and a random tape r of length  <span class="math">p_r(|x|)</span> , the verifier runs Q(x,r) to generate  <span class="math">s = p_q(|x|)</span>  queries  <span class="math">q_1, \\ldots, q_s</span> , obtains answers  <span class="math">a_1, \\ldots, a_s</span>  to those queries from the oracle, and decides by computing and outputting  <span class="math">D(x, r, a_1, \\ldots, a_s)</span> .</p>

    <p class="text-gray-300">The above properties are known to hold for many PCP systems. Below, we consider only PCP system with the above properties, and denote it as (P, V = (Q, D)) with complexity  <span class="math">p_p, p_r, p_q</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Extractable Collision Resistence Hash Function</h2>

    <p class="text-gray-300">In this section, we formally define the notion of extractable collision resistant hash functions (CRHF) and construct such a hash function based on a new knowledge of exponent assumption called q-KEA introduced in Section 4.1.</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Extractable Collision Resistence Hash Function). Let  <span class="math">\\{I_k\\}_{k\\in\\mathbb{N}}</span>  be a sequences of sets of indexes. A tuple  <span class="math">\\mathcal{H} = (\\{H_{k,id}\\}_{k\\in\\mathbb{N},id\\in I_k}, \\{\\text{valid}_k\\}_{k\\in\\mathbb{N}})</span> , is an extractable collision resistence hash function if  <span class="math">\\{H_{k,id}\\}</span>  is a family of collision resistent hash functions,  <span class="math">\\{\\text{valid}_k\\}</span>  with  <span class="math">\\text{valid}_k</span> :  <span class="math">I_k \\times \\{0,1\\}^* \\to \\{0,1\\}</span>  is a sequence of functions that decides the validity of a hash value, and satisfies the following:</p>

    <p class="text-gray-300">Extractability: For every non-uniform deterministic polynomial time machine A, there exists a non-uniform deterministic polynomial time machine E and a negligible function  <span class="math">\\mu</span> , such that, for every  <span class="math">k \\in N</span>  and every auxiliary input  <span class="math">z \\in \\{0,1\\}^*</span> , the following holds.</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[id \\leftarrow I_k, \\ \\vec{v} = A(1^k, id, z); \\ \\vec{o} = E(1^k, id, z) \\ : \\\\ \\\\ \\exists j \\in [|\\vec{v}|], \\ \\mathsf{valid}_k(id, \\vec{v}_j) = 1 \\ \\textit{and} \\ H_{k,id}(\\vec{o}_j) \\neq v \\right] \\leq \\mu(k)</span>$</p>

    <p class="text-gray-300">In other words, an CRHF is extractable if for every machine A there exists an extractor E that can extract out a pre-image for every valid hash value that A outputs. Next we proceed to construct an extractable CRHF. Our construction relies on a new knowledge of exponent assumption introduced below.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 q-Knowledge of Exponent Assumption</h3>

    <p class="text-gray-300">The knowledge of exponent (KEA) assumption introduced by Damg&aring;rd [Dam91] says that given  <span class="math">g, g^{\\alpha}</span>  it is infeasible to create  <span class="math">c, \\hat{c}</span>  so that  <span class="math">\\hat{c} = c^{\\alpha}</span>  without knowing a so  <span class="math">c = g^{a}</span>  and  <span class="math">\\hat{c} = (g^{\\alpha})^{a}</span> . Bellare and Palacio [BP04] extended this to the KEA3 assumption, which says that given  <span class="math">g, g^{x}, g^{\\alpha x}, g^{x \\alpha}</span> , it is infeasible to create c and  <span class="math">\\hat{c}</span>  so that  <span class="math">\\hat{c} = c^{\\alpha}</span>  without knowing a, b such that  <span class="math">c = g^{a}(g^{x})^{b}</span>  and  <span class="math">\\hat{c} = (g^{\\alpha})^{a}, (g^{x \\alpha})^{b}</span> . This assumption has been used also in bilinear groups by Abe and Fehr [AF07] who called it the extended knowledge of exponent assumption.</p>

    <p class="text-gray-300">Our q-Knowledge of Exponent (q-KEA) Assumption generalizes the KEA and KEA3 assumptions in the following aspect: Instead of receiving only a pair of elements  <span class="math">g, g^x</span>  and their  <span class="math">\\alpha^{\\text{th}}</span>  powers, a challenger now is given q random elements  <span class="math">g, g^{x_1}, \\ldots g^{x_q}</span>  and their corresponding  <span class="math">\\alpha^{\\text{th}}</span>  powers. The assumption states that it is infeasible to create c and  <span class="math">\\hat{c}</span>  so that  <span class="math">\\hat{c} = c^{\\alpha}</span>  without knowing  <span class="math">a_0, a_1, \\ldots, a_1</span>  such that  <span class="math">c = g^{a_0} \\prod_{i=1}^q g^{x_i a_i}</span> . A similar assumption, called the q-power knowledge of exponent assumption for bilinear groups, was introduced by Groth [Gro10] for constructing a short (sublinear length) pairing-based Non-interactive Zero-Knowledge Arguments. Their assumption is almost the same except that the challenger receives q elements of a special form  <span class="math">g, g^{x_1}, \\ldots g^{x_q}</span>  and their  <span class="math">\\alpha^{\\text{th}}</span>  powers. We note that the two assumptions are incomparable.</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (q-Knowledge of Exponent Assumption). Let q be any polynomial. The q-KEA assumption holds for a family of groups  <span class="math">\\mathcal{G}</span>  if for every deterministic polynomial time machine A, there exists a deterministic polynomial time machine E and a negligible function  <span class="math">\\mu</span> , such that, for every  <span class="math">k \\in N</span>  and every auxiliary input  <span class="math">z \\in \\{0,1\\}^*</span> , the advantage of A in the following experiment  <span class="math">Exp_{A|E}^q(k,z)</span>  is bounded by  <span class="math">\\mu(k)</span> .</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">Experiment <span class="math">Exp_{A,E}^q(1^k,z)</span> :</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">(p,G) = \\mathcal{G}(1^k)</span> ,  <span class="math">g_0</span>  a random generator in G,  <span class="math">g_1 \\dots g_{q(k)}</span>  random elements in G, and  <span class="math">\\alpha</span>  a random element in  <span class="math">\\mathbb{Z}_p</span> ; let  <span class="math">\\delta = (g_0, \\dots, g_{q(k)}, g_0^{\\alpha}, g_1^{\\alpha}, \\dots, g_{q(k)}^{\\alpha})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A, on inputs  <span class="math">1^k</span> ,  <span class="math">\\delta</span>  and auxiliary input z, outputs  <span class="math">(s, (c_1, \\hat{c}_1), \\ldots, (c_s, \\hat{c}_s))</span>  E, on inputs  <span class="math">1^k</span> ,  <span class="math">\\delta</span>  and auxiliary input z, outputs s' and a sequence of exponents  <span class="math">(a_0^j, \\ldots a_{q(k)}^j)</span> for  <span class="math">j \\in [s&#x27;]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The experiement outputs 1 if and only if there exists a  <span class="math">j \\in [s]</span> , such that,  <span class="math">\\hat{c}_j = c_j^{\\alpha}</span>  but  <span class="math">c_j \\neq \\prod_{i=0}^{q(k)} g_i^{a_i^j}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The advantage of A in the above experiment equals to the probability that the experiment outputs 1.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Constructing Extractable CRHF</h3>

    <p class="text-gray-300">Our construction of extractable CRHF is essentially the same as the construction of commitments with knowledge by Groth [Gro10], which in turn is based on a variant of the Pedersen commitment scheme. Consider the following CRHF:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H} = \\left( \\left\\{ H_{k,id} \\right\\}_{k \\in N, id \\in I_k}, \\left\\{ \\mathsf{valid}_k \\right\\}_{k \\in N} \\right)</span>$
:</p>

    <p class="text-gray-300"><strong>Sampling:</strong> Let  <span class="math">(p,G) = \\mathcal{G}(1^n)</span>  and q = q(k). The  <span class="math">k^{\\text{th}}</span>  index set is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$I_k = \\left\\{ (g_0, \\dots, g_q, \\hat{g}_0, \\dots, \\hat{g}_n) : \\\\ g_0 \\in G - \\{0\\}, \\ g_1, \\dots, g_q \\in G, \\ \\exists \\alpha \\in Z_p \\text{ s.t. } \\forall i, \\ \\hat{g}_i = g_i^{\\alpha} \\right\\}</span>$</p>

    <p class="text-gray-300">In other words, to sample a random hash function  <span class="math">H_{k,id}</span> , simply sample  <span class="math">g_0, \\ldots, g_k</span>  at random from G as specified above, sample  <span class="math">\\alpha</span>  at random from  <span class="math">\\mathbb{Z}_p</span> , and output  <span class="math">id = (g_0, \\ldots, g_q, g_0^{\\alpha}, \\ldots, g_q^{\\alpha})</span> .</p>

    <p class="text-gray-300"><strong>Hashing:</strong> For every k and  <span class="math">id = (g_0, \\ldots, g_q, \\hat{g}_0, \\ldots, \\hat{g}_q) \\in I_k</span> , hash function  <span class="math">H_{k,id} : \\mathbb{Z}_p^{q+1} \\to G^2</span> , on input  <span class="math">(a_0, \\ldots, a_q) \\in \\mathbb{Z}_p^n</span> , outputs  <span class="math">c = \\prod_{i=0}^q g_i^{a_i}</span>  and  <span class="math">\\hat{c} = \\prod_{i=0}^q \\hat{g}_i^{a_i}</span> .</p>

    <p class="text-gray-300"><strong>Verifying:</strong> On input a hash value  <span class="math">(c, \\hat{c}) \\in G^2</span>  and an index  <span class="math">id = (g_0, \\dots, g_q, \\hat{g}_0, \\dots, \\hat{g}_q) \\in I_k</span> , the function  <span class="math">\\mathsf{valid}_k</span>  outputs 1 if there exists a  <span class="math">\\alpha \\in \\mathbb{Z}_p</span>  such that  <span class="math">\\hat{g}_i = g_i^{\\alpha}</span>  for all i and  <span class="math">\\hat{c} = c^{\\alpha}</span></p>

    <p class="text-gray-300">The hash function  <span class="math">H_{k,id}</span>  maps q+1 elements in  <span class="math">Z_p</span>  to two elements in G, achieving a &quot;compression rate&quot; of (q+1)/2. It follows from stardard technique that  <span class="math">\\mathcal{H}</span>  is collision resistent assuming that the DDH assumption holds on  <span class="math">\\mathcal{G}</span> ; here we omit the proof.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Assume that the DDH assumption holds on  <span class="math">\\mathcal{G}</span> . Then,  <span class="math">\\{H_{k,id}\\}_{k\\in N, id\\in I_n}</span>  is a family of collision resistent hash function.</p>

    <p class="text-gray-300">Furthermore, it follows directly from q-KEA that the hash function is also extractable. That is,</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Let q be any polynomial. Assume that the DDH assumption and q-KEA hold on  <span class="math">\\mathcal{G}</span> . Then,  <span class="math">\\mathcal{H}</span>  is a extractable CRHF with compression rate (q(k) + 1)/2.</p>

    <p class="text-gray-300">Proof. By construction, hash function  <span class="math">\\mathcal{H}_{k,id}</span>  has compression rate (q(k)+1)/2. Then, following Lemma 1, it only remains to show that  <span class="math">\\mathcal{H}</span>  is extractable. Fix any non-uniform deterministic polynomial-time machine A. It follows from q-KEA that there exists an extractor E (also non-uniform deterministic polynomial-time) such that, for every k, z, it holds that, except from negligible probability, whenever A on input a random  <span class="math">id = (g_0, \\ldots, g_q, g_0^{\\alpha}, \\ldots, g_q^{\\alpha}) \\in I_k</span> , outputs a valid hash value  <span class="math">(c_j, \\hat{c}_j = c_j^{\\alpha})</span> , E on the same input, outputs  <span class="math">(a_0^j \\ldots a_q^j)</span>  such that  <span class="math">c_j = \\prod_{i=0}^q g_i^{a_i^j}</span> . Since  <span class="math">(a_0^j \\ldots a_q^j)</span>  is a valid preimage for  <span class="math">(c_j, \\hat{c}_j)</span> , E is a valid extractor for A w.r.t.  <span class="math">\\mathcal{H}</span> .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Extractable Merkle Trees</h3>

    <p class="text-gray-300">Recall that Merkle tree is a full binary tree whose nodes are associated with value generated in a special way according to a CRHF such that the value of an internal node is the hash of the concatenation of the values of its children. We show that by instantiating the Merkle tree with an extractable CRHF, we obtain a Merkle tree that is also <em>extractable</em>, that is, given only the root value rv of a Merkle tree, one can extract out a Merkle tree that is consistent with rv.</p>

    <p class="text-gray-300">Recall that our extractable CRHF  <span class="math">\\mathcal{H}</span>  achieves a high &quot;compression rate&quot; (q(k)+1)/2. When using such a CRHF, we can afford to let each internal node have more than two children. More precisely, a n-ary (for now, consider n to be even) Merkle tree is a n-ary tree built in the same way as a classical Merkle tree, except that each internal node can have up to n children and its associated value is the hash of the concatenation of the values of its n children through a hash function with &quot;compression rate&quot; n. As classical (binary) Merkle trees, the root value of a k-ary Merkle tree is a good &quot;commitment&quot; of the original values associated with the leaves, and a</p>

    <p class="text-gray-300">particular value  <span class="math">v_i</span>  can be &quot;decommited&quot; by revealing d(n-1)+1 values:  <span class="math">v_i</span>  together with its authentication path  <span class="math">ap_i</span>  consisting of the values stored in the d(n-1) siblings of the nodes along the path from leaf i (inclusive) to the root (exclusive). To check the consistency of a pair of value  <span class="math">v_i</span>  and authentication path  <span class="math">ap_i</span>  with a root value  <span class="math">v_i</span> , the verify procedure proceeds as follows: On input  <span class="math">v_i</span>  and  <span class="math">ap_i = (Y_1, \\ldots, Y_d)</span>  where each  <span class="math">Y_j</span>  consists of n-1 values  <span class="math">Y_j^1, \\ldots, Y_j^{n-1}</span> , verify sets  <span class="math">X_1 = v_i</span>  and computes the values  <span class="math">X_j</span>  for j from 2 to d by setting  <span class="math">X_{j+1} = \\mathcal{H}(Y_j^1 \\| \\ldots \\| Y_j^{t-1} \\| X_j \\| Y_j^t \\| Y_j^{n-1})</span>  if  <span class="math">i_j</span>  (the j<sup>th</sup> bit of i in k-ary representation) is t; finally, verify checks whether  <span class="math">X_d = rv</span>  and outputs 1 if and only if this holds.</p>

    <p class="text-gray-300">We claim that Merkle trees constructed using an extractable collision resisent hash function  <span class="math">\\mathcal{H}</span>  is also &quot;extractable&quot;. This means, for every efficient challenger A, and every constant D, there exists an efficient extractor  <span class="math">E_D</span>  such that whenever A on input a random index id, outputs a valid root value rv,  <span class="math">E_D</span>  on receiving the same index id outputs a labeled tree  <span class="math">\\mathcal{T}</span>  of depth D that is consistent with rv. A tree  <span class="math">\\mathcal{T}</span>  is consistent with a root value rv, if the following procedure outputs 1.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{merkle}_k(id, D, rv, \\mathcal{T})</span>  check:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{T}</span>  has depth at most D.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The value associated with the root of  <span class="math">\\mathcal{T}</span>  equals to rv.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The value v associated with every internal node equals to the hash of the concatenation of the values associated with its children.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The value v associated with every leaf on depth d &lt; D is not a valid hash value, that is,  <span class="math">\\mathsf{valid}_k(1^k, id, v) = 0</span> . (A node is at depth d if its distance from the root is d.)</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Output 1 if all the above conditions hold, and 0 otherwise.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">\\mathcal{H} = \\left( \\{H_{k,id}\\}_{k \\in N, id \\in I_k}, \\{\\text{valid}_k\\}_{k \\in N} \\right)</span>  be an extractable CRHF with compression rate l. Then for every non-uniform deterministic polynomial time machine A and every constant D, there exists a non-uniform deterministic polynomial time machine  <span class="math">E_D</span>  and a negligible function  <span class="math">\\mu_D</span> , such that, for every  <span class="math">k \\in N</span>  and every auxiliary input  <span class="math">z \\in \\{0,1\\}^*</span> , the following holds.</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[id \\leftarrow I_k, \\ rv = A(1^k,id,z); \\ \\mathcal{T} = E(1^k,id,z) \\ : \\right.</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{valid}_k(id,rv) = 1 \\ and \\ \\mathsf{merkle}_k(id,D,\\mathcal{T},rv) \\neq 1 \\Big] \\ \\leq \\mu(k)</span>$</p>

    <p class="text-gray-300">Proof. This lemma follows essentially by applying the extractability property of the CRHF  <span class="math">\\mathcal{H}</span>  recursively. Since the lemma only cares about extracting constant depth Merkle trees, we only need to apply the extractability property for a constant number of times and thus the resulting extractor for the Merkle tree is efficient. More precisely, fix any non-uniform deterministic polynomial time machine A; we prove by induction that for every constant D there exists an extractor  <span class="math">E_D</span>  and a negligible function  <span class="math">\\mu_D</span>  satisfying the lemma. When D=1, it follows immediately from the extractability of the CRHF  <span class="math">\\mathcal{H}</span>  that such  <span class="math">E_1</span>  and  <span class="math">\\mu_1</span>  exist. Then assuming that  <span class="math">E_d</span>  and  <span class="math">\\mu_d</span>  exist for D=d a constant, we want to exhibit an extractor  <span class="math">E_{d+1}</span>  and a negligible function  <span class="math">\\mu_{d+1}</span>  for D=d+1. Fix any  <span class="math">k \\in N</span>  and an auxiliary input  <span class="math">z \\in \\{0,1\\}^*</span> . By our hypothesis, it holds that except from a  <span class="math">\\mu_d</span>  fraction of indexes  <span class="math">id \\in I_k</span> , it holds that whenever the output of rv of the challenger  <span class="math">A(1^k, id, z)</span>  is valid, the extractor  <span class="math">E_d(1^k, id, z)</span>  outputs a labeled tree  <span class="math">\\mathcal{T}_d</span>  of depth bounded by d that is consistent with rv, (i.e., merkle(id, d, rv,  <span class="math">\\mathcal{T}_d</span> ) = 1). Then consider a machine  <span class="math">E&#x27;_d</span>  which simply runs  <span class="math">E_d</span>  internally and outputs only the values associated with the leaves at depth d in  <span class="math">\\mathcal{T}_d</span>  (output by  <span class="math">E_d</span> ). By the extractability of  <span class="math">\\mathcal{H}</span> , there exists a deterministic polynomial time machine  <span class="math">X_d</span>  and</p>

    <p class="text-gray-300">a negligible function  <span class="math">\\mu</span>  such that, except from a  <span class="math">\\mu</span>  fraction of  <span class="math">id \\in I_k</span> , for every valid hash value v output by  <span class="math">E&#x27;_d(1^k, id, z)</span> ,  <span class="math">X_d(1^k, id, z)</span>  outputs a corresponding preimage  <span class="math">(v_1 \\dots v_{l(k)})</span> . Using  <span class="math">X_d</span>  we construct  <span class="math">E_{d+1}</span>  as follows. Machine  <span class="math">E_{d+1}(1^k, id, z)</span>  internally runs  <span class="math">E_d(1^k, id, z)</span>  and  <span class="math">X_d(1^k, id, z)</span> , obtaining outputs  <span class="math">\\mathcal{T}_d</span>  and w resepctively; it then constructs a depth d+1 tree  <span class="math">T_{d+1}</span>  by extending  <span class="math">\\mathcal{T}_d</span> : For every leaf node of  <span class="math">\\mathcal{T}_d</span>  at depth d, if w contains a valid preimage  <span class="math">(v_1 \\dots v_{l(k)})</span>  of the value associated with it, extend that leaf with l(k) children with values  <span class="math">v_1</span>  to  <span class="math">v_{l(k)}</span>  respectively. If  <span class="math">\\mathcal{T}_d</span>  is consistent with  <span class="math">v_1</span>  and  <span class="math">v_2</span>  extracts a pre-image for every valid hash value associated with nodes at depth  <span class="math">v_2</span>  of  <span class="math">v_3</span>  and  <span class="math">v_4</span>  extracts a pre-image for every valid hash value associated with nodes at depth  <span class="math">v_4</span>  of  <span class="math">v_4</span>  extracts a pre-image for every valid hash value associated with nodes at depth  <span class="math">v_4</span>  of  <span class="math">v_4</span>  extracts a pre-image for every valid hash value associated with nodes at depth  <span class="math">v_4</span>  of  <span class="math">v_4</span>  extracts a pre-image for every valid hash value associated with nodes at depth  <span class="math">v_4</span>  of  <span class="math">v_4</span>  extracts and and the extractability of  <span class="math">v_4</span> , we obtain  <span class="math">v_4</span>  fails with probability at most  <span class="math">v_4</span>  extracts and and the extractability of  <span class="math">v_4</span> , we obtain  <span class="math">v_4</span>  fails with probability at most  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and  <span class="math">v_4</span>  extracts and</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Designated Verifier CS Proofs</h2>

    <p class="text-gray-300">Our designated verifier CS proofs, like CS proofs, has efficient instance-based provability and verifiablity (resepctively, polynomial and polylogarithmically in the time of the computation to be proved). However, it is weaker in the following two aspects: First, proofs of our protocol are only verifiable by a designated verifier (whereas CS proofs are publicly verifiable), and second, our protocol only achieves a weaker (computational) soundness guarantee, that is, soundness only holds if the (computationally bounded) cheating prover tries to prove an invalid <em>polynomial-time</em> computation (whereas no invalid, even exponential-time, computation can be proved using CS proofs).</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Defining Designated Verifier CS Proofs</h3>

    <p class="text-gray-300">We first recall the definition of CS language introduced by Micali [Mic00]</p>

    <p class="text-gray-300"><strong>Definition 5</strong> (CS language [Mic00]). The CS language, denoted by  <span class="math">\\mathcal{L}</span> , is the set of all quadruples q = (M, x, y, t), such that M is (the description of) a Turing machine, x and y are a binary strings, and t a binary integer such that it holds that  <span class="math">|x| \\leq t</span> ,  <span class="math">|y| \\leq t</span> , M(x) = y and steps(M(x)) = t, where steps(M(x)) denote the number of steps that M takes on input x.</p>

    <p class="text-gray-300">The CS language essentially includes all quadruples that correspond to a valid <em>deterministic</em> computation. In fact, the CS proofs are capable of proving all valid <em>non-deterministic</em> computation as well. Formally, it corresponds to the following language.</p>

    <p class="text-gray-300"><strong>Definition 6</strong> (Non-deterministic CS language). The non-deterministic CS language, denoted by  <span class="math">\\mathcal{N}</span> , is the set of all quadruples q = (M, x, t), such that M is (the description of) a Turing machine, x is a binary string, and t a binary integer, it holds that there exists a witness w,  <span class="math">|x| \\leq t</span> ,  <span class="math">|w| \\leq t</span> , M(x, w) = 1 and steps(M(x, w)) = t. Denote by  <span class="math">\\mathcal{R}</span>  the witness relation of  <span class="math">\\mathcal{N}</span> , that is,</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R} = \\{ ((M, x, t), w) : |x| &lt; t, |w| &lt; t, M(x, w) = 1, \\text{ steps}(M(x, w)) = t \\}.</span>$</p>

    <p class="text-gray-300">We also denote by  <span class="math">\\mathcal{R}(X)</span>  the set of witnesses w such that  <span class="math">\\mathcal{R}(X, w) = 1</span> .</p>

    <p class="text-gray-300">In the designated verifier model, a non-interactive proof system has an associated polynomialtime sampleable distribution D over binary strings of the form (pp, sp). During a setup phase, a trusted party samples from D, publishes pp and privately hands the Verifier sp. The Prover and Verifier then use their respective values during the proof phase.</p>

    <p class="text-gray-300"><strong>Definition 7</strong> (Designated Verifier CS Proofs). A triple of algorithms, (D, P, V), is called a designated verifier CS proof system, if D is probablistic polynomial time, P and V are deterministic, the second of which runs in polynomial time, and the following properties hold:</p>

    <p class="text-gray-300"><strong>Feasible Completeness:</strong> There exists polynomials  <span class="math">t_P</span>  and  <span class="math">\\ell</span> , such that for every  <span class="math">X = (M, x, t) \\in \\mathcal{N}</span>  and every  <span class="math">w \\in \\mathcal{R}(x)</span> , every  <span class="math">k \\in N</span> , and every possible output (pp, sp) of  <span class="math">D(1^k, 1^{|X|})</span> ,  <span class="math">P(1^k, pp, X, w)</span>  halts within  <span class="math">t_p(k, |X|, t)</span>  computational steps, outputting a proof  <span class="math">\\pi</span>  of length smaller than  <span class="math">\\ell(k, |X|)</span> . Furthermore, it holds that,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(pp,sp) \\leftarrow D(1^k,1^{|X|}); \\ \\pi \\leftarrow P(1^k,pp,X,w) \\ : \\ V(1^k,pp,sp,X,\\pi) = 1\\right]</span>$</p>

    <p class="text-gray-300">Computational Soundness: For every deterministic polynomial time machine  <span class="math">P^*</span> , there exists a negligible function  <span class="math">\\mu</span> , such that for every  <span class="math">k \\in N</span>  and every n that is polynomially bounded by k, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(pp,sp) \\leftarrow D(1^k,1^n); \\ (X,\\pi) \\leftarrow P^*(1^k,pp) \\ : \\ X \\not\\in \\mathcal{N} \\ and \\ V(1^k,pp,sp,X,\\pi) = 1\\right] \\leq \\mu(k)</span>$</p>

    <p class="text-gray-300">The above defintion adapts the original notion of CS proofs [Mic00] into the designated verifier model. In this model, the property of public verifiability no longer holds; instead, only verifiers holding certain secret information sp can verify the validity of the proof. Next, we further relax the soundness property to only require it to hold when the cheating prover is trying to prove an invalid but polynomial-time computation.</p>

    <p class="text-gray-300"><strong>Definition 8</strong> (Weak Soundness). We say that a designated verifier CS proof system (D, P, V) has weak soundness if the computational soundess property is replaced by the following:</p>

    <p class="text-gray-300">Weak Computational Soundness: For every deterministic polynomial time machine  <span class="math">P^*</span> , and every constant  <span class="math">c \\in N</span> , there exists a negligible function  <span class="math">\\mu</span> , such that for every  <span class="math">k \\in N</span>  and every n that is polynomially bounded by k, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(pp,sp) \\leftarrow D(1^k,1^n); \\ (X,\\pi) \\leftarrow P^*(1^k,pp) \\ : \\\\ X = (M,x,t) \\ and \\ t \\leq k^c \\ and \\ X \\not\\in \\mathcal{N} \\ and \\ V(1^k,pp,sp,X,\\pi) = 1\\right] \\leq \\mu(k)</span>$</p>

    <p class="text-gray-300">Below, when referring to a designated verifier CS proof system, we mean such a proof system with weak soundness.</p>

    <p class="text-gray-300">Remark 1. We remark that in our definition of computational soundness, the cheating prover only sees the public string pp. This is different from the case in the definition of designated verifier non-interactive zero-knowledge proof system in the context of constructing CCA2 secure encryption schemes, where the soundness needs to hold even if the cheating prover has access to a verification oracle, which on input a statement and a proof tells the cheating prover whether this is an accepting proof or not. One consequence of this difference is that soundness of our proof system may not hold when a cheating prover participates in a game where it interacts with the honest verifier in many rounds proving many statements and may learn the decision of the verifier in each round. As we shall see later, this is relevant to the soundness of the delegation schemes that we construct from designated verifier CS proof systems.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Constructing Designated Verifier CS Proofs</h3>

    <p class="text-gray-300">Our designated verifier CS proof system (D, P, V) for the non-deterministic CS language  <span class="math">\\mathcal{N}</span>  rely on the following building blocks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An extractable collision resistent hash functions  <span class="math">\\mathcal{H} = (\\{H_{n,id}\\}_{n \\in N, id \\in I_n}, \\{\\mathsf{valid}_k\\}_{k \\in N})</span>  be with output length k and compression rate l(k) = k.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A fully homomorphic encryption scheme E = (KeyGen, Enc, Dec) with perfect completeness.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A PCP system  <span class="math">(P_{pcp}, V_{pcp} = (Q, D))</span>  with complexity  <span class="math">p_p, p_r, p_q</span>  for  <span class="math">\\mathcal{N}</span> , such that, the number of random coins tossed by the verifier on an input  <span class="math">X = (M, x, t) \\in \\mathcal{N}</span>  is  <span class="math">p_r(|X|) = \\text{poly}(\\log |X|, \\log t)</span> , and the number of queries generated is  <span class="math">p_q(|X|) = \\text{poly}(\\log |X|, \\log t)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let k be a security parameter. To prove a statement  <span class="math">X \\in \\mathcal{N}</span> , our scheme proceeds as follows:</p>

    <p class="text-gray-300"><strong>Set-up:</strong> D on input  <span class="math">1^k</span>  and  <span class="math">1^{|X|}</span> , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sample at random a hash function  <span class="math">H_{k,id}</span> , a  <span class="math">p_r(|X|)</span> -bit string r, and a pair of public and private keys of E,  <span class="math">(pk, sk) \\leftarrow \\text{KeyGen}(1^k, 1^L)</span> , where  <span class="math">L = \\log(\\text{poly}(p_p(|X|)))</span>  is a bound on the depth of the section circuit (introduced shortly below) on input vectors and trees of length  <span class="math">\\text{poly}(p_p(|X|))</span> .</li>
      <li>Compute the encryption of r under pk,  <span class="math">c = \\operatorname{Enc}_{pk}(r)</span> ;</li>
      <li>Output pp = (id, pk, c) and sp = (sk, r).</li>
    </ul>

    <p class="text-gray-300"><strong>Prover's Message:</strong> P on input  <span class="math">1^k</span> , X = (M, x, t), a witness w, and pp = (id, pk, c), do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Internally run  <span class="math">P_{pcp}</span>  on input X and w to generate a PCP-proof  <span class="math">\\pi</span> ; the length of the proof is  <span class="math">|\\pi| = p_p(|X|, |w|)</span>  bounded by  <span class="math">p_p(|X|, t)</span>  as  <span class="math">|w| \\le t</span> .</li>
      <li>Build a l(k) = k-ary Merkle tree  <span class="math">\\mathcal{T}</span>  by setting the value associated with the  <span class="math">i^{\\text{th}}</span>  leaf node to be equal to  <span class="math">\\pi_i^4</span> , and computing the values of the internal nodes using the hash function  <span class="math">H_{k,id}</span> ; let rv be the root value generated and d be the depth of the Merkle tree;</li>
      <li>Evaluate homomorphically the circuit Q over X and c to compute the PCP queries, yielding  <span class="math">c&#x27; = \\text{Eval}_{pk}(Q; (X, c))</span> ;</li>
      <li>Select homomorphically the answers and their corresponding authentication paths according to c', yielding  <span class="math">c&#x27;&#x27; = \\operatorname{Eval}_{pk}(S; (\\pi, \\mathcal{T}, c&#x27;))</span> , where S is a selection circuit which on input a string str, a tree T, and a vector of indexes  <span class="math">\\vec{q}</span> , returns for every  <span class="math">i \\in [|\\vec{q}|]</span> ,  <span class="math">str_{q[i]}</span>  and the path leading from the root to the  <span class="math">q[i]^{\\text{th}}</span>  leaf in T;</li>
      <li>Outputs  <span class="math">\\pi = (rv, d, c&#x27;&#x27;)</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Verifier's Decision:</strong> V on input  <span class="math">1^k</span> , X=(M,x,t), pp=(id,pk,c), sp=(sk,r) and  <span class="math">\\pi=(rv,d,c&#x27;&#x27;)</span> , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verify that the depth of the Merkle tree is correctly bounded, that is,  <span class="math">d \\leq \\log_k(p_p(|X|, t))</span> .</li>
      <li>Let  <span class="math">s = p_q(|X|)</span> ; Decrypt c'' using the secret key sk, yielding  <span class="math">(a_1, \\ldots, a_s, ap_1, \\ldots, ap_s) = \\operatorname{Dec}_{sk}(c&#x27;&#x27;)</span> .</li>
      <li>Check for every  <span class="math">i \\in [s]</span> , whether  <span class="math">a_i</span> ,  <span class="math">ap_i</span>  are consistent with rv; if for any  <span class="math">i \\in [s]</span> , verify <span class="math">(id, a_i, ap_i) \\neq 1</span> , reject and abort;</li>
      <li>Run D on input X, r,  <span class="math">a_1, \\ldots, a_s</span> ; accept if and only if D outputs 1.</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>We assume w.l.o.g. that the length of the PCP proof  <span class="math">\\pi</span>  is a power of k. Otherwise, we can always make it to be the case by padding  <span class="math">\\pi</span>  with 0's.</p>

    <p class="text-gray-300">We analyze the efficinecy of the above scheme as follows: By construction and the relatively efficient oracle construction property of the PCP system, the prover P runs in time poly(k, |X| , t). It is easy to check that the set-up algorithm runs in time poly(k, |X|) and the verifier runs in poly(k, |X| , log t). Finally, we bound the length of the public information pp and the proof generated by the prover. Since the PCP verifier tosses pr(|X|) = poly(log |X| , log t)) number of coins, the length of the public information pp is bounded by poly(k, log |X| , log t). Then, since the PCP proof has length poly(k, |X| , t), the Merkle tree generated by the prover has depth d = O(log<sup>k</sup> (k, |X| , t)), and thus the length of the answers to the s PCP queries where s = pq(|X|) = poly(log |X| , log t) is s(d(k &minus; 1) + 1)k = poly(k, log |X| , log t). Therefore, the size of the proof is indeed poly(k, |X|) as required in Definition 7.</p>

    <p class="text-gray-300">Remark 2. As we shall see later, when constructing delegation schemes using the above designated verifier CS proof system. We utilize the fact that the lengths of the public information pp and the CS proof generated are both in fact poly(k, log |X| , log t), depending polylogarithmically in the length of the input. Correspondingly, this will yield a delegation scheme with communication complexity bounded poly-logarithmically in the complexity of the computation being delegated and length of the input x <sup>0</sup> of the computation, provided that the delegator and the worker receives the input x 0 from outside. From another perspective, this separates the communication complexity needed for transferring the input (from the delegator to the worker), from that needed for verifying the correctness of the output, which is only polylogarithmic in the input length.</p>

      <h4 id="sec-5.2.1" class="text-lg font-semibold mt-6">5.2.1 (D, P, V ) works</h4>

    <p class="text-gray-300">Theorem 1. (D, P, V ) is a designated verifier CS proof system.</p>

    <p class="text-gray-300">Proof. The completeness of the system follows from the perfect completeness of the fully homomorphic encryption scheme and the completeness of the PCP system. The computation and communication complexity of the system satisfies the definition of designated verifier CS proofs as analyzed above. Thus it only remains to show that (D, P, V ) satisfies weak soundness.</p>

    <p class="text-gray-300">We need to show that no prover can prove a false statement that has a polynomial time bound. That is, for every constant C and every cheating prover P &lowast; , there exists a negligible function &micro;, such that the following holds for every k &isin; N and n &isin; {0, 1} &lowast; .</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(pp,sp) \\leftarrow D(1^k,1^n); \\ (X,\\pi) \\leftarrow P^*(1^k,pp) \\ : \\\\ X = (M,x,t) \\text{ and } t \\leq k^c \\text{ and } X \\not\\in \\mathcal{N} \\text{ and } V(1^k,pp,sp,X,\\pi) = 1\\right] \\leq \\operatorname{neg}(k) \\quad (1)</span>$</p>

    <p class="text-gray-300">Recall that a proof &pi; of (D, P, V ) consists of three components (rv, d, c00), where rv is the root value of a Merkle tree and d is the depth of the tree. Towards proving the weak soundness, we show that no prover can &quot;cheat&quot; by giving a proof with a constant depth d. That is, for every constant D and every cheating prover P &lowast; , there exists a negligible function &micro;, such that the following holds</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[(pp, sp) \\leftarrow D(1^k, 1^n); \\ (X, \\pi) \\leftarrow P^*(1^k, pp) : \\right.</span>$</p>

    <p class="text-gray-300"><span class="math">$\\pi = (rv, d, c&#x27;&#x27;) \\text{ and } d \\leq D \\text{ and } X \\notin \\mathcal{N} \\text{ and } V(1^k, pp, sp, X, \\pi) = 1 \\right] \\leq \\mu(k) \\quad (2)</span>$</p>

    <p class="text-gray-300">We claim that if the above holds, then so does weak soundness. Assume for contradiction that the above holds but there exits a cheating prover P <sup>&lowast;</sup> and a constant C such that (1) is false. Recall that on input a statement X = (M, x, t) and &pi; = (rv, d, c00), the verifier checks whether the depth d is correctly bounded by log<sup>k</sup> (pp(|X| , t)). When t &le; k <sup>C</sup>, d is bounded by a constant, since both t and |X| are polynomially bounded by k. Thus there must exist a particular constant D, such that the probability that  <span class="math">P^*</span>  cheats successfully while giving a proof with depth exactly D is polynomial, which violates (2). Therefore, it suffice to show that no prover can prove a false statement by giving a proof with a constant depth.</p>

    <p class="text-gray-300">Assume for contradiction that there exists a deterministic polynomial-time cheating prover  <span class="math">P^*</span>  a constant D and a polynomial function p such that there exists an infinite sequence of  <span class="math">k \\in N</span>  and  <span class="math">n \\in \\{0,1\\}^*</span> , such that,  <span class="math">P^*</span>  succeeds in convincing the honest verifier V of some false statement  <span class="math">X = (M, x, t) \\notin \\mathcal{N}</span>  by outputting a proof with  <span class="math">d \\leq D</span> , with probability at least 1/p(k). Then we construct another deterministic polynomial time machine B that distinguishes encryption to a random value r and encryption to 0 with non-negligible probability. This violates the semantic security of the fully homomorphic encryption scheme and then the theorem follows.</p>

    <p class="text-gray-300">Fix any k, n for which  <span class="math">P^*</span>  succeeds in cheating with probability 1/p(k).  <span class="math">P^*</span> , on input  <span class="math">1^k</span>  and pp = (id, pk, c), outputs a statement X = (M, x, t) together with a proof  <span class="math">\\pi = (rv, d, c&#x27;&#x27;)</span> . Consider a wrapper machine A that on input  <span class="math">(1^k, id, z)</span> , runs  <span class="math">P^*(1^k, (id, z))</span>  internally, and outputs only the first part rv of  <span class="math">P^*</span> 's output. Since the CRHF  <span class="math">\\mathcal{H}</span>  is extractable, it follows from Lemma 2 that there exists a deterministic polynomial time machine  <span class="math">E_D</span> , such that, there exists a negligible function  <span class="math">\\mu</span>  such that for every  <span class="math">z \\in \\{0,1\\}^*</span> , except from a  <span class="math">\\mu(k)</span>  fraction of  <span class="math">id \\in I_k</span> , when  <span class="math">A(1^k, id, z)</span>  outputs a valid hash value rv,  <span class="math">E_D(1^k, id, z)</span>  outputs a tree  <span class="math">\\mathcal{T}</span>  that is consistent with rv, that is,  <span class="math">merkle_k(id, D, \\mathcal{T}, rv) = 1</span> . Given  <span class="math">E_D</span> , we are now ready to construct machine B.</p>

    <p class="text-gray-300"><strong>Machine</strong> B on input  <span class="math">1^k</span>  and pp = (id, pk, c), internally runs both  <span class="math">P^*(1^k, pp)</span>  and  <span class="math">E_D(1^k, id, z = (pk, c))</span>  and outputs both the outputs of  <span class="math">P^*</span>  and  <span class="math">E_D</span> , that is,  <span class="math">(X, \\pi = (rv, d, c&#x27;&#x27;))</span>  and  <span class="math">\\mathcal{T}</span> .</p>

    <p class="text-gray-300">Let r be the value encrypted in c under pk, and  <span class="math">(q_1, \\ldots, q_s) = Q(X, r)</span>  the PCP queries computed from X and r. We show that the probability that  <span class="math">\\mathcal{T}</span>  contains a valid answer for PCP queries  <span class="math">(q_1, \\ldots, q_s)</span>  with respect to X is at least 1/2p(k). In other words, machine B is able to prove a false statement &quot;in plaintext&quot; with probability at least 1/2p(k). This is proved through the following two Claims, which respectively says that except from negligible probabilities, i) whenever the root value rv output by B is a valid hash value, the tree  <span class="math">\\mathcal{T}</span>  is consistent (w.r.t. merkle) with rv (in Claim 1), and ii) whenever the proof  <span class="math">\\pi</span>  output by B contains in the encryption c'' an authentication path (a, ap) consistent (w.r.t. verify) with rv, and  <span class="math">\\mathcal{T}</span>  is consistent with rv, then  <span class="math">\\mathcal{T}</span>  contains (a, ap) (in Claim 2).</p>

    <p class="text-gray-300"><strong>Claim 1.</strong> There exists a negligible function  <span class="math">\\mu_1</span> , such that for all  <span class="math">k \\in \\mathbb{N}</span>  and  <span class="math">n \\in \\{0,1\\}^*</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr\\left[(pp,sp) \\leftarrow D(1^k,1^n), \\ (X,\\pi,\\mathcal{T}) &amp;= B(1^k,pp) \\ : \\\\ pp &amp;= (id,pk,c), \\ \\pi = (rv,d,c&#x27;&#x27;), \\ \\mathsf{valid}_k(id,rv) = 1, \\ \\mathsf{merkle}_k(id,D,rv,\\mathcal{T}) \\neq 1 \\right] \\leq \\mu_1(k) \\end{split}</span>$</p>

    <p class="text-gray-300">Claim 2. There exists a negligible function  <span class="math">\\mu_1</span> , such that for all  <span class="math">k \\in \\mathbb{N}</span>  and  <span class="math">n \\in \\{0,1\\}^*</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr\\left[(pp = (id, pk, c), sp = (sk, r)) \\leftarrow D(1^k, 1^n), \\ (X, \\pi = (rv, d, c&#x27;&#x27;), \\mathcal{T}) = B(1^k, pp) \\ : \\\\ (\\vec{a}, \\vec{ap}) &amp;= \\mathrm{Dec}_{sk}(c&#x27;&#x27;), \\ \\mathsf{merkle}_k(id, D, rv, \\mathcal{T}) = 1, \\\\ \\exists j \\in [|\\vec{a}|] \\ \\mathsf{verify}_k(id, a_j, ap_j) = 1 \\ \\mathit{but} \\ \\mathcal{T} \\ \\mathit{does} \\ \\mathit{not} \\ \\mathit{contain} \\ a_j, ap_j \\right] \\leq \\mu_2(k) \\end{split}</span>$</p>

    <p class="text-gray-300">Claim 1 follows from the fact that by construction, the tree  <span class="math">\\mathcal{T}</span>  output by B is from  <span class="math">E_D</span> , which is a good extractor for wrapper A that outputs the root value from  <span class="math">P^*</span> . Thus it follows directly from the extractability of the Merkle tree that except from negligible probability whenever rv is valid,  <span class="math">\\mathcal{T}</span>  is consistent. Claim 2 essentially follows from the collision resistence property of the hash</p>

    <p class="text-gray-300">function H. Assume for contradiction that with some polynomial probability, the proof &pi; output by B contains in the encryption c <sup>00</sup> an authentication path (a, ap) consistent with rv that does not appear in the tree T . Let q be the leaf node corresponding to (a, ap). Then consider the path (a 0 , ap<sup>0</sup> ) from root to leaf q in T . As long as T is consistent with rv, we must find a collision of the hash function Hk,id on (a, ap) and (a 0 , ap<sup>0</sup> ). This violates the collision resistence property of H. Thus Claim 2 holds.</p>

    <p class="text-gray-300">Combining Claim 1 and 2, we have that except from probability &micro;1(k) + &micro;2(k), the output (X, &pi; = (rv, d, c00), T ) of B(1<sup>k</sup> , pp = (id, pk, c)) satisfies that when &pi; is a convincing proof for X, the following two conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>rv is valid and thus T is consistent with rv (by Claim 1).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>c <sup>00</sup> is an encryption to authentication paths (a<sup>j</sup> , ap<sup>j</sup> ) for j &isin; [s] satisfying that each a<sup>j</sup> , ap<sup>j</sup> is consistent and (a1, . . . , as) convinces a PCP verifier with random tape r (where r is the encrypted value in c). Thus T contains all (a<sup>j</sup> , ap<sup>j</sup> ) (by Claim 2 and the first condition).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Therefore T contains &quot;in plaintext&quot; the answers that convinces a PCP verifer with random tape r. Then by our hypothesis, B on input 1<sup>k</sup> , id, pk and an encryption to r under pk, is able to convince a PCP verifer with random tape r with probability at least 1/2p(k). However, when B receives instead (1<sup>k</sup> , id, pk and) an encryption to 0 under pk, by the soundness of the PCP system, except from negligible probability, it cannot output answers that convinces a PCP verifier (since the verifier now has completely private random tape). Thus B distinguishes encryption to a random string r and encryption to 0 with probability at least 1/3p(k). This violates the semantic security of the fully homomorphic encryption scheme, and gives a contradiction.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Delegation without Rejection Problem</h2>

    <p class="text-gray-300">Loosely speaking, a delegation scheme is a 2-stage protocol between a delegator D and a worker W. In an off-line stage, the delegator does some pre-processing based on the function F it wants to compute and generates some public and secret information pp and sp. Later in an on-line stage, the delegator can delegate the computation of F on many inputs to the worker efficiently; the worker evaluates the function and proves to the delegator that the output it returns is correct. The key property of a delegation scheme is that the computation and communication complexity of the delegator in the on-line stage is polylogarithmic in the computation complexity of the function. In other words, the delegator can verify the computation done by the untrusted worker much (polylogarithmically) more efficiently than evaluating the function on its own. Recently, Genenaro, Gentry and Parno [GGP10] and Chung, Kalai and Vadhan [CKV10] presented two constructions of delegation schemes, both relying on fully homomorphic encryption schemes. Their schemes, however, share one restriction, known as the rejection problem, that is, a cheating worker can break the soundness of the scheme if it learns the verdict of the delegator on whether it accepts or rejects a proof from the worker. Their solution is either to assume that the worker does not learn the verdict or to perform the off-line stage fresh again after every time the delegator rejects a proof. In Section 6.2.2, we construct a two-message delegation scheme that does not suffer the rejection problem. Furthermore, the soundness of previous schemes relies on the use of fully homomorphic encryption schemes, which makes the computational complexity of their scheme depends on the worst case complexity of the function being computed. In Section 6.2.1, we construct a designated verifier delegation scheme, whose soundness relies on the use of designated verifier CS proof and as a result has instance-based complexity for the worker and the delegator in the on-line stage. That is, the complexity of the delegator and the worker in the on-line stage depends on the complexity of the compuation on the particular input being delegated.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Delegation Schemes</h3>

    <p class="text-gray-300">In this section, we formally describe the model of delegation that we consider. Our model is essentially the same as that in [GGP10, CKV10], except from the following three aspects. First, we require that the computational complexity of the worker and the delegator in the on-line stage, computing a function F (represented as a Turing machine M) on input x, to depend solely on the running time t of M on this particular input x, instead of the worst case running time of M; we call this property instance-based complexity. Second, we require soundness of the delegation scheme to hold even if a cheating worker learns the verdicts of the delegator in the on-line stage; we call this property robust soundness. Third, our scheme only handles delegation of polynomial-time computation. The latter seems counter-intuitive: the computational complexity of the delegator (in the on-line stage) is at least polynomial in the length |x| of the input (the delegator needs to at least read the input); if delegation can only handle computation in time polynomial in |x|, then what does the delegator gain by engaging in delegation at all? We note that the delegator still gains since the computational complexity of delegation is of a fixed polynomial in |x| (and logarithm of the time of the computation), while the complexity of the delegated computation can be of an arbitrary polynomial. Furthermore, we remark that this restriction is actually inherent for all delegation schemes whose soundness is based on some polynomial time hardness assumptions. The reason is that since soundness only holds against computationally bounded workers (otherwise a cheating worker can break the polynomial time hardness assumption that soundness is based on), then the worker, being computationally bounded, can only compute polynomial time computable functions for the delegator. (We note that this restriction also applies to previous constructions [GGP10, CKV10], although it is not stated explicitly.)</p>

    <p class="text-gray-300"><strong>Definition 9</strong> (Delegation with Robust Soundness). A delegation scheme is an interactive protocol  <span class="math">Del = (D = (A_1, A_2), W)</span>  consisting of the following two stages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Off-Line Stage:</strong> The delegator  <span class="math">A_1</span>  on input a security parameter k and a polynomial-time computable function  <span class="math">F: \\{0,1\\}^n \\to \\{0,1\\}^m</span> , represented as a Turing machine M and a polynomial time bound  <span class="math">T = k^c</span>  for M, outputs a public string pp and a private string sp, that is,  <span class="math">(pp, sp) = A_1(1^k, F)</span> . We will use the notation M, n, m, and T as the Turing machine and parameters associated with F below.</li>
      <li><strong>On-Line Stage:</strong> The delegator  <span class="math">A_2</span>  and the worker W on input  <span class="math">1^k</span> , F and an input  <span class="math">x \\in \\{0,1\\}^n</span> , interacts in an interactive protocol. At the end of the protocol, the delegator  <span class="math">A_2</span>  decides to accept or reject; if it accepts, then it additionally outputs a value y.</li>
    </ul>

    <p class="text-gray-300">Furthermore, Del satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><strong>Efficiency:</strong> The computational complexity of worker W and the delegator  <span class="math">A_2</span>  in the on-line stage is bounded by poly(k,T) and  <span class="math">poly(k,n,m,\\log T)</span>  respectively. The total communication complexity of the on-line and off-line stage is bounded by  <span class="math">poly(k,\\log n,m,\\log T)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Furthermore if the computational complexity of W and  <span class="math">A_2</span>  depends on the running time t of M on input x (i.e., resepctively poly(k,t) and  <span class="math">poly(k,n,m,\\log t)</span> ), instead of the worst case running time T of M, we say that the delegation scheme has instance-basec complexity.</li>
    </ul></li>
      <li><p class="text-gray-300"><strong>Completeness:</strong> For all k, n, m, T, F and x, after running the delegation scheme (D, W) on these inputs as specified above,  <span class="math">A_2</span>  accepts with probability 1.</p></li>
      <li><p class="text-gray-300"><strong>Robust Soundness:</strong> For every cheating  <span class="math">\\mathcal{PPT}</span>  worker  <span class="math">W^*</span> , every constant C, there exists a negligible function  <span class="math">\\mu</span> , such that for every  <span class="math">k \\in N</span> , every F = (M, n, m, T) with  <span class="math">T \\leq k^C</span> , the probability that  <span class="math">W^*</span>  wins in the following security game  <span class="math">Sec(W^*, 1^k, F)</span>  is bounded by  <span class="math">\\mu(k)</span> .</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The delegator  <span class="math">A_1</span>  executes the off-line stage by generating  <span class="math">(pp, sp) \\leftarrow A_1(1^k, F)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The cheating worker  <span class="math">W^*</span>  interacts with  <span class="math">A_2</span>  in an arbitrary number of iterations of its choice. In the  <span class="math">i^{th}</span>  iteration,  <span class="math">W^*</span>  selects an input  <span class="math">x_i \\in \\{0,1\\}^n</span>  and interacts with  <span class="math">A_2</span>  on input  <span class="math">(1^k, F, x_i, pp, sp)</span> ; after  <span class="math">A_2</span>  outputs a verdict  <span class="math">b_i</span> ,  <span class="math">W^*</span>  learns  <span class="math">b_i</span> . If  <span class="math">A_2</span>  accepts in round i, that is  <span class="math">b_i = 1</span> , let  <span class="math">y_i</span>  be value  <span class="math">A_2</span>  outputs at the end of the protocol.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">W^*</span>  wins in the game, if there exists an i in which  <span class="math">A_2</span>  accepts (i.e.,  <span class="math">b_i = 1</span> ) but  <span class="math">y_i \\neq F(x_i)</span> .</p>

    <p class="text-gray-300">In the above defined soundness game Sec, the cheating worker learns the verdict of the delegator immediately after each execution of the on-line stage. In contrast, previous works [GGP10, CKV10] consider a soundness game that terminates once the delegator rejects a proof from the cheating worker; we call delegation scheme with such soundness guarantee a delegation scheme without verification oracle.</p>

    <p class="text-gray-300">In this work, we will also consider the following additional properties. We say that a delegation scheme is a one-message delegation scheme, if the on-line stage contains only a single message from the worker to the delegator (that is,  <span class="math">A_2</span>  does not send any message). We say that a delegation scheme is on-line if the off-line stage is empty. Furthermore, we say that a delegation scheme has an efficient off-line stage if the computational complexity of the delegator  <span class="math">A_1</span>  in the off-line stage is poly <span class="math">(k, n, m, |M|, \\log T)</span> .</p>

    <p class="text-gray-300">Remark 3. In the above definition, the verifier runs in time polynomial in the length n of the input x (beyond running in time polylogarithmic in the running time of the computation T). This seems necessarily, since the verifier needs to at least read the entire input x. However, if one is willing to assumes that the input x is given in an error correcting code (as is done in [BFLS91] and some follow-up works), it would be possible to achieve verifier's computational complexity that is poly-logarithmic in the length of x. Such a delegation scheme can be constructed using essentially the same method below from a designated verifier CS proof that has verifier's complexity of polylogarithmic in the length of the input, which in turn can be constructed almost identically as in Section 5 but relying on a PCP of proximity system for the non-deterministic CS language N as in [CKLR11].</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Our Constructions</h3>

    <p class="text-gray-300">We present two delegation schemes. The first scheme  <span class="math">\\mathsf{Del}_1 = (W_1, D_1)</span> , as previous constructions, only satisfies soundness without verification oracle; but it improves previous works on that it has an efficient off-line stage, a one-message on-line stage, and instance-based complexity. The second scheme  <span class="math">\\mathsf{Del}_2 = (W_2, D_2)</span>  satisfies soundness with verification oracle and is further completely online.</p>

      <h4 id="sec-6.2.1" class="text-lg font-semibold mt-6">6.2.1 Designated Verifier CS Proofs for CS Language <span class="math">\\mathcal{L}</span></h4>

    <p class="text-gray-300">Our delegation schemes will rely on a designated verifier CS proof system for the (deterministic) CS language  <span class="math">\\mathcal{L}</span> , which includes all quadruples X = (M, x, y, t) such that M(x) = y in t steps. (See Definition 5 for a formal definition.) In section 5.2, we constructed a designated verifier CS proof system  <span class="math">(D_N, P_N, V_N)</span>  for the non-deterministic CS language  <span class="math">\\mathcal{N}</span> . We show how to transform that scheme to a designated verifier CS proof system  <span class="math">(D_L, P_L, V_L)</span>  for  <span class="math">\\mathcal{L}</span> .</p>

    <p class="text-gray-300">Towards this, we first show that every statement  <span class="math">X = (M, x, y, t) \\in \\mathcal{L}</span>  can be converted efficiently into a statement  <span class="math">X&#x27; \\in \\mathcal{N}</span>  together with a corresponding witness w. The conversion algorithm convert(X) proceeds as follows:</p>

    <p class="text-gray-300">convert(X = (M, x, y, t)): Run M on input x, producing the output y and a t-step history  <span class="math">\\sigma</span>  of a computation of M outputting y on input x. Consider the following relation R.</p>

    <p class="text-gray-300"><span class="math">R(X,\\sigma)=1</span>  if and only if  <span class="math">\\sigma</span>  is the t-step history of a computation of M outputting y on input x.</p>

    <p class="text-gray-300">Evaluates  <span class="math">R((M, x, y, t), \\sigma)</span>  and records the number of steps t' taken by R. Then set the statement  <span class="math">X&#x27; \\in \\mathcal{N}</span>  to (R, (M, x, y, t), t') and the witness  <span class="math">w = \\sigma</span> .</p>

    <p class="text-gray-300">Notice that R is polynomial time computable. Thus  <span class="math">t&#x27; = \\text{poly}(|X|, |\\sigma|) = \\text{poly}(|X|, t)</span>  bounded by  <span class="math">t^{\\beta}</span>  for some constant  <span class="math">\\beta</span> . Therefore, the length of the new statement |X'| is bounded by  <span class="math">|X|^{\\gamma}</span>  for some constant  <span class="math">\\gamma</span> , and the computational complexity of convert is poly(|X|, t). Then the designated verifier CS proof system  <span class="math">(D_L, P_L, V_L)</span>  for  <span class="math">\\mathcal{L}</span>  proceeds as follows:</p>

    <p class="text-gray-300"><strong>Set-up:</strong>  <span class="math">D_L</span> , on input  <span class="math">1^k</span>  and  <span class="math">1^{|X|}</span> , sets  <span class="math">n = |X|^{\\gamma}</span>  and runs  <span class="math">D_N(1^k, 1^n)</span>  producing (pp, sp).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Prover's Message:</strong>  <span class="math">P_L</span>  on input  <span class="math">1^k</span> , X = (M, x, y, t), and pp, converts X into a statement  <span class="math">X&#x27; \\in \\mathcal{N}</span>  and its witness w using the conversion algorithm convert, runs the honest prover strategy  <span class="math">P_N(1^k, pp, X&#x27;, w)</span>  to generate a proof  <span class="math">\\pi&#x27;</span>  and outputs  <span class="math">\\pi = (X&#x27;, \\pi)</span> .</li>
      <li>Verifier's Decision:  <span class="math">V_L</span>  on input  <span class="math">1^k</span> , X = (M, x, y, t), pp, sp and  <span class="math">\\pi = (X&#x27;, \\pi&#x27;)</span> , first checks whether X' is well formed and consists of R, (M, x, y, t) and t'; furthermore, it checks whether  <span class="math">t&#x27; \\leq t^{\\beta}</span> . It aborts if any of the conditions does not hold. Otherwise, it runs the honest verifies strategy  <span class="math">V_N(1^k, pp, sp, X&#x27;, \\pi&#x27;)</span>  and accepts if and only if  <span class="math">V_N</span>  accepts.</li>
    </ul>

    <p class="text-gray-300"><span class="math">(D_L, P_L, V_L)</span>  is a designated verifier CS proof system for  <span class="math">\\mathcal{L}</span> . It is easy to see that the computational complexity of the prover is  <span class="math">\\operatorname{poly}(k, |X|, t)</span>  and the length of the proof is  <span class="math">\\operatorname{poly}(k, |X|)</span> . Completeness follows from the completeness of  <span class="math">(D_N, P_N, V_N)</span> . Furthermore, weak soundness follows from the weak soundness of  <span class="math">(D_N, P_N, V_N)</span>  and the fact that  <span class="math">V_L</span>  checks that the time t' sent by  <span class="math">P_L</span>  is correctly bounded by  <span class="math">t^{\\beta}</span> ; this is because if a cheating prover  <span class="math">P_L^*</span>  is able to prove a false statement X with  <span class="math">t \\leq k^C</span>  for some C, it must prove a false statement  <span class="math">X&#x27; \\in \\mathcal{L}</span>  with some  <span class="math">t&#x27; \\leq t^{\\beta} \\leq k^{C\\beta}</span>  using  <span class="math">(D_N, P_N, V_N)</span> . This violates the weak soundness of  <span class="math">(D_N, P_N, V_N)</span> .</p>

      <h4 id="sec-6.2.2" class="text-lg font-semibold mt-6">6.2.2 One-Message Delegation with Instance-based Complexity</h4>

    <p class="text-gray-300">Let (D, P, V) be a designated verifier CS proof system for the non-deterministic CS language  <span class="math">\\mathcal{L}</span> . The delegation scheme  <span class="math">(D_1, W_1)</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Off-Line Stage:</strong> The delegator  <span class="math">D_1</span> , on input  <span class="math">1^k</span>  and a function F = (M, n, m, T), runs the set-up algorithm D on input  <span class="math">(1^k, 1^l)</span>  with l = |M| + n + m + |T|, producing (pp, sp).</li>
      <li><strong>On-Line Stage:</strong> The worker  <span class="math">W_1</span>  on input  <span class="math">1^k</span> , F, pp and an input  <span class="math">x \\in \\{0,1\\}^n</span> , first evaluates M on input x to obtain the output y = M(x) and measure the time t taken by the computation. It then runs the honest prover strategy  <span class="math">P(1^k, pp, X = (M, x, y, t))</span>  to generate a proof  <span class="math">\\pi</span> . Finally,  <span class="math">W_1</span>  outputs  <span class="math">y, (t, \\pi)</span> .</li>
    </ul>

    <p class="text-gray-300">The delegator  <span class="math">D_1</span>  after receiving y and  <span class="math">(t, \\pi)</span> , checks whether  <span class="math">t \\leq T</span> . It aborts if t &gt; T; otherwise, it runs the honest verifier strategy  <span class="math">V(1^k, pp, sp, X, \\pi)</span>  to verify the proof, and accepts if and only if V accepts.</p>

    <p class="text-gray-300">The completeness of  <span class="math">Del_1</span>  follows directly from that of the designated verifier CS proof. Furthermore, since the designated verifier CS proof system has instance based complexity. That is, the computational complexity of the prover and verifier on input X = (M, x, y, t) are respectively</p>

    <p class="text-gray-300">poly(k, t) and poly(k, |X| , t) = poly(k, |x| , |y| , log t), and the total length of the public information and the CS proof is poly(k, log |X| , log t) = poly(k, log |x| , log |y| , log t) (See Remark 2), all independent the worst case running time of M. The delegation scheme Del<sup>1</sup> derived from it also has instance based complexity. More precisely, in the on-line stage, the deletagor and the worker on input F and x runs in time poly(k, n, m, log t) and poly(k, t), where t is the running time of M on input x; in the off-line stage, the delegator runs in time poly(k, n, m, log T), where T is the worst case running time of M<sup>5</sup> . Furthermore, the total communication complexity including the public key and the on-line proof is poly(k, log n, m, log T). The soundness of the scheme follows from the weak soundness of the designated verifier CS proof. However, since the latter only holds against a cheating prover who does not see the verdict of the verifier. Scheme Del<sup>1</sup> only achieves soundness without verification oracle. Finally, we remark that Del<sup>1</sup> has an efficient off-line stage with computational complexity poly(k, log n, m, log T) independent of the complexity of the compuation, and the on-line stage contains only a single message from the worker to the delegator.</p>

      <h4 id="sec-6.2.3" class="text-lg font-semibold mt-6">6.2.3 On-Line Delegation Satisfying Soundness with Verification Oracle</h4>

    <p class="text-gray-300">Soundness without verification oracle means that every time after the delegator rejects a proof, it needs to execute the off-line stage fresh again to prevent a cheating worker (aware of its decision) from cheating in later proofs. Although the delegation scheme Del<sup>1</sup> satisfies only soundness without verification oracle, it has a very efficient off-line stage, with computational complexity poly(k, n, m, log T). Therefore, the delegator can, in fact, afford to run the off-line stage every time before delegating a computation. By doing so, soundness holds even if the cheating worker learns the delegator's decisions, yielding a two-message delegation scheme satisfying robust soundness.</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">Off-Line Stage: Empty.</h2>

    <p class="text-gray-300">On-Line Stage: The delegator D2, on input 1<sup>k</sup> and a function F = (M, n, m, T), runs D1(1<sup>k</sup> , F) in off-line stage to generate (pp, sp); it sends pp to the worker.</p>

    <p class="text-gray-300">The worker W<sup>2</sup> on input 1<sup>k</sup> , F, pp and an input x &isin; {0, 1} n , sends back (y, &pi;) = W1(1<sup>k</sup> , pp, F, x). D<sup>2</sup> reaches a decision exactly as D<sup>1</sup> does.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[AF07] Masayuki Abe and Serge Fehr. Perfect nizk with adaptive soundness. In TCC, pages 118&ndash;136, 2007.</li>
      <li>[BCC88] Gilles Brassard, David Chaum, and Claude Cr&acute;epeau. Minimum disclosure proofs of knowledge. J. Comput. Syst. Sci., 37(2):156&ndash;189, 1988.</li>
      <li>[BFLS91] L&acute;aszl&acute;o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In STOC, pages 21&ndash;31, 1991.</li>
      <li>[BG08] Boaz Barak and Oded Goldreich. Universal arguments and their applications. SIAM J. Comput., 38(5):1661&ndash;1694, 2008.</li>
      <li>[BP04] Mihir Bellare and Adriana Palacio. Towards plaintext-aware public-key encryption without random oracles. In ASIACRYPT, pages 48&ndash;62, 2004.</li>
    </ul>

    <p class="text-gray-300"><sup>5</sup>Recall that the delegator used T as an upper bound on the running time to generate the off-line message</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[BSGH+05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Short pcps verifiable in polylogarithmic time. In IEEE Conference on Computational Complexity, pages 120&ndash;134, 2005.</p></li>
      <li><p class="text-gray-300">[BSGH+06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust pcps of proximity, shorter pcps, and applications to coding. SIAM J. Comput., 36(4):889&ndash;974, 2006.</p></li>
      <li><p class="text-gray-300">[BV11] Z. Brakerski and V. Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. To appear in TCC 2010, 2011.</p></li>
      <li><p class="text-gray-300">[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In ICALP (2), pages 449&ndash;460, 2008.</p></li>
      <li><p class="text-gray-300">[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557&ndash;594, 2004.</p></li>
      <li><p class="text-gray-300">[CKLR11] Kai-Min Chung, Yael Tauman Kalai, Feng-Hao Liu, and Ran Raz. Memory delegation. Cryptology ePrint Archive, Report 2011/273, 2011. http://eprint.iacr.org/.</p></li>
      <li><p class="text-gray-300">[CKV10] Kai-Min Chung, Yael Kalai, and Salil P. Vadhan. Improved delegation of computation using fully homomorphic encryption. In CRYPTO, pages 483&ndash;501, 2010.</p></li>
      <li><p class="text-gray-300">[CL08] Giovanni Di Crescenzo and Helger Lipmaa. Succinct np proofs from an extractability assumption. In CiE, pages 175&ndash;185, 2008.</p></li>
      <li><p class="text-gray-300">[CMS99] Christian Cachin, Silvio Micali, and Markus Stadler. Computationally private information retrieval with polylogarithmic communication. In EUROCRYPT, pages 402&ndash;414, 1999.</p></li>
      <li><p class="text-gray-300">[Dam91] Ivan Damg&#730;ard. Towards practical public key systems secure against chosen ciphertext attacks. In CRYPTO, pages 445&ndash;456, 1991.</p></li>
      <li><p class="text-gray-300">[Din07] Irit Dinur. The pcp theorem by gap amplification. J. ACM, 54(3):12, 2007.</p></li>
      <li><p class="text-gray-300">[DNRS03] Cynthia Dwork, Moni Naor, Omer Reingold, and Larry J. Stockmeyer. Magic functions. J. ACM, 50(6):852&ndash;921, 2003.</p></li>
      <li><p class="text-gray-300">[FL93] Lance Fortnow and Carsten Lund. Interactive proof systems and alternating timespace complexity. Theor. Comput. Sci., 113(1):55&ndash;73, 1993.</p></li>
      <li><p class="text-gray-300">[FS87] Amos Fiat and Adi Shamir. How to prove yourself: practical solutions to identification and signature problems. In Proceedings on Advances in cryptology&mdash;CRYPTO '86, pages 186&ndash;194, London, UK, 1987. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In STOC, pages 169&ndash;178, 2009.</p></li>
      <li><p class="text-gray-300">[Gen11] Craig Gentry. Fully homomorphic encryption without bootstrapping. Manuscript, 2011.</p></li>
      <li><p class="text-gray-300">[GGP10] Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In CRYPTO, pages 465&ndash;482, 2010.</p></li>
      <li><p class="text-gray-300">[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the fiat-shamir paradigm. In FOCS, pages 102&ndash;, 2003.</p></li>
      <li><p class="text-gray-300">[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In STOC, pages 113&ndash;122, 2008.</p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186&ndash;208, 1989.</p></li>
      <li><p class="text-gray-300">[Gol01] Oded Goldreich. Foundations of Cryptography Basic Tools. Cambridge University Press, 2001.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASI-ACRYPT, pages 321&ndash;340, 2010.</p></li>
      <li><p class="text-gray-300">[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, pages 723&ndash;732, 1992.</p></li>
      <li><p class="text-gray-300">[Kil95] Joe Kilian. Improved efficient arguments (preliminary version). In CRYPTO, pages 311&ndash;324, 1995.</p></li>
      <li><p class="text-gray-300">[KR08] Yael Tauman Kalai and Ran Raz. Interactive pcp. In ICALP (2), pages 536&ndash;547, 2008.</p></li>
      <li><p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859&ndash;868, 1992.</p></li>
      <li><p class="text-gray-300">[Mer89] Ralph C. Merkle. A certified digital signature. In CRYPTO, pages 218&ndash;238, 1989.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253&ndash;1298, 2000.</p></li>
      <li><p class="text-gray-300">[PS94] Alexander Polishchuk and Daniel A. Spielman. Nearly-linear size holographic proofs. In STOC, pages 194&ndash;203, 1994.</p></li>
      <li><p class="text-gray-300">[Sha92] Adi Shamir. Ip = pspace. J. ACM, 39(4):869&ndash;877, 1992.</p></li>
      <li><p class="text-gray-300">[vDGHV10] Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. Fully homomorphic encryption over the integers. In EUROCRYPT, pages 24&ndash;43, 2010.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A General Definitions</h2>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Witness Relations</h3>

    <p class="text-gray-300">We recall the definition of a witness relation for a N P language [Gol01].</p>

    <p class="text-gray-300">Definition 10 (Witness relation). A witness relation for a language L &isin; N EX P is a binary relation R<sup>L</sup> that characterizes L by L = {x : &exist;y s.t.(x, y) &isin; RL}</p>

    <p class="text-gray-300">We say that y is a witness for the membership x &isin; L if (x, y) &isin; RL.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Indistinguishability</h3>

    <p class="text-gray-300"><strong>Definition 11</strong> (Computational Indistinguishability). Let Y be a countable set. Two ensembles  <span class="math">\\{A_{k,y}\\}_{k\\in N,y\\in Y}</span>  and  <span class="math">\\{B_{k,y}\\}_{k\\in N,y\\in Y}</span>  are said to be computationally indistinguishable (denoted by  <span class="math">\\{A_{k,y}\\}_{k\\in N,y\\in Y}\\approx \\{B_{k,y}\\}_{k\\in N,y\\in Y}</span> ), if for every  <span class="math">\\mathcal{PPT}</span>  &quot;distinguishing&quot; machine D, there exists a negligible function  <span class="math">\\nu(\\cdot)</span>  so that for every  <span class="math">k\\in N, y\\in Y</span> :</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr \\left[ a \\leftarrow A_{k,y} : D(1^k, y, a) = 1 \\right] - \\Pr \\left[ b \\leftarrow B_{k,y} : D(1^k, y, b) = 1 \\right] \\right| &lt; \\nu(k)</span>$</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Interactive Proofs</h3>

    <p class="text-gray-300">We use the standard definitions of interactive proofs (and interactive Turing machines) [GMR89] and arguments (a.k.a. computationally-sound proofs) [BCC88]. Given a pair of interactive Turing machines, P and V, we denote by  <span class="math">\\langle P(w), V \\rangle(x)</span>  the random variable representing the (local) output of V, on common input x, when interacting with machine P with private input w, when the random input to each machine is uniformly and independently chosen.</p>

    <p class="text-gray-300"><strong>Definition 12</strong> (Interactive Proof System). A pair of interactive machines  <span class="math">\\langle P, V \\rangle</span>  is called an interactive proof system for a language L if there is a negligible function  <span class="math">\\nu(\\cdot)</span>  such that the following two conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness: For every  <span class="math">x \\in L</span> , and every  <span class="math">w \\in R_L(x)</span> ,  <span class="math">\\Pr[\\langle P(w), V \\rangle(x) = 1] = 1</span></li>
      <li>Soundness: For every  <span class="math">x \\in \\{0,1\\}^n L</span> , and every interactive machine B,  <span class="math">\\Pr[\\langle B, V \\rangle(x) = 1] \\le \\nu(n)</span></li>
    </ul>

    <p class="text-gray-300">In case that the soundness condition is required to hold only with respect to a computationally bounded prover, the pair  <span class="math">\\langle P, V \\rangle</span>  is called an interactive argument system.</p>

    </section>
`;
---

<BaseLayout title="Delegation of Computation without Rejection Problem from Des... (2011/456)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/456
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="delegation-of-computation-without-rejection-problem-from-2011" />
  </article>
</BaseLayout>
