---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1410';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Mac&#x27;n&#x27;Cheese: Zero-Knowledge Proofs for Boolean and Arithmetic Circuits with Nested Disjunctions';
const AUTHORS_HTML = 'Carsten Baum, Alex J.  Malozemoff, Marc B.  Rosen, Peter Scholl';

const CONTENT = `    <p class="text-gray-300">Carsten Baum Aarhus University Alex J. Malozemoff Galois, Inc. Marc B. Rosen Galois, Inc. Peter Scholl Aarhus University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Zero knowledge proofs are an important building block in many cryptographic applications. Unfortunately, when the proof statements become very large, existing zero-knowledge proof systems easily reach their limits: either the computational overhead, the memory footprint, or the required bandwidth exceed levels that would be tolerable in practice.</p>

    <p class="text-gray-300">We present an interactive zero-knowledge proof system for boolean and arithmetic circuits, called Mac’n’Cheese, with a focus on supporting large circuits. Our work follows the commit-and-prove paradigm instantiated using information-theoretic MACs based on vector oblivious linear evaluation to achieve high efficiency. We additionally show how to optimize disjunctions, with a general OR transformation for proving the disjunction of <span class="math">m</span> statements that has communication complexity proportional to the longest statement (plus an additive term logarithmic in <span class="math">m</span>). These disjunctions can further be <em>nested</em>, allowing efficient proofs about complex statements with many levels of disjunctions. We also show how to make Mac’n’Cheese non-interactive (after a preprocessing phase) using the Fiat-Shamir transform, and with only a small degradation in soundness.</p>

    <p class="text-gray-300">We have implemented the online phase of Mac’n’Cheese and achieve a runtime of 144 ns per AND gate and 1.5 <span class="math">\\mu</span>s per multiplication gate in <span class="math">\\mathbb{F}_{2^{61}-1}</span> when run over a network with a 95 ms latency and a bandwidth of 31.5 Mbps. In addition, we show that the disjunction optimization improves communication as expected: when proving a boolean circuit with eight branches and each branch containing roughly 1 billion multiplications, Mac’n’Cheese requires only 75 more bytes to communicate than in the single branch case.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero knowledge (ZK) proofs are interactive protocols which allow a prover P to convince a verifier V that a certain statement <span class="math">x</span> is true in such a way that V learns nothing beyond the validity of the statement. ZK proofs have a wide range of applications in cryptography, from signatures <em>[x1]</em> to compiling other protocols from passive to active security <em>[x10]</em>. More recently, ZK proofs have seen widespread applications outside of classical cryptography, for example in the cryptocurrency space <em>[BCG^{+}14]</em>. These constructions mostly focus on <em>succinctness</em> and <em>non-interactivity</em>; namely, the construction of “succinct” proofs that have a small verification runtime and that do not require interaction between P and V for validation.</p>

    <p class="text-gray-300">However, for sufficiently large statements—on the order of billions of instructions—most existing proof systems fail due to either memory constraints or high prover running times. Systems such as SNARKs <em>[BCG^{+}13]</em> or recent IOP-based constructions such as Ligero <em>[x1]</em> or STARKs <em>[x2]</em> suffer from exactly this drawback: they have an inherent asymptotic prover</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">overhead, paying at least a multiplicative factor $\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in computation when the statement has length </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and they need to keep the entire statement </span>x$ in memory.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Approach: Mac’n’Cheese</h3>

    <p class="text-gray-300">In this work we introduce a family of novel ZK proof protocols called Mac’n’Cheese, which are optimized for statements at scale. We use the <em>commit-and-prove</em> paradigm <em>[x10]</em>, where we “commit to” values using an information-theoretic message authentication code (MAC). For each committed value, P holds the MAC’ed value and the tag, and V holds the MAC key. Such commitments can be generated very efficiently using vector oblivious linear evaluation (VOLE) <em>[x5]</em> in a pre-processing phase, which can generate many such random commitments with only a small amount of interaction and computation <em>[x36]</em>.</p>

    <p class="text-gray-300">Naively, this commit-and-prove approach leads to a proof with bandwidth costs that scale linearly with the circuit size. To decrease this, in Mac’n’Cheese we support efficiently evaluating <em>disjunctive statements</em>, namely, to prove that one out of <span class="math">m</span> statements is true, the prover only needs to communicate the information needed to evaluate the true branch among all <span class="math">m</span> disjunctions. Both parties still perform the computations necessary to evaluate each branch, but the verifier uses the messages for the correct branch for all <span class="math">m</span> instances simultaneously. The idea of optimizing disjunctive statements in this way was first considered in recent work on stacked garbling <em>[x16]</em>, with proofs of disjunctions based on garbled circuits. They observed that disjunctive statements can arise in many natural applications, such as when proving in zero-knowledge the existence of a bug in a program, so optimizing these is well-motivated.</p>

    <p class="text-gray-300">At a high level, our technique can be seen as a generalized OR composition for <span class="math">m</span> protocols, where the resulting OR proof has communication complexity proportional to <span class="math">\\max\\{C_{i}\\}</span>, where <span class="math">C_{i}</span> is the complexity of the <span class="math">i</span>-th protocol. Contrasted with the classic OR proof approach <em>[x11]</em>, which requires <span class="math">\\sum C_{i}</span> communication, our techniques for stacking save a multiplicative factor of <span class="math">m</span>. On the other hand, compared with stacked garbling <em>[x16]</em>, our underlying protocols have around <span class="math">20\\times</span> less communication, and are also more flexible, since we can support both boolean and arithmetic circuits.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Efficiency comparison and related work.</h4>

    <p class="text-gray-300">Table 1 shows the efficiency of our protocols alongside other VOLE- or garbled-circuit-based protocols, where we focus on communication cost per multiplication gate measured in field elements. As far as we are aware, there are only two ZK approaches that can successfully scale to large statements: the garbled circuit ZK approach <em>[x23, x12, x25, x13]</em>, and the more recent approach based on VOLE, namely the concurrent works Wolverine <em>[x36]</em> and Line-Point ZK <em>[x13]</em>, plus QuickSilver <em>[x39]</em> (which builds on Line-Point ZK). All of these VOLE-based approaches have provers that run linear in the proof statement alongside the ability to “stream”—namely, the prover and verifier are not required to store the entire proof statement in memory.</p>

    <p class="text-gray-300">For Mac’n’Cheese, our first class of “simple” protocols reduces the communication complexity of Wolverine from <span class="math">4</span> to <span class="math">3</span> field elements for arithmetic circuits, and achieves a slightly higher cost (<span class="math">9</span> bits) for boolean circuits, while avoiding the need to amortize over many gates. Our second set of protocols has essentially the same practical cost as Line-Point ZK and QuickSilver, but is best run in large batches, so suited for bigger circuits. Importantly, all of our protocols are compatible with our technique for efficient disjunctions—we currently do not know how to efficiently adapt</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Boolean</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Arithmetic</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Disjunctions</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Comm.</td>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">Mmps</td>

            <td class="px-3 py-2 border-b border-gray-700">Comm.</td>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">Mmps</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Stacked garbling [HK20b]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Wolverine [WYKW20]</td>

            <td class="px-3 py-2 border-b border-gray-700">7*</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2.02</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.22</td>

            <td class="px-3 py-2 border-b border-gray-700">X†</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Line-Point ZK [DIO21]</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">QuickSilver [YSWW21]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">12.23</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.43</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mac'n'Cheese (simple)</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mac'n'Cheese (batched)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 + ε*</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log b)</td>

            <td class="px-3 py-2 border-b border-gray-700">6.94</td>

            <td class="px-3 py-2 border-b border-gray-700">1 + ε*</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log b)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.64</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For large batches (e.g.,  <span class="math">b \\geq 1</span>  million).</li>

    </ul>

    <p class="text-gray-300">† While we believe Wolverine can be combined with our approach described in §3.1, the performance implications of this combination are unclear. 1 With a 100 ms latency and a 100 Mbps bandwidth. 2 With a 0.1 ms latency and a 50 Mbps bandwidth. 3 With a 0.1 ms latency and a 30 Mbps bandwidth for boolean and a 100 Mbps bandwidth for arithmetic. 4 With a 93 ms latency and a 31.5 Mbps bandwidth.</p>

    <p class="text-gray-300">Table 1: Comparison of different GC and VOLE-based ZK protocols (costs exclude OT/VOLE setup). "Comm." denotes the number of field elements communicated per multiplication. "Rounds" denotes the total number of rounds required, where we count rounds as the number of message flows, so one round is a single message from the prover to the verifier. "Mmps" denotes the number of multiplication gates per second in millions. We caution against reading too much into these numbers due to differing experimental environments, and provide them mostly as a rough comparison guide. "Disjunctions" denotes those protocols that support communication-optimized disjunctions. The variable  <span class="math">b</span>  denotes the batch-size of multiplications, and  <span class="math">\\epsilon</span>  denotes a value close to zero that depends on  <span class="math">b</span> . Concretely, for a batch size of  <span class="math">b = 1000000</span>  we require 17 rounds with  <span class="math">\\epsilon = .008</span>  for the boolean case (using  <span class="math">\\mathbb{F}_{2^{40}}</span> ) and  <span class="math">\\epsilon = .257</span>  for the arithmetic case (using  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p = 2^{61} - 1</span> ).</p>

    <p class="text-gray-300">this technique for QuickSilver or Line-Point  <span class="math">\\mathbf{ZK}^1</span></p>

    <p class="text-gray-300">Finally, note that for zero knowledge from garbled circuits, the best approach currently has a communication cost of 128 bits per AND gate, which is around  <span class="math">18 \\times</span>  higher than our approach that also supports disjunctive statements. We note that Heath and Kolesnikov [HK20b] were the first to consider "stacked" disjunctive proofs. Our approach was inspired by stacked garbling, but the technique is very different, and closer in spirit to the earlier 'free if' for private function evaluation [Kol18] (although neither technique follows from the other).</p>

    <p class="text-gray-300">Implementation. We implemented the online phase of Mac'n'Cheese in the Rust programming language. Currently, we do not have an implementation of VOLE, which should add a small amount of communication—0.42 bits per VOLE—and slight increase in runtime—at most 85 ns per VOLE [WYKW20, Table 4].</p>

    <p class="text-gray-300">When run on a real-world network (95 ms latency and a bandwidth of 31.5 Mbps), Mac'n'Cheese requires approximately  <span class="math">1.5\\mu s</span>  per multiplication gate (for  <span class="math">\\mathbb{F}_{2^{61} - 1}</span> ), and 144 ns per AND gate (using  <span class="math">\\mathbb{F}_{2^{40}}</span> ). Run locally, Mac'n'Cheese requires approximately 276 ns per multiplication gate and 141 ns per AND gate. We also show that disjunctions have large communication savings: when run on a circuit containing eight branches each of which contains 1 billion multiplication gates, we see a</p>

    <p class="text-gray-300">communication increase of only <em>75 bytes</em> versus running a single 1-billion-gate branch.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Our Techniques</h3>

    <p class="text-gray-300">We present the Mac’n’Cheese approach in four steps: first, we describe the zero-knowledge protocol in a setting with idealized homomorphic commitments to single field elements. Next, we present an abstraction for such protocols which we call <em>Interactive Protocols with Linear Oracle Verification</em>—<em>IPs with LOVe</em> for short—and explain how IPs with LOVe naturally support nested disjunctions and can be compiled to ZK protocols using VOLE. We then provide efficient IPs with LOVe for general circuit satisfiability, which intuitively follow from such protocols for homomorphic commitments. Finally, we show that our protocols are compatible with streaming and that we can apply the Fiat-Shamir transform to reduce the round complexity with only a small loss in soundness.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Circuit satisfiability via idealized homomorphic commitments.</h4>

    <p class="text-gray-300">Assume that the statement <span class="math">x</span>, together with a witness <span class="math">\\bm{w}</span>, is provided to <span class="math">\\mathsf{P}</span> while <span class="math">\\mathsf{V}</span> only obtains <span class="math">x</span>. We consider <span class="math">x</span> as a circuit <span class="math">C</span> over a finite field <span class="math">\\mathbb{F}</span>, such that <span class="math">C(\\bm{w})=0</span> iff <span class="math">(x,\\bm{w})\\in\\mathcal{R}</span> and assume that <span class="math">\\bm{w}</span> is a vector over <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Implementing the test that <span class="math">C(\\bm{w})=0</span> can be done using standard techniques with idealized homomorphic commitments <em>[x10]</em>, but we nevertheless sketch these now. First, <span class="math">\\mathsf{P}</span> commits to (1) <span class="math">\\bm{w}</span>, (2) triples of the form <span class="math">a,b,c</span> such that <span class="math">c=a\\cdot b</span>, and (3) the outputs of all the gates of <span class="math">C(\\bm{w})</span>. <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> then engage in an interactive protocol to test that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitments to gate outputs are consistent with <span class="math">C</span> and <span class="math">\\bm{w}</span>; and</li>

      <li>The output of the output gate of <span class="math">C</span> is zero.</li>

    </ol>

    <p class="text-gray-300">Note that these checks reduce to testing that certain committed values are zero:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This is clear for testing the output of the output gate.</li>

      <li>For each addition gate (or multiplications with public constants from <span class="math">\\mathbb{F}</span>) one can simply apply the respective linear operation to the commitments to the inputs of the gate, subtract the commitment of the output and test if the result is a commitment to zero.</li>

      <li>For each multiplication gate, we use Beaver’s circuit randomization approach <em>[x1, x11, x24]</em> to reduce multiplication to zero-testing a commitment to a linear combination of commitments to the gate inputs, outputs, and the random triples <span class="math">(a,b,c)</span>, alongside an additional random element sent by <span class="math">\\mathsf{V}</span>. (In fact, this random element can be generated by the output of a random oracle on the protocol transcript using the Fiat-Shamir transform. We provide more details on this in § 4.1.)</li>

    </ul>

    <p class="text-gray-300">When instantiating homomorphic commitments with VOLE (as we describe later), this basic protocol has an amortized communication complexity of 3 field elements per multiplication gate. This improves upon the arithmetic protocol of Weng et al. <em>[x32]</em>, which uses 4 field elements, although they also present a variant with 2 field elements per multiplication which has a higher computational cost due to polynomial operations.</p>

    <p class="text-gray-300">###</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Formalizing security using IPs with LOVe (§ 2).</h5>

    <p class="text-gray-300">Proofs based on ideal homomorphic commitments can be modeled as a functionality where the prover initially commits to some secret values, and the verifier is then allowed to perform linear queries to the commitments, to check that certain relations hold. For instance, linear interactive oracle proofs (IOPs) <em>[BBC^{+}19]</em> model exactly this. In § 2, we extend this paradigm with a new abstraction called <em>interactive proofs with linear oracle verification (IPs with LOVe)</em>. In this abstraction, P begins by committing some proof string <span class="math">\\bm{\\pi}</span> to an oracle <span class="math">\\mathcal{O}</span>. The parties then exchange messages for a fixed number of rounds, after which V sends multiple queries of the form <span class="math">(\\bm{z}_{i},y_{i})</span> to <span class="math">\\mathcal{O}</span>. These queries are determined by V based on the messages that it received in the previous rounds. <span class="math">\\mathcal{O}</span> truthfully tells V if <span class="math">\\langle\\bm{\\pi},\\bm{z}_{i}\\rangle=y_{i}</span> or not for each of these queries. Eventually, V outputs a bit to represent whether it accepts or not.</p>

    <p class="text-gray-300">The key difference between IPs with LOVe and linear IOPs <em>[BBC^{+}19]</em>, is that on top of oracle queries, we allow the prover and verifier to exchange a number of messages. Therefore, IPs with LOVe naturally model homomorphic commitments in the same way as linear IOPs, while also giving extra power from the exchange of messages, which is what we exploit in our protocols for efficient disjunctions.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">From IPs with LOVe to IPs with VOLE.</h5>

    <p class="text-gray-300">We show that any Public Coin IP with LOVe can be combined with a VOLE protocol to obtain a ZK proof. This is described in § 2.2. We instantiate the oracle <span class="math">\\mathcal{O}</span> that contains the string <span class="math">\\bm{\\pi}</span> using information-theoretic commitments (or MACs) of the form</p>

    <p class="text-gray-300"><span class="math">\\textsf{MAC}_{(\\alpha,\\beta)}(x):=x\\alpha+\\beta,</span></p>

    <p class="text-gray-300">where <span class="math">x</span> comes from a field <span class="math">\\mathbb{F}_{p}</span> and all remaining value from an extension field <span class="math">\\mathbb{F}_{p^{k}}</span> for <span class="math">k\\geq 1</span>. We call <span class="math">\\alpha</span> the “MAC key” and <span class="math">\\beta</span> the “MAC offset”, and sometimes use the notation <span class="math">K</span> to denote the tuple <span class="math">(\\alpha,\\beta)</span>, held by the verifier, and <span class="math">\\tau</span> to denote the MAC tag, held by the prover. These commitments are linearly homomorphic for keys that share the <span class="math">\\alpha</span> component, so we can realize each oracle query as a zero-test on such commitments. Their binding guarantee follows from the size of <span class="math">\\mathbb{F}_{p^{k}}</span>.</p>

    <p class="text-gray-300">A batch of <span class="math">n</span> MACs on random values is exactly equivalent to a VOLE of length <span class="math">n</span>, since the MAC relation can be viewed as evaluating a linear function on the input <span class="math">x</span>. This can be generated with high efficiency using recent (random) VOLE protocols based on arithmetic variants of the LPN assumption <em>[BCG+18, BCG^{+}19a, WYK+20]</em>, with communication almost independent of <span class="math">n</span>. VOLE on random inputs gives us a committed proof string of <em>random</em> elements; the prover can then take any of these random values and adjust them with a masked value to commit to an input of his choice.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Disjunctive proofs for IPs with LOVe (§ 3).</h5>

    <p class="text-gray-300">Our main technical contribution, described in § 3.1, can be seen as a general form of OR composition for IPs with LOVe. The communication complexity in the resulting OR proof is proportional to the <em>maximum</em> of that in the original proofs. Note that our transformation is different to the stacked garbling approach <em>[HK+20b]</em> (which does not fit the IP with LOVe paradigm), and we obtain much greater efficiency when using our IPs with LOVe instead.</p>

    <p class="text-gray-300">We limit ourselves to IPs with LOVe that are <em>public coin</em>, i.e., where V only sends messages that are random bits and where the queries to <span class="math">\\mathcal{O}</span> can be derived deterministically from the protocol transcript. This is indeed the case for our general IP with LOVe protocols that we describe later. We then go on to show that if one has <span class="math">m</span> such public coin IPs with LOVe <span class="math">\\Pi_{1},\\cdots,\\Pi_{m}</span> whose messages from P to V can be made “compatible”, then one can construct a (public coin) IP with</p>

    <p class="text-gray-300">LOVe <span class="math">\\Pi</span> whose message complexity essentially only depends on the protocol <span class="math">\\Pi_{i}</span> which sends the most messages, plus an additional check that requires <span class="math">O(m)</span> communication but is independent of all <span class="math">m</span> IPs of LOVe themselves. <span class="math">\\mathsf{V}</span> accepts in <span class="math">\\Pi</span> if and only if at least one of the instances <span class="math">\\Pi_{i}</span> was accepting.</p>

    <p class="text-gray-300">In order to run <span class="math">\\Pi</span>, <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> initially execute <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> in parallel. The key insight is that we only send those messages from <span class="math">\\mathsf{P}</span> to <span class="math">\\mathsf{V}</span> that belong to the one protocol <span class="math">\\Pi_{i^{<em>}}</span> where <span class="math">\\mathsf{P}</span> has a witness <span class="math">\\boldsymbol{w}_{i^{</em>}}</span> for <span class="math">x_{i^{<em>}}</span>, padding with dummy messages such that the communication looks as if it could belong to any of the <span class="math">m</span> branches. <span class="math">\\mathsf{V}</span> uses the one message that it obtains per round for all <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> in parallel, not knowing to which of the <span class="math">m</span> protocols it belongs. Finally, instead of performing the queries to <span class="math">\\mathcal{O}</span> at the end of each <span class="math">\\Pi_{i}</span>, <span class="math">\\Pi</span> runs a standard (small) OR-proof à la Cramer et al. </em>[x10]<em> to show that the queries in at least </em>one* of the <span class="math">m</span> branches are all valid. The trick here is that we can show that this OR-proof can itself be expressed as sending certain messages between <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> followed by queries to <span class="math">\\mathcal{O}</span> from <span class="math">\\mathsf{V}</span>, making <span class="math">\\Pi</span> a public coin IP with LOVe as desired.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Thresholds, logarithmic overhead, and recursive nesting.</h4>

    <p class="text-gray-300">The OR-proof of Cramer et al. <em>[x10]</em> can be generalized for any threshold <span class="math">r</span> out of <span class="math">m</span>, showing that at least <span class="math">r</span> instances of <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> were correct. We generalize our protocol to this setting, with communication <span class="math">r</span> times that of <span class="math">\\Pi_{i}</span>, instead of <span class="math">m</span>.</p>

    <p class="text-gray-300">While the above techniques avoid the factor <span class="math">m</span> blowup from <em>[x10]</em>, they do still incur an <em>additive</em> <span class="math">O(m)</span> overhead in the number of statements. We present a different approach, which reduces this to <em>logarithmic</em> using recursion. The key idea is that we can build a 1-out-of-2 disjunctive proof, which itself satisfies the conditions required to be stacked. Applying recursion in a binary tree-like manner, we obtain a 1-out-of-<span class="math">m</span> proof with <span class="math">O(\\log m)</span> overhead. Note that the ability to recurse is also useful when capturing proofs about complex programs, which may contain arbitrary nested levels of disjunctions, with communication proportional to the longest path through the entire program. The original stacked garbling approach <em>[x23]</em> did not support nested disjunctions, however, a later update shows how to handle them <em>[x22]</em>.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Efficient IPs with LOVe for circuit satisfiability (§ 4).</h4>

    <p class="text-gray-300">Towards efficiently instantiating IPs with LOVe, in § 4.1 we describe a simple high-level syntax for expressing a large class of IPs with LOVe using an abstract homomorphic commitment notation. We refer to these as <em>commit-and-prove</em> <em>(C&P) IPs with LOVe</em>. This avoids the low-level details in the definition, simplifying the process of specifying and analyzing protocols. To illustrate this, we describe in § 4.2 a simple protocol for circuit satisfiability.</p>

    <p class="text-gray-300">Next, in § 4.3 we present an optimized circuit satisfiability protocol that batch-checks <span class="math">n</span> multiplication gates simultaneously. To achieve this, we adapt the <span class="math">\\log(n)</span>-round inner product check of Boneh et al. <em>[BBC^{+}19]</em> to C&P IPs with LOVe, which we then use for the batch check.</p>

    <p class="text-gray-300">Due to the additive overhead generated from the batch check, it might not be the most communication-efficient approach for binary circuits when <span class="math">n</span> is small. In § 4.4 we therefore present a batch check of multiplications for binary circuits that has an overhead of 9 bits, essentially independent of <span class="math">n</span>. This check uses <em>reverse multiplication-friendly embeddings</em> <em>[x6, x11]</em> which were previously mainly used for efficient multiplications in MPC protocols.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Streaming and removing interaction (§ 5).</h4>

    <p class="text-gray-300">We wish to obtain a zero-knowledge proof that both has a <em>small memory footprint</em>, allowing streaming, and also <em>minimizes interaction</em>, so that</p>

    <p class="text-gray-300">ideally the proof is completely non-interactive after a one-time preprocessing phase (for generating the random VOLEs². We show how to achieve a small memory footprint in our protocols by verifying each linear oracle query as it arises during the computation, rather than batching them together at the end. However, this introduces a high degree of interaction, since now the parties have to interact for every multiplication gate in the circuit.</p>

    <p class="text-gray-300">The natural approach to avoiding interaction is to apply the Fiat-Shamir transform by obtaining the verifier's random challenges from a random oracle. However, the low-memory protocol to which we want to apply this has a very large round complexity, possibly even linear in the circuit size. The Fiat-Shamir transform is typically only applied to constant-round protocols, since in the worst-case, the soundness can degrade exponentially with the number of rounds [BCS16]. Several works, however, have defined extra conditions on the underlying protocol which suffice to avoid this degradation, for the cases of interactive oracle proofs [BCS16] and general interactive proofs [CCH⁺19].</p>

    <p class="text-gray-300">Following in this direction, we adapt the concept of round-by-round soundness [CCH⁺19] of interactive proofs to IPs with LOVe. We then show that by applying a Fiat-Shamir transform, any IP with LOVe satisfying this modified notion can be transformed into a NIZK (with VOLE preprocessing) in the random oracle model, with negligible soundness degradation. Finally, we also show that our streamable protocols for circuit satisfiability do indeed have round-by-round soundness, so can safely be made non-interactive.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2 Interactive Proofs with Linear Oracle Verification</h2>

    <p class="text-gray-300">In this section we introduce our proof methodology, called interactive proofs with linear oracle verification (IPs with LOVe). In addition, we show how, using vector oblivious linear evaluation (VOLE), any public coin IP with LOVe can be turned into a zero-knowledge proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. For any vector <span class="math">\\mathbf{r}</span> we denote by $\\mathbf{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_t<span class="math"> the restriction to the first </span>t<span class="math"> elements and by </span>\\mathbf{r}[i]<span class="math"> the </span>i<span class="math">th element of </span>\\mathbf{r}<span class="math">. Let </span>[\\mathsf{P} \\leftrightarrow \\mathsf{V}]<span class="math"> denote the distribution of exchanged messages between two parties </span>\\mathsf{P}<span class="math"> and </span>\\mathsf{V}<span class="math"> and let </span>[\\mathsf{P} \\leftrightarrow \\mathsf{V}]_t<span class="math"> denote the distribution of the transcript of the messages exchanged in the first </span>t<span class="math"> rounds. Denote by </span>\\textsf{View}_{\\mathsf{V}}[\\mathsf{P} \\leftrightarrow \\mathsf{V}]<span class="math"> the view of </span>\\mathsf{V}<span class="math"> when interacting with </span>\\mathsf{P}$. We defer the (standard) definition of zero-knowledge proofs to §A.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-15" class="text-2xl font-bold">2.1 Definitions</h2>

    <p class="text-gray-300">We now formalize IPs with LOVe over a finite field <span class="math">\\mathbb{F}_{p^k}</span>. This formalization is a generalization of linear interactive oracle proofs [BBC⁺19], where in each round, the verifier chooses some linear function, and learns the evaluation of this on a proof string chosen by the prover. In comparison, we let the prover <span class="math">\\mathsf{P}</span> first fix the proof string <span class="math">\\pi</span>, which is a vector of field elements. Then, both <span class="math">\\mathsf{P}</span> and the verifier <span class="math">\\mathsf{V}</span> exchange messages for a certain number of rounds. Finally, <span class="math">\\mathsf{V}</span> issues a number of affine queries to <span class="math">\\pi</span>, upon which it makes a decision on whether to accept or not. These queries can depend on the messages that were exchanged between both <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> throughout the protocol.</p>

    <p class="text-gray-300">We let <span class="math">\\mathsf{P}</span> fix <span class="math">\\pi \\in \\mathbb{F}_{p^k}^\\ell</span> at the beginning of the protocol and allow <span class="math">\\mathsf{V}</span> to access it via oracle queries only at the end of the protocol. In the oracle query stage, we let <span class="math">\\mathsf{V}</span> choose <span class="math">q</span> queries <span class="math">(\\mathbf{z}_1, y_1), \\ldots, (\\mathbf{z}_q, y_q) \\in \\mathbb{F}_{p^k}^\\ell \\times \\mathbb{F}_{p^k}</span> which it sends to an oracle that stores <span class="math">\\pi</span>. This oracle checks that</p>

    <p class="text-gray-300">²Note that precomputing VOLEs may require large memory and/or storage. If storage is expensive, one could compute them on-the-fly using a pseudorandom correlation function [BCG⁺20].</p>

    <p class="text-gray-300">for each of the <span class="math">q</span> queries the relation <span class="math">\\langle\\bm{\\pi},\\bm{z}_{i}\\rangle=y_{i}</span> holds. The query results are then (truthfully) reported to <span class="math">\\mathsf{V}</span> by the oracle.</p>

    <p class="text-gray-300">Note that by default, both <span class="math">\\bm{\\pi}</span> and the queries lie over the extension field <span class="math">\\mathbb{F}_{p^{k}}</span>. In some cases, such as when we are proving statements over <span class="math">\\mathbb{F}_{p}</span>, some elements of <span class="math">\\bm{\\pi}</span> may only be in <span class="math">\\mathbb{F}_{p}</span>, which allows for improved efficiency when instantiating IPs with LOVe, as we will see later. In this case, during the query phase we view any <span class="math">\\mathbb{F}_{p}</span> value as an element of <span class="math">\\mathbb{F}_{p^{k}}</span> via some fixed embedding.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 1 (Interactive Protocol with Linear Oracle Verification).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{p^{k}}</span> be a field and <span class="math">\\ell,t,q\\in\\mathbb{N}</span>. Then a <span class="math">t</span>-round <span class="math">q</span>-query interactive protocol with linear oracle verification <span class="math">\\Pi=(\\mathsf{P},\\mathsf{V})</span> with oracle length <span class="math">\\ell</span>, message lengths <span class="math">r_{1}^{\\mathsf{P}},r_{1}^{\\mathsf{V}},\\ldots,r_{t}^{\\mathsf{P}},r_{t}^{\\mathsf{V}}\\in\\mathbb{N}</span> and message complexity <span class="math">\\sum_{h=1}^{t}(r_{h}^{\\mathsf{P}}+r_{h}^{\\mathsf{V}})</span> over <span class="math">\\mathbb{F}_{p^{k}}</span> consists of the algorithm <span class="math">\\mathsf{P}</span> and PPT algorithm <span class="math">\\mathsf{V}</span> that interact as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initially, <span class="math">\\mathsf{P}</span> obtains its respective input while <span class="math">\\mathsf{V}</span> obtains the statement <span class="math">x</span>. <span class="math">\\mathsf{P}</span> then submits a string <span class="math">\\bm{\\pi}\\in\\mathbb{F}_{p^{k}}^{\\ell}</span> to the oracle. <span class="math">\\mathsf{P}</span> then outputs a state <span class="math">s_{0}^{\\mathsf{P}}</span> while <span class="math">\\mathsf{V}</span> outputs a state <span class="math">s_{0}^{\\mathsf{V}}</span>. We set an auxiliary variable <span class="math">a_{0}=\\bot</span>.</li>

      <li>For round <span class="math">h\\in[t]</span>, <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> do the following:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">\\mathsf{V}</span> on input <span class="math">s_{h-1}^{\\mathsf{V}}</span> and <span class="math">a_{h-1}</span> outputs message <span class="math">\\bm{e}_{h}\\in\\mathbb{F}_{p}^{r_{h}^{\\mathsf{V}}}</span> and state <span class="math">s_{h}^{\\mathsf{V}}</span>.</li>

      <li>Then, <span class="math">\\mathsf{P}</span> on input <span class="math">s_{h-1}^{\\mathsf{P}}</span> and <span class="math">\\bm{e}_{h}</span> outputs message <span class="math">\\bm{a}_{h}\\in\\mathbb{F}_{p}^{r_{h}^{\\mathsf{P}}}</span> and state <span class="math">s_{h}^{\\mathsf{P}}</span>.</li>

      <li>Finally, <span class="math">\\mathsf{V}</span> on input <span class="math">\\bm{a}_{t}</span> and state <span class="math">s_{t}^{\\mathsf{V}}</span> makes <span class="math">q</span> linear oracle queries to <span class="math">\\bm{\\pi}</span> over <span class="math">\\mathbb{F}_{p^{k}}</span> and outputs a bit.</li>

    </ol>

    <p class="text-gray-300">We say that the protocol accepts if <span class="math">\\mathsf{V}</span> outputs 1 at the end of the protocol.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Note that the prover and verifier’s messages <span class="math">(\\bm{a}_{h},\\bm{e}_{h})</span> are specified as elements of the base field <span class="math">\\mathbb{F}_{p}</span>, and this is how we count message complexity. This is an arbitrary restriction, since these messages can easily be used to encode extension field elements or general bit strings.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2 (Honest-Verifier Zero-Knowledge Interactive Proof with Linear Oracle Verification).</h6>

    <p class="text-gray-300">A <span class="math">t</span>-round <span class="math">q</span>-query interactive protocol with linear oracle verification <span class="math">\\Pi=(\\mathsf{P},\\mathsf{V})</span> over <span class="math">\\mathbb{F}_{p^{k}}</span> is an honest-verifier zero-knowledge interactive proof with linear oracle verification (HVZK IP with LOVe) for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span> if it satisfies the following three properties:</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Completeness:</h6>

    <p class="text-gray-300">For all <span class="math">(x,\\bm{w})\\in\\mathcal{R}</span> the interaction between <span class="math">\\mathsf{P}(x,\\bm{w})</span> and <span class="math">\\mathsf{V}(x)</span> is accepting.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Soundness:</h6>

    <p class="text-gray-300">For all <span class="math">x\\not\\in L(\\mathcal{R})</span> and for all (unbounded) algorithms <span class="math">\\mathsf{P}^{<em>}</span>, any interaction of <span class="math">\\mathsf{P}^{</em>}</span> with <span class="math">\\mathsf{V}(x)</span> is accepting with probability at most <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Honest-Verifier Zero-Knowledge:</h6>

    <p class="text-gray-300">There exists a PPT algorithm <span class="math">S</span> such that for any <span class="math">(x,\\bm{w})\\in R</span> the output of <span class="math">S(x)</span> is perfectly indistinguishable from <span class="math">\\texttt{View}_{V}[\\mathsf{P}(x,\\bm{w})\\leftrightarrow\\mathsf{V}(x)]</span> for any honest <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">We use the notation <span class="math">\\mathsf{IP}</span>-<span class="math">\\mathsf{LOVe}</span> to denote a <span class="math">t</span>-round, <span class="math">q</span>-query HVZK IP with LOVe for relation <span class="math">\\mathcal{R}</span> over field <span class="math">\\mathbb{F}_{p^{k}}</span> with oracle length <span class="math">\\ell</span>, message complexity <span class="math">\\alpha</span> elements of <span class="math">\\mathbb{F}_{p}</span>, and soundness error <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">In this work, all the protocols we construct will additionally be proofs of knowledge and public coin, as in the following definitions.</p>

    <p class="text-gray-300">Definition 3 (ZK Interactive Proof of Knowledge with LOVe). Let <span class="math">\\Pi</span> be an IP-LOVe protocol for a statement <span class="math">x</span> using a proof string <span class="math">\\pi</span> such that <span class="math">\\mathsf{V}</span> accepts with probability <span class="math">&amp;gt; \\epsilon</span>. Then <span class="math">\\Pi</span> is a proof of knowledge if there exists a PPT extractor <span class="math">\\mathsf{E}</span> that, on input <span class="math">x, \\pi</span>, outputs a witness <span class="math">\\mathbf{w}</span> such that <span class="math">(x, \\mathbf{w}) \\in \\mathcal{R}</span>.</p>

    <p class="text-gray-300">Definition 4 (Public Coin IP with LOVe). An IP-LOVe protocol <span class="math">\\Pi</span> is public coin if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> chooses each <span class="math">\\mathbf{e}_h \\in \\mathbb{F}_{p&#x27;}^{\\tau_h^{\\mathsf{V}}}</span> for <span class="math">x \\in L(\\mathcal{R})</span> uniformly at random (and in particular, independent of <span class="math">s_{h-1}^{\\mathsf{V}}</span> and <span class="math">\\mathbf{a}_{h-1}</span>).</li>

      <li>There exists a deterministic polytime algorithm <span class="math">\\mathcal{Q}</span>, which, on input <span class="math">x</span> and <span class="math">\\{\\mathbf{e}_h, \\mathbf{a}_h\\}_{h \\in [t]}</span>, computes the <span class="math">q</span> oracle queries <span class="math">(\\mathbf{z}_1, y_1), \\ldots, (\\mathbf{z}_q, y_q)</span> of <span class="math">\\mathsf{V}</span>.</li>

      <li><span class="math">\\mathsf{V}</span> accepts iff all queries generated by <span class="math">\\mathcal{Q}</span> are accepting.</li>

    </ol>

    <p class="text-gray-300">From <span class="math">q</span>-query to 1-query. Given a <span class="math">q</span>-query IP with LOVe, we can always convert it to one with a single oracle query, with a small loss in soundness, by taking random linear combinations of all queries over a large enough extension field. This transformation, given below, is public-coin and adds just one extra round of communication, so when using IPs with LOVe, we will often assume they have only one query, to simplify our protocols.</p>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be an IP-LOVe over <span class="math">\\mathbb{F}_p</span> (<span class="math">p</span> need not be prime), and let <span class="math">k</span> be such that <span class="math">p^k</span> is superpolynomial in a statistical security parameter. We construct an IP with LOVe over <span class="math">\\mathbb{F}_{p^k}</span>, by viewing the proof <span class="math">\\pi \\in \\mathbb{F}_p^\\ell</span> from <span class="math">\\Pi</span> as a vector in <span class="math">\\mathbb{F}_{p^k}^\\ell</span>, running the same protocol and then modifying the query phase as follows. Recall that the <span class="math">q</span> queries <span class="math">(\\mathbf{z}_1, y_1), \\ldots, (\\mathbf{z}_q, y_q)</span> in <span class="math">\\Pi</span> accept if and only if <span class="math">\\langle \\pi, \\mathbf{z}_i \\rangle = y_i</span> i.e. <span class="math">\\mu_i := \\langle \\pi, \\mathbf{z}_i \\rangle - y_i = 0</span> in <span class="math">\\mathbb{F}_p</span>. Now, we modify the protocol by having <span class="math">\\mathsf{V}</span> send <span class="math">q</span> random elements <span class="math">\\rho_1, \\ldots, \\rho_q \\in \\mathbb{F}_{p^k}</span> to <span class="math">\\mathsf{P}</span>. Notice that if <span class="math">\\mu := \\sum_{i \\in [q]} \\rho_i \\mu_i = 0</span>, all queries are satisfied except with probability <span class="math">p^{-k}</span>. We equivalently have <span class="math">\\mu = \\langle \\pi, \\mathbf{z} \\rangle - y</span> for <span class="math">\\mathbf{z} = \\sum_{i \\in [q]} \\rho_i \\mathbf{z}_i</span> and <span class="math">y = \\sum_{i \\in [q]} \\rho_i y_i</span>. This shows we can reduce the <span class="math">q</span> oracle queries down to just one query <span class="math">(\\mathbf{z}, y)</span> over <span class="math">\\mathbb{F}_{p^k}</span>, at the cost of an extra <span class="math">q</span> elements of <span class="math">\\mathbb{F}_{p^k}</span> sent from <span class="math">\\mathsf{V}</span> to <span class="math">\\mathsf{P}</span>, and the soundness error increasing by <span class="math">p^{-k}</span>.</p>

    <h2 id="sec-22" class="text-2xl font-bold">2.2 Instantiating IPs with LOVe Using VOLE</h2>

    <p class="text-gray-300">We now show that any IP-LOVe can be transformed into a zero-knowledge proof, by using vector oblivious linear evaluation (VOLE) to instantiate the linear oracle queries. The functionality for random VOLE is given in Figure 1: it picks a vector of random samples <span class="math">(\\mathbf{r}, \\mathbf{\\tau})</span>, <span class="math">(\\alpha, \\beta)</span> such that <span class="math">\\mathbf{\\tau} = \\mathbf{r}\\alpha + \\beta</span>, and outputs them to the respective parties. This can be seen as a secret-sharing of the products <span class="math">\\mathbf{r}[i]\\alpha</span>, for <span class="math">i = 1, \\ldots, \\ell</span>. Note that we relax security slightly by allowing corrupt parties to choose their own randomness. This models existing random VOLE protocols based on the LPN assumption [BCGI18, BCG+19b, WYKW20], which can generate a large, length <span class="math">\\ell</span> VOLE with communication that is almost independent of <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">The functionality interacts with a sender  <span class="math">S</span> , receiver  <span class="math">R</span> , and adversary  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">On input  <span class="math">\\alpha \\in \\mathbb{F}_{p^k}</span>  from  <span class="math">R</span> , the functionality does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\pmb{r}, \\pmb{\\beta} \\gets \\mathbb{F}_{p^k}^\\ell</span> , and set  <span class="math">\\pmb{\\tau} = \\pmb{r}\\alpha + \\pmb{\\beta}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">S</span>  is corrupted: receive  <span class="math">\\pmb{r}, \\pmb{\\tau}</span>  from  <span class="math">\\mathcal{A}</span>  and recompute  <span class="math">\\beta = \\pmb{\\tau} - \\pmb{r}\\alpha</span> .</li>

      <li>If  <span class="math">R</span>  is corrupted: receive  <span class="math">\\beta</span>  from  <span class="math">\\mathcal{A}</span>  and recompute  <span class="math">\\tau = r\\alpha + \\beta</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(\\pmb{r}, \\pmb{\\tau})</span>  to  <span class="math">S</span>  and  <span class="math">\\beta</span>  to  <span class="math">R</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 1: Ideal functionality for vector oblivious linear evaluation over  <span class="math">\\mathbb{F}_{p^k}</span> .</p>

    <p class="text-gray-300">Commitments with MACs. We can view each output of a VOLE as an information-theoretic MAC on the value  <span class="math">\\boldsymbol{r}[i]</span> , which commits the prover to  <span class="math">\\boldsymbol{r}[i]</span> . We write  <span class="math">[x]</span>  to denote that the prover holds  <span class="math">x, \\tau_x \\in \\mathbb{F}_{p^k}</span> , while the verifier holds  <span class="math">\\beta_x</span>  and the fixed MAC key  <span class="math">\\alpha \\in \\mathbb{F}_{p^k}</span> . To open a commitment to  <span class="math">x</span> , the prover sends  <span class="math">x, \\tau_x</span>  and the verifier checks that  <span class="math">\\tau_x = x\\alpha + \\beta_x</span> . It is easy to see that cheating in an opening requires guessing the random MAC key  <span class="math">\\alpha</span> , so happens with probability  <span class="math">1/p^k</span> .</p>

    <p class="text-gray-300">Since  <span class="math">\\alpha</span>  is the same for each commitment, these commitments are linearly homomorphic. Indeed, given two commitments  <span class="math">[x],[y]</span> , the parties can obtain  <span class="math">[x + y]</span>  by computing  <span class="math">x + y</span> ,  <span class="math">\\tau_{x} + \\tau_{y}</span>  and  <span class="math">\\beta_{x} + \\beta_{y}</span> , respectively. Similarly, we can do multiplication by constant, and addition by constant  <span class="math">c</span>  (here, the verifier adds  <span class="math">\\alpha c</span>  to  <span class="math">\\beta_{x}</span> , while the prover adds  <span class="math">c</span>  to  <span class="math">x</span> ). We overload the  <span class="math">+</span>  and  <span class="math">\\cdot</span>  operators to denote these operations being performed on the commitments.</p>

    <p class="text-gray-300">The transformation (Figure 2). Given the linearly homomorphic commitment scheme based on VOLE, obtaining a ZK proof is relatively straightforward. First, the prover commits to its proof string  <span class="math">\\pi</span> , by sending each component masked with a random VOLE commitment. The parties then run the IP-LOVe protocol as usual, until the query phase. Here, each linear query is computed by applying the linear function to the committed  <span class="math">\\pi</span> , followed by opening the result to check it gives the correct value. In §B, we prove the following.</p>

    <p class="text-gray-300">Theorem 1. Suppose  <span class="math">\\Pi_{\\mathsf{LOVe}}</span>  is a public-coin IP-LOVe for relation  <span class="math">\\mathcal{R}</span> , satisfying completeness, soundness error  <span class="math">\\epsilon</span>  and honest-verifier zero-knowledge. Then,  <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span>  is an honest-verifier zero-knowledge proof for relation  <span class="math">\\mathcal{R}</span> , with soundness error  <span class="math">\\epsilon + p^{-k}</span> . Furthermore, if  <span class="math">\\Pi_{\\mathsf{LOVe}}</span>  is a proof of knowledge, then so is  <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span> .</p>

    <p class="text-gray-300">Optimizations: Random proof elements, and subfield VOLE. We describe two simple optimizations, which reduce communication in certain cases.</p>

    <p class="text-gray-300">Firstly, in our protocols, the proof string  <span class="math">\\pi</span>  will often contain many random field elements; clearly, the values  <span class="math">d_{i}</span>  in Step 2 of the Input Phase (cf. Figure 2) do not need to be sent in this case, since  <span class="math">\\mathsf{P}</span>  can choose  <span class="math">\\pi [i] = r[i]</span> .</p>

    <p class="text-gray-300">Secondly, when working over an extension field  <span class="math">\\mathbb{F}_{p^k}</span> , sometimes it is known that  <span class="math">\\pi</span>  will consist mainly of elements in the base field  <span class="math">\\mathbb{F}_p</span>  (viewed as a subset of  <span class="math">\\mathbb{F}_{p^k}</span>  by a fixed embedding). In this case, we can optimize communication by using subfield VOLE instead of VOLE over  <span class="math">\\mathbb{F}_{p^k}</span> . In subfield VOLE [BCG+19b],  <span class="math">\\pmb{r}</span>  is sampled as a uniform vector over  <span class="math">\\mathbb{F}_p</span>  instead of  <span class="math">\\mathbb{F}_{p^k}</span> , while the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Zero-knowledge proof from VOLE and IP with LOVe.</p>

    <p class="text-gray-300">MACs  <span class="math">\\pmb{\\tau}</span>  and keys  <span class="math">\\alpha, \\beta</span>  are still computed over  <span class="math">\\mathbb{F}_{p^k}</span> . This allows  <span class="math">\\mathsf{P}</span>  to commit to values from the subfield  <span class="math">\\mathbb{F}_p</span>  (which may be small), by sending only elements from  <span class="math">\\mathbb{F}_p</span> , while still achieving soundness error  <span class="math">p^{-k}</span> . Note that this still allows committing to an extension field element  <span class="math">x \\in \\mathbb{F}_{p^k}</span>  if needed, by decomposing  <span class="math">x</span>  into a linear combination of  <span class="math">\\mathbb{F}_p</span>  elements, and committing to each component separately (this works because the MACs are linear over  <span class="math">\\mathbb{F}_{p^k}</span> ).</p>

    <p class="text-gray-300">When analyzing the complexity of our protocols, we assume that the above two optimizations have been applied.</p>

    <p class="text-gray-300">In this section, we show that when both  <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  agree on  <span class="math">m</span>  relations  <span class="math">\\mathcal{R}_1,\\ldots ,\\mathcal{R}_m</span>  and instances  <span class="math">x_{1},\\ldots ,x_{m}</span>  that can each be proven using (public coin HVZK) IPs with LOVe over the same field  <span class="math">\\mathbb{F}_p</span> , then we can construct a communication-efficient protocol showing that at least one of the statements was true. Following the terminology of stacked garbling [HK20b], we sometimes refer to this as a stacked proof. Formally, the goal of  <span class="math">\\mathsf{P}</span>  is to show that  <span class="math">(x_{1},\\dots,x_{m})\\in L(\\mathcal{R}_{\\mathsf{OR}})</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">\\left(x _ {1}, \\dots , x _ {m}\\right) \\in L \\left(\\mathcal {R} _ {\\mathrm {O R}}\\right) \\iff x _ {1} \\in L \\left(\\mathcal {R} _ {1}\\right) \\vee \\dots \\vee x _ {m} \\in L \\left(\\mathcal {R} _ {m}\\right).</span></div>

    <p class="text-gray-300">Throughout this section, we will write  <span class="math">\\hat{x}</span>  as a short-hand for  <span class="math">x_{1},\\ldots ,x_{m}</span>  when the statements are clear from the context. Suppose we have IPs with LOVe over  <span class="math">\\mathbb{F}_p</span>  for each instance  <span class="math">x_{i}</span> , with message complexity  <span class="math">\\alpha_{i}</span> . The classic OR-proof technique by Cramer et al. [CDS94] can be used to give an IP with LOVe with message complexity  <span class="math">\\approx \\sum_{i\\in [m]}\\alpha_{i}</span> . This would be done by running all  <span class="math">m</span>  proofs in parallel (which means sending messages for all of them), and then showing that at least one finished with the expected output using [CDS94]. We show how to instead reduce the message complexity of such a proof to  <span class="math">2mk + \\max \\{\\alpha_i\\}</span> , where the soundness error grows by  <span class="math">\\approx p^{-k}</span> . We also give a variant where the message complexity scales with  <span class="math">O(\\log m)</span> , instead of  <span class="math">2m</span> .</p>

    <p class="text-gray-300">Towards this, we introduce the notion of equisimulatable IPs with LOVe. The idea is that we can compress the messages for the different proof branches sent by <span class="math">\\mathsf{P}</span> in such a way that for the true branch, the correct message can be recovered by <span class="math">\\mathsf{V}</span>. The distribution of the values for non-taken branches which <span class="math">\\mathsf{V}</span> will obtain is indistinguishable from a real protocol execution.</p>

    <p class="text-gray-300">For example, assume that in the <span class="math">\\Pi_1</span> branch, <span class="math">\\mathsf{P}</span> sends one <span class="math">\\mathbb{F}_p</span> element that appears uniformly random to <span class="math">\\mathsf{V}</span>, while in the <span class="math">\\Pi_2</span> branch it sends two such elements with the same property. To achieve equisimulatability, if <span class="math">\\mathsf{P}</span> actually proves the first branch to be true then it can always append a uniformly random element to the message it sends to <span class="math">\\mathsf{V}</span>, whereas in the second case it just sends the actual message. In both cases, the distribution of the message sent by <span class="math">\\mathsf{P}</span> is identical and <span class="math">\\mathsf{V}</span> cannot identify which branch was taken by <span class="math">\\mathsf{P}</span>.</p>

    <p class="text-gray-300">Formally, for <span class="math">m</span> statements with protocols <span class="math">\\Pi_1,\\ldots,\\Pi_m</span>, we use the following two algorithms, which should satisfy the definition below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The "combined prover" algorithm <span class="math">\\mathcal{CP}</span> takes as input instances <span class="math">x_1, \\ldots, x_m</span>, instance index <span class="math">i</span>, round index <span class="math">h</span>, and prover message <span class="math">\\pmb{a}_h \\in \\mathbb{F}_{p&#x27;}^{r_h^{\\mathsf{P}}}</span>, and outputs a message <span class="math">c \\in \\mathbb{F}_p^*</span>, which encodes <span class="math">\\pmb{a}_h</span> while disguising it to hide the index <span class="math">i</span>.</li>

      <li>The "decode" algorithm <span class="math">\\mathsf{dec}</span> takes as input instances <span class="math">x_1, \\ldots, x_m</span>, index <span class="math">i</span>, round index <span class="math">h</span>, and combined prover message <span class="math">c \\in \\mathbb{F}_p^*</span>, and recovers <span class="math">\\pmb{a}_h&#x27; \\in \\mathbb{F}_{p&#x27;}^{r_h^{\\mathsf{P}}}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 5 (Equisimulatable IPs with LOVe).</strong> Let <span class="math">\\Pi_1, \\ldots, \\Pi_m</span> be protocols such that each <span class="math">\\Pi_i</span> is an IP with LOVe over <span class="math">\\mathbb{F}_p</span> for the relation <span class="math">\\mathcal{R}_i</span> with round complexity <span class="math">t_i</span>. We say that <span class="math">\\Pi_1, \\ldots, \\Pi_m</span> are equisimulatable if there exist two algorithms <span class="math">\\mathcal{CP}</span> and <span class="math">\\mathsf{dec}</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\pmb{a}_h \\gets \\Pi_i(s_{h-1}^{\\mathsf{P}}, \\pmb{e}_h)</span>, where <span class="math">\\Pi_i</span>'s inputs are from an honest execution of <span class="math">\\Pi_i</span>, then</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{dec}(\\hat{x}, i, h, \\mathcal{CP}(\\hat{x}, i, h, \\boldsymbol{a}_h)) = \\boldsymbol{a}_h.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">i, j</span>, the distributions <span class="math">\\{\\mathcal{CP}(\\hat{x}, i, h, \\boldsymbol{a}_h) \\mid \\boldsymbol{a}_h \\gets \\Pi_i(s_{h-1}^{\\mathsf{P}}, \\boldsymbol{e}_h)\\}_{h \\in [t_i]}</span> and <span class="math">\\{\\mathcal{CP}(\\hat{x}, j, h, \\boldsymbol{a}_h) \\mid \\boldsymbol{a}_h \\gets \\Pi_j(s_{h-1}^{\\mathsf{P}}, \\boldsymbol{e}_h)\\}_{h \\in [t_j]}</span>, where both the inputs of <span class="math">\\Pi_i</span> and <span class="math">\\Pi_j</span> come from honest executions, are perfectly indistinguishable.</li>

    </ol>

    <p class="text-gray-300">We say that <span class="math">\\mathcal{CP}</span> has message complexity <span class="math">\\alpha</span> if the total number of <span class="math">\\mathbb{F}_p</span> elements generated by <span class="math">\\mathcal{CP}</span> for all <span class="math">h \\in [\\max_{i \\in [m]} t_i]</span> is at most <span class="math">\\alpha</span>.</p>

    <p class="text-gray-300">In our constructions of IPs with LOVe, all prover messages will appear uniformly random. We show below that this implies both the zero-knowledge property and equisimulatability, which gives us an easy criterion for proving that an IP-LOVe can be stacked. We prove the following lemma in §C.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let <span class="math">\\Pi</span> be an IP-LOVe for proving relation <span class="math">\\mathcal{R}</span>, satisfying completeness, where <span class="math">\\mathsf{V}</span> accepts iff all queries are accepting. If the messages from <span class="math">\\mathsf{P}</span> in an honest execution are (perfectly) indistinguishable from random, it holds that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi</span> is honest-verifier zero-knowledge; and</li>

      <li><span class="math">m</span> such instances of <span class="math">\\Pi</span> (potentially for different relations <span class="math">\\mathcal{R}&#x27; \\neq \\mathcal{R}</span>) are equisimulatable (cf. Definition 5).</li>

    </ol>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">3.1 Stacking with LOVe</p>

    <p class="text-gray-300">Using the concept of <em>equisimulatability</em> of protocols we now show how to lower the message complexity when proving <span class="math">\\mathcal{R}_{\\mathtt{OR}}</span>. The protocol, given in Figure 3, is inspired by the stacked garbling approach <em>[x13]</em>, although uses a very different technique.</p>

    <p class="text-gray-300">We start with <span class="math">m</span> equisimulatable IPs with LOVe <span class="math">\\Pi_{i}</span>, over <span class="math">\\mathbb{F}_{p}</span>, for proving individual relations <span class="math">\\mathcal{R}_{i}</span>. Note that <span class="math">p</span> can be any prime power, with no restrictions on size. We construct a protocol <span class="math">\\Pi_{\\mathtt{OR}}</span>, defined over <span class="math">\\mathbb{F}_{p^{k}}</span>, which works as follows. <span class="math">\\mathsf{P}</span>, having only <span class="math">\\bm{w}_{i^{<em>}}</span> for one of the statements <span class="math">x_{i^{</em>}}</span>, will generate the oracle string <span class="math">\\bm{\\pi}</span> by running <span class="math">\\Pi_{i^{<em>}}</span>’s first step to create <span class="math">\\bm{\\pi}_{i^{</em>}}</span>, which it then pads with extra random data, and embeds in to <span class="math">\\mathbb{F}_{p^{k}}</span>. Then, <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> will <em>simultaneously</em> run all <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span>, with the following modification: <span class="math">\\mathsf{P}</span>’s message <span class="math">c_{h}</span> to <span class="math">\\mathsf{V}</span> in round <span class="math">h</span> will be determined from <span class="math">\\bm{a}_{h,i}</span> using the combined prover algorithm <span class="math">\\mathcal{CP}</span>, while <span class="math">\\mathsf{V}</span> extracts the message <span class="math">\\bm{a}_{h,i}</span> for each of the instances from <span class="math">c_{h}</span> using <span class="math">\\mathtt{dec}</span>. Due to equisimulatability, <span class="math">\\mathsf{V}</span> can now execute all instances in parallel but cannot tell which of these is the true one. Conversely, since all <span class="math">\\Pi_{i}</span> are public coin, <span class="math">\\mathsf{V}</span> sends a randomness string that is long enough for any of the <span class="math">m</span> instances in round <span class="math">h</span>. The message complexity is now determined by <span class="math">\\mathcal{CP}</span> and not the individual proofs.</p>

    <p class="text-gray-300">The challenge now, is that <span class="math">\\mathsf{V}</span> cannot simply perform the oracle queries for all <span class="math">\\Pi_{i}</span>, since this would reveal the index <span class="math">i^{<em>}</span> of the true statement. Instead, we perform a </em>[x7]<em>-style OR-proof to shows that at least one of the query’s for the <span class="math">\\Pi_{i}</span> is accepting. Recall, the basic idea behind </em>[x7]<em> is that given <span class="math">m</span> <span class="math">\\Sigma</span>-protocols for proving relations, an OR proof can be done by having the </em>prover<em> choose the random challenge <span class="math">f_{i}</span> for <span class="math">m-1</span> of the instances, so it can simulate the correct messages to be sent in every false instance, without knowing a witness. Then, after receiving the <span class="math">m</span> initial messages of each <span class="math">\\Sigma</span>-protocol, the verifier picks a challenge <span class="math">f</span>, which defines the challenge <span class="math">f_{i^{</em>}}=f-\\sum_{i}f_{i}</span> corresponding to the true instance <span class="math">i^{<em>}</span> (while hiding <span class="math">i^{</em>}</span> from <span class="math">\\mathsf{V}</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We instantiate the above, where each “instance” corresponds to a small protocol for verifying that the oracle query <span class="math">\\langle\\bm{\\pi}_{i},\\bm{z}_{i}\\rangle=y_{i}</span> for protocol <span class="math">\\Pi_{i}</span> succeeds, without actually performing the query. To carry out one such small protocol, <span class="math">\\mathsf{P}</span> includes an extra random value <span class="math">r_{i}</span> in the proof string $\\bm{\\pi}:=(\\bm{\\pi}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{i})<span class="math"> (one such </span>r_{i}$ for each branch).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the true <span class="math">\\Pi_{i^{<em>}}</span> the prover later sends <span class="math">d_{i^{</em>}}:=r_{i^{<em>}}</span> to <span class="math">\\mathsf{V}</span>. Using the random challenge <span class="math">f_{i^{</em>}}</span>, the verifier then makes a query to test that $\\langle\\bm{\\pi},\\bm{z}_{i^{*}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i^{<em>}}\\rangle=_{?}y_{i^{</em>}}+f_{i^{<em>}}d_{i^{</em>}}<span class="math">. This clearly accepts if </span>d_{i^{<em>}}=r_{i^{</em>}}<span class="math"> and the original query (</span>y_{i^{<em>}}=_{?}\\langle\\bm{\\pi}_{i^{</em>}},\\bm{z}_{i^{*}}\\rangle$) accepts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Importantly, if <span class="math">\\mathsf{P}</span> does <em>not</em> know a valid witness, but can pick <span class="math">f_{i}</span> in advance, then <span class="math">\\mathsf{P}</span> can cheat by setting <span class="math">d_{i}=(\\langle\\bm{\\pi}_{i},\\bm{z}_{i}\\rangle-y_{i})/f_{i}+r_{i}</span>, causing the aforementioned oracle query to succeed as well. This is the crux of Phase II of the protocol in Figure 3.</p>

    <p class="text-gray-300">Note that the theorem below assumes that each protocol <span class="math">\\Pi_{i}</span> uses only one query. As discussed at the end of § 2.1, this can always be achieved by combining queries into one (at the cost of one additional round). The proof of the following theorem can be found in § D.1.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> be protocols such that each <span class="math">\\Pi_{i}</span> is a <span class="math">t_{i}</span>-round, 1-query, equisimulatable Public Coin IP with LOVe over <span class="math">\\mathbb{F}_{p}</span> for relation <span class="math">\\mathcal{R}_{i}</span> with oracle length <span class="math">\\ell_{i}</span> and soundness error <span class="math">\\epsilon_{i}</span>. Furthermore, assume that <span class="math">\\mathcal{CP}</span> has overall message complexity <span class="math">\\alpha</span>. Then the protocol <span class="math">\\Pi_{\\mathtt{OR}}</span> in Figure 3 is a Public Coin IP with LOVe over <span class="math">\\mathbb{F}_{p^{k}}</span> for the relation <span class="math">\\mathcal{R}_{\\mathtt{OR}}</span> with</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">3+\\max_{i\\in[m]}t_{i}</span>;</li>

      <li>oracle length <span class="math">m+\\max_{i\\in[m]}\\ell_{i}</span>;</li>

      <li>query complexity <span class="math">m</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">\\Pi_1, \\ldots, \\Pi_m</span>  be protocols such that each  <span class="math">\\Pi_i</span>  is  <span class="math">t_i</span> -round, 1-query equisimulatable public coin IP with LOVe over  <span class="math">\\mathbb{F}_p</span>  for relation  <span class="math">\\mathcal{R}_i</span>  with oracle length  <span class="math">\\ell_i</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Both  <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  have inputs  <span class="math">x_{1},\\ldots ,x_{m}</span>  where  <span class="math">x_{i}\\in L(\\mathcal{R}_{i})</span>  .  <span class="math">\\mathsf{P}</span>  additionally has input  <span class="math">\\pmb{w}_{i^{<em>}}</span>  for (at least) one  <span class="math">i^{</em>}\\in [m]</span>  such that  <span class="math">(x_{i^{<em>}},\\pmb{w}_{i^{</em>}})\\in \\mathcal{R}_{i^{*}}</span>  . We define  <span class="math">\\ell \\coloneqq \\max_{i\\in [m]}\\ell_i</span>  , and  <span class="math">t\\coloneqq \\max_{i\\in [m]}t_i</span>  . Let  $\\pmb{z}_{k,i} = \\overline{\\pmb{z}}_{k,i}\\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underbrace{0\\cdots 0}_{\\ell -\\ell_i\\text{times}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  simulates  <span class="math">\\Pi_{i^<em>}</span>  on input  <span class="math">(x_{i^</em>},\\pmb{w}_{i^<em>})</span>  to obtain the string  <span class="math">\\pi_{i^</em>}</span> . It then sets</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {\\pi} ^ {\\prime} = \\boldsymbol {\\pi} _ {i ^ {*}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underbrace {0 \\cdots 0} _ {\\ell - \\ell_ {i ^ {*}} \\text {times}} \\quad \\text {and} \\quad \\boldsymbol {\\pi} = \\boldsymbol {\\pi} ^ {\\prime} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r _ {1} \\dots r _ {m}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where all  <span class="math">r_i</span>  are chosen uniformly at random in  <span class="math">\\mathbb{F}_{p^k}</span> .</p>

    <p class="text-gray-300">(Phase I: Running the stacked proof)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">s_0^{\\mathsf{P}} \\coloneqq (x_{i^<em>}, \\boldsymbol{w}_{i^</em>})</span> . For  <span class="math">h \\in [t]</span> ,  <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  do the following:</li>

    </ol>

    <p class="text-gray-300">(a) Let  <span class="math">r_{h,i}^{\\mathsf{V}}</span>  be the length of the challenge that  <span class="math">\\mathsf{V}</span>  would send for protocol  <span class="math">\\Pi_i</span>  in round  <span class="math">h</span> .  <span class="math">\\mathsf{V}</span>  sets  <span class="math">r_h = \\max_{i\\in [m]}r_{h,i}^{\\mathsf{V}}</span> , samples  <span class="math">\\pmb {e}_h\\gets \\mathbb{F}_p^{r_h}</span>  uniformly at random and then sends it to  <span class="math">\\mathsf{P}</span> . (b)  <span class="math">\\mathsf{P}</span>  sets  <span class="math">(\\pmb{a}_h, s_h^{\\mathsf{P}}) \\gets \\Pi_{i^<em>}(s_{h-1}^{\\mathsf{P}}, \\pmb{e}_h)</span>  where  <span class="math">\\mathsf{P}</span>  only uses the first  <span class="math">r_{h,i^</em>}^{\\mathsf{P}}</span>  elements of  <span class="math">\\pmb{e}_h</span>  as required by  <span class="math">\\Pi_{i^<em>}</span> . It then computes  <span class="math">c_h \\gets \\mathcal{CP}(\\hat{x}, h, i^</em>, \\pmb{a}_h)</span>  and sends  <span class="math">c_h</span>  to  <span class="math">\\mathsf{V}</span> .</p>

    <p class="text-gray-300">(Phase II: Running the small OR proof)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i \\in [m] \\setminus \\{i^<em>\\}</span> ,  <span class="math">\\mathsf{P}</span>  samples  <span class="math">f_i \\gets \\mathbb{F}_{p^k}^</em></span>  uniformly at random and computes  <span class="math">(\\pmb{z}_i, y_i) \\gets \\mathcal{Q}(x_i, \\{\\pmb{e}_h, \\mathrm{dec}(\\hat{x}, h, i, c_h)\\}_{h \\in [t_i]})</span> . It then computes  <span class="math">d_i := (\\langle \\pmb{\\pi}&#x27;, \\pmb{z}_i \\rangle - y_i) / f_i + r_i</span> , and defines  <span class="math">d_{i^<em>} := r_{i^</em>}</span> . Finally,  <span class="math">\\mathsf{P}</span>  sends  <span class="math">(d_1, \\ldots, d_m) \\in \\mathbb{F}_{p^k}^m</span>  to  <span class="math">\\mathsf{V}</span> .</li>

      <li><span class="math">\\mathsf{V}</span>  samples  <span class="math">f\\gets \\mathbb{F}_{p^k}</span>  uniformly at random and sends it to  <span class="math">\\mathsf{P}</span></li>

      <li><span class="math">\\mathsf{P}</span>  sets  <span class="math">f_{i^{<em>}}\\coloneqq f - \\sum_{i\\in [m]\\setminus \\{i^{</em>}\\}}f_{i}</span>  and sends  <span class="math">f_{1},\\ldots ,f_{m - 1}</span>  to  <span class="math">\\mathsf{V}</span> .  <span class="math">\\mathsf{V}</span>  computes the last challenge  <span class="math">f_{m} = f - \\sum_{i = 1}^{m - 1}f_{i}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. Let  <span class="math">\\beta_{i} \\in \\mathbb{F}_{p^{k}}^{m}</span>  be the vector that is  <span class="math">f_{i}</span>  in the  <span class="math">i</span> th position and 0 everywhere else. For  <span class="math">i \\in [m]</span> ,  <span class="math">\\mathsf{V}</span>  first generates  <span class="math">(\\pmb{z}_{i}, y_{i})</span>  like  <span class="math">\\mathsf{P}</span>  in Step 3. Then, for each  <span class="math">i \\in [m]</span>  it sends the query  $(\\pmb{z}_{i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{\\beta}_{i}, y_{i} + f_{i} d_{i})<span class="math">  to the oracle.  </span>\\mathsf{V}$  accepts if all queries are true.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: The protocol  <span class="math">\\Pi_{\\mathrm{OR}}</span>  for an OR-statement.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>message complexity  <span class="math">2mrk + \\alpha</span>  elements of  <span class="math">\\mathbb{F}_p</span> ; and</li>

      <li>soundness error  <span class="math">\\sum_{i\\in [m]}\\epsilon_i + 1 / p^k</span></li>

    </ol>

    <p class="text-gray-300">If  <span class="math">\\Pi_1, \\ldots, \\Pi_m</span>  are all proofs of knowledge, then so is  <span class="math">\\Pi_{\\mathrm{OR}}</span> .</p>

    <p class="text-gray-300">Generalizing to threshold proofs. In [CDS94] the authors describe how to additionally construct proofs of partial knowledge for any threshold, i.e., how to show that  <span class="math">r</span>  out of the  <span class="math">m</span>  statements are true. Their technique, together with a modification of  <span class="math">\\Pi_{\\mathrm{OR}}</span> , can be used to construct a proof</p>

    <p class="text-gray-300">in our setting where we implicitly only communicate the transcript of <span class="math">r</span> statements, and not all <span class="math">m</span> of them. <span class="math">\\Pi_{\\sf OR}</span> can then be seen as a special case where <span class="math">r=1</span>, where for general <span class="math">r</span> we use Shamir secret-sharing, instead of additive shares of the verifier’s challenge <span class="math">f</span>. More details are found in § D.2.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2 Recursive Stacking</h3>

    <p class="text-gray-300"><span class="math">\\Pi_{\\sf OR}</span> from § 3.1 has the drawback that to verify one out of <span class="math">m</span> statements, we still need <span class="math">O(m)</span> communication complexity. We now give an alternative construction that obtains an overhead only <em>logarithmic in <span class="math">m</span></em>.</p>

    <p class="text-gray-300">The idea behind this alternative protocol is as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any IP-LOVe <span class="math">\\Pi</span> accepts iff all queries are accepting. Assuming (wlog) there is only one query, this means that for the query <span class="math">(z,y)</span>, we have <span class="math">\\langle\\boldsymbol{\\pi},z\\rangle=y</span> i.e. <span class="math">\\mu:=\\langle\\boldsymbol{\\pi},z\\rangle-y=0</span>.</li>

      <li>If we simulate the parallel evaluation of <span class="math">m</span> protocol instances as in <span class="math">\\Pi_{\\sf OR}</span>, then if for any branch <span class="math">i^{<em>}</span> it holds that <span class="math">\\mu_{i^{</em>}}=0</span>, then <span class="math">i^{*}</span> must correspond to a “true” branch.</li>

      <li>If the prover can then compute the product <span class="math">\\mu_{1}\\cdots\\mu_{m}</span>, and prove that this is 0, then at least one <span class="math">\\mu_{j}</span> was 0 to begin with.</li>

    </ol>

    <p class="text-gray-300">A naive instantiation of the above approach is to perform <span class="math">m-1</span> multiplications between the <span class="math">m</span> implicit variables <span class="math">\\mu_{i}</span>, and open the result. However, this would still give <span class="math">O(m)</span> overhead. Instead, we carefully apply recursion to make this overhead logarithmic. Here, we use the fact that after combining two protocols <span class="math">\\Pi_{1},\\Pi_{2}</span> with the multiplication method sketched above, we can obtain a protocol which <em>itself is again stackable</em>: considering all multiplications as a tree, we only have to provide those values necessary to prove a correct multiplication that are on the path from <span class="math">\\mu_{i^{*}}</span> to the root.</p>

    <p class="text-gray-300">The actual proof for this proceeds in the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First we show that if <span class="math">\\Pi_{1}</span>, <span class="math">\\Pi_{2}</span> fulfill similar conditions as in <span class="math">\\Pi_{\\sf OR}</span> then we can combine them using the multiplication-based approach.</li>

      <li>Next, we show that starting with <span class="math">2m</span> proofs <span class="math">\\Pi_{1},\\ldots,\\Pi_{2m}</span> with similar conditions as in <span class="math">\\Pi_{\\sf OR}</span>, if we construct proofs <span class="math">\\Pi_{i}^{\\prime}</span> from <span class="math">\\Pi_{2i-1},\\Pi_{2i}</span> using the multiplication method, then <span class="math">\\Pi_{1}^{\\prime},\\ldots,\\Pi_{m}^{\\prime}</span> again fulfill the same conditions i.e. are stackable. Also, this can be done with an overhead that is only as big as one <span class="math">\\Pi_{i}</span> plus one multiplication.</li>

      <li>Finally, by recursing the previous step, we obtain the log-overhead OR-proof.</li>

    </ol>

    <p class="text-gray-300">The full construction, together with its proof, can be found in § D.3. One drawback of this approach, though, is that unlike our previous OR-proof based method, it does not give rise to a <span class="math">t</span>-out-of-<span class="math">m</span> proof.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 IPs with LOVe for Circuit Satisfiability</h2>

    <p class="text-gray-300">In this section, we present our protocols for proving circuit satisfiability of arithmetic and boolean circuits. First, in § 4.1, we define a high-level <em>commit-and-prove</em> (C&P) syntax for IPs with LOVe.</p>

    <p class="text-gray-300">This makes it simpler to specify protocols, and also aligns with the VOLE instantiation used in § 2.2. We then describe a simple protocol for arithmetic circuit satisfiability over a finite field <span class="math">\\mathbb{F}_{p}</span> (§ 4.2), with communication cost of 3 field elements per multiplication gate for large <span class="math">p</span>. We next show how we can utilize fully linear PCPs by Boneh et al. <em>[BBC^{+}19]</em> to reduce the amortized multiplication cost to just over 1 <span class="math">\\mathbb{F}_{p}</span> element per multiplication gate (§ 4.3), when the circuit size is large enough. The same approach also works over <em>binary</em> fields with the same cost (§ 4.4).</p>

    <p class="text-gray-300">To highlight the power of our disjunctive proof from § 3.1, we point out that all of these protocols fulfil the criteria of our stacking approach, so lead to efficient proofs of disjunctions. Recall that from Lemma 1, it suffices that the sender’s messages in the IP-LOVe are uniformly random, which we show for all protocols in this section.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.1 Defining C&P Protocols</h3>

    <p class="text-gray-300">We now define a high-level, commit-and-prove (C&P) syntax for specifying a large class of IPs with LOVe over <span class="math">\\mathbb{F}_{p^{k}}</span>.</p>

    <p class="text-gray-300">We require that the witness in the IP with LOVe is a vector <span class="math">\\bm{w}=(w_{1},\\ldots,w_{n})</span> of <span class="math">\\mathbb{F}_{p}</span> elements, and that the prover chooses the proof string <span class="math">\\pi=(w_{1},\\ldots,w_{n},r_{1},\\ldots,r_{t})</span>, where each <span class="math">r_{i}</span> is uniformly random. As remarked in § 2.2, we may sometimes wish to mix values in <span class="math">\\mathbb{F}_{p}</span> and <span class="math">\\mathbb{F}_{p^{k}}</span>, so allow the possibility that some <span class="math">r_{i}</span>’s are sampled from <span class="math">\\mathbb{F}_{p^{k}}</span> and others are in the base field.</p>

    <p class="text-gray-300">Following the notation used for homomorphic commitments in § 2.2, we write <span class="math">[x]</span> to denote that some value <span class="math">x</span> is committed to by the prover P. Initially, P is committed to every element <span class="math">w_{i},r_{i}</span> of the proof string <span class="math">\\pi</span>. Subsequently, we allow the parties to perform affine operations on these committed values, obtaining new commitments.</p>

    <p class="text-gray-300">Finally, we model the linear verification oracle by a special instruction AssertZero, which checks whether its input is a commitment to 0. Since any commitment comes from an affine function of <span class="math">\\pi</span>, this exactly models linear queries to <span class="math">\\pi</span>. We then specify a C&P protocol over <span class="math">\\mathbb{F}_{p^{k}}</span> as follows:</p>

    <p class="text-gray-300">P has input the witness <span class="math">w_{1},\\ldots,w_{n}\\in\\mathbb{F}_{p}</span>, and samples random values <span class="math">r_{1},\\ldots,r_{t}\\leftarrow\\mathbb{F}_{p^{k}}^{t}</span> (optionally, some <span class="math">r_{i}</span>’s may be in <span class="math">\\mathbb{F}_{p}</span>).</p>

    <p class="text-gray-300">P inputs the proof string <span class="math">\\pi=(w_{1},\\ldots,w_{n},r_{1},\\ldots,r_{t})</span>. The parties, given commitments <span class="math">[w_{1}],\\ldots,[w_{n}]</span>, run a sequence of instructions of the following types:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random(<span class="math">\\mathbb{F}</span>) (for <span class="math">\\mathbb{F}\\in\\{\\mathbb{F}_{p},\\mathbb{F}_{p^{k}}\\}</span>): Retrieve <span class="math">[r]</span>, where <span class="math">r\\in\\mathbb{F}</span> is the next suitable random value in <span class="math">\\pi</span>.</li>

      <li>Send<span class="math">{}_{[\\textsf{P}\\rightarrow\\textsf{V}]}(x)</span>: Sends value <span class="math">x\\in\\mathbb{F}_{p}</span> from P to V.</li>

      <li>Send<span class="math">{}_{[\\textsf{V}\\rightarrow\\textsf{P}]}(x)</span>: Sends value <span class="math">x\\in\\mathbb{F}_{p}</span> from V to P.</li>

      <li><span class="math">[z]=a[x]+b[y]+c</span>: Define the commitment <span class="math">[z]</span> for <span class="math">z=ax+by+c</span>, given some public values <span class="math">a,b,c</span>.</li>

      <li>AssertZero(<span class="math">[x]</span>): Asserts to V that <span class="math">[x]</span> is a commitment to <span class="math">x=0</span>.</li>

    </ul>

    <p class="text-gray-300">If none of the AssertZero instructions failed, the verifier outputs 1. Otherwise, it outputs 0.</p>

    <p class="text-gray-300">As described previously, by translating AssertZero calls into linear oracle queries, any C&P protocol specified in the above syntax defines a valid IP-LOVe.</p>

    <p class="text-gray-300">17</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.2 C&amp;P IP with LOVe for Arithmetic Circuits</h2>

    <p class="text-gray-300">We now show a C&amp;P IP with LOVe for arithmetic circuit satisfiability that satisfies (1) completeness, (2) soundness, and (3) that all inputs to Send are indistinguishable from random. Thus, by Lemma 1 we conclude that our protocol is also zero knowledge and supports disjunctions. We prove circuit satisfiability over a field <span class="math">\\mathbb{F}_p</span>, but define a protocol over <span class="math">\\mathbb{F}_{p^k}</span> for some <span class="math">k\\geq 1</span>, so that soundness can be boosted if necessary.</p>

    <p class="text-gray-300">We begin by defining two auxiliary "instructions": (1) Fix, which allows P to fix a random commitment to a value of its choosing, and (2) Reveal, which opens a commitment to V and checks this was done properly using AssertZero.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix(x) → [x]: On input x ∈ F (where F ∈ {F_p, F_{p^k}}) from P, output a commitment [x]. This is implemented as:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random(F) → [r].</li>

      <li>Send_{[P→V]}(x - r) → y.</li>

      <li>[r] + y → [x].</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reveal([x]) → x: On input commitment [x], output x to V. This is implemented as:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send_{[P→V]}(x).</li>

      <li>AssertZero([x] - x).</li>

    </ol>

    <p class="text-gray-300">Our protocol works as follows. Let C: F_p^n → F_p be a circuit known to both parties consisting of Add and Mult gates, which we want to show evaluates to zero on some input. The prover provides the witness w ∈ F_p^n as input, so the parties initially get commitments [w_1], ..., [w_n]. The parties then execute the following steps to evaluate the circuit C, where we denote by C* the set of multiplication gates in C.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each gate in C, in topological order, proceed as follows:</li>

    </ol>

    <p class="text-gray-300">Add([x], [y]): Output [x] + [y].</p>

    <p class="text-gray-300">Mult([x], [y]): Run Random(F_{p^k}) → [a], Fix(xy) → [z], and Fix(ay) → [c]. Output [z], and store the commitments [a] and [c].</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Send_{[V→P]}(e), where e ∈ R F_{p^k}.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For each i ∈ [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] let [x_i] and [y_i] denote the inputs and [z_i], [a_i] and [c_i] denote the outputs and stored values in the i-th call to Mult. Then run AssertMult([x_i], [y_i], [z_i], [a_i], [c_i], e).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run AssertZero([z_out]), where [z_out] is the commitment to the output of C.</li>

    </ol>

    <p class="text-gray-300">The subprotocol AssertMult used above works as follows:</p>

    <p class="text-gray-300">AssertMult([x], [y], [z], [a], [c], e):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Reveal([ε]), where [ε] = e[x] - [a].</li>

      <li>Run AssertZero(e[z] - [c] - ε[y]).</li>

    </ol>

    <p class="text-gray-300">Before proving security, observe that the communication complexity is 3 field elements per multiplication gate, of which one is over <span class="math">\\mathbb{F}_p</span> (for fixing <span class="math">xy</span>) and two over <span class="math">\\mathbb{F}_{p^k}</span> (for fixing <span class="math">ay</span>, and revealing <span class="math">\\varepsilon</span>).</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> Let <span class="math">\\mathcal{R}</span> be a relation that can be represented by an arithmetic circuit <span class="math">C</span> over <span class="math">\\mathbb{F}_p</span> such that <span class="math">\\mathcal{R}(x, \\boldsymbol{w}) = 1 \\Leftrightarrow C(\\boldsymbol{w}) = 0</span>. Then the above protocol is a C&amp;P IP with LOVe over <span class="math">\\mathbb{F}_{p^k}</span> for <span class="math">\\mathcal{R}</span>, such that (1) completeness holds, (2) soundness holds with soundness error <span class="math">p^{-k}</span>, (3) all inputs to Send are perfectly indistinguishable from random, and (4) the protocol is a proof of knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof can be found in § E.1. At a high level, soundness holds by the security of the Mult operation, where a malicious prover essentially needs to align its invalid Fix values with the verifier's random <span class="math">e</span> value, which happens with probability $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-31" class="text-2xl font-bold">4.3 Improved C&amp;P IP with LOVe for Arithmetic Circuits</h2>

    <p class="text-gray-300">The protocol from § 4.2 communicates 3 field elements per verified multiplication. We now present an alternative multiplication verification procedure, called AssertMultVec, that builds on a protocol from Boneh et al. [BBC+19]⁵. AssertMultVec simultaneously proves <span class="math">n</span> multiplication instances at the cost of communicating <span class="math">n + O(\\log(n))</span> <span class="math">\\mathbb{F}</span>-elements. In particular, for <span class="math">\\mathbb{F}_p</span> for <span class="math">p = 2^{61} - 1</span> we require around 64.3 bits of communication per multiplication.</p>

    <p class="text-gray-300">Boneh et al. [BBC+19] introduce a logarithmic-sized proof for "parallel-sum" circuits. In a "parallel-sum" circuit, identical subcircuits <span class="math">C&#x27;</span> are evaluated in parallel on possibly different inputs, with the sum of the output of each <span class="math">C&#x27;</span> being the output of the overall circuit. The high-level idea then is to embed checks for different instances of <span class="math">C&#x27;</span> within a single polynomial, allowing the verifier to verify <span class="math">n</span> instances of <span class="math">C&#x27;</span> in parallel. This protocol, when letting <span class="math">C&#x27;</span> be a multiplication gate, can then be used to simultaneously verify the sum of <span class="math">n</span> multiplications. We call this protocol AssertDotProduct.</p>

    <p class="text-gray-300">In more detail, the AssertDotProduct protocol works as follows. Suppose <span class="math">\\mathsf{P}</span> wants to prove that <span class="math">[z] = \\sum_{i\\in [n]}[x_i][y_i]</span>. <span class="math">\\mathsf{P}</span> begins by defining <span class="math">n</span> polynomials <span class="math">f_{1},\\ldots ,f_{n / 2},g_{1},\\ldots ,g_{n / 2}</span> such that <span class="math">f_{i}(j) = x_{(j - 1)n / 2 + i}</span> and <span class="math">g_{i}(j) = y_{(j - 1)n / 2 + i}</span>, and then computing <span class="math">h = \\sum_{i\\in [n / 2]}f_{i}g_{i}</span>. <span class="math">\\mathsf{P}</span> then commits to <span class="math">h</span> by committing to its coefficients (denoted as <span class="math">[h]</span>). <span class="math">\\mathsf{V}</span> defines its own polynomials <span class="math">f_{i}^{\\prime},g_{i}^{\\prime}</span> over the committed values <span class="math">[x_{(j - 1)n / 2 + i}]</span> and <span class="math">[y_{(j - 1)n / 2 + i}]</span> to check that <span class="math">\\sum_{i\\in [n / 2]}f_i&#x27;g_i&#x27; = h</span>. By Schwartz-Zippel, this can be done by checking that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n / 2]} f _ {i} ^ {\\prime} (r) g _ {i} ^ {\\prime} (r) = h (r) \\tag{1}</span></div>

    <p class="text-gray-300">for a random <span class="math">r</span> chosen by <span class="math">\\mathsf{V}</span>. Here, observe that the evaluation of <span class="math">f_{i}^{\\prime}, g_{i}^{\\prime}, h</span> in a public constant <span class="math">r</span> boils down to multiplying the committed coefficients of each polynomial with appropriate powers of <span class="math">r</span> and summing up the result, both of which are local operations. Then, verifying Equation 1 after fixing <span class="math">r</span> is again a dot product check, although over vectors of length <span class="math">n/2</span>, and we can recursively apply AssertDotProduct until <span class="math">n = 1</span>. Note that only two <span class="math">\\mathbb{F}_{p^r}</span>-elements are communicated during one iteration of AssertDotProduct: when committing to <span class="math">h</span> and sending <span class="math">r</span>. See Figure 4 for a formal presentation of the protocol. There, for the base-case of AssertDotProduct, we use the multiplication checking procedure from § 4.2.</p>

    <p class="text-gray-300">Given AssertDotProduct, we can batch-verify <span class="math">n</span> multiplications as follows:</p>

    <p class="text-gray-300">⁵This approach was recently used in the context of MPC-in-the-head-based ZK protocols [dSGOT21].</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 4: Protocols for efficient multiplications. See text for necessary notation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assume that  <span class="math">n</span>  tuples  <span class="math">[x_i], [y_i], [z_i]</span>  have been committed by  <span class="math">\\mathsf{P}</span> .</li>

      <li>V chooses a randomization factor  <span class="math">r</span>  that it sends to  <span class="math">\\mathsf{P}</span> .</li>

      <li><span class="math">\\mathsf{P}</span>  shows that  <span class="math">\\langle r^i [x_i],[y_i]\\rangle = \\sum_{i\\in [n]}r^i [z_i]</span> . Since  <span class="math">r</span>  is public, computing  <span class="math">r^i [x_i]</span>  and  <span class="math">\\sum_{i\\in [n]}r^i [z_i]</span>  is local.</li>

    </ol>

    <p class="text-gray-300">This protocol, called AssertMultVec, is presented in Figure 4.</p>

    <p class="text-gray-300">It is clear that both AssertDotProduct and AssertMultVec are complete and zero-knowledge. The follow theorem, proven in § E.2, shows they are also sound.</p>

    <p class="text-gray-300">Theorem 4. If the protocol AssertMultVec passes, then the input commitments have the required relation except with probability  <span class="math">\\frac{n + 4\\log n + 1}{p^k - 2}</span></p>

    <p class="text-gray-300">An alternative version of AssertMultVec with a soundness error that is only logarithmic in  <span class="math">n</span>  can be achieved as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AssertMultVec}^{\\prime}([x_{1}],\\ldots,[x_{n}],[y_{1}],\\ldots,[y_{2}],[z_{1}],\\ldots,[z_{n}])</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Send}_{[\\mathsf{V}\\to\\mathsf{P}]}(r_{1},\\ldots,r_{n})</span> for <span class="math">r_{1},\\ldots,r_{n}\\in_{R}\\mathbb{F}_{p^{k}}</span>.</li>

      <li><span class="math">\\mathsf{AssertDotProduct}(r_{1}[x_{1}],\\ldots,r_{n}[x_{n}],[y_{1}],\\ldots,[y_{n}],\\sum_{i\\in[n]}r_{i}[z_{i}])</span>.</li>

    </ol>

    <p class="text-gray-300">One can easily show that <span class="math">\\mathsf{AssertMultVec}^{\\prime}</span> has the desired soundness, although at the expense of communicating more random elements from <span class="math">\\mathsf{V}</span> to <span class="math">\\mathsf{P}</span>. In practice, one can optimize this by having <span class="math">\\mathsf{V}</span> choose a random PRG seed that it sends to <span class="math">\\mathsf{P}</span>, with <span class="math">r_{1},\\ldots,r_{n}</span> derived deterministically from the seed.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.4 C&P IP with LOVe for Binary Circuits</h3>

    <p class="text-gray-300">The protocol from § 4.3 is agnostic to the underlying field, so we can use <span class="math">p=2</span> (and large enough <span class="math">k</span> for soundness) to otain a proof for binary circuits. For <span class="math">\\mathbb{F}_{2^{40}}</span> and a batch size of <span class="math">1\\,000\\,000</span> this requires approximately <span class="math">1.008</span> bits per verified AND-gate.</p>

    <p class="text-gray-300">One of the downsides to the batching approach is that it is most efficient for large batches of multiplications. When evaluating a disjunctive branch, however, the size of the batch may be limited by the number of multiplications in the branch. This is because we need to “complete” a batch of multiplications before we can apply the OR-proof. Unfortunately, this smaller batch size increases the per-bit communication cost: as an example, a batch size of <span class="math">100</span> requires approximately <span class="math">10</span> bits per verified AND-gate.</p>

    <p class="text-gray-300">We now present an alternative approach that can achieve a fixed per-bit communication cost of <span class="math">9</span> bits per verified AND-gate. This approach uses <em>reverse multiplication friendly embeddings</em> <em>[x1, x12]</em> (RFMEs), defined as follows.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">A <span class="math">(k,m)_{p}</span>-RFME is a pair <span class="math">(\\phi,\\psi)</span> of linear maps <span class="math">\\phi:\\mathbb{F}_{p}^{k}\\to\\mathbb{F}_{p^{m}}</span> and <span class="math">\\psi:\\mathbb{F}_{p^{m}}\\to\\mathbb{F}_{p}^{k}</span> such that <span class="math">\\bm{x}<em>\\bm{y}=\\psi(\\phi(\\bm{x})\\cdot\\phi(\\bm{y}))</span>, where <span class="math"></em></span> denotes pairwise multiplication.</p>

    <p class="text-gray-300">Cascudo et al. <em>[x12]</em> showed that for <span class="math">p=2</span> and <span class="math">r&lt;33</span>, there exist <span class="math">(3r,10r-5)_{2}</span>-RFMEs. Noting that for efficiency we would like as small a field as possible, alongside the requirement of have a statistical security parameter of at least <span class="math">40</span>, we use <span class="math">(15,45)_{2}</span>-RFMEs, and thus work over <span class="math">\\mathbb{F}_{2^{45}}</span>. Thus, we can verify the multiplication of <span class="math">15</span>-element binary vectors <span class="math">[\\bm{x}]</span> and <span class="math">[\\bm{y}]</span> at the cost of a single multiplication in <span class="math">\\mathbb{F}_{2^{45}}</span> as follows. The parties locally compute <span class="math">[a]\\leftarrow\\phi([\\bm{x}])</span> and <span class="math">[b]\\leftarrow\\phi([\\bm{y}])</span>, compute <span class="math">[c]\\leftarrow[a]\\cdot[b]</span> using the multiplication verification protocol over <span class="math">\\mathbb{F}_{2^{45}}</span>, and finally locally compute <span class="math">[\\bm{z}]\\leftarrow\\psi([c])</span>. This has a per-multiplication cost of <span class="math">10</span> bits per multiplication.</p>

    <p class="text-gray-300">We can do slightly better by having the prover provide the verifier an <em>advice</em> vector to help compute <span class="math">[c]</span>. Let <span class="math">\\bm{d}</span> be a binary vector for the linear bijection <span class="math">f:\\mathbb{F}_{2}^{15}\\times\\mathbb{F}_{2}^{30}\\to\\mathbb{F}_{2}^{45}</span> such that <span class="math">f(\\bm{z},\\bm{d})=\\phi(\\bm{x})\\cdot\\phi(\\bm{y})</span>. If <span class="math">[\\bm{z}]</span> is provided by the prover, the verifier can <em>locally</em> compute <span class="math">[c]</span> by computing <span class="math">[\\bm{c}^{\\prime}]\\leftarrow f([\\bm{z}],[\\bm{d}])</span> and then mapping <span class="math">[\\bm{c}^{\\prime}]</span> to its associated element in <span class="math">\\mathbb{F}_{2^{45}}</span>. The parties can then check that <span class="math">[c]=[a]\\cdot[b]</span> as before. Overall this gives a per-bit communication cost of <span class="math">9</span> bits. See § G for more details.</p>

    <h2 id="sec-34" class="text-2xl font-bold">5 Streaming and Non-Interactive Proofs via Fiat-Shamir</h2>

    <p class="text-gray-300">We now show how to modify our previous constructions for arithmetic circuit satisfiability and disjunctions to support streaming, and also be non-interactive via a variant of the Fiat-Shamir transform <em>[x11]</em>. We first show how to stream our IPs with LOVe, at the cost of increased round</p>

    <p class="text-gray-300">complexity. Then, we show how IPs with LOVe can be transformed into NIZKs (with VOLE preprocessing) with the Fiat-Shamir transform. To analyze the soundness of this approach, we define a form of <em>round-by-round soundness</em> for IPs with LOVe, similar to Canetti et al. <em>[CCH^{+}19]</em>, and show that this is satisfied by our constructions.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">5.1 Streaming Interactive Proofs</h3>

    <p class="text-gray-300">We use the term <em>streaming</em> to refer to a protocol where both the prover and verifier algorithms can be run using only a constant amount of memory, independent of the size of the statement and witness. For disjunctive proofs, we relax this to allow <span class="math">O(m)</span> memory, where <span class="math">m</span> is the maximum number of branches in any disjunction. Note that when looking at a C&P IP with LOVe, in addition to requiring a small memory footprint for P and V, we also need that the linear oracle queries can be performed with small memory. It is enough to require that P can compute the result of each oracle query incrementally during the protocol, and with constant memory; when translating the IP with LOVe into a zero-knowledge proof based on VOLE (§ 2.2), this ensures that the resulting protocol also has constant memory, since each AssertZero can be checked on-the-fly.</p>

    <p class="text-gray-300">Recall that in our protocols for circuit satisfiability, the multiplication gates are all verified in a batch at the end of the computation. This requires storing all commitments created during each multiplication in memory, leading to a memory cost that is linear in the circuit size.</p>

    <p class="text-gray-300">For the more efficient amortized protocol, this drawback seems inherent, however, we can easily avoid it for the simpler protocol from § 4.2, by checking multiplications on-the-fly using an independent random challenge from V for each multiplication. The change is very simple, and for completeness, shown in the modified multiplication sub-protocol below.</p>

    <p class="text-gray-300">Streaming Mult<span class="math">([x_{i}],[y_{i}])</span>: To evaluate the <span class="math">i</span>-th multiplication gate:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run Random<span class="math">(\\mathbb{F}_{p})</span> to get <span class="math">[r_{i}]</span> and Random<span class="math">(\\mathbb{F}_{p^{k}})</span> to get <span class="math">[r^{\\prime}_{i}],[a_{i}]</span>.</li>

      <li>Run Fix<span class="math">(x_{i}y_{i})\\to[z_{i}]</span>, and Fix<span class="math">(a_{i}y_{i})\\to[c_{i}]</span>.</li>

      <li>Run Send<span class="math">{}_{[\\mathsf{V}\\to\\mathsf{P}]}(e_{i}\\leftarrow\\mathbb{F}_{p^{k}})</span>.</li>

      <li>Run Reveal<span class="math">([\\varepsilon])</span>, where <span class="math">[\\varepsilon]=e_{i}[x_{i}]-[a_{i}]</span>.</li>

      <li>Run AssertZero<span class="math">(e_{i}[z_{i}]-[c_{i}]-\\varepsilon_{i}[y_{i}])</span>.</li>

    </ol>

    <p class="text-gray-300">For the soundness of this protocol, following the exact same analysis as in § 4.2, we get a soundness error of <span class="math">p^{-k}</span>, due to the random choice of each challenge <span class="math">e_{i}</span>. In § 5.3, we show that this protocol also satisfies <em>round-by-round soundness</em>, implying that it can be made non-interactive using Fiat-Shamir.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.2 Batching AssertZero with Constant Memory</h3>

    <p class="text-gray-300">Recall from § 2 that often, it is useful to combine all the AssertZero statements (that is, linear oracle queries) of an IP with LOVe into just one check, by batching them together at the end. However, just as with our original circuit evaluation protocol, this is not amenable to constant memory for streaming algorithms. Instead, in Figure 5 we give an alternative transformation, which transforms any C&P IP with LOVe <span class="math">\\Pi_{\\mathsf{LOVe}}</span> to have just one AssertZero, <em>without</em> storing all intermediate values.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 5: The transformation to batch AssertZero in a streamable manner.</p>

    <p class="text-gray-300">The idea is that, instead of taking a combination of all AssertZero's at the end, we can compute this combination in an incremental manner. At each AssertZero on input  <span class="math">[\\gamma]</span> , we take a random challenge  <span class="math">e</span>  and add  <span class="math">e \\cdot [\\gamma]</span>  to a running state  <span class="math">[z]</span> . At the end of the computation, to verify that all the  <span class="math">\\gamma</span>  values were zero, we simply run AssertZero on  <span class="math">[z]</span> . Since the challenge  <span class="math">e</span>  is only sampled after the value being checked for zero was committed, it holds from the argument for the batching method from §2 that cheating in this check requires guessing a random challenge, so this transformation only increases the soundness error by  <span class="math">p^{-k}</span> .</p>

    <p class="text-gray-300">The intuition behind the definition of Round-by-round soundness is that in any given round of a protocol  <span class="math">\\Pi</span> , one can define a function State, which, given the current transcript of  <span class="math">\\Pi</span> , outputs a bit indicating whether  <span class="math">\\Pi</span> 's execution will fail. We require that, if State predicts failure in some round  <span class="math">i</span> , then State also predicts failure in round  <span class="math">i + 1</span> , with high probability over the verifier's random challenge.</p>

    <p class="text-gray-300">Previously, round-by-round soundness has been defined for standard interactive proofs  <span class="math">\\left[\\mathrm{CCH}^{+}19\\right]</span> , without any form of oracle queries. Below is our modified definition, tailored to IPs with LOVe. Note that unlike the Zero Knowledge setting, where State's inputs are publicly known, here we give the State function also the oracle string  <span class="math">\\pi</span>  as input; without this, there would be no easy way for the State algorithm to simulate whether a given oracle query to  <span class="math">\\pi</span>  would succeed or not. Note also that since we assume  <span class="math">\\Pi</span>  is public-coin, the oracle query inputs  <span class="math">(z,y)</span>  are all computable given the complete transcript, so they are also known to State.</p>

    <p class="text-gray-300">Definition 7. Let  <span class="math">\\Pi</span>  be a  <span class="math">t</span> -round, public-coin IP-LOVe for a relation  <span class="math">\\mathcal{R}</span> . We say that  <span class="math">\\Pi</span>  has round-by-round soundness error  <span class="math">\\epsilon</span>  if there exists a deterministic (not necessarily efficient) function State that takes input an instance  <span class="math">x</span> , proof  <span class="math">\\pi</span>  and partial transcript  <span class="math">\\mathcal{T}</span> , and outputs accept or reject, such that the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">x \\notin L</span> , then  <span class="math">\\operatorname{State}(x, \\pi, \\emptyset) = \\operatorname{reject}</span> .</li>

      <li>If  <span class="math">\\operatorname{State}(x, \\pi, \\mathcal{T}) = \\operatorname{reject}</span>  for a partial transcript  <span class="math">\\mathcal{T}</span>  up to round  <span class="math">h \\in [t]</span> , then for every potential prover message  <span class="math">\\mathbf{a}_h</span> ,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\bm{e}_{h+1}\\leftarrow\\mathbb{F}^{\\ell}_{h+1}}[\\mathsf{State}(x,\\bm{\\pi},\\mathcal{T}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{h}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{h+1})=\\mathsf{accept}]\\leq\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any halting transcript <span class="math">\\mathcal{T}</span>, if <span class="math">\\mathsf{State}(x,\\bm{\\pi},\\mathcal{T})=\\mathsf{reject}</span> then <span class="math">\\mathsf{V}</span> rejects.</li>

    </ol>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Round-by-round soundness of our protocols for circuit satisfiability.</h4>

    <p class="text-gray-300">In § F, we show that our IPs with LOVe for circuit satisfiability, including the streamable protocol from § 5.1–5.2, and the efficient batched multiplication protocol from § 4.3 satisfy round-by-round soundness. We also show that the same holds for our stacking protocol from § 3.</p>

    <p class="text-gray-300">Roughly speaking, for our circuit satisfiability protocol, the <span class="math">\\mathsf{State}</span> algorithm takes as input the proof string <span class="math">\\pi</span>, so can immediately extract the witness and try to verify whether the statement is true. In later rounds, <span class="math">\\mathsf{State}</span> also checks whether the prover’s messages are inconsistent with <span class="math">\\pi</span> and the verifier’s challenges, and changes to <span class="math">\\mathsf{reject}</span> if so. A similar strategy works in all our protocols to show that round-by-round soundness holds.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Soundness of Fiat-Shamir for IPs with LOVe.</h4>

    <p class="text-gray-300">We now show that the Fiat-Shamir transformation, when applied to a zero-knowledge proof built from VOLE and an IP with LOVe, is sound if the underlying IP with LOVe satisfies round-by-round soundness.</p>

    <p class="text-gray-300">For this, we follow the VOLE-based protocol from § 2.2, while replacing the verifier’s random challenges with outputs of a random oracle. We use a slightly augmented VOLE functionality, denoted <span class="math">\\mathcal{F}_{\\mathsf{VOLE+id}}</span>, which additionally samples a random identifier <span class="math">\\mathsf{id}\\in\\{0,1\\}^{\\lambda}</span>, and gives this to both parties after receiving their input. We feed this into the random oracle, which binds the statement and proof to this instance. The result we obtain is similar to the FS transform for interactive oracle proofs <em>[x1]</em>, with the differences that (1) we start from IPs with LOVe using VOLE preprocessing, and (2) we assume round-by-round soundness, which is a stronger property than state-restoration soundness from <em>[x1]</em>, but we find it simpler to work with. We prove the following theorem in § F.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathsf{LOVe}}</span> be a <span class="math">t</span>-round, 1-query, public-coin <span class="math">\\mathsf{IP}</span>-<span class="math">\\mathsf{LOVe}</span> for relation <span class="math">\\mathcal{R}</span> with round-by-round soundness <span class="math">\\epsilon</span>, which is also complete and zero-knowledge. Then, the compiled protocol <span class="math">\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}</span> in Figure 6 is a non-interactive zero-knowledge proof in the <span class="math">\\mathcal{F}_{\\mathsf{VOLE+id}}</span>-hybrid model, with soundness error at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p^{-k}+\\epsilon t+Q(\\epsilon+2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2^{-\\lambda})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">Q</span> is the number of random oracle queries made by a malicious prover, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the smallest challenge set in any given round of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, if <span class="math">\\Pi_{\\mathsf{LOVe}}</span> is a proof of knowledge, then so is <span class="math">\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}</span>.</p>

    <h2 id="sec-41" class="text-2xl font-bold">6 Implementation and Evaluation</h2>

    <p class="text-gray-300">We have implemented the online protocol of <span class="math">\\mathsf{Mac}^{\\prime}\\mathsf{n}^{\\prime}\\mathsf{Cheese}</span> with the batched multiplication approach of § 4.3 in the Rust programming language. Our implementation achieves a computational security of 128 bits and a statistical security of <span class="math">\\geq 40</span> bits. Our implementation supports pluggable VOLE backends. The backend that we use, at present, is a “dummy” backend which (insecurely) generates random MACs by using a pre-shared seed with a PRNG.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 6: NIZK from VOLE and IP with LOVe.</p>

    <p class="text-gray-300">Streaming. To facilitate streaming, our implementation does not view its input as an explicit circuit graph. Instead, the proof statement is lazily built-up by a series of function invocations. As a result, we get reduced memory consumption (for free) as temporary values get automatically freed when they are no longer in-scope. In order to stream a two-way disjunction, both branches of the disjunction must be interleaved (otherwise the prover would be forced to either buffer the entirety of a branch, or reveal which branch is 'true'). To achieve this interleaving, we leverage stackful coroutines to (cheaply) concurrently execute both branches.</p>

    <p class="text-gray-300">Concurrency. Despite running a multi-round interactive protocol (without extensive use of the Fiat-Shamir transform), we are still able to achieve high-performance even over a high-latency, throughput-limited network link. We reach this result by running one thread which exclusively sends data from the prover to the verifier to Fix MACs to prover-private values. Once this thread has Fixed a batch of MACs, it submits them to one of many background threads to verify the assertions on these MACs. Each background thread has its own unique connection between the prover and the verifier, so can independently wait for a response from the other party. As a result, we can provision a large number of background threads (which will spend most of their time waiting for the network, rather than running computation) to mitigate the latency effects of running our multi-round protocol over a network. In addition, this design allows us to leverage multiple cores independent of the circuit structure.</p>

    <p class="text-gray-300">6.1 Evaluation</p>

    <p class="text-gray-300">We benchmarked our implementation for <span class="math">\\mathbb{F}_{2^{40}}</span> (for boolean circuits) and <span class="math">\\mathbb{F}_{2^{61}-1}</span> (for arithmetic circuits). Unless otherwise specified, all benchmarks were run between two machines: a laptop (2018 MacBook Pro with 8 logical cores and 16 GB of RAM) on the east coast of the U.S., and a server (40 Intel Xeon Silver 4114 cores operating at 2.20 GHz) on the west coast of the U.S. The network had an average latency of 95 ms and an average bandwidth of 31.5 Mbps. All numbers are the average of at least four runs of the given experiment.</p>

    <p class="text-gray-300">As noted above, these results <em>do not</em> include the cost of VOLE. We are in the process of integrating the VOLE protocol of Weng et al. <em>[x22]</em>, but do not believe this will have a large impact on the overall running time and communication cost given that a single VOLE for <span class="math">\\mathbb{F}_{2^{61}-1}</span> can be generated in 85 ns at a communication cost of 0.42 bits <em>[x22, Table 4]</em>, and can be largely precomputed.</p>

    <p class="text-gray-300">As mentioned above, our implementation is multi-threaded, and in order to reduce communication latency we pipeline processing as much as possible. We use 50 threads for all of our experiments, although we note that the CPU utilization on both the prover and verifier never exceeds 226% (where the maximum possible utilization is the number of cores times 100%). We reiterate that our verifier was run on a commodity laptop, and while we use a large number of threads, this does <em>not</em> equate to extremely high CPU utilization.</p>

    <h5 id="sec-42" class="text-base font-semibold mt-4">Microbenchmarks.</h5>

    <p class="text-gray-300">Using a multiplication batch size of <span class="math">1\\,000\\,000</span>, Mac’n’Cheese achieves a per multiplication cost of approximately 144 ns for <span class="math">\\mathbb{F}_{2^{40}}</span> and 1.5 <span class="math">\\mu</span>s for <span class="math">\\mathbb{F}_{2^{61}-1}</span>. This equates to 6.9 million multiplications per second (mmps) for <span class="math">\\mathbb{F}_{2^{40}}</span>, and 0.6 mmps for <span class="math">\\mathbb{F}_{2^{61}-1}</span>. We found that the main limiter in the arithmetic case was bandwidth, and thus also ran our microbenchmarks locally (run on the Location B server), achieving a per multiplication cost of 141 ns (7.0 mmps) for <span class="math">\\mathbb{F}_{2^{40}}</span> and 276 ns (3.6 mmps) for <span class="math">\\mathbb{F}_{2^{61}-1}</span>.</p>

    <p class="text-gray-300"><em>Comparison to QuickSilver</em>. We briefly compare to QuickSilver <em>[x23]</em>. Recall that QuickSilver requires only a single field element per multiplication and requires only 3 rounds (cf. Table 1), but does not support communication-optimized disjunctions. When run on localhost within an Amazon EC2 instance, QuickSilver achieves 7.6 mmps for boolean and 4.8 mmps for arithmetic when utilizing 1 thread, and 15.8 mmps for boolean and 8.9 mmps for arithmetic when utilizing 4 threads <em>[x23, Table 2]</em>. While it is hard to make an apples-to-apples comparison here, this does suggest that QuickSilver is slightly faster, albeit at the expense of communication-optimized disjunctions. Thus, the choice of QuickSilver versus Mac’n’Cheese may come down to the characteristics of the input circuit.</p>

    <h5 id="sec-43" class="text-base font-semibold mt-4">Disjunctions.</h5>

    <p class="text-gray-300">We also explored the effect our disjunction optimization has on the communication cost. We did so by comparing a proof of a boolean circuit containing 1 billion multiplication gates to using a boolean circuit containing two or more branches each containing 1 billion gates. See Table 2 for the results.</p>

    <p class="text-gray-300">The overall communication in all cases was essentially 124 MB: the OR proof added only an additional <span class="math">25\\log(m)</span> bytes, where <span class="math">m</span> denotes the number of branches. In terms of overall running</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Branches</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Local (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (seconds)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comm. Increase (bytes)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">139</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">307</td>

            <td class="px-3 py-2 border-b border-gray-700">+25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">568</td>

            <td class="px-3 py-2 border-b border-gray-700">+50</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

            <td class="px-3 py-2 border-b border-gray-700">1254</td>

            <td class="px-3 py-2 border-b border-gray-700">+75</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Performance results for disjunctions. The "Branches" column denotes the number of branches, where each branch contains 1 billion AND gates. The "Local" column denotes the time to locally compute the circuit in-the-clear, and provides a rough lower bound of performance. The "Verify" column denotes the time to verify the ZK proof. The "Comm. Increase" column denotes the amount of communication increase from the baseline of 124 MB required in the single-branch case.</p>

    <p class="text-gray-300">time, we see an increase with the overall size of the circuit. This is due to the fact that the prover still needs to do the entire computation, and for this particular example bandwidth is not the bottleneck. The table also reports the time required to simply evaluate the circuit locally—this presents a reasonable lower bound for Mac'n'Cheese. We find that in all cases, Mac'n'Cheese takes less than  <span class="math">4.08 \\times</span>  the cost of locally evaluating the circuit.</p>

    <p class="text-gray-300">This material is based upon work supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0085. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Defense Advanced Research Projects Agency (DARPA). Distribution Statement "A" (Approved for Public Release, Distribution Unlimited).</p>

    <p class="text-gray-300">[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In ACM CCS 2017. ACM Press, October / November 2017. <span class="math">\\left[\\mathrm{BBC}^{+}19\\right]</span>  Dan Boneh, Elette Boyle, Henry Corrigan-Gibbs, Niv Gilboa, and Yuval Ishai. Zero-knowledge proofs on secret-shared data via fully linear PCPs. In CRYPTO 2019, Part III, LNCS. Springer, Heidelberg, August 2019. [BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In CRYPTO 2019, Part III, LNCS. Springer, Heidelberg, August 2019. <span class="math">\\left[\\mathrm{BCG}^{+}13\\right]</span>  Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO 2013, Part II, LNCS. Springer, Heidelberg, August 2013. <span class="math">\\left[\\mathrm{BCG}^{+}14\\right]</span>  Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from</p>

    <p class="text-gray-300">bitcoin. In 2014 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}19a] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Peter Rindal, and Peter Scholl. Efficient two-round OT extension and silent non-interactive secure computation. In ACM CCS 2019, November 2019.</li>

      <li>[BCG^{+}19b] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Efficient pseudorandom correlation generators: Silent OT extension and more. In CRYPTO 2019, Part III. Springer, Heidelberg, August 2019.</li>

      <li>[BCG^{+}20] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, and Peter Scholl. Correlated pseudorandom functions from variable-density LPN. In 61st FOCS. IEEE Computer Society Press, November 2020.</li>

      <li>[BCGI18] Elette Boyle, Geoffroy Couteau, Niv Gilboa, and Yuval Ishai. Compressing vector OLE. In ACM CCS 2018. ACM Press, October 2018.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In TCC 2016-B, Part II. Springer, Heidelberg, October / November 2016.</li>

      <li>[Bea92] Donald Beaver. Efficient multiparty protocols using circuit randomization. In CRYPTO’91, LNCS. Springer, Heidelberg, August 1992.</li>

      <li>[BG90] Mihir Bellare and Shafi Goldwasser. New paradigms for digital signatures and message authentication based on non-interative zero knowledge proofs. In CRYPTO’89, LNCS. Springer, Heidelberg, August 1990.</li>

      <li>[BMN18] Alexander R. Block, Hemanta K. Maji, and Hai H. Nguyen. Secure computation with constant communication overhead using multiplication embeddings. In INDOCRYPT 2018. Springer, Heidelberg, December 2018.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In 51st ACM STOC. ACM Press, June 2019.</li>

      <li>[CCXY18] Ignacio Cascudo, Ronald Cramer, Chaoping Xing, and Chen Yuan. Amortized complexity of information-theoretically secure MPC revisited. In CRYPTO 2018, Part III. Springer, Heidelberg, August 2018.</li>

      <li>[CD97] Ronald Cramer and Ivan Damgård. Linear zero-knowledge - a note on efficient zero-knowledge proofs and arguments. In 29th ACM STOC, May 1997.</li>

      <li>[CD98] Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In CRYPTO’98, LNCS. Springer, Heidelberg, August 1998.</li>

      <li>[CDS94] Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO’94, LNCS. Springer, Heidelberg, August 1994.</li>

    </ul>

    <p class="text-gray-300">[DIO21] Samuel Dittmer, Yuval Ishai, and Rafail Ostrovsky. Line-point zero knowledge and its applications. In Information-Theoretic Cryptography (ITC) 2021, 2021. https://eprint.iacr.org/2020/1446.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[dSGOT21] Cyprien Delpech de Saint Guilhem, Emmanuela Orsini, and Titouan Tanguy. Limbo: Efficient zero-knowledge MPCitH-based arguments. Cryptology ePrint Archive, Report 2021/215, 2021.</li>

      <li>[FNO15] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In EUROCRYPT 2015, Part II, LNCS. Springer, Heidelberg, April 2015.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO’86, LNCS. Springer, Heidelberg, August 1987.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In 19th ACM STOC. ACM Press, May 1987.</li>

      <li>[HK20a] David Heath and Vladimir Kolesnikov. Stacked garbling - garbled circuit proportional to longest execution path. In CRYPTO 2020, Part II, LNCS. Springer, Heidelberg, August 2020.</li>

      <li>[HK20b] David Heath and Vladimir Kolesnikov. Stacked garbling for disjunctive zero-knowledge proofs. In EUROCRYPT 2020, Part III, LNCS. Springer, Heidelberg, May 2020.</li>

      <li>[JKO13] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In ACM CCS 2013. ACM Press, November 2013.</li>

      <li>[Kol18] Vladimir Kolesnikov. Free IF: How to omit inactive branches and implement <span class="math">S</span>-universal garbled circuit (almost) for free. In ASIACRYPT 2018, Part III, LNCS. Springer, Heidelberg, December 2018.</li>

      <li>[KOS16] Marcel Keller, Emmanuela Orsini, and Peter Scholl. MASCOT: Faster malicious arithmetic secure computation with oblivious transfer. In ACM CCS 2016. ACM Press, October 2016.</li>

      <li>[WYKW20] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. Wolverine: Fast, scalable, and communication-efficient zero-knowledge proofs for boolean and arithmetic circuits. Cryptology ePrint Archive, Report 2020/925, 2020. https://eprint.iacr.org/2020/925.</li>

      <li>[YSWW21] Kang Yang, Pratik Sarkar, Chenkai Weng, and Xiao Wang. Quicksilver: Efficient and affordable zero-knowledge proofs for circuits and polynomials over any field. Cryptology ePrint Archive, Report 2021/076, 2021.</li>

      <li>[ZRE15] Samee Zahur, Mike Rosulek, and David Evans. Two halves make a whole - reducing data transfer in garbled circuits using half gates. In EUROCRYPT 2015, Part II, LNCS. Springer, Heidelberg, April 2015.</li>

    </ul>

    <p class="text-gray-300">A Definition for Honest-verifier Zero-knowledge Proofs of Knowledge</p>

    <p class="text-gray-300">We recap the (standard) definitions for honest-verifier zero-knowledge proofs of knowledge.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">An interactive protocol <span class="math">\\Pi</span> between two interactive probabilistic polynomial-time (PPT, in the security parameter) Turing machines <span class="math">\\mathsf{P},\\mathsf{V}</span> is called an <em>honest-verifier zero-knowledge interactive proof</em> (HVZK proof) for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span> if it satisfies the following three properties:</p>

    <p class="text-gray-300">For all <span class="math">(x,w)\\in\\mathcal{R}</span> the interaction between <span class="math">\\mathsf{P}(x,w)</span> and <span class="math">\\mathsf{V}(x)</span> is accepting, i.e. <span class="math">\\mathsf{V}</span> outputs <span class="math">1</span>. For all <span class="math">x\\not\\in L(\\mathcal{R})</span> and for all PPT algorithms <span class="math">\\mathsf{P}^{<em>}</span>, any interaction of <span class="math">\\mathsf{P}^{</em>}</span> with <span class="math">\\mathsf{V}(x)</span> is accepting with probability at most <span class="math">\\epsilon</span>. There exists a PPT algorithm <span class="math">S</span> such that for any <span class="math">(x,w)\\in\\mathcal{R}</span> the output of <span class="math">S(x)</span> is indistinguishable from <span class="math">\\mathsf{View}_{V}[\\mathsf{P}(x,w)\\leftrightarrow\\mathsf{V}(x)]</span> for any honest <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">If <span class="math">S(x)</span> and <span class="math">\\mathsf{View}_{V}[\\mathsf{P}(x,w)\\leftrightarrow\\mathsf{V}(x)]</span> have the identical distribution then the proof is called perfectly zero-knowledge. If the statistical distance between both distributions is negligible in the security parameter then it is called statistical zero-knowledge. If both distributions are indistinguishable to any PPT algorithm then it is called computational zero-knowledge.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 9 (HVZK Proof of Knowledge).</h6>

    <p class="text-gray-300">An HVZK interactive proof <span class="math">\\Pi</span> is a <em>proof of knowledge</em> if for any prover <span class="math">\\mathsf{P}^{<em>}</span> that makes the verifier accept with probability <span class="math">&gt;\\epsilon</span> for a statement <span class="math">x</span> there exists a PPT extractor <span class="math">\\mathsf{E}</span> that, using black-box access to <span class="math">\\mathsf{P}^{</em>}</span>, outputs a witness <span class="math">w</span> such that <span class="math">(x,w)\\in\\mathcal{R}</span>.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Appendix B Proof of Theorem 1</h2>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem (Theorem 1, restated).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\Pi_{\\mathsf{LOVe}}</span> is a public-coin <span class="math">\\mathsf{IP}</span>-<span class="math">\\mathsf{LOVe}</span> for relation <span class="math">\\mathcal{R}</span>, satisfying completeness, soudness error <span class="math">\\epsilon</span> and honest-verifier zero-knowledge. Then, <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span> is an honest-verifier zero-knowledge proof for relation <span class="math">\\mathcal{R}</span>, with soundness error <span class="math">\\epsilon+p^{-k}</span>. Furthermore, if <span class="math">\\Pi_{\\mathsf{LOVe}}</span> is a proof of knowledge, then so is <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows immediately from the completeness of <span class="math">\\Pi_{\\mathsf{LOVe}}</span>, and the linear properties of the VOLE-based commitments. For soundness, consider a cheating prover <span class="math">\\mathsf{P}^{<em>}</span> who manages to prove an incorrect statement in <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span> with probability <span class="math">\\epsilon^{</em>}</span>. We can turn <span class="math">\\mathsf{P}^{*}</span> into an adversary for the soundness of <span class="math">\\Pi_{\\mathsf{LOVe}}</span>. The only difference in the two executions, is that in <span class="math">\\Pi_{\\mathsf{LOVe}}</span> there is no possibility to cheat during the query phase, whereas in <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span>, passing an incorrect query can happen by guessing the MAC key, with probability <span class="math">p^{-k}</span>. We therefore have,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Pr}[\\mathsf{V}\\text{ outputs }1\\text{ in }\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}]-\\text{Pr}[\\mathsf{V}\\text{ outputs }1\\text{ in }\\Pi_{\\mathsf{CP}}^{\\mathsf{LOVe}}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq p^{-k}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">\\Pi_{\\mathsf{LOVe}}</span> has soundness error <span class="math">\\epsilon</span>, we conclude that <span class="math">\\Pi_{\\mathsf{ZK}}^{\\mathsf{VOLE}}</span> has soundness error at most <span class="math">\\epsilon+p^{-k}</span>.</p>

    <p class="text-gray-300">For the zero-knowledge property, the simulator picks <span class="math">d_{i}</span> uniformly at random, and then runs the HVZK simulator <span class="math">S</span> for <span class="math">\\Pi_{\\mathsf{LOVe}}</span>. Since <span class="math">d_{i}=\\bm{r}[i]-\\bm{\\pi}[i]</span>, where <span class="math">\\bm{r}[i]</span> is uniform in <span class="math">\\mathbb{F}_{p^{k}}</span> for an honest prover, indistinguishability of the simulation follows from that of <span class="math">\\Pi_{\\mathsf{LOVe}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Finally, for the proof of knowledge property, observe that in <span class="math">\\Pi^{\\mathsf{VOLE}}_{\\mathsf{ZK}}</span>, the extractor can simulate <span class="math">\\mathcal{F}_{\\mathsf{VOLE}}</span>, and so extract all of the random values <span class="math">\\bm{r}</span>. This corresponds to knowing the entire proof string <span class="math">\\bm{\\pi}</span> in the underlying IP with LOVe, so we can run the same extraction algorithm as for <span class="math">\\Pi_{\\mathsf{LOVe}}</span>. ∎</p>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix C Proof of Lemma 1</h2>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first prove honest-verifier zero-knowledge by constructing a simulator <span class="math">\\mathcal{S}</span> as required. <span class="math">\\mathcal{S}</span> on input the statement <span class="math">x</span> simulates the interaction in <span class="math">\\Pi</span> by sending random field elements to <span class="math">\\mathsf{V}</span>, for every message sent by <span class="math">\\mathsf{P}</span>. Finally, for each oracle query <span class="math">(\\bm{z},y)</span> made by <span class="math">\\mathsf{V}</span>, <span class="math">\\mathcal{S}</span> reports that the query succeeds. It is easy to see that <span class="math">\\mathcal{S}</span> is perfectly indistinguishable from <span class="math">\\texttt{View}_{V}[\\mathsf{P}(x,\\bm{w})\\leftrightarrow\\mathsf{V}(x)]</span> for an honest <span class="math">\\mathsf{V}</span>, because (1) the prover’s messages are uniformly random in both executions, and (2) since <span class="math">\\Pi</span> is complete, all oracle queries would succeed in an honest execution, hence, <span class="math">\\mathcal{S}</span> simulates them faithfully.</p>

    <p class="text-gray-300">We next argue that for <span class="math">m</span> protocols <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span>, where each <span class="math">\\Pi_{i}</span> is proving some relation <span class="math">\\mathcal{R}_{i}</span>, the collection <span class="math">(\\Pi_{1},\\ldots,\\Pi_{m})</span> is equisimulatable. We first need to give an algorithm <span class="math">\\mathcal{CP}</span>, which on input an index <span class="math">i</span>, round number <span class="math">h</span> and prover message <span class="math">\\bm{a}_{h}</span> from an execution of <span class="math">\\Pi_{i}</span>, outputs the ‘combined prover’ message <span class="math">\\bm{a}^{\\prime}</span>; our algorithm simply extends <span class="math">\\bm{a}_{h}</span> to the maximum length of the prover’s round-<span class="math">h</span> message in any <span class="math">\\{\\Pi_{j}\\}_{j}</span>, by padding with random field elements.</p>

    <p class="text-gray-300">Since the prover’s messages are all uniformly random, it is clear that for any two indices <span class="math">i,i^{\\prime}</span>, the output of <span class="math">\\mathcal{CP}</span> on a message <span class="math">\\bm{a}_{h}</span> from <span class="math">\\Pi_{i}</span> is identically distributed to its output given <span class="math">\\bm{a}_{h}</span> from <span class="math">\\Pi_{i^{\\prime}}</span>, which implies the second property of Definition 5.</p>

    <p class="text-gray-300">Next, we need to specify a decoding algorithm <span class="math">\\mathtt{dec}</span> for the verifier, which allows it to extract the correct message <span class="math">\\bm{a}_{h}</span> from the <span class="math">\\mathcal{CP}</span> output, given the index <span class="math">i</span>. Since the length of <span class="math">\\bm{a}_{h}</span> in <span class="math">\\Pi_{i}</span> is fixed, <span class="math">\\mathtt{dec}</span> simply truncates its input to the correct length, which clearly gives the correct result. ∎</p>

    <h2 id="sec-53" class="text-2xl font-bold">Appendix D More Details on Stacking</h2>

    <p class="text-gray-300">In this section we give the proof of our first stacking construction, and then describe the details for how to perform <em>threshold stacking</em>, and finally give a full construction and proof for the <em>recursive stacking</em> approach.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">D.1 Proof of Theorem 2</h3>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We show that Definition 2, Definition 3 and Definition 4 are fulfilled.</p>

    <p class="text-gray-300">Completeness. Assume that, as stated in the protocol, <span class="math">(x_{i^{<em>}},\\bm{w}_{i^{</em>}})\\in\\mathcal{R}_{i^{<em>}}</span>. This means that the protocol will indeed run for <span class="math">t</span> rounds without abort, as <span class="math">\\mathsf{P}</span> runs <span class="math">\\Pi_{i^{</em>}}</span> and a simulated continuation in Step 2, which are both well-defined, and because <span class="math">\\mathsf{V}</span> runs a <span class="math">t</span>-round protocol that is agnostic of the messages received from <span class="math">\\mathsf{P}</span> until this point. For the queries, we observe that if <span class="math">\\bm{\\pi},f_{i},d_{i},\\bm{z}_{i},y_{i},\\beta_{i}</span> are chosen as in the protocol, then for <span class="math">i\\neq i^{*}</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\bm{\\pi},\\bm{z}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}\\rangle<span class="math"> </span>=\\langle\\bm{\\pi}^{\\prime},\\bm{z}_{i}\\rangle+\\langle r_{1}\\cdots r_{m},\\beta_{i}\\rangle=\\langle\\bm{\\pi}^{\\prime},\\bm{z}_{i}\\rangle+f_{i}r_{i}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\langle\\bm{\\pi}^{\\prime},\\bm{z}_{i}\\rangle+f_{i}(d_{i}-(\\langle\\bm{\\pi}^{\\prime},\\bm{z}_{i}\\rangle-y_{i})/f_{i})</span> <span class="math">=y_{i}+f_{i}d_{i}</span></p>

    <p class="text-gray-300">where the penultimate step follows from the definition of <span class="math">d_{i}</span>. For the <span class="math">i^{*}</span>-th instance, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\boldsymbol{\\pi},\\boldsymbol{z}_{i^{*}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i^{<em>}}\\rangle=y_{i^{</em>}}+f_{i^{<em>}}r_{i^{</em>}}=y_{i^{<em>}}+f_{i^{</em>}}d_{i^{*}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The round, oracle, query and message complexity can be obtained from the definition of the protocol.</p>

    <p class="text-gray-300">Soundness. For the sake of notation we separate the messages sent in <span class="math">\\Pi_{\\sf OR}</span> into two phases. The messages sent in Step 2 are considered as Phase 1 while those exchanged in Step 3 or thereafter are considered Phase 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a setting where we would perform the regular IP-LOVe-queries for each of the <span class="math">m</span> statements after Phase 1. This would mean that we ran <span class="math">\\Pi_{\\sf OR}</span> without the OR-proof in the end. If we look at all messages sent during Phase 1, then if none of the <span class="math">m</span> statements are true, we have that for each <span class="math">i\\in[m]</span> at least one verification query must fail, except with probability <span class="math">\\sum_{i\\in[m]}\\epsilon_{i}</span>. This can be seen as follows: in the worst case, an <span class="math">\\epsilon_{1}</span>-fraction of all Phase 1 challenges by <span class="math">\\mathsf{V}</span> will lead to all oracle queries related to the IP-LOVe for <span class="math">x_{1}</span> being true, as <span class="math">\\Pi_{1}</span> has soundness error <span class="math">\\epsilon_{1}</span>. The same can be said about all other <span class="math">m-1</span> proofs, and in the worst case the transcripts on which they successfully finish are distinct. Hence if all statements are false, we know that when entering Phase 2, with probability at least <span class="math">1-\\sum_{i\\in[m]}\\epsilon_{i}</span>, all oracle queries in the sub-protocols must be false, that is, for all <span class="math">i\\in[m]</span>, $\\langle\\boldsymbol{\\pi}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\ell_{i}},\\boldsymbol{z}_{i}\\rangle\\neq y_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this case, we claim that there is only one choice of the verifier’s challenge <span class="math">f\\in\\mathbb{F}_{p^{k}}</span> that will accept.</p>

    <p class="text-gray-300">Suppose, for a contradiction, that there exist two accepting transcripts of messages that keep all messages of Phase 1 and 2 fixed, except for <span class="math">f</span>, and where <span class="math">\\forall i\\in[m]:\\ \\langle\\boldsymbol{\\pi},\\boldsymbol{z}_{i}\\rangle=y_{i}+\\Delta_{i}</span> for some non-zero <span class="math">\\Delta_{i}</span> by assumption. The two accepting transcripts have <span class="math">f,\\hat{f}</span> as messages by <span class="math">\\mathsf{V}</span>. Furthermore, this means there exists an index <span class="math">i</span> with two different <span class="math">f_{i},\\hat{f}_{i}</span>, since the <span class="math">f_{i}</span> form shares of <span class="math">f</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It must hold that $\\langle\\boldsymbol{\\pi},\\boldsymbol{z}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}\\rangle=y_{i}+f_{i}d_{i}<span class="math"> and </span>\\langle\\boldsymbol{\\pi},\\boldsymbol{z}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\beta}_{i}\\rangle=y_{i}+\\hat{f}_{i}d_{i}<span class="math">. </span>\\beta_{i}<span class="math"> is by definition 0 everywhere except at one point, where it is </span>f_{i}<span class="math"> (and similarly </span>\\hat{\\beta}_{i}<span class="math">). So we can write these two equalities as </span>y_{i}+\\Delta_{i}+r_{i}f_{i}=y_{i}+f_{i}d_{i}<span class="math"> and </span>y_{i}+\\Delta_{i}+r_{i}\\hat{f}_{i}=y_{i}+\\hat{f}_{i}d_{i}<span class="math">, where </span>r_{i}<span class="math"> is the value from </span>\\boldsymbol{\\pi}<span class="math"> that both </span>\\beta_{i},\\hat{\\beta}_{i}<span class="math"> select. Therefore, </span>\\Delta_{i}=f_{i}(d_{i}-r_{i})=\\hat{f}_{i}(d_{i}-r_{i})<span class="math">. Since </span>f_{i}\\neq\\hat{f_{i}}<span class="math"> this can only be fulfilled if </span>d_{i}=r_{i}<span class="math">. However, from the fact that the oracle query succeeds, this would imply </span>\\Delta_{i}=0$, contradicting the assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A cheating <span class="math">\\mathsf{P}</span> would, by the argument above, have to hit the <span class="math">\\sum\\epsilon_{i}</span>-fraction of Phase 1-challenges that make the queries accept, or otherwise can only answer one choice of <span class="math">f\\in\\mathbb{F}_{p^{k}}</span>. By a union bound, the cheating probability is at most <span class="math">\\sum_{i\\in[m]}\\epsilon_{i}+1/p^{k}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Knowledge. By the previous argument on the soundness, if the success probability of <span class="math">\\mathsf{P}</span> is <span class="math">&gt;\\sum_{i\\in[m]}\\epsilon_{i}+1/p^{k}</span>, then for at least one of the <span class="math">m</span> statements, let’s say the <span class="math">i^{<em>}</span>th, the IP-LOVe queries for <span class="math">x_{i^{</em>}}</span> are all accepting with probability <span class="math">&gt;\\epsilon_{i^{<em>}}</span>. Let the accepting proof string be <span class="math">\\boldsymbol{\\pi}</span>, then since <span class="math">\\Pi_{i^{</em>}}</span> is a Proof of Knowledge, there exists an extractor <span class="math">E</span> which on input $\\boldsymbol{\\pi}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\ell_{i^{<em>}}}<span class="math"> must therefore output </span>(x_{i},\\boldsymbol{w}_{i})\\in\\mathcal{R}_{i^{</em>}}<span class="math">. This is because by the construction of </span>\\Pi_{\\sf OR}<span class="math">, all queries of </span>\\Pi_{i^{<em>}}<span class="math"> are made to the first </span>\\ell_{i^{</em>}}<span class="math"> elements of </span>\\boldsymbol{\\pi}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Honest-Verifier Zero-Knowledge. We now construct a simulator <span class="math">\\mathcal{S}</span> for the protocol <span class="math">\\Pi_{\\sf OR}</span> that will, on input <span class="math">x_{1},\\ldots,x_{m}</span>, output a transcript <span class="math">\\tau</span> that is perfectly indistinguishable from a real transcript generated by interacting with an honest <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">Pick a protocol instance <span class="math">\\Pi_{j}</span> at random, run its HVZK simulator <span class="math">\\mathcal{S}_{j}</span> and generate all <span class="math">c_{h}</span> using <span class="math">\\mathcal{CP}</span> as well as <span class="math">\\Pi_{j}</span>. This will be perfectly indistinguishable from any transcript of <span class="math">\\Pi_{i}</span> with <span class="math">i\\neq j</span> by the HVZK property of <span class="math">\\Pi_{j}</span> and the definition of Equisimulatability.</p>

    <p class="text-gray-300">Now fix random values <span class="math">f_{1}, \\ldots, f_{m}</span> and choose all <span class="math">d_{i}</span> uniformly at random. Output <span class="math">d_{i}, f_{i}, f = \\sum_{i \\in [m]} f_{i}</span>. By definition, <span class="math">f</span> is uniformly random and all query responses are accepting. All <span class="math">f_{i}</span> are uniformly random, conditioned on summing up to <span class="math">f</span> as in the protocol. All <span class="math">d_{i}</span> are uniformly random, as in <span class="math">\\Pi_{\\mathsf{OR}}</span> where they are computed from the uniformly random <span class="math">r_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Public Coin.</strong> All challenges sent by <span class="math">\\mathsf{V}</span> are chosen as required in Definition 4: during the <span class="math">t</span> rounds, they are chosen as random strings of sufficient length. The challenge <span class="math">f</span> is also chosen uniformly at random. For each of the queries $(\\pmb{z}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_i,y_i + f_id_i)<span class="math"> the values </span>\\pmb{z}_i<span class="math"> and </span>y_{i}<span class="math"> are chosen deterministically by using </span>\\mathcal{Q}<span class="math"> and applying a deterministic transformation. </span>\\beta_{i}<span class="math"> are determined by </span>f_{1},\\ldots ,f_{m}<span class="math"> that are sent by </span>\\mathsf{P}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-56" class="text-2xl font-bold">D.2 Threshold Stacking</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now describe how to construct a protocol for a higher threshold of true statements. Let <span class="math">S \\subset [m]</span> be the subset of branches that <span class="math">\\mathsf{P}</span> has a witness for and where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= r<span class="math">. We make the following modifications to </span>\\Pi_{\\mathsf{OR}}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the original protocol, <span class="math">\\mathsf{P}</span> in Step 1 creates one string <span class="math">\\pi</span> that is getting sent to the oracle for queries by <span class="math">\\mathsf{V}</span>. This does not work in case of a general threshold <span class="math">r</span>. One solution would be to concatenate <span class="math">m</span> strings <span class="math">\\pi_1, \\ldots, \\pi_m</span> and use the respective substring <span class="math">\\pi_i</span> for the respective oracle queries of <span class="math">\\Pi_i</span>, but this will increase the oracle length by a factor of <span class="math">m</span>. As the oracle length has an impact on practical efficiency (see §2.2), we want to avoid this and will instead use a solution where <span class="math">\\pi</span> essentially scales linearly with <span class="math">r</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can write each <span class="math">\\pi_{i}</span> as having length <span class="math">\\ell = \\max_{i\\in [m]}\\ell_{i}</span> by padding it with 0s. The honest <span class="math">\\mathsf{P}</span> will only have <span class="math">\\pi_i,i\\in S</span> available. We can, for each of the <span class="math">\\ell</span> elements of each <span class="math">\\pi_{i}</span>, define a polynomial <span class="math">\\Pi_{j\\in [\\ell ]}</span> of degree <span class="math">r - 1</span> over <span class="math">\\mathbb{F}_p</span> such that <span class="math">\\Pi_j(i) = \\pi_i[j]</span> for <span class="math">i\\in S</span>. Then, we can place the <span class="math">r</span> coefficients of each <span class="math">\\Pi_{j}</span> in <span class="math">\\pi</span>, which therefore becomes $\\pi = \\Pi_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_1,\\ldots ,r_m<span class="math">. Observe that, as before </span>\\pi<span class="math"> is defined over </span>\\mathbb{F}_p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This requires us to modify how queries to the oracle will be made, but the change is simple. For each query <span class="math">\\langle \\pi_i,\\overline{z}_i\\rangle = ?y_i</span> we instead create the query <span class="math">\\langle \\pi ,\\tilde{z}_i\\rangle = ?y_i</span> where <span class="math">\\tilde{z}_i\\in \\mathbb{F}_{p^k}^{r\\ell}</span>. We will let the first <span class="math">r</span> elements of <span class="math">\\tilde{z}_i</span> consist of <span class="math">[\\overline{z}_i[1],i\\cdot \\overline{z}_i[1],\\ldots ,i^{r - 1}\\overline{z}_i[1]]</span> i.e. of the first element of <span class="math">\\overline{z}_i</span> multiplied with powers of <span class="math">i</span>. Then, the next <span class="math">r</span> elements will consist of <span class="math">\\overline{z}_i[2]</span> multiplied with the same pattern of powers of <span class="math">i</span> etc. The reason for this is that the powers of <span class="math">i</span> will later implicitly compute <span class="math">\\Pi_j(i)</span> and therefore, for the true branches, will reconstruct <span class="math">\\pi_i[j]</span>, such that the same inner product as in a real protocol will be computed.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Step 2, we need to communicate a different message <span class="math">a_{h,i}</span> for each <span class="math">i \\in [m]</span>. This is because we want to execute multiple branches honestly but do not want to reveal which it is that we use. Our solution is as follows: For each round <span class="math">h \\in [t]</span> where <span class="math">\\mathsf{P}</span> sends messages we let <span class="math">A_h(X)</span> be the polynomial of degree <span class="math">r - 1</span> such that <span class="math">\\forall s \\in S : A_h(s) = a_h^s</span>. That means that we create a polynomial that agrees with the correct messages for all valid branches. <span class="math">\\mathsf{V}</span> will later use the interpolation of each <span class="math">A_h(X)</span> at all <span class="math">i \\in [m]</span> to determine the queries that it will issue. This easily also works when the messages <span class="math">a_h</span> are vectors.</li>

    </ol>

    <p class="text-gray-300">32</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One can see Step 3 of <span class="math">\\Pi_{\\texttt{OR}}</span> as P choosing <span class="math">m-1</span> secret shares, where the choice of <span class="math">f</span> later determines the secret and thus the last share. Here, knowing these shares in advance allows P to “lie” in <span class="math">m-1</span> proof instances. For the threshold setting, we can instead let P choose <span class="math">m-r</span> shares <span class="math">f_{i},i\\not\\in S</span> in Step 3 and compute the <span class="math">d_{i}</span>-values accordingly (use e.g. Shamir’s Secret Sharing). Later in Step 4 V sends <span class="math">r</span> challenges <span class="math">f^{(1)},\\ldots,f^{(r)}</span>. P will compute the remaining <span class="math">r</span> shares of <span class="math">f_{i},i\\in S</span> such that the <span class="math">f_{1},\\ldots,f_{m}</span> form a packed secret sharing where <span class="math">f^{(1)},\\ldots,f^{(r)}</span> are the secrets. It then sends all these shares to V who checks that <span class="math">f_{1},\\ldots,f_{m}</span> form a correct secret-sharing of the secrets with threshold <span class="math">m-r</span>.</li>

    </ol>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">D.3 Formalizing Recursive Stacking</h3>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Constructing the basic protocol.</h5>

    <p class="text-gray-300">We construct the base protocol <span class="math">\\Pi_{\\texttt{A-OR}}</span> that shows the relation <span class="math">\\mathcal{R}_{\\texttt{OR}}</span> for two branches in Figure 7. The protocol <span class="math">\\Pi_{\\texttt{A-OR}}</span>, on a high level, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover adds two random <span class="math">\\mathbb{F}_{p^{k}}</span> elements <span class="math">u,v</span> to the string <span class="math">\\bm{\\pi}</span>. These will be used to prove the multiplicative relation used to verify the proof.</li>

      <li>The evaluation of both branches is done in parallel, with the combined prover algorithm, as in <span class="math">\\Pi_{\\texttt{OR}}</span>.</li>

      <li>The prover and verifier both locally compute the oracle query inputs that would be made for the base protocols <span class="math">\\Pi_{1},\\Pi_{2}</span>. The prover computes the query results <span class="math">\\mu_{1},\\mu_{2}</span>, of which one is zero (corresponding to the true branch).</li>

      <li>P commits to the product <span class="math">u\\mu_{2}</span>, by sending it masked with <span class="math">v</span>. This will be used to verify that <span class="math">\\mu_{1}\\mu_{2}=0</span>.</li>

      <li>V responds with a random challenge <span class="math">f</span>, after which P opens <span class="math">\\varepsilon=f\\mu_{1}-u</span>.</li>

      <li>Finally, V wants to verify two statements: firstly, that <span class="math">\\varepsilon</span> was sent correctly, based on the values <span class="math">\\mu_{1},u</span>, which can be derived from the proof string; and secondly, that <span class="math">\\varepsilon\\mu_{2}+u\\mu_{2}=0</span>, since this will guarantee that <span class="math">\\mu_{1}\\mu_{2}=0</span>.</li>

    </ol>

    <p class="text-gray-300">Instead of performing two oracle queries to verify these, V chooses another random challenge <span class="math">f^{\\prime}</span>, which is used to combine these two queries into one query, which concludes the protocol.</p>

    <p class="text-gray-300">The query that V does is deterministic given the transcript. Furthermore, the additional messages that are sent by both P and V appear uniformly random. This will later allow us to recursively construct a proof for more than <span class="math">2</span> branches.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{1},\\Pi_{2}</span> be protocols such that each <span class="math">\\Pi_{i}</span> is a <span class="math">t_{i}</span>-round, 1-query equisimulatable Public Coin IP with LOVe over <span class="math">\\mathbb{F}_{p}</span> for relation <span class="math">\\mathcal{R}_{i}</span> with oracle length <span class="math">\\ell_{i}</span>, message complexity <span class="math">\\alpha_{i}</span> elements of <span class="math">\\mathbb{F}_{p}</span> and soundness error <span class="math">\\epsilon_{i}</span>.</p>

    <p class="text-gray-300">Then the protocol <span class="math">\\Pi_{\\texttt{A-OR}}</span> in Figure 7 is a Public Coin IP with LOVe for the relation <span class="math">\\mathcal{R}_{\\texttt{OR}}</span> over <span class="math">\\mathbb{F}_{p^{k}}</span>, with:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">3+\\max\\{t_{1},t_{2}\\}</span>;</li>

      <li>oracle length <span class="math">2+\\max\\{\\ell_{1},\\ell_{2}\\}</span>;</li>

      <li>query complexity <span class="math">1</span></li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">\\Pi_1, \\Pi_2</span>  be protocols such that each  <span class="math">\\Pi_i</span>  is  <span class="math">t_i</span> -round, 1-query equisimulatable public coin IP with LOVe over  <span class="math">\\mathbb{F}_p</span>  for relation  <span class="math">\\mathcal{R}_i</span>  with oracle length  <span class="math">\\ell_i</span> .</p>

    <p class="text-gray-300">Both  <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  have inputs  <span class="math">x_{1}, x_{2}</span>  where  <span class="math">x_{i} \\in L(\\mathcal{R}_{i})</span> .  <span class="math">\\mathsf{P}</span>  additionally has input  <span class="math">\\boldsymbol{w}_{i^{<em>}}</span>  for (at least) one  <span class="math">i^{</em>} \\in [2]</span>  such that  <span class="math">(x_{i^{<em>}}, \\boldsymbol{w}_{i^{</em>}}) \\in \\mathcal{R}_{i^{*}}</span> . We define  <span class="math">\\ell := \\max \\{\\ell_{1}, \\ell_{2}\\}</span> , and  <span class="math">t := \\max \\{t_{1}, t_{2}\\}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  initially simulates  <span class="math">\\Pi_{i^<em>}</span>  on input  <span class="math">(x_{i^</em>},\\pmb{w}_{i^<em>})</span>  to obtain the string  <span class="math">\\pi_{i^</em>}</span>  and the state  <span class="math">s_0^{\\mathsf{P}}</span> . It then sets</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {\\pi} = \\boldsymbol {\\pi} _ {i ^ {*}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underbrace {0 \\cdots 0} _ {\\ell - \\ell_ {i ^ {*}} \\text {times}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u, v</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">u, v</span>  are chosen uniformly at random in  <span class="math">\\mathbb{F}_{p^k}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">s_0^{\\mathsf{P}} \\coloneqq (x_{i^<em>}, \\boldsymbol{w}_{i^</em>}), s_{t_{i^*}}^{\\mathsf{P}} \\coloneqq \\bot</span> . For  <span class="math">h \\in [t]</span> ,  <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  do the following:</li>

    </ol>

    <p class="text-gray-300">(a) Let  <span class="math">r_h^{\\mathsf{V},i}</span>  be the length of the challenge that  <span class="math">\\mathsf{V}</span>  would send for protocol  <span class="math">\\Pi_i</span>  in round  <span class="math">h</span> .  <span class="math">\\mathsf{V}</span>  sets  <span class="math">r_h = \\max \\{r_{h,1}^{\\mathsf{V}}, r_{h,2}^{\\mathsf{V}}\\}</span> , samples  <span class="math">\\pmb{e}_h \\gets \\mathbb{F}_p^{r_h}</span>  uniformly at random and then sends it to  <span class="math">\\mathsf{P}</span> . (b)  <span class="math">\\mathsf{P}</span>  sets  <span class="math">(\\pmb{a}_h, s_h^{\\mathsf{P}}) \\gets \\Pi_{i^<em>}(s_{h-1}^{\\mathsf{P}}, \\pmb{e}_h)</span>  where  <span class="math">\\mathsf{P}</span>  only uses the first  <span class="math">r_{h,i^</em>}^{\\mathsf{P}}</span>  elements of  <span class="math">\\pmb{e}_h</span>  as required by  <span class="math">\\Pi_{i^<em>}</span> . It computes  <span class="math">\\pmb{c}_h \\gets \\mathcal{CP}(\\hat{x}, h, i^</em>, \\pmb{a}_h)</span>  and sends  <span class="math">\\pmb{c}_h</span>  to  <span class="math">\\mathsf{V}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i\\in \\{1,2\\}</span> <span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  both compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\bar {z} _ {i}, y _ {i}\\right) \\leftarrow \\mathcal {Q} \\left(x _ {i}, \\left\\{\\boldsymbol {e} _ {h}, \\operatorname {d e c} (\\hat {x}, h, i, \\boldsymbol {c} _ {h}) \\right\\} _ {h \\in [ t _ {i} ]}\\right).</span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{z}_i \\coloneqq \\overline{\\mathbf{z}}_i \\mid \\underbrace{0 \\cdots 0}_{\\ell - \\ell_i \\text{ times}}</span>  //  <span class="math">x_i</span>  true  <span class="math">\\Rightarrow \\langle \\pi, z_i \\rangle = y_i</span></p>

    <p class="text-gray-300">Then,  <span class="math">\\mathsf{P}</span>  computes  <span class="math">\\mu_{1} = \\langle \\pmb {\\pi},\\pmb{z}_{1}\\rangle -y_{1}</span>  and  <span class="math">\\mu_{2} = \\langle \\pmb {\\pi},\\pmb{z}_{2}\\rangle -y_{2}</span> , in  <span class="math">\\mathbb{F}_{p^k}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  sends  <span class="math">\\delta = u\\mu_{2} - v\\in \\mathbb{F}_{p^{k}}</span>  to  <span class="math">\\mathsf{V}</span> . (This can be sent in parallel with  <span class="math">\\mathsf{P}</span> 's previous message)</li>

      <li>V sends a random challenge  <span class="math">f \\in \\mathbb{F}_{p^k}</span> .</li>

      <li><span class="math">\\mathsf{P}</span>  sends back  <span class="math">\\varepsilon = f\\mu_{1} - u</span></li>

      <li>V sends a second challenge  <span class="math">f&#x27; \\in \\mathbb{F}_{p^k}</span> .</li>

      <li>V makes the oracle query</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\left(f \\boldsymbol {z} _ {1} + f ^ {\\prime} \\varepsilon \\boldsymbol {z} _ {2}\\right) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1, f ^ {\\prime}\\right), f \\cdot y _ {1} + \\varepsilon + f ^ {\\prime} \\cdot \\left(\\varepsilon y _ {2} - \\delta\\right))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">// Checks that  <span class="math">f\\mu_{1} - u = \\varepsilon</span>  and  <span class="math">\\varepsilon \\mu_{2} + (\\delta + v) = 0</span>  (combined into one query by randomizing with  <span class="math">f&#x27;</span> )</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V accepts if the query is true, otherwise it rejects.</li>

    </ol>

    <p class="text-gray-300">Figure 7: The protocol  <span class="math">\\Pi_{\\mathbf{A} - \\mathbf{OR}}</span>  for an OR-statement.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>message complexity  <span class="math">4k + \\max \\{\\alpha_i\\}</span>  elements of  <span class="math">\\mathbb{F}_p</span> ; and</li>

      <li>soundness error  <span class="math">\\epsilon_{1} + \\epsilon_{2} + 2p^{-k}</span></li>

    </ol>

    <p class="text-gray-300">If  <span class="math">\\Pi_1, \\Pi_2</span>  are both proofs of knowledge, then so is  <span class="math">\\Pi_{\\mathbf{A} - \\mathbf{OR}}</span> .</p>

    <p class="text-gray-300">Note that we can choose the extension field parameter  <span class="math">k</span>  so that  <span class="math">p^k</span>  is large enough to achieve</p>

    <p class="text-gray-300">negligible soundness in one run, with only a small increase in message complexity (independent of <span class="math">\\alpha_{i}</span>).</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. If <span class="math">(x_{i^{<em>}},\\bm{w}_{i^{</em>}})\\in\\mathcal{R}_{i^{<em>}}</span> and <span class="math">\\mathsf{P}</span> has <span class="math">\\bm{w}_{i^{</em>}}</span> then Steps 1-3 will run by the same argument as in the completeness proof for <span class="math">\\Pi_{\\mathsf{OR}}</span>. All that remains to show is that the oracle query will be accepting.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\bm{\\pi},(f\\bm{z}_{1}+f^{\\prime}\\varepsilon\\bm{z}_{2})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1,f^{\\prime}\\rangle<span class="math"> </span>=f\\cdot\\langle\\bm{\\pi},\\bm{z}_{1}\\rangle-u+f^{\\prime}\\varepsilon\\cdot\\langle\\bm{\\pi},\\bm{z}_{2}\\rangle+f^{\\prime}v$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=f\\cdot(\\mu_{1}+y_{1})-u+f^{\\prime}\\varepsilon\\cdot(\\mu_{2}+y_{2})+f^{\\prime}v</span> (2) <span class="math">=f\\cdot y_{1}+\\varepsilon+f^{\\prime}\\cdot(\\varepsilon y_{2}+\\varepsilon\\mu_{2}+u\\mu_{2}-\\delta)</span> (3) <span class="math">=f\\cdot y_{1}+\\varepsilon+f^{\\prime}\\cdot(\\varepsilon y_{2}+(f\\mu_{1}-u)\\mu_{2}+u\\mu_{2}-\\delta)</span> (4) <span class="math">=f\\cdot y_{1}+\\varepsilon+f^{\\prime}\\cdot(\\varepsilon y_{2}-\\delta)</span> (5)</p>

    <p class="text-gray-300">where 2 follows from the definitions of <span class="math">\\mu_{1},\\mu_{2}</span>, 3 and 4 use the facts that <span class="math">v=u\\mu_{2}-\\delta</span> and <span class="math">\\varepsilon=f\\mu_{1}-u</span>, and 5 relies on <span class="math">\\mu_{1}\\mu_{2}=0</span> when <span class="math">\\bm{w}_{i^{*}}</span> is a valid witness (by the completeness of <span class="math">\\Pi_{1},\\Pi_{2}</span>). Thus, the proof accepts for an honest prover.</p>

    <p class="text-gray-300">Round complexity, oracle length, query complexity and message complexity follow from an inspection of the actual protocol definition.</p>

    <p class="text-gray-300">Soundness. Suppose that a cheating prover completes the protocol when it does not know a witness for either statement. By assumption on <span class="math">\\Pi_{1},\\Pi_{2}</span>, <span class="math">\\mathsf{P}</span> could only make the oracle queries <span class="math">(\\overline{\\bm{z}}_{1},y_{1})</span> and <span class="math">(\\overline{\\bm{z}}_{2},y_{2})</span> be correct with probability <span class="math">\\leq\\epsilon_{1}+\\epsilon_{2}</span> by a union bound.</p>

    <p class="text-gray-300">Thus, assume that both of these queries would not be successful, which means that <span class="math">\\mu_{1},\\mu_{2}</span> are both non-zero, hence <span class="math">\\mu_{1}\\mu_{2}=\\Delta</span> for some <span class="math">\\Delta\\neq 0</span>. (Where we define <span class="math">\\mu_{i}:=\\langle\\bm{\\pi},\\bm{z}_{i}\\rangle-y_{i}</span>, as in the protocol.) Further, define <span class="math">\\Delta_{\\varepsilon}:=\\varepsilon-(f\\mu_{1}-u)</span>, the error in the value of <span class="math">\\varepsilon</span> sent by the malicious <span class="math">\\mathsf{P}</span>.</p>

    <p class="text-gray-300">Suppose that for a successful transcript, the query in <span class="math">\\Pi_{\\mathsf{A-OR}}</span> passes. From its definition, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\bm{\\pi},(f\\bm{z}_{1}+f^{\\prime}\\varepsilon\\bm{z}_{2})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1,f^{\\prime}\\rangle=f\\cdot y_{1}+\\varepsilon+f^{\\prime}\\cdot(\\varepsilon y_{2}-\\delta)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Collecting <span class="math">(\\bm{z}_{i},y_{i})</span> terms on the left, and subbing in <span class="math">\\mu_{i}=\\langle\\bm{\\pi},\\bm{z}_{i}\\rangle-y_{i}</span> gives</p>

    <p class="text-gray-300"><span class="math">f\\mu_{1}+f^{\\prime}\\varepsilon\\mu_{2}-u+f^{\\prime}v=\\varepsilon-f^{\\prime}\\delta</span></p>

    <p class="text-gray-300">Now using the fact that <span class="math">\\varepsilon-(f\\mu_{1}-u)=\\Delta_{\\varepsilon}</span>, the above holds if and only if</p>

    <p class="text-gray-300"><span class="math">f^{\\prime}(\\varepsilon\\mu_{2}+v+\\delta)=\\Delta_{\\varepsilon}</span></p>

    <p class="text-gray-300">If <span class="math">\\Delta_{\\varepsilon}\\neq 0</span>, then there is only a single value of <span class="math">f^{\\prime}</span> that makes the above hold, hence, the check passes with probability <span class="math">p^{-k}</span>, since all other values were fixed before <span class="math">f^{\\prime}</span> was chosen.</p>

    <p class="text-gray-300">On the other hand, if <span class="math">\\Delta_{\\varepsilon}=0</span>, then</p>

    <p class="text-gray-300"><span class="math">f^{\\prime}\\cdot(f\\mu_{1}\\mu_{2}+u\\mu_{2}+v+\\delta)=0</span></p>

    <p class="text-gray-300">and the above holds either if <span class="math">f^{\\prime}=0</span>, or if</p>

    <p class="text-gray-300"><span class="math">f\\Delta+u\\mu_{2}+v+\\delta=0</span></p>

    <p class="text-gray-300">Since <span class="math">\\Delta\\neq 0</span>, and <span class="math">(u,\\mu_{2},v,\\delta)</span> were each fixed before sampling <span class="math">f</span>, each of these happens with probability <span class="math">p^{-k}</span>. Hence, summing up all the possible failure events, we obtain a soundness error of <span class="math">\\epsilon_{1}+\\epsilon_{2}+2p^{-k}</span>.</p>

    <p class="text-gray-300">Proof of Knowledge. This follows according to the same lines as in the proof of Theorem 2.</p>

    <p class="text-gray-300">Honest-Verifier Zero-Knowledge.</p>

    <p class="text-gray-300">We now construct a simulator <span class="math">\\mathcal{S}</span> for the protocol <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> that will, on input <span class="math">x_{1},x_{2}</span>, output a transcript <span class="math">\\tau</span> that is perfectly indistinguishable from a transcript generated by interaction with an honest <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">Pick a protocol instance <span class="math">\\Pi_{i}</span> at random, run its HVZK simulator <span class="math">\\mathcal{S}_{i}</span> and generate all <span class="math">\\bm{c}_{h}</span> using <span class="math">\\mathcal{CP}</span>. This will be perfectly indistinguishable from any transcript of <span class="math">\\Pi_{j}</span> with <span class="math">i\\neq j</span> by the HVZK property of <span class="math">\\Pi_{i}</span> and the definition of Equisimulatability. Choose uniformly random <span class="math">f,f^{\\prime}</span> as in the real protocol, and also uniform values <span class="math">\\delta,\\varepsilon</span> to simulate the prover’s messages. These are indistinguishable from the <span class="math">\\delta,\\varepsilon</span> from <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> where they are computed by subtracting a uniformly random <span class="math">u</span> or <span class="math">v</span> from a secret value.</p>

    <p class="text-gray-300">Public Coin. The argument is the same as for <span class="math">\\Pi_{\\texttt{OR}}</span>. <span class="math">\\square</span></p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Recursing.</h4>

    <p class="text-gray-300">We now show how to recursively apply the construction of <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span>, which is possible if all the initial protocols are equisimulatable.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{1},\\ldots,\\Pi_{2m}</span> be Public Coin IPs with LOVe with the same properties as in Theorem 6. Furthermore, assume that <em>all</em> <span class="math">2m</span> are equisimulatable. Denote with <span class="math">\\Pi_{i}^{\\prime}</span> the protocol obtained by applying <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> to <span class="math">\\Pi_{2i-1},\\Pi_{2i}</span>. Then all <span class="math">\\Pi_{1}^{\\prime},\\ldots,\\Pi_{m}^{\\prime}</span> are also equisimulatable.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By assumption, there already exists an algorithm <span class="math">\\mathcal{CP}</span> which takes care of simulating all the messages that each <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> would perform in Step 2. All that remains to show is that also the messages sent in Steps 4–6 of each instance of <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> can be packed into one vector <span class="math">c</span>. This follows trivially: by the proof of the zero-knowledge property of <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> we know that all <span class="math">\\varepsilon_{i},\\delta_{i}</span> for each <span class="math">\\Pi_{\\texttt{A}-\\texttt{OR}}</span> are uniformly random. Assuming each <span class="math">\\Pi_{i}^{\\prime}</span> uses the same extension field parameter <span class="math">k</span>, then the <span class="math">\\mathcal{CP}</span> algorithm simply outputs the messages <span class="math">\\varepsilon,\\delta</span> which the prover would send ordinarily. <span class="math">\\square</span></p>

    <p class="text-gray-300">This now allows us to construct a protocol for <span class="math">\\mathcal{R}_{\\texttt{OR}}</span> by recursively applying Theorem 6 and Lemma 2. For simplicity we assume that <span class="math">m</span> is a power of 2.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> be protocols such that each <span class="math">\\Pi_{i}</span> is a <span class="math">t_{i}</span>-round, <span class="math">1</span>-query equisimulatable Public Coin IP with LOVe over <span class="math">\\mathbb{F}_{p}</span> for relation <span class="math">\\mathcal{R}_{i}</span> with oracle length <span class="math">\\ell_{i}</span>, message complexity <span class="math">\\alpha_{i}</span> <span class="math">\\mathbb{F}_{p}</span> elements and soundness error <span class="math">\\epsilon_{i}</span>.</p>

    <p class="text-gray-300">Then there exists a protocol <span class="math">\\Pi_{\\texttt{R}-\\texttt{OR}}</span> that is a Public Coin IP with LOVe over <span class="math">\\mathbb{F}_{p^{k}}</span> for the relation <span class="math">\\mathcal{R}_{\\texttt{OR}}</span> with</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">3\\cdot\\log_{2}(m)+\\max_{i\\in[m]}\\{t_{i}\\}</span>;</li>

      <li>oracle length <span class="math">2\\cdot\\log_{2}(m)+\\max_{i\\in[m]}\\{\\ell_{i}\\}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>query complexity <span class="math">1</span>;</li>

      <li>message complexity <span class="math">4k\\log_{2}(m)+\\max\\{\\alpha_{i}\\}</span> <span class="math">\\mathbb{F}_{p}</span> elements; and</li>

      <li>soundness error <span class="math">\\sum_{i\\in[m]}\\epsilon_{i}+(m-1)\\cdot 2p^{-k}</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> are all proofs of knowledge, then so is <span class="math">\\Pi_{\\texttt{R-OR}}</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The idea for <span class="math">\\Pi_{\\texttt{R-OR}}</span> is straightforward. First, we apply Lemma 2 to go from <span class="math">m</span> protocols to <span class="math">m/2</span> IPs with LOVe. Since <span class="math">\\mathsf{P}</span> has <span class="math">(x_{i^{<em>}},\\bm{w}_{i^{</em>}})\\in\\mathcal{R}_{i^{<em>}}</span> it will first compute <span class="math">\\bm{\\pi}_{i^{</em>}}</span> as in <span class="math">\\Pi_{i^{*}}</span>, pad it with <span class="math">0</span>s as in <span class="math">\\Pi_{\\texttt{OR}}</span> and then append <span class="math">\\log_{2}(m)</span> random pairs <span class="math">u_{j},v_{j}\\in\\mathbb{F}_{p^{k}}</span>. Note that this is <span class="math">\\log_{2}(m)</span> times as many pairs as in <span class="math">\\Pi_{\\texttt{A-OR}}</span>, which we need for the recursion.</p>

    <p class="text-gray-300">As before, we simulate the messages using the true branch and in the end compute the queries that would occur in any of the <span class="math">m</span> branches from the messages that <span class="math">\\mathsf{V}</span> obtains based on each <span class="math">\\Pi_{i}</span>. We then use the <span class="math">u_{j},v_{j}</span> pair for <span class="math">j=1</span> to compute the <span class="math">\\delta,\\varepsilon</span> messages based on the instance of <span class="math">\\Pi_{\\texttt{A-OR}}</span> where the true branch <span class="math">\\Pi_{i^{*}}</span> is a part of (while also receiving a challenge from <span class="math">\\mathsf{V}</span>). Then, for each of the overall <span class="math">m/2</span> instances of <span class="math">\\Pi_{\\texttt{A-OR}}</span> we compute the queries which <span class="math">\\mathsf{V}</span> would make. Observe that we do not actually make these now. In each branch of <span class="math">\\Pi_{\\texttt{A-OR}}</span>, the adversary could have lied only with probability <span class="math">\\epsilon_{2i-1}+\\epsilon_{2i}+2p^{-k}</span> by Theorem 6.</p>

    <p class="text-gray-300">Next, as the remaining <span class="math">m/2</span> protocols are equisimulatable by Lemma 2, applying <span class="math">\\Pi_{\\texttt{A-OR}}</span> to combine these will lead to <span class="math">m/4</span> equisimulatable protocols. We again combine the <span class="math">m/2</span> equisimulatable public coin IPs with LOVe using Theorem 6, now using the random <span class="math">(u_{j},v_{j})</span> pair in <span class="math">\\bm{\\pi}</span> for <span class="math">j=2</span>. Note that we are now operating at the second layer of the tree, where we are using the <span class="math">\\Pi_{\\texttt{A-OR}}</span> instances from the first layer as input. Since each <span class="math">\\Pi_{\\texttt{A-OR}}</span> performs only <span class="math">1</span> query, it is also suitable for input to another <span class="math">\\Pi_{\\texttt{A-OR}}</span> instance.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span> computes the <span class="math">\\delta_{j},\\varepsilon_{j}</span>-values necessary for the proofs done in the second layer of <span class="math">\\Pi_{\\texttt{A-OR}}</span> instances on the inner products of the respective queries that would have been made in the end of the first layer of <span class="math">\\Pi_{\\texttt{A-OR}}</span> instances as before. The values <span class="math">\\delta_{j},\\varepsilon_{j}</span> that we send in the second layer are computed based on the one of the <span class="math">m/4</span> instances of <span class="math">\\Pi_{\\texttt{A-OR}}</span> corresponding to the true statement with <span class="math">\\Pi_{i^{*}}</span>. The soundness error in this layer is by the definition of <span class="math">\\Pi_{\\texttt{A-OR}}</span>, the sum of the soundness error on either branch of the input protocol plus an additional error term <span class="math">2p^{-k}</span>.</p>

    <p class="text-gray-300">Continuing this process <span class="math">\\log_{2}(m)</span> times, until we end up with a single output, then leads to the claimed properties. The proof of knowledge property follows accordingly. ∎</p>

    <p class="text-gray-300">In terms of practical complexity, our proof loses a factor <span class="math">m</span> in soundness, which is expected. The number of rounds blows up to be logarithmic, however, this can be avoided using Fiat-Shamir (which also removes <span class="math">2k\\log m</span> elements from the message complexity).</p>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix E Proofs from § 4</h2>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">E.1 Proof of Theorem 3</h3>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem (Theorem 3, restated).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a relation that can be represented by an arithmetic circuit <span class="math">C</span> over <span class="math">\\mathbb{F}_{p}</span> such that <span class="math">\\mathcal{R}(x,\\bm{w})=1\\Leftrightarrow C(\\bm{w})=0</span>. Then the above protocol is a <span class="math">\\mathsf{C}\\&amp;amp;\\mathsf{P}</span> IP with LOVe over <span class="math">\\mathbb{F}_{p^{k}}</span> for <span class="math">\\mathcal{R}</span>, such that (1) completeness holds, (2) soundness holds with soundness error <span class="math">p^{-k}</span>, (3) all inputs to <span class="math">\\mathsf{Send}</span> are perfectly indistinguishable from random, and (4) the protocol is a proof of knowledge.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness is immediate. For soundness, consider a malicious prover <span class="math">\\mathsf{P}^{<em>}</span>, who at the beginning of the protocol chooses all of the randomness used in Random instructions. In the remainder of the protocol, <span class="math">\\mathsf{P}^{</em>}</span> is only able to cheat in the Mult operation (since Reveal guarantees that <span class="math">\\varepsilon_{i}</span> is sent correctly, so AssertMult does not allow cheating). Consider a multiplication gate where <span class="math">\\mathsf{P}^{*}</span>, i.e., instead of sending <span class="math">\\delta=xy-r</span> in the Fix operation (for the random value <span class="math">r</span>), it sent <span class="math">\\delta=xy+\\Delta-r</span>, for some <span class="math">\\Delta\\neq 0</span>. Similarly, let <span class="math">\\delta^{\\prime}=ay+\\Delta^{\\prime}-r^{\\prime}</span> be the value sent during the second Fix operation for that gate. We then have <span class="math">z=xy+\\Delta</span> and <span class="math">c=ay+\\Delta^{\\prime}</span>.</p>

    <p class="text-gray-300">The check for this gate passes only if <span class="math">ez-c-\\varepsilon y=0</span>, which gives</p>

    <p class="text-gray-300"><span class="math">e(xy+\\Delta)-(ay+\\Delta^{\\prime})-(ex-a)y=0</span></p>

    <p class="text-gray-300">which only holds if <span class="math">e\\Delta=\\Delta^{\\prime}</span>. This occurs with probability <span class="math">p^{-k}</span>, over the random choice of <span class="math">e\\in\\mathbb{F}_{p^{k}}</span>. Since an incorrect statement must have at least one multiplication gate where the prover cheated, we obtain an overall soundness error of <span class="math">p^{-k}</span>. If instead the error is lower, then the proof string <span class="math">\\pi=(r_{1},\\ldots,r_{t},w_{1},\\ldots,w_{n})</span> directly contains a witness <span class="math">w=(w_{1},\\ldots,w_{n})</span> for <span class="math">\\mathcal{R}</span>. We can construct an extractor according to Definition 3 by simply outputting <span class="math">w</span> from <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Finally, we prove that all inputs to Send are perfectly indistinguishable from random. Clearly the Send call in Step 2 satisfies this requirement. Likewise, the Send calls in Fix and Step 3 satisfy this requirement as well, since they are masked by uniformly random field elements which are not re-used and come from the appropriate size field (note that we need <span class="math">a</span> to be in <span class="math">\\mathbb{F}_{p^{k}}</span> to ensure this holds for <span class="math">\\varepsilon</span>). ∎</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">E.2 Proof of Theorem 4</h3>

    <p class="text-gray-300">To analyze the soundness of the batched multiplication protocol (AssertMultVec), we first use the following lemma.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">If the protocol AssertDotProduct passes, then the input commitments have the required relation except with probability <span class="math">\\frac{4\\log n+1}{p^{k}-2}</span></p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows from <em>[BBC^{+}19, Theorem 5.1]</em> where the base case has soundness error <span class="math">p^{-k}</span> and the recursive step <span class="math">4/(p^{k}-2)</span>. ∎</p>

    <p class="text-gray-300">We then have the following.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Theorem (Theorem 4, restated).</h6>

    <p class="text-gray-300">If the protocol AssertMultVec passes, then the input commitments have the required relation except with probability <span class="math">\\frac{n+4\\log n+1}{p^{k}-2}</span></p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume that the committed values do not fulfill the required relation, we can write <span class="math">x_{i}\\cdot y_{i}=z_{i}+\\Delta_{i}</span> where <span class="math">\\Delta_{i}\\neq 0</span> for at least one <span class="math">i\\in[n]</span>.</p>

    <p class="text-gray-300">Consider the case where <span class="math">\\sum_{i\\in[n]}x_{i}y_{i}r^{i}\\neq\\sum_{i\\in[n]}z_{i}r^{i}</span>. Then the proof will fail except with probability <span class="math">\\frac{4\\log n+1}{p^{k}-2}</span> by Lemma 3. If instead equality holds, then this means that <span class="math">0=\\sum_{i\\in[n]}\\Delta_{i}r^{i}</span> while at least one <span class="math">\\Delta_{i}</span> is non-zero. By Schwartz-Zippel, the equation can hold with probability at most <span class="math">n/(p^{k}-1)</span> and the claim follows by a union bound. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">F Proofs from § 5</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">F.1 Round-by-round Soundness of the Protocols from § 3 and § 4</h3>

    <p class="text-gray-300">Here, we show that both our stacked OR proof transformation and our batched multiplication verification protocol are round-by-round sound, hence, suitable for use with the Fiat-Shamir transform from § 5.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">The streamable IPs with LOVe from § 5.1–§ 5.2 have round-by-round soundness error <span class="math">p^{-k}</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define the State function for the protocol from § 5.1 as follows. Initially, on input <span class="math">\\bm{\\pi}</span> and the empty transcript, State extracts the witness from <span class="math">\\bm{\\pi}</span> and checks whether the circuit is satisfied and outputs accept or reject, accordingly. In subsequent rounds, as well as checking the circuit satisfiability, State checks whether any <span class="math">\\delta_{i},\\delta_{i}^{\\prime}</span> or <span class="math">\\varepsilon_{i}</span> values were sent incorrectly since the beginning of the protocol; if any of these hold, it outputs reject. In the final round, State only checks whether the verifier’s oracle queries would succeed or not, and outputs the corresponding result.</p>

    <p class="text-gray-300">Properties 1 and 3 of the definition follow immediately. For property 2, notice that the only place it is possible to transition from a reject state to an accept state is the last round. By the argument in the text above, this only happens with probability <span class="math">p^{-k}</span>.</p>

    <p class="text-gray-300">Finally, we also observe that the transformation of batching AssertZero statements from § 5.2 preserves the round-by-round soundness of the underlying protocol, up to the same error probability. This is because the only change to the actual computation by the verifier is during the final oracle query stage where the queries are randomly combined; the soundness in all previous rounds is unaffected. This change to the oracle queries simply adds a factor of <span class="math">p^{-k}</span> to the round-by-round soundness error. ∎</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Assume that <span class="math">\\Pi_{\\mathsf{OR}}</span> from § 3 compiles protocols <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> with round-by-round soundness error <span class="math">\\epsilon_{1},\\ldots,\\epsilon_{m}</span>. Then <span class="math">\\Pi_{\\mathsf{OR}}</span> has round-by-round soundness error <span class="math">\\max\\{\\sum_{i\\in[m]}\\epsilon_{i},1/p^{k}\\}</span>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">\\Pi_{1},\\ldots,\\Pi_{m}</span> each have round-by-round soundness, there exist algorithms <span class="math">\\mathsf{State}_{1},\\ldots,\\mathsf{State}_{m}</span> for them according to Definition 7. We define the State function for the protocol <span class="math">\\Pi_{\\mathsf{OR}}</span> as follows: Initially, on input <span class="math">\\bm{\\pi}</span> and the empty transcript, State attempts to extract the actual proof string <span class="math">\\bm{\\pi}_{i}</span> for each subprotocol <span class="math">\\Pi_{i}</span> from <span class="math">\\bm{\\pi}</span> (according to how <span class="math">\\Pi_{\\mathsf{OR}}</span> places it). It then runs <span class="math">\\mathsf{State}_{i}(x_{i},\\bm{\\pi}_{i},\\emptyset)</span> and outputs accept if any <span class="math">\\mathsf{State}_{i}</span> outputs accept, otherwise reject.</p>

    <p class="text-gray-300">In subsequent rounds of Phase 1, State checks whether <span class="math">\\mathsf{State}_{i}(x_{i},\\bm{\\pi}_{i},\\mathcal{T}_{i})</span> accepts where <span class="math">\\mathcal{T}_{i}</span> is formed by concatenating the outputs of <span class="math">\\mathsf{dec}</span> on the message <span class="math">\\bm{a}_{h}</span> for each <span class="math">i\\in[m]</span> and the respective substrings of the challenges. If any <span class="math">\\mathsf{State}_{i}</span> accepts then State outputs accept, otherwise reject.</p>

    <p class="text-gray-300">At the start of Phase 2 of <span class="math">\\Pi_{\\mathsf{OR}}</span>, State outputs the same accept or reject as in the end of Phase 1. In the final round, State checks whether the verifier’s oracle queries would succeed or not, and outputs the corresponding result.</p>

    <p class="text-gray-300">For property 1, the claim follows as all <span class="math">\\mathsf{State}_{i}</span> would in such a case output reject by definition. By construction, property 3 will also always hold.</p>

    <p class="text-gray-300">For property 2, during Phase 1 such a change only occurs if any of the <span class="math">\\mathsf{State}_{i}</span> changes from reject to accept. By a union bound, this happens with probability at most <span class="math">\\sum_{i\\in[m]}\\epsilon_{i}</span> for each round. During Phase 2, no change of the output of State is possible. In the last round, such a state change can occur, but by the soundness proof of <span class="math">\\Pi_{\\mathsf{OR}}</span> with probability at most <span class="math">1/p^{k}</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">The protocol <span class="math">\\mathsf{AssertMultVec}</span> from §4.3 has round-by-round soundness error <span class="math">\\max\\{p^{-k},4/(p^{k}-2),n/(p^{k}-1)\\}</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct an algorithm <span class="math">\\mathsf{State}</span> for <span class="math">\\mathsf{AssertMultVec}</span> as follows: Initially, <span class="math">\\mathsf{State}</span> will extract all the values <span class="math">x_{i},y_{i},z_{i}</span> from <span class="math">\\bm{\\pi}</span> and check if <span class="math">x_{i}\\cdot y_{i}=z_{i}</span> for all <span class="math">i\\in[n]</span>. If so, then it outputs accept, otherwise reject.</p>

    <p class="text-gray-300">In round 1, it changes to accept if the inputs to <span class="math">\\mathsf{AssertDotProduct}</span> indeed satisfy the inner product relation for this choice of <span class="math">r</span>, otherwise it stays with its output from the previous round.</p>

    <p class="text-gray-300">For each round of <span class="math">\\mathsf{AssertDotProduct}</span>, if <span class="math">n&gt;2</span> it recomputes the inputs to the next call to <span class="math">\\mathsf{AssertDotProduct}</span>. <span class="math">\\mathsf{State}</span> then changes from reject to accept if the choice of <span class="math">r</span> makes the next such call accepting, otherwise it stays with its output from the previous round. If <span class="math">n\\leq 2</span> it will change from reject to accept if the choice of <span class="math">e</span> makes both multiplication verifications accepting.</p>

    <p class="text-gray-300">In the final round, <span class="math">\\mathsf{State}</span> checks whether the verifier’s oracle queries would succeed or not, and outputs the corresponding result.</p>

    <p class="text-gray-300">By construction, property 1 as well as property 3 holds. For property 2, observe that a state change in round 1 can only happen with probability <span class="math">n/(p^{k}-1)</span> by the proof of Theorem 4. From the proof of Lemma 3 it follows that any state change during <span class="math">\\mathsf{AssertDotProduct}</span> can happen with probability at most <span class="math">\\max\\{p^{-k},4/(p^{k}-2)\\}</span>. ∎</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">F.2 Proof of Fiat-Shamir Transform</h3>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem (Theorem 5, restated).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathsf{LOVe}}</span> be a <span class="math">t</span>-round, 1-query, public-coin <span class="math">\\mathsf{IP</span>-LOVe}<span class="math"> for relation </span>\\mathcal{R}<span class="math"> with round-by-round soundness </span>\\epsilon<span class="math">, which is also complete and zero-knowledge. Then, the compiled protocol </span>\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}<span class="math"> in Figure 6 is a non-interactive zero-knowledge proof in the </span>\\mathcal{F}_{\\mathsf{VOLE+id}}$-hybrid model, with soundness error at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p^{-k}+\\epsilon t+Q(\\epsilon+2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2^{-\\lambda})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">Q</span> is the number of random oracle queries made by a malicious prover, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the smallest challenge set in any given round of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, if <span class="math">\\Pi_{\\mathsf{LOVe}}</span> is a proof of knowledge, then so is <span class="math">\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}</span>.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be the malicious prover in an execution of <span class="math">\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}</span> for some statement <span class="math">x</span> not in the language.</p>

    <p class="text-gray-300">For any given round <span class="math">i\\in[t]</span> of <span class="math">\\Pi_{\\mathsf{LOVe}}</span>, let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{st}_{i}=\\mathsf{State}(x,\\bm{\\pi},\\bm{e}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\bm{a}_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\bm{\\pi}</span> is the proof string chosen by <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">We define the following two events concerning the prover <span class="math">\\mathcal{A}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E_{1}</span>: the event that <span class="math">\\mathcal{A}</span> outputs a proof string <span class="math">\\bm{\\pi}</span> and a corresponding accepting transcript.</li>

      <li><span class="math">E_{2}</span>: the event that both of the following hold: (1) If</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\bm{q}_{0},\\ldots,\\bm{q}_{t-1}):=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{id}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{0},\\bm{a}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{1},\\ldots,\\bm{a}_{t-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{t-1})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and <span class="math">\\mathcal{A}</span> queries both <span class="math">\\bm{q}_{i}</span> and <span class="math">\\bm{q}_{j}</span> to the random oracle for some <span class="math">i&lt;j</span>, then <span class="math">\\bm{q}_{i}</span> was queried first; and (2) For any <span class="math">i</span> where <span class="math">\\mathsf{st}_{i}=\\mathsf{reject}</span> and <span class="math">\\mathsf{st}_{i+1}=\\mathsf{accept}</span>, <span class="math">\\mathcal{A}</span> queries $(\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the malicious prover makes <span class="math">Q</span> queries to the random oracle <span class="math">\\mathsf{H}</span>, then, $\\Pr[E_{1}\\wedge\\neg E_{2}]\\leq\\epsilon t+Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that event <span class="math">E_{1}</span> occurs, and <span class="math">E_{2}</span> does not. Then, at least one of the following holds: (1) <span class="math">\\mathcal{A}</span> queried $\\bm{q}_{j}=\\bm{a}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{j}<span class="math">, and then later </span>\\bm{q}_{i}<span class="math">, for some </span>i<j<span class="math">, (2) There exists an </span>i<span class="math"> where </span>\\mathsf{st}_{i}=\\mathsf{reject},\\mathsf{st}_{i+1}=\\mathsf{accept}<span class="math">, and </span>\\mathcal{A}<span class="math"> did not query </span>\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose (1) is true, and let <span class="math">i,j</span> be a pair of indices where <span class="math">i&lt;j</span> and <span class="math">j-i</span> is smallest, such that <span class="math">\\mathcal{A}</span> queried <span class="math">\\bm{q}_{j}</span> before <span class="math">\\bm{q}_{i}</span>. We can therefore assume that <span class="math">\\mathcal{A}</span> did not query the oracle on <span class="math">\\bm{q}_{j-1}</span> before querying $\\bm{q}_{j}=\\bm{a}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{j}<span class="math">. Since </span>\\bm{e}_{j}=\\mathsf{H}(\\bm{q}_{j-1})<span class="math">, this means that the behaviour of </span>\\mathcal{A}<span class="math"> up until querying </span>\\bm{a}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{j}<span class="math"> is independent of </span>\\bm{e}_{j}<span class="math">, and so this query happens with probability at most </span>Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In case (2), let <span class="math">i</span> be an index such that <span class="math">\\mathsf{st}_{i}=\\mathsf{reject},\\mathsf{st}_{i+1}=\\mathsf{accept}</span>, but <span class="math">\\mathcal{A}</span> did not query $\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i}<span class="math">. It follows that the behaviour of </span>\\mathcal{A}<span class="math"> is independent of </span>\\bm{e}_{i+1}<span class="math">, so by the round-by-round soundness of </span>\\Pi_{\\mathsf{LOVe}}<span class="math">, and taking a union bound over all </span>t<span class="math"> rounds, this occurs only with probability </span>\\epsilon t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the malicious prover makes <span class="math">Q</span> queries to the random oracle <span class="math">\\mathsf{H}</span>, then $\\Pr[E_{1}\\wedge E_{2}]\\leq p^{-k}+Q\\epsilon+Q/2^{\\lambda}+Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that the proof accepts and event <span class="math">E_{2}</span> occurs. Since <span class="math">x</span> is not in the language, but the proof accepts, it either holds that there exists a round <span class="math">i</span> where <span class="math">\\mathsf{st}_{i}=\\mathsf{reject}</span> and <span class="math">\\mathsf{st}_{i+1}=\\mathsf{accept}</span>, or, <span class="math">\\mathsf{P}</span> cheated during the MAC check when performing the oracle query. In the latter case, <span class="math">\\mathsf{P}</span> must have guessed the MAC key <span class="math">\\alpha</span>, which only happens with probability <span class="math">p^{-k}</span>. Suppose instead the former. By assumption, <span class="math">\\mathcal{A}</span> made the query $\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i}<span class="math"> to the random oracle to obtain the challenge </span>\\bm{e}_{i+1}<span class="math"> which caused </span>\\mathsf{st}_{i+1}$ to accept.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We argue that this implies the values <span class="math">x,\\bm{\\pi}</span> and <span class="math">\\bm{a}_{1},\\ldots,\\bm{a}_{i}</span> were all fixed by <span class="math">\\mathcal{A}</span> at the time of querying $\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-90" class="text-base font-medium mt-4">Claim 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathcal{A}</span> made query $\\bm{q}_{i}=(\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i})<span class="math">, then it also queried </span>\\bm{q}_{0},\\ldots,\\bm{q}_{i-1}<span class="math">, and all these queries were made after calling </span>\\mathcal{F}_{\\mathsf{VOLE+id}}<span class="math">, except with probability at most </span>Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+Q/2^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-91" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose at least one such query was not made, and let <span class="math">j&lt;i</span> be an index where <span class="math">\\bm{q}_{j}</span> was not queried, but $\\bm{q}_{j+1}=(\\bm{a}_{j+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{j+1})<span class="math"> was. Since </span>\\bm{e}_{j+1}=\\mathsf{H}(\\bm{q}_{j})<span class="math">, the probability that </span>\\mathcal{A}<span class="math"> queried </span>\\bm{q}_{j+1}<span class="math"> is at most </span>Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Next, we argue that all queries </span>\\bm{q}_{0},\\ldots,\\bm{q}_{i}<span class="math"> must have been made after </span>\\mathcal{A}<span class="math"> received the random identifier </span>\\mathsf{id}<span class="math"> from </span>\\mathcal{F}_{\\mathsf{VOLE+id}}<span class="math">. Note that by assumption (1) of event </span>E_{2}<span class="math">, these queries were all made in order so we only need to consider </span>\\bm{q}_{0}<span class="math">. Since </span>\\bm{q}_{0}=x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{id}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}_{0}<span class="math">, and </span>\\mathsf{id}<span class="math"> is sampled from </span>\\{0,1\\}^{\\lambda}<span class="math"> after </span>\\mathcal{F}_{\\mathsf{VOLE+id}}<span class="math"> is called, however, this happens with probability at most </span>Q/2^{\\lambda}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assuming now that queries <span class="math">\\bm{q}_{0},\\ldots,\\bm{q}_{i}</span> were all made after calling <span class="math">\\mathcal{F}_{\\mathsf{VOLE+id}}</span>, then this was also after choosing <span class="math">x</span> and the proof <span class="math">\\bm{\\pi}</span>, since after <span class="math">\\mathcal{F}_{\\mathsf{VOLE+id}}</span> has been called, the input to query <span class="math">\\bm{q}_{0}</span> fixes these. It follows the entire partial transcript up to message <span class="math">\\bm{a}_{i}</span> is also fixed, at the time when <span class="math">\\mathcal{A}</span> makes query $\\bm{q}_{i}=(\\bm{a}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{e}_{i})<span class="math"> to get the challenge </span>\\bm{e}_{i+1}<span class="math">. From round-by-round soundness, we get that the probability that </span>\\mathsf{st}_{i+1}=\\mathsf{accept}<span class="math"> for any such </span>i<span class="math">, is at most </span>Q\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Taking a union bound across all failure events, we get an overall probability of at most $p^{-k}+Q\\epsilon+Q/2^{\\lambda}+Q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can then sum up the bounds from Lemmas 7 and 8, getting</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E_{1}]=\\Pr[E_{1}\\wedge E_{2}]+\\Pr[E_{1}\\wedge\\neg E_{2}]\\leq p^{-k}+\\epsilon t+Q(\\epsilon+2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2^{-\\lambda})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, for the prove of knowledge property, if <span class="math">\\Pi_{\\mathsf{LOVe}}</span> is also a proof of knowledge, then there is an extractor <span class="math">E</span> that on input <span class="math">x, \\pi</span> for an accepting proof, outputs the witness. We can therefore construct an extractor for <span class="math">\\Pi_{\\mathsf{NIZK}}^{\\mathsf{VOLE}}</span> as follows: simulating the <span class="math">\\mathcal{F}_{\\mathsf{VOLE} + \\mathsf{id}}</span> functionality, the extractor obtains the prover's random commitments <span class="math">r_i</span>, and then uses these to compute each element of the proof <span class="math">\\pi_i</span>; it then runs <span class="math">E</span> on input <span class="math">x, \\pi</span>. Given that the proof accepts, this extractor's success probability is the same as that of <span class="math">E</span>.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Recall that the goal is for the prover to assert that, for committed bit vectors <span class="math">[\\pmb{x}] = ([x_1],\\dots ,[x_n])</span>, <span class="math">[\\pmb{y}] = ([y_1],\\dots ,[y_n])</span>, and <span class="math">[\\pmb{z}] = ([z_1],\\dots ,[z_n])</span>, it holds that <span class="math">x_{i}y_{i} = z_{i}</span> for all <span class="math">i</span>. As we provided intuition for the construction in §4.4, we jump right to the construction.</p>

    <p class="text-gray-300">Let <span class="math">f: \\mathbb{F}_2^{15} \\times \\mathbb{F}_2^{30} \\to \\mathbb{F}_2^{45}</span> be a linear bijection such that there exists a <span class="math">\\pmb{d}</span> such that <span class="math">f(\\pmb{z}, \\pmb{d}) = \\phi(\\pmb{x}) \\cdot \\phi(\\pmb{y})</span> when <span class="math">\\pmb{z} = \\psi(\\phi(\\pmb{x}) \\cdot \\phi(\\pmb{y}))</span>. The vector <span class="math">\\pmb{d}</span> does not have any inherent meaning outside of the <span class="math">f</span> function. In practice, we construct <span class="math">f</span> (and decide what <span class="math">\\pmb{d}</span> is) by taking the matrix form of <span class="math">\\psi</span> and adding rows to it to make it a full-rank, square matrix. Let <span class="math">\\pmb{g} = (1, x, \\dots, x^{45}) \\in (\\mathbb{F}_{2^{45}})^{45}</span> be a constant vector, where <span class="math">x</span> here denotes the polynomial variable when representing a Galois extension field element as a polynomial.</p>

    <p class="text-gray-300">The protocol proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes <span class="math">\\pmb{d}</span> from <span class="math">f^{-1}(\\phi(\\pmb{x}) \\cdot \\phi(\\pmb{y}))</span>, and runs <span class="math">\\mathsf{Fix}(d_i) \\to [d_i]</span> on each bit of <span class="math">\\pmb{d}</span>.</li>

      <li>Both parties locally compute <span class="math">[a] \\gets \\phi([\\pmb{x}])</span>, <span class="math">[b] \\gets \\phi([\\pmb{y}])</span>, and <span class="math">[c] \\gets \\pmb{g} \\cdot f([\\pmb{z}], [\\pmb{d}])</span>.</li>

      <li>Run <span class="math">\\mathsf{Random}(\\mathbb{F}_{2^{45}}) \\to [t]</span> and <span class="math">\\mathsf{Fix}(ty) \\to [s]</span>.</li>

      <li>Run <span class="math">\\mathsf{Send}_{[\\mathsf{V} \\to \\mathsf{P}]}(e)</span> where <span class="math">e \\in_{R} \\mathbb{F}_{p^k}</span>.</li>

      <li>Run <span class="math">\\mathsf{AssertMult}([a], [b], [c], [t], [s], e)</span>.</li>

    </ol>

    <p class="text-gray-300">Overall, this gives us a prover-to-verifier per-bit communication cost of 9 bits.</p>

    <p class="text-gray-300">Security. Since <span class="math">f</span> is bijective, there is exactly one <span class="math">(\\pmb{c}, \\pmb{d})</span> pair which will satisfy <span class="math">\\mathsf{AssertMult}</span>. Thus, if the <span class="math">\\mathsf{AssertMult}</span> check passes, then we know that <span class="math">\\phi([\\pmb{a}]) \\cdot \\phi([\\pmb{b}]) = f(\\pmb{c}, \\pmb{d})</span>. Furthermore, <span class="math">\\pmb{c} = \\pmb{a} * \\pmb{b} = \\psi(\\phi(\\pmb{a}) \\cdot \\phi(\\pmb{b}))</span> since <span class="math">f</span> is bijective.</p>

    <p class="text-gray-300">42</p>`;
---

<BaseLayout title="Mac&#x27;n&#x27;Cheese: Zero-Knowledge Proofs for Boolean and Arithmet... (2020/1410)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1410
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
