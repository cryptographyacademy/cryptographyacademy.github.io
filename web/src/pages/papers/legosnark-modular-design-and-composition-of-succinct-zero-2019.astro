---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/142';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'LegoSNARK: Modular Design and Composition of Succinct Zero-Knowledge Proofs';
const AUTHORS_HTML = 'Matteo Campanelli, Dario Fiore, Anaïs Querol';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli^{1}, Dario Fiore^{1}, and Anaïs Querol^{1,2}</p>

    <p class="text-gray-300">^{1} IMDEA Software Institute ^{2} Universidad Politécnica de Madrid</p>

    <p class="text-gray-300">matteo.campanelli@imdea.org dario.fiore@imdea.org anais.querol@imdea.org</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We study the problem of building non-interactive proof systems modularly by linking small specialized “gadget” SNARKs in a lightweight manner. Our motivation is both theoretical and practical. On the theoretical side, modular SNARK designs would be flexible and reusable. In practice, specialized SNARKs have the potential to be more efficient than general-purpose schemes, on which most existing works have focused. If a computation naturally presents different “components” (e.g. one arithmetic circuit and one boolean circuit), a general-purpose scheme would homogenize them to a single representation with a subsequent cost in performance. Through a modular approach one could instead exploit the nuances of a computation and choose the best gadget for each component.</p>

    <p class="text-gray-300">Our contribution is LegoSNARK, a “toolbox” (or framework) for commit-and-prove zkSNARKs (CP-SNARKs) that includes:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>General composition tools: build new CP-SNARKs from proof gadgets for basic relations <em>simply</em>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A “lifting” tool: a compiler to add commit-and-prove capabilities to a broad class of existing zkSNARKs <em>efficiently</em>. This makes them interoperable (linkable) within the same computation. For example, one QAP-based scheme can be used prove one component; another GKR-based scheme can be used to prove another.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A collection of succinct proof gadgets for a variety of relations.</li>

    </ol>

    <p class="text-gray-300">Additionally, through our framework and gadgets, we are able to obtain new succinct proof systems. Notably:</p>

    <p class="text-gray-300">– LegoGro16, a commit-and-prove version of Groth16 zkSNARK, that operates over data committed with a classical Pedersen vector commitment, and that achieves a 5000<span class="math">\\times</span> speedup in proving time.</p>

    <p class="text-gray-300">– LegoUAC, a pairing-based SNARK for arithmetic circuits that has a universal, circuit-independent, CRS, and proving time linear in the number of circuit gates (vs. the recent scheme of Groth et al. (CRYPTO’18) with quadratic CRS and quasilinear proving time).</p>

    <p class="text-gray-300">– CP-SNARKs for matrix multiplication that achieve optimal proving complexity.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A codebase written in C++ for highly composable zkSNARKs with commit-and-prove capabilities.</li>

    </ol>

    <p class="text-gray-300">{}^{a} Available at https://github.com/imdea-software/legosnark.</p>

    <p class="text-gray-300">1 Introduction 4 1.1 Our Results 6 1.2 Related Work 7 1.3 Roadmap 9</p>

    <p class="text-gray-300">2 Preliminaries 9 2.1 Relations 10 2.2 Commitment Schemes 10 2.3 Zero-Knowledge SNARKs 10</p>

    <p class="text-gray-300">3 Building the LegoSNARK Framework 12 3.1 Commit and Prove SNARKs 12 3.2 Composition Properties of CP-SNARKs 13 3.3 Commit-Carrying SNARKs 14 3.4 Existing CP-SNARKs and cc-SNARKs 17 3.5 Bootstrapping our Framework 18</p>

    <p class="text-gray-300">4 CP-SNARKs for Pedersen-like Commitments 20 4.1 CP-SNARK for Pedersen Verification 21 4.2 CP-SNARK for Linear Properties 22</p>

    <p class="text-gray-300">5 Efficient CP-SNARKs for Polynomial Commitments 23 5.1 Preliminaries and Building Blocks 23 5.2 A CP-SNARK for Sum-Check 26 5.3 A CP-SNARK for Hadamard Products 28 5.4 A CP-SNARK for Self Permutation 29 5.5 A CP-SNARK for Linear Properties of Committed Vector 30 5.6 A CP-SNARK for Matrix Multiplication 33</p>

    <p class="text-gray-300">6 LegoSNARK Applications and Evaluation 35 6.1 Preliminaries and Building Blocks 36 6.2 Arithmetic Circuit Satisfiability 37 6.3 Parallel Computation on Joint Inputs 39</p>

    <p class="text-gray-300">7 Experimental Evaluation 41 7.1 Commit-and-Prove SNARKs 41 7.2 Matrix Multiplication 41 7.3 LegoAC1 for Arithmetic Circuits 42 7.4 Parallel Checks on Joint Inputs 43</p>

    <p class="text-gray-300">8 Conclusions 45</p>

    <p class="text-gray-300">A Security proof of CP-SNARK composition</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A.1 Proof of Knowledge Soundness</li>

      <li>A.2 Proof of Zero-Knowledge</li>

      <li>B Proofs for the General Compiler</li>

      <li>B.1 Proof of Knowledge Soundness</li>

      <li>B.2 Proof of Zero-Knowledge</li>

      <li>C Supplementary Results on <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span></li>

      <li>C.1 Proof of <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> Security</li>

      <li>C.2 An extension of <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> for Prefixes of a Committed Vector</li>

      <li>D A zkSNARK for Linear Subspaces</li>

      <li>E A Construction of <span class="math">\\mathsf{PolyCom}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> from zk-vSQL</li>

      <li>F Additional Material on CP-SNARKs for <span class="math">\\mathsf{PolyCom}</span></li>

      <li>F.1 Proof of our <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span></li>

      <li>F.2 Proof of Security of <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span></li>

      <li>F.3 Proof of <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span></li>

      <li>F.4 Proof of <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span></li>

      <li>F.5 A CP-SNARK for Data-Parallel Computations</li>

      <li>G A CP-SNARK for Internal Products from Thaler’s Protocol</li>

      <li>G.1 CMT Protocol</li>

      <li>G.2 Thaler’s Protocol for Trees of Multiplications</li>

      <li>G.3 Adapting zk-vSQL to Thaler’s Protocol</li>

      <li>H Commit and Prove SNARKs from existing schemes</li>

      <li>H.1 “Adaptive Pinocchio” <em>[x21]</em></li>

      <li>H.2 Lipmaa’s Hadamard Product Argument <em>[x10]</em></li>

      <li>H.3 zk-vSQL <em>[ZGK^{+}17b]</em></li>

      <li>H.4 Geppetto <em>[CFH^{+}15]</em></li>

      <li>H.5 cc-SNARKs based on Groth’s SNARK</li>

    </ul>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-knowledge proofs (ZKPs), introduced by Goldwasser, Micali and Rackoff <em>[x10]</em>, let a prover convince a verifier of a statement without revealing more information than its validity. This power of ZKPs—simultaneously providing <em>integrity</em> (the prover cannot cheat) and <em>privacy</em> (the verifier does not learn any of the prover’s secrets)—has found countless applications, including multiparty computation <em>[x11]</em>, signature schemes <em>[x23]</em>, public-key encryption <em>[x24]</em>, and, more recently, blockchain systems <em>[BCG^{+}14, x1]</em>.</p>

    <p class="text-gray-300">Some zero-knowledge proof systems—called <em>succinct</em> or simply <em>zkSNARKs</em>, zero-knowledge Succinct Non-interactive Argument of Knowledge—have short and efficiently verifiable proofs <em>[x18, x12, x5]</em>. Succinctness is desirable in general but is especially critical in applications where verifiers would not invest significant computational resources (e.g. if they are unwilling to do it for reasons of scalability and cost, or if they are computationally weak).</p>

    <p class="text-gray-300">Motivation. The last years have seen remarkable progress in the construction of zkSNARKs. Different lines of work (cf. Section 1.2 for a detailed review) have built a variety of schemes that are highly expressive, supporting general computations in the class NP. The general-purpose nature of these schemes makes them very attractive to practitioners. At the same time, this high expressivity comes at a cost in terms of performance. To achieve generality, these constructions abstract specific features of computation by assuming one <em>single unifying representation</em> (e.g., boolean or arithmetic circuits, state-machine transitions, RAM computations), and this abstraction is often a source of overhead, for two main reasons.</p>

    <p class="text-gray-300">First, <em>general-purpose zk-SNARKs may miss opportunities for significant optimizations</em> by not exploiting the nuances of a computation. In contrast, specialized solutions can gain efficiency by exploiting specific structural properties. For example, recent works <em>[x6, WTas^{+}17]</em> show how to highly optimize the GKR protocol<em>[x12]</em> for the case of parallel computations. A further example is the specialized protocol for the multiplication of <span class="math">n\\times n</span> matrices we propose in Section 5.6. Here, our prover runs in <span class="math">O(n^{2})</span> time as opposed to any circuit-based approach running in at least <span class="math">O(n^{3})</span> time.</p>

    <p class="text-gray-300">Second, <em>computation tends to be heterogeneous</em>, often consisting of several subroutines of different nature, e.g. both arithmetic and boolean components. If we design SNARKs assuming one single general representation then we will not be able to provide the best match for all the different subroutines. In this context specialized protocols are clearly not an answer either as they fail whenever faced with a non homogeneous computation. As a concrete example, the GKR-like protocols mentioned above are highly efficient when executed on parallel computations, but they fail to be succinct if a computation <em>also</em> includes heavily sequential subroutines (e.g. iterated block ciphers).</p>

    <p class="text-gray-300">In contrast, specialized solutions can gain efficiency by exploiting specific structural properties. For example, recent works <em>[x6, WTas^{+}17]</em> show how to highly optimize the GKR protocol<em>[x12]</em> for the case of parallel computations. A further example is the specialized protocol for the multiplication of <span class="math">n\\times n</span> matrices we propose in Section 5.6. Here, our prover runs in <span class="math">O(n^{2})</span> time as opposed to a circuit-based approach running in at least <span class="math">O(n^{3})</span> time.</p>

    <p class="text-gray-300">A Modular Approach for zk-SNARKs. In this paper we study an alternative approach to the design of zkSNARKs that would gain the advantages of specialized proof systems without inheriting their shortcomings when applied to heterogeneous computations. With this goal in mind we propose to build zkSNARKs by proceeding in a modular “bottom-up” fashion. Most current works use a “top-down” approach: they build general-purpose schemes adopting one single representation that *must</p>

    <p class="text-gray-300">be shared across all the different subroutines in the program. On the other hand, in this work we consider designing a “global” SNARK for a computation <span class="math">C</span> through a (lightweight) linking of “smaller” specialized SNARKs for the different subroutines composing <span class="math">C</span>. We call these interlinked specialized SNARKs <em>proof gadgets</em>, as they act as basic building blocks that one can compose and reuse according to the situation.</p>

    <p class="text-gray-300">The modular approach has multiple benefits. First, it allows for <em>reducing complexity</em>: instead of focusing on handling arbitrary computation using a single representation, one can focus on a smaller, more specific problem (e.g., log-depth computation, membership proof, range proof, algebraic group relation etc.), and exploit its nuances to get a more efficient solution. This way, one could maximize efficiency by letting each subroutine of <span class="math">C</span> be handled by a different proof system, specialized and efficient for that type of computation. Second, modularity allows for flexibility and costs reduction: a proof gadget can be reused in several systems and one can easily plug in a new solution, or replace an old one.</p>

    <p class="text-gray-300">Modularity from Commit-and-Prove SNARKs. To realize this modular approach we rely on the well known <em>commit-and-prove</em> (CP) methodology <em>[x13, x10]</em>. With a CP scheme one can prove statements of the form “<span class="math">c_{\\mathsf{ck}}(x)</span> contains <span class="math">x</span> such that <span class="math">R(x,w)</span>” where <span class="math">c_{\\mathsf{ck}}(x)</span> is a commitment. To see how the CP capability can be used for modular composition consider the following example of sequential composition in which one wants to prove that <span class="math">\\exists w:z=h(x;w)</span>, where <span class="math">h(x;w):=g(f(x;w);w)</span>. Such a proof can be built by combining two CP systems <span class="math">\\Pi_{f}</span> and <span class="math">\\Pi_{g}</span> for its two building blocks, i.e., respectively <span class="math">f</span> and <span class="math">g</span>: the prover creates a commitment <span class="math">c_{\\mathsf{ck}}(y)</span> of <span class="math">y</span>, and then uses <span class="math">\\Pi_{f}</span> (resp. <span class="math">\\Pi_{g}</span>) to prove that “<span class="math">c_{\\mathsf{ck}}(y)</span> contains <span class="math">y=f(x;w)</span> (resp. contains <span class="math">y</span> such that <span class="math">z=g(y;w)</span>)”.</p>

    <p class="text-gray-300">Challenges of the CP modular composition. The composition idea sketched above implicitly assumes that <span class="math">\\Pi_{f}</span> and <span class="math">\\Pi_{g}</span> work on the same commitment <span class="math">c_{\\mathsf{ck}}(y)</span>. Namely, <em>in order to be composed, different CP schemes must be compatible with the same commitment scheme</em> (and commitment key). Essentially we need a <em>sort of universal commitment scheme</em> that is as decoupled as possible from the specific argument systems that will operate on it.</p>

    <p class="text-gray-300">We argue that achieving such universality with state-of-the-art zkSNARKs entails major challenges:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Most of the popular zkSNARKs, e.g., <em>[x20, x16]</em>, are not explicitly commit-and-prove. This limitation can be overcome using a (somewhat folklore) approach in which the SNARK <span class="math">\\Pi</span> additionally proves the correct opening of the commitment, i.e., <span class="math">R(x,w)\\land\`\`c_{\\mathsf{ck}}(x)</span> opens to <span class="math">x&quot;</span>. This approach has two main drawbacks: <em>(i)</em> <span class="math">\\Pi</span> must be expressive enough to include the commitment verification in its language, but in our vision <span class="math">\\Pi</span> is a SNARK for a specialized task and may not have this capability; <em>(ii)</em> even if <span class="math">\\Pi</span> were expressive enough (e.g., supports arbitrary circuits), encoding commitment verification incurs significant overheads.</li>

      <li>Some existing SNARKs have commit-and-prove capabilities <em>[x16, CFH^{+}15, x15, x37]</em>. Yet, each of these schemes uses its own specific commitment scheme. In some cases <em>[CFH^{+}15]</em> the commitment keys are <em>relation-dependent</em>, which means commitments cannot be generated before</li>

    </ol>

    <p class="text-gray-300">fixing one or multiple relations.⁶ In the other cases, despite being relation-independent, commitment keys have a very specific structure that may not fit other proof systems. In summary, a main limitation of existing commit-and-prove SNARKs is their incompatibility, between them and with other potentially more efficient candidates to be developed.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.1 Our Results</h2>

    <p class="text-gray-300"><strong>LegoSNARK Framework.</strong> We present LegoSNARK, a framework for commit-and-prove zk-SNARKs (CP-SNARKs) that includes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Definitions</strong> that formalize CP-SNARKs and their variants.</li>

      <li><strong>Composition recipes</strong> that show how to use different CP-SNARKs in a generic and secure way for handling conjunction, disjunction and sequential composition of relations. This composition result enables the use of modularity in designing CP-SNARKs for complex relations out of schemes for simpler relations.</li>

      <li><strong>A generic construction</strong> to efficiently turn a broad class of zkSNARKs into CP-SNARKs that can be composed together. This class includes several existing schemes such as ones based on quadratic arithmetic programs [PHGR13, CFH⁺15, Gro16], or zk-vSQL [ZGK⁺17a, ZGK⁺17b]. For this transformation we only need a “minimal” CP-SNARK, CP_link, for proving that two commitments (under different schemes) open to the same value.</li>

    </ul>

    <p class="text-gray-300"><strong>LegoSNARK Gadgets.</strong> We populate our framework by constructing new CP-SNARKs for several basic relations, such as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>CP_link</strong> for proving that two different Pedersen-like commitments open to the same vector.⁷ Plugging <strong>CP_link</strong> in our generic construction solves the challenges (a) and (b) mentioned above and gives us interoperable versions of several existing schemes.</li>

      <li><strong>CP_lin</strong> for proving that a linear relation <span class="math">\\pmb{F} \\cdot \\pmb{u} = \\pmb{x}</span> holds for a committed vector <span class="math">\\pmb{u}</span>, a public matrix <span class="math">\\pmb{F}</span> and public vector <span class="math">\\pmb{x}</span>.</li>

      <li><strong>CP_had</strong> for proving that a vector <span class="math">\\pmb{u}_0</span> is the Hadamard product of <span class="math">\\pmb{u}_1</span> and <span class="math">\\pmb{u}_2</span>, when all the three vectors are committed.</li>

      <li><strong>CP_sfprm</strong> for proving a self-permutation, i.e., that <span class="math">y_i = y_{\\phi(i)}</span> for a public permutation <span class="math">\\phi</span> and a committed vector <span class="math">\\pmb{y}</span>.</li>

      <li><strong>CP_mm</strong> for proving that matrix <span class="math">\\pmb{X}</span> is the product of committed matrices <span class="math">\\pmb{A}</span> and <span class="math">\\pmb{B}</span>.</li>

    </ul>

    <p class="text-gray-300">All the aforementioned schemes have succinct proofs and work for Pedersen-like commitments in bilinear groups. This means that by using our generic construction with <strong>CP_link</strong> they can be turned to support the same commitment and then be composed.</p>

    <p class="text-gray-300"><strong>LegoSNARK Applications and Evaluation.</strong> Using our initial set of specialized proof gadgets, our next step is to combine them in order to build new succinct proof systems for different use cases, mentioned below. Our results offer various improvements over the state of the art. We have also implemented some of our solutions to test their concrete performance.</p>

    <p class="text-gray-300">⁶ This could be mitigated by using universal circuits, paying a (multiplicative) logarithmic overhead in parameters size and prover complexity.</p>

    <p class="text-gray-300">⁷ By “Pedersen-like” we mean schemes where the verification algorithm is the same as in Pedersen scheme [Ped92] for vectors (but the bases can have a different distribution).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient Commit-Ahead-of-Time. Through our generic construction instantiated with <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> we also obtained commit-and-prove versions of popular efficient zkSNARKs, such as Groth’s <em>[x13]</em>, that can prove statements about data committed using the Pedersen scheme for vectors <em>[x20]</em>, in which bases are random group elements that can be generated without trusted setup. Such commit-and-prove schemes are useful in applications where one needs to commit before the SNARK keys for a relation are created, e.g., to post commitments on a blockchain so that one can later prove statements about the committed data. By applying our solution to <em>[x13]</em> we obtain a scheme that is <span class="math">5000\\times</span> faster than Groth16, where the commitment is encoded in the circuit.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CP-SNARKs for Parallel Computation. Consider the problem of proving (in zero-knowledge) correctness of a computation that consists of the same subcircuit executed in parallel. The recent Hyrax system <em>[WTs^{+}18]</em> is suitably designed for and shows good performances on this type of circuit. It requires, however, an additional verification cost whenever the repeated subcircuits share (non-deterministic) inputs, which is common. The verifier thus pays an additional factor linear in the total width of the circuit. Using our LegoSNARK framework we show how to build a new CP-SNARK based on Hyrax that avoids this problem. The idea is that parallel computation on joint inputs can be expressed as the combination of a fully parallel computation (after inputs were appropriately duplicated) and a permutation check to ensure that inputs have been duplicated correctly. We build this by combining our <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> gadget with a version of Hyrax modified to work with the polynomial commitment of zk-vSQL <em>[ZGK^{+}17b]</em>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CP-SNARKs for Arithmetic Circuits. We give two main constructions of CP-SNARKs for arithmetic circuit (AC) satisfiability. Table 1 summarizes a theoretical comparison with other schemes in the literature (selected among the ones with similar succinctness).</li>

    </ol>

    <p class="text-gray-300">Our first scheme, LegoAC, relies on an encoding of AC based on Hadamard products and linear constraints from <em>[BCC^{+}16]</em> and can be built from <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> gadgets. We evaluate two instantiations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LegoAC1—from our <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> and a <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> from <em>[x17]</em>—is secure in the generic group model (GGM), enjoys constant-size proofs, and has a <span class="math">\\log n</span> factor in proving time (similar to <em>[x22, x13]</em>);</li>

      <li>LegoAC2—from our <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> gadgets—is secure in the GGM and random oracle model, it has <span class="math">\\log n</span>-size proofs but only linear proving time.</li>

    </ul>

    <p class="text-gray-300">The second CP-SNARK, LegoUAC, builds on an encoding of AC based on Hadamard products, additions and permutation from <em>[x13, BCG^{+}17]</em> and can be built from our <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span> gadgets. The main novelty of LegoUAC is to admit a universal, circuit-independent CRS, in the “specialization” model of <em>[GKM^{+}18]</em> where the universal CRS can be specialized to a circuit <span class="math">C</span> with a deterministic algorithm. LegoUAC’s CRS has <span class="math">O(N)</span> size where <span class="math">N</span> is an upper bound on the number of gates of the circuits; in contrast, the CRS has quadratic size in the recent scheme in <em>[GKM^{+}18]</em>. Our LegoUAC also improves on the approach applying an efficient system, say <em>[x13]</em>, on a universal circuit <em>[x29, x11]</em>, which would incur at least a logarithmic multiplicative factor in circuit size.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">The idea of combining two different NIZKs to improve efficiency when handling heterogeneous computations has been considered by Chase et al. <em>[x6]</em> and more recently by Agrawal et</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Uni</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KG time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ver. time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">crs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[PHGR13, Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">n+m</td>

            <td class="px-3 py-2 border-b border-gray-700">m+n log n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n+m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LegoAC1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">n+m</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LegoAC2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">n+m</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GKM+18]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

            <td class="px-3 py-2 border-b border-gray-700">m+n log n</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LegoUAC</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">N*</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log2N</td>

            <td class="px-3 py-2 border-b border-gray-700">N*</td>

            <td class="px-3 py-2 border-b border-gray-700">log2N</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparing pairing-based zkSNARKs for arithmetic circuits with  <span class="math">m</span>  wires and  <span class="math">N</span>  gates, of which  <span class="math">n</span>  are multiplication gates,  <span class="math">n_a</span>  (resp.  <span class="math">n_c</span> ) are addition (resp. multiplication-by-constant) gates, and  <span class="math">N^* = \\max(n, n_a, n_c)</span> . Numbers in the table are in  <span class="math">O(\\cdot)</span>  notation.</p>

    <p class="text-gray-300">al. [AGM18]. In [AGM18], they propose combining the Pinocchio scheme [PHGR13] with Sigma-protocol-based NIZKs and show an efficient construction for computations that combines algebraic relations in a cryptographic group and arbitrary computation. Their approach reveals beneficial and improves performances. The solution in [AGM18] is tailored to two specific proof systems and their combination methodology does not always preserve succinctness. In contrast, our techniques are general, apply to a variety of existing proof systems and preserve succinctness (they compose succinct schemes into succinct schemes).</p>

    <p class="text-gray-300">Succinct ZK Proofs. In the past years several research lines have built a variety of zk-SNARKs for general NP statements. Here we provide an overview of each line, especially focusing on their differences in performance.</p>

    <p class="text-gray-300">A major research line is the one based on the seminal paper of Gennaro et al. [GGPR13] who proposed a pairing-based SNARK based on the NP-complete language of quadratic span/arithmetic programs. This approach improves on previous approaches by Ishai et al. [IKO07], Groth [Gro10] and Lipmaa [Lip12], and is the basis of several works such as [PHGR13, BCG+13, BFR+13, BCTV14, KPP+14, CFH+15, BBFR15, WSR+15, Gro16, FFG+16, GKM+18]. The zkSNARKs in this family enjoy constant-size proofs and fast verification, the latter depending only linearly on the statement size; on the downside, they feature large overheads at proving time, costly (although amortizable) preprocessing and security properties based on non-standard non-falsifiable assumptions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A second research line builds on the MPC-in-the-head approach of Ishai et al. [IKOS07] to construct a ZK argument from an MPC protocol. The first scheme that refined and experimented this approach is ZKBoo [GMO16], then improved in  <span class="math">\\mathrm{[CDG^{+}17]}</span> ; a more recent work in this line is Ligero [AHIV17]. These schemes do not need trusted setup and show excellent proving performances on Boolean circuits, since they rely only on symmetric-key cryptographic primitives. On the downside their proofs are not fully succinct, being linear in the circuit size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in [GMO16], and  </span>\\tilde{O} (\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$  in [AHIV17].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The works  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{a},\\mathrm{ZGK}^{+}17\\mathrm{b},\\mathrm{WTs}^{+}18\\right]</span>  stem from the interactive proof techniques for low-depth circuits pioneered in Goldwasser et al. [GKR08] and later refined in [CMT12, Tha13, WJB  <span class="math">^{+}17]</span> . The resulting succinct ZK arguments are made non-interactive in the random oracle model. These schemes offer good proving performance and use asymptotically fewer cryptographic operations than those from the MPC-in-the-head family; they can be instantiated without  <span class="math">\\left[\\mathrm{WTs}^{+}18\\right]</span>  (or with a circuit-independent  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right]</span> ) trusted setup. On the other hand their proof size and verification time depend on the structure of the circuit at hand, notably on the depth and in some cases on the width.</p>

    <p class="text-gray-300">Building on the work of Groth [Gro09], two recent proposals  <span class="math">\\mathrm{[BCC^{+}16, BBB^{+}17]}</span>  give ZK arguments for arithmetic circuit satisfiability that can be instantiated without trusted setup. The first</p>

    <p class="text-gray-300">scheme of Bootle et al. <em>[BCC^{+}16]</em> has proofs of size <span class="math">O(\\sqrt{M})</span> where <span class="math">M</span> is the number of multiplication gates in the circuit, while their second scheme (improved in <em>[BBB^{+}17]</em>) has proofs of size <span class="math">O(\\log M)</span> but has a linear time verifier.</p>

    <p class="text-gray-300">Compared to the results from the latter three research lines we described, our instantiations have the disadvantage of needing a trusted setup, although in some cases this is universal and thus reusable. In terms of performances, however, our results are more succinct, both in terms of proof size and verifier time.</p>

    <p class="text-gray-300">A recent line of work <em>[x10]</em> builds on the seminal works of Kilian <em>[x22]</em> and Micali <em>[x30]</em>, and generalizations of PCPs (IOPs) <em>[x6, x34]</em> in order to construct systems (dubbed zkSTARKs) that are general-purpose (capturing very general computations that can be expressed as state-machine transitions), do not require trusted setup and offer good timings for prover and verifier. On the downside, the memory costs for the prover are still high and their security relies on a non-standard conjecture about Reed-Solomon codes.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Roadmap</h3>

    <p class="text-gray-300">The paper is organized as follows. Section 2 introduces notation and preliminar definitions. Section 3 provides the basis for building our framework: composing CP-SNARKs, the notion of cc-SNARKs and our compiler to import existing schemes in the framework. Sections 4 and 5 present constructions both for Pedersen-like commitments and polynomial commitments. Section 6 explains how to apply LegoSNARK to build schemes for arithmetic circuits. Section 7 gives experimental details of our library. We conclude in Section 8.</p>

    <p class="text-gray-300">This text is the full work of our shorter version published at CCS’19. Several results only appear in this long version. Namely: security proofs, formal definitions, more schemes and constructions, and further details.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use <span class="math">\\lambda\\in\\mathbb{N}</span> to denote the security parameter, and <span class="math">1^{\\lambda}</span> to denote its unary representation. Throughout the paper we assume that all the algorithms of the cryptographic schemes take as input <span class="math">1^{\\lambda}</span>, and thus we omit it from the list of inputs. For a distribution <span class="math">D</span>, we denote by <span class="math">x\\leftarrow D</span> the fact that <span class="math">x</span> is being sampled according to <span class="math">D</span>. We remind the reader that an ensemble <span class="math">\\mathcal{X}=\\{X_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a family of probability distributions over a family of domains <span class="math">\\mathcal{D}=\\{D_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span>. We say two ensembles <span class="math">\\mathcal{D}=\\{D_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> and <span class="math">\\mathcal{D}^{\\prime}=\\{D^{\\prime}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> are statistically indistinguishable (denoted by <span class="math">\\mathcal{D}\\approx_{s}\\mathcal{D}^{\\prime}</span>) if $\\frac{1}{2}\\sum_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{\\lambda}(x)-D^{\\prime}_{\\lambda}(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\mathsf{negl}(\\lambda)<span class="math">. If </span>\\mathcal{A}=\\{\\mathcal{A}_{\\lambda}\\}<span class="math"> is a (possibly non-uniform) family of circuits and </span>\\mathcal{D}=\\{D_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}<span class="math"> is an ensemble, then we denote by </span>\\mathcal{A}(\\mathcal{D})<span class="math"> the ensemble of the outputs of </span>\\mathcal{A}_{\\lambda}(x)<span class="math"> when </span>x\\leftarrow D_{\\lambda}<span class="math">. We say two ensembles </span>\\mathcal{D}=\\{D_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}<span class="math"> and </span>\\mathcal{D}^{\\prime}=\\{D^{\\prime}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}<span class="math"> are computationally indistinguishable (denoted by </span>\\mathcal{D}\\approx_{c}\\mathcal{D}^{\\prime}<span class="math">) if for every non-uniform polynomial time distinguisher </span>\\mathcal{A}<span class="math"> we have </span>\\mathcal{A}(\\mathcal{D})\\approx_{s}\\mathcal{A}(\\mathcal{D}^{\\prime})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote by <span class="math">[n]</span> the set of integers <span class="math">\\{1,\\ldots,n\\}</span> and by <span class="math">[:n]</span> the set <span class="math">\\{0,1,\\ldots,n-1\\}</span>. By <span class="math">(u_{j})_{j\\in[\\ell]}</span> we denote the tuple <span class="math">(u_{1},\\ldots,u_{\\ell})</span>.</p>

    <p class="text-gray-300">2.1 Relations</p>

    <p class="text-gray-300">Let <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be a family of polynomial-time decidable relations <span class="math">R</span> on pairs <span class="math">(x,w)</span> where <span class="math">x\\in\\mathcal{D}_{x}</span> is called the <em>statement</em> or <em>input</em>, and <span class="math">w\\in\\mathcal{D}_{w}</span> the <em>witness</em>. We write <span class="math">R(x,w)=1</span> to denote that <span class="math">R</span> holds on <span class="math">(x,w)</span>, else we write <span class="math">R(x,w)=0</span>. When discussing schemes that prove statements on committed values we assume that <span class="math">\\mathcal{D}_{w}</span> can be split in two subdomains <span class="math">\\mathcal{D}_{u}\\times\\mathcal{D}_{\\omega}</span>. Finally we sometimes use an even finer grained specification of <span class="math">\\mathcal{D}_{u}</span> assuming we can split it over <span class="math">\\ell</span> arbitrary domains <span class="math">(\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{\\ell})</span> for some arity <span class="math">\\ell</span>. In our security definitions we assume relations to be generated by a <em>relation generator</em> <span class="math">\\mathcal{RG}(1^{\\lambda})</span> that, on input the security parameter <span class="math">1^{\\lambda}</span>, outputs <span class="math">R</span> together with some side information, an auxiliary input <span class="math">\\mathsf{aux}_{R}</span>, that is given to the adversary. We define <span class="math">\\mathcal{RG}_{\\lambda}</span> as the set of all relations that can be returned by <span class="math">\\mathcal{RG}(1^{\\lambda})</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.2 Commitment Schemes</h3>

    <p class="text-gray-300">We recall the notion of non-interactive commitment schemes.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.1.</h6>

    <p class="text-gray-300">A commitment scheme is a tuple of algorithms <span class="math">\\mathsf{Com}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCommit})</span> that work as follows and satisfy the notions of correctness, binding and hiding defined below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{ck}</span> takes the security parameter and outputs a commitment key <span class="math">\\mathsf{ck}</span>. This key includes descriptions of the input space <span class="math">\\mathcal{D}</span>, commitment space <span class="math">\\mathcal{C}</span> and opening space <span class="math">\\mathcal{O}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{ck},u)\\to(c,o)</span> takes the commitment key <span class="math">\\mathsf{ck}</span> and a value <span class="math">u\\in\\mathcal{D}</span>, and outputs a commitment <span class="math">c</span> and an opening <span class="math">o</span>.</li>

      <li><span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c,u,o)\\to b</span> takes as input a commitment <span class="math">c</span>, a value <span class="math">u</span> and an opening <span class="math">o</span>, and accepts <span class="math">(b=1)</span> or rejects <span class="math">(b=0)</span>.</li>

    </ul>

    <p class="text-gray-300">Correctness. For all <span class="math">\\lambda\\in\\mathbb{N}</span> and any input <span class="math">u\\in\\mathcal{D}</span> we have:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{ck}\\leftarrow\\mathsf{Setup}(1^{\\lambda}),(c,o)\\leftarrow\\mathsf{Commit}(\\mathsf{ck},u):\\mathsf{VerCommit}(\\mathsf{ck},c,u,o)=1\\right]=1.</span></p>

    <p class="text-gray-300">Binding. For every polynomial-time adversary <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}\\mathsf{ck}\\leftarrow\\mathsf{Setup}(1^{\\lambda})&u\\neq u^{\\prime}\\wedge\\ \\mathsf{VerCommit}(\\mathsf{ck},c,u,o)=1\\\\ (c,u,o,u^{\\prime},o^{\\prime})\\leftarrow\\mathcal{A}(\\mathsf{ck})&\\wedge\\ \\mathsf{VerCommit}(\\mathsf{ck},c,u^{\\prime},o^{\\prime})=1\\end{matrix}\\right]=\\mathsf{negl} \\]</p>

    <p class="text-gray-300">Hiding. For <span class="math">\\mathsf{ck}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> and <span class="math">\\forall</span> <span class="math">u,u^{\\prime}\\in\\mathcal{D}</span>, the following two distributions are statistically close:</p>

    <p class="text-gray-300"><span class="math">\\{c:(c,o)\\leftarrow\\mathsf{Commit}(\\mathsf{ck},u)\\}\\approx\\{c^{\\prime}:(c^{\\prime},o^{\\prime})\\leftarrow\\mathsf{Commit}(\\mathsf{ck},u^{\\prime})\\}</span></p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.3 Zero-Knowledge SNARKs</h3>

    <p class="text-gray-300">We recall the definition of (pre-processing) zero-knowledge succinct non-interactive arguments of knowledge (zkSNARKs, for short) <em>[BCC+12, BCC+17]</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.2 (SNARK).</h6>

    <p class="text-gray-300">A SNARK for <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a triple of algorithms <span class="math">\\Pi=(\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{VerProof})</span> that work as follows and satisfy the notions of completeness, succinctness and knowledge soundness defined below. If <span class="math">\\Pi</span> also satisfies zero-knowledge we call it a zkSNARK.</p>

    <p class="text-gray-300">######</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}(R)\\to(\\mathsf{ek},\\mathsf{vk})</span> takes the security parameter <span class="math">\\lambda</span> and a relation <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>, and outputs a common reference string consisting of an evaluation and a verification key.</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{ek},x,w)\\to\\pi</span> takes an evaluation key for a relation <span class="math">R</span>, a statement <span class="math">x</span>, and a witness <span class="math">w</span> such that <span class="math">R(x,w)</span> holds, and returns a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{VerProof}(\\mathsf{vk},x,\\pi)\\to b</span> takes a verification key, a statement <span class="math">x</span>, and either accepts (<span class="math">b=1</span>) or rejects (<span class="math">b=0</span>) the proof <span class="math">\\pi</span>.</li>

    </ul>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Completeness.</h4>

    <p class="text-gray-300">For any pair <span class="math">(x,w)</span> satisfying the relation, the verifier always accepts the corresponding proof. Formally, <span class="math">\\forall\\lambda\\in\\mathbb{N}</span>, <span class="math">R\\in\\mathcal{R}_{\\lambda}</span> and <span class="math">(x,w)</span> such that <span class="math">R(x,w)</span>, it holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr[(\\mathsf{ek},\\mathsf{vk})\\leftarrow\\mathsf{KeyGen}(R),\\pi\\leftarrow\\mathsf{Prove}(\\mathsf{ek},x,w):\\mathsf{VerProof}(\\mathsf{vk},x,\\pi)=1]=1</span></p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Succinctness.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pi</span> is said succinct if the running time of <span class="math">\\mathsf{VerProof}</span> is $\\mathsf{poly}(\\lambda)(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the proof size is </span>\\mathsf{poly}(\\lambda)(\\lambda+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Knowledge Soundness.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathcal{RG}</span> be a relation generator such that <span class="math">\\mathcal{RG}_{\\lambda}\\subseteq\\mathcal{R}_{\\lambda}</span>. <span class="math">\\Pi</span> has knowledge soundness for <span class="math">\\mathcal{RG}</span> and auxiliary input distribution <span class="math">\\mathcal{Z}</span>, denoted <span class="math">\\mathsf{KSND}(\\mathcal{RG},\\mathcal{Z})</span> for brevity, if for every (non-uniform) efficient adversary <span class="math">\\mathcal{A}</span> there exists a (non-uniform) efficient extractor <span class="math">\\mathcal{E}</span> such that <span class="math">\\Pr[\\mathsf{Game}^{\\mathsf{KSND}}_{\\mathcal{RG},\\mathcal{Z},\\mathcal{A},\\mathcal{E}}=1]=\\mathsf{negl}</span>. We say that <span class="math">\\Pi</span> is knowledge sound if there exists benign <span class="math">\\mathcal{RG}</span> and <span class="math">\\mathcal{Z}</span> such that <span class="math">\\Pi</span> is <span class="math">\\mathsf{KSND}(\\mathcal{RG},\\mathcal{Z})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}^{\\mathsf{KSND}}_{\\mathcal{RG},\\mathcal{Z},\\mathcal{A},\\mathcal{E}}\\to b</span> <span class="math">(R,\\mathsf{aux}_{R})\\leftarrow\\mathcal{RG}(1^{\\lambda})\\ \\ ;\\ \\mathsf{crs}:=(\\mathsf{ek},\\mathsf{vk})\\leftarrow\\mathsf{KeyGen}(R)\\ \\ ;\\ \\mathsf{aux}_{Z}\\leftarrow\\mathcal{Z}(R,\\mathsf{aux}_{R},\\mathsf{crs})</span> <span class="math">(x,\\pi)\\leftarrow\\ \\mathcal{A}(R,\\mathsf{crs},\\mathsf{aux}_{R},\\mathsf{aux}_{Z})\\ \\ ;\\ w\\leftarrow\\ \\mathcal{E}(R,\\mathsf{crs},\\mathsf{aux}_{R},\\mathsf{aux}_{Z})\\ \\ ;\\ b=\\mathsf{VerProof}(\\mathsf{vk},x,\\pi)\\ \\land\\neg R(x,w)</span></p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Composable Zero-Knowledge.</h4>

    <p class="text-gray-300">A scheme <span class="math">\\Pi</span> satisfies composable zero-knowledge for a relation generator <span class="math">\\mathcal{RG}</span> if there exists a simulator <span class="math">\\mathcal{S}=(\\mathcal{S}_{\\mathsf{kg}},\\mathcal{S}_{\\mathsf{prv}})</span> such that both following conditions hold for all adversaries <span class="math">\\mathcal{A}</span>:</p>

    <p class="text-gray-300">Keys Indistinguishability.</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(R,\\mathsf{aux}_{R})\\leftarrow\\mathcal{RG}(1^{\\lambda}),\\mathsf{crs}\\leftarrow\\mathsf{KeyGen}(R):\\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_{R})=1\\right]</span> <span class="math">\\approx\\Pr\\left[(R,\\mathsf{aux}_{R})\\leftarrow\\mathcal{RG}(1^{\\lambda}),(\\mathsf{crs},\\mathsf{td}_{\\mathsf{k}})\\leftarrow\\mathcal{S}_{\\mathsf{kg}}(R):\\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_{R})=1\\right]</span></p>

    <p class="text-gray-300">Proof Indistinguishability. For all <span class="math">(x,w)</span> such that <span class="math">R(x,w)=1</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[(R,\\mathsf{aux}_{R})\\leftarrow\\mathcal{RG}(1^{\\lambda}),(\\mathsf{crs},\\mathsf{td}_{\\mathsf{k}})\\leftarrow\\mathcal{S}_{\\mathsf{kg}}(R):\\pi\\leftarrow\\mathsf{Prove}(\\mathsf{ek},x,w),\\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_{R},\\pi)=1\\right]</span> <span class="math">\\approx\\Pr\\left[(R,\\mathsf{aux}_{R})\\leftarrow\\mathcal{RG}(1^{\\lambda}),(\\mathsf{crs},\\mathsf{td}_{\\mathsf{k}})\\leftarrow\\mathcal{S}_{\\mathsf{kg}}(R):\\pi\\leftarrow\\mathcal{S}_{\\mathsf{prv}}(\\mathsf{crs},\\mathsf{td}_{\\mathsf{k}},x),\\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_{R},\\pi)=1\\right]</span></p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">In the notion of knowledge soundness defined above we consider two kinds of auxiliary inputs, <span class="math">\\mathsf{aux}_{R}</span> generated together with the relation by <span class="math">\\mathcal{RG}</span>, and <span class="math">\\mathsf{aux}_{Z}</span> that is generated from some distribution <span class="math">\\mathcal{Z}</span> that may depend on the common reference string that in turn depends on <span class="math">R</span>. An example of this appears in our proof of Theorem B.1. Notice that although our notion is implied by a notion where auxiliary inputs can be arbitrary, our aim is a precise formalization of auxiliary inputs; this is useful to justify why certain auxiliary inputs should be considered benign, as required to avoid known impossibility results <em>[x1, x2]</em>. Finally, we also note that our notion is also implied by SNARKs that admit black-box extractors (as may be the case for those relying on random oracles <em>[x10]</em>).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">zkSNARKs with Specializable Universal CRS</p>

    <p class="text-gray-300">In the SNARK notion presented above, the common reference string generated by KeyGen is tied to a specific relation <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>. A variant of this notion is that of SNARKs for universal relations in which the output of KeyGen depends only on the family <span class="math">\\mathcal{R}_{\\lambda}</span> and can be used to prove and verify statements about any <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>. Due to the practical concerns on the execution of KeyGen, SNARKs for universal relations are more convenient as one can reuse and amortize the cost of one setup. In a recent work, Groth et al. <em>[GKM^{+}18]</em> introduced the notion of <em>zkSNARK with specializable universal common reference string</em>. In a nutshell, this notion formalizes the idea that key generation for <span class="math">R</span> can be seen as the sequential combination of two steps: a first probabilistic algorithm that generates a CRS for the universal relation, and a second <em>deterministic</em> algorithm that specializes this universal CRS into one for a specific <span class="math">R</span>. We remark that our UC SNARKs follow this model.</p>

    <p class="text-gray-300">More formally, let <span class="math">\\mathcal{R}_{\\lambda}</span> be a family of relations. The universal relation <span class="math">R^{<em>}</span> for <span class="math">\\mathcal{R}_{\\lambda}</span> defines a language with instances <span class="math">(R,x)</span> such that <span class="math">R^{</em>}(R,x,w)</span> holds iff <span class="math">R\\in\\mathcal{R}_{\\lambda}</span> and <span class="math">R(x,w)</span> holds.</p>

    <p class="text-gray-300">A <span class="math">\\Pi=(\\textsf{KeyGen},\\textsf{Prove},\\textsf{VerProof})</span> is said a <em>zkSNARK with specializable universal common reference string</em> <em>[GKM^{+}18]</em> if there exist algorithms <span class="math">\\textsf{Derive},\\textsf{Prove}^{<em>},\\textsf{VerProof}^{</em>}</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsf{Derive}(\\textsf{crs},R)\\to\\textsf{crs}_{R}</span> is a <em>deterministic</em> algorithm that takes as input a <span class="math">\\textsf{crs}:=(\\textsf{ek},\\textsf{vk})</span> produced by <span class="math">\\textsf{KeyGen}(R^{*})</span> and a relation <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>, and outputs a specialized common reference string <span class="math">\\textsf{crs}_{R}:=(\\textsf{ek}_{R},\\textsf{vk}_{R})</span>.</li>

      <li><span class="math">\\textsf{Prove}(\\textsf{ek},(R,x),w)\\to\\pi</span> runs <span class="math">(\\textsf{ek}_{R},\\textsf{vk}_{R})\\leftarrow\\textsf{Derive}(\\textsf{crs},R)</span> and returns <span class="math">\\pi\\leftarrow\\textsf{Prove}^{*}(\\textsf{ek}_{R},x,w)</span>.</li>

      <li><span class="math">\\textsf{VerProof}(\\textsf{vk},(R,x),\\pi)\\to b</span> runs <span class="math">(\\textsf{ek}_{R},\\textsf{vk}_{R})\\leftarrow\\textsf{Derive}(\\textsf{crs},R)</span> and returns <span class="math">b\\leftarrow\\textsf{VerProof}^{*}(\\textsf{vk}_{R},x,\\pi)</span>.</li>

    </ul>

    <h2 id="sec-17" class="text-2xl font-bold">3 Building the LegoSNARK Framework</h2>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 Commit and Prove SNARKs</h3>

    <p class="text-gray-300">In a nutshell, a <em>commit-and-prove SNARK</em> (CP-SNARK) is a SNARK that can prove knowledge of <span class="math">(x,w)</span> such that <span class="math">R(x,w)</span> holds w.r.t. a witness <span class="math">w=(u,\\omega)</span> and <span class="math">u</span> opens a commitment <span class="math">c_{u}</span>. Our formal definitions below add some syntactic sugar to this idea to explicitly handle relations where the input domain <span class="math">\\mathcal{D}_{u}</span> is more fine grained and splits over <span class="math">\\ell</span> subdomains. For reasons that will shortly become clear, we call these subdomains <em>commitment slots</em>. This splitting is often natural (e.g., if <span class="math">u</span> is a binary string, one can think of <span class="math">u:=(u_{1},\\ldots,u_{\\ell})</span> for suitable substrings), and it is crucial to exploit the compositional power of CP-SNARKs, as we show in Section 3.2. We assume the description of the splitting is part of <span class="math">R</span>’s description.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3.1 (CP-SNARKs).</h6>

    <p class="text-gray-300">Let <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be a family of relations <span class="math">R</span> over <span class="math">\\mathcal{D}_{x}\\times\\mathcal{D}_{u}\\times\\mathcal{D}_{\\omega}</span> such that <span class="math">\\mathcal{D}_{u}</span> splits over <span class="math">\\ell</span> arbitrary domains <span class="math">(\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{\\ell})</span> for some arity parameter <span class="math">\\ell\\geq 1</span>. Let <span class="math">\\textsf{Com}=(\\textsf{Setup},\\textsf{Commit},\\textsf{VerCommit})</span> be a commitment scheme (as per Definition 2.1) whose input space <span class="math">\\mathcal{D}</span> is such that <span class="math">\\mathcal{D}_{i}\\subset\\mathcal{D}</span> for all <span class="math">i\\in[\\ell]</span>. A commit and prove zkSNARK for <span class="math">\\textsf{Com}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a zkSNARK for a family of relations <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\textsf{Com}}\\}_{\\lambda\\in\\mathbb{N}}</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>every <span class="math">\\textsf{R}\\in\\mathcal{R}^{\\textsf{Com}}</span> is represented by a pair <span class="math">(\\textsf{ck},R)</span> where <span class="math">\\textsf{ck}\\in\\textsf{Setup}(1^{\\lambda})</span> and <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>;</li>

      <li><span class="math">\\textsf{R}</span> is over pairs <span class="math">(\\textsf{x},\\textsf{w})</span> where the statement is <span class="math">\\textsf{x}:=(x,(c_{j})_{j\\in[\\ell]})\\in\\mathcal{D}_{x}\\times\\mathcal{C}^{\\ell}</span>, the witness is <span class="math">\\textsf{w}:=((u_{j})_{j\\in[\\ell]},(o_{j})_{j\\in[\\ell]},\\omega)\\in\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{\\ell}\\times\\mathcal{O}^{\\ell}\\times\\mathcal{D}_{\\omega}</span>, and the relation <span class="math">\\textsf{R}</span> holds iff</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bigwedge_{j\\in[\\ell]}\\textsf{VerCommit}(\\textsf{ck},c_{j},u_{j},o_{j})=1\\wedge R(x,(u_{j})_{j\\in[\\ell]},\\omega)=1</span></p>

    <p class="text-gray-300">Furthermore, when we say that <span class="math">\\mathsf{CP}</span> is knowledge-sound for a relation generator <span class="math">\\mathcal{RG}</span> and auxiliary input generator <span class="math">\\mathcal{Z}</span> (denoted <span class="math">\\mathsf{KSND}(\\mathcal{RG},\\mathcal{Z})</span>, for short) we mean it is a knowledge-sound SNARK for the relation generator <span class="math">\\mathcal{RG}_{\\mathsf{Com}}(1^{\\lambda})</span> that runs <span class="math">\\mathsf{ck} \\gets \\mathsf{Setup}(1^{\\lambda})</span> and <span class="math">(R,\\mathsf{aux}_R) \\gets \\mathcal{RG}(1^{\\lambda})</span>, and returns <span class="math">((\\mathsf{ck},R),\\mathsf{aux}_R)</span>.</p>

    <p class="text-gray-300">We denote a CP-SNARK as a triple of algorithms <span class="math">\\mathsf{CP} = (\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{VerProof})</span>. For ease of exposition, in our constructions we adopt the syntax for CP's algorithms defined below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}(\\mathsf{ck},R)\\to \\mathsf{crs} := (\\mathsf{ek},\\mathsf{vk})</span> generates the common reference string.</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{ek},x,(c_j)_{j\\in [\\ell]},(u_j)_{j\\in [\\ell]},(o_j)_{j\\in [\\ell]},\\omega)\\to \\pi</span> outputs the proof of correct commitment.</li>

      <li><span class="math">\\mathsf{VerProof}(\\mathsf{vk},x,(c_j)_{j\\in [\\ell]},\\pi)\\to b\\in \\{0,1\\}</span> rejects or accepts the proof.</li>

    </ul>

    <p class="text-gray-300">Remark 3.1 (Comparing with existing definitions). To define the Geppetto scheme <span class="math">\\left[\\mathrm{CFH}^{+}15\\right]</span> the authors define a notion of commit-and-prove SNARKs. Here we highlight the main differences between their definition and ours. First, our commitment key can be generated without fixing a priori a relation (or a set of relations, e.g., a multi-QAP). Second, in their model one needs to commit to data using a commitment key corresponding to a specific portion of the input (in their lingo a "bank"), whereas in our model one can just commit to a vector of data, and only at proving time one assigns that data to a specific input slot. Third, we do not require commitments to have a trapdoor. Our notion is closer to the one given by Lipmaa [Lip16] (although [Lip16] uses trapdoor commitments) and is in fact a specialized SNARK notion when considering relation families including verifying openings of commitments.</p>

    <h2 id="sec-20" class="text-2xl font-bold">3.2 Composition Properties of CP-SNARKs</h2>

    <p class="text-gray-300">In this section, we formally show how the commit-and-prove capability can be used to combine different CP-SNARKs securely.</p>

    <p class="text-gray-300"><strong>Conjunction of relations with shared inputs.</strong> Let <span class="math">\\{\\mathcal{R}_{\\lambda}^{(0)}\\}_{\\lambda \\in \\mathbb{N}}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}^{(1)}\\}_{\\lambda \\in \\mathbb{N}}</span> be two families of relations such that, for every <span class="math">\\lambda \\in \\mathbb{N}</span> the input domains <span class="math">\\mathcal{D}_u^{(0)}</span> and <span class="math">\\mathcal{D}_u^{(1)}</span> of relations <span class="math">R_0 \\in \\mathcal{R}_{\\lambda}^{(0)}</span> and <span class="math">R_1 \\in \\mathcal{R}_{\\lambda}^{(1)}</span> respectively can split as follows: <span class="math">\\mathcal{D}_u^{(0)} := \\mathcal{D}_0 \\times \\mathcal{D}_2</span> and <span class="math">\\mathcal{D}_u^{(1)} := \\mathcal{D}_1 \\times \\mathcal{D}_2&#x27;</span> with <span class="math">\\mathcal{D}_2 = \\mathcal{D}_2&#x27;</span>. In other words we require these relations to share a commitment slot that we call the shared slot.</p>

    <p class="text-gray-300">Given the above relation families, we define <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\wedge}\\}_{\\lambda \\in \\mathbb{N}}</span> as the family of relations where for every <span class="math">\\lambda \\in \\mathbb{N}</span>, <span class="math">\\mathcal{R}_{\\lambda}^{\\wedge} = \\{R_{R_0,R_1}^{\\wedge}:R_0\\in \\mathcal{R}_{\\lambda}^{(0)},R_1\\in \\mathcal{R}_{\\lambda}^{(1)}\\}</span> and <span class="math">R_{R_0,R_1}^{\\wedge}(x_0,x_1,u_0,u_1,u_2,w^*)</span> is defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">R _ {R _ {0}, R _ {1}} ^ {\\wedge} \\left(x _ {0}, x _ {1}, u _ {0}, u _ {1}, u _ {2}, \\left(w _ {0}, w _ {1}\\right)\\right) := R _ {0} \\left(x _ {0}, u _ {0}, u _ {2}, w _ {0}\\right) \\wedge R _ {1} \\left(x _ {1}, u _ {1}, u _ {2}, w _ {1}\\right)</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Com}</span> be a commitment scheme, for <span class="math">b\\in \\{0,1\\}</span> let <span class="math">\\mathsf{CP}_b</span> be a CP-SNARK for <span class="math">\\mathsf{Com}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}^{(b)}\\}_{\\lambda \\in \\mathbb{N}}</span>. In Figure 1 we show a construction of a CP-SNARK <span class="math">\\mathsf{CP}^{\\wedge}</span> for <span class="math">\\mathsf{Com}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\wedge}\\}_{\\lambda \\in \\mathbb{N}}</span>. It is also easy to see that if both <span class="math">\\mathsf{CP}_0</span> and <span class="math">\\mathsf{CP}_1</span> are CP-SNARKs with specializable universal CRS, then so is the resulting <span class="math">\\mathsf{CP}^{\\wedge}</span>.</p>

    <p class="text-gray-300">Theorem 3.1. If <span class="math">\\mathsf{Com}</span> is a computationally binding commitment and, for <span class="math">b\\in \\{0,1\\}</span>, <span class="math">\\mathsf{CP}_b</span> is a zero-knowledge CP-SNARK for <span class="math">\\mathsf{Com}</span> and relation family <span class="math">\\{\\mathcal{R}_{\\lambda}^{(b)}\\}_{\\lambda \\in \\mathbb{N}}</span>, then there is a zero-knowledge CP-SNARK <span class="math">\\mathsf{CP}^{\\wedge}</span> for <span class="math">\\mathsf{Com}</span> and <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\wedge}\\}_{\\lambda \\in \\mathbb{N}}</span>.</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: CP-SNARK construction for AND composition</p>

    <p class="text-gray-300">Correctness and succinctness follow by inspection. Knowledge-soundness and zero-knowledge follow rather easily from the respective properties of the underlying schemes. In particular, for knowledge-soundness the basic idea is that in order for an adversary to break  <span class="math">\\mathsf{CP}^{\\wedge}</span>  it must break either one of the two underlying schemes,  <span class="math">\\mathsf{CP}_0, \\mathsf{CP}_1</span> , or the binding of the commitment scheme. We give a full proof of knowledge-soundness and zero-knowledge in Appendix A.</p>

    <p class="text-gray-300">Functions composition. A CP-SNARK for conjunction of relations can be easily used for proving correctness of composed functions, e.g., proving that  <span class="math">\\exists (y,w):z = f(x,y,w)</span> , where  <span class="math">f(x,y,w) := h(g(x,w),y)</span> . Indeed, let  <span class="math">R_{h}(x^{\\prime},y,z) = 1</span>  iff  <span class="math">\\exists (x^{\\prime},y):h(x^{\\prime},y) = z</span> , and  <span class="math">R_{g}(x,x^{\\prime}) = 1</span>  iff  <span class="math">\\exists (x^{\\prime},w): g(x,w) = x^{\\prime}</span> , then  <span class="math">\\exists (y,w):z = f(x,y,w)</span>  can be expressed as  <span class="math">R_{h}(x^{\\prime},y,z) \\wedge R_{g}(x,x^{\\prime})</span> .</p>

    <p class="text-gray-300">Disjunction of relations with shared inputs. We can reduce the case of OR composition to the conjunction construction above. For this we assume relations are defined over elements of a ring. For a relation  <span class="math">R(u)</span>  denote by  <span class="math">\\hat{R}(u, t)</span>  the relation such that  <span class="math">\\hat{R}(u, 0) = 1</span>  iff  <span class="math">R(u) = 1</span>  and  <span class="math">\\hat{R}(u, t) = 1</span>  iff  <span class="math">R(u) = 0</span>  whenever  <span class="math">t \\neq 0</span> . We can now express the disjunction of  <span class="math">R_0(u_0)</span> ,  <span class="math">R_1(u_1)</span>  as  <span class="math">R_{R_0,R_1}^{\\vee}(u_0,u_1,t_0,t_1) := \\hat{R}_0(u_0,t_0) \\wedge \\hat{R}_1(u_1,t_1) \\wedge t_0t_1 = 0</span> . For this approach to work we need the proof systems for the two relations  <span class="math">R_0,R_1</span>  to support their modified version  <span class="math">\\hat{R}_0,\\hat{R}_1</span> , which is the case for proof systems supporting general arithmetic or boolean circuits. Finally, we need a simple efficient proof system for the relation  <span class="math">R_{\\mathrm{mul}}(t_0,t_1) = 1</span>  iff  <span class="math">t_0 \\cdot t_1 = 0</span> , where both  <span class="math">t_0</span>  and  <span class="math">t_1</span>  are committed in two different slots.</p>

    <p class="text-gray-300">Composing more than two relations. By iterating the application of our Theorem 3.1 we can build CP-SNARKs that handle conjunctions and/or disjunctions of more than two relations. In order to maintain the succinctness property, one should apply composition only a small (e.g., constant, logarithmic) number of times. However, this is arguably the case when we deal with real-world heterogeneous computations. The following example scenarios consider heterogeneous computations that can be split naturally into two "homogeneous" components: square-and-multiply algorithms (splitting the relation into the conjunction of all the iterated squarings and the final inner product), aggregation queries to a database (that can be split in a "filter" and an "aggregate" component), proving a property  <span class="math">P</span>  for a datum in a Merkle tree, as done in Zcash [BCG+14] (that can be split in a membership verification component and the property  <span class="math">P</span> , which could in turn be decomposed further).</p>

    <p class="text-gray-300">In this section we define a variant of SNARKs that lies in between standard SNARKs and CP-SNARKs. We call these schemes SNARKs with commit-carrying proofs (or commit-carrying SNARKs,</p>

    <p class="text-gray-300">cc-SNARKs for short). In a nutshell, a cc-SNARK is like a SNARK in which the proof contains a commitment to the portion <span class="math">u</span> of the witness. Essentially the difference is that in cc-SNARKs we assume the extractor outputs the opening of the commitment returned along with the proof. Formalizing this idea requires to make explicit the commitment scheme associated to the SNARK, as well as the commitment key that is part of the common reference string. In the next section we discuss how many of the existing SNARK constructions satisfy this property. Later, in Section 3.5 we show that cc-SNARKs can be lifted to become full fledged, composable, CP-SNARKs. These two results together allow us to compose several existing SNARKs. We define commit-carrying SNARKs as follows:</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 3.2 (cc-SNARK).</h6>

    <p class="text-gray-300">A <em>commit-carrying zkSNARKs</em> for <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a tuple of algorithms <span class="math">\\mathsf{cc}\\Pi=(\\mathsf{KeyGen},\\mathsf{Prove},\\mathsf{VerProof},\\mathsf{VerCommit})</span> that work as follows and satisfy the notions of <em>completeness</em>, succinctness, knowledge soundness, zero knowledge and binding <em>as defined below</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}(R)\\to(\\mathsf{ck},\\mathsf{ek},\\mathsf{vk})</span>: the key generation takes as input the security parameter <span class="math">\\lambda</span> and a relation <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>, and outputs a common reference string that includes a commitment key, an evaluation key and verification key.</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{ek},x,w)\\to(c,\\pi;o)</span>: the proving algorithm takes as input an evaluation key, a statement <span class="math">x</span> and a witness <span class="math">w:=(u,\\omega)</span> such that the relation <span class="math">R(x,u,\\omega)</span> holds, and it outputs a proof <span class="math">\\pi</span>, a commitment <span class="math">c</span> and opening <span class="math">o</span> such that <span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c,u,o)=1</span>.</li>

      <li><span class="math">\\mathsf{VerProof}(\\mathsf{vk},x,c,\\pi)\\to b</span>: the verification algorithm takes a verification key, a statement <span class="math">x</span>, a commitment <span class="math">c</span>, and either accepts (<span class="math">b=1</span>) or rejects (<span class="math">b=0</span>) the proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c,u,o)\\to b</span>: the commitment verification algorithm takes as input a commitment key, a commitment <span class="math">c</span>, a message <span class="math">u</span> and an opening <span class="math">o</span> and accepts (<span class="math">b=1</span>) or rejects (<span class="math">b=0</span>).</li>

    </ul>

    <p class="text-gray-300">cc-SNARKs can be seen as a less versatile version of CP-SNARKs (clearly, a CP-SNARK implies a cc-SNARK). In a cc-SNARK the commitment key depends on the relation taken by <span class="math">\\mathsf{KeyGen}</span>, and a commitment is freshly created by the <span class="math">\\mathsf{Prove}</span> algorithm and is tied to a single proof; in a CP-SNARK the commitment key is independent of relations and commitments can also be created independently and shared across different proofs. Futhermore, in the literature, there are examples of schemes that lie in between our notions of CP-SNARK and cc-SNARK; this is the case for commit and prove SNARKs in which the commitment key is relation-dependent, e.g., <em>[CFH^{+}15, x27]</em>.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300">For any <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">R\\in\\mathcal{R}_{\\lambda}</span> and <span class="math">(x,w)</span> such that <span class="math">R(x,w)=1</span>, it holds</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{(}(\\mathsf{ck},\\mathsf{ek},\\mathsf{vk})\\leftarrow\\mathsf{KeyGen}(R),(c,\\pi;o)\\leftarrow\\mathsf{Prove}(\\mathsf{ek},x,w):\\mathsf{VerProof}(\\mathsf{vk},x,c,\\pi)\\big{)}=1</span></p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Succinctness.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{cc}\\Pi</span> is said <em>succinct</em> if the running time of <span class="math">\\mathsf{VerProof}</span> is $\\mathsf{poly}(\\lambda)(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the size of the proof is </span>\\mathsf{poly}(\\lambda)\\cdot(\\lambda+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Knowledge Soundness.</h5>

    <p class="text-gray-300">Let <span class="math">\\mathcal{RG}</span> be a relation generator such that <span class="math">\\mathcal{RG}_{\\lambda}\\subseteq\\mathcal{R}_{\\lambda}</span>. <span class="math">\\mathsf{cc}\\Pi</span> satisfies knowledge soundness for <span class="math">\\mathcal{RG}</span> and auxiliary input distribution <span class="math">\\mathcal{Z}</span>, or <span class="math">\\mathsf{ccKSND}(\\mathcal{RG},\\mathcal{Z})</span>, if for every (non-uniform) efficient adversary <span class="math">\\mathcal{A}</span> there exists a (non-uniform) efficient extractor <span class="math">\\mathcal{E}</span> such that <span class="math">\\Pr[\\mathsf{Game}_{\\mathcal{RG},\\mathcal{Z},\\mathcal{A},\\mathcal{E}}^{\\mathsf{ccKSND}}=1]=\\mathsf{negl}</span>. We say that <span class="math">\\mathsf{cc}\\Pi</span> is knowledge sound if there exist benign <span class="math">\\mathcal{RG}</span> and <span class="math">\\mathcal{Z}</span> such that <span class="math">\\mathsf{cc}\\Pi</span> is <span class="math">\\mathsf{ccKSND}(\\mathcal{RG},\\mathcal{Z})</span>.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">|  GameCCKSND RGLZALZ → b ∈ {0,1}  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  (R,auxR) ← RGL(1λ)  |</p>

    <p class="text-gray-300">|  crs := (ck, ek, vk) ← KeyGen(R)  |</p>

    <p class="text-gray-300">|  auxZ ← Z(R, auxR, crs) (x, c, π) ← A(R, crs, auxR, auxZ) (u, o, ω) ← E(R, crs, auxR, auxZ)  |</p>

    <p class="text-gray-300">|  b ← VerProof(vk, x, c, π) = 1 ∧ (VerCommit(ck, c, u, o) = 0 ∨ R(x, u, ω) = 0)  |</p>

    <p class="text-gray-300">Composable Zero-Knowledge. A scheme  <span class="math">\\mathsf{cc}\\varPi</span>  has composable zero-knowledge for a relation generator  <span class="math">\\mathcal{RG}</span>  if for every adversary  <span class="math">\\mathcal{A}</span>  there exists a simulator  <span class="math">S = (S_{\\mathrm{kg}}, S_{\\mathrm{prv}})</span>  such that both following conditions hold for all adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <p class="text-gray-300">KEYS INDISTINGUISHABILITY.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left((R, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} (1 ^ {\\lambda}), \\mathsf {c r s} \\leftarrow \\mathsf {K e y G e n} (R): \\mathcal {A} (\\mathsf {c r s}, \\mathsf {a u x} _ {R}) = 1\\right) \\\\ \\approx \\Pr \\left((R, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} (1 ^ {\\lambda}), (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathcal {S} _ {\\mathsf {k g}} (R): \\mathcal {A} (\\mathsf {c r s}, \\mathsf {a u x} _ {R}) = 1\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">PROOF INDISTINGUISHABILITY.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀(x,w):Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\left[\\begin{array}{c}(R,\\mathsf{aux}_R)\\leftarrow\\mathcal{RG}(1^\\lambda),(\\mathsf{crs},\\mathsf{td}_k)\\leftarrow\\mathcal{S}_{\\mathsf{kg}}(R),(c,\\pi;o)\\leftarrow\\mathsf{Prove}(\\mathsf{ek},x,w)\\\\ \\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_R,c,\\pi)=1\\wedge R(x,w)=1\\end{array}\\right]\\)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≈Pr</td>

            <td class="px-3 py-2 border-b border-gray-700">\\(\\left[\\begin{array}{c}(R,\\mathsf{aux}_R)\\leftarrow\\mathcal{RG}(1^\\lambda),(\\mathsf{crs},\\mathsf{td}_k)\\leftarrow\\mathcal{S}_{\\mathsf{kg}}(R),(c,\\pi)\\leftarrow\\mathcal{S}_{\\mathsf{prv}}(\\mathsf{crs},\\mathsf{td}_k,x)\\\\ \\mathcal{A}(\\mathsf{crs},\\mathsf{aux}_R,c,\\pi)=1\\wedge R(x,w)=1\\end{array}\\right]\\)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Binding. For every polynomial-time adversary  <span class="math">\\mathcal{A}</span>  the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\left[\\begin{array}{c}(R,\\mathsf{aux}_R)\\leftarrow\\mathcal{RG}(1^\\lambda),\\mathsf{crs}:= (\\mathsf{ck},\\mathsf{ek},\\mathsf{vk})\\leftarrow\\mathsf{KeyGen}(R)\\\\(c,u,o,u',o')\\leftarrow\\mathcal{A}(R,\\mathsf{crs},\\mathsf{aux}_R)\\end{array}\\right]\\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VerCommit(ck,c,u',o') ∧ VerCommit(ck,c,u,o) ∧ u ≠ u'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 3.2. While our definitions consider the case where the proof contains a commitment to a portion  <span class="math">u</span>  of the witness  <span class="math">w = (u, \\omega)</span> , notice that this partition of the witness is arbitrary and thus this notion also captures those constructions where the commitment is to the entire witness if one thinks of a void  <span class="math">\\omega</span> .</p>

    <p class="text-gray-300">Let us now define a weaker variant of cc-SNARKs that differs from the one given in Definition 3.2 in that the underlying commitment scheme is not binding in the usual sense. Slightly more in detail, we consider the case where the commitment refers to the whole witness (i.e.,  <span class="math">\\omega</span>  is an empty string) and it is actually possible to find collisions for a given commitment as long as these collisions are among valid witnesses, or more precisely we require to be computationally infeasible to find two different witnesses that validly open the commitment such that one falsifies the relation and the other one satisfies it. Worth noting that our generic compiler can also turn weak cc-SNARKs into CP-SNARKs.</p>

    <p class="text-gray-300">Definition 3.3 (cc-SNARKs with Weak Binding). We define cc-SNARKs with Weak Binding as in Definition 3.2 with two exceptions: we assume that the scheme is defined only for relations such that  <span class="math">\\mathcal{D}_{\\omega} = \\emptyset</span> ; we replace the binding property with the one below.</p>

    <p class="text-gray-300">Weak Binding.  <span class="math">\\forall</span>  polynomial-time adversary  <span class="math">\\mathcal{A}</span>  and  <span class="math">u\\neq u^{\\prime}</span>  the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (R, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} (1 ^ {\\lambda}), \\mathsf {c r s} := (\\mathsf {c k}, \\mathsf {e k}, \\mathsf {v k}) \\leftarrow \\mathsf {K G} (R), (x, c, u, o, u ^ {\\prime}, o ^ {\\prime}, \\pi) \\leftarrow \\mathcal {A} (R, \\mathsf {c r s}, \\mathsf {a u x} _ {R}) \\\\ \\mathsf {V e r C o m m i t} (\\mathsf {c k}, c, u, o) \\wedge \\mathsf {V e r C o m m i t} (\\mathsf {c k}, c, u ^ {\\prime}, o ^ {\\prime}) \\wedge \\mathsf {V e r P r o o f} (\\mathsf {v k}, x, c, \\pi) \\wedge \\neg R (x, u) \\wedge R (x, u ^ {\\prime}) \\end{array} ; \\right]</span></div>

    <p class="text-gray-300">We define yet another variant of cc-SNARKs that differs from the notion of Definition 3.2 in that here the knowledge-soundness extractor may return an opening  <span class="math">o^<em></span>  of the commitment  <span class="math">c</span>  which verifies under an algorithm  <span class="math">\\mathsf{VerCommit}^</em></span>  possibly different from  <span class="math">\\mathsf{VerCommit}</span> . Yet,  <span class="math">\\mathsf{VerCommit}^<em></span>  guarantees a form of binding in the sense that it is computationally infeasible to open the same commitment  <span class="math">c</span>  to two distinct messages  <span class="math">u</span>  and  <span class="math">u^</em></span>  under  <span class="math">\\mathsf{VerCommit}</span>  and  <span class="math">\\mathsf{VerCommit}^*</span>  respectively. We call cc-SNARKs satisfying this notion  <span class="math">cc-SNARKs</span>  with Double Binding. This variant of cc-SNARKs is motivated by obtaining more efficient concrete constructions simply: our generic compiler of Section 3.5 can (without changes) also turn cc-SNARKs with double binding into CP-SNARKs. We use this compilation step to obtain our construction LegoGro16.</p>

    <p class="text-gray-300">Definition 3.4 (cc-SNARKs with Double Binding). We define cc-SNARKs with Double Binding as in Definition 3.2 with the exception that knowledge soundness is replaced by the following property. There exists an algorithm  <span class="math">\\mathsf{VerCommit}^<em>(\\mathsf{ck}, c, u, o^</em>)</span>  which returns a bit such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(i) Let  <span class="math">\\mathcal{RG}</span>  be a relation generator such that  <span class="math">\\mathcal{RG}_{\\lambda} \\subseteq \\mathcal{R}_{\\lambda}</span> . ccII satisfies double-binding knowledge-soundness for  <span class="math">\\mathcal{RG}</span>  and auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , or db-ccKSND( <span class="math">\\mathcal{RG}, \\mathcal{Z}</span> ), if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A}</span>  there exists a (non-uniform) efficient extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\operatorname*{Pr}[\\text{Game}_{\\mathcal{RG}, \\mathcal{Z}, \\mathcal{A}, \\mathcal{E}}^{\\text{db-ccKSND}} = 1] = \\text{negl}</span> , where the game is defined as follows.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\mathsf {G a m e} _ {\\mathcal {R G}, \\mathcal {Z}, \\mathcal {A}, \\mathcal {E}} ^ {\\mathsf {d b - c c K S N D}} \\to b \\in \\{0, 1 \\} \\\\ \\hline (R, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} (1 ^ {\\lambda}) \\\\ \\mathsf {c r s} := (\\mathsf {c k}, \\mathsf {e k}, \\mathsf {v k}) \\leftarrow \\mathsf {K e y G e n} (R) \\\\ \\mathsf {a u x} _ {\\mathcal {Z}} \\leftarrow \\mathcal {Z} (R, \\mathsf {a u x} _ {R}, \\mathsf {c r s}) \\quad (x, c, \\pi) \\leftarrow \\mathcal {A} (R, \\mathsf {c r s}, \\mathsf {a u x} _ {R}, \\mathsf {a u x} _ {\\mathcal {Z}}) \\quad (u, o, \\omega) \\leftarrow \\mathcal {E} (R, \\mathsf {c r s}, \\mathsf {a u x} _ {R}, \\mathsf {a u x} _ {\\mathcal {Z}}) \\\\ b \\leftarrow \\mathsf {V e r P r o o f} (\\mathsf {v k}, x, c, \\pi) = 1 \\wedge (\\mathsf {V e r C o m m i t} ^ {*} (\\mathsf {c k}, c, u, o ^ {*}) = 0 \\lor R (x, u, \\omega) = 0) \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(ii) For every polynomial-time adversary  <span class="math">\\mathcal{A}</span>  the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} (R, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} (1 ^ {\\lambda}) &amp;amp; \\mathsf {V e r C o m m i t} ^ {*} (\\mathsf {c k}, c, u ^ {\\prime}, o ^ {*}) = 1 \\\\ \\mathsf {c r s} := (\\mathsf {c k}, \\mathsf {e k}, \\mathsf {v k}) \\leftarrow \\mathsf {K e y G e n} (R): \\wedge \\mathsf {V e r C o m m i t} (\\mathsf {c k}, c, u, o) = 1 \\\\ (c, u, o, u ^ {\\prime}, o ^ {*}) \\leftarrow \\mathcal {A} (R, \\mathsf {c r s}, \\mathsf {a u x} _ {R}) &amp;amp; \\wedge u \\neq u ^ {\\prime} \\end{array} \\right]</span></div>

    <p class="text-gray-300">In this section, we provide a summary of existing schemes that can be explained, with no or little modification, under our CP-SNARK and cc-SNARK notions. In fact, existing QAP-based schemes [PHGR13, BCTV14, Gro16] are not fully binding but can satisfy our weak binding. In Appendix H.5 we prove that [Gro16] is a weak cc-SNARK.</p>

    <p class="text-gray-300">Existing CP-SNARKs. The following list is a summary. Details supporting the following claims appear in Appendix H.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive Pinocchio <em>[x23]</em> is a CP-SNARK for relations <span class="math">R_{\\mathcal{Q}}(x,\\,(u_{j})_{j\\in[\\ell]},\\omega)</span> where <span class="math">R_{\\mathcal{Q}}</span> is a quadratic arithmetic program (QAP), and the commitment scheme is the extended Pedersen commitment of Groth <em>[x10]</em> in which the <span class="math">i</span>-th basis of the commitment key is <span class="math">g^{x^{i}}</span> for a random <span class="math">x</span>.</li>

      <li>The scheme in <em>[x16]**[Section 4]</em> is a CP-SNARK for Hadamard product relations <span class="math">R^{\\mathsf{had}}(\\bm{a},\\bm{b},\\bm{c})</span> over <span class="math">\\mathbb{Z}_{q}^{3m}</span>, i.e. <span class="math">R^{\\mathsf{had}}</span> holds iff <span class="math">\\forall i\\in[m]:a_{i}\\cdot b_{i}=c_{i}</span>. In this case the commitment scheme is a variant of the extended Pedersen scheme where the <span class="math">i</span>th basis of the commitment key is <span class="math">g^{\\ell_{i}(x)}</span> for a random <span class="math">x</span> and <span class="math">\\ell_{i}</span> being the <span class="math">i</span>-th Lagrange basis polynomial.</li>

      <li>zk-vSQL <em>[ZGK^{+}17b]</em> is a CP-SNARK for relations <span class="math">R((u_{j})_{j\\in[\\ell]})</span> where <span class="math">R</span> is an arithmetic circuit, and the commitment is a polynomial commitment that, we observe (cf. Appendix H), can also be explained as a variant of extended Pedersen.</li>

    </ul>

    <p class="text-gray-300">Existing cc-SNARKs. Geppetto <em>[CFH^{+}15]</em> is a commit-and-prove SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(x,u,\\omega)</span>, with a relation-dependent commitment key. This scheme immediately yields a cc-SNARK where VerCommit is also a variant of extended Pedersen.</p>

    <p class="text-gray-300">Existing Weak cc-SNARKs. There exist other schemes in the literature that fit the cc-SNARK syntax, but fail to satisfy the binding property. This is the case for some QAP-based schemes, such as Pinocchio <em>[x15, x2]</em> or the efficient SNARK of Groth <em>[x16]</em>. For the latter <em>[x16]</em> we prove in Appendix H.5 that it is a weak cc-SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(u)</span> QAP. Worth noting that our generic compiler in the next section allows to turn also weak cc-SNARKs into CP-SNARKs.</p>

    <p class="text-gray-300">New Efficient cc-SNARKs for QAPs. We show that the SNARK of <em>[x16]</em> can be modified to obtain cc-SNARKs for QAP relations <span class="math">R_{\\mathcal{Q}}(u,\\omega)</span>, where the witness portion committed in a fully binding way can be chosen (see Appendix H.5). Compared to the other cc-SNARKs for QAPs mentioned above, these schemes offer nearly optimal efficiency (essentially due to the fact that we start from <em>[x16]</em> whereas <em>[CFH^{+}15, x23]</em> build on <em>[x15]</em>).</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">3.5 Bootstrapping our Framework</h3>

    <p class="text-gray-300">A key requirement to apply the composition results of the LegoSNARK framework is to start from CP-SNARKs that share the same commitment scheme. In practice this is not always the case (see for example the discussion in the previous section). In this section we propose a solution to this issue by giving a generic compiler for turning a cc-SNARK <span class="math">\\mathsf{cc}\\Pi</span> for a family of relations <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> into a CP-SNARK CP that supports the same relations and works for a given, global, commitment scheme Com. Incidentally, since a CP-SNARK CP for commitment <span class="math">\\mathsf{Com}^{\\prime}</span> is also a cc-SNARK, our compiler can also turn CP into a CP-SNARK for another commitment Com.</p>

    <p class="text-gray-300">As noted in the introduction one could solve the interoperability problem if the cc-SNARK (or even any SNARK) is sufficiently expressive so as to encode the commitment verification algorithm VerCommit in its relations (e.g., as a circuit). This approach of letting the SNARK take care of the commitment verification however has two main drawbacks. First, recall that in our vision, the cc-SNARK <span class="math">\\mathsf{cc}\\Pi</span> may be a proof system for a specialized task, and thus may not be able to express</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP.KeyGen(ck,R) → (ek,vk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP.Prove(ek,x,(cj,uj,oj)j∈[l],ω) → π := (c',πlink,π')</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(ck',ek',vk') ← ccΠ.KeyGen(R)</td>

            <td class="px-3 py-2 border-b border-gray-700">(c',π',o') ← ccΠ.Prove(ek',x,(uj)j∈[l];ω);(xlink,ωlink) := (c',o')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Build Rlink from (ck',Dxlink,Du link,Dw link)</td>

            <td class="px-3 py-2 border-b border-gray-700">πlink ← CPLink.Prove(eklink,xlink,(cj)j∈[l],(uj)j∈[l],(oj)j∈[l],ωlink)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(eklink,vk link) ← CPLink.KeyGen(ck,Rlink)</td>

            <td class="px-3 py-2 border-b border-gray-700">CP.VerProof(vk,x,(cj)j∈[l],π) → {0,1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return ((ck',ek',eklink),(vk',vk link))</td>

            <td class="px-3 py-2 border-b border-gray-700">CPLink.VerProof(vk link,c',cj)j∈[l],πlink) ∧ ccΠ.VerProof(vk',x,c',π')</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Generic Construction of CP from  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  and ccII.</p>

    <p class="text-gray-300">VerCommit in its language. Second, even if  <span class="math">\\mathsf{cc}\\varPi</span>  is expressive enough, such encodings of VerCommit (for various choices of schemes) are notoriously very expensive. Our approach to deal with this issue is to propose a slightly different methodology that shifts the problem of expressing a relation about VerCommit from  <span class="math">\\mathsf{cc}\\varPi</span>  to a CP-SNARK that is tailored to this problem. Our idea in brief: linking a proof-dependent commitment  <span class="math">c^{\\prime}</span>  from  <span class="math">\\mathsf{cc}\\varPi</span>  to a general-purpose commitment  <span class="math">c</span>  from a CP-SNARK. Specifically we rely on a CP-SNARK (from now on  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> ) able to prove that the two commitments,  <span class="math">c^{\\prime}</span>  and  <span class="math">c</span>  (actually a collection of  <span class="math">c_{j}</span> ), open to the same value. In other words  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is a minimal tool able to turn a  <span class="math">\\mathsf{cc}\\varPi</span>  into a full fledged CP-SNARK CP that supports some general purpose commitment. The fact we require CP-SNARK to create a CP-SNARK is a curious aspect of this approach. What we require however is less than what we get: we only need to start from a simple scheme  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  that handles a specific relation to create CP-SNARKs for disparate families of relations. Since  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is a simple object we can obtain from it efficient instantiations (as confirmed by our concrete construction proposed in Section 4.1).</p>

    <p class="text-gray-300">Our cc-SNARK-lifting compiler. Let  <span class="math">\\mathsf{cc}\\varPi</span>  be a cc-SNARK for a family of relations  <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  where, for every  <span class="math">\\lambda</span> ,  <span class="math">R \\in \\mathcal{R}_{\\lambda}</span>  is over tuples in  <span class="math">\\mathcal{D}_x \\times \\mathcal{D}_u \\times \\mathcal{D}_{\\omega}</span> , and  <span class="math">\\mathcal{D}_u</span>  splits over  <span class="math">\\ell</span>  subdomains  <span class="math">(\\mathcal{D}_1 \\times \\dots \\times \\mathcal{D}_{\\ell})</span>  for some arity parameter  <span class="math">\\ell</span> . Consider the commitment verification algorithm  <span class="math">\\mathsf{cc}\\varPi</span> . VerCommit. For any  <span class="math">\\lambda \\in \\mathbb{N}</span>  and any  <span class="math">\\mathsf{ck}&#x27; \\in \\{\\mathsf{cc}\\varPi.\\mathsf{KeyGen}(R)\\}_{R \\in \\mathcal{R}_{\\lambda}}</span> , we define the relation  <span class="math">R^{\\mathrm{link}}</span>  that has input space  <span class="math">\\mathcal{D}_x^{\\mathrm{link}} = \\mathcal{C}&#x27;</span> , and witness space  <span class="math">\\mathcal{D}_{\\omega}^{\\mathrm{link}} = \\mathcal{D}_u^{\\mathrm{link}} \\times \\mathcal{D}_{\\omega}^{\\mathrm{link}}</span>  such that  <span class="math">\\mathcal{D}_u^{\\mathrm{link}} = \\mathcal{D}_1 \\times \\dots \\times \\mathcal{D}_{\\ell}</span>  and  <span class="math">\\mathcal{D}_{\\omega}^{\\mathrm{link}} := \\mathcal{O}&#x27;</span> , where  <span class="math">\\mathcal{C}&#x27;</span>  and  <span class="math">\\mathcal{O}&#x27;</span>  are the commitment and opening space of the commitment of  <span class="math">\\mathsf{cc}\\varPi</span> . For compactness we represent  <span class="math">R^{\\mathrm{link}}</span>  with  <span class="math">(\\mathsf{ck}&#x27;, \\mathcal{D}_x^{\\mathrm{link}}, \\mathcal{D}_u^{\\mathrm{link}}, \\mathcal{D}_{\\omega}^{\\mathrm{link}})</span> . Then,  <span class="math">R^{\\mathrm{link}}</span>  is defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {\\text {l i n k}} \\left(x ^ {\\text {l i n k}}, \\left(u _ {j} ^ {\\text {l i n k}}\\right) _ {j \\in [ \\ell ]}, \\omega^ {\\text {l i n k}}\\right) := \\mathsf {c c} \\varPi . \\text {V e r C o m m i t} \\left(\\mathsf {c k} ^ {\\prime}, x ^ {\\text {l i n k}}, \\left(u _ {j} ^ {\\text {l i n k}}\\right) _ {j \\in [ \\ell ]}, \\omega^ {\\text {l i n k}}\\right)</span></div>

    <p class="text-gray-300">We remark that, above,  <span class="math">x^{\\mathrm{link}} \\in \\mathcal{C}&#x27;</span>  is a commitment for  <span class="math">\\mathsf{cc}\\varPi</span> . VerCommit and  <span class="math">\\omega^{\\mathrm{link}} \\in \\mathcal{O}&#x27;</span>  is its opening.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  be a CP-SNARK for  <span class="math">\\mathsf{Com}</span>  and a family of relations  <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\mathrm{link}}\\}_{\\lambda \\in \\mathbb{N}}</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span>  the relation  <span class="math">R^{\\mathrm{link}}</span>  defined above is in  <span class="math">\\mathcal{R}_{\\lambda}^{\\mathrm{link}}</span> . In Table 2 we describe a CP-SNARK CP for  <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  that works by using  <span class="math">\\mathsf{cc}\\varPi</span>  and  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> .</p>

    <p class="text-gray-300">The correctness of CP follows by that of the two schemes  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  and  <span class="math">\\mathsf{cc}\\varPi</span> . The same holds for succinctness. In the following theorem we state how knowledge soundness and zero-knowledge of CP follow from the corresponding properties of  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  and  <span class="math">\\mathsf{cc}\\varPi</span> . The formal statement appears in Appendix B, and proofs appear in Appendix B.1 and B.2 respectively.</p>

    <p class="text-gray-300">Theorem 3.2. If  <span class="math">\\mathsf{cc}\\varPi</span>  is a  <span class="math">zk</span> - <span class="math">cc</span> -SNARK (or a weak  <span class="math">cc</span> -SNARK, or a  <span class="math">cc</span> -SNARK with double binding) for  <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is a  <span class="math">zk</span> - <span class="math">CP</span> -SNARK for  <span class="math">\\{\\mathcal{R}_{\\lambda}^{\\mathrm{link}}\\}_{\\lambda \\in \\mathbb{N}}</span> , then the scheme  <span class="math">\\mathsf{CP}</span>  in Figure 2 is a  <span class="math">zk</span> - <span class="math">CP</span> -SNARK for  <span class="math">\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> .</p>

    <p class="text-gray-300">4 CP-SNARKs for Pedersen-like Commitments</p>

    <p class="text-gray-300">In this section we propose two CP-SNARKs that work for any commitment scheme whose verification algorithm is the same as the extended Pedersen commitment (essentially a multi-exponentiation). This class of commitments includes those underlying several existing SNARKs, such as all the ones we mentioned in section 3.4. Notable, this also includes the “classical” extension of Pedersen whose key is a set of random group elements, which can be sampled in a transparent way; in other words no trusted setup is needed for this commitment key.</p>

    <p class="text-gray-300">For vectors committed in this way, we show two schemes. Our first scheme (given in Section 4.1) allows to prove that another commitment, with the same verification algorithm but different key, opens to the same vector. This is essentially an efficient realization of the CP_{link} CP-SNARK needed in our compiler of Section 3.5, and that works for cc-SNARKs whose underlying commitment verification has the same structure as Pedersen. Our second scheme (given in Section 4.2) instead allows one to prove correctness of a linear function of the committed vector (i.e., that <span class="math">\\bm{x}=\\bm{F}\\cdot\\bm{u}</span>).</p>

    <p class="text-gray-300">In what follows we start by recalling facts and notation about bilinear groups and the Pedersen commitment.</p>

    <p class="text-gray-300">Bilinear Groups. A bilinear group generator <span class="math">\\mathcal{BG}(1^{\\lambda})</span> outputs <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span>, where <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span>, <span class="math">\\mathbb{G}_{T}</span> are additive groups of prime order <span class="math">q</span>, and <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span> is an efficiently computable, non-degenerate, bilinear map. In this paper, we consider Type-3 groups where it is assumed there is no efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. We use bracket notation of <em>[EHK^{+}13]</em>, i.e., for <span class="math">s\\in\\{1,2,T\\}</span> and <span class="math">a\\in\\mathbb{Z}_{q}</span>, we write <span class="math">[a]_{s}</span> to denote <span class="math">a\\cdot g_{s}\\in\\mathbb{G}_{s}</span>, where <span class="math">g_{s}</span> is a fixed generator of <span class="math">\\mathbb{G}_{s}</span>. From an element <span class="math">[a]_{s}\\in\\mathbb{G}_{s}</span> and a scalar <span class="math">b</span> it is possible to efficiently compute <span class="math">[ab]\\in\\mathbb{G}_{s}</span>. Also, given elements <span class="math">[a]_{1}\\in\\mathbb{G}_{1}</span> and <span class="math">[b]_{2}\\in\\mathbb{G}_{2}</span>, one can efficiently compute <span class="math">[a\\cdot b]_{T}</span> by using the pairing <span class="math">e([a]_{1},[b]_{2})</span>, that we compactly denote with <span class="math">[a]_{1}\\cdot[b]_{2}</span>. Vectors and matrices are denoted in boldface. We use the bracket notation also for matrix operations, i.e., <span class="math">[\\bm{A}]_{1}\\cdot[\\bm{B}]_{2}=[\\bm{A}\\cdot\\bm{B}]_{T}</span>. For a vector <span class="math">\\bm{a}</span> and for <span class="math">i&lt;j</span> we denote by <span class="math">\\bm{a}_{[i,j]}</span> its portion <span class="math">(a_{i},\\ldots a_{j})</span>.</p>

    <p class="text-gray-300">Pedersen Vector Commitment. Let us recall the extended Pedersen commitment scheme for vectors of size <span class="math">n</span>. Here we consider an instantiation on a group <span class="math">\\mathbb{G}_{1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ped.Setup}(1^{\\lambda})</span>: sample <span class="math">[\\bm{h}]_{1}\\leftarrow\\mathbb{G}_{1}^{n+1}</span> from a distribution <span class="math">\\mathcal{D}</span>, and output <span class="math">\\mathsf{ck}:=[\\bm{h}]_{1}</span>;</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ped.Commit}([\\bm{h}]_{1},\\bm{w}):</span> sample <span class="math">o\\leftarrow\\ast\\mathbb{Z}_{q}</span> and return <span class="math">(c,o):=((o,\\bm{w}^{\\top})\\cdot[\\bm{h}]_{1},o)</span>;</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ped.VerCommit}([\\bm{h}]_{1},c,\\bm{w},o):</span> output 1 iff <span class="math">c=(o,\\bm{w}^{\\top})\\cdot[\\bm{h}]_{1}</span>.</p>

    <p class="text-gray-300">Above <span class="math">\\mathcal{D}</span> is a probability distribution over the group elements that allows to argue that the scheme is perfectly hiding and computationally binding. For example, <span class="math">\\mathcal{D}</span> may be the uniform distribution, in which case we obtain the classical scheme that is binding under the discrete logarithm assumption, or <span class="math">\\mathcal{D}</span> may output powers of random values, e.g., <span class="math">h_{i}=s^{i}</span> for an <span class="math">s\\leftarrow\\ast\\mathbb{Z}_{q}</span>, that has also been proved computationally binding under a suitable assumption.</p>

    <p class="text-gray-300">In our constructions we only require the commitment scheme to have the same verification algorithm as Ped.VerCommit.</p>

    <p class="text-gray-300">Tool: SNARK for Linear Subspaces. In our CP-SNARK constructions we make use of a SNARK for the linear subspace relation <span class="math">R_{\\mathbf{M}}([\\bm{x}]_{1},\\bm{w})</span> such that:</p>

    <p class="text-gray-300"><span class="math">R_{\\mathbf{M}}([\\bm{x}]_{1},\\bm{w})=1\\iff[\\bm{x}]_{1}=[\\mathbf{M}]_{1}\\cdot\\bm{w}\\in\\mathbb{G}_{1}^{l},\\text{ where }[\\mathbf{M}]\\in\\mathbb{G}_{1}^{l\\times t},\\bm{w}\\in\\mathbb{Z}_{q}^{t}</span></p>

    <p class="text-gray-300">Namely, given a fixed public matrix <span class="math">[\\mathbf{M}]_1</span> and a public vector <span class="math">[\\boldsymbol{x}]_1</span>, one can prove knowledge of a vector <span class="math">\\boldsymbol{w}</span> such that <span class="math">[\\boldsymbol{x}]_1 = [\\mathbf{M}]_1 \\cdot \\boldsymbol{w}</span>. We denote a SNARK for this family of relations with <span class="math">\\mathsf{ss}\\Pi</span>. A candidate scheme for <span class="math">\\mathsf{ss}\\Pi</span> is the Kiltz-Wee QA-NIZK scheme <span class="math">\\Pi_{as}&#x27;</span> [KW15] that works in bilinear groups. As described in [KW15], the security of this scheme requires that <span class="math">l &amp;gt; t</span>, which is not satisfied in our setting where matrices have always more columns than rows. This means that, when <span class="math">\\mathbf{M}</span> has full rank, <span class="math">R_{\\mathbf{M}}</span> is satisfied for any <span class="math">[\\boldsymbol{x}]_1</span>. In fact, what we need is an argument of knowledge for this language. For this, by extending a recent result [FLSZ17], we show the knowledge soundness of <span class="math">\\Pi_{as}&#x27;</span> [KW15], without the <span class="math">l &amp;gt; t</span> restriction, under the discrete logarithm assumption, in the algebraic group model [FKL18]. We recall the scheme and its security statement in Appendix D. For knowledge soundness, the matrix <span class="math">[\\mathbf{M}]_1</span> must be generated using a witness sampleable distribution <span class="math">\\mathcal{D}_{\\mathrm{mtx}}</span>, i.e., there must exist a polynomial time algorithm that samples <span class="math">\\mathbf{M}</span> in <span class="math">\\mathbb{Z}_q</span> such that <span class="math">[\\mathbf{M}]_1</span> has the same distribution as the one sampled with <span class="math">\\mathcal{D}_{\\mathrm{mtx}}</span>. We note that this is satisfied by our use cases where <span class="math">\\mathbf{M}</span> includes bases of Pedersen-like commitment schemes.</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.1 CP-SNARK for Pedersen Verification</h2>

    <p class="text-gray-300">Our scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> is designed to work with, as global commitment scheme, any <span class="math">\\mathsf{Com}</span> such that <span class="math">\\mathsf{Com.VerCommit} = \\mathsf{Ped.VerCommit}</span>. Furthermore, it handles any cc-SNARK scheme <span class="math">\\mathsf{ccII}</span> whose underlying commitment algorithm also follows Pedersen verification, i.e., <span class="math">\\mathsf{ccII.VerCommit} = \\mathsf{Ped.VerCommit}</span>. Let us stress that although the verification algorithm is the same the commitment keys are not. In particular, the key of <span class="math">\\mathsf{Com}</span> is completely independent of the relations to be proven (e.g., are random group elements) whereas the key of <span class="math">\\mathsf{ccII}</span> is relation-dependent.</p>

    <p class="text-gray-300">More formally, let <span class="math">\\mathsf{Com}</span> be a commitment scheme such that <span class="math">\\mathsf{Com.VerCommit} = \\mathsf{Ped.VerCommit}</span>. We build a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> for <span class="math">\\mathsf{Com}</span> and for the following class of relations <span class="math">R^{\\mathrm{link}}</span>. Fixed a security parameter <span class="math">\\lambda</span> (and the group setting for <span class="math">\\lambda</span> as well), <span class="math">R^{\\mathrm{link}}</span> is over <span class="math">(\\mathcal{D}_x \\times \\mathcal{D}_1 \\times \\dots \\times \\mathcal{D}_\\ell \\times \\mathcal{D}_\\omega)</span>, where <span class="math">\\mathcal{D}_x = \\mathbb{G}_1, \\mathcal{D}_\\omega = \\mathbb{Z}_q</span> and <span class="math">\\mathcal{D}_j = \\mathbb{Z}_q^{n_j}</span> for some <span class="math">n_j</span> such that <span class="math">\\sum_{j} n_j = m</span>. <span class="math">R^{\\mathrm{link}}</span> is parametrized by a commitment key <span class="math">[\\pmb{f}]_1 \\in \\mathbb{G}_1^{m+1}</span>, and is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {\\text {l i n k}} \\left(c ^ {\\prime}, \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}, o ^ {\\prime}\\right) = 1 \\iff c ^ {\\prime} \\stackrel {?} {=} \\left(o ^ {\\prime}, \\boldsymbol {u} _ {1} ^ {\\top}, \\dots , \\boldsymbol {u} _ {\\ell} ^ {\\top}\\right) \\cdot [ \\boldsymbol {f} ] _ {1}</span></div>

    <p class="text-gray-300">Before describing the construction in full detail, let us present the main ideas.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ck} = [\\pmb{h}]_1 \\in \\mathbb{G}_1^{n+1}</span> be the key of the global commitment <span class="math">\\mathsf{Com}</span>. In our <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> the public inputs of the prover are <span class="math">\\ell</span> commitments <span class="math">(c_j)_{j \\in [\\ell]}</span> and another commitment <span class="math">c&#x27;</span>; the witness is a set of openings <span class="math">((\\pmb{u}_j)_{j \\in [\\ell]}, (o_j)_{j \\in [\\ell]})</span> for commitments <span class="math">(c_j)_{j \\in [\\ell]}</span>, and an opening <span class="math">o&#x27;</span> for <span class="math">c&#x27;</span>. In particular, the prover must prove that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} R _ {\\mathsf {P e d}} ^ {\\mathsf {l i n k}} \\left(c ^ {\\prime}, \\left(c _ {j}\\right) _ {j \\in [ \\ell ]}, \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}, \\left(o _ {j}\\right) _ {j \\in [ \\ell ]}, o ^ {\\prime}\\right) = 1 \\iff \\\\ \\bigwedge_ {j \\in [ \\ell ]} c _ {j} = (o _ {j}, \\boldsymbol {u} _ {j} ^ {\\top}) \\cdot [ \\boldsymbol {h} _ {[ 0, n _ {j} ]} ] _ {1} \\wedge c ^ {\\prime} = (o ^ {\\prime}, \\boldsymbol {u} _ {1} ^ {\\top}, \\dots , \\boldsymbol {u} _ {\\ell} ^ {\\top}) \\cdot [ \\boldsymbol {f} ] _ {1} \\end{array}</span></div>

    <p class="text-gray-300">The description of our scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathsf{KeyGen}(\\mathsf{ck},R^{\\mathrm{link}})</span>: parse <span class="math">\\mathsf{ck} = [\\pmb {h}]_1\\in \\mathbb{G}_1^{n + 1}</span>, and let <span class="math">R^{\\mathrm{link}}:\\mathbb{G}_1\\times \\mathcal{D}_1\\times \\dots \\times \\mathcal{D}_\\ell \\times \\mathbb{Z}_q</span> be the relation defined above with <span class="math">\\mathsf{ck}&#x27; = [\\pmb {f}]_1\\in \\mathbb{G}_1^{m + 1}</span>. Use <span class="math">[\\pmb {h}]_1</span>, <span class="math">[\\pmb {f}]_1</span> and <span class="math">R^{\\mathrm{link}}</span> to build a matrix <span class="math">\\mathbf{M}</span> as in equation (1). Compute <span class="math">(\\mathsf{ek},\\mathsf{vk})\\gets \\mathsf{ss}\\Pi .\\mathsf{KeyGen}([\\mathbf{M}]_1)</span> and return <span class="math">(\\mathsf{ek},\\mathsf{vk})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathsf{Prove}(\\mathsf{ek},c^{\\prime},(c_{j})_{j\\in [\\ell]},(\\pmb{u}_{j})_{j\\in [\\ell]},(o_{j})_{j\\in [\\ell]},o^{\\prime})</span>: define <span class="math">[\\pmb {x}]_1</span> and <span class="math">\\pmb{w}</span> as in as in equation (1), compute <span class="math">\\pi \\gets \\mathsf{ss}\\Pi .\\mathsf{Prove}(\\mathsf{ek},[\\pmb {x}]_1,\\pmb {w})</span> and return <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathsf{VerProof}(\\mathsf{vk},c^{\\prime},(c_{j})_{j\\in [\\ell ]},\\pi)</span>  : set  <span class="math">[\\pmb {x}]_1</span>  as in (1) and return ssN.VerProof(vk,  <span class="math">[\\pmb {x}]_1,\\pi)</span></p>

    <p class="text-gray-300">The key idea of the construction is that this relation can be expressed as a linear subspace relation  <span class="math">R_{\\mathbf{M}}([x]_1, \\boldsymbol{w})</span>  where  <span class="math">\\mathbf{M}, \\boldsymbol{x}, \\boldsymbol{w}</span>  can be defined as follows from the inputs of  <span class="math">R_{\\mathrm{Ped}}^{\\mathrm{link}}</span> , with  <span class="math">l = \\ell + 1</span>  and  <span class="math">t = m + \\ell + 1</span> :</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">In the theorem below we show that  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is knowledge-sound and zero-knowledge assuming so is ssN. We show the formal statement in Appendix C.1, where we also prove the security of  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  based on that of ssN. Appendix C.2 shows how to extend  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  to handle a more general class of relations that essentially checks that a set of vectors  <span class="math">(\\pmb{u}_j)_{j\\in [\\ell ]}</span>  is a prefix, of known length, of a vector  <span class="math">\\pmb{u}^{\\prime}</span>  committed in  <span class="math">c^\\prime</span></p>

    <p class="text-gray-300">EFFICIENCY. When using ss <span class="math">\\Pi</span>  from [KW15], the key generation algorithm outputs an evaluation key of  <span class="math">m + \\ell + 1</span> <span class="math">\\mathbb{G}_1</span>  elements and a verification key with  <span class="math">l + 1</span> <span class="math">\\mathbb{G}_2</span>  elements. The prover cost is one multi-exponentiation of length  <span class="math">m + \\ell + 1</span>  while the verifier needs  <span class="math">l + 1</span>  pairings to check the one group element composing the proof.</p>

    <p class="text-gray-300">Theorem 4.1. If  <span class="math">\\mathfrak{ss}\\Pi</span>  is  <span class="math">\\mathsf{KSND}(\\mathfrak{ss}\\Pi.\\mathcal{RG},\\mathcal{Z})</span>  where  <span class="math">\\mathcal{Z}</span>  is an auxiliary input distribution, then the CP-SNARK construction  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  given above is  <span class="math">\\mathsf{KSND}(\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{RG},\\mathcal{Z})</span> . Furthermore, if  <span class="math">\\mathfrak{ss}\\Pi</span>  is composable  <span class="math">ZK</span>  for  <span class="math">\\mathfrak{ss}\\Pi.\\mathcal{RG}</span> , then  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is composable  <span class="math">ZK</span>  for  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{RG}</span> .</p>

    <p class="text-gray-300">In this section we show a CP-SNARK for the relation  <span class="math">R^{\\mathrm{lin}}</span>  that checks linear properties of (committed) vectors: for a fixed public matrix  <span class="math">\\pmb{F} \\in \\mathbb{Z}_q^{n \\times m}</span> , relation  <span class="math">R_{\\pmb{F}}^{\\mathrm{lin}}</span>  over public input  <span class="math">\\pmb{x} \\in \\mathbb{Z}_q^n</span>  and witness  <span class="math">\\pmb{u} \\in \\mathbb{Z}_q^m</span> , with  <span class="math">\\pmb{u} := (\\pmb{u}_j)_{j \\in [\\ell]}</span>  and  <span class="math">\\pmb{u}_j \\in \\mathbb{Z}_q^{n_j}</span> , holds iff  <span class="math">\\pmb{x} = \\pmb{F} \\cdot \\pmb{u}</span> .</p>

    <p class="text-gray-300">Our scheme, called  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> , is quite similar to  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  and essentially consists into invoking ss <span class="math">\\Pi</span>  to prove that the above subspace relation holds. The full description of our scheme  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span>  follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> . KeyGen  <span class="math">(\\mathsf{ck}, R_{\\pmb{F}}^{\\mathrm{lin}})</span> : parse  <span class="math">\\mathsf{ck} = [h]_1 \\in \\mathbb{G}_1^{m+1}</span> . Use  <span class="math">[h]_1</span>  and  <span class="math">R_{\\pmb{F}}^{\\mathrm{lin}}</span>  to build a matrix  <span class="math">[\\mathbf{M}]</span>  as in equation (2). Compute  <span class="math">(\\mathsf{ek}, \\mathsf{vk}) \\gets \\mathsf{ss}\\Pi</span> . KeyGen  <span class="math">([\\mathbf{M}]_1)</span>  and return  <span class="math">(\\mathsf{ek}, \\mathsf{vk})</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> . Prove  <span class="math">(\\mathsf{ek}, \\boldsymbol{x}, (c_j)_{j \\in [\\ell]}, (\\boldsymbol{u}_j)_{j \\in [\\ell]}, (o_j)_{j \\in [\\ell]})</span> : define  <span class="math">[\\boldsymbol{x}&#x27;]_1</span>  and  <span class="math">\\boldsymbol{w}&#x27;</span>  as in equation (2), and return  <span class="math">\\pi \\gets \\mathsf{ss}\\Pi</span> . Prove  <span class="math">(\\mathsf{ek}, [\\boldsymbol{x}&#x27;]_1, \\boldsymbol{w}&#x27;)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> . VerProof(vk,  <span class="math">\\pmb{x}</span> ,  <span class="math">(c_{j})_{j\\in [\\ell ]}</span> ,  <span class="math">\\pi</span> ): set  <span class="math">[\\pmb{x}^{\\prime}]_{1}</span>  as in (2) and return ssN.VerProof(vk,  <span class="math">[\\pmb{x}^{\\prime}]_{1}</span> ,  <span class="math">\\pi</span> ).</p>

    <p class="text-gray-300">The scheme  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span>  considers each  <span class="math">\\pmb{u}_j</span>  to be committed using a commitment scheme  <span class="math">\\mathsf{Com}</span>  such that  <span class="math">\\mathsf{Com.VerCommit} = \\mathsf{Ped.VerCommit}</span> , and whose key is  <span class="math">\\mathsf{ck} = [h]_1 \\in \\mathbb{G}_1^{m^<em> + 1}</span> , with  <span class="math">m^</em> \\geq m</span> . The</p>

    <p class="text-gray-300">idea is to express such a commit-and-prove relation with the linear subspace relation  <span class="math">R_{\\mathbf{M}}([\\pmb{x}^{\\prime}]_1, \\pmb{w}^{\\prime})</span>  that holds iff  <span class="math">[\\pmb{x}^{\\prime}]_1 = [\\mathbf{M}]_1 \\cdot \\pmb{w}^{\\prime}</span> , where  <span class="math">[\\pmb{x}^{\\prime}]_1 \\in \\mathbb{G}_1^l, [\\mathbf{M}]_1 \\in \\mathbb{G}_1^{l \\times t}</span>  and  <span class="math">\\pmb{w}^{\\prime} \\in \\mathbb{Z}_{q}^{t}</span>  can be built from the inputs of  <span class="math">R_{\\pmb{F}}^{\\mathrm{lin}}</span>  as follows (for  <span class="math">l = \\ell + n</span>  and  <span class="math">t = m + \\ell</span> ):</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EFFICIENCY. When using  <span class="math">\\mathfrak{ss}\\Pi</span>  from [KW15], the prover cost is one multi-exponentiation of length  <span class="math">m + \\ell</span>  while the verifier needs  $\\ell +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math">  pairings. If  </span>\\pmb{x}<span class="math">  is some fixed value, as in our applications,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  of these pairings either disappear (if  </span>\\pmb{x} = \\mathbf{0}<span class="math"> ) or can be precomputed. Furthermore, it is possible to see that the cost of KeyGen is  </span>O(\\ell \\cdot t + n_F)<span class="math">  where  </span>n_F<span class="math">  is the number of nonzero entries of  </span>\\pmb{F}<span class="math"> . Essentially this cost depends on the sparsity of the matrix; this is crucial in our applications where for example  </span>\\pmb{F}<span class="math">  includes the  </span>\\pmb{W}<span class="math">  matrices representing the linear constraints of a circuit  </span>[\\mathrm{BCC}^{+}16]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We state the following theorem. We omit the proof, which is essentially the same as that of Theorem C.1.</p>

    <p class="text-gray-300">Theorem 4.2. Let  <span class="math">\\pmb{F} \\in \\mathbb{Z}_q^{n \\times m}</span>  be a matrix from a distribution  <span class="math">\\mathcal{D}_{\\mathrm{mtx}}</span> , and  <span class="math">\\mathcal{Z}</span>  be an auxiliary input distribution. If  <span class="math">\\mathfrak{ss}\\Pi</span>  is KSND(ssΠ.RG, Z) where  <span class="math">\\mathfrak{ss}\\Pi.\\mathcal{RG}</span>  is a relation generator that samples ck and  <span class="math">\\pmb{F} \\gets \\mathcal{D}_{\\mathrm{mtx}}</span> , then the CP-SNARK construction  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span>  given above is KSND(Dmtx, Z). Furthermore, if  <span class="math">\\mathfrak{ss}\\Pi</span>  is composable ZK for  <span class="math">\\mathfrak{ss}\\Pi.\\mathcal{RG}</span> , then  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span>  is composable ZK for  <span class="math">\\mathcal{D}_{\\mathrm{mtx}}</span> .</p>

    <p class="text-gray-300">In this section we show a collection of zero-knowledge CP-SNARKs for a variety of relations over vectors committed using a specific commitment scheme from  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right]</span> . This scheme is for committing to multivariate polynomials and it can be used for vectors by converting them into their multilinear extension polynomials. Although this commitment scheme has a specially structured commitment key, its verification algorithm can be casted as a form of Pedersen verification; this means we can apply our results of Section 3.5 to turn all the CP-SNARKs in this section into ones for a standard Pedersen commitment, or to simply make them work under some common Pedersen-like scheme. Among the CP-SNARKs in this section, worth mentioning are one for Hadamard product and one for the self permutation relation. Notably these schemes have a CRS that is universal (and in some cases deterministically specializable).</p>

    <p class="text-gray-300">We review the main building blocks of our constructions.</p>

    <p class="text-gray-300">The specific commitment scheme we consider here is the polynomial commitment underlying the verifiable polynomial delegation (VPD) scheme of Zhang et al. [ZGK+17b]. In a nutshell, a VPD</p>

    <p class="text-gray-300">allows one to commit to multivariate polynomials and later prove their evaluations (also committed) at a public point. Here we show that their VPD scheme can be seen as a CP-SNARK for such polynomial commitment, for relations encoding polynomial evaluations. Namely, whereas in  <span class="math">\\mathrm{[ZGK^{+}17b]}</span>  VPD is presented as a single primitive, here we separate the commitment scheme from the argument system. With this simple change (together with a slightly stronger zero-knowledge notion) we can use our composition results to argue security when commitments are reused across different proofs.</p>

    <p class="text-gray-300">Formally, we consider a commitment scheme whose message space  <span class="math">\\mathcal{D}</span>  includes both values in a finite field  <span class="math">\\mathbb{F}</span>  and a class  <span class="math">\\mathcal{F}</span>  of polynomials with coefficients in  <span class="math">\\mathbb{F}</span> , with  <span class="math">\\mu</span>  variables and maximal degree  <span class="math">\\delta</span>  in each variable. We denote these partitions of  <span class="math">\\mathcal{D} = \\mathbb{F} \\cup \\mathcal{F}</span>  as  <span class="math">\\mathcal{D}_{\\mathrm{pol}} = \\mathcal{F}</span>  and  <span class="math">\\mathcal{D}_{\\mathrm{val}} = \\mathbb{F}</span>  and we use a flag type to differentiate between them so that  <span class="math">f \\in \\mathcal{F}</span>  when type = pol, and  <span class="math">f \\in \\mathbb{F}</span>  when type = val. In addition to satisfying the notion of Definition 2.1, we assume the scheme to be knowledge extractable and to have a trapdoor generation. For convenience, we summarize its definition below.</p>

    <p class="text-gray-300">Definition 5.1 (Extractable Trapdoor Polynomial Commitments). An extractable trapdoor polynomial commitment scheme for a class of polynomials  <span class="math">\\mathcal{F}</span>  is a tuple of algorithms  <span class="math">\\text{PolyCom} = (\\text{Setup}, \\text{Commit}, \\text{CheckCom}, \\text{VerCommit})</span>  that work as follows.</p>

    <p class="text-gray-300">Setup  <span class="math">(1^{\\lambda})\\to \\mathsf{ck}</span>  : takes the security parameter and outputs a commitment key ck.</p>

    <p class="text-gray-300">Commit  <span class="math">(\\mathsf{ck},f,\\mathsf{type})\\to (c_f,o_f)</span>  : takes the commitment key ck, a flag type  <span class="math">\\in \\{\\mathsf{pol},\\mathsf{val}\\}</span>  and an element  <span class="math">f\\in \\mathcal{D}_{\\mathrm{type}}</span>  , and outputs a commitment  <span class="math">c_{f}</span>  and an opening  <span class="math">o_{f}</span>  . We use ComPoly  <span class="math">(\\mathsf{ck},\\cdot)</span>  and ComVal  <span class="math">(\\mathsf{ck},\\cdot)</span>  as shorthands for Commit  <span class="math">(\\mathsf{ck},\\cdot ,\\mathsf{pol})</span>  and Commit  <span class="math">(\\mathsf{ck},\\cdot ,\\mathsf{val})</span>  respectively. We also assume that type is part of  <span class="math">c_{f}</span>  , namely it is not hidden.</p>

    <p class="text-gray-300">CheckCom  <span class="math">(\\mathsf{ck},c)\\to b</span>  : takes as input a commitment  <span class="math">c</span>  and accepts it as valid  <span class="math">(b = 1)</span>  or not  <span class="math">(b = 0)</span> .</p>

    <p class="text-gray-300"><span class="math">\\operatorname{VerCommit}(\\mathsf{ck}, c_f, f, o_f) \\to b</span> : takes as input commitment  <span class="math">c</span> , element  <span class="math">f \\in \\mathcal{D}</span>  and opening  <span class="math">o_f</span> , and accepts  <span class="math">(b = 1)</span>  or rejects  <span class="math">(b = 0)</span> . If  <span class="math">f</span>  is a degree-0 polynomial the same algorithm applies to commitments created using ComVal</p>

    <p class="text-gray-300">PolyCom must satisfy correctness, binding and (perfect) hiding as in Definition 2.1 (with the additional requirements that correctness also implies that CheckCom accepts, and binding holds for adversarial commitments that are accepted by CheckCom). In addition PolyCom must satisfy the trapdoor and extractability properties defined below.</p>

    <p class="text-gray-300">Trapdoor. There exists three algorithms  <span class="math">(\\mathsf{ck},\\mathsf{td})\\gets S_{\\mathsf{ck}}(1^{\\lambda}),(c,st)\\gets \\mathsf{TdCom}(\\mathsf{td},\\mathsf{type})</span>  and  <span class="math">o\\gets \\mathsf{TdOpen}(\\mathsf{td},st,c,f)</span>  such that: the distribution of the commitment key returned by  <span class="math">S_{\\mathsf{ck}}</span>  is perfectly/statistically close to the one of the key returned by Setup; for any type  <span class="math">\\in (\\mathsf{pol},\\mathsf{val})</span> , any  <span class="math">f\\in \\mathcal{D}_{\\mathrm{type}}</span> ,  <span class="math">(c,o)\\approx (c&#x27;,o&#x27;)</span>  where  <span class="math">(c,o)\\gets \\mathsf{Commit}(\\mathsf{ck},f,\\mathsf{type})</span> ,  <span class="math">(c&#x27;,st)\\gets \\mathsf{TdCom}(\\mathsf{td},\\mathsf{type})</span>  and  <span class="math">o&#x27;\\gets \\mathsf{TdOpen}(\\mathsf{td},st,c&#x27;,f)</span> .</p>

    <p class="text-gray-300">Extractability. PolyCom is knowledge extractable for auxiliary input distribution  <span class="math">\\mathcal{Z}</span>  if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A}</span>  there exists a (non-uniform) efficient extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\operatorname*{Pr}[\\text{Game}_{\\mathcal{Z},\\mathcal{A},\\mathcal{E}}^{\\text{extr}} = 1] = \\text{negl}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\text {G a m e} _ {\\mathcal {Z}, \\mathcal {A}, \\mathcal {E}} ^ {\\text {e x t r}} \\\\ \\hline \\text {c k} \\leftarrow \\text {S e t u p} (1 ^ {\\lambda}) ; \\text {a u x} _ {Z} \\leftarrow \\mathcal {Z} (1 ^ {\\lambda}) ; c \\leftarrow \\mathcal {A} (\\text {c k}, \\text {a u x} _ {Z}) ; (f, o) \\leftarrow \\mathcal {E} (\\text {c k}, \\text {a u x} _ {Z}) \\\\ \\text {r e t u r n C h e c k C o m} (\\text {c k}, c) \\stackrel {?} {=} 1 \\wedge \\text {V e r C o m m i t} (\\text {c k}, c, f, o) \\stackrel {?} {=} 0 \\end{array}</span></div>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Linearly Homomorphic Commitments.</h5>

    <p class="text-gray-300">For the constructions presented in this section we assume that the commitments are linearly homomorphic. That is we assume existence of a deterministic algorithm <span class="math">(c^{\\prime},o^{\\prime})\\leftarrow\\mathsf{HomEval}(\\mathsf{ck},g,(c_{j})_{j\\in[\\ell]},(o_{j})_{j\\in[\\ell]})</span> such that, for a linear function <span class="math">g:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>, if <span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c_{j},a_{j},o_{j})=1</span> then <span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c^{\\prime},g((a_{j})_{j\\in[\\ell]}),o^{\\prime})=1</span>. In the paper we assume <span class="math">\\mathsf{HomEval}</span> takes in the vector of <span class="math">\\ell</span> coefficients of <span class="math">g</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Zero-knowledge CP-SNARKs for PolyCom</h4>

    <p class="text-gray-300">Constructions in this section use the following existing CP-SNARKs for the scheme <span class="math">\\mathsf{PolyCom}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>: a CP-SNARK for relation <span class="math">R^{\\mathsf{eq}}(u_{1},u_{2}):=u_{1}\\stackrel{{\\scriptstyle?}}{{=}}u_{2}</span>, where <span class="math">u_{1},u_{2}\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>: a CP-SNARK for relation <span class="math">R^{\\mathsf{prd}}(u_{1},u_{2},u_{3}):=u_{3}\\stackrel{{\\scriptstyle?}}{{=}}u_{1}\\cdot u_{2}</span>, where <span class="math">u_{1},u_{2},u_{3}\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>: a CP-SNARK for the relation <span class="math">R^{\\mathsf{poly}}</span> over <span class="math">\\mathcal{D}_{x}\\times\\mathcal{D}_{1}\\times\\mathcal{D}_{2}</span> where <span class="math">\\mathcal{D}_{x}=\\mathbb{F}^{\\mu}</span>, <span class="math">\\mathcal{D}_{1}=\\mathcal{F}</span>, <span class="math">\\mathcal{D}_{2}=\\mathbb{F}</span> and <span class="math">R^{\\mathsf{poly}}(\\bm{x},f,y):=y\\stackrel{{\\scriptstyle?}}{{=}}f(\\bm{x})</span>. For zero-knowledge, we assume that <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> satisfies a notion where the commitment key is generated in trapdoor mode and the <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> simulators <span class="math">(\\mathcal{S}_{\\mathsf{kg}},\\mathcal{S}_{\\mathsf{prv}})</span> get access to the commitment trapdoor produced by <span class="math">\\mathcal{S}_{\\mathsf{ck}}</span>. Note that such notion is weaker than the one of Definition 3.1 but sufficient to argue that a scheme satisfying this notion is a cc-SNARK.</li>

    </ul>

    <p class="text-gray-300">In Appendix E we show pairing-based constructions of <span class="math">\\mathsf{PolyCom}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> extracted from the verifiable polynomial delegation scheme of Zhang et al. <em>[ZGK^{+}17b]</em>. As observed by Zhang et al. constructions for <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> can be obtained using standard techniques from classical sigma-protocols. Finally, we observe that all these schemes share the same (deterministic) <span class="math">\\mathsf{KeyGen}</span> algorithm that, on input the commitment key <span class="math">\\mathsf{ck}</span>, simply partitions the elements of <span class="math">\\mathsf{ck}</span> into <span class="math">\\mathsf{ek}=\\mathsf{ck}</span> and <span class="math">\\mathsf{vk}=\\mathsf{cvk}</span>, where <span class="math">\\mathsf{cvk}</span> is a subset of the elements in <span class="math">\\mathsf{ck}</span> that is sufficient to run algorithms <span class="math">\\mathsf{CheckCom},\\mathsf{ComVal}</span> and <span class="math">\\mathsf{HomEval}</span>.</p>

    <p class="text-gray-300">Efficiency. Both proof-of-equality and proof-of-product (Appendix A in <em>[WTas^{+}17]</em>) are built as Sigma protocols, where both prover and verifier run in constant time. They can be made non-interactive using the Fiat-Shamir heuristic <em>[x10]</em>. The proof in <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> consists of one group element and one field element. In <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>, the prover sends <span class="math">3\\mathbb{G}_{1}+5\\mathbb{F}</span>. The proof in <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> for polynomial evaluation <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> needs <span class="math">2(\\mu+1)</span> group elements, its verifier runs in <span class="math">O(\\mu)</span> and the prover in time <span class="math">O(m)</span>. Here, <span class="math">\\mu</span> is the number of variables of the polynomial and <span class="math">m</span> is its number of monomials. The <span class="math">\\mathsf{KeyGen}</span> algorithm of <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> outputs an evaluation key of <span class="math">(2(\\delta+1)^{\\mu}+3)\\mathbb{G}_{1}+(\\mu+3)\\mathbb{G}_{2}</span> elements and a subset verification key of size <span class="math">(\\mu+3)\\mathbb{G}_{2}</span>, where <span class="math">\\delta</span> is the maximum degree in each variable of the committed polynomial. For clarification, note that by construction the public parameters <span class="math">\\mathbb{P}</span> within the commitment key are formed by two group elements per element in the set of all multisets of <span class="math">\\{1,\\ldots,\\mu\\}</span> where each element appears at most <span class="math">\\delta</span> times. Asymptotically, the <span class="math">\\mathsf{crs}</span> of <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> contains <span class="math">O(\\binom{\\mu\\delta+\\mu}{\\mu\\delta})</span> group elements. As will be explained, in our setting <span class="math">\\delta=1</span>, which keeps the <span class="math">\\mathsf{crs}</span> size small.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Multilinear Extensions</h4>

    <p class="text-gray-300">Given a function <span class="math">f:\\{0,1\\}^{\\mu}\\to\\mathbb{F}</span>, its unique multilinear extension (MLE) is the (unique) multilinear polynomial <span class="math">\\tilde{f}:\\mathbb{F}^{\\mu}\\to\\mathbb{F}</span> such that <span class="math">f(\\bm{b})=\\tilde{f}(\\bm{b})</span> for all <span class="math">\\bm{b}\\in\\{0,1\\}^{\\mu}</span>. Such multilinear extension is defined as the following polynomial</p>

    <p class="text-gray-300"><span class="math">\\tilde{f}(X_{1},\\ldots,X_{\\mu})=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\chi_{\\bm{b}}(X_{1},\\ldots,X_{\\mu})\\cdot f(\\bm{b})</span></p>

    <p class="text-gray-300">where <span class="math">\\chi_{\\bm{b}}(X_{1},\\ldots,X_{\\mu})=\\prod_{j=1}^{\\mu}\\chi_{b_{j}}(X_{j})</span>, <span class="math">\\chi_{1}(X)=X</span> and <span class="math">\\chi_{0}(X)=1-X</span>. For a vector <span class="math">\\bm{u}\\in\\mathbb{F}^{m}</span> (for some <span class="math">m=2^{\\mu}</span>), its unique MLE is the MLE <span class="math">\\tilde{u}</span> of the function <span class="math">u:\\{0,1\\}^{\\mu}\\to\\mathbb{F}</span> such that, for every <span class="math">0\\leq i\\leq m-1</span> with <span class="math">i=\\sum_{j=0}^{m-1}i_{j}2^{j}</span>, <span class="math">u(i_{0},\\ldots,i_{\\mu-1})=u_{i+1}</span>. Note that by using MLEs one can commit to a vector <span class="math">\\bm{u}</span> using PolyCom by committing to its MLE <span class="math">\\tilde{u}</span>, with maximum variable degree <span class="math">\\delta=1</span>.</p>

    <p class="text-gray-300">Let <span class="math">eq:\\{0,1\\}^{\\mu}\\times\\{0,1\\}^{\\mu}\\to\\{0,1\\}</span> be the equality predicate (<span class="math">eq(a,b)=1</span> iff <span class="math">a=b</span>) and let <span class="math">\\widetilde{eq}</span> be its MLE (which has a closed-form representation that allows evaluation in time <span class="math">O(\\mu)</span> <em>[x21]</em>). We recall the following lemma from <em>[x23]</em> (as restated in <em>[x21]</em>):</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Lemma 5.1 (<em>[x23, Lemma 3.2.1]</em>).</h6>

    <p class="text-gray-300">For any polynomial <span class="math">h:\\mathbb{F}^{\\mu}\\!\\to\\mathbb{F}</span> extending <span class="math">p:\\{0,1\\}^{\\mu}\\to\\mathbb{F}</span> (i.e., such that <span class="math">\\forall\\bm{b}\\in\\{0,1\\}^{\\mu}:h(\\bm{b})=p(\\bm{b})</span>), it holds</p>

    <p class="text-gray-300"><span class="math">\\tilde{p}(\\bm{X})=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\widetilde{eq}(\\bm{X},\\bm{b})\\cdot h(\\bm{b}).</span></p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">5.2 A CP-SNARK for Sum-Check</h3>

    <p class="text-gray-300">The sum-check protocol <em>[x14]</em> is an interactive proof that allows a prover to convince a verifier of the validity of a statement of the form <span class="math">t=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}g(\\bm{b})</span> where <span class="math">g:\\mathbb{F}^{\\mu}\\to\\mathbb{F}</span>. The protocol consists of <span class="math">\\mu</span> rounds, it is public coin, and the running time of the verifier in it is <span class="math">O(\\sum_{i=1}^{\\mu}\\mathsf{deg}_{i}(g))</span> plus the cost of evaluating <span class="math">g</span> once (on a random point).</p>

    <p class="text-gray-300">Here we propose a zero-knowledge variant of the sum-check protocol where both the polynomial <span class="math">g</span> and the target value <span class="math">t</span> are committed and one proves knowledge of these values such that <span class="math">t=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}g(\\bm{b})</span>. Precisely, we work with polynomials <span class="math">g</span> defined as the product of <span class="math">p+1</span> polynomials of the form <span class="math">g(\\bm{S})=\\prod_{i=0}^{p}g_{i}(\\bm{S})</span>, such that all the <span class="math">g_{i}</span>’s, except <span class="math">g_{0}</span>, are committed. Namely, we show a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> for commitment scheme PolyCom and the relation <span class="math">R^{\\mathsf{sc}}(\\bm{x},\\bm{u})</span>, with <span class="math">\\bm{x}\\in\\mathcal{F}</span> and <span class="math">\\bm{u}\\in\\mathbb{F}\\times\\mathcal{F}^{p}</span>, that is formally defined as:</p>

    <p class="text-gray-300"><span class="math">R^{\\mathsf{sc}}(g_{0},(t,(g_{j})_{j\\in[p]}))</span> <span class="math">=</span> <span class="math">1\\iff g(\\bm{S})</span> <span class="math">=</span> <span class="math">\\prod_{i=0}^{p}g_{i}(\\bm{S})\\wedge t</span> <span class="math">=</span> <span class="math">\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}g(\\bm{b})</span></p>

    <p class="text-gray-300">Our scheme, dubbed <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>, is built as a generalization of the protocol recently proposed in <em>[ZGK^{+}17b, WTs^{+}18]</em> that works for a relation that is the same as the above one except that only <span class="math">t</span> is committed while <span class="math">g</span> is public to the verifier. For the reader familiar with the zero-knowledge sum-check protocol in <em>[ZGK^{+}17b, Construction 2]</em>, what we do here is to modify their protocol using the following ideas: whereas in <em>[ZGK^{+}17b]</em> the verifier has access to <span class="math">g</span> and computes a commitment to <span class="math">g(\\bm{s})</span> for a random point <span class="math">\\bm{s}</span> on its own, in our case the verifier has access to a commitment <span class="math">c_{g}</span> of <span class="math">g</span> and we let the prover create a commitment to <span class="math">g(\\bm{s})</span> and use <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> to prove its correctness with respect to <span class="math">c_{g}</span>. More precisely, the verifier does not have a commitment to <span class="math">g</span> but rather commitments to the factors of <span class="math">g</span>. Hence our prover proceeds by additionally creating commitments to each <span class="math">g_{i}(\\bm{s})</span>, it proves their correct evaluations and then uses <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> to prove that <span class="math">g(\\bm{s})=\\prod_{i=0}^{p}g_{i}(\\bm{s})</span> with respect to these commitments. Making these changes results in a protocol that is the same as that in <em>[ZGK^{+}17b]</em> except for the last round from the prover to the verifier. Indeed we can prove the security of our protocol by making a reduction to the one of <em>[ZGK^{+}17b]</em>. In Figure 3 we give a detailed description of this protocol for the case <span class="math">p=2</span>; this is sufficient for our applications.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">EFFICIENCY. In  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> , the verifier needs time  <span class="math">O(\\mu)</span>  plus the time to compute  <span class="math">g_0(\\pmb{s})</span> . The prover's costs include the running time in the sum-check protocol and the creation of the  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  proofs. If the  <span class="math">g_i</span>  are multilinear,  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> . Prove time is  <span class="math">O(2^{\\mu})</span> . Also, from [Tha13], if the polynomials  <span class="math">g_i</span>  allow for evaluation in  <span class="math">O(\\mu)</span>  time or are MLE of vectors, the prover's cost in sum-check can be reduced to  <span class="math">O(2^{\\mu})</span> . More detailed, our verifier runs linearly on the number of variables of the polynomial and the prover time is linear on the number of monomials of the factors of the target polynomial. The degree- <span class="math">d</span>  polynomial  <span class="math">g(S)</span>  can have up to  <span class="math">m</span>  monomials (in particular,  <span class="math">m \\leq 2^{\\mu}</span> ). Note that in the  <span class="math">i</span> -th iteration, the prover evaluates the target polynomial  <span class="math">2^{\\mu - i}</span>  times. This means  <span class="math">2^{\\mu}</span>  times in one whole execution of the scheme. For each variable of the polynomial, the prover sends one  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  proof and commitments to each nonzero coefficient of  <span class="math">h_i(X)</span> , at most  <span class="math">(d + 1)</span>  of them. Finally, he sends commitments to the evaluations of the two factor polynomials, two  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  proofs and one  <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>  proof. The crs in this case is as long as the one for  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> , with  <span class="math">\\delta = 1</span>  and then  <span class="math">(\\delta + 1)^{\\mu} \\geq m</span> .</p>

    <p class="text-gray-300">Theorem 5.1. Assume PolyCom is an extractable linearly homomorphic commitment,  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>  are  <span class="math">zkSNARKs</span>  for relations  <span class="math">R^{\\mathsf{poly}}</span>  and  <span class="math">R^{\\mathsf{prd}}</span>  respectively, and Construction 2 in  <span class="math">[ZGK^{+}17b]</span>  is a ZK interactive argument for sum-check. Then there is a ZK interactive argument for relation  <span class="math">R^{\\mathsf{sc}}</span> . Furthermore, by applying the Fiat-Shamir heuristic we get a  <span class="math">zkSNARK</span>  in the random oracle model, that we call  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> .</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{sc}</span> Common input:  <span class="math">c_{t},g_{0},c_{1},c_{2}</span>  .  <span class="math">\\mathcal{P}</span>  's input:  <span class="math">(t,o_t,g_1,o_1,g_2,o_2)</span> <span class="math">\\mathcal{P}:g(\\pmb {S}):= \\prod_{i = 0}^{2}g_{i}(\\pmb {S}),c_{0}:= c_{t},t_{0}:= t,\\rho_{0}:= o_{t}</span>  , let  <span class="math">f(A_0,\\ldots A_k)\\coloneqq A_0 + \\sum_{j = 0}^d A_j\\coloneqq (2,1,\\dots ,1)</span> for  <span class="math">i = 1\\dots \\mu</span>  .. <span class="math">\\mathcal{P}:h_i(X)\\coloneqq \\sum_{b_{i + 1},\\ldots ,b_\\mu \\in \\{0,1\\}}g(s_1,\\ldots ,s_{i - 1},X,b_{i + 1},\\ldots ,b_\\mu)\\coloneqq \\sum_{j = 0}^d a_jX^j</span> <span class="math">\\mathcal{P}</span>  : compute  <span class="math">\\{(\\mathrm{com}_{a_j},\\rho_{a_j})\\gets \\mathrm{ComVal}(\\mathrm{ck},a_j)\\}_{j = 0}^d,(\\mathrm{com}_{i - 1}^<em>,\\rho_{i - 1}^</em>)\\gets \\mathrm{HomEval}(\\mathrm{ck},f,\\{\\mathrm{com}_{a_j}\\}_{j = 0}^d),\\{\\rho_{a_j}\\}_{j = 0}^d)</span> <span class="math">\\pi_{\\mathrm{eq}}\\gets \\mathrm{CP}_{\\mathrm{eq}}.</span>  Prove  <span class="math">(\\mathrm{ck},\\mathrm{com}_{i - 1},\\mathrm{com}_{i - 1}^<em>,t_{i - 1},h_i(0) + h_i(1),\\rho_{i - 1},\\rho_{i - 1}^</em>)</span> <span class="math">\\mathcal{P}\\to \\mathcal{V}:\\{\\mathrm{com}_{a_j}\\}_{j = 0}^d,\\pi_{\\mathrm{eq}}</span> <span class="math">\\mathcal{V}:\\{\\mathrm{CheckCom}(\\mathrm{cvk},\\mathrm{com}_{a_j})\\}_{j = 0}^d</span>  , compute  <span class="math">(\\mathrm{com}_{i - 1}^<em>,\\cdot)\\gets \\mathrm{HomEval}(\\mathrm{ck},f,\\{\\mathrm{com}_{a_j}\\}_{j = 0}^d),\\cdot)</span> <span class="math">\\mathcal{V}:CP_{\\mathrm{eq}}.</span>  VerProof(cvk,comi-1,comi-1,πeq),si←F,(comi,·)←HomEval(ck,(1,si,...,si),{comaj}d/2=0,·)  <span class="math">\\mathcal{V}\\rightarrow \\mathcal{P}:s_i\\in \\mathbb{F}</span> <span class="math">\\mathcal{P}:t_i\\gets h_i(s_i),(\\mathrm{com}_i,\\rho_i)\\gets \\mathrm{HomEval}(\\mathrm{ck},(1,s_i,\\dots ,s_i^d),\\{\\mathrm{com}_{a_j}\\}_{j = 0}^d,\\{\\rho_{a_j}\\}_{j = 0}^d)</span> endfor <span class="math">\\mathcal{P}:\\{(c_j&#x27;,o_j&#x27;)\\gets \\mathrm{ComVal}(\\mathrm{ck},g_j&#x27; := g_j(\\pmb {s})),\\pi_j\\gets \\mathrm{CP}_{\\mathrm{poly}}.</span>  Prove(ek,s,(cj,cj), (gj,gj), (oj,o))j=1,2 <span class="math">\\mathcal{P}:(c_1^</em>,o_1^<em>)\\gets \\mathrm{HomEval}(\\mathrm{ck},g_0(\\pmb {s}),c_1&#x27;,o_1&#x27;),\\pi^</em>\\gets \\mathrm{CP}_{\\mathrm{prd}}.</span>  Prove(ck,(c1,c2,comμ),(g0(s)·g1,g2,g(s)),(o1,o2,ρμ)) <span class="math">\\mathcal{P}\\to \\mathcal{V}:c_1&#x27;,c_2&#x27;,\\pi_1,\\pi_2,\\pi^<em></span> <span class="math">\\mathcal{V}:\\bigwedge_{j = 1,2}\\mathrm{CheckCom}(\\mathrm{cvk},c_j&#x27;)\\wedge \\mathrm{CP}_{\\mathrm{poly}}.</span>  VerProof(vk,s,cj,cj,πj) <span class="math">\\mathcal{V}:(c_1^</em>,\\cdot)\\gets \\mathrm{HomEval}(\\mathrm{ck},g_0(\\pmb {s}),c_1&#x27;,\\cdot),\\mathrm{CP}_{\\mathrm{prd}}.</span>  VerProof(vk,(c1,c2,comμ),π*)</p>

    <p class="text-gray-300">Figure 3: Our sum-check protocol over committed result and polynomial with 3 factors  <span class="math">(p = 2)</span> ; in black are the steps identical to  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right]</span> .</p>

    <p class="text-gray-300">In this section we propose a CP-SNARK for PolyCom for the relation  <span class="math">R^{\\mathrm{had}}</span>  over  <span class="math">(\\mathbb{F}^m)^3</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {\\mathsf {h a d}} (\\pmb {u} _ {0}, \\pmb {u} _ {1}, \\pmb {u} _ {2}) = 1 \\iff \\forall i \\in [ m ]: u _ {0, i} = u _ {1, i} \\cdot u _ {2, i}</span></div>

    <p class="text-gray-300">Let  <span class="math">m = 2^{\\mu}</span>  and let  <span class="math">\\tilde{u}_j: \\mathbb{F}^\\mu \\to \\mathbb{F}</span>  be the MLE of  <span class="math">\\pmb{u}_j</span> . Clearly, the relation holds iff for all  <span class="math">\\pmb{b} \\in \\{0,1\\}^\\mu</span>  we have  <span class="math">\\tilde{u}_0(\\pmb{b}) = \\tilde{u}_1(\\pmb{b}) \\cdot \\tilde{u}_2(\\pmb{b})</span> . If the relation holds, observe that the polynomial  <span class="math">\\tilde{u}_1(\\pmb{X}) \\cdot \\tilde{u}_2(\\pmb{X})</span>  is an extension of the vector  <span class="math">\\pmb{u}_0</span> , but not a multilinear one. From Lemma 5.1 this equality holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {u} _ {0} (\\boldsymbol {X}) = \\sum_ {\\boldsymbol {b} \\in \\{0, 1 \\} ^ {\\mu}} \\tilde {e q} (\\boldsymbol {X}, \\boldsymbol {b}) \\cdot \\tilde {u} _ {1} (\\boldsymbol {b}) \\cdot \\tilde {u} _ {2} (\\boldsymbol {b})</span></div>

    <p class="text-gray-300">Without considering zero-knowledge, the main idea of our protocol is that, to check the above equality, the verifier starts by picking a random point  <span class="math">\\boldsymbol{r} \\gets \\mathbb{F}^{\\mu}</span> , and then the prover uses  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  to show that  <span class="math">t = \\tilde{u}_0(\\boldsymbol{r}) = \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^\\mu} g(\\boldsymbol{b})</span> , where  <span class="math">g(\\boldsymbol{S}) = \\tilde{eq}(\\boldsymbol{r}, \\boldsymbol{S}) \\cdot \\tilde{u}_1(\\boldsymbol{S}) \\cdot \\tilde{u}_2(\\boldsymbol{S})</span> . Notice indeed that  <span class="math">g</span>  can be written as the product of three polynomials  <span class="math">g(\\boldsymbol{S}) := \\prod_0^2 g_i(\\boldsymbol{S})</span> , of which the first one is public:  <span class="math">g_1(\\boldsymbol{S}) = \\tilde{u}_1(\\boldsymbol{S})</span> ,  <span class="math">g_2(\\boldsymbol{S}) = \\tilde{u}_2(\\boldsymbol{S})</span>  and  <span class="math">g_0(\\boldsymbol{S}) := \\tilde{eq}(\\boldsymbol{r}, \\boldsymbol{S})</span> . Finally, the prover also needs to convince the verifier that  <span class="math">t = \\tilde{u}_0(\\boldsymbol{r})</span> , which is done using a CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  for proving correctness of polynomial evaluations. Therefore we build a CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span>  for  <span class="math">R^{\\mathsf{had}}</span>  and PolyCom by using CP-SNARKs  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> ,  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  for PolyCom as building blocks. Furthermore, we describe the scheme as a non-interactive one by letting  <span class="math">\\boldsymbol{r} \\gets H((c_j)_{j \\in [3]})</span>  using the random oracle model for  <span class="math">H</span> . The full scheme is given below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPhad.KeyGen(ck)→(ek,vk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPhad.Prove(ek,(cj)j∈[3], (uj)j∈[3], (oj)j∈[3]) → π := (ct, π0, πsc)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(eks, vks)← CPsc.KeyGen(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">r← H((cj)j∈[3]) ; t← u0(r) ; (ct, ot) ← ComVal(ck, t)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(ekp, vkp)← CPpoly.KeyGen(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">π0← CPpoly.Prove(ekp, r, (c0, ct), (u0, t), (o0, ot))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ek := (ck, eks, ekp, H)</td>

            <td class="px-3 py-2 border-b border-gray-700">πsc← CPsc.Prove(eks, êq(r, S), (ct, c1, c2), (t, ot, u1, o1, u2, o2))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">vk := (cvk, vks, vkp, H)</td>

            <td class="px-3 py-2 border-b border-gray-700">CPhad.VerProof(vk, (cj)j∈[3], π) → b ∈ {0, 1}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | r← H((cj)j∈[3]) ; b← CPpoly.VerProof(vkp, r, c0, ct, π0)  |</p>

    <p class="text-gray-300">|   | b← b ∧ CPsc.VerProof(vks, êq(r, S), (ct, c1, c2), πsc)  |</p>

    <p class="text-gray-300">Figure 4: CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span>  for relation  <span class="math">R^{\\mathrm{had}}</span></p>

    <p class="text-gray-300">EFFICIENCY. Computing  <span class="math">\\pi_0</span>  takes time  <span class="math">O(m)</span> , and the same holds for  <span class="math">\\pi_{\\mathrm{sc}}</span> . The latter follows by observing that the factors of  <span class="math">g(S)</span>  satisfy the good efficiency conditions for  <span class="math">\\mathsf{CP}_{\\mathrm{sc}}</span> , i.e.,  <span class="math">\\tilde{e} q(\\boldsymbol{r},\\boldsymbol{s})</span>  can be computed in  <span class="math">O(\\mu)</span>  time and  <span class="math">\\tilde{u}_1,\\tilde{u}_2</span>  are MLE of vectors of length  <span class="math">m = 2^{\\mu}</span> . For similar reasons, the verifier's time is  <span class="math">O(\\mu)</span> . More detailed, our  <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span>  that proves the result of Hadamard products  <span class="math">\\boldsymbol{u}_0 = \\boldsymbol{u}_1\\circ \\boldsymbol{u}_2</span>  with  <span class="math">m = 2^{\\mu}</span>  elements each. The prover runs linear in the number of monomials of  <span class="math">\\tilde{u}_0(X)</span> , which is at most  <span class="math">m</span> , and the verifier time is linear in its number of variables  <span class="math">\\mu</span> . The prover sends one value commitment, one  <span class="math">\\mathsf{CP}_{\\mathrm{poly}}</span>  proof and one  <span class="math">\\mathsf{CP}_{\\mathrm{sc}}</span> . Note the polynomial used inside sum-check is at most degree  <span class="math">d = 3</span>  in each variable. The crs include the group elements output by</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. KeyGen with <span class="math">\\delta = 1</span>, and the description of the hash function <span class="math">H:(\\mathbb{G}_1,\\mathbb{G}_1)^3\\to \\mathbb{F}^\\mu</span> used as a random oracle to achieve noninteractivity.</p>

    <p class="text-gray-300">We state the following result; its proof is in Appendix F.2.</p>

    <p class="text-gray-300">Theorem 5.2. In the random oracle model, assuming that PolyCom is an extractable trapdoor commitment, <span class="math">\\mathsf{CP}_{\\mathsf{poly}},\\mathsf{CP}_{\\mathsf{sc}}</span> are zero-knowledge CP-SNARKs for PolyCom and relations <span class="math">R^{\\mathrm{poly}}</span> and <span class="math">R^{\\mathrm{sc}}</span> respectively, then the scheme <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> described above is a zero-knowledge CP-SNARK for PolyCom and relation <span class="math">R^{\\mathrm{had}}</span>.</p>

    <h2 id="sec-41" class="text-2xl font-bold">5.4 A CP-SNARK for Self Permutation</h2>

    <p class="text-gray-300">In this section we propose a CP-SNARK for PolyCom for the relation <span class="math">R_{\\phi}^{\\mathrm{sfprm}}</span> defined below.</p>

    <p class="text-gray-300">Definition 5.2 (Self permutation of a vector). Let <span class="math">\\mathcal{D}</span> be some domain (e.g., a finite field <span class="math">\\mathbb{F}</span>), let <span class="math">n_0, \\ldots, n_\\ell</span> be positive integers such that <span class="math">\\mathcal{D}_j := \\mathcal{D}^{n_j}</span> and let <span class="math">m = \\sum_{j=0}^\\ell n_j</span>. Given a permutation <span class="math">\\phi : [m] \\to [m]</span>, we define a relation <span class="math">R_{\\phi}^{\\mathrm{sfprm}}</span> over <span class="math">\\mathcal{D}_0 \\times \\dots \\times \\mathcal{D}_\\ell = \\mathcal{D}^m</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\phi} ^ {\\mathrm {s f p r m}} \\left(\\boldsymbol {x}, \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}\\right) = 1 \\iff \\forall i \\in [ m ]: y _ {i} = y _ {\\phi (i)}, \\text{ where } \\boldsymbol {y} := \\left(\\boldsymbol {x}, \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}\\right)</span></div>

    <p class="text-gray-300">Our scheme uses a probabilistic test to prove a permutation of vectors due to [Gro09, BCG⁺17]. For this we need of a CP-SNARK for proving that <span class="math">t = \\prod_{i=1}^{m} y_i</span> with respect to a commitment to point <span class="math">t</span> and vector <span class="math">\\mathbf{y}</span>. We call such a relation internal product <span class="math">R^{\\mathrm{ipd}}</span>. A formal definition follows:</p>

    <p class="text-gray-300">Definition 5.3 (Internal product). Let <span class="math">n_1, \\ldots, n_\\ell</span> be positive integers and let <span class="math">m = \\sum_{j=1}^\\ell n_j</span>. We define the relation <span class="math">R^{\\mathrm{ipd}}</span> over <span class="math">\\mathbb{F} \\times \\mathbb{F}^{n_1} \\cdots \\times \\mathbb{F}^{n_\\ell}</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {\\mathrm {i p d}} \\left(u _ {0}, \\boldsymbol {y} := \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}\\right) = 1 \\iff u _ {0} \\stackrel {?} {=} \\prod_ {j = 1} ^ {\\ell} \\prod_ {i = 1} ^ {n _ {j}} y _ {j, i} ^ {\\prime}</span></div>

    <p class="text-gray-300">We give a formal description of <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> in Figure 19 and its computation complexity in Appendix G.</p>

    <p class="text-gray-300">In what follows we present the main ideas to build a CP-SNARK for <span class="math">R^{\\mathrm{sfprm}}</span> from one for <span class="math">R^{\\mathrm{ipd}}</span>. Next, we discuss how a CP-SNARK for internal products can be instantiated.</p>

    <p class="text-gray-300">Recall that the goal is to prove that, for a permutation <span class="math">\\phi : [m] \\to [m]</span> a committed vector <span class="math">\\mathbf{y}</span> satisfies <span class="math">y_{i} = y_{\\phi(i)}, \\forall i \\in [m]</span>. Consider the following vectors in <span class="math">\\mathbb{F}^m</span>, <span class="math">\\mathbf{1}</span>, <span class="math">\\mathbf{v} = (1, \\ldots, m)</span>, and <span class="math">\\phi = (\\phi(1), \\ldots, \\phi(m))</span>, and assume that the prover committed to <span class="math">\\mathbf{y}</span>. Let the verifier choose two random values <span class="math">r, s \\gets \\S \\mathbb{F}</span> and define the vectors <span class="math">\\mathbf{y}&#x27; := \\mathbf{y} + r \\cdot \\mathbf{v} - s \\cdot \\mathbf{1}</span> and <span class="math">\\mathbf{y}&#x27;&#x27; := \\mathbf{y} + r \\cdot \\phi - s \\cdot \\mathbf{1}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\pmb{y}</span> is a permutation of itself according to <span class="math">\\phi</span>, then <span class="math">(\\pmb{y} + r \\cdot \\pmb{\\phi})</span> is a permutation of <span class="math">(\\pmb{y} + r \\cdot \\pmb{v})</span> according to <span class="math">\\phi</span>; however, if <span class="math">\\pmb{y}</span> is not a self-permutation according to <span class="math">\\phi</span> then with overwhelming probability over the choice of <span class="math">r</span> some of the entries of <span class="math">\\pmb{y} + r \\cdot \\pmb{\\phi}</span> will not be in the vector <span class="math">\\pmb{y} + r \\cdot \\pmb{v}</span>. In our scheme the idea is to let the prover show that <span class="math">\\prod_{i} y_{i}&#x27; = z = \\prod_{i} y_{i}&#x27;&#x27;</span> using <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> on <span class="math">(z, \\pmb{y}&#x27;)</span> and <span class="math">(z, \\pmb{y}&#x27;&#x27;)</span>. However, if some entries of <span class="math">\\pmb{y} + r \\cdot \\pmb{\\phi}</span> are not in <span class="math">\\phi \\neq \\pmb{y} + r \\cdot \\pmb{v}</span>, <span class="math">\\prod_{i} (y_{i} + r \\cdot i - s) = \\prod_{i} (y_{i} + r \\cdot \\phi(i) - s)</span> holds with negligible probability over the choice of <span class="math">s</span> by the Schwartz-Zippel lemma, thus a prover can be successful only by cheating with <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>.</p>

    <p class="text-gray-300">We consider an instantiation of <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> based on Thaler's protocol for trees of multiplications [Tha13]. <span class="math">R^{\\mathrm{ipd}}</span> can be expressed with an arithmetic circuit that is a tree of multiplications over <span class="math">m = 2^{\\mu}</span> inputs. Thaler showed that for this specially regular circuit the CMT protocol can be</p>

    <p class="text-gray-300">adapted so that the prover and verifier run in time <span class="math">O(m)</span> and <span class="math">O(\\mu^2)</span>, respectively. To build a CP-SNARK for <span class="math">R^{\\mathrm{ipd}}</span>, we thus modify the zk-vSQL protocol [ZGK+17b] so as to work over Thaler's protocol instead of CMT. The changes are quite minimal and mainly regard the equation that links the adjacent layers of the tree. We show this protocol in Appendix G.</p>

    <p class="text-gray-300">One detail to be noted here is that such <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> works with binary tree circuits, meaning that their input should be a power of two length, so we tweak our definition of the self-permutation relation accordingly. We must work on <span class="math">\\ell + 1</span> vectors such that, each has length <span class="math">n_j = 2^{\\mu_j}</span> (this is immediate since we commit to MLEs of vectors) but their concatenation has length <span class="math">\\sum_{j=0}^{\\ell} n_j = m</span> which may not be a power-of-two.</p>

    <p class="text-gray-300">To solve this issue, we execute <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> on each block and then aggregate the <span class="math">\\ell + 1</span> committed results using a simple zero-knowledge argument for proving a product relation over three commitments, i.e., <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>. This results in about <span class="math">\\ell + 1</span> calls to <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>. Although this makes proofs grow with <span class="math">\\ell</span>, we observe that in all our applications <span class="math">\\ell</span> is some small constant, e.g., <span class="math">8 - 10</span> in our arithmetic circuits encoding.</p>

    <p class="text-gray-300">EFFICIENCY. From the efficiency observations about <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> given above, we get that <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span>. Prove and <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span>. VerProof run in time <span class="math">O(m)</span> and <span class="math">O(\\log^2 m)</span> respectively. More in depth, our <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span>, built from <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>, is used for proving that a vector <span class="math">\\pmb{y} \\in \\mathbb{F}^m</span> is a self-permutation. This scheme works for vectors whose components <span class="math">\\pmb{y} := (\\pmb{x}, (\\pmb{u}_j)_{j \\in [\\ell]})</span> have power-of-two length <span class="math">n_j = 2^{\\mu_j}</span> such that <span class="math">m = \\sum_{j=0}^{\\ell} n_j</span>, where <span class="math">\\ell</span> is typically some small constant. For each of its <span class="math">(\\ell + 1)</span> components, the prover runs 2 calls to <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> and iteratively builds 2 proofs-of-product and a final call to <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>. This means the prover runs in time <span class="math">O(m)</span>, the verifier runs in polylogarithmic time in <span class="math">m</span>. The prover sends <span class="math">(4\\ell + 5)</span> commitments, 1 opening, <span class="math">2(\\ell + 1)</span> short <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> proofs, <span class="math">2\\ell</span> <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> proofs and 1 proof-of-equality. Note that in each iteration, the length of the current vector is some <span class="math">n_i &amp;lt; m</span>. This means that performing <span class="math">(\\ell + 1)</span> calls to <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> costs the prover <span class="math">O(\\sum_{i=0}^{\\ell} n_i) = O(m)</span>. Conversely, the length of such <span class="math">(\\ell + 1)</span> <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> proofs is notably larger than the hypothetical length of one single <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> proof over <span class="math">\\pmb{y} \\in \\mathbb{F}^m</span>, except that our <span class="math">m</span> is not necessarily a power of two as the tree of multiplications requires. Here, the length of these <span class="math">(2\\ell + 2)</span> <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span> proofs is <span class="math">\\sum_{j=0}^{\\ell} (11\\mu_j^2 + 25\\mu_j) + 2\\ell + 2</span> group elements and <span class="math">\\sum_{j=0}^{\\ell} (\\mu_j^2 + 15\\mu_j)</span> field elements. For brevity, we can express this kind of calculations asymptotically as <span class="math">O(\\log^2 m)</span>. Note its upper bound for any constant <span class="math">\\ell</span> using the fact that <span class="math">\\sum_{j=0}^{\\ell} \\log^2 n_j &amp;lt; \\ell \\log^2 \\max\\{n_j\\}_0^\\ell &amp;lt; \\ell \\log^2 m</span>. Here the crs size is the same as that in <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>: <span class="math">(2m + 3)\\mathbb{G}_1 + (\\mu + 3)\\mathbb{G}_2</span> elements.</p>

    <p class="text-gray-300">Theorem 5.3. In the random oracle model, assuming that PolyCom is an extractable and linearly-homomorphic trapdoor commitment, <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> are zero-knowledge CP-SNARKs for PolyCom and relations <span class="math">R^{\\mathrm{ipd}}</span> and <span class="math">R^{\\mathrm{prd}}</span> respectively, then <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span> in Figure 5 is a zero-knowledge CP-SNARK for PolyCom and relation <span class="math">R^{\\mathrm{sfprm}}</span>.</p>

    <h2 id="sec-42" class="text-2xl font-bold">5.5 A CP-SNARK for Linear Properties of Committed Vector</h2>

    <p class="text-gray-300">In this section we show a CP-SNARK for PolyCom that has a specializable universal CRS for relations <span class="math">R_{\\mathbf{F}}^{\\mathrm{lin}}(\\mathbf{x}, \\mathbf{u}) := \\mathbf{x} \\stackrel{?}{=} \\mathbf{F} \\cdot \\mathbf{u}</span> where <span class="math">\\mathbf{F} \\in \\mathbb{Z}_q^{n \\times m}</span>, <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^n</span> and <span class="math">\\mathbf{u} \\in \\mathbb{Z}_q^m</span>. More precisely, our <span class="math">\\mathsf{CP}_{\\mathrm{lin}}</span> works for a family of relations <span class="math">\\mathcal{R}</span> that includes all <span class="math">R_{\\mathbf{F}}^{\\mathrm{lin}}</span> for all matrices <span class="math">\\mathbf{F} \\in \\mathbb{F}^{n \\times m}</span>.</p>

    <p class="text-gray-300">The scheme is based on the interactive proof for Matrix multiplication of Thaler [Tha13]. In a nutshell, we specialize this protocol to the case of a matrix-vector multiplication and we turn it into a ZK argument using ideas similar to those in [ZGK+17b].</p>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 5: CP-SNARK for specializable universal relation  <span class="math">R^{\\mathrm{sfprm}}</span></p>

    <p class="text-gray-300">Our scheme makes use of the building blocks defined in Section 5.1: a polynomial commitment scheme PolyCom, and CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> for the relations <span class="math">R^{\\mathsf{poly}}</span> and <span class="math">R^{\\mathsf{sc}}</span> respectively.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Review of Thaler’s Matrix Multiplication protocol.</h4>

    <p class="text-gray-300">We begin by reviewing the idea of Thaler’s matrix multiplication protocol in our specific case of proving <span class="math">\\bm{x}=\\bm{F}\\cdot\\bm{u}</span>. Let <span class="math">\\nu:=\\log n,\\mu:=\\log m</span>. We let <span class="math">\\tilde{F}:\\{0,1\\}^{\\nu}\\times\\{0,1\\}^{\\mu}\\rightarrow\\mathbb{Z}_{q}</span> be the multilinear extension (MLE) of <span class="math">\\bm{F}</span>, i.e., the unique multilinear polynomial such that <span class="math">\\tilde{F}(i_{1},\\ldots,i_{\\nu},j_{1},\\ldots,j_{\\mu})=F_{i,j}</span>. Similarly, let <span class="math">\\tilde{u}</span> and <span class="math">\\tilde{x}</span> be the MLE of <span class="math">\\bm{u}</span> and <span class="math">\\bm{x}</span> respectively. The protocol exploits that the MLE <span class="math">\\tilde{x}</span> can also be expressed as <span class="math">\\tilde{x}(\\bm{R})=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\tilde{F}(\\bm{R},\\bm{b})\\cdot\\tilde{u}(\\bm{b})</span>. In particular, since this MLE is unique, if <span class="math">\\tilde{F}</span> and <span class="math">\\tilde{u}</span> are MLE of <span class="math">\\bm{F}</span> and <span class="math">\\bm{u}</span> respectively, then <span class="math">\\tilde{x}</span> is a MLE of <span class="math">\\bm{x}=\\bm{F}\\cdot\\bm{u}</span>. Next, starting from this observation, the verifier picks a random <span class="math">\\bm{r}</span>, and then starts a sum-check protocol where the prover convinces the verifier that <span class="math">t=\\tilde{x}(\\bm{r})=\\sum_{\\bm{b}\\in\\{0,1\\}^{\\mu}}g(\\bm{b})</span> for the polynomial <span class="math">g(\\bm{S}):=\\tilde{F}(\\bm{r},\\bm{S})\\cdot\\tilde{u}(\\bm{S})</span>. At the end of the sum-check the verifier instead of computing <span class="math">g(\\bm{s})</span> directly, it gets it by evaluating <span class="math">\\tilde{F}(\\bm{r},\\bm{s})</span> and <span class="math">\\tilde{u}(\\bm{s})</span> and by computing their product.</p>

    <p class="text-gray-300">The idea to turn the above protocol into a commit and prove argument is rather simple and consists into using a CP-SNARK for the sumcheck relation with a committed polynomial <span class="math">g</span>, or more precisely for the case when a commitment to <span class="math">g</span> is implicitly given through commitments to its factors (see the <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> scheme). To see this, let us write <span class="math">g(\\bm{S}):=\\prod_{0}^{p}g_{i}(\\bm{S})</span>, where <span class="math">g_{1}(\\bm{S}):=\\tilde{F}(\\bm{r},\\bm{S})</span>, <span class="math">g_{2}(\\bm{S})=\\tilde{u}(\\bm{S})</span>, and <span class="math">g_{0}(\\bm{S}):=1</span> is the constant polynomial. A commitment to <span class="math">\\tilde{u}(\\bm{S})</span> is part of the statement, a commitment to <span class="math">\\tilde{F}(\\bm{R},\\bm{S})</span> can be generated when specializing the relation to <span class="math">\\bm{F}</span> in the Derive algorithm. However, note that <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> expects a commitment to a <span class="math">\\mu</span>-variate polynomial, whereas <span class="math">\\tilde{F}</span> is in <span class="math">\\nu+\\mu</span> variables. For this, we let the prover commit to the partial evaluation of <span class="math">\\tilde{F}</span> on <span class="math">\\bm{r}</span>, i.e., to the polynomial <span class="math">g_{1}(\\bm{S})</span> and uses this commitment and polynomial in <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>. Then, what is left to show is that such committed <span class="math">g_{1}(\\bm{S})</span> is actually the partial evaluation of the other committed polynomial <span class="math">\\tilde{F}</span>. To prove this, the idea is that the verifier chooses a random <span class="math">\\sigma\\leftarrow\\S\\mathbb{F}^{\\mu}</span>, and the prover uses <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> to prove that <span class="math">g_{1}(\\bm{\\sigma})=\\tilde{F}(\\bm{r},\\bm{\\sigma})</span>.</p>

    <p class="text-gray-300">We show the full protocol <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> in Figure 6.</p>

    <p class="text-gray-300">Efficiency. Our <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> proves the result of a matrix-vector multiplication <span class="math">\\bm{F}\\cdot\\bm{u}=\\bm{x}</span> for <span class="math">\\bm{F}\\in\\mathbb{F}^{n\\times m}</span>. The prover sends one <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> proof, two <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> proofs, three commitments and two field elements. Here the polynomial used inside sum-check is at most degree <span class="math">2</span> in each of its <span class="math">\\mu=\\log m</span> variables. Here, <span class="math">p=2=d</span> because <span class="math">g_{0}</span> is the constant polynomial and does not increase the total maximum degree inside sum-check. Also, the number of variables for the first <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> proof over <span class="math">g_{1}(\\bm{S})</span> is <span class="math">\\log m</span> and the number of monomials is <span class="math">m</span>. For the second one over <span class="math">\\tilde{F}(\\bm{r},\\bm{S})</span> with <span class="math">N</span> monomials, the number of variables is <span class="math">\\log n+\\log m=\\log N</span>. The <span class="math">\\mathsf{crs}</span> output by the derivation function includes matrix <span class="math">\\bm{F}</span>., whereas the output of <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span>. <span class="math">\\mathsf{KeyGen}</span> has <span class="math">(2\\cdot 2^{\\nu+\\mu}+3)\\mathbb{G}_{1}+(\\nu+\\mu+3)\\mathbb{G}_{2}</span> elements; that is, we are not considering the derived version including the description of matrix <span class="math">\\bm{F}</span> (as this is part of the statement).</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Theorem 5.4.</h6>

    <p class="text-gray-300">In the random oracle model, assuming <span class="math">\\mathsf{PolyCom}</span> is an extractable trapdoor commitment and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> are zero-knowledge CP-SNARKs for <span class="math">\\mathsf{PolyCom}</span>, then <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> in Figure 6 is a zero-knowledge CP-SNARK for <span class="math">\\mathsf{PolyCom}</span> and relations <span class="math">R^{\\mathsf{lin}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: CP-SNARK for specializable universal  <span class="math">R^{\\mathrm{lin}}</span></p>

    <p class="text-gray-300">In this section we propose a CP-SNARK for PolyCom for the relation  <span class="math">R^{\\mathsf{mm}}</span>  over  <span class="math">\\mathcal{D}_A \\times \\mathcal{D}_B \\times \\mathcal{D}_C</span>  where  <span class="math">\\mathcal{D}_A = \\mathbb{F}^{n \\times n&#x27;}</span> ,  <span class="math">\\mathcal{D}_B = \\mathbb{F}^{n&#x27; \\times m}</span> ,  <span class="math">\\mathcal{D}_C = \\mathbb{F}^{n \\times m}</span>  and  <span class="math">R^{\\mathsf{mm}}(\\mathbf{A}, \\mathbf{B}, \\mathbf{C}) = 1 \\iff \\mathbf{C} = \\mathbf{A} \\cdot \\mathbf{B}</span> . Namely, for two committed matrices  <span class="math">\\mathbf{A}</span>  and  <span class="math">\\mathbf{B}</span> , one can prove that another committed matrix  <span class="math">\\mathbf{C}</span>  equals to their product.</p>

    <p class="text-gray-300">The scheme is inspired by the interactive proof of matrix multiplication of Thaler [Tha13], making it a ZK argument with similar ideas to those in  <span class="math">\\mathrm{[ZGK^{+}17b]}</span> . We build our scheme for the polynomial commitment scheme PolyCom and CP-SNARKs  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  for the relations  <span class="math">R^{\\mathsf{poly}}</span>  and  <span class="math">R^{\\mathsf{sc}}</span>  for factored polynomials.</p>

    <p class="text-gray-300">We present this scheme for square matrices for readability, but the protocol can be simply adapted to the general form. Let matrices  <span class="math">\\mathbf{A}, \\mathbf{B}, \\mathbf{C} \\in \\mathbb{F}^{n \\times n}</span> , we build their multilinear extension  <span class="math">\\tilde{C} \\in \\mathbb{F}^{\\mu} \\times \\mathbb{F}^{\\mu} \\to \\mathbb{F}</span>  with  <span class="math">\\mu = \\log n</span> , which is the unique polynomial such that  <span class="math">\\tilde{C}(i_1, \\ldots, i_\\mu, j_1, \\ldots, j_\\mu) = C_{i,j}</span>  if  <span class="math">\\{i_k\\}_{k=1}^\\mu</span>  and  <span class="math">\\{j_k\\}_{k=1}^\\mu</span>  are the binary representation of indexes  <span class="math">i</span>  and  <span class="math">j</span>  (resp.  <span class="math">\\tilde{A}</span>  and  <span class="math">\\tilde{B}</span> ).</p>

    <p class="text-gray-300">Then, we can represent matrix multiplication as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {C} (\\boldsymbol {I}, \\boldsymbol {J}) = \\sum_ {\\boldsymbol {b} \\in \\{0, 1 \\} ^ {\\mu}} \\tilde {A} (\\boldsymbol {I}, \\boldsymbol {b}) \\cdot \\tilde {B} (\\boldsymbol {b}, \\boldsymbol {J})</span></div>

    <p class="text-gray-300">where  <span class="math">(\\mathbf{I},\\mathbf{J})</span>  could be seen as a single vector of length  <span class="math">2\\mu</span> . However, we will stick to this notation instead as it makes clearer that multilinearity is conserved after the product of  <span class="math">\\tilde{A}</span>  and  <span class="math">\\tilde{B}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol works as follows. The prover evaluates  <span class="math">\\tilde{C}</span>  on a randomly chosen value  $(\\pmb{\\rho}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{\\sigma})<span class="math">  and obtains a proof that the output  </span>t<span class="math">  is indeed the result of the polynomial evaluation  </span>t = \\tilde{C}(\\pmb{\\rho},\\pmb{\\sigma})<span class="math">  using  </span>\\mathsf{CP}_{\\mathsf{poly}}<span class="math"> . Then, the prover convinces the verifier that  </span>\\tilde{C}<span class="math">  is well-formed using  </span>\\mathsf{CP}_{\\mathsf{sc}}<span class="math"> , i.e.  </span>t = \\sum_{\\pmb{b} \\in \\{0,1\\}^{\\mu}} g(b)<span class="math"> . Here  </span>g(\\pmb{S}) = \\prod_{n}^{2} g_i(\\pmb{S})<span class="math"> , where  </span>g_1(\\pmb{S}) := \\tilde{A}(\\pmb{\\rho},\\pmb{S})<span class="math"> ,  </span>g_2(\\pmb{S}) := \\tilde{B}(\\pmb{S},\\pmb{\\sigma})<span class="math">  and  </span>g_0(\\pmb{S}) := 1$  is the all-ones constant polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPmm.KeyGen(ck) → (ek, vk):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPmm.Prove(ek, cA, cB, cC, A, B, C, oA, oB, oC, ) → π :</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(eks, vks) ← CPsc.KeyGen(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">(ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">σ) ← H(cA, cB, cC) ; t ← C(ρ, σ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(ekp, vkp) ← CPpoly.KeyGen(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">(ct, ot) ← ComVal(ck, t)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (ck, ekp, eks, H), (cvk, vkp, vks, H)</td>

            <td class="px-3 py-2 border-b border-gray-700">Define constant function g0(S) := 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPmm.VerProof(vk, cA, cB, cC, π) → b ∈ {0,1} :</td>

            <td class="px-3 py-2 border-b border-gray-700">Let g(S) := A(ρ, S) · B(S, σ) ≡ g1(S) · g2(S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Define constant function g0(S) := 1</td>

            <td class="px-3 py-2 border-b border-gray-700">πt ← CPpoly.Prove(ekp, (ρ, σ), (cC, ct), (C, t), (oC, ot))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b ← CPpoly.VerProof(vkp, (ρ, σ), cC, ct, πt)</td>

            <td class="px-3 py-2 border-b border-gray-700">πsc ← CPsc.Prove(eks, g0(S), (ct, cA, cB), (t, ot, A, oA, B, oB))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∧ CPsc.VerProof(vks, g0(S), (ct, cA, cB), πsc)</td>

            <td class="px-3 py-2 border-b border-gray-700">return π ← (ct, πt, πsc)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPmmp.KeyGen(ck) → (ek, vk):</td>

            <td class="px-3 py-2 border-b border-gray-700">CPmmp.Prove(ek, cA, cB, X, A, B, oA, oB) → π :</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(eks, vks) ← CPsc.KeyGen(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">(ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">σ) ← H(X, cA, cB) ; t ← X(ρ, σ) ; (ct, ot) ← ComVal(ck, t)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return ((ck, eks, H), (cvk, vks, H))</td>

            <td class="px-3 py-2 border-b border-gray-700">Let g(S) := A(ρ, S) · B(S, σ) ≡ g1(S) · g2(S) ; g0(S) := 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | π ← CPsc.Prove(eks, g0(S), (ct, cA, cB), (t, ot, A, oA, B, oB))  |</p>

    <p class="text-gray-300">|  CPmmp.VerProof(vk, X, cA, cB, π) → b ∈ {0,1} : |   |</p>

    <p class="text-gray-300">|  (ρ, σ) ← H(X, cA, cB) ; t ← X(ρ, σ) ; (ct, ot) ← ComVal(ck, t) ; g0(S) := 1 |   |</p>

    <p class="text-gray-300">|  b ← CPsc.VerProof(vks, g0(S), (ct, cA, cB), π) |   |</p>

    <p class="text-gray-300">Figure 7: CP-SNARK for matrix multiplication with committed output (top) and CP-SNARK for matrix multiplication with known output (bottom)</p>

    <p class="text-gray-300">EFFICIENCY. The cost of this scheme is given by the complexity of  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> . The proving time of the former is linear in the number of monomials of the polynomial  <span class="math">\\tilde{C}</span> , which is  <span class="math">2^{2\\mu}</span>  by construction. Similarly, the latter's is linear in the monomials of  <span class="math">g(S)</span> , which is again  <span class="math">2^{2\\mu}</span> . This makes a linear prover in the number of elements ( <span class="math">N = n^2</span> ). The verifier runtime is linear in the number of variables of the polynomials (i.e.  <span class="math">2\\mu</span> ). The crs size is given by that of  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  for committed polynomials of length  <span class="math">2\\mu</span>  and  <span class="math">\\delta = 1</span>  (because  <span class="math">\\tilde{A}</span> ,  <span class="math">\\tilde{B}</span>  and  <span class="math">\\tilde{C}</span>  are multilinear polynomials of  <span class="math">\\log n + \\log n</span>  variables). That is, it has linear length in the matrix size with  <span class="math">2n^2 + 3\\mathbb{G}_1</span>  and  <span class="math">2\\mu + 3\\mathbb{G}_2</span>  elements. The proof involves one  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  proof ( <span class="math">4\\mu + 2\\mathbb{G}_1</span> , with  <span class="math">2\\mu</span>  variables), one  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  proof ( <span class="math">11\\mu + 11\\mathbb{G}_1</span>  and  <span class="math">\\mu + 5\\mathbb{F}</span> , with  <span class="math">\\mu</span>  variables) and one commitment ( <span class="math">2\\mathbb{G}_1</span> ).</p>

    <p class="text-gray-300">Theorem 5.5. In the random oracle model, assuming that PolyCom is an extractable trapdoor commitment,  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  are  <span class="math">zkSNARKs</span>  for PolyCom and relations  <span class="math">R^{\\mathsf{poly}}</span>  and  <span class="math">R^{\\mathsf{sc}}</span>  respectively, then the scheme  <span class="math">\\mathsf{CP}_{\\mathsf{mm}}^{16}</span>  described above is a  <span class="math">zkSNARK</span>  for PolyCom and relation  <span class="math">R^{\\mathsf{mm}}</span> .</p>

    <p class="text-gray-300">In this section we propose a variation of our  <span class="math">\\mathsf{CP}_{\\mathsf{mm}}</span>  for PolyCom for the relation  <span class="math">R^{\\mathsf{mmp}}</span>  over  <span class="math">\\mathcal{D}_X\\times</span> <span class="math">\\mathcal{D}_A\\times \\mathcal{D}_B</span>  where  <span class="math">\\mathcal{D}_x = \\mathbb{F}^{n\\times m}</span> <span class="math">\\mathcal{D}_A = \\mathbb{F}^{n\\times n&#x27;}</span> <span class="math">\\mathcal{D}_B = \\mathbb{F}^{n&#x27;\\times m}</span>  and  <span class="math">R^{\\mathsf{mmp}}(\\pmb {X},\\pmb {A},\\pmb {B}) = 1\\Longleftrightarrow \\pmb {X} = \\pmb {A}\\cdot \\pmb{B}</span>  Namely, for two committed matrices  <span class="math">\\pmb{A}</span>  and  <span class="math">\\pmb{B}</span> , one can prove that a public matrix  <span class="math">\\pmb{X}</span>  equals to</p>

    <p class="text-gray-300">their product. This version is more efficient than the obvious solution of opening the commitment to <span class="math">\\bm{C}</span> in the <span class="math">\\mathsf{CP_{mm}}</span> scheme.</p>

    <p class="text-gray-300">These two versions only vary only subtly on the way the matrix <span class="math">\\bm{X}</span> is treated. Here, the verifier can check the correct evaluation on a random value <span class="math">t\\stackrel{{\\scriptstyle?}}{{=}}\\tilde{X}(\\bm{\\rho},\\bm{\\sigma})</span>, with no need of relying on <span class="math">\\mathsf{CP_{poly}}</span>. We give the complete protocol in Figure 7 for completeness but we do not provide a formal proof, as its security is trivially implied by that of <span class="math">\\mathsf{CP_{mm}}</span>.</p>

    <p class="text-gray-300">The asymptotic complexity of the prover in this scheme is the same as that in <span class="math">\\mathsf{CP_{mm}}</span>. In practice however, the prover is twice faster, as it will not run <span class="math">\\mathsf{CP_{poly}}</span>. Conversely, the verifier will be slower because evaluating <span class="math">\\tilde{X}(\\bm{\\rho},\\bm{\\sigma})</span> is more costly than verifying a <span class="math">\\mathsf{CP_{poly}}</span> proof (about <span class="math">O(n^{2})</span> field operations vs. <span class="math">O(\\log n)</span> group operations). Note here that evaluating the MLE of <span class="math">\\bm{X}</span> as</p>

    <p class="text-gray-300"><span class="math">\\tilde{X}(x_{1},\\ldots,x_{2\\mu}):=\\sum\\nolimits_{\\bm{b}\\in\\{0,1\\}^{2\\mu}}\\chi_{\\bm{b}}(x_{1},\\ldots,x_{2\\mu})\\cdot X(\\bm{b})</span></p>

    <p class="text-gray-300">where <span class="math">\\chi_{\\bm{b}}(x_{1},\\ldots,x_{2\\mu}):=\\prod_{j=1}^{2\\mu}\\big{(}\\bm{b}_{j}\\cdot x_{j}+(1-\\bm{b}_{j})(1-x_{j})\\big{)}</span>, takes both the prover and the verifier <span class="math">2^{2\\mu}\\cdot 2\\mu</span> operations naively. Following the strategy of <em>[x20]</em>, the terms <span class="math">\\chi_{\\bm{b}}</span> can be precomputed offline so that computing each <span class="math">\\chi_{\\bm{b}}(\\bm{x})\\cdot X(\\bm{b})</span> takes a constant time and evaluating <span class="math">\\tilde{X}(\\bm{\\rho},\\bm{\\sigma})</span> becomes a quadratic-time task in <span class="math">n</span> (as <span class="math">2^{2\\mu}=n^{2}</span>).</p>

    <p class="text-gray-300">Efficiency. Our <span class="math">\\mathsf{CP_{mmp}}</span> proves matrix multiplication <span class="math">\\bm{X}=\\bm{A}\\cdot\\bm{B}</span> where the output <span class="math">\\bm{X}</span> is given in clear. We consider square matrices of <span class="math">N=n\\ \\times\\ n</span> elements with <span class="math">n=2^{\\mu}</span>. Both prover and verifier evaluate the <span class="math">\\tilde{X}</span> on a <span class="math">2\\mu-</span>length random point. By construction of the MLE <span class="math">\\tilde{X}(r_{1},\\ldots,r_{2\\mu})=\\sum_{\\bm{b}\\in\\{0,1\\}^{2\\mu}}X(\\bm{b})\\prod_{j=1}^{2\\mu}\\chi_{\\bm{b}_{j}}(r_{j})</span>, this carries a cost of <span class="math">2^{2\\mu}\\cdot 2\\mu=2n^{2}\\log n=O(N\\log n)</span> field operations, which can be reduced to <span class="math">O(N)</span> through dynamic programming techniques <em>[x20]</em>. As the degree–2 polynomial <span class="math">g(\\bm{S})</span> inside sum-check has <span class="math">\\mu</span> variables, the proving algorithm in <span class="math">\\mathsf{CP_{sc}}</span> involves <span class="math">O(\\mu)</span> group operations. Checking <span class="math">\\pi_{\\mathsf{sc}}</span> requires <span class="math">O(\\mu)</span> more group operations from the verifier. The proof contains one <span class="math">\\mathsf{CP_{sc}}</span> proof consisting of <span class="math">(11\\mu+11)\\mathbb{G}_{1}</span> and <span class="math">(\\mu+5)\\mathbb{F}</span>. The <span class="math">\\mathsf{crs}</span> in this scheme is the same as the one in <span class="math">\\mathsf{CP_{sc}}</span> for <span class="math">p=2=d</span> and <span class="math">\\delta=1</span>, which also coincides with that of <span class="math">\\mathsf{CP_{mm}}</span>. That is, it has linear length in the matrix size with <span class="math">(2n^{2}+3)\\mathbb{G}_{1}</span> and <span class="math">(2\\mu+3)\\mathbb{G}_{2}</span> elements. We do not include the description of the public matrix as this is part of the statement.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 5.6.</h6>

    <p class="text-gray-300">In the random oracle model, assuming that <span class="math">\\mathsf{PolyCom}</span> is an extractable trapdoor commitment and <span class="math">\\mathsf{CP_{sc}}</span> is a zkSNARK for <span class="math">\\mathsf{PolyCom}</span> and relation <span class="math">R^{\\mathsf{sc}}</span>, then the scheme <span class="math">\\mathsf{CP_{mmp}}</span> is a zkSNARK for <span class="math">\\mathsf{PolyCom}</span> and relation <span class="math">R^{\\mathsf{mmp}}</span>.</p>

    <h2 id="sec-48" class="text-2xl font-bold">6 LegoSNARK Applications and Evaluation</h2>

    <p class="text-gray-300">In this section we show how to use the modular commit-and-prove approach to obtain new CP-SNARKs for computations expressible by arithmetic circuits (ACs) and we discuss the resulting instantiations. Precisely, we show new CP-SNARKs for (1) arithmetic circuit satisfiability, and (2) parallel computation on joint inputs.</p>

    <p class="text-gray-300">In both constructions the idea is to break the target problem into the conjunction of simpler relations with shared input. Once having done this, and assuming the existence of CP-SNARKs for these simpler relations and that share the same commitment scheme, we immediately obtain a CP-SNARK for the target problem by applying our composition Theorem 3.1. Furthermore, thanks to our lifting transformation of Section 3.5 sharing the same commitment scheme is not a restricting requirement.</p>

    <p class="text-gray-300">6.1 Preliminaries and Building Blocks</p>

    <p class="text-gray-300">We begin by formalizing some basic relations useful to express our target problems.</p>

    <p class="text-gray-300">Equalities Among Vector Entries. A common building block in both schemes of this section is a system for proving that the entries of a vector satisfy a set of equalities between them. Namely, given a set <span class="math">S</span> of pairs of indices <span class="math">(i,k)</span>, we define a relation <span class="math">R^{\\mathsf{veq}}_{S}</span> that holds for a vector <span class="math">\\boldsymbol{u}</span> iff <span class="math">u_{i}=u_{k}</span> for all <span class="math">(i,k)\\in S</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 6.1 (Relation for equalities among vector entries).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}</span> be some domain (e.g., a finite field <span class="math">\\mathbb{F}</span>), let <span class="math">n_{0},\\ldots,n_{\\ell}</span> be positive integers such that <span class="math">\\mathcal{D}_{j}:=\\mathcal{D}^{n_{j}}</span> and let <span class="math">m=\\sum_{j=0}^{\\ell}n_{j}</span>. Given a set <span class="math">S=\\{(i_{1},k_{1}),\\ldots,(i_{l},k_{l})\\}\\subset[m]\\times[m]</span>, we define a relation <span class="math">R^{\\mathsf{veq}}_{S}</span> over <span class="math">\\mathcal{D}_{0}\\times\\cdots\\times\\mathcal{D}_{\\ell}=\\mathcal{D}^{m}</span> such that: <span class="math">R^{\\mathsf{veq}}_{S}\\big{(}\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]}\\big{)}=1\\iff\\forall(i,k)\\in S:y_{i}=y_{k}</span>, where <span class="math">\\boldsymbol{y}:=(\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})</span>.</p>

    <p class="text-gray-300">In what follows, we discuss different ways to encode this relation.</p>

    <p class="text-gray-300">The relation <span class="math">R^{\\mathsf{veq}}_{S}</span> can be expressed using <span class="math">R^{\\mathsf{sfprm}}_{\\phi}</span> in Definition 5.2 for an appropriate permutation <span class="math">\\phi</span> that encodes <span class="math">S</span>. The idea is that a set <span class="math">S\\subset[m]\\times[m]</span> can be seen as the description of an undirected graph with <span class="math">2m</span> vertices. From <span class="math">S</span> it is possible to extract another set <span class="math">S^{\\prime}\\subset[m]\\times[m]</span> that contains a cycle <span class="math">((i_{1},k_{1}),\\ldots,(i_{t},k_{t}))</span> for every connected component of the graph represented by <span class="math">S</span>. Taking the product of all the cycles in <span class="math">S^{\\prime}</span> defines a permutation <span class="math">\\phi:[m]\\to[m]</span> such that <span class="math">\\forall(i,k)\\in S:y_{i}=y_{k}</span> iff <span class="math">\\forall j\\in[m]:y_{j}=y_{\\phi(j)}</span>. Then for such <span class="math">\\phi</span> computed from <span class="math">S</span> we have <span class="math">R^{\\mathsf{veq}}_{S}(\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})\\iff R^{\\mathsf{sfprm}}_{\\phi}(\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})</span>. We refer to <em>[x10, BCG^{+}17]</em> for more details on the idea of this permutation encoding. Here is a small example. Consider an arbitrary <span class="math">m</span> and assume <span class="math">S=\\{(1,2),(1,3),(3,4),(6,7)\\}</span>. One can define a permutation <span class="math">\\phi_{S}</span> over <span class="math">[m]</span> as: <span class="math">\\phi_{S}(1)=2</span>, <span class="math">\\phi_{S}(2)=3</span>, <span class="math">\\phi_{S}(3)=4</span>, <span class="math">\\phi_{S}(4)=1</span>, <span class="math">\\phi_{S}(6)=7</span>, <span class="math">\\phi_{S}(7)=6</span>, and <span class="math">\\phi_{S}(j)=j</span> for all <span class="math">8\\leq j\\leq m</span>.</p>

    <p class="text-gray-300">At this point one can either assume to have a proof system for <span class="math">R^{\\mathsf{sfprm}}_{\\phi}</span> (as in Section 5.4) or to use an encoding of <span class="math">R^{\\mathsf{sfprm}}_{\\phi}</span> based on linear constraints that can be obtained as follows. The idea is to define a relation on a vector <span class="math">\\boldsymbol{y}\\in\\mathbb{F}^{m}</span> that is true iff <span class="math">\\boldsymbol{Z}\\cdot\\boldsymbol{y}=\\boldsymbol{0}</span>, where <span class="math">\\boldsymbol{Z}\\in\\mathbb{F}^{m^{\\prime}\\times m}</span>, with <span class="math">m^{\\prime}\\leq m</span>, is the matrix obtained by removing the zero rows from <span class="math">(\\boldsymbol{I}-\\boldsymbol{\\Sigma}_{\\phi})\\in\\mathbb{F}^{m\\times m}</span>, where <span class="math">\\boldsymbol{\\Sigma}_{\\phi}</span> is the permutation matrix representing <span class="math">\\phi</span>. Then clearly <span class="math">R^{\\mathsf{sfprm}}_{\\phi}(\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})</span> holds iff <span class="math">R^{\\mathsf{lin}}_{\\boldsymbol{Z}}(\\boldsymbol{0},\\boldsymbol{x},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})</span> holds, where the relation <span class="math">R^{\\mathsf{lin}}</span>, modelling the linear property over (committed) vectors, is formally defined as follows.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 6.2 (Linear property relation).</h6>

    <p class="text-gray-300">Let <span class="math">n_{1},n_{2},m_{1},\\ldots,m_{\\ell}</span> be integers such that <span class="math">\\{\\mathcal{D}_{x,j}:=\\mathcal{D}^{n_{j}}\\}_{j\\in[1,2]}</span>, <span class="math">\\{\\mathcal{D}_{u,j}:=\\mathcal{D}^{m_{j}}\\}_{j\\in[\\ell]}</span>, and <span class="math">m=n_{2}+\\sum_{j=1}^{\\ell}m_{j}</span>. Given a matrix <span class="math">\\boldsymbol{F}\\in\\mathcal{D}^{n_{1}\\times m}</span>, we define a relation <span class="math">R^{\\mathsf{lin}}_{\\boldsymbol{F}}</span> over <span class="math">\\mathcal{D}_{x,1}\\times\\mathcal{D}_{x,2}\\times\\mathcal{D}_{u,1}\\times\\cdots\\times\\mathcal{D}_{u,\\ell}</span> such that:</p>

    <p class="text-gray-300"><span class="math">R^{\\mathsf{lin}}_{\\boldsymbol{F}}\\big{(}\\boldsymbol{x}_{1},\\boldsymbol{x}_{2},(\\boldsymbol{u}_{j})_{j\\in[\\ell]}\\big{)}=1\\iff\\boldsymbol{F}\\cdot\\boldsymbol{y}=\\boldsymbol{x}_{1}</span>, where <span class="math">\\boldsymbol{y}:=(\\boldsymbol{x}_{2},(\\boldsymbol{u}_{j})_{j\\in[\\ell]})</span></p>

    <p class="text-gray-300">Note that the above relation <span class="math">R^{\\mathsf{lin}}</span> is slightly different from the one supported by <span class="math">\\mathsf{CP}^{\\mathsf{Ped}}_{\\mathsf{lin}}</span> of Section 4.2. The only difference is that in <span class="math">\\mathsf{CP}^{\\mathsf{Ped}}_{\\mathsf{lin}}</span> the linear function is not applied over public inputs. However, this small discrepancy can be easily solved by adding a commitment to the additional public input <span class="math">\\boldsymbol{x}_{2}</span> and opening this commitment.</p>

    <p class="text-gray-300">Summary of the Building Blocks. In Table 2 we recall the various commit-and-prove SNARKs presented Sections 4 and 5 along with a summary of their efficiency measures. First-level dependencies between the different building blocks can be found in the first column of the table. We wanted to show the minimal requirements to build such constructions, regardless of the inner instantiation</p>

    <p class="text-gray-300">of each modular component. That is, for each row we are pointing out the CP-SNARKs that appear only in the description of their respective protocol.</p>

    <p class="text-gray-300">Let us consider the problem of arithmetic circuit satisfiability.</p>

    <p class="text-gray-300">Definition 6.3. Let  <span class="math">C: \\mathbb{F}^{n_x} \\times \\mathbb{F}^{n_w} \\to \\mathbb{F}^l</span>  be an arithmetic circuit, where  <span class="math">n_x, n_w, l \\in \\mathbb{N}</span>  denote input, witness and output length. We define the arithmetic circuit satisfiability relation  <span class="math">R_C^{\\mathrm{ac}}(\\pmb{x},\\pmb{w})</span>  as the set of pairs such that  <span class="math">C(\\pmb{x},\\pmb{w}) = \\mathbf{0}^l</span> .</p>

    <p class="text-gray-300">We show two solutions to model the above relation using a commit-and-prove paradigm. The first one relies on the encoding put forward by Bootle et al.  <span class="math">\\mathrm{[BCC^{+}16]}</span>  that reduces the relation  <span class="math">R^{\\mathrm{ac}}</span>  to an Hadamard product and a set of linear constraints. The second one is similar to that of Groth [Gro09] (recently used in  <span class="math">\\mathrm{[BCG^{+}17]}</span> ) and encodes arithmetic circuit satisfiability using Hadamard products, additions and permutations of (committed) vectors.</p>

    <p class="text-gray-300">Following  <span class="math">\\mathrm{[BCC^{+}16,BBB^{+}17]}</span> , an arithmetic circuit  <span class="math">C</span>  can be described by a tuple  <span class="math">(n_x,n_u,N,\\pmb {W}_L,</span> <span class="math">\\pmb {W}_R,\\pmb {W}_O,\\pmb {W}_x,\\pmb {W}_U,\\pmb {c})</span>  where  <span class="math">n_x</span>  and  <span class="math">n_u</span>  are the input and (committed) witness lengths respectively,  <span class="math">N</span>  is the number of multiplication gates, and matrices  <span class="math">\\pmb {W}_L,\\pmb {W}_R,\\pmb {W}_O\\in \\mathbb{F}^{Q\\times N},\\pmb {W}_x\\in \\mathbb{F}^{Q\\times n_x},\\pmb {W}_U\\in</span> <span class="math">\\mathbb{F}^{Q\\times n_u}</span>  and vector  <span class="math">\\pmb {c}\\in \\mathbb{F}^Q</span>  describe a system of linear equations over the wires of  <span class="math">C</span> . Using such a definition,  <span class="math">C</span>  is satisfied by  <span class="math">(\\pmb {x},\\pmb {u})</span>  if there exist three vectors  <span class="math">\\pmb{u}_{L}^{M},\\pmb{u}_{R}^{M},\\pmb{u}_{O}^{M}\\in \\mathbb{F}^{N}</span>  such that</p>

    <p class="text-gray-300"><span class="math">\\pmb{u}_{L}^{M}\\circ \\pmb{u}_{R}^{M} = \\pmb{u}_{O}^{M}\\wedge \\pmb{W}_{L}\\cdot \\pmb{u}_{L}^{M} + \\pmb{W}_{R}\\cdot \\pmb{u}_{R}^{M} + \\pmb{W}_{O}\\cdot \\pmb{u}_{O}^{M} + \\pmb{W}_{x}\\cdot \\pmb{x} + \\pmb{W}_{U}\\cdot \\pmb{u} = \\pmb{c}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP-SNARKs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">crs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dependencies</td>

            <td class="px-3 py-2 border-b border-gray-700">Scheme</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CPlin</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">m+ℓ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ+2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CPPadlin</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+n)</td>

            <td class="px-3 py-2 border-b border-gray-700">m+ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">n+ℓ+1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPeq ∧ CPpoly ∧ CPprd → CPsc</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">2(δ+1)μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ(2d+2p+3)+4p+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPpoly ∧ CPsc → CPlin</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2N+3</td>

            <td class="px-3 py-2 border-b border-gray-700">log N+3</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log N+13μ+21</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPsc → CPmmp</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n2+3</td>

            <td class="px-3 py-2 border-b border-gray-700">2μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">11μ+11</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPpoly ∧ CPsc → CPmm</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n2+3</td>

            <td class="px-3 py-2 border-b border-gray-700">2μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">15μ+15</td>

            <td class="px-3 py-2 border-b border-gray-700">2μ+5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPpoly ∧ CPsc → CPhad</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">15μ+15</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPeq ∧ CPpoly ∧ CPprd → CPipd</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ2)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">11μ2/2+25μ/2+2</td>

            <td class="px-3 py-2 border-b border-gray-700">μ2/2+15μ/2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPeq ∧ CPipd ∧ CPprd → CPsfpm</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(μ2)</td>

            <td class="px-3 py-2 border-b border-gray-700">2n+3</td>

            <td class="px-3 py-2 border-b border-gray-700">μ+3</td>

            <td class="px-3 py-2 border-b border-gray-700">∑j=0l(11μj2+25μj)+16ℓ+13</td>

            <td class="px-3 py-2 border-b border-gray-700">∑j=0l(μj2+15μj)+10ℓ+2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Direct dependencies and concrete theoretical costs of our CP-SNARKs. In  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  we denote: by  <span class="math">m</span>  the number of monomials in the sumcheck polynomial; by  <span class="math">\\mu</span>  the number of variables in the sumcheck polynomial (note  <span class="math">m \\leq 2^{\\mu}</span> ); by  <span class="math">\\delta</span>  the degree of the committed polynomial (if  <span class="math">\\delta = 1</span> , it holds that  <span class="math">(\\delta + 1)^{\\mu} \\geq m</span> ); by  <span class="math">d</span>  the maximum degree of each variable in the sumcheck polynomial; by  <span class="math">p</span>  the number of polynomial factors committed. For all remaining schemes, we denote: by  <span class="math">n</span>  the length of vectors, the order of square matrices or the largest dimension in a matrix; by  <span class="math">\\mu</span>  the size of the multilinear extensions involved, which above it is always such that  <span class="math">\\mu = \\log n</span> ; by  <span class="math">N</span>  the size of the  <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{lin}}^{\\mathsf{Ped}}</span>  matrix, of dimension  <span class="math">2^{\\nu} \\times 2^{\\mu} = n \\times m</span> ; by  <span class="math">\\mu_{j}</span>  the logarithm of the length of the  <span class="math">j</span> -th set of variables; by  <span class="math">\\ell</span>  the total number of commitments.</p>

    <p class="text-gray-300"><span class="math">R^{\\mathsf{ac}}_{C}(\\bm{x},\\bm{u},\\bm{u}_{w}):=R^{\\mathsf{had}}(\\bm{u}^{M}_{L},\\bm{u}^{M}_{R},\\bm{u}^{M}_{O})\\wedge R^{\\mathsf{lin}}_{\\bm{F}}(\\bm{c},(\\bm{x},\\bm{u},\\bm{u}^{M}_{L},\\bm{u}^{M}_{R},\\bm{u}^{M}_{O}))</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{F}=(\\bm{W}_{x},\\bm{W}_{U},\\bm{W}_{L},\\bm{W}_{R},\\bm{W}_{O})\\in\\mathbb{F}^{Q\\times(n_{x}+n_{u}+3N)}</span>.</p>

    <p class="text-gray-300">By the above definition of <span class="math">R^{\\mathsf{ac}}_{C}</span> and our Theorem 3.1 we obtain the following corollary.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Corollary 6.1.</h6>

    <p class="text-gray-300">If there exist CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> for a commitment scheme <span class="math">\\mathsf{Com}</span> and for relations <span class="math">R^{\\mathsf{had}}</span> and <span class="math">R^{\\mathsf{lin}}</span> respectively, then there is a CP-SNARK <span class="math">\\mathsf{LegoAC}</span> for <span class="math">\\mathsf{Com}</span> and relation <span class="math">R^{\\mathsf{ac}}_{C}</span>.</p>

    <p class="text-gray-300">Instantiations. We evaluate two instantiations of <span class="math">\\mathsf{LegoAC}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{LegoAC1}</span>: from our <span class="math">\\mathsf{CP}^{\\mathsf{Ped}}_{\\mathsf{lin}}</span> (Section 4.2) and Lipmaa’s CP-SNARK for Hadamard products <em>[x11]</em>. <span class="math">\\mathsf{LegoAC1}</span> is a CP-SNARK for the commitment scheme of <em>[x11]</em>, and its security holds in the generic group model (due to GGM security of <span class="math">\\mathsf{CP}^{\\mathsf{Ped}}_{\\mathsf{lin}}</span>).</li>

      <li><span class="math">\\mathsf{LegoAC2}</span>: from our <span class="math">\\mathsf{CP}^{\\mathsf{Ped}}_{\\mathsf{lin}}</span> (Section 4.2) and our <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> (Section 5.3). This is a CP-SNARK for <span class="math">\\mathsf{PolyCom}</span>, and its security holds in the GGM and random oracle model (the latter due to <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span>).</li>

    </ul>

    <p class="text-gray-300">If needed, both schemes can be lifted to work with a standard Pedersen commitment using <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span>. Their complexity, summarized in Table 1, results from the combined efficiency of the building blocks plus the observation that the matrices <span class="math">\\bm{W}_{L},\\bm{W}_{R},\\bm{W}_{O}</span> are sparse and with a number of nonzero entries linear in the number of circuit wires.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">Arithmetic Circuit Satisfiability through Hadamard, Addition and Equalities</h3>

    <p class="text-gray-300">Any arithmetic circuit <span class="math">C</span> consists of <span class="math">N_{A}</span> addition gates, <span class="math">N_{M}</span> multiplication gates, both of fan-in 2, and <span class="math">N_{C}</span> multiplication-by-constant gates, of fan-in 1. Each gate has a left input, a right input and an output wire; also each output wire can be input to another gate. This means that <span class="math">C</span> can be described by integers <span class="math">N_{A},N_{M},N_{C}</span>, a vector <span class="math">\\bm{c}\\in\\mathbb{F}^{N_{C}}</span> of constants, and the wiring information saying that the output wire of addition/multiplication <span class="math">i</span> is the left/right input of addition/multiplication gate <span class="math">j</span>. With such a representation <span class="math">\\exists\\bm{w}:C(\\bm{x},\\bm{w})=\\bm{0}^{l}</span> can be encoded by showing the existence of an assignment to the inputs and outputs of <span class="math">C</span>’s gates that satisfies every gate, that is consistent with the wiring of <span class="math">C</span> as well as with the public input <span class="math">\\bm{x}</span> and the output <span class="math">\\bm{0}</span>.</p>

    <p class="text-gray-300">More formally, consider an arithmetic circuit <span class="math">C:\\mathbb{F}^{n_{x}}\\times\\mathbb{F}^{n_{w}}\\to\\mathbb{F}^{l}</span> with <span class="math">N_{A}</span> addition gates, <span class="math">N_{M}</span> multiplication gates, and <span class="math">N_{C}</span> multiplication by constant gates, and where we split the witness <span class="math">\\bm{w}</span> between committed witness <span class="math">\\bm{u}\\in\\mathbb{F}^{n_{u}}</span> and free witness <span class="math">\\bm{\\omega}\\in\\mathbb{F}^{n_{\\omega}}</span>. Assume we arrange the wires of <span class="math">C</span> so as to have, orderly: the <span class="math">n_{x}</span> input wires, the <span class="math">n_{u}</span> committed witness wires, the <span class="math">l</span> output wires, the <span class="math">3N_{A}</span> left, right and output wires of the addition gates, the <span class="math">3N_{M}</span> left, right and output wires of the multiplication gates, and the <span class="math">2N_{C}</span> input and output wires of the multiplication-by-constant gates. All these wires can be indexed by integers from 1 to <span class="math">m=n_{x}+n_{u}+l+3(N_{A}+N_{M})+2N_{C}</span>, and the wiring information of <span class="math">C</span> can be described by a set <span class="math">S</span> of pairs <span class="math">(i,k)\\in[m]\\times[m]</span> indicating that the wire at position <span class="math">i</span> is connected to the wire at position <span class="math">k</span>.</p>

    <p class="text-gray-300">Therefore we model an arithmetic circuit <span class="math">C</span> with a tuple <span class="math">(n_{x},n_{u},l,N_{A},N_{M},N_{C},\\bm{c},S)</span>. Then proving <span class="math">\\exists(\\bm{u},\\bm{\\omega})\\,R^{\\mathsf{ac}}_{C}(\\bm{x},\\bm{u},\\bm{\\omega})</span> can be done by proving the existence of a vector <span class="math">\\bm{u}_{w}</span>, that is the concatenation of vectors <span class="math">\\bm{u}_{w}:=(\\bm{u}^{A}_{L},\\bm{u}^{A}_{R},\\bm{u}^{A}_{O},\\bm{u}^{M}_{L},\\bm{u}^{M}_{R},\\bm{u}^{M}_{O},\\bm{u}^{C}_{I},\\bm{u}^{C}_{O})</span>, such that</p>

    <p class="text-gray-300"><span class="math">R^{\\mathsf{ac}}_{C}(\\bm{x},\\bm{u},\\bm{u}_{w})</span> <span class="math">:=R_{\\mathsf{add}}(\\bm{u}^{A}_{L},\\bm{u}^{A}_{R},\\bm{u}^{A}_{O})\\wedge R^{\\mathsf{had}}(\\bm{u}^{C}_{I},\\bm{c},\\bm{u}^{C}_{O})</span> <span class="math">\\wedge R^{\\mathsf{had}}(\\bm{u}^{M}_{L},\\bm{u}^{M}_{R},\\bm{u}^{M}_{O})\\wedge R^{\\mathsf{veq}}_{S}((\\bm{x},\\bm{0}),\\bm{u},\\bm{u}_{w})</span></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a) In  <span class="math">R^{\\mathrm{par}}</span> ,  <span class="math">R&#x27;</span>  inputs are disjoint</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (b) In  <span class="math">R^{\\mathrm{parjnt}}</span> ,  <span class="math">R&#x27;</span>  inputs are joint Figure 8: Inputs structures for parallel relations.</p>

    <p class="text-gray-300">where  <span class="math">R_{\\mathrm{add}}(\\pmb{u}_L^A, \\pmb{u}_R^A, \\pmb{u}_O^A)</span>  is the relation expressing the predicate  <span class="math">\\pmb{u}_L^A + \\pmb{u}_R^A \\stackrel{?}{=} \\pmb{u}_O^A</span> , and  <span class="math">R^{\\mathrm{had}}(\\pmb{u}_L^M, \\pmb{u}_R^M, \\pmb{u}_O^M)</span>  is the Hadamard product relation  <span class="math">\\pmb{u}_L^M \\circ \\pmb{u}_R^M \\stackrel{?}{=} \\pmb{u}_O^M</span>  (i.e.,  <span class="math">u_{L,j}^M \\cdot u_{R,j}^M = u_{O,j}^M</span>  for all  <span class="math">j \\in [3N_M]</span> ).</p>

    <p class="text-gray-300">If  <span class="math">\\mathsf{Com}</span>  is a linearly homomorphic and extractable commitment scheme, a proof system for  <span class="math">R_{\\mathrm{add}}</span>  comes for free. Therefore, by definition of  <span class="math">R_C^{\\mathrm{ac}}</span>  and our Theorem 3.1 we obtain the following corollary.</p>

    <p class="text-gray-300">Corollary 6.2. If there exist CP-SNARKs  <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathrm{veq}}</span>  for a linearly-homomorphic extractable commitment scheme  <span class="math">\\mathsf{Com}</span>  and for relations  <span class="math">R^{\\mathrm{had}}</span>  and  <span class="math">R^{\\mathrm{veq}}</span>  respectively, then there is a CP-SNARK LegoUAC for  <span class="math">\\mathsf{Com}</span>  and relation  <span class="math">R_C^{\\mathrm{ac}}</span> .</p>

    <p class="text-gray-300">Instantiating LegoUAC with Universal CRS. Both the schemes LegoAC1 and LegoAC2 considered earlier have a circuit-specific CRS due to the circuit-specific CRS of  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> . The LegoUAC scheme obtained in the corollary above can be instantiated in such a way to have universal CRS of linear-size. To this end, we recall that  <span class="math">R^{\\mathrm{veq}}</span>  can be expressing using  <span class="math">R^{\\mathrm{sfprm}}</span> , and therefore we evaluate an instantiation of LegoUAC with our  <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathrm{sfprm}}</span>  schemes. Both schemes admit a universal CRS that can be deterministically specialized (due to specializing  <span class="math">\\mathsf{CP}_{\\mathrm{sfprm}}</span> 's CRS to the circuit-dependent permutation  <span class="math">\\phi</span> ). The complexity of LegoUAC is depicted in Table 1 and stems from that of our  <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span>  and  <span class="math">\\mathsf{CP}_{\\mathrm{sfprm}}</span> .</p>

    <p class="text-gray-300">We consider the problem of proving (in zero-knowledge) the correctness of a computation that consists in the parallel execution of the same subcomputation on (partially) shared inputs. Slightly more in detail, we consider relations  <span class="math">R^{\\mathrm{parjnt}}(u) \\coloneqq \\bigwedge_{j=1}^{N} R&#x27;(u_j&#x27;)</span>  where each  <span class="math">u_j&#x27;</span>  is a subset of the entries of  <span class="math">u</span> . This relation has several use cases. One example is proving knowledge of all the leaves of a Merkle tree of height  <span class="math">N</span>  with respect to a public root; the corresponding relation can be seen as the parallel check of  <span class="math">2^N - 1</span>  hash verification relations (i.e.,  <span class="math">R_H(x_1, x_2, y) \\coloneqq H(x_1, x_2) \\stackrel{?}{=} y</span> ) that share some of the inputs. Another example is proving correctness of the output of a sequential computation whose internal step is always the same (e.g., the square-and-multiply algorithm).</p>

    <p class="text-gray-300">One way to deal with  <span class="math">R^{\\mathrm{parjnt}}</span>  is by defining the arithmetic circuit that computes it (cf. Fig. 8b). The Hyrax system is particularly designed for parallel circuits [WTs+18]; they deal with non-parallel input by introducing a (non-parallel) redistribution layer (RDL) layer that redistributes the input and feeds it to the identical sub-circuits at the next level. Unfortunately an effect of using an RDL is that the verifier must pay an additional cost linear in the total width of the circuit. This makes verification time pretty high in applications like the Merkle tree example above.</p>

    <p class="text-gray-300">Here we propose another natural modelling of relations with joint inputs, that is the simple conjunction of two relations:  <span class="math">R^{\\mathrm{par}}</span>  that models fully parallel checks of some  <span class="math">R&#x27;</span>  on disjoint inputs,</p>

    <p class="text-gray-300">and another relation that models the consistency of the shared inputs across the (fully) parallel executions. The advantage of this encoding is that <span class="math">R^{\\text{par}}</span> is now fully parallel and one could use for it a system for parallel computation without any caveat, whereas to check the consistency of shared input one can use a system for the <span class="math">R^{\\text{veq}}</span> relation from Definition 6.1. More formally, we define a parallel relation on disjoint inputs as follows.</p>

    <p class="text-gray-300"><strong>Definition 6.4 (Parallel relation on disjoint inputs).</strong> For a relation <span class="math">R&#x27;</span> over <span class="math">\\mathcal{D}&#x27;</span> and an integer <span class="math">N \\geq 1</span>, a parallel relation <span class="math">R_{R&#x27;}^{\\text{par}}</span> on disjoint inputs is defined as <span class="math">R_{R&#x27;}^{\\text{par}}(\\boldsymbol{u}) := \\bigwedge_{j=1}^{N} R&#x27;(u_j)</span>, where <span class="math">\\boldsymbol{u} := (u_j)_{j \\in [N]} \\in (\\mathcal{D}&#x27;)^N</span>.</p>

    <p class="text-gray-300">From <span class="math">R^{\\text{par}}</span> and <span class="math">R^{\\text{veq}}</span> we define a relation for parallel checks on joint inputs.</p>

    <p class="text-gray-300"><strong>Definition 6.5 (Parallel relation on joint inputs).</strong> Let <span class="math">n_0, n_1, n&#x27;, N \\in \\mathbb{N}</span> be integers such that <span class="math">n&#x27;, N \\geq 1</span> and <span class="math">n_0, n_1 \\geq 0</span>, and let <span class="math">m = n_0 + n_1 + N \\cdot n&#x27;</span>. Let <span class="math">\\mathcal{D}</span> be some domain, <span class="math">R&#x27;</span> be a relation over <span class="math">\\mathcal{D}&#x27; := \\mathcal{D}^{n&#x27;}</span>, and <span class="math">S</span> a set of the form <span class="math">S = \\{(i_1, k_1), \\ldots, (i_l, k_l)\\} \\subset [m] \\times [m]</span>. <span class="math">R_{R&#x27;,S}^{\\text{parjnt}}</span> is a relation over <span class="math">\\mathcal{D}_x \\times \\mathcal{D}_1 \\times \\mathcal{D}_2</span>, with <span class="math">\\mathcal{D}_x := \\mathcal{D}^{n_0}</span>, <span class="math">\\mathcal{D}_1 := \\mathcal{D}^{n_1}</span> and <span class="math">\\mathcal{D}_2 := \\mathcal{D}^{Nn&#x27;}</span>, such that:</p>

    <div class="my-4 text-center"><span class="math-block">R_{R&#x27;,S}^{\\text{parjnt}}(\\boldsymbol{x}, \\boldsymbol{u}_1, \\boldsymbol{u}_2) := R_{R&#x27;}^{\\text{par}}(\\boldsymbol{u}_2) \\wedge R_S^{\\text{veq}}(\\boldsymbol{x}, \\boldsymbol{u}_1, \\boldsymbol{u}_2)</span></div>

    <p class="text-gray-300">Basically, <span class="math">R_{R&#x27;,S}^{\\text{parjnt}}</span> models the parallel checking of <span class="math">R&#x27;</span> on <span class="math">N</span> different subsets of the entries of <span class="math">(\\boldsymbol{x}, \\boldsymbol{u}_1)</span> (consisting of a public <span class="math">\\boldsymbol{x}</span> and committed <span class="math">\\boldsymbol{u}_1</span>) where such subsets are defined by the set <span class="math">S</span>, and their concatenation is the vector <span class="math">\\boldsymbol{u}_2</span>. Alternatively, if <span class="math">\\boldsymbol{x}, \\boldsymbol{u}_1</span> are empty, <span class="math">R_{R&#x27;,S}^{\\text{parjnt}}</span> models the parallel checking of <span class="math">R&#x27;</span> on <span class="math">N</span> different sets of inputs with some shared values (as specified by <span class="math">S</span>).</p>

    <p class="text-gray-300">From the definition of <span class="math">R^{\\text{parjnt}}</span> and our Theorem 3.1 we obtain the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary 6.3.</strong> If there exist CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{par}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{veq}}</span> for a commitment scheme <span class="math">\\mathsf{Com}</span> relations <span class="math">R^{\\mathsf{par}}</span> and <span class="math">R^{\\mathsf{veq}}</span> respectively, then there is a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{parjnt}}</span> for <span class="math">\\mathsf{Com}</span> and relations <span class="math">R^{\\mathsf{parjnt}}</span>.</p>

    <p class="text-gray-300">INSTANTIATIONS. Following the corollary above, we consider an instantiation of <span class="math">\\mathsf{CP}_{\\mathsf{parjnt}}</span> (that we call LegoPar) obtained as follows. As <span class="math">\\mathsf{CP}_{\\mathsf{veq}}</span> we use our scheme <span class="math">\\mathsf{CP}_{\\mathsf{lin}}^{\\mathsf{Ped}}</span> using the encoding of <span class="math">R^{\\mathsf{veq}}</span> with linear constraints. As <span class="math">\\mathsf{CP}_{\\mathsf{par}}</span> we use an adaptation of Hyrax using the polynomial commitment PolyCom of zk-vSQL. We call HyrPoly-Par this scheme invoked on circuits without RDL (i.e., it supports <span class="math">R^{\\mathsf{par}}</span>), and HyrPoly-RDL the same scheme for circuits with an RDL (i.e., it supports <span class="math">R^{\\mathsf{parjnt}}</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We compare the efficiency of LegoPar and HyrPoly-RDL on <span class="math">R^{\\text{parjnt}}</span> relations. Let <span class="math">d</span> and <span class="math">G</span> be depth and width of the arithmetic circuit evaluating <span class="math">R&#x27;</span>. Proving time and proof size have the same complexity in both solutions; verifier time is <span class="math">O(d(G + \\log (NG)))</span> in LegoPar and $O(d(G + \\log (NG)) +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ NG)<span class="math"> in HyrPoly-RDL. We note that due to the use of </span>\\mathsf{CP}_{\\mathsf{lin}}^{\\mathsf{Ped}}<span class="math">, the CRS of LegoPar becomes specific to the input wiring of </span>R^{\\text{parjnt}}$, whereas in HyrPoly-RDL the CRS is just the commitment key. On the other hand, this one-time preprocessing allows the verifier to later check any number of proofs in shorter time.¹⁹ In Section 7 we discuss an experimental comparison based on an implementation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">¹⁹ We do not see a way to run a similar preprocessing in HyrPoly. We evaluated the possibility to commit, in preprocessing, to the MLE of the RDL wiring so that the prover would compute this on behalf of the verifier and prove its correct evaluation using <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. This idea however would require a commitment key quadratic in the circuit width, which is prohibitively large.</p>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">7 Experimental Evaluation</p>

    <p class="text-gray-300">We provide an implementation for LegoSNARK that includes the following gadgets: our CP_{link} and CP<span class="math">{}^{\\sf Ped}_{\\sf lin}</span>, the Hadamard product CP-SNARK of <em>[x13]</em>, and the CP_{poly} from <em>[ZGK^{+}17b]</em>. LegoSNARK is written in C++; for polynomial operations and bilinear pairings we use the libraries underlying libsnark <em>[x11]</em>. We executed our experiments on a virtual machine running Debian GNU/Linux with 8 Xeon Gold 6154 cores and 30 GB of RAM. We ran all tests single threaded. In our experiments, we tested the performance of some of our instantiations and compared to different baseline systems.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">7.1 Commit-and-Prove SNARKs</h3>

    <p class="text-gray-300">We consider a generic application of proving commit-and-prove relations where commitments are created using the Pedersen scheme for vectors, i.e., proving <span class="math">\\exists(u</span>,<span class="math">o</span>,<span class="math">\\omega)\\colon R(u</span>,<span class="math">\\omega)\\wedge\\mathsf{VerCommit}(\\mathsf{ck},c,u,o)</span>.</p>

    <p class="text-gray-300">As baseline system, we use the Groth16 zkSNARK in libsnark on the libsnark gadget circuit for multi-scalar additions over a SNARK-friendly elliptic curve (to model the Pedersen computation). We call this CPGro16. We compare CPGro16 to a CP-SNARK, LegoGro16, obtained by applying our cc-SNARK-lifting compiler with our CP_{link} scheme to the cc-variant of <em>[x10]</em>, ccGro16, that we present in Appendix H.5. We measured the overhead of dealing with the commitment in both schemes (the <span class="math">R</span>-dependent costs would be the same in both cases) at the increase of the committed vector’s size (from 8 to 2048). On the largest instance (<span class="math">n=2048</span>) LegoGro16’s proving time is 5K<span class="math">\\times</span> (0.08 vs. 428 s) faster than CPGro16, at the price of a verification that is 1.2<span class="math">\\times</span> slower (4.1 vs 3.4 ms), and a slightly larger proof (191 vs. 127 Bytes). LegoGro16’s CRS is also 7K<span class="math">\\times</span> shorter (130KB vs. 950MB).</p>

    <p class="text-gray-300">In the case of LegoGro16, such overhead in proving time is essentially that of creating the additional element <span class="math">D</span> of the proof that contains a commitment to the data and to create a CP_{link} proof to link <span class="math">D</span> to the external commitment. The LegoGro16 proof is longer because of these two additional elements of <span class="math">\\mathbb{G}_{1}</span>. And for verification, the CP_{link} verification must be executed. With respect to the CRS, in LegoGro16 we have the additional elements of the CRS needed to create <span class="math">D</span> and the CP_{link} CRS, that is essentially one vector of <span class="math">n</span> elements of <span class="math">\\mathbb{G}_{1}</span>. In CPGro16, all the overhead in proving time and CRS is related to the size and degree of the QAP that models the computation of the Pedersen commitment. This was done by selecting an appropriate gadget in libsnark, which optimizes the task by selecting a suitable elliptic curve.</p>

    <p class="text-gray-300">Table 3 shows our experimental results that compare the schemes LegoGro16 and CPGro16 with respect to the overhead for dealing with data committed using a Pedersen vector commitment. The experiments considered vectors of different length <span class="math">n</span>.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">7.2 Matrix Multiplication</h3>

    <p class="text-gray-300">We evaluate our CP_{mmp} scheme for matrix multiplication against a solution based on Groth16 <em>[x10]</em>. We remind the reader that in this version of matrix product relation the output matrix is given in the clear as part of the statement to be proven (rather than being committed as in CP_{mm}). Our scheme has a faster prover and smaller crs using an asymptotically more efficient verifier with a longer, but still succinct, proof. Our experiments confirm the theoretical costs of these schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LegoGro16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPGro16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KG (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">P (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">crs (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">KG (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">P (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">crs (MB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">3.677</td>

            <td class="px-3 py-2 border-b border-gray-700">3.044</td>

            <td class="px-3 py-2 border-b border-gray-700">0.51</td>

            <td class="px-3 py-2 border-b border-gray-700">3.928</td>

            <td class="px-3 py-2 border-b border-gray-700">1.185</td>

            <td class="px-3 py-2 border-b border-gray-700">3.653</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">5.949</td>

            <td class="px-3 py-2 border-b border-gray-700">4.202</td>

            <td class="px-3 py-2 border-b border-gray-700">1.02</td>

            <td class="px-3 py-2 border-b border-gray-700">7.307</td>

            <td class="px-3 py-2 border-b border-gray-700">2.252</td>

            <td class="px-3 py-2 border-b border-gray-700">7.305</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">10.90</td>

            <td class="px-3 py-2 border-b border-gray-700">5.201</td>

            <td class="px-3 py-2 border-b border-gray-700">2.04</td>

            <td class="px-3 py-2 border-b border-gray-700">13.78</td>

            <td class="px-3 py-2 border-b border-gray-700">4.461</td>

            <td class="px-3 py-2 border-b border-gray-700">14.61</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">19.37</td>

            <td class="px-3 py-2 border-b border-gray-700">8.979</td>

            <td class="px-3 py-2 border-b border-gray-700">4.08</td>

            <td class="px-3 py-2 border-b border-gray-700">26.04</td>

            <td class="px-3 py-2 border-b border-gray-700">8.685</td>

            <td class="px-3 py-2 border-b border-gray-700">29.22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">32.49</td>

            <td class="px-3 py-2 border-b border-gray-700">15.58</td>

            <td class="px-3 py-2 border-b border-gray-700">8.16</td>

            <td class="px-3 py-2 border-b border-gray-700">50.69</td>

            <td class="px-3 py-2 border-b border-gray-700">16.50</td>

            <td class="px-3 py-2 border-b border-gray-700">58.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">57.76</td>

            <td class="px-3 py-2 border-b border-gray-700">19.50</td>

            <td class="px-3 py-2 border-b border-gray-700">16.32</td>

            <td class="px-3 py-2 border-b border-gray-700">102.8</td>

            <td class="px-3 py-2 border-b border-gray-700">33.02</td>

            <td class="px-3 py-2 border-b border-gray-700">116.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">117.8</td>

            <td class="px-3 py-2 border-b border-gray-700">30.84</td>

            <td class="px-3 py-2 border-b border-gray-700">32.64</td>

            <td class="px-3 py-2 border-b border-gray-700">292.0</td>

            <td class="px-3 py-2 border-b border-gray-700">65.42</td>

            <td class="px-3 py-2 border-b border-gray-700">233.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">241.2</td>

            <td class="px-3 py-2 border-b border-gray-700">55.35</td>

            <td class="px-3 py-2 border-b border-gray-700">65.28</td>

            <td class="px-3 py-2 border-b border-gray-700">876.3</td>

            <td class="px-3 py-2 border-b border-gray-700">133.3</td>

            <td class="px-3 py-2 border-b border-gray-700">467.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">466.6</td>

            <td class="px-3 py-2 border-b border-gray-700">84.09</td>

            <td class="px-3 py-2 border-b border-gray-700">130.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1011</td>

            <td class="px-3 py-2 border-b border-gray-700">428.7</td>

            <td class="px-3 py-2 border-b border-gray-700">935.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">(B)</td>

            <td class="px-3 py-2 border-b border-gray-700">191.13</td>

            <td class="px-3 py-2 border-b border-gray-700">127.38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

            <td class="px-3 py-2 border-b border-gray-700">---</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.129</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Performance comparison of LegoGro16 and CPGro16. Numbers for the two schemes are in different units. Those for CPGro16 are three orders of magnitude larger.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Space</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">crs</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPmmp</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n3 log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(n3)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">CPmmp</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Groth16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">P (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">V (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">KB</td>

            <td class="px-3 py-2 border-b border-gray-700">P (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">V (ms)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">35.36</td>

            <td class="px-3 py-2 border-b border-gray-700">22.74</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">0.181</td>

            <td class="px-3 py-2 border-b border-gray-700">4.312</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">46.26</td>

            <td class="px-3 py-2 border-b border-gray-700">23.19</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.379</td>

            <td class="px-3 py-2 border-b border-gray-700">6.060</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">55.78</td>

            <td class="px-3 py-2 border-b border-gray-700">24.00</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">11.61</td>

            <td class="px-3 py-2 border-b border-gray-700">12.60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">83.78</td>

            <td class="px-3 py-2 border-b border-gray-700">28.03</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">109.3</td>

            <td class="px-3 py-2 border-b border-gray-700">50.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">149.7</td>

            <td class="px-3 py-2 border-b border-gray-700">40.01</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Comparing  <span class="math">\\mathbf{CP}_{\\mathrm{mmp}}</span>  and Groth16 for  <span class="math">n\\times n</span>  matrices</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LegoAC1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Groth16</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KG(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">P(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">V(ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">KG(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">P(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">V(ms)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">1.105</td>

            <td class="px-3 py-2 border-b border-gray-700">0.278</td>

            <td class="px-3 py-2 border-b border-gray-700">3.097</td>

            <td class="px-3 py-2 border-b border-gray-700">0.210</td>

            <td class="px-3 py-2 border-b border-gray-700">0.150</td>

            <td class="px-3 py-2 border-b border-gray-700">1.662</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">7.569</td>

            <td class="px-3 py-2 border-b border-gray-700">1.680</td>

            <td class="px-3 py-2 border-b border-gray-700">4.697</td>

            <td class="px-3 py-2 border-b border-gray-700">1.227</td>

            <td class="px-3 py-2 border-b border-gray-700">0.957</td>

            <td class="px-3 py-2 border-b border-gray-700">3.696</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">52.86</td>

            <td class="px-3 py-2 border-b border-gray-700">11.90</td>

            <td class="px-3 py-2 border-b border-gray-700">10.73</td>

            <td class="px-3 py-2 border-b border-gray-700">8.848</td>

            <td class="px-3 py-2 border-b border-gray-700">7.177</td>

            <td class="px-3 py-2 border-b border-gray-700">9.686</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">419.8</td>

            <td class="px-3 py-2 border-b border-gray-700">89.70</td>

            <td class="px-3 py-2 border-b border-gray-700">35.71</td>

            <td class="px-3 py-2 border-b border-gray-700">69.21</td>

            <td class="px-3 py-2 border-b border-gray-700">58.60</td>

            <td class="px-3 py-2 border-b border-gray-700">34.83</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">(B)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">350.25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">127.38</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Performance of LegoAC1 comparing to Groth16</p>

    <p class="text-gray-300">We evaluate both proving and verification time when delegating a square matrix multiplication with size  <span class="math">N = n \\times n</span>  field elements, ranging from  <span class="math">n = 16</span>  to  <span class="math">n = 256</span> . We observe our scheme noticeably improves on proving time as our prover runs in linear time in the number of elements in the matrix  <span class="math">(n^2)</span> , whereas Groth's runs in quasicubic time in  <span class="math">n</span> . Even if our verifier is slower for smaller matrices, the  <span class="math">O(n^2)</span>  work in our scheme involves only field operations whereas in Groth16 one needs to do a  <span class="math">O(n^2)</span> -wide multiexponentiation. On the largest instance we measured (square matrices with  <span class="math">n = 128</span>  rows and columns), our proving time is roughly  <span class="math">1300 \\times</span>  faster (109 seconds vs. 84 milliseconds) and verification time is  <span class="math">1.8 \\times</span>  faster (51 vs. 28 milliseconds). This is a tradeoff between the running time and the proof length: only 3 group elements in Groth16 vs  <span class="math">O(\\log n)</span>  in our scheme (127 bytes vs. 32 kilobytes).</p>

    <p class="text-gray-300">Table 4 shows concrete performance measurements of both schemes, showing a clear proving time improvement in our scheme.</p>

    <p class="text-gray-300">We tested our LegoAC1 scheme (see Section 6.2) for arithmetic circuits and compared it to Groth16 as a baseline system. We considered two benchmark applications:</p>

    <p class="text-gray-300">(a) proving knowledge of a SHA256 pre-image on 512-bit inputs; for this we used the existing circuit gadgets implemented in libsnark (for Groth16), and in Bulletproofs [bulk1] (for LegoAC1).</p>

    <p class="text-gray-300">(b) matrix factoring, i.e., proving knowledge of two <span class="math">n\\times n</span> matrices <span class="math">A,B</span> whose product is a public matrix <span class="math">C</span>; for this we designed suitable constraints systems, considering 32-bit integers entries and a varying <span class="math">n=16,32,64,128</span>.</p>

    <p class="text-gray-300">Overall, our experiments show that LegoAC1 performs slightly worse than Groth16. For example, for SHA256 proving time is <span class="math">1.2\\times</span> slower (0.7 vs. 0.9 s); verification is up to <span class="math">2\\times</span> slower (0.9 vs. 1.8 ms) and improves with larger inputs; our key generation is about <span class="math">5-6\\times</span> slower. Proof size is constant: 350B in LegoAC1 and 127B in Groth16. Noteworthy that most of LegoAC1 key generation time (about 70%) is taken by the corresponding algorithm for <span class="math">\\mathsf{CP}_{\\mathsf{lin}}^{\\mathsf{Ped}}</span>; this is mainly due to an unoptimized technique for dealing with sparse matrices like the ones that encode the linear constraints <span class="math">\\bm{W}_{L},\\bm{W}_{R},\\bm{W}_{O}</span>, and we expect this to be improved in the future.</p>

    <p class="text-gray-300">In a way this result is not surprising: Groth16 is an extremely optimized and well explored scheme, whereas for LegoAC1 we believe that more optimizations could be explored (in a similar way as Groth16 optimized Pinocchio). More remarkably, LegoAC1 has a built-in commit-and-prove capability, which means its proofs are done with respect to matrices that committed in a Pedersen commitment (in a canonical vectorized form). This property is not present in Groth16, and can be useful in several applications.</p>

    <p class="text-gray-300">For example, in the matrix factoring case, LegoAC1 works with commitments to the three matrices that could be reused. This is a powerful feature as we could prove a statement like “<span class="math">B=A^{2^{k}}</span> for a committed matrix <span class="math">A</span>” by doing <span class="math">k</span> proofs, one for each squaring step (i.e., to show that <span class="math">B_{i}=B_{i-1}^{2}</span>); this can be done by reusing the same CRS for one matrix factoring relation. In contrast, proving <span class="math">B=A^{2^{k}}</span> directly with Groth16 would require a very large CRS and a memory intensive prover that would not scale for large <span class="math">k</span> and <span class="math">n</span>.</p>

    <p class="text-gray-300">We give the experimental results that compare our LegoAC1 commit-and-prove zkSNARK against the Groth16 scheme, in the SHA256 and matrix factoring applications explained above. For SHA256, Groth16 needs 1.9s for key generation of a CRS of 5.1MB, 0.7s for proving and 0.9ms for verification; LegoAC1 needs 7.9s for key generation of a CRS of 6.2MB, 0.9s for proving and 1.8ms for verification. For matrix factoring, we used <span class="math">n\\times n</span> matrices of 32-bit integers with <span class="math">n\\in\\{16,32,64,128\\}</span>. Detailed timings are in Table 5.</p>

    <p class="text-gray-300">Finally, we remark that LegoAC1 is commit-and-prove, which means its proofs are done with respect to matrices that committed in a Pedersen commitment (in a canonical vectorized form).</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">7.4 Parallel Checks on Joint Inputs</h3>

    <p class="text-gray-300">We compare performances of our LegoPar system with a baseline system, i.e. HyrPoly-RDL (see Appendix F.5). Our choice of an Hyrax-based system for comparison is due to its optimization for parallel computations, and thus enhancing the latter implies refinements in all computations where Hyrax applies today.</p>

    <p class="text-gray-300">Recall that LegoPar consists of our <span class="math">\\mathsf{CP}_{\\mathsf{lin}}^{\\mathsf{Ped}}</span> and HyrPoly-Par. To evaluate HyrPoly-Par and HyrPoly-RDL we executed separately the part concerning PolyCom and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>, and the one that includes the ZKGir^{++} core. To benchmark the latter, we used the original Python code (appropriately modified for the commitment part) from the Hyrax project [gitax] (run using the JIT-compiling interpreter PyPy [pypPy]).</p>

    <p class="text-gray-300">We benchmarked LegoPar and HyrPoly-RDL on a highly parallel computation, that is proving knowledge of an assignment to the leaves of a Merkle tree <em>[x13]</em> (cf. Section LABEL:sec:HyrPoly) to see how it can</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (a) Proving time comparison LegoPar and HyrPoly-RDL.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> for (b) Verification time comparison for LegoPar and HyrPoly-RDL.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (c)  <span class="math">\\mathcal{P}</span>  time (component-wise) for LegoPar (left) and HyrPoly-RDL (right). Figure 9: Performance comparison of systems for parallel relations. Lower on the  <span class="math">y</span>  axis is better (in (c), axis  <span class="math">y</span>  is log-scale). We remind the reader that LegoPar = HyrPoly-Par + CPlin =  <span class="math">(\\mathrm{Gir}_{\\mathrm{noRDL}} + \\mathrm{CP}_{\\mathrm{poly}}^{\\mathrm{Lego}}) + \\mathrm{CP}_{\\mathrm{lin}}</span>  and HyrPoly-RDL = GiryesRDL + CPpoly.</p>

    <p class="text-gray-300">be expressed using  <span class="math">R^{\\text{parjnt}}</span> ). We used SHA256 for the hash and a varying number of leaves (from 2 to  <span class="math">2^{9}</span> ). For this computation we generated two circuits using the Hyrax tool: one fully parallel to be fed to HyrPoly-Par and one with the RDL for HyrPoly-RDL. Recall that in LegoPar the RDL is checked using  <span class="math">\\mathsf{CP}_{\\mathrm{lin}}^{\\mathrm{Ped}}</span> . We finally note that the two largest inputs in our evaluation required extending the available RAM from 30 to 75GB for both schemes.</p>

    <p class="text-gray-300">Results. Figure 9 compares the costs (proving and verification time) in the two schemes for repeated computation. Overall LegoPar is faster than HyrPoly-RDL, both in proving and verification time. On our largest input, proving in LegoPar is  <span class="math">1.25 \\times</span>  faster; verifying is more than  <span class="math">2.5 \\times</span>  faster. Verification is expected to become faster due to the asymptotic difference in the verification time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving time: On larger inputs LegoPar has a faster (up to  <span class="math">1.25 \\times</span> ) proving time (Figs. 9a). In both schemes most of the computation is due to ZKGir++: approximately  <span class="math">50\\%</span>  for LegoPar and  <span class="math">75\\%</span>  for HyrPoly-RDL. The higher time of ZKGir++ in HyrPoly-RDL is explained by the additional round for the RDL. On the other hand, LegoPar spends twice as much time for the proving step of  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> . This is because it evaluates a polynomial with twice as many terms, in turn requiring roughly twice the number of exponentiations. (This is due to the RDL output  <span class="math">u_{2}</span> , on which LegoPar operates, being twice as long as the RDL input  <span class="math">u_{1}</span>  (also the "bottom-layer" input), on which  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  runs in HyrPoly-RDL).</li>

      <li>Verification time: On larger inputs LegoPar has a shorter (up to  <span class="math">2.5 \\times</span> ) verification time (Fig. 9b). This speedup is due to increase with larger inputs, as the verifier in HyrPoly-RDL has to perform an additional verification step for the RDL in ZKGir++ (requiring a number of field operations roughly linear in the width of the circuit). On the other hand LegoPar performs the same step through a constant number of pairings (two) in CPveq. In both schemes ZKGir++ dominates running time (more than  <span class="math">99.5\\%</span> ) <span class="math">^{24}</span> .</li>

    </ul>

    <p class="text-gray-300">Discussion. Partly, the different performances we observed are due to specific features of the circuit chosen for benchmarks (we chose Merkle tree verification, due to its relevance in practice). In a circuit for parallel computation, at least two features, both related to the RDL, can have impact:  <span class="math">(i)</span>  how "large" the output  <span class="math">u_{2}</span>  of the RDL is w.r.t. its input  <span class="math">u_{1}</span> ;  <span class="math">(ii)</span>  how "complex" the RDL is. A higher</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ratio $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> will determine the difference in running time for the </span>\\mathsf{CP}_{\\mathsf{poly}}$.Prove component. In our circuit of choice the ratio was 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-60" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">We have described LegoSNARK, a framework for commit-and-prove zkSNARKs that comprises definitions, a general composition result, and a “lifting” construction. The LegoSNARK tools are useful as they enable designing zkSNARKs in a modular way (due to the framework of definitions and the composition theorem) and they allow to efficiently add commit-and-prove capabilities to a variety of existing schemes thus made interoperable. Furthermore we have proposed efficient proof gadgets for specialized relations and shown how to combine them into succinct proof systems for more complex relations. We have described instantiations of these new proof systems and evaluated them against prior work. The results show they have competitive performances. Specifically they show slightly worse (but still acceptable) performances in some applications (general arithmetic circuits) and significant improvements in others (commit-ahead-of-time systems, parallel computations).</p>

    <p class="text-gray-300">A limitation of our current instantiations is their reliance on pairing-based systems with a trusted setup. Interestingly in some cases this is only needed to generate the commitment key of PolyCom. We believe this is doable by a large-scale MPC ceremony similar to the powers-of-tau round 1 of <em>[x1]</em> since the CRS includes only monomials in the exponent. It is future work to explore this direction. Nonetheless we note that this limitation is not inherent. The basic results of the framework (i.e., Section 3) are general enough to be instantiated in the future with schemes without trust assumptions. Finally, another future work direction is investigating new and more efficient proof gadgets CP-SNARKs for specialized relations and test them in specific applications.</p>

    <h2 id="sec-61" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We would like to thank Chris Peikert and Xiong (Leo) Fan for identifying a problem in an earlier version of Theorem H.1 (see Remark H.1).</p>

    <p class="text-gray-300">Research leading to these results has been supported by the Spanish Government under projects Datamantium (ref. RTC-2016-4930-7), SCUM (ref. RTI2018-102043-B-I00), and ERC2018-092822, by the Madrid Regional Government under project BLOQUES (ref. S2018/TCS-4339) and by Protocol Labs. The project that gave rise to these results received the support of a fellowship from “la Caixa” Foundation (ID 100010434). The fellowship code is LCF/BQ/ES18/11670018.</p>

    <h2 id="sec-62" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGM18] Shashank Agrawal, Chaya Ganesh, and Payman Mohassel. Non-interactive zero-knowledge proofs for composite statements. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 643–673. Springer, Heidelberg, August 2018.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2087–2104. ACM Press, October / November 2017.</li>

      <li>[AJ18] Kurt M. Alonso and Jordi Herrera Joancomartí. Monero - privacy in the blockchain. Cryptology ePrint Archive, Report 2018/535, 2018. https://eprint.iacr.org/2018/535.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">BBB^{+}17. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Efficient range proofs for confidential transactions. Technical report, Cryptology ePrint Archive, Report 2017/1066, 2017. https://eprint. iacr. org/2017/1066, 2017.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BBFR15. Michael Backes, Manuel Barbosa, Dario Fiore, and Raphael M. Reischuk. ADSNARK: Nearly practical and privacy-preserving proofs on authenticated data. In 2015 IEEE Symposium on Security and Privacy, pages 271–286. IEEE Computer Society Press, May 2015.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>BCC^{+}17. Nir Bitansky, Ran Canetti, Alessandro Chiesa, Shafi Goldwasser, Huijia Lin, Aviad Rubinstein, and Eran Tromer. The hunting of the SNARK. Journal of Cryptology, 30(4):989–1066, October 2017.</li>

      <li>BCCT12. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, ITCS 2012, pages 326–349. ACM, January 2012.</li>

      <li>BCG^{+}13. Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, Heidelberg, August 2013.</li>

      <li>BCG^{+}14. Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, May 2014.</li>

      <li>BCG^{+}17. Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part III, volume 10626 of LNCS, pages 336–365. Springer, Heidelberg, December 2017.</li>

      <li>BCI^{+}13. Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, March 2013.</li>

      <li>BCPR14. Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In David B. Shmoys, editor, 46th ACM STOC, pages 505–514. ACM Press, May / June 2014.</li>

      <li>BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</li>

      <li>BCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security 2014, pages 781–796. USENIX Association, August 2014.</li>

      <li>BFR^{+}13. Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In Proc. of the ACM SOSP, 2013.</li>

      <li>BGM17. Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-snark parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. https://eprint.iacr. org/2017/1050.</li>

      <li>BP15. Elette Boyle and Rafael Pass. Limits of extractability assumptions with distributional auxiliary input. In Tetsu Iwata and Jung Hee Cheon, editors, ASIACRYPT 2015, Part II, volume 9453 of LNCS, pages 236–261. Springer, Heidelberg, November / December 2015.</li>

      <li>BSBHR18. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</li>

      <li>bulk1. https://github.com/apoelstra/secp256k1-mw/tree/bulletproofs, libsecp256k1.</li>

      <li>CDG^{+}17. Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 1825–1842. ACM Press, October / November 2017.</li>

      <li>CFH^{+}15. Craig Costello, Cédric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, and Samee Zahur. Geppetto: Versatile verifiable computation. In 2015 IEEE Symposium on Security and Privacy, pages 253–270. IEEE Computer Society Press, May 2015.</li>

    </ul>

    <p class="text-gray-300">CGM16. Melissa Chase, Chaya Ganesh, and Payman Mohassel. Efficient zero-knowledge proof of algebraic and non-algebraic statements with applications to privacy preserving credentials. In Matthew Robshaw and Jonathan Katz, editors, CRYPTO 2016, Part III, volume 9816 of LNCS, pages 499–530. Springer, Heidelberg, August 2016.</p>

    <p class="text-gray-300">CLOS02. Ran Canetti, Yehuda Lindell, Rafail Ostrovsky, and Amit Sahai. Universally composable two-party and multi-party secure computation. In 34th ACM STOC, pages 494–503. ACM Press, May 2002.</p>

    <p class="text-gray-300">CMT12. Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In Shafi Goldwasser, editor, ITCS 2012, pages 90–112. ACM, January 2012.</p>

    <p class="text-gray-300">EHK^{+}13. Alex Escala, Gottfried Herold, Eike Kiltz, Carla Räfols, and Jorge Villar. An algebraic framework for Diffie-Hellman assumptions. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 129–147. Springer, Heidelberg, August 2013.</p>

    <p class="text-gray-300">FFG^{+}16. Dario Fiore, Cédric Fournet, Esha Ghosh, Markulf Kohlweiss, Olga Ohrimenko, and Bryan Parno. Hash first, argue later: Adaptive verifiable computations on outsourced data. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, ACM CCS 2016, pages 1304–1316. ACM Press, October 2016.</p>

    <p class="text-gray-300">FKL18. Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Heidelberg, August 2018.</p>

    <p class="text-gray-300">FLSZ17. Prastudy Fauzi, Helger Lipmaa, Janno Siim, and Michal Zajac. An efficient pairing-based shuffle argument. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 97–127. Springer, Heidelberg, December 2017.</p>

    <p class="text-gray-300">FS87. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</p>

    <p class="text-gray-300">GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</p>

    <p class="text-gray-300">gitax. https://github.com/hyraxZK, Hyrax.</p>

    <p class="text-gray-300">GKM^{+}18. Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Heidelberg, August 2018.</p>

    <p class="text-gray-300">GKR08. Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008.</p>

    <p class="text-gray-300">GKS17. Daniel Günther, Ágnes Kiss, and Thomas Schneider. More efficient universal circuit constructions. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRYPT 2017, Part II, volume 10625 of LNCS, pages 443–470. Springer, Heidelberg, December 2017.</p>

    <p class="text-gray-300">GMO16. Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. ZKBoo: Faster zero-knowledge for Boolean circuits. In Thorsten Holz and Stefan Savage, editors, USENIX Security 2016, pages 1069–1083. USENIX Association, August 2016.</p>

    <p class="text-gray-300">GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989.</p>

    <p class="text-gray-300">GMW87. Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness theorem for protocols with honest majority. In Alfred Aho, editor, 19th ACM STOC, pages 218–229. ACM Press, May 1987.</p>

    <p class="text-gray-300">Gro09. Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 192–208. Springer, Heidelberg, August 2009.</p>

    <p class="text-gray-300">Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.</p>

    <p class="text-gray-300">Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</p>

    <p class="text-gray-300">GW11. Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, June 2011.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[IKO07] Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Efficient arguments without short pcps. In Proceedings of the Twenty-Second Annual IEEE Conference on Computational Complexity, CCC ’07, pages 278–291, Washington, DC, USA, 2007. IEEE Computer Society.</li>

      <li>[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty computation. In David S. Johnson and Uriel Feige, editors, 39th ACM STOC, pages 21–30. ACM Press, June 2007.</li>

      <li>[Kil89] J. Kilian. Uses of randomness in algorithms and protocols. PhD Thesis. Massachusetts Institute of Technology, 1989.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[KPP^{+}14] Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou, Mahmoud F. Sayed, Elaine Shi, and Nikos Triandopoulos. TRUESET: Faster verifiable set computations. In Kevin Fu and Jaeyeon Jung, editors, USENIX Security 2014, pages 765–780. USENIX Association, August 2014.</li>

      <li>[KW15] Eike Kiltz and Hoeteck Wee. Quasi-adaptive NIZK for linear subspaces revisited. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 101–128. Springer, Heidelberg, April 2015.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859–868, October 1992.</li>

      <li>[librk] https://github.com/scipr-lab/libsnark, libsnark.</li>

      <li>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, Heidelberg, March 2012.</li>

      <li>[Lip16] Helger Lipmaa. Prover-efficient commit-and-prove zero-knowledge SNARKs. In David Pointcheval, Abderrahmane Nitaj, and Tajjeeddine Rachidi, editors, AFRICACRYPT 16, volume 9646 of LNCS, pages 185–206. Springer, Heidelberg, April 2016.</li>

      <li>[Mer88] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.</li>

      <li>[Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.</li>

      <li>[NY90] Moni Naor and Moti Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In 22nd ACM STOC, pages 427–437. ACM Press, May 1990.</li>

      <li>[Par15] Bryan Parno. A note on the unsoundness of vnTinyRAM’s SNARK. Cryptology ePrint Archive, Report 2015/437, 2015. http://eprint.iacr.org/2015/437.</li>

      <li>[Ped92] Torben P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In Joan Feigenbaum, editor, CRYPTO’91, volume 576 of LNCS, pages 129–140. Springer, Heidelberg, August 1992.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE Computer Society Press, May 2013.</li>

      <li>[pypPy] https://pypy.org, PyPy.</li>

      <li>[Rot09] Guy Rothblum. Delegating computation reliably: paradigms and constructions, 2009. PhD thesis.</li>

      <li>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In Daniel Wichs and Yishay Mansour, editors, 48th ACM STOC, pages 49–62. ACM Press, June 2016.</li>

      <li>[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, January 1991.</li>

      <li>[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 71–89. Springer, Heidelberg, August 2013.</li>

      <li>[Val76] Leslie G. Valiant. Universal circuits (preliminary report). In STOC, pages 196–203. ACM, 1976.</li>

      <li>[Vee17] Meilof Veeningen. Pinocchio-based adaptive zk-SNARKs and secure/correct adaptive function evaluation. In Marc Joye and Abderrahmane Nitaj, editors, AFRICACRYPT 17, volume 10239 of LNCS, pages 21–39. Springer, Heidelberg, May 2017.</li>

      <li>[WJB^{+}17] Riad S. Wahby, Ye Ji, Andrew J. Blumberg, abhi shelat, Justin Thaler, Michael Walfish, and Thomas Wies. Full accounting for verifiable outsourcing. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2071–2086. ACM Press, October / November 2017.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{WSR}^{+}15</span> . Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In NDSS 2015. The Internet Society, February 2015. <span class="math">\\mathrm{WTas}^{+}17</span> . Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup. Cryptology ePrint Archive, Report 2017/1132, 2017. https://eprint.iacr.org/2017/1132. <span class="math">\\mathrm{WTs}^{+}18</span> . Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zk-SNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926-943. IEEE Computer Society Press, May 2018. ZGK <span class="math">^{+}</span> 17a. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In 2017 IEEE Symposium on Security and Privacy, pages 863-880. IEEE Computer Society Press, May 2017. ZGK <span class="math">^{+}</span> 17b. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. A zero-knowledge version of vsql. Cryptology ePrint Archive, Report 2017/1146, 2017. https://eprint.iacr.org/2017/1146.</p>

    <p class="text-gray-300">In this section we provide a proof of Theorem 3.1. We first define relation generators and auxiliary input generators for this construction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AuxRG(1λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RGb(1λ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z<em>(ck, RnR0,R1), (ek</em>, vk*), (auxR, auxR)):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(R0, auxR(0))← RG0(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">(Rb, auxR(b))b∈{0,1}← AuxRG(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">(auxZ(b))b∈{0,1}← AuxZ(ck, (crsb, Rb, auxR(b))b∈{0,1})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(R1, auxR(1))← RG1(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">auxR(b):= (R1-b, (auxR(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">return (auxZ(b))b∈{0,1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (Rb, auxR(b))b∈{0,1}</td>

            <td class="px-3 py-2 border-b border-gray-700">return (Rb, auxR(b))</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AuxZ(ck, (crsb, Rb, auxR(b))b∈{0,1}):</td>

            <td class="px-3 py-2 border-b border-gray-700">RG*(1λ):</td>

            <td class="px-3 py-2 border-b border-gray-700">Zb(ck, Rb, crsb, auxR(b)):</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">auxZ(0)← Z0(ck, R0, crs0, auxR(0))</td>

            <td class="px-3 py-2 border-b border-gray-700">(Rb, auxR(b))b∈{0,1}← AuxRG(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse auxR as (R1-b, (auxR(b))b∈{0,1})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">auxZ(1)← Z1(ck, R1, crs1, auxR(1))</td>

            <td class="px-3 py-2 border-b border-gray-700">return (RΛ0,R1, (auxR(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">crs1-b← CP1-b. KeyGen(ck, R1-b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (auxZ(b))b∈{0,1}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">{auxZ(b)← AuxZ(ck, (crsb, Rb, auxR(b))b∈{0,1})}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | return auxZ(b):= (crs1-b, (auxZ(b))b∈{0,1})  |</p>

    <p class="text-gray-300">Figure 10: Relation and Auxiliary Input Generators for AND Composition Construction</p>

    <p class="text-gray-300">We state the following lemma.</p>

    <p class="text-gray-300">Lemma A.1. If  <span class="math">\\mathsf{Com}</span>  is computationally binding, and if  <span class="math">\\mathsf{CP}_b</span>  is  <span class="math">\\mathsf{KSND}(\\overline{\\mathcal{RG}}_b,\\overline{\\mathcal{Z}}_b)</span>  (where  <span class="math">\\overline{\\mathcal{RG}}_b,\\overline{\\mathcal{Z}}_b</span>  are defined in terms of  <span class="math">\\mathcal{RG}_b,\\mathcal{Z}_b</span>  in Figure 10) for  <span class="math">b\\in \\{0,1\\}</span> , then the scheme  <span class="math">\\mathsf{CP}^{\\wedge}</span>  in Figure 1 is  <span class="math">\\mathsf{KSND}(\\mathcal{RG}^{<em>},\\mathcal{Z}^{</em>})</span>  where  <span class="math">\\mathcal{RG}^{<em>},\\mathcal{Z}^{</em>}</span>  are as defined in Figure 10.</p>

    <p class="text-gray-300">Proof Let  <span class="math">\\mathcal{A}^<em></span>  be an adversary against the soundness of  <span class="math">\\mathsf{CP}^{\\wedge}</span>  with respect to  <span class="math">\\mathcal{RG}^</em></span>  and  <span class="math">\\mathcal{Z}^<em></span> . Now for  <span class="math">b\\in \\{0,1\\}</span>  consider adversary  <span class="math">\\mathcal{A}_b</span>  (defined in Figure 11) against  <span class="math">\\mathsf{CP}_b</span>  with respect to  <span class="math">\\overline{\\mathcal{RG}}_b</span>  and  <span class="math">\\overline{\\mathcal{Z}}_b</span> . By the fact that  <span class="math">\\mathsf{CP}_b</span>  is  <span class="math">\\mathsf{KSND}(\\overline{\\mathcal{RG}}_b,\\overline{\\mathcal{Z}}_b)</span>  there exists an extractor  <span class="math">\\mathcal{E}_b</span>  such that  <span class="math">\\operatorname</em>{Pr}[\\mathsf{Game}_{\\overline{\\mathcal{RG}}_b,\\overline{\\mathcal{Z}}_b,\\mathcal{A}_b,\\mathcal{E}_b}^{\\mathsf{KSND}} = 1]</span>  is negligible.</p>

    <p class="text-gray-300">We define an extractor  <span class="math">\\mathcal{E}^<em></span>  for  <span class="math">\\mathsf{CP}^{\\wedge}</span>  in Figure 11, and we claim is such that  <span class="math">\\operatorname</em>{Pr}[\\mathsf{Game}_{\\mathcal{R}\\mathcal{G}^<em>,\\mathcal{Z}^</em>,\\mathcal{A}^<em>,\\mathcal{E}^</em>}^{\\mathsf{KSND}} = 1]</span> . First observe that with overwhelming probability the values  <span class="math">u_{2}</span>  and  <span class="math">u_{2}&#x27;</span>  in  <span class="math">\\mathcal{E}^*</span>  are equal, conditioned to the openings being all correct for their respective commitments (i.e., conditioned to VerCommit returning 1 on each of them). In fact, if it were otherwise, we could then break the binding of Com (as done in the proof of Theorem B.1).</p>

    <p class="text-gray-300">We now define the following notations:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\operatorname {G d C o m} \\left(c _ {b}, u _ {b}, o _ {b}\\right) := \\operatorname {C o m . V e r C o m m i t} \\left(\\mathrm {c k}, c _ {b}, u _ {b}, o _ {b}\\right) = 1 \\right\\} _ {b \\in \\{0, 1 \\}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {G d C o m} \\left(c _ {2}, u _ {2}, o _ {2}\\right) := \\operatorname {C o m . V e r C o m m i t} \\left(\\mathrm {c k}, c _ {2}, u _ {2}, o _ {2}\\right) = 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {G d C o m} \\left(c _ {2}, u _ {2} ^ {\\prime}, o _ {2} ^ {\\prime}\\right) := \\operatorname {C o m . V e r C o m m i t} \\left(\\mathrm {c k}, c _ {2}, u _ {2} ^ {\\prime}, o _ {2} ^ {\\prime}\\right) = 1</span></div>

    <p class="text-gray-300">For  <span class="math">b \\in \\{0,1\\}</span> , by the soundness properties of  <span class="math">\\mathsf{CP}_b</span>  and the definition of  <span class="math">\\mathcal{E}_b, \\mathcal{E}^*</span>  we have that  <span class="math">p_b</span> , as defined below, is negligible.</p>

    <div class="my-4 text-center"><span class="math-block">p _ {b} := \\Pr \\left[ b _ {\\mathsf {o k}} ^ {(b)} \\wedge (\\neg \\mathsf {G d C o m} (c _ {b}, u _ {b}, o _ {b}) \\vee \\neg \\mathsf {G d C o m} (c _ {2}, u _ {2}, o _ {2}) \\vee R _ {b} (x _ {b}, u _ {b}, u _ {2}, \\omega_ {b}) = 0) \\right]</span></div>

    <p class="text-gray-300">where all the symbols above are as defined in the construction of  <span class="math">\\mathcal{E}^*</span> . Now we can observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\text {G a m e} _ {\\mathcal {R G} ^ {*}, \\mathcal {Z} ^ {*}, \\mathcal {A} ^ {*}, \\mathcal {E} ^ {*}} ^ {\\text {K S N D}} = 1 \\right] = \\dots \\\\ = \\Pr \\left[ b _ {o k} ^ {(0)} \\wedge b _ {o k} ^ {(1)} \\wedge (\\neg G d C o m (c _ {0}, u _ {0}, o _ {0}) \\vee \\neg G d C o m (c _ {1}, u _ {1}, o _ {1}) \\vee \\neg G d C o m (c _ {2}, u _ {2}, o _ {2}) \\right. \\\\ \\left. \\vee R _ {0} \\left(x _ {0}, u _ {0}, u _ {2}; \\omega_ {0}\\right) = 0 \\vee R _ {1} \\left(x _ {1}, u _ {1}, u _ {2}; \\omega_ {1}\\right) = 0\\right) \\big ] \\\\ \\leq \\Pr \\left[ b _ {o k} ^ {(0)} \\wedge (\\neg G d C o m (c _ {0}, u _ {0}, o _ {0}) \\vee \\neg G d C o m (c _ {2}, u _ {2}, o _ {2}) \\vee R _ {0} (u _ {0}, u _ {2}, \\omega_ {0}) = 0) \\right] + \\\\ \\Pr \\left[ b _ {o k} ^ {(1)} \\wedge (\\neg G d C o m (c _ {1}, u _ {1}, o _ {1}) \\vee \\neg G d C o m (c _ {2}, u _ {2} ^ {\\prime}, o _ {2} ^ {\\prime}) \\vee R _ {1} (u _ {1}, u _ {2} ^ {\\prime}, \\omega_ {1}) = 0) \\right] + \\operatorname {n e g l} (\\lambda) \\leq p _ {0} + p _ {1} + \\operatorname {n e g l} (\\lambda) \\leq \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where in the last two inequalities we used our earlier observations on the openings of  <span class="math">u_{2}</span>  and  <span class="math">u_{2}^{\\prime}</span>  and  <span class="math">p_0</span>  and  <span class="math">p_1</span>  being negligible respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_b(ck, (crsb, Rb), auxR(b), auxZ(b)):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E*(ck, ((crsb)b∈{0,1}, R_Rb,R_1), auxR(b), auxZ(b)):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse auxR(b) as (R1-b, (auxR(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">auxR(b) := (R1-b, (auxR(b))b∈{0,1}) for b ∈ {0,1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parse auxZ(b) as (crs1-b, (auxZ(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">auxZ(b) := (crs1-b, (auxZ(b))b∈{0,1}) for b ∈ {0,1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(x0, x1, (cj)j∈[3], π* := (πb)b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">((x0, u0, u2), (o0, o2), ω0) ← E0(ck, (crs0, R0), auxR(0), auxZ(0))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">← A*(ck, (crs0, crs1, R_R0,R1),</td>

            <td class="px-3 py-2 border-b border-gray-700">((x1, u1, u2'), (o1, o2'), ω1) ← E1(ck, (crs1, R1), auxR(1), auxZ(1))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(auxR(b))b∈{0,1}, (auxZ(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">return ((xb)b∈{0,1}, (uj)j∈[3], (oj)j∈[3], (ωb)b∈{0,1})</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  return (xb, cb, c2, πb) |   |</p>

    <p class="text-gray-300">Figure 11: Adversary and Extractor for Proof of Lemma A.1</p>

    <p class="text-gray-300">We state the following lemma.</p>

    <p class="text-gray-300">Lemma A.2. If  <span class="math">\\mathsf{CP}_b</span>  is zero-knowledge for  <span class="math">\\mathsf{Com}</span>  and  <span class="math">\\overline{\\mathcal{RG}}_b</span>  for  <span class="math">b\\in \\{0,1\\}</span> , then the scheme  <span class="math">\\mathsf{CP}^{\\wedge}</span>  in Figure 1 is a zero-knowledge CP-SNARK for  <span class="math">\\mathsf{Com}</span>  and  <span class="math">\\mathcal{RG}^*</span>  (where relation generators are defined in Figure 10).</p>

    <p class="text-gray-300">Proof We construct the following two simulators for  <span class="math">\\mathcal{R}\\mathcal{G}^*</span>  from simulators for  <span class="math">\\mathsf{CP}_0, \\mathsf{CP}_1</span> . Then ZK follows through a standard hybrid argument.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S<em>kg(ck, R</em>R0,R1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S*prv((crsb)b∈{0,1}, (tdk(b))b∈{0,1}, (xb)b∈{0,1}, (cj)j∈[3])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for b∈{0,1} : (crsb, tdk(b)) ← S(bb)(ck, Rb)</td>

            <td class="px-3 py-2 border-b border-gray-700">for b∈{0,1} : πb ← S(bb)(crsb, tdk(b), xb, (cb, c2))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (crs<em> := (crsb)b∈{0,1}, tdk</em> := (tdk(b))b∈{0,1})</td>

            <td class="px-3 py-2 border-b border-gray-700">return (πb)b∈{0,1}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem B.1. Let  <span class="math">\\mathsf{CP}.\\mathcal{R}\\mathcal{G}</span>  be a relation generator such that  <span class="math">\\mathsf{CP}.\\mathcal{R}\\mathcal{G}_{\\lambda} \\subseteq \\mathcal{R}_{\\lambda}</span> , and let  <span class="math">\\mathsf{CP}.\\mathcal{Z}</span>  be an auxiliary input distribution. Then the scheme  <span class="math">\\mathsf{CP}</span>  in Table 2 is KSND( <span class="math">\\mathsf{CP}.\\mathcal{R}\\mathcal{G}, \\mathsf{CP}.\\mathcal{Z}</span> ) and composable zero-knowledge for  <span class="math">\\mathsf{CP}.\\mathcal{R}\\mathcal{G}</span>  whenever: (i) ccII is ccKSND( <span class="math">\\mathsf{ccII}.\\mathcal{R}\\mathcal{G}, \\mathsf{ccII}.\\mathcal{Z}</span> ) and composable zero-knowledge for ccII.RG, (ii)  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is KSND( <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{R}\\mathcal{G}, \\mathsf{CP}_{\\mathrm{link}}.\\mathcal{Z}</span> ) and composable zero-knowledge for  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{R}\\mathcal{G}</span> , where the relation generators and auxiliary input distributions ccII.RG, ccII.Z,  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{R}\\mathcal{G}, \\mathsf{CP}_{\\mathrm{link}}.\\mathcal{Z}</span>  are the ones in Figure 12. This result also holds when ccII is a cc-SNARK with weak binding (Definition 3.3) or a cc-SNARK with double binding (Definition 3.4).</p>

    <p class="text-gray-300">|  CPlink.RG(1λ):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  (R, auxR) ← CP.RG(1λ)  |</p>

    <p class="text-gray-300">|  (ck', ek', vk') ← ccII.KeyGen(R)  |</p>

    <p class="text-gray-300">|  Rlink := (ck', Dxlink, Du link, Dω link)  |</p>

    <p class="text-gray-300">|  auxLink := (ek', vk', R, auxR)  |</p>

    <p class="text-gray-300">|  return (Rlink, auxLink)  |</p>

    <p class="text-gray-300">|  ccII.RG(1λ):  |</p>

    <p class="text-gray-300">|  (R, auxR) ← CP.RG(1λ)  |</p>

    <p class="text-gray-300">|  ck ← CP.Setup(1λ)  |</p>

    <p class="text-gray-300">|  return (R, aux'R := (ck, auxR))  |</p>

    <p class="text-gray-300">|  CPlink.Z((ck,Rlink),auxLink, crslink):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Parse auxLink as (ek', vk', R, auxR) ; Parse crslink as (eklink, vklink)  |</p>

    <p class="text-gray-300">|  Get ck' from Rlink ; ek := (ck', ek', eklink) ; vk := (vk', vklink)  |</p>

    <p class="text-gray-300">|  return auxLink ← CP.Z((ck,R),auxR, (ek, vk))  |</p>

    <p class="text-gray-300">|  ccII.Z(R, aux'R, crs'):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Parse crs' as (ck', ek', vk') and aux'R as (ck, auxR)  |</p>

    <p class="text-gray-300">|  Rlink := (ck', Dxlink, Du link, Dω link)  |</p>

    <p class="text-gray-300">|  (eklink, vklink) ← CPlink.KeyGen(ck, Rlink)  |</p>

    <p class="text-gray-300">|  ek := (ck', ek', eklink) ; vk := (vk', vklink)  |</p>

    <p class="text-gray-300">|  auxZ ← CP.Z((ck, R), auxR, (ek, vk))  |</p>

    <p class="text-gray-300">|  return aux'Z := (eklink, vklink, auxZ)  |</p>

    <p class="text-gray-300">Figure 12: Relation and Auxiliary Input Generators for Theorem B.1</p>

    <p class="text-gray-300">Proof First, recall that proving the knowledge soundness of a CP-SNARK scheme CP for relation generator CP.RG means proving the knowledge soundness of CP as a SNARK for the corresponding relation generator CP.RGCom that, we recall, honestly generates the commitment key  <span class="math">\\mathsf{ck} \\gets \\mathsf{Setup}(1^{\\lambda})</span>  and generates  <span class="math">(R, \\mathsf{aux}_R)</span>  using CP.RG and outputs  <span class="math">((\\mathsf{ck}, R), \\mathsf{aux}_R)</span> .</p>

    <p class="text-gray-300">Our proof proceeds in the following steps.</p>

    <p class="text-gray-300">First, assume there exists an adversary CP.A against scheme CP that runs in the experiment GameKSND, CP.RGCom, CP.Z and outputs a tuple <span class="math">(x,(c_{j})_{j\\in [\\ell]},\\pi)</span> such that CP.VerProof(vk, <span class="math">x,(c_{j})_{j\\in [\\ell]},\\pi)=1</span>. Then, from such CP.A we can build:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an adversary ccΠ.A against ccΠ that runs in the experiment GameccKSND, ccΠ.RG, ccΠ.Z (with the relation and auxiliary input generators ccΠ.RG, ccΠ.Z defined in Fig. 12), and outputs <span class="math">(x, c&#x27;, \\pi&#x27;)</span>;</li>

      <li>an adversary CPlink.A against CPlink that runs in the experiment GameKSD, CPlink.RGCom, CPlink.Z (with the relation and auxiliary input generators CPlink.RGCom, CPlink.Z defined in Fig. 12), and that outputs <span class="math">(c&#x27;, (c_{j})_{j \\in [\\ell]}, \\pi^{\\text{link}})</span>;</li>

    </ol>

    <p class="text-gray-300">The two adversaries ccΠ.A, CPlink.A are defined below. By looking at the way their inputs are sampled in their respective games GameccKSND, ccΠ.RG, ccΠ.Z and GameKSD, CPlink.RGCom, CPlink.Z, and how the relation and auxiliary input generators are defined, the input received by CP.A in both simulations (the one by ccΠ.A and the one by CPlink.A) is distributed identically as the input CP.A would receive in GameKSND, CP.RGCom, CP.Z.</p>

    <p class="text-gray-300">ccΠ.A(R, crs', auxR', auxZ'):</p>

    <pre><code class="language-txt">Parse auxR&#x27; as (ck, auxR) ; auxZ&#x27; as (eklink, vklink, auxZ) ; crs&#x27; as (ck&#x27;, ek&#x27;, vk&#x27;)</code></pre>

    <pre><code class="language-txt">ek := (ck&#x27;, ek&#x27;, ek&#x27; link) ; vk := (vk&#x27;, vk&#x27; link) ; $(x, (c_j)_{j \\in [\\ell]}, \\pi) := (c&#x27;, \\pi&#x27; link, \\pi&#x27;) \\gets \\mathsf{CP} \\cdot \\mathcal{A}((\\mathsf{ck}, R), (\\mathsf{ek}, \\mathsf{vk}), \\mathsf{aux}_R, \\mathsf{aux}_Z)$</code></pre>

    <pre><code class="language-txt">return $(x, c&#x27;, \\pi&#x27;)$</code></pre>

    <p class="text-gray-300">CPlink.A((ck,Rlink),crslink,auxlink,auxlink):</p>

    <pre><code class="language-txt">Parse auxR link as (ek&#x27;, vk&#x27;, R, auxR) ; crs link as (eklink, vk link) ; auxZ link as auxZ ; R link as (ck&#x27;, Dk link, Dk link, Dk link)</code></pre>

    <pre><code class="language-txt">ek := (ck&#x27;, ek&#x27;, ek&#x27; link) ; vk := (vk&#x27;, vk&#x27; link) ; $(x, (c_j)_{j \\in [\\ell]}, \\pi := (c&#x27;, \\pi&#x27; link, \\pi&#x27;) \\gets \\mathsf{CP} \\cdot \\mathcal{A}((\\mathsf{ck}, R), (\\mathsf{ek}, \\mathsf{vk}), \\mathsf{aux}_R, \\mathsf{aux}_Z)$</code></pre>

    <pre><code class="language-txt">return $(c&#x27;, (c_j)_{j \\in [\\ell]}, \\pi^{\\text{link}})$</code></pre>

    <p class="text-gray-300">Second, observe that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If ccΠ is ccKSND(ccΠ.RG, ccΠ.Z) then for every ccΠ.A there exists an extractor ccΠ.E that returns <span class="math">((u_j&#x27;)_{j \\in [\\ell]}, o&#x27;, w&#x27;)</span> such that</li>

    </ul>

    <p class="text-gray-300">Pr[GameccKSND, ccΠ.RG, ccΠ.Z, ccΠ.A, ccΠ.E = 1] is negligible.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If CPlink is KSND(CPlink.RGCom, CPlink.Z) then for every CPlink.A there exists extractor CPlink.E that returns <span class="math">((u_j^{\\mathrm{link}})_{j\\in [\\ell]},(o_j^{\\mathrm{link}})_{j\\in [\\ell]},\\omega^{\\mathrm{link}})</span> such that the following probability is negligible</li>

    </ul>

    <p class="text-gray-300">Pr[GameKSND, CPlink.RGCom, CPlink.Z, CPlink.A, CPlink.E = 1].</p>

    <p class="text-gray-300">Hence, let ccΠ.E and CPlink.E be the extractors corresponding to our adversaries ccΠ.A and CPlink.A respectively. From the existence of the two extractors ccΠ.E and CPlink.E we construct extractor CP.E as below.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">CP. \\mathcal{E}((\\mathrm{ck},R),(\\mathrm{ek},\\mathrm{vk}),\\mathrm{aux}_R,\\mathrm{aux}_Z):</p>

    <p class="text-gray-300">|  Parse ek as (ck', ek', ek' link) ; vk as (vk', vk' link) ; crs' := (ck', ek' vk')  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  auxR := (ck, auxR) ; auxZ := (ek' link, vk' link, auxZ) ; ((uj)j∈[ell], o', ω') ← ccΠ.ε(R, crs', auxR, auxZ)  |</p>

    <p class="text-gray-300">|  R' link := (ck', D'k, D'k, D'k, D'k) ; auxR' link := (ek', vk', R*, auxR) ; auxZ' link := auxZ  |</p>

    <p class="text-gray-300">|  ((uj' link)j∈[ell], (oj' link)j∈[ell], ω' link) ← CPlink.ε((ck, R' link), crs' link, auxR' link, auxZ' link)  |</p>

    <p class="text-gray-300">|  return ((uj' link)j∈[ell], (oj' link)j∈[ell], ω')  |</p>

    <p class="text-gray-300">Combining the steps above, we have shown that for any CP adversary CP.A there exists a corresponding extractor CP.E. We are left to prove that  <span class="math">\\operatorname{Pr}[\\text{Game}_{\\text{CP},\\mathcal{R}\\mathcal{G}_{\\text{Com}},\\text{CP},\\mathcal{Z},\\text{CP},\\mathcal{A},\\text{CP},\\mathcal{E}} = 1] = \\text{negl}</span> . Recall that the output of CP.A is of the form  <span class="math">(x,(c_j)_{j\\in [\\ell]},\\pi)</span>  with  <span class="math">\\pi = (c&#x27;,\\pi^{\\text{link}},\\pi&#x27;)</span> , and for CP.E is of the form  <span class="math">((u_j^{\\text{link}})_{j\\in [\\ell]},(o_j^{\\text{link}})_{j\\in [\\ell]},w&#x27;)</span> .</p>

    <p class="text-gray-300">For convenience we use the following shorter notations about "good proofs" and "good commitments":</p>

    <p class="text-gray-300"><span class="math">\\mathsf{GdPf}(\\pi^{\\prime})\\coloneqq \\mathsf{cc}\\varPi .\\mathsf{VerProof}(\\mathsf{vk}^{\\prime},x,c^{\\prime},\\pi^{\\prime}) = 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{GdPf}(\\pi^{\\mathrm{link}}):= \\mathsf{CP}_{\\mathrm{link}}.\\mathsf{VerProof}(\\mathsf{vk}^{\\mathrm{link}},c^{\\prime},(c_{j})_{j\\in [\\ell ]},\\pi^{\\mathrm{link}}) = 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{GdCom}(c_j,u_j^{\\mathrm{link}}):= \\mathsf{VerCommit}(\\mathsf{ck},c_j,u_j^{\\mathrm{link}},o_j^{\\mathrm{link}}) = 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{GdCom}&#x27;(c&#x27;, u^{\\mathrm{link}}) := \\mathsf{ccII}.\\mathsf{VerCommit}(\\mathsf{ck}&#x27;, c&#x27;, (u_j^{\\mathrm{link}})_{j \\in [\\ell]}, \\omega^{\\mathrm{link}}) = 1</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{GdCom}&#x27;(c&#x27;, u&#x27;) := \\mathsf{ccII}.\\mathsf{VerCommit}(\\mathsf{ck}&#x27;, c&#x27;, (u_j&#x27;)_{j \\in [\\ell]}, o&#x27;) = 1</span></p>

    <p class="text-gray-300"><span class="math">R^{\\mathrm{link}}(x^{\\mathrm{link}},u^{\\mathrm{link}},\\omega^{\\mathrm{link}}):= \\mathsf{ccII}.\\mathsf{VerCommit}(\\mathsf{ck}&#x27;,x^{\\mathrm{link}},(u_j^{\\mathrm{link}})_{j\\in [\\ell ]},\\omega^{\\mathrm{link}})</span></p>

    <p class="text-gray-300">Let us define the following events:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{bad}:= \\big(\\bigvee_{j\\in [\\ell ]}\\neg \\mathsf{GdCom}(c_j,u_j^{\\mathrm{link}})\\lor \\neg R(x,u^{\\mathrm{link}},\\omega &#x27;)\\big)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{bad}^{\\prime}:= \\big(\\neg \\mathsf{GdCom}^{\\prime}(c^{\\prime},u^{\\prime})\\lor \\neg R(x,u^{\\prime},\\omega^{\\prime})\\big);</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{bad}^{\\circ}:= \\big(\\bigvee_{j\\in [\\ell ]}\\neg \\mathsf{GdCom}(c_j,u_j^{\\mathrm{link}})\\lor \\neg \\mathsf{GdCom}(c&#x27;,x^{\\mathrm{link}})\\lor \\neg R^{\\mathrm{link}}(x^{\\mathrm{link}},u^{\\mathrm{link}},\\omega^{\\mathrm{link}})\\big)</span></p>

    <p class="text-gray-300">By the knowledge soundness of  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  and  <span class="math">\\mathsf{ccII}</span>  we have that  <span class="math">\\operatorname<em>{Pr}[\\mathsf{GdPf}(\\pi^{\\mathrm{link}})\\wedge \\mathsf{bad}^{\\circ}] = \\mathsf{negl}(\\lambda)</span>  and  <span class="math">\\operatorname</em>{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\mathsf{bad}^{\\prime}] = \\mathsf{negl}(\\lambda)</span> , and we abbreviate  <span class="math">\\mathfrak{n}_{\\lambda} := \\mathsf{negl}(\\lambda)</span>  for convenience. Let us now first consider the case when cc-SNARK is binding and observe that:</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}[\\mathsf{Game}_{\\mathsf{CP},\\mathcal{R}\\mathcal{G}_{\\mathsf{Com}},\\mathsf{CP},\\mathcal{Z},\\mathsf{CP},\\mathcal{A},\\mathsf{CP},\\mathcal{E}} = 1]</span></p>

    <p class="text-gray-300"><span class="math">= \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\mathsf{GdPf}(\\pi^{\\mathrm{link}})\\wedge \\mathsf{bad}]</span>  (1)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname <em>{Pr}[\\mathsf{GdPf}(\\pi^{\\mathrm{link}})\\wedge \\mathsf{bad}^{\\circ}] + \\operatorname </em>{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\mathsf{bad}\\wedge R^{\\mathrm{link}}(c^{\\prime},u^{\\mathrm{link}},\\omega^{\\mathrm{link}})\\bigwedge_{j\\in [\\ell ]}\\mathsf{GdCom}(c_j,u_j^{\\circ})]</span>  (2)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\neg R(x,u^{\\mathrm{link}},\\omega^{\\prime})\\wedge R^{\\mathrm{link}}(c^{\\prime},u^{\\mathrm{link}},\\omega^{\\mathrm{link}})] + \\mathfrak{n}_{\\lambda}</span>  (3)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\neg R(x,u^{\\mathrm{link}},\\omega^{\\prime})\\wedge R^{\\mathrm{link}}(c^{\\prime},u^{\\mathrm{link}},\\omega^{\\mathrm{link}})\\wedge (\\neg R^{\\mathrm{link}}(c^{\\prime},u^{\\prime},o^{\\prime})\\lor u^{\\prime} = u^{\\mathrm{link}})] +</span>  (4)</p>

    <p class="text-gray-300"><span class="math">\\operatorname *{Pr}[R^{\\mathrm{link}}(c&#x27;,u^{\\mathrm{link}},\\omega^{\\mathrm{link}})\\wedge R^{\\mathrm{link}}(c&#x27;,u&#x27;,o&#x27;)\\wedge u&#x27;\\neq u^{\\mathrm{link}}] + \\mathfrak{n}_{\\lambda}</span></p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\neg R(x,u^{\\mathrm{link}},\\omega^{\\prime})\\wedge R^{\\mathrm{link}}(c^{\\prime},u^{\\mathrm{link}},\\omega^{\\mathrm{link}})\\wedge (\\neg R^{\\mathrm{link}}(c^{\\prime},u^{\\prime},o^{\\prime})\\lor u^{\\prime} = u^{\\mathrm{link}})] + \\mathfrak{n}_{\\lambda}</span>  (5)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\big((\\neg R(x,u^{\\prime},\\omega^{\\prime})\\wedge R^{\\mathrm{link}}(c^{\\prime},u^{\\prime},\\omega^{\\mathrm{link}}))\\lor</span></p>

    <p class="text-gray-300"><span class="math">(\\neg R^{\\mathrm{link}}(c&#x27;,u&#x27;,o&#x27;)\\wedge \\neg R(x,u^{\\mathrm{link}},\\omega &#x27;)\\wedge R^{\\mathrm{link}}(c&#x27;,u^{\\mathrm{link}},\\omega^{\\mathrm{link}}))\\big)\\big] + \\mathfrak{n}_{\\lambda}</span>  (6)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname *{Pr}[\\mathsf{GdPf}(\\pi^{\\prime})\\wedge \\big(\\neg R(x,u^{\\prime},\\omega^{\\prime})\\lor \\neg R^{\\mathrm{link}}(c^{\\prime},u^{\\prime},o^{\\prime})\\big)\\big] + \\mathfrak{n}_{\\lambda}</span>  (7)</p>

    <p class="text-gray-300"><span class="math">\\leq \\operatorname {negl}(\\lambda)</span>  (8)</p>

    <p class="text-gray-300">Above, (1) follows by spelling out the winning condition of the experiment considering our construction of CP.VerCommit; (2) follows first partitioning over <span class="math">\\mathsf{bad}^{\\circ}</span> and then by observing that <span class="math">\\neg \\mathsf{bad}^{\\circ} := R^{\\mathsf{link}}(c&#x27;, u^{\\mathsf{link}}, \\omega^{\\mathsf{link}}) \\bigwedge_{j \\in [\\ell]} \\mathsf{GdCom}(c_j, u_j^{\\mathsf{link}})</span>; (3) follows by knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span>; (4) follows after partitioning on the event <span class="math">R^{\\mathsf{link}}(c&#x27;, u&#x27;, o&#x27;) \\wedge u&#x27; \\neq u^{\\mathsf{link}}</span>; (5) is by the binding property of the commitment of <span class="math">\\mathsf{ccII}</span>; (7) holds by using that <span class="math">\\operatorname<em>{Pr}[(E_1 \\wedge E_1&#x27;) \\vee (E_2 \\wedge E_2&#x27;))] \\leq \\operatorname</em>{Pr}(E_1 \\vee E_2)</span>; finally, (8) follows by knowledge soundness of <span class="math">\\mathsf{ccII}</span>.</p>

    <p class="text-gray-300"><strong>The case of weak binding.</strong> Let us now consider the case in which <span class="math">\\mathsf{ccII}</span> has only weak binding. In this case the commitment returned by <span class="math">\\mathsf{ccII}.\\mathsf{Prove}</span> refers to the whole witness <span class="math">w = u</span>, which in the previous proof means that the value <span class="math">\\omega&#x27;</span> returned by <span class="math">\\mathsf{ccII}.\\mathcal{E}</span> is empty.</p>

    <p class="text-gray-300">To show that with this change the adversary and extractor still have negligible probability of making the knowledge soundness experiment output 1, we closely follow the analysis we already carried out by equations 1 through 8 above. We slightly deviate after (3) and obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\Pr \\left[ \\mathsf{Game}_{\\mathsf{CP.RG}_{\\mathsf{Com},\\mathsf{CP.Z}},\\mathsf{CP.A},\\mathsf{CP.E}}^{\\mathsf{KSND}} = 1 \\right] \\\\ &amp;amp; \\vdots \\\\ &amp;amp; \\leq \\Pr \\left[ \\mathsf{GdPf}(\\pi&#x27;) \\wedge \\neg R(x, u^{\\mathsf{link}}) \\wedge R^{\\mathsf{link}}(c&#x27;, u^{\\mathsf{link}}, \\omega^{\\mathsf{link}}) \\right] + \\mathsf{negl}(\\lambda) \\tag{3} \\\\ &amp;amp; \\leq \\Pr \\left[ \\mathsf{GdPf}(\\pi&#x27;) \\wedge \\neg R(x, u^{\\mathsf{link}}) \\wedge R^{\\mathsf{link}}(c&#x27;, u^{\\mathsf{link}}, \\omega^{\\mathsf{link}}) \\wedge (\\neg R^{\\mathsf{link}}(c&#x27;, u&#x27;, o&#x27;) \\vee u&#x27; = u^{\\mathsf{link}}) \\right] + \\\\ &amp;amp; \\quad \\Pr \\left[ \\mathsf{GdPf}(\\pi&#x27;) \\wedge \\neg R(x, u^{\\mathsf{link}}) \\wedge R^{\\mathsf{link}}(c&#x27;, u^{\\mathsf{link}}, \\omega^{\\mathsf{link}}) \\wedge R^{\\mathsf{link}}(c&#x27;, u&#x27;, o&#x27;) \\wedge u&#x27; \\neq u^{\\mathsf{link}} \\right] + \\mathsf{n}_{\\lambda} \\end{aligned}</span></div>

    <p class="text-gray-300">For the case <span class="math">u&#x27; = u^{\\mathrm{link}}</span> we proceed exactly as before. For the case <span class="math">u&#x27; \\neq u^{\\mathrm{link}}</span>, defining <span class="math">\\mathsf{comsOpen} := R^{\\mathrm{link}}(c&#x27;, u^{\\mathrm{link}}, \\omega^{\\mathrm{link}}) \\wedge R^{\\mathrm{link}}(c&#x27;, u&#x27;, o&#x27;)</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\Pr \\left[ \\mathsf{GdPf}(\\pi&#x27;) \\wedge \\neg R(x, u^{\\mathsf{link}}) \\wedge \\mathsf{comsOpen} \\wedge u&#x27; \\neq u^{\\mathsf{link}} \\right] \\\\ &amp;amp; \\leq \\Pr \\left[ \\mathsf{GdPf}(\\pi&#x27;) \\wedge \\neg R(x, u^{\\mathsf{link}}) \\wedge \\mathsf{comsOpen} \\wedge u&#x27; \\neq u^{\\mathsf{link}} \\wedge R(u&#x27;, w&#x27;) \\right] + \\mathsf{n}_{\\lambda} \\\\ &amp;amp; \\leq \\mathsf{negl}(\\lambda) \\end{aligned}</span></div>

    <p class="text-gray-300">where the two inequalities follow respectively from knowledge soundness and weak binding of <span class="math">\\mathsf{ccII}</span>.</p>

    <p class="text-gray-300"><strong>The case of cc-SNARKs with double binding.</strong> Let us now consider the case in which <span class="math">\\mathsf{ccII}</span> is a cc-SNARK with double binding. In this case the main difference is that the extractor <span class="math">\\mathsf{ccII}.\\mathcal{E}</span> returns a tuple <span class="math">(u&#x27;, o&#x27;, \\omega&#x27;)</span> where <span class="math">(u&#x27;, o&#x27;)</span> are supposed to be an opening of <span class="math">c&#x27;</span> under the algorithm <span class="math">\\mathsf{VerCommit}^*</span> (instead of <span class="math">\\mathsf{VerCommit}</span>).</p>

    <p class="text-gray-300">To show that with this change the same adversary <span class="math">\\mathsf{CP.A}</span> and extractor <span class="math">\\mathsf{CP.E}</span> still have negligible probability of making the knowledge soundness experiment output 1, we proceed as follows. First, we redefine the event <span class="math">\\mathsf{GdCom}&#x27;(c&#x27;, u&#x27;)</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{GdCom}&#x27;(c&#x27;, u&#x27;) := \\mathsf{ccII}.\\mathsf{VerCommit}^*(\\mathsf{ck}&#x27;, c&#x27;, u&#x27;, o&#x27;) = 1</span></div>

    <p class="text-gray-300">Next, we follow the same analysis of equations (1)-(8) above, with the only difference that equation (5) is obtained by applying the property (ii) of Definition 3.4, instead of the cc-SNARK binding. This holds as one could run <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{E}</span> to find a tuple <span class="math">(c&#x27;, (u^{\\mathrm{link}}, o^{\\mathrm{link}}), (u&#x27;, o&#x27;))</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">u^{\\mathrm{link}} \\neq u&#x27; \\wedge \\mathsf{VerCommit}(\\mathsf{ck}, c&#x27;, u^{\\mathrm{link}}, o^{\\mathrm{link}}) = 1 \\wedge \\mathsf{VerCommit}^*(\\mathsf{ck}, c&#x27;, u&#x27;, o&#x27;) = 1.</span></div>

    <p class="text-gray-300">54</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Skg(ck,R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sprv(crs,tdk,x,(cj)j∈[ell])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(crs',tdk')←Skg(R) ; Parse crs' as (ck',ek',vk')</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse crs as (crslink, crs'); crs' as (ck',ek',vk'); tdk as (tdk' link, tdk')</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(crslink, tdk' link)←Skg((ck',Dwlink, Dwlink))</td>

            <td class="px-3 py-2 border-b border-gray-700">(c',π')←Sprv(crs',tdk',x) ; πlink←Sprv(crs' link, tdk' link, c', (cj)j∈[ell])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (crs := (crs' link, crs'), tdk := (tdk' link, tdk'))</td>

            <td class="px-3 py-2 border-b border-gray-700">return π := (c', π' link, π')</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 13: Zero-knowledge simulators for our generic CP.</p>

    <p class="text-gray-300">Proof Let  <span class="math">\\mathcal{A}</span>  be an adversary. Since the scheme  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is zero-knowledge there exists a simulator  <span class="math">S^{\\circ} = (S_{\\mathrm{kg}}^{\\circ}, S_{\\mathrm{prv}}^{\\circ})</span>  such that keys and proof indistinguishability hold for  <span class="math">\\mathcal{A}</span>  as in Definition 2.2. Similarly, since the scheme  <span class="math">\\mathsf{ccII}</span>  is zero-knowledge <span class="math">^{26}</span>  there exists a simulator  <span class="math">S&#x27; = (S_{\\mathrm{kg}}&#x27;, S_{\\mathrm{prv}}&#x27;)</span>  such that keys and proof indistinguishability hold for  <span class="math">\\mathcal{A}</span>  as in Definition 3.3. In Figure 13 we show simulators  <span class="math">S = (S_{\\mathrm{kg}}, S_{\\mathrm{prv}})</span>  for the CP scheme of Figure 2, and below we argue that keys and proof indistinguishability hold for such simulators.</p>

    <p class="text-gray-300">PROOF INDISTINGUISHABILITY. fixed arbitrary  <span class="math">\\mathcal{A}</span> ,  <span class="math">x</span> ,  <span class="math">(c_{j})_{j\\in [\\ell ]}</span> ,  <span class="math">(o_{j})_{j\\in [\\ell ]}</span> ,  <span class="math">(u_{j})_{j\\in [\\ell ]}</span> ,  <span class="math">\\omega</span> , we define three hybrids (Figure 15):  <span class="math">\\mathcal{H}_0, \\mathcal{H}_1</span>  and  <span class="math">\\mathcal{H}_{\\mathrm{sim}}</span> , and claim that  <span class="math">\\mathcal{H}_0 \\approx \\mathcal{H}_1 \\approx \\mathcal{H}_{\\mathrm{sim}}</span> , which, by definition of the hybrids, implies proof indistinguishability. We skip the proof of the claim as it follows from a standard hybrid argument.</p>

    <p class="text-gray-300">Keys indistinguishability: we proceed by a standard hybrid argument. Consider the hybrid simulator  <span class="math">\\mathcal{HS}_{\\mathrm{kg}}</span>  in Figure 14. By construction of  <span class="math">\\mathcal{HS}_{\\mathrm{kg}}</span>  and the keys indistinguishability for  <span class="math">S_{\\mathrm{kg}}^{\\prime}, S_{\\mathrm{kg}}^{\\circ}</span>  we have that:</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[(ck,R,\\mathsf{aux}_R)\\leftarrow \\mathcal{RG}_{\\mathsf{Com}}(1^{\\lambda}),\\mathsf{crs}\\leftarrow \\mathsf{CP}.\\mathsf{KeyGen}(ck,R) = 1:\\mathcal{A}(ck,\\mathsf{crs},\\mathsf{aux}_R) = 1\\right]</span> <span class="math">\\approx \\operatorname</em>{Pr}\\left[(ck,R,\\mathsf{aux}_R)\\leftarrow \\mathcal{RG}_{\\mathsf{Com}}(1^{\\lambda}),(crs,td_k)\\leftarrow \\mathcal{HS}_{\\mathsf{kg}}(ck,R):\\mathcal{A}(ck,crs,\\mathsf{aux}_R) = 1\\right]</span> <span class="math">\\approx \\operatorname*{Pr}\\left[(ck,R,\\mathsf{aux}_R)\\leftarrow \\mathcal{RG}_{\\mathsf{Com}}(1^{\\lambda}),(crs,td_k)\\leftarrow S_{\\mathsf{kg}}(ck,R):\\mathcal{A}(ck,crs,\\mathsf{aux}_R) = 1\\right]</span></p>

    <p class="text-gray-300">This section contains the security proof and an extension of the  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  scheme.</p>

    <p class="text-gray-300">The following theorem shows that  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is knowledge-sound and zero-knowledge assuming so is  <span class="math">\\mathfrak{ss}\\Pi</span> .</p>

    <p class="text-gray-300">Theorem C.1. Let  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{RG}</span>  be a relation generator and  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{Z}</span>  be an auxiliary input distribution. If  <span class="math">\\mathsf{ss}\\Pi</span>  is KSND(ssN.RG,ssN.Z) where ssN.RG is a relation generator as in Figure 16 and ssN.Z = CPlink.Z, then the CP-SNARK construction  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  given above is KSND(CPlink.RG,CPlink.Z). Furthermore, if ssN is composable ZK for ssN.RG, then  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  is composable ZK for CPlink.RG.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{HS}_{\\mathrm{kg}}(\\mathrm{ck},R)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{HS}_{\\mathrm{prv}}(\\mathrm{crs},\\mathrm{td}_{\\mathrm{k}},\\mathbf{x},\\mathbf{w})</span></p>

    <p class="text-gray-300"><span class="math">\\mathrm{crs}^{\\prime}\\gets \\mathrm{cc}\\Pi .\\mathrm{KeyGen}(R)</span></p>

    <p class="text-gray-300">Parse  <span class="math">\\mathbf{crs}^{\\prime}</span>  as  <span class="math">(\\mathrm{ck}^{\\prime},\\mathrm{ek}^{\\prime},\\mathrm{vk}^{\\prime})</span></p>

    <p class="text-gray-300"><span class="math">(\\mathsf{crs}^{\\mathrm{link}},\\mathsf{td}_{\\mathsf{k}}^{\\mathrm{link}})\\gets \\mathcal{S}_{\\mathrm{kg}}^{\\circ}(\\mathsf{ck}^{\\prime},\\mathcal{D}_{x}^{\\mathrm{link}},\\mathcal{D}_{a}^{\\mathrm{link}},\\mathcal{D}_{\\omega}^{\\mathrm{link}})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{crs}:= (\\mathsf{crs}^{\\mathrm{link}},\\mathsf{crs}^{\\prime})</span>  ;  <span class="math">\\mathsf{td}_{\\mathsf{k}}\\coloneqq \\mathsf{td}_{\\mathsf{k}}^{\\mathrm{link}}</span></p>

    <p class="text-gray-300">return (crs, tdk)</p>

    <p class="text-gray-300"><span class="math">\\mathcal{HS}_{\\mathrm{prv}}(\\mathrm{crs},\\mathrm{td}_{\\mathrm{k}},\\mathbf{x},\\mathbf{w})</span></p>

    <p class="text-gray-300">Parse  <span class="math">\\mathbf{x}</span>  as  <span class="math">(x,(c_j)_{j\\in [\\ell ]})</span>  ; crs as (crslink, crs') ; crs' as (ck', ek', vk')</p>

    <p class="text-gray-300">Parse  <span class="math">\\mathbf{w}</span>  as  <span class="math">((u_j)_{j\\in [\\ell ]},(o_j)_{j\\in [\\ell ]},\\omega)</span>  ; tdks as (tdk link, td)</p>

    <p class="text-gray-300"><span class="math">(c&#x27;, \\pi&#x27;, o&#x27;) \\gets \\mathsf{ccII}.\\mathsf{Prove}(\\mathsf{ek}&#x27;, x, (u_j)_{j \\in [\\ell]}, \\omega)</span></p>

    <p class="text-gray-300"><span class="math">\\pi^{\\mathrm{link}}\\gets S_{\\mathrm{prv}}^{\\circ}(\\mathsf{crs}^{\\mathrm{link}},\\mathsf{td}_{\\mathsf{k}}^{\\mathrm{link}},c^{\\prime},(c_{j})_{j\\in [\\ell ]})</span></p>

    <p class="text-gray-300">return  <span class="math">\\left(c^{\\prime},\\pi^{\\mathrm{link}},\\pi^{\\prime}\\right)</span></p>

    <p class="text-gray-300">Figure 14: Hybrids for proof of ZK of Theorem B.1 (differences with original simulators in blue).</p>

    <p class="text-gray-300">Below we use the same notation as in Definition 3.1: define  <span class="math">\\mathbf{x} := (x, (c_j)_{j \\in [\\ell]})</span> ,  <span class="math">\\mathbf{w} := ((u_j)_{j \\in [\\ell]}, (o_j)_{j \\in [\\ell]}, \\omega)</span> ; the relation  <span class="math">\\mathbf{R}</span>  over pairs  <span class="math">(\\mathbf{x}, \\mathbf{w})</span>  both tests commitment openings and the underlying relation  <span class="math">R</span> .  <span class="math">\\mathcal{H}_0</span>  is defined as the probability that an adversary outputs 1 when a proof is computed through CP.Prove. This is the same as in Definition 2.2 for the case in which  <span class="math">\\mathcal{A}</span>  takes in input an actual proof:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {0} := \\Pr \\left[ (\\mathbf {R}, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} _ {\\mathrm {C o m}} (1 ^ {\\lambda}) ; (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathrm {k}}) \\leftarrow \\mathcal {S} _ {\\mathrm {k g}} (\\mathbf {R}) ; \\pi \\leftarrow \\mathsf {C P}. \\mathsf {P r o v e} (\\mathsf {c r s}, \\mathbf {x}, \\mathbf {w}) : \\right.</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{R}(\\mathbf{x},\\mathbf{w}) = 1\\land \\mathcal{A}(\\mathrm{crs},\\mathrm{aux}_R,\\pi) = 1</span></p>

    <p class="text-gray-300">In  <span class="math">\\mathcal{H}_1</span>  we replace the sub-proof  <span class="math">\\pi^{\\mathrm{link}}</span>  for  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  with its respective simulated version (see Figure 14 for a definition of  <span class="math">\\mathcal{HS}_{\\mathrm{prv}}</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {1} := \\Pr \\left[ (\\mathbf {R}, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} _ {\\mathrm {C o m}} (1 ^ {\\lambda}) ; (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathrm {k}}) \\leftarrow \\mathcal {S} _ {\\mathrm {k g}} (\\mathbf {R}) ; \\pi \\leftarrow \\mathcal {H S} _ {\\mathrm {p r v}} (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathrm {k}}, \\mathbf {x}, \\mathbf {w}) : \\right.</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{R}(\\mathbf{x},\\mathbf{w}) = 1\\land \\mathcal{A}(\\mathrm{crs},\\mathrm{aux}_R,\\pi) = 1</span></p>

    <p class="text-gray-300">We define  <span class="math">\\mathcal{H}_{\\mathrm{sim}}</span>  as the simulated proof output as in the standard zero-knowledge experiment (Definition 2.2). We point out that the only change from  <span class="math">\\mathcal{H}_{\\ell}</span>  consists in replacing the actual proof for  <span class="math">\\mathsf{ccII}</span>  with its simulated version:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {\\mathrm {s i m}} := \\Pr \\left[ (\\mathbf {R}, \\mathsf {a u x} _ {R}) \\leftarrow \\mathcal {R G} _ {\\mathrm {C o m}} (1 ^ {\\lambda}) ; (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathrm {k}}) \\leftarrow \\mathcal {S} _ {\\mathrm {k g}} (\\mathbf {R}) ; \\pi \\leftarrow \\mathcal {S} _ {\\mathrm {p r v}} (\\mathsf {c r s}, \\mathsf {t d} _ {\\mathrm {k}}, \\mathbf {x}) \\right.</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{R}(\\mathbf{x},\\mathbf{w}) = 1\\land \\mathcal{A}(\\mathrm{crs},\\mathrm{aux}_R,\\pi) = 1</span></p>

    <p class="text-gray-300">Figure 15: Hybrids for proof indistinguishability of CP.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{ss}\\Pi .\\mathcal{RG}(1^{\\lambda})\\to ([\\mathbf{M}]_{1},\\mathsf{aux}_{R}^{\\mathrm{link}})</span></p>

    <p class="text-gray-300"><span class="math">[\\pmb {h}]_{1}\\gets \\mathsf{Ped.Setup}(1^{\\lambda})</span>  using distribution  <span class="math">\\mathcal{D}</span></p>

    <p class="text-gray-300"><span class="math">(R^{\\mathrm{link}},\\mathsf{aux}_R^{\\mathrm{link}})\\gets \\mathsf{CP}_{\\mathrm{link}}.\\mathcal{RG}(1^{\\lambda})</span></p>

    <p class="text-gray-300">Define  <span class="math">[\\mathbf{M}]_1</span>  from  <span class="math">[\\pmb {h}]_1,R^{\\mathrm{link}}</span></p>

    <p class="text-gray-300">Figure 16: Relation generator on which we base ssN security.</p>

    <p class="text-gray-300">Knowledge Soundness. Consider an arbitrary adversary  <span class="math">\\mathcal{A}</span>  against  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> . From  <span class="math">\\mathcal{A}</span>  we can construct an adversary  <span class="math">\\mathcal{A}&#x27;</span>  against  <span class="math">\\mathsf{ss}\\Pi</span>  as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}&#x27;([\\mathbf{M}]_1, \\mathrm{crs}, \\mathrm{aux}_R, \\mathrm{aux}_Z)</span> :</p>

    <p class="text-gray-300">Extract  <span class="math">[\\pmb {f}]_1,[\\pmb {h}]_1</span>  from  <span class="math">[\\mathbf{M}]_{1}</span>  ；  <span class="math">([\\pmb {x}]_{1},\\pi)\\gets \\mathcal{A}\\big(([\\pmb {h}]_{1},R^{\\mathrm{link}}),\\mathrm{crs},\\mathrm{aux}_{R},\\mathrm{aux}_{Z}\\big)</span>  ; Parse  <span class="math">[\\pmb {x}]_{1}</span>  as  <span class="math">((c_j)_{j\\in [\\ell ]},c^{\\prime})</span></p>

    <p class="text-gray-300">return  <span class="math">(c^{\\prime},(c_{j})_{j\\in [\\ell ]},\\pi)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(([\\pmb {h}]_1,R^{\\mathrm{link}}),\\mathrm{crs},\\mathrm{aux}_R,\\mathrm{aux}_Z)</span></p>

    <p class="text-gray-300">Compute matrix  <span class="math">[\\mathbf{M}]_1</span> ;  <span class="math">\\pmb{w} \\gets \\mathsf{ss}\\Pi.\\mathcal{E}([\\mathbf{M}]_1, \\mathsf{crs}, \\mathsf{aux}_R, \\mathsf{aux}_Z)</span> ; Parse  <span class="math">\\pmb{w}</span>  as  <span class="math">((o_j)_{j \\in [\\ell]}, o&#x27;, (\\pmb{u}_j)_{j \\in [\\ell]})</span></p>

    <p class="text-gray-300">return  <span class="math">((\\pmb{u}_j)_{j\\in [\\ell ]},(o_j)_{j\\in [\\ell ]},o^{\\prime})</span></p>

    <p class="text-gray-300">By knowledge soundness of  <span class="math">\\mathfrak{ss}\\Pi</span> , for every such  <span class="math">\\mathcal{A}&#x27;</span>  there is an extractor  <span class="math">\\mathfrak{ss}\\Pi.\\mathcal{E}</span> , that we can use to build the above extractor  <span class="math">\\mathcal{E}</span>  for  <span class="math">\\mathcal{A}</span> . In particular, the knowledge soundness of  <span class="math">\\mathfrak{ss}\\Pi</span>  and the definition of  <span class="math">\\mathbf{M}</span>  give us that  <span class="math">\\mathcal{E}</span> 's output is such that the following probability is negligible:</p>

    <p class="text-gray-300"><span class="math">\\operatorname*{Pr}\\left(\\mathsf{ss}\\Pi .\\mathsf{VerProof}(\\mathsf{vk},(c_j)_{j\\in [\\ell ]},c&#x27;) = 1\\wedge \\big(\\bigvee_{j\\in [\\ell ]}\\big(c_j\\neq (o_j,\\boldsymbol {u}_j^\\top)\\cdot [\\boldsymbol {h}_{[0,n_j]}]_1\\big)\\lor c&#x27;\\neq (o&#x27;,\\boldsymbol {u}_1^\\top ,\\ldots ,\\boldsymbol {u}_\\ell^\\top)\\cdot [\\boldsymbol {f}]_1\\right)</span></p>

    <p class="text-gray-300">Hence we can conclude that  <span class="math">\\operatorname<em>{Pr}[\\mathsf{Game}_{\\mathsf{CP}_{\\mathsf{link}}}^{\\mathsf{KSND}},\\mathcal{R}\\mathcal{G},\\mathsf{CP}_{\\mathsf{link}},\\mathcal{Z},\\mathcal{A},\\mathcal{E} = 1] = \\operatorname</em>{Pr}[\\mathsf{GdPf}\\wedge (\\mathsf{BadComm}\\vee \\mathsf{BadRel})]\\leq</span>  negl(λ) using: GdPf := CPlink.VerProof(vk, c', (cj)j∈[ell], π) = 1, BadComm := ∨j∈[ell] cj ≠ (oj, uj) · [h[0,nj]]1, BadRel := c' ≠ (o', u1T, ..., uL) · [f]1.</p>

    <p class="text-gray-300">Zero-Knowledge. From the zero-knowledge property of  <span class="math">\\mathfrak{ss}\\Pi</span>  we know there exists a simulator  <span class="math">\\mathfrak{ss}\\Pi .S = (\\mathfrak{ss}\\Pi .S_{\\mathrm{kg}},\\mathfrak{ss}\\Pi .S_{\\mathrm{prv}})</span>  such that keys and proof indistinguishability hold for an arbitrary  <span class="math">\\mathcal{A}</span>  as in Definition 2.2. We now define the following key simulator  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{S}_{\\mathrm{kg}}</span>  such that  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{S}_{\\mathrm{kg}}([h]_1,R^{\\mathrm{link}}):= \\mathfrak{ss}\\Pi .\\mathcal{S}_{\\mathrm{kg}}([\\mathbf{M}]_1)</span> . Keys indistinguishability follows directly from the assumption on  <span class="math">\\mathfrak{ss}\\Pi .\\mathcal{S}_{\\mathrm{kg}}</span> . Analogously, we obtain proof indistinguishability by defining a proof simulator  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{S}_{\\mathrm{prv}}</span>  such that  <span class="math">\\mathsf{CP}_{\\mathrm{link}}.\\mathcal{S}_{\\mathrm{prv}}(\\mathsf{crs},\\mathsf{td}_k,c&#x27;,(c_j)_{j\\in [\\ell]}):= \\mathfrak{ss}\\Pi .\\mathcal{S}_{\\mathrm{prv}}(\\mathsf{crs},\\mathsf{td}_k,[\\boldsymbol {x}]_1)</span> , with  <span class="math">[\\boldsymbol {x}]_1 = ((c_j)_{j\\in [\\ell]},c&#x27;)</span> .</p>

    <p class="text-gray-300">Fixed a security parameter  <span class="math">\\lambda</span>  (and the bilinear group setting for  <span class="math">\\lambda</span>  as well),  <span class="math">R_{\\mathrm{pre}}^{\\mathrm{link}}</span>  is a relation over  <span class="math">(\\mathcal{D}_x\\times \\mathcal{D}_1\\times \\dots \\times \\mathcal{D}_\\ell \\times \\mathcal{D}_\\omega)</span> , where  <span class="math">\\mathcal{D}_x = \\mathbb{G}_1</span> ,  <span class="math">\\mathcal{D}_{\\omega} = \\mathbb{Z}_{q}^{n_{\\omega} + 1}</span>  and  <span class="math">\\mathcal{D}_j = \\mathbb{Z}_q^{n_j}</span>  for some  <span class="math">n_j</span>  such that  <span class="math">n_{\\omega} + \\sum_{j}n_{j} = m</span> .  <span class="math">R_{\\mathrm{pre}}^{\\mathrm{link}}</span>  is parametrized by a commitment key  <span class="math">[\\pmb {f}]_1\\in \\mathbb{G}_1^{m + 1}</span> , and is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">R _ {\\text {p r e}} ^ {\\text {l i n k}} \\left(c ^ {\\prime}, \\left(\\boldsymbol {u} _ {j}\\right) _ {j \\in [ \\ell ]}, \\left(\\boldsymbol {u} _ {\\ell + 1}, o ^ {\\prime}\\right)\\right) = 1 \\Longleftrightarrow c ^ {\\prime} \\stackrel {?} {=} \\left(o ^ {\\prime}, \\boldsymbol {u} _ {1} ^ {\\top}, \\dots , \\boldsymbol {u} _ {\\ell + 1} ^ {\\top}\\right) \\cdot [ \\boldsymbol {f} ] _ {1}</span></div>

    <p class="text-gray-300">Similarly to the case of  <span class="math">R^{\\mathrm{link}}</span> , this relation can be expressed as a linear subspace relation,  <span class="math">R_{\\mathbf{M}}([x]_1, w)</span> , where  <span class="math">\\mathbf{M}, x, w</span>  are as follows:</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a></p>

    <p class="text-gray-300">Given the above encoding, it is straightforward to extend our scheme  <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>  to support the relation  <span class="math">R_{\\mathrm{pre}}^{\\mathrm{link}}</span>  instead of  <span class="math">R^{\\mathrm{link}}</span> .</p>

    <p class="text-gray-300">D A zkSNARK for Linear Subspaces</p>

    <p class="text-gray-300">Here we recall the QA-NIZK scheme for linear subspaces <span class="math">\\Pi_{as}^{\\prime}</span> of Kiltz and Wee <em>[x11]</em>, in the MDDH setting where <span class="math">k=1</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ss}\\Pi.\\mathsf{KeyGen}([\\mathbf{M}]_{1}\\in\\mathbb{G}_{1}^{l\\times t})</span>: <span class="math">\\bm{k}\\leftarrow\\</span>\\mathbb{Z}_{q}^{l},\\,a\\leftarrow\\<span class="math">\\mathbb{Z}_{q};\\,\\mathbf{P}:=\\mathbf{M}^{\\top}\\bm{k};\\,\\mathbf{C}:=a\\cdot\\bm{k}</span> <span class="math">\\mathbf{return}\\ \\big{(}\\mathsf{ek}:=[\\mathbf{P}]_{1}\\in\\mathbb{G}_{1}^{t},\\mathsf{vk}:=([\\mathbf{C}]_{2},[a]_{2})\\in\\mathbb{G}_{2}^{l}\\times\\mathbb{G}_{2}\\big{)}</span> <span class="math">\\mathsf{ss}\\Pi.\\mathsf{Prove}(\\mathsf{ek},[\\bm{x}]_{1},\\bm{w})</span>: <span class="math">\\mathbf{return}\\ [\\pi]_{1}\\leftarrow\\bm{w}^{\\top}[\\mathbf{P}]_{1}\\in\\mathbb{G}_{1}</span> <span class="math">\\mathsf{ss}\\Pi.\\mathsf{VerProof}(\\mathsf{vk},[\\bm{x}]_{1},[\\pi]_{1})</span>:] check that <span class="math">[\\bm{x}]_{1}^{\\top}\\cdot[\\mathbf{C}]_{2}=[\\pi]_{1}\\cdot[a]_{2}</span> <span class="math">\\mathsf{ss}\\Pi.\\mathcal{S}_{\\mathsf{kg}}(1^{\\lambda})</span>: run as <span class="math">\\mathsf{ss}\\Pi.\\mathsf{KeyGen}</span> and output <span class="math">\\mathsf{td}_{\\mathsf{k}}=\\bm{k}</span> and <span class="math">(\\mathsf{ek},\\mathsf{vk})</span> <span class="math">\\mathsf{ss}\\Pi.\\mathcal{S}_{\\mathsf{prv}}(\\mathsf{td}_{\\mathsf{k}},[\\bm{x}]_{1})</span>: <span class="math">\\mathbf{return}\\ [\\pi]_{1}\\leftarrow\\bm{k}^{\\top}[\\bm{x}]_{1}</span></p>

    <p class="text-gray-300">In the following theorem we prove the knowledge soundness of the scheme given above. The proof holds under the discrete logarithm assumption in the algebraic group model of <em>[x10]</em>; this can also be interpreted as a proof in the (bilinear) generic group model. We also note that a similar proof about the use of this scheme in a non-falsifiable setting <em>[x11]</em> also appeared in <em>[x9]</em>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem D.1.</h6>

    <p class="text-gray-300">Assume that <span class="math">\\mathcal{D}_{\\mathsf{mtx}}</span> is a witness sampleable matrix distribution. Then, under the discrete logarithm assumption, in the algebraic group model, the QA-NIZK <span class="math">\\Pi_{as}^{\\prime}</span> in <em>[x11]</em> (in the MDDH setting <span class="math">k=1</span>) is a knowledge-sound SNARK for linear subspace relations with matrices from <span class="math">\\mathcal{D}_{\\mathsf{mtx}}</span>.</p>

    <p class="text-gray-300">Proof Consider an algebraic adversary <span class="math">\\mathcal{A}</span> against the knowledge soundness of <span class="math">\\mathsf{ss}\\Pi</span>. Its input consists of the matrix <span class="math">[\\mathbf{M}]_{1}</span> and the associated auxiliary input <span class="math">\\mathsf{aux}</span>, along with the common reference string <span class="math">[\\mathbf{P}]_{1},[\\mathbf{C}]_{2},[a]_{2}</span>. Let <span class="math">[\\bm{z}]_{1}</span> be a vector that contains <span class="math">\\mathbf{M}</span> and the portion of <span class="math">\\mathsf{aux}</span> that has elements from the group <span class="math">\\mathbb{G}_{1}</span>, and also assume <span class="math">[\\bm{z}]</span> includes <span class="math">[1]_{1}</span>. <span class="math">\\mathcal{A}</span> returns a pair <span class="math">([\\bm{x}]_{1},[\\pi]_{1})</span> along with coefficients that “explain” these elements as linear combinations of its input in the group <span class="math">\\mathbb{G}_{1}</span>. Let these coefficients be:</p>

    <p class="text-gray-300"><span class="math">[\\bm{x}]_{1}</span> <span class="math">:=\\bm{X}_{0}\\ [\\mathbf{P}]_{1}+\\bm{X}_{1}\\ [\\bm{z}]_{1}=\\bm{X}_{0}\\ [\\mathbf{M}^{\\top}\\bm{k}]_{1}+\\bm{X}_{1}\\ [\\bm{z}]_{1}</span> <span class="math">[\\pi]_{1}</span> <span class="math">:=\\bm{\\pi}_{0}^{\\top}[\\mathbf{P}]_{1}+\\bm{\\pi}_{1}^{\\top}[\\bm{z}]_{1}=\\bm{\\pi}_{0}^{\\top}[\\mathbf{M}^{\\top}\\bm{k}]_{1}+\\bm{\\pi}_{1}^{\\top}[\\bm{z}]_{1}</span></p>

    <p class="text-gray-300">We define the extractor <span class="math">\\mathcal{E}</span> to be the algorithm that runs the algebraic <span class="math">\\mathcal{A}</span> and returns <span class="math">\\bm{w}:=\\bm{\\pi}_{0}</span>, i.e., the coefficients of <span class="math">[\\pi]_{1}</span> corresponding to <span class="math">\\mathbf{P}</span>. Next, we have to show that the probability that the output of <span class="math">(\\mathcal{A},\\mathcal{E})</span> satisfies verification while <span class="math">\\bm{x}\\neq\\mathbf{M}\\bm{w}</span> is negligible. In other words, assume that the output of <span class="math">\\mathcal{A}</span> is such that:</p>

    <p class="text-gray-300"><span class="math">[\\bm{x}]_{1}^{\\top}\\cdot[a\\cdot\\bm{k}]_{2}=[\\pi]_{1}\\cdot[a]_{2}\\quad\\text{ and }\\quad[\\bm{x}]_{1}\\neq[\\mathbf{M}]_{1}\\bm{\\pi}_{0}</span></p>

    <p class="text-gray-300">If <span class="math">\\mathcal{A}</span> returns such a tuple with non-negligible probability, we show how to build an algorithm <span class="math">\\mathcal{B}</span> that on input <span class="math">([\\bm{k}]_{1},[\\bm{k}]_{2})</span> outputs nonzero elements <span class="math">\\bm{A}\\in\\mathbb{Z}_{q}^{l\\times l}</span>, <span class="math">\\bm{b}\\in\\mathbb{Z}_{q}^{l},c\\in\\mathbb{Z}_{q}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\bm{k}^{\\top}\\bm{A}\\ \\bm{k}+\\bm{k}^{\\top}\\bm{b}+c=0</span></p>

    <p class="text-gray-300">Such a <span class="math">\\mathcal{B}</span> can in turn be reduced to an algorithm <span class="math">\\mathcal{B}^{\\prime}</span> that solves discrete log, i.e., on input <span class="math">([\\alpha]_{1},[\\alpha]_{2})</span> return <span class="math">\\alpha</span>.</p>

    <p class="text-gray-300">Algorithm <span class="math">\\mathcal{B}([\\bm{k}]_{1},[\\bm{k}]_{2})</span> proceeds as follows. First, it uses <span class="math">\\mathcal{D}_{\\mathsf{mtx}}</span> to sample <span class="math">([\\mathbf{M}]_{1},\\mathsf{aux})</span> along with its <span class="math">\\mathbb{G}_{1}</span> witness (i.e., a vector <span class="math">\\bm{z}</span> of entries in <span class="math">\\mathbb{Z}_{q}</span>). Second, it samples <span class="math">a\\leftarrow\\</span>\\mathbb{Z}_{q}<span class="math"> and runs </span>\\mathcal{A}([\\bm{z},\\mathbf{P}]_{1},[a,a\\cdot\\bm{k}]_{2})$</p>

    <p class="text-gray-300">(notice that <span class="math">\\mathcal{A}</span>'s input can be efficiently simulated). Third, once received the output of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{B}</span> sets <span class="math">\\mathbf{A} := \\mathbf{X}_0 \\mathbf{M}^\\top</span>, <span class="math">\\mathbf{b} := \\mathbf{X}_1 \\mathbf{z} - \\mathbf{M} \\boldsymbol{\\pi}_0</span> and <span class="math">c = -\\boldsymbol{\\pi}_1^\\top \\mathbf{z}</span>. Notice that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{k}^\\top \\mathbf{A} \\mathbf{k} + \\mathbf{k}^\\top \\mathbf{b} + c = \\mathbf{k}^\\top \\mathbf{X}_0 \\mathbf{M}^\\top \\mathbf{k} + \\mathbf{k}^\\top \\mathbf{X}_1 \\mathbf{z} - \\mathbf{k}^\\top \\mathbf{M} \\boldsymbol{\\pi}_0 - \\boldsymbol{\\pi}_1^\\top \\mathbf{z} \\\\ = \\mathbf{k}^\\top \\mathbf{X}_0 \\mathbf{M}^\\top \\mathbf{k} + \\mathbf{k}^\\top \\mathbf{X}_1 \\mathbf{z} - \\pi \\\\ = \\mathbf{k}^\\top \\mathbf{x} - \\pi = 0 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Also, one among <span class="math">\\mathbf{A}, \\mathbf{b}</span> and <span class="math">c</span> must be nonzero. Indeed, if they are all zero then <span class="math">\\mathbf{X}_1 \\mathbf{z} - \\mathbf{M} \\boldsymbol{\\pi}_0 = 0</span>, that is <span class="math">\\mathbf{x} = \\mathbf{M} \\boldsymbol{\\pi}_0</span>, which contradicts our assumption on <span class="math">\\mathcal{A}</span>'s output.</p>

    <p class="text-gray-300">To finish the proof, we show how the above problem can be reduced to discrete log in asymmetric groups, i.e., <span class="math">\\mathcal{B}&#x27;</span> on input <span class="math">([\\alpha]_1, [\\alpha]_2)</span> returns <span class="math">\\alpha</span>. <span class="math">\\mathcal{B}&#x27;</span> samples <span class="math">\\mathbf{r}, \\mathbf{s} \\in \\mathbb{Z}_q^l</span> and implicitly sets <span class="math">\\mathbf{k} := \\alpha \\cdot \\mathbf{r} + \\mathbf{s}</span>. It is easy to see that <span class="math">([\\mathbf{k}]_1, [\\mathbf{k}]_2)</span> can be efficiently simulated with a distribution identical to the one expected by <span class="math">\\mathcal{B}</span>. Next, given a solution <span class="math">(\\mathbf{A}, \\mathbf{b}, c)</span> such that <span class="math">\\mathbf{k}^\\top \\mathbf{A} \\mathbf{k} + \\mathbf{k}^\\top \\mathbf{b} + c = 0</span> one can find <span class="math">a&#x27;, b&#x27;, c&#x27; \\in \\mathbb{Z}_q</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = (\\alpha \\mathbf{r} + \\mathbf{s})^\\top \\mathbf{A} (\\alpha \\mathbf{r} + \\mathbf{s}) + (\\alpha \\mathbf{r} + \\mathbf{s})^\\top \\mathbf{b} + c \\\\ = \\alpha^2 (\\mathbf{r}^\\top \\mathbf{A} \\mathbf{r}) + \\alpha \\cdot (\\mathbf{r}^\\top \\mathbf{A} \\mathbf{s} + \\mathbf{s}^\\top \\mathbf{A} \\mathbf{r} + \\mathbf{r}^\\top \\mathbf{b}) + (\\mathbf{s}^\\top \\mathbf{A} \\mathbf{s} + \\mathbf{s}^\\top \\mathbf{b} + c) \\\\ = a&#x27; \\alpha^2 + b&#x27; \\alpha + c&#x27; \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In particular, with overwhelming probability (over the choice of <span class="math">\\mathbf{s}</span> that is information theoretically hidden from <span class="math">\\mathcal{B}</span>'s view) <span class="math">c&#x27; \\neq 0</span>. From this solution <span class="math">\\mathcal{B}&#x27;</span> can solve the system and extract <span class="math">\\alpha</span>.</p>

    <h2 id="sec-73" class="text-2xl font-bold">E A Construction of PolyCom and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> from zk-vSQL</h2>

    <p class="text-gray-300">We show a pairing-based construction of the commitment PolyCom and CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> that are "extracted" from the verifiable polynomial delegation scheme of Zhang et al. [ZGK⁺17b]. Basically, we separate the algorithms related to committing from the ones related to proving and verifying evaluations of committed polynomials. Except for that, the only noticeable difference is that in our case we can prove that <span class="math">c_y</span> opens to <span class="math">y = f(\\mathbf{x})</span> (with respect to <span class="math">c_f</span> which opens to <span class="math">f</span>) for a given <span class="math">c_y</span> instead of one that is freshly generated at proving time. As we show below, this difference would matter only for zero-knowledge, for which we give a proof a slightly different than the one in [ZGK⁺17b].</p>

    <p class="text-gray-300">Setup(1^λ): let <span class="math">\\mathcal{F}</span> be <span class="math">\\mu</span>-variate polynomials of degree <span class="math">d</span> in each variable. Sample <span class="math">\\alpha, \\beta, s_1, \\ldots, s_{\\mu+1} \\leftrightarrow \\mathbb{Z}_q</span> uniformly at random, compute <span class="math">\\mathbb{P} = \\{[\\prod_{i \\in W} s_i, \\alpha \\prod_{i \\in W} s_i]_1\\}_{W \\in \\mathcal{W}_{\\mu,d}}</span>, and output <span class="math">\\mathsf{ck} = (\\mathbb{P}, [s_{\\mu+1}, \\alpha s_{\\mu+1}, \\beta s_{\\mu+1}]_1, [\\alpha, \\beta, s_1, \\ldots, s_{\\mu+1}]_2)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ComPoly}(\\mathsf{ck}, f) \\to (c_f, o_f)</span>: sample <span class="math">o_f \\leftrightarrow \\mathbb{Z}_q</span>, compute <span class="math">c_{f,1} = [f(s_1, \\ldots, s_\\mu) + o_f s_{\\mu+1}]_1</span>, <span class="math">c_{f,2} = [\\alpha(f(s_1, \\ldots, s_\\mu) + o_f s_{\\mu+1})]_1</span> and output <span class="math">c_f = (c_{f,1}, c_{f,2})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ComVal}(\\mathsf{ck}, y) \\to (c_y, o_y)</span>: sample <span class="math">o_y \\leftrightarrow \\mathbb{Z}_q</span>, compute <span class="math">c_{y,1} = [y + o_y s_{\\mu+1}]_1</span>, <span class="math">c_{y,2} = [\\beta(y + o_f s_{\\mu+1})]_1</span> and output <span class="math">c_y = (c_{y,1}, c_{y,2})</span>.</p>

    <p class="text-gray-300">CheckCom(ck, c): we assume one knows the type for which <span class="math">c</span> was created. If type = pol, output 1 iff <span class="math">c_1 \\cdot [\\alpha]_2 = c_2 \\cdot [1]_2</span>. If type = val, output 1 iff <span class="math">c_1 \\cdot [\\beta]_2 = c_2 \\cdot [1]_2</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VerCommit}(\\mathsf{ck}, c, f, o) \\to b</span>: output <span class="math">c_1 \\stackrel{?}{=} [f(s_1, \\ldots, s_\\mu) + o s_{\\mu+1}]_1</span>.</p>

    <p class="text-gray-300">59</p>

    <p class="text-gray-300">60</p>

    <p class="text-gray-300">Theorem E.1 ([ZGK⁺17b]). Under the <span class="math">(\\mu + 1)\\delta</span>-Strong Diffie-Hellman and the <span class="math">(\\delta, \\mu)</span>-Extended Power Knowledge of Exponent assumptions (see [ZGK⁺17b]), PolyCom is an extractable trapdoor polynomial commitment.</p>

    <p class="text-gray-300">The proof of the theorem follows from Theorem 1 in [ZGK⁺17b]. The only property that is not proved there is the trapdoor property, which is however straightforward to see if one considers a simulator <span class="math">S_{\\mathrm{ck}}</span> that sets the values <span class="math">\\alpha, \\beta, s_1, \\ldots, s_{\\mu+1}</span> as trapdoor.</p>

    <p class="text-gray-300">Next, we show a CP-SNARK for polynomial evaluation relations <span class="math">R^{\\mathrm{poly}}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. KeyGen(ck): set <span class="math">\\mathsf{ek} := \\mathsf{ck}</span> and <span class="math">\\mathsf{vk} := ([\\alpha, \\beta, s_1, \\ldots, s_{\\mu+1}]_2)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. Prove(ek, <span class="math">\\boldsymbol{x}, f, y, o_f, o_y</span>): sample <span class="math">o_1, \\ldots, o_\\mu \\gets \\S \\mathbb{Z}_q</span>; find polynomials <span class="math">q_i</span> such that <span class="math">f(Z_1, \\ldots, Z_\\mu) + o_f Z_{\\mu+1} - (y + o_y Z_{\\mu+1}) = \\sum_{i=1}^{\\mu} (Z_i - x_i)(q_i(Z_i, \\ldots, Z_\\mu) + o_i Z_{\\mu+1}) + X_{\\mu+1}(o_f - o_y - \\sum_{i=1}^{\\mu} o_i(Z_i - x_i)</span>.</p>

    <p class="text-gray-300">For <span class="math">i = 1</span> to <span class="math">\\mu</span>, compute <span class="math">c_{i} := (c_{i,1}, c_{i,2}) = [q_{i}(s_{1}, \\ldots, s_{\\mu}) + o_{i}s_{\\mu+1}, \\alpha(q_{i}(s_{1}, \\ldots, s_{\\mu}) + o_{i}s_{\\mu+1})]_{1}</span>, <span class="math">c_{\\mu+1} := (c_{\\mu+1,1}, c_{\\mu+1,2}) = [o_{f} - o_{y} - \\sum_{i=1}^{\\mu} o_{i}(s_{i} - x_{i}), \\alpha(o_{f} - o_{y} - \\sum_{i=1}^{\\mu} o_{i}(s_{i} - x_{i}))]_{1}</span>. Output <span class="math">\\pi := (c_{1}, \\ldots, c_{\\mu+1})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. VerProof(vk, <span class="math">\\boldsymbol{x}, c_f, c_y, \\pi</span>): parse <span class="math">\\pi := (c_1, \\ldots, c_{\\mu+1})</span>, output <span class="math">(c_{f,1} - c_{y,1}) \\cdot [1]_2 = c_{\\mu+1,1} \\cdot [s_{\\mu+1}]_2 \\sum_{i=1}^{\\mu} c_{i,1} \\cdot [(s_i - x_i)]_2</span> and CheckCom(vk, <span class="math">c_f</span>) <span class="math">\\wedge</span> CheckCom(vk, <span class="math">c_y</span>) <span class="math">\\bigwedge_{i=1}^{\\mu+1} \\mathsf{CheckCom}(\\mathsf{vk}, c_i)</span>.</p>

    <p class="text-gray-300">Theorem E.2 ([ZGK⁺17b]). Under the <span class="math">(\\mu + 1)\\delta</span>-Strong Diffie-Hellman and the <span class="math">(\\delta, \\mu)</span>-Extended Power Knowledge of Exponent assumptions (see [ZGK⁺17b]), <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> is a zero-knowledge CP-SNARK for <span class="math">R^{\\mathrm{poly}}</span>.</p>

    <p class="text-gray-300">Correctness and knowledge soundness are immediate from Theorem 1 in [ZGK⁺17b]. The only difference is in the zero-knowledge property. For this, consider the following proof simulator algorithm, <span class="math">S_{\\mathrm{prv}}(\\mathsf{td}, \\boldsymbol{x}, c_f, c_y)</span>: for <span class="math">i = 1</span> to <span class="math">\\mu</span>, sample <span class="math">c_{i,1} \\gets \\S \\mathbb{G}_1</span> and compute <span class="math">c_{i,2} = \\alpha \\cdot c_{i,1}</span>. Next, compute <span class="math">c_{\\mu + 1,1}</span> such that <span class="math">(c_{f,1} - c_{y,1}) \\cdot [1]_2 = c_{\\mu + 1,1} \\cdot [s_{\\mu + 1}]_2 + \\sum_{i=1}^{\\mu} c_{i,1} \\cdot [(s_i - x_i)]_2</span> holds and set <span class="math">c_{\\mu + 1,2} \\gets \\beta \\cdot c_{\\mu + 1,1}</span>. It is straightforward to check that proofs created by <span class="math">S_{\\mathrm{prv}}</span> are identically distributed to the ones returned by <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>. Prove.</p>

    <h2 id="sec-74" class="text-2xl font-bold">F Additional Material on CP-SNARKs for PolyCom</h2>

    <p class="text-gray-300">In this section we present more CP-SNARKs for PolyCom.</p>

    <h2 id="sec-75" class="text-2xl font-bold">F.1 Proof of our <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span></h2>

    <p class="text-gray-300">We give a full description of the interactive protocol in Figure 3.</p>

    <p class="text-gray-300">Proof We show the security of our protocol by reducing it to the one of [ZGK⁺17b, Construction 2]. For this let us recall the following theorem from [ZGK⁺17b]:</p>

    <p class="text-gray-300">Theorem F.1 ([ZGK⁺17b, Theorem 2]). For any <span class="math">\\mu</span>-variate total-degree-<span class="math">d</span> polynomial <span class="math">g: \\mathbb{F}^{\\mu} \\to \\mathbb{F}</span> with <span class="math">m</span> non-zero coefficients, assuming <span class="math">\\mathsf{Com}</span> is an extractable linearly homomorphic commitment scheme, and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is a zero-knowledge non-interactive argument for testing equality of commitments for <span class="math">\\mathsf{Com}</span>, then there is an interactive argument for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{VerCommit}(\\mathsf{ck}, c_t, t, o_t) = 1 \\wedge t = \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{\\mu}} g(\\boldsymbol{b})</span></div>

    <p class="text-gray-300">Moreover, we recall below the last two steps of Construction 2 in <em>[ZGK^{+}17b]</em> (i.e., Construction 2 is the same as in our Figure 3 with the blue part replaced by the following steps):</p>

    <p class="text-gray-300">1 : Common input: <span class="math">c_{t},g;\\quad\\mathcal{P}</span>’s input: <span class="math">(t,o_{t})</span> 2 : <span class="math">\\mathcal{P}:(c^{<em>}_{\\mu},o^{</em>}_{\\mu})\\leftarrow\\textsf{ComVal}(\\mathsf{ck},g(\\bm{s}))\\ \\ ;\\ \\ \\pi^{<em>}\\leftarrow\\textsf{CP}_{\\mathsf{eq}}.\\mathsf{Prove}(\\mathsf{ck},(c^{</em>}_{\\mu},\\mathsf{com}_{\\mu}),g(\\bm{s}),(o^{<em>}_{\\mu},\\rho_{\\mu}))</span> 3 : <span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}:c^{</em>}_{\\mu},o^{<em>}_{\\mu},\\pi^{</em>}</span> 4 : <span class="math">\\mathcal{V}:\\mathsf{VerCommit}(\\mathsf{cvk},c^{<em>}_{\\mu},g(\\bm{s}),o^{</em>}_{\\mu})\\wedge\\textsf{CP}_{\\mathsf{eq}}.\\mathsf{VerProof}(\\mathsf{vk},(c^{<em>}_{\\mu},\\mathsf{com}_{\\mu}),\\pi^{</em>})</span></p>

    <p class="text-gray-300">For knowledge soundness, the idea of the proof is that for any adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span> we can create an adversary <span class="math">\\mathcal{B}</span> against Construction 2 in <em>[ZGK^{+}17b]</em>.</p>

    <p class="text-gray-300">Similarly to <em>[ZGK^{+}17b]</em>, we begin by observing that the commitments <span class="math">c_{1},c_{2}</span> as well as all the commitments <span class="math">\\mathsf{com}_{a_{j}}</span>’s sent during the <span class="math">\\mu</span> rounds are extractable. By extractability, for any successful <span class="math">\\mathcal{A}</span> there exists an extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> that, on the same input of <span class="math">\\mathcal{A}</span>, outputs with all but negligible probability valid openings of all these commitments. Thus we define <span class="math">\\mathcal{B}</span> as the adversary that executes <span class="math">(\\mathcal{A},\\mathcal{E}_{\\mathcal{A}})</span>, obtains <span class="math">g_{1},g_{2}</span>, reconstructs the polynomial <span class="math">g(\\bm{S})</span>, and then keeps executing <span class="math">\\mathcal{A}</span> until the end of the protocol, forwarding its messages to its challenger. This is done until the last step where <span class="math">\\mathcal{A}</span> sends <span class="math">c_{1}^{\\prime},c_{2}^{\\prime},\\pi^{*}</span>. Notice that <span class="math">\\mathcal{B}</span> also has the commitments <span class="math">\\mathsf{com}_{a_{j}}</span> sent by <span class="math">\\mathcal{A}</span> in step <span class="math">\\mu</span> as well as their openings extracted through <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>. Thus, <span class="math">\\mathcal{B}</span> can compute homomorphically the commitment <span class="math">\\mathsf{com}_{\\mu}</span> and its opening.</p>

    <p class="text-gray-300">With this knowledge, <span class="math">\\mathcal{B}</span> executes the last two lines in Figure 3 (acting as the verifier): if all verifications pass and <span class="math">\\mathcal{B}</span> has an opening of <span class="math">\\mathsf{com}_{\\mu}</span> to <span class="math">g(\\bm{s})</span>, then it executes the lines 2–4 above and sends <span class="math">(c^{<em>}_{\\mu},o^{</em>}_{\\mu},\\pi^{*})</span> to its challenger.</p>

    <p class="text-gray-300">If all verifications pass but <span class="math">\\mathcal{B}</span> has an opening of <span class="math">\\mathsf{com}_{\\mu}</span> to a value different from <span class="math">g(\\bm{s})</span>, then it must be the case that <span class="math">\\mathcal{A}</span> cheated in one of the proofs <span class="math">\\pi_{1},\\pi_{2},\\pi^{*}</span>. By the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> this however occurs only with negligible probability.</p>

    <p class="text-gray-300">To show zero-knowledge, we build a simulator that can simulate the verifier’s view without knowing the prover’s input. Our simulator is the same as the one in <em>[ZGK^{+}17b]</em> up to their step (d). For step (e), we let our simulator additionally create commitments <span class="math">(c_{1}^{\\prime},c_{2}^{\\prime})</span> to dummy values and then run the ZK simulators of <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> to simulate proofs <span class="math">(\\pi_{1},\\pi_{2},\\pi^{<em>})</span>. By the proof in </em>[ZGK^{+}17b]<em>, the verifier’s transcript except for the last message <span class="math">(c_{1}^{\\prime},c_{2}^{\\prime},\\pi_{1},\\pi_{2},\\pi^{</em>})</span> is indistinguishable from an honest one. The indistinguishability with respect to the last message follows immediately from the zero-knowledge <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>. ∎</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">F.2 Proof of Security of <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span></h3>

    <p class="text-gray-300">Proof Let <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> be the adversary against <span class="math">\\mathsf{CP}_{\\mathsf{had}}</span> that, on input <span class="math">(\\mathsf{ck},\\mathsf{ek}_{s},\\mathsf{ek}_{p})</span> and interacting with the random oracle <span class="math">H</span>, returns a statement <span class="math">(c_{j})_{j\\in[\\cdot 3]}</span> and a proof <span class="math">\\pi</span> that verifies correctly. For any such <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> we can define a non-interactive adversary <span class="math">\\mathcal{A}_{\\mathsf{had}}^{<em>}</span> that additionally takes as input a sequence of random values <span class="math">\\bm{r}_{i}</span>, for <span class="math">i=1</span> to <span class="math">Q</span>, such that <span class="math">\\bm{r}_{i}</span> is used to answer the <span class="math">i</span>-th query of <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> to the random oracle <span class="math">H</span>. For any <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> making <span class="math">Q</span> queries to <span class="math">H</span> there exists an index <span class="math">i\\in[0,Q]</span> such that the commitments <span class="math">(c_{j})_{j\\in[\\cdot 3]}</span> returned at the end of its execution were queried to <span class="math">H</span> in the <span class="math">i</span>-th query (letting <span class="math">i=0</span> being the case in which they were not asked at all). From the above adversary <span class="math">\\mathcal{A}_{\\mathsf{had}}^{</em>}</span> we can define <span class="math">\\mathcal{A}_{com}</span> as the non-uniform adversary that on input <span class="math">(\\mathsf{ck},\\mathsf{ek}_{s},\\mathsf{ek}_{p},\\bm{r}_{1},\\ldots,\\bm{r}_{i-1})</span> runs <span class="math">\\mathcal{A}_{\\mathsf{had}}</span> (in the same way as <span class="math">\\mathcal{A}_{\\mathsf{had}}^{*}</span> does) up to its <span class="math">i</span>-th query <span class="math">H((c_{j})_{j\\in[\\cdot 3]})</span> and returns <span class="math">(c_{j})_{j\\in[\\cdot 3]}</span>. By the extractability of the commitment, for <span class="math">\\mathcal{A}_{com}</span> there exists an extractor <span class="math">\\mathsf{Ext}_{com}</span> that on the same input of <span class="math">\\mathcal{A}_{com}</span> outputs openings <span class="math">(\\tilde{u}_{j})_{j\\in[\\cdot 3]},(o_{j})_{j\\in[\\cdot 3]}</span>. We define the extractor <span class="math">\\mathcal{E}_{\\mathsf{had}}</span> to be the</p>

    <p class="text-gray-300">one that runs <span class="math">\\mathsf{Ext}_{com}</span> and returns its output. Notice that by the extractability of PolyCom it holds <span class="math">\\mathsf{VerCommit}(\\mathsf{ck}, c_j, \\tilde{u}_j, o_j)</span> for <span class="math">j = 0, 1, 2</span> with all but negligible probability.</p>

    <p class="text-gray-300">Next, we need to argue that this adversary-extractor pair <span class="math">(\\mathcal{A}_{\\mathrm{had}}, \\mathcal{E}_{\\mathrm{had}})</span> has negligible probability of winning in the knowledge soundness experiment. From <span class="math">\\mathcal{A}_{\\mathrm{had}}^{*}</span> we can define two adversaries <span class="math">\\mathcal{A}_p</span> and <span class="math">\\mathcal{A}_{sc}</span> against <span class="math">\\mathsf{CP}_{\\mathrm{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{sc}}</span> respectively, and by using the knowledge soundness of the two CP-SNARKs we have that for each of these adversaries there is a corresponding extractor that gives us a value <span class="math">t</span> such that <span class="math">\\tilde{u}_0(\\boldsymbol{r}) = t</span> and <span class="math">t = \\sum_{\\boldsymbol{b} \\in \\{0,1\\}^{\\mu}} \\widetilde{eq}(\\boldsymbol{r}, \\boldsymbol{b}) \\cdot \\tilde{u}_1(\\boldsymbol{b}) \\cdot \\tilde{u}_2(\\boldsymbol{b})</span> hold respectively with all but negligible probability. Furthermore, the binding of PolyCom implies that the values and openings for all the commitments <span class="math">(c_j)_{j \\in [3]}, c_t</span> obtained using these extractors are all the same with all but negligible probability (otherwise we could define a reduction against the binding of PolyCom).</p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{VerCommit}(\\mathsf{ck}, c_j, \\tilde{u}_j, o_j)</span> for <span class="math">j = 0, 1, 2</span>, the only way for the adversary to win is when the relation <span class="math">R^{\\mathrm{had}}</span> is not satisfied. Since we have vectors in MLE form, the check of relation <span class="math">R^{\\mathrm{had}}</span> can be equivalently written as <span class="math">\\forall \\boldsymbol{b} \\in \\{0, 1\\}^{\\mu}: \\tilde{u}_0(\\boldsymbol{b}) \\stackrel{?}{=} \\tilde{u}_1(\\boldsymbol{b}) \\cdot \\tilde{u}_2(\\boldsymbol{b})</span>. Let us define the polynomial <span class="math">\\tilde{u}_0^<em>(\\boldsymbol{X}) = \\sum_{\\boldsymbol{b} \\in \\{0, 1\\}^{\\mu}} \\widetilde{eq}(\\boldsymbol{X}, \\boldsymbol{b}) \\cdot \\tilde{u}_1(\\boldsymbol{b}) \\cdot \\tilde{u}_2(\\boldsymbol{b})</span>; essentially <span class="math">\\tilde{u}_0^</em>(\\boldsymbol{X})</span> is the MLE of the vector that should correctly verify the <span class="math">R^{\\mathrm{had}}</span> relation. In particular, by lemma 5.1, <span class="math">\\tilde{u}_0^<em>(\\boldsymbol{X})</span> agrees with <span class="math">\\tilde{u}_1(\\boldsymbol{X}) \\cdot \\tilde{u}_2(\\boldsymbol{X})</span> on all boolean points. Thus, if the relation does not hold we must have <span class="math">\\tilde{u}_0^</em>(\\boldsymbol{X}) \\neq \\tilde{u}_0(\\boldsymbol{X})</span>. However, from above we have that <span class="math">\\tilde{u}_0(\\boldsymbol{r}) = \\tilde{u}_0^<em>(\\boldsymbol{r})</span> holds. Notice that from the construction of <span class="math">\\mathcal{E}_{\\mathrm{had}}</span>, the polynomials <span class="math">\\tilde{u}_0(\\boldsymbol{X}), \\tilde{u}_1(\\boldsymbol{X}), \\tilde{u}_2(\\boldsymbol{X})</span> are independent from <span class="math">\\boldsymbol{r}</span> (this is because the extractor <span class="math">\\mathcal{E}_{com}</span> that returned this polynomial did not have <span class="math">\\boldsymbol{r} = \\boldsymbol{r}_i</span> among its inputs), and <span class="math">\\tilde{u}_0^</em>(\\boldsymbol{X})</span> is fully determined from <span class="math">\\tilde{u}_1(\\boldsymbol{X}), \\tilde{u}_2(\\boldsymbol{X})</span>. Therefore, by the Schwartz-Zippel lemma, the event <span class="math">\\tilde{u}_0^<em>(\\boldsymbol{X}) \\neq \\tilde{u}_0(\\boldsymbol{X}) \\wedge \\tilde{u}_0(\\boldsymbol{r}) = \\tilde{u}_0^</em>(\\boldsymbol{r})</span> occurs with negligible probability over the random choice of <span class="math">\\boldsymbol{r}</span>.</p>

    <p class="text-gray-300">The zero-knowledge of <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span> relies on the hiding of PolyCom and the zero-knowledge of <span class="math">\\mathsf{CP}_{\\mathrm{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{sc}}</span>. Building simulators <span class="math">S_{\\mathrm{kg}}</span> and <span class="math">S_{\\mathrm{prv}}</span> for <span class="math">\\mathsf{CP}_{\\mathrm{had}}</span> from the corresponding simulators for <span class="math">\\mathsf{CP}_{\\mathrm{poly}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{sc}}</span> is fairly straightforward and is omitted here.</p>

    <h2 id="sec-77" class="text-2xl font-bold">F.3 Proof of <span class="math">\\mathsf{CP}_{\\mathrm{sfprm}}</span></h2>

    <p class="text-gray-300"><strong>Proof</strong> Let <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}</span> be the adversary against <span class="math">\\mathsf{CP}_{\\mathrm{sfprm}}</span> that, on input <span class="math">(\\mathsf{ck}, \\mathsf{ek}_p)</span> and interacting with the random oracle <span class="math">H</span>, returns a statement <span class="math">(\\phi, x, (c_j)_{j \\in [\\ell]})</span> and a proof <span class="math">\\pi</span> that verifies correctly. For any such <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}</span> we can define a non-interactive adversary <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}^<em></span> that additionally takes as input a sequence of random values <span class="math">(r_i, s_i)</span>, for <span class="math">i = 1</span> to <span class="math">Q</span>, such that <span class="math">(r_i, s_i)</span> are used to answer the <span class="math">i</span>-th query of <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}</span> to the random oracle <span class="math">H</span>. For any <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}</span> making <span class="math">Q</span> queries to <span class="math">H</span> there exists an index <span class="math">i \\in [0, Q]</span> such that for the relation statement <span class="math">(\\phi, x, (c_j)_{j \\in [\\ell]})</span> returned at the end of its execution, <span class="math">((c_{\\phi,j})_{j \\in [0,\\ell]}, \\boldsymbol{x}, (c_j)_{j \\in [\\ell]})</span> was queried to <span class="math">H</span> in the <span class="math">i</span>-th query (letting <span class="math">i = 0</span> being the case in which they were not asked at all, and <span class="math">c_{\\phi,j}</span> be deterministically derived from <span class="math">\\phi</span>). From the above adversary <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}^</em></span> we can define <span class="math">\\mathcal{A}_{\\mathrm{com}}</span> as the non-uniform adversary that on input <span class="math">(\\mathsf{ck}, \\mathsf{ek}_p, r_1, s_1, \\ldots, r_{i-1}, s_{i-1})</span> runs <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}</span> (in the same way as <span class="math">\\mathcal{A}_{\\mathrm{sfprm}}^*</span> does) up to its <span class="math">i</span>-th query <span class="math">H((c_{\\phi,j})_{j \\in [0,\\ell]}, \\boldsymbol{x}, (c_j)_{j \\in [\\ell]})</span> and returns <span class="math">(c_j)_{j \\in [\\ell]}</span>. By the extractability of the commitment, for <span class="math">\\mathcal{A}_{\\mathrm{com}}</span> there exists an extractor <span class="math">\\mathcal{E}_{\\mathrm{com}}</span> that on the same input of <span class="math">\\mathcal{A}_{\\mathrm{com}}</span> outputs openings <span class="math">(\\tilde{u}_j)_{j \\in [\\ell]}, (o_j)_{j \\in [\\ell]}</span>. We define the extractor <span class="math">\\mathcal{E}_{\\mathrm{sfprm}}</span> to be the one that runs <span class="math">\\mathcal{E}_{\\mathrm{com}}</span> and returns its output. Notice that by the extractability of PolyCom it holds <span class="math">\\mathsf{VerCommit}(\\mathsf{ck}, c_j, \\tilde{u}_j, o_j)</span> for <span class="math">j = 0, 1, 2</span> with all but negligible probability.</p>

    <p class="text-gray-300">Next, we need to argue that this adversary-extractor pair <span class="math">(\\mathcal{A}_{\\mathrm{sfprm}}, \\mathcal{E}_{\\mathrm{sfprm}})</span> has negligible probability of winning in the knowledge soundness experiment. Recall that we have <span class="math">\\mathsf{VerCommit}(\\mathsf{ck}, c_j, \\tilde{u}_j, o_j)</span> for <span class="math">j \\in [\\ell]</span> and, by the linear homomorphic property of <span class="math">\\mathsf{PolyCom}</span>, for all <span class="math">j \\in [0, \\ell]</span>, <span class="math">c_j&#x27;</span> and <span class="math">c_j&#x27;&#x27;</span> are commitments to the MLE of <span class="math">\\boldsymbol{y}_j&#x27; := \\boldsymbol{y}_j + r \\cdot \\boldsymbol{v}_j - s \\cdot \\mathbf{1}_j</span> and <span class="math">\\boldsymbol{y}_j&#x27;&#x27; := \\boldsymbol{y}_j + r \\cdot \\boldsymbol{\\phi}_j - s \\cdot \\mathbf{1}_j</span> respectively.</p>

    <p class="text-gray-300">Also, in order for the adversary to be successful it must be the case that the relation does not hold, i.e., <span class="math">\\bm{y}</span> is not a self-permutation according to <span class="math">\\phi</span>. Notice that the vector <span class="math">\\bm{y}</span> is independent of <span class="math">(r,s)</span> since it was returned by <span class="math">\\mathcal{E}_{\\mathsf{com}}</span> without having these values in its view. This allows us to argue that with overwhelming probability over the choice of <span class="math">r</span> it is the case that at least one of the entries of <span class="math">\\bm{y}+r\\cdot\\bm{\\phi}</span> is not in <span class="math">\\bm{y}+r\\cdot\\bm{v}</span>. Moreover, when these vectors have different entries the equation <span class="math">\\prod_{i}(y_{i}+r\\cdot i-s)=\\prod_{i}(y_{i}+r\\cdot\\phi(i)-s)</span> holds with negligible probability over the choice of <span class="math">s</span> by the Schwartz-Zippel lemma.</p>

    <p class="text-gray-300">Hence we have that with all but negligible probability <span class="math">\\prod_{i}(y_{i}+r\\cdot i-s)\\neq\\prod_{i}(y_{i}+r\\cdot\\phi(i)-s)</span>, which means that at one of the statements in the <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> or <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> proofs is not correct. We can reduce these cases to the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> or <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> using a fairly standard reduction, in which from an adversary <span class="math">\\mathcal{A}^{*}_{\\mathsf{sfprm}}</span> that falls into the above conditions (i.e., an <span class="math">(r,s)</span> that cause the above inequality) we build either an adversary <span class="math">\\mathcal{A}_{\\mathsf{ipd}}</span> against <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>, or an adversary <span class="math">\\mathcal{A}_{\\mathsf{prd}}</span> against <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> or an <span class="math">\\mathcal{A}_{\\mathsf{eq}}</span> against <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>.</p>

    <p class="text-gray-300">The zero-knowledge of <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span> follows from the hiding of <span class="math">\\mathsf{PolyCom}</span> (for creating dummy commitments <span class="math">(c_{z^{\\prime}_{j}},c_{z^{\\prime\\prime}_{j}})_{j\\in[0\\ldots\\ell]}</span>) and the zero-knowledge of all the underlying CP-SNARKs. ∎</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">F.4 Proof of <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span></h3>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}_{\\mathsf{lin}}</span> be the adversary against <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> that, on input <span class="math">(\\mathsf{ck},\\mathsf{ek}_{s},\\mathsf{ek}_{p})</span> and interacting with the random oracles <span class="math">H_{1},H_{2}</span>, returns a statement <span class="math">(\\bm{F},\\bm{x},c_{u})</span> and a proof <span class="math">\\pi</span> that verifies correctly. For any such <span class="math">\\mathcal{A}_{\\mathsf{lin}}</span> we can define a non-interactive adversary <span class="math">\\mathcal{A}^{<em>}_{\\mathsf{lin}}</span> that additionally takes as input a sequence of random values <span class="math">\\{\\bm{r}_{i}\\}_{i}</span>, <span class="math">\\{\\bm{\\sigma}_{j}\\}_{j}</span>, for <span class="math">i=1</span> to <span class="math">Q_{1}</span> and <span class="math">j=1</span> to <span class="math">Q_{2}</span>, such that <span class="math">\\bm{r}_{i}</span> (resp. <span class="math">\\bm{\\sigma}_{j}</span>) is used to answer the <span class="math">i</span>-th (resp. <span class="math">j</span>-th) query of <span class="math">\\mathcal{A}_{\\mathsf{lin}}</span> to the random oracle <span class="math">H_{1}</span> (resp. <span class="math">H_{2}</span>). For any <span class="math">\\mathcal{A}_{\\mathsf{lin}}</span> making <span class="math">Q_{1}</span> queries to <span class="math">H_{1}</span> there exists an index <span class="math">i\\in[0,Q_{1}]</span> such that for the statement <span class="math">(\\bm{F},\\bm{x},c_{u})</span> returned at the end of its execution the <span class="math">i</span>-th query to <span class="math">H_{1}</span> (letting <span class="math">i=0</span> being the case in which they were not asked at all) is <span class="math">(c_{F},\\bm{x},c_{u})</span>. From the above adversary <span class="math">\\mathcal{A}^{</em>}_{\\mathsf{lin}}</span> we can define <span class="math">\\mathcal{A}_{com}</span> as the non-uniform adversary that on input <span class="math">(\\mathsf{ck},\\mathsf{ek}_{s},\\bm{r}_{1},\\ldots,\\bm{r}_{i-1})</span> runs <span class="math">\\mathcal{A}_{\\mathsf{lin}}</span> (in the same way as <span class="math">\\mathcal{A}^{*}_{\\mathsf{lin}}</span> does) up to its <span class="math">i</span>-th query <span class="math">H(c_{F},\\bm{x},c_{u})</span> and returns <span class="math">c_{u}</span>. By the extractability of the commitment, for <span class="math">\\mathcal{A}_{com}</span> there exists an extractor <span class="math">\\mathcal{E}_{com}</span> that on the same input of <span class="math">\\mathcal{A}_{com}</span> outputs an opening <span class="math">\\tilde{u},o_{u}</span>. We define the extractor <span class="math">\\mathcal{E}_{\\mathsf{lin}}</span> to be the one that runs <span class="math">\\mathsf{Ext}_{com}</span> and returns its output. Notice that by the extractability of <span class="math">\\mathsf{PolyCom}</span> it holds <span class="math">\\mathsf{VerCommit}(\\mathsf{ck},c_{u},\\tilde{u},o_{u})</span> with all but negligible probability.</p>

    <p class="text-gray-300">Next, we need to argue that this adversary-extractor pair <span class="math">(\\mathcal{A}_{\\mathsf{lin}},\\mathcal{E}_{\\mathsf{lin}})</span> has negligible probability of winning in the knowledge soundness experiment. In a similar way as we argued extractability of <span class="math">c_{u}</span>, we can show that it is possible to extract the polynomial <span class="math">g_{1}</span> that correctly opens <span class="math">c_{1}</span>.</p>

    <p class="text-gray-300">Recall that the adversary is successful if the verifications pass and the relation does not hold, i.e., <span class="math">\\bm{F}\\cdot\\bm{u}\\neq\\bm{x}</span>. Considering MLEs, this means there is some <span class="math">\\bm{a}\\in\\{0,1\\}^{\\nu}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\tilde{x}(\\bm{a})\\neq\\sum\\nolimits_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\tilde{F}(\\bm{a},\\bm{b})\\tilde{u}(\\bm{b}).</span></p>

    <p class="text-gray-300">This means that the following polynomial inequality holds:</p>

    <p class="text-gray-300"><span class="math">\\tilde{x}(\\bm{R})\\neq\\sum\\nolimits_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\tilde{F}(\\bm{R},\\bm{b})\\cdot\\tilde{u}(\\bm{b})</span></p>

    <p class="text-gray-300">First, we argue that with all but negligible probability over the choice of <span class="math">\\bm{r}</span> we have <span class="math">t=\\tilde{x}(\\bm{r})\\neq\\sum\\nolimits_{\\bm{b}\\in\\{0,1\\}^{\\mu}}\\tilde{F}(\\bm{r},\\bm{b})\\tilde{u}(\\bm{b})</span>. Indeed, <span class="math">\\bm{r}</span> is random and independent from <span class="math">\\bm{x},\\tilde{F},\\tilde{u}</span> and the two polynomials</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">would be equal when evaluated on <span class="math">\\bm{r}</span> with probability at most $\\nu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by Schwartz-Zippel. Thus we can continue the proof assuming that </span>t\\neq\\sum_{\\bm{b}\\in\\{0,1\\}^{\\nu}}\\tilde{F}(\\bm{r},\\bm{b})\\cdot\\tilde{u}(\\bm{b})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, consider that for the extracted <span class="math">g_{1}</span> there are two possible cases: (i) <span class="math">g_{1}(\\bm{S})=\\tilde{F}(\\bm{r},\\bm{S})</span>, and (ii) <span class="math">g_{1}(\\bm{S})\\neq\\tilde{F}(\\bm{r},\\bm{S})</span>.</p>

    <p class="text-gray-300">If (i) occurs, then we can immediately build an adversary against the soundness of <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If (ii) occurs, consider two subcases: (ii.a) <span class="math">g_{1}(\\bm{\\sigma})=\\tilde{F}(\\bm{r},\\bm{\\sigma})</span>, and (ii.b) <span class="math">g_{1}(\\bm{\\sigma})\\neq\\tilde{F}(\\bm{r},\\bm{\\sigma})</span>. However, by Schwartz-Zippel (ii.a) occurs with negligible probability $\\mu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\bm{\\sigma}<span class="math">. And if (ii.b) occurs then it is possible to do a reduction to the soundness of </span>\\mathsf{CP}_{\\mathsf{poly}}<span class="math"> (since at least one of the claims </span>y^{<em>}=g_{1}(\\bm{\\sigma})<span class="math"> or </span>y^{</em>}=\\tilde{F}(\\bm{r},\\bm{\\sigma})$ is false).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The zero-knowledge of <span class="math">\\mathsf{CP}_{\\mathsf{lin}}</span> follows immediate from the zero-knowledge of <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>. ∎</p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">F.5 A CP-SNARK for Data-Parallel Computations</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we discuss how a CP-SNARK for relations <span class="math">R^{\\mathsf{par}}</span> and <span class="math">R^{\\mathsf{parjnt}}</span>, and for the commitment scheme <span class="math">\\mathsf{PolyCom}</span> of <em>[ZGK^{+}17b]</em> can be obtained by merging ideas from <em>[ZGK^{+}17b]</em> and <em>[WTs^{+}18]</em>. Such a merge of techniques was hinted possible in <em>[WTs^{+}18]</em>. Here we give more details on how such a scheme looks like. The main motivation of studying such a scheme is that the commitment part of the proof (and similarly a factor of the verification time) is $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, instead of </span>O(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An Abstract Version of Hyrax. Hyrax <em>[WTs^{+}18]</em> is a zero-knowledge proof, based on discrete log in the random oracle model that is based on the CMT protocol <em>[x10]</em>. Hyrax extends CMT, which is particularly suited for circuits composed of parallel identical basic blocks, by supporting non-determinism in zero-knowledge, as well as including other optimizations. Its basic structure as an interactive protocol: (i) the prover creates a commitment <span class="math">c_{w}</span> to the witness <span class="math">\\bm{w}</span> (a vector of field elements); (ii) the parties run a ZK variant of CMT (including optimizations from Giraffe++ <em>[WJB^{+}17]</em>); (iii) the prover “links” together the outputs of steps (i) and (ii). For this, it must prove that the MLE <span class="math">\\tilde{w}</span> of the witness in <span class="math">c_{w}</span> evaluated on a random point <span class="math">q_{d}</span> is equal to another value <span class="math">y</span> committed in <span class="math">\\zeta</span>.</p>

    <p class="text-gray-300">In Figure 17 we formalize this structure via a generic use of a commitment scheme for polynomials and a proof system for proving the correct evaluations of committed polynomials. For these two tools we use the syntax formalized in Appendix F. We call this scheme Hyrax-Abstract. It is clear from the security proof of <em>[WTs^{+}18]</em> that one could rephrase their security statement so that Hyrax-Abstract has witness extended emulation if <span class="math">\\mathsf{PolyCom}</span> is an extractable commitment and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> is a NIZK argument of knowledge for polynomial evaluations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instantiating Hyrax-Abstract with <span class="math">\\mathsf{PolyCom}</span>. We call <span class="math">\\mathsf{Hyrax-PolyCom}</span> the instantiation of Hyrax-Abstract with the <span class="math">\\mathsf{PolyCom}</span> commitment and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span> argument from <em>[ZGK^{+}17b]</em> as described in Appendix E. This is essentially the only difference with the original Hyrax scheme that uses (an extension of) a matrix commitment of size $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/l})<span class="math"> and Bulletproof for proving polynomial evaluations with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{(l-1)/l})<span class="math"> verification time. In </span>\\mathsf{HyrPoly}<span class="math"> there is instead a succinct commitment (of constant size) and a verification time, in step (iii), of </span>O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using <span class="math">\\mathsf{HyrPoly}</span> for Data-Parallel Computations. Hyrax, and in particular its <span class="math">\\mathrm{Gir}^{++}</span> core protocol, is designed to work on arithmetic circuits of fan-in two, consisting of <span class="math">N</span> identical sub-computations, each having <span class="math">d</span> layers and width at most <span class="math">G</span>. For this class of circuits, considering Hyrax’s cost analysis combined with the costs of <span class="math">\\mathsf{PolyCom}</span> commitment and <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>, we have</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 17: Pseudocode for Hyrax-Abstract.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">that in  <span class="math">\\mathsf{HyrPoly}</span> : the verifier runs in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ dG + \\lambda d\\log (NG))<span class="math">  and proofs have length  </span>O(\\lambda d\\log (NG))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to see that the relation  <span class="math">R^{\\mathsf{par}}((u_j)_{j \\in [N]}) \\coloneqq \\bigwedge_{j=1}^{N} R&#x27;(u_j)</span>  can be modeled with an arithmetic circuit  <span class="math">C</span>  consisting of  <span class="math">N</span>  copies of a circuit  <span class="math">C&#x27;</span>  that outputs 0 on  <span class="math">u_j</span>  iff  <span class="math">R&#x27;(u_j)</span>  holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we instead consider a parallel relation with joint inputs, i.e.,  <span class="math">R^{\\text{parjnt}}(u) \\coloneqq \\bigwedge_{j=1}^{N} R&#x27;(u_j&#x27;)</span>  where each  <span class="math">u_j&#x27;</span>  is a subset of the entries of  <span class="math">u</span> , a corresponding circuit can be built by taking the parallel  <span class="math">C</span>  as for  <span class="math">R^{\\text{par}}</span> , and by adding one layer - called redistribution layer (RDL) in [WTs+18] - that appropriately duplicates and redistributes wires from the input layer to the input wires of each  <span class="math">C&#x27;</span>  copy. In the case of using an RDL, the verifier of Hyrax, and also in our HyrPoly scheme, incurs an additional overhead in running time of the verifier  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ NG)$ . Essentially, for this break of parallelism the verifier must pay a cost in the total width of the circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the sake of our experiments, we call HyrPoly-Par the HyrPoly scheme executed on fully parallel circuits (no RDL), and we call HyrPoly-RDL the version of Hyrax - PolyCom executed with circuits with an RDL.</p>

    <p class="text-gray-300">In this section we show how to modify the zk-vSQL protocol of  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right]</span>  with a special class of circuits that simply consist of a tree of multiplications. The basic idea is to replace the CMT protocol over homomorphic commitment schemes proposed in  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right]</span>  with an analogous version of the protocol proposed by Thaler [Tha13] for the specific case of trees of multiplications. The advantage of this encoding is to bring the prover runtime linear in the number of gates in the circuit.</p>

    <p class="text-gray-300">We first explain some preliminaries and then present this construction.</p>

    <p class="text-gray-300">The CMT protocol [CMT12] is a variant of the GKR protocol [GKR08] where the prover runs in time  <span class="math">\\mathcal{O}(S\\log S)</span> , where  <span class="math">S</span>  is the size of the circuit. This protocol provides a proof that an element is the output of a circuit evaluated over a certain input. That is  <span class="math">y = C(\\pmb{x})</span> , where  <span class="math">C</span>  is a circuit of depth  <span class="math">d</span> ,  <span class="math">\\pmb{x}</span>  are the wires of layer  <span class="math">d</span>  and  <span class="math">y</span>  is claimed to be the output wire of the first layer 0. In short, the prover reduces recursively a claim on layer  <span class="math">i</span>  to another claim on layer  <span class="math">(i + 1)</span> , until he</p>

    <p class="text-gray-300">obtains a publicly verifiable claim on the input. In order to do that, both prover and verifier engage in a sum-check protocol for each layer, using one polynomial representing the values of the wires in layer <span class="math">i</span>. Its multilinear extension links layer <span class="math">i</span> (of size <span class="math">s_i</span>) to layer <span class="math">(i+1)</span> by a summation of wiring predicates as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{V}_{i}(\\boldsymbol{q}) = \\sum_{\\substack{\\boldsymbol{b}\\in \\{0,1\\}^{s_{i}}\\\\ \\boldsymbol{l},\\boldsymbol{r}\\in \\{0,1\\}^{s_{i + 1}}}}g_{\\boldsymbol{q}}^{(i)}(\\boldsymbol {b},\\boldsymbol {r},\\boldsymbol {l}):= \\sum_{\\substack{\\boldsymbol{b}\\in \\{0,1\\}^{s_{i}}\\\\ \\boldsymbol{l},\\boldsymbol{r}\\in \\{0,1\\}^{s_{i + 1}}}} \\tilde{\\beta}_{i}(\\boldsymbol {q},\\boldsymbol {b})\\cdot \\left(\\widetilde{\\mathsf{add}}_{i + 1}(\\boldsymbol {l},\\boldsymbol {r},\\boldsymbol {b})\\cdot (\\tilde{V}_{i + 1}(\\boldsymbol {l}) + \\tilde{V}_{i + 1}(\\boldsymbol {r})) + \\widetilde{\\mathsf{mul}}_{i + 1}(\\boldsymbol {l},\\boldsymbol {r},\\boldsymbol {b})\\cdot \\tilde{V}_{i + 1}(\\boldsymbol {l})\\cdot \\tilde{V}_{i + 1}(\\boldsymbol {r})\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{V}_i</span> returns the value of one gate, <span class="math">\\tilde{\\beta}_i(\\pmb{q},\\pmb{b}) = \\pmb{q} \\stackrel{\\tau}{=} \\pmb{b}</span> is a selector function, and <span class="math">\\widetilde{\\mathsf{opn}}_i(\\pmb{l},\\pmb{r},\\pmb{b})</span> checks whether the value of gate <span class="math">\\pmb{b}</span> at layer <span class="math">i</span> is the result of an <span class="math">\\mathsf{opn} \\in \\{\\mathsf{add},\\mathsf{mul}\\}</span> addition or multiplication gate with <span class="math">\\pmb{l}</span> and <span class="math">\\pmb{r}</span> being its left and right inputs in the <span class="math">(i + 1)</span>-th layer.</p>

    <p class="text-gray-300">The standard version of the protocol suggests that for each layer of the circuit the verifier has to check two claims. This results in <span class="math">O(2^{d})</span> calls to the sum-check protocol. However, an ingenious technique shows how to use a single claim per layer using a line through both values. Then the verifier chooses one random point on which they perform a single sum-check invocation per layer, resulting in <span class="math">O(d)</span> calls.</p>

    <h2 id="sec-83" class="text-2xl font-bold">G.2 Thaler's Protocol for Trees of Multiplications</h2>

    <p class="text-gray-300">In [Tha13], Thaler proposes another variation of the CMT/GKR protocol [GKR08, CMT12] for some specific classes of circuits, allowing for a logarithmic factor reduction in the prover's runtime. One of his protocols takes advantage of circuits where all gates perform the same operation, and whose wires are settled in a binary tree structure. He denotes these regular circuits by trees of multiplications or additions. This section only shows the notation of the former one due to its suitability for our construction of <span class="math">\\mathsf{CP}_{\\mathsf{sfprm}}</span>. Nonetheless, moving to the addition case is straightforward.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The main difference that will be discussed here is a different polynomial for sum-check, as well as the notation of the wiring predicates. Thaler's protocol assumes highly structured wiring in order to reduce the number of arguments of the predicates. Namely, given a gate at layer <span class="math">i</span> with label <span class="math">\\pmb{b} \\in \\{0,1\\}^{s_i}</span>, we assume its value is the result of a multiplication of gates of layer <span class="math">(i + 1)</span> with labels $(\\pmb{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0) \\in \\{0,1\\}^{s_i + 1}<span class="math"> and </span>(\\pmb{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) \\in \\{0,1\\}^{s_i + 1}$. This means, the number of inputs to the circuit is a power of two and each layer has half the size of its preceding one. On this basis, the resulting polynomial of each layer is much simpler as shown below:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {V} _ {i} (\\boldsymbol {q}) = \\sum_ {\\boldsymbol {b} \\in \\{0, 1 \\} ^ {s _ {i}}} g _ {\\boldsymbol {q}} ^ {(i)} (\\boldsymbol {b}) = \\sum_ {\\boldsymbol {b} \\in \\{0, 1 \\} ^ {s _ {i}}} \\tilde {\\beta} _ {i} (\\boldsymbol {q}, \\boldsymbol {b}) \\cdot \\tilde {V} _ {i + 1} (\\boldsymbol {b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0) \\cdot \\tilde {V} _ {i + 1} (\\boldsymbol {b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This tweak, together with a series of precomputations of <span class="math">\\tilde{\\beta}_i(\\pmb{q},\\pmb{b})</span> and <span class="math">\\tilde{V}_{i + 1}(\\pmb{b})</span> values allows to obtain a linear-time prover.</p>

    <h2 id="sec-84" class="text-2xl font-bold">G.3 Adapting zk-vSQL to Thaler's Protocol</h2>

    <p class="text-gray-300">Here we show how to change the CMT protocol over homomorphic commitments in [ZGK+17b, Construction 3] in order to work with circuits that are a tree of multiplication gates using Thaler's representation [Tha13] to achieve faster prover runtime. From the point of view of security, this modification of [ZGK+17b, Construction 3] does not require any significant change; essentially a proof would be a rewrite of the one in [ZGK+17b]. The precise description of the protocol is however interesting and therefore we give it for completeness in Figure 18.</p>

    <p class="text-gray-300">66</p>

    <p class="text-gray-300">Let  <span class="math">C: \\mathbb{F}^m \\to \\mathbb{F}</span>  be a depth- <span class="math">d</span>  binary tree of multiplications such that  <span class="math">C(\\pmb{y}) = z</span>  represents the operation  <span class="math">z = \\prod_{i=1}^{m} y_i</span>  where  <span class="math">m</span>  is a power of two, and let  <span class="math">\\mathsf{ck} \\gets \\mathsf{Setup}(1^\\lambda)</span>  be a commitment key of a linearly homomorphic commitment scheme. The protocol in Figure 18 allows a prover  <span class="math">\\mathcal{P}</span>  to convince a verifier  <span class="math">\\mathcal{V}</span>  that  <span class="math">C(\\pmb{y}) = z</span>  with respect to  <span class="math">\\pmb{y}</span>  and  <span class="math">z</span>  committed in  <span class="math">\\{c_{y_j}\\}_{j \\in \\{1\\dots m\\}}</span>  and  <span class="math">c_z</span> .</p>

    <p class="text-gray-300">As in [ZGK+17b], let  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  (resp.  <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span> ) be a zero-knowledge argument of knowledge for testing equality of two committed values (resp. the product relation between three commitments).</p>

    <p class="text-gray-300">1: Common input: cvk ;  <span class="math">r_0 = 0</span>  ;  <span class="math">c_{0}:= c_{z}</span>  ;  <span class="math">(c_{y_j})_{j\\in \\{1\\dots m\\}}</span> 2:  <span class="math">\\mathcal{P}</span>  input: ck ;  <span class="math">t_0\\coloneqq z</span>  ;  <span class="math">o_0\\coloneqq o_z</span>  ;  <span class="math">\\pmb {y}</span>  ;  <span class="math">(o_{y_j})_{j\\in \\{1\\dots m\\}}</span> 3: for  <span class="math">i = 0\\ldots d - 1</span> 4: Run Step 1 of Construction 2 [ZGK+17b] (sum-check over homomorphic commitments) 5: on the claim  <span class="math">t_i = V_i(\\pmb{r}_i) = \\sum_{b \\in \\{0,1\\}^{si}} g_{\\pmb{r}_i}^{(i)}(\\pmb{b})</span> 6: At the end of Step 1,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  hold  <span class="math">\\pmb{r}_i&#x27; \\in \\mathbb{F}^{s_i}</span>  and commitment  <span class="math">c_i&#x27;</span>  to  <span class="math">t_i&#x27; = g_{\\pmb{r}_i}^{(i)}(\\pmb{r}_i&#x27;)</span> 7:  <span class="math">\\mathcal{P}</span>  : Claims that VerCommit(cvk,  <span class="math">c_{i}^{\\prime}, t_{i}^{\\prime}, o_{i}^{\\prime}) = 1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8:  $\\mathcal{P}:(c_R,o_R)\\gets \\mathsf{ComVal}\\big(\\mathsf{ck},v_R\\coloneqq \\tilde{V}_{i + 1}(\\pmb {r}_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0)\\big);(c_L,o_L)\\gets \\mathsf{ComVal}\\big(\\mathsf{ck},v_L\\coloneqq \\tilde{V}_{i + 1}(\\pmb {r}_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1)\\big)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9:  <span class="math">\\mathcal{P}:(c^{<em>},o^{</em>})\\gets \\mathsf{ComVal}\\big(\\mathsf{ck},v^{<em>}:= v_{L}\\cdot v_{R}\\big)</span> 10:  <span class="math">\\mathcal{P}\\to \\mathcal{V}:c_R,c_L,c^</em></span> 11:  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathsf{CP}_{\\mathsf{prd}}\\big(\\mathsf{ck},(c_L,c_R,c^<em>);((v_L,v_R,v^</em>),(o_L,o_R,o^<em>))\\big)</span> 12:  <span class="math">\\mathcal{P}:(c_i^</em>,o_i^<em>)\\gets \\mathsf{HomEval}(\\mathsf{cvk},\\tilde{\\beta}_i(\\pmb {r}_i,\\pmb {r}_i&#x27;),c^</em>,o^<em>)</span> 13:  <span class="math">\\mathcal{V}:(c_i^</em>,\\cdot)\\gets \\mathsf{HomEval}(\\mathsf{cvk},\\tilde{\\beta}_i(\\pmb {r}_i,\\pmb {r}_i&#x27;),c^<em>,\\cdot)</span> 14:  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}\\big(\\mathsf{ck},(c_i&#x27;,c_i^</em>);(t_i&#x27;,(o_i&#x27;,o_i^*))\\big)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15:  <span class="math">\\mathcal{P}</span>  :Computes  <span class="math">\\{(c_{\\ell_j},o_{\\ell_j})\\gets \\mathsf{ComVal}(\\mathsf{ck},\\ell_j)\\}_{j = 0}^{s_{i + 1}}</span>  where  $\\ell (\\rho) = \\tilde{V}_{i + 1}(\\pmb{r}_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math">  for  </span>\\rho \\in \\mathbb{F}<span class="math">  and  </span>\\{\\ell_j\\}_{j = 0}^{s_{i + 1}}$  its coefficients</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">16:  <span class="math">\\mathcal{P}\\to \\mathcal{V}:\\{c_{\\ell_j}\\}_{j\\in \\{0\\dots s_{i + 1}\\}}</span> 17:  <span class="math">\\mathcal{P}:c_{\\ell (0)}\\gets c_{\\ell_0}</span>  ;  <span class="math">(c_{\\ell (1)},o_{\\ell (1)})\\gets \\mathsf{HomEval}(\\mathsf{cvk},(1,\\ldots ,1),\\{c_{\\ell_j},o_{\\ell_j}\\}_{j\\in [0,s_{i + 1}]})</span> 18:  <span class="math">\\mathcal{V}:c_{\\ell (0)}\\gets c_{\\ell_0}</span>  ;  <span class="math">(c_{\\ell (1)},\\cdot)\\gets \\mathsf{HomEval}(\\mathsf{cvk},(1,\\ldots ,1),\\{c_{\\ell_j}\\}_{j = 0}^{s_{i + 1}},\\cdot)</span> 19:  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}\\big(\\mathsf{ck},(c_R,c_{\\ell (0)});(v_R,o_R,o_{\\ell_0})\\big)</span>  ;  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}\\big(\\mathsf{ck},(c_L,c_{\\ell (1)});(v_L,o_L,o_{\\ell (1)})\\big)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20:  <span class="math">\\mathcal{V}\\to \\mathcal{P}:r_i^{\\prime \\prime}\\gets \\mathbb{S}\\mathbb{F}</span>  and define  $\\pmb{r}_{i + 1}\\gets (\\pmb{r}_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_i'')$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">21:  <span class="math">\\mathcal{V}:(c_{i + 1},\\cdot)\\gets \\mathsf{HomEval}\\big(\\mathsf{ck},(1,r_i^{\\prime \\prime},\\dots,r_i^{\\prime \\prime s_{i + 1}}),\\{c_{\\ell_j}\\}_{j\\in [0,s_{i + 1}]},\\cdot \\big)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">22:  $\\mathcal{P}:\\pmb{r}_{i + 1}\\gets (\\pmb{r}_i'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_i'')<span class="math">  .  </span>t_{i + 1}\\gets \\tilde{V}_{i + 1}(\\pmb{r}_{i + 1})<span class="math">  .  </span>(c_{i + 1},o_{i + 1})\\gets \\mathsf{HomEval}\\big(\\mathsf{ck},(1,r_i^{\\prime \\prime},\\dots,r_i^{\\prime \\prime s_{i + 1}}),\\{c_{\\ell_j},o_{\\ell_j}\\}_{j\\in [0,s_{i + 1}]}\\big)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">23: endfor 24:  <span class="math">\\mathcal{P}\\to \\mathcal{V}:\\pmb {y}</span>  ;  <span class="math">(o_{y_j})_{j\\in \\{1\\dots m\\}}</span>  ;  <span class="math">o_0</span> 25:  <span class="math">\\mathcal{V}:\\{\\text{VerCommit}(\\mathsf{cvk},c_{y_j},y_j,o_{y_j})\\}_{j = 1}^m</span>  ; VerCommit(cvk,  <span class="math">c_{0},t_{0},o_{0})</span> 26:  <span class="math">\\mathcal{V}:(c_y^<em>,o_y^</em>)\\gets \\mathsf{ComVal}(\\mathsf{ck},\\tilde{V}_y(\\pmb {r}_d))</span>  where MLE  <span class="math">(V_{y}(j) = y_{j}) = \\tilde{V}_{y}</span> 27:  <span class="math">\\mathcal{V}\\to \\mathcal{P}:o_y^<em></span> 28:  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}\\big(\\mathsf{ck},(c_y^</em>,c_d);(\\tilde{V}_y(\\pmb {r}_d),o_y^*,o_d)\\big)</span></p>

    <p class="text-gray-300">Figure 18: Thaler's tree of multiplications over homomorphic commitment schemes. Main differences from  <span class="math">\\left[\\mathrm{ZGK}^{+}17\\mathrm{b}\\right.</span> , Construction 3] in blue</p>

    <p class="text-gray-300">SuccinctZK - TTM :</p>

    <p class="text-gray-300">Preprocessing: generate the commitment key</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{ck},\\mathsf{cvk})\\gets \\mathsf{PolyCom.Setup}(1^{\\lambda})</span>  for m-variate multilinear polynomials.</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{ek},\\mathsf{vk})\\gets \\mathsf{CP}_{\\mathsf{poly}}.</span>  KeyGen(ck)</p>

    <p class="text-gray-300">Evaluation: on common input  <span class="math">(c_y, c_z)</span> ;  <span class="math">\\mathcal{P}</span>  input  <span class="math">(z, \\tilde{y}, o_y)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}:\\mathrm{CheckCom}(\\mathsf{vk},c_y)\\wedge \\mathrm{CheckCom}(\\mathsf{vk},c_z)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P},\\mathcal{V}</span>  : Execute  <span class="math">\\mathsf{TTM}^{\\mathsf{Com}}</span>  until line 23 :</p>

    <p class="text-gray-300">Both hold  <span class="math">\\pmb{r}_d, c_d; \\mathcal{P}</span>  holds an opening  <span class="math">o_d</span>  of  <span class="math">\\tilde{V}_d(\\pmb{r}_d) = \\tilde{y}(\\pmb{r}_d)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}\\to \\mathcal{V}:\\pi_y\\gets \\mathsf{CP}_{\\mathsf{poly}}.</span>  Prove  <span class="math">(\\mathsf{ek},\\pmb {r}_d,(c_y,c_d),(\\tilde{y},\\tilde{y} (\\pmb {r}_d)),(o_y,o_d))</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}:\\mathsf{CP}_{\\mathsf{poly}}.\\mathsf{VerProof}(\\mathsf{vk},\\pmb {r}_d,c_{\\tilde{V}_d},c_d,\\pi_d)</span></p>

    <p class="text-gray-300">Figure 19: Succinct zero-knowledge argument for  <span class="math">\\mathsf{TTM}^{\\mathsf{Com}}</span></p>

    <p class="text-gray-300">A Succinct Zero Knowledge Argument for  <span class="math">R^{\\mathrm{prd}}</span> . In Figure 19 we give the succinct version of the protocol  <span class="math">\\mathsf{TTM}^{\\mathsf{Com}}</span>  presented in Figure 18. The protocol is almost identical to Construction 4 in [ZGK+17b] except for a few simplifications due to the fact that in our case the input and output of the circuit are assumed to be already committed and these commitments are known to the verifier, and that all the input is committed (i.e., there is no public input). Basically, the idea is that prover and verifier run the  <span class="math">\\mathsf{TTM}^{\\mathsf{Com}}</span>  protocol until they get to the end of the last round (line 23). Then the last lines of  <span class="math">\\mathsf{TTM}^{\\mathsf{Com}}</span> , in which the prover opens the commitments to input and output and the verifier gets convinced that  <span class="math">c_{d}</span>  opens to  <span class="math">\\tilde{y}(\\boldsymbol{r}_{d})</span> , are replaced with a step that does the same: the prover uses  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  to prove that  <span class="math">c_{d}</span>  opens to  <span class="math">\\tilde{y}(\\boldsymbol{r}_{d})</span>  with respect to the commitment  <span class="math">c_{y}</span> . For the polynomial commitments and the proof system for their evaluations we use our notation of Section F.</p>

    <p class="text-gray-300">EFFICIENCY. Our  <span class="math">\\mathsf{CP}_{\\mathsf{ipd}}</span>  is a succinct zero-knowledge argument for  <span class="math">R^{\\mathsf{prd}}</span>  that uses a variant of Thaler's protocol for trees of multiplications [Tha13] over homomorphic commitment schemes [ZGK+17b, Construction 4]. Here, we compute a proof of the product of the elements of a vector  <span class="math">\\pmb{y} \\in \\mathbb{F}^{m}</span>  where  <span class="math">m = 2^{\\mu}</span> . This is encoded as a depth- <span class="math">\\mu</span>  circuit  <span class="math">C</span>  of size  <span class="math">S = (m - 1)</span>  with  <span class="math">m</span>  inputs and 1 output element. By the regularity of the circuit, here the number of gates of each layer is double the size of the previous one  <span class="math">S_{i} = 2S_{i - 1}</span> , meaning that  <span class="math">\\log S_{i + 1} = s_{i + 1} = s_i + 1</span>  where  <span class="math">s_i</span>  is the number of variables of the target polynomial at layer  <span class="math">i</span> . Since the polynomial used inside  <span class="math">\\mathsf{CP}_{\\mathsf{sc}}</span>  is a product of three polynomials, each of its  <span class="math">s_i</span>  variables will be at most degree 3. Considering that the output layer has an only gate, then the sum for the whole circuit of the number of variables of all target polynomials can be computed as  <span class="math">\\sum_{i = 0}^{\\mu -1}s_i = \\sum_{i = 0}^{\\mu -1}i = \\frac{\\mu^2 - \\mu}{2}</span> . The SuccinctZK - TTM construction shows that the proof consists of  <span class="math">(\\frac{\\mu^2 - \\mu}{2} +3\\mu)</span> <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  proofs,  <span class="math">\\mu</span> <span class="math">\\mathsf{CP}_{\\mathsf{prd}}</span>  proofs, 1  <span class="math">\\mathsf{CP}_{\\mathsf{poly}}</span>  proofs and  <span class="math">\\frac{5\\mu^2 - \\mu}{2}</span>  commitments. The prover requires linear time in the circuit size and the verifier runs in quadratic time in the circuit depth. Its crs has length  <span class="math">(2\\cdot 2^{\\mu} + 3)\\mathbb{G}_1 + (\\mu +3)\\mathbb{G}_2</span> . We refer the reader to Table 2 for a summary.</p>

    <p class="text-gray-300">In this section we give details supporting our claims of Section 3.4.</p>

    <p class="text-gray-300">Background on Quadratic Arithmetic Programs. Since several of the SNARKs considered in this section rely on quadratic arithmetic programs [GGPR13] here we recall this notion.</p>

    <p class="text-gray-300"><strong>Definition H.1 (QAP [GGPR13]).</strong> A Quadratic Arithmetic Program (QAP) <span class="math">\\mathcal{Q} = (\\mathcal{A},\\mathcal{B},\\mathcal{C},t(Z))</span> of size <span class="math">m</span> and degree <span class="math">d</span> over a finite field <span class="math">\\mathbb{F}</span> is defined by three sets of polynomials <span class="math">\\mathcal{A} := \\{a_i(Z)\\}_{i=0}^m, \\mathcal{B} := \\{b_i(Z)\\}_{i=0}^m, \\mathcal{C} := \\{c_i(Z)\\}_{i=0}^m</span> of degree <span class="math">\\leq d - 1</span>, and a target degree-<span class="math">d</span> polynomial <span class="math">t(Z)</span>. Given <span class="math">\\mathcal{Q}</span> we define a relation <span class="math">R_{\\mathcal{Q}}</span> over pairs <span class="math">(\\boldsymbol{x},\\boldsymbol{w}) \\in \\mathbb{F}^n \\times \\mathbb{F}^{m-n}</span> that holds iff there exists a polynomial <span class="math">h(X)</span> (of degree at most <span class="math">d - 2</span>) such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{k=0}^{m} y_k \\cdot a_k(Z)\\right) \\cdot \\left(\\sum_{k=0}^{m} y_k \\cdot b_k(Z)\\right) = \\left(\\sum_{k=0}^{m} y_k \\cdot c_k(Z)\\right) + h(Z) t(Z) \\tag{9}</span></div>

    <p class="text-gray-300">where <span class="math">y_0 = 1</span>, <span class="math">y_k = x_k</span> for all <span class="math">k = 1</span> to <span class="math">n</span>, and <span class="math">y_k = w_{k-n}</span> for <span class="math">k = n + 1</span> to <span class="math">m</span>.</p>

    <h2 id="sec-87" class="text-2xl font-bold">H.1 “Adaptive Pinocchio” [Vee17]</h2>

    <p class="text-gray-300">The Adaptive Pinocchio scheme proposed in [Vee17] yields a CP-SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(\\boldsymbol{x}, \\boldsymbol{u}, \\boldsymbol{\\omega})</span>. First, note that [Vee17] already presents the scheme as a commit-and-prove SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{\\ell}, \\boldsymbol{\\omega})</span>, and for an extractable trapdoor commitment scheme, which is the one proposed by Groth in [Gro10]. Second, observe that the commitment key consists of two vectors <span class="math">\\boldsymbol{S} := [1, s, s^2, \\ldots, s^d]_1</span>, <span class="math">\\boldsymbol{S}&#x27; := [\\alpha, \\alpha s, \\alpha s^2, \\ldots, \\alpha s^d]_2</span>, for random <span class="math">s, \\alpha \\gets \\mathbb{Z}_q</span>, and the commitment to <span class="math">\\boldsymbol{u}_j</span> is a pair <span class="math">(C, C&#x27;) = (r, \\boldsymbol{u}_j^\\top) \\cdot (\\boldsymbol{S}, \\boldsymbol{S}&#x27;)</span>. To see how this implies a CP-SNARK for <span class="math">R_{\\mathcal{Q}}(\\boldsymbol{x}, \\boldsymbol{u}, \\boldsymbol{\\omega})</span>, consider <span class="math">\\ell = 2</span> so that the first input <span class="math">\\boldsymbol{u}_1</span> is used for the public input <span class="math">\\boldsymbol{x}</span> (the corresponding commitment can be a dummy one) and the second one for the actual committed value <span class="math">\\boldsymbol{u}</span>. Also, to fit our syntax let <span class="math">C</span> be the actual commitment whereas <span class="math">C&#x27;</span> is part of the proof.</p>

    <h2 id="sec-88" class="text-2xl font-bold">H.2 Lipmaa’s Hadamard Product Argument [Lip16]</h2>

    <p class="text-gray-300">The product argument proposed by Lipmaa in [Lip16] is a commit-and-prove SNARK for the Hadamard product relation <span class="math">R^{\\mathsf{had}}(\\boldsymbol{a}, \\boldsymbol{b}, \\boldsymbol{c})</span>. In this case the commitment key <span class="math">\\mathsf{ck}</span> are two vectors <span class="math">\\boldsymbol{S} := [Z(\\chi), \\ell_1(\\chi), \\ldots, \\ell_m(\\chi)]_1^\\top</span> and <span class="math">\\boldsymbol{S}&#x27; := [\\gamma Z(\\chi), \\gamma \\ell_1(\\chi), \\ldots, \\gamma \\ell_m(\\chi)]_2^\\top</span>, for random <span class="math">\\chi, \\gamma \\gets \\mathbb{Z}_q</span>, where, for <span class="math">m</span> a power of two and <span class="math">\\omega</span> the <span class="math">m</span>-th root of unity modulo <span class="math">q</span>, <span class="math">Z(X) = \\prod_{i=1}^{m} (X - \\omega^{i-1})</span> and <span class="math">\\ell_i(X)</span> is the <span class="math">i</span>-th Lagrange basis polynomial (such distribution of <span class="math">\\mathsf{ck}</span> guarantees binding under the <span class="math">m</span>-PDL assumption [Lip12, Lip16]). A commitment to <span class="math">\\boldsymbol{a}</span> is a pair <span class="math">(A_1, A_2) = (r_a, \\boldsymbol{a}^\\top) \\cdot (\\boldsymbol{S}, \\boldsymbol{S}&#x27;)</span> (and similarly to <span class="math">\\boldsymbol{b}, \\boldsymbol{c}</span>). As in the previous section, to fit our CP-SNARK syntax we can think of <span class="math">A_1, B_1, C_1</span> as the actual commitments and let their “knowledge components” as part of the proof.</p>

    <h2 id="sec-89" class="text-2xl font-bold">H.3 zk-vSQL [ZGK⁺17b]</h2>

    <p class="text-gray-300">The zk-vSQL protocol [ZGK⁺17b] is a CP-SNARK for relations <span class="math">R((u_j)_{j \\in [\\ell]})^{27}</span> where <span class="math">R</span> is an arithmetic circuit (that we assume to output some constant, e.g., 0, on acceptance), and for the commitment scheme PolyCom introduced in [ZGK⁺17b] and recalled in Appendix E.²⁸ The commit and prove capability is immediate by the construction and security of [ZGK⁺17b]. In what follows</p>

    <p class="text-gray-300">²⁷ Precisely, although the scheme in [ZGK⁺17b] is described with a single <span class="math">u</span>, the same technique used in its predecessor [ZGK⁺17a] trivially allows to let it work with multiple commitments.</p>

    <p class="text-gray-300">²⁸ Here we are considering the non-interactive version in the random oracle model obtained after applying the Fiat-Shamir transform.</p>

    <p class="text-gray-300">69</p>

    <p class="text-gray-300">we observe that their commitments can also be seen as a variant of extended Pedersen commitment. This observation is crucial to see that we can apply our lifting transformation using our <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> scheme to zk-vSQL. Let us recall that for an input <span class="math">\\pmb{u} \\in \\mathbb{Z}_q^m</span> (for some <span class="math">m = 2^\\mu</span>), its commitment is <span class="math">\\mathsf{ComPoly}(\\mathsf{ck}, \\tilde{u})</span> where <span class="math">\\tilde{u}</span> is the multilinear extension of <span class="math">\\pmb{u}</span> (cf. Section 5.1 about multilinear extensions). In particular, such MLE is the following <span class="math">\\mu</span>-variate multilinear polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {u} (X _ {1}, \\dots , X _ {\\mu}) = \\sum_ {i = 0} ^ {m - 1} \\chi_ {i} (X _ {1}, \\dots , X _ {\\mu}) \\cdot u _ {i + 1}</span></div>

    <p class="text-gray-300">Since <span class="math">c</span> returned by <span class="math">\\mathsf{ComPoly}(\\mathsf{ck},\\tilde{u},\\rho)</span> is defined as <span class="math">[\\tilde{u} (s_1,\\ldots ,s_\\mu) + \\rho s_{\\mu +1}]_1</span> and the common reference string includes the monomials <span class="math">[\\prod_{j\\in W}s_j]_1</span> for all possible subsets of indices <span class="math">W</span> needed to evaluate such a <span class="math">\\tilde{u}</span>, <span class="math">c</span> can also be seen as a Pedersen commitment <span class="math">c = (\\rho ,u^{\\top})\\cdot [s_{\\mu +1},\\chi_0(s_1,\\dots ,s_\\mu),\\dots,</span> <span class="math">\\chi_{m - 1}(s_1,\\ldots ,s_\\mu)]_1^\\top = (\\rho ,u^\\top)\\cdot \\mathsf{ck}</span>, where the elements <span class="math">[\\chi_i(s_1,\\ldots ,s_\\mu)]_1</span> can be publicly computed from the existing key. Note that this commitment is binding. This can be seen via a simple reduction to the soundness of the polynomial delegation protocol in [ZGK+17b]. The idea is that from an adversary that opens the commitment to two different polynomials <span class="math">\\tilde{u}_1,\\tilde{u}_2</span> one can sample a random <span class="math">t</span> such that with overwhelming probability <span class="math">y_{1} = \\tilde{u}_{1}(t)\\neq \\tilde{u}_{2}(t) = y_{2}</span>, honestly compute a proof for the evaluation of <span class="math">y_{1} = \\tilde{u}_{1}(t)</span> and then claim this is an evaluation for <span class="math">\\tilde{u}_2(t)</span>.</p>

    <h2 id="sec-90" class="text-2xl font-bold">H.4 Geppetto [CFH+15]</h2>

    <p class="text-gray-300">The Geppetto scheme [CFH+15] yields a cc-SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(\\pmb{x}, \\pmb{w})</span> where <span class="math">\\pmb{x} \\in \\mathbb{Z}_q^n</span> and <span class="math">\\pmb{w} = (\\pmb{u}, \\pmb{\\omega})</span> with <span class="math">\\pmb{u} \\in \\mathbb{Z}_q^{n&#x27;}</span>, <span class="math">\\pmb{\\omega} \\in \\mathbb{Z}_q^{m - n - n&#x27;}</span> for some integers <span class="math">n, n&#x27;</span>. We recall that Geppetto is a SNARK for MultiQAP relations. A polynomial MultiQAP is a tuple <span class="math">\\mathcal{MQ} = (\\ell, \\mathcal{J}, \\mathcal{A}, \\mathcal{B}, \\mathcal{C}, t(Z))</span> such that <span class="math">(\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, t(Z))</span> is a QAP, and <span class="math">\\mathcal{J} = \\{I_0, \\dots, I_{\\ell - 1}\\}</span> is a partition of <span class="math">[m]</span>. Let <span class="math">R_{\\mathcal{MQ}}</span> denote the relation corresponding to <span class="math">\\mathcal{MQ}</span>. To model <span class="math">R_{\\mathcal{Q}}(\\pmb{x}, \\pmb{u}, \\pmb{\\omega})</span> we consider a MultiQAP where <span class="math">\\ell = 3</span> and where the partition <span class="math">\\mathcal{J}</span> consists of <span class="math">I_0 = [n]</span>, <span class="math">I_1 = \\{n + 1, \\dots, n + n&#x27;\\}</span> and <span class="math">I_2 = \\{n + n&#x27; + 1, \\dots, m\\}</span> such that <span class="math">I_0</span> and <span class="math">I_1</span> are in the binding subset <span class="math">S</span>.</p>

    <p class="text-gray-300">To see how Geppetto yields a cc-SNARK for such family of relations, we consider the following straightforward modification:</p>

    <p class="text-gray-300">ccGep.KeyGen <span class="math">(R_{\\mathcal{Q}})\\to (\\mathsf{ck},\\mathsf{ek},\\mathsf{vk})</span>: run <span class="math">(EK,VK)\\gets</span> Geppetto.KeyGen <span class="math">(R_{\\mathcal{MQ}})</span>; set <span class="math">\\mathsf{ek} = EK</span>, <span class="math">\\mathsf{vk} = VK</span> and let <span class="math">\\mathsf{ck}</span> be a subset of <span class="math">EK</span> consisting of <span class="math">[r_y t(s),r_c c_{n + 1}(s),\\ldots ,r_c c_{n + n&#x27;}(s)]_1^\\top \\in \\mathbb{G}_1^{n&#x27; + 1}</span>.</p>

    <p class="text-gray-300">ccGep.VerCommit(ck, c, u, o) → b: output 1 iff <span class="math">(o, \\boldsymbol{u}^{\\top}) \\cdot \\mathsf{ck} = c</span>.</p>

    <p class="text-gray-300">ccGep.Prove(ek, x, u, ω) → (c, π; o):</p>

    <p class="text-gray-300">Compute commitments:</p>

    <p class="text-gray-300"><span class="math">C_0\\gets</span> Geppetto.Commit <span class="math">(EK_{0},\\pmb {x},0)</span> <span class="math">C_1\\gets</span> Geppetto.Commit <span class="math">(EK_{1},\\pmb {u},o_{1})</span> <span class="math">C_2\\gets</span> Geppetto.Commit <span class="math">(EK_{2},\\pmb {\\omega},o_{2})</span></p>

    <p class="text-gray-300">Compute the proof <span class="math">\\pi^{\\prime}\\gets</span> Geppetto.Prove <span class="math">(EK,(\\pmb {x},\\pmb {u},\\pmb {\\omega}),(0,o_1,o_2))</span></p>

    <p class="text-gray-300">Parse <span class="math">C_1</span> as <span class="math">(C_{1,1},C_{1,\\alpha},C_{1,\\beta})\\in \\mathbb{G}_1^3</span></p>

    <p class="text-gray-300">Output <span class="math">c = C_{1,1}</span>, <span class="math">\\pi = (C_{1,\\alpha}, C_{1,\\beta}, C_2, \\pi&#x27;)</span>, and <span class="math">o = o_1</span>.</p>

    <p class="text-gray-300">ccΠ.VerProof(vk, x, c, π) → b: recompute <span class="math">C_0 \\gets</span> Geppetto.Commit <span class="math">(EK_0, \\pmb{x}, 0)</span>; reconstruct <span class="math">C_1 \\gets (c, C_{1,\\alpha}, C_{1,\\beta})</span>; check Geppetto.Verify <span class="math">(VK_j, C_j)_{j=1,2}</span>; check Geppetto.Verify <span class="math">(VK, C_0, C_1, C_2, \\pi&#x27;)</span>.</p>

    <p class="text-gray-300">Setting randomness 0 here is essentially a trick to let this commitment correspond to the public input of the relation.</p>

    <p class="text-gray-300">We claim that assuming Geppetto is a commit-and-prove SNARK for MultiQAPs (according to the commit-and-prove definition in  <span class="math">\\mathrm{[CFH^{+}15]}</span> ), then the scheme ccGep described above is a cc-SNARK for QAP relations  <span class="math">R_{\\mathcal{Q}}(\\pmb {x},\\pmb {u},\\pmb {\\omega})</span></p>

    <p class="text-gray-300">The correctness of ccGep immediately follows from the one of Geppetto, and the same holds for knowledge soundness. Indeed, notice that the knowledge soundness satisfied by Geppetto provides extractability of the commitment's openings. The perfect zero-knowledge of ccGep follow from the zero-knowledge of Geppetto and the perfect hiding of its commitments. Finally, we observe that by Def. 10 in  <span class="math">\\mathrm{[CFH^{+}15]}</span>  the polynomials  <span class="math">\\{c_k(x)\\}_{k\\in I_1}</span>  are linearly independent; thus for a random  <span class="math">s</span> , the vector  <span class="math">[r_ct(s),r_cc_{n + 1}(s),\\ldots ,r_cc_{n + n&#x27;}(s)]_1</span>  defines a Pedersen commitment key whose distribution guarantees the binding property under the  <span class="math">d</span> -SDH assumption.</p>

    <p class="text-gray-300">In this section we show that the SNARK of [Gro16] is a weak cc-SNARK, and then that it can be modified to obtain efficient cc-SNARKs, one scheme with classical binding commitments and one scheme with double binding. Below we start by giving a background on non-interactive linear proofs, that are instrumental for presenting the scheme.</p>

    <p class="text-gray-300">Split Non-Interactive Linear Proofs of Degree 2. This notion, dubbed NILP for brevity, was introduced by Groth [Gro16] as a refinement of the linear interactive proofs defined in  <span class="math">\\mathrm{[BCI^{+}13]}</span> . A NILP is a triple of algorithms (LinSetup, ProofMatrix, Test) working as follows. LinSetup takes in a relation  <span class="math">R</span>  (e.g., a QAP) and outputs two vectors  <span class="math">\\sigma_{1}\\in \\mathbb{F}^{\\mu_{1}},\\sigma_{2}\\in \\mathbb{F}^{\\mu_{2}}</span> . ProofMatrix on input a relation  <span class="math">R</span>  and a pair  <span class="math">(x,w)</span>  outputs two matrices  <span class="math">(\\varPi_1,\\varPi_2)\\in \\mathbb{F}^{k_1\\times \\mu_1}\\times \\mathbb{F}^{k_2\\times \\mu_2}</span>  so that a proof  <span class="math">(\\pi_1,\\pi_2)</span>  is computed as  <span class="math">(\\varPi_1\\cdot\\sigma_1,\\varPi_2\\cdot\\sigma_2)</span> . Test on input a relation  <span class="math">R</span>  and a statement  <span class="math">x</span>  outputs a collection of matrices  <span class="math">T_{1},\\ldots T_{\\eta}\\in \\mathbb{F}^{(\\mu_{1} + k_{1})\\times (\\mu_{2} + k_{2})}</span>  such that a proof  <span class="math">(\\pi_1,\\pi_2)</span>  is accepted iff  <span class="math">(\\sigma_1^\\top ,\\pi_1^\\top)\\cdot T_i\\cdot (\\sigma_2^\\top ,\\pi_2^\\top) = 0</span>  for all  <span class="math">i = 1</span>  to  <span class="math">\\eta</span> . A NILP is required to satisfy completeness, statistical knowledge soundness and zero-knowledge. Informally, completeness says that honestly computed proofs for true statements are accepted. Knowledge soundness says that there must exist an extractor algorithm that on input  <span class="math">R,x</span>  and a prover strategy  <span class="math">(\\varPi_1,\\varPi_2)</span>  outputs a witness  <span class="math">w</span>  such that the probability that  <span class="math">(\\varPi_1\\cdot\\sigma_1,\\varPi_2\\cdot\\sigma_2)</span>  is accepted while  <span class="math">R(x,w) = 0</span>  is negligible (over the random choices of LinSetup). Finally, (perfect) zero-knowledge states requires to show a simulator that with knowledge of  <span class="math">(\\sigma_{1},\\sigma_{2},R,x)</span> ) outputs proofs  <span class="math">(\\pi_1,\\pi_2)</span>  that have the same distribution as honestly generated ones.</p>

    <p class="text-gray-300">Groth's zkSNARK [Gro16] is a weak cc-SNARK for QAP relations  <span class="math">R_{\\mathcal{Q}}(\\pmb{u})</span> . First, we recall the scheme from [Gro16]: this scheme is obtained by instantiating the generic pairing-based construction of Figure 20 with the Non-Interactive Linear Proof (NILP) in Figure 21.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 20: Groth's generic SNARK in asymmetric groups from a split NILP.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Figure 21: Groth's NILP for a QAP relation  <span class="math">R_{\\mathcal{Q}}(\\pmb{x}, \\pmb{w})</span> .</p>

    <p class="text-gray-300">Recall that for our claim we only consider the case of QAP relations where  <span class="math">\\pmb{x}</span>  is void and the witness is  <span class="math">\\pmb{w} = \\pmb{u}</span>  (i.e., the commitment is to the entire witness). This is enough to instantiate our compiler of Section 3.5. To see why this scheme is a weak cc-SNARK for QAP relations  <span class="math">R_{\\mathcal{Q}}(\\pmb{u})</span>  we make the following observations.</p>

    <p class="text-gray-300">First, let the commitment  <span class="math">c</span>  to  <span class="math">\\pmb{u}</span>  be the value  <span class="math">[A]_1 = r[\\delta]_1 + \\sum_{k=0}^m u_k \\cdot [a_k(\\tau)]_1 + [\\alpha]_1</span> ; this means that  <span class="math">\\mathsf{ck}</span>  is  <span class="math">[\\delta, \\{a_k(\\tau)\\}, \\alpha]_1</span>  where  <span class="math">\\alpha, \\delta, \\tau</span>  are random. Second, for knowledge soundness we observe that from the existing security proof we can also extract the opening  <span class="math">r</span>  of  <span class="math">[A]_1</span> . What is left to argue is the binding of such commitment. Since the  <span class="math">\\{a_k(Z)\\}_k</span>  polynomials are not necessarily linearly independent (see, e.g., [Par15]) the commitment key  <span class="math">\\mathsf{ck}</span>  does not guarantee binding. However, we can show as follows that the scheme satisfies weak binding. In a nutshell, this means that it is computationally infeasible to open  <span class="math">[A]_1</span>  to two different witnesses  <span class="math">\\pmb{u}</span>  and  <span class="math">\\pmb{u}&#x27;</span>  with  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}) \\neq R_{\\mathcal{Q}}(\\pmb{u}&#x27;)</span> .</p>

    <p class="text-gray-300">Notice that from the two different valid openings  <span class="math">(\\pmb{u}, r)</span>  and  <span class="math">(\\pmb{u}&#x27;, r&#x27;)</span>  of  <span class="math">[A]_1</span>  we can easily rule out two cases. The first case is the one where  <span class="math">r \\neq r&#x27;</span> : this can be immediately reduced to finding the discrete log  <span class="math">\\delta</span> . The second case is the one when  <span class="math">r = r&#x27;</span>  and  <span class="math">\\sum_{k} (u_k - u_k&#x27;) a_k(Z)</span>  is a nonzero polynomial: this can be reduced to finding the discrete log  <span class="math">\\tau</span>  (which is known as PDL problem [Lip12]), as  <span class="math">\\tau</span>  can be computed by factoring this polynomial. Therefore we are left with the case when  <span class="math">\\sum_{k} (u_k - u_k&#x27;) a_k(Z)</span>  is the zero polynomial, yet  <span class="math">\\pmb{u} \\neq \\pmb{u}&#x27;</span> . We argue that it cannot be that  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}) \\neq R_{\\mathcal{Q}}(\\pmb{u}&#x27;)</span> . Indeed, the existing proof [Gro16][Theorem 1] shows that equalities  <span class="math">A = \\alpha + r\\delta + \\sum_{k=0}^{m} C_k \\cdot a_k(\\tau)</span>  and  <span class="math">B = \\beta + s\\delta + \\sum_{k=0}^{m} C_k \\cdot b_j(\\tau)</span>  hold, where  <span class="math">\\{C_k\\}_{k=0}^m</span>  are the same coefficients of the term  <span class="math">\\sum_{k=0}^{m} C_k \\cdot \\frac{\\alpha b_k(\\tau) + \\beta a_k(\\tau) + c_k(\\tau)}{\\delta}</span>  in  <span class="math">C</span> . Therefore, if the commitment  <span class="math">A</span>  opens to  <span class="math">\\pmb{u}&#x27;</span>  then it must be the case that  <span class="math">C_k = u_k&#x27;</span> , but in this case the QAP would be satisfied (i.e.,  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}&#x27;) = 1</span> ) contradicting that  <span class="math">u&#x27;</span>  is an invalid witness for  <span class="math">R_{\\mathcal{Q}}</span> .</p>

    <p class="text-gray-300">|  LinSetup(RQ) → (σ1, σ2)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  α, β, γ, δ, η, τ ←$ F*  |</p>

    <p class="text-gray-300">|  σ1 := (1, α, β, δ, {τi}d-1i=1, {βai(τ) + αbi(τ) + ci(τ)/γ}n, η/γ, {βai(τ) + αbi(τ) + ci(τ)/δ}m i=n+1, {1/δτi t(τ)}d-2i=0, η/δ)  |</p>

    <p class="text-gray-300">|  σ2 := (1, β, γ, δ, {τi}d-1i=0)  |</p>

    <p class="text-gray-300">|  ProofMatrix(RQ, w) → (Π1, Π2)  |</p>

    <p class="text-gray-300">|  Let w := (u, ω). Compute h(Z) as in (9); r, s, v ←$ F  |</p>

    <p class="text-gray-300">|  Let Π1 ∈ F3×(m+2d+6), Π2 ∈ F1×(d+4) s.t. (A, C, D)T = Π1 · σ1, B = Π2 · σ2 and  |</p>

    <p class="text-gray-300">|  A := α + ∑m k=0wk · ak(τ) + rδ ; B := β + ∑m k=0wk · bk(τ) + sδ ; D := ∑m k=0wk · 1/γ(βak(τ) + αbk(τ) + ck(τ)) + v/γ  |</p>

    <p class="text-gray-300">|  C := ∑m k=n+1wk · βak(τ) + αbk(τ) + ck(τ)/δ - v/δ + ∑m k=0d-2hi τi t(τ)/δ + As + Br - rsδ  |</p>

    <p class="text-gray-300">|  Test(RQ) → T  |</p>

    <p class="text-gray-300">|  Define T ∈ F(m+2d+9)×(d+5) encoding the following quadratic test: A · B = α · β + C · δ + D · γ  |</p>

    <p class="text-gray-300">Figure 22: Our NILP for an augmented QAP relation  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}, \\pmb{\\omega})</span> , to be used to obtain ccGro16.</p>

    <p class="text-gray-300">A new cc-SNARK with double binding for QAP relations  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}, \\pmb{\\omega})</span> . Here we show how we can modify the zkSNARK of [Gro16] in order to obtain a cc-SNARK with double binding for proving the satisfiability of QAP relations of the form  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}, \\pmb{\\omega})</span> , that is a scheme where there is a binding commitment to a portion,  <span class="math">\\pmb{u}</span> , of the witness and where the public input is void.[30]</p>

    <p class="text-gray-300">In our construction we consider an augmented QAP (in the sense of [BCTV14]), which is a QAP as in Definition H.1 with the additional property that the polynomials  <span class="math">a_{k}(X)</span>  for  <span class="math">k = 0</span>  to  <span class="math">n</span>  are linearly independent.</p>

    <p class="text-gray-300">Our new cc-SNARK, called ccGro16, is the scheme obtained by instantiating the generic SNARK construction of [Gro16] recalled in Figure 20 with the NILP that we describe in Figure 22. To match the cc-SNARK syntax we let the commitment be the proof element  <span class="math">[D]_1</span> , which can be seen as a Pedersen commitment for the key  <span class="math">\\mathsf{ck} = [\\frac{\\eta}{\\gamma}, \\{\\frac{1}{\\gamma} (\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau))\\}_{i=0}^n]_1</span> , and whose corresponding VerCommit algorithm is:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {V e r C o m m i t} (\\mathsf {c k}, [ D _ {1} ], \\boldsymbol {u}, o) := [ D ] _ {1} \\stackrel {?} {=} \\sum_ {k = 0} ^ {n} u _ {k} \\cdot \\left[ \\frac {1}{\\gamma} \\left(\\beta a _ {k} (\\tau) + \\alpha b _ {k} (\\tau) + c _ {k} (\\tau)\\right) \\right] _ {1} + o \\cdot \\left[ \\frac {\\eta}{\\gamma} \\right] _ {1} \\tag {10}</span></div>

    <p class="text-gray-300">By the linear independence of the  <span class="math">a_{i}(Z)</span>  polynomials the binding of this commitment can be reduced to the PDL assumption.</p>

    <p class="text-gray-300">For the double binding property, we instead consider an algorithm <span class="math">\\mathsf{VerCommit}^{<em>}([\\boldsymbol{\\sigma}_{1}]_{1},[D_{1}],\\boldsymbol{u},\\boldsymbol{o}^{</em>})</span> that parses <span class="math">\\boldsymbol{o}^{*}:=(o_{\\alpha},o_{\\delta},o_{\\tau,0},\\ldots,o_{\\tau,d-1},o^{\\prime})</span> and outputs 1 iff</p>

    <p class="text-gray-300"><span class="math">[D]_{1}\\stackrel{{\\scriptstyle?}}{{=}}o_{\\alpha}\\cdot[\\alpha]_{1}+o_{\\delta}\\cdot[\\delta]_{1}+\\sum_{i=0}^{d-1}o_{\\tau,i}\\cdot[\\tau^{i}]_{1}+\\sum_{k=0}^{n}u_{k}\\cdot\\left[\\frac{1}{\\gamma}(\\beta a_{k}(\\tau)+\\alpha b_{k}(\\tau)+c_{k}(\\tau))\\right]_{1}+o^{\\prime}\\cdot\\left[\\frac{\\eta}{\\gamma}\\right]_{1}</span></p>

    <p class="text-gray-300">To see the binding property (ii) of Definition 3.4 we observe that from an opening <span class="math">o</span> of <span class="math">[D]_{1}</span> to <span class="math">\\boldsymbol{u}</span> under <span class="math">\\mathsf{VerCommit}</span>, and an opening <span class="math">\\boldsymbol{o}^{<em>}</span> of the same <span class="math">[D]_{1}</span> to <span class="math">\\boldsymbol{u}^{\\prime}\\neq\\boldsymbol{u}</span> under <span class="math">\\mathsf{VerCommit}^{</em>}</span> we obtain</p>

    <p class="text-gray-300"><span class="math">o_{\\alpha}\\cdot[\\alpha]_{1}+o_{\\delta}\\cdot[\\delta]_{1}+\\sum_{i=0}^{d-1}o_{\\tau,i}\\cdot[\\tau^{i}]_{1}+\\sum_{k=0}^{n}(u_{k}^{\\prime}-u_{k})\\cdot\\left[\\frac{\\beta a_{k}(\\tau)+\\alpha b_{k}(\\tau)+c_{k}(\\tau)}{\\gamma}\\right]_{1}+(o^{\\prime}-o)\\cdot\\left[\\frac{\\eta}{\\gamma}\\right]_{1}=[0]_{1}</span></p>

    <p class="text-gray-300">which can be reduced to the PDL assumption.</p>

    <p class="text-gray-300">Correctness and knowledge soundness of ccGro16 follow from the proof of the generic construction in <em>[x10]</em>, assuming that the construction in Figure 22 is a NILP. In particular, in order to obtain the knowledge soundness (i) of Definition 3.4 we show that the NILP extractor also returns an “opening” of <span class="math">D</span> under <span class="math">\\mathsf{VerCommit}^{*}</span>, that is a collection of field elements</p>

    <p class="text-gray-300"><span class="math">\\{D_{\\alpha},D_{\\delta},D_{0},\\ldots,D_{d-1},D_{\\gamma,0},\\ldots,D_{\\gamma,n},D_{\\eta/\\gamma}\\}\\text{ such that }</span> <span class="math">D=D_{\\alpha}\\cdot\\alpha+D_{\\delta}\\cdot\\delta+\\sum_{i=0}^{d-1}D_{i}\\cdot\\tau^{i}+\\sum_{i=0}^{n}D_{\\gamma,i}\\cdot\\frac{\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau)}{\\gamma}+D_{\\eta/\\gamma}\\cdot\\frac{\\eta}{\\gamma}</span> (11)</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Remark H.1.</h6>

    <p class="text-gray-300">An earlier version of Theorem H.1 incorrectly claimed that the ccGro16 scheme is a cc-SNARK with respect to the <span class="math">\\mathsf{VerCommit}</span> algorithm described above. We thank Chris Peikert and Xiong (Leo) Fan who spotted this flaw, noticing that an adversary may generate a malformed commitment <span class="math">[D]_{1}</span> which also includes other elements (e.g., <span class="math">\\alpha</span>). It is interesting to note that in spite of this flaw, our applications of ccGro16, notably the LegoGroth16 CP-SNARK, remain unaffected as our lifting compiler includes a proof that the cc-SNARK commitment must be correct and thus prevents this attack. In this version of the paper, we formalized this property via the following changes: we define the notion of cc-SNARKs with double binding (Section 3.3), we show that our lifting transformation also works with cc-SNARKs satisfying this notion (Theorem 3.2), and we show here that ccGro16 is a cc-SNARK with double binding. For completeness, later in the next section we also present a variant of ccGro16, called ccGro16*, which, at the price of one more group element in the proof and one more verification equation, satisfies the cc-SNARK knowledge soundness of Definition 3.2.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Theorem H.1.</h6>

    <p class="text-gray-300">The construction in Figure 22 is a NILP with perfect completeness, perfect zero-knowledge and statistical knowledge soundness against affine provers. In particular, the NILP extractor also returns coefficients <span class="math">\\{D_{\\alpha},D_{\\delta},D_{0},\\ldots,D_{d-1},D_{\\eta/\\gamma}\\}</span> such that (11) holds with overwhelming probability.</p>

    <p class="text-gray-300">Proof Perfect completeness is easy to verify. For perfect zero-knowledge, we define the simulator that samples <span class="math">A,B,D\\longleftrightarrow\\mathbb{F}</span> at random and then finds <span class="math">C</span> so that the verification test is satisfied. This shows that real and simulated proofs are identically distributed.</p>

    <p class="text-gray-300">For knowledge soundness, let <span class="math">(\\varPi_1,\\varPi_2)\\in \\mathbb{F}^{3\\times (m + 2d + 6)}\\times \\mathbb{F}^{1\\times (d + 4)}</span> be an affine prover strategy. From these matrices we can derive a set of field elements <span class="math">A_{\\alpha},A_{\\beta},A_{\\delta}</span> etc. such that we can write <span class="math">(A,C,D)^{\\top} = \\varPi_{1}\\cdot \\pmb{\\sigma}_{1},B = \\varPi_{2}\\cdot \\pmb{\\sigma}_{2}</span> in the following way:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} A = A _ {\\alpha} \\cdot \\alpha + A _ {\\beta} \\cdot \\beta + A _ {\\delta} \\cdot \\delta + A (\\tau) + \\sum_ {i = 0} ^ {n} A _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + A _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = n + 1} ^ {m} A _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + A _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + A _ {t} (\\tau) \\frac {t (\\tau)}{\\delta} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="my-4 text-center"><span class="math-block">B = B _ {\\beta} \\cdot \\beta + B _ {\\gamma} \\cdot \\gamma + B _ {\\delta} \\cdot \\delta + B (\\tau)</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} C = C _ {\\alpha} \\cdot \\alpha + C _ {\\beta} \\cdot \\beta + C _ {\\delta} \\cdot \\delta + C (\\tau) + \\sum_ {i = 0} ^ {n} C _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + C _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = n + 1} ^ {m} C _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + C _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + C _ {t} (\\tau) \\frac {t (\\tau)}{\\delta} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">$$ \\begin{array}{l} D = D _ {\\alpha} \\cdot \\alpha + D _ {\\beta} \\cdot \\beta + D _ {\\delta} \\cdot \\delta + D (\\tau) + \\sum_ {i = 0} ^ {n} D _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + D _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = n + 1} ^ {m} D _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + D _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + D _ {t} (\\tau) \\frac {t (\\tau)}{\\delta} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Let us define the NILP extractor as the algorithm that on input <span class="math">(\\varPi_1,\\varPi_2)</span> returns</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\omega} := (C _ {\\delta , n + 1}, \\dots , C _ {\\delta , m}), \\quad \\boldsymbol {u} := (D _ {\\gamma , 0}, \\dots , D _ {\\gamma , n}), \\quad \\boldsymbol {o} ^ {*} := (D _ {\\alpha}, D _ {\\delta}, D _ {0}, \\dots , D _ {d - 1}, D _ {\\eta / \\gamma})</span></div>

    <p class="text-gray-300">Once defined the extractor, we need to show that the probability that the proof verifies and the relation <span class="math">R_{\\mathcal{Q}}(\\boldsymbol{u}, \\boldsymbol{\\omega})</span> does not hold is negligible. This proof closely follows the one used for the NILP of [Gro16] with some differences related to extracting from <span class="math">D</span>.</p>

    <p class="text-gray-300">If we view the verification equation</p>

    <div class="my-4 text-center"><span class="math-block">A \\cdot B = \\alpha \\cdot \\beta + C \\cdot \\delta + D \\cdot \\gamma \\tag {12}</span></div>

    <p class="text-gray-300">as an equality over Laurent polynomials, then by the Schwartz-Zippel lemma, the prover has negligible probability of finding an affine strategy such that the equation holds for random <span class="math">\\alpha, \\beta, \\gamma, \\delta, \\eta, \\tau</span> but does not hold as an equality of polynomials, when viewing <span class="math">\\alpha, \\beta, \\gamma, \\delta, \\eta, \\tau</span> as indeterminates.</p>

    <p class="text-gray-300">Therefore we proceed by analyzing the polynomial identity in order to show that the extractor's output satisfies the QAP relation.</p>

    <p class="text-gray-300">75</p>

    <p class="text-gray-300">We start by looking at the term with <span class="math">\\alpha\\beta</span>, from which we get that <span class="math">A_{\\alpha} \\cdot B_{\\beta} = 1</span>. Without loss of generality one can rescale the proof elements <span class="math">A</span> and <span class="math">B</span> and obtain another proof with <span class="math">A_{\\alpha} = B_{\\beta} = 1</span>.</p>

    <p class="text-gray-300">Next, observe that on the right hand side of equation (12) we have <span class="math">\\alpha\\beta + C \\cdot \\delta + D \\cdot \\gamma</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} C \\cdot \\delta &amp;amp;= C_{\\alpha} \\cdot \\alpha \\delta + C_{\\beta} \\cdot \\beta \\delta + C_{\\delta} \\cdot \\delta^2 + C(\\tau) \\delta + \\sum_{i=0}^{n} C_{\\gamma,i} \\cdot \\frac{\\beta \\delta a_i(\\tau) + \\alpha \\delta b_i(\\tau) + c_i(\\tau) \\delta}{\\gamma} + C_{\\eta/\\gamma} \\cdot \\frac{\\delta \\eta}{\\gamma} \\\\ &amp;amp;\\quad + \\sum_{i=n+1}^{m} C_{\\delta,i} \\cdot \\left(\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)\\right) + C_{\\eta/\\delta} \\cdot \\eta + C_t(\\tau) t(\\tau) \\end{aligned}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} D \\cdot \\gamma &amp;amp;= D_{\\alpha} \\cdot \\alpha \\gamma + D_{\\beta} \\cdot \\beta \\gamma + D_{\\delta} \\cdot \\delta \\gamma + D(\\tau) \\gamma + \\sum_{i=0}^{n} D_{\\gamma,i} \\cdot \\left(\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)\\right) + D_{\\eta/\\gamma} \\cdot \\eta \\\\ &amp;amp;\\quad + \\sum_{i=n+1}^{m} D_{\\delta,i} \\cdot \\frac{\\beta \\gamma a_i(\\tau) + \\alpha \\gamma b_i(\\tau) + c_i(\\tau) \\gamma}{\\delta} + D_{\\eta/\\delta} \\cdot \\frac{\\eta \\gamma}{\\delta} + D_t(\\tau) t(\\tau) \\frac{\\gamma}{\\delta} \\end{aligned}</span></div>

    <p class="text-gray-300">Let us consider the following terms of <span class="math">A \\cdot B</span> and observe that they must be 0</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\beta \\left( \\sum_{i=0}^{n} A_{\\gamma,i} \\cdot \\frac{\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)}{\\gamma} + A_{\\eta/\\gamma} \\cdot \\frac{\\eta}{\\gamma} \\right. \\\\ \\left. + \\sum_{i=n+1}^{m} A_{\\delta,i} \\cdot \\frac{\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)}{\\delta} + A_{\\eta/\\delta} \\cdot \\frac{\\eta}{\\delta} + A_t(\\tau) \\frac{t(\\tau)}{\\delta} \\right) = 0 \\end{aligned}</span></div>

    <p class="text-gray-300">Hence we can simplify <span class="math">A = \\alpha + A_{\\beta} \\beta + A_{\\delta} \\cdot \\delta + A(\\tau)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">A \\cdot B = (\\alpha + A_{\\beta} \\beta + A_{\\delta} \\cdot \\delta + A(\\tau)) (\\beta + B_{\\gamma} \\cdot \\gamma + B_{\\delta} \\cdot \\delta + B(\\tau))</span></div>

    <p class="text-gray-300">By noticing that <span class="math">A \\cdot B</span> does not include any indeterminate in the denominator, we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n} C_{\\gamma,i} \\cdot \\frac{\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)}{\\gamma} + C_{\\eta/\\gamma} \\cdot \\frac{\\eta}{\\gamma} = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=n+1}^{m} D_{\\delta,i} \\cdot \\frac{\\beta a_i(\\tau) + \\alpha b_i(\\tau) + c_i(\\tau)}{\\delta} + D_{\\eta/\\delta} \\cdot \\frac{\\eta}{\\delta} = 0</span></div>

    <p class="text-gray-300">Recall that for extractor we defined <span class="math">\\boldsymbol{w} = (\\boldsymbol{u}, \\boldsymbol{\\omega})</span> where <span class="math">w_i = C_{\\delta,i}</span> for <span class="math">i = n+1</span> to <span class="math">m</span>, and <span class="math">w_i = D_{\\gamma,i}</span> for <span class="math">i = 0</span> to <span class="math">n</span>. Therefore <span class="math">AB - \\alpha\\beta - C\\delta - D\\gamma = 0</span> gives us</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} 0 &amp;amp;= \\alpha B(\\tau) + \\beta A(\\tau) - \\beta \\left( \\sum_{i=0}^{m} w_i \\cdot a_i(\\tau) \\right) - \\alpha \\left( \\sum_{i=0}^{m} w_i \\cdot b_i(\\tau) \\right) - \\sum_{i=0}^{m} w_i \\cdot c_i(\\tau) + A(\\tau) B(\\tau) \\\\ &amp;amp;\\quad + B_{\\gamma} \\cdot \\alpha \\gamma + B_{\\delta} \\cdot \\alpha \\delta + A_{\\delta} \\cdot \\beta \\delta + A_{\\delta} B_{\\gamma} \\cdot \\gamma \\delta + A_{\\delta} B_{\\delta} \\cdot \\delta^2 + A_{\\delta} B(\\tau) \\delta \\\\ &amp;amp;\\quad + A(\\tau) B_{\\gamma} \\cdot \\gamma + A(\\tau) B_{\\delta} \\cdot \\delta \\\\ &amp;amp;\\quad + A_{\\beta} \\beta^2 + A_{\\beta} B_{\\gamma} \\cdot \\beta \\gamma + A_{\\beta} B_{\\delta} \\cdot \\beta \\delta + A_{\\beta} B(\\tau) \\beta \\\\ &amp;amp;\\quad - C_{\\alpha} \\cdot \\alpha \\delta - C_{\\beta} \\cdot \\beta \\delta - C_{\\delta} \\cdot \\delta^2 - C(\\tau) \\delta - C_{\\eta/\\delta} \\cdot \\eta - C_t(\\tau) t(\\tau) \\\\ &amp;amp;\\quad - D_{\\alpha} \\cdot \\alpha \\gamma - D_{\\beta} \\cdot \\beta \\gamma - D_{\\delta} \\cdot \\delta \\gamma - D(\\tau) \\gamma - D_{\\eta/\\gamma} \\cdot \\eta \\tag{13} \\end{aligned}</span></div>

    <p class="text-gray-300">By considering the term involving <span class="math">\\beta^2</span> we get <span class="math">A_{\\beta} = 0</span>, and thus also <span class="math">A_{\\beta}\\beta^{2} + A_{\\beta}B_{\\gamma}\\cdot \\beta \\gamma +A_{\\beta}B_{\\delta}\\cdot \\beta \\delta +A_{\\beta}B(\\tau)\\beta = 0</span>. By considering the terms <span class="math">\\beta \\tau^i</span> and <span class="math">\\alpha \\tau^i</span> we get</p>

    <div class="my-4 text-center"><span class="math-block">A (\\tau) = \\sum_ {i = 0} ^ {m} w _ {i} \\cdot a _ {i} (\\tau), \\quad B (\\tau) = \\sum_ {i = 0} ^ {m} w _ {i} \\cdot b _ {i} (\\tau)</span></div>

    <p class="text-gray-300">By considering the term <span class="math">(A_{\\delta}B_{\\delta} - C_{\\delta})\\delta^{2} = 0</span> we get <span class="math">C_{\\delta} = A_{\\delta}B_{\\delta}</span>, and by considering the term <span class="math">(C_{\\eta /\\delta} + D_{\\eta /\\gamma})\\cdot \\eta = 0</span> we can conclude that <span class="math">C_{\\eta /\\delta} = -D_{\\eta /\\gamma}</span>.</p>

    <p class="text-gray-300">Therefore the equation (13) can be simplified as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot a _ {i} (\\tau)\\right) \\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot b _ {i} (\\tau)\\right) - \\sum_ {i = 0} ^ {m} w _ {i} \\cdot c _ {i} (\\tau) - C _ {t} (\\tau) t (\\tau) \\\\ + \\left(B _ {\\delta} A (\\tau) + A _ {\\delta} B (\\tau) - C (\\tau)\\right) \\delta + B _ {\\gamma} \\cdot \\alpha \\gamma + B _ {\\delta} \\cdot \\alpha \\delta + A _ {\\delta} \\cdot \\beta \\delta + A _ {\\delta} B _ {\\gamma} \\cdot \\gamma \\delta \\\\ + A (\\tau) B _ {\\gamma} \\cdot \\gamma - C _ {\\alpha} \\cdot \\alpha \\delta - C _ {\\beta} \\cdot \\beta \\delta - D _ {\\alpha} \\cdot \\alpha \\gamma - D _ {\\beta} \\cdot \\beta \\gamma - D _ {\\delta} \\cdot \\gamma \\delta - D (\\tau) \\gamma \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From above we can derive the following equalities</p>

    <div class="my-4 text-center"><span class="math-block">C _ {\\alpha} = B _ {\\delta}, C _ {\\beta} = A _ {\\delta}, D _ {\\alpha} = B _ {\\gamma}, D _ {\\beta} = 0, D (\\tau) = B _ {\\gamma} A (\\tau), D _ {\\delta} = A _ {\\delta} B _ {\\gamma}</span></div>

    <p class="text-gray-300">while equation (13) becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot a _ {i} (\\tau)\\right) \\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot b _ {i} (\\tau)\\right) - \\sum_ {i = 0} ^ {m} w _ {i} \\cdot c _ {i} (\\tau) - C _ {t} (\\tau) t (\\tau) \\\\ + \\left(B _ {\\delta} A (\\tau) + A _ {\\delta} B (\\tau) - C (\\tau)\\right) \\delta \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Finally we get that</p>

    <div class="my-4 text-center"><span class="math-block">B _ {\\delta} A (\\tau) + A _ {\\delta} B (\\tau) - C (\\tau) = 0</span></div>

    <p class="text-gray-300">and we are left with the equality</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot a _ {i} (\\tau)\\right) \\left(\\sum_ {i = 0} ^ {m} w _ {i} \\cdot b _ {i} (\\tau)\\right) - \\sum_ {i = 0} ^ {m} w _ {i} \\cdot c _ {i} (\\tau) = C _ {t} (\\tau) t (\\tau)</span></div>

    <p class="text-gray-300">which means that <span class="math">\\pmb{w}</span> is a valid solution for the QAP relation.</p>

    <p class="text-gray-300">By applying the equalities derived above we have that <span class="math">D</span> is defined as follows</p>

    <div class="my-4 text-center"><span class="math-block">D = B _ {\\gamma} (\\alpha + A _ {\\delta} \\delta + A (\\tau)) + \\sum_ {i = 0} ^ {n} D _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + D _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma}</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">A new cc-SNARK for QAP relations <span class="math">R_{\\mathcal{Q}}(\\boldsymbol{u}, \\boldsymbol{\\omega})</span>. Here we show how we can modify the ccGro16 scheme described earlier in order to become a full fledged cc-SNARK (i.e., such that the extractor can extract an opening of the commitment <span class="math">[D]_1</span> with respect to the algorithm VerCommit. The</p>

    <p class="text-gray-300">77</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Figure 23: Our NILP for an augmented QAP relation  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}, \\pmb{\\omega})</span> , to be used to obtain ccGro16*.</p>

    <p class="text-gray-300">modification enforces the prover to choose  <span class="math">D</span>  in the span of the elements of  <span class="math">\\mathsf{ck}</span> , i.e., to be wellformed with respect to VerCommit.</p>

    <p class="text-gray-300">As before, we consider an augmented QAP in which the polynomials  <span class="math">a_{k}(X)</span>  for  <span class="math">k = 0</span>  to  <span class="math">n</span>  are linearly independent. Our new cc-SNARK, called ccGro16*, is the scheme obtained by instantiating the generic SNARK construction of [Gro16] recalled in Figure 20 with the NILP that we describe in Figure 23. We let the commitment be the proof element  <span class="math">[D]_1</span> .</p>

    <p class="text-gray-300">Theorem H.2. The construction in Figure 23 is a NILP with perfect completeness, perfect zero-knowledge and statistical knowledge soundness against affine provers. In particular, the NILP extractor also returns a coefficient  <span class="math">o \\in \\mathbb{F}</span>  such that (10) holds with overwhelming probability.</p>

    <p class="text-gray-300">Proof Perfect completeness is easy to verify. For perfect zero-knowledge, we define the simulator that samples  <span class="math">A, B, D \\gets \\S \\mathbb{F}</span>  at random and then finds  <span class="math">C</span>  and  <span class="math">D&#x27;</span>  so that the verification tests are satisfied. This shows that real and simulated proofs are identically distributed.</p>

    <p class="text-gray-300">For knowledge soundness, let  <span class="math">(\\varPi_1,\\varPi_2)\\in \\mathbb{F}^{4\\times (m + n + 2d + 7)}\\times \\mathbb{F}^{1\\times (d + 5)}</span>  be an affine prover strategy. From these matrices we can derive a set of field elements  <span class="math">A_{\\alpha},A_{\\beta},A_{\\delta}</span>  etc. such that we can write  <span class="math">(A,C,D,D^{\\prime})^{\\top} = \\varPi_{1}\\cdot \\pmb{\\sigma}_{1},B = \\varPi_{2}\\cdot \\pmb{\\sigma}_{2}</span>  in the following way:</p>

    <div class="my-4 text-center"><span class="math-block">A = A _ {\\alpha} \\cdot \\alpha + A _ {\\beta} \\cdot \\beta + A _ {\\delta} \\cdot \\delta + A (\\tau) + \\sum_ {i = 0} ^ {n} A _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + A _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = 0} ^ {n} A _ {\\theta , i} \\cdot \\frac {\\theta (\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau))}{\\gamma} + A _ {\\theta , \\gamma} \\cdot \\frac {\\eta \\theta}{\\gamma} + \\sum_ {i = n + 1} ^ {m} A _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + A _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + A _ {t} (\\tau) \\frac {t (\\tau)}{\\delta}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">B = B _ {\\beta} \\cdot \\beta + B _ {\\gamma} \\cdot \\gamma + B _ {\\delta} \\cdot \\delta + B _ {\\theta} \\cdot \\theta + B (\\tau)</span></div>

    <div class="my-4 text-center"><span class="math-block">C = C _ {\\alpha} \\cdot \\alpha + C _ {\\beta} \\cdot \\beta + C _ {\\delta} \\cdot \\delta + C (\\tau) + \\sum_ {i = 0} ^ {n} C _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + C _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = 0} ^ {n} C _ {\\theta , i} \\cdot \\frac {\\theta (\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau))}{\\gamma} + C _ {\\theta , \\gamma} \\cdot \\frac {\\eta \\theta}{\\gamma} + \\sum_ {i = n + 1} ^ {m} C _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + C _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + C _ {t} (\\tau) \\frac {t (\\tau)}{\\delta}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">D = D _ {\\alpha} \\cdot \\alpha + D _ {\\beta} \\cdot \\beta + D _ {\\delta} \\cdot \\delta + D (\\tau) + \\sum_ {i = 0} ^ {n} D _ {\\gamma , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + D _ {\\eta / \\gamma} \\cdot \\frac {\\eta}{\\gamma}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = 0} ^ {n} D _ {\\theta , i} \\cdot \\frac {\\theta (\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau))}{\\gamma} + D _ {\\theta , \\gamma} \\cdot \\frac {\\eta \\theta}{\\gamma} + \\sum_ {i = n + 1} ^ {m} D _ {\\delta , i} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + D _ {\\eta / \\delta} \\cdot \\frac {\\eta}{\\delta} + D _ {t} (\\tau) \\frac {t (\\tau)}{\\delta}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">D ^ {\\prime} = D _ {\\alpha} ^ {\\prime} \\cdot \\alpha + D _ {\\beta} ^ {\\prime} \\cdot \\beta + D _ {\\delta} ^ {\\prime} \\cdot \\delta + D ^ {\\prime} (\\tau) + \\sum_ {i = 0} ^ {n} D _ {\\gamma , i} ^ {\\prime} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\gamma} + D _ {\\eta / \\gamma} ^ {\\prime} \\cdot \\frac {\\eta}{\\gamma}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_ {i = 0} ^ {n} D _ {\\theta , i} ^ {\\prime} \\cdot \\frac {\\theta (\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau))}{\\gamma} + D _ {\\theta , \\gamma} ^ {\\prime} \\cdot \\frac {\\eta \\theta}{\\gamma} + \\sum_ {i = n + 1} ^ {m} D _ {\\delta , i} ^ {\\prime} \\cdot \\frac {\\beta a _ {i} (\\tau) + \\alpha b _ {i} (\\tau) + c _ {i} (\\tau)}{\\delta} + D _ {\\eta / \\delta} ^ {\\prime} \\cdot \\frac {\\eta}{\\delta} + D _ {t} ^ {\\prime} (\\tau) \\frac {t (\\tau)}{\\delta}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let us define the NILP extractor as the algorithm that on input  <span class="math">(\\Pi_1, \\Pi_2)</span>  returns</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\omega} := (C _ {\\delta , n + 1}, \\dots , C _ {\\delta , m}), \\quad \\boldsymbol {u} := (D _ {\\gamma , 0}, \\dots , D _ {\\gamma , n}), \\quad \\boldsymbol {o} := D _ {\\eta / \\gamma}</span></div>

    <p class="text-gray-300">Once defined the extractor, we need to show that the probability that the proof verifies and the relation  <span class="math">R_{\\mathcal{Q}}(\\pmb{u}, \\pmb{\\omega})</span>  does not hold is negligible. This proof closely follows the one of Theorem H.1 with the difference that the additional verification equation enforces the structure of  <span class="math">D</span> .</p>

    <p class="text-gray-300">If we view the verification equations</p>

    <div class="my-4 text-center"><span class="math-block">A \\cdot B = \\alpha \\cdot \\beta + C \\cdot \\delta + D \\cdot \\gamma \\quad \\wedge D \\cdot \\theta = D ^ {\\prime} \\tag {14}</span></div>

    <p class="text-gray-300">as equalities over Laurent polynomials, then by the Schwartz-Zippel lemma, the prover has negligible probability of finding an affine strategy such that the equation holds for random  <span class="math">\\alpha, \\beta, \\gamma, \\delta, \\eta, \\theta, \\tau</span>  but does not hold as an equality of polynomials, when viewing  <span class="math">\\alpha, \\beta, \\gamma, \\delta, \\eta, \\theta, \\tau</span>  as indeterminates.</p>

    <p class="text-gray-300">79</p>

    <p class="text-gray-300">Therefore we proceed by analyzing the polynomial identity in order to show that the extractor’s output satisfies the QAP relation.</p>

    <p class="text-gray-300">We start by analyzing the equality <span class="math">D\\cdot\\theta=D^{\\prime}</span>, which immediately allows us to simplify</p>

    <p class="text-gray-300"><span class="math">D=\\sum_{i=0}^{n}D_{\\gamma,i}\\cdot\\frac{\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau)}{\\gamma}+D_{\\eta/\\gamma}\\cdot\\frac{\\eta}{\\gamma}</span> <span class="math">D^{\\prime}=\\sum_{i=0}^{n}D_{\\gamma,i}\\cdot\\frac{\\theta(\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau))}{\\gamma}+D_{\\eta/\\gamma}\\cdot\\frac{\\eta\\theta}{\\gamma}</span></p>

    <p class="text-gray-300">Let us now focus on the first equality <span class="math">A\\cdot B=\\alpha\\cdot\\beta+C\\cdot\\delta+D\\cdot\\gamma</span>.</p>

    <p class="text-gray-300">We start by looking at the term with <span class="math">\\alpha\\beta</span>, from which we derive <span class="math">A_{\\alpha}=B_{\\beta}=1</span> as in the proof of Theorem H.1.</p>

    <p class="text-gray-300">Let us analyze the term <span class="math">B_{\\theta}\\cdot\\alpha\\theta</span> and notice that it must be zero, hence <span class="math">B_{\\theta}=0</span>.</p>

    <p class="text-gray-300">Let us consider the following terms of <span class="math">A\\cdot B</span> and observe that they must be 0</p>

    <p class="text-gray-300"><span class="math">\\beta\\left(\\sum_{i=0}^{n}A_{\\theta,i}\\cdot\\frac{\\theta(\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau))}{\\gamma}+A_{\\theta,\\gamma}\\cdot\\frac{\\eta\\theta}{\\gamma}\\right)=0</span></p>

    <p class="text-gray-300">Hence, we have that <span class="math">A</span> and <span class="math">B</span> can be simplified to have the same form as in the beginning of the proof of Theorem H.1.</p>

    <p class="text-gray-300">After the above simplification of <span class="math">A</span>, let us consider the following terms of <span class="math">C\\cdot\\delta</span>, which must also be zero:</p>

    <p class="text-gray-300"><span class="math">\\delta\\left(\\sum_{i=0}^{n}C_{\\theta,i}\\cdot\\frac{\\theta(\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau))}{\\gamma}+C_{\\theta,\\gamma}\\cdot\\frac{\\eta\\theta}{\\gamma}\\right)=0</span></p>

    <p class="text-gray-300">and thus we can also simplify <span class="math">C</span> in the same form as in the beginning of the proof of Theorem H.1.</p>

    <p class="text-gray-300">At this point the proof of the theorem can proceed the same as in Theorem H.1 except for having here <span class="math">D</span> already in a simpler form. We recall below the main steps.</p>

    <p class="text-gray-300">We can use the same arguments to simplify <span class="math">A=\\alpha+A_{\\beta}\\beta+A_{\\delta}\\cdot\\delta+A(\\tau)</span> and then</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{n}C_{\\gamma,i}\\cdot\\frac{\\beta a_{i}(\\tau)+\\alpha b_{i}(\\tau)+c_{i}(\\tau)}{\\gamma}+C_{\\eta/\\gamma}\\cdot\\frac{\\eta}{\\gamma}=0</span></p>

    <p class="text-gray-300">Therefore <span class="math">AB-\\alpha\\beta-C\\delta-D\\gamma=0</span> gives us</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=\\alpha B(\\tau)+\\beta A(\\tau)-\\beta\\left(\\sum_{i=0}^{m}w_{i}\\cdot a_{i}(\\tau)\\right)-\\alpha\\left(\\sum_{i=0}^{m}w_{i}\\cdot b_{i}(\\tau)\\right)-\\sum_{i=0}^{m}w_{i}\\cdot c_{i}(\\tau)+A(\\tau)B(\\tau)</span> <span class="math">+B_{\\gamma}\\cdot\\alpha\\gamma+B_{\\delta}\\cdot\\alpha\\delta+A_{\\delta}\\cdot\\beta\\delta+A_{\\delta}B_{\\gamma}\\cdot\\gamma\\delta+A_{\\delta}B_{\\delta}\\cdot\\delta^{2}+A_{\\delta}B(\\tau)\\delta</span> <span class="math">+A(\\tau)B_{\\gamma}\\cdot\\gamma+A(\\tau)B_{\\delta}\\cdot\\delta</span> <span class="math">+A_{\\beta}\\beta^{2}+A_{\\beta}B_{\\gamma}\\cdot\\beta\\gamma+A_{\\beta}B_{\\delta}\\cdot\\beta\\delta+A_{\\beta}B(\\tau)\\beta</span> <span class="math">-C_{\\alpha}\\cdot\\alpha\\delta-C_{\\beta}\\cdot\\beta\\delta-C_{\\delta}\\cdot\\delta^{2}-C(\\tau)\\delta-C_{\\eta/\\delta}\\cdot\\eta-C_{t}(\\tau)t(\\tau)-D_{\\eta/\\gamma}\\cdot\\eta</span></p>

    <p class="text-gray-300">from which one can derive <span class="math">A_{\\beta}=0</span>, <span class="math">A(\\tau)=\\sum_{i=0}^{m}w_{i}\\cdot a_{i}(\\tau)</span>, <span class="math">B(\\tau)=\\sum_{i=0}^{m}w_{i}\\cdot b_{i}(\\tau)</span>, <span class="math">C_{\\delta}=A_{\\delta}B_{\\delta}</span>, and <span class="math">C_{\\eta/\\delta}=-D_{\\eta/\\gamma}</span>. Therefore the equation (15) can be simplified as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\left(\\sum_{i=0}^{m} w_{i} \\cdot a_{i}(\\tau)\\right) \\left(\\sum_{i=0}^{m} w_{i} \\cdot b_{i}(\\tau)\\right) - \\sum_{i=0}^{m} w_{i} \\cdot c_{i}(\\tau) - C_{t}(\\tau) t(\\tau) \\\\ \\quad + (B_{\\delta} A(\\tau) + A_{\\delta} B(\\tau) - C(\\tau)) \\delta + B_{\\gamma} \\cdot \\alpha \\gamma + B_{\\delta} \\cdot \\alpha \\delta + A_{\\delta} \\cdot \\beta \\delta + A_{\\delta} B_{\\gamma} \\cdot \\gamma \\delta \\\\ \\quad + A(\\tau) B_{\\gamma} \\cdot \\gamma - C_{\\alpha} \\cdot \\alpha \\delta - C_{\\beta} \\cdot \\beta \\delta \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From above we can derive the following equalities <span class="math">C_{\\alpha} = B_{\\delta}, C_{\\beta} = A_{\\delta}, B_{\\gamma} = 0</span> while equation (15) becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\left(\\sum_{i=0}^{m} w_{i} \\cdot a_{i}(\\tau)\\right) \\left(\\sum_{i=0}^{m} w_{i} \\cdot b_{i}(\\tau)\\right) - \\sum_{i=0}^{m} w_{i} \\cdot c_{i}(\\tau) - C_{t}(\\tau) t(\\tau) \\\\ \\quad + (B_{\\delta} A(\\tau) + A_{\\delta} B(\\tau) - C(\\tau)) \\delta \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and then the proof concludes as in Theorem H.1.</p>`;
---

<BaseLayout title="LegoSNARK: Modular Design and Composition of Succinct Zero-K... (2019/142)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/142
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
