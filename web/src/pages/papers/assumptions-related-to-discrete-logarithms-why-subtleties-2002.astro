---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/126';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Assumptions Related to Discrete Logarithms: Why Subtleties Make a Real Difference';
const AUTHORS_HTML = 'Ahmad-Reza Sadeghi, Michael Steiner';

const CONTENT = `    <p class="text-gray-300">Assumptions Related to Discrete Logarithms: Why Subtleties Make a Real Difference</p>

    <p class="text-gray-300">Ahmad-Reza Sadeghi Michael Steiner Fachrichtung Informatik, Universität des Saarlandes D-66123 Saarbrücken, Germany {sadeghi,steiner}@cs.uni-sb.de</p>

    <p class="text-gray-300">August 23, 2002</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">The security of many cryptographic constructions relies on assumptions related to Discrete Logarithms (DL), e.g., the Diffie-Hellman, Square Exponent, Inverse Exponent or Representation Problem assumptions. In the concrete formalizations of these assumptions one has some degrees of freedom offered by parameters such as computational model, problem type (computational, decisional) or success probability of adversary. However, these parameters and their impact are often not properly considered or are simply overlooked in the existing literature.</p>

    <p class="text-gray-300">In this paper we identify parameters relevant to cryptographic applications and describe a formal framework for defining DL-related assumptions. This enables us to precisely and systematically classify these assumptions.</p>

    <p class="text-gray-300">In particular, we identify a parameter, termed granularity, which describes the underlying probability space in an assumption. Varying granularity we discover the following surprising result: We prove that two DL-related assumptions can be reduced to each other for medium granularity but we also show that they are provably not reducible with generic algorithms for high granularity. Further we show that reductions for medium granularity can achieve much better concrete security than equivalent high-granularity reductions.</p>

    <p class="text-gray-300"><strong>Keywords</strong>: Complexity Theory, Cryptographic Assumptions, Generic Algorithms, Discrete Logarithms, Diffie-Hellman, Square Exponent, Inverse Exponent.</p>

    <h2 id="sec-2" class="text-2xl font-bold">Contents</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Introduction  2</li>

      <li>Terminology  4</li>

    </ol>

    <p class="text-gray-300">2.1 General Notational Conventions  4</p>

    <p class="text-gray-300">1 INTRODUCTION</p>

    <p class="text-gray-300">2.2 Asymptotics 5 2.3 Computational Model 6 2.4 Indistinguishability 7 2.5 Algebraic Structures 7 2.6 Problems 8 2.7 Samplers 9</p>

    <p class="text-gray-300">3 Parameters of DL-based Assumptions 11 4 Defining Assumptions 20 5 The Impact of Granularity 27 6 Computational DH, SE and IE 29</p>

    <p class="text-gray-300">6.1 Self-Correction 30 6.2 CSE versus CDH 32</p>

    <p class="text-gray-300">6.2.1 High Granular 32 6.2.2 Medium Granular 37</p>

    <p class="text-gray-300">6.3 CDH versus CIE 39</p>

    <p class="text-gray-300">6.3.1 High Granular 39 6.3.2 Medium Granular 46</p>

    <p class="text-gray-300">7 Decisional DH, SE and IE 49</p>

    <p class="text-gray-300">7.1 Difficulty in the Generic Model 49 7.2 DSE versus DDH 54</p>

    <p class="text-gray-300">7.2.1 High Granular 54</p>

    <p class="text-gray-300">7.3 DIE versus DDH 57 7.3.1 High Granular 57</p>

    <p class="text-gray-300">7.4 DSE versus DIE 65</p>

    <p class="text-gray-300">7.4.1 High Granular 65 7.4.2 Medium Granular 68</p>

    <p class="text-gray-300">8 Conclusions 72</p>

    <p class="text-gray-300">References 74</p>

    <p class="text-gray-300">Index 79</p>

    <p class="text-gray-300">A Deriving Formal Assumptions 82</p>

    <p class="text-gray-300">Most modern cryptographic systems rely on assumptions on the computational difficulty of some particular number-theoretic problem. One well-known class of</p>

    <p class="text-gray-300">assumptions is related to the difficulty of computing discrete logarithms in cyclic groups <em>(McCurley, 1990)</em>. In this class a number of variants exists. The most prominent ones, besides Discrete Logarithm (DL), are the computational and decisional Diffie-Hellman (DH) assumptions <em>(Diffie and Hellman, 1976; Brands, 1994)</em> Less known assumptions are Matching Diffie-Hellman <em>(Frankel et al., 1996)</em>, Square Exponent (SE) <em>(Maurer and Wolf, 1996)</em>, and Inverse Exponent (IE) <em>(Pfitzmann and Sadeghi, 2000)</em>, an assumption closely related to the Inverted-Additive Exponent (IAE) Problem introduced by <em>MacKenzie (2001)</em> and also implicitly required for the security of the schemes proposed by <em>Camenisch, Maurer, and Stadler (1996)</em> and <em>Davida, Frankel, Tsiounis, and Yung (1997)</em>. Further related assumptions mentioned in the sequel are Generalized Diffie-Hellman (GDH) <em>(Shmuely, 1985; Steiner et al., 1996)</em> and the Representation Problem (RP) <em>(Brands, 1994)</em>. Several additional papers have studied relations among these assumptions, e.g., <em>(Shoup, 1997; Maurer and Wolf, 1998a; Maurer and Wolf, 1998b; Biham et al., 1999; Wolf, 1999)</em>.</p>

    <p class="text-gray-300">In the concrete formalizations of these assumptions one has various degrees of freedom offered by parameters such as computational model, problem type (computational, decisional or matching) or success probability of the adversary. However, such aspects are often not precisely considered in the literature and consequences are simply overlooked. In this paper, we address these aspects by identifying the parameters relevant to cryptographic assumptions. Based on this, we present a formal framework and a concise notation for defining DL-related assumptions. This enables us to precisely and systematically classify these assumptions.</p>

    <p class="text-gray-300">Among the specified parameters, we focus on a parameter we call granularity of the probability space which underlies an assumption. Granularity defines what part of the underlying algebraic structure (i.e., algebraic group and generator) is part of the probability space and what is fixed in advance: For high granularity an assumption has to hold for all groups and generators; for medium granularity the choice of the generator is included in the probability space and for low granularity the probability is taken over both the choice of the group and the generator. Assumptions with lower granularity are weaker than those with higher granularity. Nonetheless, not all cryptographic settings can rely on the weaker variants: Only when the choice of the system parameters is guaranteed to be random one can rely on a low-granularity assumption. For example, consider an anonymous payment system where the bank chooses the system parameters. To base the security of such a system a-priori on a low-granularity assumption would not be appropriate. A cheating bank might try to choose a weak group with trapdoors (easy problem instances) to violate the anonymity of the customer. Such a cheater strategy might be possible even if the low-granular assumption holds: The assumption would ensure that the overall number of easy</p>

    <p class="text-gray-300">problem instances is asymptotically negligible (in respect to the security parameter). Nonetheless, it would not rule out that there are infinitely many weak groups! However, if we choose the system parameters of the payment system through a random yet verifiable process we can resort to a weaker assumption with lower granularity. To our knowledge no paper on anonymous payment systems addresses this issue properly. Granularity was also overlooked in different contexts, e.g., <em>Boneh (1998)</em> ignores the fact that low-granular assumptions are not known to be random self-reducible and comes to a wrong conclusion regarding the correctness of a certain self-corrector.</p>

    <p class="text-gray-300">In this paper, we show that varying granularity can lead to surprising results. We extend the results of <em>Wolf (1999)</em> to the problem class IE, i.e., we prove statements on relations between IE, DH and SE for both computational and decisional variants in the setting of <em>Wolf (1999)</em>, which corresponds to the high-granular case. We then consider medium granularity (with other parameters unchanged) and show the impact: We prove that the decisional IE and SE assumptions are equivalent for medium granularity whereas this is provably not possible for their high-granular variants, at least not in the generic model <em>(Shoup 1997)</em>. We also show that reductions between computational IE, SE and DH can offer much better concrete security for medium granularity than their high-granular analogues.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Terminology</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 General Notational Conventions</h3>

    <p class="text-gray-300">By <span class="math">\\{\\mathsf{a},\\mathsf{b},\\mathsf{c},\\ldots\\}</span> and <span class="math">(\\mathsf{a},\\mathsf{b},\\mathsf{c},\\ldots)</span> we denote the set and the sequence consisting of the elements <span class="math">\\mathsf{a}</span>, <span class="math">\\mathsf{b}</span>, <span class="math">\\mathsf{c}</span>, …. By specifying a set as <span class="math">\\{f(v_{1},\\ldots,v_{n})\\mid\\mathsf{pred}(v_{1},\\ldots,v_{n})\\}</span> we mean the set of elements we get by evaluating the formula <span class="math">f</span> with any instantiation of the <span class="math">n</span> free variables <span class="math">v_{1},\\ldots,v_{n}</span> which fulfills the predicate <span class="math">\\mathsf{pred}</span>, e.g., <span class="math">\\{(v,v^{2})\\mid v\\in\\mathbb{N}\\}</span> denotes the set of all tuples which contain a natural number and its square. Similarly, we define <span class="math">(f(v_{1},\\ldots,v_{n})\\mid\\mathsf{pred}(v_{1},\\ldots,v_{n}))</span> to be the sequence of elements we get by evaluating the formula <span class="math">f</span> with any instantiation of the <span class="math">n</span> free variables <span class="math">v_{1},\\ldots,v_{n}</span> which fulfills the predicate <span class="math">\\mathsf{pred}</span>. The elements are ordered according to some arbitrary but fixed order relation on the (instantiated) argument tuples <span class="math">(v_{1},\\ldots,v_{n})</span>. For example, <span class="math">((v,v^{2})\\mid v\\in\\mathbb{N})</span> denotes the infinite sequence of all tuples which contain a natural number and its square, and where the sequence is ordered, e.g., using the standard order <span class="math">&lt;</span> on <span class="math">\\mathbb{N}</span> and the value of <span class="math">v</span> as the sort index.</p>

    <p class="text-gray-300">The evaluation and following assignment of an expression <span class="math">\\mathsf{expr}</span> to a variable <span class="math">v</span> is denoted by <span class="math">v\\leftarrow\\mathsf{expr}</span>. By <span class="math">v\\xleftarrow{\\mathsf{n}}S</span> we mean the assignment of a uniformly chosen random element from the set <span class="math">S</span> to variable <span class="math">v</span>. Similarly, <span class="math">v\\in_{\\mathcal{R}}S</span> denotes that <span class="math">v</span> is a uniformly distributed random element from set <span class="math">S</span>. Finally, by <span class="math">\\mathsf{t:}=\\mathsf{expr}</span> we mean that by definition the term <span class="math">\\mathsf{t}</span> is equal to <span class="math">\\mathsf{expr}</span>.</p>

    <p class="text-gray-300">Simple random variables are specified as <span class="math">v\\xleftarrow{\\mathsf{n}}S</span> as mentioned above. To</p>

    <p class="text-gray-300">2.2 Asymptotics</p>

    <p class="text-gray-300">specify more complicated random variables, we use the following notation: <span class="math">(f(v_{1},\\ldots ,v_{n}):\\mathsf{assign}(v_{1},\\ldots ,v_{n}))</span>. By this we mean the random variable having a structure as defined by the formula <span class="math">f</span> and a probability space as induced by binding the <span class="math">n</span> free variables <span class="math">v_{1},\\ldots ,v_{n}</span> via the assignment rule assign, e.g., <span class="math">((v,v^{2})::v\\stackrel {\\mathrm{sc}}{\\leftarrow}\\mathbb{Z}_{n})</span> denotes the random variable consisting of a tuple which contains an integer and its square where the integer is uniformly chosen from <span class="math">\\mathbb{Z}_n</span>. Similarly, <span class="math">\\{f(v_{1},\\dots ,v_{n}):\\mathsf{assign}(v_{1},\\dots ,v_{n})\\}</span> defines an ensemble of random variables indexed by the free variables <span class="math">v_{i}</span> which are left unspecified in the assignment rule assign and which have by definition domain <span class="math">\\mathbb{N}</span>, e.g., <span class="math">\\{(v,v^k)::v\\stackrel {\\mathrm{sc}}{\\leftarrow}\\mathbb{Z}_n\\}</span> denotes the ensemble of random variables consisting of a tuple which contain an integer and its <span class="math">k</span>-th power where the integer is uniformly chosen from <span class="math">\\mathbb{Z}_n</span> and the natural number <span class="math">k</span> is the index of the ensemble. Finally, let <span class="math">v</span> be some arbitrary random variable or random variable ensemble. Then, <span class="math">[v]</span> denotes the set of all possible values of <span class="math">v</span>.</p>

    <p class="text-gray-300">To specify probabilities, we use the notation <span class="math">\\mathbf{Prob}[\\mathsf{pred}(v_1,\\ldots ,v_n):\\mathsf{assign}(v_1,\\ldots ,v_n)]</span>. This denotes the probability that the predicate pred holds when the probability is taken over a probability space defined by the formula assign on the <span class="math">n</span> free variables <span class="math">v_{i}</span> of the predicate pred. For example, <span class="math">\\mathbf{Prob}[v\\equiv 0\\pmod{2}::v\\stackrel {\\mathrm{sc}}{\\leftarrow}\\mathbb{Z}_n]</span> denotes the probability that a random element of <span class="math">\\mathbb{Z}_n</span> is even.</p>

    <p class="text-gray-300">For convenience, by log we always mean the logarithm to the base two.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2.2 Asymptotics</h2>

    <p class="text-gray-300">Cryptographic assumptions are always expressed asymptotically in a security parameter <span class="math">k \\in \\mathbb{N}</span>. To classify the asymptotic behavior of functions <span class="math">\\mathbb{N} \\to \\mathbb{R}^<em></span> (with <span class="math">\\mathbb{R}^</em></span> denoting the set of all non-negative real numbers) we require the following definitions.</p>

    <p class="text-gray-300">We can extend ordinary relation operators <span class="math">op \\in \\{&amp;lt;, \\leq, =, &amp;gt;, \\geq\\}</span> on elements of <span class="math">\\mathbb{R}^*</span> to asymptotic relation operators <span class="math">op_{\\infty}</span> on functions <span class="math">f_1</span> and <span class="math">f_2</span> defined as above as follows:</p>

    <div class="my-4 text-center"><span class="math-block">f _ {1} (k) \\quad o p _ {\\infty} \\quad f _ {2} (k) := \\exists k _ {0} \\forall k &amp;gt; k _ {0}: f _ {1} (k) \\text{ op } f _ {2} (k).</span></div>

    <p class="text-gray-300">The corresponding negation of the asymptotic relation operators is then denoted by <span class="math">\\preccurlyeq_{\\infty}</span>, <span class="math">\\preccurlyeq_{\\infty}</span>, <span class="math">\\preccurlyeq_{\\infty}</span>, <span class="math">\\preccurlyeq_{\\infty}</span>, and <span class="math">\\preccurlyeq_{\\infty}</span>, respectively.</p>

    <p class="text-gray-300">For example, <span class="math">f_{1}(k) &amp;lt;_{\\infty} f_{2}(k)</span> means that <span class="math">f_{1}</span> is asymptotically strictly smaller than <span class="math">f_{2}</span> and <span class="math">f_{1}(k) \\not\\geq_{\\infty} f_{2}(k)</span> means that <span class="math">f_{1}</span> is not asymptotically larger or equal to <span class="math">f_{2}</span>, i.e., for each <span class="math">k_{0}</span> there is a <span class="math">k_{1} &amp;gt; k_{0}</span> such that <span class="math">f_{1}(k_{1}) &amp;lt; f_{2}(k_{1})</span>. However, note that the <span class="math">f_{1}(k) \\not\\geq_{\\infty} f_{2}(k)</span> does not imply <span class="math">f_{1}(k) &amp;lt;_{\\infty} f_{2}(k)!</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{poly}(v)</span> be the class of univariate polynomials with variable <span class="math">v</span> and non-negative coefficients, i.e., <span class="math">\\mathsf{poly}(v) := \\{\\sum_{i=0}^{d} a_i v^i \\mid d \\in \\mathbb{N}_0 \\land a_i \\in \\mathbb{N}_0\\}</span>. Furthermore, let <span class="math">\\mathsf{poly}(v_1, \\ldots, v_n)</span> be the class of multivariate polynomials with <span class="math">n</span> variables <span class="math">v_j</span> and non-negative coefficients, i.e., $\\mathsf{poly}(v_1, \\ldots, v_n) := \\{\\sum_{i=0}^{d} \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} a_{ij} \\prod_{l=1}^{n} v_l^{d_{ijt}} \\mid d \\in \\mathbb{N}_0 \\land a_{ij} \\in \\mathbb{N}_0 \\land (d_{ij1}, \\ldots, d_{ijn}) \\in D_i^n\\}<span class="math"> where </span>D_i^n := \\{(d_l \\mid l \\in \\{1, \\ldots, n\\}) \\mid d_l \\in \\mathbb{N}_0 \\land \\sum_{l=1}^{n} d_l = i\\}$. Based on this we can define the following useful classes of functions:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2 TERMINOLOGY</p>

    <p class="text-gray-300">A negligible function <span class="math">\\epsilon(k)</span> is a function where the inverse of any polynomial is asymptotically an upper bound, i.e., <span class="math">\\forall d &amp;gt; 0 \\ \\exists k_0 \\ \\forall k &amp;gt; k_0 : \\epsilon(k) &amp;lt; 1/k^d</span>. We denote this by <span class="math">\\epsilon(k) &amp;lt;_{\\infty} 1/\\mathsf{poly}(k)</span>. If <span class="math">\\epsilon(k)</span> cannot be upper bounded in such a way, we say <span class="math">\\epsilon(k)</span> is not negligible and we denote this by <span class="math">\\epsilon(k) \\not\\leq_{\\infty} 1/\\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">A non-negligible function <span class="math">f(k)</span> is a function which asymptotically can be lower bounded by the inverse of some polynomial, i.e., <span class="math">\\exists d &amp;gt; 0 \\ \\exists k_0 \\ \\forall k &amp;gt; k_0 : f(k) \\geq 1/k^d</span>. We denote this by <span class="math">f(k) \\geq_{\\infty} 1/\\mathsf{poly}(k)</span>. If <span class="math">f(k)</span> cannot be lower bounded in such a way we say <span class="math">f(k)</span> is not non-negligible and denote this by <span class="math">f(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">Non-negligible functions are — when seen as a class — closed under multivariate polynomial composition, i.e., <span class="math">\\forall n \\in \\mathbb{N} \\ \\forall i \\in \\{1, \\ldots, n\\} \\ \\forall p \\in \\mathsf{poly}(v_1, \\ldots, v_n) \\setminus \\{0_{\\mathsf{poly}}\\} \\ \\forall f_i \\geq_{\\infty} 1 / \\mathsf{poly}(k) : p(f_1, \\ldots, f_n) \\geq_{\\infty} 1 / \\mathsf{poly}(k)</span> where <span class="math">0_{\\mathsf{poly}}</span> denotes the null polynomial. This holds also for negligible functions if there is no non-zero constant term in the polynomial, i.e., we select only elements from the class <span class="math">\\mathsf{poly}(v_1, \\ldots, v_n)</span> where <span class="math">a_{01}</span> is zero. For not negligible and not non-negligible functions this holds solely for univariate polynomial composition. Finally, the addition (multiplication) of a non-negligible and a not negligible function is a non-negligible (not negligible) function. Similarly, the addition of a negligible and a not non-negligible function is a not non-negligible function. The multiplication of a negligible and a not non-negligible function is a not non-negligible function or even a negligible function if the not non-negligible function can be upper bounded by some polynomial.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.3 Computational Model</h2>

    <p class="text-gray-300">The computational model is based on the class <span class="math">\\mathcal{T}\\mathcal{M}</span> of probabilistic Turing machines on the binary alphabet <span class="math">\\{0,1\\}</span>. The runtime of a Turing machine <span class="math">\\mathsf{M}</span> is measured by the number of simple Turing steps from the initial state with given inputs until the machine reaches a final state. This is denoted by <span class="math">\\mathrm{RunTime}(\\mathsf{M}(\\mathrm{inputs}))</span>. The complexity of a Turing machine is expressed as a function of the bit-length of the inputs encoded on its input tape and defined as the maximum runtime for any input of a given bit-length. To make the definition of the probability spaces more explicit, we model a probabilistic Turing machine always as a deterministic machine with the random coins given as an explicit input <span class="math">\\mathcal{C}</span> chosen from the uniform distribution of infinite binary strings <span class="math">\\mathcal{U}</span>. However, we do not consider the randomness when calculating the length of the inputs. The important class of polynomial-time Turing machines is the class of machines with polynomial complexity:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{\\mathcal{A} \\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad \\mathcal{A} \\in \\mathcal{T}\\mathcal{M}; \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad \\forall d_1; \\ \\exists d_2; \\ \\forall k; \\\\ \\quad \\forall \\mathrm{inputs} \\in \\{0,1\\}^{k^{d_1}}; \\ \\forall \\mathcal{C} \\in \\{0,1\\}^{\\infty}; \\\\ \\quad : \\ \\mathrm{RunTime}(\\mathcal{A}(\\mathcal{C}, \\mathrm{inputs})) \\ &lt; k^{d_2} \\} \\end{array} $$</p>

    <p class="text-gray-300">3Note that not negligible is not the same as non-negligible, there are functions which are neither negligible nor non-negligible!</p>

    <p class="text-gray-300">2.4 Indistinguishability</p>

    <p class="text-gray-300">When we use the term efficient in the context of algorithms or computation we mean a Turing machine with polynomial complexity. By a hard problem we mean the absence of any efficient algorithm (asymptotically) solving that problem.</p>

    <p class="text-gray-300">In some situations, e.g., in a reduction, a machine <span class="math">\\mathsf{M}</span> has access to some other machines <span class="math">\\mathcal{O}_1,\\ldots ,\\mathcal{O}_n</span> and can query them as oracles. We denote this by <span class="math">\\mathsf{M}^{\\mathcal{O}_1,\\dots ,\\mathcal{O}_n}</span>. This means that the machine <span class="math">\\mathsf{M}</span> can write the input tapes of all <span class="math">\\mathcal{O}_i</span>, run them on that input, and read the corresponding output tapes. However, <span class="math">\\mathsf{M}</span> does not get access to the internal structure or state of the oracle.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.4 Indistinguishability</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let two families of random variables <span class="math">X \\coloneqq (X_{k} \\mid k \\in \\mathbb{N})</span> and <span class="math">Y \\coloneqq (Y_{k} \\mid k \\in \\mathbb{N})</span> be defined over some discrete domain <span class="math">\\mathcal{D}</span>. They are said to be computationally indistinguishable iff there is no efficient distinguishing algorithm <span class="math">\\mathsf{D}</span> which can distinguish the two asymptotically, i.e., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Prob}[\\mathsf{D}(1^k, X_k) = 1] - \\mathbf{Prob}[\\mathsf{D}(1^k, Y_k) = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a negligible function in </span>k<span class="math">. This is denoted by </span>X \\stackrel{\\mathrm{e}}{\\approx} Y<span class="math">. </span>X<span class="math"> and </span>Y<span class="math"> are statistically indistinguishable iff the statistical difference </span>\\Delta_{(X,Y)}(k) \\coloneqq \\sum_{d \\in \\mathcal{D}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Prob}[X_k = d] - \\mathbf{Prob}[Y_k = d]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a negligible function. This is written as </span>X \\stackrel{\\mathrm{s}}{\\approx} Y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-9" class="text-2xl font-bold">2.5 Algebraic Structures</h2>

    <p class="text-gray-300">The following terms are related to the algebraic structures underlying an assumption.</p>

    <p class="text-gray-300"><strong>Finite cyclic group</strong> <span class="math">G</span>: A group is an algebraic structure with a set <span class="math">G</span> of group elements and a binary group operation <span class="math">*: G \\times G \\to G</span> such that the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the group operation is associative, i.e., <span class="math">a <em> (b </em> c) = (a <em> b) </em> c</span> for all <span class="math">a, b, c \\in G</span>,</li>

      <li>there is an identity element <span class="math">1 \\in G</span> such that <span class="math">a <em> 1 = a = 1 </em> a</span> for all <span class="math">a \\in G</span>, and</li>

      <li>for each <span class="math">a \\in G</span> there is an inverse <span class="math">a^{-1} \\in G</span> such that <span class="math">a <em> a^{-1} = 1 = a^{-1} </em> a</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The group order is the cardinality of the set <span class="math">G</span> and is denoted by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, we write group operations always multiplicatively by juxtaposition of group elements; Nonetheless, note that the following results apply — with the appropriate adaption of notation — also to additive groups such as elliptic curves. The exponentiation <span class="math">a^x</span> for <span class="math">a \\in G</span> and <span class="math">x \\in \\mathbb{N}_0</span> is then defined as usual as <span class="math">\\overbrace{a \\cdots a}^{x \\text{ times}}</span>. The discrete logarithm of a given <span class="math">b \\in G</span> in respect to a specified base <span class="math">a \\in G</span> is the smallest <span class="math">x \\in \\mathbb{N}_0</span> such that <span class="math">a^x = b</span> or undefined if no such <span class="math">x</span> exists. The order of a group element <span class="math">b \\in G</span> is the least positive integer <span class="math">x</span> such that <span class="math">b^x = 1</span> or <span class="math">\\infty</span> if no such <span class="math">x</span> exists.</p>

    <p class="text-gray-300">2 TERMINOLOGY</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A group <span class="math">G</span> is finite if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is finite. A group </span>G<span class="math"> is cyclic if there is a generator </span>g \\in G<span class="math">, such that </span>\\forall b \\in G \\, \\exists !x \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} : g^x = b<span class="math">. The order of all elements in a finite cyclic group </span>G<span class="math"> divides </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In particular, there are exactly </span>\\varphi(d)<span class="math"> elements of order </span>d<span class="math"> (where </span>d<span class="math"> is any divisor of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">All considered assumptions are based on finite cyclic groups. For brevity, however, we omit the "finite cyclic" in the sequel and refer to them simply as "groups".</p>

    <p class="text-gray-300">For more information on the relevant abstract algebra we refer you to the book of Lidl and Niederreiter (1997).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithmically, the following is noteworthy: Finding generators can be done efficiently when the factorization of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is known; it is possible to perform exponentiations in </span>O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> group operations; and computing inverses can be done in </span>O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> group operations under the condition that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is known. For the corresponding algorithms and further algorithms for abstract or concrete groups we refer you to the books of Bach and Shallit (1996) and Menezes, van Oorschot, and Vanstone (1997).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Structure instance <span class="math">SI</span>: A tuple <span class="math">(G, g_1, \\ldots, g_n)</span> containing a group <span class="math">G</span> as first element followed by a sequence of one or more generators <span class="math">g_i</span>. This represents the structure underlying a particular problem. We can assume that the structure instance <span class="math">SI</span> (though not necessarily properties thereof such as the order or the factorization of the order) is publicly known.</p>

    <p class="text-gray-300">As a convention we abbreviate <span class="math">g_{1}</span> to <span class="math">g</span> if there is only a single generator associated with a given structure instance.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.6 Problems</h2>

    <p class="text-gray-300">The following two terms characterize a particular problem underlying an assumption.</p>

    <p class="text-gray-300"><strong>Problem family <span class="math">\\mathcal{P}</span></strong>: A family of abstract relations indexed by their underlying structure instance <span class="math">SI</span>. An example is the family of Diffie-Hellman problems which relate two (secret) numbers <span class="math">x</span> and <span class="math">y</span>, the two (public) values <span class="math">g^x</span> and <span class="math">g^y</span>, and the value <span class="math">g^{xy}</span> where all exponentiations are computed using the generator <span class="math">g</span> specified in <span class="math">SI</span>. We define a problem family by explicitly describing its problem instances as shown in the next paragraph.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Problem instance <span class="math">PI</span></strong>: A list of concrete parameters fully describing a particular instance of a problem family, i.e., a description of the structure instance <span class="math">SI</span> and a tuple <span class="math">(priv, publ, sol)</span> where <span class="math">priv</span> is the tuple of values kept secret from adversaries, <span class="math">publ</span> is the tuple of information publicly known on that problem and <span class="math">sol</span> is the set of possible solutions<span class="math">^4</span> of that problem instance. When not explicitly stated, we can assume that <span class="math">priv</span> consists always of elements from $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^4</span>The solutions might not be unique, e.g., multiple solution tuples match a given public value in the case of the Representation Problem (See Section 3, Parameter 1).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">publ</span> consists of elements from <span class="math">G</span>, and <span class="math">sol</span> is either a set of elements from $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> or from </span>G$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we take the aforementioned Diffie-Hellman problem for subgroups of <span class="math">\\mathbb{Z}_{p}^{*}</span> of order <span class="math">q</span> with <span class="math">p</span> and <span class="math">q</span> prime as an example, a problem instance <span class="math">PI_{DH}</span> is defined by a tuple</p>

    <p class="text-gray-300"><span class="math">(((\\mathbb{Z}_{p/q}^{*}p,q),(g)),((x,y),(g^{x},g^{y}),\\{(g^{xy})\\}))</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{Z}_{p/q}^{*}</span> denotes the parameterized description of the group and its operation, and <span class="math">p,q</span> are the corresponding group parameters. (More details on the group description and parameter are given below when group samplers are introduced.)</p>

    <p class="text-gray-300">This presentation achieves a certain uniformity of description and allows a generic definition of types of problems, i.e., whether it is a decisional or computational variant of a problem. While this might not be obvious right now, it should become clear at the latest in Section 3 below when we give the explicit definition of the different problem families with Parameter 1 and the precise definition of problem types with Parameter 2.</p>

    <p class="text-gray-300">For convenience, we define <span class="math">PI^{SI}</span>, <span class="math">PI^{publ}</span>, <span class="math">PI^{priv}</span> and <span class="math">PI^{sol}</span> to be the projection of a problem instance <span class="math">PI</span> to its structure instance, public, private and solution part, respectively. Picking up again above example, this means <span class="math">PI_{DH}^{SI}:=((\\mathbb{Z}_{p/q}^{*}p,q),(g))</span>, <span class="math">PI_{DH}^{priv}</span>:=<span class="math">(x,y)</span>, <span class="math">PI_{DH}^{publ}</span>:=<span class="math">(g^{x},g^{y})</span>, and <span class="math">PI_{DH}^{sol}</span>:=<span class="math">\\{g^{xy}\\}</span>, respectively.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.7 Samplers</h3>

    <p class="text-gray-300">In the following, we describe different probabilistic polynomial-time algorithms we use to randomly select (sample) various parameters. Note that these samplers cannot be assumed to be publicly known, i.e., to sample from the corresponding domains adversaries have to construct their own sampling algorithms from publicly known information.</p>

    <p class="text-gray-300">Group sampler <span class="math">SG_{\\mathcal{G}}</span>: A function which, when given a security parameter <span class="math">k</span> as input, randomly selects a group <span class="math">G</span> and returns a corresponding group index. We assume that a group sampler selects groups only of similar nature and type, i.e., there is a general description of a Turing machine which, based on a group index as parameter, implements at least the group operation and the equality test, and specifies how the group elements are represented. An example are the groups pioneered by <em>Schnorr (1991)</em> in his identification and signature schemes and also used in the Digital Signature Standard (DSS) <em>(National Institute of Standards and Technology (NIST) 2000)</em>, i.e., unique subgroups of <span class="math">\\mathbb{Z}_{p}^{<em>}</span> of order <span class="math">q</span> with <span class="math">p</span> and <span class="math">q</span> prime. The group index would be <span class="math">(p,q)</span> and the description of the necessary algorithms would be taken, e.g., from </em>Menezes et al. (1997)*. Note that, in this example, the group index allows the derivation of the group order and the factorization thereof. However, it cannot be assumed that the group index — the only information besides the description of the Turing machine which will be always publicly known about the group — allows to derive such knowledge on the group order in general.</p>

    <p class="text-gray-300">2 TERMINOLOGY</p>

    <p class="text-gray-300">The set of groups possibly returned by a group sampler, i.e., <span class="math">[SG_{\\mathcal{G}}]</span>, is called in the sequel a group family <span class="math">\\mathcal{G}</span> and is required to be infinite. To make the specific group family <span class="math">\\mathcal{G}</span> more explicit in the sampler we often label the sampler accordingly as <span class="math">SG_{\\mathcal{G}}</span>, e.g., for above example the sampler would be named <span class="math">SG_{\\mathbb{Z}_{p/q}^*}</span>.</p>

    <p class="text-gray-300">Furthermore, the set of possible groups <span class="math">G</span> returned by <span class="math">SG_{\\mathcal{G}}</span> for a given fixed security parameter <span class="math">k</span>, i.e., <span class="math">[SG_{\\mathcal{G}}(1^k)]</span>, is called group siblings <span class="math">\\mathcal{G}_{SG(k)}</span>. This represents the groups of a given family <span class="math">\\mathcal{G}</span> with approximately the same "security". We assume that the group operation and equality test for the groups in <span class="math">\\mathcal{G}_{SG(k)}</span> can be computed efficiently (in <span class="math">k</span>); yet the underlying problem is supposedly asymptotically hard.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Slightly restricting the class of samplers, we require that the order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of all </span>G \\in \\mathcal{G}_{SG(k)}<span class="math"> is approximately the same. In particular, we assume that the order can be bounded in the security parameter, i.e., </span>\\exists d_1, d_2 &gt; 0 \\ \\forall k &gt; 1 \\ \\forall G \\in \\mathcal{G}_{SG(k)} : k^{d_1} \\leq \\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\leq k^{d_2}<span class="math">. For Schnorr signatures, in the example given above, a group sampler might choose the random primes </span>p<span class="math"> and </span>q<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2k<span class="math"> and </span>p = rq + 1<span class="math"> for an integer </span>r<span class="math"> sufficiently large to make DL hard to compute in security parameter </span>k<span class="math">. See Menezes et al. (1997) and Odlyzko (2000) for the state-of-the-art algorithms for computing discrete logarithms and Lenstra and Verheul (2001) for a methodology on how to choose parameters (as a function of the security parameter </span>k<span class="math">), illustrated concretely for group families such as </span>\\mathbb{Z}_p^*$ or elliptic curves.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Generator sampler <span class="math">Sg</span>: A function which, when given a description of a group <span class="math">G</span> for a fixed group family, randomly selects a generator <span class="math">g \\in G</span>. We assume that <span class="math">Sg</span> has always access somehow, e.g., via an oracle, to the factorization of the group order. This information is required by the sampler as the group index might not be sufficient to find generators efficiently. This covers the situation where an honest party chooses the group as well as the generator but keeps the factorization of the group order secret. However, it also implies that the factorization of the order should in general be public when the adversary chooses the generators.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the number of generators is $\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and, due to requirements on group orders mentioned above, always super-polynomial in the security parameter </span>k<span class="math">: Given the lower bound </span>\\forall n \\geq 5 : \\varphi(n) &gt; n / (6 \\log (\\log (n)))<span class="math"> (Fact 2.102, Menezes et al. 1997) and our size restrictions on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we have asymptotically the following relation: </span>\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 1 / O(\\log k) &gt; 1 / k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Problem instance sampler <span class="math">SPI_{\\mathcal{P}}</span>: A function indexed by a problem family <span class="math">\\mathcal{P}</span> which, when given a description of a structure instance <span class="math">SI</span> as input, ran</p>

    <p class="text-gray-300">5This restriction is mainly for easier treatment in various reductions and is not a hindrance in practical applications: On the one hand, the upper bound is tight (larger groups cannot have efficient group operations). On the other hand, the common approach in choosing a safe group order, e.g., as proposed by Lenstra and Verheul (2001), will relate the group order closely to the negligible probability of guessing a random element correctly, and hence result in exponential order.</p>

    <p class="text-gray-300">11</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">domly selects a problem instance <span class="math">PI</span>. Similarly to <span class="math">Sg</span>, we assume that <span class="math">SPI_{\\mathcal{P}}</span> gets always access to the factorization of the group order. Furthermore, <span class="math">SPI_{\\mathcal{P}}</span> gets also access to the discrete logarithms among the different generators in <span class="math">SI</span>. This is required for some problem families, e.g., IE and <span class="math">\\mathrm{RP}(n)</span>. In most cases and in all examples considered here, this corresponds to randomly selecting priv and deriving publ and sol from it. For example, a problem instance sampler <span class="math">SPI_{\\mathrm{DH}}</span> for the Diffie-Hellman problem family would return a tuple <span class="math">(SI, ((x,y), (g^x, g^y), \\{(g^{xy})\\}))</span> with <span class="math">x</span> and <span class="math">y</span> randomly picked from $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and </span>g<span class="math"> taken from </span>SI<span class="math">. When the specific problem family </span>\\mathcal{P}<span class="math"> is not relevant or clear from the context we abbreviate </span>SPI_{\\mathcal{P}}<span class="math"> to </span>SPI$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the running time of the samplers is always polynomially bounded in the security parameter <span class="math">k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If not stated explicitly we can always assume a uniform distribution of the sampled elements in the corresponding domains, as done in most cases of cryptographic applications. The rare exceptions are cases such as the c-DLSE assumption (Patel and Sundaram 1998; Gennaro 2000), an assumption on the difficulty of taking discrete logarithms when the random exponents are taken only from a small set, i.e., <span class="math">\\mathbb{Z}_{2^c}</span> with $c = \\omega (\\log \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> instead of </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, or the Diffie-Hellman Indistinguishability (DHI) assumptions introduced by Canetti (1997). The difficulty of these assumptions is not necessarily their individual specification, e.g., c-DLSE could be defined by suitably restricting the domain of the sol part of a DL problem instance. The deeper problem is that proving relations among these and other assumptions seems to require very specific tools, e.g., for randomization and analysis of resulting success probabilities, and are difficult to generalize as desirable for a classification as presented here. However, it might be worthwhile to investigate in future work whether these cases can be addressed by treating the sampling probability distribution as an explicit parameter of the classification. To make this extension promising, one would have to first find a suitable categorization of sampling probability distributions which: (1) captures the assumptions currently not addressed, and (2) offers tools assisting in proving reductions in a generalizable fashion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In defining assumptions, a cryptographer has various degrees of freedom related to the concrete mathematical formulation of the assumption, e.g., what kind of attackers are considered or over what values the probability spaces are defined.</p>

    <p class="text-gray-300">6As a practical consequence, it means that for such problem families either this information has to be public, e.g., the group index should allow the derivation of the factorization of the order, or the group and generators are chosen by the same party which samples the problem instance.</p>

    <p class="text-gray-300">7For <span class="math">SG</span> this holds trivially as we required samplers to be polynomial-time in their inputs. The input of <span class="math">Sg</span> are the outputs of a single call of a machine (<span class="math">SG</span>) polynomially bounded by <span class="math">k</span> and, therefore, can be polynomially upper bounded in <span class="math">k</span>. As the class of polynomials is closed under polynomial composition this holds also for <span class="math">Sg</span> and, using similar reasoning, also for <span class="math">SPI</span>.</p>

    <p class="text-gray-300">3 PARAMETERS OF DL-BASED ASSUMPTIONS</p>

    <p class="text-gray-300">To shed some light in these degrees of freedom we classify intractability assumptions for problems related to DL and relevant to many cryptographic applications. We identify the following orthogonal parameters. Additionally, we give for each of these parameters in a corresponding sublist different values which can produce significantly different assumptions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Problem family: The following problem families are useful (and often used) for cryptographic applications. As mentioned in Section 2.6 we define the problem family (or more precisely their problem instances) by a structure instance  <span class="math">SI</span>  (described abstractly by  <span class="math">G</span>  and  <span class="math">g_i</span> 's) and a tuple  <span class="math">(priv, publ, sol)</span> :</li>

    </ol>

    <p class="text-gray-300">DL (Discrete Logarithm):</p>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {D L}} := ((G, g), ((x), (g ^ {x}), \\{(x) \\})).</span></div>

    <p class="text-gray-300">DH (Diffie-Hellman):</p>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {D H}} := ((G, g), ((x, y), (g ^ {x}, g ^ {y}), \\{(g ^ {x y}) \\}))</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{GDH}(n)</span>  (Generalized Diffie-Hellman for  <span class="math">n \\geq 2</span> ):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} P I _ {\\mathrm {G D H} (n)} := ((G, g), ((x _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i \\in \\{1, \\dots , n \\}), \\\\ \\left(g ^ {\\prod_ {i \\in I} x _ {i}} \\mid I \\subset \\{1, \\dots , n \\}\\right), \\left\\{\\left(g ^ {\\prod_ {i = 1} ^ {n} x _ {i}}\\right) \\right\\}), \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">n</span>  is a fixed parameter.8</p>

    <p class="text-gray-300">SE (Square-Exponent):</p>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {S E}} := ((G, g), ((x), (g ^ {x}), \\{(g ^ {x ^ {2}}) \\})).</span></div>

    <p class="text-gray-300">IE (Inverse-Exponent):</p>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {I E}} := ((G, g), ((x), (g ^ {x}), \\{(g ^ {x ^ {- 1}}) \\})).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that for elements  $x' \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\setminus \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">  the value  </span>x^{-1}<span class="math">  is not defined. Therefore,  </span>PI_{\\mathrm{IE}}^{priv} (= (x))<span class="math">  has to contain an element of  </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> , contrary to the previously mentioned problem families where priv consists of elements from  </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{RP}(n)</span>  (Representation Problem for  <span class="math">n \\geq 2</span> ):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} P I _ {\\mathrm {R P} (n)} := ((G, g _ {1}, \\dots , g _ {n}), ((x _ {i} \\mid i \\in \\{1, \\dots , n \\}), (\\prod_ {i = 1} ^ {n} g _ {i} ^ {x _ {i}}), \\\\ \\{(x _ {i} ^ {\\prime} \\mid i \\in \\{1, \\ldots , n \\}) \\mid (x _ {i} ^ {\\prime} \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\land (\\prod_ {i = 1} ^ {n} g _ {i} ^ {x _ {i} ^ {\\prime}} = \\prod_ {i = 1} ^ {n} g _ {i} ^ {x _ {i}}) \\}), \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">A slightly generalized form \\mathrm{GDH}(n(k))  would allow n  to be a function in k . However, this function can grow at most logarithmically (otherwise the tuple would be of super-polynomial size!)</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">where <span class="math">n</span> is a fixed parameter.<span class="math">^9</span></p>

    <p class="text-gray-300"><strong>IAE</strong> (Inverted Additive Exponent Problem):</p>

    <div class="my-4 text-center"><span class="math-block">PI_{\\mathrm{IAE}} := ((G, g), ((x, y), (g^{1/x}, g^{1/y}), \\{(g^{1/(x+y)})\\})).</span></div>

    <p class="text-gray-300">Similar to IE, <span class="math">PI_{\\mathrm{IAE}}^{priv}</span> (<span class="math">= (x,y)</span>) consists of elements from <span class="math">\\mathbb{Z}_{[G]}^<em></span>. Additionally, it has to hold that <span class="math">x + y \\in \\mathbb{Z}_{[G]}^</em></span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Problem type</strong>: Each problem can be formulated in three variants.</li>

    </ol>

    <p class="text-gray-300"><strong>C</strong> (Computational): For a given problem instance <span class="math">PI</span> an algorithm <span class="math">\\mathcal{A}</span> succeeds if and only if it can solve <span class="math">PI</span>, i.e., <span class="math">\\mathcal{A}(\\ldots, PI^{publ}) \\in PI^{sol}</span>. For the Diffie-Hellman problem family this means that <span class="math">\\mathcal{A}</span> gets <span class="math">g^x</span> and <span class="math">g^y</span> as input and the task is to compute <span class="math">g^{xy}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There is a small twist in the meaning of <span class="math">\\mathcal{A}(\\ldots, PI^{publ}) \\in PI^{sol}</span>: As $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is not necessarily known, </span>\\mathcal{A}<span class="math"> might not be able to represent elements of </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> required in the solution set uniquely in their “principal” representation as elements of </span>\\{0, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}<span class="math">. Therefore, we allow </span>\\mathcal{A}<span class="math"> in these cases to return elements of </span>\\mathbb{Z}<span class="math"> and we implicitly reduce them mod </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>D</strong> (Decisional): For a given problem instance <span class="math">PI_0</span>, a random problem instance <span class="math">PI_1</span> chosen with the same structure instance using the corresponding problem instance sampler and a random bit <span class="math">b</span>, the algorithm <span class="math">\\mathcal{A}</span> succeeds if and only if it can decide whether a given solution chosen randomly from the solution set of one of the two problem instances corresponds to the given problem instance, i.e., <span class="math">\\mathcal{A}(\\ldots, PI^{publ}, sol_c) = b</span> where <span class="math">sol_c \\stackrel{\\pi}{\\leftarrow} PI_b^{sol}</span>. For the Diffie-Hellman problem family this means that <span class="math">\\mathcal{A}</span> gets <span class="math">g^x</span>, <span class="math">g^y</span> and <span class="math">g^c</span> (where <span class="math">c</span> is either <span class="math">xy</span> or <span class="math">x&#x27;y&#x27;</span> for $x', y' \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">) as input and the task is to decide whether </span>g^c<span class="math"> is </span>g^{xy}$ or not.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>M</strong> (Matching): For two given problem instances <span class="math">PI_0</span> and <span class="math">PI_1</span> and a random bit <span class="math">b</span>, the algorithm <span class="math">\\mathcal{A}</span> succeeds if and only if it can correctly associate the given solutions with their corresponding problem instances, i.e., <span class="math">\\mathcal{A}(\\ldots, PI_0^{publ}, PI_1^{publ}, sol_b, sol_{\\bar{b}}) = b</span> where <span class="math">sol_0 \\stackrel{\\pi}{\\leftarrow} PI_0^{sol}</span> and <span class="math">sol_1 \\stackrel{\\pi}{\\leftarrow} PI_1^{sol}</span>. For the Diffie-Hellman problem family this means that <span class="math">\\mathcal{A}</span> gets <span class="math">g^{x_0}</span>, <span class="math">g^{y_0}</span>, <span class="math">g^{x_1}</span>, <span class="math">g^{y_1}</span>, <span class="math">g^{x_b y_b}</span> and <span class="math">g^{x_{\\bar{b}} y_{\\bar{b}}}</span> as input and the task is to predict <span class="math">b</span>.</p>

    <p class="text-gray-300"><span class="math">^9</span>Similar to <span class="math">\\mathrm{GDH}(n)</span> one can also define here a slightly generalized form <span class="math">\\mathrm{RP}(n(k))</span>. In this case one can allow <span class="math">n(k)</span> to grow even polynomially.</p>

    <p class="text-gray-300"><span class="math">^{10}</span>This definition differs subtly from most other definitions of decisional problems: Here the distribution of the challenge <span class="math">sol_c</span> is for <span class="math">b = 1</span>, i.e., the random “wrong” challenge, according to the distribution of <span class="math">sol</span> induced by <span class="math">SPI</span> whereas most others consider it to be a (uniformly chosen) random element of <span class="math">G</span>. Taking DIE or DDH with groups where the order has small factors these distributions are quite different! Conceptually, the definition here seems more reasonable, e.g., in a key exchange protocol you distinguish a key from an arbitrary key, not an arbitrary random value. It also addresses nicely the case of samplers with non-uniform distributions.</p>

    <p class="text-gray-300">3 PARAMETERS OF DL-BASED ASSUMPTIONS</p>

    <p class="text-gray-300">Initially, only computational assumptions, which follow naturally from informal security requirements, were considered in cryptography. For example, a key exchange protocol should prevent the complete recovery of the key which is usually the solution part of an assumption. However, the later formalization of security requirements, in particular semantic security (Goldwasser and Micali 1984), requires often the indistinguishability of random variables. Taking again the example of a key exchange protocol, it was realized that if you do not want to make strong requirements on the particular use of exchanged keys but allow the modular and transparent composition of key exchange protocols with other protocols, e.g., for secure sessions, it is essential that an exchanged key is indistinguishable from random keys, i.e., not even partial information on the key is leaked. While this does not necessarily imply decisional assumptions, such assumptions might be indispensable for efficient systems: There is an efficient encryption scheme secure against adaptive adversaries under the Decisional Diffie-Hellman assumption (Cramer and Shoup 1998). Nonetheless, no system is known today which achieves the same security under a similar computational assumption in the standard model.[11] Finally, the matching variant was introduced by Frankel, Tsiounis, and Yung (1996) where it showed to be a useful tool to construct fair off-line cash. Handschuh, Tsiounis, and Yung (1999) later showed that the matching and the decisional variants of Diffie-Hellman are equivalent, a proof which is adaptable also to other problem families.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group family: Various group families are used in cryptographic applications. The following list contains some of the more common ones. For brevity we do not mention the specific parameter choice as a function of  <span class="math">k</span> . We refer you to, e.g., Lenstra and Verheul (2001), for concrete proposals:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_p^*</span> : The multiplicative groups of integers modulo a prime  <span class="math">p</span>  with group order  <span class="math">\\varphi(p)</span>  having at least one large prime factor. The group index is  <span class="math">p</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{p / q}^{<em>}</span> : The subgroups of  <span class="math">\\mathbb{Z}_p^</em></span>  of prime order  <span class="math">q</span> . The group index is the tuple  <span class="math">(p,q)</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_n^*</span> : The multiplicative groups of integers modulo a product  <span class="math">n</span>  of two (or more) large primes  <span class="math">p</span>  and  <span class="math">q</span>  with  <span class="math">p - 1</span>  and  <span class="math">q - 1</span>  containing at least one large prime factor. The group index is  <span class="math">n</span> .12</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Q}\\mathbb{R}_n^<em></span> : The subgroups of  <span class="math">\\mathbb{Z}_n^</em></span>  formed by the quadratic residues with  <span class="math">n</span>  product of two large safe <span class="math">^{13}</span>  primes. The group index is  <span class="math">n</span> .</p>

    <p class="text-gray-300">15</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">E_{a,b} / \\mathbb{F}_p</span>: The elliptic curves over <span class="math">\\mathbb{F}_p</span> with <span class="math">p</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{a,b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> prime with group index </span>(a,b,p)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The concrete choice of a group family has significant practical impact on aspects such as computation or bandwidth efficiency or suitability for a particular hardware but discussing this goes beyond the scope of this document, namely comparing assumptions. In this scope, it is mostly sufficient to classify simple and abstract properties of the chosen family and the public knowledge about a given group. We established the following two general criteria:</p>

    <p class="text-gray-300">(a) The factorization of the group order contains</p>

    <p class="text-gray-300"><strong>lprim</strong>: large prime factors (at least one). Formally, it has to hold that (with <span class="math">\\mathbb{P}</span> being the set of prime numbers):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall d &gt; 0 \\exists k_0 \\forall k &gt; k_0 \\forall G \\in \\mathcal{G}_{SG(k)} \\exists p \\in \\mathbb{P} \\exists r \\in \\mathbb{N}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= pr \\wedge p &gt; k^d,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>nsprim</strong>: no small prime factor. Formally, the following has to hold:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall d &gt; 0 \\exists k_0 \\forall k &gt; k_0 \\forall G \\in \\mathcal{G}_{SG(k)} \\nexists p \\in \\mathbb{P} \\exists r \\in \\mathbb{N}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= pr \\wedge p &lt; k^d,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>prim</strong>: only a single and large prime factor.</p>

    <p class="text-gray-300">Note that this is a strict hierarchy and later values imply earlier ones. There would also be an obvious fourth value, namely the order contains no large factor. However, in such cases no reasonable DL based assumption seems possible (Pohlig and Hellman 1978; Pollard 1978).</p>

    <p class="text-gray-300">(b) The group order is publicly</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>unknown,</li>

      <li>known,</li>

      <li><strong>fct</strong>: known including its complete¹⁴ factorization.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume any such public knowledge to be encoded in the description returned by a group sampler <span class="math">SG</span>. Note that in practice the group order is never completely unknown: at least an efficiently computable upper bound $B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ can always be derived, e.g., from the bit-length of the representation of group elements. This can be exploited, e.g., in achieving <strong>random self-reducibility</strong>¹⁵ (Blum and Micali 1984) for DDH even in the case where the order is not known (Boneh 1998).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The cryptographic application will determine which of above properties hold, e.g., a verifiable group generation will quite likely result in a publicly known factorization.</p>

    <p class="text-gray-300">¹⁴If the order is known then small prime factors can always be computed. Insofar the case here extends the knowledge about the factorization also to large prime factors.</p>

    <p class="text-gray-300">¹⁵Informally, a problem is random self-reducible if solving any problem instance can be reduced to solving the problem on a random instance, i.e., when given an instance <span class="math">x</span> we can efficiently randomize it to a random instance <span class="math">x_{\\mathcal{R}}</span> and can efficiently derive (derandomize) the solution for <span class="math">x</span> from the solution returned by an oracle call on <span class="math">x_{\\mathcal{R}}</span>.</p>

    <p class="text-gray-300">3 PARAMETERS OF DL-BASED ASSUMPTIONS</p>

    <p class="text-gray-300">Furthermore, note that the group families given above implicitly fix the properties of the group order factorization  <span class="math">(\\mathbb{Z}_{p^<em>}^</em>:\\mathrm{lprim};\\mathbb{Z}_{p / q}^<em>:\\mathrm{prim};\\mathbb{Z}_n^</em>:\\mathrm{lprim};\\mathbb{Q}\\mathbb{R}_n^<em>:\\mathrm{nsprim};E_{a,b} / \\mathbb{F}_p:\\mathrm{prim})</span> , and the public knowledge about it  <span class="math">(\\mathbb{Z}_{p^</em>}^<em>:\\mathrm{o};\\mathbb{Z}_{p / q^</em>}^<em>:\\mathrm{fct};\\mathbb{Z}_n^</em>:\\overline{\\mathrm{o}};\\mathbb{Q}\\mathbb{R}_n^*:\\overline{\\mathrm{o}};E_{a,b} / \\mathbb{F}_p:\\mathrm{fct})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computational capability of adversary: Potential algorithms solving a problem have to be computationally limited for number-theoretic assumptions to be meaningful (otherwise we could never assume their nonexistence). Here, we only consider probabilistic polynomial-time algorithms (called adversaries in the following). The adversary can be of</li>

    </ol>

    <p class="text-gray-300">u (Uniform complexity): There is a single probabilistic Turing machine  <span class="math">\\mathcal{A}</span>  which for any given finite input returns a (not necessarily correct) answer in polynomial time in its input length. As the complexity of Turing machines is measured in the bit-length of the inputs the inputs should be neither negligible nor super-polynomial in the security parameter  <span class="math">k</span> , otherwise the algorithm might not be able to write out the complete desired output or might become too powerful. To address this issue one normally passes an additional input  <span class="math">1^k</span>  to  <span class="math">\\mathcal{A}</span>  to lower bound the complexity and makes sure that the other inputs can be polynomially upper bounded in  <span class="math">k</span> . In all cases considered here, the inputs in the assumptions are already proportional to the security parameters, see remarks on the size of groups and on the runtime of samplers in Section 2.7. Therefore we can safely omit  <span class="math">1^k</span>  in the inputs of  <span class="math">\\mathcal{A}</span> . n (Non-uniform complexity): There is an (infinite) family of Turing machines  <span class="math">(\\mathcal{A}_k \\mid k \\in \\mathbb{N})</span>  with description size and running time of  <span class="math">\\mathcal{A}_k</span>  bounded by a polynomial in the security parameter  <span class="math">k</span> . Equivalent alternatives are a (single) Turing Machine with polynomial running time and an additional (not necessarily computable) family of auxiliary inputs polynomially bounded by the security parameter, or families of circuits with the number of gates polynomially bounded by the security parameter, respectively.</p>

    <p class="text-gray-300">Uniform assumptions are (in many cases strictly) weaker than corresponding non-uniform assumptions as any uniform algorithm is also a non-uniform one. Furthermore, all uniform black-box reductions map to the non-uniform case (but not necessarily vice-versa!) and henceforth most uniform proofs should map to their non-uniform counterpart. This makes uniform assumptions preferable over non-uniform assumptions (e.g., honest users are normally uniform and weaker assumptions are always prefer-</p>

    <p class="text-gray-300">17</p>

    <p class="text-gray-300">able over stronger ones). However, uniform assumptions also assume uniform adversaries which is a weaker adversary model than the model considering non-uniform adversaries. Furthermore, there are proofs which only work in a non-uniform model.</p>

    <p class="text-gray-300">Further, potentially interesting yet currently ignored, attacker capabilities would be bounds on space instead of (or in addition) to time. Adaptive adversaries do not seem of concern for pure assumptions.</p>

    <p class="text-gray-300">Ideally, one would consider larger, i.e., less restricted, classes of adversaries than the strictly polynomial-time one following from the definition from Section 2.3. It would seem more natural, e.g., to require polynomial behavior only on inputs valid for a given assumption or to allow algorithms, e.g., Las Vegas algorithms, with no a-priori bound on the runtime.¹⁸ Unfortunately, such classes are difficult to define properly and even harder to work with. However, as for each adversary of these classes there seems to be a closely related (yet not necessarily black-box constructible) strictly polynomial-time adversary with similar success probability, this restriction seems of limited practical relevance.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>“Algebraic knowledge”: A second parameter describing the adversary’s computational capabilities relates to the adversary’s knowledge on the group family. It can be one of the following:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\sigma</span> (Generic): This means that the adversary does not know anything about the structure (representation) of the underlying algebraic group. More precisely this means that all group elements are represented using an encoding function <span class="math">\\sigma(\\cdot)</span> drawn randomly from the set <span class="math">\\Sigma_{G,g}</span> of bijective¹⁹ functions $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\to G<span class="math">. Group operations can only be performed via the addition and inversion²⁰ oracles </span>\\sigma(x + y) \\gets \\sigma_{+}(\\sigma(x), \\sigma(y))<span class="math"> and </span>\\sigma(-x) \\gets \\sigma_{-}(x)<span class="math"> respectively, which the adversary receives as a black box (Shoup 1997; Nechaev 1994) together with </span>\\sigma(1)$, the generator.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we use <span class="math">\\sigma</span> in the following, we always mean the (not further specified) random encoding used for generic algorithms with a group <span class="math">G</span> and generator <span class="math">g</span> implied by the context. In particular, by <span class="math">\\mathcal{A}^{\\sigma}</span> we refer to a generic algorithm. To prevent clutter in the presentation, we do not explicitly encode group elements passed as inputs to such generic</p>

    <p class="text-gray-300">¹⁸ However, we would have to restrict the considerations to polynomial time runs when measuring the success probability of adversaries.</p>

    <p class="text-gray-300">¹⁹ Others, e.g., Babai and Szemerédi (1984) and Boneh and Lipton (1996), considered the more general case where elements are not necessarily unique and there is a separate equality oracle. However, that model is too weak to cover some important algorithms, e.g., Pohlig and Hellman (1978), which are intuitively “generic”. Furthermore, the impossibility results mentioned later still hold when transferred to the more general case.</p>

    <p class="text-gray-300">²⁰ Computing inverses is usually efficient only when the group order is known. However, note that all impossibility results — the main use of generic adversaries — considered later hold naturally also without the inversion oracle.</p>

    <p class="text-gray-300">algorithms. However, they should all be considered suitable encoded with <span class="math">\\sigma</span>. (marked by absence of <span class="math">\\sigma</span>) (Specific): In this case the adversary can also exploit special properties (e.g., the encoding) of the underlying group.</p>

    <p class="text-gray-300">This separation is interesting for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tight lower bounds on the complexity of some DL-based assumptions can lead to provably hard assumptions in the generic model <em>(Shoup 1997; Maurer and Wolf 1998b)</em>. No such results are known in the standard model. However, similar to the random oracle model <em>(Bellare and Rogaway 1993)</em> the generic model is idealized and related pitfalls lure when used in a broader context than simple assumptions <em>(Fischlin 2000)</em>.</li>

      <li>A number of algorithms computing discrete logarithms are generic in their nature. Two prominent ones are <em>Pohlig-Hellman (1978)</em> and <em>Pollard-<span class="math">\\rho</span> (1978)</em> paired with Shanks Baby-Step Giant-Step optimization. Furthermore, most reductions are generic.</li>

      <li>However, exploiting some structure in the group can lead to faster algorithms, e.g., for finite fields there is the class of index-calculus methods and in particular the generalized number field sieve (GNFS) <em>(Gordon 1993b; Schirokauer 1993)</em> with sub-exponential expected running time.</li>

      <li>Nonetheless, for many group families, e.g., elliptic curves, no specific algorithms are known which compute the discrete logarithms better than the generic algorithms mentioned above.</li>

    </ul>

    <p class="text-gray-300">Note that a generic adversary can always be transformed to a specific adversary but not necessarily vice-versa. Therefore, a reduction between two generic assumptions is also a reduction between the specific counterparts of the two assumptions. However, proofs of the hardness of generic assumptions or the non-existence of relations among them do <em>not</em> imply their specific counterparts!</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>“Granularity of probability space”: Depending on what part of the structure instance is a-priori fixed (i.e., the assumption has to hold for all such parameters) or not (i.e., the parameters are part of the probability space underlying an assumption) we can distinguish among the following situations:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Low-granular): The group family (e.g., prime order subgroups of <span class="math">\\mathbb{Z}_{p}^{*}</span>) is fixed but not the specific structure instance (e.g., parameters <span class="math">p</span>, <span class="math">q</span> and generators <span class="math">g_{i}</span> for the example group family given above).</li>

      <li>(Medium-granular): The group (e.g., <span class="math">p</span> and <span class="math">q</span>) but not the generators <span class="math">g_{i}</span> are fixed.</li>

    </ul>

    <p class="text-gray-300">High-granular): The group as well as the generators <span class="math">g_{i}</span> are fixed.</p>

    <p class="text-gray-300">An assumption defines a family of probability spaces <span class="math">\\mathcal{D}_{i}</span>, where the index <span class="math">i</span> is the tuple of <span class="math">k</span> and, depending on granularity, group and generator, i.e., all parameters with an all-quantifier in the assumption statement. Each probability space <span class="math">\\mathcal{D}_{i}</span> is defined over problem instances, random coins for the adversary, and, again depending on granularity, groups and generators. Note that for a given <span class="math">k</span> there are always only polynomially many <span class="math">\\mathcal{D}_{i}</span>. In the sequel we use the term probability space instance (PSI) for a single probability space <span class="math">\\mathcal{D}_{i}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Success probability: This parameter gives an (asymptotic) upper bound on how large a success probability we tolerate from an adversary. The success probability is measured over the family of probability space instances <span class="math">\\mathcal{D}_{i}</span>. Violation of an assumption means that there exists an algorithm <span class="math">\\mathcal{A}</span> whose success probability <span class="math">\\alpha(k)</span> reaches or exceeds this bound for infinitely many <span class="math">k</span> in respect to at least one of the corresponding probability space instances <span class="math">\\mathcal{D}_{i}</span>.</li>

    </ol>

    <p class="text-gray-300">The upper bound and the corresponding adversary can be classified in the following types:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Perfect): The strict upper bound on the success probability is <span class="math">1</span>. Therefore, a perfect adversary algorithm <span class="math">\\mathcal{A}</span> with success probability <span class="math">\\alpha(k)</span> has to solve the complete probability mass of infinitely many <span class="math">\\mathcal{D}_{i}</span>, i.e., <span class="math">\\alpha(k)\\not&lt;\\infty 1</span>.</li>

      <li>(Strong): The bound is defined by the error probability which has to be non-negligible. Therefore, a strong adversary algorithm <span class="math">\\mathcal{A}</span> has to be successful for infinitely many <span class="math">\\mathcal{D}_{i}</span> with overwhelming probability., i.e., if <span class="math">\\alpha(k)</span> is the success probability of <span class="math">\\mathcal{A}</span> then <span class="math">1-\\alpha(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span>.</li>

      <li>(Invariant): The strict upper bound is a fixed and given constant <span class="math">0&lt;\\epsilon&lt;1</span>. Therefore, the success probability <span class="math">\\alpha(k)</span> of an invariant adversary algorithm <span class="math">\\mathcal{A}</span> has to be larger than <span class="math">\\epsilon</span> for infinitely many <span class="math">\\mathcal{D}_{i}</span>, i.e., <span class="math">\\alpha(k)\\not&lt;\\infty\\epsilon</span>.</li>

      <li>(Weak): All non-negligible functions are upper bounds, i.e., only negligible success probabilities are tolerated. Therefore, a weak adversary algorithm <span class="math">\\mathcal{A}</span> has to be successful with a not negligible fraction of the probability mass of <span class="math">\\mathcal{D}_{i}</span> for infinitely many <span class="math">\\mathcal{D}_{i}</span>, i.e., if <span class="math">\\alpha(k)</span> is the success probability of <span class="math">\\mathcal{A}</span> then <span class="math">\\alpha(k)\\not&lt;\\infty 1/\\mathsf{poly}(k)</span>.</li>

    </ol>

    <p class="text-gray-300">An assumption requiring the nonexistence of perfect adversaries corresponds to worst-case complexity, i.e., if the assumption holds then there are at least a few hard instances. However, what is a-priori required in most cases in cryptography is a stronger assumption requiring the nonexistence of even weak adversaries, i.e., if the assumption holds then most problem instances are hard.</p>

    <p class="text-gray-300">4 DEFINING ASSUMPTIONS</p>

    <p class="text-gray-300">The classification given above is certainly not exhaustive. The exploration of new problem families, e.g., related to arbitrary multivariate functions in the exponents as investigated by Kiltz (2001), might require additional values for the existing parameters. This can be done without much impact on the classification itself and other results. However, the need for a new dimension such as adding probability distributions as a separate parameter (see Section 2.7) would be of much larger impact. Nevertheless, from the current experience, above classification seems quite satisfactory.</p>

    <p class="text-gray-300">Using the parameters and corresponding values defined in the previous section we can define intractability assumptions in a compact and precise way.</p>

    <p class="text-gray-300">The notation for a given assumption is</p>

    <div class="my-4 text-center"><span class="math-block">\\$s-\\$t\\$P^{\\$}a(c:\\$c;g:\\$g;f:\\$G)</span></div>

    <p class="text-gray-300">where for each parameter there is a placeholder \\$X which is instantiated by the labels corresponding to the value of that parameter in the given assumption. The placeholders and values (with - denoting that this value can be absent in the notation and has the same meaning as a corresponding wild card) are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\<span class="math">s: The algorithm&#x27;s success probability (\\</span>s \\in \\{1, (1 - 1 / \\mathsf{poly}(k)), \\epsilon, 1 / \\mathsf{poly}(k)\\}).</li>

      <li>\\<span class="math">t: The problem type (\\</span>t \\in \\{C, D, M\\}).</li>

      <li>\\<span class="math">P: The problem family (\\</span>P \\in \\{DL, DH, GDH(n), SE, IE, RP(n), IAE\\}).</li>

      <li>\\<span class="math">a: The algebraic knowledge of the algorithm (\\</span>a \\in \\{\\sigma, -\\}).</li>

      <li>\\<span class="math">c: The algorithm&#x27;s complexity (\\</span>c \\in \\{u, n\\}).</li>

      <li>\\<span class="math">g: The granularity of the probability space (\\</span>g \\in \\{h, m, l\\}).</li>

      <li>\\<span class="math">G: The group family (\\</span>G \\in \\{lprim, nsprim, prim, -\\} \\times \\{\\overline{0}, o, fct, -\\} \\times \\{\\mathbb{Z}_p^<em>, \\mathbb{Z}_{p/q}^</em>, \\mathbb{Z}_n^<em>, \\mathbb{Q}\\mathbb{R}_n^</em>, E_{a,b} / \\mathbb{F}_p, -\\}).</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is best illustrated in an example: The term</p>

    <div class="my-4 text-center"><span class="math-block">1 / \\operatorname {p o l y} (k) - \\mathrm {D D H} ^ {\\sigma} (\\mathrm {c}: \\mathrm {u}; \\mathrm {g}: \\mathrm {h}; \\mathrm {f}: \\text {p r i m})</span></div>

    <p class="text-gray-300">denotes the decisional (D) Diffie-Hellman (DH) assumption in prime-order groups (f:prim) with weak success probability  <span class="math">(1 / \\mathsf{poly}(k))</span> , limited to generic algorithms  <span class="math">(\\sigma)</span>  of uniform complexity (c:u), and with high granularity (g:h).</p>

    <p class="text-gray-300">To refer to classes of assumptions we use wild cards  <span class="math">(\\ast)</span>  and sets  <span class="math">(\\{\\dots \\})</span>  of parameter values, e.g.,</p>

    <p class="text-gray-300">21The parameters for \\mathcal{G}  are not completely orthogonal in the sense that some combinations do not exist, e.g., (\\mathrm{prim},\\cdot ,\\mathbb{Q}\\mathbb{R}_n^<em>) , and some result in nonsensical assumptions, e.g., (\\cdot ,\\mathrm{fct},\\mathbb{Z}_n^</em>) . Nonetheless, the assumptions still can be defined and insofar this is not really of concern here.</p>

    <p class="text-gray-300">denotes the class of computational (C) Diffie-Hellman (DH) assumptions with uniform complexity (c:u), limited to generic algorithms (<span class="math">\\sigma</span>), with high-granular probability space (g:h), with some error (<span class="math">\\{(1-1/\\mathsf{poly}(k)),\\epsilon,1/\\mathsf{poly}(k)\\}</span>) and based on an arbitrary group family (f:*).</p>

    <p class="text-gray-300">Let us turn now to the meaning of an assumption described by above notation: By stating that an assumption <span class="math">\\s</span>s-<span class="math">\\t&lt;span class=&quot;math-block&quot;&gt;\\mathcal{P}^{\\s}</span>a(c:<span class="math">c;g:</span>g;f:</span>\\mathcal{G}<span class="math">) holds, we believe that asymptotically no algorithm of complexity </span>\\c<span class="math">c and algebraic knowledge </span>\\a<span class="math">can solve (random) problem instances of a problem family </span>\\mathcal{P}<span class="math"> with problem type </span>\\t chosen from groups in <span class="math">\\mathcal{G}</span> with sufficient (as specified by <span class="math">\\s</span>) success probability where the probability space is defined according to granularity <span class="math">\\g</span>.</p>

    <p class="text-gray-300">The precise and formal definitions follow naturally and quite mechanically. In defining an assumption we always require a bound <span class="math">k_{0}</span> for the asymptotic behavior which says that beyond that bound no adversary will be successful. As further “ingredients” there are polynomials defined by their maximal degree <span class="math">d_{1}</span>, <span class="math">d_{2}</span> and <span class="math">d_{3}</span> which bind the error probability, time and description of programs, respectively. Finally, we require a machine (or family thereof) <span class="math">\\mathcal{A}</span> (<span class="math">\\mathcal{A}_{i}</span>) trying to solve the problem, and various quantifiers specifying (using the various samplers) the required parameters for a problem instance <em>PI</em> to solve.</p>

    <p class="text-gray-300">Finally, we denote the class of uniform complexity adversaries by <span class="math">\\mathcal{UPTM}</span> and the corresponding class of generic adversaries by <span class="math">\\mathcal{UPTM}^{\\sigma}</span>. The class of non-uniform complexity and generic non-uniform complexity adversaries is denoted similarly by <span class="math">\\mathcal{NPTM}</span> and <span class="math">\\mathcal{NPTM}^{\\sigma}</span>, respectively.</p>

    <p class="text-gray-300">To illustrate the formal details of assumptions and to provide a feel for the various parameters we offer three sets of examples. In each set we vary one of the parameters, namely: (1) the computational complexity, (2) the less obvious and often overlooked granularity parameter, and (3) the success probability. The complete details on how to derive the formal assumption statement from the parameters can be found in Appendix A:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Weak computational DL assumptions in the generic model, a group order with at least one large prime factor and the two variants of complexity measures (see Parameter 4). Remember that <span class="math">PI_{\\text{DL}}:=(SI,((x),(g^{x}),\\{(x)\\}))</span>, <span class="math">PI_{\\text{DL}}^{publ}:=(g^{x})</span> and <span class="math">PI_{\\text{DL}}^{sol}:=\\{(x)\\}</span>. Further, let <span class="math">SG_{\\mathcal{G}}</span> be a group sampler of some group family <span class="math">\\mathcal{G}</span> where the groups have an order with at least one large prime factor.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assumption <span class="math">1/\\mathsf{poly}(k)</span>-CDL^{σ}(c:u;g:h;f:lprim), i.e., the uniform complexity variant:</li>

    </ol>

    <p class="text-gray-300">4 DEFINING ASSUMPTIONS</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A}^{\\sigma} \\in \\mathcal{UPTM}^{\\sigma};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in [SG_{\\mathcal{G}}(1^k)];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [Sg(G)];</span></div>

    <div class="my-4 text-center"><span class="math-block">SI \\leftarrow (G, g);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Prob}[\\mathcal{A}^{\\sigma}(\\mathcal{C}, SI, PI_{\\mathrm{DL}}^{publ}) \\in PI_{\\mathrm{DL}}^{sol} :: \\\\ \\sigma \\stackrel{\\approx}{\\leftarrow} \\Sigma_{G,g}; \\\\ PI_{\\mathrm{DL}} \\leftarrow SPI_{\\mathrm{DL}}(SI); \\\\ \\mathcal{C} \\stackrel{\\approx}{\\leftarrow} \\mathcal{U} \\\\ ] &amp;lt; 1/k^{d_1}. \\end{array}</span></div>

    <p class="text-gray-300">(b) Same setting as above except now with a non-uniform adversary <span class="math">(1/\\mathsf{poly}(k)\\text{-CDL}^{\\sigma}(\\mathrm{c:n};\\mathrm{g:h};\\mathrm{f:lprim}))</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall (\\mathcal{A}_i^{\\sigma} \\mid i \\in \\mathbb{N}) \\in \\mathcal{NPTM}^{\\sigma};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in [SG_{\\mathcal{G}}(1^k)];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [Sg(G)];</span></div>

    <div class="my-4 text-center"><span class="math-block">SI \\leftarrow (G, g);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Prob}[\\mathcal{A}_k^{\\sigma}(\\mathcal{C}, SI, PI_{\\mathrm{DL}}^{publ}) \\in PI_{\\mathrm{DL}}^{sol} :: \\\\ \\sigma \\stackrel{\\approx}{\\leftarrow} \\Sigma_{G,g}; \\\\ PI_{\\mathrm{DL}} \\leftarrow SPI_{\\mathrm{DL}}(SI); \\\\ \\mathcal{C} \\stackrel{\\approx}{\\leftarrow} \\mathcal{U} \\\\ ] &amp;lt; 1/k^{d_1}. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Weak decisional DH assumption variants for prime order subgroups of <span class="math">\\mathbb{Z}_p^*</span> with varying granularity. Recall that <span class="math">PI_{\\mathrm{DH}} := (SI, ((x,y), (g^x, g^y), \\{(g^{xy})\\})</span>, <span class="math">PI_{DH}^{publ} := (g^x, g^y)</span> and <span class="math">PI_{DH}^{sol} := \\{(g^{xy})\\}</span>.</li>

    </ol>

    <p class="text-gray-300">(a) Assumption <span class="math">1/\\mathsf{poly}(k)\\text{-DDH}(\\mathrm{c:u};\\mathrm{g:h};\\mathrm{f:}\\mathbb{Z}_{p/q}^*)</span>, i.e., with high granularity:</p>

    <p class="text-gray-300">23</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A} \\in \\mathcal{UPTM};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in \\left[ SG_{\\mathbb{Z}_{p/q}^*}(1^k) \\right];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [Sg(G)];</span></div>

    <div class="my-4 text-center"><span class="math-block">SI \\leftarrow (G, g);</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left( \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Prob}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{DH}/0}^{publ}, sol_{\\mathrm{DH}/c}) = b :: \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad b \\stackrel{\\mathrm{sc}}{=} \\{0, 1\\}; \\\\ \\quad PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad PI_{\\mathrm{DH}/1} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad sol_{\\mathrm{DH}/c} \\stackrel{\\mathrm{sc}}{=} PI_{\\mathrm{DH}/b}^{sol}; \\\\ \\quad \\mathcal{C} \\stackrel{\\mathrm{sc}}{=} \\mathcal{U} \\\\ \\quad \\left. \\left. -1/2 \\mid \\cdot 2 \\right) &lt; 1/k^{d_1}. \\right. \\end{array} $$</p>

    <p class="text-gray-300">(b) As above except now with medium granularity <span class="math">(1/poly(k)-DDH(c:u; g:m; f:\\mathbb{Z}_{p/q}^*))</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A} \\in \\mathcal{UPTM};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in \\left[ SG_{\\mathbb{Z}_{p/q}^*}(1^k) \\right];</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left( \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Prob}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{DH}/0}^{publ}, sol_{\\mathrm{DH}/c}) = b :: \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad g \\leftarrow Sg(G); \\\\ \\quad SI \\leftarrow (G, g); \\\\ \\quad b \\stackrel{\\mathrm{sc}}{=} \\{0, 1\\}; \\\\ \\quad PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad PI_{\\mathrm{DH}/1} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad sol_{\\mathrm{DH}/c} \\stackrel{\\mathrm{sc}}{=} PI_{\\mathrm{DH}/b}^{sol}; \\\\ \\quad \\mathcal{C} \\stackrel{\\mathrm{sc}}{=} \\mathcal{U} \\\\ \\quad \\left. \\left. -1/2 \\mid \\cdot 2 \\right) &lt; 1/k^{d_1}. \\right. \\end{array} $$</p>

    <p class="text-gray-300">(c) As above except now with low granularity <span class="math">(1/poly(k)-DDH(c:u; g:l; f:\\mathbb{Z}_{p/q}^*))</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A} \\in \\mathcal{UPTM};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left( \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Prob}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{DH}/0}^{publ}, sol_{\\mathrm{DH}/c}) = b :: \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad G \\leftarrow SG_{\\mathbb{Z}_{p/q}^*}(1^k); \\\\ \\quad g \\leftarrow Sg(G); \\\\ \\quad SI \\leftarrow (G, g); \\\\ \\quad b \\stackrel{\\mathrm{sc}}{=} \\{0, 1\\}; \\\\ \\quad PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad PI_{\\mathrm{DH}/1} \\leftarrow SPI_{\\mathrm{DH}}(SI); \\\\ \\quad sol_{\\mathrm{DH}/c} \\stackrel{\\mathrm{sc}}{=} PI_{\\mathrm{DH}/b}^{sol}; \\\\ \\quad \\mathcal{C} \\stackrel{\\mathrm{sc}}{=} \\mathcal{U} \\\\ \\quad \\left. \\left. -1/2 \\mid \\cdot 2 \\right) &lt; 1/k^{d_1}. \\right. \\end{array} $$</p>

    <p class="text-gray-300">4 DEFINING ASSUMPTIONS</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Matching IE assumptions in <span class="math">\\mathbb{Q}\\mathbb{R}_n^+</span> with varying success probability. Recall that <span class="math">PI_{\\mathrm{IE}} := (SI, ((x), (g^x), \\{(g^{x^{-1}})\\}))</span>, <span class="math">PI_{IE}^{publ} := (g^x)</span> and <span class="math">PI_{IE}^{sol} := \\{(g^{x^{-1}})\\}</span>.</li>

    </ol>

    <p class="text-gray-300">(a) Assumption <span class="math">1 / \\mathsf{poly}(k)</span>-MIE(c:u; g:h; f: <span class="math">\\mathbb{Q}\\mathbb{R}_n^+</span>), i.e., the variant with weak success probability:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal {A} \\in \\mathcal {U P T M};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall d _ {1} &amp;gt; 0; \\exists k _ {0}; \\forall k &amp;gt; k _ {0};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in \\left[ S G _ {\\mathbb {Q R} _ {n} ^ {*}} \\left(1 ^ {k}\\right) \\right];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [ S g (G) ];</span></div>

    <div class="my-4 text-center"><span class="math-block">S I \\leftarrow (G, g);</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {P r o b} [ \\mathcal {A} (\\mathcal {C}, S I, P I _ {\\mathrm {I E} / 0} ^ {p u b l}, P I _ {\\mathrm {I E} / 1} ^ {p u b l}, s o l _ {\\mathrm {I E} / b}, s o l _ {\\mathrm {I E} / \\bar {b}}) = b:: \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">b \\stackrel {\\approx} {\\leftarrow} \\{0, 1 \\};</span></div>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {I E} / 0} \\leftarrow S P I _ {\\mathrm {I E}} (S I);</span></div>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {I E} / 1} \\leftarrow S P I _ {\\mathrm {I E}} (S I);</span></div>

    <div class="my-4 text-center"><span class="math-block">s o l _ {\\mathrm {I E} / 0} \\stackrel {\\approx} {\\leftarrow} P I _ {\\mathrm {D H} / 0} ^ {s o l};</span></div>

    <div class="my-4 text-center"><span class="math-block">s o l _ {\\mathrm {I E} / 1} \\stackrel {\\approx} {\\leftarrow} P I _ {\\mathrm {D H} / 1} ^ {s o l};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C} \\stackrel {\\approx} {\\leftarrow} \\mathcal {U}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] - 1 / 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2) &lt; 1 / k ^ {d _ {1}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(b) Same setting as above except now with invariant success probability <span class="math">\\epsilon</span> (<span class="math">\\epsilon</span>-MIE(c:u; g:h; f: <span class="math">\\mathbb{Q}\\mathbb{R}_n^+</span>) ):</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal {A} \\in \\mathcal {U P T M};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\exists k _ {0}; \\forall k &amp;gt; k _ {0};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in \\left[ S G _ {\\mathbb {Q R} _ {n} ^ {*}} \\left(1 ^ {k}\\right) \\right];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [ S g (G) ];</span></div>

    <div class="my-4 text-center"><span class="math-block">S I \\leftarrow (G, g);</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {P r o b} [ \\mathcal {A} (\\mathcal {C}, S I, P I _ {\\mathrm {I E} / 0} ^ {p u b l}, P I _ {\\mathrm {I E} / 1} ^ {p u b l}, s o l _ {\\mathrm {I E} / b}, s o l _ {\\mathrm {I E} / \\bar {b}}) = b:: \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">b \\stackrel {\\approx} {\\leftarrow} \\{0, 1 \\};</span></div>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {I E} / 0} \\leftarrow S P I _ {\\mathrm {I E}} (S I);</span></div>

    <div class="my-4 text-center"><span class="math-block">P I _ {\\mathrm {I E} / 1} \\leftarrow S P I _ {\\mathrm {I E}} (S I);</span></div>

    <div class="my-4 text-center"><span class="math-block">s o l _ {\\mathrm {I E} / 0} \\stackrel {\\approx} {\\leftarrow} P I _ {\\mathrm {D H} / 0} ^ {s o l};</span></div>

    <div class="my-4 text-center"><span class="math-block">s o l _ {\\mathrm {I E} / 1} \\stackrel {\\approx} {\\leftarrow} P I _ {\\mathrm {D H} / 1} ^ {s o l};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C} \\stackrel {\\approx} {\\leftarrow} \\mathcal {U};</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] - 1 / 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2) &lt; \\epsilon .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(c) Same setting as above except now with strong success probability <span class="math">((1 - 1 / \\mathsf{poly}(k))</span>-MIE(c:u; g:h; f: <span class="math">\\mathbb{Q}\\mathbb{R}_n^+</span>)):</p>

    <p class="text-gray-300">25</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A} \\in \\mathcal{UPTM};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\exists d_1 &amp;gt; 0; \\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in [SG_{\\mathbb{QR}_n^*}(1^k)];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [Sg(G)];</span></div>

    <div class="my-4 text-center"><span class="math-block">SI \\leftarrow (G, g);</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{(i) Prob}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{IE}/0}^{publ}, PI_{\\mathrm{IE}/1}^{publ}, sol_{\\mathrm{IE}/b}, sol_{\\mathrm{IE}/\\bar{b}}) = b :: \\\\ b \\stackrel{\\approx}{\\leftarrow} \\{0, 1\\}; \\\\ PI_{\\mathrm{IE}/0} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ PI_{\\mathrm{IE}/1} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ sol_{\\mathrm{IE}/0} \\stackrel{\\approx}{\\leftarrow} PI_{\\mathrm{DH}/0}^{sol}; \\\\ sol_{\\mathrm{IE}/1} \\stackrel{\\approx}{\\leftarrow} PI_{\\mathrm{DH}/1}^{sol}; \\\\ \\mathcal{C} \\stackrel{\\approx}{\\leftarrow} \\mathcal{U} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]-1/2 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; (1 - 1/k^{d_1}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">(d) Same setting as above except with no tolerated error, i.e., perfect success probability (1-MIE(c:u; g:h; f: <span class="math">\\mathbb{QR}_n^*</span> )):</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathcal{A} \\in \\mathcal{UPTM};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\exists k_0; \\forall k &amp;gt; k_0;</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall G \\in [SG_{\\mathbb{QR}_n^*}(1^k)];</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall g \\in [Sg(G)];</span></div>

    <div class="my-4 text-center"><span class="math-block">SI \\leftarrow (G, g);</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\text{(i) Prob}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{IE}/0}^{publ}, PI_{\\mathrm{IE}/1}^{publ}, sol_{\\mathrm{IE}/b}, sol_{\\mathrm{IE}/\\bar{b}}) = b :: \\\\ b \\stackrel{\\approx}{\\leftarrow} \\{0, 1\\}; \\\\ PI_{\\mathrm{IE}/0} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ PI_{\\mathrm{IE}/1} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ sol_{\\mathrm{IE}/0} \\stackrel{\\approx}{\\leftarrow} PI_{\\mathrm{DH}/0}^{sol}; \\\\ sol_{\\mathrm{IE}/1} \\stackrel{\\approx}{\\leftarrow} PI_{\\mathrm{DH}/1}^{sol}; \\\\ \\mathcal{C} \\stackrel{\\approx}{\\leftarrow} \\mathcal{U} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]-1/2 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">To express relations among assumptions we use the following operators where <span class="math">P</span> and <span class="math">Q</span> are assumptions as previously defined:</p>

    <p class="text-gray-300"><span class="math">P \\Rightarrow Q</span> means that if assumption <span class="math">P</span> holds, so does assumption <span class="math">Q</span>, i.e., <span class="math">P(Q)</span> is a stronger (weaker) assumption than <span class="math">Q(P)</span>. Vice-versa, it also means that if there is a polynomially-bounded algorithm <span class="math">\\mathcal{A}_Q</span> breaking assumption <span class="math">Q</span> then there is also another polynomially-bounded algorithm <span class="math">\\mathcal{A}_P</span> which breaks assumption <span class="math">P</span>. Usually, this is shown in a <strong>black-box reduction</strong> where <span class="math">\\mathcal{A}_P</span>, or more precisely <span class="math">\\mathcal{A}_P^{\\mathcal{A}_Q}</span>, breaks assumption <span class="math">P</span> with oracle access to <span class="math">\\mathcal{A}_Q</span>. As a special case for invariant assumptions, we mean with <span class="math">\\epsilon - P \\Rightarrow \\epsilon - Q</span> that it should hold that <span class="math">\\forall \\epsilon&#x27; \\in ]0,1[ \\exists \\epsilon&#x27;&#x27; \\in ]0,1[: \\epsilon&#x27;&#x27; - P \\Rightarrow \\epsilon&#x27; - Q</span>.</p>

    <p class="text-gray-300"><span class="math">P\\iff Q</span> means that <span class="math">P\\implies Q</span> and <span class="math">Q\\implies P</span>, i.e., <span class="math">P</span> and <span class="math">Q</span> are assumptions of the same (polynomial) complexity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P\\xrightarrow{\\alpha^{\\prime}\\geq f_{\\alpha}(t,\\alpha,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ldots);\\ t^{\\prime}\\leq f_{t}(t,\\alpha,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ldots)}\\;Q<span class="math"> is used to specify the quality of the reduction, i.e., the concrete security. It means that if assumption </span>Q<span class="math"> can be broken in time </span>t<span class="math"> and with success probability </span>\\alpha<span class="math"> we can break </span>P<span class="math"> in time </span>t^{\\prime}<span class="math"> and with success probability </span>\\alpha^{\\prime}<span class="math"> bounded by functions </span>f_{t}<span class="math"> and </span>f_{\\alpha}<span class="math">, respectively. To measure time, we consider group operations and equality tests having unit-cost each and oracle calls having cost </span>t<span class="math">. Obviously, the cost of group operations, the runtime and the success probability of the oracle, and the size of the groups are not constant but functions depending on the security parameter </span>k<span class="math">, e.g., </span>\\alpha<span class="math"> should be written more precisely as </span>\\alpha(k)<span class="math">. However, for better readability we omit this and all asymptotic aspects in the presentation. For the identical reason, we also cautiously use the </span>O(\\cdot)$ notation even if we slightly lose precision.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us illustrate this with the following result from <em>Maurer and Wolf (1996)</em> (for more information on this result see also page 32):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon\\text{-CDH(c:u;\\,g:h;\\,f:o)}\\;\\xrightarrow{\\alpha^{\\prime}=\\alpha^{3};\\ t^{\\prime}=3t+O(\\log\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)^{2})}\\;\\epsilon\\text{-CSE(c:u;\\,g:h;\\,f:o)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This means that with three calls to an oracle breaking <span class="math">\\epsilon\\text{-CSE(c:u;\\,g:h;\\,f:o)}</span> and additional $O(\\log\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)^{2})<span class="math"> group operations we can achieve a success probability of at least </span>\\alpha^{3}<span class="math"> in breaking </span>\\epsilon\\text{-CDH(c:u;\\,g:h;\\,f:o)}<span class="math"> where </span>t<span class="math"> and </span>\\alpha$ are the runtime and the success probability of the oracle, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simple assumptions, above is interpreted without syntactical conditions on <span class="math">P</span> and <span class="math">Q</span>, i.e., they may be arbitrary assumptions. If a relation refers to assumption classes, i.e., they contain some parameters which are not fully specified and contain wild cards or sets, there is the following syntactical constraint: The parameters which are not fully specified have to be equal for both assumptions <span class="math">P</span> and <span class="math">Q</span>. The meaning is as follows: The relation <span class="math">P</span> OP <span class="math">Q</span> holds for any assumption <span class="math">P^{\\prime}</span> and <span class="math">Q^{\\prime}</span> we can instantiate from <span class="math">P</span> and <span class="math">Q</span> by fixing all not fully specified parameters to any matching value with the additional condition that these values are identical for <span class="math">P^{\\prime}</span> and <span class="math">Q^{\\prime}</span>. To give an example,</p>

    <p class="text-gray-300"><span class="math"><em>\\text{-CDH}^{</em>}(\\text{c:<em>;\\,g:}\\{\\text{h,m}\\};\\text{f:o})\\implies</em>\\text{-CSE}^{<em>}(\\text{c:</em>;\\,g:}\\{\\text{h,m}\\};\\text{f:o})</span></p>

    <p class="text-gray-300">illustrates that the result from Maurer and Wolf mentioned above can be generalized — as proven later in this paper — to high and medium granularity with arbitrary success probability, complexity and algebraic knowledge.</p>

    <p class="text-gray-300">Furthermore, if we are referring to oracle-assumptions, i.e., assumptions where we give adversaries access to auxiliary oracles, we indicate it by listing the oracles at the end of the list in the assumption term. For example, the assumption <span class="math">1/\\mathsf{poly}(k)\\text{-CDL}^{\\sigma}(\\text{c:u;\\,g:h;\\,f:lprim;\\,}\\mathcal{O}_{\\text{1-CDL(c:u;\\,g:h;\\,f:lprim)}})</span> corresponds to the first assumption statement given in the example list above except that now the adversary also gets access to an oracle breaking the 1-CDL(c:u;\\,g:h;\\,f:lprim) assumption.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The impact of granularity</p>

    <p class="text-gray-300">It would go beyond the scope of this paper to discuss all previously identified parameters and we will focus only on granularity. Before stating the actual results, let us first briefly repeat the practical relevance of granularity as alluded in the introduction. Figure 1 illustrates exemplarily different variants of the probability space for a given security parameter  <span class="math">k</span> . The areas labeled with l, m and h represent the algebraic parameters over which low-, medium- and high-granular probability spaces are defined.[22] Assumptions with lower granularity are weaker, and are therefore more desirable in principle. However, not all cryptographic settings can rely on the weaker variants: Consider, for instance, an escrowed anonymous payment system where the bank chooses the system parameters.[23] It would not be appropriate to base the security of such a system a-priori on a low-granular assumption. This is because a cheating bank might try to choose a weak group with trapdoors (easy problem instances) to violate the anonymity of the customer (This case is shown in Figure 1 with a trapdoor group  <span class="math">G^{*}</span>  and its corresponding easy instances.) Such a strategy might be possible even if the low-granular assumption holds: The assumption would ensure that the overall number of easy problem instances is asymptotically negligible with respect to the security parameter (In Figure 1 weak instances (in area m))</p>

    <p class="text-gray-300">represent exemplarily a negligible portion of the instances of the low-granular space in area l.) Yet, the assumption would not rule out that there are infinitely many weak groups. Therefore, there might not exist a sufficiently large <span class="math">k</span> for which the bank cannot break the assumption.</p>

    <p class="text-gray-300">In contrast, a high-granular (medium-granular) assumption does not hold in our example because as shown in the figure, the fraction of weak instances in area h (m) is not negligible. However, if a high-granular (medium-granular) assumption holds then the trapdoor groups <span class="math">G^{*}</span> in the above example would not exist and the bank could not cheat.</p>

    <p class="text-gray-300">Thus, which of the granularity variants is appropriate in cryptographic protocols depends on how and by whom the parameters are chosen. A priori we have to use a high-granular assumption. Yet, in the following situations we can resort to a weaker less granular assumption: The security requirements of the cryptographic system guarantee that it’s in the best (and only) interest of the chooser of the system parameters to choose them properly; the system parameters are chosen by a mutually trusted third party; or the system parameters are chosen in a verifiable random process. Also, at most in these cases we can reasonably assume a group family with the group order and its factorization to be hidden from the public and the adversary. As a consequence, it would seem strange to base a cryptographic system on a high-granular assumption with unknown order factorization: either the system parameters are chosen by an honest party and we could resort to a weaker assumption with lower granularity, or the knowledge of the order and its factorization has to be assumed to be known to the adversary. Furthermore, care has to be taken for DL-related high- and medium-granular assumptions in <span class="math">\\mathbb{Z}_{p}^{<em>}</span> and its subgroups. Unless we further constrain the set of valid groups with (expensive) tests as outlined by </em>Gordon (1993a)*, we require, for a given security parameter, considerably larger groups than for the low granular counterpart of the assumptions. As informally mentioned above, assumptions with lower granularity are weaker than assumption of higher granularity. Formally, this is stated and proven in the following theorem:</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 5.1</h6>

    <p class="text-gray-300"><span class="math"><em>-<strong>^{</em>}(c:<em>;g:h;f:</em>)\\implies<em>-</strong>^{</em>}(c:<em>;g:m;f:</em>)\\implies<em>-**^{</em>}(c:<em>;g:l;f:</em>)</span></p>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume we are given an adversary <span class="math">\\mathcal{A}</span> breaking a low-granular assumption for some group and problem family, some problem type, computational complexity, arbitrary algebraic knowledge and success probability. Furthermore, we are given an input <span class="math">I</span> corresponding to an assumption of high- or medium-granular but otherwise identical parameters.</p>

    <p class="text-gray-300">For the reduction, call <span class="math">\\mathcal{A}</span> on this input <span class="math">I</span> and return the result. To see that this achieves the desired attack on the medium- or high-granular assumption, note that inputs to an adversary breaking a high- or medium-granular assumption are also valid inputs to a low-granular adversary. Therefore, this reduction is a legitimate attacker from a runtime perspective exactly in the case where the oracle itself is a legitimate attacker. Furthermore, the probability space instances defined by a high- or medium-granular assumption always partition the probability space instances of a low-granular assumption. Therefore, it it is clear that for a perfect adversary <span class="math">\\mathcal{A}</span> the reduction breaks certainly the high- or medium-granular probability space instances which are part of the low-granular probability space instances which <span class="math">\\mathcal{A}</span> breaks. As there are by definition of <span class="math">\\mathcal{A}</span> infinitely many such low-granular probability space instances it automatically follows that for the perfect case the high- and medium-granular assumption is broken, too. By a counting argument this also easily extends to the case of strong, invariant and weak adversaries, i.e., at least some of the high- or medium-granular probability space instances which are part of the low-granular probability space instances broken by <span class="math">\\mathcal{A}</span>, are broken with the necessary success probability as well.</p>

    <p class="text-gray-300">By an identical argument it follows that a high-granular assumption can be reduced to the corresponding medium-granular assumption. This concludes the theorem.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <p class="text-gray-300">Note that the inverse of above result, a low-granular assumption implies the corresponding high-granular one, does not hold in general: There are always super-polynomially many of the higher-granular probability space instances contained in a given lower-granular instance. Therefore, there might be situations where infinitely many high-granular probability space instances — and henceforth the corresponding high-granular assumption — are broken, yet they form only a negligible subset of the enclosing lower-granular probability space instances and the low-granular assumption can still hold.</p>

    <p class="text-gray-300">However, if for a given granularity there exists a random self-reduction <em>(Blum and Micali, 1984)</em>, then the inverse reduction exists also from that granularity to all higher granularities. As random self-reductions are known for all mentioned problem families and problem types in their medium granularity variant, this equates the medium- and high-granular cases. Unfortunately, no random self-reduction is yet known for low-granular assumptions and achieving such “full” random self-reducibility seems very difficult in general (if not impossible) in number-theoretic settings <em>(Boneh, 2000)</em> contrary to, e.g., lattice settings used by <em>Ajtai and Dwork (1997)</em>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">6 Computational DH, SE and IE</h2>

    <p class="text-gray-300"><em>Maurer and Wolf (1996)</em> prove the equivalence between the computational SE and DH assumptions in their uniform and high-granular variant for both perfect and invariant success probabilities.</p>

    <p class="text-gray-300">We briefly review their results, and show that they also hold for weak and strong success probabilities. We then extend these results to medium granularity and prove similar relations between IE and DH.</p>

    <p class="text-gray-300">First however, we will look into how the success probability of oracles can be improved.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">6.1 Self-Correction</h3>

    <p class="text-gray-300">In the following sections we are mostly concerned with faulty oracles, i.e., oracles which answer with a certain success probability to the legal inputs (inputs with correct distribution over the oracle’s input domain). If an oracle has a small but not negligible success probability, one is interested in constructing an efficient algorithm which improves this success probability such that the answers to the legal inputs are almost certainly correct. In other words, one is interested in performing self-correction on the faulty oracle.</p>

    <p class="text-gray-300">In our considerations we need to self-correct the faulty CDH oracle to determine the success probability of certain reductions which appear in later sections. Suppose, we are given a faulty CDH oracle <span class="math">\\mathcal{O}_{CDH}</span> which on input <span class="math">((G,g),(g^{x},g^{y}))</span> outputs <span class="math">g^{xy}</span> with a not negligible probability <span class="math">\\alpha</span>. Then we can construct an efficient algorithm for CDH which outputs the correct answer almost certainly for all legal inputs. One may ask, why not running such an oracle for <span class="math">O(1/\\alpha)</span> times until we get a correct answer! However, this is of no help, since in general we cannot determine (decide) whether the output of the oracle is the correct Diffie-Hellman solution or not – this would mean solving Decisional Diffie-Hellman (DDH) Problem which is assumed to be hard in the underlying group.</p>

    <p class="text-gray-300">Thus, other (more complicated) approaches have been taken to construct self-correctors for computational problems such as CDH.</p>

    <p class="text-gray-300">Maurer and Wolf ( [1996]) and Shoup ( [1997]) give different constructions for CDH self-correctors. For our considerations we will use the result from [Shoup 1997] which is formulated in the following lemma.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 6.1 ( [Shoup 1997])</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a CDH oracle with success probability <span class="math">\\alpha</span>, one can construct a probabilistic algorithm for CDH which, for a given <span class="math">0&lt;\\beta&lt;1</span>, answers correctly to all inputs with probability at least <span class="math">\\alpha^{\\prime}=1-\\beta</span> making <span class="math">O(\\frac{\\log(1/\\beta)}{\\alpha})</span> queries to the faulty oracle and performing additional $O(\\frac{\\log(1/\\beta)}{\\alpha}\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2})$ group operations. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that Lemma 6.1 does not consider the success probabilities in the asymptotic framework as we introduced in Section 2.2. Thus, for our considerations we suitably adjust this result when self-correcting a weak or invariant oracle to a strong oracle. This is summarized in the following corollary:</p>

    <p class="text-gray-300">6.1 Self-Correction</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\{(1 - 1 / \\mathsf{poly}(k))\\} - \\mathrm{CDH}(\\mathrm{c} *; \\mathrm{g}: \\{\\mathrm{h}, \\mathrm{m}\\}; \\mathrm{f}: \\mathrm{o}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\alpha' \\geq 1 - 1/2^k; \\quad t' = O\\left(\\frac{lk}{a}\\right) + O\\left(\\frac{k \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{a} + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2\\right)}{\\alpha} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\{\\epsilon, 1 / \\mathsf{poly}(k)\\} - \\mathrm{CDH}(\\mathrm{c} *; \\mathrm{g}: \\{\\mathrm{h}, \\mathrm{m}\\}; \\mathrm{f}: \\mathrm{o}) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Proof. We give the proof for weak oracles and the proof for the invariant oracle immediately follows.</p>

    <p class="text-gray-300">Assume, we are given a CDH oracle with weak success probability <span class="math">\\alpha(k)</span>. In our framework for success probabilities it is reasonable to self-correct this oracle to a strong oracle, i.e., an oracle with success probability <span class="math">\\alpha&#x27;(k)</span> where <span class="math">1 - \\alpha&#x27;(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the straight forward (and naive) application of Lemma 6.1 one may set <span class="math">\\beta(k) := 1/2^k</span> (<span class="math">k</span> security parameter) and self-correct oracle's success probability to <span class="math">\\alpha&#x27;(k) \\geq 1 - 1/2^k</span> implying <span class="math">1 - \\alpha&#x27;(k) \\leq 1/2^k</span>. Since <span class="math">1/2^k</span> is asymptotically smaller than the inverse of any polynomial we can write <span class="math">1/2^k &amp;lt;_{\\infty} 1 / \\mathsf{poly}(k)</span>. It follows that <span class="math">1 - \\alpha&#x27;(k) &amp;lt;_{\\infty} 1 / \\mathsf{poly}(k)</span>. According to Lemma 6.1 the self-correction requires <span class="math">O\\left(\\frac{k}{\\alpha(k)}\\right)</span> calls to the weak oracle and $O\\left(\\frac{k \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\alpha(k)} + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2\\right)<span class="math"> group operations where we used </span>\\log(1 / \\beta(k)) = \\log(2^k) = k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, the above approach is not conform to our framework of success probabilities and does not work directly. The reason is that in general the above self-correction may not provide us with a polynomial time algorithm. It is guaranteed to be polynomial only for those values of <span class="math">k</span> (infinitely many <span class="math">k_i</span> by definition) where the success probability <span class="math">\\alpha(k)</span> of the weak oracle can be lower bounded by the inverse of some polynomial <span class="math">p(\\cdot)</span>, but not necessarily for other values of <span class="math">k</span>.[26]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To handle this problem, one can define a family of algorithms indexed by a polynomial <span class="math">p_j(\\cdot)</span> which runs the self-correction with <span class="math">p_j(k)</span> rounds (oracle calls). Thus, all members of this family have the run time $O\\big(p_j(k)t\\big) + O\\big(p_j(k)\\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2\\big)<span class="math">, and therefore are polynomial. Moreover, there are members of this family which satisfy the condition for strong success probability. These are exactly the members for which </span>kp(\\cdot) &lt;_{\\infty} p_j(\\cdot)<span class="math"> holds. In particular, this holds for the same </span>k$ values where the condition for the given weak success probability is satisfied.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, this is an existential argument and not constructive, as in general neither the function <span class="math">\\alpha(k)</span> or the <span class="math">k_i</span> values are known beforehand nor they can be approximated by querying the oracle in polynomial time.</p>

    <p class="text-gray-300">Hence, in our framework it suffices to self-correct <span class="math">\\mathcal{O}_{CDH}</span> such that <span class="math">\\alpha&#x27;(k) \\not\\prec_{\\infty} 1 - 1/2^k</span> holds. This implies <span class="math">1 - \\alpha&#x27;(k) \\not\\prec_{\\infty} 1/2^k</span>, and since <span class="math">1/2^k &amp;lt;_{\\infty} 1 / \\mathrm{poly}(k)</span>, it follows <span class="math">1 - \\alpha&#x27;(k) \\not\\prec_{\\infty} 1 / \\mathrm{poly}(k)</span> (i.e., <span class="math">\\alpha&#x27;(k)</span> is strong.) This completes the proof.</p>

    <p class="text-gray-300">[26] Note that we might have <span class="math">\\alpha(k) = 0</span> for infinitely many <span class="math">k</span> values, and since the self-correction costs are proportional to <span class="math">1/\\alpha(k)</span>, this would lead to exponentially high number of oracle calls and group operations.</p>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <p class="text-gray-300">Remark 6.1. In the proof of his self-corrector Shoup (1997) assumes that the group order is known. However, by a closer inspection of the proof and the deployment of the techniques used in Remark 7.8 we can drop this requirement. Thus, Corollary 6.1 also holds without requiring the knowledge of the group order.</p>

    <p class="text-gray-300">We start with the result of Maurer and Wolf (1996) on the equivalence between the computational SE and DH assumptions in their uniform and high-granular variant for perfect and invariant success probabilities. This is formulated in our convention in the following theorem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\epsilon</span>  -CSE(c:u;g:h;f:o)  $\\xrightarrow{\\alpha^{\\prime} = \\alpha; t^{\\prime} = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> </span>\\epsilon$  -CDH(c:u;g:h;f:o)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Let  <span class="math">0 &amp;lt; \\epsilon_{1} &amp;lt; 1</span> ,  <span class="math">0 &amp;lt; \\epsilon_{2} &amp;lt; 1</span>  be arbitrary constants. Then the following statements hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Given a CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which breaks  <span class="math">\\epsilon</span> -CDH(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CDH}(k) \\not\\leq_{\\infty} \\epsilon_1</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  which breaks  <span class="math">\\epsilon</span> -CSE(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CSE}(k) \\not\\leq_{\\infty} \\epsilon_1</span> , using a single call to  <span class="math">\\mathcal{O}_{CDH}</span>  and  $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From these reductions the theorem immediately follows. Above reductions are achieved as follows:</p>

    <p class="text-gray-300">Case (a) is quite straightforward as the problem instances of SE are a proper subset of the problem instances of DH and the answer can be retrieved in one call to the oracle. In the case of perfect CDH oracle (perfect success probability) the oracle returns  <span class="math">g^{x^2}</span>  on the input  <span class="math">((G,g),(g^x,g^x))</span> . However, in the case of invariant oracle (faulty oracle) care has to be taken that the inputs to the CDH oracle are uniformly distributed over oracle's input domain.[27] This can easily be achieved by randomizing a given tuple  <span class="math">((G,g),(g^x,g^x))</span>  to a random CDH tuple</p>

    <p class="text-gray-300">6.2 CSE versus CDH</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">((G,g),(g^{x^{\\prime}},g^{y^{\\prime}}))</span>, i.e., randomly self-reducing the problem, as follows: Choose $r_x,r_y\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and set </span>x^{\\prime}\\coloneqq x + r_{x}<span class="math">, and </span>y^\\prime \\coloneqq y + r_y<span class="math">. The elements </span>g^{x^{\\prime}},g^{y^{\\prime}}<span class="math"> are randomly and uniformly distributed over </span>G<span class="math">, since due to the randomization, </span>x^{\\prime},y^{\\prime}<span class="math"> are randomly and uniformly spread over </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">.²⁸ Note that in the high-granular case an </span>SI = (G,g)$ fixes a probability space instance (PSI).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using oracle's answer we can determine the desired result as follows:</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {x ^ {2}} = \\frac {\\mathcal {O} _ {C D H} (g ^ {x ^ {\\prime}} , g ^ {y ^ {\\prime}})}{g ^ {r _ {x} y + r _ {y} x + r _ {x} r _ {y}}} = \\frac {g ^ {x ^ {\\prime} y ^ {\\prime}}}{g ^ {r _ {x} y + r _ {y} x + r _ {x} r _ {y}}}.</span></div>

    <p class="text-gray-300">Success probability: There is a single oracle call and thus for the success probability of <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span> we have <span class="math">\\alpha_{CSE}(k) = \\alpha_{CDH}(k)</span>. Since <span class="math">\\alpha_{CDH}(k) \\not\\prec_{\\infty} \\epsilon_1</span> it follows <span class="math">\\alpha_{CSE}(k) \\not\\prec_{\\infty} \\epsilon_1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: There is only one oracle call and to solve the DSE instance we need to compute <span class="math">g^{r_x}, g^{r_y}</span>, <span class="math">(g^y)^{r_x}, (g^x)^{r_y}, g^{r_x r_y}</span> and <span class="math">(g^{r_xy + r_y x + r_x r_y})^{-1}</span>. For exponentiations we can use, e.g., the square and multiply method requiring $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations. If we assume that the group order is known (denoted by the place holder &quot;f:o&quot;) we can efficiently compute the inverse of the group elements using </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case (b) is slightly more involved. The key observation is that</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {(x + y) ^ {2}} = g ^ {2 x y} g ^ {x ^ {2}} g ^ {y ^ {2}}.</span></div>

    <p class="text-gray-300">This implies</p>

    <div class="my-4 text-center"><span class="math-block">(g ^ {x y}) ^ {2} = g ^ {2 x y} = g ^ {(x + y) ^ {2}} (g ^ {x ^ {2}}) ^ {- 1} (g ^ {y ^ {2}}) ^ {- 1} = g ^ {(x + y) ^ {2} - x ^ {2} - y ^ {2}}.</span></div>

    <p class="text-gray-300">Therefore, we can solve CDH with three oracle calls (one for each of <span class="math">g^{(x + y)^2}</span>, <span class="math">g^{x^2}</span> and <span class="math">g^{y^2}</span>), the computation of inverses of <span class="math">g^{x^2}</span> and <span class="math">g^{y^2}</span> and the square root of <span class="math">g^{2xy} = (g^{xy})^2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As before, for the faulty oracle we have to uniformly spread the given input over oracle's input domain using randomization. Furthermore, we have to make sure now that all oracle calls are (statistically) independent to be able to make concrete statements on the success probability of <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span>. Both we achieve with independent blinding factors $r_i \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and computing </span>g^{u^2}<span class="math"> as </span>\\mathcal{O}_{CSE}(g^{(u + r_i)}) / (g^u)^{2r_i} g^{r_i^2}<span class="math">. Note that </span>g^{(u + r_i)}<span class="math"> are randomly and uniformly distributed group elements, since </span>u + r_i<span class="math"> are randomly and uniformly distributed over </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Success probability: There are 3 independent calls to the CSE oracle and thus the success probability of <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span> is <span class="math">\\alpha_{CDH}(k) = \\alpha_{CSE}(k)^3</span>. Since <span class="math">\\alpha_{CSE}(k) \\not\\prec_{\\infty} \\epsilon_2</span> it follows <span class="math">\\alpha_{CDH}(k) \\not\\prec_{\\infty} \\epsilon_2^3</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">²⁸ that is, $\\forall (x', y') \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> and </span>\\forall (x, y) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> there exists exactly one pair </span>(r_x, r_y) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> such that the equations </span>x' = x + r_x<span class="math"> and </span>y' = x + r_y$ hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: Assuming the group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is known, one can efficiently compute the inverse and square roots of elements in </span>G<span class="math">. Computing the inverse of elements requires </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations. For computing square roots there two possible cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i) The group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is odd, i.e., </span>\\gcd(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 2) = 1<span class="math">. In this case, we can use the following general result: For </span>d<span class="math"> with </span>\\gcd(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d) = 1<span class="math"> and </span>a \\in G<span class="math"> the equation </span>x^d = a<span class="math"> has the unique solution </span>x = a^c<span class="math"> where </span>dc \\equiv 1 \\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The required number of group operations for computing this is in the order of </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, one can determine the (unique) square root of <span class="math">a = (g^{xy})^2</span> by computing $c \\equiv 2^{-1} \\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and then </span>g^{xy} = a^c<span class="math">. As mentioned above, the total cost is in the order of </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ii) The group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is even. Thus, there exist two square roots. To compute these roots, one can apply the methods from Wolf 1999 (Lemma 11.4 and Theorem 11.5) where the (maximal) cost is in the order of </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The two square roots of <span class="math">a</span> are <span class="math">g^{xy}</span> and $g^{xy +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2}<span class="math">. To find out which one is the correct square root of </span>a<span class="math">, we proceed as follows: Assume, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^e s<span class="math"> where </span>\\gcd(s, p) = 1<span class="math">. Apply the Pohlig-Hellman algorithm to compute </span>x, y<span class="math"> and </span>xy \\bmod 2^e<span class="math">. This requires </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations. Since </span>2^e \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2<span class="math"> we have </span>xy \\not\\equiv xy +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2 \\bmod 2^e<span class="math">, and so we can determine the correct root </span>g^{xy}<span class="math"> by computing the discrete logarithm of one of the roots </span>\\bmod 2^e$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The costs per oracle call are in the order of $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations for computing the square roots, and </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations for exponentiation and computing the inverses. Hence, for 3 oracle calls the total costs can be expressed by </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we extend this result to all other variants related to success probability (weak, strong) and adversary's computational complexity (non-uniform) as stated in the following Theorem:</p>

    <p class="text-gray-300"><strong>Theorem 6.2</strong></p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em> \\text{-CSE}(c: </em>; g: h; f: o) \\quad \\xrightarrow{\\alpha' = \\alpha; t' = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} <em> \\quad </em> \\text{-CDH}(c: *; g: h; f: o) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\prod p_i^{e_i}</span> be the prime factorization of the group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then using the so-called Pohlig-Hellman decomposition (Pohlig and Hellman 1978) combined with baby-step giant-step one can compute the discrete logarithm </span>x<span class="math"> of </span>b = g^x<span class="math"> in </span>G<span class="math"> by </span>O(\\sum e_i (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sqrt{p_i} \\log p_i))<span class="math"> group operations if memory space for storing </span>\\lceil \\sqrt{p_i} \\rceil<span class="math"> group elements is available (see also Wolf (1999)). Here the discrete logarithm modulo </span>2^e<span class="math"> is to be computed, i.e., for </span>p_i = 2<span class="math"> and </span>e_i = e<span class="math">. For this, one requires </span>O(e (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sqrt{2} \\log 2)) = O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.2 CSE versus CDH</p>

    <p class="text-gray-300">Proof. We consider only the variants related to the weak and strong success probabilities since the other variants (perfect and invariant) are handled by Theorem 6.1.</p>

    <p class="text-gray-300">Weak oracles <span class="math">(\\alpha_{CDH}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability in both reductions is also weak: In the first reduction, we have <span class="math">\\alpha_{CSE}(k) = \\alpha_{CDH}(k)</span> implying <span class="math">\\alpha_{CSE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k)</span>. In the second reduction, we have <span class="math">\\alpha_{CDH}(k) = \\alpha_{CSE}(k)^3</span> which is a power of a not negligible function resulting in a not negligible function. It follows <span class="math">\\alpha_{CDH}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">Strong oracles <span class="math">(1 - \\alpha_{CDH}(k) \\ngeq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability in both cases is also strong: We use the result of Lemma 6.2 stating that if a strong oracle is called polynomially (and independently) many times, the resulting success probability is also strong: In the first reduction there is a single oracle call, and in the second case there is a constant number of oracle calls (3 calls). Hence, the error probability of the algorithm is in both cases not non-negligible, i.e., <span class="math">1 - \\alpha_{CDH}(k) \\ngeq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">Efficiency: is the same as in Theorem 6.1.</p>

    <p class="text-gray-300">The following lemma formulates the fact that if a strong oracle is called polynomially (and independently) many times, the resulting success probability is also strong.</p>

    <p class="text-gray-300">Lemma 6.2 Let <span class="math">k \\in \\mathbb{N}</span>, <span class="math">\\alpha(k)</span> be a function <span class="math">\\mathbb{N} \\to [0,1]</span> and <span class="math">b, d &amp;gt; 0</span> some real constants. Then the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">1 - \\alpha (k) \\ngeq_ {\\infty} 1 / \\operatorname {p o l y} (k) \\Rightarrow 1 - \\alpha (k) ^ {b k ^ {d}} \\geq_ {\\infty} 1 / \\operatorname {p o l y} (k).</span></div>

    <p class="text-gray-300">Proof. Due to the definition we have</p>

    <div class="my-4 text-center"><span class="math-block">1 - \\alpha (k) \\ngeq_ {\\infty} 1 / \\operatorname {p o l y} (k) \\Rightarrow \\forall c &amp;gt; 0 \\forall k _ {0} \\exists k _ {1} &amp;gt; k _ {0}: \\alpha (k _ {1}) &amp;gt; 1 - \\frac {1}{k _ {1} ^ {c}}.</span></div>

    <p class="text-gray-300">It follows</p>

    <div class="my-4 text-center"><span class="math-block">\\forall b &amp;gt; 0 \\forall d &amp;gt; 0 \\forall c &amp;gt; 0 \\forall k _ {0} \\exists k _ {1} &amp;gt; k _ {0}: \\alpha (k _ {1}) ^ {b k _ {1} ^ {d}} &amp;gt; (1 - \\frac {1}{k _ {1} ^ {c}}) ^ {b k _ {1} ^ {d}}.</span></div>

    <p class="text-gray-300">Now, for any <span class="math">b &amp;gt; 0</span> and any <span class="math">d&#x27; &amp;gt; d &amp;gt; 0</span> there exists <span class="math">k_0&#x27; \\in \\mathbb{N}</span> such that for all <span class="math">k &amp;gt; k_0&#x27;</span> the relation <span class="math">1 \\leq bk^d \\leq k^{d&#x27;}</span> holds. It follows</p>

    <div class="my-4 text-center"><span class="math-block">\\forall b &amp;gt; 0 \\forall d &amp;gt; 0 \\forall d ^ {\\prime} &amp;gt; d &amp;gt; 0 \\forall c &amp;gt; 0 \\forall k _ {0} &amp;gt; k _ {0} ^ {\\prime} \\exists k _ {1} &amp;gt; k _ {0}: \\alpha (k _ {1}) ^ {b k _ {1} ^ {d}} &amp;gt; (1 - \\frac {1}{k _ {1} ^ {c}}) ^ {k _ {1} ^ {d ^ {\\prime}}}.</span></div>

    <p class="text-gray-300">According to Lemma 6.3 below, for <span class="math">k \\in \\mathbb{N}</span> and <span class="math">c \\geq d&#x27;</span> the following holds: <span class="math">(1 - \\frac{1}{k^c})^{k^{d&#x27;}} \\geq 1 - \\frac{1}{k^{c - d&#x27;}}</span>. Since <span class="math">c</span> is arbitrary and since we can write <span class="math">c&#x27; := c - d&#x27; &amp;gt; 0</span> it follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall b &amp;gt; 0 \\forall d &amp;gt; 0 \\forall c ^ {\\prime} &amp;gt; 0 \\forall k &amp;gt; k _ {0} ^ {\\prime} \\exists k _ {1} &amp;gt; k _ {0} ^ {\\prime}: \\alpha (k _ {1}) ^ {b k _ {1} ^ {d}} &amp;gt; 1 - \\frac {1}{k _ {1} ^ {c ^ {\\prime}}}.</span></div>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <p class="text-gray-300">This implies <span class="math">1 - \\alpha(k)^{bk^d} \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span> and the proof is completed.</p>

    <p class="text-gray-300">The next lemma provides us with a useful lower bound which we apply in some proofs (as in the proof of Lemma 6.2).</p>

    <p class="text-gray-300"><strong>Lemma 6.3</strong> Let <span class="math">k \\in \\mathbb{N}</span>. Then for all real constants <span class="math">d&#x27; &amp;gt; 0</span> and <span class="math">c &amp;gt; 0</span> with <span class="math">c &amp;gt; d&#x27;</span> the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(1 - \\frac {1}{k ^ {c}}\\right) ^ {k ^ {d ^ {\\prime}}} \\geq 1 - \\frac {k ^ {d ^ {\\prime}}}{k ^ {c}} = 1 - \\frac {1}{k ^ {c - d ^ {\\prime}}}.</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><strong>Proof.</strong> First, we stress that for <span class="math">a \\in \\mathbb{R}, a &amp;gt; -1</span> and <span class="math">n \\in \\mathbb{N}</span>, one can apply the Bernoulli inequality <span class="math">(1 + a)^n \\geq 1 + na</span>, and the claim follows immediately (set <span class="math">a := -\\frac{1}{k^c}</span> and <span class="math">n := k^{d&#x27;}</span>.)</p>

    <p class="text-gray-300">We prove the claim for <span class="math">n \\coloneqq k^{d&#x27;} \\in \\mathbb{R}</span>: For <span class="math">k = 1</span> this relation obviously holds. One way to see that it also holds for <span class="math">k &amp;gt; 1</span> is as follows: Consider the expressions <span class="math">k^{d&#x27;}\\ln (1 - 1 / k^c)</span> and <span class="math">\\ln (1 - 1 / k^{c - d&#x27;})</span>. We expand them using</p>

    <div class="my-4 text-center"><span class="math-block">\\ln (1 - x) = - \\left[ x + x ^ {2} / 2 + x ^ {3} / 3 + \\dots + x ^ {n} / n + \\dots \\right]</span></div>

    <p class="text-gray-300">for <span class="math">-1\\leq x &amp;lt; 1</span>.</p>

    <p class="text-gray-300">The expansion of the first expression is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} k ^ {d ^ {\\prime}} \\ln \\left(1 - \\frac {1}{k ^ {c}}\\right) = - k ^ {d ^ {\\prime}} \\left[ \\frac {1}{k ^ {c}} + \\frac {1}{2 k ^ {2 c}} + \\frac {1}{3 k ^ {3 c}} + \\dots \\frac {1}{n k ^ {n c}} + \\dots \\right] \\\\ = - \\left[ \\frac {1}{k ^ {c - d ^ {\\prime}}} + \\frac {1}{2 k ^ {2 c - d ^ {\\prime}}} + \\frac {1}{3 k ^ {3 c - d ^ {\\prime}}} + \\dots + \\frac {1}{n k ^ {n c - d ^ {\\prime}}} + \\dots \\right] \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">x \\coloneqq 1 / k^c &amp;lt; 1</span> that is <span class="math">k^c &amp;gt; 1</span>.</p>

    <p class="text-gray-300">Expanding the other expression we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\ln \\left(1 - \\frac {1}{k ^ {c - d ^ {\\prime}}}\\right) = - \\left[ \\frac {1}{k ^ {c - d ^ {\\prime}}} + \\frac {1}{2 k ^ {2 (c - d ^ {\\prime})}} + \\frac {1}{3 k ^ {3 (c - d ^ {\\prime})}} + \\dots + \\frac {1}{n k ^ {n (c - d ^ {\\prime})}} + \\dots \\right].</span></div>

    <p class="text-gray-300">where <span class="math">x \\coloneqq 1 / k^{c - d&#x27;} &amp;lt; 1</span> that is <span class="math">k^{d&#x27;} &amp;lt; k^c</span>.</p>

    <p class="text-gray-300">Next we compute the difference between these expansions:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Delta (k) := k ^ {d ^ {\\prime}} \\ln \\left(1 - \\frac {1}{k ^ {c}}\\right) - \\ln \\left(1 - \\frac {1}{k ^ {c - d ^ {\\prime}}}\\right) \\\\ = \\underbrace {\\left[ \\left(- \\frac {1}{2 k ^ {2 c - d ^ {\\prime}}} + \\frac {1}{2 k ^ {2 (c - d ^ {\\prime})}}\\right) \\right.} _ {\\delta_ {2}} + \\underbrace {\\left(- \\frac {1}{3 k ^ {3 c - d ^ {\\prime}}} + \\frac {1}{3 k ^ {3 (c - d ^ {\\prime})}}\\right)} _ {\\delta_ {3}} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\dots + \\underbrace {\\left(- \\frac {1}{n k ^ {n c - d ^ {\\prime}}} + \\frac {1}{n k ^ {n (c - d ^ {\\prime})}}\\right)} _ {\\delta_ {n}} + \\dots ].</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">6.2 CSE versus CDH</p>

    <p class="text-gray-300">For <span class="math">k &amp;gt; 1, c &amp;gt; d&#x27; &amp;gt; 0</span> each difference term <span class="math">\\delta_{n}</span> is positive, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{n} = \\left(- \\frac {1}{n k ^ {n c - d ^ {\\prime}}} + \\frac {1}{n k ^ {n (c - d ^ {\\prime})}}\\right) = \\frac {1}{n k ^ {n c - d ^ {\\prime}}} (- 1 + (k ^ {d ^ {\\prime}}) ^ {n - 1}) &amp;gt; 0.</span></div>

    <p class="text-gray-300">and we can conclude <span class="math">\\Delta &amp;gt; 0</span>. Thus for <span class="math">k &amp;gt; 1</span> and <span class="math">c &amp;gt; d&#x27;</span> we can write</p>

    <div class="my-4 text-center"><span class="math-block">k ^ {d ^ {\\prime}} \\ln (1 - \\frac {1}{k ^ {c}}) &amp;gt; \\ln (1 - \\frac {1}{k ^ {c - d ^ {\\prime}}})</span></div>

    <p class="text-gray-300">and by applying the exponential function we obtain</p>

    <div class="my-4 text-center"><span class="math-block">e ^ {k ^ {d ^ {\\prime}} \\ln (1 - 1 / k ^ {c})} = (1 - \\frac {1}{k ^ {c}}) ^ {k ^ {d ^ {\\prime}}} &amp;gt; e ^ {\\ln (1 - 1 / k ^ {c - d ^ {\\prime}})} = 1 - \\frac {1}{k ^ {c - d ^ {\\prime}}}.</span></div>

    <p class="text-gray-300">and this completes the proof.</p>

    <h2 id="sec-25" class="text-2xl font-bold">6.2.2 Medium Granular</h2>

    <p class="text-gray-300">Until now we have proved the equivalence between CDH and CSE for their high-granular variants. The next theorem shows that this relation also holds for medium granularity.</p>

    <h2 id="sec-26" class="text-2xl font-bold">Theorem 6.3</h2>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} <em> \\text {- C S E (c : </em> ; g : m ; f : o)} \\quad \\xrightarrow {\\alpha^ {\\prime} = \\alpha ; t ^ {\\prime} = t + O (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} <em> \\text {- C D H (c : </em> ; g : m ; f : o)} \\\\ <em> \\text {- C S E (c : </em> ; g : m ; f : o)} \\quad \\xleftarrow {\\alpha^ {\\prime} = \\alpha^ {3} ; t ^ {\\prime} = 3 t + O (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} <em> \\text {- C D H (c : </em> ; g : m ; f : o)} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. The proof idea of Theorem 6.2 can also be applied here. The only thing we have to show is that the necessary randomization in the reduction steps can be extended to the medium granularity variants of CDH and CSE. Note that for the medium-granular probability space a group <span class="math">G</span> fixes a probability space instance (PSI).</p>

    <p class="text-gray-300">CDH: We transform a given CDH input tuple <span class="math">((G,g),(g^{x},g^{y}))</span> for a given generator <span class="math">g\\in G</span> into a random CDH input tuple <span class="math">((G,g_{<em>}),(g_{</em>}^{x^{\\prime}},g_{<em>}^{y^{\\prime}}))</span> for a random generator <span class="math">g_{</em>}\\in G</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. We choose $r_g \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*, r_x, r_y \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and set </span>g_* := g^{r_g}<span class="math">, </span>x' := x + r_x<span class="math">, and </span>y' := y + r_y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We compute the public part of the input to the CDH oracle as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(g ^ {x}) ^ {r _ {g}} g ^ {r _ {g} r _ {x}} = g ^ {r _ {g} (x + r _ {x})} = (g ^ {r _ {g}}) ^ {(x + r _ {x})} = g _ {*} ^ {x ^ {\\prime}}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(g ^ {y}) ^ {r _ {g}} g ^ {r _ {g} r _ {y}} = g ^ {r _ {g} (y + r _ {y})} = (g ^ {r _ {g}}) ^ {(y + r _ {y})} = g _ {*} ^ {y ^ {\\prime}}.</span></div>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The tuple <span class="math">((G,g_{<em>}),(g_{</em>},g_{<em>}^{x^{\\prime}},g_{</em>}^{y^{\\prime}}))</span> has the correct distribution for CDH oracle. This is because (i) <span class="math">g_{<em>}</span> is a random group generator, and (ii) <span class="math">g_{</em>}^{x^{\\prime}},g_{*}^{y^{\\prime}}</span> are randomly and uniformly distributed elements of <span class="math">G</span> since, due to the randomization, <span class="math">x^{\\prime},y^{\\prime}</span> are randomly and uniformly spread over $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We unblind the result of the CDH oracle as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (g_{*}^{x^{\\prime} y^{\\prime}})^{r_{g}^{-1}} / ((g^{x})^{r_{y}} (g^{y})^{r_{x}} g^{r_{x} r_{y}}) = (g^{x^{\\prime} y^{\\prime}})^{r_{g} r_{g}^{-1}} / ((g^{x})^{r_{y}} (g^{y})^{r_{x}} g^{r_{x} r_{y}}) \\\\ = g^{(x y + x r_{y} + y r_{x} + r_{x} r_{y})} / g^{(x r_{y} + y r_{x} + r_{x} r_{y})} \\\\ = g^{x y}. \\end{array}</span></div>

    <p class="text-gray-300">CSE: We transform a given CSE input <span class="math">((G,g),(g^{x}))</span> for a given generator <span class="math">g\\in G</span> into a random CSE input <span class="math">((G,g_{<em>}),(g_{</em>}^{x^{\\prime}}))</span> for a random generator <span class="math">g_{*}\\in G</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. We choose $r_g \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*, r_x \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and set </span>g_* := g^{r_g}<span class="math"> and </span>x' := x + r_x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We compute the public part of the input to the CSE oracle as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(g^{x})^{r_{g}} g^{r_{g} r_{x}} = g^{r_{g} (x + r_{x})} = (g^{r_{g}})^{(x + r_{x})} = g_{*}^{x^{\\prime}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to the above case, the tuple <span class="math">((G,g_{<em>}),(g_{</em>},g_{<em>}^{x^{\\prime}}))</span> has the correct input distribution for the DSE oracle. This is because (i) <span class="math">g_{</em>}</span> is a random group generator, and (ii) <span class="math">g_{*}^{x^{\\prime}}</span> is a random element of <span class="math">G</span> since, due to the randomization, <span class="math">x^{\\prime}</span> is randomly and uniformly spread over $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We unblind the result of the CSE oracle as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (g_{*}^{x^{\\prime 2}})^{r_{g}^{-1}} / ((g^{x})^{2 r_{x}} g^{r_{x}^{2}}) = (g^{x^{\\prime 2}})^{r_{g} r_{g}^{-1}} / ((g^{x})^{2 r_{x}} g^{r_{x}^{2}}) \\\\ = g^{(x^{2} + 2 x r_{x} + r_{x}^{2})} / g^{(2 x r_{x} + r_{x}^{2})} \\\\ = g^{x^{2}}. \\end{array}</span></div>

    <p class="text-gray-300">The rest of the proof remains the same as the proof of Theorems 6.1 and 6.2.</p>

    <p class="text-gray-300">Remark 6.2. Reduction proofs of a certain granularity can in general be easily applied to the lower granularity variants of the involved assumptions. A sufficient condition is that all involved randomizations extend to the wider probability space associated with the lower granularity parameter. In all the mentioned problem families the random self-reducibility exists for medium granularity and we can transform proofs from a high-granular variant to the corresponding medium-granular variant. However, it does not seem to extend to low-granular variants, since this would require to randomize not only over the public part of the problem instance <span class="math">PI</span> and the generator <span class="math">g</span> but also over the groups <span class="math">G</span> with the same associated security parameter <span class="math">k</span>; this seems impossible to do in the general case and is easily overlooked and can lead to wrong conclusions, e.g., the random self-reducibility as stated by Boneh (1998) doesn't hold as the assumptions are (implicitly) given in their low-granular form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">30 that is $\\forall (x', y') \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2, \\forall (x, y) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> there exists exactly one pair </span>(r_x, r_y) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> such that the equations </span>x' = x + r_x<span class="math">, and </span>y' = y + r_y$ hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.3 CDH versus CIE</p>

    <p class="text-gray-300">In the following, we prove that similar relations as between CDH and CSE also exist for CDH and CIE. As before, we show equivalence between the high-granular CDH and CIE assumptions: In Lemma 6.4 we prove high-granular reduction from CIE to CDH assumption for their different variants with respect to success probability. However, for weak and invariant CDH oracle the reduction does not work directly, and we need to self-correct the CDH oracle first.</p>

    <p class="text-gray-300">For the converse reduction (i.e., from CDH to CIE), we first reduce CSE to CIE (Lemma 6.6), and then apply Theorem 6.2. Finally, we prove that the same relations hold also for the medium-granular versions, however, we can achieve them much more efficiently.</p>

    <pre><code class="language-latex">$\\{1,(1 - 1 / \\mathsf{poly}(k))\\}$  -CIE(c:  $\\ast$  ;g:h;f:fct)  $\\begin{array}{r}\\overbrace{\\alpha^{\\prime} = \\alpha^{O(\\log |G|)};t^{\\prime} = O(t\\log |G|) + O((\\log |G|)^{2})}^{\\alpha^{\\prime} = \\alpha^{O(\\log |G|)};t^{\\prime} = O(t\\log |G|) + O((\\log |G|)^{2})}\\\\ \\end{array}$ $\\{\\epsilon ,1 / \\mathsf{poly}(k)\\}$  -CIE(c:  $\\ast$  ;g:h;f:fct)  $\\begin{array}{r}\\overbrace{\\alpha^{\\prime}\\geq 1 - 1 / 2^{k};t^{\\prime} = O(tk / \\alpha + t\\log |G|) + O(k\\log |G| / \\alpha + (\\log |G|)^{2})}^{\\alpha^{\\prime}\\geq 1 - 1 / 2^{k};t^{\\prime} = O(tk / \\alpha + t\\log |G|) + O(k\\log |G| / \\alpha + (\\log |G|)^{2})}\\\\ \\end{array}$ $\\{(1 - 1 / \\mathsf{poly}(k))\\}$  -CDH(c:  $\\ast$  ;g:h;f:fct)</code></pre>

    <p class="text-gray-300">Proof. The following statements hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Given a CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which breaks  <span class="math">\\{1, (1 - 1 / \\mathsf{poly}(k))\\}</span> -CDH(c:  <span class="math"><em></span> ; g:h; f:fct) with success probability  <span class="math">\\alpha_{CDH}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  which breaks  <span class="math">\\{1, (1 - 1 / \\mathsf{poly}(k))\\}</span> -CIE(c:  <span class="math"></em></span> ; g:h; f:fct) with success probability  $\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> , using  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  oracle calls and  </span>O((\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (a): Given the CDH input tuple  <span class="math">((G,g),(g^{x}))</span> , compute  $g^{x^{-1}} = g^{x^{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}}<span class="math">  by applying, e.g., the square and multiply method which requires  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  calls to  </span>\\mathcal{O}_{CDH}<span class="math"> . Note that for this,  </span>\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  and consequently the factorization of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  must be known (This fact is indicated by the place holder f:fct in the assumption.) Further, note that each time  </span>\\mathcal{O}_{CDH}$  is called its inputs component</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <p class="text-gray-300"><span class="math">g^{u}</span> must be randomized to obtain oracle calls with properly distributed and statistically independent inputs.³¹</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Success probability:</strong> Since there are $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> independent oracle calls the resulting success probability is </span>\\alpha_{CIE} = (\\alpha_{CDH}(k))^{O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math">. Depending on </span>\\alpha_{CDH}(k)$ we have the following cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle <span class="math">(\\alpha_{CDH}(k) \\not\\leq_{\\infty} 1)</span>: Clearly, the resulting success probability is also perfect, i.e., <span class="math">\\alpha_{CIE}(k) \\not\\leq_{\\infty} 1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Strong oracle <span class="math">(1 - \\alpha_{CDH}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is also strong: Set $f(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) := O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It follows </span>f(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\leq b \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for a constant </span>b &gt; 0<span class="math">. As discussed in Section 2.7 we can assume that the group order can be bounded in the security parameter, i.e., </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{k^d}<span class="math"> for some </span>d &gt; 0<span class="math">. It follows </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k^d$ and we can write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{f(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} \\geq \\alpha_{CDH}(k)^{bk^d}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">According to Lemma 6.2 a polynomial power of a strong success probability is itself strong, i.e., <span class="math">1 - \\alpha_{CDH}(k)^{bk^d} \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span> and thus, it follows <span class="math">1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency:</strong> There are $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> oracle calls, and per oracle call </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group operations are required for exponentiations and computing inverses. This makes the total cost of </span>O((\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case (b): The proof is similar to the case (a), except that for the weak and invariant CDH oracle the resulting success probability <span class="math">\\alpha_{CIE}(k)</span> cannot be polynomially bounded, and the above reduction does not work directly. The success probability of <span class="math">\\mathcal{O}_{CDH}</span> has to be improved first by self-correction (see Section 6.1), a task expensive both in terms of oracle calls and group operations.</p>

    <p class="text-gray-300"><strong>Success probability:</strong> As mentioned above, we first self-correct the success probability of the invariant (weak) CDH oracle to strong success probability. This is done by applying Corollary 6.1. Thus, we have <span class="math">1 - \\alpha_{CDH}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>. Then it follows from Lemma 6.2 that <span class="math">\\alpha_{CDH}(k)^{bk^d}</span> is strong, i.e., we have <span class="math">1 - \\alpha_{CDH}(k)^{bk^d} \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>. Since <span class="math">\\alpha_{CIE}(k) \\geq \\alpha_{CDH}(k)^{bk^d}</span> it follows <span class="math">1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300"><strong>Efficiency:</strong> Due to Corollary 6.1 the additional costs for self-correcting are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">³¹ This is done as follows: Due to square and multiply method the input tuple to <span class="math">\\mathcal{O}_{CDH}</span> at given step is either of the form <span class="math">(g^{x^u}, g^x)</span> (multiplication) or of the form <span class="math">(g^{x^u}, g^{x^u})</span> (squaring) for some <span class="math">a</span>. The inputs are randomized by choosing $r, s \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and inputting the tuple </span>(g^{x^u + r}, g^{x + s})<span class="math"> or </span>(g^{x^u + r}, g^{x^u + s})<span class="math"> to </span>\\mathcal{O}_{CDH}<span class="math">. The desired outputs are then computed as </span>g^{x^{a+1}} = \\frac{g^{(x^u + r)(x + s)}}{g^{xx^u + rx + rs}}<span class="math"> or </span>g^{x^{2a}} = \\frac{g^{(x^u + r)(x^u + s)}}{g^{(r + s)x^u + rs}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.3 CDH versus CIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">O(k / \\alpha_{CDH}(k))</span>  oracle calls and  $O(k\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\alpha_{CDH}(k) + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2)<span class="math">  group operations. Thus, the total costs are:  </span>O(k / \\alpha_{CDH}(k) + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  oracle calls and  </span>O(k\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\alpha_{CDH}(k) + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following Lemma we analyze the behavior of  $\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  for group orders containing no small prime factors. This will be helpful when proving relations between certain assumptions in the sequel.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 6.5 Let  <span class="math">SG_{\\mathcal{G}}</span>  be a group sampler generating a family  <span class="math">\\mathcal{G}</span>  of groups whose orders contain no small prime factors. Let  <span class="math">\\mathcal{G}_{SG(k)}</span>  be the corresponding group siblings (the set of groups  <span class="math">G</span>  returned by  <span class="math">SG_{\\mathcal{G}}</span>  for a security parameter  <span class="math">k</span> .) Further, let  <span class="math">f: \\mathbb{N} \\mapsto \\mathcal{G}</span>  be a function such that  <span class="math">f(k) \\in \\mathcal{G}_{SG(k)}</span>  and  $\\forall G' \\in \\mathcal{G}_{SG(k)}, \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\geq \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Then it follows  </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt;_{\\infty} 1 / \\text{poly}(k)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\prod_{i=1}^{m} p_i^{e_i}<span class="math">  be the prime factorization of the group order  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>p = \\min(p_1, \\dots, p_m)<span class="math">  be the smallest prime factor of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Then it follows  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\prod_{i=1}^{m} p_i \\geq p^m<span class="math">  and  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m \\log p<span class="math">  and thus  </span>m \\leq \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\log p \\leq \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for  </span>\\log p \\geq 1<span class="math">  (i.e., for  </span>p \\geq 2<span class="math"> ). Moreover, as discussed in Section 2.7, we can assume that the group order can be upper bounded in security parameter, i.e.,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{k^d}<span class="math">  for  </span>k &gt; 1<span class="math">  and some  </span>d &gt; 0<span class="math"> . It follows  </span>m \\leq \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k^d$ . Hence, we can write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\prod_ {i = 1} ^ {m} (1 - \\frac {1}{p _ {i}}) \\geq (1 - \\frac {1}{p}) ^ {m} &gt; (1 - \\frac {1}{p}) ^ {k ^ {d}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  contains no small prime factors, it follows from the definition of no small prime (see Section 3) that for any real constant  </span>c &gt; 0<span class="math"> , there exists a  </span>k_0<span class="math">  such that for all  </span>k &gt; k_0<span class="math"> ,  </span>1/p &lt; 1/k^c$ . Thus, we can write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\geq (1 - \\frac {1}{p}) ^ {k ^ {d}} &gt; (1 - \\frac {1}{k ^ {c}}) ^ {k ^ {d}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">According to Lemma 6.3, the relation  <span class="math">(1 - 1 / k^{c})^{k^{d}}\\geq 1 - 1 / k^{c - d}</span>  holds for  <span class="math">c &amp;gt; d</span>  and  <span class="math">k\\in \\mathbb{N}</span> . Since  <span class="math">c</span>  is arbitrary, and since for all  <span class="math">c &amp;gt; d</span>  we can write  <span class="math">c^{\\prime}:= c - d &amp;gt; 0</span> , it follows that for all  <span class="math">c^\\prime &amp;gt;0</span> , there exists a  <span class="math">k_{0}</span>  such that for all  <span class="math">k &amp;gt; k_{0}</span> ,  $\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt;1 - 1 / k^{c^{\\prime}}<span class="math">  and consequently  </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; 1 / k^{c^{\\prime}}<span class="math"> . This means  </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; \\infty 1 / \\mathsf{poly}(k)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following lemma we prove the reduction from CSE to CIE assumption for their high-granular version. This lemma will be helpful later when establishing the relation between CIE and CDH assumptions.</p>

    <p class="text-gray-300"><span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span>  -CSE(c:  <span class="math">\\ast</span>  ;g:h;f:nsprim,o)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\alpha^ {\\prime} \\geq \\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha^ {3}; t ^ {\\prime} = 3 t + O (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\hline \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span>  -CIE(c:  <span class="math">\\ast</span>  ;g:h;f:nsprim,o)</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We prove the following statement: Given a CIE oracle <span class="math">\\mathcal{O}_{CIE}</span> which breaks <span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span>-CIE(c: <span class="math">\\ast</span> ; g:h; f:nsprim,o) with success probability <span class="math">\\alpha_{CIE}(k)</span>, there exists an algorithm <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span> which breaks the assumption <span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span>-CSE(c: <span class="math">\\ast</span> ; g:h; f:nsprim,o) with success probability $\\alpha_{CSE}(k) \\geq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{CIE}(k)^3<span class="math">, using 3 oracle calls and </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We proceed as follows:</p>

    <p class="text-gray-300">(i) Select <span class="math">b, r_1, r_2 \\in_{\\mathcal{R}} \\mathbb{Z}_{[G]}^<em></span> compute <span class="math">(g^x g^{-b})^{r_1} = g^{(x - b)r_1}</span> and <span class="math">(g^x g^b)^{r_2} = g^{(x + b)r_2}</span>, and query <span class="math">\\mathcal{O}_{CIE}</span> with <span class="math">((G,g),(g^{(x - b)r_1}))</span> and <span class="math">((G,g),(g^{(x + b)r_1}))</span>. One can expect correct oracle answers with probability <span class="math">\\alpha_{CIE}(k)</span> only if oracle inputs are legal, i.e., only if <span class="math">x \\pm b \\in \\mathbb{Z}_{[G]}^</em></span>. This event occurs with a certain probability which will be determined later. Now, assuming the inputs are legal, one obtains statistically independent oracle calls by randomizing the input elements with <span class="math">r_1, r_2</span>. The oracle answers are <span class="math">g^{\\frac{1}{r_1(x - b)}} = \\mathcal{O}_{CIE}\\big(g^{(x - b)r_1}\\big)</span> and <span class="math">g^{\\frac{1}{r_2(x + b)}} = \\mathcal{O}_{CIE}\\big(g^{(x + b)r_2}\\big)</span>, each time with probability <span class="math">\\alpha_{CIE}(k)</span>.</p>

    <p class="text-gray-300">(ii) Using the oracle's answers in Step (i) compute:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {g ^ {\\frac {1}{r _ {1} (x - b)}}}{g ^ {\\frac {1}{r _ {2} (x + b)}}}\\right) ^ {r _ {1}} = g ^ {\\left(\\frac {1}{x - b} - \\frac {1}{x + b}\\right)} = g ^ {\\frac {2 b}{x ^ {2} - b ^ {2}}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The exponent <span class="math">\\frac{2b}{x^2 - b^2}</span> is an element of <span class="math">\\mathbb{Z}_{[G]}^<em></span> because of the following reasons: <span class="math">b \\in \\mathbb{Z}_{[G]}^</em></span>, and as discussed above, <span class="math">x \\pm b \\in \\mathbb{Z}_{[G]}^<em></span> which implies <span class="math">x^2 - b^2 \\in \\mathbb{Z}_{[G]}^</em></span>. Further, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is odd as the group families do not have any small prime factors in the order.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(iii) Select <span class="math">r_3 \\in_{\\mathcal{R}} \\mathbb{Z}_{[G]}^*</span> and query <span class="math">\\mathcal{O}_{CIE}</span> with <span class="math">\\left((G, g), \\left(\\left(g^{\\frac{2b}{x^2 - b^2}}\\right)^{r_3}\\right)\\right)</span> where <span class="math">r_3</span> is used for randomization to obtain statistically independent oracle call. The oracle answers <span class="math">g^{\\frac{x^2 - b^2}{2br_3}} = \\mathcal{O}_{CIE}\\left(g^{\\frac{2br_3}{x^2 - b^2}}\\right)</span> with success probability <span class="math">\\alpha_{CIE}(k)</span>.</p>

    <p class="text-gray-300">(iv) Compute the desired CSE instance by using the oracle's answer in Step (iii)</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {x ^ {2}} = \\left(g ^ {\\frac {x ^ {2} - b ^ {2}}{2 b r _ {3}}}\\right) ^ {2 b r _ {3}} g ^ {b ^ {2}}.</span></div>

    <p class="text-gray-300">Success probability: The probability that both events <span class="math">E_1 : x + b \\in \\mathbb{Z}_{[G]}^*</span> and</p>

    <p class="text-gray-300">6.3 CDH versus CIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$E_{2}:x - b\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}$  occur (in Step (i)) is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {P r o b} [ E _ {1} \\wedge E _ {2} ] = \\mathbf {P r o b} [ E _ {1} ] + \\mathbf {P r o b} [ E _ {2} ] - \\mathbf {P r o b} [ E _ {1} \\vee E _ {2} ] \\\\ = \\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\mathbf {P r o b} [ E _ {1} \\vee E _ {2} ] \\\\ \\geq \\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1 \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where we set  <span class="math">\\mathbf{Prob}[E_1 \\vee E_2] = 1</span> . Obviously, this is a worst case lower bound.[33]</p>

    <p class="text-gray-300">Each time with probability  <span class="math">\\alpha_{CIE}(k)</span>  the oracle outputs the correct value. There are 3 statistically independent calls to the oracle, and so the resulting success probability of  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  is:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {C S E} (k) \\geq (\\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1) \\alpha_ {C I E} (k) ^ {3}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following, we set  <span class="math">\\lambda(k) \\coloneqq \\alpha_{CIE}(k)^3</span>  and  $\\gamma(k) \\coloneqq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1<span class="math">  (Note that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is a function of the security parameter  </span>k<span class="math"> , see also Lemma 6.5) Depending on the oracle&#x27;s success probability  </span>\\alpha_{CIE}(k)$  we have the following cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle  <span class="math">(\\alpha_{CIE}(k) \\not\\prec_{\\infty} 1)</span> : The resulting success probability cannot be perfect because there is a non-zero error probability when querying the CIE oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak oracle  <span class="math">(\\alpha_{CIE}(k) \\not\\prec_{\\infty} 1 / \\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) weak: Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  contains no small prime factors, it follows from Lemma 6.5 that  </span>1 - \\gamma(k) = 2(1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math"> . Thus, we can write  </span>\\gamma(k) &gt;_{\\infty} 1 - 1 / \\mathsf{poly}(k)<span class="math"> , meaning that  </span>\\gamma(k)<span class="math">  is non-negligible. Further, we have  </span>\\alpha_{CIE}(k) \\not\\prec_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">  which implies  </span>\\lambda(k) \\not\\prec_{\\infty} 1 / \\mathsf{poly}(k)<span class="math"> . It follows  </span>\\gamma(k) \\lambda(k) \\not\\prec_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">  (see also Section 2.2) Finally, since  </span>\\alpha_{CSE}(k) \\geq \\gamma(k) \\lambda(k)<span class="math"> , it follows  </span>\\alpha_{CSE}(k) \\not\\prec_{\\infty} 1 / \\mathsf{poly}(k)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{CIE} \\not\\prec_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant: As shown in the weak case, we can write  <span class="math">\\gamma(k) &amp;gt;_{\\infty} 1 - 1 / \\mathsf{poly}(k)</span> . More precisely, for any  <span class="math">\\epsilon&#x27; &amp;gt; 0</span>  there exist a  <span class="math">k_0</span>  such that for all  <span class="math">k &amp;gt; k_0</span> ,  <span class="math">\\gamma(k) &amp;gt; 1 - \\epsilon&#x27;</span> . Since  <span class="math">\\alpha_{CIE}(k) \\not\\prec_{\\infty} \\epsilon_1</span> , for any  <span class="math">k_0&#x27;</span>  there exists a  <span class="math">k_1 &amp;gt; k_0&#x27;</span>  such that  <span class="math">\\alpha_{CIE}(k_1) \\geq \\epsilon_1</span>  and consequently  <span class="math">\\lambda(k_1) \\geq \\epsilon_1^3</span> . Hence, for any  <span class="math">k_0&#x27; &amp;gt; k_0</span>  there exists a  <span class="math">k_1 &amp;gt; k_0&#x27;</span>  such that  <span class="math">\\alpha_{CSE}(k_1) \\geq \\epsilon_2</span>  where  <span class="math">\\epsilon_2 := (1 - \\epsilon&#x27;)\\epsilon_1^3</span> . This means  <span class="math">\\alpha_{CSE}(k) \\not\\prec_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong. For this, we first prove that  <span class="math">1 - \\gamma(k) \\lambda(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span> : As shown in the weak case, we can write  <span class="math">\\gamma(k) &amp;gt;_{\\infty} 1 - 1 / \\mathsf{poly}(k)</span> . Further, from Lemma 6.2 it follows  <span class="math">1 - \\lambda(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span> . Applying Lemma</p>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <p class="text-gray-300">6.7 we obtain <span class="math">1 - \\gamma(k)\\lambda(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>. Since <span class="math">1 - \\alpha_{CSE}(k) \\leq 1 - \\gamma(k)\\lambda(k)</span>, it follows <span class="math">1 - \\alpha_{CSE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">Lemma 6.7 Let <span class="math">f(k)</span>, <span class="math">g(k)</span> be functions <span class="math">\\mathbb{N} \\to [0,1]</span>. If <span class="math">1 - f(k) \\not\\geq_{\\infty} 1 / \\mathrm{poly}(k)</span> and <span class="math">1 - g(k) &amp;lt;_{\\infty} 1 / \\mathrm{poly}(k)</span>, then <span class="math">1 - f(k)g(k) \\not\\geq_{\\infty} 1 / \\mathrm{poly}(k)</span>.</p>

    <p class="text-gray-300">Proof. Consider <span class="math">P(k) = (1 - f(k))(1 - g(k))</span>. Obviously, <span class="math">P(k) \\geq 0</span> for all <span class="math">k</span> and we can write</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (1 - f (k)) (1 - g (k)) = 1 + f (k) g (k) - f (k) - g (k) \\\\ = - (1 - f (k) g (k)) + (1 - f (k)) + (1 - g (k)) \\\\ = - (1 - f (k) g (k)) + S (k) \\geq 0 \\end{array}</span></div>

    <p class="text-gray-300">where we set <span class="math">S(k) \\coloneqq (1 - g(k)) + (1 - f(k))</span>. <span class="math">S(k)</span> is a not non-negligible function since it is the sum of a negligible and a not non-negligible function. Thus, we can write <span class="math">S(k) \\not\\geq_{\\infty} 1 / \\mathrm{poly}(k)</span>. From equations above we have <span class="math">1 - f(k)g(k) \\leq S(k)</span>. Since <span class="math">S(k) \\not\\geq_{\\infty} 1 / \\mathrm{poly}(k)</span>, it follows <span class="math">1 - f(k)g(k) \\not\\geq_{\\infty} 1 / \\mathrm{poly}(k)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: There are 3 calls to <span class="math">\\mathcal{O}_{CIE}</span>, and $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations are required for the exponentiations and computing the inverse elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 6.3. For groups of prime order, the resulting success probability covers also perfect success probability as the special case of elements not in <span class="math">\\mathbb{Z}_p^*</span> (i.e., 0) can be tested and handled.</p>

    <p class="text-gray-300">Using the previous results we can now prove the relation between CIE and CDH assumptions in their high-granular variant.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\text{-CIE} (c: *; g: h; f: f: c)</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underbrace{\\alpha^{\\prime} \\geq 1 - 1 / 2^{k} ; t^{\\prime} = O\\left(\\frac{tk}{n} + t \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) + O\\left(\\frac{k \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n} + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}\\right)}_{\\text{<em> - CDH} (c: </em>; g: h; f: f: c)};</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\{(1 - 1 / \\operatorname {p o l y} (k)), \\epsilon , 1 / \\operatorname {p o l y} (k) \\} - \\operatorname {C I E} (\\mathrm {c}: *; \\mathrm {g}: \\mathrm {h}; \\mathrm {f}: \\mathrm {n s p r i m}, \\mathrm {o})</span></div>

    <p class="text-gray-300">$$ \\begin{array}{c}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\prime} \\geq (\\frac{2 \\rho \\langle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rangle - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{2} \\alpha^{9}; t^{\\prime} = 9t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\hline \\hline \\{(1 - 1 / \\operatorname {p o l y} (k)), \\epsilon , 1 / \\operatorname {p o l y} (k) \\} - \\operatorname {C D H} (\\mathrm {c}: *; \\mathrm {g}: \\mathrm {h}; \\mathrm {f}: \\mathrm {n s p r i m}, \\mathrm {o}) \\end{array} $$</p>

    <p class="text-gray-300">Proof. The following statements hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Given a CDH oracle <span class="math">\\mathcal{O}_{CDH}</span> which breaks <span class="math"><em></span>-CDH(c: <span class="math"></em>;</span> g:h; f:fct) with success probability <span class="math">\\alpha_{CDH}(k)</span>, there exists an algorithm <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span> which breaks <span class="math"><em></span>-CIE(c: <span class="math"></em>;</span> g:h; f:fct) with success probability $\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math">, using at most </span>O\\left(\\frac{k}{\\alpha_{CDH}(k)} + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)<span class="math"> calls to </span>\\mathcal{O}_{CDH}<span class="math"> and </span>O\\left(\\frac{k \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\alpha_{CDH}(k)} + (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}\\right)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.3 CDH versus CIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) Given a CIE oracle  <span class="math">\\mathcal{O}_{CIE}</span>  which breaks  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CIE(c:  <span class="math"><em></span>  ;g:h;f:nsprim,o) with success probability  <span class="math">\\alpha_{CIE}(k)</span>  , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  which breaks  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CDH(c:  <span class="math"></em></span>  ;g:h;f:nsprim,o) with success probability  $\\alpha_{CDH}(k)\\geq (\\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^3\\alpha_{CIE}(k)^9<span class="math">  , using 9 oracle calls and  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case (a): Follows immediately from lemma 6.4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (b): According to Theorem 6.2 there is a reduction from  <span class="math"><em></span> -CDH(c:  <span class="math"></em></span> ; g:h; f: o) to  <span class="math"><em></span> -CSE(c:  <span class="math"></em></span> ; g:h; f: o) with success probability  <span class="math">\\alpha_{CDH}(k) = \\alpha_{CSE}(k)^3</span> , using 3 calls to  <span class="math">\\mathcal{O}_{CDH}</span>  and  $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, according to Lemma 6.6 there is a reduction from  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CSE(c:  <span class="math"><em></span>  ;g:h;f:nsprim,o) to  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CIE(c:  <span class="math"></em></span>  ;g:h;f:nsprim,o) with success probability  $\\alpha_{CSE}(k)\\geq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{CIE}(k)^3<span class="math">  , using 3 oracle calls and  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Combining these results we obtain a reduction from  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CDH(c:  <span class="math"><em></span>  ;g:h;f:nsprim,o) to  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span>  -CIE(c:  <span class="math"></em></span>  ;g:h;f:nsprim,o) with the resulting success probability  $\\alpha_{CDH}(k)\\geq (\\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^3\\alpha_{CIE}(k)^9<span class="math">  , using 9 oracle calls and  </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations. This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 6.4. Theorem 6.4 concerns only group orders with no small prime factors, and does not cover the gap between the group orders with at least one large prime factor and those containing no small primes. Note that for group orders with only small prime factors the problems are easy to solve since one can apply well-known algorithms for solving the discrete logarithms (Shoup 1997).</p>

    <p class="text-gray-300">Remark 6.5. The CDH oracle can be used to multiply two discrete logarithms without knowing them explicitly (e.g., to compute  <span class="math">g^{x^2}</span>  without knowing  <span class="math">x</span> ). Using CDH oracle one can compute  <span class="math">g^{p(x)}</span>  for a polynomial  <span class="math">p(x)</span>  with integer coefficients or to compute  <span class="math">g^{h(x)}</span>  for any rational function of the form  <span class="math">h(x) = f(x) / g(x)</span>  where  <span class="math">f(x), g(x)</span>  are polynomials with integer coefficients. This fact was also mentioned shortly by Maurer (1994). As a consequence one can use CDH oracle to compute any multivariate polynomial  <span class="math">p(x_1, x_2, \\dots, x_n)</span>  or rational function  <span class="math">h(x_1, x_2, \\dots, x_n)</span>  in the exponent.</p>

    <p class="text-gray-300">Let us, for brevity, consider bivariate expressions in exponents. Assume we are given an oracle which, on input  <span class="math">g^x, g^y</span> , outputs  <span class="math">g^{p(x,y)}</span>  with a certain probability, where  <span class="math">p(x,y)</span>  is a known (fixed) bivariate polynomial whose degree and form is appropriately defined. We may call this oracle CPE (Computational Polynomial Exponent) and want to analyze its relation to CDH oracle. Due to the discussion above we can easily construct a CPE oracle using a CDH oracle, however, the converse (reduction CDH to CPE) is not obvious. This direction</p>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <p class="text-gray-300">was shown in Kiltz (2001): First show the equivalence between CDH oracle and a CPE oracle which computes polynomials of degree 2 (according to the underlying polynomial definition). We denote such oracle with <span class="math">\\mathrm{CPE}(2)</span>. Next prove that a <span class="math">\\mathrm{CPE}(n)</span>, i.e., a CPE oracle outputting <span class="math">p(x,y)</span> of degree <span class="math">n</span>, can be inductively reduced to <span class="math">\\mathrm{CPE}(2)</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">6.3.2 Medium Granular</h2>

    <p class="text-gray-300">Next, we prove the above equivalence (Theorem 6.4) also for medium granularity. Similar to Theorem 6.3 we could argue that due to the existence of a randomization the result immediately follows also for the medium-granular case. However, we will show that this reduction can be performed much more efficiently in the medium-granular case than in the high-granular case; thereby we improve the concrete security considerably. We start with the following lemma.</p>

    <h2 id="sec-33" class="text-2xl font-bold">Lemma 6.8</h2>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\text{-CIE}(c: *; g: m; f: o) \\\\</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xrightarrow{\\alpha' = \\alpha; t' = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\text{-CIE}(c: *; g: m; f: o);</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\{(1 - 1/\\operatorname{poly}(k)), \\epsilon, 1/\\operatorname{poly}(k)\\} \\text{-CIE}(c: *; g: m; f: n \\text{spring}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xrightarrow[\\text{COO}]{\\alpha' \\geq \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha; t' = t} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\{(1 - 1/\\operatorname{poly}(k)), \\epsilon, 1/\\operatorname{poly}(k)\\} \\text{-CIE}(c: *; g: m; f: n \\text{spring}) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Proof. We prove that the following statements hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Given a CIE oracle <span class="math">\\mathcal{O}_{CIE}</span> which breaks <span class="math"><em></span>-CIE(c: </em>; g: m; f: o) with success probability <span class="math">\\alpha_{CIE}(k)</span>, there exists an algorithm <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span> that breaks <span class="math"><em></span>-CIE(c: </em>; g: m; f: o) with success probability <span class="math">\\alpha_{CIE}(k) = \\alpha_{CIE}(k)</span>, using 1 oracle call and $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) Given a CIE oracle <span class="math">\\mathcal{O}_{CIE}</span> which breaks <span class="math">\\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CIE(c: <em>; g: h; f: n \\text{spring})<span class="math"> with success probability </span>\\alpha_{CIE}(k)<span class="math">, there exists an algorithm </span>\\mathcal{A}^{\\mathcal{O}_{CIE}}<span class="math"> which breaks </span>\\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}<span class="math"> -CIE(c: </em>; g: h; f: n \\text{spring})</span> with success probability $\\alpha_{CIE}(k) \\geq \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{CIE}(k)$, using 1 oracle call.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (a): Given a CIE input tuple <span class="math">((G,g),(g^x))</span> with $x\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> we construct </span>\\mathcal{A}^{\\mathcal{O}_{CIE}}<span class="math"> as follows: Set </span>h:=g^{x}<span class="math">, then we have </span>g = h^{t}<span class="math"> for </span>t\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">. Since </span>x\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">, </span>h<span class="math"> is a group generator, and </span>t = x^{-1}<span class="math"> exists as we implicitly assumed above. Select </span>r\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and pass </span>((G,h),(h^{t + r}))<span class="math"> to </span>\\mathcal{O}_{CIE}<span class="math"> where </span>h^{t + r} = gg^{r}<span class="math">. The reason for the randomization with </span>r<span class="math"> is that here the inputs to </span>\\mathcal{O}_{CIE}<span class="math"> are limited to those with secret exponents </span>x<span class="math"> from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*$ whereas the success probability of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6.3 CDH versus CIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{O}_{CSE}</span> is defined over the input set with $x \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Using the answer of </span>\\mathcal{O}_{CSE}$ we compute</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">h^{t^2} = \\frac{\\mathcal{O}_{CSE}(h^{t+r})}{g^{2r} g^{r^2}} = \\frac{h^{t^2 + 2rt + r^2}}{(h^t)^{2r} h^{r^2}}.</span></div>

    <p class="text-gray-300">Since <span class="math">t = x^{-1}</span> we exploit the identity <span class="math">h^{t^2} = (g^x)^{(x^{-1})^2} = (g^x)^{x^{-2}} = g^{xx^{-2}} = g^{x^{-1}}</span> to solve CIE input.</p>

    <p class="text-gray-300"><strong>Success probability:</strong> There is a single call to <span class="math">\\mathcal{O}_{CSE}</span>. Thus, the resulting success probability is <span class="math">\\alpha_{CIE}(k) = \\alpha_{CSE}(k)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency:</strong> There is a single oracle call, and there are $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations required for computing the inverses and exponentiations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (b): Given a CSE input tuple <span class="math">((G,g),(g^x))</span>, we construct <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span> as follows: Set <span class="math">h := g^x</span> and pass <span class="math">((G,h),(h^t))</span> to <span class="math">\\mathcal{O}_{CIE}</span> where <span class="math">h^t = g</span>. Note that <span class="math">\\mathcal{O}_{CIE}</span> answers correctly (i.e., <span class="math">h^{t^{-1}}</span>) with probability <span class="math">\\alpha_{CIE}(k)</span> only to the legal queries, i.e., when <span class="math">h</span> is a generator and $t \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">. The probability for this event is </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Note that in this case </span>t := x^{-1}<span class="math"> exists, as we implicitly assumed above. The desired solution to the CSE problem is obtained by exploiting the identity </span>h^{t^{-1}} = (g^x)^{(x^{-1})^{-1}} = g^{x^2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Success probability:</strong> There is a single call to <span class="math">\\mathcal{O}_{CIE}</span>. Thus, the resulting success probability is $\\alpha_{CSE}(k) \\geq \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{CIE}(k)<span class="math">. Depending on the oracle&#x27;s success probability </span>\\alpha_{CIE}(k)$ we have the following cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle <span class="math">(\\alpha_{CIE}(k) \\not\\leq_{\\infty} 1)</span>: The resulting success probability cannot be perfect because there is a non-zero error probability when querying the CIE oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak oracle <span class="math">(\\alpha_{CIE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is weak: <span class="math">\\alpha_{CIE}(k)</span> is a not negligible function, and $\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> is always non-negligible (see also Lemma 6.5). Thus, the product of these terms is a not-negligible function, implying </span>\\alpha_{CSE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Invariant oracle <span class="math">(\\alpha_{CIE} \\not\\leq_{\\infty} \\epsilon_1)</span>: The resulting success probability is (asymptotically) invariant. The proof is similar to that of the invariant case in Lemma 6.6: Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> contains no small prime factors, it follows from Lemma 6.5 that </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. More precisely, for all </span>\\epsilon' &gt; 0<span class="math"> there exist a </span>k_0<span class="math"> such that for all </span>k &gt; k_0<span class="math">, </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt; 1 - \\epsilon'<span class="math">. Since </span>\\alpha_{CIE}(k) \\not\\leq_{\\infty} \\epsilon_1<span class="math">, for any </span>k_0'<span class="math"> there exists </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{CIE}(k_1) &gt; \\epsilon_1<span class="math">. Thus, for any </span>k_0' &gt; k_0<span class="math"> there exists </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{CSE}(k_1) &gt; \\epsilon_2<span class="math"> where </span>\\epsilon_2 := (1 - \\epsilon')\\epsilon_1<span class="math">. This means </span>\\alpha_{CSE}(k) \\not\\leq_{\\infty} \\epsilon_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Strong oracle <span class="math">(1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is (asymptotically) strong. The proof is similar to that of the strong case in Lemma 6.6: Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ contains no small prime factors, it follows from Lemma</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6 COMPUTATIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6.5 that $1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; \\infty 1 / \\mathsf{poly}(k)<span class="math">. Further, we have </span>1 - \\alpha_{CIE}(k) \\geq \\infty 1 / \\mathsf{poly}(k)<span class="math">. Applying Lemma 6.7 we obtain </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{CIE}(k) \\geq \\infty 1 / \\mathsf{poly}(k)<span class="math">, and since </span>1 - \\alpha_{CSE}(k) \\leq 1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{CIE}(k)<span class="math">, it follows </span>1 - \\alpha_{CSE}(k) \\geq \\infty 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Theorem 6.3 and Lemma 6.8 we obtain the following theorem on the relation between the medium-granular variants of CIE and CDH assumptions.</p>

    <h2 id="sec-34" class="text-2xl font-bold">Theorem 6.5</h2>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathrm{-CIE} (c: *; g: m; f: o)</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xrightarrow{\\alpha' = \\alpha; t' = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathrm{-CDH} (c: *; g: m; f: o);</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\{(1 - 1 / \\operatorname{poly}(k)), \\epsilon, 1 / \\operatorname{poly}(k) \\} - \\operatorname{CIE} (c: *; g: m; f: n \\text{spring}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\xrightarrow[\\text{cut}]{} \\alpha' \\geq \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^3 \\alpha^3; t' = 3t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\hline \\{(1 - 1 / \\operatorname{poly}(k)), \\epsilon, 1 / \\operatorname{poly}(k) \\} - \\operatorname{CDH} (c: *; g: m; f: n \\text{spring}) \\\\ \\end{array} $$</p>

    <p class="text-gray-300">Remark 6.6. In Theorem 6.5 we consider group orders containing no small prime factors (for the reduction CIE to CDH) to obtain comparable results to the high-granular variant of the reduction. However, the reduction holds also for general group orders <span class="math">^{35}</span> although for invariant and strong CIE oracle we need to self-correct the resulting success probability <span class="math">\\alpha_{CDH}</span> after the reduction (see Corollary 6.1). This is stated in the following lemma.</p>

    <h2 id="sec-35" class="text-2xl font-bold">Lemma 6.9</h2>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\{(1 - 1 / \\operatorname{poly}(k)), \\epsilon, 1 / \\operatorname{poly}(k) \\} - \\operatorname{CIE} (c: *; g: m; f: *) \\\\ \\Longleftarrow \\\\ \\{(1 - 1 / \\operatorname{poly}(k)), \\epsilon, 1 / \\operatorname{poly}(k) \\} - \\operatorname{CDH} (c: *; g: m; f: *) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Remark 6.7. For prime group orders Theorem 6.5 also covers perfect oracles as the special case of elements not in <span class="math">\\mathbb{Z}_p^*</span> (i.e., 0) can be tested and handled.</p>

    <p class="text-gray-300">In this section we have analyzed and proved relations between CDH, CSE, CIE in their high- and medium-granular versions. We can summarize the advantages of medium-granular reductions over their high-granular variants as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The medium-granular reduction of CIE to CDH (Theorem 6.4) does not require the CDH oracle to be self-corrected.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The medium-granular reduction (Theorem 6.5) is much more efficient than the corresponding high-granular reduction (Theorem 6.4): The reduction CIE-CDH requires a single call to the CDH oracle and $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{35}</span>e.g., it holds also for orders containing at least one large prime factor.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">operations whereas the high-granular version requires, even without self-correction, $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (very expensive) oracle calls and </span>O((\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2})<span class="math"> group operations. Further, the reduction achieves a success probability which is higher by a power of </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. The success probability of the converse reduction CDH-CIE is comparatively higher for the medium-granular variant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The high-granular variant of Theorem 6.5 works for group orders with no small prime factors. It does not cover the range of group orders with at least one large prime factor to those with no small prime factors. However, this gap is covered by the medium-granular version since the reduction works for any group order (see Remarks 6.4 and 6.6).</li>

    </ul>

    <h2 id="sec-36" class="text-2xl font-bold">7 Decisional DH, SE and IE</h2>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">7.1 Difficulty in the Generic Model</h3>

    <p class="text-gray-300">First we state a Lemma which plays an important role for later proofs in the context of generic algorithms:</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Lemma 7.1 <em>(Schwartz 1980; Shoup 1997)</em></h6>

    <p class="text-gray-300">Let <span class="math">p\\in\\mathbb{P}</span> and <span class="math">e\\in\\mathbb{N}</span>. Further, let <span class="math">P(X_{1},X_{2},\\cdots,X_{n})</span> be a non-zero polynomial in <span class="math">\\mathbb{Z}_{p^{e}}[X]</span> of total degree <span class="math">d\\geq 0</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\textbf{Prob}[P(x_{1},x_{2},\\cdots,x_{n})\\equiv 0::(x_{1},x_{2},\\cdots,x_{n})\\in_{\\mathcal{R}}\\mathbb{Z}_{p^{e}}^{n}]\\leq d/p.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Using Lemma 7.1 <em>Wolf (1999)</em> shows the following result: There exists no generic algorithm that can solve DSE in polynomial time if the order of the multiplicative group is not divisible by small primes. This result is summarized in the following theorem:</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 7.1 <em>(Wolf 1999)</em></h6>

    <p class="text-gray-300"><span class="math">\\textit{true}\\implies\\epsilon\\text{-DSE}^{\\sigma}(\\text{c:}\\ast;\\text{g:h;f:nsprim,o})</span> ∎</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 7.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More precisely, Wolf shows, the probability that any generic algorithm <span class="math">\\mathcal{A}^{\\sigma}</span> can correctly distinguish correct DSE inputs from incorrect ones is at most <span class="math">\\frac{(T+4)(T+3)}{2p^{\\prime}}</span> where <span class="math">p^{\\prime}</span> is the smallest prime factor of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>T$ is an upper bound on the algorithm’s runtime.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-41" class="text-base font-medium mt-4">Remark 7.2.</h6>

    <p class="text-gray-300">In the sequel, we will consider several decisional problems and prove results on the generic complexity of solving them. For known group orders the generic complexity of these problems is directly proportional to the smallest prime factor of the group order (similar to the result of Theorem 7.1)</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, these problems can only be hard if the group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is free of small primes.³⁶</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To make this more clear, consider the following example regarding DDH for group family with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2q<span class="math"> where </span>q \\in \\mathbb{P}<span class="math"> is a prime. We assume that DDH is hard for </span>q<span class="math">. Note that this example can be generalized to any group families with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> containing small prime factors. Now, assume we are given a correct DDH tuple </span>I_1 := ((G, g), (g^x, g^y), (g^{xy}))<span class="math"> and a random DDH tuple </span>I_0 := ((G, g), (g^x, g^y), (g^{x'y'}))<span class="math"> with </span>x', y' \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is even, we can determine the parity </span>\\text{parity}(exp) := \\exp \\bmod 2<span class="math"> of the exponents </span>exp \\in \\{x, y, xy, x'y'\\}$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\text{parity}(exp) = \\left\\{ \\begin{array}{l l} 0 &amp;amp; : \\text{if } (g^{exp})^q = 1 \\\\ 1 &amp;amp; : \\text{if } (g^{exp})^q = g^q. \\end{array} \\right.</span></div>

    <p class="text-gray-300">This can be exploited to construct an algorithm (distinguisher) <span class="math">D</span> which solves DDH in <span class="math">G</span> with non-negligible success probability. <span class="math">D</span> gets the tuple <span class="math">I_b</span> as input, where <span class="math">b</span> is a randomly and uniformly chosen bit, and outputs a bit <span class="math">D(I_b)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">D(I_b) := \\left\\{ \\begin{array}{l l} 1 &amp;amp; : \\text{if } \\text{parity}(z) = \\text{parity}(x) \\text{parity}(y) \\\\ 0 &amp;amp; : \\text{otherwise} \\end{array} \\right.</span></div>

    <p class="text-gray-300">where <span class="math">z</span> is either <span class="math">xy</span> or <span class="math">x&#x27;y&#x27;</span>. <span class="math">D</span> is successful if and only if <span class="math">D(I_b) = b</span>. The success probability of <span class="math">D</span> is determined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{Prob}[D(I_b) = b] = \\mathbf{Prob}[D(I_b) = 1 \\mid b = 1] \\mathbf{Prob}[b = 1] \\\\ \\quad + \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0] \\mathbf{Prob}[b = 0] \\\\ \\quad = 1 \\left(\\frac{1}{2}\\right) + \\frac{1}{2} \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0] \\\\ \\quad = \\frac{1}{2} + \\frac{1}{2} \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0]. \\end{array}</span></div>

    <p class="text-gray-300">Note that <span class="math">\\mathbf{Prob}[D(I_b) = 1 \\mid b = 1] = 1</span> always holds. Further, <span class="math">\\mathbf{Prob}[b = 1] = \\mathbf{Prob}[b = 0] = 1/2</span> holds since <span class="math">b</span> is chosen randomly and uniformly from <span class="math">\\{0,1\\}</span>. It remains to compute <span class="math">\\mathbf{Prob}[D(I_b) = 0 \\mid b = 0]</span>. For this, we consider the 4 possible cases for the parities of <span class="math">x</span> and <span class="math">y</span> represented by the disjoint events <span class="math">E_{i,j}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{i,j} := \\left\\{(i, j): x, y \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\wedge i = \\text{parity}(x) \\wedge j = \\text{parity}(y) \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for <span class="math">i,j \\in \\{0,1\\}</span>. It follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0] = \\sum_{i, j \\in \\{0,1\\}} \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0 \\wedge E_{i,j}] \\mathbf{Prob}[E_{i,j}] \\\\ \\quad = \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0 \\wedge E_{1,1}] \\mathbf{Prob}[E_{1,1}] \\\\ \\quad + \\sum_{\\substack{i, j \\in \\{0,1\\} \\\\ (i, j) \\neq (1, 1)}} \\mathbf{Prob}[D(I_b) = 0 \\mid b = 0 \\wedge E_{i,j}] \\mathbf{Prob}[E_{i,j}]. \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">³⁶Note that if the group order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is known then its small prime factors can easily be computed by using well-known factoring algorithms.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.1 Difficulty in the Generic Model</p>

    <p class="text-gray-300">Since <span class="math">x</span> and <span class="math">y</span> are chosen uniformly and randomly we have <span class="math">\\mathbf{Prob}[E_{i,j}] = 1/4</span> for all <span class="math">i,j \\in \\{0,1\\}</span>. Further, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Prob}[D(I_b) = 0 \\mid b = 0 \\wedge E_{1,1}] = \\mathbf{Prob}[\\text{parity}(z) = 0] = 3/4</span></div>

    <p class="text-gray-300">and for <span class="math">i,j \\in \\{0,1\\}, (i,j) \\neq (1,1)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Prob}[D(I_b) = 0 \\mid b = 0 \\wedge E_{i,j}] = \\mathbf{Prob}[\\text{parity}(z) = 1] = 1/4.</span></div>

    <p class="text-gray-300">Substituting these results in the above equations we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Prob}[D(I_b) = 0 \\mid b = 0] = 1/4(3/4) + 1/4(3/4) = 6/16</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Prob}[D(I_b) = b] = 1/2 + 1/2(6/16) = 11/16.</span></div>

    <p class="text-gray-300">According to our definitions of the assumptions in Section 4 the adversary's success probability for decisional assumptions is normalized to <span class="math">(\\mathbf{Prob}[D(I_b) = b] - 1/2)2 = 6/16</span>. Thus, with (non-negligible) success probability <span class="math">6/16</span> the distinguisher can recognize the correct DDH tuple.</p>

    <p class="text-gray-300"><strong>Remark 7.3.</strong> Theorem 7.1 holds also for other variants of the assumption with respect to the success probabilities perfect, weak and strong.</p>

    <p class="text-gray-300"><strong>Remark 7.4.</strong> It might look surprising that <span class="math"><em></span>-DSE<span class="math">^{\\sigma}</span>(c:<span class="math"></em></span>; g:h; f:nsprim) always holds, i.e., it's a fact, not an assumption. Of course, the crucial aspect is the rather restricted adversary model (the <span class="math">\\sigma</span> in the assumption statement) which limits adversaries to generic algorithms. However, note that, consequently, to break DSE, one has to exploit deeper knowledge on the actual structure of the used algebraic groups. In particular, for appropriately chosen prime-order subgroups of <span class="math">\\mathbb{Z}_p^*</span> and elliptic or hyper-elliptic curves no such exploitable knowledge could yet be found, and all of currently known efficient and relevant algorithms in these groups are generic algorithms, e.g., Pohlig-Hellman (1978) or Pollard-<span class="math">\\rho</span> (Pollard 1978). Nevertheless, care has to be applied when proving systems secure in the generic model (Fischlin 2000).</p>

    <p class="text-gray-300"><strong>Remark 7.5.</strong> As we will see later several (impossibility) results are proven in the generic model. All these proofs use similar techniques to determine bounds on the amount of information a generic adversary can obtain. For the better understanding, we describe this below by giving an example for DDH.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First recall that in the generic model a group element <span class="math">a \\in G</span> is represented by its encoding <span class="math">\\sigma(x)</span>, with $x \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, using an encoding function </span>\\sigma(\\cdot)<span class="math"> chosen randomly from the set </span>\\Sigma_{G,g}<span class="math"> of bijective functions </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\to G<span class="math">. The generic adversary </span>\\mathcal{A}^{\\sigma}<span class="math"> is given </span>\\sigma(1)<span class="math">, i.e., the encoding of a generator, and it is given access to oracles for performing addition </span>\\sigma(x + y) \\gets \\sigma_{+}(\\sigma(x), \\sigma(y))<span class="math"> and inversions </span>\\sigma(-x) \\gets \\sigma_{-}(x)$ on group elements (see also Section 3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A decisional problem in this model is formulated as follows: The adversary <span class="math">\\mathcal{A}^{\\sigma}</span> is given the encodings of the secret, solution and random parts where the</p>

    <p class="text-gray-300">37 As we will see later, for proving the impossibility of some reductions <span class="math">\\mathcal{A}^{\\sigma}</span> is given access to additional oracles.</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">latter two parts are in random order. Then <span class="math">\\mathcal{A}^{\\sigma}</span> has to decide on the correct order of these two parts. For DDH it means, <span class="math">\\mathcal{A}^{\\sigma}</span> is given <span class="math">\\sigma(1), \\sigma(x), \\sigma(y)</span> and the elements <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span> in random order. Now, <span class="math">\\mathcal{A}^{\\sigma}</span> has to decide which of the elements <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span> is the encoding of the solution part and which one corresponds to the encoding of the random part. Assuming <span class="math">\\mathcal{A}^{\\sigma}</span> makes <span class="math">T</span> queries to the addition and inversion oracles we are interested in the amount of information it can obtain. Each time <span class="math">\\mathcal{A}^{\\sigma}</span> interacts with these oracles it learns the encoding <span class="math">\\sigma(w_i)</span> of a $w_i \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> where </span>w_i = P_i(x,y,xy,c)<span class="math"> is a linear function </span>P_i<span class="math"> in </span>x,y,c<span class="math">, and can be determined by using the previous oracle queries. </span>\\mathcal{A}^{\\sigma}$ has the following possibilities to obtain information on the encoded values:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) <span class="math">\\mathcal{A}^{\\sigma}</span> learns distinct (random) encoding of distinct values. More precisely, for all <span class="math">(i,j)</span> with <span class="math">P_{i} \\neq P_{j}</span> we have <span class="math">\\sigma(w_{i}) \\neq \\sigma(w_{j})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) <span class="math">\\mathcal{A}^{\\sigma}</span> learns a linear relation on the values <span class="math">x, y, xy</span> and <span class="math">c</span>. More precisely, there exists <span class="math">(i,j)</span> such that <span class="math">P_{i} \\neq P_{j}</span> and <span class="math">\\sigma(w_{i}) = \\sigma(w_{j})</span>, meaning that either $P_{i}(x,y,xy,c) \\equiv P_{j}(x,y,xy,c) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> holds or </span>P_{i}(x,y,c,xy) \\equiv P_{j}(x,y,c,xy) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the case (a) the obtained values are independent random values and do not leak any information to <span class="math">\\mathcal{A}^{\\sigma}</span> at all. In contrast, case (b) represents the only way <span class="math">\\mathcal{A}^{\\sigma}</span> may obtain information on the values <span class="math">x, y, xy</span> and <span class="math">c</span>. If <span class="math">\\mathcal{A}^{\\sigma}</span> can find such a relation we consider it as successful in finding the correct order of the elements. Hence, we are interested in bounding the probability of <span class="math">\\mathcal{A}^{\\sigma}</span>'s success. For this purpose, it suffices to bound the probability that a pair <span class="math">(i,j)</span> with <span class="math">i \\neq j</span> exists such that $P_{i}(x,y,xy,c) \\equiv P_{j}(x,y,xy,c) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> or </span>P_{i}(x,y,c,xy) \\equiv P_{j}(x,y,c,xy) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> when given any </span>T<span class="math"> distinct linear polynomials and the random values </span>x,y,xy,c \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. As we will see later this bound is determined by exploiting the result of Theorem 7.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following Theorem we show that also DIE cannot be solved by generic algorithms if the order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the multiplicative group </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}$ is not divisible by small primes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Theorem 7.2</strong></p>

    <p class="text-gray-300">true <span class="math">\\Rightarrow <em></span>-DIE<span class="math">^{\\sigma}</span>(c:</em>; g:h; f:nsprim)</p>

    <p class="text-gray-300"><strong>Proof.</strong> The following lemma associates the minimal generic complexity of solving DIE directly to the smallest prime factor of the order of the underlying group <span class="math">G</span>. Theorem 7.2 immediately follows from this lemma and Remarks 7.6 and 7.5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 7.2</strong> Let <span class="math">G</span> be a cyclic group and <span class="math">g</span> a corresponding generator, let <span class="math">p&#x27;</span> be the smallest prime factor of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\mathcal{A}^{\\sigma}<span class="math"> be any generic algorithm for groups </span>G<span class="math"> with maximum run time </span>T$. Then the following always holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.1 Difficulty in the Generic Model</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Prob}[\\mathcal{A}^{\\sigma}(\\mathcal{C},(G,g),w_b,w_{\\bar{b}}) = b::$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} b \\stackrel {\\approx} {\\leftarrow} \\{0, 1 \\}; \\mathcal {C} \\stackrel {\\approx} {\\leftarrow} \\mathcal {U}; \\\\ P I \\leftarrow S P I _ {I E} ((G, g)); P I _ {\\mathcal {R}} \\leftarrow S P I _ {P I ^ {\\mathcal {P}}} (P I ^ {S I}); \\\\ w _ {b} \\leftarrow \\left(P I ^ {\\text {p u b l}}, P I ^ {\\text {s o l}}\\right); \\\\ w _ {\\bar {b}} \\leftarrow \\left(P I ^ {p u b l}, P I _ {\\mathcal {R}} ^ {s o l}\\right) \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\square \\left] - 1 / 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2) \\leq \\frac {2 (T + 4) (T + 3)}{p ^ {r} - 2} \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Assume, we are given the encodings  <span class="math">\\sigma(1)</span> ,  <span class="math">\\sigma(x)</span>  and  <span class="math">\\{\\sigma(x^{-1}), \\sigma(c)\\}</span>  where  <span class="math">x \\in \\mathbb{Z}_{[G]}^*</span> . After  <span class="math">T</span>  computation steps the algorithm  <span class="math">\\mathcal{A}^\\sigma</span>  can compute at most  <span class="math">T + 4</span>  distinct linear combinations  <span class="math">P_i</span>  of the elements  <span class="math">1, x, x^{-1}</span>  and  <span class="math">c</span> , i.e., it obtains</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma \\left(P _ {i} \\left(1, x, x ^ {- 1}, c\\right)\\right) = \\sigma \\left(a _ {i 1} + a _ {i 2} x + a _ {i 3} x ^ {- 1} + a _ {i 4} c\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">a_{ij}</span>  are constant coefficients. Furthermore, it is not a-priori known to  <span class="math">\\mathcal{A}^{\\sigma}</span>  which one of the values in  <span class="math">\\{a_{i3}, a_{i4}\\}</span>  is the coefficient for  <span class="math">x^{-1}</span>  and which one corresponds to  <span class="math">c</span> .  <span class="math">\\mathcal{A}^{\\sigma}</span>  may be able to distinguish  <span class="math">\\sigma(x^{-1})</span>  and  <span class="math">\\sigma(c)</span>  by finding relations (collisions) between distinct linear combinations  <span class="math">(P_i, P_j)</span>  with  <span class="math">i \\neq j</span> . This means it obtains  <span class="math">\\sigma(P_i(1, x, x^{-1}, c)) = \\sigma(P_j(1, x, x^{-1}, c))</span>  or  <span class="math">\\sigma(P_i(1, x, c, x^{-1})) = \\sigma(P_j(1, x, c, x^{-1}))</span> , implying either  $P_i(1, x, x^{-1}, c) \\equiv P_j(1, x, x^{-1}, c) \\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  or  </span>P_i(1, x, c, x^{-1}) \\equiv P_j(1, x, c, x^{-1}) \\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Let  </span>E<span class="math">  denote this event. We compute an upper bound for the probability that  </span>E<span class="math">  occurs: There are  </span>\\binom{T+4}{2} = \\frac{(T+4)(T+3)}{2}<span class="math">  possible distinct pairs of polynomials  </span>(P_i, P_j)<span class="math"> . For each such a pair  </span>(i, j)<span class="math">  we can bound the number of solutions to  </span>P_i \\equiv P_j \\mod p^e<span class="math">  for any prime power  </span>p^e<span class="math">  that exactly divides  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , i.e.,  </span>p^{e+1} \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (Note that uniformly distributed random values  </span>\\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  are also randomly and uniformly distributed  </span>\\mod p^e$ .) More precisely, we consider the solutions to the following polynomials</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">F _ {i, j} (x, c) := x \\left[ P _ {i} \\left(1, x, x ^ {- 1}, c\\right) - P _ {j} \\left(1, x, x ^ {- 1}, c\\right) \\right] \\equiv 0 \\bmod p ^ {e}</span></div>

    <p class="text-gray-300">or</p>

    <div class="my-4 text-center"><span class="math-block">G _ {i, j} (x, c) := x \\left[ P _ {i} \\left(1, x, c, x ^ {- 1}\\right) - P _ {j} \\left(1, x, c, x ^ {- 1}\\right) \\right] \\equiv 0 \\bmod p ^ {e}.</span></div>

    <p class="text-gray-300">Here the polynomials  <span class="math">F</span>  or  <span class="math">G</span>  are obtained by multiplying both sides of the congruence  <span class="math">P_{i} \\equiv P_{j} \\mod p^{e}</span>  with  <span class="math">x</span>  and then reordering the resulting congruence.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence, we bound the probability that a random tuple  <span class="math">(x,c)\\in_{\\mathcal{R}}\\mathbb{Z}_{p^e}^<em>\\times \\mathbb{Z}_{p^e}^</em></span>  is a zero of the polynomials  <span class="math">F</span>  or  <span class="math">G\\bmod p^{e}</span>  (Note that  $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}$  is the domain of the secret exponents of DIE input tuples.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To do this, we first bound the number of solutions  <span class="math">(x,c)</span>  to  <span class="math">F</span>  or  <span class="math">G\\bmod p^{e}</span>  where  <span class="math">(x,c)</span>  are randomly selected from  <span class="math">\\mathbb{Z}_{p^e}^2</span> . The total degree of each of the polynomials  <span class="math">F</span>  and  <span class="math">G</span>  is two. It follows from Lemma 7.1 that the probability of a random tuple  <span class="math">(x,c)\\in \\mathbb{Z}_{p^e}^2</span>  to be a zero of  <span class="math">F</span>  or  <span class="math">G\\bmod p^{e}</span>  is at most  <span class="math">2(2 / p) = 4 / p</span> . There are  <span class="math">p^{2e}</span>  tuples  <span class="math">(x,c)</span>  in  <span class="math">\\mathbb{Z}_{p^e}^2</span> . Thus, there are at most  <span class="math">p^{2e}4 / p = 4p^{2e - 1}</span>  zeros for  <span class="math">F</span>  or  <span class="math">G\\bmod p^{e}</span> .</p>

    <p class="text-gray-300">Further, there are  <span class="math">(\\varphi(p^e))^2 = (p^e - p^{e-1})^2</span>  tuples in  <span class="math">\\mathbb{Z}_{p^e}^<em> \\times \\mathbb{Z}_{p^e}^</em></span> . Hence, the probability that such a tuple is a zero of  <span class="math">F</span>  or  <span class="math">G \\bmod p^e</span>  is upper bounded by</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <p class="text-gray-300"><span class="math">4p^{2e - 1} / (p^e - p^{e - 1})^2</span>. It follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Prob}[E] \\leq \\frac{(T + 4)(T + 3)}{2} \\frac{4p^{2e - 1}}{(p^e - p^{e - 1})^2} \\\\ = \\frac{(T + 4)(T + 3)}{2} \\frac{4p^{2e - 1}}{p^{2e} + p^{2e - 2} - 2p^{2e - 1}} \\\\ = (T + 4)(T + 3) \\frac{2p}{p^2 - 2p + 1} \\\\ \\leq (T + 4)(T + 3) \\frac{2p}{p^2 - 2p} = (T + 4)(T + 3) \\frac{2}{p - 2} \\\\ \\leq (T + 4)(T + 3) \\frac{2}{p&#x27; - 2}. \\end{array}</span></div>

    <p class="text-gray-300">If the complementary event <span class="math">\\bar{E}</span> occurs, then <span class="math">\\mathcal{A}^{\\sigma}</span> cannot obtain any information about the bit <span class="math">b</span> except pure guessing. Thus, the success probability of <span class="math">\\mathcal{A}^{\\sigma}</span> for correctly outputting <span class="math">b</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Prob}[\\mathcal{A}^{\\sigma}(..) = b] = \\operatorname{Prob}[E] + \\frac{1}{2} \\operatorname{Prob}[\\bar{E}] \\\\ = \\operatorname{Prob}[E] + \\frac{1 - \\operatorname{Prob}[E]}{2} \\\\ = \\frac{1}{2} + \\frac{\\operatorname{Prob}[E]}{2} \\\\ \\leq \\frac{1}{2} + \\frac{(T + 4)(T + 3)}{p&#x27; - 2}. \\end{array}</span></div>

    <p class="text-gray-300">Remark 7.6. In the classical formulation of decision problems the adversary gets, depending on the challenge <span class="math">b</span>, either the correct element or a random element as input, i.e., in the case of DIE the adversary gets <span class="math">g^x</span> together with <span class="math">g^{x^{-1}}</span> if <span class="math">b = 0</span> and <span class="math">g^c</span> (with <span class="math">c \\in_{\\mathcal{R}} \\mathbb{Z}_{[G]}^*</span>) if <span class="math">b = 1</span>. The formulation used in Lemma 7.2 considers a slightly different variant of the decisional problem type: We consider here an adversary which receives, in random order, both the correct and a random element and the adversary has to decide on the order of the elements, i.e., the adversary gets <span class="math">g^x</span> and <span class="math">(g^{x^{-1}}, g^c)</span> for <span class="math">b = 0</span> and <span class="math">(g^c, g^{x^{-1}})</span> for <span class="math">b = 1</span>.</p>

    <p class="text-gray-300">This formulation makes the proofs easier to understand. However, note that both variants are equivalent.</p>

    <h2 id="sec-42" class="text-2xl font-bold">7.2 DSE versus DDH</h2>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">7.2.1 High Granular</h3>

    <p class="text-gray-300">Wolf (1999) shows the following two results on the relation between DSE and DDH: DSE can easily be reduced to DDH, however, as Theorem 7.4 shows, the converse doesn't hold.</p>

    <p class="text-gray-300">7.2 DSE versus DDH</p>

    <p class="text-gray-300">Theorem 7.3 (Wolf 1999)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon \\text{-DSE}(\\mathrm{c}:\\ast;\\mathrm{g}:\\mathrm{h};\\mathrm{f}:\\mathrm{o}) \\xrightarrow{\\alpha' = \\alpha; t' = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} \\epsilon \\text{-DDH}(\\mathrm{c}:\\ast;\\mathrm{g}:\\mathrm{h};\\mathrm{f}:\\mathrm{o}) \\quad \\square</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Given a DDH oracle <span class="math">\\mathcal{O}_{DDH}</span> which breaks <span class="math">\\epsilon</span>-DDH(c:\\<em>;g:h;f:\\</em>), one can construct an algorithm <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span> for breaking <span class="math">\\epsilon</span>-DSE(c:\\*;g:h;f:o) as follows: <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span> randomizes its input tuple <span class="math">((G,g),(g^{x}),(g^{z}))</span> by choosing $r\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ and constructing the tuple</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">I = ((G, g), (g^{X}, g^{Y}), (g^{Z}))</span></div>

    <p class="text-gray-300">where <span class="math">g^{X} \\coloneqq g^{x}</span>, <span class="math">g^{Y} \\coloneqq g^{x + r}</span> and <span class="math">g^{Z} \\coloneqq g^{z}(g^{x})^{r}</span>. The tuple <span class="math">I</span> has the correct input distribution for <span class="math">\\mathcal{O}_{DDH}</span> because (i) <span class="math">g^{Y} \\coloneqq g^{x + r}</span> is a random group element independent of <span class="math">g^{X}</span>, and (ii) the last element <span class="math">g^{Z}</span> is <span class="math">g^{XY}</span> if and only if <span class="math">g^{z} = g^{x^{2}}</span>, and it is a random group element otherwise.</p>

    <p class="text-gray-300">Success probability: There is a single call to the DDH oracle with correctly distributed inputs. Thus, the resulting success probability is <span class="math">\\alpha_{DSE} = \\alpha_{DDH}</span>, and since <span class="math">\\alpha_{DSE}</span> is invariant, it follows that <span class="math">\\alpha_{DDH}</span> is also invariant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency: There is a single oracle call, and by applying the square and multiply method one requires $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations for performing the exponentiations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 7.7. The reduction in Theorem 7.3 also holds for other variants of the assumption with respect to the success probabilities perfect, weak and strong.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 7.8. In the proof of Theorem 7.3 we selected random elements from $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> exploiting that the group order is known. While the group order might not always be publicly known, there is always a publicly known upper bound </span>B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ on the group order as mentioned in Section 3 where Parameter 3 is discussed. If we now consider the two probability ensembles</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{k}^{<em>} := \\left\\{g^{x^{</em>}} :: G \\leftarrow SG(1^{k}) \\wedge g \\leftarrow Sg(G) \\wedge x^{*} \\xleftarrow{\\pi} \\mathbb{Z}_{2^{k}B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{k} := \\left\\{g^{x} :: G \\leftarrow SG(1^{k}) \\wedge g \\leftarrow Sg(G) \\wedge x \\xleftarrow{\\pi} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">we prove that they are statistically indistinguishable. First, observe that we compute in the exponents implicitly modulo $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Therefore, it is sufficient to consider the ensembles</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{k}^{<em>} := \\left\\{x^{</em>} \\quad (\\mathrm{mod} \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) :: G \\leftarrow SG(1^{k}) \\wedge x^{*} \\xleftarrow{\\pi} \\mathbb{Z}_{2^{k}B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{k} := \\left\\{x :: G \\leftarrow SG(1^{k}) \\wedge x \\xleftarrow{\\pi} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <p class="text-gray-300">Investigating their statistical difference, we can derive following inequalities:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{(Y^{*}, Y)}(k) := \\sum_{y \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Prob}[Y_{k}^{*} = y] - \\mathbf{Prob}[Y_{k} = y]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sum_{y \\in \\mathbb{Z}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}} \\left(\\max_{y \\in \\mathbb{Z}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}} (\\mathbf{Prob}[Y_{k}^{*} = y]) - \\min_{y \\in \\mathbb{Z}_{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}} (\\mathbf{Prob}[Y_{k}^{*} = y])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\max_{y \\in \\mathbb{Z}_{G}} (\\mathbf{Prob}[Y_{k}^{<em>} = y]) - \\min_{y \\in \\mathbb{Z}_{G}} (\\mathbf{Prob}[Y_{k}^{</em>} = y])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\frac{\\lceil 2^{k} B(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">\\rceil}{2^{k} B(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)} - \\frac{\\lfloor 2^{k} B(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">\\rfloor}{2^{k} B(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)}\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}{2^{k} B(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)} \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq \\frac{1}{2^{k}} \\\\ \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, from this it follows that <span class="math">Y</span> and <span class="math">Y^{<em>}</span> (and indirectly <span class="math">X</span> and <span class="math">X^{</em>}</span>) are statistically indistinguishable. Given that the behavior of the oracle machine cannot significantly differ on input distributions which are statistically indistinguishable from the correct ones — otherwise we would have a computational and therefore also statistical distinguisher — it is sufficient to sample random exponents from $\\mathbb{Z}_{2^k B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$ to make the reduction work also for arbitrary group families.³⁸</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 7.9. Following Remark 6.2, the result of Theorem 7.3 easily extends to the medium-granular variant.</p>

    <p class="text-gray-300">Next theorem states that a DSE oracle, even when perfect, is of no help in breaking DDH assumptions.</p>

    <p class="text-gray-300">Theorem 7.4 (Wolf 1999)</p>

    <p class="text-gray-300">true <span class="math">\\Longrightarrow</span> 1-DDH⁰ (c:\\*; g:h; f:nsprim; <span class="math">\\mathcal{O}_{1\\text{-DSE}(\\mathrm{c}:\\ast;\\mathrm{g}:\\mathrm{h};\\mathrm{f}:\\mathrm{nsprim})}</span>)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 7.10. More precisely, Wolf shows, the probability that any <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> can correctly distinguish correct DDH inputs from incorrect ones is at most <span class="math">\\frac{(T+5)(T+4)}{2p^t}</span> where <span class="math">p^t</span> is the smallest prime factor of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>T$ is an upper bound on the algorithm's runtime.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">³⁸ A similar argument (but without proof) is given by Boneh (1998) for random self-reducing of DDH with unknown order. He proposes to sample from $\\mathbb{Z}_{B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2}<span class="math">. However, as in virtually all practical cases </span>B(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> is considerably larger than </span>2^k<span class="math"> this results in a much more expensive reduction. Let us consider following (common) example: The computation is done in subgroups of </span>\\mathbb{Z}_G^*<span class="math"> with prime order </span>q<span class="math"> and an obvious upper bound on the group order is </span>p<span class="math">. For concreteness, let us use the group parameters suggested by Leustra and Verheul (2001) for security parameter </span>k = 80<span class="math">, i.e., </span>p<span class="math"> and </span>q$ having approximately 1460 and 142 bits, respectively. While our method requires exponentiation with exponents of 1540 bits, Boneh’s method would require exponentiation with exponents of 2920 bits, i.e., a huge difference!</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.3 DIE versus DDH</p>

    <p class="text-gray-300">Remark 7.11. Theorem 7.4 holds also for other variants of the DDH assumption with respect to success probabilities weak, invariant and strong.</p>

    <h2 id="sec-44" class="text-2xl font-bold">7.3 DIE versus DDH</h2>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">7.3.1 High Granular</h3>

    <p class="text-gray-300">In the following we prove that similar relations also hold between DDH and DIE. We first prove a reduction from DIE to DDH, and then show in Theorem 7.7 that the converse does not hold in generic model. This means a DIE oracle, even when perfect, is of no help in breaking DDH assumption.</p>

    <p class="text-gray-300"><strong>Theorem 7.5</strong></p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\{(1 - 1 / \\mathsf{poly}(k)), \\epsilon , 1 / \\mathsf{poly}(k) \\} \\text{-DIE} (\\mathrm{c}: *; \\mathrm{g}: \\mathrm{h}; \\mathrm{f}: \\mathrm{nspim}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\underbrace{\\alpha' \\geq \\frac{2 \\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha; t' = t + O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}_{\\text{空}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\underbrace{\\{(1 - 1 / \\mathsf{poly}(k)) , \\epsilon , 1 / \\mathsf{poly}(k) \\} \\text{-DDH} (\\mathrm{c}: *; \\mathrm{g}: \\mathrm{h}; \\mathrm{f}: \\mathrm{nspim})}_{\\square} \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We prove the following statement: Given a DDH oracle <span class="math">\\mathcal{O}_{DDH}</span> which breaks <span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span> -DDH(c: <span class="math"><em></span> ; g:h; f:nspim) with success probability <span class="math">\\alpha_{DDH}(k)</span>, there exists an algorithm <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span> which breaks the assumption <span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span> -DIE(c: <span class="math"></em></span> ; g:h; f:nspim) with success probability $\\alpha_{DIE}(k) \\geq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{DDH}(k)<span class="math">, using a single call to </span>\\mathcal{O}_{CDH}<span class="math"> and </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose, we are given a DIE input tuple <span class="math">((G,g),(g^{x}),(g^{z}))</span> with <span class="math">z = x^{-1}</span> or <span class="math">z = c</span> where $c\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">. We transform the DIE input tuple to a DDH input tuple </span>((G,g),(g^{X},g^{Y}),(g^{Z}))$ as follows: Set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">g ^ {X} := g ^ {x + a _ {1}}, \\quad g ^ {Y} := g ^ {a _ {2} z + a _ {3}}, \\quad g ^ {Z} := g ^ {a _ {4} ^ {*} x + a _ {5} ^ {*} z + a _ {6} ^ {*}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $a_1, a_2, a_3 \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, </span>a_4^<em> = a_3<span class="math">, </span>a_5^</em> = a_2a_1<span class="math"> and </span>a_6^<em> = a_2 + a_1a_3$. Here the superscript "</em>" indicates that the corresponding values are constructed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">z = x^{-1}</span>, we get a correct DDH input tuple <span class="math">((G,g),(g^{X},g^{Y}),(g^{Z}))</span> because (i) <span class="math">X,Y</span> are randomly and uniformly distributed over $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> due to the randomization with </span>a_1,a_2,a_3\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, and (ii) the following holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} XY = a _ {2} x z + a _ {3} x + a _ {2} a _ {1} z + a _ {1} a _ {3} \\\\ = a _ {2} x x ^ {- 1} + a _ {3} x + a _ {2} a _ {1} z + a _ {1} a _ {3} \\\\ = a _ {3} x + a _ {2} a _ {1} x ^ {- 1} + a _ {2} + a _ {1} a _ {3} \\\\ = a _ {4} ^ {*} + a _ {5} ^ {*} x ^ {- 1} + a _ {6} ^ {*} \\\\ = Z. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The case <span class="math">z = c</span> is more involved. Here we apply the result of Lemma 7.3: For group orders with no small prime factors, the (constructed) tuples <span class="math">(X,Y,Z)</span> are statistically indistinguishable from tuples <span class="math">(X&#x27;,Y&#x27;,Z&#x27;)</span> chosen randomly from</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{3}$, and therefore, also indistinguishable for the DDH oracle. Thus, also in this case we get a correct DDH input tuple.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Success probability:</h5>

    <p class="text-gray-300">There is single call to <span class="math">\\mathcal{O}_{DDH}</span> and, therefore, the resulting success probability is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\alpha_{DIE}(k)=\\mathbf{Prob}[E_{k}]\\alpha_{DDH}(k)\\geq(\\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1)\\alpha_{DDH}(k).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The reason for the factor <span class="math">\\mathbf{Prob}[E_{k}]</span> is that the input tuples to <span class="math">\\mathcal{O}_{DDH}</span> are legal only if the tuples <span class="math">(X,Y,Z)</span> are randomly and uniformly distributed over $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and this is the case if the event </span>E_{k}$ occurs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following, we set $\\gamma(k):=\\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1<span class="math"> (Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a function of the security parameter </span>k<span class="math">, see also Lemma 6.5) The type of resulting success probability </span>\\alpha_{DIE}(k)<span class="math"> depends on the type of </span>\\alpha_{DDH}(k)$. The proofs are similar to those of Lemma 6.6. Nevertheless, for completeness, they are given below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle (<span class="math">\\alpha_{DDH}(k)\\not&lt;\\infty</span> 1): The resulting success probability cannot be perfect because there is a non-zero error probability when querying the DDH oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak oracle (<span class="math">\\alpha_{DDH}(k)\\not&lt;\\infty</span> 1/poly(k)): The resulting success probability is (asymptotically) weak: Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> contains no small prime factors, it follows from Lemma 6.5 that </span>1-\\gamma(k)=2(1-\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<\\infty<span class="math"> 1/poly(k). Thus, we can write </span>\\gamma(k)>1-1/\\mathsf{poly}(k)<span class="math">, meaning that </span>\\gamma(k)<span class="math"> is non-negligible. Further, we have </span>\\alpha_{DDH}(k)\\not<\\infty<span class="math"> 1/poly(k). It follows </span>\\gamma(k)\\alpha_{DDH}(k)\\not<\\infty<span class="math"> 1/poly(k) (see also Section 2.2) Finally, since </span>\\alpha_{DIE}(k)\\geq\\gamma(k)\\alpha_{DDH}(k)<span class="math">, it follows </span>\\alpha_{DIE}(k)\\not<\\infty$ 1/poly(k).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Invariant oracle (<span class="math">\\alpha_{DDH}\\not&lt;\\infty</span> <span class="math">\\epsilon_{1}</span>): The resulting success probability is (asymptotically) invariant: As shown in the weak case, we can write <span class="math">\\gamma(k)&gt;\\infty</span> 1<span class="math">-</span>1/poly(k). More precisely, for any <span class="math">\\epsilon^{\\prime}&gt;0</span> there exists a <span class="math">k_{0}</span> such that for all <span class="math">k&gt;k_{0}</span> we have <span class="math">\\gamma(k)&gt;\\infty</span> 1<span class="math">-\\epsilon^{\\prime}</span>. From <span class="math">\\alpha_{DDH}(k)\\not&lt;\\infty</span> <span class="math">\\epsilon_{1}</span>, it follows that for any <span class="math">k_{0}^{\\prime}</span> there exists a <span class="math">k_{1}&gt;k_{0}^{\\prime}</span> such that <span class="math">\\alpha_{DDH}(k_{1})\\geq\\epsilon_{1}</span>. Thus, for any <span class="math">k_{0}^{\\prime}&gt;k_{0}</span> there exists a <span class="math">k_{1}&gt;k_{0}^{\\prime}</span> such that <span class="math">\\alpha_{DIE}(k_{1})\\geq\\epsilon_{2}</span> where <span class="math">\\epsilon_{2}:=(1-\\epsilon^{\\prime})\\epsilon_{1}</span>. It follows <span class="math">\\alpha_{DIE}(k)\\not&lt;\\infty</span> <span class="math">\\epsilon_{2}</span>.</p>

    <p class="text-gray-300">Strong oracle (<span class="math">1-\\alpha_{DDH}(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span>): The resulting success probability is (asymptotically) strong: As shown in the weak case, we can write <span class="math">\\gamma(k)&gt;\\infty</span> 1<span class="math">-</span>1/poly(k). Further, we have <span class="math">1-\\alpha_{DDH}(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span>. It follows from Lemma 6.7 that <span class="math">1-\\gamma(k)\\alpha_{DDH}(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span>. Finally, since <span class="math">\\alpha_{DIE}(k)\\geq\\gamma(k)\\alpha_{DDH}(k)</span>, it follows <span class="math">1-\\alpha_{DIE}(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7.3 DIE versus DDH</p>

    <p class="text-gray-300">Lemma 7.3 Let <span class="math">SG</span> be a group sampler of groups whose orders contain no small prime factors. Further, let <span class="math">V_{k}</span> and <span class="math">V_{k}^{\\prime}</span> be probability ensembles defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} V _ {k} := \\{(X, Y, Z):: G \\leftarrow S G (1 ^ {k}) \\wedge \\\\ (x, z) \\in_ {\\mathcal {R}} \\left(\\mathbb {Z} _ {[ G ]} ^ {*}\\right) ^ {2} \\wedge (a _ {1}, a _ {2}, a _ {3}) \\in_ {\\mathcal {R}} \\mathbb {Z} _ {[ G ]} ^ {3} \\wedge \\\\ a _ {4} ^ {*} = a _ {3} \\wedge a _ {5} ^ {*} = a _ {2} a _ {1} \\wedge a _ {6} ^ {*} = a _ {2} + a _ {1} a _ {3} \\wedge \\\\ X := x + a _ {1} \\wedge Y := a _ {2} z + a _ {3}; \\wedge Z := a _ {4} ^ {*} x + a _ {5} ^ {*} z + a _ {6} ^ {*} \\}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">V _ {k} ^ {\\prime} := \\{(X ^ {\\prime}, Y ^ {\\prime}, Z ^ {\\prime}):: G \\leftarrow S G (1 ^ {k}) \\wedge (X ^ {\\prime}, Y ^ {\\prime}, Z ^ {\\prime}) \\in_ {\\mathcal {R}} \\mathbb {Z} _ {[ G ]} ^ {3} \\}.</span></div>

    <p class="text-gray-300">Then <span class="math">V_{k}</span> and <span class="math">V_{k}^{\\prime}</span> are statistically indistinguishable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. According to the definition of statistical indistinguishability (see Section 2.4) we have to prove that the statistical difference <span class="math">\\Delta_{(V,V^{\\prime})}(k)</span> is negligible in security parameter <span class="math">k</span> (here, for group orders $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ with no small prime factors)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, $\\mathbf{Prob}[V_k' = v] = 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math"> holds for all </span>v \\in \\mathbb{Z}_{[G]}^3<span class="math"> by definition. Next, we partition </span>\\mathbb{Z}_{[G]}^3<span class="math"> in two disjoint sets </span>D<span class="math"> and its complement </span>\\bar{D} = \\mathbb{Z}_{[G]}^3 \\setminus D<span class="math"> such that </span>\\mathbf{Prob}[V_k = v] \\geq 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math"> for all </span>v \\in D<span class="math"> and </span>\\mathbf{Prob}[V_k = v] &lt; 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math"> for all </span>v \\in \\bar{D}$. Then we can write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {(V, V ^ {\\prime})} (k) := \\sum_ {v \\in \\mathbb {Z} _ {[ G ]} ^ {3}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {P r o b} [ V _ {k} = v ] - \\mathbf {P r o b} [ V _ {k} ^ {\\prime} = v ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\sum_ {v \\in \\bar {D}} \\left(\\mathbf {P r o b} \\left[ V _ {k} = v \\right] - 1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3}\\right) + \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\sum_ {v \\in \\bar {D}} (1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\mathbf {P r o b} [ V _ {k} = v ]).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">It follows</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {(V, V ^ {\\prime})} (k) \\leq \\sum_ {v \\in D} \\left(\\mathbf {P r o b} [ V _ {k} = v ] - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3}\\right) + \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\sum_ {v \\in D} \\mathbf {P r o b} [ V _ {k} = v ] -</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} + \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\min  _ {v \\in \\mathbb {Z} _ {[ G ]} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We exploit the relations <span class="math">\\sum_{v\\in D}\\mathbf{Prob}[V_k = v] = 1 - \\sum_{v\\in \\bar{D}}\\mathbf{Prob}[V_k = v]</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, and substitute them in the above inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{(V, V')} (k) \\leq 1 - \\sum_{v \\in \\bar{D}} \\mathbf{Prob}[V_k = v] - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3} + \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq 1 - \\sum_{v \\in \\bar{D}} \\left(\\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) - 1 +</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} + \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\quad</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= -</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) +</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} + \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\quad</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= 2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - 2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= 2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\bar {D}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\left(1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq 2</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} \\left(1 /</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3} - \\min _ {v \\in \\mathbb {Z} _ {</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where for the last step we used the fact $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math">. Next, we determine a lower bound for </span>\\min_{v \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^3} (\\mathbf{Prob}[V_k = v])<span class="math">. For this, we first consider the probability </span>\\mathbf{Prob}[V_k = v]<span class="math"> together with the event </span>E_k := E(V_k) : (1 - xz) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*$. It follows</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P r o b} [ V _ {k} = v ] = \\mathbf {P r o b} [ V _ {k} = v \\wedge E _ {k} ] + \\mathbf {P r o b} [ V _ {k} = v \\wedge \\bar {E} _ {k} ]</span></div>

    <p class="text-gray-300">where <span class="math">\\bar{E}_k</span> is the complement of <span class="math">E_k</span>. Thus, we can write</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\min _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ]) \\geq \\min _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v \\wedge E _ {k} ]) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since $\\min_{v\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^3}(\\mathbf{Prob}[V_k = v\\wedge \\bar{E}_k])\\geq 0$, it follows</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\min _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ]) \\geq \\min _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v \\wedge E _ {k} ]).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Further, we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {P r o b} [ V _ {k} = v \\wedge E _ {k} ] = \\mathbf {P r o b} [ V _ {k} = v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E _ {k} ] \\mathbf {P r o b} [ E _ {k} ] \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\geq \\frac {1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">^ {3}} \\left(\\frac {2 \\varphi (</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">} - 1\\right). \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">To see this, we consider the probability terms separately:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i) For all <span class="math">v</span> it holds $\\mathbf{Prob}[V_k = v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_k] = 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3<span class="math">. This is because, if </span>E(V_k)<span class="math"> (i.e., </span>1 - xz \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">) holds then the tuples </span>(X,Y,Z)<span class="math"> are uniformly distributed over </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^3<span class="math">. One can see this as follows: For any </span>(x,z) \\in_{\\mathcal{R}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.3 DIE versus DDH</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^* \\times \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">  with  </span>z \\neq x^{-1}<span class="math">  and for any  </span>(X,Y,Z) \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^3<span class="math"> , there exist exactly one tuple  </span>(a_1,a_2,a_3) \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^3$  such that following equations hold</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">X := x + a _ {1}, \\quad Y := a _ {2} z + a _ {3}, \\quad Z := a _ {4} ^ {*} x + a _ {5} ^ {*} z + a _ {6} ^ {*}</span></div>

    <p class="text-gray-300">where  <span class="math">a_4^<em> = a_3</span> ,  <span class="math">a_5^</em> = a_2a_1</span> ,  <span class="math">a_6^* = a_2 + a_1a_3</span> . We compute  <span class="math">a_1, a_3</span>  from the first equations and set them in the third and obtain:</p>

    <div class="my-4 text-center"><span class="math-block">Z = X Y + a _ {2} - a _ {2} x z, a _ {2} (1 - x z) = Z - X Y.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The last equation has a solution for  <span class="math">a_2 = (Z - XY)(1 - xz)^{-1}</span>  if  $\\gcd(1 - xz,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 1<span class="math"> , i.e.,  </span>1 - xz \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> . Having  </span>a_2<span class="math">  computed, we can obtain the other values by computing  </span>a_1 = X - x<span class="math">  and  </span>a_3 = Y - a_2z$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ii)  $\\mathbf{Prob}[E_k] \\geq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1<span class="math"> : As  </span>x, z<span class="math">  are elements from  </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> , there are  </span>\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  possible values for  </span>1 - xz<span class="math">  which may or may not be relatively prime to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In the worst case, at most  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  of them are not relatively prime to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Thus, in the worst case, the number of possible values for  </span>1 - xz<span class="math">  relatively prime to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is still  </span>\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)) = 2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Therefore, we can write  </span>\\mathbf{Prob}[E_k] \\geq \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{2\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\min  _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v \\wedge E _ {k} ]) = \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3}} \\big (\\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1 \\big).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Now, we return to the statistical difference of the distributions. Substituting the above results, we obtain</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Delta_ {(V, V ^ {\\prime})} (k) \\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3} \\left(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3} - \\min  _ {v \\in \\mathbb {Z} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} ^ {3}} (\\mathbf {P r o b} [ V _ {k} = v ])\\right) \\\\ \\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3} \\left(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3} - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3}} \\left(\\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - 1\\right)\\right) \\\\ \\leq \\frac {4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {3}} \\left(1 - \\frac {2 \\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\ \\leq 4 \\left(1 - \\frac {\\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with no small prime factors, it follows from Lemma 6.5 that  </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; \\infty 1 / \\mathsf{poly}(k)<span class="math">  and consequently  </span>\\Delta_{(V,V')}(k) &lt; \\infty 1 / \\mathsf{poly}(k)$ . This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <p class="text-gray-300">Remark 7.12. The above reduction does not hold for perfect success probability because of introduced non-zero error probability. However, for groups of prime order the reduction also holds for perfect success probability as the only special case <span class="math">x = 0</span> can be explicitly handled, i.e., one can easily test whether <span class="math">g^0 = 1</span> is the input.</p>

    <p class="text-gray-300">Remark 7.13. The reduction in Theorem 7.5 is proven for group orders with no small prime factors. However, it also holds for all other group orders, provided the group order is known. Knowing the group order, one can factor out the small prime factors by well-known factoring algorithms, and then easily solve the decisional problems DIE and DDH (see also Remark 7.2). Thus, we have the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 7.6</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\{(1 - 1 / \\operatorname {p o l y} (k)), \\epsilon , 1 / \\operatorname {p o l y} (k) \\} \\text {- D I E} (\\mathrm {c}: *; \\mathrm {g}: \\mathrm {h}; \\mathrm {f}: *, \\mathrm {o}) \\\\ \\Longrightarrow \\\\ \\{(1 - 1 / \\operatorname {p o l y} (k)), \\epsilon , 1 / \\operatorname {p o l y} (k) \\} \\text {- D D H} (\\mathrm {c}: *; \\mathrm {g}: \\mathrm {h}; \\mathrm {f}: *, \\mathrm {o}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The following theorem proves (in generic model) that a DIE oracle, even when perfect, is of no help in breaking DDH assumptions.</p>

    <p class="text-gray-300"><strong>Theorem 7.7</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\text {true} \\Longrightarrow * - D D H ^ {\\sigma} (c: *; g: h; f: n s p r i m; \\mathcal {O} _ {1 - D I E (c: *; g: h; f: n s p r i m)})</span></div>

    <p class="text-gray-300">Proof. Similar to the proof of Theorem 7.2 we define a Lemma which associates the minimal generic complexity of solving DIE with the smallest prime factor of the order of the underlying group <span class="math">G</span>. Theorem 7.7 immediately follows from Lemma 7.4 and Remark 7.6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 7.4</strong> Let <span class="math">G</span> be a cyclic group and <span class="math">g</span> a corresponding generator, let <span class="math">p&#x27;</span> be the smallest prime factor of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\mathcal{O}_{DIE}<span class="math"> be a given oracle which solves DIE tuples in </span>G<span class="math"> and let </span>\\mathcal{A}^{\\sigma, \\mathcal{O}_{DIE}}<span class="math"> be any generic algorithm for groups </span>G<span class="math"> with maximum run time </span>T<span class="math"> and oracle access to </span>\\mathcal{O}_{DIE}$. Then the following always holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {P r o b} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {A} ^ {\\sigma , \\mathcal {O} _ {D I E}} \\left(\\mathcal {C}, (G, g), w _ {b}, w _ {\\bar {b}}\\right) = b\\right. : \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b \\stackrel {{u}} {{\\leftarrow}} \\{0, 1 \\}; \\mathcal {C} \\stackrel {{u}} {{\\leftarrow}} \\mathcal {U}; \\\\ P I \\leftarrow S P I _ {D H} ((G, g)); P I _ {\\mathcal {R}} \\leftarrow S P I _ {P I ^ {\\mathcal {P}}} (P I ^ {\\mathcal {P}}); \\\\ w _ {b} \\leftarrow \\left(P I ^ {p u b l}, P I ^ {s o l}\\right); \\\\ w _ {\\bar {b}} \\leftarrow \\left(P I ^ {p u b l}, P I _ {\\mathcal {R}} ^ {s o l}\\right) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] - 1 / 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2) \\leq \\frac {2 (T + 5) (T + 4)}{p ^ {\\prime}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">7.3 DIE versus DDH</p>

    <p class="text-gray-300">Proof. Assume, we are given the encodings <span class="math">\\sigma(1)</span>, <span class="math">\\sigma(x)</span>, <span class="math">\\sigma(y)</span> and <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span>. After <span class="math">T_1</span> computation steps <span class="math">\\mathcal{A}^{\\sigma, \\mathcal{O}_{DIE}}</span> can compute at most <span class="math">T_1 + 5</span> distinct linear combinations <span class="math">P_i(x, y, xy, c)</span> of <span class="math">1, x, y, xy</span> and <span class="math">c</span>, i.e., it obtains</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma(P_i(1, x, y, xy, c)) = \\sigma(a_{i1} + a_{i2}x + a_{i3}y + a_{i4}xy + a_{i5}c)</span></div>

    <p class="text-gray-300">where <span class="math">a_{ij}</span> are constant coefficients. Furthermore, it is not known to <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span> which one of the values <span class="math">\\{a_{i4}, a_{i5}\\}</span> is the coefficient of <span class="math">xy</span> and which one corresponds to <span class="math">c</span>. Further, assume that <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span> makes <span class="math">T_2</span> calls to <span class="math">\\mathcal{O}_{DIE}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span> may be able to distinguish <span class="math">\\sigma(xy)</span> and <span class="math">\\sigma(c)</span> by obtaining information from either of the following events:</p>

    <p class="text-gray-300"><span class="math">E_a</span>: <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span> finds relations (collision) between two distinct linear combinations <span class="math">(P_i, P_j)</span> with <span class="math">i \\neq j</span>. This means, it obtains either <span class="math">\\sigma(P_i(1,x,y,xy,c)) = \\sigma(P_j(1,x,y,xy,c))</span> or <span class="math">\\sigma(P_i(1,x,y,c,xy)) = \\sigma(P_j(1,x,y,c,xy))</span>.</p>

    <p class="text-gray-300"><span class="math">E_b</span>: <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span> gets at least one positive answer from <span class="math">\\mathcal{O}_{DIE}</span>, i.e., it obtains either <span class="math">\\sigma(P_i(1,x,y,xy,c)) = \\sigma((P_j(1,x,y,xy,c))^{-1})</span> or <span class="math">\\sigma(P_i(1,x,y,c,xy)) = \\sigma((P_j(1,x,y,c,xy))^{-1})</span>.</p>

    <p class="text-gray-300">We compute an upper bound for the probability that either of the events <span class="math">E_a</span> and <span class="math">E_b</span> occurs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case <span class="math">E_a</span>: In this case we have $P_i(1, x, y, xy, c) \\equiv P_j(1, x, y, xy, c) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> or </span>P_i(1, x, y, c, xy) \\equiv P_j(1, x, y, c, xy) \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. There are </span>\\binom{T_1+5}{2} = \\frac{(T_1+5)(T_1+4)}{2}<span class="math"> distinct pairs of polynomials </span>(P_i, P_j)<span class="math">. For each such a pair </span>(i, j)<span class="math"> we bound the number of solutions to </span>P_i \\equiv P_j \\bmod p^e<span class="math"> for any prime power </span>p^e<span class="math"> that exactly divides </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e., </span>p^{e+1} \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. (Note that uniformly distributed random values </span>\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are also randomly and uniformly distributed </span>\\bmod p^e$.) More precisely, we consider the solutions to the following polynomials</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">F_{i,j}(x, y, c) := P_i(1, x, y, xy, c) - P_j(x, y, xy, c) \\equiv 0 \\bmod p^e</span></div>

    <p class="text-gray-300">or</p>

    <div class="my-4 text-center"><span class="math-block">G_{i,j}(x, y, c) := P_i(1, x, y, c, xy) - P_j(x, y, c, xy) \\equiv 0 \\bmod p^e.</span></div>

    <p class="text-gray-300">Each of the polynomials <span class="math">F</span> and <span class="math">G</span> has the total degree 2. It follows from Lemma 7.1 that the probability for a random <span class="math">(x,y,c) \\in \\mathbb{Z}_{p^e}^3</span> to be a zero of <span class="math">F \\bmod p^e</span> or <span class="math">G \\bmod p^e</span> is at most <span class="math">2(2/p) = 4/p</span>. Thus, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname{Prob}[E_a] \\leq \\frac{(T_1 + 5)(T_1 + 4)}{2} \\frac{4}{p} \\\\ \\leq \\frac{2(T_1 + 5)(T_1 + 4)}{p&#x27;}. \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case <span class="math">E_b</span>: In this case we have $P_i \\equiv P_j^{-1} \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. However, it is not possible to derive this relation between the polynomials </span>P_i<span class="math"> and </span>P_j<span class="math"> but only between their evaluations at the points </span>(x,y,c)<span class="math">, i.e., when </span>P_i(1,x,y,c,xy) \\equiv P_j(x,y,c,xy)^{-1} \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (with </span>P_j(x,y,c,xy) \\neq 0 \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to our approach in the case <span class="math">E_{a}</span>, for each such a pair <span class="math">(i,j)</span> we can bound the number of solutions to <span class="math">P_{i}(x,y,xy,c) \\equiv P_{j}(x,y,xy,c)^{-1} \\bmod p^{e}</span> or <span class="math">P_{i}(x,y,c,xy) - P_{j}(x,y,c,xy)^{-1} \\bmod p^{e}</span> for any prime power <span class="math">p^{e}</span> that exactly divides $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. More precisely, we consider the solutions to the following polynomials</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">H _ {i, j} (x, y, c) := P _ {i} (1, x, y, x y, c) P _ {j} (x, y, x y, c) - 1 \\equiv 0 \\bmod p ^ {e}</span></div>

    <p class="text-gray-300">or</p>

    <div class="my-4 text-center"><span class="math-block">I _ {i, j} (x, y, c) := P _ {i} (1, x, y, c, x y) P _ {j} (x, y, c, x y) - 1 \\equiv 0 \\bmod p ^ {e}.</span></div>

    <p class="text-gray-300">Here, the polynomial <span class="math">H(x,y,c)</span> is obtained by multiplying both sides of the equation <span class="math">P_{i}(1,x,y,xy,c) - P_{j}(1,x,y,xy,c)^{-1} \\equiv 0 \\mod p^{e}</span> with <span class="math">P_{j}(1,x,y,xy,c)</span>. Similarly, we obtain <span class="math">I(x,y,c)</span>.</p>

    <p class="text-gray-300">Hence, we bound the probability that a random triple <span class="math">(x,y,c) \\in \\mathbb{Z}_{p^e}^3</span> is a zero of the polynomials <span class="math">I</span> or <span class="math">H</span>.[40] The total degree of each of the polynomials <span class="math">H</span> and <span class="math">I</span> is at most 4. It follows from Lemma 7.1 that the probability of a randomly chosen <span class="math">(x,y,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{p^e}^3</span> to be a zero of <span class="math">H</span> or <span class="math">I</span> is at most <span class="math">2(4/p) = 8/p</span> .t follows</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P r o b} [ E _ {b} ] \\leq T _ {2} \\frac {8}{p} \\leq T _ {2} \\frac {8}{p ^ {\\prime}}.</span></div>

    <p class="text-gray-300">In total we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {P r o b} [ E ] \\leq \\mathbf {P r o b} [ E _ {a} ] + \\mathbf {P r o b} [ E _ {b} ] \\\\ \\leq \\frac {2 (T _ {1} + 5) (T _ {1} + 4)}{p ^ {\\prime}} + \\frac {8 T _ {2}}{p ^ {\\prime}} \\\\ \\leq \\frac {2 (T + 5) (T + 4)}{p ^ {\\prime}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">T_{1} + T_{2} \\leq T</span>. If the complementary event <span class="math">\\bar{E}</span> occurs, then <span class="math">\\mathcal{A}^{\\sigma, \\mathcal{O}_{DIE}}</span> cannot obtain any information about the bit <span class="math">b</span> except by pure guessing. Thus, the success probability of <span class="math">\\mathcal{A}^{\\sigma, \\mathcal{O}_{DIE}}</span> for correctly outputting <span class="math">b</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {P r o b} [ \\mathcal {A} ^ {\\sigma , \\mathcal {O} _ {D I E}} (..) = b ] = \\mathbf {P r o b} [ E ] + \\frac {1}{2} \\mathbf {P r o b} [ \\bar {E} ] \\\\ = \\mathbf {P r o b} [ E ] + \\frac {1 - \\mathbf {P r o b} [ E ]}{2} \\\\ = \\frac {1}{2} + \\frac {\\mathbf {P r o b} [ E ]}{2} \\\\ \\leq \\frac {1}{2} + \\frac {(T + 5) (T + 4)}{p ^ {\\prime}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">40Note that DIE oracle is guaranteed to answer correctly only to the legal inputs, i.e., when the secret exponents are elements from <span class="math">\\mathbb{Z}_{[G]}^{<em>}</span>. Thus, the answer of DIE oracle is correct if <span class="math">P_{i}(x,y,xy,c)</span> and <span class="math">P_{j}(x,y,xy,c)</span> are elements of <span class="math">\\mathbb{Z}_{[G]}^{</em>}</span>. As the DIE oracle can be evil on illegal inputs, the adversary can obtain fewer information, if any, than in the case where the inputs are legal. Hence, to be on the safe side, we give the generic adversary the advantage that all values <span class="math">P_{i}(x,y,xy,c)</span> and <span class="math">P_{j}(x,y,xy,c)</span> are legal inputs to the DIE oracle.</p>

    <p class="text-gray-300">7.4 DSE versus DIE</p>

    <h2 id="sec-47" class="text-2xl font-bold">7.4 DSE versus DIE</h2>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">7.4.1 High Granular</h3>

    <p class="text-gray-300">In the next theorem we prove that an oracle breaking <span class="math">1\\text{-DSE}(c:<em>; \\mathrm{g};\\mathrm{h}; \\mathrm{f};</em>)</span> is of no help in breaking <span class="math"><em>-\\mathrm{DIE}^{\\sigma}(c:</em>; \\mathrm{g};\\mathrm{h}; \\mathrm{f};*)</span>.</p>

    <p class="text-gray-300"><strong>Theorem 7.8</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\text{true} \\Longrightarrow *-\\mathrm{DIE}^{\\sigma}(c:*; \\mathrm{g};\\mathrm{h}; \\mathrm{f};\\mathrm{nspim}; \\mathcal{O}_{1-\\mathrm{DSE}(c:*; \\mathrm{g};\\mathrm{h}; \\mathrm{f};\\mathrm{nspim})}) \\quad \\square</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Similar to the proofs of Theorem 7.2 and 7.7 we define a Lemma which associates the minimal generic complexity of solving DIE directly to the smallest prime factor of the order of the underlying group <span class="math">G</span>. Theorem 7.8 immediately follows from Lemma 7.5 and Remark 7.6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 7.5</strong> Let <span class="math">G</span> be a cyclic group and <span class="math">g</span> a corresponding generator, let <span class="math">p&#x27;</span> be the smallest prime factor of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\mathcal{O}_{DSE}<span class="math"> be a given oracle solving DSE tuples in </span>G<span class="math"> and let </span>\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}<span class="math"> be any generic algorithm for groups </span>G<span class="math"> with maximum run time </span>T<span class="math"> and oracle access to </span>\\mathcal{O}_{DSE}$. Then the following always holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Prob} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}} \\left(\\mathcal{C}, (G, g), w_b, w_{\\bar{b}}\\right) = b :: \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b \\stackrel{\\pi}{\\leftarrow} \\{0, 1\\}; \\mathcal{C} \\stackrel{\\pi}{\\leftarrow} \\mathcal{U}; \\\\ PI \\leftarrow SPI_{IE}((G, g)); \\quad PI_{\\mathcal{R}} \\leftarrow SPI_{PI^{\\mathcal{P}}} (PI^{\\mathcal{P}}); \\\\ w_b \\leftarrow (PI^{publ}, PI^{sol}); \\\\ w_{\\bar{b}} \\leftarrow (PI^{publ}, PI_{\\mathcal{R}}^{sol}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left] -1/2 \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2) \\leq \\frac{2(T+4)(T+3)}{p' - 2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Proof.</strong> Assume, we are given the encodings <span class="math">\\sigma(1)</span>, <span class="math">\\sigma(x)</span> and <span class="math">\\{\\sigma(x^{-1}), \\sigma(c)\\}</span> where <span class="math">x \\in \\mathbb{Z}_{[G]}^*</span>. After <span class="math">T_1</span> computation steps the algorithm <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> can compute at most <span class="math">T_1 + 4</span> distinct linear combinations <span class="math">P_i</span> of the elements <span class="math">1, x, x^{-1}</span>, and <span class="math">c</span>, i.e., it obtains</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma(P_i(1, x, x^{-1}, c)) = \\sigma(a_{i1} + a_{i2}x + a_{i3}x^{-1} + a_{i4}c),</span></div>

    <p class="text-gray-300">where <span class="math">a_{ij}</span> are constant coefficients. Furthermore, it is not a-priori known to <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> which of the values in <span class="math">\\{a_{i3}, a_{i4}\\}</span> is the coefficient for <span class="math">x^{-1}</span> and which one corresponds to <span class="math">c</span>. Further, assume that <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> makes <span class="math">T_2</span> calls to <span class="math">\\mathcal{O}_{DSE}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> may be able to distinguish <span class="math">\\sigma(x^{-1})</span> and <span class="math">\\sigma(c)</span> by obtaining information from either of the following events:</p>

    <p class="text-gray-300"><span class="math">E_a</span>: <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> finds a relation (collision) between two distinct linear equations <span class="math">(P_i, P_j)</span> with <span class="math">i \\neq j</span>. This means it obtains <span class="math">\\sigma(P_i(1,x,x^{-1},c)) = \\sigma(P_j(1,x,x^{-1},c))</span> or <span class="math">\\sigma(P_i(1,x,c,x^{-1})) = \\sigma(P_j(1,x,c,x^{-1}))</span>.</p>

    <p class="text-gray-300"><span class="math">E_b</span>: <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span> gets at least one positive answer from <span class="math">\\mathcal{O}_{DSE}</span> with <span class="math">i \\neq j</span>, i.e., it obtains <span class="math">\\sigma(P_i(1,x,x^{-1},c)) = \\sigma((P_j(1,x,x^{-1},c))^2)</span> or <span class="math">\\sigma(P_i(1,x,c,x^{-1})) = \\sigma((P_j(1,x,c,x^{-1}))^2)</span>.</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <p class="text-gray-300">We compute an upper bound for the probability that either of these events occurs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case <span class="math">E_{a}</span>: In this case we have $P_{i}(1,x,x^{-1},c)\\equiv P_{j}(1,x,x^{-1},c)\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> or </span>P_{i}(1,x,c,x^{-1})\\equiv P_{j}(1,x,c,x^{-1})\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. There are </span>\\binom{T+4}{2}=\\frac{(T+4)(T+3)}{2}<span class="math"> distinct polynomial pairs </span>(P_{i},P_{j})<span class="math">. For each such a pair </span>(i,j)<span class="math"> we can bound the number of possible solutions to </span>P_{i}\\equiv P_{j}\\bmod p^{e}<span class="math"> for any prime power </span>p^{e}<span class="math"> that exactly divides </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e., </span>p^{e+1}\\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (Note that uniformly distributed random values </span>\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are also randomly and uniformly distributed </span>\\bmod p^{e}$.) More precisely, we consider the solutions to the following polynomials</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">F_{i,j}(x,c):=x[P_{i}(1,x,x^{-1},c)-P_{j}(1,x,x^{-1},c)]\\equiv 0\\bmod p^{e}</span></p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">G_{i,j}(x,c):=x[P_{i}(1,x,c,x^{-1})-P_{j}(1,x,c,x^{-1})]\\equiv 0\\bmod p^{e}.</span></p>

    <p class="text-gray-300">Here, <span class="math">F</span> and <span class="math">G</span> are obtained by multiplying both sides of the congruence <span class="math">P_{i}\\equiv P_{j}\\bmod p^{e}</span> with <span class="math">x</span> and then reordering the resulting congruence.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence, we bound the probability that a random tuple <span class="math">(x,c)\\in\\mathbb{Z}_{p^{e}}^{<em>}\\times\\mathbb{Z}_{p^{e}}^{</em>}</span> is a zero of the polynomials <span class="math">F</span> or <span class="math">G\\bmod p^{e}</span> (Note that $\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}$ is the domain of the secret exponents of DIE inputs.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To do this, we first bound the number of solutions to <span class="math">F</span> or <span class="math">G\\bmod p^{e}</span> where <span class="math">(x,c)</span> are randomly selected from <span class="math">\\mathbb{Z}_{p^{e}}^2</span>. The total degree of each of the polynomials <span class="math">F</span> and <span class="math">G</span> is two. It follows from Lemma 7.1 that the probability for a random tuple $(x,c)\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^2<span class="math"> to be a zero of </span>F<span class="math"> or </span>G\\bmod p^{e}<span class="math"> is at most </span>2(2/p)=4/p<span class="math">. There are </span>p^{2e}<span class="math"> tuples </span>(x,c)<span class="math"> in </span>\\mathbb{Z}_{p^{e}}^2<span class="math">. Thus, there are at most </span>p^{2e}4/p=4p^{2e-1}<span class="math"> zeros for either </span>F<span class="math"> or </span>G\\bmod p^{e}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Further, there are <span class="math">\\left(\\varphi(p^{e})\\right)^{2}=(p^{e}-p^{e-1})^{2}</span> tuples <span class="math">(x,c)</span> in <span class="math">\\mathbb{Z}_{p^{e}}^{<em>}\\times\\mathbb{Z}_{p^{e}}^{</em>}</span>. Hence, the probability that such a tuple is a zero of <span class="math">F</span> or <span class="math">G\\bmod p^{e}</span> is upper bounded by <span class="math">4p^{2e-1}/(p^{e}-p^{e-1})^{2}</span>. It follows</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Prob}[E_{a}]</span> <span class="math">\\leq</span> <span class="math">\\frac{(T+4)(T+3)}{2}\\frac{4p^{2e-1}}{(p^{e}-p^{e-1})^{2}}</span> <span class="math">=</span> <span class="math">\\frac{(T+4)(T+3)}{2}\\frac{4p^{2e-1}}{p^{2e}+p^{2e-2}-2p^{2e-1}}</span> <span class="math">=</span> <span class="math">(T+4)(T+3)\\frac{2p}{p^{2}-2p+1}</span> <span class="math">\\leq</span> <span class="math">(T+4)(T+3)\\frac{2}{p-2}</span> <span class="math">\\leq</span> <span class="math">(T+4)(T+3)\\frac{2}{p^{t}-2}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case <span class="math">E_{b}</span>: In this case we have $P_{i}\\equiv P_{j}{}^{2}\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. However, it is not possible to derive this relation between the polynomials </span>P_{i}<span class="math"> and </span>P_{j}<span class="math"> but only between their evaluations at the points </span>(x,c)<span class="math">, i.e., when </span>P_{i}(1,x,x^{-1},c)\\equiv$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.4 DSE versus DIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P_{j}(1,x,x^{-1},c)^{-1}\\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Similar to the case </span>E_{a}<span class="math">, for each pair </span>(i,j)<span class="math">, </span>i\\neq j<span class="math">, we can bound the number of possible solutions to </span>P_{i}(1,x,x^{-1},c)\\equiv (P_{j}(1,x,x^{-1},c))^{2}\\bmod p^{e}<span class="math"> or </span>P_{i}(1,x,c,x^{-1})\\equiv (P_{j}(1,x,c,x^{-1}))^{2}\\bmod p^{e}<span class="math"> for any prime power </span>p^e<span class="math"> that exactly divides </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. More precisely, we consider the solutions to the following polynomials</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">H _ {i, j} (x, c) := x ^ {2} \\left[ P _ {i} \\left(1, x, x ^ {- 1}, c\\right) - \\left(P _ {j} \\left(1, x, x ^ {- 1}, c\\right)\\right) ^ {2} \\right] \\equiv 0 \\bmod p ^ {e}</span></div>

    <p class="text-gray-300">or</p>

    <div class="my-4 text-center"><span class="math-block">I _ {i, j} (x, c) := x ^ {2} \\left[ P _ {i} \\left(1, x, x ^ {- 1}, c\\right) - \\left(P _ {j} \\left(1, x, x ^ {- 1}, c\\right)\\right) ^ {2} \\right] \\equiv 0 \\bmod p ^ {e}.</span></div>

    <p class="text-gray-300">Here, we obtain the polynomial <span class="math">H(x,c)</span> by multiplying both sides of the congruence <span class="math">P_{i}(1,x,x^{-1},c)\\equiv P_{j}(1,x,x^{-1},c)\\bmod p^{e}</span> with <span class="math">x^{2}</span> and then reordering the resulting congruence. Similarly, we obtain <span class="math">I(x,c)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence, we bound the probability that a random tuple <span class="math">(x,c)\\in_{\\mathcal{R}}\\mathbb{Z}_{p^e}^<em>\\times \\mathbb{Z}_{p^e}^</em></span> is a zero of the polynomials <span class="math">H</span> or <span class="math">I</span> mod <span class="math">p^e</span> (similar to the case <span class="math">E_{a}</span>): The total degree of each of the polynomials <span class="math">H</span> and <span class="math">I</span> is at most 4. It follows from Lemma 7.1 that the probability for a random tuple $(x,c)\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{2}<span class="math"> to be a zero of </span>H<span class="math"> or </span>I<span class="math"> mod </span>p^e<span class="math"> is at most </span>2(4 / p) = 8 / p<span class="math">. Thus, there are at most </span>p^{2e}8 / p = 8p^{2e - 1}<span class="math"> zeros for either </span>H<span class="math"> or </span>I<span class="math"> mod </span>p^e$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Further, there are <span class="math">\\left(\\varphi(p^e)\\right)^2 = (p^e - p^{e-1})^2</span> tuples <span class="math">(x, c)</span> in <span class="math">\\mathbb{Z}_{p^e}^<em> \\times \\mathbb{Z}_{p^e}^</em></span>. Hence, the probability that <span class="math">(x, c) \\in \\mathbb{Z}_{p^e}^<em> \\times \\mathbb{Z}_{p^e}^</em></span> is a zero of <span class="math">H</span> or <span class="math">I \\bmod p^e</span> is upper bounded by <span class="math">8p^{2e-1} / (p^e - p^{e-1})^2</span>. It follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P r o b} \\left[ E _ {b} \\right] \\leq \\frac {8 T _ {2} p ^ {2 e - 1}}{\\left(p ^ {e} - p ^ {e - 1}\\right) ^ {2}} = \\frac {8 T _ {2} p ^ {2 e - 1}}{p ^ {2 e} + p ^ {2 e - 2} - 2 p ^ {2 e - 1}} \\\\ = \\frac {8 T _ {2} p}{p ^ {2} - 2 p + 1} \\\\ \\leq \\frac {8 T _ {2} p}{p ^ {2} - 2 p} = \\frac {8 T _ {2}}{p - 2} \\\\ \\leq \\frac {8 T _ {2}}{p ^ {\\prime} - 2}. \\end{array}</span></div>

    <p class="text-gray-300">In total we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P r o b} [ E ] \\leq \\operatorname {P r o b} [ E _ {a} ] + \\operatorname {P r o b} [ E _ {b} ] \\\\ = \\frac {2 (T _ {1} + 4) (T _ {1} + 3)}{p ^ {\\prime} - 2} + \\frac {8 T _ {2}}{p ^ {\\prime} - 2} \\\\ \\leq \\frac {2 (T + 4) (T + 3)}{p ^ {\\prime} - 2} \\end{array}</span></div>

    <p class="text-gray-300">with <span class="math">T_{1} + T_{2} \\leq T</span>. If the complementary event <span class="math">\\bar{E}</span> occurs, then <span class="math">\\mathcal{A}^{\\sigma, \\mathcal{O}_{DSE}}</span> cannot obtain any information about the bit <span class="math">b</span> except by pure guessing. Thus, the</p>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <p class="text-gray-300">success probability of  <span class="math">\\mathcal{A}^{\\sigma, \\mathcal{O}_{DSE}}</span>  for correctly outputting  <span class="math">b</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {P r o b} [ \\mathcal {A} ^ {\\sigma , \\mathcal {O} _ {D S E}} (..) = b ] = \\mathbf {P r o b} [ E ] + \\frac {1}{2} \\mathbf {P r o b} [ \\bar {E} ] \\\\ = \\mathbf {P r o b} [ E ] + \\frac {1 - \\mathbf {P r o b} [ E ]}{2} \\\\ = \\frac {1}{2} + \\frac {\\mathbf {P r o b} [ E ]}{2} \\\\ \\leq \\frac {1}{2} + \\frac {(T + 4) (T + 3)}{p ^ {\\prime} - 2}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In sharp contrast to the above mentioned high-granular case, we prove in the following theorem that these assumptions are equivalent for their medium-granular version (other parameters remain unchanged).</p>

    <p class="text-gray-300"><span class="math">\\{(1 - 1 / \\mathsf{poly}(k)),\\epsilon ,1 / \\mathsf{poly}(k)\\}</span>  -DSE(c:  <span class="math">\\ast</span>  ;g:m;f:nsprim)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\xrightarrow {\\alpha^ {\\prime} \\geq \\left(\\frac {\\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2} \\alpha ; t ^ {\\prime} = t} \\\\ \\left\\{\\left(1 - 1 / \\operatorname {p o l y} (k)\\right), \\epsilon , 1 / \\operatorname {p o l y} (k) \\right\\} - \\mathrm {D I E} (\\mathrm {c}: *; \\mathrm {g}: \\mathrm {m}; \\mathrm {f}: \\mathrm {n s p r i m}) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">\\<em>-DSE(c: \\</em>; g:m; f: nsprim)</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\xrightarrow {\\alpha^ {\\prime} \\geq \\alpha - \\left(1 - \\left(\\frac {\\varphi (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2}\\right) ; t ^ {\\prime} = t} \\\\ <em> - \\mathrm {D I E} (\\mathrm {c}: </em>; \\mathrm {g}: \\mathrm {m}; \\mathrm {f}: \\mathrm {n s p r i m}) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. We prove the following statements:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Given a DIE oracle  <span class="math">\\mathcal{O}_{DIE}</span>  which breaks  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span> -DSE(c:  <span class="math"><em></span> ; g:m; f:nsprim) with success probability  <span class="math">\\alpha_{DIE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DSE}}</span>  which breaks  <span class="math">\\{(1 - 1 / \\mathrm{poly}(k)),\\epsilon ,1 / \\mathrm{poly}(k)\\}</span> -DIE(c:  <span class="math"></em></span> ; g:m; f:nsprim) with success probability  $\\alpha_{DSE}(k) \\geq \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2\\alpha_{DIE}(k)$ , using a single oracle call.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (a): Assume, we are given a DSE input tuple  <span class="math">((G,g),(g^{x}),(g^{z}))</span>  where  <span class="math">z</span>  is either  <span class="math">x^{2}</span>  or a random element  $c\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Set  </span>h\\coloneqq g^x<span class="math"> , and pass  </span>((G,h),(h^t),(h^{tz}))<span class="math">  to  </span>\\mathcal{O}_{DIE}<span class="math"> . Here, we used the relations  </span>g = h^t<span class="math">  and  </span>g^{z} = h^{tz}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.4 DSE versus DIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we implicitly assumed <span class="math">t = x^{-1}</span>. This holds only if $x \\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> which occurs with probability </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (Note that DIE oracle is not guaranteed to answer correctly on illegal inputs, i.e., inputs with secret exponents from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\setminus \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">z = x^2</span> then with <span class="math">x = t^{-1}</span> we have <span class="math">z = t^{-2}</span>, and the tuple <span class="math">((G,h),(h^{t}),(h^{xt}))</span> has the form <span class="math">((G,h),(h^{t}),(h^{t^{-1}}))</span> which is with probability $\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> a legal DIE input tuple. This holds since </span>h<span class="math"> is a generator with probability </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and thus, </span>h^t<span class="math"> and </span>h^{t^{-1}}$ are legal public and solution parts of a DIE input tuple.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">z \\neq x^2</span> then the tuple <span class="math">((G, h), (h^t), (h^{tz}))</span> is a legal input tuple for DIE oracle with probability $\\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2<span class="math">. This holds because (i) </span>h<span class="math"> is a generator with probability </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and thus </span>h^t<span class="math"> is a legal public part of the DIE input tuple, and (ii) </span>h^{zt}<span class="math"> is a legal random part of a DIE input tuple only if </span>z \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math"> which is true with probability </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since these events are independent, the probability for both to occur is $\\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Success probability: We have $\\alpha_{DSE}(k) \\geq \\alpha_{DIE}(k)\\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)<span class="math"> for the correct case (i.e., </span>z = x^2<span class="math">) and </span>\\alpha_{DSE}(k) \\geq \\alpha_{DIE}(k)\\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2<span class="math"> for the random case (i.e., </span>z \\neq x^2$). Hence, for the resulting success probability the following holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{DSE}(k) \\geq \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2 \\alpha_{DIE}(k).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following we set $\\gamma(k) \\coloneqq \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2<span class="math"> (Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a function of the security parameter </span>k$, see also Lemma 6.5). Depending on the success probability of DIE oracle we have the following cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle <span class="math">(\\alpha_{DIE}(k) \\not\\leq_{\\infty} 1)</span>: The resulting success probability cannot be perfect because there is a non-zero error probability when querying the DIE oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak oracle <span class="math">(\\alpha_{DIE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is also weak: This holds since $\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and consequently </span>\\gamma(k)<span class="math"> is always non-negligible, and its multiplication with a not negligible function results in a not negligible function. Thus, we can write </span>\\gamma(k) \\alpha_{DIE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. Since </span>\\alpha_{DSE}(k) \\geq \\gamma(k) \\alpha_{DIE}(k)<span class="math">, it follows </span>\\alpha_{DSE}(k) \\not\\leq_{\\infty} 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Invariant oracle <span class="math">(\\alpha_{DIE} \\not\\leq_{\\infty} \\epsilon_1)</span>: The resulting success probability is (asymptotically) invariant: Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> contains no small prime factors, it follows from Lemma 6.5 that </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. More precisely, for any </span>\\epsilon' &gt; 0<span class="math"> there exists a </span>k_0<span class="math"> such that for all </span>k &gt; k_0<span class="math">, </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt; 1 - \\epsilon'<span class="math">. It follows that for all </span>k &gt; k_0<span class="math">, </span>\\gamma(k) &gt; (1 - \\epsilon')^2 = 1 - \\epsilon''<span class="math"> where </span>\\epsilon'' := 2\\epsilon' - \\epsilon'^2<span class="math">. Since </span>\\alpha_{DIE}(k) \\not\\leq_{\\infty} \\epsilon_1<span class="math">, for each </span>k_0'<span class="math"> there exists a </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{DIE}(k_1) \\geq \\epsilon_1<span class="math">. Hence, for each </span>k_0' &gt; k_0<span class="math"> there exists </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{DSE}(k_1) \\geq \\epsilon_2<span class="math"> where </span>\\epsilon_2 := (1 - \\epsilon'')\\epsilon_1<span class="math">. This means </span>\\alpha_{DSE}(k) \\not\\leq_{\\infty} \\epsilon_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7 DECISIONAL DH, SE AND IE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Strong oracle <span class="math">(1 - \\alpha_{DIE}(k) \\ngeq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is (asymptotically) strong: Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> contains no small prime factors, it follows from Lemma 6.5 that </span>1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. Then we can write </span>\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &gt;_{\\infty} 1 - 1 / \\mathsf{poly}(k)<span class="math"> and </span>\\gamma(k) &gt;_{\\infty} (1 - 1 / \\mathsf{poly}(k))^2 = 1 - 1 / \\mathsf{poly}(k)<span class="math">. Hence, we have </span>1 - \\gamma(k) &gt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. From Lemma 6.7 it follows </span>1 - \\gamma(k) \\alpha_{DIE}(k) \\ngeq_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. Finally, since </span>1 - \\alpha_{DSE}(k) \\leq 1 - \\gamma(k) \\alpha_{DIE}(k)<span class="math"> we have </span>1 - \\alpha_{DSE}(k) \\ngeq_{\\infty} 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case (b): Assume, we are given a DIE input tuple <span class="math">((G,g),(g^{x}),(g^{z}))</span> where $x,z\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math">, and </span>z<span class="math"> is either </span>x^{-1}<span class="math"> or a random element </span>c\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math">. Set </span>h\\coloneqq g^z<span class="math"> and pass </span>((G,h),(h^{t}),(h^{tx}))<span class="math"> to </span>\\mathcal{O}_{DSE}<span class="math"> where </span>h^t = g<span class="math"> and </span>h^{tx} = g^x<span class="math"> for some </span>t\\in \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math">. If </span>z = x^{-1}<span class="math"> then </span>t = x<span class="math"> and the tuple </span>((G,h),(h^{t}),(h^{xt}))<span class="math"> has the form </span>((G,h),(h^{t}),(h^{t^{2}}))<span class="math"> which is a correct DSE input tuple. This is because </span>h<span class="math"> is a generator, and </span>h^t<span class="math"> is a group element with </span>t\\in_{\\mathcal{R}}\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math">. Thus, this instance can be solved by the given DSE oracle. However, the probability for a correct answer is not necessarily </span>\\alpha_{DSE}(k)<span class="math"> since the inputs to the DSE oracle are limited to those with secret exponents from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math"> whereas its success probability is defined over </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Let </span>\\alpha_{DSE}'(k)<span class="math"> and </span>\\alpha_{DSE}''(k)<span class="math"> denote the oracles&#x27; success probabilities under the condition that the random secret exponents </span>x<span class="math"> are chosen from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}<span class="math"> and from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\setminus \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{*}$ respectively. It follows</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{DSE}(k) = \\alpha_{DSE}''(k) \\mathbf{Prob}[x \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\setminus \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*] + \\alpha_{DSE}'(k) \\mathbf{Prob}[x \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">By reordering we obtain</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{DSE}'(k) = \\frac{\\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\alpha_{DSE}''(k)}{\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">)}{</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where in the last inequality we set <span class="math">\\alpha_{DSE}&#x27;&#x27;(k) = 1</span> to lower bound <span class="math">\\alpha_{DSE}&#x27;(k)</span>. Thus, the oracle answers correctly on the restricted inputs with probability at least $\\alpha_{DSE}'(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">z \\neq x^{-1}</span> then <span class="math">t \\neq x</span> and the tuple <span class="math">((G, h), (h^t), (h^{xt}))</span> is a correct (random) DSE input tuple. This is because (i) <span class="math">h</span> is a generator, and (ii) <span class="math">h^t</span> and <span class="math">h^{xt}</span> are group elements (with $x, t \\in_{\\mathcal{R}} \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">) representing legal public and random parts of the DSE input tuple. However, the inputs to the DSE oracle are limited to those with secret exponents </span>(t, z)<span class="math"> from </span>\\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^* \\times \\mathbb{Z}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^*<span class="math">. Thus, similar to the correct case, we can determine the probability that the oracle answers correctly on these inputs. This probability is </span>\\alpha_{DSE}'(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.4 DSE versus DIE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Success probability: We have $\\alpha_{DSE}'(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)<span class="math"> for the correct case (i.e., </span>z = x^{-1}<span class="math">) and </span>\\alpha_{DSE}'(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2\\right)<span class="math"> for the random case (i.e., </span>z \\neq x^{-1}$). Hence, for the resulting success probability the following holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{DIE}(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following we set $\\gamma(k) \\coloneqq \\left(\\frac{\\varphi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^2<span class="math"> (Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a function of the security parameter </span>k$, see also Lemma 6.5). Depending on the success probability of DSE oracle we have the following cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect oracle <span class="math">(\\alpha_{DSE}(k) \\neq_{\\infty} 1)</span>: The resulting success probability is also perfect because DIE instances represent legal inputs to the DSE oracle, and they all are solved by the perfect oracle.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Weak oracle <span class="math">(\\alpha_{DSE}(k) \\neq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is (asymptotically) weak: As shown in the case (a), for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with no small prime factors we have </span>1 - \\gamma(k) &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. The subtraction of a negligible function from a not negligible one results in a not negligible function, i.e., </span>\\alpha_{DSE}(k) - (1 - \\gamma(k)) \\neq_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. This implies </span>\\alpha_{DIE}(k) \\neq_{\\infty} 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Invariant oracle <span class="math">(\\alpha_{DSE} \\neq_{\\infty} \\epsilon_1)</span>: The resulting success probability is (asymptotically) invariant: As shown in the case (a), for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with no small prime factors we have </span>1 - \\gamma(k) &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. More precisely, for any </span>\\epsilon'<span class="math"> there exists a </span>k_0<span class="math"> such that for all </span>k &gt; k_0<span class="math">, </span>1 - \\gamma(k) &lt; \\epsilon'<span class="math"> holds. Since </span>\\alpha_{DSE}(k) \\neq_{\\infty} \\epsilon_1<span class="math">, for any </span>k_0'<span class="math"> there exists a </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{DSE}(k_1) \\geq \\epsilon_1<span class="math">. Thus, for any </span>k_0' &gt; k_0<span class="math"> there exists a </span>k_1 &gt; k_0'<span class="math"> such that </span>\\alpha_{DSE}(k_1) - (1 - \\gamma(k_1)) \\geq \\epsilon_2<span class="math"> where </span>\\epsilon_2 := \\epsilon_1 - \\epsilon'<span class="math">. Hence, we can write </span>\\alpha_{DSE}(k) - (1 - \\gamma(k)) \\neq_{\\infty} \\epsilon_2<span class="math">. Finally, since </span>\\alpha_{DIE} \\geq \\alpha_{DSE}(k) - (1 - \\gamma(k))<span class="math">, it follows that </span>\\alpha_{DIE} \\neq_{\\infty} \\epsilon_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Strong oracle <span class="math">(1 - \\alpha_{DSE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k))</span>: The resulting success probability is (asymptotically) strong: From <span class="math">\\alpha_{DIE}(k) \\geq \\alpha_{DSE}(k) - (1 - \\gamma(k))</span> follows <span class="math">1 - \\alpha_{DIE}(k) \\leq 1 - \\alpha_{DSE}(k) + (1 - \\gamma(k))</span>. As shown in the case (a), for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with no small prime factors we have </span>1 - \\gamma(k) &lt;_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. Further, we have </span>1 - \\alpha_{DSE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">. Thus, the right side of the above inequality is a not non-negligible function as it is the sum of a not non-negligible and a negligible functions. Hence, we can write </span>1 - \\alpha_{DSE}(k) + (1 - \\gamma(k)) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)<span class="math">, implying </span>1 - \\alpha_{DIE}(k) \\not\\geq_{\\infty} 1 / \\mathsf{poly}(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 7.14. The reductions in Theorem 7.9 are proven for group orders with no small prime factors. However, they also hold for all other group orders provided the group order is known (see also Remark 7.13). Thus, the following holds.</p>

    <p class="text-gray-300">Theorem 7.10</p>

    <div class="my-4 text-center"><span class="math-block">\\{(1 - 1 / \\mathsf{poly}(k)), \\epsilon, 1 / \\mathsf{poly}(k)\\} - \\mathrm{DSE}(\\mathrm{c} : *; \\mathrm{g} : \\mathrm{m}; \\mathrm{f} : *; \\mathrm{o})</span></div>

    <p class="text-gray-300"><span class="math">\\Longrightarrow</span> <span class="math">\\{(1-1/\\mathsf{poly}(k)),\\epsilon,1/\\mathsf{poly}(k)\\}\\text{-DIE(c:<em>;g:m;f:</em>,o)}</span> <span class="math"><em></span>DSE(c:</em>;g:m;f:<em>,o) <span class="math">\\Longleftarrow</span> <span class="math"></em></span>DIE(c:<em>;g:m;f:</em>,o)</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Remark 7.15.</h6>

    <p class="text-gray-300">The reduction (DIE to DSE) in Theorem 7.9 (7.10 respectively) does not hold for perfect success probability due to the introduced error probability. However, for groups of prime order the reduction also holds for perfect oracles as the only special case <span class="math">x=0</span> can be explicitly handled, i.e., one can easily test whether <span class="math">g^{0}=1</span> is the input.</p>

    <h2 id="sec-52" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">In this paper, we identify the parameters relevant to cryptographic assumptions. Based on this we present a framework and notation for defining assumptions related to Discrete Logarithms. Using this framework these assumptions can be precisely and systematically classified. Wider adoption of such a terminology would ease the study and comparison of results in the literature, e.g., the danger of ambiguity and mistakes in lengthily stated textual assumptions and theorems would be minimized. Furthermore, clearly stating and considering these parameters opens an avenue to generalize results regarding the relation of different assumptions and to get a better understanding of them. This is the focus of our ongoing research. A parameter in defining assumptions previously ignored in the literature is granularity. We show (as summarized in Figure 2) that varying this parameter leads to surprising results: We prove that some DL-related assumptions are equivalent in one case (medium granular) and provably not equivalent, at least not in a generic sense, in another case (high granular). Furthermore, we show that some reductions for medium granularity are much more efficient than their high-granular version leading to considerably improved concrete security, in particular as medium granularity results in weaker assumptions than high-granular ones. However, we note that medium- or low-granular assumptions apply in cryptographic settings only when the choice of system parameters is guaranteed to be truly random. Interesting open questions remain to be answered: While for both CDL and CDH it can be shown that their high- and medium-granular assumptions are equivalent, this is not yet known for DDH (also briefly mentioned as an open problem by <em>Shoup (1999)</em>). Only few relations can be shown for low-granular assumptions as no random self-reducibility is yet known. However, achieving such “full” random self-reducibility seems very difficult in general (if not impossible) in number-theoretic settings <em>(Boneh, 2000)</em> contrary to, e.g., lattice settings used by <em>Ajtai and Dwork (1997)</em>. Finally, high granularity is almost intrinsic in the generic model and it is not clear how to extend the generic model to medium or low granularity. Our surprising results also throw some shadow of doubt onto the use of the generic model as a tool</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Summary of our results</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient reduction</li>

      <li>Inefficient reduction</li>

    </ul>

    <p class="text-gray-300">Reduction impossible in generic model</p>

    <p class="text-gray-300">to show impossibility results. It remains to be further explored whether these results are due to the limitations of the generic model or are really intrinsic differences between assumptions with medium and high granularity.</p>

    <p class="text-gray-300">We thank André Adelsbach, Birgit Pfitzmann, Matthias Schunter, and the anonymous reviewers for their helpful comments.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">Ajtai, Miklós and Cynthia Dwork. 1997, May. “A Public-Key Cryptosystem with Worst-Case/Average-Case Equivalence.” <em>Proceedings of the 29th Annual Symposium on Theory Of Computing (STOC)</em>. El Paso, TX, USA: ACM Press, 284–293.</p>

    <p class="text-gray-300">Babai, Laszlo and Endre Szemerédi. 1984. “On the complexity of matrix group problems.” <em>Proceedings of the 25th Symposium on Foundations of Computer Science (FOCS)</em>. IEEE Computer Society Press, 229–240.</p>

    <p class="text-gray-300">Bach, Eric and Jeffrey Shallit. 1996. <em>Algorithmic Number Theory — Efficient Algorithms</em>. Volume I. Cambridge, USA: MIT Press. ISBN: 0-262-02405-5.</p>

    <p class="text-gray-300">Bellare, Mihir and Phillip Rogaway. 1993, November. “Random Oracles are Practical: A Paradigm for Designing Efficient Protocols.” Edited by Victoria Ashby, <em>Proceedings of the 1st ACM Conference on Computer and Communications Security</em>. Fairfax, Virginia: ACM Press, 62–73.</p>

    <p class="text-gray-300">———. 1995. “Optimal Asymmetric Encryption — How to encrypt with RSA.” Edited by A. De Santis, <em>Advances in Cryptology – EUROCRYPT ’94</em>, Volume 950 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 92–111. Final (revised) version appeared November 19, 1995. Available from http://www-cse.ucsd.edu/users/mihir/papers/oaep.html.</p>

    <p class="text-gray-300">Biham, Eli, Dan Boneh, and Omer Reingold. 1999. “Breaking Generalized Diffie-Hellman modulo a composite is no easier than factoring.” <em>Information Processing Letters</em> 70:83–87. Also appeared in Theory of Cryptography Library, Record 97-14, 1997.</p>

    <p class="text-gray-300">Blum, Manuel and Silvio Micali. 1984. “How to Generate Cryptographically Strong Sequences of Pseudo-Random Bits.” <em>SIAM Journal on Computing</em> 13 (4): 850–864 (November).</p>

    <p class="text-gray-300">Boneh, Dan. 1998. “The Decision Diffie-Hellman problem.” <em>Third International Algorithmic Number Theory Symposium (ANTS-III)</em>, Volume 1423 of <em>Lecture Notes in Computer Science</em>. Springer-Verlag, Berlin Germany, 48–63.</p>

    <p class="text-gray-300">———. 2000, October. Personal Communication.</p>

    <p class="text-gray-300">———. 2001. “Simplified OAEP for the RSA and Rabin functions.” In <em>Kilian</em> 2001, 275–291.</p>

    <p class="text-gray-300">Boneh, Dan and Richard J. Lipton. 1996. “Algorithms for black box fields and their application to cryptography.” In <em>Koblitz</em> 1996, 283–297.</p>

    <p class="text-gray-300">Brands, Stefan. 1994. “Untraceable Off-line Cash in Wallet with Observers.” Edited by Douglas R. Stinson, <em>Advances in Cryptology – CRYPTO ’93</em>, Volume 773 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 302–318.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">Cachin, Christian, Klaus Kursawe, and Victor Shoup. 2000, July. “Random Oracles in Constantinople: Practical Asynchronous Byzantine Agreement using Cryptography.” <em>Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing</em>. ACM Portland, Oregon. Full version appeared as Cryptology ePrint Archive Report 2000/034 (2000/7/7).</p>

    <p class="text-gray-300">Camenisch, Jan, Ueli Maurer, and Markus Stadler. 1996, September. “Digital Payment Systems with Passive Anonymity-Revoking Trustees.” Edited by E. Bertino, H. Kurth, G. Martella, and E. Montolivo, <em>Proceedings of the Fourth European Symposium on Research in Computer Security (ESORICS)</em>, Volume 1146 of <em>Lecture Notes in Computer Science</em>. Rome, Italy: Springer-Verlag, Berlin Germany, 33–43.</p>

    <p class="text-gray-300">Canetti, Ran. 1997. “Towards realizing random oracles: Hash functions that hide all partial information.” Edited by Burton S. Kaliski, Jr., <em>Advances in Cryptology – CRYPTO ’97</em>, Volume 1294 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 455–469.</p>

    <p class="text-gray-300">Canetti, Ran, Oded Goldreich, and Shai Halevi. 1998, May. “The Random Oracle Methodology, Revisited.” <em>Proceedings of the 30th Annual Symposium on Theory Of Computing (STOC)</em>. Dallas, TX, USA: ACM Press, 209–218.</p>

    <p class="text-gray-300">Cramer, Ronald and Victor Shoup. 1998. “A Practical Public Key Cryptosystem Provably Secure against Adaptive Chosen Ciphertext Attack.” In <em>Krawczyk (1998)</em>, 13–25.</p>

    <p class="text-gray-300">Davida, George, Yair Frankel, Yiannis Tsiounis, and Moti Yung. 1997, February. “Anonymity Control in E-Cash Systems.” <em>Proceedings of the First Conference on Financial Cryptography (FC ’97)</em>, Volume 1318 of <em>Lecture Notes in Computer Science</em>. International Financial Cryptography Association (IFCA) Anguilla, British West Indies: Springer-Verlag, Berlin Germany, 1–16.</p>

    <p class="text-gray-300">Diffie, Whitfield and Martin Hellman. 1976. “New Directions in Cryptography.” <em>IEEE Transactions on Information Theory</em> IT-22 (6): 644–654 (November).</p>

    <p class="text-gray-300">Fischlin, Marc. 2000. “A Note on Security Proofs in the Generic Model.” In <em>Okamoto (2000)</em>, 458–469.</p>

    <p class="text-gray-300">Frankel, Yair, Yiannis Tsiounis, and Moti Yung. 1996. “‘Indirect Discourse Proofs’: Achieving Fair Off-Line Cash (FOLC).” Edited by K. Kim and T. Matsumoto, <em>Advances in Cryptology – ASIACRYPT ’96</em>, Volume 1163 of <em>Lecture Notes in Computer Science</em>. Springer-Verlag, Berlin Germany, 286–300.</p>

    <p class="text-gray-300">Fujisaki, Eiichiro, Tatsuaki Okamoto, David Pointcheval, and Jacques Stern. 2001. “RSA—OAEP is secure under the RSA Assumption.” In <em>Kilian (2001)</em>, 260–274.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">Gennaro, Rosario. 2000. "An Improved Pseudo-random Generator Based on Discrete Log." Edited by Mihir Bellare, <em>Advances in Cryptology – CRYPTO '2000</em>, Volume 1880 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 469–481.</p>

    <p class="text-gray-300">Goldwasser, Shafi and Silvio Micali. 1984. "Probabilistic Encryption." <em>Journal of Computer Security</em> 28:270–299.</p>

    <p class="text-gray-300">Gordon, Daniel M. 1993a. "Designing and Detecting Trapdoors for Discrete Log Cryptosystems." Edited by E.F. Brickell, <em>Advances in Cryptology – CRYPTO '92</em>, Volume 740 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 66–75.</p>

    <p class="text-gray-300">——— 1993b. "Discrete logarithms in <span class="math">\\mathrm{GF}(p)</span> using the number field sieve." <em>SIAM Journal on Discrete Mathematics</em> 6 (1): 124–138.</p>

    <p class="text-gray-300">Handschuh, Helena, Yiannis Tsiounis, and Moti Yung. 1999, March. "Decision oracles are equivalent to matching oracles." <em>International Workshop on Practice and Theory in Public Key Cryptography '99 (PKC '99)</em>, Volume 1560 of <em>Lecture Notes in Computer Science</em>. Kamakura, Japan: Springer-Verlag, Berlin Germany.</p>

    <p class="text-gray-300">Kilian, Joe, ed. 2001. <em>Advances in Cryptology – CRYPTO '2001</em>. Volume 2139 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</p>

    <p class="text-gray-300">Kiltz, Eike. 2001. "A Tool Box of Cryptographic Functions related to the Diffie-Hellman Function." <em>Advances in Cryptology – INDOCRYPT '2001</em>, Volume 2247 of <em>Lecture Notes in Computer Science</em>. Springer-Verlag, Berlin Germany, 339–350.</p>

    <p class="text-gray-300">Koblitz, Neal, ed. 1996. <em>Advances in Cryptology – CRYPTO '96</em>. Volume 1109 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</p>

    <p class="text-gray-300">Krawczyk, Hugo, ed. 1998. <em>Advances in Cryptology – CRYPTO '98</em>. Volume 1462 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</p>

    <p class="text-gray-300">Lenstra, Arjen K. and Eric R. Verheul. 2001. "Selecting Cryptographic Key Sizes." <em>Journal of Cryptology</em> 14 (4): 255–293.</p>

    <p class="text-gray-300">Lidl, Rudolf and Harald Niederreiter. 1997, January. <em>Finite Fields</em>. Second edition. Encyclopedia of Mathematics and its Applications. Cambridge University Press.</p>

    <p class="text-gray-300">MacKenzie, Philip. 2001, July. "On the Security of the SPEKE Password-Authenticated Key Exchange Protocol." Report 2001/057, Cryptology ePrint Archive.</p>

    <p class="text-gray-300">Maurer, Ueli M. 1994. "Towards the Equivalence of Breaking the Diffie-Hellman Protocol and Computing Discrete Logarithms." Edited by Yvo G.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">Desmedt, <em>Advances in Cryptology – CRYPTO ’94</em>, Volume 839 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 271–281.</p>

    <p class="text-gray-300">Maurer, Ueli M. and Stefan Wolf. 1996. “Diffie-Hellman Oracles.” In <em>Koblitz 1996</em>, 268–282.</p>

    <p class="text-gray-300">——. 1998a, August. “Diffie-Hellman, Decision Diffie-Hellman, and Discrete Logarithms.” <em>IEEE Symposium on Information Theory</em>. Cambridge, USA, 327.</p>

    <p class="text-gray-300">——. 1998b. “Lower bounds on generic algorithms in groups.” Edited by Kaisa Nyberg, <em>Advances in Cryptology – EUROCRYPT ’98</em>, Volume 1403 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 72–84.</p>

    <p class="text-gray-300">McCurley, Kevin S. 1990. “The Discrete Logarithm Problem.” Edited by Carl Pomerance, <em>Cryptology and Computational Number Theory</em>, Volume 42 of <em>Proceedings of Symposia in Applied Mathematics</em>. American Mathematical Society Providence, 49–74.</p>

    <p class="text-gray-300">Menezes, Alfred J., Paul C. van Oorschot, and Scott A. Vanstone. 1997. <em>Handbook of Applied Cryptography</em>. CRC Press series on discrete mathematics and its applications. CRC Press. ISBN 0-8493-8523-7.</p>

    <p class="text-gray-300">National Institute of Standards and Technology (NIST). 2000, January. The Digital Signature Standard (DSS). FIPS PUB 186-2.</p>

    <p class="text-gray-300">Nechaev, V. I. 1994. “Complexity of a determinate algorithm for the discrete logarithm.” <em>Mathematical Notes</em> 55 (2): 165–172. Translated from Matematicheskie Zametki, 55(2):91–101, 1994.</p>

    <p class="text-gray-300">Odlyzko, Andrew. 2000. “Discrete logarithms: The past and the future.” <em>Designs, Codes and Cryptography</em> 19:129–145.</p>

    <p class="text-gray-300">Okamoto, T., ed. 2000. <em>Advances in Cryptology – ASIACRYPT ’2000</em>. Volume 1976 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research, Kyoto, Japan: Springer-Verlag, Berlin Germany.</p>

    <p class="text-gray-300">Patel, Sarvar and Ganapathy S. Sundaram. 1998. “An Efficient Discrete Log Pseudo Random Generator.” In <em>Krawczyk 1998</em>, 304–317.</p>

    <p class="text-gray-300">Pfitzmann, Birgit and Ahmad-Reza Sadeghi. 2000. “Anonymous Fingerprinting with Direct Non-Repudiation.” In <em>Okamoto 2000</em>, 401–414.</p>

    <p class="text-gray-300">Pohlig, S.C. and M. E. Hellman. 1978. “An improved algorithm for computing logarithms over <span class="math">\\operatorname{GF}(p)</span> and its cryptographic significance.” <em>IEEE Transactions on Information Theory</em> 24:106–110.</p>

    <p class="text-gray-300">Pollard, J. M. 1978. “Monte Carlo methods for index computation mod p.” <em>Mathematics of Computation</em> 32:918–924.</p>

    <p class="text-gray-300">Schirokauer, Oliver. 1993. “Discrete logarithms and local units.” <em>Philosophical Transactions of the Royal Society of London</em> A 345:409–423.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">Schnorr, Claus P. 1991. “Efficient Signature Generation by Smart Cards.” <em>Journal of Cryptology</em> 4 (3): 161–174.</p>

    <p class="text-gray-300">Schwartz, J. T. 1980. “Fast probabilistic algorithms for verification of polynomial identities.” <em>Journal of the ACM</em> 27 (4): 701–717 (October).</p>

    <p class="text-gray-300">Shmuely, Zahava. 1985, February. “Composite Diffie-Hellman Public-Key Generating Systems are Hard to Break.” Computer science technical report 356, Israel Institute of Technology (Technion).</p>

    <p class="text-gray-300">Shoup, Victor. 1997. “Lower Bounds for Discrete Logarithms and Related Problems.” Edited by Walter Fumy, <em>Advances in Cryptology – EURO-CRYPT ’97</em>, Volume 1233 of <em>Lecture Notes in Computer Science</em>. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 256–266.</p>

    <p class="text-gray-300">———. 1999, April. “On Formal Models for Secure Key Exchange.” Research report RZ 3120 (#93166), IBM Research. A revised version 4, dated November 15, 1999, is available from http://www.shoup.net/papers/.</p>

    <p class="text-gray-300">———. 2001. “OAEP Reconsidered.” In <em>Kilian 2001</em>, 239–259.</p>

    <p class="text-gray-300">Steiner, Michael, Gene Tsudik, and Michael Waidner. 1996, March. “Diffie-Hellman Key Distribution Extended to Groups.” Edited by Clifford Neuman, <em>Proceedings of the 3rd ACM Conference on Computer and Communications Security</em>. New Delhi, India: ACM Press, 31–37. Appeared as revised and extended journal version as (Steiner, Tsudik, and Waidner 2000).</p>

    <p class="text-gray-300">———. 2000. “Key Agreement in Dynamic Peer Groups.” <em>IEEE Transactions on Parallel and Distributed Systems</em> 11 (8): 769–780 (August).</p>

    <p class="text-gray-300">Wolf, Stefan. 1999. “Information-Theoretically and Computationally Secure Key Agreement in Cryptography.” Ph.D. diss., ETH Zürich.</p>

    <p class="text-gray-300">C, see problem type, computational</p>

    <p class="text-gray-300">DH, see problem family, DH</p>

    <p class="text-gray-300">DL, see problem family, DL</p>

    <p class="text-gray-300">D, see problem type, decisional</p>

    <p class="text-gray-300"><span class="math">E_{a,b} / \\mathbb{F}_p</span>  , see group family</p>

    <p class="text-gray-300"><span class="math">\\mathrm{GDH}(n)</span>  , see problem family,  <span class="math">\\mathrm{GDH}(n)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{SG(k)}</span>  , see group sibling</p>

    <p class="text-gray-300">IAE, see problem family, IAE</p>

    <p class="text-gray-300">IE, see problem family, IE</p>

    <p class="text-gray-300">M, see problem type, matching</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{p / q}^{*}</span>  , see group family</p>

    <p class="text-gray-300"><span class="math">\\mathrm{RP}(n)</span>  , see problem family,  <span class="math">\\mathrm{RP}(n)</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_n^*</span>  , see group family</p>

    <p class="text-gray-300">SE, see problem family, SE</p>

    <p class="text-gray-300"><span class="math">SG</span>  , see group sampler</p>

    <p class="text-gray-300"><span class="math">SPI</span>  , see problem instance sampler</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Q}\\mathbb{R}_n^*</span>  , see group family</p>

    <p class="text-gray-300"><span class="math">Sg</span>  , see generator sampler</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{p^<em>}^</em></span>  see group family</p>

    <p class="text-gray-300"><span class="math">\\leftarrow</span>  , see assignment</p>

    <p class="text-gray-300"><span class="math">\\stackrel{\\mathrm{s}}{=}</span>  , see assignment, see random variable</p>

    <p class="text-gray-300"><span class="math">\\in_{\\mathcal{R}}</span>  , see assignment</p>

    <p class="text-gray-300">\\*, see wild card</p>

    <p class="text-gray-300"><span class="math">G</span>  , see group</p>

    <p class="text-gray-300"><span class="math">PI</span>  , see problem instance</p>

    <p class="text-gray-300"><span class="math">SI</span>  , see structure Instance</p>

    <p class="text-gray-300"><span class="math">&amp;lt;  _{\\infty}1 / \\mathrm{poly}(k)</span>  , see negligible</p>

    <p class="text-gray-300"><span class="math">\\geq_{\\infty}1 / \\mathrm{poly}(k)</span>  , see non-negligible</p>

    <p class="text-gray-300"><span class="math">\\neq_{\\infty}1 / \\mathrm{poly}(k)</span>  , see negligible</p>

    <p class="text-gray-300"><span class="math">\\not\\geq_{\\infty}1 / \\mathrm{poly}(k)</span>  , see non-negligible</p>

    <p class="text-gray-300"><span class="math">&amp;lt;  _{\\infty}</span>  ,5</p>

    <p class="text-gray-300"><span class="math">\\geq_{\\infty}</span>  ,5</p>

    <p class="text-gray-300"><span class="math">\\neq_{\\infty}</span>  ,5</p>

    <p class="text-gray-300"><span class="math">\\geqslant_{\\infty}</span>  ,5</p>

    <p class="text-gray-300"><span class="math">g</span>  , see group, generator</p>

    <p class="text-gray-300"><span class="math">k</span>  , see security parameter</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}</span>  , see group family</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  , see problem family</p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}</span>  , see uniform distribution of infinite binary strings</p>

    <p class="text-gray-300"><span class="math">PI^{SI}</span>  , see problem instance</p>

    <p class="text-gray-300"><span class="math">PI^{priv}</span>  , see problem instance</p>

    <p class="text-gray-300"><span class="math">PI^{publ}</span>  , see problem instance</p>

    <p class="text-gray-300"><span class="math">PI^{sol}</span>  , see problem instance</p>

    <p class="text-gray-300"><span class="math">\\stackrel{c}{\\approx}</span>  , see indistinguishability, computational</p>

    <p class="text-gray-300"><span class="math">\\approx</span>  , see indistinguishability, statistical</p>

    <p class="text-gray-300">(…), see sequence</p>

    <p class="text-gray-300"><span class="math">(\\ldots :\\ldots)</span>  , see random variable</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots)$  , see sequence</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta_{(X,Y)}(k)</span>  , see statistical difference</p>

    <p class="text-gray-300"><span class="math">\\Sigma_{G,g}</span>  , see encoding function</p>

    <p class="text-gray-300"><span class="math">g^{x}</span>  , see exponentiation</p>

    <p class="text-gray-300">log, 5</p>

    <p class="text-gray-300">poly(v1, ..., vn), see polynomial, multivariate</p>

    <p class="text-gray-300">poly(v), see polynomial, univariate</p>

    <p class="text-gray-300"><span class="math">\\sigma (\\cdot)</span>  , see encoding function</p>

    <p class="text-gray-300">RunTime, see Turing machine, runtime</p>

    <p class="text-gray-300"><span class="math">\\{\\ldots :\\ldots \\}</span>  , see random variable, ensemble</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\{\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\}$  , see set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\{\\ldots \\}</span>  , see set</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  , see group order</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sigma</span>  , see algebraic knowledge</p>

    <p class="text-gray-300">h, see granularity, high</p>

    <p class="text-gray-300"><span class="math">\\epsilon</span>  , see success probability, invariant</p>

    <p class="text-gray-300">fct, see group family</p>

    <p class="text-gray-300">o, see group family</p>

    <p class="text-gray-300">lprim, see group family</p>

    <p class="text-gray-300">l, see granularity, low</p>

    <p class="text-gray-300">m, see granularity, medium</p>

    <p class="text-gray-300">nsprim, see group family</p>

    <p class="text-gray-300">n, see complexity, non-uniform</p>

    <p class="text-gray-300"><span class="math">\\coloneqq</span>  , see assignment</p>

    <p class="text-gray-300">1, see success probability, perfect</p>

    <p class="text-gray-300">prim, see group family</p>

    <p class="text-gray-300">[·], see random variable</p>

    <p class="text-gray-300">INDEX</p>

    <p class="text-gray-300"><span class="math">(1 - 1 / \\mathsf{poly}(k))</span>  , see success probability, strong</p>

    <p class="text-gray-300"><span class="math">\\overline{\\mathbf{o}}</span>  , see group family</p>

    <p class="text-gray-300">u, see complexity, uniform</p>

    <p class="text-gray-300"><span class="math">1 / \\mathsf{poly}(k)</span>  , see success probability, weak</p>

    <p class="text-gray-300">adversary, 15</p>

    <p class="text-gray-300">generic, 17</p>

    <p class="text-gray-300">specific, 17</p>

    <p class="text-gray-300">algebraic knowledge, 17</p>

    <p class="text-gray-300">assignment, 4</p>

    <p class="text-gray-300">associative, 7</p>

    <p class="text-gray-300">black-box reduction, 25</p>

    <p class="text-gray-300">complexity, 15</p>

    <p class="text-gray-300">non-uniform, 16</p>

    <p class="text-gray-300">uniform, 16</p>

    <p class="text-gray-300">cryptographic assumption, 11-26</p>

    <p class="text-gray-300">parameter, 11-19</p>

    <p class="text-gray-300">DH, see Diffie-Hellman</p>

    <p class="text-gray-300">Diffie-Hellman (DH), 3</p>

    <p class="text-gray-300">Discrete Logarithm (DL), 3, 7</p>

    <p class="text-gray-300">distinguisher, 7</p>

    <p class="text-gray-300">DL, see Discrete Logarithm</p>

    <p class="text-gray-300">DL-based assumption, see cryptographic assumption</p>

    <p class="text-gray-300">efficient, 6</p>

    <p class="text-gray-300">encoding function, 17</p>

    <p class="text-gray-300">exponentiation, 7</p>

    <p class="text-gray-300">GDH, see Generalized Diffie-Hellman</p>

    <p class="text-gray-300">Generalized Diffie-Hellman (GDH), 3</p>

    <p class="text-gray-300">generator, see group, generator sampler, 10</p>

    <p class="text-gray-300">generic model, see algebraic knowledge</p>

    <p class="text-gray-300">granularity, 3, 18, 27-29</p>

    <p class="text-gray-300">high, 18</p>

    <p class="text-gray-300">low, 18</p>

    <p class="text-gray-300">medium, 18</p>

    <p class="text-gray-300">group, 7</p>

    <p class="text-gray-300">cyclic, 7</p>

    <p class="text-gray-300">element, 7</p>

    <p class="text-gray-300">order, 7</p>

    <p class="text-gray-300">family, 9, 14</p>

    <p class="text-gray-300">finite, 7</p>

    <p class="text-gray-300">generator, 7</p>

    <p class="text-gray-300">identity element, 7</p>

    <p class="text-gray-300">inverse, 7</p>

    <p class="text-gray-300">operation, 7</p>

    <p class="text-gray-300">order, 7</p>

    <p class="text-gray-300">factorization, 14</p>

    <p class="text-gray-300">sampler, 9</p>

    <p class="text-gray-300">sibling, 9</p>

    <p class="text-gray-300">IAE, see Inverted-Additive Exponent</p>

    <p class="text-gray-300">IE, see Inverse Exponent</p>

    <p class="text-gray-300">indistinguishability</p>

    <p class="text-gray-300">computational, 7</p>

    <p class="text-gray-300">statistical, 7</p>

    <p class="text-gray-300">Inverse Exponent (IE), 3</p>

    <p class="text-gray-300">Inverted-Additive Exponent (IAE), 3</p>

    <p class="text-gray-300">Matching Diffie-Hellman, 3</p>

    <p class="text-gray-300">negligible, 5</p>

    <p class="text-gray-300">not, 5</p>

    <p class="text-gray-300">non-negligible, 5</p>

    <p class="text-gray-300">not, 6</p>

    <p class="text-gray-300">oracle, 6</p>

    <p class="text-gray-300">INDEX</p>

    <p class="text-gray-300">polynomial</p>

    <p class="text-gray-300">multivariate, 5</p>

    <p class="text-gray-300">univariate, 5</p>

    <p class="text-gray-300">probability, 5</p>

    <p class="text-gray-300">probability space, 4</p>

    <p class="text-gray-300">probability space instance (PSI), 18</p>

    <p class="text-gray-300">problem</p>

    <p class="text-gray-300">family, 8, 11</p>

    <p class="text-gray-300">DH, 12</p>

    <p class="text-gray-300">DL, 12</p>

    <p class="text-gray-300"><span class="math">\\operatorname{GDH}(n)</span>, 12</p>

    <p class="text-gray-300">IAE, 12</p>

    <p class="text-gray-300">IE, 12</p>

    <p class="text-gray-300"><span class="math">\\operatorname{RP}(n)</span>, 12</p>

    <p class="text-gray-300">SE, 12</p>

    <p class="text-gray-300">hard, 6</p>

    <p class="text-gray-300">instance, 8</p>

    <p class="text-gray-300">sampler, 10</p>

    <p class="text-gray-300">type, 13</p>

    <p class="text-gray-300">computational, 13</p>

    <p class="text-gray-300">decisional, 13</p>

    <p class="text-gray-300">matching, 13</p>

    <p class="text-gray-300">PSI, see probability space instance</p>

    <p class="text-gray-300">random self-reducibility, 15</p>

    <p class="text-gray-300">random variable, 4</p>

    <p class="text-gray-300">ensemble, 5</p>

    <p class="text-gray-300">Representation Problem (RP), 3</p>

    <p class="text-gray-300">RP, see Representation Problem</p>

    <p class="text-gray-300">sampler</p>

    <p class="text-gray-300">generator, see generator sampler</p>

    <p class="text-gray-300">group, see group sampler</p>

    <p class="text-gray-300">problem instance, see problem</p>

    <p class="text-gray-300">instance sampler</p>

    <p class="text-gray-300">SE, see Square Exponent</p>

    <p class="text-gray-300">security parameter <span class="math">k</span>, 5</p>

    <p class="text-gray-300">self-reduction</p>

    <p class="text-gray-300">random, see random self-reducibility</p>

    <p class="text-gray-300">semantic security, 13</p>

    <p class="text-gray-300">sequence, 4</p>

    <p class="text-gray-300">set, 4</p>

    <p class="text-gray-300">Square Exponent (SE), 3</p>

    <p class="text-gray-300">statistical difference, 7</p>

    <p class="text-gray-300">structure instance</p>

    <p class="text-gray-300"><span class="math">SI</span>, 8</p>

    <p class="text-gray-300">success probability, 18</p>

    <p class="text-gray-300">invariant, 19</p>

    <p class="text-gray-300">perfect, 19</p>

    <p class="text-gray-300">strong, 19</p>

    <p class="text-gray-300">weak, 19</p>

    <p class="text-gray-300">Turing machine, 6, 16</p>

    <p class="text-gray-300">polynomial-time, 6</p>

    <p class="text-gray-300">runtime, 6</p>

    <p class="text-gray-300">uniform distribution of infinite binary strings, 6</p>

    <p class="text-gray-300">wild card, 20</p>

    <p class="text-gray-300">A DERIVING FORMAL ASSUMPTIONS</p>

    <p class="text-gray-300">The "mechanics" of deriving the formal assumption statement from its short form <span class="math">s-</span>t<span class="math">P</span>a(c:<span class="math">c; g:</span>g; f:<span class="math">G) — as described in Section 4 the </span>X's are placeholders of the parameters defined in Section 3 — is as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group and problem family: Just fix the group, generator and problem instance sampler <span class="math">SG_{\\mathcal{G}}</span>, <span class="math">Sg</span>, and <span class="math">SPI_{\\mathcal{P}}</span> corresponding to group family <span class="math">\\mathcal{G}</span> and problem family <span class="math">\\mathcal{P}</span>, respectively. In the context of generic relations, <span class="math">\\mathcal{G}</span> does normally not fix a particular group family and sampler but gives just some specific constraints on group families, e.g., groups with large prime factors indicated by "lprim". In such a case <span class="math">SG_{\\mathcal{G}}</span> denotes an arbitrary sampler for an arbitrary group family fulfilling the given constraints on the group family and the constraints on samplers given in Section 2.7.⁴¹</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Problem type: Prepare the assumption formula <span class="math">\\mathbf{F}</span> as the probability statement <span class="math">\\mathbf{P}</span> defined as “Prob[”. <span class="math">\\mathbf{P}_{\\mathrm{pred}}</span> .“ :: ”. <span class="math">\\mathbf{P}_{\\mathrm{def}}</span> .“]. The . denotes the string-concatenation operator and the variables <span class="math">\\mathbf{P}_{\\mathrm{pred}}</span> and <span class="math">\\mathbf{P}_{\\mathrm{def}}</span> are the probability predicate and the probability space instance definition, respectively. They are defined depending on the problem type <span class="math">\\mathbf{t}</span> as follows (where <span class="math">SPI_{\\mathcal{P}}</span> is the problem sampler fixed in item 1 above and where the source of <span class="math">SI</span> is explained in item 3 below):</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{t} = \\mathbf{C}</span>: Initialize <span class="math">\\mathbf{P}_{\\mathrm{def}}</span> to “<span class="math">PI \\leftarrow SPI_{\\mathcal{P}}(SI)</span>;” (the problem instance to solve) and add “<span class="math">\\mathcal{C} \\xleftarrow{\\approx} \\mathcal{U}</span>;” (the random coins for the adversary) to it. Define <span class="math">\\mathbf{P}_{\\mathrm{pred}}</span> as “<span class="math">\\mathcal{A}(\\mathcal{C}, SI, PI^{publ}) \\in PI^{sol}</span>”.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbf{t} = \\mathbf{D}</span>: Initialize <span class="math">\\mathbf{P}_{\\mathrm{def}}</span> to the concatenation of “<span class="math">b \\xleftarrow{\\approx} \\{0,1\\}</span>;” (the random bit used as challenge), “<span class="math">PI_0 \\leftarrow SPI_{\\mathcal{P}}(SI)</span>;” and “<span class="math">PI_1 \\leftarrow SPI_{\\mathcal{P}}(SI)</span>;” (the real problem instance and an auxiliary problem instance for the random public part), “<span class="math">sol_c \\xleftarrow{\\approx} PI_b^{sol}</span>;” (one possible solution), and “<span class="math">\\mathcal{C} \\xleftarrow{\\approx} \\mathcal{U}</span>;”. <span class="math">\\mathbf{P}_{\\mathrm{pred}}</span> is defined as “<span class="math">\\mathcal{A}(\\mathcal{C}, SI, PI^{publ}, sol_c) = b</span>”. Additionally, the probability statement <span class="math">\\mathbf{P}</span> is normalized to “$2 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{Prob}[\\mathbf{P}_{\\mathrm{pred}}::\\mathbf{P}_{\\mathrm{def}}] - 0.5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$”.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Granularity: Depending on the granularity value <span class="math">g</span> do the following (where <span class="math">SG_{\\mathcal{G}}</span> and <span class="math">Sg</span> are the group and generator sampler fixed in item 1):</li>

    </ol>

    <p class="text-gray-300">⁴¹In practice, only the later application of this relation using specific assumptions implied by a cryptographic systems will determine the concrete choices of group family and sampler.</p>

    <p class="text-gray-300">83</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{S}\\mathbf{g} = \\mathrm{l}</span>: Prepend “ <span class="math">G \\leftarrow SG_{\\mathcal{G}}(1^k)</span> ”, “ <span class="math">g_i \\leftarrow Sg(G)</span> ” (for as many <span class="math">i \\in \\mathbb{N}</span> as required by the problem family, e.g., one generator for DL and <span class="math">n</span> generators for <span class="math">\\mathrm{RP}(n)</span>), and “ <span class="math">SI \\leftarrow (G, g_1, \\ldots)</span> ” to <span class="math">\\mathbb{S}\\mathbf{P}_{\\mathrm{def}}</span>.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{g} = \\mathrm{m}</span>: Prepend “ <span class="math">\\forall G \\in [SG_{\\mathcal{G}}(1^k)]</span> ” to <span class="math">\\mathbb{S}\\mathbf{F}</span>. Prepend “ <span class="math">g \\leftarrow Sg(G)</span> ” and “ <span class="math">SI \\leftarrow (G, g_1, \\ldots)</span> ” to <span class="math">\\mathbb{S}\\mathbf{P}_{\\mathrm{def}}</span>.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{g} = \\mathrm{h}</span>: Prepend “ <span class="math">\\forall G \\in [SG_{\\mathcal{G}}(1^k)]</span> ”, “ <span class="math">\\forall g_i \\in [Sg(G)]</span> ”, and “ <span class="math">SI \\leftarrow (G, g_1, \\ldots)</span> ” to <span class="math">\\mathbb{S}\\mathbf{F}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computational complexity and algebraic knowledge: Depending on the computational complexity <span class="math">\\mathbb{C}</span> do the following:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{S}\\mathbf{c} = \\mathbf{u}</span>: Prefix <span class="math">\\mathbb{S}\\mathbf{F}</span> with “ <span class="math">\\forall \\mathcal{A} \\in \\mathcal{UPTM}</span> ”, “ <span class="math">\\exists k_0</span> ”, and “ <span class="math">\\forall k &amp;gt; k_0</span> ”.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{c} = \\mathbf{n}</span>: Prefix <span class="math">\\mathbb{S}\\mathbf{F}</span> with “ <span class="math">\\forall (\\mathcal{A}_i \\mid i \\in \\mathbb{N}) \\in \\mathcal{NPTM}</span> ”, “ <span class="math">\\exists k_0</span> ”, and “ <span class="math">\\forall k &amp;gt; k_0</span> ”. In <span class="math">\\mathbb{P}_{\\mathrm{pred}}</span> replace “ <span class="math">\\mathcal{A}</span> ” by “ <span class="math">\\mathcal{A}_k</span> ”.</li>

    </ul>

    <p class="text-gray-300">If the considered assumption is in the generic model ( <span class="math">\\mathbb{S}a = \\sigma</span> ) then replace everywhere “ <span class="math">\\mathcal{A}</span> ”, <span class="math">\\mathcal{UPTM}</span> and <span class="math">\\mathcal{NPTM}</span> by “ <span class="math">\\mathcal{A}^{\\sigma}</span> ”, <span class="math">\\mathcal{UPTM}^{\\sigma}</span> and <span class="math">\\mathcal{NPTM}^{\\sigma}</span> respectively. Furthermore, append “ <span class="math">\\sigma \\stackrel{\\mathrm{s}}{\\leftarrow} \\Sigma_{G,g}</span> ” (the choice of the random encoding function) to <span class="math">\\mathbb{P}_{\\mathrm{def}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Success probability: Depending on the success probability <span class="math">\\mathbb{S}</span> do the following to finish the formal assumption statement:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{S}\\mathbf{s} = 1</span>: Append “&lt; 1” to <span class="math">\\mathbb{S}\\mathbf{F}</span>, i.e., immediately after <span class="math">\\mathbb{S}\\mathbf{P}</span>.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{s} = (1 - 1 / \\mathsf{poly}(k))</span>: Append “ <span class="math">\\exists d_1</span> ” immediately after the all-quantifier on adversary algorithms in <span class="math">\\mathbb{S}\\mathbf{F}</span>. Append “ <span class="math">&amp;lt; (1 - 1 / k^{d_1})</span> ” to <span class="math">\\mathbb{S}\\mathbf{F}</span>.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{s} = \\epsilon</span>: Append “&lt; <span class="math">\\epsilon</span> ” to <span class="math">\\mathbb{S}\\mathbf{F}</span>.</li>

      <li><span class="math">\\mathbb{S}\\mathbf{s} = 1 / \\mathsf{poly}(k)</span>: Append “ <span class="math">\\forall d_1</span> ” immediately after the all-quantifier on adversary algorithms in <span class="math">\\mathbb{S}\\mathbf{F}</span>. Append “ <span class="math">&amp;lt; 1 / k^{d_1}</span> ” to <span class="math">\\mathbb{S}\\mathbf{F}</span>.</li>

    </ul>

    <p class="text-gray-300">Evaluating <span class="math">\\mathbb{F}</span> by expanding the variables, i.e., <span class="math">\\mathbb{S}\\mathbf{P}</span>, <span class="math">\\mathbb{P}_{\\mathrm{pred}}</span> and <span class="math">\\mathbb{P}_{\\mathrm{def}}</span>, and applying the string-concatenation operator gives now the desired precise formal assumption statement.</p>`;
---

<BaseLayout title="Assumptions Related to Discrete Logarithms: Why Subtleties M... (2002/126)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/126
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
