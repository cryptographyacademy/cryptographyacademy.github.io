---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/126';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Assumptions Related to Discrete Logarithms: Why Subtleties Make a Real Difference';
const AUTHORS_HTML = 'Ahmad-Reza Sadeghi, Michael Steiner';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The security of many cryptographic constructions relies on
assumptions related to Discrete Logarithms (DL), e.g., the
Diffie-Hellman, Square Exponent, Inverse Exponent or Representation
Problem assumptions. In the concrete formalizations of these
assumptions one has some degrees of freedom offered by parameters such
as computational model, problem type (computational, decisional) or
success probability of adversary.  However, these parameters and their
impact are often not properly considered or are simply overlooked in
the existing literature.
In this paper we identify parameters relevant to cryptographic
applications and describe a formal framework for defining DL-related
assumptions. This enables us to precisely and systematically classify
these assumptions.
In particular, we identify a parameter, termed granularity, which
describes the underlying probability space in an assumption.  Varying
granularity we discover the following surprising result: We prove that
two DL-related assumptions can be reduced to each other for medium
granularity but we also show that they are provably not reducible with
generic algorithms for high granularity.  Further we show that
reductions for medium granularity can achieve much better concrete
security than equivalent high-granularity reductions.</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Most modern cryptographic systems rely on assumptions on the computational difficulty of some particular number-theoretic problem.<sup>1</sup> One well-known class of</p>

    <p class="text-gray-300"><sup>1</sup>The exceptions are information-theoretically secure systems and systems such as hashfunctions or shared-key encryption relying on heuristic assumptions, e.g., the Random Oracle</p>

    <p class="text-gray-300">assumptions is related to the difficulty of computing discrete logarithms in cyclic groups <a href="#page-76-0">(McCurley</a> 1990). In this class a number of variants exists. The most prominent ones, besides Discrete Logarithm (DL), are the computational and decisional Diffie-Hellman (DH) assumptions (Diffie and <a href="#page-74-0">Hellman</a> 1976; <a href="#page-73-1">Brands</a> 1994) Less known assumptions are Matching Diffie-Hellman <a href="#page-74-1">(Frankel</a> et al. 1996), Square Exponent (SE) <a href="#page-76-1">(Maurer</a> and Wolf 1996), and Inverse Exponent (IE) <a href="#page-76-2">(Pfitzmann</a> and Sadeghi 2000), an assumption closely related to the Inverted-Additive Exponent (IAE) Problem introduced by <a href="#page-75-0">MacKenzie</a> (2001) <sup>2</sup> and also implicitly required for the security of the schemes proposed by <a href="#page-74-2">Camenisch,</a> Maurer, and Stadler (1996) and Davida, Frankel, <a href="#page-74-3">Tsiounis,</a> and Yung (1997). Further related assumptions mentioned in the sequel are Generalized Diffie-Hellman (GDH) <a href="#page-77-0">(Shmuely</a> 1985; <a href="#page-77-1">Steiner</a> et al. 1996) and the Representation Problem (RP) <a href="#page-73-1">(Brands</a> 1994). Several additional papers have studied relations among these assumptions, e.g., <a href="#page-77-2">(Shoup</a> 1997; <a href="#page-76-3">Maurer</a> and Wolf 1998a; <a href="#page-76-4">Maurer</a> and Wolf 1998b; <a href="#page-73-2">Biham</a> et al. 1999; Wolf <a href="#page-77-3">1999)</a>.</p>

    <p class="text-gray-300">In the concrete formalizations of these assumptions one has various degrees of freedom offered by parameters such as computational model, problem type (computational, decisional or matching) or success probability of the adversary. However, such aspects are often not precisely considered in the literature and consequences are simply overlooked. In this paper, we address these aspects by identifying the parameters relevant to cryptographic assumptions. Based on this, we present a formal framework and a concise notation for defining DLrelated assumptions. This enables us to precisely and systematically classify these assumptions.</p>

    <p class="text-gray-300">Among the specified parameters, we focus on a parameter we call granularity of the probability space which underlies an assumption. Granularity defines what part of the underlying algebraic structure (i.e., algebraic group and generator) is part of the probability space and what is fixed in advance: For high granularity an assumption has to hold for all groups and generators; for medium granularity the choice of the generator is included in the probability space and for low granularity the probability is taken over both the choice of the group and the generator. Assumptions with lower granularity are weaker than those with higher granularity. Nonetheless, not all cryptographic settings can rely on the weaker variants: Only when the choice of the system parameters is guaranteed to be random one can rely on a low-granularity assumption. For example, consider an anonymous payment system where the bank chooses the system parameters. To base the security of such a system a-priori on a low-granularity assumption would not be appropriate. A cheating bank might try to choose a weak group with trapdoors (easy problem instances) to violate the anonymity of the customer. Such a cheater strategy might be possible even if the low-granular assumption holds: The assumption would ensure that the overall number of easy</p>

    <p class="text-gray-300">Model (Bellare and <a href="#page-73-3">Rogaway</a> 1993).</p>

    <p class="text-gray-300"><sup>2</sup>Note that SE and IAE are originally called Squaring Diffie-Hellman <a href="#page-77-3">(Wolf</a> 1999) and Inverted-Additive Diffie-Hellman <a href="#page-75-0">(MacKenzie</a> 2001), respectively. They are renamed here for consistency and clarity reasons.</p>

    <p class="text-gray-300">problem instances is asymptotically negligible (in respect to the security parameter). Nonetheless, it would not rule out that there are infinitely many weak groups! However, if we choose the system parameters of the payment system through a random yet verifiable process we can resort to a weaker assumption with lower granularity. To our knowledge no paper on anonymous payment systems addresses this issue properly. Granularity was also overlooked in different contexts, e.g., <a href="#page-73-4">Boneh</a> (1998) ignores the fact that low-granular assumptions are not known to be random self-reducible and comes to a wrong conclusion regarding the correctness of a certain self-corrector.</p>

    <p class="text-gray-300">In this paper, we show that varying granularity can lead to surprising results. We extend the results of Wolf <a href="#page-77-3">(1999)</a> to the problem class IE, i.e., we prove statements on relations between IE, DH and SE for both computational and decisional variants in the setting of Wolf <a href="#page-77-3">(1999)</a>, which corresponds to the high-granular case. We then consider medium granularity (with other parameters unchanged) and show the impact: We prove that the decisional IE and SE assumptions are equivalent for medium granularity whereas this is provably not possible for their high-granular variants, at least not in the generic model <a href="#page-77-2">(Shoup</a> 1997). We also show that reductions between computational IE, SE and DH can offer much better concrete security for medium granularity than their high-granular analogues.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Terminology</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 General Notational Conventions</h3>

    <p class="text-gray-300">By {a, b, c, . . . } and (a, b, c, . . .) we denote the set and the sequence consisting of the elements a, b, c, . . . . By specifying a set as {f(v<sup>1</sup> , . . . , vn) | pred(v<sup>1</sup> , . . . , v<sup>n</sup> )} we mean the set of elements we get by evaluating the formula f with any instantiation of the n free variables v<sup>1</sup> , . . . , v<sup>n</sup> which fulfills the predicate pred, e.g., {(v, v 2 ) | v &isin; } denotes the set of all tuples which contain a natural number and its square. Similarly, we define (f(v<sup>1</sup> , . . . , vn) | pred(v<sup>1</sup> , . . . , v<sup>n</sup> )) to be the sequence of elements we get by evaluating the formula f with any instantiation of the n free variables v<sup>1</sup> , . . . , v<sup>n</sup> which fulfills the predicate pred. The elements are ordered according to some arbitrary but fixed order relation on the (instantiated) argument tuples (v<sup>1</sup> , . . . , vn). For example, ((v, v 2 ) | v &isin; ) denotes the infinite sequence of all tuples which contain a natural number and its square, and where the sequence is ordered, e.g., using the standard order &lt; on and the value of v as the sort index.</p>

    <p class="text-gray-300">The evaluation and following assignment of an expression expr to a variable v is denoted by v &larr; expr. By v &larr;<sup>R</sup> S we mean the assignment of a uniformly chosen random element from the set S to variable v. Similarly, v &isin;<sup>R</sup> S denotes that v is a uniformly distributed random element from set S. Finally, by t:=expr we mean that by definition the term t is equal to expr.</p>

    <p class="text-gray-300">Simple random variables are specified as v &larr;<sup>R</sup> S as mentioned above. To specify more complicated random variables, we use the following notation:  <span class="math">(f(v_1,\\ldots,v_n)::\\operatorname{assign}(v_1,\\ldots,v_n))</span> . By this we mean the random variable having a structure as defined by the formula f and a probability space as induced by binding the n free variables  <span class="math">v_1,\\ldots,v_n</span>  via the assignment rule assign, e.g.,  <span class="math">((v,v^2)::v\\stackrel{\\mathcal{R}}{\\leftarrow}\\mathbb{Z}_n)</span>  denotes the random variable consisting of a tuple which contains an integer and its square where the integer is uniformly chosen from  <span class="math">\\mathbb{Z}_n</span> . Similarly,  <span class="math">\\{f(v_1,\\ldots,v_n)::\\operatorname{assign}(v_1,\\ldots,v_n)\\}</span>  defines an ensemble of random variables indexed by the free variables  <span class="math">v_i</span>  which are left unspecified in the assignment rule assign and which have by definition domain  <span class="math">\\mathbb{N}</span> , e.g.,  <span class="math">\\{(v,v^k)::v\\stackrel{\\mathcal{R}}{\\leftarrow}\\mathbb{Z}_n\\}</span>  denotes the ensemble of random variables consisting of a tuple which contain an integer and its k-th power where the integer is uniformly chosen from  <span class="math">\\mathbb{Z}_n</span>  and the natural number k is the index of the ensemble. Finally, let v be some arbitrary random variable or random variable ensemble. Then, [v] denotes the set of all possible values of v.</p>

    <p class="text-gray-300">To specify probabilities, we use the notation  <span class="math">\\mathbf{Prob}[\\mathsf{pred}(v_1,\\ldots,v_n) :: \\mathsf{assign}(v_1,\\ldots,v_n)]</span> . This denotes the probability that the predicate  <span class="math">\\mathsf{pred}</span>  holds when the probability is taken over a probability space defined by the formula  <span class="math">\\mathsf{assign}</span>  on the n free variables  <span class="math">v_i</span>  of the predicate  <span class="math">\\mathsf{pred}</span> . For example,  <span class="math">\\mathsf{Prob}[v \\equiv 0 \\pmod 2] :: v \\xleftarrow{\\mathcal{R}} \\mathbb{Z}_n</span>  denotes the probability that a random element of  <span class="math">\\mathbb{Z}_n</span>  is even.</p>

    <p class="text-gray-300">For convenience, by log we always mean the logarithm to the base two.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Asymptotics</h3>

    <p class="text-gray-300">Cryptographic assumptions are always expressed asymptotically in a <strong>security parameter</strong>  <span class="math">k \\in \\mathbb{N}</span> . To classify the asymptotic behavior of functions  <span class="math">\\mathbb{N} \\to \\mathbb{R}^*</span>  (with  <span class="math">\\mathbb{R}^*</span>  denoting the set of all non-negative real numbers) we require the following definitions.</p>

    <p class="text-gray-300">We can extend ordinary relation operators  <span class="math">op \\in \\{&lt;, \\leq, =, &gt;, \\geq\\}</span>  on elements of  <span class="math">\\mathbb{R}^*</span>  to asymptotic relation operators  <span class="math">op_{\\infty}</span>  on functions  <span class="math">f_1</span>  and  <span class="math">f_2</span>  defined as above as follows:</p>

    <p class="text-gray-300"><span class="math">$f_1(k)</span>$
<span class="math">op_{\\infty}</span>   <span class="math">f_2(k) := \\exists k_0 \\ \\forall k &gt; k_0 : f_1(k) \\ op \\ f_2(k).</span></p>

    <p class="text-gray-300">The corresponding negation of the asymptotic relation operators is then denoted by  <span class="math">\\not&lt;_{\\infty}</span> ,  <span class="math">\\not\\leq_{\\infty}</span> ,  <span class="math">\\not\\geq_{\\infty}</span> , and  <span class="math">\\not&gt;_{\\infty}</span> , respectively.</p>

    <p class="text-gray-300">For example,  <span class="math">f_1(k) &lt;_{\\infty} f_2(k)</span>  means that  <span class="math">f_1</span>  is asymptotically strictly smaller than  <span class="math">f_2</span>  and  <span class="math">f_1(k) \\not\\geq_{\\infty} f_2(k)</span>  means that  <span class="math">f_1</span>  is not asymptotically larger or equal to  <span class="math">f_2</span> , i.e., for each  <span class="math">k_0</span>  there is a  <span class="math">k_1 &gt; k_0</span>  such that  <span class="math">f_1(k_1) &lt; f_2(k_1)</span> . However, note that the  <span class="math">f_1(k) \\not\\geq_{\\infty} f_2(k)</span>  does not imply  <span class="math">f_1(k) &lt;_{\\infty} f_2(k)</span> !</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{poly}(v)</span>  be the class of  <span class="math">\\mathsf{univariate}\\ \\mathsf{polynomials}</span>  with variable v and non-negative coefficients, i.e.,  <span class="math">\\mathsf{poly}(v) := \\{\\sum_{i=0}^d a_i v^i \\mid d \\in \\mathbb{N}_0 \\land a_i \\in \\mathbb{N}_0\\}</span> . Furthermore, let  <span class="math">\\mathsf{poly}(v_1, \\ldots, v_n)</span>  be the class of  <span class="math">\\mathsf{multivariate}\\ \\mathsf{polynomials}</span>  with n variables  <span class="math">v_j</span>  and non-negative coefficients, i.e.,  <span class="math">\\mathsf{poly}(v_1, \\ldots, v_n) := \\{\\sum_{i=0}^d \\sum_{j=1}^{|D_i|} a_{ij} \\prod_{l=1}^n v_l^{d_{ijl}} \\mid d \\in \\mathbb{N}_0 \\land a_{ij} \\in \\mathbb{N}_0 \\land (d_{ij1}, \\ldots, d_{ijn}) \\in D_i^n\\}</span>  where  <span class="math">D_i^n := \\{(d_l \\mid l \\in \\{1, \\ldots, n\\}) \\mid d_l \\in \\mathbb{N}_0 \\land \\sum_{l=1}^n d_l = i\\}</span> . Based on this we can define the following useful classes of functions:</p>

    <p class="text-gray-300">A <strong>negligible</strong> function  <span class="math">\\epsilon(k)</span>  is a function where the inverse of any polynomial is asymptotically an upper bound, i.e.,  <span class="math">\\forall d &gt; 0 \\ \\exists k_0 \\ \\forall k &gt; k_0 : \\epsilon(k) &lt; 1/k^d</span> . We denote this by  <span class="math">\\epsilon(k) &lt;_{\\infty} 1/\\text{poly}(k)</span> . If  <span class="math">\\epsilon(k)</span>  cannot be upper bounded in such a way, we say  <span class="math">\\epsilon(k)</span>  is <strong>not negligible</strong> and we denote this by  <span class="math">\\epsilon(k) \\not&lt;_{\\infty} 1/\\text{poly}(k)</span> .</p>

    <p class="text-gray-300">A <strong>non-negligible</strong> function f(k) is a function which asymptotically can be lower bounded by the inverse of some polynomial, i.e.,  <span class="math">\\exists d &gt; 0 \\ \\exists k_0 \\ \\forall k &gt; k_0 : f(k) \\geq 1/k^d</span> . We denote this by  <span class="math">f(k) \\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .<sup>3</sup> If f(k) cannot be lower bounded in such a way we say f(k) is <strong>not non-negligible</strong> and denote this by  <span class="math">f(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Non-negligible functions are &mdash; when seen as a class &mdash; closed under multivariate polynomial composition, i.e.,  <span class="math">\\forall n \\in \\mathbb{N} \\ \\forall i \\in \\{1,\\dots,n\\} \\ \\forall p \\in \\mathsf{poly}(v_1,\\dots,v_n) \\setminus \\{0_{\\mathsf{poly}}\\} \\ \\forall f_i \\geq_\\infty 1/\\mathsf{poly}(k) : \\ p(f_1,\\dots,f_n) \\geq_\\infty 1/\\mathsf{poly}(k)</span>  where  <span class="math">0_{\\mathsf{poly}}</span>  denotes the null polynomial. This holds also for negligible functions if there is no non-zero constant term in the polynomial, i.e., we select only elements from the class  <span class="math">\\mathsf{poly}(v_1,\\dots,v_n)</span>  where  <span class="math">a_{01}</span>  is zero. For not negligible and not non-negligible functions this holds solely for univariate polynomial composition. Finally, the addition (multiplication) of a non-negligible and a not negligible function is a non-negligible function. Similarly, the addition of a negligible and a not non-negligible function is a not non-negligible function or even a negligible function if the not non-negligible function can be upper bounded by some polynomial.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Computational Model</h3>

    <p class="text-gray-300">The computational model is based on the class  <span class="math">\\mathcal{TM}</span>  of probabilistic  <span class="math">\\mathit{Turing}</span>   <span class="math">\\mathit{machines}</span>  on the binary alphabet  <span class="math">\\{0,1\\}</span> . The  <span class="math">\\mathit{runtime}</span>  of a Turing machine M is measured by the number of simple Turing steps from the initial state with given inputs until the machine reaches a final state. This is denoted by  <span class="math">\\mathit{RunTime}(\\mathsf{M}(\\mathit{inputs}))</span> . The complexity of a Turing machine is expressed as a function of the bit-length of the inputs encoded on its input tape and defined as the maximum runtime for any input of a given bit-length. To make the definition of the probability spaces more explicit, we model a probabilistic Turing machine always as a deterministic machine with the random coins given as an explicit input  <span class="math">\\mathcal C</span>  chosen from the  <span class="math">\\mathit{uniform}</span>  distribution of  <span class="math">\\mathit{infinite}</span>  binary  <span class="math">\\mathit{strings}</span>   <span class="math">\\mathcal U</span> . However, we do not consider the randomness when calculating the length of the inputs. The important class of  <span class="math">\\mathit{polynomial-time}</span>   <span class="math">\\mathit{Turing}</span>   <span class="math">\\mathit{machines}</span>  is the class of machines with polynomial complexity:</p>

    <pre><code class="language-text"> \\{ \\mathcal{A} \\mid \\mathcal{A} \\in \\mathcal{TM};
\\forall d_1; \\ \\exists d_2; \\ \\forall k;
\\forall inputs \\in \\{0,1\\}^{k^{d_1}}; \\ \\forall \\mathcal{C} \\in \\{0,1\\}^{\\infty};
: \\text{RunTime}(\\mathcal{A}(\\mathcal{C}, inputs)) &lt; k^{d_2} \\}
</code></pre>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^3&lt;/sup&gt;</span> Note that not negligible is <em>not</em> the same as non-negligible, there are functions which are neither negligible nor non-negligible!</p>

    <p class="text-gray-300">When we use the term <strong>efficient</strong> in the context of algorithms or computation we mean a Turing machine with polynomial complexity. By a <strong>hard problem</strong> we mean the absence of any efficient algorithm (asymptotically) solving that problem.</p>

    <p class="text-gray-300">In some situations, e.g., in a reduction, a machine M has access to some other machines  <span class="math">\\mathcal{O}_1, \\ldots, \\mathcal{O}_n</span>  and can query them as <strong>oracles</strong>. We denote this by  <span class="math">\\mathsf{M}^{\\mathcal{O}_1, \\ldots, \\mathcal{O}_n}</span> . This means that the machine M can write the input tapes of all  <span class="math">\\mathcal{O}_i</span> , run them on that input, and read the corresponding output tapes. However, M does not get access to the internal structure or state of the oracle.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Indistinguishability</h3>

    <p class="text-gray-300">Let two families of random variables  <span class="math">X := (X_k \\mid k \\in \\mathbb{N})</span>  and  <span class="math">Y := (Y_k \\mid k \\in \\mathbb{N})</span>  be defined over some discrete domain  <span class="math">\\mathcal{D}</span> . They are said to be <strong>computationally indistinguishable</strong> iff there is no efficient distinguishing algorithm D which can distinguish the two asymptotically, i.e.,  <span class="math">|\\mathbf{Prob}[D(1^k, X_k) = 1] - \\mathbf{Prob}[D(1^k, Y_k) = 1]|</span>  is a negligible function in k. This is denoted by  <span class="math">X \\stackrel{c}{\\approx} Y</span> . X and Y are <strong>statistically indistinguishable</strong> iff the <strong>statistical difference</strong>  <span class="math">\\Delta_{(X,Y)}(k) := \\sum_{d \\in \\mathcal{D}} |\\mathbf{Prob}[X_k = d] - \\mathbf{Prob}[Y_k = d]|</span>  is a negligible function. This is written as  <span class="math">X \\stackrel{s}{\\approx} Y</span> .</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Algebraic Structures</h3>

    <p class="text-gray-300">The following terms are related to the algebraic structures underlying an assumption.</p>

    <p class="text-gray-300"><strong>Finite cyclic group</strong> G: A group is an algebraic structure with a set G of <strong>group elements</strong> and a binary <strong>group operation</strong>  <span class="math">*: G \\times G \\to G</span>  such that the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the group operation is <strong>associative</strong>, i.e., a*(b*c)=(a*b)*c for all  <span class="math">a,b,c\\in G</span> ,</li>
      <li>there is an identity element  <span class="math">1 \\in G</span>  such that a * 1 = a = 1 * a for all  <span class="math">a \\in G</span> , and</li>
      <li>for each  <span class="math">a \\in G</span>  there is an <strong>inverse</strong>  <span class="math">a^{-1} \\in G</span>  such that  <span class="math">a * a^{-1} = 1 = a^{-1} * a</span> .</li>
    </ul>

    <p class="text-gray-300">The <strong>group order</strong> is the cardinality of the set G and is denoted by |G|.</p>

    <p class="text-gray-300">In the following, we write group operations always multiplicatively by juxtaposition of group elements; Nonetheless, note that the following results apply &mdash; with the appropriate adaption of notation &mdash; also to additive groups such as elliptic curves. The <strong>exponentiation</strong>  <span class="math">a^x</span>  for  <span class="math">a \\in G</span>  and  <span class="math">x \\in \\mathbb{N}_0</span>  is then defined</p>

    <p class="text-gray-300">as usual as  <span class="math">\\overbrace{a\\cdots a}</span> . The <strong>discrete logarithm</strong> of a given  <span class="math">b\\in G</span>  in respect to a specified base  <span class="math">a\\in G</span>  is the smallest  <span class="math">x\\in \\mathbb{N}_0</span>  such that  <span class="math">a^x=b</span>  or undefined if no such x exists. The <strong>order of a group element</strong>  <span class="math">b\\in G</span>  is the least positive integer x such that  <span class="math">b^x=1</span>  or  <span class="math">\\infty</span>  if no such x exists.</p>

    <p class="text-gray-300">A group G is <strong>finite</strong> if |G| is finite. A group G is <strong>cyclic</strong> if there is a <strong>generator</strong>  <span class="math">g \\in G</span> , such that  <span class="math">\\forall b \\in G \\exists ! x \\in \\mathbb{Z}_{|G|} : g^x = b</span> . The order of all elements in a finite cyclic group G divides |G|. In particular, there are exactly  <span class="math">\\varphi(d)</span>  elements of order d (where d is any divisor of |G|).</p>

    <p class="text-gray-300">All considered assumptions are based on finite cyclic groups. For brevity, however, we omit the &quot;finite cyclic&quot; in the sequel and refer to them simply as &quot;groups&quot;.</p>

    <p class="text-gray-300">For more information on the relevant abstract algebra we refer you to the book of Lidl and Niederreiter (1997).</p>

    <p class="text-gray-300">Algorithmically, the following is noteworthy: Finding generators can be done efficiently when the factorization of |G| is known; it is possible to perform exponentiations in  <span class="math">O(\\log{(|G|)})</span>  group operations; and computing inverses can be done in  <span class="math">O(\\log{(|G|)})</span>  group operations under the condition that |G| is known. For the corresponding algorithms and further algorithms for abstract or concrete groups we refer you to the books of Bach and Shallit (1996) and Menezes, van Oorschot, and Vanstone (1997).</p>

    <p class="text-gray-300"><strong>Structure instance</strong> SI:A tuple  <span class="math">(G, g_1, \\ldots, g_n)</span>  containing a group G as first element followed by a sequence of one or more generators  <span class="math">g_i</span> . This represents the structure underlying a particular problem. We can assume that the structure instance SI (though not necessarily properties thereof such as the order or the factorization of the order) is publicly known.</p>

    <p class="text-gray-300">As a convention we abbreviate  <span class="math">g_1</span>  to g if there is only a single generator associated with a given structure instance.</p>

      <h3 id="sec-2.6" class="text-xl font-semibold mt-8">2.6 Problems</h3>

    <p class="text-gray-300">The following two terms characterize a particular problem underlying an assumption.</p>

    <p class="text-gray-300"><strong>Problem family</strong>  <span class="math">\\mathcal{P}</span> : A family of abstract relations indexed by their underlying structure instance SI. An example is the family of Diffie-Hellman problems which relate two (secret) numbers x and y, the two (public) values  <span class="math">g^x</span>  and  <span class="math">g^y</span> , and the value  <span class="math">g^{xy}</span>  where all exponentiations are computed using the generator g specified in SI. We define a problem family by explicitly describing its problem instances as shown in the next paragraph.</p>

    <p class="text-gray-300"><strong>Problem instance</strong> PI: A list of concrete parameters fully describing a particular instance of a problem family, i.e., a description of the structure instance SI and a tuple (priv, publ, sol) where priv is the tuple of values kept secret from adversaries, publ is the tuple of information publicly known on that problem and sol is the set of possible solutions<sup>4</sup> of that problem instance. When not explicitly stated, we can assume that priv consists always of elements from  <span class="math">\\mathbb{Z}_{|G|}</span> ,</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>The solutions might not be unique, e.g., multiple solution tuples match a given public value in the case of the Representation Problem (See Section 3, Parameter 1).</p>

    <p class="text-gray-300">publ consists of elements from G, and sol is either a set of elements from  <span class="math">\\mathbb{Z}_{|G|}</span>  or from G.</p>

    <p class="text-gray-300">If we take the aforementioned Diffie-Hellman problem for subgroups of  <span class="math">\\mathbb{Z}_p^*</span>  of order q with p and q prime as an example, a problem instance  <span class="math">PI_{DH}</span>  is defined by a tuple</p>

    <p class="text-gray-300"><span class="math">$(((\\mathbb{Z}_{p/q}^*, p, q), (g)), ((x, y), (g^x, g^y), \\{(g^{xy})\\}))</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbb{Z}_{p/q}^*</span>  denotes the parameterized description of the group and its operation, and p,q are the corresponding group parameters. (More details on the group description and parameter are given below when group samplers are introduced.)</p>

    <p class="text-gray-300">This presentation achieves a certain uniformity of description and allows a generic definition of types of problems, i.e., whether it is a decisional or computational variant of a problem. While this might not be obvious right now, it should become clear at the latest in Section 3 below when we give the explicit definition of the different problem families with Parameter 1 and the precise definition of problem types with Parameter 2.</p>

    <p class="text-gray-300">For convenience, we define  <span class="math">PI^{SI}</span> ,  <span class="math">PI^{publ}</span> ,  <span class="math">PI^{priv}</span>  and  <span class="math">PI^{sol}</span>  to be the projection of a problem instance PI to its structure instance, public, private and solution part, respectively. Picking up again above example, this means  <span class="math">PI_{DH}^{SI} := ((\\mathbb{Z}^*_{p/q}, p, q), (g)), PI_{DH}^{priv} := (x, y), PI_{DH}^{publ} := (g^x, g^y), \\text{ and } PI_{DH}^{sol} := \\{g^{xy}\\}, \\text{ respectively.}</span></p>

      <h3 id="sec-2.7" class="text-xl font-semibold mt-8">2.7 Samplers</h3>

    <p class="text-gray-300">In the following, we describe different probabilistic polynomial-time algorithms we use to randomly select (sample) various parameters. Note that these samplers cannot be assumed to be publicly known, i.e., to sample from the corresponding domains adversaries have to construct their own sampling algorithms from publicly known information.</p>

    <p class="text-gray-300"><strong>Group sampler</strong>  <span class="math">SG_{\\mathcal{G}}</span> : A function which, when given a security parameter k as input, randomly selects a group G and returns a corresponding group index. We assume that a group sampler selects groups only of similar nature and type, i.e., there is a general description of a Turing machine which, based on a group index as parameter, implements at least the group operation and the equality test, and specifies how the group elements are represented. An example are the groups pioneered by Schnorr (1991) in his identification and signature schemes and also used in the Digital Signature Standard (DSS) (National Institute of Standards and Technology (NIST) 2000), i.e., unique subgroups of  <span class="math">\\mathbb{Z}_p^*</span>  of order q with p and q prime. The group index would be (p,q) and the description of the necessary algorithms would be taken, e.g., from Menezes et al. (1997). Note that, in this example, the group index allows the derivation of the group order and the factorization thereof. However, it cannot be assumed that the group index &mdash; the only information besides the description of the Turing machine which will be always publicly known about the group &mdash; allows to derive such knowledge on the group order in general.</p>

    <p class="text-gray-300">The set of groups possibly returned by a group sampler, i.e.,  <span class="math">[SG_{\\mathcal{G}}]</span> , is called in the sequel a <strong>group family</strong>  <span class="math">\\mathcal{G}</span>  and is required to be infinite. To make the specific group family  <span class="math">\\mathcal{G}</span>  more explicit in the sampler we often label the sampler accordingly as  <span class="math">SG_{\\mathcal{G}}</span> , e.g., for above example the sampler would be named  <span class="math">SG_{\\mathbb{Z}_{p/q}^*}</span> .</p>

    <p class="text-gray-300">Furthermore, the set of possible groups G returned by  <span class="math">SG_{\\mathcal{G}}</span>  for a given fixed security parameter k, i.e.,  <span class="math">[SG_{\\mathcal{G}}(1^k)]</span> , is called <strong>group siblings</strong>  <span class="math">\\mathcal{G}_{SG(k)}</span> . This represents the groups of a given family  <span class="math">\\mathcal{G}</span>  with approximately the same &quot;security&quot;. We assume that the group operation and equality test for the groups in  <span class="math">\\mathcal{G}_{SG(k)}</span>  can be computed efficiently (in k); yet the underlying problem is supposedly asymptotically hard.</p>

    <p class="text-gray-300">Slightly restricting the class of samplers, we require that the order |G| of all  <span class="math">G \\in \\mathcal{G}_{SG(k)}</span>  is approximately the same. In particular, we assume that the order can be bounded in the security parameter, i.e.,  <span class="math">\\exists d_1, d_2 &gt; 0 \\ \\forall k &gt; 1 \\ \\forall G \\in \\mathcal{G}_{SG(k)} : k^{d_1} \\leq \\log{(|G|)} \\leq k^{d_2}.^5</span>  For Schnorr signatures, in the example given above, a group sampler might choose the random primes p and q with  <span class="math">|q| \\approx 2k</span>  and p = rq + 1 for an integer r sufficiently large to make DL hard to compute in security parameter k. See Menezes et al. (1997) and Odlyzko (2000) for the state-of-the-art algorithms for computing discrete logarithms and Lenstra and Verheul (2001) for a methodology on how to choose parameters (as a function of the security parameter k), illustrated concretely for group families such as  <span class="math">\\mathbb{Z}_p^*</span>  or elliptic curves.</p>

    <p class="text-gray-300">Generator sampler Sg: A function which, when given a description of a group G for a fixed group family, randomly selects a generator  <span class="math">g \\in G</span> . We assume that Sg has always access somehow, e.g., via an oracle, to the factorization of the group order. This information is required by the sampler as the group index might not be sufficient to find generators efficiently. This covers the situation where an honest party chooses the group as well as the generator but keeps the factorization of the group order secret. However, it also implies that the factorization of the order should in general be public when the adversary chooses the generators.</p>

    <p class="text-gray-300">Note that the number of generators is  <span class="math">\\varphi(|G|)</span>  and, due to requirements on group orders mentioned above, always super-polynomial in the security parameter k: Given the lower bound  <span class="math">\\forall n \\geq 5 : \\varphi(n) &gt; n/(6\\log(\\log(n)))</span>  (Fact 2.102, Menezes et al. 1997) and our size restrictions on |G| we have asymptotically the following relation:  <span class="math">\\varphi(|G|)/|G| &gt; 1/O(\\log k) &gt; 1/k</span> .</p>

    <p class="text-gray-300"><strong>Problem instance sampler</strong>  <span class="math">SPI_{\\mathcal{P}}</span> : A function indexed by a problem family  <span class="math">\\mathcal{P}</span>  which, when given a description of a structure instance SI as input, ran-</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>This restriction is mainly for easier treatment in various reductions and is not a hindrance in practical applications: On the one hand, the upper bound is tight (larger groups cannot have efficient group operations). On the other hand, the common approach in choosing a safe group order, e.g., as proposed by Lenstra and Verheul (2001), will relate the group order closely to the negligible probability of guessing a random element correctly, and hence result in exponential order.</p>

    <p class="text-gray-300">domly selects a problem instance PI. Similarly to Sg, we assume that  <span class="math">SPI_{\\mathcal{P}}</span>  gets always access to the factorization of the group order. Furthermore,  <span class="math">SPI_{\\mathcal{P}}</span>  gets also access to the discrete logarithms among the different generators in SI. This is required for some problem families, e.g., IE and RP(n). In most cases and in all examples considered here, this corresponds to randomly selecting priv and deriving publ and sol from it. For example, a problem instance sampler  <span class="math">SPI_{DH}</span>  for the Diffie-Hellman problem family would return a tuple  <span class="math">(SI, ((x, y), (g^x, g^y), \\{(g^{xy})\\}))</span>  with x and y randomly picked from  <span class="math">\\mathbb{Z}_{|G|}</span>  and g taken from SI. When the specific problem family  <span class="math">\\mathcal{P}</span>  is not relevant or clear from the context we abbreviate  <span class="math">SPI_{\\mathcal{P}}</span>  to SPI.</p>

    <p class="text-gray-300">Note that the running time of the samplers is always polynomially bounded in the security parameter k.<sup>7</sup></p>

    <p class="text-gray-300">If not stated explicitly we can always assume a uniform distribution of the sampled elements in the corresponding domains, as done in most cases of cryptographic applications. The rare exceptions are cases such as the c-DLSE assumption (Patel and Sundaram 1998; Gennaro 2000), an assumption on the difficulty of taking discrete logarithms when the random exponents are taken only from a small set, i.e.,  <span class="math">\\mathbb{Z}_{2^c}</span>  with  <span class="math">c = \\omega(\\log \\log |G|)</span>  instead of  <span class="math">\\mathbb{Z}_{|G|}</span> , or the Diffie-Hellman Indistinguishability (DHI) assumptions introduced by Canetti (1997). The difficulty of these assumptions is not necessarily their individual specification, e.g., c-DLSE could be defined by suitably restricting the domain of the sol part of a DL problem instance. The deeper problem is that proving relations among these and other assumptions seems to require very specific tools, e.g., for randomization and analysis of resulting success probabilities, and are difficult to generalize as desirable for a classification as presented here. However, it might be worthwhile to investigate in future work whether these cases can be addressed by treating the sampling probability distribution as an explicit parameter of the classification. To make this extension promising, one would have to first find a suitable categorization of sampling probability distributions which: (1) captures the assumptions currently not addressed, and (2) offers tools assisting in proving reductions in a generalizable fashion.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Parameters of DL-based Assumptions</h2>

    <p class="text-gray-300">In defining assumptions, a cryptographer has various degrees of freedom related to the concrete mathematical formulation of the assumption, e.g., what kind of attackers are considered or over what values the probability spaces are defined.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^6&lt;/sup&gt;</span>  As a practical consequence, it means that for such problem families either this information has to be public, e.g., the group index should allow the derivation of the factorization of the order, or the group and generators are chosen by the same party which samples the problem instance.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^7&lt;/sup&gt;</span> For SG this holds trivially as we required samplers to be polynomial-time in their inputs. The input of Sg are the outputs of a single call of a machine (SG) polynomially bounded by k and, therefore, can be polynomially upper bounded in k. As the class of polynomials is closed under polynomial composition this holds also for Sg and, using similar reasoning, also for SPI.</p>

    <p class="text-gray-300">To shed some light in these degrees of freedom we classify intractability assumptions for problems related to DL and relevant to many cryptographic applications. We identify the following orthogonal parameters. Additionally, we give for each of these parameters in a corresponding sublist different values which can produce significantly different assumptions.</p>

    <p class="text-gray-300">1. <strong>Problem family</strong>: The following problem families are useful (and often used) for cryptographic applications. As mentioned in Section 2.6 we define the problem family (or more precisely their problem instances) by a structure instance SI (described abstractly by G and  <span class="math">g_i</span> 's) and a tuple (priv, publ, sol):</p>

    <p class="text-gray-300"><strong>DL</strong> (Discrete Logarithm):</p>

    <p class="text-gray-300"><span class="math">$PI_{DL} := ((G, g), ((x), (g^x), \\{(x)\\})).</span>$</p>

    <p class="text-gray-300"><strong>DH</strong> (Diffie-Hellman):</p>

    <p class="text-gray-300"><span class="math">$PI_{DH} := ((G,g),((x,y),(g^x,g^y),\\{(g^{xy})\\}))</span>$</p>

    <p class="text-gray-300"><strong>GDH</strong>(n) (Generalized Diffie-Hellman for  <span class="math">n \\geq 2</span> ):</p>

    <p class="text-gray-300"><span class="math">$PI_{\\mathrm{GDH}(n)} := ((G,g), ((x_i|i \\in \\{1,\\ldots,n\\}), (g^{\\prod_{i \\in I} x_i} \\mid I \\subset \\{1,\\ldots,n\\}), \\{(g^{\\prod_{i=1}^n x_i})\\})),</span>$</p>

    <p class="text-gray-300">where n is a fixed parameter.<sup>8</sup></p>

    <p class="text-gray-300"><strong>SE</strong> (Square-Exponent):</p>

    <p class="text-gray-300"><span class="math">$PI_{SE} := ((G,g),((x),(g^x),\\{(g^{x^2})\\})).</span>$</p>

    <p class="text-gray-300"><strong>IE</strong> (Inverse-Exponent):</p>

    <p class="text-gray-300"><span class="math">$PI_{\\text{IE}} := ((G, g), ((x), (g^x), \\{(g^{x^{-1}})\\})).</span>$</p>

    <p class="text-gray-300">Note that for elements  <span class="math">x&#x27; \\in \\mathbb{Z}_{|G|} \\setminus \\mathbb{Z}_{|G|}^*</span>  the value  <span class="math">x^{-1}</span>  is not defined. Therefore,  <span class="math">PI_{\\mathrm{IE}}^{priv}</span>  (= (x)) has to contain an element of  <span class="math">\\mathbb{Z}_{|G|}^*</span> , contrary to the previously mentioned problem families where priv consists of elements from  <span class="math">\\mathbb{Z}_{|G|}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{RP}(n)</span>  (Representation Problem for  <span class="math">n \\geq 2</span> ):</p>

    <p class="text-gray-300"><span class="math">$PI_{\\mathrm{RP}(n)} := ((G, g_1, \\dots, g_n), ((x_i \\mid i \\in \\{1, \\dots, n\\}), (\\prod_{i=1}^n g_i^{x_i}), \\{(x_i&#x27; \\mid i \\in \\{1, \\dots, n\\}) \\mid (x_i&#x27; \\in \\mathbb{Z}_{|G|}) \\wedge (\\prod_{i=1}^n g_i^{x_i&#x27;} = \\prod_{i=1}^n g_i^{x_i})\\})),</span>$</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span> A slightly generalized form  <span class="math">\\mathrm{GDH}(n(k))</span>  would allow n to be a function in k. However, this function can grow at most logarithmically (otherwise the tuple would be of super-polynomial size!)</p>

    <p class="text-gray-300">where n is a fixed parameter.<sup>9</sup></p>

    <p class="text-gray-300">IAE (Inverted Additive Exponent Problem):</p>

    <p class="text-gray-300"><span class="math">$PI_{\\text{IAE}} := ((G, g), ((x, y), (g^{1/x}, g^{1/y}), \\{(g^{1/(x+y)})\\})).</span>$</p>

    <p class="text-gray-300">Similar to IE,  <span class="math">PI_{\\text{IAE}}^{priv}</span>  (= (x, y)) consists of elements from  <span class="math">\\mathbb{Z}^*_{|G|}</span> . Additionally, it has to hold that  <span class="math">x + y \\in \\mathbb{Z}^*_{|G|}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>2. <strong>Problem type</strong>: Each problem can be formulated in three variants.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C (Computational): For a given problem instance PI an algorithm  <span class="math">\\mathcal{A}</span>  succeeds if and only if it can solve PI, i.e.,  <span class="math">\\mathcal{A}(\\dots, PI^{publ}) \\in PI^{sol}</span> . For the Diffie-Hellman problem family this means that  <span class="math">\\mathcal{A}</span>  gets  <span class="math">g^x</span>  and  <span class="math">g^y</span>  as input and the task is to compute  <span class="math">g^{xy}</span> . There is a small twist in the meaning of  <span class="math">\\mathcal{A}(\\dots, PI^{publ}) \\in PI^{sol}</span> : As |G| is not necessarily known,  <span class="math">\\mathcal{A}</span>  might not be able to represent elements of  <span class="math">\\mathbb{Z}_{|G|}</span>  required in the solution set uniquely in their &quot;principal&quot; representation as elements of  <span class="math">\\{0,\\dots,|G|-1\\}</span> . Therefore, we allow  <span class="math">\\mathcal{A}</span>  in these cases to return elements of  <span class="math">\\mathbb{Z}</span>  and we implicitly reduce them  <span class="math">\\operatorname{mod}|G|</span> .</li>
      <li>D (Decisional): For a given problem instance  <span class="math">PI_0</span> , a random problem instance  <span class="math">PI_1</span>  chosen with the same structure instance using the corresponding problem instance sampler and a random bit b, the algorithm  <span class="math">\\mathcal{A}</span>  succeeds if and only if it can decide whether a given solution chosen randomly from the solution set of one of the two problem instances corresponds to the given problem instance, i.e.,  <span class="math">\\mathcal{A}(\\ldots, PI^{publ}, sol_c)) = b</span>  where  <span class="math">sol_c \\stackrel{\\mathcal{R}}{\\leftarrow} PI_b^{sol}</span> . For the Diffie-Hellman problem family this means that  <span class="math">\\mathcal{A}</span>  gets  <span class="math">g^x</span> ,  <span class="math">g^y</span>  and  <span class="math">g^c</span>  (where c is either xy or x'y' for  <span class="math">x&#x27;, y&#x27; \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span> ) as input and the task is to decide whether  <span class="math">g^c</span>  is  <span class="math">g^{xy}</span>  or not.</li>
      <li>M (Matching): For two given problem instances  <span class="math">PI_0</span>  and  <span class="math">PI_1</span>  and a random bit b, the algorithm  <span class="math">\\mathcal{A}</span>  succeeds if and only if it can correctly associate the given solutions with their corresponding problem instances, i.e.,  <span class="math">\\mathcal{A}(\\ldots,PI_0^{publ},PI_1^{publ},sol_b,sol_{\\bar{b}})=b</span>  where  <span class="math">sol_0\\stackrel{\\mathcal{R}}{\\leftarrow}PI_0^{sol}</span>  and  <span class="math">sol_1\\stackrel{\\mathcal{R}}{\\leftarrow}PI_1^{sol}</span> . For the Diffie-Hellman problem family this means that  <span class="math">\\mathcal{A}</span>  gets  <span class="math">g^{x_0}</span> ,  <span class="math">g^{y_0}</span> ,  <span class="math">g^{x_1}</span> ,  <span class="math">g^{y_1}</span> ,  <span class="math">g^{x_by_b}</span>  and  <span class="math">g^{x_{\\bar{b}}y_{\\bar{b}}}</span>  as input and the task is to predict b.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup>Similar to  <span class="math">\\mathrm{GDH}(n)</span>  one can also define here a slightly generalized form  <span class="math">\\mathrm{RP}(n(k))</span> . In this case one can allow n(k) to grow even polynomially.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{10}&lt;/sup&gt;</span> This definition differs subtly from most other definitions of decisional problems: Here the distribution of the challenge  <span class="math">sol_c</span>  is for b=1, i.e., the random &quot;wrong&quot; challenge, according to the distribution of sol induced by SPI whereas most others consider it to be a (uniformly chosen) random element of G. Taking DIE or DDH with groups where the order has small factors these distributions are quite different! Conceptually, the definition here seems more reasonable, e.g., in a key exchange protocol you distinguish a key from an arbitrary key, not an arbitrary random value. It also addresses nicely the case of samplers with non-uniform distributions.</p>

    <p class="text-gray-300">Initially, only computational assumptions, which follow naturally from informal security requirements, were considered in cryptography. For example, a key exchange protocol should prevent the complete recovery of the key which is usually the solution part of an assumption. However, the later formalization of security requirements, in particular semantic security (Goldwasser and Micali 1984), requires often the indistinguishability of random variables. Taking again the example of a key exchange protocol, it was realized that if you do not want to make strong requirements on the particular use of exchanged keys but allow the modular and transparent composition of key exchange protocols with other protocols, e.g., for secure sessions, it is essential that an exchanged key is indistinguishable from random keys, i.e., not even partial information on the key is leaked. While this does not necessarily imply decisional assumptions, such assumptions might be indispensable for efficient systems: There is an efficient encryption scheme secure against adaptive adversaries under the Decisional Diffie-Hellman assumption (Cramer and Shoup 1998). Nonetheless, no system is known today which achieves the same security under a similar computational assumption in the standard model.<sup>11</sup> Finally, the matching variant was introduced by Frankel, Tsiounis, and Yung (1996) where it showed to be a useful tool to construct fair off-line cash. Handschuh, Tsiounis, and Yung (1999) later showed that the matching and the decisional variants of Diffie-Hellman are equivalent, a proof which is adaptable also to other problem families.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>3. <strong>Group family</strong>: Various group families are used in cryptographic applications. The following list contains some of the more common ones. For brevity we do not mention the specific parameter choice as a function of k. We refer you to, e.g., Lenstra and Verheul (2001), for concrete proposals:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{Z}_p^*</span> : The multiplicative groups of integers modulo a prime p with group order  <span class="math">\\varphi(p)</span>  having at least one large prime factor. The group index is p.</li>
      <li><span class="math">\\mathbb{Z}_{p/q}^*</span> : The subgroups of  <span class="math">\\mathbb{Z}_p^*</span>  of prime order q. The group index is the tuple (p,q).</li>
      <li><span class="math">\\mathbb{Z}_n^*</span> : The multiplicative groups of integers modulo a product n of two (or more) large primes p and q with p-1 and q-1 containing at least one large prime factor. The group index is n.<sup>12</sup></li>
      <li><span class="math">\\mathbb{QR}_n^*</span> : The subgroups of  <span class="math">\\mathbb{Z}_n^*</span>  formed by the quadratic residues with n product of two large safe<sup>13</sup> primes. The group index is n.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>There are efficient schemes known in the random oracle model (Bellare and Rogaway 1993), e.g., OAEP (Bellare and Rogaway 1995; Boneh 2001; Shoup 2001; Fujisaki et al. 2001). However, this model is strictly weaker than the standard model and has a number of caveats (Canetti et al. 1998).</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{12}&lt;/sup&gt;</span> This means that the order of the group is secret if we assume factoring n is hard.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup>A prime p is a safe prime when p-1=2p' and  <span class="math">p&#x27; \\in \\mathbb{P}</span> .</p>

    <p class="text-gray-300">Ea,b/<sup>p</sup> : The elliptic curves over <sup>p</sup> with p and |Ea,b| prime with group index (a, b, p).</p>

    <p class="text-gray-300">The concrete choice of a group family has significant practical impact on aspects such as computation or bandwidth efficiency or suitability for a particular hardware but discussing this goes beyond the scope of this document, namely comparing assumptions. In this scope, it is mostly sufficient to classify simple and abstract properties of the chosen family and the public knowledge about a given group. We established the following two general criteria:</p>

    <p class="text-gray-300">(a) The factorization of the group order contains</p>

    <p class="text-gray-300">lprim: large prime factors (at least one). Formally, it has to hold that (with being the set of prime numbers):</p>

    <p class="text-gray-300"><span class="math">$\\forall d &gt; 0 \\exists k_0 \\forall k &gt; k_0 \\forall G \\in \\mathcal{G}_{SG(k)} \\exists p \\in \\mathbb{P} \\exists r \\in \\mathbb{N} : |G| = pr \\land p &gt; k^d,</span>$</p>

    <p class="text-gray-300">nsprim: no small prime factor. Formally, the following has to hold:</p>

    <p class="text-gray-300"><span class="math">$\\forall d &gt; 0 \\exists k_0 \\forall k &gt; k_0 \\forall G \\in \\mathcal{G}_{SG(k)} \\not\\exists p \\in \\mathbb{P} \\exists r \\in \\mathbb{N} : |G| = pr \\land p &lt; k^d,</span>$</p>

    <p class="text-gray-300">prim: only a single and large prime factor.</p>

    <p class="text-gray-300">Note that this is a strict hierarchy and later values imply earlier ones. There would also be an obvious fourth value, namely the order contains no large factor. However, in such cases no reasonable DL based assumption seems possible (Pohlig and <a href="#page-76-9">Hellman</a> 1978; <a href="#page-76-10">Pollard</a> 1978).</p>

    <p class="text-gray-300">(b) The group order is publicly</p>

    <p class="text-gray-300">o: unknown,</p>

    <p class="text-gray-300">o: known,</p>

    <p class="text-gray-300">fct: known including its complete<sup>14</sup> factorization.</p>

    <p class="text-gray-300">We assume any such public knowledge to be encoded in the description returned by a group sampler SG. Note that in practice the group order is never completely unknown: at least an efficiently computable upper bound B(|G|) can always be derived, e.g., from the bit-length of the representation of group elements. This can be exploited, e.g., in achieving random self-reducibility <sup>15</sup> (Blum and <a href="#page-73-8">Micali</a> 1984) for DDH even in the case where the order is not known <a href="#page-73-4">(Boneh</a> 1998).</p>

    <p class="text-gray-300">The cryptographic application will determine which of above properties hold, e.g., a verifiable group generation will quite likely result in a publicly known factorization.</p>

    <p class="text-gray-300"><sup>14</sup>If the order is known then small prime factors can always be computed. Insofar the case here extends the knowledge about the factorization also to large prime factors.</p>

    <p class="text-gray-300"><sup>15</sup>Informally, a problem is random self-reducible if solving any problem instance can be reduced to solving the problem on a random instance, i.e., when given an instance x we can efficiently randomize it to a random instance x<sup>R</sup> and can efficiently derive (derandomize) the solution for x from the solution returned by an oracle call on xR.</p>

    <p class="text-gray-300">Furthermore, note that the group families given above implicitly fix the properties of the group order factorization ( <span class="math">\\mathbb{Z}_p^*</span> : lprim;  <span class="math">\\mathbb{Z}_{p/q}^*</span> : prim;  <span class="math">\\mathbb{Z}_n^*</span> : lprim;  <span class="math">\\mathbb{QR}_n^*</span> : nsprim;  <span class="math">E_{a,b}/\\mathbb{F}_p</span> : prim), and the public knowledge about it ( <span class="math">\\mathbb{Z}_p^*</span> : o;  <span class="math">\\mathbb{Z}_{p/q}^*</span> : fct;  <span class="math">\\mathbb{Z}_n^*</span> :  <span class="math">\\overline{o}</span> ;  <span class="math">\\mathbb{QR}_n^*</span> :  <span class="math">\\overline{o}</span> ;  <span class="math">E_{a,b}/\\mathbb{F}_p</span> : fct).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Computational capability of adversary: Potential algorithms solving a problem have to be computationally limited for number-theoretic assumptions to be meaningful (otherwise we could never assume their nonexistence). Here, we only consider probabilistic polynomial-time algorithms (called adversaries in the following). The adversary can be of</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>u</strong> (Uniform complexity): There is a single probabilistic Turing machine  <span class="math">\\mathcal{A}</span>  which for any given finite input returns a (not necessarily correct) answer in polynomial time in its input length. As the complexity of Turing machines is measured in the bit-length of the inputs the inputs should be neither negligible nor super-polynomial in the security parameter k, otherwise the algorithm might not be able to write out the complete desired output or might become too powerful. To address this issue one normally passes an additional input  <span class="math">1^k</span>  to  <span class="math">\\mathcal{A}</span>  to lower bound the complexity and makes sure that the other inputs can be polynomially upper bounded in k. In all cases considered here, the inputs in the assumptions are already proportional to the security parameters, see remarks on the size of groups and on the runtime of samplers in Section 2.7. Therefore we can safely omit  <span class="math">1^k</span>  in the inputs of  <span class="math">\\mathcal{A}</span> .</li>
      <li>n (Non-uniform complexity): There is an (infinite) family of Turing machines  <span class="math">(\\mathcal{A}_k \\mid k \\in \\mathbb{N})</span>  with description size and running time of  <span class="math">\\mathcal{A}_k</span>  bounded by a polynomial in the security parameter k. Equivalent alternatives are a (single) Turing Machine with polynomial running time and an additional (not necessarily computable) family of auxiliary inputs polynomially bounded by the security parameter, or families of circuits with the number of gates polynomially bounded by the security parameter,  <span class="math">^{17}</span>  respectively.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Uniform assumptions are (in many cases strictly) weaker than corresponding non-uniform assumptions as any uniform algorithm is also a non-uniform one. Furthermore, all uniform black-box reductions map to the non-uniform case (but not necessarily vice-versa!) and henceforth most uniform proofs should map to their non-uniform counterpart. This makes uniform assumptions preferable over non-uniform assumptions (e.g., honest users are normally uniform and weaker assumptions are always prefer-</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{16}&lt;/sup&gt;</span> The remarks on input length and runtime mentioned above for uniform complexity also apply here.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{\\&lt;/sup&gt;hat{1}7}</span> In the case of circuits the bound on the running time automatically follows and does not have to be explicitly restricted.</p>

    <p class="text-gray-300">able over stronger ones). However, uniform assumptions also assume uniform adversaries which is a weaker adversary model than the model considering non-uniform adversaries. Furthermore, there are proofs which only work in a non-uniform model.</p>

    <p class="text-gray-300">Further, potentially interesting yet currently ignored, attacker capabilities would be bounds on space instead of (or in addition) to time. Adaptive adversaries do not seem of concern for pure assumptions.</p>

    <p class="text-gray-300">Ideally, one would consider larger, i.e., less restricted, classes of adversaries than the strictly polynomial-time one following from the definition from Section 2.3. It would seem more natural, e.g., to require polynomial behavior only on inputs valid for a given assumption or to allow algorithms, e.g., Las Vegas algorithms, with no a-priori bound on the runtime. <sup>18</sup> Unfortunately, such classes are difficult to define properly and even harder to work with. However, as for each adversary of these classes there seems to be a closely related (yet not necessarily black-box constructible) strictly polynomial-time adversary with similar success probability, this restriction seems of limited practical relevance.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&quot;Algebraic knowledge&quot;: A second parameter describing the adversary's computational capabilities relates to the adversary's knowledge on the group family. It can be one of the following:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\sigma</span>  (Generic): This means that the adversary does not know anything about the structure (representation) of the underlying algebraic group. More precisely this means that all group elements are represented using an <strong>encoding function</strong>  <span class="math">\\sigma(\\cdot)</span>  drawn randomly from the set  <span class="math">\\Sigma_{G,g}</span>  of bijective<sup>19</sup> functions  <span class="math">\\mathbb{Z}_{|G|} \\to G</span> . Group operations can only be performed via the addition and inversion<sup>20</sup> oracles  <span class="math">\\sigma(x+y) \\leftarrow \\sigma_+(\\sigma(x),\\sigma(y))</span>  and  <span class="math">\\sigma(-x) \\leftarrow \\sigma_-(x)</span>  respectively, which the adversary receives as a black box (Shoup 1997; Nechaev 1994) together with  <span class="math">\\sigma(1)</span> , the generator.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If we use  <span class="math">\\sigma</span>  in the following, we always mean the (not further specified) random encoding used for generic algorithms with a group G and generator g implied by the context. In particular, by  <span class="math">\\mathcal{A}^{\\sigma}</span>  we refer to a generic algorithm. To prevent clutter in the presentation, we do not explicitly encode group elements passed as inputs to such generic</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{18}&lt;/sup&gt;</span> However, we would have to restrict the considerations to polynomial time runs when measuring the success probability of adversaries.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>Others, e.g., Babai and Szemer&eacute;di (1984) and Boneh and Lipton (1996), considered the more general case where elements are not necessarily unique and there is a separate equality oracle. However, that model is too weak to cover some important algorithms, e.g., Pohlig and Hellman (1978), which are intuitively &quot;generic&quot;. Furthermore, the impossibility results mentioned later still hold when transferred to the more general case.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{20}\\&lt;/sup&gt;mathrm{Computing}</span>  inverses is usually efficient only when the group order is known. However, note that all impossibility results &mdash; the main use of generic adversaries &mdash; considered later hold naturally also without the inversion oracle.</p>

    <p class="text-gray-300">algorithms. However, they should all be considered suitable encoded with  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">(marked by absence of  <span class="math">\\sigma</span> ) (Specific): In this case the adversary can also exploit special properties (e.g., the encoding) of the underlying group.</p>

    <p class="text-gray-300">This separation is interesting for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Tight lower bounds on the complexity of some DL-based assumptions can lead to provably hard assumptions in the generic model (Shoup 1997; Maurer and Wolf 1998b). No such results are known in the standard model. However, similar to the random oracle model (Bellare and Rogaway 1993) the generic model is idealized and related pitfalls lure when used in a broader context than simple assumptions (Fischlin 2000).</li>
      <li>A number of algorithms computing discrete logarithms are generic in their nature. Two prominent ones are Pohlig-Hellman (1978) and Pollard- <span class="math">\\rho</span>  (1978) paired with Shanks Baby-Step Giant-Step optimization. Furthermore, most reductions are generic.</li>
      <li>However, exploiting some structure in the group can lead to faster algorithms, e.g., for finite fields there is the class of index-calculus methods and in particular the generalized number field sieve (GNFS) (Gordon 1993b; Schirokauer 1993) with sub-exponential expected running time.</li>
      <li>Nonetheless, for many group families, e.g., elliptic curves, no specific algorithms are known which compute the discrete logarithms better than the generic algorithms mentioned above.</li>
    </ul>

    <p class="text-gray-300">Note that a generic adversary can always be transformed to a specific adversary but not necessarily vice-versa. Therefore, a reduction between two generic assumptions is also a reduction between the specific counterparts of the two assumptions. However, proofs of the hardness of generic assumptions or the non-existence of relations among them do <em>not</em> imply their specific counterparts!</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&quot;Granularity of probability space&quot;: Depending on what part of the structure instance is a-priori fixed (i.e., the assumption has to hold for all such parameters) or not (i.e., the parameters are part of the probability space underlying an assumption) we can distinguish among the following situations:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1 (Low-granular): The group family (e.g., prime order subgroups of  <span class="math">\\mathbb{Z}_p^*</span> ) is fixed but not the specific structure instance (e.g., parameters p, q and generators  <span class="math">g_i</span>  for the example group family given above).</li>
      <li><strong>m</strong> (Medium-granular): The group (e.g., p and q) but not the generators  <span class="math">g_i</span>  are fixed.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">h (High-granular): The group as well as the generators g<sup>i</sup> are fixed.</p>

    <p class="text-gray-300">An assumption defines a family of probability spaces D<sup>i</sup> , where the index i is the tuple of k and, depending on granularity, group and generator, i.e., all parameters with an all-quantifier in the assumption statement. Each probability space D<sup>i</sup> is defined over problem instances, random coins for the adversary, and, again depending on granularity, groups and generators. Note that for a given k there are always only polynomially many D<sup>i</sup> . In the sequel we use the term probability space instance (PSI) for a single probability space D<sup>i</sup> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Success probability: This parameter gives an (asymptotic) upper bound on how large a success probability we tolerate from an adversary. The success probability is measured over the family of probability space instances Di . Violation of an assumption means that there exists an algorithm A whose success probability &alpha;(k) reaches or exceeds this bound for infinitely many k in respect to at least one of the corresponding probability space instances D<sup>i</sup> .</li>
    </ol>

    <p class="text-gray-300">The upper bound and the corresponding adversary can be classified in the following types:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1 (Perfect): The strict upper bound on the success probability is 1. Therefore, a perfect adversary algorithm A with success probability &alpha;(k) has to solve the complete probability mass of infinitely many D<sup>i</sup> , i.e., &alpha;(k) 6&lt;<sup>&infin;</sup> 1.</li>
      <li>(1&minus;1/poly(k)) (Strong): The bound is defined by the error probability which has to be non-negligible. Therefore, a strong adversary algorithm A has to be successful for infinitely many D<sup>i</sup> with overwhelming probability., i.e., if &alpha;(k) is the success probability of A then 1 &minus; &alpha;(k) 6&ge;<sup>&infin;</sup> 1/poly(k).</li>
      <li>(Invariant): The strict upper bound is a fixed and given constant 0 &lt; &lt; 1. Therefore, the success probability &alpha;(k) of an invariant adversary algorithm A has to be larger than for infinitely many Di , i.e., &alpha;(k) 6&lt;<sup>&infin;</sup> .</li>
      <li>1/poly(k) (Weak): All non-negligible functions are upper bounds, i.e., only negligible success probabilities are tolerated. Therefore, a weak adversary algorithm A has to be successful with a not negligible fraction of the probability mass of D<sup>i</sup> for infinitely many D<sup>i</sup> , i.e., if &alpha;(k) is the success probability of A then &alpha;(k) 6&lt;<sup>&infin;</sup> 1/poly(k).</li>
    </ul>

    <p class="text-gray-300">An assumption requiring the nonexistence of perfect adversaries corresponds to worst-case complexity, i.e., if the assumption holds then there are at least a few hard instances. However, what is a-priori required in most cases in cryptography is a stronger assumption requiring the nonexistence of even weak adversaries, i.e., if the assumption holds then most problem instances are hard.</p>

    <p class="text-gray-300">The classification given above is certainly not exhaustive. The exploration of new problem families, e.g., related to arbitrary multivariate functions in the exponents as investigated by Kiltz (2001), might require additional values for the existing parameters. This can be done without much impact on the classification itself and other results. However, the need for a new dimension such as adding probability distributions as a separate parameter (see Section 2.7) would be of much larger impact. Nevertheless, from the current experience, above classification seems quite satisfactory.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Defining Assumptions</h2>

    <p class="text-gray-300">Using the parameters and corresponding values defined in the previous section we can define intractability assumptions in a compact and precise way.</p>

    <p class="text-gray-300">The notation for a given assumption is</p>

    <p class="text-gray-300"><span class="math">$s-f^{a}(c:c;g:g;f:\\mathcal{G})</span>$</p>

    <p class="text-gray-300">where for each parameter there is a placeholder $X which is instantiated by the labels corresponding to the value of that parameter in the given assumption. The placeholders and values (with &mdash; denoting that this value can be absent in the notation and has the same meaning as a corresponding wild card) are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>$s: The algorithm's success probability ($ <span class="math">s \\in \\{1, (1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> ).</li>
      <li>$t: The problem type ( <span class="math">t \\in \\{C, D, M\\}</span> ).</li>
      <li>$\\mathcal{P}$: The problem family ($\\mathcal{P} \\in {\\text{DL}, \\text{DH}, \\text{GDH}(n), \\text{SE}, \\text{IE}, \\text{RP}(n), \\text{IAE}}).</li>
      <li>$a: The algebraic knowledge of the algorithm ( <span class="math">a \\in \\{\\sigma, -\\}</span> ).</li>
      <li>$c: The algorithm's complexity ( <span class="math">c \\in \\{u, n\\}</span> ).</li>
      <li>$g: The granularity of the probability space ( <span class="math">g \\in \\{h, m, l\\}</span> ).</li>
      <li>$\\mathcal{G}$: The group family ($\\mathcal{G} \\in {\\text{lprim}, nsprim, prim, -} \\times {\\overline{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operatorname{\\operato</li>
    </ul>

    <p class="text-gray-300">This is best illustrated in an example: The term</p>

    <p class="text-gray-300"><span class="math">$1/\\mathsf{poly}(k)</span>$
-DDH <span class="math">^{\\sigma}(c:u;g:h;f:prim)</span></p>

    <p class="text-gray-300">denotes the decisional (D) Diffie-Hellman (DH) assumption in prime-order groups (f:prim) with weak success probability  <span class="math">(1/\\mathsf{poly}(k))</span> , limited to generic algorithms  <span class="math">(\\sigma)</span>  of uniform complexity (c:u), and with high granularity (g:h).</p>

    <p class="text-gray-300">To refer to classes of assumptions we use <strong>wild cards</strong> (*) and sets  <span class="math">(\\{\\cdots\\})</span>  of parameter values, e.g.,</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;21</sup>The parameters for  <span class="math">\\mathcal{G}</span>  are not completely orthogonal in the sense that some combinations do not exist, e.g., (prim, &middot;,  <span class="math">\\mathbb{QR}_n^*</span> ), and some result in nonsensical assumptions, e.g., (&middot;, fct,  <span class="math">\\mathbb{Z}_n^*</span> ). Nonetheless, the assumptions still can be defined and insofar this is not really of concern here.</p>

    <p class="text-gray-300"><span class="math">$\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}CDH^{\\sigma}(c:u;g:h;f:*)</span>$</p>

    <p class="text-gray-300">denotes the class of computational (C) Diffie-Hellman (DH) assumptions with uniform complexity (c:u), limited to generic algorithms  <span class="math">(\\sigma)</span> , with high-granular probability space (g:h), with some error  <span class="math">(\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\})</span>  and based on an arbitrary group family (f:*).</p>

    <p class="text-gray-300">Let us turn now to the meaning of an assumption described by above notation: By stating that an assumption  <span class="math">s-tt^{a}(c;s;g;s;f;t)</span>  holds, we believe that asymptotically no algorithm of complexity c and algebraic knowledge c an solve (random) problem instances of a problem family P with problem type c thosen from groups in P with sufficient (as specified by P) success probability where the probability space is defined according to granularity P.</p>

    <p class="text-gray-300">The precise and formal definitions follow naturally and quite mechanically. In defining an assumption we always require a bound  <span class="math">k_0</span>  for the asymptotic behavior which says that beyond that bound no adversary will be successful. As further &quot;ingredients&quot; there are polynomials defined by their maximal degree  <span class="math">d_1</span> ,  <span class="math">d_2</span>  and  <span class="math">d_3</span>  which bind the error probability, time and description of programs, respectively. Finally, we require a machine (or family thereof)  <span class="math">\\mathcal{A}(\\mathcal{A}_i)</span>  trying to solve the problem, and various quantifiers specifying (using the various samplers) the required parameters for a problem instance PI to solve.</p>

    <p class="text-gray-300">Finally, we denote the class of uniform complexity adversaries by  <span class="math">\\mathcal{UPTM}</span>  and the corresponding class of generic adversaries by  <span class="math">\\mathcal{UPTM}^{\\sigma}</span> . The class of non-uniform complexity and generic non-uniform complexity adversaries is denoted similarly by  <span class="math">\\mathcal{NPTM}</span>  and  <span class="math">\\mathcal{NPTM}^{\\sigma}</span> , respectively.</p>

    <p class="text-gray-300">To illustrate the formal details of assumptions and to provide a feel for the various parameters we offer three sets of examples. In each set we vary one of the parameters, namely: (1) the computational complexity, (2) the less obvious and often overlooked granularity parameter, and (3) the success probability. The complete details on how to derive the formal assumption statement from the parameters can be found in Appendix A:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Weak computational DL assumptions in the generic model, a group order with at least one large prime factor and the two variants of complexity measures (see Parameter 4). Remember that  <span class="math">PI_{DL} := (SI, ((x), (g^x), \\{(x)\\}))</span> ,  <span class="math">PI_{DL}^{publ} := (g^x)</span>  and  <span class="math">PI_{DL}^{sol} := \\{(x)\\}</span> . Further, let  <span class="math">SG_{\\mathcal{G}}</span>  be a group sampler of some group family  <span class="math">\\mathcal{G}</span>  where the groups have an order with at least one large prime factor.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Assumption  <span class="math">1/\\mathsf{poly}(k)</span> -CDL <span class="math">^{\\sigma}</span> (c:u; g:h; f:lprim), i.e., the uniform complexity variant:</li>
    </ul></li>
    </ul>

    <pre><code class="language-text">\\begin{aligned} &amp;\\forall \\mathcal{A}^{\\sigma} \\in \\mathcal{UPTM}^{\\sigma}; \\\\ &amp;\\forall d_{1} &gt; 0; \\ \\exists k_{0}; \\ \\forall k &gt; k_{0}; \\\\ &amp;\\forall G \\in [SG_{\\mathcal{G}}(1^{k})]; \\\\ &amp;\\forall g \\in [Sg(G)]; \\\\ &amp;SI \\leftarrow (G,g); \\end{aligned}
&amp;\\mathbf{Prob}[\\mathcal{A}^{\\sigma}(\\mathcal{C},SI,PI_{\\mathrm{DL}}^{publ}) \\in PI_{\\mathrm{DL}}^{sol} :: \\\\ &amp;\\sigma \\stackrel{\\mathcal{R}}{\\leftarrow} \\Sigma_{G,g}; \\\\ &amp;PI_{\\mathrm{DL}} \\leftarrow SPI_{\\mathrm{DL}}(SI); \\\\ &amp;\\mathcal{C} \\stackrel{\\mathcal{R}}{\\leftarrow} \\mathcal{U} \\\\ &amp;] &lt; 1/k^{d_{1}}. \\end{aligned}
</code></pre>

    <p class="text-gray-300">(b) Same setting as above except now with a non-uniform adversary  <span class="math">(1/\\mathsf{poly}(k)\\text{-}\\mathrm{CDL}^{\\sigma}(c:n;g:h;f:lprim))</span> :</p>

    <pre><code class="language-text">\\forall (\\mathcal{A}_{i}^{\\sigma} \\mid i \\in \\mathbb{N}) \\in \\mathcal{NPTM}^{\\sigma};
\\forall d_{1} &gt; 0; \\; \\exists k_{0}; \\; \\forall k &gt; k_{0};
\\forall G \\in [SG_{\\mathcal{G}}(1^{k})];
\\forall g \\in [Sg(G)];
SI \\leftarrow (G, g);
\\mathbf{Prob}[\\mathcal{A}_{k}^{\\sigma}(\\mathcal{C}, SI, PI_{\\mathrm{DL}}^{publ}) \\in PI_{\\mathrm{DL}}^{sol} ::
\\sigma \\stackrel{\\mathcal{R}}{\\leftarrow} \\Sigma_{G,g};
PI_{\\mathrm{DL}} \\leftarrow SPI_{\\mathrm{DL}}(SI);
\\mathcal{C} \\stackrel{\\mathcal{R}}{\\leftarrow} \\mathcal{U}
| &lt; 1/k^{d_{1}}.
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Weak decisional DH assumption variants for prime order subgroups of  <span class="math">\\mathbb{Z}_p^*</span>  with varying granularity. Recall that  <span class="math">PI_{\\mathrm{DH}} := (SI, ((x,y), (g^x, g^y), \\{(g^{xy})\\}))</span> ,  <span class="math">PI_{DH}{}^{publ} := (g^x, g^y)</span>  and  <span class="math">PI_{DH}{}^{sol} := \\{(g^{xy})\\}</span> .</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Assumption 1/poly(k)-DDH(c:u; g:h; f: <span class="math">\\mathbb{Z}_{p/q}^*</span> ), i.e., with high granularity:</li>
    </ul></li>
    </ul>

    <pre><code class="language-text">\\forall \\mathcal{A} \\in \\mathcal{UPTM};
         \\forall d_1 &gt; 0; \\ \\exists k_0; \\ \\forall k &gt; k_0;
         \\forall G \\in [SG_{\\mathbb{Z}_{p/q}^*}(1^k)];
         \\forall g \\in [Sg(G)];
         SI \\leftarrow (G, g);
         (|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\mathrm{DH/0}}^{publ},sol_{\\mathrm{DH/c}})=b::
                 b \\stackrel{\\mathcal{R}}{\\leftarrow} \\{0,1\\};
                  PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                  PI_{\\mathrm{DH/1}} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                  sol_{\\mathrm{DH/c}} \\xleftarrow{\\mathcal{R}} PI_{\\mathrm{DH/b}}{}^{sol};
                 \\mathcal{C} \\xleftarrow{\\mathcal{R}} \\mathcal{U}
              ]-1/2[\\cdot 2] &lt; 1/k^{d_1}.
                                                  except
                         above
                                                                                                  with
                                                                                                                        medium
                                                                                                                                                     granularity
         (1/\\mathsf{poly}(k)\\text{-DDH}(c:u; g:m; f:\\mathbb{Z}_{p/q}^*)):
         \\forall A \\in \\mathcal{UPTM};
         \\forall d_1 &gt; 0; \\ \\exists k_0; \\ \\forall k &gt; k_0;
         \\forall G \\in [SG_{\\mathbb{Z}_{n/a}^*}(1^k)];
         (|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\mathrm{DH/0}}^{publ},sol_{\\mathrm{DH/c}})=b::
                 g \\leftarrow Sg(G);
                  SI \\leftarrow (G,g);
                 b \\xleftarrow{\\mathcal{R}} \\{0,1\\};
                  PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                  PI_{\\mathrm{DH/1}} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                 sol_{\\mathrm{DH/c}} \\xleftarrow{\\mathcal{R}} PI_{\\mathrm{DH/b}}^{sol};
               \\begin{array}{c|c} \\mathcal{C} \\xleftarrow{\\mathcal{R}} \\overset{&#x27;}{\\mathcal{U}} \\\\ ]-1/2 \\mid \\cdot \\ 2) \\ &lt; 1/k^{d_1}. \\end{array}
(c) As
                           above
                                                      except
                                                                                                          with
                                                                                                                                low
                                                                                                                                                      granularity
                                                                                   now
         (1/\\mathsf{poly}(k)\\text{-}\\mathrm{DDH}(\\mathbf{c}:\\mathbf{u};\\mathbf{g}:\\mathbf{l};\\mathbf{f}:\\mathbb{Z}_{p/q}^*)):
         \\forall A \\in \\mathcal{UPTM};
         \\forall d_1 &gt; 0; \\ \\exists k_0; \\ \\forall k &gt; k_0;
         (|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C}, SI, PI_{\\mathrm{DH/0}}^{publ}, sol_{\\mathrm{DH/c}}) = b ::
                 G \\leftarrow SG_{\\mathbb{Z}_{p/q}^*}(1^k);
                 g \\leftarrow Sg(G);
                  SI \\leftarrow (G, g);
                 b \\stackrel{\\mathcal{R}}{\\leftarrow} \\{0,1\\};
                  PI_{\\mathrm{DH}/0} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                 PI_{\\mathrm{DH/1}} \\leftarrow SPI_{\\mathrm{DH}}(SI);
                 sol_{\\mathrm{DH}/c} \\xleftarrow{\\mathcal{R}} PI_{\\mathrm{DH}/b}^{sol};
              \\begin{array}{c|c} \\mathcal{C} \\xleftarrow{\\mathcal{R}} \\mathcal{U} \\\\ |-1/2 \\mid \\cdot \\ 2) &amp;&lt; 1/k^{d_1}. \\end{array}
</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Matching IE assumptions in  <span class="math">\\mathbb{QR}_n^*</span>  with varying success probability. Recall that  <span class="math">PI_{\\text{IE}} := (SI, ((x), (g^x), \\{(g^{x^{-1}})\\}))</span> ,  <span class="math">PI_{IE}^{publ} := (g^x)</span>  and  <span class="math">PI_{IE}^{sol} := \\{(g^{x^{-1}})\\}</span> .</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Assumption  <span class="math">1/\\mathsf{poly}(k)</span> -MIE(c:u; g:h; f: <span class="math">\\mathbb{QR}_n^*</span> ), i.e., the variant with weak success probability:</li>
    </ul></li>
    </ul>

    <pre><code class="language-text">\\begin{split} &amp;\\forall \\mathcal{A} \\in \\mathcal{UPTM}; \\\\ &amp;\\forall d_1 &gt; 0; \\ \\exists k_0; \\ \\forall k &gt; k_0; \\\\ &amp;\\forall G \\in [SG_{\\mathbb{QR}_n^*}(1^k)]; \\\\ &amp;\\forall g \\in [Sg(G)]; \\\\ &amp;SI \\leftarrow (G,g); \\\\ &amp;(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\mathrm{IE}/0}^{publ},PI_{\\mathrm{IE}/1}^{publ},sol_{\\mathrm{IE}/b},sol_{\\mathrm{IE}/\\bar{b}}) = b :: \\\\ &amp;b \\overset{\\mathcal{R}}{\\leftarrow} \\{0,1\\}; \\\\ &amp;PI_{\\mathrm{IE}/0} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ &amp;PI_{\\mathrm{IE}/1} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ &amp;sol_{\\mathrm{IE}/0} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\mathrm{DH/0}}^{sol}; \\\\ &amp;sol_{\\mathrm{IE}/1} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\mathrm{DH/0}}^{sol}; \\\\ &amp;c \\overset{\\mathcal{R}}{\\leftarrow} \\mathcal{U} \\\\ &amp;] -1/2 \\mid \\cdot 2) \\ &lt; 1/k^{d_1}. \\end{split}
</code></pre>

    <p class="text-gray-300">(b) Same setting as above except now with invariant success probability  <span class="math">\\epsilon</span>  ( <span class="math">\\epsilon</span> -MIE(c:u; g:h; f: <span class="math">\\mathbb{QR}_n^*</span> )):</p>

    <pre><code class="language-text">\\begin{split} &amp;\\forall \\mathcal{A} \\in \\mathcal{UPTM}; \\\\ &amp;\\exists k_0; \\ \\forall k &gt; k_0; \\\\ &amp;\\forall G \\in [SG_{\\mathbb{Q}\\mathbb{R}^*_n}(1^k)]; \\\\ &amp;\\forall g \\in [Sg(G)]; \\\\ &amp;SI \\leftarrow (G,g); \\\\ &amp;(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\mathrm{IE}/0}^{publ},PI_{\\mathrm{IE}/1}^{publ},sol_{\\mathrm{IE}/b},sol_{\\mathrm{IE}/\\bar{b}}) = b :: \\\\ &amp;b \\overset{\\mathcal{R}}{\\leftarrow} \\{0,1\\}; \\\\ &amp;PI_{\\mathrm{IE}/0} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ &amp;PI_{\\mathrm{IE}/1} \\leftarrow SPI_{\\mathrm{IE}}(SI); \\\\ &amp;sol_{\\mathrm{IE}/0} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\mathrm{DH}/0}^{sol}; \\\\ &amp;sol_{\\mathrm{IE}/1} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\mathrm{DH}/1}^{sol}; \\\\ &amp;\\mathcal{C} \\overset{\\mathcal{R}}{\\leftarrow} \\mathcal{U}; \\\\ &amp;|-1/2 \\mid \\cdot 2) &lt; \\epsilon. \\end{split}
</code></pre>

    <p class="text-gray-300">(c) Same setting as above except now with strong success probability  <span class="math">((1-1/\\mathsf{poly}(k))\\text{-MIE}(c:u;g:h;f:\\mathbb{QR}_n^*))</span> :</p>

    <pre><code class="language-text">\\begin{split} &amp;\\forall \\mathcal{A} \\in \\mathcal{UPTM}; \\\\ &amp;\\exists d_1 &gt; 0; \\ \\exists k_0; \\ \\forall k &gt; k_0; \\\\ &amp;\\forall G \\in [SG_{\\mathbb{QR}_n^*}(1^k)]; \\\\ &amp;\\forall g \\in [Sg(G)]; \\\\ &amp;SI \\leftarrow (G,g); \\\\ &amp;(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\operatorname{IE}/0}^{publ},PI_{\\operatorname{IE}/1}^{publ},sol_{\\operatorname{IE}/b},sol_{\\operatorname{IE}/\\bar{b}}) = b :: \\\\ &amp;b \\overset{\\mathcal{R}}{\\leftarrow} \\{0,1\\}; \\\\ &amp;PI_{\\operatorname{IE}/0} \\leftarrow SPI_{\\operatorname{IE}}(SI); \\\\ &amp;PI_{\\operatorname{IE}/1} \\leftarrow SPI_{\\operatorname{IE}}(SI); \\\\ &amp;sol_{\\operatorname{IE}/0} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\operatorname{DH}/0}^{sol}; \\\\ &amp;sol_{\\operatorname{IE}/1} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\operatorname{DH}/1}^{sol}; \\\\ &amp;\\mathcal{C} \\overset{\\mathcal{R}}{\\leftarrow} \\mathcal{U} \\\\ &amp;]-1/2 \\mid \\cdot 2) \\ &lt; (1-1/k^{d_1}). \\end{split}
</code></pre>

    <p class="text-gray-300">(d) Same setting as above except with no tolerated error, i.e., perfect success probability (1-MIE(c:u; g:h; f: <span class="math">\\mathbb{QR}_n^*</span> )):</p>

    <pre><code class="language-text">\\begin{split} &amp;\\forall \\mathcal{A} \\in \\mathcal{UPTM}; \\\\ &amp;\\exists k_0; \\ \\forall k &gt; k_0; \\\\ &amp;\\forall G \\in [SG_{\\mathbb{Q}\\mathbb{R}_n^*}(1^k)]; \\\\ &amp;\\forall g \\in [Sg(G)]; \\\\ &amp;SI \\leftarrow (G,g); \\\\ &amp;(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}(\\mathcal{C},SI,PI_{\\operatorname{IE}/0}^{publ},PI_{\\operatorname{IE}/1}^{publ},sol_{\\operatorname{IE}/b},sol_{\\operatorname{IE}/\\bar{b}}) = b :: \\\\ &amp;b \\overset{\\mathcal{R}}{\\leftarrow} \\{0,1\\}; \\\\ &amp;PI_{\\operatorname{IE}/0} \\leftarrow SPI_{\\operatorname{IE}}(SI); \\\\ &amp;PI_{\\operatorname{IE}/1} \\leftarrow SPI_{\\operatorname{IE}}(SI); \\\\ &amp;sol_{\\operatorname{IE}/0} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\operatorname{DH}/0}^{sol}; \\\\ &amp;sol_{\\operatorname{IE}/1} \\overset{\\mathcal{R}}{\\leftarrow} PI_{\\operatorname{DH}/1}^{sol}; \\\\ &amp;C \\overset{\\mathcal{R}}{\\leftarrow} \\mathcal{U} \\\\ &amp;] -1/2 \\mid \\cdot 2) &lt; 1. \\end{split}
</code></pre>

    <p class="text-gray-300">To express relations among assumptions we use the following operators where P and Q are assumptions as previously defined:</p>

    <p class="text-gray-300"><span class="math">P \\Longrightarrow Q</span>  means that if assumption P holds, so does assumption Q, i.e., P (Q) is a stronger (weaker) assumption than Q (P). Vice-versa, it also means that if there is a polynomially-bounded algorithm  <span class="math">\\mathcal{A}_Q</span>  breaking assumption Q then there is also another polynomially-bounded algorithm  <span class="math">\\mathcal{A}_P</span>  which breaks assumption P. Usually, this is shown in a <strong>black-box reduction</strong> where  <span class="math">\\mathcal{A}_P</span> , or more precisely  <span class="math">\\mathcal{A}_P^{\\mathcal{A}_Q}</span> , breaks assumption P with oracle access to  <span class="math">\\mathcal{A}_Q</span> . As a special case for invariant assumptions, we mean with  <span class="math">\\epsilon</span> - <span class="math">P \\Longrightarrow \\epsilon</span> -Q that it should hold that  <span class="math">\\forall \\epsilon&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in ]0,1[\\exists \\epsilon&#x27;&#x27; \\in</span></p>

    <p class="text-gray-300"> <span class="math">P \\iff Q</span>  means that  <span class="math">P \\implies Q</span>  and  <span class="math">Q \\implies P</span> , i.e., P and Q are assumptions of the same (polynomial) complexity.</p>

    <p class="text-gray-300"><span class="math">P \\xrightarrow{\\alpha&#x27; \\geq f_{\\alpha}(t,\\alpha,|G|,\\dots); \\ t&#x27; \\leq f_{t}(t,\\alpha,|G|,\\dots)} Q \\text{ is used to specify the quality of the reduction, i.e., the concrete security. It means that if assumption } Q \\text{ can be broken in time } t \\text{ and with success probability } \\alpha \\text{ we can break } P \\text{ in time } t&#x27; \\text{ and with success probability } \\alpha&#x27; \\text{ bounded by functions } f_{t} \\text{ and } f_{\\alpha}, \\text{ respectively.}</span>  To measure time, we consider group operations and equality tests having unit-cost each and oracle calls having cost } t. \\text{ Obviously, the cost of group operations, the runtime and the success probability of the oracle, and the size of the groups are not constant but functions depending on the security parameter k, e.g.,  <span class="math">\\alpha</span>  should be written more precisely as  <span class="math">\\alpha(k)</span> . However, for better readability we omit this and all asymptotic aspects in the presentation. For the identical reason, we also cautiously use the  <span class="math">O(\\cdot)</span>  notation even if we slightly lose precision.</p>

    <p class="text-gray-300">Let us illustrate this with the following result from Maurer and Wolf (1996) (for more information on this result see also page 32):</p>

    <p class="text-gray-300"><span class="math">$\\epsilon</span>$
-CDH(c:u; g:h; f:o)  <span class="math">\\xrightarrow{\\alpha&#x27; = \\alpha^3; \\ t&#x27; = 3t + O(\\log(|G|)^2)} \\epsilon</span> -CSE(c:u; g:h; f:o)</p>

    <p class="text-gray-300">This means that with three calls to an oracle breaking  <span class="math">\\epsilon</span> -CSE(c:u; g:h; f:o) and additional  <span class="math">O(\\log (|G|)^2)</span>  group operations we can achieve a success probability of at least  <span class="math">\\alpha^3</span>  in breaking  <span class="math">\\epsilon</span> -CDH(c:u; g:h; f:o) where t and  <span class="math">\\alpha</span>  are the runtime and the success probability of the oracle, respectively.</p>

    <p class="text-gray-300">For simple assumptions, above is interpreted without syntactical conditions on P and Q, i.e., they may be arbitrary assumptions. If a relation refers to assumption classes, i.e., they contain some parameters which are not fully specified and contain wild cards or sets, there is the following syntactical constraint: The parameters which are not fully specified have to be equal for both assumptions P and Q. The meaning is as follows: The relation P OP Q holds for any assumption P' and Q' we can instantiate from P and Q by fixing all not fully specified parameters to any matching value with the additional condition that these values are identical for P' and Q'. To give an example,</p>

    <p class="text-gray-300"><span class="math">$*-CDH^*(c:*;g:\\{h,m\\};f:o) \\implies *-CSE^*(c:*;g:\\{h,m\\};f:o)</span>$</p>

    <p class="text-gray-300">illustrates that the result from Maurer and Wolf mentioned above can be generalized &mdash; as proven later in this paper &mdash; to high and medium granularity with arbitrary success probability, complexity and algebraic knowledge.</p>

    <p class="text-gray-300">Furthermore, if we are referring to oracle-assumptions, i.e., assumptions where we give adversaries access to auxiliary oracles, we indicate it by listing the oracles at the end of the list in the assumption term. For example, the assumption  <span class="math">1/\\mathsf{poly}(k)\\text{-}\\mathsf{CDL}^\\sigma(\\mathsf{c:u};\\mathsf{g:h};\\mathsf{f:lprim};\\mathcal{O}_{1\\text{-}\\mathsf{CDL}(\\mathsf{c:u};\\mathsf{g:h};\\mathsf{f:lprim})})</span>  corresponds to the first assumption statement given in the example list above except that now the adversary also gets access to an oracle breaking the 1-CDL(c:u; g:h; f:lprim) assumption.</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: The impact of granularity</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 The Impact of Granularity</h2>

    <p class="text-gray-300">It would go beyond the scope of this paper to discuss all previously identified parameters and we will focus only on granularity. Before stating the actual results, let us first briefly repeat the practical relevance of granularity as alluded in the introduction. Figure <a href="#page-26-1">1</a> illustrates exemplarily different variants of the probability space for a given security parameter k. The areas labeled with l, m and h represent the algebraic parameters over which low-, medium- and high-granular probability spaces are defined.<sup>22</sup> Assumptions with lower granularity are weaker, and are therefore more desirable in principle. However, not all cryptographic settings can rely on the weaker variants: Consider, for instance, an escrowed anonymous payment system where the bank chooses the system parameters.<sup>23</sup> It would not be appropriate to base the security of such a system a-priori on a low-granular assumption. This is because a cheating bank might try to choose a weak group with trapdoors (easy problem instances) to violate the anonymity of the customer (This case is shown in Figure <a href="#page-26-1">1</a> with a trapdoor group G<sup>&lowast;</sup> and its corresponding easy instances.) Such a strategy might be possible even if the low-granular assumption holds: The assumption would ensure that the overall number of easy problem instances is asymptotically negligible with respect to the security parameter (In Figure <a href="#page-26-1">1</a> weak instances (in area m)</p>

    <p class="text-gray-300"><sup>22</sup>Recall that high-granular probability space is defined over the private parts (secret exponents), the medium-granular over the generators and private parts and finally the low-granular over groups, generators and the private parts.</p>

    <p class="text-gray-300"><sup>23</sup>These are electronic payment systems where a third party can revoke the anonymity of the users under certain circumstances. Because of the revocation ability such systems can offer the users only computationally secure anonymity.</p>

    <p class="text-gray-300">represent exemplarily a negligible portion of the instances of the low-granular space in areal.) Yet, the assumption would not rule out that there are infinitely many weak groups. Therefore, there might not exist a sufficiently large k for which the bank cannot break the assumption.</p>

    <p class="text-gray-300">In contrast, a high-granular (medium-granular) assumption does not hold in our example because as shown in the figure, the fraction of weak instances in area h (m) is not negligible. However, if a high-granular (medium-granular) assumption holds then the trapdoor groups  <span class="math">G^*</span>  in the above example would not exist and the bank could not cheat.</p>

    <p class="text-gray-300">Thus, which of the granularity variants is appropriate in cryptographic protocols depends on how and by whom the parameters are chosen. A priori we have to use a high-granular assumption. Yet, in the following situations we can resort to a weaker less granular assumption: The security requirements of the cryptographic system guarantee that it's in the best (and only) interest of the chooser of the system parameters to choose them properly; the system parameters are chosen by a mutually trusted third party; or the system parameters are chosen in a verifiable random process.<sup>24</sup> Also, at most in these cases we can reasonably assume a group family with the group order and its factorization to be hidden from the public and the adversary. As a consequence, it would seem strange to base a cryptographic system on a high-granular assumption with unknown order factorization: either the system parameters are chosen by an honest party and we could resort to a weaker assumption with lower granularity, or the knowledge of the order and its factorization has to be assumed to be known to the adversary. Furthermore, care has to be taken for DL-related high- and medium-granular assumptions in  <span class="math">\\mathbb{Z}_p^*</span>  and its subgroups. Unless we further constrain the set of valid groups with (expensive) tests as outlined by Gordon (1993a), we require, for a given security parameter, considerably larger groups than for the low granular counterpart of the assumptions. As informally mentioned above, assumptions with lower granularity are weaker than assumption of higher granularity. Formally, this is stated and proven in the following theorem:</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Theorem 5.1</h4>

    <p class="text-gray-300"><span class="math">$*-***(c:*;g:h;f:*) \\implies *-***(c:*;g:m;f:*) \\implies *-***(c:*;g:l;f:*)</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Assume we are given an adversary  <span class="math">\\mathcal{A}</span>  breaking a low-granular assumption for some group and problem family, some problem type, computational complexity, arbitrary algebraic knowledge and success probability. Furthermore, we are given an input I corresponding to an assumption of high- or medium-granular but otherwise identical parameters.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{24}\\&lt;/sup&gt;mathrm{This}</span>  can be done either through a joint generation using random coins (Cachin et al. 2000) or using heuristics such as the one used for DSS key generation (National Institute of Standards and Technology (NIST) 2000).</p>

    <p class="text-gray-300">For the reduction, call A on this input I and return the result. To see that this achieves the desired attack on the medium- or high-granular assumption, note that inputs to an adversary breaking a high- or medium-granular assumption are also valid inputs to a low-granular adversary. Therefore, this reduction is a legitimate attacker from a runtime perspective exactly in the case where the oracle itself is a legitimate attacker. Furthermore, the probability space instances defined by a high- or medium-granular assumption always partition the probability space instances of a low-granular assumption. Therefore, it it is clear that for a perfect adversary A the reduction breaks certainly the high- or medium-granular probability space instances which are part of the low-granular probability space instances which A breaks. As there are by definition of A infinitely many such low-granular probability space instances it automatically follows that for the perfect case the high- and medium-granular assumption is broken, too. By a counting argument this also easily extends to the case of strong, invariant and weak adversaries, i.e., at least some of the high- or medium-granular probability space instances which are part of the low-granular probability space instances broken by A, are broken with the necessary success probability as well.</p>

    <p class="text-gray-300">By an identical argument it follows that a high-granular assumption can be reduced to the corresponding medium-granular assumption. This concludes the theorem.</p>

    <p class="text-gray-300">Remark 5.1. Note that the inverse of above result, a low-granular assumption implies the corresponding high-granular one, does not hold in general: There are always super-polynomially many of the higher-granular probability space instances contained in a given lower-granular instance. Therefore, there might be situations where infinitely many high-granular probability space instances and henceforth the corresponding high-granular assumption &mdash; are broken, yet they form only a negligible subset of the enclosing lower-granular probability space instances and the low-granular assumption can still hold.</p>

    <p class="text-gray-300">However, if for a given granularity there exists a random selfreduction (Blum and <a href="#page-73-8">Micali</a> 1984), then the inverse reduction exists also from that granularity to all higher granularities. As random self-reductions are known for all mentioned problem families and problem types in their medium granularity variant, this equates the medium- and high-granular cases. Unfortunately, no random self-reduction is yet known for low-granular assumptions and achieving such &quot;full&quot; random self-reducibility seems very difficult in general (if not impossible) in number-theoretic settings <a href="#page-73-11">(Boneh</a> 2000) contrary to, e.g., lattice settings used by Ajtai and <a href="#page-73-12">Dwork</a> (1997). &#9702;</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Computational DH, SE and IE</h2>

    <p class="text-gray-300">Maurer and Wolf <a href="#page-76-1">(1996)</a> prove the equivalence between the computational SE and DH assumptions in their uniform and high-granular variant for both perfect and invariant success probabilities.</p>

    <p class="text-gray-300">We briefly review their results, and show that they also hold for weak and strong success probabilities. We then extend these results to medium granularity and prove similar relations between IE and DH.</p>

    <p class="text-gray-300">First however, we will look into how the success probability of oracles can be improved.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Self-Correction</h3>

    <p class="text-gray-300">In the following sections we are mostly concerned with faulty oracles, i.e., oracles which answer with a certain success probability to the legal inputs (inputs with correct distribution over the oracle's input domain). If an oracle has a small but not negligible success probability, one is interested in constructing an efficient algorithm which improves this success probability such that the answers to the legal inputs are almost certainly correct. In other words, one is interested in performing <strong>self-correction</strong> on the faulty oracle.</p>

    <p class="text-gray-300">In our considerations we need to self-correct the faulty CDH oracle to determine the success probability of certain reductions which appear in later sections. Suppose, we are given a faulty CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which on input  <span class="math">((G,g),(g^x,g^y))</span>  outputs  <span class="math">g^{xy}</span>  with a not negligible probability  <span class="math">\\alpha</span> . Then we can construct an efficient algorithm for CDH which outputs the correct answer almost certainly for all legal inputs. One may ask, why not running such an oracle for  <span class="math">O(1/\\alpha)</span>  times until we get a correct answer! However, this is of no help, since in general we cannot determine (decide) whether the output of the oracle is the correct Diffie-Hellman solution or not &ndash; this would mean solving Decisional Diffie-Hellman (DDH) Problem which is assumed to be hard in the underlying group.</p>

    <p class="text-gray-300">Thus, other (more complicated) approaches have been taken to construct self-correctors for computational problems such as CDH.</p>

    <p class="text-gray-300">Maurer and Wolf (1996) and Shoup (1997) give different constructions for CDH self-correctors. For our considerations we will use the result from Shoup 1997 which is formulated in the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 6.1 (Shoup 1997)</strong> Given a CDH oracle with success probability  <span class="math">\\alpha</span> , one can construct a probabilistic algorithm for CDH which, for a given  <span class="math">0 &lt; \\beta &lt; 1</span> , answers correctly to all inputs with probability at least  <span class="math">\\alpha&#x27; = 1 - \\beta</span>  making  <span class="math">O(\\frac{\\log(1/\\beta)}{\\alpha})</span>  queries to the faulty oracle and performing additional  <span class="math">O(\\frac{\\log(1/\\beta)}{\\alpha}) \\log |G| + (\\log |G|)^2</span>  group operations.</p>

    <p class="text-gray-300">Note that Lemma 6.1 does not consider the success probabilities in the asymptotic framework as we introduced in Section 2.2. Thus, for our considerations we suitably adjust this result when self-correcting a weak or invariant oracle to a strong oracle.<sup>25</sup> This is summarized in the following corollary:</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{25} \\&lt;/sup&gt;text{Recall}</span>  that in the asymptotic notion the success probabilities are in fact functions in the security parameter and for weak and invariant oracles we have  <span class="math">\\alpha(k) \\not&lt;_{\\infty} 1/\\text{poly}(k)</span>  and  <span class="math">\\alpha(k) \\not&lt;_{\\infty} \\epsilon</span>  (see Section 3)</p>

    <h2 id="sec-misc-2" class="text-2xl font-bold">Corollary 6.1</h2>

    <pre><code class="language-text"> \\begin{array}{c} \\{(1-1/\\mathsf{poly}(k))\\}\\text{-}\\mathrm{CDH}(\\mathbf{c}:*;\\mathbf{g}:\\{\\mathbf{h},\\mathbf{m}\\ \\};\\mathbf{f}:\\mathbf{o})\\\\ \\xrightarrow{\\alpha&#x27;\\geq 1-1/2^k;\\ t&#x27;=O(\\frac{tk}{\\alpha})+O(\\frac{k\\log|G|}{\\alpha}+(\\log|G|)^2)}\\\\ &amp;\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad
</code></pre>

    <p class="text-gray-300">Proof. We give the proof for weak oracles and the proof for the invariant oracle immediately follows.</p>

    <p class="text-gray-300">Assume, we are given a CDH oracle with weak success probability  <span class="math">\\alpha(k)</span> . In our framework for success probabilities it is reasonable to self-correct this oracle to a strong oracle, i.e., an oracle with success probability  <span class="math">\\alpha&#x27;(k)</span>  where  <span class="math">1-\\alpha&#x27;(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">By the straight forward (and naive) application of Lemma 6.1 one may set  <span class="math">\\beta(k) := 1/2^k</span>  (k security parameter) and self-correct oracle's success probability to  <span class="math">\\alpha&#x27;(k) \\geq 1 - 1/2^k</span>  implying  <span class="math">1 - \\alpha&#x27;(k) \\leq 1/2^k</span> . Since  <span class="math">1/2^k</span>  is asymptotically smaller than the inverse of any polynomial we can write  <span class="math">1/2^k &lt;_{\\infty} 1/\\text{poly}(k)</span> . It follows that  <span class="math">1 - \\alpha&#x27;(k) &lt;_{\\infty} 1/\\text{poly}(k)</span> . According to Lemma 6.1 the self-correction requires  <span class="math">O(\\frac{k}{\\alpha(k)})</span>  calls to the weak oracle and  <span class="math">O(\\frac{k \\log |G|}{\\alpha(k)} + (\\log |G|)^2)</span>  group operations where we used  <span class="math">\\log(1/\\beta(k)) = \\log(2^k) = k</span> .</p>

    <p class="text-gray-300">However, the above approach is not conform to our framework of success probabilities and does not work directly. The reason is that in general the above self-correction may not provide us with a polynomial time algorithm. It is guaranteed to be polynomial only for those values of k (infinitely many  <span class="math">k_i</span>  by definition) where the success probability  <span class="math">\\alpha(k)</span>  of the weak oracle can be lower bounded by the inverse of some polynomial  <span class="math">p(\\cdot)</span> , but not necessarily for other values of k.<sup>26</sup></p>

    <p class="text-gray-300">To handle this problem, one can define a family of algorithms indexed by a polynomial  <span class="math">p_j(\\cdot)</span>  which runs the self-correction with  <span class="math">p_j(k)</span>  rounds (oracle calls). Thus, all members of this family have the run time  <span class="math">O(p_j(k)t) + O(p_j(k)\\log(|G|) + (\\log|G|)^2)</span> , and therefore are polynomial. Moreover, there are members of this family which satisfy the condition for strong success probability. These are exactly the members for which  <span class="math">kp(\\cdot) &lt;_{\\infty} p_j(\\cdot)</span>  holds. In particular, this holds for the same k values where the condition for the given weak success probability is satisfied.</p>

    <p class="text-gray-300">However, this is an existential argument and not constructive, as in general neither the function  <span class="math">\\alpha(k)</span>  or the  <span class="math">k_i</span>  values are known beforehand nor they can be approximated by querying the oracle in polynomial time.</p>

    <p class="text-gray-300">Hence, in our framework it suffices to self-correct  <span class="math">\\mathcal{O}_{CDH}</span>  such that  <span class="math">\\alpha&#x27;(k) \\not&lt;_{\\infty} 1 - 1/2^k</span>  holds. This implies  <span class="math">1 - \\alpha&#x27;(k) \\not&gt;_{\\infty} 1/2^k</span> , and since  <span class="math">1/2^k &lt;_{\\infty} 1/\\operatorname{poly}(k)</span> , it follows  <span class="math">1 - \\alpha&#x27;(k) \\not\\geq_{\\infty} 1/\\operatorname{poly}(k)</span>  (i.e.,  <span class="math">\\alpha&#x27;(k)</span>  is strong.) This completes the proof.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{26}&lt;/sup&gt;</span>  Note that we might have  <span class="math">\\alpha(k)=0</span>  for infinitely many k values, and since the self-correction costs are proportional to  <span class="math">1/\\alpha(k)</span> , this would lead to exponentially high number of oracle calls and group operations.</p>

    <p class="text-gray-300">Remark 6.1. In the proof of his self-corrector Shoup (1997) assumes that the group order is known. However, by a closer inspection of the proof and the deployment of the techniques used in Remark 7.8 we can drop this requirement. Thus, Corollary 6.1 also holds without requiring the knowledge of the group order.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 CSE versus CDH</h3>

      <h4 id="sec-6.2.1" class="text-lg font-semibold mt-6">6.2.1 High Granular</h4>

    <p class="text-gray-300">We start with the result of Maurer and Wolf (1996) on the equivalence between the computational SE and DH assumptions in their uniform and high-granular variant for perfect and invariant success probabilities. This is formulated in our convention in the following theorem.</p>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">Theorem 6.1 (Maurer and Wolf 1996)</h3>

    <pre><code class="language-text">\\begin{array}{ll} \\epsilon\\text{-CSE}\\left(\\text{c:u;g:h;f:o}\\right) &amp; \\xrightarrow{\\alpha&#x27;=\\alpha;\\ t&#x27;=t+O(\\log|G|)} &amp; \\epsilon\\text{-CDH}\\left(\\text{c:u;g:h;f:o}\\right) \\\\ \\epsilon\\text{-CSE}\\left(\\text{c:u;g:h;f:o}\\right) &amp; \\xleftarrow{\\alpha&#x27;=\\alpha^3;\\ t&#x27;=3t+O(\\log|G|)} &amp; \\epsilon\\text{-CDH}\\left(\\text{c:u;g:h;f:o}\\right) \\end{array}
</code></pre>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">0 &lt; \\epsilon_1 &lt; 1, 0 &lt; \\epsilon_2 &lt; 1</span>  be arbitrary constants. Then the following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Given a CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which breaks  <span class="math">\\epsilon</span> -CDH(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CDH}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  which breaks  <span class="math">\\epsilon</span> -CSE(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , using a single call to  <span class="math">\\mathcal{O}_{CDH}</span>  and  <span class="math">O(\\log |G|)</span>  group operations.</li>
      <li>(b) Given a CSE oracle  <span class="math">\\mathcal{O}_{CSE}</span>  which breaks  <span class="math">\\epsilon</span> -CSE(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_2</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span>  which breaks  <span class="math">\\epsilon</span> -CDH(c:u; g:h; f:o) with success probability  <span class="math">\\alpha_{CDH}(k) \\not&lt;_{\\infty} \\epsilon_2^3</span> , using 3 calls to  <span class="math">\\mathcal{O}_{CSE}</span>  and  <span class="math">O(\\log |G|)</span>  group operations.</li>
    </ul>

    <p class="text-gray-300">From these reductions the theorem immediately follows. Above reductions are achieved as follows:</p>

    <p class="text-gray-300">Case (a) is quite straightforward as the problem instances of SE are a proper subset of the problem instances of DH and the answer can be retrieved in one call to the oracle. In the case of perfect CDH oracle (perfect success probability) the oracle returns  <span class="math">g^{x^2}</span>  on the input  <span class="math">((G,g),(g^x,g^x))</span> . However, in the case of invariant oracle (faulty oracle) care has to be taken that the inputs to the CDH oracle are uniformly distributed over oracle's input domain.<sup>27</sup> This can easily be achieved by randomizing a given tuple  <span class="math">((G,g),(g^x,g^x))</span>  to a random CDH tuple</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;27</sup>Note that the success probability of a faulty oracle holds for randomly and uniformly chosen inputs from the oracle's input domain.</p>

    <p class="text-gray-300"><span class="math">((G,g),(g^{x&#x27;},g^{y&#x27;}))</span> , i.e, randomly self-reducing the problem, as follows: Choose  <span class="math">r_x, r_y \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and set  <span class="math">x&#x27; := x + r_x</span> , and  <span class="math">y&#x27; := y + r_y</span> . The elements  <span class="math">g^{x&#x27;}, g^{y&#x27;}</span>  are randomly and uniformly distributed over G, since due to the randomization, x', y' are randomly and uniformly spread over  <span class="math">\\mathbb{Z}_{|G|}</span> . Note that in the high-granular case an SI = (G, g) fixes a probability space instance (PSI).</p>

    <p class="text-gray-300">Using oracle's answer we can determine the desired result as follows:</p>

    <p class="text-gray-300"><span class="math">$g^{x^2} = \\frac{\\mathcal{O}_{CDH}(g^{x&#x27;}, g^{y&#x27;})}{g^{r_x y + r_y x + r_x r_y}} = \\frac{g^{x&#x27;y&#x27;}}{g^{r_x y + r_y x + r_x r_y}}.</span>$</p>

    <p class="text-gray-300">Success probability: There is a single oracle call and thus for the success probability of  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  we have  <span class="math">\\alpha_{CSE}(k) = \\alpha_{CDH}(k)</span> . Since  <span class="math">\\alpha_{CDH}(k) \\not&lt;_{\\infty} \\epsilon_1</span>  it follows  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_1</span> .</p>

    <p class="text-gray-300">Efficiency: There is only one oracle call and to solve the DSE instance we need to compute  <span class="math">g^{r_x}, g^{r_y}, (g^y)^{r_x}, (g^x)^{r_y}, g^{r_x r_y}</span>  and  <span class="math">(g^{r_x y + r_y x + r_x r_y})^{-1}</span> . For exponentiations we can use, e.g., the square and multiply method requiring  <span class="math">O(\\log |G|)</span>  group operations. If we assume that the group order is known (denoted by the place holder &quot;f:o&quot;) we can efficiently compute the inverse of the group elements using  <span class="math">O(\\log |G|)</span>  group operations.</p>

    <p class="text-gray-300">Case (b) is slightly more involved. The key observation is that</p>

    <p class="text-gray-300"><span class="math">$g^{(x+y)^2} = g^{2xy}g^{x^2}g^{y^2}.</span>$</p>

    <p class="text-gray-300">This implies</p>

    <p class="text-gray-300"><span class="math">$(g^{xy})^2 = g^{2xy} = g^{(x+y)^2}(g^{x^2})^{-1}(g^{y^2})^{-1} = g^{(x+y)^2 - x^2 - y^2}.</span>$</p>

    <p class="text-gray-300">Therefore, we can solve CDH with three oracle calls (one for each of  <span class="math">g^{(x+y)^2}</span> ,  <span class="math">g^{x^2}</span>  and  <span class="math">g^{y^2}</span> ), the computation of inverses of  <span class="math">g^{x^2}</span>  and  <span class="math">g^{y^2}</span>  and the square root of  <span class="math">g^{2xy} = (g^{xy})^2</span> .</p>

    <p class="text-gray-300">As before, for the faulty oracle we have to uniformly spread the given input over oracle's input domain using randomization. Furthermore, we have to make sure now that all oracle calls are (statistically) independent to be able to make concrete statements on the success probability of  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span> . Both we achieve with independent blinding factors  <span class="math">r_i \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and computing  <span class="math">g^{u^2}</span>  as  <span class="math">\\mathcal{O}_{CSE}(g^{(u+r_i)})/(g^u)^{2r_i}g^{r_i^2}</span> . Note that  <span class="math">g^{(u+r_i)}</span>  are randomly and uniformly distributed group elements, since  <span class="math">u+r_i</span>  are randomly and uniformly distributed over  <span class="math">\\mathbb{Z}_{|G|}</span> .</p>

    <p class="text-gray-300">Success probability: There are 3 independent calls to the CSE oracle and thus the success probability of  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span>  is  <span class="math">\\alpha_{CDH}(k) = \\alpha_{CSE}(k)^3</span> . Since  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_2</span>  it follows  <span class="math">\\alpha_{CDH}(k) \\not&lt;_{\\infty} \\epsilon_2^3</span> .</p>

    <p class="text-gray-300">That is,  <span class="math">\\forall (x&#x27;,y&#x27;) \\in \\mathbb{Z}^2_{|G|}</span>  and  <span class="math">\\forall (x,y) \\in \\mathbb{Z}^2_{|G|}</span>  there exists exactly one pair  <span class="math">(r_x,r_y) \\in \\mathbb{Z}^2_{|G|}</span>  such that the equations  <span class="math">x&#x27; = x + r_x</span>  and  <span class="math">y&#x27; = x + r_y</span>  hold.</p>

    <p class="text-gray-300">Efficiency: Assuming the group order |G| is known, one can efficiently compute the inverse and square roots of elements in G. Computing the inverse of elements requires  <span class="math">O(\\log |G|)</span>  group operations. For computing square roots there two possible cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) The group order |G| is odd, i.e.,  <span class="math">\\gcd(|G|, 2) = 1</span> . In this case, we can use the following general result: For d with  <span class="math">\\gcd(|G|, d) = 1</span>  and  <span class="math">a \\in G</span>  the equation  <span class="math">x^d = a</span>  has the unique solution  <span class="math">x = a^c</span>  where  <span class="math">dc \\equiv 1 \\mod |G|</span> . The required number of group operations for computing this is in the order of  <span class="math">O(\\log |G|)</span> .    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Thus, one can determine the (unique) square root of  <span class="math">a = (g^{xy})^2</span>  by computing  <span class="math">c \\equiv 2^{-1} \\mod |G|</span>  and then  <span class="math">g^{xy} = a^c</span> . As mentioned above, the total cost is in the order of  <span class="math">O(\\log |G|)</span>  group operations.</li>
    </ul></li>
      <li>(ii) The group order |G| is even. Thus, there exist two square roots. To compute these roots, one can apply the methods from Wolf 1999 (Lemma 11.4 and Theorem 11.5) where the (maximal) cost is in the order of  <span class="math">O(\\log |G|)</span>  group operations.</li>
    </ul>

    <p class="text-gray-300">The two square roots of a are  <span class="math">g^{xy}</span>  and  <span class="math">g^{xy+|G|/2}</span> . To find out which one is the correct square root of a, we proceed as follows: Assume,  <span class="math">|G| = 2^e s</span>  where  <span class="math">\\gcd(s,p) = 1</span> . Apply the Pohlig-Hellman algorithm to compute x, y and  <span class="math">xy \\mod 2^e</span> . This requires  <span class="math">O(\\log |G|)</span>  group operations.<sup>29</sup> Since  <span class="math">2^e \\not\\mid |G|/2</span>  we have  <span class="math">xy \\not\\equiv xy + |G|/2 \\mod 2^e</span> , and so we can determine the correct root  <span class="math">g^{xy}</span>  by computing the discrete logarithm of one of the roots  <span class="math">\\gcd 2^e</span> .</p>

    <p class="text-gray-300">The costs per oracle call are in the order of  <span class="math">O(\\log |G|)</span>  group operations for computing the square roots, and  <span class="math">O(\\log |G|)</span>  group operations for exponentiation and computing the inverses. Hence, for 3 oracle calls the total costs can be expressed by  <span class="math">O(\\log |G|)</span>  group operations.</p>

    <p class="text-gray-300">Next, we extend this result to all other variants related to success probability (weak, strong) and adversary's computational complexity (non-uniform) as stated in the following Theorem:</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Theorem 6.2</h4>

    <p class="text-gray-300">
<span class="math">$*-\\text{CSE}(\\text{c:*};\\text{g:h};\\text{f:o}) \\xrightarrow{\\alpha&#x27;=\\alpha;\\ t&#x27;=t+O(\\log|G|)} *-\\text{CDH}(\\text{c:*};\\text{g:h};\\text{f:o})</span>$</p>

    <p class="text-gray-300"><span class="math">$*-\\text{CSE}(\\text{c:*};\\text{g:h};\\text{f:o}) \\xrightarrow{\\alpha&#x27;=\\alpha^3;\\ t&#x27;=3t+O(\\log(|G|))} *-\\text{CDH}(\\text{c:*};\\text{g:h};\\text{f:o})</span>$</p>

    <p class="text-gray-300"><span class="math">^{29}\\mathrm{Let}\\prod p_i^{e_i}</span>  be the prime factorization of the group order |G|. Then using the so-called Pohlig-Hellman decomposition (Pohlig and Hellman 1978) combined with baby-step giant-step one can compute the discrete logarithm x of  <span class="math">b=g^x</span>  in G by  <span class="math">O(\\sum e_i(\\log |G|+\\sqrt{p_i}\\log p_i))</span>  group operations if memory space for storing  <span class="math">\\lceil \\sqrt{p_i} \\rceil</span>  group elements is available (see also Wolf (1999)) Here the discrete logarithm modulo  <span class="math">2^e</span>  is to be computed, i.e., for  <span class="math">p_i=2</span>  and  <span class="math">e_i=e</span> . For this, one requires  <span class="math">O(e(\\log |G|+\\sqrt{2}\\log 2))=O(\\log |G|)</span>  group operations.</p>

    <p class="text-gray-300"><em>Proof.</em> We consider only the variants related to the weak and strong success probabilities since the other variants (perfect and invariant) are handled by Theorem 6.1.</p>

    <p class="text-gray-300">Weak oracles  <span class="math">(\\alpha_{CDH}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability in both reductions is also weak: In the first reduction, we have  <span class="math">\\alpha_{CSE}(k) = \\alpha_{CDH}(k)</span>  implying  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . In the second reduction, we have  <span class="math">\\alpha_{CDH}(k) = \\alpha_{CSE}(k)^3</span>  which is a power of a not negligible function resulting in a not negligible function. It follows  <span class="math">\\alpha_{CDH}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Strong oracles  <span class="math">(1 - \\alpha_{CDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability in both cases is also strong: We use the result of Lemma 6.2 stating that if a strong oracle is called polynomially (and independently) many times, the resulting success probability is also strong: In the first reduction there is a single oracle call, and in the second case there is a constant number of oracle calls (3 calls). Hence, the error probability of the algorithm is in both cases not non-negligible, i.e.,  <span class="math">1 - \\alpha_{CDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Efficiency: is the same as in Theorem 6.1.</p>

    <p class="text-gray-300">The following lemma formulates the fact that if a strong oracle is called polynomially (and independently) many times, the resulting success probability is also strong.</p>

    <p class="text-gray-300"><strong>Lemma 6.2</strong> Let  <span class="math">k \\in \\mathbb{N}</span> ,  <span class="math">\\alpha(k)</span>  be a function  <span class="math">\\mathbb{N} \\to [0,1]</span>  and b,d&gt;0 some real constants. Then the following holds:</p>

    <p class="text-gray-300"><span class="math">$1 - \\alpha(k) \\not \\geq_\\infty 1/\\mathsf{poly}(k) \\implies 1 - \\alpha(k)^{bk^d} \\not \\geq_\\infty 1/\\mathsf{poly}(k).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Due to the definition we have</p>

    <p class="text-gray-300"><span class="math">$1-\\alpha(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k) \\implies \\forall c&gt;0 \\ \\forall k_0 \\ \\exists k_1&gt;k_0: \\alpha(k_1)&gt;1-\\frac{1}{k_1^c}.</span>$</p>

    <p class="text-gray-300">It follows</p>

    <p class="text-gray-300"><span class="math">$\\forall b &gt; 0 \\ \\forall d &gt; 0 \\ \\forall c &gt; 0 \\ \\forall k_0 \\ \\exists k_1 &gt; k_0 : \\alpha(k_1)^{bk_1^d} &gt; (1 - \\frac{1}{k_1^c})^{bk_1^d}.</span>$</p>

    <p class="text-gray-300">Now, for any b&gt;0 and any d'&gt;d&gt;0 there exists  <span class="math">k&#x27;_0\\in\\mathbb{N}</span>  such that for all  <span class="math">k&gt;k&#x27;_0</span>  the relation  <span class="math">1\\leq bk^d\\leq k^{d&#x27;}</span>  holds. It follows</p>

    <p class="text-gray-300"><span class="math">$\\forall b &gt; 0 \\ \\forall d &gt; 0 \\ \\forall d &gt; 0 \\ \\forall c &gt; 0 \\ \\forall c &gt; 0 \\ \\forall k_0 &gt; k_0&#x27; \\ \\exists k_1 &gt; k_0 : \\alpha(k_1)^{bk_1^d} &gt; (1 - \\frac{1}{k_1^c})^{k_1^{d&#x27;}}.</span>$</p>

    <p class="text-gray-300">According to Lemma 6.3 below, for  <span class="math">k \\in \\mathbb{N}</span>  and  <span class="math">c \\geq d&#x27;</span>  the following holds:  <span class="math">(1 - \\frac{1}{k^c})^{k^{d&#x27;}} \\geq 1 - \\frac{1}{k^{c-d&#x27;}}</span> . Since c is arbitrary and since we can write c' := c - d' &gt; 0 it follows:</p>

    <p class="text-gray-300"><span class="math">$\\forall b &gt; 0 \\ \\forall d &gt; 0 \\ \\forall c&#x27; &gt; 0 \\ \\forall k &gt; k&#x27;_0 \\ \\exists k_1 &gt; k&#x27;_0 : \\alpha(k_1)^{bk_1^d} &gt; 1 - \\frac{1}{k_1^{c&#x27;}}.</span>$</p>

    <p class="text-gray-300">This implies  <span class="math">1 - \\alpha(k)^{bk^d} \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span>  and the proof is completed.</p>

    <p class="text-gray-300">The next lemma provides us with a useful lower bound which we apply in some proofs (as in the proof of Lemma 6.2).</p>

    <p class="text-gray-300"><strong>Lemma 6.3</strong> Let  <span class="math">k \\in \\mathbb{N}</span> . Then for all real constants d' &gt; 0 and c &gt; 0 with c &gt; d' the following holds:</p>

    <p class="text-gray-300"><span class="math">$(1 - \\frac{1}{k^c})^{k^{d&#x27;}} \\ge 1 - \\frac{k^{d&#x27;}}{k^c} = 1 - \\frac{1}{k^{c-d&#x27;}}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> First, we stress that for  <span class="math">a \\in \\mathbb{R}, a &gt; -1</span>  and  <span class="math">n \\in \\mathbb{N}</span> , one can apply the Bernoulli inequality  <span class="math">(1+a)^n \\ge 1+na</span> , and the claim follows immediately (set  <span class="math">a := -\\frac{1}{k^c}</span>  and  <span class="math">n := k^{d&#x27;}</span> .)</p>

    <p class="text-gray-300">We prove the claim for  <span class="math">n := k^{d&#x27;} \\in \\mathbb{R}</span> : For k = 1 this relation obviously holds. One way to see that it also holds for k &gt; 1 is as follows: Consider the expressions  <span class="math">k^{d&#x27;} \\ln(1 - 1/k^c)</span>  and  <span class="math">\\ln(1 - 1/k^{c-d&#x27;})</span> . We expand them using</p>

    <p class="text-gray-300"><span class="math">$\\ln(1-x) = -[x + x^2/2 + x^3/3 + \\dots + x^n/n + \\dots]</span>$</p>

    <p class="text-gray-300">for  <span class="math">-1 \\le x &lt; 1</span> .</p>

    <p class="text-gray-300">The expansion of the first expression is</p>

    <p class="text-gray-300"><span class="math">$k^{d&#x27;} \\ln(1 - \\frac{1}{k^c}) = -k^{d&#x27;} \\left[ \\frac{1}{k^c} + \\frac{1}{2k^{2c}} + \\frac{1}{3k^{3c}} + \\dots + \\frac{1}{nk^{nc}} + \\dots \\right]</span>$
<span class="math">$= -\\left[ \\frac{1}{k^{c-d&#x27;}} + \\frac{1}{2k^{2c-d&#x27;}} + \\frac{1}{3k^{3c-d&#x27;}} + \\dots + \\frac{1}{nk^{nc-d&#x27;}} + \\dots \\right]</span>$</p>

    <p class="text-gray-300">where  <span class="math">x := 1/k^c &lt; 1</span>  that is  <span class="math">k^c &gt; 1</span> .</p>

    <p class="text-gray-300">Expanding the other expression we obtain</p>

    <p class="text-gray-300"><span class="math">$\\ln(1 - \\frac{1}{k^{c-d&#x27;}}) = -\\left[\\frac{1}{k^{c-d&#x27;}} + \\frac{1}{2k^{2(c-d&#x27;)}} + \\frac{1}{3k^{3(c-d&#x27;)}} + \\dots + \\frac{1}{nk^{n(c-d&#x27;)}} + \\dots\\right].</span>$</p>

    <p class="text-gray-300">where  <span class="math">x := 1/k^{c-d&#x27;} &lt; 1</span>  that is  <span class="math">k^{d&#x27;} &lt; k^c</span> .</p>

    <p class="text-gray-300">Next we compute the difference between these expansions:</p>

    <p class="text-gray-300"><span class="math">$\\Delta(k) := k^{d&#x27;} \\ln(1 - \\frac{1}{k^c}) - \\ln(1 - \\frac{1}{k^{c-d&#x27;}})</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\underbrace{\\left[\\left(-\\frac{1}{2k^{2c-d&#x27;}} + \\frac{1}{2k^{2(c-d&#x27;)}}\\right) + \\left(-\\frac{1}{3k^{3c-d&#x27;}} + \\frac{1}{3k^{3(c-d&#x27;)}}\\right)\\right]}_{\\delta_3}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\dots + \\underbrace{\\left(-\\frac{1}{nk^{nc-d&#x27;}} + \\frac{1}{nk^{n(c-d&#x27;)}}\\right) + \\dots\\right]}_{\\delta_{-}}.</span>$</p>

    <p class="text-gray-300">For k &gt; 1, c &gt; d' &gt; 0 each difference term  <span class="math">\\delta_n</span>  is positive, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\delta_n = \\left(-\\frac{1}{nk^{nc-d&#x27;}} + \\frac{1}{nk^{n(c-d&#x27;)}}\\right) = \\frac{1}{nk^{nc-d&#x27;}}(-1 + (k^{d&#x27;})^{n-1}) &gt; 0.</span>$</p>

    <p class="text-gray-300">and we can conclude  <span class="math">\\Delta &gt; 0</span> . Thus for k &gt; 1 and c &gt; d' we can write</p>

    <p class="text-gray-300"><span class="math">$k^{d&#x27;}\\ln(1-\\frac{1}{k^c}) &gt; \\ln(1-\\frac{1}{k^{c-d&#x27;}})</span>$</p>

    <p class="text-gray-300">and by applying the exponential function we obtain</p>

    <p class="text-gray-300"><span class="math">$e^{k^{d&#x27;}\\ln(1-1/k^c)} = \\left(1 - \\frac{1}{k^c}\\right)^{k^{d&#x27;}} &gt; e^{\\ln(1-1/k^{c-d&#x27;})} = 1 - \\frac{1}{k^{c-d&#x27;}}.</span>$</p>

    <p class="text-gray-300">and this completes the proof.</p>

      <h4 id="sec-6.2.2" class="text-lg font-semibold mt-6">6.2.2 Medium Granular</h4>

    <p class="text-gray-300">Until now we have proved the equivalence between CDH and CSE for their high-granular variants. The next theorem shows that this relation also holds for medium granularity.</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Theorem 6.3</h4>

    <p class="text-gray-300">*-CSE(c:*; g:m; f:o)
<span class="math">$\\xrightarrow{\\alpha&#x27; = \\alpha; \\ t&#x27; = t + O(\\log |G|)}</span>$
*-CDH(c:*; g:m; f:o)
*-CSE(c:*; g:m; f:o)
<span class="math">$\\xrightarrow{\\alpha&#x27; = \\alpha^3; \\ t&#x27; = 3t + O(\\log |G|)}</span>$
*-CDH(c:*; g:m; f:o)</p>

    <p class="text-gray-300"><em>Proof.</em> The proof idea of Theorem 6.2 can also be applied here. The only thing we have to show is that the necessary randomization in the reduction steps can be extended to the medium granularity variants of CDH and CSE. Note that for the medium-granular probability space a group G fixes a probability space instance (PSI).</p>

    <p class="text-gray-300">CDH: We transform a given CDH input tuple  <span class="math">((G,g),(g^x,g^y))</span>  for a given generator  <span class="math">g \\in G</span>  into a random CDH input tuple  <span class="math">((G,g_*),({g_*}^{x&#x27;},{g_*}^{y&#x27;}))</span>  for a random generator  <span class="math">g_* \\in G</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We choose  <span class="math">r_g \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}, r_x, r_y \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and set  <span class="math">g_* := g^{r_g}, x&#x27; := x + r_x</span> , and  <span class="math">y&#x27; := y + r_y</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We compute the public part of the input to the CDH oracle as</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(g^x)^{r_g}g^{r_gr_x} = g^{r_g(x+r_x)} = (g^{r_g})^{(x+r_x)} = g_*^{x&#x27;}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$(g^y)^{r_g}g^{r_gr_y} = g^{r_g(y+r_y)} = (g^{r_g})^{(y+r_y)} = g_*^{y&#x27;}.</span>$</p>

    <p class="text-gray-300">The tuple  <span class="math">((G, g_*), (g_*, g_*^{x&#x27;}, g_*^{y&#x27;}))</span>  has the correct distribution for CDH oracle. This is because (i)  <span class="math">g_*</span>  is a random group generator, and (ii)  <span class="math">g_*^{x&#x27;}, g_*^{y&#x27;}</span>  are randomly and uniformly distributed elements of G since, due to the randomization, x', y' are randomly and uniformly spread over  <span class="math">\\mathbb{Z}_{|G|}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We unblind the result of the CDH oracle as</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lcl} (g_*^{x&#x27;y&#x27;})^{r_g^{-1}}/((g^x)^{r_y}(g^y)^{r_x}g^{r_xr_y}) &amp; = &amp; (g^{x&#x27;y&#x27;})^{r_g}r_g^{-1}/((g^x)^{r_y}(g^y)^{r_x}g^{r_xr_y}) \\\\ &amp; = &amp; g^{(xy+xr_y+yr_x+r_xr_y)}/g^{(xr_y+yr_x+r_xr_y)} \\\\ &amp; = &amp; g^{xy}. \\end{array}</span>$</p>

    <p class="text-gray-300">CSE: We transform a given CSE input  <span class="math">((G, g), (g^x))</span>  for a given generator  <span class="math">g \\in G</span>  into a random CSE input  <span class="math">((G, g_*), (g_*^{x&#x27;}))</span>  for a random generator  <span class="math">g_* \\in G</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We choose  <span class="math">r_g \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}, r_x \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and set  <span class="math">g_* := g^{r_g}</span>  and  <span class="math">x&#x27; := x + r_x</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We compute the public part of the input to the CSE oracle as</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(g^x)^{r_g}g^{r_gr_x} = g^{r_g(x+r_x)} = (g^{r_g})^{(x+r_x)} = g_*^{x&#x27;}.</span>$</p>

    <p class="text-gray-300">Similar to the above case, the tuple  <span class="math">((G, g_*), (g_*, g_*^{x&#x27;}))</span>  has the correct input distribution for the DSE oracle. This is because (i)  <span class="math">g_*</span>  is a random group generator, and (ii)  <span class="math">g_*^{x&#x27;}</span>  is a random element of G since, due to the randomization, x' is randomly and uniformly spread over  <span class="math">\\mathbb{Z}_{|G|}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We unblind the result of the CSE oracle as</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{array}{rcl} (g_*{}^{x&#x27;^2})^{r_g^{-1}}/((g^x)^{2r_x}g^{r_x^2}) &amp; = &amp; (g^{x&#x27;^2})^{r_gr_g^{-1}}/((g^x)^{2r_x}g^{r_x^2}) \\\\ &amp; = &amp; g^{(x^2+2xr_x+r_x^2)}/g^{(2xr_x+r_x^2)} \\\\ &amp; = &amp; g^{x^2}. \\end{array}</span>$</p>

    <p class="text-gray-300">The rest of the proof remains the same as the proof of Theorems 6.1 and 6.2.</p>

    <p class="text-gray-300">Remark 6.2. Reduction proofs of a certain granularity can in general be easily applied to the lower granularity variants of the involved assumptions. A sufficient condition is that all involved randomizations extend to the wider probability space associated with the lower granularity parameter. In all the mentioned problem families the random self-reducibility exists for medium granularity and we can transform proofs from a high-granular variant to the corresponding medium-granular variant. However, it does not seem to extend to low-granular variants, since this would require to randomize not only over the public part of the problem instance PI and the generator g but also over the groups G with the same associated security parameter k; this seems impossible to do in the general case and is easily overlooked and can lead to wrong conclusions, e.g., the random self-reducibility as stated by Boneh (1998) doesn't hold as the assumptions are (implicitly) given in their low-granular form.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;30</sup>that is  <span class="math">\\forall (x&#x27;, y&#x27;) \\in \\mathbb{Z}^2_{|G|}, \\forall (x, y) \\in \\mathbb{Z}^2_{|G|}</span>  there exists exactly one pair  <span class="math">(r_x, r_y) \\in \\mathbb{Z}^2_{|G|}</span>  such that the equations  <span class="math">x&#x27; = x + r_x</span> , and  <span class="math">y&#x27; = y + r_y</span>  hold.</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 CDH versus CIE</h3>

      <h4 id="sec-6.3.1" class="text-lg font-semibold mt-6">6.3.1 High Granular</h4>

    <p class="text-gray-300">In the following, we prove that similar relations as between CDH and CSE also exist for CDH and CIE. As before, we show equivalence between the high-granular CDH and CIE assumptions: In Lemma 6.4 we prove high-granular reduction from CIE to CDH assumption for their different variants with respect to success probability. However, for weak and invariant CDH oracle the reduction does not work directly, and we need to self-correct the CDH oracle first.</p>

    <p class="text-gray-300">For the converse reduction (i.e., from CDH to CIE), we first reduce CSE to CIE (Lemma 6.6), and then apply Theorem 6.2. Finally, we prove that the same relations hold also for the medium-granular versions, however, we can achieve them much more efficiently.</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Lemma 6.4</h4>

    <pre><code class="language-text">\\begin{split} \\{1,\\, (1-1/\\mathsf{poly}(k))\\}\\text{-}\\mathrm{CIE}\\big(\\mathbf{c};\\mathbf{s};\\mathbf{g};\\mathbf{h};\\mathbf{f};\\mathbf{f}\\mathbf{c}t\\big) &amp; \\xrightarrow{\\underline{\\alpha&#x27;=\\alpha^{O(\\log|G|)}};\\,\\, t&#x27;=O(t\\log|G|)+O((\\log|G|)^2)} \\\\ &amp; \\underbrace{\\{1,\\, (1-1/\\mathsf{poly}(k))\\}\\text{-}\\mathrm{CDH}\\big(\\mathbf{c};\\mathbf{s};\\mathbf{g};\\mathbf{h};\\mathbf{f};\\mathbf{f}\\mathbf{c}t\\big);} \\\\ \\{\\epsilon,1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{CIE}\\big(\\mathbf{c};\\mathbf{s};\\mathbf{g};\\mathbf{h};\\mathbf{f};\\mathbf{f}\\mathbf{c}t\\big) \\\\ &amp; \\xrightarrow{\\underline{\\alpha&#x27;\\geq 1-1/2^k;\\,\\, t&#x27;=O(tk/\\alpha+t\\log|G|)+O(k\\log|G|/\\alpha+(\\log|G|)^2)}} \\\\ &amp; \\underbrace{\\{(1-1/\\mathsf{poly}(k))\\}\\text{-}\\mathrm{CDH}\\big(\\mathbf{c};\\mathbf{s};\\mathbf{g};\\mathbf{h};\\mathbf{f};\\mathbf{f}\\mathbf{c}t\\big)}_{\\square} \\end{split}
</code></pre>

    <p class="text-gray-300"><em>Proof.</em> The following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Given CDHoracle  <span class="math">\\mathcal{O}_{CDH}</span> which breaks  <span class="math">\\{1, (1-1/poly(k))\\}</span> -CDH(c:*; g:h; f:fct) with probabilsuccess ity  <span class="math">\\alpha_{CDH}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span> which breaks  <span class="math">\\{1, (1-1/poly(k))\\}\\-CIE(c:*; g:h; f:fct)</span> with success probability  <span class="math">\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{O(\\log |G|)}</span> , using  <span class="math">O(\\log |G|)</span>  oracle calls and  <span class="math">O((\\log |G|)^2)</span>  group operations.</li>
      <li>(b) Given a CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which breaks  <span class="math">\\{\\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CDH (c:*; g:h; f:fct) with success probability  <span class="math">\\alpha_{CDH}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k))\\}</span> -CIE(c:*; g:h; f:fct) with success probability  <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1 1/2^k</span> , using  <span class="math">O(k/\\alpha_{CDH}(k) + \\log |G|)</span>  oracle calls and  <span class="math">O(k \\log |G|/\\alpha_{CDH}(k) + (\\log |G|)^2)</span>  group operations.</li>
    </ul>

    <p class="text-gray-300">Case (a): Given the CDH input tuple  <span class="math">((G,g),(g^x))</span> , compute  <span class="math">g^{x^{-1}} = g^{x^{\\varphi(|G|)-1}}</span>  by applying, e.g., the square and multiply method which requires  <span class="math">O(\\log |G|)</span>  calls to  <span class="math">\\mathcal{O}_{CDH}</span> . Note that for this,  <span class="math">\\varphi(|G|)</span>  and consequently the factorization of |G| must be known (This fact is indicated by the place holder f:fct in the assumption.) Further, note that each time  <span class="math">\\mathcal{O}_{CDH}</span>  is called its inputs component</p>

    <p class="text-gray-300"><span class="math">g^u</span>  must be randomized to obtain oracle calls with properly distributed and statistically independent inputs.<sup>31</sup></p>

    <p class="text-gray-300">Success probability: Since there are  <span class="math">O(\\log |G|)</span>  independent oracle calls the resulting success probability is  <span class="math">\\alpha_{CIE} = (\\alpha_{CDH}(k))^{O(\\log |G|)}</span> . Depending on  <span class="math">\\alpha_{CDH}(k)</span>  we have the following cases:</p>

    <p class="text-gray-300">Perfect oracle  <span class="math">(\\alpha_{CDH}(k) \\nleq_{\\infty} 1)</span> : Clearly, the resulting success probability is also perfect, i.e.,  <span class="math">\\alpha_{CIE}(k) \\nleq_{\\infty} 1</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1-\\alpha_{CDH}(k)\\not\\geq_{\\infty}1/\\text{poly}(k))</span> : The resulting success probability is also strong: Set  <span class="math">f(|G|):=O(\\log|G|)</span> . It follows  <span class="math">f(|G|)\\leq b\\log|G|</span>  for a constant b&gt;0. As discussed in Section 2.7 we can assume that the group order can be bounded in the security parameter, i.e.,  <span class="math">|G|\\leq 2^{k^d}</span>  for some d&gt;0. It follows  <span class="math">\\log|G|\\leq k^d</span>  and we can write</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{f(|G|)} \\ge \\alpha_{CDH}(k)^{bk^d}.</span>$</p>

    <p class="text-gray-300">According to Lemma 6.2 a polynomial power of a strong success probability is itself strong, i.e.,  <span class="math">1 - \\alpha_{CDH}(k)^{bk^d} \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span>  and thus, it follows  <span class="math">1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Efficiency: There are  <span class="math">O(\\log |G|)</span>  oracle calls, and per oracle call  <span class="math">O(\\log |G|)</span>  group operations are required for exponentiations and computing inverses. This makes the total cost of  <span class="math">O((\\log |G|)^2)</span>  group operations.</p>

    <p class="text-gray-300">Case (b): The proof is similar to the case (a), except that for the weak and invariant CDH oracle the resulting success probability  <span class="math">\\alpha_{CIE}(k)</span>  cannot be polynomially bounded, and the above reduction does not work directly. The success probability of  <span class="math">\\mathcal{O}_{CDH}</span>  has to be improved first by self-correction (see Section 6.1), a task expensive both in terms of oracle calls and group operations.</p>

    <p class="text-gray-300">Success probability: As mentioned above, we first self-correct the success probability of the invariant (weak) CDH oracle to strong success probability. This is done by applying Corollary 6.1. Thus, we have  <span class="math">1 - \\alpha_{CDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Then it follows from Lemma 6.2 that  <span class="math">\\alpha_{CDH}(k)^{bk^d}</span>  is strong, i.e., we have  <span class="math">1 - \\alpha_{CDH}(k)^{bk^d} \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Since  <span class="math">\\alpha_{CIE}(k) \\geq \\alpha_{CDH}(k)^{bk^d}</span>  it follows  <span class="math">1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Efficiency: Due to Corollary 6.1 the additional costs for self-correcting are</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{31}&lt;/sup&gt;</span>  This is done as follows: Due to square and multiply method the input tuple to  <span class="math">\\mathcal{O}_{CDH}</span>  at given step is either of the form  <span class="math">(g^{x^a},g^x)</span>  (multiplication) or of the form  <span class="math">(g^{x^a},g^{x^a})</span>  (squaring) for some a. The inputs are randomized by choosing  <span class="math">r,s\\in_{\\mathcal{R}}\\mathbb{Z}_{|G|}</span>  and inputing the tuple  <span class="math">(g^{x^a+r},g^{x+s})</span>  or  <span class="math">(g^{x^a+r},g^{x^a+s})</span>  to  <span class="math">\\mathcal{O}_{CDH}</span> . The desired outputs are then computed as  <span class="math">g^{x^{a+1}}=\\frac{g^{(x^a+r)(x+s)}}{g^{sx^a}+rx+rs}</span>  or  <span class="math">g^{x^{2a}}=\\frac{g^{(x^a+r)(x^a+s)}}{g^{(r+s)x^a}+rs}</span> .</p>

    <p class="text-gray-300"><span class="math">O(k/\\alpha_{CDH}(k))</span>  oracle calls and  <span class="math">O(k\\log|G|/\\alpha_{CDH}(k) + (\\log|G|)^2)</span>  group operations. Thus, the total costs are:  <span class="math">O(k/\\alpha_{CDH}(k) + \\log|G|)</span>  oracle calls and  <span class="math">O(k\\log|G|/\\alpha_{CDH}(k) + (\\log|G|)^2)</span>  group operations.</p>

    <p class="text-gray-300">In the following Lemma we analyze the behavior of  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  for group orders containing no small prime factors. This will be helpful when proving relations between certain assumptions in the sequel.</p>

    <p class="text-gray-300"><strong>Lemma 6.5</strong> Let  <span class="math">SG_{\\mathcal{G}}</span>  be a group sampler generating a family  <span class="math">\\mathcal{G}</span>  of groups whose orders contain no small prime factors. Let  <span class="math">\\mathcal{G}_{SG(k)}</span>  be the corresponding group siblings (the set of groups G returned by  <span class="math">SG_{\\mathcal{G}}</span>  for a security parameter K.) Further, let  <span class="math">f: \\mathbb{N} \\mapsto \\mathcal{G}</span>  be a function such that  <span class="math">f(k) \\in \\mathcal{G}_{SG(k)}</span>  and  <span class="math">\\forall G&#x27; \\in \\mathcal{G}_{SG(k)}</span> ,  <span class="math">\\frac{\\varphi(|G&#x27;|)}{|G&#x27;|} \\geq \\frac{\\varphi(|f(k)|)}{|f(k)|}</span> . Then it follows  <span class="math">1 - \\frac{\\varphi(|f(k)|)}{|f(k)|} &lt;_{\\infty} 1/\\operatorname{poly}(k)</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">Proof. Let  <span class="math">|f(k)| = |G| = \\prod_{i=1}^m p_i^{e_i}</span>  be the prime factorization of the group order |G| and  <span class="math">p = \\min(p_1, \\cdots, p_m)</span>  be the smallest prime factor of |G|. Then it follows  <span class="math">|G| = \\prod_{i=1}^m p_i \\ge p^m</span>  and  <span class="math">\\log |G| \\ge m \\log p</span>  and thus  <span class="math">m \\le \\log |G| / \\log p \\le \\log |G|</span>  for  <span class="math">\\log p \\ge 1</span>  (i.e., for  <span class="math">p \\ge 2</span> ). Moreover, as discussed in Section 2.7, we can assume that the group order can be upper bounded in security parameter, i.e.,  <span class="math">|G| \\le 2^{k^d}</span>  for k &gt; 1 and some d &gt; 0. It follows  <span class="math">m \\le \\log |G| \\le k^d</span> . Hence, we can write</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\varphi(|G|)}{|G|} = \\prod_{i=1}^{m} (1 - \\frac{1}{p_i}) \\ge (1 - \\frac{1}{p})^m &gt; (1 - \\frac{1}{p})^{k^d}.</span>$</p>

    <p class="text-gray-300">Since |G| contains no small prime factors, it follows from the definition of no small prime (see Section 3) that for any real constant c &gt; 0, there exists a  <span class="math">k_0</span>  such that for all  <span class="math">k &gt; k_0</span> ,  <span class="math">1/p &lt; 1/k^c</span> . Thus, we can write</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\varphi(|G|)}{|G|} \\ge (1 - \\frac{1}{p})^{k^d} &gt; (1 - \\frac{1}{k^c})^{k^d}.</span>$</p>

    <p class="text-gray-300">According to Lemma 6.3, the relation  <span class="math">(1-1/k^c)^{k^d} \\geq 1-1/k^{c-d}</span>  holds for c&gt;d and  <span class="math">k\\in\\mathbb{N}</span> . Since c is arbitrary, and since for all c&gt;d we can write c':=c-d&gt;0, it follows that for all c'&gt;0, there exists a  <span class="math">k_0</span>  such that for all  <span class="math">k&gt;k_0</span> ,  <span class="math">\\frac{\\varphi(|G|)}{|G|}&gt;1-1/k^{c&#x27;}</span>  and consequently  <span class="math">1-\\frac{\\varphi(|G|)}{|G|}&lt;1/k^{c&#x27;}</span> . This means  <span class="math">1-\\frac{\\varphi(|G|)}{|G|}&lt;\\infty</span>   <span class="math">1/\\operatorname{poly}(k)</span> .</p>

    <p class="text-gray-300">In the following lemma we prove the reduction from CSE to CIE assumption for their high-granular version. This lemma will be helpful later when establishing the relation between CIE and CDH assumptions.</p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Lemma 6.6</h4>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c} \\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{CSE}\\left(\\mathbf{c}; \\mathbf{s}; \\mathbf{g}; \\mathbf{h}; \\mathbf{f}; \\mathbf{nsprim}, \\mathbf{o}\\right) \\\\ &amp; \\xrightarrow{\\alpha&#x27; \\geq \\frac{2\\varphi(|G|)-1}{|G|}} \\alpha^3; \\ t&#x27; = 3t + O(\\log|G|) \\\\ \\hline &amp; &amp; &amp; \\\\ \\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{CIE}\\left(\\mathbf{c}; \\mathbf{s}; \\mathbf{g}; \\mathbf{h}; \\mathbf{f}; \\mathbf{nsprim}, \\mathbf{o}\\right) \\end{array}</span>$</p>

    <p class="text-gray-300">Proof. We prove the following statement: Given a CIE oracle  <span class="math">\\mathcal{O}_{CIE}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CIE(c:*; g:h; f:nsprim,o) with success probability  <span class="math">\\alpha_{CIE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  which breaks the assumption  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CSE(c:*; g:h; f:nsprim,o) with success probability  <span class="math">\\alpha_{CSE}(k) \\geq \\frac{2\\varphi(|G|)-1}{|G|}\\alpha_{CIE}(k)^3</span> , using 3 oracle calls and  <span class="math">O(\\log |G|)</span>  group operations.</p>

    <p class="text-gray-300">We proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) Select  <span class="math">b, r_1, r_2 \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}</span> , compute  <span class="math">(g^x g^{-b})^{r_1} = g^{(x-b)r_1}</span>  and  <span class="math">(g^x g^b)^{r_2} = g^{(x+b)r_2}</span> , and query  <span class="math">\\mathcal{O}_{CIE}</span>  with  <span class="math">((G,g),(g^{(x-b)r_1}))</span>  and  <span class="math">((G,g),(g^{(x+b)r_1}))</span> . One can expect correct oracle answers with probability  <span class="math">\\alpha_{CIE}(k)</span>  only if oracle inputs are legal, i.e., only if  <span class="math">x \\pm b \\in \\mathbb{Z}^*_{|G|}</span> . This event occurs with a certain probability which will be determined later. Now, assuming the inputs are legal, one obtains statistically independent oracle calls by randomizing the input elements with  <span class="math">r_1, r_2</span> . The oracle answers are  <span class="math">g^{\\frac{1}{r_1(x-b)}} = \\mathcal{O}_{CIE}(g^{(x-b)r_1})</span>  and  <span class="math">g^{\\frac{1}{r_2(x+b)}} = \\mathcal{O}_{CIE}(g^{(x+b)r_2})</span> , each time with probability  <span class="math">\\alpha_{CIE}(k)</span> .</li>
      <li>(ii) Using the oracle's answers in Step (i) compute:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\frac{\\left(g^{\\frac{1}{r_1(x-b)}}\\right)^{r_1}}{\\left(g^{\\frac{1}{r_2(x+b)}}\\right)^{r_2}} = g^{\\left(\\frac{1}{x-b} - \\frac{1}{x+b}\\right)} = g^{\\frac{2b}{x^2 - b^2}}.</span>$</p>

    <p class="text-gray-300">The exponent  <span class="math">\\frac{2b}{x^2-b^2}</span>  is an element of  <span class="math">\\mathbb{Z}^*_{|G|}</span>  because of the following reasons:  <span class="math">b \\in \\mathbb{Z}^*_{|G|}</span> , and as discussed above,  <span class="math">x \\pm b \\in \\mathbb{Z}^*_{|G|}</span>  which implies  <span class="math">x^2 - b^2 \\in \\mathbb{Z}^*_{|G|}</span> . Further, |G| is odd as the group families do not have any small prime factors in the order.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(iii) Select  <span class="math">r_3 \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}</span>  and query  <span class="math">\\mathcal{O}_{CIE}</span>  with  <span class="math">\\left( (G,g), \\left( (g^{\\frac{2b}{x^2-b^2}})^{r_3} \\right) \\right)</span>  where  <span class="math">r_3</span>  is used for randomization to obtain statistically independent oracle call. The oracle answers  <span class="math">g^{\\frac{x^2-b^2}{2br_3}} = \\mathcal{O}_{CIE} \\left( g^{\\frac{2br_3}{x^2-b^2}} \\right)</span>  with success probability  <span class="math">\\alpha_{CIE}(k)</span> .</li>
      <li>(iv) Compute the desired CSE instance by using the oracle's answer in Step (iii)</li>
    </ul>

    <p class="text-gray-300"><span class="math">$g^{x^2} = \\left(g^{\\frac{x^2-b^2}{2br_3}}\\right)^{2br_3} g^{b^2}.</span>$</p>

    <p class="text-gray-300">Success probability: The probability that both events  <span class="math">E_1: x+b \\in \\mathbb{Z}_{|G|}^*</span>  and  <span class="math">\\overline{}^{32}</span> Note that for  <span class="math">x \\pm b \\in \\mathbb{Z}_{|G|}^*</span>  the multiplication with  <span class="math">r_1, r_2 \\in \\mathbb{Z}_{|G|}^*</span>  spreads  <span class="math">x \\pm b</span>  randomly and uniformly over  <span class="math">\\mathbb{Z}_{|G|}^*</span> , and consequently  <span class="math">(g^{(x-b)})^{r_1}</span> ,  <span class="math">(g^{(x+b)})^{r_2}</span>  are randomly and uniformly distributed over input domain of  <span class="math">\\mathcal{O}_{CIE}</span> , implying statistically independent oracle calls.</p>

    <p class="text-gray-300"><span class="math">E_2: x - b \\in \\mathbb{Z}_{|G|}^*</span>  occur (in Step (i)) is</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[E_1 \\wedge E_2] &amp;= \\mathbf{Prob}[E_1] + \\mathbf{Prob}[E_2] - \\mathbf{Prob}[E_1 \\vee E_2] \\\\ &amp;= \\frac{2\\varphi(|G|)}{|G|} - \\mathbf{Prob}[E_1 \\vee E_2] \\\\ &amp;\\geq \\frac{2\\varphi(|G|)}{|G|} - 1 \\end{aligned}</span>$</p>

    <p class="text-gray-300">where we set  <span class="math">\\operatorname{\\mathbf{Prob}}[E_1 \\vee E_2] = 1</span> . Obviously, this is a worst case lower bound.<sup>33</sup> Each time with probability  <span class="math">\\alpha_{CIE}(k)</span>  the oracle outputs the correct value. There are 3 statistically independent calls to the oracle, and so the resulting success probability of  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  is:</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{CSE}(k) \\geq \\big(\\frac{2\\varphi(|G|)}{|G|} - 1\\big)\\alpha_{CIE}(k\\big)^3.</span>$</p>

    <p class="text-gray-300">In the following, we set  <span class="math">\\lambda(k) := \\alpha_{CIE}(k)^3</span>  and  <span class="math">\\gamma(k) := \\frac{2\\varphi(|G|)}{|G|} - 1</span>  (Note that |G| is a function of the security parameter k, see also Lemma 6.5) Depending on the oracle's success probability  <span class="math">\\alpha_{CIE}(k)</span>  we have the following cases:</p>

    <p class="text-gray-300">Perfect oracle ( <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1</span> ): The resulting success probability cannot be perfect because there is a non-zero error probability when querying the CIE oracle.</p>

    <p class="text-gray-300">Weak oracle  <span class="math">(\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) weak: Since |G| contains no small prime factors, it follows from Lemma 6.5 that  <span class="math">1-\\gamma(k)=2(1-\\frac{\\varphi(|G|}{|G|})&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Thus, we can write  <span class="math">\\gamma(k)&gt;_{\\infty} 1-1/\\mathsf{poly}(k)</span> , meaning that  <span class="math">\\gamma(k)</span>  is non-negligible. Further, we have  <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span>  which implies  <span class="math">\\lambda(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . It follows  <span class="math">\\gamma(k)\\lambda(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span>  (see also Section 2.2) Finally, since  <span class="math">\\alpha_{CSE}(k) \\ge \\gamma(k)\\lambda(k)</span> , it follows  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{CIE} \\not&lt;_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant: As shown in the weak case, we can write  <span class="math">\\gamma(k) &gt;_{\\infty} 1-1/\\mathsf{poly}(k)</span> . More precisely, for any  <span class="math">\\epsilon&#x27; &gt; 0</span>  there exist a  <span class="math">k_0</span>  such that for all  <span class="math">k &gt; k_0</span> ,  <span class="math">\\gamma(k) &gt; 1 - \\epsilon&#x27;</span> . Since  <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , for any  <span class="math">k&#x27;_0</span>  there exists a  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{CIE}(k_1) \\ge \\epsilon_1</span>  and consequently  <span class="math">\\lambda(k_1) \\ge \\epsilon_1^3</span> . Hence, for any  <span class="math">k&#x27;_0 &gt; k_0</span>  there exists a  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{CSE}(k_1) \\ge \\epsilon_2</span>  where  <span class="math">\\epsilon_2 := (1 - \\epsilon&#x27;)\\epsilon_1^3</span> . This means  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong. For this, we first prove that  <span class="math">1 - \\gamma(k)\\lambda(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> : As shown in the weak case, we can write  <span class="math">\\gamma(k) &gt;_{\\infty} 1 - 1/\\mathsf{poly}(k)</span> . Further, from Lemma 6.2 it follows  <span class="math">1 - \\lambda(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Applying Lemma</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{33}&lt;/sup&gt;</span>  For this (worst case) lower bound to be meaningful (non-negative) the relation  <span class="math">\\frac{\\varphi(|G|)}{|G|}&gt;\\frac{1}{2}</span>  must hold, and clearly this is the case as |G| contains no small prime factors.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{34}\\&lt;/sup&gt;lambda(k)</span>  is a (polynomial) power of a strong success probability.</p>

    <p class="text-gray-300">6.7 we obtain  <span class="math">1 - \\gamma(k)\\lambda(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Since  <span class="math">1 - \\alpha_{CSE}(k) \\leq 1 - \\gamma(k)\\lambda(k)</span> , it follows  <span class="math">1 - \\alpha_{CSE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 6.7</strong> Let f(k), g(k) be functions  <span class="math">\\mathbb{N} \\to [0,1]</span> . If  <span class="math">1 - f(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span>  and  <span class="math">1 - g(k) &lt;_{\\infty} 1/\\mathsf{poly}(k)</span> , then  <span class="math">1 - f(k)g(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Proof. Consider P(k) = (1 - f(k))(1 - g(k)). Obviously,  <span class="math">P(k) \\ge 0</span>  for all k and we can write</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lcl} (1-f(k))(1-g(k)) &amp; = &amp; 1+f(k)g(k)-f(k)-g(k) \\\\ &amp; = &amp; -(1-f(k)g(k))+(1-f(k))+(1-g(k)) \\\\ &amp; = &amp; -(1-f(k)g(k))+S(k) \\geq 0 \\end{array}</span>$</p>

    <p class="text-gray-300">where we set  <span class="math">S(k)\\!:=\\!(1-g(k))\\!+\\!(1-f(k))</span> . S(k) is a not non-negligible function since it is the sum of a negligible and a not non-negligible functions. Thus, we can write  <span class="math">S(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span> . From equations above we have  <span class="math">1-f(k)g(k)\\leq S(k)</span> . Since  <span class="math">S(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span> , it follows  <span class="math">1-f(k)g(k)\\not\\geq_{\\infty}1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Efficiency: There are 3 calls to  <span class="math">\\mathcal{O}_{CIE}</span> , and  <span class="math">O(\\log |G|)</span>  group operations are required for the exponentiations and computing the inverse elements.</p>

    <p class="text-gray-300">Remark 6.3. For groups of prime order, the resulting success probability covers also perfect success probability as the special case of elements not in  <span class="math">\\mathbb{Z}_p^*</span>  (i.e., 0) can be tested and handled.</p>

    <p class="text-gray-300">Using the previous results we can now prove the relation between CIE and CDH assumptions in their high-granular variant.</p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Theorem 6.4</h4>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c} *\\text{-CIE}\\left(\\mathbf{c}\\text{:}*;\\mathbf{g}\\text{:}\\mathbf{h};\\mathbf{f}\\text{:}\\mathbf{f}\\mathbf{c}\\mathbf{t}\\right) \\\\ \\xrightarrow{\\alpha&#x27; \\geq 1 - 1/2^k; \\ t&#x27; = O\\left(\\frac{tk}{\\alpha} + t\\log|G|\\right) + O\\left(\\frac{k\\log|G|}{\\alpha} + (\\log|G|)^2\\right)} \\\\ &amp; *\\text{-CDH}\\left(\\mathbf{c}\\text{:}*;\\mathbf{g}\\text{:}\\mathbf{h};\\mathbf{f}\\text{:}\\mathbf{f}\\mathbf{c}\\mathbf{t}\\right); \\\\ \\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-CIE}\\left(\\mathbf{c}\\text{:}*;\\mathbf{g}\\text{:}\\mathbf{h};\\mathbf{f}\\text{:}\\mathsf{nsprim},\\mathbf{o}\\right) \\\\ \\xrightarrow{\\alpha&#x27; \\geq (\\frac{2\\varphi(|G|) - 1}{|G|})^3\\alpha^9; \\ t&#x27; = 9t + O(\\log|G|)} \\\\ &amp; \\underbrace{\\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-CDH}\\left(\\mathbf{c}\\text{:}*;\\mathbf{g}\\text{:}\\mathbf{h};\\mathbf{f}\\text{:}\\mathsf{nsprim},\\mathbf{o}\\right)}_{} \\end{array}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The following statements hold:</p>

    <p class="text-gray-300">(a) Given a CDH oracle  <span class="math">\\mathcal{O}_{CDH}</span>  which breaks *-CDH(c:*; g:h; f:fct) with success probability  <span class="math">\\alpha_{CDH}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CDH}}</span>  which breaks *-CIE(c:*; g:h; f:fct) with success probability  <span class="math">\\alpha_{CIE}(k) = \\alpha_{CDH}(k)^{O(\\log|G|)}</span> , using at most  <span class="math">O(\\frac{k}{\\alpha_{CDH}(k)} + \\log|G|)</span>  calls to  <span class="math">\\mathcal{O}_{CDH}</span>  and  <span class="math">O(\\frac{k \\log|G|}{\\alpha_{CDH}(k)} + (\\log|G|)^2)</span>  group operations.</p>

    <p class="text-gray-300">(b) Given a CIE oracle OCIE which breaks {(1&minus;1/poly(k)),,1/poly(k)}-CIE(c:&lowast;; g:h; f:nsprim,o) with success probability &alpha;CIE(k), there exists an algorithm AOCIE which breaks {(1&minus;1/poly(k)),,1/poly(k)}-CDH(c:&lowast;; g:h; f:nsprim,o) with success probability &alpha;CDH (k) &ge; ( 2&#981;(|G|)&minus;1 |G| ) <sup>3</sup>&alpha;CIE(k) 9 , using 9 oracle calls and O(log |G|) group operations.</p>

    <p class="text-gray-300">Case (a): Follows immediately from lemma <a href="#page-61-0">6.4.</a></p>

    <p class="text-gray-300">Case (b): According to Theorem <a href="#page-33-0">6.2</a> there is a reduction from &lowast;-CDH(c:&lowast;; g:h; f:o) to &lowast;-CSE(c:&lowast;; g:h; f:o) with success probability &alpha;CDH (k) = &alpha;CSE(k) 3 , using 3 calls to OCDH and O(log |G|) group operations.</p>

    <p class="text-gray-300">Further, according to Lemma <a href="#page-40-0">6.6</a> there is a reduction from {(1&minus;1/poly(k)),,1/poly(k)}-CSE(c:&lowast;; g:h; f:nsprim,o) to {(1&minus;1/poly(k)),,1/poly(k)}-CIE(c:&lowast;; g:h; f:nsprim,o) with success probability &alpha;CSE(k) &ge; 2&#981;(|G|)&minus;1 |G| &alpha;CIE(k) 3 , using 3 oracle calls and O(log |G|) group operations.</p>

    <p class="text-gray-300">Combining these results we obtain a reduction from {(1&minus;1/poly(k)),,1/poly(k)}-CDH(c:&lowast;; g:h; f:nsprim,o) to {(1&minus;1/poly(k)),,1/poly(k)}-CIE(c:&lowast;; g:h; f:nsprim,o) with the resulting success probability &alpha;CDH (k) &ge; ( 2&#981;(|G|)&minus;1 |G| ) <sup>3</sup>&alpha;CIE(k) 9 , using 9 oracle calls and O(log |G|) group operations. This completes the proof.</p>

    <p class="text-gray-300">Remark 6.4. Theorem <a href="#page-43-1">6.4</a> concerns only group orders with no small prime factors, and does not cover the gap between the group orders with at least one large prime factor and those containing no small primes. Note that for group orders with only small prime factors the problems are easy to solve since one can apply well-known algorithms for solving the discrete logarithms <a href="#page-77-2">(Shoup</a> 1997).</p>

    <p class="text-gray-300">Remark 6.5. The CDH oracle can be used to multiply two discrete logarithms without knowing them explicitly (e.g., to compute g x 2 without knowing x). Using CDH oracle one can compute g p(x) for a polynomial p(x) with integer coefficients or to compute g h(x) for any rational function of the form h(x) = f(x)/g(x) where f(x), g(x) are polynomials with integer coefficients. This fact was also mentioned shortly by <a href="#page-75-9">Maurer</a> (1994). As a consequence one can use CDH oracle to compute any multivariate polynomial p(x1, x2, &middot; &middot; &middot; xn) or rational function h(x1, x2, &middot; &middot; &middot; , xn) in the exponent.</p>

    <p class="text-gray-300">Let us, for brevity, consider bivariate expressions in exponents. Assume we are given an oracle which, on input g x , g y , outputs g <sup>p</sup>(x,y) with a certain probability, where p(x, y) is a known (fixed) bivariate polynomial whose degree and form is appropriately defined. We may call this oracle CPE (Computational Polynomial Exponent) and want to analyze its relation to CDH oracle. Due to the discussion above we can easily construct a CPE oracle using a CDH oracle, however, the converse (reduction CDH to CPE) is not obvious. This direction was shown in Kiltz (2001): First show the equivalence between CDH oracle and a CPE oracle which computes polynomials of degree 2 (according to the underlying polynomial definition). We denote such oracle with CPE(2). Next prove that a CPE(n), i.e, a CPE oracle outputting p(x,y) of degree n, can be inductively reduced to CPE(2).</p>

      <h4 id="sec-6.3.2" class="text-lg font-semibold mt-6">6.3.2 Medium Granular</h4>

    <p class="text-gray-300">Next, we prove the above equivalence (Theorem 6.4) also for medium granularity. Similar to Theorem 6.3 we could argue that due to the existence of a randomization the result immediately follows also for the medium-granular case. However, we will show that this reduction can be performed much more efficiently in the medium-granular case than in the high-granular case; thereby we improve the concrete security considerably. We start with the following lemma.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Lemma 6.8</h4>

    <p class="text-gray-300"><span class="math">$\\underbrace{ \\begin{array}{c} \\alpha&#x27; = \\alpha; \\ t&#x27; = t + O(\\log |G|) \\\\ \\\\ = - \\operatorname{CSE}(c:*; g:m; f:o); \\end{array} }_{ \\text{</span><em>$-CSE}(c:</em>; g:m; f:o); } \\ { (1 - 1/\\operatorname{poly}(k)), \\epsilon, 1/\\operatorname{poly}(k) } \\text{-<span class="math">\\operatorname{CIE}(c:*; g:m; f:nsprim)</span>} \\ \\underbrace{ \\begin{array}{c} \\alpha' \\geq \\frac{\\varphi(|G|)}{|G|} \\alpha; \\ t' = t \\ \\ = - \\operatorname{color}(1 - 1/\\operatorname{poly}(k)), \\epsilon, 1/\\operatorname{poly}(k) } \\text{-<span class="math">\\operatorname{CSE}(c:*; g:m; f:nsprim)</span>} \\end{array} }_{ \\text{<span class="math">*</span>-CSE}(c:*; g:m; f:nsprim) }$$</p>

    <p class="text-gray-300"><em>Proof.</em> We prove that the following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Given a CSE oracle  <span class="math">\\mathcal{O}_{CSE}</span>  which breaks *-CSE(c:*; g:m; f:o) with success probability  <span class="math">\\alpha_{CSE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span>  that breaks *-CIE(c:*; g:m; f:o) with success probability  <span class="math">\\alpha_{CIE}(k) = \\alpha_{CSE}(k)</span> , using 1 oracle call and  <span class="math">O(\\log |G|)</span>  group operations.</li>
      <li>(b) Given a CIE oracle  <span class="math">\\mathcal{O}_{CIE}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CIE(c:*; g:h; f:nsprim) with success probability  <span class="math">\\alpha_{CIE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -CSE(c:*; g:h; f:nsprim) with success probability  <span class="math">\\alpha_{CSE}(k) \\geq \\frac{\\varphi(|G|)}{|G|} \\alpha_{CIE}(k)</span> , using 1 oracle call.</li>
    </ul>

    <p class="text-gray-300">Case (a): Given a CIE input tuple  <span class="math">((G,g),(g^x))</span>  with  <span class="math">x \\in \\mathbb{Z}^*_{|G|}</span> , we construct  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CSE}}</span>  as follows: Set  <span class="math">h := g^x</span> , then we have  <span class="math">g = h^t</span>  for  <span class="math">t \\in \\mathbb{Z}^*_{|G|}</span> . Since  <span class="math">x \\in \\mathbb{Z}^*_{|G|}</span> , h is a group generator, and  <span class="math">t = x^{-1}</span>  exists as we implicitly assumed above. Select  <span class="math">r \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and pass  <span class="math">((G,h),(h^{t+r}))</span>  to  <span class="math">\\mathcal{O}_{CSE}</span>  where  <span class="math">h^{t+r} = gg^r</span> . The reason for the randomization with r is that here the inputs to  <span class="math">\\mathcal{O}_{CSE}</span>  are limited to those with secret exponents x from  <span class="math">\\mathbb{Z}^*_{|G|}</span>  whereas the success probability of</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}_{CSE}</span>  is defined over the input set with  <span class="math">x \\in \\mathbb{Z}_{|G|}</span> . Using the answer of  <span class="math">\\mathcal{O}_{CSE}</span>  we compute</p>

    <p class="text-gray-300"><span class="math">$h^{t^2} = \\frac{\\mathcal{O}_{CSE}(h^{t+r})}{g^{2r}g^{r^2}} = \\frac{h^{t^2+2rt+r^2}}{(h^t)^{2r}h^{r^2}}.</span>$</p>

    <p class="text-gray-300">Since  <span class="math">t = x^{-1}</span>  we exploit the identity  <span class="math">h^{t^2} = (g^x)^{(x^{-1})^2} = (g^x)^{x^{-2}} = g^{xx^{-2}} = g^{x^{-1}}</span>  to solve CIE input.</p>

    <p class="text-gray-300">Success probability: There is a single call to  <span class="math">\\mathcal{O}_{CSE}</span> . Thus, the resulting success probability is  <span class="math">\\alpha_{CIE}(k) = \\alpha_{CSE}(k)</span> .</p>

    <p class="text-gray-300">Efficiency: There is a single oracle call, and there are  <span class="math">O(\\log |G|)</span>  group operations required for computing the inverses and exponentiations.</p>

    <p class="text-gray-300">Case (b): Given a CSE input tuple  <span class="math">((G,g),(g^x))</span> , we construct  <span class="math">\\mathcal{A}^{\\mathcal{O}_{CIE}}</span>  as follows: Set  <span class="math">h:=g^x</span>  and pass  <span class="math">((G,h),(h^t))</span>  to  <span class="math">\\mathcal{O}_{CIE}</span>  where  <span class="math">h^t=g</span> . Note that  <span class="math">\\mathcal{O}_{CIE}</span>  answers correctly (i.e.,  <span class="math">{h^t}^{-1}</span> ) with probability  <span class="math">\\alpha_{CIE}(k)</span>  only to the legal queries, i.e., when h is a generator and  <span class="math">t\\in\\mathbb{Z}^*_{|G|}</span> . The probability for this event is  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span> . Note that in this case  <span class="math">t:=x^{-1}</span>  exists, as we implicitly assumed above. The desired solution to the CSE problem is obtained by exploiting the identity  <span class="math">h^{t^{-1}}=(g^x)^{(x^{-1})^{-1}}=g^{x^2}</span> .</p>

    <p class="text-gray-300">Success probability: There is a single call to  <span class="math">\\mathcal{O}_{CIE}</span> . Thus, the resulting success probability is  <span class="math">\\alpha_{CSE}(k) \\geq \\frac{\\varphi(|G|)}{|G|}\\alpha_{CIE}(k)</span> . Depending on the oracle's success probability  <span class="math">\\alpha_{CIE}(k)</span>  we have the following cases:</p>

    <p class="text-gray-300">Perfect oracle ( <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1</span> ): The resulting success probability cannot be perfect because there is a non-zero error probability when querying the CIE oracle.</p>

    <p class="text-gray-300">Weak oracle  <span class="math">(\\alpha_{CIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is weak:  <span class="math">\\alpha_{CIE}(k)</span>  is a not negligible function, and  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  is always non-negligible (see also Lemma 6.5) Thus, the product of these terms is a not-negligible function, implying  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{CIE} \\not&lt;_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant. The proof is similar to that of the invariant case in Lemma 6.6: Since |G| contains no small prime factors, it follows from Lemma 6.5 that  <span class="math">1 - \\frac{\\varphi(|G|)}{|G|} &lt;_{\\infty} 1/\\text{poly}(k)</span> . More precisely, for all  <span class="math">\\epsilon&#x27; &gt; 0</span>  there exist a  <span class="math">k_0</span>  such that for all  <span class="math">k &gt; k_0</span> ,  <span class="math">\\frac{\\varphi(|G|)}{|G|} &gt; 1 - \\epsilon&#x27;</span> . Since  <span class="math">\\alpha_{CIE}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , for any  <span class="math">k&#x27;_0</span>  there exists  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{CIE}(k_1) &gt; \\epsilon_1</span> . Thus, for any  <span class="math">k&#x27;_0 &gt; k_0</span>  there exists  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{CSE}(k_1) &gt; \\epsilon_2</span>  where  <span class="math">\\epsilon_2 := (1 - \\epsilon&#x27;)\\epsilon_1</span> . This means  <span class="math">\\alpha_{CSE}(k) \\not&lt;_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong. The proof is similar to that of the strong case in Lemma 6.6: Since |G| contains no small prime factors, it follows from Lemma</p>

    <p class="text-gray-300">6.5 that  <span class="math">1 - \\frac{\\varphi(|G|)}{|G|} &lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Further, we have  <span class="math">1 - \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Applying Lemma 6.7 we obtain  <span class="math">1 - \\frac{\\varphi(|G|)}{|G|} \\alpha_{CIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> , and since  <span class="math">1 - \\alpha_{CSE}(k) \\leq 1 - \\frac{\\varphi(|G|)}{|G|} \\alpha_{CIE}(k)</span> , it follows  <span class="math">1 - \\alpha_{CSE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Combining Theorem 6.3 and Lemma 6.8 we obtain the following theorem on the relation between the medium-granular variants of CIE and CDH assumptions.</p>

    <h3 id="sec-misc-10" class="text-xl font-semibold mt-8">Theorem 6.5</h3>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\alpha&#x27; = \\alpha; \\ t&#x27; = t + O(\\log |G|)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\alpha&#x27; = \\alpha; \\ t&#x27; = t + O(\\log |G|)}</span>$</p>

    <p class="text-gray-300"><span class="math">$*-CDH(c:*; g:m; f:o);</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\} - CIE(c:*; g:m; f:nsprim)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\alpha&#x27; \\geq \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^3 \\alpha^3; \\ t&#x27; = 3t + O(\\log |G|)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\{(1 - 1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\} - CDH(c:*; g:m; f:nsprim)</span>$</p>

    <p class="text-gray-300">Remark 6.6. In Theorem 6.5 we consider group orders containing no small prime factors (for the reduction CIE to CDH) to obtain comparable results to the high-granular variant of the reduction. However, the reduction holds also for general group orders<sup>35</sup> although for invariant and strong CIE oracle we need to self-correct the resulting success probability  <span class="math">\\alpha_{CDH}</span>  after the reduction (see Corollary 6.1) This is stated in the following lemma.</p>

    <h3 id="sec-misc-11" class="text-xl font-semibold mt-8">Lemma 6.9</h3>

    <pre><code class="language-text">\\begin{aligned} \\{(1-1/\\mathsf{poly}(k)), &amp;\\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{CIE}(\\mathbf{c}\\text{:}*; \\mathbf{g}\\text{:}\\mathbf{m}; \\mathbf{f}\\text{:}*) \\\\ &amp; \\longleftarrow \\\\ \\{(1-1/\\mathsf{poly}(k)), &amp;\\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{CDH}(\\mathbf{c}\\text{:}*; \\mathbf{g}\\text{:}\\mathbf{m}; \\mathbf{f}\\text{:}*) \\end{aligned}
</code></pre>

    <p class="text-gray-300">Remark 6.7. For prime group orders Theorem 6.5 also covers perfect oracles as the special case of elements not in  <span class="math">\\mathbb{Z}_p^*</span>  (i.e., 0) can be tested and handled.</p>

    <p class="text-gray-300">In this section we have analyzed and proved relations between CDH, CSE, CIE in their high- and medium-granular versions. We can summarize the advantages of medium-granular reductions over their high-granular variants as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The medium-granular reduction of CIE to CDH (Theorem 6.4) does not require the CDH oracle to be self-corrected.</li>
      <li>The medium-granular reduction (Theorem 6.5) is much more efficient than the corresponding high-granular reduction (Theorem 6.4): The reduction CIE-CDH requires a single call to the CDH oracle and  <span class="math">O(\\log |G|)</span>  group</li>
    </ul>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{35}&lt;/sup&gt;</span> e.g., it holds also for orders containing at least one large prime factor.</p>

    <p class="text-gray-300">operations whereas the high-granular version requires, even without self-correction,  <span class="math">O(\\log |G|)</span>  (very expensive) oracle calls and  <span class="math">O((\\log |G|)^2)</span>  group operations. Further, the reduction achieves a success probability which is higher by a power of  <span class="math">O(\\log |G|)</span> . The success probability of the converse reduction CDH-CIE is comparatively higher for the medium-granular variant.</p>

    <p class="text-gray-300">&bull; The high-granular variant of Theorem 6.5 works for group orders with no small prime factors. It does not cover the range of group orders with at least one large prime factor to those with no small prime factors. However, this gap is covered by the medium-granular version since the reduction works for any group order (see Remarks 6.4 and 6.6).</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Decisional DH, SE and IE</h2>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Difficulty in the Generic Model</h3>

    <p class="text-gray-300">First we state a Lemma which plays an important role for later proofs in the context of generic algorithms:</p>

    <p class="text-gray-300"><strong>Lemma 7.1 (Schwartz 1980; Shoup 1997)</strong> Let  <span class="math">p \\in \\mathbb{P}</span>  and  <span class="math">e \\in \\mathbb{N}</span> . Further, let  <span class="math">P(X_1, X_2, \\dots, X_n)</span>  be a non-zero polynomial in  <span class="math">\\mathbb{Z}_{p^e}[X]</span>  of total degree  <span class="math">d \\geq 0</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Prob}[P(x_1, x_2, \\cdots, x_n) \\equiv 0 :: (x_1, x_2, \\cdots, x_n) \\in_{\\mathcal{R}} \\mathbb{Z}_{p^e}^n] \\leq d/p.</span>$</p>

    <p class="text-gray-300">Using Lemma 7.1 Wolf (1999) shows the following result: There exists no generic algorithm that can solve DSE in polynomial time if the order of the multiplicative group is not divisible by small primes. This result is summarized in the following theorem:</p>

    <p class="text-gray-300">Theorem 7.1 (Wolf 1999)
<span class="math">$true \\implies \\epsilon\\text{-DSE}^{\\sigma}(c:*;g:h;f:nsprim,o)</span>$</p>

    <p class="text-gray-300">Remark 7.1. More precisely, Wolf shows, the probability that any generic algorithm  <span class="math">\\mathcal{A}^{\\sigma}</span>  can correctly distinguish correct DSE inputs from incorrect ones is at most  <span class="math">\\frac{(T+4)(T+3)}{2p&#x27;}</span>  where p' is the smallest prime factor of |G| and T is an upper bound on the algorithm's runtime.</p>

    <p class="text-gray-300">Remark 7.2. In the sequel, we will consider several decisional problems and prove results on the generic complexity of solving them. For known group orders the generic complexity of these problems is directly proportional to the smallest prime factor of the group order (similar to the result of Theorem 7.1)</p>

    <p class="text-gray-300">In other words, these problems can only be hard if the group order |G| is free of small primes.<sup>36</sup></p>

    <p class="text-gray-300">To make this more clear, consider the following example regarding DDH for group family with |G|=2q where  <span class="math">q\\in\\mathbb{P}</span>  is a prime. We assume that DDH is hard for q. Note that this example can be generalized to any group families with |G| containing small prime factors. Now, assume we are given a correct DDH tuple  <span class="math">I_1:=((G,g),(g^x,g^y),(g^{xy}))</span>  and a random DDH tuple  <span class="math">I_0:=((G,g),(g^x,g^y),(g^{x&#x27;y&#x27;}))</span>  with  <span class="math">x&#x27;,y&#x27;\\in_{\\mathcal{R}}\\mathbb{Z}_{|G|}</span> . Since |G| is even, we can determine the parity parity  <span class="math">(exp):=exp \\mod 2</span>  of the exponents  <span class="math">exp\\in\\{x,y,xy,x&#x27;y&#x27;\\}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{parity}(\\mathit{exp}) = \\left\\{ \\begin{array}{ll} 0 &amp; : &amp; \\mathrm{if}\\,(g^{\\mathit{exp}})^q = 1 \\\\ 1 &amp; : &amp; \\mathrm{if}\\,(g^{\\mathit{exp}})^q = g^q. \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">This can be exploited to construct an algorithm (distinguisher) D which solves DDH in G with non-negligible success probability. D gets the tuple  <span class="math">I_b</span>  as input, where b is a randomly and uniformly chosen bit, and outputs a bit  <span class="math">D(I_b)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$D(I_b) := \\left\\{ \\begin{array}{ll} 1 &amp; : &amp; \\text{if } \\mathsf{parity}(z) = \\mathsf{parity}(x) \\mathsf{parity}(y) \\\\ 0 &amp; : &amp; \\text{otherwise} \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">where z is either xy or x'y'. D is successful if and only if  <span class="math">D(I_b) = b</span> . The success probability of D is determined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[D(I_b) = b] &amp;= \\mathbf{Prob}[D(I_b) = 1|b = 1]\\mathbf{Prob}[b = 1] \\\\ &amp;+ \\mathbf{Prob}[D(I_b) = 0|b = 0]\\mathbf{Prob}[b = 0] \\\\ &amp;= 1(\\frac{1}{2}) + \\frac{1}{2}\\mathbf{Prob}[D(I_b) = 0|b = 0] \\\\ &amp;= \\frac{1}{2} + \\frac{1}{2}\\mathbf{Prob}[D(I_b) = 0|b = 0]. \\end{aligned}</span>$</p>

    <p class="text-gray-300">Note that  <span class="math">\\mathbf{Prob}[D(I_b) = 1|b=1] = 1</span>  always holds. Further,  <span class="math">\\mathbf{Prob}[b=1] = \\mathbf{Prob}[b=0] = 1/2</span>  holds since b is chosen randomly and uniformly from  <span class="math">\\{0,1\\}</span> . It remains to compute  <span class="math">\\mathbf{Prob}[D(I_b) = 0|b=0]</span> . For this, we consider the 4 possible cases for the parities of x and y represented by the disjoint events  <span class="math">E_{i,j}</span></p>

    <p class="text-gray-300"><span class="math">$E_{i,j} := \\{(i,j) : x, y \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|} \\land i = \\mathsf{parity}(x) \\land j = \\mathsf{parity}(y)\\}</span>$</p>

    <p class="text-gray-300">for  <span class="math">i, j \\in \\{0, 1\\}</span> . It follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[D(I_b) = 0 | b = 0] &amp;= \\sum_{i,j \\in \\{0,1\\}} \\mathbf{Prob}[D(I_b) = 0 | b = 0 \\land E_{i,j}] \\mathbf{Prob}[E_{i,j}] \\\\ &amp;= \\mathbf{Prob}[D(I_b) = 0 | b = 0 \\land E_{1,1}] \\mathbf{Prob}[E_{1,1}] \\\\ &amp;+ \\sum_{\\substack{i,j \\in \\{0,1\\}\\\\ (i,j) \\neq (1,1)}} \\mathbf{Prob}[D(I_b) = 0 | b = 0 \\land E_{i,j}] \\mathbf{Prob}[E_{i,j}]. \\end{aligned}</span>$</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\ \\ }^{36}</span> Note that if the group order |G| is known then its small prime factors can easily be computed by using well-known factoring algorithms.</p>

    <p class="text-gray-300">Since x and y are chosen uniformly and randomly we have Prob[Ei,j ] = 1/4 for all i, j &isin; {0, 1}. Further, we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[D(I_b) = 0 | b = 0 \\land E_{1,1}] = \\mathbf{Prob}[\\mathsf{parity}(z) = 0] = 3/4</span>$</p>

    <p class="text-gray-300">and for i, j &isin; {0, 1},(i, j) 6= (1, 1)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[D(I_b) = 0 | b = 0 \\land E_{i,j}] = \\mathbf{Prob}[\\mathsf{parity}(z) = 1] = 1/4.</span>$</p>

    <p class="text-gray-300">Substituting these results in the above equations we obtain:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[D(I_b) = 0|b = 0] = 1/4(3/4) + 1/4(3/4) = 6/16</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[D(I_b) = b] = 1/2 + 1/2(6/16) = 11/16.</span>$</p>

    <p class="text-gray-300">According to our definitions of the assumptions in Section <a href="#page-19-0">4</a> the adversary's success probability for decisional assumptions is normalized to (Prob[D(Ib) = b]&minus; 1/2)2 = 6/16. Thus, with (non-negligible) success probability 6/16 the distinguisher can recognize the correct DDH tuple.</p>

    <p class="text-gray-300">Remark 7.3. Theorem <a href="#page-48-3">7.1</a> holds also for other variants of the assumption with respect to the success probabilities perfect, weak and strong.</p>

    <p class="text-gray-300">Remark 7.4. It might look surprising that &lowast;-DSE<sup>&sigma;</sup> (c:&lowast;; g:h; f:nsprim) always holds, i.e., it's a fact, not an assumption. Of course, the crucial aspect is the rather restricted adversary model (the &sigma; in the assumption statement) which limits adversaries to generic algorithms. However, note that, consequently, to break DSE, one has to exploit deeper knowledge on the actual structure of the used algebraic groups. In particular, for appropriately chosen prime-order subgroups of <sup>&lowast;</sup> <sup>p</sup> and elliptic or hyper-elliptic curves no such exploitable knowledge could yet be found, and all of currently known efficient and relevant algorithms in these groups are generic algorithms, e.g., Pohlig-Hellman <a href="#page-76-9">(1978)</a> or Pollard&rho; <a href="#page-76-10">(Pollard</a> 1978). Nevertheless, care has to be applied when proving systems secure in the generic model <a href="#page-74-8">(Fischlin</a> 2000).</p>

    <p class="text-gray-300">Remark 7.5. As we will see later several (impossibility) results are proven in the generic model. All these proofs use similar techniques to determine bounds on the amount of information a generic adversary can obtain. For the better understanding, we describe this below by giving an example for DDH.</p>

    <p class="text-gray-300">First recall that in the generic model a group element a &isin; G is represented by its encoding &sigma;(x), with x &isin; <sup>|</sup>G<sup>|</sup> , using an encoding function &sigma;(&middot;) chosen randomly from the set &Sigma;G,g of bijective functions <sup>|</sup>G<sup>|</sup> &rarr; G. The generic adversary A<sup>&sigma;</sup> is given &sigma;(1), i.e., the encoding of a generator, and it is given access to oracles for performing addition &sigma;(x + y) &larr; &sigma;+(&sigma;(x), &sigma;(y)) and inversions &sigma;(&minus;x) &larr; &sigma;&minus;(x) on group elements (see also Section <a href="#page-10-0">3)</a> 37</p>

    <p class="text-gray-300">A decisional problem in this model is formulated as follows: The adversary A<sup>&sigma;</sup> is given the encodings of the secret, solution and random parts where the</p>

    <p class="text-gray-300"><sup>37</sup>As we will see later, for proving the impossibility of some reductions <sup>A</sup><sup>&sigma;</sup> is given access to additional oracles.</p>

    <p class="text-gray-300">latter two parts are in random order. Then  <span class="math">\\mathcal{A}^{\\sigma}</span>  has to decide on the correct order of these two parts. For DDH it means,  <span class="math">\\mathcal{A}^{\\sigma}</span>  is given  <span class="math">\\sigma(1), \\sigma(x), \\sigma(y)</span>  and the elements  <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span>  in random order. Now,  <span class="math">\\mathcal{A}^{\\sigma}</span>  has to decide which of the elements  <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span>  is the encoding of the solution part and which one corresponds to the encoding of the random part. Assuming  <span class="math">\\mathcal{A}^{\\sigma}</span>  makes T queries to the addition and inversion oracles we are interested in the amount of information it can obtain. Each time  <span class="math">\\mathcal{A}^{\\sigma}</span>  interacts with these oracles it learns the encoding  <span class="math">\\sigma(w_i)</span>  of a  <span class="math">w_i \\in \\mathbb{Z}_{|G|}</span>  where  <span class="math">w_i = P_i(x, y, xy, c)</span>  is a linear function  <span class="math">P_i</span>  in x, y, c, and can be determined by using the previous oracle queries.  <span class="math">\\mathcal{A}^{\\sigma}</span>  has the following possibilities to obtain information on the encoded values:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">\\mathcal{A}^{\\sigma}</span>  learns distinct (random) encoding of distinct values. More precisely, for all (i, j) with  <span class="math">P_i \\neq P_j</span>  we have  <span class="math">\\sigma(w_i) \\neq \\sigma(w_j)</span> .</li>
      <li>(b)  <span class="math">\\mathcal{A}^{\\sigma}</span>  learns a linear relation on the values x, y, xy and c. More precisely, there exists (i, j) such that  <span class="math">P_i \\neq P_j</span>  and  <span class="math">\\sigma(w_i) = \\sigma(w_j)</span> , meaning that either  <span class="math">P_i(x, y, xy, c) \\equiv P_j(x, y, xy, c) \\mod |G|</span>  holds or  <span class="math">P_i(x, y, c, xy) \\equiv P_j(x, y, c, xy) \\mod |G|</span> .</li>
    </ul>

    <p class="text-gray-300">In the case (a) the obtained values are independent random values and do not leak any information to  <span class="math">\\mathcal{A}^{\\sigma}</span>  at all. In contrast, case (b) represents the only way  <span class="math">\\mathcal{A}^{\\sigma}</span>  may obtain information on the values x,y,xy and c. If  <span class="math">\\mathcal{A}^{\\sigma}</span>  can find such a relation we consider it as successful in finding the correct order of the elements. Hence, we are interested in bounding the probability of  <span class="math">\\mathcal{A}^{\\sigma}</span> 's success. For this purpose, it suffices to bound the probability that a pair (i,j) with  <span class="math">i \\neq j</span>  exists such that  <span class="math">P_i(x,y,xy,c) \\equiv P_j(x,y,xy,c)</span>  mod |G| or  <span class="math">P_i(x,y,c,xy) \\equiv P_j(x,y,c,xy)</span>  mod |G| when given any T distinct linear polynomials and the random values  <span class="math">x,y,xy,c \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span> . As we will see later this bound is determined by exploiting the result of Theorem 7.1.</p>

    <p class="text-gray-300">In the following Theorem we show that also DIE cannot be solved by generic algorithms if the order |G| of the multiplicative group  <span class="math">\\mathbb{Z}_{|G|}^*</span>  is not divisible by small primes.</p>

    <h4 id="sec-misc-12" class="text-lg font-semibold mt-6">Theorem 7.2</h4>

    <p class="text-gray-300"><span class="math">$true \\implies *-DIE^{\\sigma}(c:*;g:h;f:nsprim)</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The following lemma associates the minimal generic complexity of solving DIE directly to the smallest prime factor of the order of the underlying group G. Theorem 7.2 immediately follows from this lemma and Remarks 7.6 and 7.5.</p>

    <p class="text-gray-300"><strong>Lemma 7.2</strong> Let G be a cyclic group and g a corresponding generator, let p' be the smallest prime factor of |G|. Let  <span class="math">\\mathcal{A}^{\\sigma}</span>  be any generic algorithm for groups G with maximum run time T. Then the following always holds:</p>

    <p class="text-gray-300"><span class="math">$(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}^{\\sigma}(\\mathcal{C}, (G, g), w_b, w_{\\bar{b}}) = b :: b \\stackrel{\\mathcal{R}}{\\leftarrow} \\{0, 1\\}; \\ \\mathcal{C} \\stackrel{\\mathcal{R}}{\\leftarrow} \\mathcal{U};</span>$</p>

    <p class="text-gray-300"><span class="math">$PI \\leftarrow SPI_{IE}((G, g)); \\ PI_{\\mathcal{R}} \\leftarrow SPI_{PI^{\\mathcal{P}}}(PI^{SI});</span>$</p>

    <p class="text-gray-300"><span class="math">$w_b \\leftarrow (PI^{publ}, PI^{sol});</span>$</p>

    <p class="text-gray-300"><span class="math">$w_{\\bar{b}} \\leftarrow (PI^{publ}, PI_{\\mathcal{R}}^{sol})</span>$</p>

    <p class="text-gray-300"><span class="math">$|-1/2| \\cdot 2) \\leq \\frac{2(T+4)(T+3)}{p&#x27;-2}</span>$</p>

    <p class="text-gray-300">Proof. Assume, we are given the encodings  <span class="math">\\sigma(1)</span> ,  <span class="math">\\sigma(x)</span>  and  <span class="math">\\{\\sigma(x^{-1}), \\sigma(c)\\}</span>  where  <span class="math">x \\in \\mathbb{Z}_{|G|}^*</span> . After T computation steps the algorithm  <span class="math">\\mathcal{A}^{\\sigma}</span>  can compute at most T+4 distinct linear combinations  <span class="math">P_i</span>  of the elements  <span class="math">1, x, x^{-1}</span>  and c, i.e., it obtains</p>

    <p class="text-gray-300"><span class="math">$\\sigma(P_i(1, x, x^{-1}, c)) = \\sigma(a_{i1} + a_{i2}x + a_{i3}x^{-1} + a_{i4}c),</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_{ij}</span>  are constant coefficients. Furthermore, it is not a-priori known to  <span class="math">\\mathcal{A}^{\\sigma}</span>  which one of the values in  <span class="math">\\{a_{i3}, a_{i4}\\}</span>  is the coefficient for  <span class="math">x^{-1}</span>  and which one corresponds to c.  <span class="math">\\mathcal{A}^{\\sigma}</span>  may be able to distinguish  <span class="math">\\sigma(x^{-1})</span>  and  <span class="math">\\sigma(c)</span>  by finding relations (collisions) between distinct linear combinations  <span class="math">(P_i, P_j)</span>  with  <span class="math">i \\neq j</span> . This means it obtains  <span class="math">\\sigma(P_i(1, x, x^{-1}, c)) = \\sigma(P_j(1, x, x^{-1}, c))</span>  or  <span class="math">\\sigma(P_i(1, x, c, x^{-1})) = \\sigma(P_j(1, x, c, x^{-1}))</span> , implying either  <span class="math">P_i(1, x, x^{-1}, c) \\equiv P_j(1, x, x^{-1}, c)</span>  mod |G| or  <span class="math">P_i(1, x, c, x^{-1}) \\equiv P_j(1, x, c, x^{-1})</span>  mod |G|. Let E denote this event. We compute an upper bound for the probability that E occurs: There are  <span class="math">\\binom{T+4}{2} = \\frac{(T+4)(T+3)}{2}</span>  possible distinct pairs of polynomials  <span class="math">(P_i, P_j)</span> . For each such a pair (i, j) we can bound the number of solutions to  <span class="math">P_i \\equiv P_j \\mod p^e</span>  for any prime power  <span class="math">p^e</span>  that exactly divides |G|, i.e.,  <span class="math">p^{e+1} \\not | |G|</span>  (Note that uniformly distributed random values mod |G| are also randomly and uniformly distributed mod  <span class="math">p^e</span> .) More precisely, we consider the solutions to the following polynomials</p>

    <p class="text-gray-300"><span class="math">$F_{i,j}(x,c) := x[P_i(1,x,x^{-1},c) - P_j(1,x,x^{-1},c)] \\equiv 0 \\bmod p^e</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$G_{i,j}(x,c) := x[P_i(1,x,c,x^{-1}) - P_j(1,x,c,x^{-1})] \\equiv 0 \\bmod p^e.</span>$</p>

    <p class="text-gray-300">Here the polynomials F or G are obtained by multiplying both sides of the congruence  <span class="math">P_i \\equiv P_j \\mod p^e</span>  with x and then reordering the resulting congruence.</p>

    <p class="text-gray-300">Hence, we bound the probability that a random tuple  <span class="math">(x,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span>  is a zero of the polynomials F or  <span class="math">G \\mod p^e</span>  (Note that  <span class="math">\\mathbb{Z}_{|G|}^*</span>  is the domain of the secret exponents of DIE input tuples.)</p>

    <p class="text-gray-300">To do this, we first bound the number of solutions (x,c) to F or G mod  <span class="math">p^e</span>  where (x,c) are randomly selected from  <span class="math">\\mathbb{Z}_{p^e}^2</span> : The total degree of each of the polynomials F and G is two. It follows from Lemma 7.1 that the probability of a random tuple  <span class="math">(x,c)\\in\\mathbb{Z}_{p^e}^2</span>  to be a zero of F or G mod  <span class="math">p^e</span>  is at most 2(2/p)=4/p. There are  <span class="math">p^{2e}</span>  tuples (x,c) in  <span class="math">\\mathbb{Z}_{p^e}^2</span> . Thus, there are at most  <span class="math">p^{2e}4/p=4p^{2e-1}</span>  zeros for F or G mod  <span class="math">p^e</span> .</p>

    <p class="text-gray-300">Further, there are  <span class="math">(\\varphi(p^e))^2 = (p^e - p^{e-1})^2</span>  tuples in  <span class="math">\\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span> . Hence, the probability that such a tuple is a zero of F or G mod  <span class="math">p^e</span>  is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$4p^{2e-1}/(p^e-p^{e-1})^2</span>$
. It follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[E] &amp; \\leq &amp; \\frac{(T+4)(T+3)}{2} \\frac{4p^{2e-1}}{(p^e - p^{e-1})^2} \\\\ &amp; = &amp; \\frac{(T+4)(T+3)}{2} \\frac{4p^{2e-1}}{p^{2e} + p^{2e-2} - 2p^{2e-1}} \\\\ &amp; = &amp; (T+4)(T+3) \\frac{2p}{p^2 - 2p + 1} \\\\ &amp; \\leq &amp; (T+4)(T+3) \\frac{2p}{p^2 - 2p} = (T+4)(T+3) \\frac{2}{p-2} \\\\ &amp; \\leq &amp; (T+4)(T+3) \\frac{2}{p&#x27;-2}. \\end{aligned}</span>$</p>

    <p class="text-gray-300">If the complementary event  <span class="math">\\bar{E}</span>  occurs, then  <span class="math">\\mathcal{A}^{\\sigma}</span>  cannot obtain any information about the bit b except pure guessing. Thus, the success probability of  <span class="math">\\mathcal{A}^{\\sigma}</span>  for correctly outputting b is</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[\\mathcal{A}^{\\sigma}(..) = b] &amp;= \\mathbf{Prob}[E] + \\frac{1}{2}\\mathbf{Prob}[\\bar{E}] \\\\ &amp;= \\mathbf{Prob}[E] + \\frac{1 - \\mathbf{Prob}[E]}{2} \\\\ &amp;= \\frac{1}{2} + \\frac{\\mathbf{Prob}[E]}{2} \\\\ &amp;\\leq \\frac{1}{2} + \\frac{(T+4)(T+3)}{p&#x27;-2}. \\end{aligned}</span>$</p>

    <p class="text-gray-300">Remark 7.6. In the classical formulation of decision problems the adversary gets, depending on the challenge b, either the correct element or a random element as input, i.e., in the case of DIE the adversary gets  <span class="math">g^x</span>  together with  <span class="math">g^{x^{-1}}</span>  if b=0 and  <span class="math">g^c</span>  (with  <span class="math">c \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}</span> ) if b=1. The formulation used in Lemma 7.2 considers a slightly different variant of the decisional problem type: We consider here an adversary which receives, in random order, both the correct and a random element and the adversary has to decide on the order of the elements, i.e., the adversary gets  <span class="math">g^x</span>  and  <span class="math">(g^{x^{-1}}, g^c)</span>  for b=0 and  <span class="math">(g^c, g^{x^{-1}})</span>  for b=1.</p>

    <p class="text-gray-300">This formulation makes the proofs easier to understand. However, note that both variants are equivalent.  <span class="math">\\quad \\circ</span></p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8">7.2 DSE versus DDH</h3>

      <h4 id="sec-7.2.1" class="text-lg font-semibold mt-6">7.2.1 High Granular</h4>

    <p class="text-gray-300">Wolf (1999) shows the following two results on the relation between DSE and DDH: DSE can easily be reduced to DDH, however, as Theorem 7.4 shows, the converse doesn't hold.</p>

    <p class="text-gray-300">Theorem 7.3 (Wolf 1999)</p>

    <p class="text-gray-300"><span class="math">$\\epsilon</span>$
-DSE(c:*; g:h; f:o)  <span class="math">\\xrightarrow{\\alpha&#x27; = \\alpha; \\ t&#x27; = t + O(\\log |G|)} \\epsilon</span> -DDH(c:*; g:h; f:o)</p>

    <p class="text-gray-300"><em>Proof.</em> Given a DDH oracle  <span class="math">\\mathcal{O}_{DDH}</span>  which breaks  <span class="math">\\epsilon</span> -DDH(c:*; g:h; f:*), one can construct an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span>  for breaking  <span class="math">\\epsilon</span> -DSE(c:*; g:h; f:o) as follows:  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span>  randomizes its input tuple  <span class="math">((G,g),(g^x),(g^z))</span>  by choosing  <span class="math">r \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span>  and constructing the tuple</p>

    <p class="text-gray-300"><span class="math">$I = ((G, g), (g^X, g^Y), (g^Z))</span>$</p>

    <p class="text-gray-300">where  <span class="math">g^X := g^x</span> ,  <span class="math">g^Y := g^{x+r}</span>  and  <span class="math">g^Z := g^z(g^x)^r</span> . The tuple I has the correct input distribution for  <span class="math">\\mathcal{O}_{DDH}</span>  because (i)  <span class="math">g^Y := g^{x+r}</span>  is a random group element independent of  <span class="math">g^X</span> , and (ii) the last element  <span class="math">g^Z</span>  is  <span class="math">g^{XY}</span>  if and only if  <span class="math">g^z = g^{x^2}</span> , and it is a random group element otherwise.</p>

    <p class="text-gray-300">Success probability: There is a single call to the DDH oracle with correctly distributed inputs. Thus, the resulting success probability is  <span class="math">\\alpha_{DSE} = \\alpha_{DDH}</span> , and since  <span class="math">\\alpha_{DSE}</span>  is invariant, it follows that  <span class="math">\\alpha_{DDH}</span>  is also invariant.</p>

    <p class="text-gray-300">Efficiency: There is a single oracle call, and by applying the square and multiply method one requires  <span class="math">O(\\log |G|)</span>  group operations for performing the exponentiations.</p>

    <p class="text-gray-300">Remark 7.7. The reduction in Theorem 7.3 also holds for other variants of the assumption with respect to the success probabilities perfect, weak and strong.</p>

    <p class="text-gray-300">Remark 7.8. In the proof of Theorem 7.3 we selected random elements from  <span class="math">\\mathbb{Z}_{|G|}</span>  exploiting that the group order is known. While the group order might not always be publicly known, there is always a publicly known upper bound B(|G|) on the group order as mentioned in Section 3 where Parameter 3 is discussed. If we now consider the two probability ensembles</p>

    <p class="text-gray-300"><span class="math">$X_k^* := \\{g^{x^*} \\, :: \\, G \\leftarrow SG(1^k) \\ \\land \\ g \\leftarrow Sg(G) \\ \\land \\ x^* \\xleftarrow{\\mathcal{R}} \\mathbbm{Z}_{2^kB(|G|)} \\}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$X_k := \\{g^x \\, :: \\, G \\leftarrow SG(1^k) \\ \\land \\ g \\leftarrow Sg(G) \\ \\land \\ x \\xleftarrow{\\mathcal{R}} \\mathbbm{Z}_{|G|}\\},</span>$</p>

    <p class="text-gray-300">we prove that they are statistically indistinguishable. First, observe that we compute in the exponents implicitly modulo |G|. Therefore, it is sufficient to consider the ensembles</p>

    <p class="text-gray-300"><span class="math">$Y_k^* := \\{x^* \\pmod{|G|} \\, :: \\, G \\leftarrow SG(1^k) \\ \\land \\ x^* \\xleftarrow{\\mathcal{R}} \\mathbbm{Z}_{2^k B(|G|)} \\}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$Y_k := \\{x :: G \\leftarrow SG(1^k) \\ \\land \\ x \\xleftarrow{\\mathcal{R}} \\mathbb{Z}_{|G|} \\}.</span>$</p>

    <p class="text-gray-300">Investigating their statistical difference, we can derive following inequalities:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Delta_{(Y^*,Y)}(k) &amp;:= \\sum_{y \\in \\mathbb{Z}_{|G|}} |\\mathbf{Prob}[Y_k^* = y] - \\mathbf{Prob}[Y_k = y]| \\\\ &amp;= \\sum_{y \\in \\mathbb{Z}_{|G|}} |\\mathbf{Prob}[Y_k^* = y] - \\frac{1}{|G|}| \\\\ &amp;\\leq \\sum_{y \\in \\mathbb{Z}_{|G|}} (\\max_{y \\in \\mathbb{Z}_{|G|}} (\\mathbf{Prob}[Y_k^* = y]) - \\min_{y \\in \\mathbb{Z}_{|G|}} (\\mathbf{Prob}[Y_k^* = y])) \\\\ &amp;= |G| \\; (\\max_{y \\in \\mathbb{Z}_G} (\\mathbf{Prob}[Y_k^* = y]) - \\min_{y \\in \\mathbb{Z}_G} (\\mathbf{Prob}[Y_k^* = y])) \\\\ &amp;= |G| \\; (\\frac{[2^k B(|G|)/|G|]}{2^k B(|G|)} - \\frac{\\lfloor 2^k B(|G|)/|G| \\rfloor}{2^k B(|G|)}) \\\\ &amp;= \\frac{|G|}{2^k B(|G|)} \\\\ &amp;\\leq \\frac{1}{2^k} \\end{split}</span>$</p>

    <p class="text-gray-300">Clearly, from this it follows that Y and  <span class="math">Y^*</span>  (and indirectly X and  <span class="math">X^*</span> ) are statistically indistinguishable. Given that the behavior of the oracle machine cannot significantly differ on input distributions which are statistically indistinguishable from the correct ones &mdash; otherwise we would have a computational and therefore also statistical distinguisher &mdash; it is sufficient to sample random exponents from  <span class="math">\\mathbb{Z}_{2^kB(|G|)}</span>  to make the reduction work also for arbitrary group families.<sup>38</sup></p>

    <p class="text-gray-300">0</p>

    <p class="text-gray-300">Remark 7.9. Following Remark 6.2, the result of Theorem 7.3 easily extends to the medium-granular variant.  <span class="math">\\circ</span></p>

    <p class="text-gray-300">Next theorem states that a DSE oracle, even when perfect, is of no help in breaking DDH assumptions.</p>

    <p class="text-gray-300">
<span class="math">$true \\implies 1\\text{-DDH}^{\\sigma}(c:*;g:h;f:nsprim;\\mathcal{O}_{1\\text{-DSE}(c:*;g:h;f:nsprim)})</span>$</p>

    <p class="text-gray-300">Remark 7.10. More precisely, Wolf shows, the probability that any  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  can correctly distinguish correct DDH inputs from incorrect ones is at most  <span class="math">\\frac{(T+5)(T+4)}{2p&#x27;}</span>  where p' is the smallest prime factor of |G| and T is an upper bound on the algorithm's runtime.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{38}&lt;/sup&gt;</span>  A similar argument (but without proof) is given by Boneh (1998) for random self-reducing of DDH with unknown order. He proposes to sample from  <span class="math">\\mathbb{Z}_{B(|G|)^2}</span> . However, as in virtually all practical cases B(|G|) is considerably larger than  <span class="math">2^k</span>  this results in a much more expensive reduction. Let us consider following (common) example: The computation is done in subgroups of  <span class="math">\\mathbb{Z}_p^*</span>  with prime order q and an obvious upper bound on the group order is p. For concreteness, let us use the group parameters suggested by Lenstra and Verheul (2001) for security parameter k=80, i.e., p and q having approximately 1460 and 142 bits, respectively. While our method requires exponentiation with exponents of 1540 bits, Boneh's method would require exponentiation with exponents of 2920 bits, i.e., a huge difference!</p>

    <p class="text-gray-300">Remark 7.11. Theorem 7.4 holds also for other variants of the DDH assumption with respect to success probabilities weak, invariant and strong.</p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8">7.3 DIE versus DDH</h3>

      <h4 id="sec-7.3.1" class="text-lg font-semibold mt-6">7.3.1 High Granular</h4>

    <p class="text-gray-300">In the following we prove that similar relations also hold between DDH and DIE. We first prove a reduction from DIE to DDH, and then show in Theorem 7.7 that the converse does not hold in generic model. This means a DIE oracle, even when perfect, is of no help in breaking DDH assumption.</p>

    <h3 id="sec-misc-13" class="text-xl font-semibold mt-8">Theorem 7.5</h3>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\{(1-1/\\mathsf{poly}(k)), &amp;\\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-DIE}(\\mathbf{c}\\text{:*}; \\mathbf{g}\\text{:h}; \\mathbf{f}\\text{:nsprim}) \\\\ &amp; \\xrightarrow{\\alpha&#x27; \\geq \\frac{2\\varphi(|G|)-1}{|G|}\\alpha; \\ t&#x27; = t + O(\\log|G|)} \\\\ &amp; \\xrightarrow{\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-DDH}(\\mathbf{c}\\text{:*}; \\mathbf{g}\\text{:h}; \\mathbf{f}\\text{:nsprim})} \\end{split}</span>$</p>

    <p class="text-gray-300">Proof. We prove the following statement: Given a DDH oracle  <span class="math">\\mathcal{O}_{DDH}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -DDH(c:*; g:h; f:nsprim) with success probability  <span class="math">\\alpha_{DDH}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DDH}}</span>  which breaks the assumption  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -DIE(c:*; g:h; f:nsprim) with success probability  <span class="math">\\alpha_{DIE}(k) \\geq \\frac{2\\varphi(|G|)-1}{|G|}\\alpha_{DDH}(k)</span> , using a single call to  <span class="math">\\mathcal{O}_{CDH}</span>  and  <span class="math">O(\\log |G|)</span>  group operations.</p>

    <p class="text-gray-300">Suppose, we are given a DIE input tuple  <span class="math">((G,g),(g^x),(g^z))</span>  with  <span class="math">z=x^{-1}</span>  or z=c where  <span class="math">c\\in_{\\mathcal{R}}\\mathbb{Z}^*_{|G|}</span> . We transform the DIE input tuple to a DDH input tuple  <span class="math">((G,g),(g^X,g^Y),(g^Z))</span>  as follows: Set</p>

    <p class="text-gray-300"><span class="math">$g^X := g^{x+a_1}, \\quad g^Y := g^{a_2z+a_3}, \\quad g^Z := g^{a_4^*x+a_5^*z+a_6^*}.</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_1, a_2, a_3 \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span> ,  <span class="math">a_4^* = a_3</span> ,  <span class="math">a_5^* = a_2 a_1</span>  and  <span class="math">a_6^* = a_2 + a_1 a_3</span> . Here the superscript &quot;*&quot; indicates that the corresponding values are constructed.</p>

    <p class="text-gray-300">If  <span class="math">z=x^{-1}</span> , we get a correct DDH input tuple  <span class="math">((G,g),(g^X,g^Y),(g^Z))</span>  because (i) X,Y are randomly and uniformly distributed over  <span class="math">\\mathbb{Z}_{|G|}</span>  due to the randomization with  <span class="math">a_1,a_2,a_3\\in_{\\mathcal{R}}\\mathbb{Z}_{|G|}</span> , and (ii) the following holds</p>

    <p class="text-gray-300"><span class="math">$XY = a_2xz + a_3x + a_2a_1z + a_1a_3</span>$</p>

    <p class="text-gray-300"><span class="math">$= a_2xx^{-1} + a_3x + a_2a_1z + a_1a_3</span>$</p>

    <p class="text-gray-300"><span class="math">$= a_3x + a_2a_1x^{-1} + a_2 + a_1a_3</span>$</p>

    <p class="text-gray-300"><span class="math">$= a_4^* + a_5^*x^{-1} + a_6^*</span>$</p>

    <p class="text-gray-300"><span class="math">$= Z.</span>$</p>

    <p class="text-gray-300">The case z=c is more involved. Here we apply the result of Lemma 7.3: For group orders with no small prime factors, the (constructed) tuples (X,Y,Z) are statistically indistinguishable from tuples (X',Y',Z') chosen randomly from  <span class="math">\\mathbb{Z}^3_{|G|}</span> , and therefore, also indistinguishable for the DDH oracle. Thus, also in this case we get a correct DDH input tuple.</p>

    <p class="text-gray-300">Success probability: There is single call to  <span class="math">\\mathcal{O}_{DDH}</span>  and, therefore, the resulting success probability is</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{DIE}(k) = \\mathbf{Prob}[E_k]\\alpha_{DDH}(k) \\ge (\\frac{2\\varphi(|G|}{|G|} - 1)\\alpha_{DDH}(k).</span>$</p>

    <p class="text-gray-300">The reason for the factor  <span class="math">\\operatorname{\\mathbf{Prob}}[E_k]</span>  is that the input tuples to  <span class="math">\\mathcal{O}_{DDH}</span>  are legal only if the tuples (X,Y,Z) are randomly and uniformly distributed over  <span class="math">\\mathbb{Z}_{|G|}</span> , and this is the case if the event  <span class="math">E_k</span>  occurs.</p>

    <p class="text-gray-300">In the following, we set  <span class="math">\\gamma(k) := \\frac{2\\varphi(|G|)}{|G|} - 1</span>  (Note that |G| is a function of the security parameter k, see also Lemma 6.5) The type of resulting success probability  <span class="math">\\alpha_{DIE}(k)</span>  depends on the type of  <span class="math">\\alpha_{DDH}(k)</span> . The proofs are similar to those of Lemma 6.6. Nevertheless, for completeness, they are given below.</p>

    <p class="text-gray-300">Perfect oracle  <span class="math">(\\alpha_{DDH}(k) \\nleq_{\\infty} 1)</span> : The resulting success probability cannot be perfect because there is a non-zero error probability when querying the DDH oracle.</p>

    <p class="text-gray-300">Weak oracle  <span class="math">(\\alpha_{DDH}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) weak: Since |G| contains no small prime factors, it follows from Lemma 6.5 that  <span class="math">1-\\gamma(k)=2(1-\\frac{\\varphi(|G|}{|G|})&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Thus, we can write  <span class="math">\\gamma(k)&gt;1-1/\\mathsf{poly}(k)</span> , meaning that  <span class="math">\\gamma(k)</span>  is non-negligible. Further, we have  <span class="math">\\alpha_{DDH}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . It follows  <span class="math">\\gamma(k)\\alpha_{DDH}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span>  (see also Section 2.2) Finally, since  <span class="math">\\alpha_{DIE}(k) \\ge \\gamma(k)\\alpha_{DDH}(k)</span> , it follows  <span class="math">\\alpha_{DIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{DDH} \\not&lt;_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant: As shown in the weak case, we can write  <span class="math">\\gamma(k) &gt;_{\\infty} 1-1/\\mathsf{poly}(k)</span> . More precisely, for any  <span class="math">\\epsilon&#x27; &gt; 0</span>  there exists a  <span class="math">k_0</span>  such that for all  <span class="math">k &gt; k_0</span>  we have  <span class="math">\\gamma(k) &gt;_{\\infty} 1 - \\epsilon&#x27;</span> . From  <span class="math">\\alpha_{DDH}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , it follows that for any  <span class="math">k&#x27;_0</span>  there exists a  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{DDH}(k_1) \\ge \\epsilon_1</span> . Thus, for any  <span class="math">k&#x27;_0 &gt; k_0</span>  there exists a  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{DIE}(k_1) \\ge \\epsilon_2</span>  where  <span class="math">\\epsilon_2 := (1 - \\epsilon&#x27;)\\epsilon_1</span> . It follows  <span class="math">\\alpha_{DIE}(k) \\not&lt;_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{DDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong: As shown in the weak case, we can write  <span class="math">\\gamma(k) &gt;_{\\infty} 1 - 1/\\mathsf{poly}(k)</span> . Further, we have  <span class="math">1 - \\alpha_{DDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . It follows from Lemma 6.7 that  <span class="math">1 - \\gamma(k)\\alpha_{DDH}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Finally, since  <span class="math">\\alpha_{DIE}(k) \\geq \\gamma(k)\\alpha_{DDH}(k)</span> , it follows  <span class="math">1 - \\alpha_{DIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 7.3</strong> Let SG be a group sampler of groups whose orders contain no small prime factors. Further, let  <span class="math">V_k</span>  and  <span class="math">V&#x27;_k</span>  be probability ensembles defined as</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} V_k &amp;:= &amp; \\{(X,Y,Z) :: G \\leftarrow SG(1^k) \\ \\land \\\\ &amp; (x,z) \\in_{\\mathcal{R}} (\\mathbb{Z}^*_{|G|})^2 \\land \\ (a_1,a_2,a_3) \\in_{\\mathcal{R}} \\mathbb{Z}^3_{|G|} \\land \\\\ &amp; a_4^* = a_3 \\land \\ a_5^* = a_2a_1 \\land \\ a_6^* = a_2 + a_1a_3 \\land \\\\ &amp; X := x + a_1 \\land \\ Y := a_2z + a_3; \\land \\ Z := a_4^*x + a_5^*z + a_6^*\\}, \\\\ V_k&#x27; &amp;:= &amp; \\{(X&#x27;,Y&#x27;,Z&#x27;) :: G \\leftarrow SG(1^k) \\land \\ (X&#x27;,Y&#x27;,Z&#x27;) \\in_{\\mathcal{R}} \\mathbb{Z}^3_{|G|}\\}. \\end{array}</span>$</p>

    <p class="text-gray-300">Then  <span class="math">V_k</span>  and  <span class="math">V&#x27;_k</span>  are statistically indistinguishable.</p>

    <p class="text-gray-300"><em>Proof.</em> According to the definition of statistical indistinguishability (see Section 2.4) we have to prove that the statistical difference  <span class="math">\\Delta_{(V,V&#x27;)}(k)</span>  is negligible in security parameter k (here, for group orders |G| with no small prime factors)</p>

    <p class="text-gray-300">Clearly,  <span class="math">\\operatorname{\\mathbf{Prob}}[V_k&#x27;=v]=1/|G|^3</span>  holds for all  <span class="math">v\\in\\mathbb{Z}^3_{|G|}</span>  by definition. Next, we partition  <span class="math">\\mathbb{Z}^3_{|G|}</span>  in two disjoint sets D and its complement  <span class="math">\\bar{D}=\\mathbb{Z}^3_{|G|}\\setminus D</span>  such that  <span class="math">\\operatorname{\\mathbf{Prob}}[V_k=v]\\geq 1/|G|^3</span>  for all  <span class="math">v\\in \\bar{D}</span> . Then we can write</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Delta_{(V,V&#x27;)}(k) &amp;:= \\sum_{v \\in \\mathbb{Z}_{|G|}^3} |\\mathbf{Prob}[V_k = v] - \\mathbf{Prob}[V_k&#x27; = v]| \\\\ &amp;= \\sum_{v \\in \\mathbb{Z}_{|G|}^3} |\\mathbf{Prob}[V_k = v] - 1/|G|^3| \\\\ &amp;= \\sum_{v \\in D} (\\mathbf{Prob}[V_k = v] - 1/|G|^3) + \\\\ &amp;= \\sum_{v \\in \\bar{D}} (1/|G|^3 - \\mathbf{Prob}[V_k = v]). \\end{split}</span>$</p>

    <p class="text-gray-300">It follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Delta_{(V,V&#x27;)}(k) &amp; \\leq &amp; \\sum_{v \\in D} \\left( \\mathbf{Prob}[V_k = v] - 1/|G|^3 \\right) + \\\\ &amp; \\sum_{v \\in \\bar{D}} \\left( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}^3_{|G|}} (\\mathbf{Prob}[V_k = v]) \\right) \\\\ &amp; = &amp; \\sum_{v \\in D} \\mathbf{Prob}[V_k = v] - |D|/|G|^3 + \\\\ &amp; |\\bar{D}| \\left( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}^3_{|G|}} (\\mathbf{Prob}[V_k = v]) \\right). \\end{split}</span>$</p>

    <p class="text-gray-300">We exploit the relations  <span class="math">\\sum_{v \\in D} \\mathbf{Prob}[V_k = v] = 1 - \\sum_{v \\in \\bar{D}} \\mathbf{Prob}[V_k = v]</span>  and  <span class="math">|D| = |G|^3 - |\\bar{D}|</span> , and substitute them in the above inequality:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Delta_{(V,V&#x27;)}(k) &amp; \\leq &amp; 1 - \\sum_{v \\in \\bar{D}} \\mathbf{Prob}[V_k = v] - \\frac{|G|^3 - |\\bar{D}|}{|G|^3} + \\\\ &amp; &amp; |\\bar{D}| \\big( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) \\\\ &amp; \\leq &amp; 1 - \\sum_{v \\in \\bar{D}} \\big( \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) - 1 + |\\bar{D}|/|G|^3 + \\\\ &amp; &amp; |\\bar{D}| \\big( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) \\\\ &amp; = &amp; -|\\bar{D}| \\big( \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) + |\\bar{D}|/|G|^3 + \\\\ &amp; &amp; |\\bar{D}| \\big( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) \\\\ &amp; = &amp; 2|\\bar{D}|/|G|^3 - 2|\\bar{D}| \\big( \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) \\\\ &amp; \\leq &amp; 2|G|^3 \\big( 1/|G|^3 - \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v]) \\big) \\end{split}</span>$</p>

    <p class="text-gray-300">where for the last step we used the fact  <span class="math">|\\bar{D}| \\leq |G|^3</span> . Next, we determine a lower bound for  <span class="math">\\min_{v \\in \\mathbb{Z}_{|G|}^3}(\\mathbf{Prob}[V_k = v])</span> . For this, we first consider the probability  <span class="math">\\mathbf{Prob}[V_k = v]</span>  together with the event  <span class="math">E_k := E(V_k) : (1 - xz) \\in \\mathbb{Z}_{|G|}^*</span> . It follows</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{\\mathbf{Prob}}[V_k = v] = \\operatorname{\\mathbf{Prob}}[V_k = v \\wedge E_k] + \\operatorname{\\mathbf{Prob}}[V_k = v \\wedge \\overline{E}_k]</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\bar{E}_k</span>  is the complement of  <span class="math">E_k</span> . Thus, we can write</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\min_{v \\in \\mathbb{Z}^3_{|G|}} (\\mathbf{Prob}[\\,V_k = v]) &amp; \\geq &amp; \\min_{v \\in \\mathbb{Z}^3_{|G|}} (\\mathbf{Prob}[\\,V_k = v \\wedge E_k]) \\\\ &amp; + \\min_{v \\in \\mathbb{Z}^3_{|G|}} (\\mathbf{Prob}[\\,V_k = v \\wedge \\bar{E}_k]). \\end{split}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[V_k = v \\wedge \\bar{E}_k]) \\geq 0</span> , it follows</p>

    <p class="text-gray-300"><span class="math">$\\min_{v \\in \\mathbb{Z}^3_{|G|}}(\\mathbf{Prob}[\\,V_k = v]) \\geq \\min_{v \\in \\mathbb{Z}^3_{|G|}}(\\mathbf{Prob}[\\,V_k = v \\wedge E_k]).</span>$</p>

    <p class="text-gray-300">Further, we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[\\,V_k = v \\wedge E_k] &amp;= &amp;\\mathbf{Prob}[\\,V_k = v | E_k] \\mathbf{Prob}[E_k] \\\\ &amp;\\geq &amp;\\frac{1}{|G|^3} \\frac{\\varphi(|G|) - (|G| - \\varphi(|G|))}{|G|} \\\\ &amp;\\geq &amp;\\frac{1}{|G|^3} \\big(\\frac{2\\varphi(|G|}{|G|} - 1\\big). \\end{aligned}</span>$</p>

    <p class="text-gray-300">To see this, we consider the probability terms separately:</p>

    <p class="text-gray-300">(i) For all v it holds  <span class="math">\\operatorname{\\mathbf{Prob}}[V_k=v|E_k]=1/|G|^3</span> . This is because, if  <span class="math">E(V_k)</span>  (i.e.,  <span class="math">1-xz\\in\\mathbb{Z}^*_{|G|}</span> ) holds then the tuples (X,Y,Z) are uniformly distributed over  <span class="math">\\mathbb{Z}^3_{|G|}</span> . One can see this as follows: For any  <span class="math">(x,z)\\in\\mathbb{R}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{|G|}^* \\times \\mathbb{Z}_{|G|}^*</span>  with  <span class="math">z \\neq x^{-1}</span>  and for any  <span class="math">(X, Y, Z) \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}^3</span> , there exist exactly one tuple  <span class="math">(a_1, a_2, a_3) \\in \\mathbb{Z}_{|G|}^3</span>  such that following equations hold</p>

    <p class="text-gray-300"><span class="math">$X := x + a_1, \\quad Y := a_2 z + a_3, \\quad Z := a_4^* x + a_5^* z + a_6^*</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_4^* = a_3</span> ,  <span class="math">a_5^* = a_2 a_1</span> ,  <span class="math">a_6^* = a_2 + a_1 a_3</span> . We compute  <span class="math">a_1, a_3</span>  from the first equations and set them in the third and obtain:</p>

    <p class="text-gray-300"><span class="math">$Z = XY + a_2 - a_2xz, \\ a_2(1 - xz) = Z - XY.</span>$</p>

    <p class="text-gray-300">The last equation has a solution for  <span class="math">a_2=(Z-XY)(1-xz)^{-1}</span>  if  <span class="math">\\gcd(1-xz,|G|)=1</span> , i.e.,  <span class="math">1-xz\\in\\mathbb{Z}^*_{|G|}</span> . Having  <span class="math">a_2</span>  computed, we can obtain the other values by computing  <span class="math">a_1=X-x</span>  and  <span class="math">a_3=Y-a_2z</span> .</p>

    <p class="text-gray-300">(ii)  <span class="math">\\operatorname{\\mathbf{Prob}}[E_k] \\geq \\frac{2\\varphi(|G|)}{|G|} - 1</span> : As x, z are elements from  <span class="math">\\mathbb{Z}^*_{|G|}</span> , there are  <span class="math">\\varphi(|G|)</span>  possible values for 1-xz which may or may not be relatively prime to |G|. In the worst case, at most  <span class="math">|G| - \\varphi(|G|)</span>  of them are not relatively prime to |G|. Thus, in the worst case, the number of possible values for 1-xz relatively prime to |G| is still  <span class="math">\\varphi(|G|) - (|G| - \\varphi(|G|)) = 2\\varphi(|G|) - |G|</span> . Therefore, we can write  <span class="math">\\operatorname{\\mathbf{Prob}}[E_k] \\geq \\frac{2\\varphi(|G|) - |G|}{|G|} = \\frac{2\\varphi(|G|)}{|G|} - 1</span> .</p>

    <p class="text-gray-300">It follows</p>

    <p class="text-gray-300"><span class="math">$\\mathrm{min}_{v \\in \\mathbb{Z}^3_{|G|}}(\\mathbf{Prob}[\\,V_k = v \\wedge E_k]) = \\frac{1}{|G|^3}\\big(\\frac{2\\varphi(|G|}{|G|} - 1\\big).</span>$</p>

    <p class="text-gray-300">Now, we return to the statistical difference of the distributions. Substituting the above results, we obtain</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lcl} \\Delta_{(V,V&#x27;)}(k) &amp; \\leq &amp; 2|G|^3 \\left(1/|G|^3 - \\min_{v \\in \\mathbb{Z}_{|G|}^3} (\\mathbf{Prob}[\\,V_k = v]) \\right) \\\\ &amp; \\leq &amp; 2|G|^3 \\left(1/|G|^3 - \\frac{1}{|G|^3} \\big(\\frac{2\\varphi(|G|}{|G|} - 1)\\big) \\\\ &amp; \\leq &amp; \\frac{4|G|^3}{|G|^3} \\big(1 - \\frac{2\\varphi(|G|)}{|G|} \\big) \\\\ &amp; \\leq &amp; 4 \\Big(1 - \\frac{\\varphi(|G|)}{|G|} \\Big) \\end{array}</span>$</p>

    <p class="text-gray-300">For |G| with no small prime factors, it follows from Lemma 6.5 that  <span class="math">1-\\frac{\\varphi(|G|}{|G|}&lt;_{\\infty}1/\\mathsf{poly}(k)</span>  and consequently  <span class="math">\\Delta_{(V,V&#x27;)}(k)&lt;_{\\infty}1/\\mathsf{poly}(k)</span> . This completes the proof.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{39}&lt;/sup&gt;</span>  The other solutions are all congruence modulo |G|. Note that if  <span class="math">d=\\gcd((1-xz),Z-XY)</span>  the equation has exactly d solutions for a given (x,z). In this case, we have collisions, i.e., there exist d different  <span class="math">(a_1,a_2,a_3)</span>  tuples and that (X,Y,Z) are in general not uniformly distributed over  <span class="math">\\mathbb{Z}^3_{|G|}</span> .</p>

    <p class="text-gray-300">Remark 7.12. The above reduction does not hold for perfect success probability because of introduced non-zero error probability. However, for groups of prime order the reduction also holds for perfect success probability as the only special case x=0 can be explicitly handled, i.e., one can easily test whether  <span class="math">g^0=1</span>  is the input.</p>

    <p class="text-gray-300">Remark 7.13. The reduction in Theorem 7.5 is proven for group orders with no small prime factors. However, it also holds for all other group orders, provided the group order is known. Knowing the group order, one can factor out the small prime factors by well-known factoring algorithms, and then easily solve the decisional problems DIE and DDH (see also Remark 7.2). Thus, we have the following theorem.</p>

    <h4 id="sec-misc-14" class="text-lg font-semibold mt-6">Theorem 7.6</h4>

    <pre><code class="language-text"> \\begin{split} \\{(1-1/\\mathsf{poly}(k)), &amp;\\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{DIE}(\\mathbf{c}\\text{:}*; \\mathbf{g}\\text{:}\\mathbf{h}; \\mathbf{f}\\text{:}*, \\mathbf{o}) \\\\ &amp;\\Longrightarrow \\\\ \\{(1-1/\\mathsf{poly}(k)), &amp;\\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-}\\mathrm{DDH}(\\mathbf{c}\\text{:}*; \\mathbf{g}\\text{:}\\mathbf{h}; \\mathbf{f}\\text{:}*, \\mathbf{o}) \\\\ &amp; &amp; \\Box \\\\ &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp;
</code></pre>

    <p class="text-gray-300">The following theorem proves (in generic model) that a DIE oracle, even when perfect, is of no help in breaking DDH assumptions.</p>

    <h4 id="sec-misc-15" class="text-lg font-semibold mt-6">Theorem 7.7</h4>

    <p class="text-gray-300">
<span class="math">$true \\implies *-DDH^{\\sigma}(c:*;g:h;f:nsprim;\\mathcal{O}_{1-DIE(c:*;g:h;f:nsprim)})</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Similar to the proof of Theorem 7.2 we define a Lemma which associates the minimal generic complexity of solving DIE with the smallest prime factor of the order of the underlying group G. Theorem 7.7 immediately follows from Lemma 7.4 and Remark 7.6.</p>

    <p class="text-gray-300"><strong>Lemma 7.4</strong> Let G be a cyclic group and g a corresponding generator, let p' be the smallest prime factor of |G|. Let  <span class="math">\\mathcal{O}_{DIE}</span>  be a given oracle which solves DIE tuples in G and let  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  be any generic algorithm for groups G with maximum run time T and oracle access to  <span class="math">\\mathcal{O}_{DIE}</span> . Then the following always holds:</p>

    <pre><code class="language-text">(|\\operatorname{\\mathbf{Prob}}[\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}(\\mathcal{C},(G,g),w_b,w_{\\bar{b}})=b:: b \\stackrel{\\mathcal{R}}{\\leftarrow} \\{0,1\\}; \\ \\mathcal{C} \\stackrel{\\mathcal{R}}{\\leftarrow} \\mathcal{U}; \\\\ PI \\leftarrow SPI_{DH}((G,g)); \\ PI_{\\mathcal{R}} \\leftarrow SPI_{PI^{\\mathcal{P}}}(PI^{\\mathcal{P}}); \\\\ w_b \\leftarrow (PI^{publ},PI^{sol}); \\\\ w_{\\bar{b}} \\leftarrow (PI^{publ},PI_{\\mathcal{R}}^{sol}) \\\\ ]-1/2 \\mid \\cdot 2) \\leq \\frac{2(T+5)(T+4)}{p&#x27;}
</code></pre>

    <p class="text-gray-300">Proof. Assume, we are given the encodings  <span class="math">\\sigma(1)</span> ,  <span class="math">\\sigma(x)</span> ,  <span class="math">\\sigma(y)</span>  and  <span class="math">\\{\\sigma(xy), \\sigma(c)\\}</span> . After  <span class="math">T_1</span>  computation steps  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  can compute at most  <span class="math">T_1 + 5</span>  distinct linear combinations  <span class="math">P_i(x, y, xy, c)</span>  of 1, x, y, xy and c, i.e., it obtains</p>

    <p class="text-gray-300"><span class="math">$\\sigma(P_i(1, x, y, xy, c)) = \\sigma(a_{i1} + a_{i2}x + a_{i3}y + a_{i4}xy + a_{i5}c)</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_{ij}</span>  are constant coefficients. Furthermore, it is not known to  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  which one of the values  <span class="math">\\{a_{i4}, a_{i5}\\}</span>  is the coefficient of xy and which one corresponds to c. Further, assume that  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  makes  <span class="math">T_2</span>  calls to  <span class="math">\\mathcal{O}_{DIE}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  may be able to distinguish  <span class="math">\\sigma(xy)</span>  and  <span class="math">\\sigma(c)</span>  by obtaining information from either of the following events:</p>

    <p class="text-gray-300"><span class="math">E_a</span> :  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  finds relations (collision) between two distinct linear combination  <span class="math">(P_i, P_j)</span>  with  <span class="math">i \\neq j</span> . This means, it obtains either  <span class="math">\\sigma(P_i(1, x, y, xy, c)) = \\sigma(P_j(1, x, y, xy, c))</span>  or  <span class="math">\\sigma(P_i(1, x, y, c, xy)) = \\sigma(P_j(1, x, y, c, xy))</span> .</p>

    <p class="text-gray-300"><span class="math">E_b</span> :  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  gets at least one positive answer from  <span class="math">\\mathcal{O}_{DIE}</span> , i.e., it obtains either  <span class="math">\\sigma(P_i(1,x,y,xy,c)) = \\sigma((P_j(1,x,y,xy,c))^{-1})</span>  or  <span class="math">\\sigma(P_i(1,x,y,c,xy)) = \\sigma((P_j(1,x,y,c,xy))^{-1})</span> .</p>

    <p class="text-gray-300">We compute an upper bound for the probability that either of the events  <span class="math">E_a</span>  and  <span class="math">E_b</span>  occurs.</p>

    <p class="text-gray-300">Case  <span class="math">E_a</span> : In this case we have  <span class="math">P_i(1,x,y,xy,c) \\equiv P_j(1,x,y,xy,c) \\bmod |G|</span>  or  <span class="math">P_i(1,x,y,c,xy) \\equiv P_j(1,x,y,c,xy) \\bmod |G|</span> . There are  <span class="math">\\binom{T_1+5}{2} = \\frac{(T_1+5)(T_1+4)}{2}</span>  distinct pairs of polynomials  <span class="math">(P_i,P_j)</span> . For each such a pair (i,j) we bound the number of solutions to  <span class="math">P_i \\equiv P_j \\bmod p^e</span>  for any prime power  <span class="math">p^e</span>  that exactly divides |G|, i.e.,  <span class="math">p^{e+1} \\not |G|</span> . (Note that uniformly distributed random values  <span class="math">\\bmod |G|</span>  are also randomly and uniformly distributed  <span class="math">\\bmod p^e</span> .) More precisely, we consider the solutions to the following polynomials</p>

    <p class="text-gray-300"><span class="math">$F_{i,j}(x, y, c) := P_i(1, x, y, xy, c) - P_j(x, y, xy, c) \\equiv 0 \\mod p^e</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$G_{i,j}(x, y, c) := P_i(1, x, y, c, xy) - P_j(x, y, c, xy) \\equiv 0 \\mod p^e</span>$
.</p>

    <p class="text-gray-300">Each of the polynomials F and G has the total degree 2. It follows from Lemma 7.1 that the probability for a random  <span class="math">(x, y, c) \\in \\mathbb{Z}_{p^e}^3</span>  to be a zero of F mod  <span class="math">p^e</span>  or G mod  <span class="math">p^e</span>  is at most 2(2/p) = 4/p. Thus, we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[E_a] \\leq \\frac{(T_1+5)(T_1+4)}{2} \\frac{4}{p} \\\\ \\leq \\frac{2(T_1+5)(T_1+4)}{p&#x27;}.</span>$</p>

    <p class="text-gray-300">Case  <span class="math">E_b</span> : In this case we have  <span class="math">P_i \\equiv P_j^{-1} \\mod |G|</span> . However, it is not possible to derive this relation between the polynomials  <span class="math">P_i</span>  and  <span class="math">P_j</span>  but only between their evaluations at the points (x, y, c), i.e., when  <span class="math">P_i(1, x, y, c, xy) \\equiv P_j(x, y, c, xy)^{-1} \\mod |G|</span>  (with  <span class="math">P_j(x, y, c, xy) \\not\\equiv 0 \\mod |G|</span> )</p>

    <p class="text-gray-300">Similar to our approach in the case  <span class="math">E_a</span> , for each such a pair (i, j) we can bound the number of solutions to  <span class="math">P_i(x, y, xy, c) \\equiv P_j(x, y, xy, c)^{-1} \\mod p^e</span>  or  <span class="math">P_i(x, y, c, xy) - P_j(x, y, c, xy)^{-1} \\mod p^e</span>  for any prime power  <span class="math">p^e</span>  that exactly divides |G|. More precisely, we consider the solutions to the following polynomials</p>

    <p class="text-gray-300"><span class="math">$H_{i,j}(x,y,c) := P_i(1,x,y,xy,c)P_j(x,y,xy,c) - 1 \\equiv 0 \\bmod p^e</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$I_{i,j}(x,y,c) := P_i(1,x,y,c,xy)P_i(x,y,c,xy) - 1 \\equiv 0 \\mod p^e</span>$
.</p>

    <p class="text-gray-300">Here, the polynomial H(x, y, c) is obtained by multiplying both sides of the equation  <span class="math">P_i(1, x, y, xy, c) - P_j(1, x, y, xy, c)^{-1} \\equiv 0 \\mod p^e</span>  with  <span class="math">P_j(1, x, y, xy, c)</span> . Similarly, we obtain I(x, y, c).</p>

    <p class="text-gray-300">Hence, we bound the probability that a random triple  <span class="math">(x,y,c) \\in \\mathbb{Z}_{p^e}^3</span>  is a zero of the polynomials I or  <span class="math">H^{:40}</span>  The total degree of each of the polynomials H and I is at most 4. It follows from Lemma 7.1 that the probability of a randomly chosen  <span class="math">(x,y,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{p^e}^3</span>  to be a zero of H or I is at most 2(4/p) = 8/p.t follows</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[E_b] \\le T_2 \\frac{8}{p} \\le T_2 \\frac{8}{p&#x27;}.</span>$</p>

    <p class="text-gray-300">In total we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[E] &amp; \\leq &amp; \\mathbf{Prob}[E_a] + \\mathbf{Prob}[E_b] \\\\ &amp; \\leq &amp; \\frac{2(T_1 + 5)(T_1 + 4)}{p&#x27;} + \\frac{8T_2}{p&#x27;} \\\\ &amp; \\leq &amp; \\frac{2(T + 5)(T + 4)}{p&#x27;} \\end{aligned}</span>$</p>

    <p class="text-gray-300">where  <span class="math">T_1 + T_2 \\leq T</span> . If the complementary event  <span class="math">\\bar{E}</span>  occurs, then  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  cannot obtain any information about the bit b except by pure guessing. Thus, the success probability of  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}</span>  for correctly outputting b is</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Prob}[\\mathcal{A}^{\\sigma,\\mathcal{O}_{DIE}}(..) = b] &amp;= \\mathbf{Prob}[E] + \\frac{1}{2}\\mathbf{Prob}[\\bar{E}] \\\\ &amp;= \\mathbf{Prob}[E] + \\frac{1 - \\mathbf{Prob}[E]}{2} \\\\ &amp;= \\frac{1}{2} + \\frac{\\mathbf{Prob}[E]}{2} \\\\ &amp;\\leq \\frac{1}{2} + \\frac{(T+5)(T+4)}{p&#x27;}. \\end{split}</span>$</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{40}&lt;/sup&gt;</span>  Note that DIE oracle is guaranteed to answer correctly only to the legal inputs, i.e., when the secret exponents are elements from  <span class="math">\\mathbb{Z}^*_{|G|}</span> . Thus, the answer of DIE oracle is correct if  <span class="math">P_i(x,y,xy,c)</span>  and  <span class="math">P_j(x,y,xy,c)</span>  are elements of  <span class="math">\\mathbb{Z}^*_{|G|}</span> . As the DIE oracle can be evil on illegal inputs, the adversary can obtain fewer information, if any, than in the case where the inputs are legal. Hence, to be on the safe side, we give the generic adversary the advantage that all values  <span class="math">P_i(x,y,xy,c)</span>  and  <span class="math">P_j(x,y,xy,c)</span>  are legal inputs to the DIE oracle.</p>

      <h3 id="sec-7.4" class="text-xl font-semibold mt-8">7.4 DSE versus DIE</h3>

      <h4 id="sec-7.4.1" class="text-lg font-semibold mt-6">7.4.1 High Granular</h4>

    <p class="text-gray-300">In the next theorem we prove that an oracle breaking 1-DSE(c:*; g:h; f:*) is of no help in breaking *-DIE <span class="math">^{\\sigma}</span> (c:*; g:h; f:*).</p>

    <h3 id="sec-misc-16" class="text-xl font-semibold mt-8">Theorem 7.8</h3>

    <p class="text-gray-300">
<span class="math">$true \\implies *-DIE^{\\sigma}(c:*;g:h;f:nsprim;\\mathcal{O}_{1-DSE(c:*;g:h;f:nsprim)})</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Similar to the proofs of Theorem 7.2 and 7.7 we define a Lemma which associates the minimal generic complexity of solving DIE directly to the smallest prime factor of the order of the underlying group G. Theorem 7.8 immediately follows from Lemma 7.5 and Remark 7.6.</p>

    <p class="text-gray-300"><strong>Lemma 7.5</strong> Let G be a cyclic group and g a corresponding generator, let p' be the smallest prime factor of |G|. Let  <span class="math">\\mathcal{O}_{DSE}</span>  be a given oracle solving DSE tuples in G and let  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  be any generic algorithm for groups G with maximum run time T and oracle access to  <span class="math">\\mathcal{O}_{DSE}</span> . Then the following always holds:</p>

    <p class="text-gray-300"><span class="math">$(|\\operatorname{\\textbf{\\textit{Prob}}}[\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}(\\mathcal{C},(G,g),w_b,w_{\\bar{b}})=b::\\\\b\\overset{\\mathcal{R}}{\\leftarrow}\\{0,1\\};\\;\\mathcal{C}\\overset{\\mathcal{R}}{\\leftarrow}\\mathcal{U};\\\\PI\\leftarrow SPI_{IE}((G,g));\\;PI_{\\mathcal{R}}\\leftarrow SPI_{PI^{\\mathcal{P}}}(PI^{\\mathcal{P}});\\\\w_b\\leftarrow (PI^{publ},PI^{sol}_{\\mathcal{D}});\\\\w_{\\bar{b}}\\leftarrow (PI^{publ},PI_{\\mathcal{R}}^{sol})\\\\]-1/2\\mid\\cdot 2)\\;\\leq \\frac{2(T+4)(T+3)}{p&#x27;-2}</span>$</p>

    <p class="text-gray-300">Proof. Assume, we are given the encodings  <span class="math">\\sigma(1)</span> ,  <span class="math">\\sigma(x)</span>  and  <span class="math">\\{\\sigma(x^{-1}), \\sigma(c)\\}</span>  where  <span class="math">x \\in \\mathbb{Z}^*_{|G|}</span> . After  <span class="math">T_1</span>  computation steps the algorithm  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  can compute at most  <span class="math">T_1 + 4</span>  distinct linear combinations  <span class="math">P_i</span>  of the elements  <span class="math">1, x, x^{-1}</span> , and c, i.e., it obtains</p>

    <p class="text-gray-300"><span class="math">$\\sigma(P_i(1, x, x^{-1}, c)) = \\sigma(a_{i1} + a_{i2}x + a_{i3}x^{-1} + a_{i4}c),</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_{ij}</span>  are constant coefficients. Furthermore, it is not a-priori known to  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  which of the values in  <span class="math">\\{a_{i3}, a_{i4}\\}</span>  is the coefficient for  <span class="math">x^{-1}</span>  and which one corresponds to c. Further, assume that  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  makes  <span class="math">T_2</span>  calls to  <span class="math">\\mathcal{O}_{DSE}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  may be able to distinguish  <span class="math">\\sigma(x^{-1})</span>  and  <span class="math">\\sigma(c)</span>  by obtaining information from either of the following events:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">E_a</span> :  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  finds a relation (collision) between two distinct linear equations  <span class="math">(P_i,P_j)</span>  with  <span class="math">i\\neq j</span> . This means it obtains  <span class="math">\\sigma(P_i(1,x,x^{-1},c))=\\sigma(P_j(1,x,x^{-1},c))</span>  or  <span class="math">\\sigma(P_i(1,x,c,x^{-1}))=\\sigma(P_j(1,x,c,x^{-1}))</span> .</li>
      <li><span class="math">E_b</span> :  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  gets at least one positive answer from  <span class="math">\\mathcal{O}_{DSE}</span>  with  <span class="math">i \\neq j</span> , i.e., it obtains  <span class="math">\\sigma(P_i(1,x,x^{-1},c)) = \\sigma((P_j(1,x,x^{-1},c))^2)</span>  or  <span class="math">\\sigma(P_i(1,x,c,x^{-1})) = \\sigma((P_j(1,x,c,x^{-1}))^2)</span> .</li>
    </ul>

    <p class="text-gray-300">We compute an upper bound for the probability that either of these events occurs.</p>

    <p class="text-gray-300">Case  <span class="math">E_a</span> : In this case we have  <span class="math">P_i(1, x, x^{-1}, c) \\equiv P_j(1, x, x^{-1}, c) \\mod |G|</span>  or  <span class="math">P_i(1, x, c, x^{-1}) \\equiv P_j(1, x, c, x^{-1}) \\mod |G|</span> . There are  <span class="math">\\binom{T+4}{2} = \\frac{(T+4)(T+3)}{2}</span>  distinct polynomial pairs  <span class="math">(P_i, P_j)</span> . For each such a pair (i, j) we can bound the number of possible solutions to  <span class="math">P_i \\equiv P_j \\mod p^e</span>  for any prime power  <span class="math">p^e</span>  that exactly divides |G|, i.e.,  <span class="math">p^{e+1} \\not |G|</span>  (Note that uniformly distributed random values  <span class="math">\\mod |G|</span>  are also randomly and uniformly distributed  <span class="math">\\mod p^e</span> .) More precisely, we consider the solutions to the following polynomials</p>

    <p class="text-gray-300"><span class="math">$F_{i,j}(x,c) := x[P_i(1,x,x^{-1},c) - P_j(1,x,x^{-1},c)] \\equiv 0 \\mod p^e</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$G_{i,j}(x,c) := x[P_i(1,x,c,x^{-1}) - P_j(1,x,c,x^{-1})] \\equiv 0 \\mod p^e.</span>$</p>

    <p class="text-gray-300">Here, F and G are obtained by multiplying both sides of the congruence  <span class="math">P_i \\equiv P_j \\mod p^e</span>  with x and then reordering the resulting congruence.</p>

    <p class="text-gray-300">Hence, we bound the probability that a random tuple  <span class="math">(x,c) \\in \\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span>  is a zero of the polynomials F or  <span class="math">G \\mod p^e</span>  (Note that  <span class="math">\\mathbb{Z}_{|G|}^*</span>  is the domain of the secret exponents of DIE inputs.)</p>

    <p class="text-gray-300">To do this, we first bound the number of solutions to F or G mod  <span class="math">p^e</span>  where (x,c) are randomly selected from  <span class="math">\\mathbb{Z}_{p^e}^2</span> : The total degree of each of the polynomials F and G is two. It follows from Lemma 7.1 that the probability for a random tuple  <span class="math">(x,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}^2</span>  to be a zero of F or G mod  <span class="math">p^e</span>  is at most 2(2/p) = 4/p. There are  <span class="math">p^{2e}</span>  tuples (x,c) in  <span class="math">\\mathbb{Z}_{p^e}^2</span> . Thus, there are at most  <span class="math">p^{2e}4/p = 4p^{2e-1}</span>  zeros for either F or G mod  <span class="math">p^e</span> .</p>

    <p class="text-gray-300">Further, there are  <span class="math">(\\varphi(p^e))^2 = (p^e - p^{e-1})^2</span>  tuples (x,c) in  <span class="math">\\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span> . Hence, the probability that such a tuple is a zero of F or G mod  <span class="math">p^e</span>  is upper bounded by  <span class="math">4p^{2e-1}/(p^e - p^{e-1})^2</span> . It follows</p>

    <p class="text-gray-300">$$\\mathbf{Prob}[E_a] \\leq \\frac{(T+4)(T+3)}{2} \\frac{4p^{2e-1}}{(p^e - p^{e-1})^2} \\
= \\frac{(T+4)(T+3)}{2} \\frac{4p^{2e-1}}{p^{2e} + p^{2e-2} - 2p^{2e-1}} \\
= (T+4)(T+3) \\frac{2p}{p^2 - 2p + 1} \\
\\leq (T+4)(T+3) \\frac{2}{p-2} \\
\\leq (T+4)(T+3) \\frac{2}{p'-2}.$$</p>

    <p class="text-gray-300">Case  <span class="math">E_b</span> : In this case we have  <span class="math">P_i \\equiv P_j^2 \\mod |G|</span> . However, it is not possible to derive this relation between the polynomials  <span class="math">P_i</span>  and  <span class="math">P_j</span>  but only between their evaluations at the points (x,c), i.e., when  <span class="math">P_i(1,x,x^{-1},c) \\equiv</span></p>

    <p class="text-gray-300"><span class="math">P_j(1, x, x^{-1}, c)^{-1} \\mod |G|</span> . Similar to the case  <span class="math">E_a</span> , for each pair (i, j),  <span class="math">i \\neq j</span> , we can bound the number of possible solutions to  <span class="math">P_i(1, x, x^{-1}, c) \\equiv (P_j(1, x, x^{-1}, c))^2 \\mod p^e</span>  or  <span class="math">P_i(1, x, c, x^{-1}) \\equiv (P_j(1, x, c, x^{-1}))^2 \\mod p^e</span>  for any prime power  <span class="math">p^e</span>  that exactly divides |G|. More precisely, we consider the solutions to the following polynomials</p>

    <p class="text-gray-300"><span class="math">$H_{i,j}(x,c) := x^2 [P_i(1,x,x^{-1},c) - (P_j(1,x,x^{-1},c))^2] \\equiv 0 \\mod p^e</span>$</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">$I_{i,j}(x,c) := x^2 [P_i(1,x,x^{-1},c) - (P_i(1,x,x^{-1},c))^2] \\equiv 0 \\bmod p^e.</span>$</p>

    <p class="text-gray-300">Here, we obtain the polynomial H(x,c) by multiplying both sides of the congruence  <span class="math">P_i(1,x,x^{-1},c) \\equiv P_j(1,x,x^{-1},c) \\mod p^e</span>  with  <span class="math">x^2</span>  and then reordering the resulting congruence. Similarly, we obtain I(x,c).</p>

    <p class="text-gray-300">Hence, we bound the probability that a random tuple  <span class="math">(x,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span>  is a zero of the polynomials H or  <span class="math">I \\mod p^e</span>  (similar to the case  <span class="math">E_a</span> ): The total degree of each of the polynomials H and I is at most 4. It follows from Lemma 7.1 that the probability for a random tuple  <span class="math">(x,c) \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}^2</span>  to be a zero of H or  <span class="math">I \\mod p^e</span>  is at most 2(4/p) = 8/p. Thus, there are at most  <span class="math">p^{2e}8/p = 8p^{2e-1}</span>  zeros for either H or  <span class="math">I \\mod p^e</span> .</p>

    <p class="text-gray-300">Further, there are  <span class="math">(\\varphi(p^e))^2 = (p^e - p^{e-1})^2</span>  tuples (x, c) in  <span class="math">\\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span> . Hence, the probability that  <span class="math">(x, c) \\in \\mathbb{Z}_{p^e}^* \\times \\mathbb{Z}_{p^e}^*</span>  is a zero of H or  <span class="math">I \\mod p^e</span>  is upper bounded by  <span class="math">8p^{2e-1}/(p^e - p^{e-1})^2</span> . It follows</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Prob}[E_b] \\leq \\frac{8T_2p^{2e-1}}{(p^e - p^{e-1})^2} = \\frac{8T_2p^{2e-1}}{p^{2e} + p^{2e-2} - 2p^{2e-1}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{8T_2p}{p^2 - 2p + 1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{8T_2p}{p^2 - 2p} = \\frac{8T_2}{p - 2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{8T_2}{p&#x27; - 2}.</span>$</p>

    <p class="text-gray-300">In total we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[E] &amp; \\leq &amp; \\mathbf{Prob}[E_a] + \\mathbf{Prob}[E_b] \\\\ &amp; = &amp; \\frac{2(T_1 + 4)(T_1 + 3)}{p&#x27; - 2} + \\frac{8T_2}{p&#x27; - 2} \\\\ &amp; \\leq &amp; \\frac{2(T + 4)(T + 3)}{p&#x27; - 2} \\end{aligned}</span>$</p>

    <p class="text-gray-300">with  <span class="math">T_1 + T_2 \\leq T</span> . If the complementary event  <span class="math">\\bar{E}</span>  occurs, then  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  cannot obtain any information about the bit b except by pure guessing. Thus, the</p>

    <p class="text-gray-300">success probability of  <span class="math">\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}</span>  for correctly outputting b is</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\mathbf{Prob}[\\mathcal{A}^{\\sigma,\\mathcal{O}_{DSE}}(..) = b] &amp;= \\mathbf{Prob}[E] + \\frac{1}{2}\\mathbf{Prob}[\\bar{E}] \\\\ &amp;= \\mathbf{Prob}[E] + \\frac{1 - \\mathbf{Prob}[E]}{2} \\\\ &amp;= \\frac{1}{2} + \\frac{\\mathbf{Prob}[E]}{2} \\\\ &amp;\\leq \\frac{1}{2} + \\frac{(T+4)(T+3)}{p&#x27;-2}. \\end{aligned}</span>$</p>

      <h4 id="sec-7.4.2" class="text-lg font-semibold mt-6">7.4.2 Medium Granular</h4>

    <p class="text-gray-300">In sharp contrast to the above mentioned high-granular case, we prove in the following theorem that these assumptions are equivalent for their medium-granular version (other parameters remain unchanged).</p>

    <h4 id="sec-misc-17" class="text-lg font-semibold mt-6">Theorem 7.9</h4>

    <p class="text-gray-300"><span class="math">$\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-DSE}(\\mathbf{c}:*; \\mathbf{g}:\\mathbf{m}; \\mathbf{f}:\\mathbf{nsprim}) \\\\ \\xrightarrow{\\alpha&#x27; \\geq \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2 \\alpha; \\ t&#x27; = t} \\\\ \\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-DIE}(\\mathbf{c}:*; \\mathbf{g}:\\mathbf{m}; \\mathbf{f}:\\mathbf{nsprim}) \\\\ *\\text{-DSE}(\\mathbf{c}:*; \\mathbf{g}:\\mathbf{m}; \\mathbf{f}:\\mathbf{nsprim}) \\\\ \\xrightarrow{\\alpha&#x27; \\geq \\alpha - \\left(1 - \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2\\right); \\ t&#x27; = t}} \\\\ \\text{*-DIE}(\\mathbf{c}:*; \\mathbf{g}:\\mathbf{m}; \\mathbf{f}:\\mathbf{nsprim})</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We prove the following statements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Given a DIE oracle  <span class="math">\\mathcal{O}_{DIE}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -DSE(c:*; g:m; f:nsprim) with success probability  <span class="math">\\alpha_{DIE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DSE}}</span>  which breaks  <span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -DIE(c:*; g:m; f:nsprim) with success probability  <span class="math">\\alpha_{DSE}(k) \\geq \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2 \\alpha_{DIE}(k)</span> , using a single oracle call.</li>
      <li>(b) Given an oracle  <span class="math">\\mathcal{O}_{DSE}</span>  which breaks *-DIE(c:*; g:m; f:nsprim) with success probability  <span class="math">\\alpha_{DSE}(k)</span> , there exists an algorithm  <span class="math">\\mathcal{A}^{\\mathcal{O}_{DSE}}</span>  which breaks *-DSE(c:*; g:m; f:nsprim) with success probability  <span class="math">\\alpha_{DIE}(k) \\geq \\alpha_{DSE}(k) \\left(1 \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2\\right)</span> , using a single oracle call.</li>
    </ul>

    <p class="text-gray-300">Case (a): Assume, we are given a DSE input tuple  <span class="math">((G,g),(g^x),(g^z))</span>  where z is either  <span class="math">x^2</span>  or a random element  <span class="math">c \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}</span> . Set  <span class="math">h := g^x</span> , and pass  <span class="math">((G,h),(h^t),(h^{tz}))</span>  to  <span class="math">\\mathcal{O}_{DIE}</span> . Here, we used the relations  <span class="math">g = h^t</span>  and  <span class="math">g^z = h^{tz}</span></p>

    <p class="text-gray-300">where we implicitly assumed  <span class="math">t=x^{-1}</span> . This holds only if  <span class="math">x\\in\\mathbb{Z}_{|G|}^*</span>  which occurs with probability  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  (Note that DIE oracle is not guaranteed to answer correctly on illegal inputs, i.e., inputs with secret exponents from  <span class="math">\\mathbb{Z}_{|G|}\\setminus\\mathbb{Z}_{|G|}^*</span> .) If  <span class="math">z=x^2</span>  then with  <span class="math">x=t^{-1}</span>  we have  <span class="math">z=t^{-2}</span> , and the tuple  <span class="math">((G,h),(h^t),(h^{tt}))</span>  has the form  <span class="math">((G,h),(h^t),(h^{t^{-1}}))</span>  which is with probability  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  a legal DIE input tuple. This holds since h is a generator with probability  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  and thus,  <span class="math">h^t</span>  and  <span class="math">h^{t^{-1}}</span>  are legal public and solution parts of a DIE input tuple.</p>

    <p class="text-gray-300">If  <span class="math">z \\neq x^2</span>  then the tuple  <span class="math">((G,h),(h^t),(h^{tz}))</span>  is a legal input tuple for DIE oracle with probability  <span class="math">\\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2</span> . This holds because (i) h is a generator with probability  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span> , and thus  <span class="math">h^t</span>  is a legal public part of the DIE input tuple, and (ii)  <span class="math">h^{zt}</span>  is a legal random part of a DIE input tuple only if  <span class="math">z \\in_{\\mathcal{R}} \\mathbb{Z}_{|G|}^*</span>  which is true with probability  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span> .</p>

    <p class="text-gray-300">Since these events are independent, the probability for both to occur is  <span class="math">\\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2</span> .</p>

    <p class="text-gray-300">Success probability: We have  <span class="math">\\alpha_{DSE}(k) \\geq \\alpha_{DIE}(k) \\left(\\frac{\\varphi(|G|)}{|G|}\\right)</span>  for the correct case (i.e.,  <span class="math">z=x^2</span> ) and  <span class="math">\\alpha_{DSE}(k) \\geq \\alpha_{DIE}(k) \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2</span>  for the random case (i.e.,  <span class="math">z \\neq x^2</span> ). Hence, for the resulting success probability the following holds</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{DSE}(k) \\geq \\big(\\frac{\\varphi(|G|)}{|G|}\\big)^2 \\alpha_{DIE}(k).</span>$</p>

    <p class="text-gray-300">In the following we set  <span class="math">\\gamma(k) := \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2</span>  (Note that |G| is a function of the security parameter k, see also Lemma 6.5). Depending on the success probability of DIE oracle we have the following cases:</p>

    <p class="text-gray-300">Perfect oracle  <span class="math">(\\alpha_{DIE}(k) \\not&lt;_{\\infty} 1)</span> : The resulting success probability cannot be perfect because there is a non-zero error probability when querying the DIE oracle.</p>

    <p class="text-gray-300">Weak oracle  <span class="math">(\\alpha_{DIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is also weak: This holds since  <span class="math">\\frac{\\varphi(|G|)}{|G|}</span>  and consequently  <span class="math">\\gamma(k)</span>  is always non-negligible, and its multiplication with a not negligible function results in a not negligible function. Thus, we can write  <span class="math">\\gamma(k)\\alpha_{DIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Since  <span class="math">\\alpha_{DSE}(k) \\ge \\gamma(k)\\alpha_{DIE}(k)</span> , it follows  <span class="math">\\alpha_{DSE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{DIE} \\not&lt;_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant: Since |G| contains no small prime factors, it follows from Lemma 6.5 that  <span class="math">1 - \\frac{\\varphi(|G|)}{|G|} &lt;_{\\infty} 1/\\text{poly}(k)</span> . More precisely, for any  <span class="math">\\epsilon&#x27; &gt; 0</span>  there exists a  <span class="math">k_0</span>  such that for all  <span class="math">k &gt; k_0</span> ,  <span class="math">\\frac{\\varphi(|G|)}{|G|} &gt; 1 - \\epsilon&#x27;</span> . It follows that for all  <span class="math">k &gt; k_0</span> ,  <span class="math">\\gamma(k) &gt; (1 - \\epsilon&#x27;)^2 = 1 - \\epsilon&#x27;&#x27;</span>  where  <span class="math">\\epsilon&#x27;&#x27; := 2\\epsilon&#x27; - \\epsilon&#x27;^2</span> . Since  <span class="math">\\alpha_{DIE}(k) \\not&lt;_{\\infty} \\epsilon_1</span> , for each  <span class="math">k&#x27;_0</span>  there exists a  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{DIE}(k_1) \\ge \\epsilon_1</span> . Hence, for each  <span class="math">k&#x27;_0 &gt; k_0</span>  there exists  <span class="math">k_1 &gt; k&#x27;_0</span>  such that  <span class="math">\\alpha_{DSE}(k_1) \\ge \\epsilon_2</span>  where  <span class="math">\\epsilon_2 := (1 - \\epsilon&#x27;&#x27;)\\epsilon_1</span> . This means  <span class="math">\\alpha_{DSE}(k) \\not&lt;_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{DIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong: Since |G| contains no small prime factors, it follows from Lemma 6.5 that  <span class="math">1 - \\frac{\\varphi(|G|)}{|G|} &lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Then we can write  <span class="math">\\frac{\\varphi(|G|)}{|G|} &gt;_{\\infty} 1 - 1/\\mathsf{poly}(k)</span>  and  <span class="math">\\gamma(k) &gt;_{\\infty} (1 - 1/\\mathsf{poly}(k))^2 = 1 - 1/\\mathsf{poly}(k)</span> . Hence, we have  <span class="math">1 - \\gamma(k) &gt;_{\\infty} 1/\\mathsf{poly}(k)</span> . From Lemma 6.7 it follows  <span class="math">1 - \\gamma(k)\\alpha_{DIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Finally, since  <span class="math">1 - \\alpha_{DSE}(k) \\leq 1 - \\gamma(k)\\alpha_{DIE}(k)</span>  we have  <span class="math">1 - \\alpha_{DSE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Case (b): Assume, we are given a DIE input tuple  <span class="math">((G,g),(g^x),(g^z))</span>  where  <span class="math">x,z\\in\\mathbb{Z}^*_{|G|}</span> , and z is either  <span class="math">x^{-1}</span>  or a random element  <span class="math">c\\in_{\\mathcal{R}}\\mathbb{Z}^*_{|G|}</span> . Set  <span class="math">h:=g^z</span>  and pass  <span class="math">((G,h),(h^t),(h^{tx}))</span>  to  <span class="math">\\mathcal{O}_{DSE}</span>  where  <span class="math">h^t=g</span>  and  <span class="math">h^{tx}=g^x</span>  for some  <span class="math">t\\in\\mathbb{Z}^*_{|G|}</span> . If  <span class="math">z=x^{-1}</span>  then t=x and the tuple  <span class="math">((G,h),(h^t),(h^{tx}))</span>  has the form  <span class="math">((G,h),(h^t),(h^{t^2}))</span>  which is a correct DSE input tuple. This is because h is a generator, and  <span class="math">h^t</span>  is a group element with  <span class="math">t\\in_{\\mathcal{R}}\\mathbb{Z}^*_{|G|}</span> . Thus, this instance can be solved by the given DSE oracle. However, the probability for a correct answer is not neccessarily  <span class="math">\\alpha_{DSE}(k)</span>  since the inputs to the DSE oracle are limited to those with secret exponents from  <span class="math">\\mathbb{Z}^*_{|G|}</span>  whereas its success probabilities under the condition that the random secret exponents x are chosen from  <span class="math">\\mathbb{Z}^*_{|G|}</span>  and from  <span class="math">\\mathbb{Z}_{|G|}\\setminus\\mathbb{Z}^*_{|G|}</span>  respectively. It follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\alpha_{DSE}(k) &amp;= &amp; \\alpha_{DSE}&#x27;&#x27;(k)\\mathbf{Prob}[x \\in_{\\mathcal{R}} \\ \\mathbb{Z}_{|G|} \\setminus \\mathbb{Z}_{|G|}^*] + \\alpha_{DSE}&#x27;(k)\\mathbf{Prob}[x \\in_{\\mathcal{R}} \\ \\mathbb{Z}_{|G|}^*] \\\\ &amp;= &amp; \\alpha_{DSE}&#x27;&#x27;(k) \\Big(1 - \\frac{\\varphi(|G|)}{|G|}\\Big) + \\alpha_{DSE}&#x27;(k) \\frac{\\varphi(|G|)}{|G|}. \\end{split}</span>$</p>

    <p class="text-gray-300">By reordering we obtain</p>

    <p class="text-gray-300"><span class="math">$\\alpha&#x27;_{DSE}(k) = \\frac{\\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(|G|)}{|G|}\\right) \\alpha&#x27;&#x27;_{DSE}(k)}{\\frac{\\varphi(|G|)}{|G|}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(|G|)}{|G|}\\right) \\alpha&#x27;&#x27;_{DSE}(k)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(|G|)}{|G|}\\right)</span>$</p>

    <p class="text-gray-300">where in the last inequality we set  <span class="math">\\alpha&#x27;&#x27;_{DSE}(k) = 1</span>  to lower bound  <span class="math">\\alpha&#x27;_{DSE}(k)</span> . Thus, the oracle answers correctly on the restricted inputs with probability at least  <span class="math">\\alpha&#x27;_{DSE}(k) \\geq \\alpha_{DSE}(k) - (1 - \\frac{\\varphi(|G|)}{|G|})</span> .</p>

    <p class="text-gray-300">If  <span class="math">z \\neq x^{-1}</span>  then  <span class="math">t \\neq x</span>  and the tuple  <span class="math">((G,h),(h^t),(h^{xt}))</span>  is a correct (random) DSE input tuple. This is because (i) h is a generator, and (ii)  <span class="math">h^t</span>  and  <span class="math">h^{xt}</span>  are group elements (with  <span class="math">x, t \\in_{\\mathcal{R}} \\mathbb{Z}^*_{|G|}</span> ) representing legal public and random parts of the DSE input tuple. However, the inputs to the DSE oracle are limited to those with secret exponents (t,z) from  <span class="math">\\mathbb{Z}^*_{|G|} \\times \\mathbb{Z}^*_{|G|}</span> . Thus, similar to the correct case, we can determine the probability that the oracle answers correctly on these inputs. This probability is  <span class="math">\\alpha&#x27;_{DSE}(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2\\right)</span> .</p>

    <p class="text-gray-300">Success probability: We have  <span class="math">\\alpha&#x27;_{DSE}(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\frac{\\varphi(|G|)}{|G|}\\right)</span>  for the correct case (i.e.,  <span class="math">z = x^{-1}</span> ) and  <span class="math">\\alpha&#x27;_{DSE}(k) \\geq \\alpha_{DSE}(k) - \\left(1 - \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2\\right)</span>  for the random case (i.e.,  <span class="math">z \\neq x^{-1}</span> ). Hence, for the resulting success probability the following holds</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{DIE}(k) \\geq \\alpha_{DSE}(k) - \\big(1 - \\big(\\frac{\\varphi(|G|)}{|G|}\\big)^2\\big).</span>$</p>

    <p class="text-gray-300">In the following we set  <span class="math">\\gamma(k) := \\left(\\frac{\\varphi(|G|)}{|G|}\\right)^2</span>  (Note that |G| is a function of the security parameter k, see also Lemma 6.5). Depending on the success probability of DSE oracle we have the following cases:</p>

    <p class="text-gray-300">Perfect oracle ( <span class="math">\\alpha_{DSE}(k) \\not&lt;_{\\infty} 1</span> ): The resulting success probability is also perfect because DIE instances represent legal inputs to the DSE oracle, and they all are solved by the perfect oracle.</p>

    <p class="text-gray-300">Weak oracle  <span class="math">(\\alpha_{DSE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) weak: As shown in the case (a), for |G| with no small prime factors we have  <span class="math">1-\\gamma(k)&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . The subtraction of a negligible function from a not negligible one results in a not negligible function, i.e.,  <span class="math">\\alpha_{DSE}(k) - (1-\\gamma(k)) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . This implies  <span class="math">\\alpha_{DIE}(k) \\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Invariant oracle  <span class="math">(\\alpha_{DSE} \\not&lt;_{\\infty} \\epsilon_1)</span> : The resulting success probability is (asymptotically) invariant: As shown in the case (a), for |G| with no small prime factors we have  <span class="math">1-\\gamma(k)&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . More precisely, for any  <span class="math">\\epsilon&#x27;</span>  there exists a  <span class="math">k_0</span>  such that for all  <span class="math">k&gt;k_0</span> ,  <span class="math">1-\\gamma(k)&lt;\\epsilon&#x27;</span>  holds. Since  <span class="math">\\alpha_{DSE}(k)\\not&lt;_{\\infty} \\epsilon_1</span> , for any  <span class="math">k&#x27;_0</span>  there exists a  <span class="math">k_1&gt;k&#x27;_0</span>  such that  <span class="math">\\alpha_{DSE}(k_1)\\geq\\epsilon_1</span> . Thus, for any  <span class="math">k&#x27;_0&gt;k_0</span>  there exists a  <span class="math">k_1&gt;k&#x27;_0</span>  such that  <span class="math">\\alpha_{DSE}(k_1)-(1-\\gamma(k_1))\\geq\\epsilon_2</span>  where  <span class="math">\\epsilon_2:=\\epsilon_1-\\epsilon&#x27;</span> . Hence, we can write  <span class="math">\\alpha_{DSE}(k)-(1-\\gamma(k))\\not&lt;_{\\infty} \\epsilon_2</span> . Finally, since  <span class="math">\\alpha_{DIE}\\geq\\alpha_{DSE}(k)-(1-\\gamma(k))</span> , it follows that  <span class="math">\\alpha_{DIE}\\not&lt;_{\\infty} \\epsilon_2</span> .</p>

    <p class="text-gray-300">Strong oracle  <span class="math">(1 - \\alpha_{DSE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k))</span> : The resulting success probability is (asymptotically) strong: From  <span class="math">\\alpha_{DIE}(k) \\geq \\alpha_{DSE}(k) - (1 - \\gamma(k))</span>  follows  <span class="math">1 - \\alpha_{DIE}(k) \\leq 1 - \\alpha_{DSE}(k) + (1 - \\gamma(k))</span> . As shown in the case (a), for |G| with no small prime factors we have  <span class="math">1 - \\gamma(k) &lt;_{\\infty} 1/\\mathsf{poly}(k)</span> . Further, we have  <span class="math">1 - \\alpha_{DSE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> . Thus, the right side of the above inequality is a not non-negligible function as it is the sum of a not non-negligible and a negligible functions. Hence, we can write  <span class="math">1 - \\alpha_{DSE}(k) + (1 - \\gamma(k)) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> , implying  <span class="math">1 - \\alpha_{DIE}(k) \\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> .</p>

    <p class="text-gray-300">Remark 7.14. The reductions in Theorem 7.9 are proven for group orders with no small prime factors. However, they also hold for all other group orders provided the group order is known (see also Remark 7.13) Thus, the following holds.</p>

    <h3 id="sec-misc-18" class="text-xl font-semibold mt-8">Theorem 7.10</h3>

    <p class="text-gray-300"><span class="math">\\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}</span> -DSE(c:*; g:m; f:*,o)</p>

    <p class="text-gray-300"><span class="math">$\\Rightarrow \\\\ \\{(1-1/\\mathsf{poly}(k)), \\epsilon, 1/\\mathsf{poly}(k)\\}\\text{-DIE}(c:*; g:m; f:*,o) \\\\ *-\\mathrm{DSE}(c:*; g:m; f:*,o) \\\\ \\Leftarrow \\\\ *-\\mathrm{DIE}(c:*; g:m; f:*,o) \\\\ \\Box</span>$</p>

    <p class="text-gray-300">Remark 7.15. The reduction (DIE to DSE) in Theorem <a href="#page-67-1">7.9</a> <a href="#page-70-0">(7.10</a> respectively) does not hold for perfect success probability due to the introduced error probability. However, for groups of prime order the reduction also holds for perfect oracles as the only special case x = 0 can be explicitly handled, i.e., one can easily test whether g <sup>0</sup> = 1 is the input. &#9702;</p>

    </section>

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">In this paper, we identify the parameters relevant to cryptographic assumptions. Based on this we present a framework and notation for defining assumptions related to Discrete Logarithms. Using this framework these assumptions can be precisely and systematically classified. Wider adoption of such a terminology would ease the study and comparison of results in the literature, e.g., the danger of ambiguity and mistakes in lengthily stated textual assumptions and theorems would be minimized. Furthermore, clearly stating and considering these parameters opens an avenue to generalize results regarding the relation of different assumptions and to get a better understanding of them. This is the focus of our ongoing research. A parameter in defining assumptions previously ignored in the literature is granularity. We show (as summarized in Figure <a href="#page-72-0">2)</a> that varying this parameter leads to surprising results: We prove that some DLrelated assumptions are equivalent in one case (medium granular) and provably not equivalent, at least not in a generic sense, in another case (high granular). Furthermore, we show that some reductions for medium granularity are much more efficient than their high-granular version leading to considerably improved concrete security, in particular as medium granularity results in weaker assumptions than high-granular ones. However, we note that medium- or low-granular assumptions apply in cryptographic settings only when the choice of system parameters is guaranteed to be truly random. Interesting open questions remain to be answered: While for both CDL and CDH it can be shown that their highand medium-granular assumptions are equivalent, this is not yet known for DDH (also briefly mentioned as an open problem by <a href="#page-77-7">Shoup</a> (1999)). Only few relations can be shown for low-granular assumptions as no random self-reducibility is yet known. However, achieving such &quot;full&quot; random self-reducibility seems very difficult in general (if not impossible) in number-theoretic settings <a href="#page-73-11">(Boneh</a> 2000) contrary to, e.g., lattice settings used by Ajtai and <a href="#page-73-12">Dwork</a> (1997). Finally, high granularity is almost intrinsic in the generic model and it is not clear how to extend the generic model to medium or low granularity. Our surprising results also throw some shadow of doubt onto the use of the generic model as a tool</p>

    <p class="text-gray-300">    <img src="_page_72_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Summary of our results</p>

    <p class="text-gray-300">to show impossibility results. It remains to be further explored whether these results are due to the limitations of the generic model or are really intrinsic differences between assumptions with medium and high granularity.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Andr&acute;e Adelsbach, Birgit Pfitzmann, Matthias Schunter, and the anonymous reviewers for their helpful comments.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ajtai, Mikl&acute;os and Cynthia Dwork. 1997, May. &quot;A Public-Key Cryptosystem with Worst-Case/Average-Case Equivalence.&quot; Proceedings of the 29th Annual Symposium on Theory Of Computing (STOC). El Paso, TX, USA: ACM Press, 284&ndash;293.</li>
      <li>Babai, Laszlo and Endre Szemer&acute;edi. 1984. &quot;On the complexity of matrix group problems.&quot; Proceedings of the 25th Symposium on Foundations of Computer Science (FOCS). IEEE Computer Society Press, 229&ndash;240.</li>
      <li>Bach, Eric and Jeffrey Shallit. 1996. Algorithmic Number Theory &mdash; Efficient Algorithms. Volume I. Cambridge, USA: MIT Press. ISBN: 0-262-02405-5.</li>
      <li>Bellare, Mihir and Phillip Rogaway. 1993, November. &quot;Random Oracles are Practical: A Paradigm for Designing Efficient Protocols.&quot; Edited by Victoria Ashby, Proceedings of the 1st ACM Conference on Computer and Communications Security. Fairfax, Virginia: ACM Press, 62&ndash;73.</li>
      <li>. 1995. &quot;Optimal Asymmetric Encryption &mdash; How to encrypt with RSA.&quot; Edited by A. De Santis, Advances in Cryptology &ndash; EUROCRYPT '94, Volume 950 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 92&ndash; 111. Final (revised) version appeared November 19, 1995. Available from <a href="http://www-cse.ucsd.edu/users/mihir/papers/oaep.html" target="_blank" rel="noopener noreferrer">http://www-cse.ucsd.edu/users/mihir/papers/oaep.html</a>.</li>
      <li>Biham, Eli, Dan Boneh, and Omer Reingold. 1999. &quot;Breaking Generalized Diffie-Hellman modulo a composite is no easier than factoring.&quot; Information Processing Letters 70:83&ndash;87. Also appeared in Theory of Cryptography Library, Record 97-14, 1997.</li>
      <li>Blum, Manuel and Silvio Micali. 1984. &quot;How to Generate Cryptographically Strong Sequences of Pseudo-Random Bits.&quot; SIAM Journal on Computing 13 (4): 850&ndash;864 (November).</li>
      <li>Boneh, Dan. 1998. &quot;The Decision Diffie-Hellman problem.&quot; Third International Algorithmic Number Theory Symposium (ANTS-III), Volume 1423 of Lecture Notes in Computer Science. Springer-Verlag, Berlin Germany, 48&ndash;63.</li>
      <li>. 2000, October. Personal Communication.</li>
      <li>. 2001. &quot;Simplified OAEP for the RSA and Rabin functions.&quot; In <a href="#page-75-10">Kilian</a> 2001, 275&ndash;291.</li>
      <li>Boneh, Dan and Richard J. Lipton. 1996. &quot;Algorithms for black box fields and their application to cryptography.&quot; In <a href="#page-75-11">Koblitz</a> 1996, 283&ndash;297.</li>
      <li>Brands, Stefan. 1994. &quot;Untraceable Off-line Cash in Wallet with Observers.&quot; Edited by Douglas R. Stinson, Advances in Cryptology &ndash; CRYPTO '93, Volume 773 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 302&ndash;318.</li>
    </ul>

    <p class="text-gray-300">Cachin, Christian, Klaus Kursawe, and Victor Shoup. 2000, July. &quot;Random Oracles in Constantinople: Practical Asynchronous Byzantine Agreement using Cryptography.&quot; Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing. ACM Portland, Oregon. Full version appeared as Cryptology ePrint Archive Report 2000/034 (2000/7/7).</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Camenisch, Jan, Ueli Maurer, and Markus Stadler. 1996, September. &quot;Digital Payment Systems with Passive Anonymity-Revoking Trustees.&quot; Edited by E. Bertino, H. Kurth, G. Martella, and E. Montolivo, Proceedings of the Fourth European Symposium on Research in Computer Security (ES-ORICS), Volume 1146 of Lecture Notes in Computer Science. Rome, Italy: Springer-Verlag, Berlin Germany, 33&ndash;43.</li>
      <li>Canetti, Ran. 1997. &quot;Towards realizing random oracles: Hash functions that hide all partial information.&quot; Edited by Burton S. Kaliski, Jr., Advances in Cryptology &ndash; CRYPTO '97, Volume 1294 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 455&ndash;469.</li>
      <li>Canetti, Ran, Oded Goldreich, and Shai Halevi. 1998, May. &quot;The Random Oracle Methodology, Revisited.&quot; Proceedings of the 30th Annual Symposium on Theory Of Computing (STOC). Dallas, TX, USA: ACM Press, 209&ndash;218.</li>
      <li>Cramer, Ronald and Victor Shoup. 1998. &quot;A Practical Public Key Cryptosystem Provably Secure against Adaptive Chosen Ciphertext Attack.&quot; In <a href="#page-75-12">Krawczyk</a> 1998, 13&ndash;25.</li>
      <li>Davida, George, Yair Frankel, Yiannis Tsiounis, and Moti Yung. 1997, February. &quot;Anonymity Control in E-Cash Systems.&quot; Proceedings of the First Conference on Financial Cryptography (FC '97), Volume 1318 of Lecture Notes in Computer Science. International Financial Cryptography Association (IFCA) Anguilla, British West Indies: Springer-Verlag, Berlin Germany, 1&ndash;16.</li>
      <li>Diffie, Whitfield and Martin Hellman. 1976. &quot;New Directions in Cryptography.&quot; IEEE Transactions on Information Theory IT-22 (6): 644&ndash;654 (November).</li>
      <li>Fischlin, Marc. 2000. &quot;A Note on Security Proofs in the Generic Model.&quot; In <a href="#page-76-13">Okamoto</a> 2000, 458&ndash;469.</li>
      <li>Frankel, Yair, Yiannis Tsiounis, and Moti Yung. 1996. &quot;&quot;Indirect Discourse Proofs&quot;: Achieving Fair Off-Line Cash (FOLC).&quot; Edited by K. Kim and T. Matsumoto, Advances in Cryptology &ndash; ASIACRYPT '96, Volume 1163 of Lecture Notes in Computer Science. Springer-Verlag, Berlin Germany, 286&ndash;300.</li>
      <li>Fujisaki, Eiichiro, Tatsuaki Okamoto, David Pointcheval, and Jacques Stern. 2001. &quot;RSA&mdash;OAEP is secure under the RSA Assumption.&quot; In <a href="#page-75-10">Kilian</a> 2001, 260&ndash;274.</li>
    </ul>

    <p class="text-gray-300">Gennaro, Rosario. 2000. &quot;An Improved Pseudo-random Generator Based on Discrete Log.&quot; Edited by Mihir Bellare, Advances in Cryptology &ndash; CRYPTO '2000, Volume 1880 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 469&ndash;481.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Goldwasser, Shafi and Silvio Micali. 1984. &quot;Probabilistic Encryption.&quot; Journal of Computer Security 28:270&ndash;299.</li>
      <li>Gordon, Daniel M. 1993a. &quot;Designing and Detecting Trapdoors for Discrete Log Cryptosystems.&quot; Edited by E.F. Brickell, Advances in Cryptology &ndash; CRYPTO '92, Volume 740 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 66&ndash;75.</li>
      <li>1993b. &quot;Discrete logarithms in GF(p) using the number field sieve.&quot; SIAM Journal on Discrete Mathematics 6 (1): 124&ndash;138.</li>
      <li>Handschuh, Helena, Yiannis Tsiounis, and Moti Yung. 1999, March. &quot;Decision oracles are equivalent to matching oracles.&quot; International Workshop on Practice and Theory in Public Key Cryptography '99 (PKC '99), Volume 1560 of Lecture Notes in Computer Science. Kamakura, Japan: Springer-Verlag, Berlin Germany.</li>
      <li>Kilian, Joe, ed. 2001. Advances in Cryptology &ndash; CRYPTO '2001. Volume 2139 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</li>
      <li>Kiltz, Eike. 2001. &quot;A Tool Box of Cryptographic Functions related to the Diffie-Hellman Function.&quot; Advances in Cryptology &ndash; INDOCRYPT '2001, Volume 2247 of Lecture Notes in Computer Science. Springer-Verlag, Berlin Germany, 339&ndash;350.</li>
      <li>Koblitz, Neal, ed. 1996. Advances in Cryptology &ndash; CRYPTO '96. Volume 1109 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</li>
      <li>Krawczyk, Hugo, ed. 1998. Advances in Cryptology &ndash; CRYPTO '98. Volume 1462 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany.</li>
      <li>Lenstra, Arjen K. and Eric R. Verheul. 2001. &quot;Selecting Cryptographic Key Sizes.&quot; Journal of Cryptology 14 (4): 255&ndash;293.</li>
      <li>Lidl, Rudolf and Harald Niederreiter. 1997, January. Finite Fields. Second edition. Encyclopedia of Mathematics and its Applications. Cambridge University Press.</li>
      <li>MacKenzie, Philip. 2001, July. &quot;On the Security of the SPEKE Password-Authenticated Key Exchange Protocol.&quot; Report 2001/057, Cryptology ePrint Archive.</li>
      <li>Maurer, Ueli M. 1994. &quot;Towards the Equivalence of Breaking the Diffie-Hellman Protocol and Computing Discrete Logarithms.&quot; Edited by Yvo G.</li>
    </ul>

    <p class="text-gray-300">Desmedt, Advances in Cryptology &ndash; CRYPTO '94, Volume 839 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 271&ndash;281.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Maurer, Ueli M. and Stefan Wolf. 1996. &quot;Diffie-Hellman Oracles.&quot; In <a href="#page-75-11">Koblitz</a> 1996, 268&ndash;282.</li>
      <li>. 1998a, August. &quot;Diffie-Hellman, Decision Diffie-Hellman, and Discrete Logarithms.&quot; IEEE Symposium on Information Theory. Cambridge, USA, 327.</li>
      <li>. 1998b. &quot;Lower bounds on generic algorithms in groups.&quot; Edited by Kaisa Nyberg, Advances in Cryptology &ndash; EUROCRYPT '98, Volume 1403 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 72&ndash;84.</li>
      <li>McCurley, Kevin S. 1990. &quot;The Discrete Logarithm Problem.&quot; Edited by Carl Pomerance, Cryptology and Computational Number Theory, Volume 42 of Proceedings of Symposia in Applied Mathematics. American Mathematical Society Providence, 49&ndash;74.</li>
      <li>Menezes, Alfred J., Paul C. van Oorschot, and Scott A. Vanstone. 1997. Handbook of Applied Cryptography. CRC Press series on discrete mathematics and its applications. CRC Press. ISBN 0-8493-8523-7.</li>
      <li>National Institute of Standards and Technology (NIST). 2000, January. The Digital Signature Standard (DSS). FIPS PUB 186-2.</li>
      <li>Nechaev, V. I. 1994. &quot;Complexity of a determinate algorithm for the discrete logarithm.&quot; Mathematical Notes 55 (2): 165&ndash;172. Translated from Matematicheskie Zametki, 55(2):91&ndash;101, 1994.</li>
      <li>Odlyzko, Andrew. 2000. &quot;Discrete logarithms: The past and the future.&quot; Designs, Codes and Cryptography 19:129&ndash;145.</li>
      <li>Okamoto, T., ed. 2000. Advances in Cryptology &ndash; ASIACRYPT '2000. Volume 1976 of Lecture Notes in Computer Science. International Association for Cryptologic Research, Kyoto, Japan: Springer-Verlag, Berlin Germany.</li>
      <li>Patel, Sarvar and Ganapathy S. Sundaram. 1998. &quot;An Efficient Discrete Log Pseudo Random Generator.&quot; In <a href="#page-75-12">Krawczyk</a> 1998, 304&ndash;317.</li>
      <li>Pfitzmann, Birgit and Ahmad-Reza Sadeghi. 2000. &quot;Anonymous Fingerprinting with Direct Non-Repudiation.&quot; In <a href="#page-76-13">Okamoto</a> 2000, 401&ndash;414.</li>
      <li>Pohlig, S.C. and M. E. Hellman. 1978. &quot;An improved algorithm for computing logarithms over GF(p) and its cryptographic significance.&quot; IEEE Transactions on Information Theory 24:106&ndash;110.</li>
      <li>Pollard, J. M. 1978. &quot;Monte Carlo methods for index computation mod p.&quot; Mathematics of Computation 32:918&ndash;924.</li>
      <li>Schirokauer, Oliver. 1993. &quot;Discrete logarithms and local units.&quot; Philosophical Transactions of the Royal Society of London A 345:409&ndash;423.</li>
    </ul>

    <p class="text-gray-300">Schnorr, Claus P. 1991. &quot;Efficient Signature Generation by Smart Cards.&quot; Journal of Cryptology 4 (3): 161&ndash;174.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Schwartz, J. T. 1980. &quot;Fast probabilistic algorithms for verification of polynomial identities.&quot; Journal of the ACM 27 (4): 701&ndash;717 (October).</li>
      <li>Shmuely, Zahava. 1985, February. &quot;Composite Diffie-Hellman Public-Key Generating Systems are Hard to Break.&quot; Computer science technical report 356, Israel Institute of Technology (Technion).</li>
      <li>Shoup, Victor. 1997. &quot;Lower Bounds for Discrete Logarithms and Related Problems.&quot; Edited by Walter Fumy, Advances in Cryptology &ndash; EURO-CRYPT '97, Volume 1233 of Lecture Notes in Computer Science. International Association for Cryptologic Research: Springer-Verlag, Berlin Germany, 256&ndash;266.</li>
      <li>. 1999, April. &quot;On Formal Models for Secure Key Exchange.&quot; Research report RZ 3120 (#93166), IBM Research. A revised version 4, dated November 15, 1999, is available from <a href="http://www.shoup.net/papers/" target="_blank" rel="noopener noreferrer">http://www.shoup.net/papers/</a>.</li>
      <li>. 2001. &quot;OAEP Reconsidered.&quot; In <a href="#page-75-10">Kilian</a> 2001, 239&ndash;259.</li>
      <li>Steiner, Michael, Gene Tsudik, and Michael Waidner. 1996, March. &quot;Diffie-Hellman Key Distribution Extended to Groups.&quot; Edited by Clifford Neuman, Proceedings of the 3rd ACM Conference on Computer and Communications Security. New Delhi, India: ACM Press, 31&ndash;37. Appeared as revised and extended journal version as (Steiner, Tsudik, and <a href="#page-77-8">Waidner</a> 2000).</li>
      <li>. 2000. &quot;Key Agreement in Dynamic Peer Groups.&quot; IEEE Transactions on Parallel and Distributed Systems 11 (8): 769&ndash;780 (August).</li>
      <li>Wolf, Stefan. 1999. &quot;Information-Theoretically and Computionally Secure Key Agreement in Cryptography.&quot; Ph.D. diss., ETH Zuric &uml; h.</li>
    </ul>

    <h2 id="sec-misc-19" class="text-2xl font-bold">Index</h2>

    <h2 id="sec-misc-20" class="text-2xl font-bold"><strong>Symbols</strong></h2>

    <p class="text-gray-300">C, see problem type, computational DH, see problem family, DH DL, see problem family, DL D, see problem type, decisional  <span class="math">E_{a,b}/\\mathbb{F}_p</span> , see group family  <span class="math">\\mathrm{GDH}(n)</span> , see problem family. GDH(n) <span class="math">\\mathcal{G}_{SG(k)}</span> , see group sibling IAE, see problem family, IAE IE, see problem family, IE M, see problem type, matching  <span class="math">\\mathbb{Z}_{p/q}^*</span> , see group family RP(n), see problem family, RP(n) <span class="math">\\mathbb{Z}_n^*</span> , see group family SE, see problem family, SE SG, see group sampler SPI, see problem instance sampler  <span class="math">\\mathbb{QR}_n^*</span> , see group family Sg, see generator sampler  <span class="math">\\mathbb{Z}_{n}^{*}</span> , see group family  <span class="math">\\leftarrow</span> , see assignment  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span> , see assignment, see random variable  <span class="math">\\in_{\\mathcal{R}}</span> , see assignment *, see wild card G, see group PI, see problem instance SI, see structure Instance  <span class="math">&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> , see negligible  <span class="math">\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> , see non-negligible  <span class="math">\\not&lt;_{\\infty} 1/\\mathsf{poly}(k)</span> , see negligible  <span class="math">\\not\\geq_{\\infty} 1/\\mathsf{poly}(k)</span> , see non-negligible  <span class="math">&lt;_{\\infty}</span> , 5  <span class="math">\\geq_{\\infty}</span> , 5  <span class="math">\\not&lt;_{\\infty}</span> , 5  <span class="math">\\ngeq_{\\infty}</span> , 5 g, see group, generator k, see security parameter  <span class="math">\\mathcal{G}</span> , see group family  <span class="math">\\mathcal{P}</span> , see problem family</p>

    <p class="text-gray-300">U, see uniform distribution of infinite binary strings  <span class="math">PI^{SI}</span> , see problem instance  <span class="math">PI^{priv}</span> , see problem instance  <span class="math">PI^{publ}</span> , see problem instance  <span class="math">PI^{sol}</span> , see problem instance  <span class="math">\\stackrel{c}{\\approx}</span> , see indistinguishability, computational  <span class="math">\\stackrel{\\circ}{\\approx}</span> , see indistinguishability, statistical (...), see sequence  <span class="math">(\\ldots :: \\ldots)</span> , see random variable  <span class="math">(\\ldots \\mid \\ldots)</span> , see sequence  <span class="math">\\Delta_{(X,Y)}(k)</span> , see statistical difference  <span class="math">\\Sigma_{G,q}</span> , see encoding function  <span class="math">g^x</span> , see exponentiation  <span class="math">\\log, 5</span>  <span class="math">poly(v_1,\\ldots,v_n),</span> seepolynomial, multivariate poly(v), see polynomial, univariate  <span class="math">\\sigma(\\cdot)</span> , see encoding function RunTime, seeTuring chine, runtime  <span class="math">\\{\\ldots :: \\ldots\\}</span> , see random variable, ensemble  <span class="math">\\{\\ldots \\mid \\ldots\\}</span> , see set  <span class="math">\\{\\ldots\\}</span> , see set |G|, see group order  <span class="math">\\sigma</span> , see algebraic knowledge h, see granularity, high  <span class="math">\\epsilon</span> , see success probability, invariant fct, see group family o, see group family lprim, see group family l, see granularity, low m, see granularity, medium nsprim, see group family n, see complexity, non-uniform :=, see assignment 1, see success probability, perfect prim, see group family  <span class="math">[\\cdot]</span> , see random variable</p>

    <p class="text-gray-300">80 INDEX</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(1&minus;1/poly(k)), see success probabil<br>ity, strong<br>o, see group family<br>u, see complexity, uniform<br>1/poly(k),<br>see success probability,<br>weak<br>A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">generator, see group, generator<br>sampler, 10<br>generic model, see algebraic knowl<br>edge<br>granularity, 3, 18, 27&ndash;29<br>high, 18<br>low, 18<br>medium, 18</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">adversary, 15<br>generic, 17<br>specific, 17<br>algebraic knowledge, 17<br>assignment, 4<br>associative, 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">group, 7<br>cyclic, 7<br>element, 7<br>order, 7<br>family, 9, 14<br>finite, 7<br>generator, 7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B<br>black-box reduction, 25<br>C<br>complexity, 15<br>non-uniform, 16<br>uniform, 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">identity element, 7<br>inverse, 7<br>operation, 7<br>order, 7<br>factorization, 14<br>sampler, 9<br>sibling, 9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cryptographic assumption, 11&ndash;26<br>parameter, 11&ndash;19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I<br>IAE, see<br>Inverted-Additive Expo</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D<br>DH, see Diffie-Hellman<br>Diffie-Hellman (DH), 3<br>Discrete Logarithm (DL), 3, 7<br>distinguisher, 7<br>DL, see Discrete Logarithm<br>DL-based assumption, see crypto</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nent<br>IE, see Inverse Exponent<br>indistinguishability<br>computational, 7<br>statistical, 7<br>Inverse Exponent (IE), 3<br>Inverted-Additive Exponent (IAE),<br>3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">graphic assumption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Matching Diffie-Hellman, 3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">efficient, 6<br>encoding function, 17<br>exponentiation, 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">N<br>negligible, 5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G<br>GDH,<br>see<br>Generalized<br>Diffie</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">not, 5<br>non-negligible, 5<br>not, 6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hellman<br>Generalized Diffie-Hellman (GDH),<br>3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O<br>oracle, 6</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">INDEX 81</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">P</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">sequence, 4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">polynomial</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">set, 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">multivariate, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Square Exponent (SE), 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">univariate, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">statistical difference, 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">probability, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">structure instance</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">probability space, 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SI, 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">probability space instance (PSI), 18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">success probability, 18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">problem</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">invariant, 19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">family, 8, 11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">perfect, 19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DH, 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">strong, 19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DL, 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">weak, 19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GDH(n), 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IAE, 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">T</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IE, 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Turing machine, 6, 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RP(n), 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">polynomial-time, 6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SE, 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">runtime, 6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hard, 6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">instance, 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">U</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">sampler, 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">uniform distribution of infinite bi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">type, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nary strings, 6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">computational, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">decisional, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">W</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">matching, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PSI, see probability space instance</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">wild card, 20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">R</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">random self-reducibility, 15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">random variable, 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ensemble, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Representation Problem (RP), 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RP, see Representation Problem</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">sampler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">generator, see generator sam</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">group, see group sampler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">problem instance, see problem</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">instance sampler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SE, see Square Exponent</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">security parameter k, 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">self-reduction</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">see<br>random,<br>random<br>self</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">reducibility</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">semantic security, 13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Deriving Formal Assumptions</h2>

    <p class="text-gray-300">The &quot;mechanics&quot; of deriving the formal assumption statement from its short form s-s+s-g-a (c:g:g:g:g:g:g-a) &mdash; as described in Section 4 the X's are placeholders of the parameters defined in Section 3 &mdash; is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Group and problem family:</strong> Just fix the group, generator and problem instance sampler  <span class="math">SG_{\\mathcal{G}}</span> , Sg, and  <span class="math">SPI_{\\mathcal{P}}</span>  corresponding to group family  <span class="math">\\mathcal{SG}</span>  and problem family  <span class="math">\\mathcal{SP}</span> , respectively. In the context of generic relations,  <span class="math">\\mathcal{SG}</span>  does normally not fix a particular group family and sampler but gives just some specific constraints on group families, e.g., groups with large prime factors indicated by &quot;lprim&quot;. In such a case  <span class="math">SG_{\\mathcal{G}}</span>  denotes an arbitrary sampler for an arbitrary group family fulfilling the given constraints on the group family and the constraints on samplers given in Section 2.7.<sup>41</sup></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Problem type:</strong> Prepare the assumption formula F as the probability statement P defined as &quot;Prob[&quot;.  <span class="math">P_{pred}</span> .&quot;::&quot;.  <span class="math">P_{def}</span> .&quot;]&quot;. The denotes the string-concatenation operator and the variables  <span class="math">P_{pred}</span>  and  <span class="math">P_{def}</span>  are the probability predicate and the probability space instance definition, respectively. They are defined depending on the problem type R as follows (where  <span class="math">PI_{\\mathcal{P}}</span>  is the problem sampler fixed in item 1 above and where the source of R is explained in item 3 below):</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>$t = C: Initialize $\\mathbb{P}_{\\text{def}}$ to &quot;PI ( -SPI_{\\mathcal{P}}(SI);&quot;$ (the problem instance to solve) and add &quot;$\\mathcal{C} ( \\frac{\\mathcal{P}}{\\mathcal{U}} \\mathcal{U};&quot;$ (the random coins for the adversary) to it. Define $\\mathbb{P}_{\\text{pred}}$ as &quot;$\\mathcal{A}(\\mathcal{C}, SI, PI^{publ}) \\in PI^{sol}&quot;$.</li>
      <li>$t = D: Initialize $\\mathbb{P}_{def}$ to the concatenation of &quot;b  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span>  {0,1};&quot; (the random bit used as challenge), &quot;PI_0 ( \\simes SPI_{\\mathbb{P}}(SI);&quot; and &quot;PI_1 ( SPI_{\\mathbb{P}}(SI);&quot; (the real problem instance and an auxiliary problem instance for the random public part), &quot;sol<sub>c</sub>  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span>  PI<sub>b</sub><sup>sol</sup>;&quot; (one possible solution), and &quot;$\\mathcal{C} ( \\stackrel{\\mathcal{R}}{\\leftarrow} \\mathcal{U};&quot;. $\\mathbb{P}_{pred}$ is defined as &quot;$\\mathcal{A}(\\mathcal{C}, SI, PI^{publ}, sol_c) = b&quot;. Additionally, the probability statement $\\mathbb{P}$ is normalized to &quot;2 ( |\\mathbb{P}\\mathbf{rob}[\\mathbb{S}\\mathbb{P}_{pred} :: \\mathbb{P}_{def}] 0.5|&quot;.</li>
      <li>$t = M: Initialize $\\mathbb{P}_{def}$ to the concatenation of &quot;b  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span>  {0,1};&quot; (the random bit used as challenge), &quot;PI_0 ( \\simes SPI_{\\mathbb{P}}(SI);&quot; and &quot;PI_1 ( SPI_{\\mathbb{P}}(SI);&quot; (the two problem instances to match), &quot;sol_0  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span>  PI_0 sol&quot; and &quot;sol_1  <span class="math">\\stackrel{\\mathcal{R}}{\\leftarrow}</span>  PI_1 sol&quot; (two corresponding solutions), and &quot;$\\mathcal{C} \\simes \\mathcal{U}$;&quot;. $\\mathbb{P}_{pred}$ is defined as &quot;$\\mathcal{A}(\\mathcal{C}, SI, PI_0^{publ}, PI_1^{publ}, sol_b, sol_{\\bar{b}}) = b&quot;. Additionally, the probability statement $\\mathbb{P}$ is normalized as above to &quot;2 \\cdot |\\mathbb{P}\\mathcal{c}| \\mathbb{P}_{pred} :: $\\mathbb{P}_{def}| 0.5|&quot;.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Granularity:</strong> Depending on the granularity value $g do the following (where  <span class="math">SG_{\\mathcal{G}}</span>  and Sg are the group and generator sampler fixed in item 1):</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{41}&lt;/sup&gt;</span> In practice, only the later application of this relation using specific assumptions implied by a cryptographic systems will determine the concrete choices of group family and sampler.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>$g = l: Prepend &quot;G &larr; SGG(1<sup>k</sup> );&quot;, &quot;g<sup>i</sup> &larr; Sg(G);&quot; (for as many i &isin; as required by the problem family, e.g., one generator for DL and n generators for RP(n)), and &quot;SI &larr; (G, g1, . . .);&quot; to $Pdef.</li>
      <li>$g = m: Prepend &quot;&forall;G &isin; [SGG(1<sup>k</sup> )]; to $F. Prepend &quot;g &larr; Sg(G);&quot; and &quot;SI &larr; (G, g1, . . .);&quot; to $Pdef.</li>
      <li>$g = h: Prepend &quot;&forall;G &isin; [SGG(1<sup>k</sup> )];&quot;, &quot;&forall;g<sup>i</sup> &isin; [Sg(G)];&quot;, and &quot;SI &larr; (G, g1, . . .);&quot; to $F.</li>
      <li>4. Computational complexity and algebraic knowledge: Depending on the computational complexity $c do the following:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>$c = u: Prefix $F with &quot;&forall;A &isin; UPT M;&quot;, &quot;&exist;k0;&quot;, and &quot;&forall;k &gt; k0;&quot;.</li>
      <li>$c = n: Prefix $F with &quot;&forall;(A<sup>i</sup> | i &isin; ) &isin; N PT M;&quot;, &quot;&exist;k0;&quot;, and &quot;&forall;k &gt; k0;&quot;. In $Ppred replace &quot;A&quot; by &quot;Ak&quot;.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If the considered assumption is in the generic model ($a = &sigma;) then replace everywhere &quot;A&quot;, UPT M and N PT M by &quot;A<sup>&sigma;</sup>&quot;, UPT M<sup>&sigma;</sup> and N PT M<sup>&sigma;</sup> , respectively. Furthermore, append &quot;&sigma; &larr;<sup>R</sup> &Sigma;G,g;&quot; (the choice of the random encoding function) to $Pdef.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Success probability: Depending on the success probability $s do the following to finish the formal assumption statement:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>$s = 1: Append &quot;&lt; 1&quot; to $F, i.e., immediately after $P.</li>
      <li>$s = (1 &minus; 1/poly(k)): Append &quot;&exist;d1;&quot; immediately after the allquantifier on adversary algorithms in $F. Append &quot;&lt; (1 &minus; 1/k<sup>d</sup><sup>1</sup> )&quot; to $F.</li>
      <li>$s = : Append &quot;&lt; &quot; to $F.</li>
      <li>$s = 1/poly(k): Append &quot;&forall;d1;&quot; immediately after the all-quantifier on adversary algorithms in $F. Append &quot;&lt; 1/k<sup>d</sup><sup>1</sup> &quot; to $F.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Evaluating $F by expanding the variables , i.e., $P, $Ppred and $Pdef, and applying the string-concatenation operator gives now the desired precise formal assumption statement.</p>

    </section>
`;
---

<BaseLayout title="Assumptions Related to Discrete Logarithms: Why Subtleties M... (2002/126)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/126
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Terminology</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">General Notational Conventions</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Asymptotics</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Computational Model</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Indistinguishability</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Algebraic Structures</a></li>
            <li><a href="#sec-2.6" class="hover:text-white">Problems</a></li>
            <li><a href="#sec-2.7" class="hover:text-white">Samplers</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Parameters of DL-based Assumptions</a></li>
        <li><a href="#sec-4" class="hover:text-white">Defining Assumptions</a></li>
        <li><a href="#sec-5" class="hover:text-white">The Impact of Granularity</a></li>
        <li>
          <a href="#sec-6" class="hover:text-white">Computational DH, SE and IE</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Self-Correction</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">CSE versus CDH</a></li>
            <li><a href="#sec-6.2.1" class="hover:text-white">High Granular</a></li>
            <li><a href="#sec-6.2.2" class="hover:text-white">Medium Granular</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">CDH versus CIE</a></li>
            <li><a href="#sec-6.3.1" class="hover:text-white">High Granular</a></li>
            <li><a href="#sec-6.3.2" class="hover:text-white">Medium Granular</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">Decisional DH, SE and IE</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">Difficulty in the Generic Model</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">DSE versus DDH</a></li>
            <li><a href="#sec-7.2.1" class="hover:text-white">High Granular</a></li>
            <li><a href="#sec-7.3" class="hover:text-white">DIE versus DDH</a></li>
            <li><a href="#sec-7.3.1" class="hover:text-white">High Granular</a></li>
            <li><a href="#sec-7.4" class="hover:text-white">DSE versus DIE</a></li>
            <li><a href="#sec-7.4.1" class="hover:text-white">High Granular</a></li>
            <li><a href="#sec-7.4.2" class="hover:text-white">Medium Granular</a></li>
          </ol>
        </li>
        <li><a href="#sec-8" class="hover:text-white">Conclusions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Deriving Formal Assumptions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="assumptions-related-to-discrete-logarithms-why-subtleties-2002" />
  </article>
</BaseLayout>
