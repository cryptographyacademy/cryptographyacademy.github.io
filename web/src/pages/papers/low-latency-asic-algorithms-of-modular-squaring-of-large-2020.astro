---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/480';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Low-Latency ASIC Algorithms of Modular Squaring of Large Integers for VDF Evaluation';
const AUTHORS_HTML = 'Ahmet Can Mert, Erdinc Ozturk, Erkay Savas';

const CONTENT = `    <p class="text-gray-300">1</p>

    <p class="text-gray-300">Ahmet Can Mert, Erdinç Öztürk, Erkay Savaş, Member, IEEE</p>

    <p class="text-gray-300">Abstract—This study is an attempt in quest of the fastest hardware algorithms for the computation of the evaluation component of verifiable delay functions (VDFs), <span class="math">a^{2^T} \\mod N</span>, proposed for use in various distributed protocols, in which no party is assumed to compute it significantly faster than other participants. To this end, we propose a class of modular squaring algorithms suitable for low-latency ASIC implementations. The proposed algorithms aim to achieve highest levels of parallelization that have not been explored in previous works in the literature, which usually pursue more balanced optimization of speed and area. For this, we utilize redundant representations of integers and introduce three modular squaring algorithms that work with integers in redundant forms: i) Montgomery algorithm, ii) memory-based algorithm and iii) direct reduction algorithm for fixed moduli. All algorithms enable <span class="math">O(\\log k)</span> depth circuit implementations, where <span class="math">k</span> is the bit-size of the modulus <span class="math">N</span> in the VDF function. We analyze and compare gate level-circuits of the proposed algorithms and provide estimates for their critical path delay and gate count.</p>

    <p class="text-gray-300">Index Terms—Verifiable Delay Functions, Modular Squaring, Reduction, Montgomery, Redundant Representation</p>

    <p class="text-gray-300">A Verifiable Delay Function (VDF) consists of an inherently sequential operation, which takes some prescribed and modifiable amount of time for its computation. The term verifiable emerges from the fact that the computation needs to be verified fairly quickly, without re-doing the entire costly operation. Any function that is inherently sequential, cryptographically secure and publicly and efficiently verifiable can be considered a VDF.</p>

    <p class="text-gray-300">As stated in [1], with additional formal definition, a VDF is only complete with the following operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construction: VDFs are constructed with certain algorithms and security parameters. For example, if the VDF is based on a group of unknown order, field size is one of the security parameters. For real-life applications, once the construction phase is complete, other parts of VDF can be implemented. For practicality, construction should not change frequently.</li>

      <li>Setup: As stated, a VDF is an operation that takes some prescribed and modifiable amount of time. Given a VDF construction, in order to ensure the required minimum computation time for evaluation of the inherently sequential function, certain parameters need to be setup.</li>

      <li>Evaluate: Evaluation function is the aforementioned inherently sequential function, computed using only the construction and setup parameters. Evaluation function must be setup to output some amount of intermediate results (proof [1]), depending the proving algorithm. This proof data helps the proving algorithm to verify the result of the computation without re-doing the entire costly operation. Without this proof data, there is no other way of computing the output of the evaluation function other than re-evaluation.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove: For any VDF, the output of the evaluation function needs to be verified, using the proof data. Depending on the VDF construction, different prover algorithms can be utilized. One common property of these algorithms is that they are not as costly as the evaluation functions, as they are using the intermediate results from the evaluator, reducing the amount of required computations.</li>

    </ul>

    <p class="text-gray-300">For any VDF construction, evaluation is the most time-consuming and compute-intensive function. Therefore, in this paper, we focus only on constructions for VDF evaluation.</p>

    <p class="text-gray-300">The two recent VDF constructions proposed by Pietrzak [2] and Wesolowski [3] are based on time-lock puzzles and they are thoroughly analyzed by Boneh et al. in [1]. The notion of time-lock puzzles, introduced by Rivest, Shamir, and Wagner [4] in 1999, is built upon an inherently sequential and cryptographically secure mathematical operation: exponentiation in a group of unknown order [5]. The exponent utilized for time-lock puzzles is of special form, which transforms the exponentiation operation into repeated squaring operations; e.g., <span class="math">a^{2^T} \\mod N</span>.</p>

    <p class="text-gray-300">Since time-lock puzzles are constructed upon repeated modular squaring operations, VDF constructions utilizing time-lock puzzles rely on efficient implementations of low-latency modular squaring algorithms, optimized for repeated-squaring setting. As the entire exponentiation operation of VDF evaluation, rather than a single modular squaring, calls for a low-latency design, any redundant representation and lazy reduction technique can be utilized to accelerate intermediate modular squaring computations. While there is a plethora of efficient implementations of modular multiplication and modular squaring in the literature [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], they mostly focus on throughput, utilizing the time-area metric for measuring performance. Yet, for a VDF evaluator implementation, the most important metric is time itself as the VDF evaluation, which is an inherently sequential function that cannot be parallelized regardless of the amount of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ahmet Can Mert, Erdinç Öztürk and Erkay Savaş are with the Faculty of Engineering and Natural Sciences, Sabancı University, Istanbul, Turkey. E-mail: {ahmetcanmert,erdinco,erkays}@sabanciuniv.edu</li>

    </ul>

    <p class="text-gray-300">compute resources, should take the minimum amount of time possible.</p>

    <p class="text-gray-300">There are well-studied high-level algorithms and methods enabling efficient modular multiplication implementations. One of the most commonly used modular multiplication algorithm is due to Montgomery <em>[17]</em>. The Montgomery modular multiplication algorithm realizes <span class="math">C^{\\prime}\\equiv A\\cdot B\\cdot R^{-1}</span> (mod <span class="math">N</span>) instead of the desired <span class="math">C=A\\cdot B</span> (mod <span class="math">N</span>) result. To compute the desired result, pre- and post-processing steps are usually required. Therefore, the Montgomery modular multiplication algorithm is efficient only for applications involving many modular arithmetic operations, such as exponentiation, due to inherent pre-processing and post-processing overheads.</p>

    <p class="text-gray-300">Barrett reduction <em>[18]</em> can also be utilized for implementing modular multiplication operation. It computes the desired outcome <span class="math">C=A\\cdot B</span> (mod <span class="math">N</span>) directly, which makes it a better choice for a single modular multiplication scheme. Although Barrett and Montgomery reduction algorithms are similar in terms of complexity, they yield different performance figures in different implementation settings <em>[19, 20]</em>.</p>

    <p class="text-gray-300">There are algorithms that allow lower circuit depth than classical multiplication operation <em>[21, 22]</em>. Schonhage-Strassen is an NTT-based method presented in 1971 that can multiply two n-bit integers in <span class="math">O(n\\log n\\log\\log n)</span> time <em>[23]</em>. Harvey et al. presented an improved algorithm that can multiply two <span class="math">n</span>-bit integers in <span class="math">O(n\\log n4^{\\log n})</span> operations <em>[24, 25]</em>. However, efficient low-latency hardware implementations of these schemes do not exist in literature. While a theoretical log-depth circuit algorithm is presented in <em>[22]</em>, no practical low-latency implementation of this algorithm has been reported in the literature to the best of our knowledge.</p>

    <p class="text-gray-300">Depending on specific application and computation platform used for implementation, different constraints and design goals can be adopted in the design and implementation of a modular multiplication circuit. For instance, a low-power design is usually targeted for implementations in resource-constrained devices. For data center applications, an implementation with high throughput is usually the primary requirement. For typical client applications, a public-key operation finished in milliseconds range is sufficient for a practical implementation. Consequently, low-latency is hardly the predominant or the only design metric for most cases as others such as cost and time-area are almost always taken into consideration.</p>

    <p class="text-gray-300">In a typical application of VDF, verifiable lottery using a randomness beacon <em>[5]</em>, no participant is allowed to compute VDF significantly faster than others. Namely, all participants are supposed to be equipped with sufficiently fast hardware for the VDF computation. Consequently, for the RSA-based VDF construction <em>[2, 3, 5]</em>, metrics such as throughput, power and area become either irrelevant or less important emphasizing the need for a low-latency design. This calls for more aggressive acceleration techniques, which have not been explored in the literature before except in <em>[26]</em>. In <em>[26]</em>, the author discusses a low-latency modular multiplication algorithm and construction for a known modulus, targeting FPGA architecture for proof of concept performance.</p>

    <p class="text-gray-300">Contribution: In this paper, highly parallel, regularly structured, and bitwise modular squaring algorithms are explored and proposed for efficient low-latency ASIC implementations. The algorithms utilize various redundant representations to reduce circuit depth. To this end, we first introduce a variant of the Montgomery reduction algorithm that works with integers in redundant representations, requires no final subtraction and utilizes incomplete arithmetic <em>[27]</em>. Then, we explore two other modular reduction algorithms: i) memory-based reduction for variable moduli and ii) direct reduction for fixed moduli. We study the modular multiplication algorithm in <em>[26]</em>, based on polynomial representation, originally optimized for FPGA implementations and uses only memory-based approach for modular reduction. We, then, introduce three different modular squaring algorithms using polynomial representation for low-latency ASIC implementations. We show that the proposed algorithms enable <span class="math">O(\\log k)</span> depth circuit implementations for modular squaring operation on large <span class="math">k</span>-bit integers and amenable to highly regular and low fan-out designs. We analyze all algorithms and provide estimates for critical path delay and gate count.</p>

    <p class="text-gray-300">The remainder of the paper is structured as follows: Section 2 presents background information such as basic notations, bitwise integer operations and redundant representation of integers. Section 3 presents two widely used classes of adder tree constructions, Wallace and Dadda tree methods and provides an explicit algorithm for Dadda tree. Section 4 presents three modular squaring methods for integers in Carry-Save (C-S) representation which are suitable for low-latency circuit implementations. Section 5 describes Redundant-Polynomial (R-P) representation for integers and presents its utilization in different modular squaring methods. Section 6 compares the proposed algorithms and gives estimates for their ASIC implementations. Section 7 concludes the paper.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Background</h2>

    <p class="text-gray-300">Throughout the paper, a <span class="math">k</span>-bit integer <span class="math">a</span> is represented in radix 2 as <span class="math">a=(a_{k-1},\\ldots,a_{1},a_{0})_{2}</span>, where <span class="math">a_{i}\\in\\{0,1\\}</span>. When a radix larger than 2 is used, we use uppercase letters to represent the digits of integers; e.g., <span class="math">(A_{s-1},\\ldots,A_{1},A_{0})</span>, where <span class="math">A_{i}</span> is the <span class="math">i^{th}</span> digit and <span class="math">A_{i}&lt;2^{r}</span> with <span class="math">r&gt;1</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Bitwise Integer Multiplication</h3>

    <p class="text-gray-300">In a straightforward gate-level implementation of bitwise integer multiplication, there are a total of <span class="math">k^{2}</span> bitwise logical-AND (<span class="math">\\land</span>) operations and sequential addition operations resulting in prohibitively long carry chains. Therefore, in hardware realizations the multiplication operation is performed often in two phases. Algorithm 1 elaborates this method. In the first phase, all partial product bits are calculated using <span class="math">k^{2}</span> logical-AND gates in parallel and grouped in the partial product list <span class="math">t</span> as shown in Steps 2-6 of Algorithm 1. Here, a list is a two-dimensional data structure with different sized columns. Furthermore, for <span class="math">i=0,\\ldots,2k-1</span>, <span class="math">t_{i}</span>s are the columns of the product list <span class="math">t</span>, where each column is a multiset of partial product bits of the same weight. Each partial product bit is appended (using the set union operation <span class="math">\\cup</span>) in the corresponding column and no addition operation is performed in the first phase.</p>

    <p class="text-gray-300">Then in the second phase (Step 7 of Algorithm 1), the partial product bits are summed using efficient adder tree constructions such as Wallace <em>[28]</em> or Dadda Trees <em>[29]</em>. The result <span class="math">c</span> is in the redundant C-S form, which means most of <span class="math">c_{i}</span> consist of two bits: the carry bit <span class="math">c_{i,1}</span> and the save bit <span class="math">c_{i,0}</span>. Since the result <span class="math">c</span> is in redundant form, it is transformed into non-redundant form using fast carry propagation adders (CPAs)</p>

    <p class="text-gray-300">Algorithm 1 Bitwise Integer Multiplication Suitable for Hardware Implementation Input:  <span class="math">a = (a_{k - 1},\\dots ,a_1,a_0)</span> <span class="math">b = (b_{k - 1},\\dots ,b_1,b_0)</span> Output:  <span class="math">c = (c_{2k - 1},\\dots ,c_1,c_0)</span>  where  <span class="math">c = a\\cdot b</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: for  <span class="math">i</span>  from 0 to  <span class="math">(2k - 1)</span>  do  $t_i\\gets</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\emptyset</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  end for</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2: for  <span class="math">i</span>  from 0 to  <span class="math">(k - 1)</span>  do ▷ First Phase 3: for  <span class="math">j</span>  from 0 to  <span class="math">(k - 1)</span>  do 4:  <span class="math">t_{i + j}\\gets t_{i + j}\\cup (b_i\\wedge a_j)</span> 5: end for 6: end for 7:  <span class="math">t\\gets</span>  ADDERTREE(t) ▷ Second Phase 8:  <span class="math">c\\gets \\mathrm{CPA}(t)</span></p>

    <p class="text-gray-300">[30], [31]. As our operands are very large, the CPA still creates very long carry chains. In this paper, we propose algorithms either to shorten the carry chain of CPA or eliminate CPA altogether from the hardware implementation for low-latency applications such as VDF, as stated in [26]. To this end, we utilize various redundant forms for integers.</p>

    <p class="text-gray-300">Example 1. Fig. 1 illustrates the operations of Algorithm 1 for 4-bit operands  <span class="math">(k = 4)</span> . As observed from the figure, the columns of the partial product list have different number of bits.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The Operations of Algorithm 1 for  <span class="math">k = 4</span></p>

    <p class="text-gray-300">Algorithm 2 for integer squaring is a simplified version of Algorithm 1 for the case  <span class="math">b = a</span> , in which  <span class="math">a_i \\wedge b_j = a_j \\wedge b_i</span>  for  <span class="math">i \\neq j</span> . As we have  <span class="math">a_i \\wedge a_j + a_j \\wedge a_i = 2 \\cdot (a_i \\wedge a_j)</span>  and multiplication by 2 is realized via a simple shift operation, the weight of  <span class="math">(a_i \\wedge a_j)</span>  becomes  <span class="math">i + j + 1</span> , instead of  <span class="math">i + j</span>  (see Step 5 of Algorithm 2).</p>

    <p class="text-gray-300">Algorithm 2 Bitwise Integer Squaring Input:  <span class="math">a = (a_{k - 1},\\dots ,a_1,a_0)</span> Output:  <span class="math">d = (d_{2k - 1},\\ldots ,d_1,d_0)</span>  where  <span class="math">d = a^2</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: for  <span class="math">i</span>  from 0 to  <span class="math">(2k - 1)</span>  do  $t_i\\gets</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\emptyset</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  end for</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2: for  <span class="math">i</span>  from 0 to  <span class="math">(k - 1)</span>  do ▷ First Phase 3:  <span class="math">t_{2i}\\gets t_{2i}\\cup a_i</span> 4: for  <span class="math">j</span>  from  <span class="math">(i + 1)</span>  to  <span class="math">(k - 1)</span>  do 5:  <span class="math">t_{i + j + 1}\\gets t_{i + j + 1}\\cup (a_i\\wedge a_j)</span> 6: end for 7: end for 8:  <span class="math">t\\gets</span>  ADDERTREE(t) ▷ Second Phase 9:  <span class="math">d\\gets \\mathrm{CPA}(t)</span></p>

    <p class="text-gray-300">Algorithm 2 shows that there is a total of  <span class="math">(k^2 + k) / 2</span>  logical-AND operations, all of which can be performed in parallel.</p>

    <p class="text-gray-300">Thus, the circuit delay for the first phase is equivalent to the delay of an AND gate. For the second phase, the circuit delay is determined by the delay of the adder tree, which is logarithmic with respect to the input size  <span class="math">k</span>  as shown in Section 3.</p>

    <p class="text-gray-300">Example 2. Fig. 2 illustrates the operations of Algorithm 2 for  <span class="math">k = 4</span> . Note that the column  <span class="math">t_1</span>  in the partial product list is an empty set.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. The Operations of Algorithm 2 for  <span class="math">k = 4</span></p>

    <p class="text-gray-300">A positive integer in the interval  <span class="math">[0, N)</span>  can be represented using as low as  <span class="math">k = \\lceil \\log_2 N \\rceil</span>  bits. Generally speaking, any representation using more bits than this lower bound can be referred as redundant representation. The most common examples are Carry-Save and redundant signed digit (RSD) representations [32].</p>

    <p class="text-gray-300">In RSD representation [33], an integer  <span class="math">a</span>  is viewed as the difference between two positive integers, while in C-S it is the sum of two such integers. In binary, we can write  <span class="math">a = \\sum_{i=0}^{k-1} (a_{i,0} - a_{i,1}) 2^i</span>  and  <span class="math">a = \\sum_{i=0}^{k-1} (a_{i,0} + a_{i,1}) 2^i</span>  for RSD and C-S representations, respectively. Redundant representations are useful to defer additions (or subtractions) for avoiding delays of long carry chains.</p>

    <p class="text-gray-300">We can generalize the C-S representation to have an arbitrary number of bits for each weight as</p>

    <div class="my-4 text-center"><span class="math-block">a = \\sum_ {i = 0} ^ {k - 1} \\left(a _ {i, 0} + a _ {i, 1} + \\dots + a _ {i, i _ {v}}\\right) 2 ^ {i}, \\tag {1}</span></div>

    <p class="text-gray-300">where  <span class="math">i_v \\geq 0</span>  is an integer. Also, we can combine all the bits with the same weight into a set of bits; e.g.,  <span class="math">a_i = \\{a_{i,0}, a_{i,1}, \\ldots, a_{i,i_v}\\}</span>  for  <span class="math">i = 0, \\ldots, k-1</span> . This new notation is especially useful to denote the bits accumulated in the adder tree in the first phase of Algorithms 1 and 2 before the addition operation.</p>

    <p class="text-gray-300">Example 3. Using the new notation, the result of the first phase of the bitwise squaring operation of a 4-bit integer  <span class="math">a</span> ,  <span class="math">d = a^2</span>  in Example 2 can be written in generic redundant representation as  <span class="math">t_0 = \\{t_{0,0}\\}, t_1 = \\{\\emptyset\\}, t_2 = \\{t_{2,0}, t_{2,1}\\}, t_3 = \\{t_{3,0}\\}</span> ,  <span class="math">t_4 = \\{t_{4,0}, t_{4,1}, t_{4,2}\\}, t_5 = \\{t_{5,0}\\}, t_6 = \\{t_{6,0}, t_{6,1}\\}</span> , where  <span class="math">t_{0,0} = a_0</span> ,  <span class="math">t_{2,0} = a_0 \\wedge a_1</span> ,  <span class="math">t_{2,1} = a_1</span> ,  <span class="math">t_{3,0} = a_0 \\wedge a_2</span> ,  <span class="math">t_{4,0} = a_0 \\wedge a_3</span> ,  <span class="math">t_{4,1} = a_1 \\wedge a_2</span> ,  <span class="math">t_{4,2} = a_2</span> ,  <span class="math">t_{5,0} = a_1 \\wedge a_3</span> ,  <span class="math">t_{6,0} = a_2 \\wedge a_3</span> , and  <span class="math">t_{6,0} = a_3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As shown in Example 3, the sets for each weight can contain different number of bits. We adopt the notation that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of elements in the set  </span>t_i<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of sets in the redundant representation. Also,  </span>\\mathrm{DEPTH}(t) = \\max</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For example, the classical C-S representation has  </span>\\mathrm{DEPTH}(t) = 2$  while the redundant representation in Example 3 has depth 3. The actual summation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">operation can be performed using adder tree constructions as explained in Section 3.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Adder Tree Constructions</h2>

    <p class="text-gray-300">In <em>[28]</em>, Wallace proposed adder tree circuits to eliminate long carry chains in Algorithms 1 and 2 using counters, which are combinational logic elements that output the number of ones in their inputs. The two most common counters are <span class="math">(2\\times 2)</span> half adder (HA) and <span class="math">(3\\times 2)</span> full adder (FA) counters. Other counters include <span class="math">(7\\times 3)</span>, <span class="math">(15\\times 4)</span>, and <span class="math">(31\\times 5)</span> counters.</p>

    <p class="text-gray-300">The Wallace tree consists of layers, in each of which we have a different redundant representation of the same integer; e.g., the result of the squaring operation. A layer is of lower depth than the previous layer and the last layer is of depth two. In a layer, there are counters acting on the bits of the columns of the partial product list <span class="math">t</span>. As the counters in one layer works in parallel, they are referred as parallel counters in <em>[29]</em>. Consequently, the delay of a Wallace tree layer is equivalent to the delay of the slowest counter employed in the layer.</p>

    <p class="text-gray-300">There are different adaptations of Wallace trees. For example, the greedy Wallace tree working with HAs and FAs combines the sets in redundant representation in each layer into three-bit groups and apply each group to the inputs of a FA. If there are two bits not included in any group, they are applied to the input of a HA. When there is only a single bit left, it will be copied to the next layer as is. Both FA and HA have two outputs: carry and sum. The sum output will be copied to the set with the same weight in the next layer while the carry output will be appended to the set with one larger weight in the next layer.</p>

    <p class="text-gray-300">An alternative adaptation performs the grouping according to the deepest set; e.g., <span class="math">t_{k-1}</span> for <span class="math">k</span>-bit multiplication. The bits of this set are grouped in three. If there are two bits in any other set corresponding to a three-bit group in the longest set, then they are applied to the inputs of a HA. If there is a single bit in such situations, it will be copied to the next layer as is. If there are one or two rows left after grouping, they will directly be copied to the next layer, as well. The next example illustrates this adaptation.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Example 4.</h6>

    <p class="text-gray-300">The integer multiplication operation in Example 1 results in a redundant representation of depth 4 after the first phase as shown in Fig. 3 (see Layer I). The Wallace tree first reduces the depth to 3 and then to 2, as can be observed in Layer II of the circuit and the resulting integer in C-S form, respectively. The boxes with two and three dots stand for HA and FA, respectively. This Wallace tree employs 3 HAs and 5 FAs, in total.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: The Wallace Tree Layers for <span class="math">k=4</span></p>

    <p class="text-gray-300">After the final layer of a Wallace tree, the resulting integer is in redundant representation of depth two, which is the regular C-S form. For the final result, a CPA is used to add carry and save parts. As all HAs and FAs work independently and thus in parallel to each other, the time delay of one layer of Wallace tree is always equivalent to one FA delay.</p>

    <p class="text-gray-300">When FA and HA are used, we can give a lower bound for the number of layers <span class="math">L(h)</span> to reduce a redundant representation of depth <span class="math">h</span> to depth 2 representation <em>[32]</em>:</p>

    <p class="text-gray-300"><span class="math">L(h)\\geq</span> <span class="math">\\log_{1.5}(h/2).</span> (2)</p>

    <p class="text-gray-300">The multiplication of two <span class="math">k</span>-bit integers and squaring of a <span class="math">k</span>-bit integer lead to trees of depth <span class="math">k</span> and <span class="math">\\lfloor k/2\\rfloor+1</span>, respectively. Consequently, the lower bounds for the number of layers to reduce the depths of <span class="math">k</span>-bit multiplication and squaring to 2 are <span class="math">\\lceil\\log_{1.5}(k/2)\\rceil</span> and <span class="math">\\lceil\\log_{1.5}((\\lfloor k/2\\rfloor+1)/2)\\rceil</span>, respectively. For example, the multiplication of two 2048-bit integers results in a tree of depth 2048 while the squaring of a 2048-bit integer leads to a shorter tree of depth <span class="math">\\lfloor 2048/2\\rfloor+1=1025</span>. Consequently, the lower bounds for the number of layers needed to reduce the trees in multiplication of two 2048-bit integers and squaring of a 2048-bit integer are <span class="math">\\lceil\\log_{1.5}(2048/2)\\rceil=18</span> and <span class="math">\\lceil\\log_{1.5}(1025/2)\\rceil=16</span>, respectively.</p>

    <p class="text-gray-300">The number of layers is, in fact, determined by the compression factor, which is the ratio of the number of inputs to the number of outputs of the largest counter used in the Wallace tree. For instance, when the largest counter is a FA, then the compression factor is 1.5, which explains the base of the logarithm in Equation 2.</p>

    <p class="text-gray-300">In <em>[29]</em>, Dadda observes that the compression factor in fact determines the reduction amount in the depths of the tree from one layer to the next. He, then, proposes a method to minimize the number of counters used in one layer. To this end, Dadda’s method utilizes an array of integers that is recursively generated as <span class="math">D[0]=2</span> and <span class="math">D[i]=\\lfloor 1.5\\cdot D[i-1]\\rfloor</span> for <span class="math">i\\geq 1</span>. This array also determines how to reach a representation of depth 2 progressively.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Example 5.</h6>

    <p class="text-gray-300">Dadda’s method uses the array <span class="math">D=[2,3,4,6,9,13,19,28,42,63,94,141,\\ldots]</span> for reducing the depth of the tree to 2. For a <span class="math">k</span>-bit multiplication operation with <span class="math">k=128</span> which has initial depth of 128, Dadda’s method first reduces the depth from 128 to 94 since initial depth 128 falls between <span class="math">D[10]=94</span> and <span class="math">D[11]=141</span>. Then, it reduces the depth from <span class="math">D[10]=94</span> to <span class="math">D[9]=63</span> . The operation continued until the tree of depth <span class="math">D[0]=2</span> is obtained.</p>

    <p class="text-gray-300">Dadda’s method uses no more counters than sufficient to reduce the depth of a tree layer to next smaller integer in <span class="math">D</span> than the current depth. The method is given in Algorithm 3, where one iteration of the while loop stands for one layer of Dadda tree.</p>

    <p class="text-gray-300">Algorithm 3 determines the depth of the next layer <span class="math">\\beta</span> in Step 2 using the FindNextMaxDepth function, which computes the maximum element in <span class="math">D</span> that is smaller than the depth of the current layer. Then, using FAs and HAs, the depth of the next layer will be reduced to <span class="math">\\beta</span>. If the depth of a set <span class="math">t_{i}</span> is already less than or equal to <span class="math">\\beta</span>, then no counter is used and the set is copied to the next layer with no change. Otherwise, counters are used to decrease the depth of <span class="math">t_{i}</span> to <span class="math">\\beta</span> (Steps 8-21 of Algorithm 3).</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Example 6.</h6>

    <p class="text-gray-300">Fig. 4 shows how Dadda’s method reduces the depth of redundant result in Example 1 from 4 to 2. In</p>

    <p class="text-gray-300">Algorithm 3 AddERTREE with Dadda's Method [29] Input:  <span class="math">t = (\\{t_{k - 1,0},\\dots ,t_{k - 1,d_{k - 1} - 1}\\} ,\\dots ,\\{t_{0,0},\\dots ,t_{0,d_0 - 1}\\})</span> <span class="math">D = (D[0],D[1],D[2],\\ldots)</span> Output:  <span class="math">t = (\\{t_{k - 1,0},t_{k - 1,1}\\} ,\\dots ,\\{t_{0,0},t_{0,1}\\})</span> 1: while MAXDEPTH  <span class="math">(t) &amp;gt; 2</span>  do 2:  <span class="math">\\beta \\gets</span>  FINDNEXTMAXDEPTH(DEPTH  <span class="math">(t),D)</span> 3:  <span class="math">\\nu \\gets \\{\\emptyset \\}</span> 4: for i from 0 to  <span class="math">(k - 1)</span>  by 1 do 5:  <span class="math">t_i\\gets t_i\\cup \\nu</span> 6:  <span class="math">\\nu \\gets \\{\\emptyset \\} ;\\sigma \\gets \\{\\emptyset \\}</span> 7: if DEPTH  <span class="math">(t_i) &amp;gt; \\beta</span>  then 8:  <span class="math">\\Delta \\gets</span>  DEPTH  <span class="math">(t_i) - \\beta</span> 9:  <span class="math">f\\gets [\\Delta /2];h\\gets \\Delta</span>  mod 2 10: for j from 0 to  <span class="math">(3f - 1)</span>  by 3 do 11:  <span class="math">C,S\\gets \\mathrm{FA}(t_{i,j},t_{i,j + 1},t_{i,j + 2})</span> 12:  <span class="math">\\sigma \\gets \\sigma \\cup S;\\nu \\gets \\nu \\cup C</span> 13: end for 14: for j from 3f to  <span class="math">(3f + 2h - 1)</span>  by 2 do 15:  <span class="math">C,S\\gets \\mathrm{HA}(t_{i,j},t_{i,j + 1})</span> 16:  <span class="math">\\sigma \\gets \\sigma \\cup S;\\nu \\gets \\nu \\cup C</span> 17: end for 18: for j from  <span class="math">(3f + 2h)</span>  to (DEPTH  <span class="math">(t_i) - 1)</span>  by 1 do 19:  <span class="math">\\sigma \\gets \\sigma \\cup t_{i,j}</span> 20: end for 21:  <span class="math">t_i\\gets \\sigma</span> 22: end if 23: end for 24: end while</p>

    <p class="text-gray-300">Layer I, where  <span class="math">\\beta = 3</span> , 2 HAs are used to reduce  <span class="math">t_3</span>  and  <span class="math">t_4</span>  as these sets are likely to produce sets with depths greater than 3 in the next layer if their depths are not reduced otherwise. In Layer II, where  <span class="math">\\beta = 2</span> , the three sets  <span class="math">t_3 - t_5</span>  are reduced using 3 FAs and  <span class="math">t_2</span>  is reduced using 1 HA. Dadda's method employs 3 HAs and 3 FAs, which results in smaller circuit area than the one produced by the Wallace tree in Example 4 (cf. 3 HAs and 5 FAs) and the circuit delay is equivalent to the total delay of one FA and one HA.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. The Dadda Tree Layers for  <span class="math">k = 4</span></p>

    <p class="text-gray-300">As it is likely to result in slightly smaller circuits, the function AddERTREE uses Dadda's method in the subsequent sections of the this paper.</p>

    <p class="text-gray-300">In this section, we present three modular squaring methods suitable for low-latency circuit implementations for the computation of the VDF function  <span class="math">a^{2^T} \\pmod{N}</span> . All the methods take an integer  <span class="math">a</span>  in C-S form and outputs the result  <span class="math">c = a^2 \\pmod{N}</span></p>

    <p class="text-gray-300">also in C-S form, where the modulus  <span class="math">N</span>  is any odd integer. Consequently, no CPA is needed and long carry chains are completely avoided during the computation of  <span class="math">a^{2^T} \\pmod{N}</span> . Only one CPA is used after the final modular squaring of the exponentiation. Note that algorithms in this section employ incomplete arithmetic similar to [27], which basically works with inputs and outputs not fully reduced with modulus  <span class="math">N</span> , but always in the equivalence class.</p>

    <p class="text-gray-300">The first method is a variant of the Montgomery modular multiplication algorithm, which is efficient for randomly chosen variable moduli. The second method uses a memory-based modular reduction algorithm, where memory cells can be used to configure the circuit for different moduli. The third method are used when the modulus is fixed. In all cases, we assume the modulus is randomly chosen and has no special form as the RSA setting is usually employed in VDF instances.</p>

    <p class="text-gray-300">The Montgomery algorithm [17] eliminates costly division operation from the modular reduction and employs shift operations instead, which are free of cost in hardware implementations. It, however, computes  <span class="math">abR^{-1}</span>  (mod  <span class="math">N</span> ) instead of  <span class="math">ab</span>  (mod  <span class="math">N</span> ), where  <span class="math">\\gcd(R, N) = 1</span>  and  <span class="math">R</span>  is chosen as a power of two. This, on the other hand, leads to no complications, especially in exponentiation operations as at the end, a simple transformation operation suffices to obtain the result in the correct form. For this the input  <span class="math">a</span>  is first transformed into the Montgomery form  <span class="math">aR</span>  (mod  <span class="math">N</span> ) by multiplying it with the precomputed constant  <span class="math">R^2</span>  (mod  <span class="math">N</span> ) using the Montgomery multiplication algorithm. Then,  <span class="math">aR</span>  (mod  <span class="math">N</span> ) is raised to the power of  <span class="math">2^T</span> , which results in  <span class="math">a^{2^T}R</span>  (mod  <span class="math">N</span> ). Finally, to obtain the desired result  <span class="math">a^{2^T}</span>  (mod  <span class="math">N</span> ),  <span class="math">a^{2^T}R</span>  (mod  <span class="math">N</span> ) is multiplied by 1.</p>

    <p class="text-gray-300">There are various methods to compute the Montgomery multiplication [34] such as separate operand scanning (SOS), coarsely integrated operand scanning (CIOS) etc. Here, we employ the simple SOS method, which performs the integer squaring first and then the Montgomery reduction operation. Namely, given an integer  <span class="math">a</span>  we first perform the integer squaring  <span class="math">d = a^2</span>  and then the Montgomery reduction</p>

    <div class="my-4 text-center"><span class="math-block">c = \\frac {d + N \\left(d N ^ {\\prime} \\bmod R\\right)}{R}, \\tag {3}</span></div>

    <p class="text-gray-300">where  <span class="math">N&#x27; = -N^{-1} \\pmod{R}</span>  and  <span class="math">c = a^2 R^{-1} \\pmod{N}</span> . As  <span class="math">R = 2^m</span> , the division by  <span class="math">R</span>  in Equation 3 is a simple right shift operation while mod  <span class="math">R</span>  is equivalent to taking the least significant  <span class="math">m</span>  bits of the result. Also, the numerator in Equation 3 always produces a number whose  <span class="math">m</span>  least significant bits are all zero. Therefore, shifting it to right by  <span class="math">m</span>  bits (or equivalently dividing it by  <span class="math">R</span> ) does not result in loss of accuracy in the computation.</p>

    <p class="text-gray-300">We propose Algorithm 4 to compute the square of an  <span class="math">(k + 1)</span> -bit integer  <span class="math">a</span>  which is given in C-S form, namely  <span class="math">a = a_1 + a_0</span> , and the square  <span class="math">d = a^2</span>  is also in C-S form,  <span class="math">d = d_1 + d_0</span> . Also, we assume  <span class="math">a &amp;lt; 2N</span>  to avoid the final subtraction in Montgomery reduction [35]. Therefore, the input of square operation is a  <span class="math">(k + 1)</span> -bit integer,  <span class="math">a = a_1 + a_0 &amp;lt; 2^{k + 1}</span> , where  <span class="math">a_1, a_0 &amp;lt; 2^{k + 1}</span> . For the</p>

    <p class="text-gray-300">Algorithm 4 Squaring Algorithm for Integers in C-S form 0: <span class="math">a=(\\{a_{k,0},a_{k,1}\\},\\ldots,\\{a_{0,0},a_{0,1}\\}),\\ a&lt;2^{k+1}</span> 0: <span class="math">d=a^{2}=(\\{d_{2k+1,0},d_{2k+1,1}\\},\\ldots,\\{d_{0,0},d_{0,1}\\}),\\ d&lt;2^{2k+2}</span> 1: for <span class="math">i</span> from 0 to <span class="math">(2k+1)</span> do <span class="math">t_{i}\\leftarrow\\{\\emptyset\\}</span> end for 2: for <span class="math">i</span> from 0 to <span class="math">k</span> do <span class="math">\\triangleright a_{1}^{2}+a_{0}^{2}</span> 3: <span class="math">t_{2i}\\leftarrow t_{2i}\\cup a_{i,0}\\cup a_{i,1}</span> 4: for <span class="math">j</span> from <span class="math">(i+1)</span> to <span class="math">k</span> do 5: <span class="math">t_{i+j+1}\\leftarrow t_{i+j+1}\\cup(a_{i,0}\\wedge a_{j,0})\\cup(a_{i,1}\\wedge a_{j,1})</span> 6: end for 7: end for 8: for <span class="math">i</span> from 0 to <span class="math">k</span> do <span class="math">\\triangleright 2a_{1}a_{0}</span> 9: for <span class="math">j</span> from 0 to <span class="math">k</span> do 10: <span class="math">t_{i+j+1}\\leftarrow t_{i+j+1}\\cup(a_{i,0}\\wedge a_{j,1})</span> 11: end for 12: end for 13: <span class="math">d\\leftarrow\\text{ADDERTREE}(t)</span></p>

    <p class="text-gray-300">reasons explained in Section 4.1.2, <span class="math">m=k+3</span> where <span class="math">k=\\lceil\\log_{2}N\\rceil</span> and <span class="math">R=2^{m}</span>. Algorithm 4, basically, computes</p>

    <p class="text-gray-300"><span class="math">a^{2}=(a_{1}+a_{0})^{2}=a_{1}^{2}+a_{0}^{2}+2a_{1}a_{0},</span> (4)</p>

    <p class="text-gray-300">where <span class="math">a_{1}=a_{k,1},\\ldots,a_{1,1},a_{0,1}</span> and <span class="math">a_{0}=a_{k,0},\\ldots,a_{1,0},a_{0,0}</span> are carry and save parts, respectively. Steps 2-7 of Algorithm 4 compute the partial product list for <span class="math">a_{1}^{2}+a_{0}^{2}</span> and are almost identical to Algorithm 2 except that the computations for <span class="math">a_{1}^{2}</span> and <span class="math">a_{0}^{2}</span> are performed together. On the other hand, Steps 8-12 compute the partial product list for <span class="math">2a_{1}a_{0}</span> and are almost identical to Algorithm 1 except that <span class="math">t_{i+j}</span> in Step 4 of Algorithm 1 is replaced by <span class="math">t_{i+j+1}</span> in Step 10 of Algorithm 4. This is due to the fact that the multiplication of <span class="math">a_{1}a_{0}</span> by 2 necessitates a right shift operation by one bit. The partial product list is computed using <span class="math">(k+1)(2k+3)</span> logical-AND gates and has depth of <span class="math">4\\lfloor(k+1)/2\\rfloor+2</span>. Finally, the last step of the algorithm reduces the resulting partial product list to the C-S form using the Dadda’s method. The Dadda tree uses <span class="math">(k+6)</span> HAs and <span class="math">(2k^{2}+k-2)</span> FAs.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Example 7.</h6>

    <p class="text-gray-300">For <span class="math">k=2048</span>, Algorithm 4 results in a partial product list <span class="math">t</span> of depth 4098 before the last step using 8,398,851 logical-AND gates where it takes 20 layers of FAs for its reduction to depth 2. And the Dadda tree in the last step utilizes 8,390,654 FAs and 2,054 HAs. Finally the total delay of the squaring circuit is <span class="math">20\\tau_{\\text{FA}}+\\tau_{\\text{AND}}</span>, where <span class="math">\\tau_{\\text{FA}}</span> and <span class="math">\\tau_{\\text{AND}}</span> are the delays of a FA and an AND gate, respectively.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">4.1.2 Montgomery Reduction for Integers in C-S Form</h4>

    <p class="text-gray-300">Here, we present a new variant of the Montgomery reduction method in Algorithm 5 for integers in C-S form. The algorithm takes a <span class="math">(2k+2)</span>-bit integer <span class="math">d</span> in the C-S form and outputs a <span class="math">(k+1)</span>-bit integer <span class="math">c</span> again in C-S form, where <span class="math">c=dR^{-1}\\pmod{N}</span>, <span class="math">c&lt;2N</span>, <span class="math">R=2^{m}</span> and <span class="math">m=k+3</span>. In Algorithm 5, <span class="math">N</span> and <span class="math">N^{\\prime}=-N^{-1}\\pmod{R}</span> are in non-redundant form, i.e. <span class="math">\\textsc{DEPTH}(N)=\\textsc{DEPTH}(N^{\\prime})=1</span>.</p>

    <p class="text-gray-300">Algorithm 5 computes Equation 3 in several stages. In Stage I (Steps 2-6), the algorithm computes the lower half (the least significant <span class="math">m</span> bits) of <span class="math">dN^{\\prime}</span>, where <span class="math">d</span> is in C-S form while <span class="math">\\textsc{DEPTH}(N^{\\prime})=1</span>. The partial product list <span class="math">\\mu</span> is computed using <span class="math">m(m+1)</span> logical-AND gates and has depth of <span class="math">2m</span>. The result <span class="math">\\mu</span> is reduced to the C-S form in Step 7.</p>

    <p class="text-gray-300">Algorithm 5 Montgomery Reduction Algorithm for Integers in C-S form 0: <span class="math">d=(\\{d_{2k+1,0},d_{2k+1,1}\\},\\ldots,\\{d_{0,0},d_{0,1}\\}),\\ d&lt;2^{2k+2}</span> 0: <span class="math">c=d\\cdot 2^{-m}\\pmod{N}</span>, where <span class="math">c=(\\{c_{k,0},c_{k,1}\\},\\ldots,\\{c_{0,0},c_{0,1}\\}),\\ c&lt;2^{k+1}</span> 1: for <span class="math">i</span> from 0 to <span class="math">(m-1)</span> do <span class="math">\\mu_{i}\\leftarrow\\{\\emptyset\\}</span> end for 2: for <span class="math">i</span> from 0 to <span class="math">(m-1)</span> do <span class="math">\\triangleright</span> I: <span class="math">\\mu=dN^{\\prime}\\bmod R</span> 3: for <span class="math">j</span> from 0 to <span class="math">(m-1-i)</span> do 4: <span class="math">\\mu_{i+j}\\leftarrow\\mu_{i+j}\\cup\\{N^{\\prime}_{i}\\wedge d_{j,0}\\}\\cup\\{N^{\\prime}_{j}\\wedge d_{j,1}\\}</span> 5: end for 6: end for 7: <span class="math">\\mu\\leftarrow\\text{ADDERTREE}(\\mu)</span> 8: <span class="math">\\mu_{m-1,0}\\leftarrow\\mu_{m-1,0}\\wedge(\\sim\\mu_{m-1,1})</span> <span class="math">\\triangleright</span> II: Trimming 9: <span class="math">\\mu_{m-1,1}\\leftarrow\\mu_{m-1,1}\\wedge(\\sim\\mu_{m-1,0})</span> 10: <span class="math">t\\leftarrow d</span> 11: for <span class="math">i</span> from 0 to <span class="math">(k-1)</span> do <span class="math">\\triangleright</span> III: <span class="math">t=d+N(dN^{\\prime}\\bmod R)</span> 12: for <span class="math">j</span> from 0 to <span class="math">(m-1)</span> do 13: <span class="math">t_{i+j}\\leftarrow t_{i+j}\\cup\\{N_{i}\\wedge\\mu_{j,0}\\}\\cup\\{N_{i}\\wedge\\mu_{j,1}\\}</span> 14: end for 15: end for 16: <span class="math">t\\leftarrow\\text{ADDERTREE}(t)</span> 17: for <span class="math">i</span> from 0 to <span class="math">k</span> do <span class="math">\\triangleright</span> III: <span class="math">c=\\frac{d+N(dN^{\\prime}\\bmod R)}{R}</span> 18: <span class="math">c_{i}\\leftarrow t_{m+i}</span> 19: end for 20: <span class="math">c_{0}\\leftarrow c_{0}\\cup\\{t_{m-1,1}\\vee t_{m-1,0}\\}</span> <span class="math">\\triangleright</span> IV: Final Correction 21: <span class="math">c\\leftarrow\\text{ADDERTREE}(c)</span></p>

    <p class="text-gray-300">Normally, <span class="math">\\mu&lt;R</span> in the original Montgomery reduction algorithm; but in Algorithm 5, after Step 7, <span class="math">\\mu</span> can be larger than <span class="math">R</span> as it is in C-S form. In case <span class="math">\\mu&gt;R</span>, the final result of Algorithm 5 can be much larger than <span class="math">N</span>. Comparison and subtraction operations would necessitate conversion to non-redundant representation using prohibitively expensive CPAs. Thus, we employ a trimming stage in Stage II (Steps 8-9), which resets the most significant bits of <span class="math">\\mu</span>, <span class="math">\\mu_{m-1,0}</span> and <span class="math">\\mu_{m-1,0}</span>, if they are both 1. The trimming stage does not guarantee <span class="math">\\mu&lt;R</span>, but decreases the difference <span class="math">\\mu-R</span> in case <span class="math">\\mu&gt;R</span> still holds. As we explain in the subsequent parts of this section, trimming ensures that <span class="math">c&lt;2^{k+1}</span> provided that <span class="math">a&lt;2^{k+1}</span>, where <span class="math">c=a^{2}R^{-1}\\pmod{N}</span>. In Stage III (Steps 11-16), the algorithm multiplies <span class="math">\\mu N</span> and appends the partial product list of the result to <span class="math">d</span> in order to compute <span class="math">d+N(dN^{\\prime}\\bmod R)</span>. The resulting partial product list <span class="math">t</span> is computed using <span class="math">2km</span> logical-AND gates and has depth of <span class="math">2k+2</span>. The result <span class="math">t</span> is reduced to the C-S form in Step 16 using Dadda tree.</p>

    <p class="text-gray-300">After Step 16, the lower half (the least significant <span class="math">m</span> bits) of <span class="math">t</span> is always zero and the result <span class="math">c</span> is the upper half of <span class="math">t</span>, which could be copied to <span class="math">c</span> directly if it were in the non-redundant form. However, since <span class="math">t</span> is in C-S form, there may be carry out from the addition of carry and save parts of the lower half of <span class="math">t</span>. The carry is only possible if either of the most significant bits of <span class="math">t</span> is 1, i.e., either <span class="math">t_{m-1,1}=1</span> or <span class="math">t_{m-1,0}=1</span>. Thus, in Stage IV (Steps 20-21), <span class="math">1</span> is appended to the set <span class="math">c_{0}</span>, which calls for another adder tree as <span class="math">\\textsc{DEPTH}(c)=3</span> after Step 20. However, this can be performed in one layer whose delay is only <span class="math">\\tau_{\\text{HA}}</span> (i.e., <span class="math">O(1)</span>).</p>

    <p class="text-gray-300">Now, we prove that Algorithm 5, using Equation 3, computes the correct result <span class="math">c=dR^{-1}\\pmod{N}</span> and <span class="math">c&lt;2^{k+1}</span> given <span class="math">a&lt;2^{k+1}</span>, where <span class="math">d=a^{2}</span>. Recall also that <span class="math">m=k+3</span>, <span class="math">k=\\lceil\\log_{2}N\\rceil</span>, and <span class="math">R=2^{m}</span>. After Step 7 of Algorithm 5, <span class="math">\\mu=dN^{\\prime}\\pmod{R}</span>. As <span class="math">\\mu</span> is in C-S form, its value can be computed as <span class="math">\\mu_{0}+\\mu_{1}</span>. Then, we can only guarantee <span class="math">\\mu&lt;(2^{k+3}+2^{k+3}=2^{k+4})</span> and therefore</p>

    <p class="text-gray-300">it can be the case <span class="math">\\mu &amp;gt; R</span>. Consequently, Equation 3 can result in a value <span class="math">c</span> greater than <span class="math">2^{k+1}</span>, given <span class="math">a &amp;lt; 2^{k+1}</span> or equivalently <span class="math">d &amp;lt; 2^{2k+2}</span>. Therefore, we need to trim <span class="math">\\mu</span> to have <span class="math">c &amp;lt; 2^{k+1}</span>, which is implemented in Steps 8-9 of Algorithm 5. If the trim operation is applied, then we have <span class="math">\\mu &amp;lt; (2^{k+3} + 2^{k+2})</span>. Therefore, we can show</p>

    <div class="my-4 text-center"><span class="math-block">c &amp;lt; \\frac{2^{2k+2} + 2^k (2^{k+3} + 2^{k+2})}{2^{k+3}} = 2^{k-1} + 2^k + 2^{k-1} = 2^{k+1}.</span></div>

    <p class="text-gray-300">In other words, when <span class="math">a &amp;lt; 2^{k+1}</span>, Algorithms 4 and 5 produce the result <span class="math">c &amp;lt; 2^{k+1}</span>.</p>

    <p class="text-gray-300">Example 8. Table 1 lists the delay and the area costs of Algorithm 4 and each stage of Algorithm 5 for <span class="math">k = 2048</span>.</p>

    <p class="text-gray-300">TABLE 1 Costs of Montgomery Modular Squaring Algorithm with C-S Form (Algorithms 4 + Algorithm 5) for <span class="math">k = 2048</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Delay</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Logical gates</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Alg. 4</td>

            <td class="px-3 py-2 border-b border-gray-700">20τ_{FA} + τ_{AND}</td>

            <td class="px-3 py-2 border-b border-gray-700">8,398,851 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">2,054</td>

            <td class="px-3 py-2 border-b border-gray-700">8,390,654</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Alg. 5 - I</td>

            <td class="px-3 py-2 border-b border-gray-700">20τ_{FA} + τ_{AND}</td>

            <td class="px-3 py-2 border-b border-gray-700">4,208,652 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">2,050</td>

            <td class="px-3 py-2 border-b border-gray-700">4,200,451</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Alg. 5 - II</td>

            <td class="px-3 py-2 border-b border-gray-700">τ_{AND} + τ_{NOT}</td>

            <td class="px-3 py-2 border-b border-gray-700">2 AND + 2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Alg. 5 - III</td>

            <td class="px-3 py-2 border-b border-gray-700">20τ_{FA} + τ_{AND}</td>

            <td class="px-3 py-2 border-b border-gray-700">8,413,202 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">2,055</td>

            <td class="px-3 py-2 border-b border-gray-700">8,413,193</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Alg. 5 - IV</td>

            <td class="px-3 py-2 border-b border-gray-700">τ_{HA} + τ_{OR}</td>

            <td class="px-3 py-2 border-b border-gray-700">1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">2,049</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">60τ_{FA} + τ_{HA} + τ_{NOT} + τ_{OR} + 4τ_{AND}</td>

            <td class="px-3 py-2 border-b border-gray-700">21,020,707 AND + 2 NOT + 1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">8,208</td>

            <td class="px-3 py-2 border-b border-gray-700">21,004,298</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that Algorithm 5 does not require the final subtraction operation as in [35], which proposes to use <span class="math">R = 2^{k + 2}</span> for a <span class="math">k</span>-bit modulus <span class="math">N</span> to eliminate the final subtraction. Here, we need to add one more bit to all operands and work with <span class="math">R = 2^{k + 3}</span>. This is especially important as the subtraction operation is prohibitively expensive in C-S form.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4.2 Memory-Based Modular Squaring with Variable Modulus</h2>

    <p class="text-gray-300">In memory-based modular squaring operation, no sophisticated reduction algorithms such as Montgomery's method [17] are needed. Instead, we can use lookup table approach for reducing the upper part of the output bits of the integer squaring (see Algorithm 4 for <span class="math">a &amp;lt; 2^k</span> and <span class="math">d &amp;lt; 2^{2k}</span>), namely <span class="math">\\{d_{2k-1,0}, d_{2k-1,1}\\}, \\ldots, \\{d_{k,0}, d_{k,1}\\}</span>. In particular, we can precompute and store the integers <span class="math">(2^i \\bmod N)</span> for <span class="math">k \\leq i &amp;lt; 2k</span> in a lookup table, <span class="math">T</span>. Then, after the integer squaring operation, each lookup table cell goes to input of an AND gate with corresponding <span class="math">d_{i,0}</span> (as well as <span class="math">d_{i,1}</span>) for <span class="math">k \\leq i &amp;lt; 2k</span> and appended to the lower part of <span class="math">d</span>.</p>

    <p class="text-gray-300">There is, however, one small concern about the bit-size of the final result <span class="math">c = d</span> (mod <span class="math">N</span>) after the adder tree is applied as <span class="math">c</span> now requires more than <span class="math">k</span> bits. The final result <span class="math">c</span> still needs to be reduced to <span class="math">k</span> bits. However, this will require another reduction operation. Therefore, to capture all bits of the final result, we need a final result with <span class="math">(k + \\ell)</span>-bits, where <span class="math">\\ell</span> is the number of extra bits necessary for avoiding extra reduction operations. To this end, we again employ incomplete arithmetic, where input and output of our modular squaring algorithm are <span class="math">(k + \\ell)</span>-bit integers.</p>

    <p class="text-gray-300">The algorithm for integer squaring operation, which are identical to Algorithm 4 except for the input being now <span class="math">(k + \\ell)</span>-bit long, outputs a <span class="math">(2k + 2\\ell)</span>-bit integer, <span class="math">d</span>. The uppermost <span class="math">(k + 2\\ell)</span>-bits of <span class="math">d_0</span> and <span class="math">d_1</span> are now reduced modulo <span class="math">N</span> with the help of the lookup table <span class="math">T</span> and appended to the lower part</p>

    <p class="text-gray-300">Algorithm 6 Lookup Table Generation Algorithm for <span class="math">k \\geq 16</span> Input: <span class="math">N = (N_{k - 1},\\dots ,N_0)</span>, <span class="math">\\ell = \\lceil \\log_2k\\rceil +2</span> Output: <span class="math">T_{i,j}</span> for <span class="math">i\\in [0,k + 2\\ell)</span> and <span class="math">j\\in [0,k)</span> 1: for <span class="math">i</span> from 0 to <span class="math">(k + 2\\ell -1)</span> do <span class="math">T_{i}\\gets \\{\\emptyset \\}</span> end for 2: for <span class="math">i</span> from 0 to <span class="math">(k + 2\\ell -1)</span> do 3: <span class="math">\\alpha \\leftarrow 2^{k + i}</span> (mod <span class="math">N</span>) 4: for <span class="math">j</span> from 0 to <span class="math">(k - 1)</span> do 5: <span class="math">T_{i,j}\\gets T_{i,j}\\cup \\alpha_j</span> 6: end for 7: end for</p>

    <p class="text-gray-300">Algorithm 7 Memory-Based Modular Reduction Algorithm Input: <span class="math">d = (\\{d_{2(k + \\ell) - 1,0},d_{2(k + \\ell) - 1,1}\\} ,\\ldots ,\\{d_{0,0},d_{0,1}\\})</span> T: Lookup table Output: <span class="math">c\\equiv d</span> (mod N), where <span class="math">c = (\\{c_{k + \\ell -1,0},c_{k + \\ell -1,1}\\} ,\\ldots ,\\{c_{0,0},c_{0,1}\\})</span> 1: for i from 0 to (k-1) do ti←di end for 2: for i from k to (k+ℓ-1) do ti←{∅} end for 3: for j from k to (2k+2ℓ-1) do 4: for i from 0 to (k-1) do 5: ti←ti∪(Tj-k,i∧dj,0) 6: ti←ti∪(Tj-k,i∧dj,1) 7: end for 8: end for 9: c←ADDERTREE(t)</p>

    <p class="text-gray-300">of <span class="math">d</span>. This generates a partial product list of depth <span class="math">2(k + 2\\ell) + 2</span> requiring <span class="math">\\lceil \\log_2(2k + 4\\ell + 2) \\rceil</span> extra bits for adder tree which should be less than or equal to <span class="math">\\ell</span>. By <span class="math">\\lceil \\log_2(2k + 4\\ell + 2) \\rceil \\leq \\ell</span>, the number of extra bits, <span class="math">\\ell</span>, is formulated as shown in Equation 5.</p>

    <div class="my-4 text-center"><span class="math-block">\\ell = \\left\\{ \\begin{array}{l l} \\lceil \\log_ {2} k \\rceil + 4 &amp;amp; \\text{if } k \\leq 2 \\\\ \\lceil \\log_ {2} k \\rceil + 3 &amp;amp; \\text{if } 2 &amp;lt; k &amp;lt; 16 \\\\ \\lceil \\log_ {2} k \\rceil + 2 &amp;amp; \\text{if } k \\geq 16 \\end{array} \\right. \\tag{5}</span></div>

    <p class="text-gray-300">Since the uppermost <span class="math">(k + 2\\ell)</span> bits of <span class="math">d</span> are reduced, the lookup table <span class="math">T</span> has <span class="math">(k + 2\\ell)</span> entries where each entry is <span class="math">k</span>-bit long as shown in Algorithm 6. This explains the upper limit of the iteration in Step 2 of Algorithm 6. Also, the memory cells are appended to the partial product list via <span class="math">2k(k + 2\\ell)</span> logical-AND gates. After the reduction operation, the adder tree reduces <span class="math">d</span> to its C-S form. All operations for modular reduction are given in Algorithm 7.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4.3 Direct Modular Squaring with Fixed Modulus</h2>

    <p class="text-gray-300">In some VDF settings, the modulus <span class="math">N</span> is generated once and used thereafter. In this scenario, that <span class="math">N</span> is fixed enables significant optimizations in the circuit complexity and time delay. Direct modular squaring method uses the same approach as the memory-based modular squaring method except for the modular reduction operation. Since the modulus is fixed, then only the nonzero bits of integers <span class="math">(2^i \\mod N)</span> for <span class="math">k \\leq i &amp;lt; (2k + 2\\ell)</span> are hardwired in the modular reduction circuit. This means we need no memory cells and only half of the AND gates (i.e., <span class="math">k(k + 2\\ell))</span>, on average. This also simplifies the final addition operation in Step 9 of Algorithm 7 by reducing the depth of the partial product list <span class="math">t</span> from <span class="math">2(k + 2\\ell) + 2</span> to <span class="math">k + 2\\ell + 2</span>.</p>

    <p class="text-gray-300">Example 9. Table 2 lists the delay and the area cost of Algorithm 4 and Algorithm 7 with <span class="math">k = 2048</span> and <span class="math">\\ell = 13</span> for the cases when the modulus is variable or fixed.</p>

    <p class="text-gray-300">TABLE 2 Costs of Memory-Based and Direct Modular Squaring Algorithms with C-S Form (Algorithm 4 + Algorithm 7) for <span class="math">k = 2048</span> and <span class="math">\\ell = 13</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory-Based</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Direct</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FA / HA</td>

            <td class="px-3 py-2 border-b border-gray-700">16,984,339 / 2,144</td>

            <td class="px-3 py-2 border-b border-gray-700">12,736,789 / 2,132</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AND</td>

            <td class="px-3 py-2 border-b border-gray-700">16,992,607</td>

            <td class="px-3 py-2 border-b border-gray-700">12,745,055</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">4,247,552</td>

            <td class="px-3 py-2 border-b border-gray-700">–</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">40τ_{FA} + 2τ_{AND}</td>

            <td class="px-3 py-2 border-b border-gray-700">38τ_{FA} + 2τ_{AND}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we present a novel polynomial representation for integers, referred as Redundant-Polynomial form, which is a variant of redundant representation introduced here and similar to the one in [26]. We also present its utilization in the three modular squaring methods presented in Section 4.</p>

    <p class="text-gray-300">The polynomial representation enables low-latency circuit implementations of modular multiplication and squaring, targeting applications with variable and fixed moduli. Whereas an FPGA-optimized version is presented in [26], where the implementation is optimized to utilize FPGA-specific full-custom built-in blocks such as DSPs and Block RAMs effectively, the polynomial representation can be profitably employed for implementations on different target devices. In this paper, we utilize a novel variant of modular squaring algorithm that is tailored to be more suitable for ASIC implementations. Besides using R-P form for input and output, we take advantage of the inherent simplicity of a squaring operation and the fact that it is used repeatedly for the exponentiation <span class="math">a^{2^r}</span> (mod <span class="math">N</span>) in the VDF computation.</p>

    <p class="text-gray-300">Each <span class="math">k</span>-bit integer <span class="math">a</span> can also be considered as an <span class="math">s</span>-digit integer with <span class="math">r</span>-bit digits <span class="math">A_i</span>, where <span class="math">s = \\lceil k / r \\rceil</span> and <span class="math">A = \\sum_{i=0}^{s-1} A_i \\cdot 2^r</span>. Similarly, the integer <span class="math">A</span> can also be represented as a polynomial <span class="math">A(x) = \\sum_{i=0}^{s-1} A_i \\cdot x^i</span>, where the radix <span class="math">x = 2^r</span> and <span class="math">A_i &amp;lt; 2^r</span>.</p>

    <p class="text-gray-300">In the R-P form presented in [26], an integer <span class="math">A</span> is represented using a polynomial <span class="math">A(x)</span> of degree <span class="math">(s - 1)</span> with <span class="math">(r + 1)</span>-bit coefficients <span class="math">\\mathbf{A}_i</span> as shown in Equation 6.</p>

    <div class="my-4 text-center"><span class="math-block">A (x) = \\sum_ {i = 0} ^ {s - 1} \\mathbf {A} _ {i} \\cdot x ^ {i} = \\sum_ {i = 0} ^ {s - 1} A _ {i} \\cdot x ^ {i} + \\sum_ {i = 0} ^ {s - 1} e _ {i} \\cdot x ^ {i + 1} \\tag {6}</span></div>

    <p class="text-gray-300">Here, <span class="math">\\mathbf{A}_i = (A_i + x e_i) &amp;lt; 2^{r+1}</span> and where <span class="math">e_i \\in [0,1]</span>.</p>

    <p class="text-gray-300">Equation 6 is indeed a redundant form for integers similar to C-S form, where only certain bits are represented by two bits. More specifically in polynomial form for a <span class="math">k</span>-bit integer <span class="math">a</span>, we have <span class="math">A_{i} = (\\{a_{(i + 1)r - 1,0},0\\} ,\\ldots ,\\{a_{ir + 1,0},0\\} ,\\{a_{ir,0},a_{ir,1}\\})</span> for <span class="math">(s - 1)\\geq i\\geq 1</span> and <span class="math">A_0 = (\\{a_{r - 1,0},0\\} ,\\dots ,\\{a_{1,0},0\\} ,\\{a_{0,0},0\\})</span> where <span class="math">a_{j,0} = a_{j,1} = 0</span> for <span class="math">j\\geq k</span> and <span class="math">a_{ir,1} = e_i</span> for <span class="math">i = 1,2,\\ldots ,s - 1</span>. Also, <span class="math">a = a_{1} + a_{0}</span> where <span class="math">a_1 = a_{k,1},\\ldots ,a_{1,1},a_{0,1}</span> and <span class="math">a_0 = a_{k,0},\\ldots ,a_{1,0},a_{0,0}</span>.</p>

    <p class="text-gray-300">Example 10. For <span class="math">k = 9</span> and <span class="math">r = 3</span>, C-S and R-P forms are shown in Fig. 5. The bits representing the first, second and third digits of the R-P form are shown with black, gray and blue dots, respectively. As shown in the Fig. 5, the R-P form can also be viewed as a modified version of C-S form.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5. C-S and R-P Forms for <span class="math">k = 9</span> and <span class="math">r = 3</span></p>

    <p class="text-gray-300">Input: <span class="math">a = (\\{a_{k - 1,0},a_{k - 1,1}\\} ,\\ldots ,\\{a_{0,0},\\ldots ,a_{0,1}\\})</span></p>

    <p class="text-gray-300"><span class="math">s = \\lceil k / r\\rceil</span> where <span class="math">r</span>: bit-size of a digit</p>

    <p class="text-gray-300">Output: <span class="math">b = a = (\\{b_{k - 1,0},b_{k - 1,1}\\} ,\\ldots ,\\{b_{0,0},b_{0,1}\\})</span></p>

    <p class="text-gray-300">where <span class="math">b_{i,1} = e_i</span> for <span class="math">i \\equiv 0 \\pmod{r}</span> and <span class="math">i \\neq 0</span></p>

    <p class="text-gray-300">where <span class="math">b_{i,1} = 0</span> for <span class="math">i \\neq 0 \\pmod{r}</span> and <span class="math">i = 0</span></p>

    <p class="text-gray-300">1: for <span class="math">i</span> from 0 to <span class="math">(s - 1)</span> do 2: <span class="math">C\\gets 0</span> 3: for <span class="math">j</span> from 0 to <span class="math">(r - 1)</span> do <span class="math">\\triangleright</span> <span class="math">r</span>-bit CPA <span class="math">(\\mathrm{CPA}_r)</span> 4: <span class="math">C, S \\gets \\operatorname{FA}(a_{is + j,0}, a_{is + j,1}, C)</span> 5: <span class="math">b_{is + j,0}\\gets S</span> 6: end for 7: <span class="math">b_{(i + 1)s,1}\\gets C</span> 8: end for</p>

    <p class="text-gray-300">The basic idea of the polynomial representation is to confine the carry propagation into <span class="math">r</span>-bit digits and use only <span class="math">r</span>-bit CPA <span class="math">(\\mathrm{CPA}_r)</span> circuits. During the VDF computation, therefore, the intermediate results are kept in R-P form; but at the end, the final result is converted to the non-redundant form using a <span class="math">\\mathrm{CPA}_k</span>.</p>

    <p class="text-gray-300">After applying the adder tree to partial products in our algorithms, we obtain the result in C-S form, which needs to be converted to R-P form. Algorithm 8 shows the steps of this conversion function, <span class="math">\\mathrm{CSTOPOLY}()</span>.</p>

    <p class="text-gray-300">When the new R-P form is used, all algorithms in Section 4 can easily be adapted with minor modifications as discussed in the next sections.</p>

    <p class="text-gray-300">A low-latency integer multiplication algorithm with the polynomial form is detailed in Algorithm 7 in [26], in which its FPGA-optimized version is implemented. In an FPGA architecture, there are special functional blocks such as DSP including a full-custom <span class="math">25 \\times 18</span> signed multiplier [36]. In [26], the entire integer multiplication algorithm was optimized to utilize this basic building block in FPGA for a low-latency implementation. Since the entire algorithm is based on coefficient-wise multiplications, a DSP block is utilized to realize a <span class="math">17 \\times 17</span> core multiplication operation, which provides best utilization for <span class="math">r = 16</span>.</p>

    <p class="text-gray-300">For ASIC implementation, utilizing core <span class="math">17 \\times 17</span> multipliers of non-redundant form is not always most inefficient, as these multipliers results in long carry chains in the partial product calculation stage. Therefore, carry propagation should be deferred as long as possible. To this end, we propose Algorithm 9 to compute the square of a <span class="math">(k + 1)</span>-bit integer <span class="math">a</span> given in R-P form, where <span class="math">a = a_1 + a_0 &amp;lt; 2^{k + 1}</span> and <span class="math">a_1, a_0 &amp;lt; 2^{k + 1}</span>. The result <span class="math">d</span> is also in R-P form, where <span class="math">d = d_1 + d_0 &amp;lt; 2^{2k + 2}</span>. Note that Algorithm 9 basically computes Equation 4.</p>

    <p class="text-gray-300">Example 11. For <span class="math">k = 2048</span> and <span class="math">r = 8</span>, Algorithm 9 results in a partial product list <span class="math">t</span> of depth 1,407 before the last two steps using 2,657,665 logical-AND gates, where it takes 17 layers of FAs for its reduction to depth 2. And the operations in the last two steps employ 2,649,472 FAs, 2,135 HAs and 513 CPA₈₅. Finally, the total delay of the squaring circuit is <span class="math">17\\tau_{\\mathrm{FA}} + \\tau_{\\mathrm{AND}} + \\tau_{\\mathrm{CPA}_8}</span>.</p>

    <p class="text-gray-300">Note that all partial product bits are calculated using logical-AND gates in parallel and the resulting bits are grouped</p>

    <p class="text-gray-300">Algorithm 9 Squaring Algorithm for Integers in R-P Form Input:  <span class="math">a = (\\{a_{k,0},a_{k,1}\\} ,\\dots ,\\{a_{0,0},a_{0,1}\\})</span> Output:  <span class="math">d = a^{2} = (\\{d_{2k + 1,0},d_{2k + 1,1}\\} ,\\dots ,\\{d_{0,0},d_{0,1}\\})</span> 1: for i from 0 to  <span class="math">(2k + 1)</span>  do  <span class="math">t_i\\gets \\{\\emptyset \\}</span>  end for 2: for i from r to  <span class="math">(k - 1)</span>  by r do  <span class="math">\\triangleright a_1^2</span> 3:  <span class="math">t_{2i}\\gets t_{2i}\\cup a_{i,0}</span> 4: for j from  <span class="math">(i + r)</span>  to  <span class="math">(k - 1)</span>  by r do 5:  <span class="math">t_{i + j + 1}\\gets t_{i + j + 1}\\cup (a_{i,0}\\wedge a_{j,0})</span> 6: end for 7: end for 8: for i from 0 to k do  <span class="math">\\triangleright a_0^2</span> 9:  <span class="math">t_{2i}\\gets t_{2i}\\cup a_{i,1}</span> 10: for j from  <span class="math">(i + 1)</span>  to k do 11:  <span class="math">t_{i + j + 1}\\gets t_{i + j + 1}\\cup (a_{i,1}\\wedge a_{j,1})</span> 12: end for 13: end for 14: for i from 0 to k do  <span class="math">\\triangleright 2a_1a_0</span> 15: for j from r to  <span class="math">(k - 1)</span>  by r do 16:  <span class="math">t_{i + j + 1}\\gets t_{i + j + 1}\\cup (a_{i,0}\\wedge a_{j,1})</span> 17: end for 18: end for 19:  <span class="math">t\\gets</span>  ADDERTREE(t) 20:  <span class="math">d\\gets</span>  CSTOPOLY(t)</p>

    <p class="text-gray-300">together in the partial product list  <span class="math">t</span>  as shown in Steps 1-18 of Algorithm 9. This is a totally different approach from the one in Algorithm 7 in [26], which is based on digit-wise multiplications.</p>

    <p class="text-gray-300">As shown in Steps 2-13 of Algorithm 9, the partial product bits generated by squaring of  <span class="math">a_1</span>  and  <span class="math">a_0</span>  are calculated using  <span class="math">s(s - 1)/2</span>  and  <span class="math">(k + 1)(k + 2)/2</span>  logical-AND gates, respectively. The partial product bits generated by the multiplication  <span class="math">2a_0a_1</span> , (see Steps 14-18 of Algorithm 9), need  <span class="math">(s - 1)(k + 1)</span>  logical-AND gates. The partial product list  <span class="math">t</span>  has depth of  <span class="math">s + \\lfloor (k + 1)/2 \\rfloor + \\lfloor (s - 1)/2 \\rfloor + 1</span>  at most.</p>

    <p class="text-gray-300">After the generation of the partial product list  <span class="math">t</span> , the algorithm reduces the resulting list to the regular C-S form using Dadda tree (Step 19 of Algorithm 9). The output of the adder tree represents a  <span class="math">(2k + 2)</span> -bit integer in C-S form with  <span class="math">(2k + 2)</span> -bit carry and save parts,  <span class="math">d_{1}</span>  and  <span class="math">d_{0}</span> , respectively, where  <span class="math">d_{1}, d_{0} &amp;lt; 2^{2k + 2}</span> . Therefore, the resulting integer is transformed to R-P form using CSTOPOLY function, which uses  <span class="math">\\lceil (2k + 2) / r \\rceil \\mathrm{CPA}_r</span> 's.</p>

    <p class="text-gray-300">Example 12. Fig. 6 depicts an example implementation of Algorithm 9 for  <span class="math">k = 4</span>  and  <span class="math">r = 2</span> .</p>

    <p class="text-gray-300">In this section, we investigate the utilization of the R-P form in the three modular reduction methods already presented in Section 4: Montgomery modular reduction with variable modulus, memory-based modular reduction with variable modulus and direct modular reduction with fixed modulus.</p>

    <p class="text-gray-300">For the R-P form, we utilize the Montgomery reduction algorithm (see Algorithm 5) presented in Section 4 and propose three alternative variations in the actual implementation. In the R-P form, similar to the C-S form, the Montgomery reduction algorithm takes  <span class="math">(2k + 2)</span> -bit integer  <span class="math">d</span>  as input and outputs a  <span class="math">(k + 1)</span> -bit integer  <span class="math">c</span>  where  <span class="math">R = 2^m</span>  and  <span class="math">m = k + 3</span> .</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6. Example implementation of Algorithm 9 for  <span class="math">k = 4</span>  and  <span class="math">r = 2</span></p>

    <p class="text-gray-300">Modular squaring operation with redundant representation requires only its input and output to be in the identical redundant form. Integers in the intermediate steps of modular squaring can have different forms as long as the operation generates the output in the same form as the input. For the integers in R-P form, CSTOPOLY operation is applied after ADDERTREE to convert the integer in C-S form to R-P form. Therefore, CSTOPOLY applied in the intermediate steps of modular squaring operation can be omitted as long as it is applied to the final modular squaring result,  <span class="math">c</span> .</p>

    <p class="text-gray-300">In modular squaring with Montgomery reduction for integers in R-P form, CSTOPOLY can be applied at three different points. The first one is after squaring operation (see Step 20 of Algorithm 9). The second CSTOPOLY can be applied after  <span class="math">\\mu</span>  is calculated as shown in Step 7 of Algorithm 5. The third conversion is applied after the output  <span class="math">c</span>  is calculated, which is performed in all cases. The first and second CSTOPOLY operations can be skipped as explained next.</p>

    <p class="text-gray-300">We investigate three different Montgomery reduction methods. In the first method (Method 1), CSTOPOLY operations after squaring and the calculation of  <span class="math">\\mu</span>  are skipped. CSTOPOLY is only applied after the Step 21 of Algorithm 5. In the second method (Method 2), CSTOPOLY is performed after squaring and skipped after the calculation of  <span class="math">\\mu</span> . Since  <span class="math">d</span>  is in the R-P form after the squaring, the partial product list  <span class="math">\\mu</span>  in Stage I of Algorithm 5 is computed using  <span class="math">m(m + 1) / 2 + mz - rz(z + 1) / 2</span>  logical-AND gates and has depth of  <span class="math">m + z</span>  where  <span class="math">z = \\lfloor (m - 1) / r \\rfloor</span> . In the third method (Method 3), all CSTOPOLY operations are performed. The integer  <span class="math">\\mu</span>  in C-S form is converted to R-P form using  <span class="math">\\lceil m / r \\rceil</span>  CPA <span class="math">_r</span> s after the Step 7 of Algorithm 5. Since  <span class="math">\\mu</span>  is in R-P form, the partial product list  <span class="math">t</span>  generated in Stage III is computed using  <span class="math">k(m + z)</span>  logical-AND gates and has depth of  <span class="math">k + z + 2</span>  at most where  <span class="math">z = \\lfloor (m - 1) / r \\rfloor</span> . Finally, the final modular squaring result  <span class="math">c</span>  in C-S form is converted to R-P form using  <span class="math">\\lceil (k + 1) / r \\rceil</span>  CPA <span class="math">_r</span> s.</p>

    <p class="text-gray-300">Example 13. Table 3 lists the delay and the area costs of the three Montgomery modular squaring methods (Algorithm 9 + Algorithm 5) for  <span class="math">k = 2048</span>  and  <span class="math">r = \\{4,8\\}</span> . The third method uses fewer number of FA, HA and AND gates at the expense of extra CPAs. It also has fewer FAs on the critical path because CSTOPOLY operations reduce the bits in the carry</p>

    <p class="text-gray-300">TABLE 3 Costs of Montgomery Modular Squaring Algorithms with R-P Form (Algorithm 9 + Algorithm 5) for  <span class="math">k = 2048</span>  and  <span class="math">r = \\{4,8\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  r = 4  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15,886,092</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14,308,106</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11,151,619</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">513</td>

            <td class="px-3 py-2 border-b border-gray-700">1,538</td>

            <td class="px-3 py-2 border-b border-gray-700">2,051</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">15,902,497 AND + 2 NOT + 1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">14,848,283 AND + 2 NOT + 1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">11,691,794 AND + 2 NOT + 1 OR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">58τFA + τHA +4τAND + τOR +τNOT + τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">57τFA + τHA +4τAND + τOR +τNOT + 2τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">56τFA + τHA +4τAND + τOR +τNOT + 3τCPA4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  r = 8  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15,263,116</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13,422,474</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9,740,931</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA6</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">770</td>

            <td class="px-3 py-2 border-b border-gray-700">1,027</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">15,279,521 AND + 2 NOT + 1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">13,700,251 AND + 2 NOT + 1 OR</td>

            <td class="px-3 py-2 border-b border-gray-700">10,018,706 AND + 2 NOT + 1 OR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">57τFA + τHA +4τAND + τOR +τNOT + τCPA6</td>

            <td class="px-3 py-2 border-b border-gray-700">55τFA + τHA +4τAND + τOR +τNOT + 2τCPA6</td>

            <td class="px-3 py-2 border-b border-gray-700">53τFA + τHA +4τAND + τOR +τNOT + 3τCPA6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">part of the integer as the representation goes from C-S to R-P.</p>

    <p class="text-gray-300">As already explained Section 4.2, we can use lookup tables for reducing integers in R-P form employing Algorithm 9 followed by Algorithm 7. Since input and output of our modular squaring algorithm are  <span class="math">(k + \\ell)</span> -bit integers as explained in Section 4.2, the algorithm for integer squaring operation, which is identical to Algorithm 9 except for the input being now  <span class="math">(k + \\ell)</span> -bit long, outputs a  <span class="math">(2k + 2\\ell)</span> -bit integer,  <span class="math">d</span> , where  <span class="math">\\ell</span>  is formulated as shown in Equation 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Following the approach introduced in Section 5.2.1, we can utilize R-P form in memory-based modular squaring algorithm with two different variants. In the first method (Method 1), CSTOPOLY after squaring is skipped and it is applied after the final modular squaring result  <span class="math">c</span>  is calculated (see Step 9 of Algorithm 7). In the second method (Method 2), CSTOPOLY is performed after squaring and applied to the upper part of  <span class="math">d</span> , namely  $\\{d_{2k + 2\\ell -1,1}, d_{2k + 2\\ell -1,0}\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{k,1}, d_{k,0}\\}<span class="math"> , using  </span>\\lceil (k + 2\\ell) / r \\rceil \\mathrm{CPA}_r \\mathrm{s}<span class="math"> . Since the upper part of  </span>d<span class="math">  is in R-P form after squaring, the partial product list  </span>t<span class="math">  generated after reduction is computed using  </span>k(k + 2\\ell) + k\\lfloor (k + 2\\ell -1) / 2\\rfloor<span class="math">  logical-AND gates and it has depth of  </span>k + 2\\ell + \\lfloor (k + 2\\ell -1) / 2\\rfloor + 2<span class="math"> . Finally, the final modular squaring result  </span>c<span class="math">  in C-S form is converted to R-P form using  </span>\\lceil (k + \\ell) / r \\rceil \\mathrm{CPA}_r \\mathrm{s}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example 14. Table 4 lists the delay and the area costs of memory-based modular squaring operation (Algorithm 9 and Algorithm 7) for  <span class="math">k = 2048</span> ,  <span class="math">\\ell = 13</span>  and  <span class="math">r = \\{4,8\\}</span> .</p>

    <p class="text-gray-300">This method uses the same approach as the memory-based squaring method except for the modular reduction operation. In this method, we need no memory cells and only half of the AND gates, on average. This also simplifies the final addition operation in Step 9 of Algorithm 7. Also, we have two variants due to reasons explained in Section 5.2.2: i) the first method (Method 1) avoids CSTOPOLY operation after the integer squaring operation (Algorithm 9) and ii) the second</p>

    <p class="text-gray-300">TABLE 4 Costs of Memory-Based Modular Squaring Algorithms with R-P Form (Algorithm 9 + Algorithm 7) for  <span class="math">k = 2048</span> ,  <span class="math">\\ell = 13</span>  and  <span class="math">r = \\{4,8\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FA</td>

            <td class="px-3 py-2 border-b border-gray-700">11,806,016</td>

            <td class="px-3 py-2 border-b border-gray-700">11,174,563</td>

            <td class="px-3 py-2 border-b border-gray-700">8,619,330</td>

            <td class="px-3 py-2 border-b border-gray-700">7,457,445</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HA</td>

            <td class="px-3 py-2 border-b border-gray-700">2,421</td>

            <td class="px-3 py-2 border-b border-gray-700">2,240</td>

            <td class="px-3 py-2 border-b border-gray-700">2,413</td>

            <td class="px-3 py-2 border-b border-gray-700">2,224</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AND</td>

            <td class="px-3 py-2 border-b border-gray-700">11,814,280</td>

            <td class="px-3 py-2 border-b border-gray-700">11,182,825</td>

            <td class="px-3 py-2 border-b border-gray-700">8,627,592</td>

            <td class="px-3 py-2 border-b border-gray-700">7,465,705</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">4,247,552</td>

            <td class="px-3 py-2 border-b border-gray-700">4,247,552</td>

            <td class="px-3 py-2 border-b border-gray-700">4,247,552</td>

            <td class="px-3 py-2 border-b border-gray-700">4,247,552</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA</td>

            <td class="px-3 py-2 border-b border-gray-700">516a</td>

            <td class="px-3 py-2 border-b border-gray-700">258b</td>

            <td class="px-3 py-2 border-b border-gray-700">1,035a</td>

            <td class="px-3 py-2 border-b border-gray-700">518b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">2τAND +38τFA +τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">2τAND +37τFA +τCPA6</td>

            <td class="px-3 py-2 border-b border-gray-700">2τAND +37τFA +2τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">2τAND +35τFA +2τCPA6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">a:4</span>  -bit CPA.  <span class="math">b:8</span>  -bit CPA.</p>

    <p class="text-gray-300">method (Method 2) uses two applications of CSTOPOLY operation; one after the integer squaring and the other at the end of the modular reduction.</p>

    <p class="text-gray-300">Example 15. Table 5 lists the delay and the area cost of direct modular squaring operation with fixed modulus (Algorithm 9 and Algorithm 7) for  <span class="math">k = 2048</span> ,  <span class="math">\\ell = 13</span>  and  <span class="math">r = \\{4,8\\}</span> .</p>

    <p class="text-gray-300">TABLE 5 Costs of Direct Modular Squaring Algorithms with R-P Form (Algorithm 9 + Algorithm 7) for  <span class="math">k = 2048</span> ,  <span class="math">\\ell = 13</span>  and  <span class="math">r = \\{4,8\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">r = 8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FA</td>

            <td class="px-3 py-2 border-b border-gray-700">7,558,466</td>

            <td class="px-3 py-2 border-b border-gray-700">6,927,013</td>

            <td class="px-3 py-2 border-b border-gray-700">5,965,124</td>

            <td class="px-3 py-2 border-b border-gray-700">5,067,431</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HA</td>

            <td class="px-3 py-2 border-b border-gray-700">2,409</td>

            <td class="px-3 py-2 border-b border-gray-700">2,228</td>

            <td class="px-3 py-2 border-b border-gray-700">2,402</td>

            <td class="px-3 py-2 border-b border-gray-700">2,219</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AND</td>

            <td class="px-3 py-2 border-b border-gray-700">7,566,728</td>

            <td class="px-3 py-2 border-b border-gray-700">6,935,273</td>

            <td class="px-3 py-2 border-b border-gray-700">5,973,384</td>

            <td class="px-3 py-2 border-b border-gray-700">5,076,713</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA</td>

            <td class="px-3 py-2 border-b border-gray-700">516a</td>

            <td class="px-3 py-2 border-b border-gray-700">258b</td>

            <td class="px-3 py-2 border-b border-gray-700">1,035a</td>

            <td class="px-3 py-2 border-b border-gray-700">518b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">36τFA +2τAND +τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">35τFA +2τAND +τCPA6</td>

            <td class="px-3 py-2 border-b border-gray-700">35τFA +2τAND +2τCPA4</td>

            <td class="px-3 py-2 border-b border-gray-700">34τFA +2τAND +2τCPA6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">a:4</span>  -bit CPA.  <span class="math">b:8</span>  -bit CPA.</p>

    <p class="text-gray-300">In this section, we provide the results and comparison of the algorithms presented in this work. To provide a fair comparison, we implemented the same algorithms for integers in nonredundant form, as well. In Table 6, we present the delay and area costs of the modular squaring methods proposed for the integers in C-S and non-redundant forms for  <span class="math">k = \\{1024,4096\\}</span> . Similarly, Table 7 presents the delay and area costs of the modular squaring methods proposed for the integers in R-P form for  <span class="math">k = \\{1024,4096\\}</span>  and  <span class="math">r = \\{8,16\\}</span> . In Table 6 and Table 7, the best result for each cost category is bolded. The key points are summarized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Algorithms utilizing C-S and R-P forms avoid long carry chains. These representations show superior time performance in comparison with non-redundant representation for modular squaring operation.</li>

      <li>R-P form requires at least one layer of  <span class="math">\\mathrm{CPA}_r</span>  units for modular squaring due to the requirement that input and output be in the same form. Since the carry part of R-P form has many fewer number of bits than the save part, adder trees generated using R-P form has less depth than the adder trees in C-S form. Furthermore, the design with R-P form uses less resources at the expense of extra CPAs.</li>

      <li>Overall, R-P form has fewer number of FAs on the critical path of the design than the C-S form at the</li>

    </ul>

    <p class="text-gray-300">expense of additional CPAs. Thus, there is a trade-off between CPA and FA delays. For instance, Montgomery multiplication with C-S incurs about the delay of  <span class="math">63\\tau_{\\mathrm{FA}}</span>  (see Table 6) whereas its R-P version does the delay of  <span class="math">61\\tau_{\\mathrm{FA}} + \\tau_{\\mathrm{CPA}_0}</span>  (see Method 1 in Table 7). Our experiments with TMSC  <span class="math">65~\\mathrm{nm}</span>  technology indicate that both C-S and R-P based designs feature similar critical path delays whereas the latter consumes much less chip area (see Fig. 7). This is due to the fact that highly optimized CPA designs are available in ASIC libraries. However, it is difficult to derive a definitive conclusion as to which redundant form yields a lower latency circuit, which depends on the technology and design optimization efforts; and this can be the focus of a future study.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Memory-based modular reduction algorithms incur much lower gate count and result in significantly shorter critical path compared to the Montgomery modular reduction algorithms at the expense of chip area for large number of memory cells. As memory access can be done in parallel to the integer squaring operation, memory access latency is not on the critical path. In summary, memory based modular squaring algorithms can be strong alternatives to Montgomery-based designs subject to the overall cost of memory.</li>

      <li>The direct modular reduction methods offer the best solution in terms of area and time performance; however, they support only fixed moduli.</li>

    </ul>

    <p class="text-gray-300">In order to provide a theoretical lower bound for the area and time complexities of ASIC implementations, we synthesized every building block (AND, OR, NOT, HA, FA, CPAs) used in the proposed algorithms using the TSMC 65 nm standard cell library. The time and area costs of different methods and representations are plotted in Fig. 7 for  <span class="math">k = 2048</span>  and  <span class="math">r = 8</span> .</p>

    <p class="text-gray-300">As expected, direct modular reduction algorithms yield the best area and time performance for all representations since they take the advantage of fixed moduli. For variable moduli, memory-based modular reduction methods enjoy higher performance than the Montgomery modular reduction algorithm as far as the critical path delay is concerned. Memory-based modular reduction methods, however, require memory cells; and they are not included in the area cost. For each modular squaring method, constructions using C-S and R-P forms show similar time performance while the latter form allows lower area design. Both forms have up to  <span class="math">16\\%</span>  better time performance than the baseline using non-redundant representation. It should be again noted that these results are presented to provide a lower bound for ASIC implementations and include only standard cell area/delay information excluding routing cost and memory. Current ASIC design tools fall short of achieving the heavy requirements of these architectures.</p>

    <p class="text-gray-300">In order to demonstrate the scaling of the proposed methods, the time and area costs (where time is in linear scale and area is in logarithmic scale) of proposed methods and representations are plotted in Fig. 8 for  <span class="math">k = \\{256, 512, 1024, 2048, 4096\\}</span>  and  <span class="math">r = 8</span> . In Fig. 8, designs with the same  <span class="math">k</span>  are circled together and  <span class="math">k</span>  value is written in the middle of the circle. As  <span class="math">k</span>  is doubled, we observe linear and logarithmic increase in latency and area, respectively, for all methods and representations.</p>

    <p class="text-gray-300">We generated the Verilog codes for complete Montgomery modular squaring operation (Method 3) with R-P</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7. Area (NAND2-based) vs. Latency (ns) Graph for the ASIC Implementations of Proposed Modular Squaring Methods with Redundant and Non-Redundant Representations for  <span class="math">k = 2048</span>  and  <span class="math">r = 8</span> .</p>

    <p class="text-gray-300">and non-redundant representations for  <span class="math">k = \\{64,128,256,512\\}</span>  and  <span class="math">r = 8</span> . Then, these codes are synthesized with TSMC 65 nm standard cell library using Synopsys DC compiler with compile_ultra command and default settings. The proposed Montgomery modular squaring operation with R-P representation leads to  <span class="math">34\\%</span>  increase in area on average compared to the non-redundant representation. On the other hand, the latency of the operation is reduced up to up to  <span class="math">5.6\\%</span>  with R-P representation. Also, we observed more latency reduction as  <span class="math">k</span>  gets larger. As  <span class="math">k</span>  value is increased, synthesis time is increased significantly. Therefore, we only presented synthesis results up to  <span class="math">k = 512</span> .</p>

    <p class="text-gray-300">The adder trees, which constitute an important part of our algorithms, are much larger in comparison with those in the literature. Works on multiplier designs in the literature have never explored adders tree constructions, which are deeper than necessary for the word size of computers as they are concerned with general-purpose computing and optimization of time-area product. As our goal is to find a lower bound for the latency of modular squaring of RSA-size operands, we, for the first time in the literature, explored unconventionally large adder trees optimized for low latency.</p>

    <p class="text-gray-300">Furthermore, it may not be really practicable to construct adder trees of the aforementioned sizes using available CAD tools. Therefore, the actual realizations of the proposed designs may call for a modular approach, in which modules are used to compress only a part of the adder tree. As this requires several iterations incurring extra overhead in latency, the modular approach is likely to yield slower circuits.</p>

    <p class="text-gray-300">An interesting algorithm [37] using the Chinese remainder theorem turns the modular multiplication with large modulus into many modular multiplications with much smaller moduli, all of which can be performed in parallel. By leveraging even larger number of small primes, parallelization can be further utilized to achieve much lower latency values. However, certain aspects of the algorithm should be investigated in more detail for a possible ASIC implementation. While, it can indeed reduce the adder tree depths, one major design issue of the algorithm in [37] is its high fan-out and involved place-and-route requirements. For instance, a 2048-bit modular multiplication requires modular multiplications with 422 small moduli, whose results are inputs to subsequent 422 additions. Employing larger number of small moduli (e.g., 725 for further parallelization) will increase the fan-out requirements by the same amount. Our algorithms, on the other hand, are likely to enable low fan</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 8. Area (NAND2-based) in Logarithmic Scale vs. Latency (ns) Graph for the ASIC Implementations of Proposed Modular Squaring Methods with C-S and R-P Representations for  <span class="math">k = \\{256, 512, 1024, 2048, 4096\\}</span>  and  <span class="math">r = 8</span> .</p>

    <p class="text-gray-300">TABLE 6 Delay and Area Costs of Modular Squaring Methods with C-S and Non-Redundant Forms for  <span class="math">k = \\{ {1024},{4096}\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C-S Form</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-Redundant Form</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Montgomery</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory-Based</td>

            <td class="px-3 py-2 border-b border-gray-700">Direct</td>

            <td class="px-3 py-2 border-b border-gray-700">Montgomery</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory-Based</td>

            <td class="px-3 py-2 border-b border-gray-700">Direct</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">FA</td>

            <td class="px-3 py-2 border-b border-gray-700">5,259,274</td>

            <td class="px-3 py-2 border-b border-gray-700">4,289,766</td>

            <td class="px-3 py-2 border-b border-gray-700">3,216,616</td>

            <td class="px-3 py-2 border-b border-gray-700">2,096,130</td>

            <td class="px-3 py-2 border-b border-gray-700">1,602,057</td>

            <td class="px-3 py-2 border-b border-gray-700">1,066,507</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">HA</td>

            <td class="px-3 py-2 border-b border-gray-700">4,112</td>

            <td class="px-3 py-2 border-b border-gray-700">1,108</td>

            <td class="px-3 py-2 border-b border-gray-700">1,096</td>

            <td class="px-3 py-2 border-b border-gray-700">3,073</td>

            <td class="px-3 py-2 border-b border-gray-700">1,085</td>

            <td class="px-3 py-2 border-b border-gray-700">1,078</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">5,267,491 AND + 1 OR + 2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">4,293,932 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">3,220,780 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">2,105,352 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,607,234 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,071,682 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1,073,152</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1,071,104</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">54τFA + τHA+ 4τAND + τOR + τNOT</td>

            <td class="px-3 py-2 border-b border-gray-700">36τFA + 2τAND</td>

            <td class="px-3 py-2 border-b border-gray-700">34τFA + 2τAND</td>

            <td class="px-3 py-2 border-b border-gray-700">47τFA + 3τAND + τCPA1026 + 2τCPA2051</td>

            <td class="px-3 py-2 border-b border-gray-700">31τFA + 2τAND + τCPA1035 + τCPA2070</td>

            <td class="px-3 py-2 border-b border-gray-700">30τFA + 2τAND + τCPA1035 + τCPA2070</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">FA</td>

            <td class="px-3 py-2 border-b border-gray-700">83,951,626</td>

            <td class="px-3 py-2 border-b border-gray-700">67,555,652</td>

            <td class="px-3 py-2 border-b border-gray-700">50,663,750</td>

            <td class="px-3 py-2 border-b border-gray-700">33,550,338</td>

            <td class="px-3 py-2 border-b border-gray-700">25,307,158</td>

            <td class="px-3 py-2 border-b border-gray-700">16,865,304</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">HA</td>

            <td class="px-3 py-2 border-b border-gray-700">16,400</td>

            <td class="px-3 py-2 border-b border-gray-700">4,202</td>

            <td class="px-3 py-2 border-b border-gray-700">4,192</td>

            <td class="px-3 py-2 border-b border-gray-700">12,289</td>

            <td class="px-3 py-2 border-b border-gray-700">4,185</td>

            <td class="px-3 py-2 border-b border-gray-700">4,173</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">83,984,419 AND + 1 OR + 2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">67,572,118 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">50,680,214 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">33,587,208 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">25,327,707 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">16,885,851 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16,891,904</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16,883,712</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">63τFA + τHA+ 4τAND + τOR + τNOT</td>

            <td class="px-3 py-2 border-b border-gray-700">42τFA + 2τAND</td>

            <td class="px-3 py-2 border-b border-gray-700">42τFA + 2τAND</td>

            <td class="px-3 py-2 border-b border-gray-700">58τFA + 3τAND + τCPA4098 + 2τCPA8195</td>

            <td class="px-3 py-2 border-b border-gray-700">38τFA + 2τAND + τCPA4109 + τCPA8218</td>

            <td class="px-3 py-2 border-b border-gray-700">36τFA + 2τAND + τCPA4109 + τCPA8218</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">out designs (especially in the adder tree) and relatively simple place-and-routing. As there is no hardware implementation of the algorithm [37] in the literature, it is not possible to provide its fair comparison with our algorithms. Nevertheless, it would be highly valuable from research point of view to explore its various hardware implementations, which is an interesting future research subject.</p>

    <p class="text-gray-300">In this work, we provided an in-depth study for utilization of redundant representations of integers to accelerate modular squaring operation, which is the core operation in VDF evaluation applications. Our analysis and the results indicate that redundant representations potentially yield a significant reduction in the critical path delay of the modular squaring hardware. In particular, we introduced three different modular reduction algorithms that work with redundant representations, which are amenable to regular, low fan-out and low-latency ASIC implementations. The direct reduction algorithm enjoys the best time as well as best area performance with respect to the other two; but it works for only fixed modulus. With variable moduli, the Montgomery reduction algorithm stands the best solution for memory-constrained designs while designs can greatly benefit from memory-based reduction algorithm provided that the required memory is available.</p>

    <p class="text-gray-300">We also provided figures for area and time complexities of the proposed hardware algorithms in terms of number of basic building blocks such as logical gates, half- and full-adders and carry propagation adders. These figures are intended to serve as lower bounds for the future studies on ASIC implementations of modular squaring operation, which is urgently needed for the adoption of the verifiable delay function in practical applications. Although implementation of a complete VDF system is out of scope for our work, it can be studied as a future extension of this work.</p>

    <p class="text-gray-300">[1] D. Boneh, B. Bunz, and B. Fisch, "A survey of two verifiable delay functions," Cryptology ePrint Archive, Report 2018/712, 2018, https://eprint.iacr.org/2018/712. [2] Krzysztof Pietrzak, "Simple Verifiable Delay Functions," Cryptology ePrint Archive, Report 2018/627, 2018, https://eprint.iacr.org/2018/627. [3] Benjamin Wesolowski, "Efficient verifiable delay functions," Cryptology ePrint Archive, Report 2018/623, 2018, https://eprint.iacr.org/2018/623. [4] Rivest, R. L. and Shamir, A. and Wagner, D. A., "Time-Lock Puzzles and Timed-Release Crypto," Cambridge, MA, USA, Tech. Rep., 1996. [5] Dan Boneh and Joseph Bonneau and Benedikt Bunz and Ben Fisch, "Verifiable Delay Functions," Cryptology ePrint Archive, Report 2018/601, 2018, https://eprint.iacr.org/2018/601. [6] R. Liu and S. Li, "A design and implementation of montgomery modular multiplier," in 2019 IEEE International Symposium on Circuits and Systems (ISCAS), May 2019, pp. 1-4.</p>

    <p class="text-gray-300">TABLE 7 Delay and Area Costs of Modular Squaring Methods with R-P Form for  <span class="math">k = \\{1024,4096\\}</span>  and  <span class="math">r = \\{8,16\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Res.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Montgomery</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory-Based</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Direct</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Method 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 2</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 3</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 2</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Method 2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  k=1024,r=8  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3,822,284</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3,360,714</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,437,443</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,821,339</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,881,309</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,748,189</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,278,175</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">386</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

            <td class="px-3 py-2 border-b border-gray-700">261</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

            <td class="px-3 py-2 border-b border-gray-700">261</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">3,830,497 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">3,434,075 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">2,510,802 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">2,825,499 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,885,467 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,752,347 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,282,331 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1,073,152</td>

            <td class="px-3 py-2 border-b border-gray-700">1,073,152</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">51τFA+τHA+4τAND+τOR+τNOT+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">50τFA+τHA+4τAND+τOR+τNOT+2τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">49τFA+τHA+4τAND+τOR+τNOT+3τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">33τFA+2τAND+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">32τFA+2τAND+2τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">31τFA+2τAND+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">30τFA+2τAND+2τCPA8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  k=1024,r=16  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3,750,508</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3,256,042</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,267,043</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,747,694</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,741,104</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,674,544</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,170,738</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">194</td>

            <td class="px-3 py-2 border-b border-gray-700">259</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">3,758,721 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">3,296,571 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">2,307,570 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">2,751,854 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,745,262 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,678,702 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">1,175,406 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1,073,152</td>

            <td class="px-3 py-2 border-b border-gray-700">1,073,152</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">51τFA+τHA+4τAND+τOR+τNOT+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">50τFA+τHA+4τAND+τOR+τNOT+2τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">49τFA+τHA+4τAND+τOR+τNOT+3τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">33τFA+2τAND+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">32τFA+2τAND+2τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">31τFA+2τAND+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">30τFA+2τAND+2τCPA16</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  k=4096,r=8  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">61,000,460</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">53,649,162</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">38,946,051</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44,455,724</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">29,673,262</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27,563,822</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20,170,544</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">513</td>

            <td class="px-3 py-2 border-b border-gray-700">1,538</td>

            <td class="px-3 py-2 border-b border-gray-700">2,051</td>

            <td class="px-3 py-2 border-b border-gray-700">514</td>

            <td class="px-3 py-2 border-b border-gray-700">1,030</td>

            <td class="px-3 py-2 border-b border-gray-700">514</td>

            <td class="px-3 py-2 border-b border-gray-700">1,030</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">61,033,249 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">54,728,987 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">40,025,874 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">44,472,184 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">29,689,720 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">27,580,280 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">20,189,048 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16,891,904</td>

            <td class="px-3 py-2 border-b border-gray-700">16,891,904</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">61τFA+τHA+4τAND+τOR+τNOT+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">60τFA+τHA+4τAND+τOR+τNOT+2τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">59τFA+τHA+4τAND+τOR+τNOT+3τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">40τFA+2τAND+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">39τFA+2τAND+2τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">39τFA+2τAND+τCPA8</td>

            <td class="px-3 py-2 border-b border-gray-700">37τFA+2τAND+2τCPA8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  k=4096,r=16  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">59,853,196</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">51,977,098</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">36,224,643</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">43,300,509</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27,461,279</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">26,408,607</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18,486,945</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">770</td>

            <td class="px-3 py-2 border-b border-gray-700">1,827</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">515</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Logical Gates</td>

            <td class="px-3 py-2 border-b border-gray-700">59,885,985 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">52,532,379 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">36,779,922 AND +1 OR +2 NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">43,316,969 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">27,477,737 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">26,425,065 AND</td>

            <td class="px-3 py-2 border-b border-gray-700">18,505,449 AND</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M.Cells</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16,891,904</td>

            <td class="px-3 py-2 border-b border-gray-700">16,891,904</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Delay</td>

            <td class="px-3 py-2 border-b border-gray-700">61τFA+τHA+4τAND+τOR+τNOT+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">60τFA+τHA+4τAND+τOR+τNOT+2τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">59τFA+τHA+4τAND+τOR+τNOT+3τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">40τFA+2τAND+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">39τFA+2τAND+2τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">39τFA+2τAND+τCPA16</td>

            <td class="px-3 py-2 border-b border-gray-700">37τFA+2τAND+2τCPA16</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE 8 Area (NAND-2 based) and Latency (ns) Results for the ASIC Synthesis of Montgomery Modular Squaring Operation with R-P (Method 3) and Non-Redundant (N-R) Representations for  <span class="math">k = \\{64,128,256,512\\}</span>  and  <span class="math">r = 8</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mont. (R-P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mont. (N-R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area Incr.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lat. Red.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Area</td>

            <td class="px-3 py-2 border-b border-gray-700">Latency</td>

            <td class="px-3 py-2 border-b border-gray-700">Area</td>

            <td class="px-3 py-2 border-b border-gray-700">Latency</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">51.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.00</td>

            <td class="px-3 py-2 border-b border-gray-700">38.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.11</td>

            <td class="px-3 py-2 border-b border-gray-700">34%</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">184.9K</td>

            <td class="px-3 py-2 border-b border-gray-700">4.85</td>

            <td class="px-3 py-2 border-b border-gray-700">134.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">5.10</td>

            <td class="px-3 py-2 border-b border-gray-700">37%</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">680.8K</td>

            <td class="px-3 py-2 border-b border-gray-700">5.80</td>

            <td class="px-3 py-2 border-b border-gray-700">503.8K</td>

            <td class="px-3 py-2 border-b border-gray-700">6.10</td>

            <td class="px-3 py-2 border-b border-gray-700">35%</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">2528.8K</td>

            <td class="px-3 py-2 border-b border-gray-700">6.81</td>

            <td class="px-3 py-2 border-b border-gray-700">1919.1K</td>

            <td class="px-3 py-2 border-b border-gray-700">7.22</td>

            <td class="px-3 py-2 border-b border-gray-700">31%</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">[7] Z. Gu and S. Li, "A generalized rns mclaughlin modular multiplication with non-coprime moduli sets," IEEE Transactions on Computers, vol. 68, no. 11, pp. 1689-1696, Nov 2019. [8] J. Ding and S. Li, "A low-latency and low-cost montgomery modular multiplier based on nlp multiplication," IEEE Transactions on Circuits and Systems II: Express Briefs, pp. 1-1, 2019. [9] M. J. Foster, M. Lukowiak, and S. Radziszowski, "Flexible hls-based implementation of the karatsuba multiplier targeting homomorphic encryption schemes," in 2019 MIXDES - 26th Int. Conference "Mixed Design of Integrated Circuits and Systems", June 2019, pp. 215-220. [10] S. Li, J. Tian, H. Zhu, Z. Tian, H. Qiao, X. Li, and J. Liu, "Research in fast modular exponentiation algorithm based on fpga," in 2019 11th International Conference on Measuring Technology and Mechatronics Automation (ICMTMA), April 2019, pp. 79-82.</p>

    <p class="text-gray-300">[11] K. Venkatesh, K. Pratibha, S. Annadurai, and L. Kuppusamy, "Reconfigurable architecture to speed-up modular exponentiation," in 2019 Int. Carnahan Conf. on Security Technology (ICCST), Oct 2019, pp. 1-6. [12] G. X. Yao, J. Fan, R. C. C. Cheung, and I. Verbauwhede, “Novel rns parameter selection for fast modular multiplication,” IEEE Transactions on Computers, vol. 63, no. 8, pp. 2099–2105, Aug 2014. [13] W. Wang, Y. Hu, L. Chen, X. Huang, and B. Sunar, "Exploring the feasibility of fully homomorphic encryption," IEEE Transactions on Computers, vol. 64, no. 3, pp. 698-706, March 2015. [14] D. D. Chen, G. X. Yao, R. C. C. Cheung, D. Pao, and C. K. Koc, "Parameter space for the architecture of fft-based montgomery modular multiplication," IEEE Trans. on Comp., vol. 65, no. 1, pp. 147-160, Jan 2016. [15] W. Dai, D. D. Chen, R. C. C. Cheung, and C. K. Koc, "Area-time efficient architecture of ft-based montgomery multiplication," IEEE Transactions on Computers, vol. 66, no. 3, pp. 375-388, March 2017. [16] W. Dai, D. Chen, R. C. C. Cheung, and C. K. Koc, "Fft-based mclaughlin's montgomery exponentiation without conditional selections," IEEE Transactions on Computers, vol. 67, no. 9, pp. 1301-1314, Sep. 2018. [17] P. L. Montgomery, "Modular multiplication without trial division," Mathematics of Computation, vol. 44, no. 170, pp. 519-521, 1985. [18] P. Barrett, "Implementing the Rivest Shamir and Adleman Public Key Encryption Algorithm on a Standard Digital Signal Processor," in Advances in Cryptology — CRYPTO' 86, A. M. Odlyzko, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 1987, pp. 311-323. [19] Bosselaers, Antoon and Govaerts, René and Vandewalle, Joos, "Comparison of Three Modular Reduction Functions," in Proceedings of the 13th Annual International Cryptology Conference on</p>

    <p class="text-gray-300">Advances in Cryptology, ser. CRYPTO '93. Berlin, Heidelberg: Springer-Verlag, 1994, pp. 175-186. [Online]. Available: {http://dl.acm.org/citation.cfm?id=188105.188147} [20] M. Knezevic and F. Vercauteren and I. Verbauwhede, "Faster Interleaved Modular Multiplication Based on Barrett and Montgomery Reduction Methods," IEEE Transactions on Computers, vol. 59, no. 12, pp. 1715-1721, Dec 2010. [21] C. Aguilar-Melchor, J. Barrier, S. Guelton, A. Guinet, M.-O. Killijan, and T. Lepoint, "NFLlib: NTT-Based Fast Lattice Library," in Topics in Cryptology - CT-RSA 2016, K. Sako, Ed. Cham: Springer International Publishing, 2016, pp. 341-356. [22] P. W. Beame and S. A. Cook and H. J. Hoover, "Log Depth Circuits For Division And Related Problems," in 25th Annual Symp. on Foundations of Computer Science, 1984., vol., no., Oct 1984, pp. 1-6. [23] A. Schonhage and V. Strassen, "Schnelle Multiplikation großer Zahlen," Computing, vol. 7, no. 3, pp. 281-292, Sep 1971. [Online]. Available: https://doi.org/10.1007/BF02242355 [24] D. Harvey and J. van der Hoeven, "Faster integer multiplication using short lattice vectors," The Open Book Series, vol. 2, no. 1, pp. 293-310, 2019. [25] ——, "Faster integer multiplication using plain vanilla FFT primes," Mathematics of Computation, vol. 88, no. 315, pp. 501-514, 2019. [26] E. Öztürk, “Design and implementation of a low-latency modular multiplication algorithm,” IEEE Transactions on Circuits and Systems I: Regular Papers, pp. 1-10, 2020. [27] T. Yanik, E. Savaş, and C. K. Koç, "Incomplete reduction in modular arithmetic," IEEE Proceedings - Computers and Digital Techniques, vol. 149, pp. 46-52(6), March 2002. [Online]. Available: https://digital-library.theiet.org/content/journals/10.1049/ip-cdt_20020235 [28] C. S. Wallace, “A suggestion for a fast multiplier,” IEEE Transactions on Electronic Computers, vol. EC-13, no. 1, pp. 14–17, Feb 1964. [29] L. Dadda, "Some schemes for parallel multipliers," in Alta Frequenza, vol. 34, 1965, pp. 349-356. [30] P. M. Kogge and H. S. Stone, "A parallel algorithm for the efficient solution of a general class of recurrence equations," IEEE Transactions on Computers, vol. C-22, no. 8, pp. 786-793, Aug 1973. [31] R. P. Brent and H. T. Kung, "A regular layout for parallel adders," IEEE Trans. Comput., vol. 31, no. 3, pp. 260-264, Mar. 1982. [Online]. Available: http://dx.doi.org/10.1109/TC.1982.1675982 [32] B. Parhami, Computer Arithmetic: Algorithms and Hardware Designs. New York, NY, USA: Oxford University Press, Inc., 2000. [33] A. Avizienis, "Signed-digit numbe representations for fast parallel arithmetic," IRE Trans. Elect. Comp., vol. 10, no. 3, pp. 389-400, 1961. [Online]. Available: https://doi.org/10.1109/TEC.1961.5219227 [34] C. K. Koc, T. Acar, and B. S. K. Jr., "Analyzing and comparing montgomery multiplication algorithms," IEEE Micro, vol. 16, no. 3, pp. 26-33, 1996. [Online]. Available: https://doi.org/10.1109/40.502403 [35] G. Hachez and J.-J. Quisquater, "Montgomery exponentiation with no final subtractions: Improved results," in Proceedings of the Second Int. Workshop on Cryptographic Hardware and Embedded Systems, ser. CHES '00. London, UK, UK: Springer-Verlag, 2000, pp. 293-301. [36] XILINX Inc., "UG479-7 Series DSP48E1 Slice User Guide," 2018, https://www.xilinx.com/support/documentation/user_guides/ug479_7Series_DSP48E1.pdf. [37] D. J. Bernstein and J. P. Sorenson, "Modular exponentiation via the explicit chinese remainder theorem," Math. Comput., vol. 76, no. 257, pp. 443-454, 2007. [Online]. Available: https://doi.org/10.1090/S0025-5718-06-01849-7</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">Erdinç Öztürk received his BS degree in Microelectronics from Sabanci University in 2003. He received his MS degree in Electrical Engineering in 2005 and PhD degree in Electrical and Computer engineering in 2009 from Worcester Polytechnic Institute. After receiving his PhD degree, he worked at Intel in Hudson, Massachusetts for almost 5 years as a hardware engineer, before joining Istanbul Commerce University in Turkey as an assistant professor. He joined Sabanci University in 2017 as an assistant professor.</p>

    <p class="text-gray-300">His research interest focuses on efficient hardware implementations of compute-intensive algorithms.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">Erkay Savaş received the BS and MS degrees in electrical engineering from the Electronics and Communications Engineering Department, Istanbul Technical University in 1990 and 1994, respectively. He received the PhD degree from the Department of Electrical and Computer Engineering, Oregon State University in June 2000. He has been a faculty member at Sabanci University since 2002. His research interests include applied cryptography, data and communication security, security and privacy in data min</p>

    <p class="text-gray-300">ing applications, embedded systems security, and distributed systems.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a></p>

    <p class="text-gray-300">Ahmet Can Mert received the B.S. and M.S. degrees in Electronics Engineering Program from Sabanci University, Istanbul, Turkey, in 2015 and 2017, respectively. Currently, he is working towards the Ph.D. degree in Electronics Engineering Program at Sabanci University, Istanbul, Turkey. His research interest includes homomorphic encryption, lattice-based cryptography and cryptographic hardware design. He received the best paper award at the 2020 Design, Automation and Test in Europe (DATE) Conference.</p>`;
---

<BaseLayout title="Low-Latency ASIC Algorithms of Modular Squaring of Large Int... (2020/480)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/480
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
