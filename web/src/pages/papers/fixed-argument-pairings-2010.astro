---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/342';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fixed Argument Pairings';
const AUTHORS_HTML = 'Craig Costello, Douglas Stebila';

const CONTENT = `    <p class="text-gray-300">Craig Costello and Douglas Stebila</p>

    <p class="text-gray-300">Information Security Institute, Queensland University of Technology, Brisbane, Queensland, Australia Email: craig.costello@qut.edu.au, douglas@stebila.ca</p>

    <p class="text-gray-300">Abstract. A common scenario in many pairing-based cryptographic protocols is that one argument in the pairing is fixed as a long term secret key or a constant parameter in the system. In these situations, the runtime of Miller's algorithm can be significantly reduced by storing precomputed values that depend on the fixed argument, prior to the input or existence of the second argument. In light of recent developments in pairing computation, we show that the computation of the Miller loop can be sped up by up to <span class="math">37\\%</span> if precomputation is employed, with our method being up to <span class="math">19.5\\%</span> faster than the previous precomputation techniques.</p>

    <p class="text-gray-300">Keywords: Pairings, Miller's algorithm, Tate pairing, ate pairing, precomputation.</p>

    <p class="text-gray-300">Boneh and Franklin were among the first to present a pairing-based cryptosystem in 2001, when they exploited the powerful bilinearity property of pairings to construct the first efficient and provably secure identity-based encryption (IBE) scheme [9], answering an open question first posed by Shamir in 1984 [44]. Boneh and Franklin's discovery, alongside Joux's one round tripartite key agreement protocol [29], were major breakthroughs that gave rise to the now thriving field of pairing-based cryptography and a vast array of new pairing-based primitives that followed, including short signatures [11], hierarchical encryption [23], group signatures [8], ring signatures [10], identity-based key agreement schemes [45, 13, 33], an IBE scheme secure in the standard model [47], as well as generalizations of IBE such as attribute-based encryption [24, 31].</p>

    <p class="text-gray-300">The computation of pairings via Miller's algorithm [35] was initially too slow for them to be considered practically viable, but this did not remain the case for long. Much research has concentrated on achieving pairings at high security levels that are efficient enough for industrial applications. Although use of the Weil pairing was initially proposed, it quickly became evident that the computation of the Tate pairing was much faster in practice [9, 21, 22, 4]. A decade after their introduction into cryptosystems, the computation of a pairing has accelerated from older implementations that took a few minutes [34], to current state-of-the-art implementations that take only a few milliseconds [25, 1, 37]. Many of the avenues for improving the computation speed of cryptographic pairings on elliptic curves have been somewhat exhausted:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Miller loop has been truncated to optimal lengths [3, 28, 32, 46, 27];</li>

      <li>improvements inside the Miller iterations, such as denominator elimination, have been thoroughly explored [4, 5];</li>

      <li>the choice of the groups <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> as the two eigenspaces of the Frobenius endormorphism is now standard [28, 18];</li>

      <li>there is now a flexible array of curve constructions that facilitate fast implementations [20];</li>

      <li>different elliptic curve representations and coordinates systems have been explored in efforts to reduce the field operations encountered when computing the Miller functions [2, 16, 17]; and</li>

      <li>many other improvements have become standard in optimal or restricted implementations, such as compressed pairings [39, 36], optimized field constructions [30, 6], fast hashing [40], and fast final exponentiation [41] techniques.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first author acknowledges funding from the Queensland Government Smart State PhD Scholarship.</li>

    </ul>

    <p class="text-gray-300">While these techniques have allowed for relatively fast implementations of pairings, there are still some possible improvements that are yet to be explored to their full potential. In this paper we explore one such technique: the implementation of pairings with one argument fixed, which allow for improvements in runtime performance based on precomputations. In the pairing <span class="math">e(R,S)</span> of two points <span class="math">R</span> and <span class="math">S</span> on an elliptic curve, we call the argument <em>R fixed</em> if it is constant in terms of the corresponding protocol that employs the pairing, for example, <span class="math">R</span> is a long-term private key that is “paired” with ephemeral or dynamic values (different <span class="math">S</span> values) at runtime.</p>

    <p class="text-gray-300">Scott <em>[38]</em> was the first to comment on the possibility of exploiting the nature of a fixed argument <span class="math">R</span>, suggesting to precompute all multiples of the point <span class="math">R</span> required in the Miller loop. Scott <em>et al.</em> <em>[42]</em> took this idea further by also precomputing the gradients, <span class="math">\\lambda_{i}</span>, of each of the line functions that arise in the Miller iterations, since these are also values depending solely on the first argument <span class="math">R</span>. Essentially, this means that the coefficients of the affine Miller functions have been computed in advance and are just “waiting” as indeterminate functions until <span class="math">S</span> is known, so that they can be evaluated and used to update the Miller function.</p>

    <p class="text-gray-300">We adopt this same approach by performing all computations that are solely dependent on the fixed argument <span class="math">R</span>, and storing these before the second argument <span class="math">S</span> is available. Since <span class="math">R</span>-dependent computations can be performed once only and stored in the long term, it is only the subsequent <span class="math">S</span>-dependent computations that affect the runtime of the pairing algorithm. The question that we address in this paper arises naturally: <em>are there further <span class="math">R</span>-dependent (pre)computations that can be done to reduce the workload encountered when the dynamic second argument <span class="math">S</span> is known?</em></p>

    <p class="text-gray-300">In light of recent developments in pairing computation <em>[14, 15]</em>, we address this question by considering another: <em>is it computationally cheaper to evaluate a function before operating on its result, or can it be advantageous to operate on the indeterminate function before evaluating it?</em></p>

    <p class="text-gray-300">When neither of the pairing arguments are fixed, the results in <em>[14]</em> and <em>[15]</em> show that many cases of pairing implementations favour the latter. In the case of fixed argument pairings, this becomes even more evident when we observe that any computations on the indeterminate Miller functions are entirely <span class="math">R</span>-dependent and can be done in advance. We show that for both the Tate and ate pairings, the Miller loop can be computed with between <span class="math">25</span> and <span class="math">37\\%</span> fewer field multiplications (or squarings) if an optimal amount of precomputation is performed in the fixed argument, compared to the case when no precomputation is performed.</p>

    <p class="text-gray-300">The rest of this paper is organized as follows. In Section 2, we present background information on computing pairings using Miller’s algorithm. In Section 3, we separate the <span class="math">R</span>-dependent precomputations from the <span class="math">S</span>-dependent dynamic computations in preparation for Section 4, where we present our main technical innovation: we show how to merge multiple iterations of the loop in Miller’s algorithm in the precomputation stage to reduce the cost of the <span class="math">S</span>-dependent computations. Section 5 presents the optimal number of iterations to merge for various security levels, and Section 6 lists a number of cryptosystems which can benefit from our techniques. We conclude in Section 7.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve defined over a large prime field <span class="math">\\mathbb{F}_{p}</span> which is given by the short Weierstrass equation <span class="math">E:y^{2}=x^{3}+ax+b</span>, the identity element of which is denoted by <span class="math">\\mathcal{O}</span>. Let <span class="math">r</span> be a large prime and let <span class="math">E[r]</span> be the group of points with order <span class="math">r</span> (the <span class="math">r</span>-torsion) on <span class="math">E</span>. Let <span class="math">k&gt;1</span> be the smallest integer such that <span class="math">r\\mid p^{k}-1</span>; we call <span class="math">k</span> the <em>embedding degree</em>. Let <span class="math">\\pi_{p}</span> be the <span class="math">p</span>-power Frobenius endormorphism on <span class="math">E</span>. The two eigenspaces of <span class="math">\\pi_{p}</span>, restricted to the <span class="math">r</span>-torsion on <span class="math">E</span>, form two linearly independent groups of order <span class="math">r</span>, written as <span class="math">\\mathbb{G}_{1}=E[r]\\cap\\ker(\\pi_{p}-[1])</span> and <span class="math">\\mathbb{G}_{2}=E[r]\\cap\\ker(\\pi_{p}-[p])</span>. The group <span class="math">\\mathbb{G}_{1}</span> is defined over the base field <span class="math">\\mathbb{F}_{p}</span>, whilst the group <span class="math">\\mathbb{G}_{2}</span> is defined over the full extension field <span class="math">\\mathbb{F}_{p^{k}}</span>.</p>

    <p class="text-gray-300">A bilinear pairing <span class="math">e</span> of two points <span class="math">R,S\\in E</span> can be computed as</p>

    <p class="text-gray-300"><span class="math">e(R,S)=f_{m,R}(S)^{(p^{k}-1)/r},</span></p>

    <p class="text-gray-300">where <span class="math">m \\in \\mathbb{Z}</span>, and <span class="math">f_{m,R}</span> is a function with divisor <span class="math">\\operatorname{div}(f_{m,R}) = m(R) - ([m]R) - (m - 1)(\\mathcal{O})</span>. For our purposes, <span class="math">k</span> will always be even, which allows us to write the function <span class="math">f_{m,R}</span> as a polynomial in <span class="math">x</span> and <span class="math">y</span> so that <span class="math">f_{m,R}(x,y)</span> is evaluated at the coordinates of the point <span class="math">S</span> when the pairing is computed. For the Tate pairing, the first argument <span class="math">R</span> comes from <span class="math">\\mathbb{G}_1</span> and the second argument <span class="math">S</span> comes from <span class="math">\\mathbb{G}_2</span>, whilst the ate pairing takes <span class="math">R \\in \\mathbb{G}_2</span> and <span class="math">S \\in \\mathbb{G}_1</span>. In either case, the function <span class="math">f_{m,R}(S)</span> evaluates as an element of the finite field <span class="math">\\mathbb{F}_{p^k}</span>, and this value is raised to the power <span class="math">(p^k - 1)/r</span> in the "final exponentiation" stage. The function <span class="math">f_{m,R}</span> is called the Miller function, since it is constructed in a double-and-add like fashion using Miller's algorithm, which is described in Algorithm 1.</p>

    <p class="text-gray-300">Algorithm 1 Miller's affine double-and-add algorithm with denominator elimination Input: <span class="math">R = (x_{R},y_{R})</span>, <span class="math">S = (x_{S},y_{S})</span>, <span class="math">m = (m_{l - 1}\\dots m_1,m_0)_2</span>. Output: <span class="math">f_{m,R}(S) \\gets f</span>. 1: <span class="math">T \\gets R</span>, <span class="math">f \\gets 1</span>. 2: for <span class="math">i</span> from <span class="math">l - 2</span> to 0 do 3: Compute <span class="math">g(x,y) = y - y_{T} + \\lambda (x_{T} - x)</span>, where <span class="math">\\lambda</span> is the gradient of the tangent line to <span class="math">T</span>. 4: <span class="math">T \\gets 2[T = 2]</span>. 5: <span class="math">g \\gets g(x_{S},y_{S})</span>. 6: <span class="math">f \\gets f^{2} \\cdot g</span>. 7: if <span class="math">m_i \\neq 0</span> then 8: Compute <span class="math">g(x,y) = y - y_{T} + \\lambda (x_{T} - x)</span>, where <span class="math">\\lambda</span> is the gradient of the line joining <span class="math">T</span> and <span class="math">R</span>. 9: <span class="math">T \\gets T + R</span>. 10: <span class="math">g \\gets g(x_{S},y_{S})</span>. 11: <span class="math">f \\gets f \\cdot g</span>. 12: end if 13: end for 14: return <span class="math">f</span>.</p>

    <p class="text-gray-300">If we were to discard lines 5 and 10 of Algorithm 1, the output would be an indeterminate function <span class="math">f_{m,R}(x,y)</span> of degree <span class="math">m</span>, rather than a field element <span class="math">f_{m,R}(x_S,y_S) \\in \\mathbb{F}_{p^k}</span>. The reason we include lines 5 and 10 and evaluate the intermediate functions in each iteration is because <span class="math">m</span> is usually quite large (for example, no smaller than <span class="math">2^{20}</span>), and storing so many coefficients is infeasible; memory constraints force us to evaluate the <span class="math">g</span> functions as we go.</p>

    <p class="text-gray-300">Modern pairing implementations make use of the twisted curve <span class="math">E&#x27;</span> of <span class="math">E</span>, to define a group <span class="math">\\mathbb{G}_2&#x27; \\in E&#x27;</span> that is isomorphic to <span class="math">\\mathbb{G}_2 \\in E</span>, but is defined over a smaller subfield <span class="math">\\mathbb{F}_{p^e}</span> of <span class="math">\\mathbb{F}_{p^k}</span>. We let <span class="math">\\psi : E&#x27; \\to E</span> be the twisting isomorphism from <span class="math">E&#x27;</span> to <span class="math">E</span>, so that <span class="math">\\psi(\\mathbb{G}_2&#x27;) = \\mathbb{G}_2</span>. A point <span class="math">P \\in \\mathbb{G}_2</span> is usually written as <span class="math">P = P&#x27; \\cdot \\alpha</span>, where <span class="math">P&#x27; \\in \\mathbb{G}_2&#x27;</span> is defined over <span class="math">\\mathbb{F}_{p^e}</span> and <span class="math">\\alpha</span> is an algebraic element used in the twisting isomorphism (cf. [28, 17]). In both the Tate and ate pairings, such points in <span class="math">\\mathbb{G}_2</span> are often multiplied by elements in the base field <span class="math">\\mathbb{F}_p</span>, and because of the representation of <span class="math">\\mathbb{G}_2</span> over the twisted curve, these multiplications are counted as <span class="math">e</span> multiplications in the base field.</p>

    <p class="text-gray-300">To count field multiplications and squarings across the different fields employed in pairing computations, we use <span class="math">\\mathbf{m}_i</span> and <span class="math">\\mathbf{s}_i</span> to respectively denote a multiplication and a squaring in the field <span class="math">\\mathbb{F}_{p^i}</span>. We maintain generality (across both Tate and ate like pairings) by assuming that the first argument <span class="math">R</span> is written as an element of <span class="math">\\mathbb{F}_{p^u}</span> and that the second argument <span class="math">S</span> is written as an element of <span class="math">\\mathbb{F}_{p^e}</span>, where it is understood that the Tate pairing has <span class="math">(u,v) = (1,e)</span> and that the ate pairing has <span class="math">(u,v) = (e,1)</span>. In both cases, the argument defined over <span class="math">\\mathbb{F}_{p^k}</span> is actually treated as an element of <span class="math">\\mathbb{F}_{p^e}</span> using <span class="math">\\mathbb{G}_2&#x27;</span>.</p>

    <p class="text-gray-300">We begin by separating the  <span class="math">R</span> -dependent (fixed) computations from the  <span class="math">S</span> -dependent (dynamic) computations. Our goal is to minimize the computational complexity of the  <span class="math">S</span> -dependent computations.</p>

    <p class="text-gray-300">When the first argument in the pairing,  <span class="math">R</span> , is a fixed or constant parameter in a protocol, Scott et al. [42] propose precomputing and storing all the multiples of  <span class="math">R</span>  (the  <span class="math">T</span>  values in Algorithm 1) and all of the gradients (the  <span class="math">\\lambda</span>  values) in each of the Miller lines (the functions  <span class="math">g</span> ). This is essentially the same as writing each of the Miller lines as  <span class="math">g(x,y) = y - \\lambda x - c</span> , where  <span class="math">c = y_{T} - \\lambda x_{T}</span>  is precomputed and stored alongside  <span class="math">\\lambda</span>  (see Algorithm 1). We prefer to precompute and store  <span class="math">(\\lambda, c)</span>  at each iteration, rather than  <span class="math">(x_{T}, y_{T}, \\lambda)</span> , since this saves an extra multiplication  <span class="math">(\\lambda</span>  by  <span class="math">x_{T}</span> ) at runtime and only requires the storage of two values for each iteration, as well as somewhat simplifying the description of what the precomputation achieves. Namely, we do not store the multiples of the point  <span class="math">R</span> , since they are not necessarily required once  <span class="math">S</span>  is input. Instead, we compute all of the  <span class="math">R</span> -dependent coefficients of the Miller line functions that are required, in complete preparation for the "arrival" of the argument  <span class="math">S</span> .</p>

    <p class="text-gray-300">In this light, fixing one argument in the pairing allows us to split Miller's algorithm into two parts. The first part involves all of the  <span class="math">R</span> -dependent (pre)computations that can be performed in advance: computing a set of indeterminate Miller lines defined by  <span class="math">(\\lambda, c)</span> . The second part involves all of the  <span class="math">S</span> -dependent computations, namely those which cannot be performed until the argument  <span class="math">S</span>  is known. We describe the  <span class="math">R</span> -dependent precomputations in Algorithm 2 and the  <span class="math">S</span> -dependent dynamic computations in Algorithm 3. For ease of exposition, we assume from here on that the Miller lines are of the form  <span class="math">g(x, y) = y + \\tilde{\\lambda} x + \\tilde{c}</span> , instead of the usual  <span class="math">g(x, y) = y - \\lambda x - c</span> , by taking  <span class="math">\\tilde{\\lambda} = -\\lambda</span>  and  <span class="math">\\tilde{c} = -c</span> , and make an abuse of notation by relabeling and writing  <span class="math">g(x, y) = y + \\lambda x + c</span>  from now on. We use #DBL and #ADD in both algorithms to denote the number of doublings and additions, respectively, that occur in the run of Miller's algorithm. Clearly, #DBL = l - 1 (from Algorithm 1) and #ADD is equal to the number of non-zero bits in the binary representation of the loop parameter  <span class="math">m</span>  (excluding the most significant bit). We also write the binary representation of  <span class="math">m</span>  from  <span class="math">m = (m_{l-1} \\dots m_1, m_0)_2</span>  to  <span class="math">m = (\\tilde{m}_0, \\tilde{m}_1 \\dots \\tilde{m}_{\\# DBL-1}, \\tilde{m}_{\\# DBL})_2</span> , so that  <span class="math">\\tilde{m}_0</span>  is now the most significant bit, and Miller's algorithm proceeds from  <span class="math">\\tilde{m}_1</span>  to  <span class="math">\\tilde{m}_{\\# DBL}</span> ; we relabel so that  <span class="math">m = (m_0, m_1 \\dots m_{\\# DBL-1}, m_{\\# DBL})_2</span>  from now on.</p>

    <p class="text-gray-300">Algorithm 2  <span class="math">R</span> -dependent precomputations Input:  <span class="math">R = (x_{R},y_{R})</span> <span class="math">m = (m_0,m_1\\dots m_{\\# \\mathrm{DBL} - 1},m_{\\# \\mathrm{DBL}})_2</span> Output:  <span class="math">G_{\\mathrm{DBL}} = \\{(\\lambda_1,c_1),(\\lambda_2,c_2),\\dots,(\\lambda_{\\# \\mathrm{DBL}},c_{\\# \\mathrm{DBL}})\\}</span>  and  <span class="math">G_{\\mathrm{ADD}} = \\{(\\lambda_1&#x27;,c_1&#x27;),(\\lambda_2&#x27;,c_2&#x27;),\\dots,(\\lambda_{\\# \\mathrm{ADD}}&#x27;,c_{\\# \\mathrm{ADD}}&#x27;)\\}</span> 1:  <span class="math">T\\gets R,G_{\\mathrm{DBL}}\\gets \\{\\emptyset \\}</span> <span class="math">G_{\\mathrm{ADD}}\\gets \\{\\emptyset \\}</span> 2: for i from 1 to #DBL do 3: Compute  <span class="math">\\lambda_{i}</span>  and  <span class="math">c_{i}</span>  , such that  <span class="math">y + \\lambda_{i}x + c_{i}</span>  is the line tangent to  <span class="math">T</span> 4:  <span class="math">T\\gets [2]T</span> 5: Append  <span class="math">(\\lambda_i,c_i)</span>  to  <span class="math">G_{\\mathrm{DBL}}</span> 6: if  <span class="math">m_i\\neq 0</span>  then 7: Compute  <span class="math">\\lambda_i^\\prime</span>  and  <span class="math">c_{i}^{\\prime}</span>  , such that  <span class="math">y + \\lambda_i^\\prime x + c_i^\\prime</span>  is the line joining  <span class="math">T</span>  and  <span class="math">R</span> 8:  <span class="math">T\\gets T + R</span> 9: Append  <span class="math">(\\lambda_i&#x27;,c_i&#x27;)</span>  to  <span class="math">G_{\\mathrm{ADD}}</span> 10: end if 11: end for 12: return  <span class="math">G_{\\mathrm{DBL}},G_{\\mathrm{ADD}}</span></p>

    <p class="text-gray-300">It is important to note that we are solely focussed on minimizing the computational complexity of the algorithm that is  <span class="math">S</span> -dependent. We are assuming that the  <span class="math">R</span> -dependent precomputations are carried out well in advance on a platform that is not too restricted (within reason) with</p>

    <p class="text-gray-300">Algorithm 3  <span class="math">S</span> -dependent computations Input:  <span class="math">S = (x_{S},y_{S})</span> <span class="math">m = (m_0,m_1\\dots m_{\\# \\mathrm{DBL} - 1},m_{\\# \\mathrm{DBL}})_2</span> <span class="math">G_{\\mathrm{DBL}}</span>  and  <span class="math">G_{\\mathrm{ADD}}</span>  (from Algorithm 2). Output:  <span class="math">f_{m,R}(S)\\gets f</span> 1:  <span class="math">f\\gets 1</span>  countADD  <span class="math">\\leftarrow 1</span> 2: for i from 1 to #DBL do 3: Compute  <span class="math">g\\gets (y_S + \\lambda_i x_S + c_i)</span> 4:  <span class="math">f\\gets f^2\\cdot g</span> 5: if  <span class="math">m_i\\neq 0</span>  then 6: Compute  <span class="math">g\\gets (y_S + \\lambda_{\\mathrm{countADD}}&#x27;x_S + c_{\\mathrm{countADD}}&#x27;)</span> 7: countADD  <span class="math">\\leftarrow</span>  countADD+1. 8:  <span class="math">f\\gets f\\cdot g</span> 9: end if 10: end for 11: return f.</p>

    <p class="text-gray-300">computational time. For example, in pairings where both arguments are dynamic, one would never compute the Miller point operations and the Miller line functions in affine coordinates, as this involves costly field inversions. Such pairings always resort to avoiding these inversions by using projective coordinates, but in these cases the Miller lines that arise are almost always (cf. [17]) of the form  <span class="math">g(x,y) = g_x \\cdot x + g_y \\cdot y + g_0</span> . Employing projective coordinates would certainly reduce the computational time spent performing the  <span class="math">R</span> -dependent precomputations, but this would produce slightly more complicated Miller lines (the extra coefficient  <span class="math">g_y</span>  in front of  <span class="math">y</span> ), and would inevitably slow down the dynamic computations involving  <span class="math">S</span> . In the theme of this paper then, we opt for affine coordinates throughout, with the ultimate goal of minimizing the  <span class="math">S</span> -dependent runtime. We do point out however, that the methods in this paper are entirely compatible with an implementation where the precomputation complexity might still be somewhat crucial, in which case the precomputation could be performed in projective coordinates. In such cases, one would split the algorithm and the analogous computational cost analysis described in [15].</p>

    <p class="text-gray-300">In Table 1, we present the  <span class="math">S</span> -dependent dynamic computational complexity in a typical iteration of Algorithm 3, ignoring the cost of the precomputations in Algorithm 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Iteration</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R-dependent values</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Storage ∈ Fpα</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-dependent computations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dynamic costs</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">λ1, c1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">λ1·xS, f←f2, f←f·g</td>

            <td class="px-3 py-2 border-b border-gray-700">em1 + sk + mk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">λ2, c2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">λ2·xS, f←f2, f←f·g</td>

            <td class="px-3 py-2 border-b border-gray-700">em1 + sk + mk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">λi, ci</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">λi·xS, f←f2, f←f·g</td>

            <td class="px-3 py-2 border-b border-gray-700">em1 + sk + mk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">#DBL</td>

            <td class="px-3 py-2 border-b border-gray-700">λ#DBL, c#DBL</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">λ#DBL·xS, f←f2, f←f·g</td>

            <td class="px-3 py-2 border-b border-gray-700">em1 + sk + mk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. The complexity of  <span class="math">S</span> -dependent computations and storage requirements for Miller's double-and-add routine</p>

    <p class="text-gray-300">Table 1 also includes the storage requirements for the Miller lines in each iteration. We do not include the extra storage and  <span class="math">S</span> -dependent computations required for the addition steps in our analysis, since additions only occur a small number of times in state-of-the-art implementations that make use of well-chosen, low Hamming-weight loop parameters. In each iteration, the multiplication of the Miller function  <span class="math">f</span>  by the update  <span class="math">g</span>  is counted as  <span class="math">\\tilde{\\mathbf{m}}_k</span> , where  <span class="math">\\tilde{\\mathbf{m}}_k</span>  is actually less than a general  <span class="math">\\mathbf{m}_k</span> , since the updates  <span class="math">g</span>  are sparse. The complexity of  <span class="math">\\tilde{\\mathbf{m}}_k</span>  compared with  <span class="math">\\mathbf{m}_k</span>  depends on the degree of the twist and the nature of the field construction.</p>

    <p class="text-gray-300">The <span class="math">R</span>-dependent precomputations described above are somewhat natural in the context of fixed argument pairings. In the next section, we investigate whether more precomputation can be done to reduce the overall <span class="math">S</span>-dependent complexity (the total of all the entries in the “Dynamic costs” column).</p>

    <h2 id="sec-5" class="text-2xl font-bold">4 Further Precomputations: Merging <span class="math">n</span> Iterations at a Time</h2>

    <p class="text-gray-300">It was shown very recently <em>[14, 15]</em> that speedups in pairing computations can be achieved if the Miller lines for consecutive iterations are combined before they are evaluated at the second argument of the pairing. In <em>[15]</em>, speedups were achieved by developing a general algorithm for merging <span class="math">n</span> consecutive iterations. This involves multiplying <span class="math">n</span> Miller lines together, each of which is raised to a different exponent depending on how many field squarings it would otherwise encounter in the standard Miller routine, given as</p>

    <p class="text-gray-300"><span class="math">G_{n}(x,y)=\\prod_{i=1}^{n}g_{i}(x,y)^{2^{n-i}}.</span> (1)</p>

    <p class="text-gray-300">The technique in <em>[14]</em> is much the same, except the formulas for the above line product were presented in (slightly faster) explicit formulas, depending on the shape of the curve employed.</p>

    <p class="text-gray-300">Our approach is analogous to that of <em>[15]</em>, where we derive an algorithm to give <span class="math">G_{n}(x,y)</span> in its general form. We note two important differences between the results herein, and those in <em>[15]</em>. Firstly, the Miller lines in this paper are given in affine form, and so the general product in (1) will have a slightly different form. Secondly, the only computational costs we are concerned with are the dynamic <span class="math">S</span>-dependent costs. This means that the (potentially very expensive) computational costs associated with building up the combined products in (1) can be ignored when determining the optimal number of lines to combine.</p>

    <p class="text-gray-300">We start the discussion by determining the nature of the function <span class="math">G_{n}(x,y)</span>, since the <span class="math">G_{n}(x,y)</span> products will be evaluated at <span class="math">S</span>, and this is the first <span class="math">S</span>-dependent cost incurred in each of the <span class="math">n</span>-at-a-time iterations. We reiterate that the cost associated with building the indeterminate <span class="math">G_{n}(x,y)</span> functions is ignored since the coefficients of these functions are solely <span class="math">R</span>-dependent. We assume that <span class="math">G_{n}(x,y)</span> is reduced modulo the curve equation <span class="math">y^{2}=h(x)</span>, so that the result will always be (at most) linear in <span class="math">y</span>, given as</p>

    <p class="text-gray-300"><span class="math">G_{n}(x,y)=f_{n}(x)+g_{n}(x)y,</span> (2)</p>

    <p class="text-gray-300">(where <span class="math">f_{n}(x)</span> and <span class="math">g_{n}(x)</span> are not to be confused with the <span class="math">f</span> and <span class="math">g</span> functions described in the algorithms in the previous sections). The following lemma can be used to determine the exact degree of <span class="math">f_{n}(x)</span> and <span class="math">g_{n}(x)</span> for all <span class="math">n</span>.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">Let <span class="math">y^{2}=h(x)</span> define an elliptic curve, where <span class="math">h(x)</span> is a monic polynomial with <span class="math">\\deg(h)=3</span>. Let <span class="math">n</span> consecutive affine Miller doubling updates be given by <span class="math">g_{1}(x,y)=y+\\lambda_{1}x+c_{1},...</span>, <span class="math">g_{n}(x,y)=y+\\lambda_{n}x+c_{n}</span>. If <span class="math">G_{n}</span> is defined as in Equation (1), then <span class="math">G_{n}(x,y)</span> takes the form</p>

    <p class="text-gray-300"><span class="math">G_{n}(x,y)=f_{n}(x)+g_{n}(x)y,</span></p>

    <p class="text-gray-300">where <span class="math">g(x)</span> is a monic polynomial such that <span class="math">\\deg(g_{n})=\\deg(f_{n})-1</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">When <span class="math">n=1</span>, we have <span class="math">G_{1}(x,y)=g_{1}(x,y)=y+\\lambda_{1}x+c_{1}=f_{1}(x)+g_{1}(x)y</span>, where <span class="math">f_{1}(x)=\\lambda_{1}x+c</span> and <span class="math">g_{1}(x)=1</span>, so that <span class="math">\\deg(g_{1})=\\deg(f_{1})-1</span> and <span class="math">g_{1}(x)</span> is trivially monic.</p>

    <p class="text-gray-300">For induction, assume <span class="math">G_{k}=f_{k}(x)+g_{k}(x)y</span>, where <span class="math">\\deg(g_{k})=\\deg(f_{k})-1</span> and <span class="math">g_{k}</span> is monic. <span class="math">G_{k+1}</span> is computed as</p>

    <p class="text-gray-300"><span class="math">G_{k+1}</span> <span class="math">=G_{k}^{2}\\cdot g_{k+1}</span> <span class="math">=\\left(f_{k}(x)+g_{k}(x)y\\right)^{2}\\cdot\\left(y+\\lambda_{k+1}x+c_{k+1}\\right)</span> <span class="math">=\\left(f_{k}(x)^{2}+2f_{k}(x)g_{k}(x)y+g_{k}(x)^{2}h(x)\\right)\\!(y+\\lambda_{k+1}x+c_{k+1}\\!\\left. \\right)</span> <span class="math">=f_{k+1}(x)+g_{k+1}(x)y,</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">f_{k+1}(x)=2f_{k}(x)g_{k}(x)h(x)+\\big{(}f_{k}(x)^{2}+g_{k}(x)^{2}h(x)\\big{)}\\big{(}\\lambda_{k+1}x+c_{k+1}\\big{)}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">g_{k+1}(x)=f_{k}(x)^{2}+g_{k}(x)^{2}h(x)+2f_{k}(x)g_{k}(x)\\big{(}\\lambda_{k+1}x+c_{k+1}\\big{)}.</span></p>

    <p class="text-gray-300">The degree of <span class="math">f_{k+1}(x)</span> is easily seen to be <span class="math">\\deg(f_{k+1})=\\deg(f_{k})+\\operatorname{def}(g_{k})+\\deg(h)=\\deg(f_{k})+(\\deg(f_{k})-1)+3=2\\cdot\\deg(f_{k})+2</span>, and the degree of <span class="math">g_{k+1}(x)</span> is <span class="math">2\\cdot\\deg(g_{k})+\\deg(h)=2\\cdot\\deg(f_{k})+1</span>, so that <span class="math">\\deg(g_{k+1})=\\deg(f_{k+1})-1</span>. Lastly, <span class="math">g_{k}(x)^{2}h(x)</span> is the only expression contributing to <span class="math">g_{k+1}(x)</span> whose degree is the same as the degree of <span class="math">g_{k+1}(x)</span>, and <span class="math">g_{k}(x)^{2}h(x)</span> is clearly monic (since both <span class="math">g_{k}(x)</span> and <span class="math">h(x)</span> are monic), so <span class="math">g_{k+1}(x)</span> is also monic. ∎</p>

    <p class="text-gray-300">To determine the degrees of <span class="math">f_{n}</span> and <span class="math">g_{n}</span>, we couple the initial values, <span class="math">\\deg(f_{1})=1</span> and <span class="math">\\deg(g_{1})=0</span>, with the conditions <span class="math">\\deg(f_{k+1})=2\\cdot\\deg(f_{k})+2</span> and <span class="math">\\deg(g_{k+1})=2\\cdot\\deg(f_{k})+1</span>; hence</p>

    <p class="text-gray-300"><span class="math">\\deg(f_{n})=3\\cdot(2^{n-1}-1)+1\\qquad\\quad\\text{and}\\qquad\\quad\\deg(g_{n})=3\\cdot(2^{n-1}-1),</span> (3)</p>

    <p class="text-gray-300">agreeing with the analogous result for projective coordinates in <em>[15, Eq. (10)]</em>.</p>

    <p class="text-gray-300">Since we are combining <span class="math">n</span> iterations into one, the <span class="math">R</span>-dependent precomputation stage of the pairing algorithm will now involve two sub-algorithms. Firstly, Algorithm 2 will precompute the <span class="math">(\\lambda,c)</span> and <span class="math">(\\lambda^{\\prime},c^{\\prime})</span> pairs as usual. Then, another sub-algorithm will be called to combine these pairs (which define lines <span class="math">g(x,y)=y+\\lambda x+c</span>), combining <span class="math">n</span> at a time into products of the form in (2), the degrees of which are described in (3). Since this sub-algorithm deals with <span class="math">n</span> of the <span class="math">\\lfloor\\log_{2}(m)\\rfloor</span> standard Miller iterations at a time, it will involve <span class="math">\\lfloor\\log_{2^{n}}(m)\\rfloor</span> iterations.</p>

    <p class="text-gray-300">For exactly the same reason, the modified <span class="math">S</span>-dependent evaluation stage of the pairing algorithm will now also involve <span class="math">\\lfloor\\log_{2^{n}}(m)\\rfloor</span> iterations. We now turn to determining the cost of each of these dynamic iterations. Each of the <span class="math">G_{n(i)}</span> takes the form <span class="math">G_{n(i)}(x,y)=f_{n(i)}(x)+g_{n(i)}(x)y</span>, containing <span class="math">\\deg(f_{n})+1+\\deg(g_{n})=2\\cdot\\deg(f_{n})=6\\cdot(2^{n-1}-1)+2</span> non-trivial coefficients, since <span class="math">g_{n}</span> is monic. Thus, for each <span class="math">1\\leq i\\leq\\lfloor\\log_{2^{n}}(m)\\rfloor</span>, we must store <span class="math">6\\cdot(2^{n-1}-1)+2</span> elements in <span class="math">\\mathbb{F}_{p^{n}}</span>. Apart from the constant term of <span class="math">f_{n(i)}(x)</span>, every one of these <span class="math">6\\cdot(2^{n-1}-1)+2</span> non-trivial coefficients is multiplied by a product of the coordinates of <span class="math">S</span>, each multiplication of which costs <span class="math">\\epsilon\\mathbf{m}_{1}</span>. Thus, the cost of evaluating <span class="math">G_{n(i)}</span> at <span class="math">S</span> is <span class="math">[6\\cdot(2^{n-1}-1)+1]\\epsilon\\mathbf{m}_{1}</span>. We summarize the <span class="math">S</span>-dependent “per-iteration” costs in Table 2. Importantly, we note that each of the <span class="math">n</span>-at-a-time iterations will also involve <span class="math">n</span> squarings of the Miller function <span class="math">f</span>, as well as one (rather than <span class="math">n</span>) multiplication of <span class="math">f</span> by <span class="math">G(S)</span> (see <em>[14, 15]</em>). For <span class="math">n&gt;1</span>, this multiplication becomes a general full extension field multiplication <span class="math">\\mathbf{m}_{k}</span>, rather than the <span class="math">\\mathbf{\\tilde{m}}_{k}</span> that is reported for <span class="math">n=1</span>, since <span class="math">G(S)</span> is no longer sparse.</p>

    <p class="text-gray-300">Each of the <span class="math">\\lfloor\\log_{2^{n}}(m)\\rfloor</span> iterations requires the computation of <span class="math">f_{n(1)}(S_{x})</span> and <span class="math">g_{n(1)}(S_{x})\\cdot S_{y}</span>. Thus, each iterate requires the same products of <span class="math">S_{x}^{i}</span> and <span class="math">S_{x}^{j}S_{y}</span>, where <span class="math">2\\leq i\\leq\\deg(f_{n})</span> and <span class="math">1\\leq j\\leq\\deg(g_{n})</span>, and these products, which are dependent on the dynamic input, are precomputed before the first iteration. We use the term precomputed here carefully, since these <span class="math">S</span>-dependent precomputations are not to be confused with the <span class="math">R</span>-dependent precomputations that don’t contribute to the complexity at runtime. Where possible, we would like to use field squarings to determine the <span class="math">S_{x}^{i}</span> and <span class="math">S_{x}^{j}S_{y}</span> terms, rather than the slightly more expensive field multiplications. We can compute the <span class="math">S_{x}^{i}</span> terms, which range from <span class="math">S_{x}^{2}</span> to <span class="math">S_{x}^{\\deg(f_{n})}</span>, where <span class="math">2\\leq i\\leq 2^{\\lfloor\\log_{2}(\\deg(f_{n}))\\rfloor}</span>, using one field squaring each (cf. <em>[14, §5.2]</em>). The remaining <span class="math">S_{x}^{i}</span> terms, where <span class="math">i&gt;2^{\\lfloor\\log_{2}(\\deg(f_{n}))\\rfloor}</span>, are computed using <span class="math">(\\deg(f_{n})-2^{\\lfloor\\log_{2}(\\deg(f_{n}))\\rfloor})</span> field multiplications. These multiplications and squarings occur in the field <span class="math">\\mathbb{F}_{p^{v}}</span>, so that the total dynamic cost of obtaining <span class="math">S_{x}^{i}</span> for <span class="math">2\\leq i\\leq\\deg(f_{n})</span> is</p>

    <p class="text-gray-300"><span class="math">(2^{\\lfloor\\log_{2}(\\deg(f_{n}))\\rfloor}-1)\\mathbf{s}_{v}+(\\deg(f_{n})-2^{\\lfloor\\log_{2}(\\deg(f_{n}))\\rfloor})\\mathbf{m}_{v}.</span></p>

    <p class="text-gray-300">To compute the <span class="math">S_{x}^{j}S_{y}</span> products, where <span class="math">1\\leq j\\leq\\deg(g_{n})</span>, we require <span class="math">\\deg(g_{n})</span> multiplications since we already have all of the <span class="math">S_{x}^{j}</span>. Each of these multiplications occur in <span class="math">\\mathbb{F}_{p^{v}}</span>, so that the total cost of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Iterations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R-dependent values</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Storage ∈ Fpn</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-dependent computations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dynamic costs</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">coefficients of fn(1), gn(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">6(2n-1-1) +2</td>

            <td class="px-3 py-2 border-b border-gray-700">fn(1)(S), gn(1)(S) f←f2n</td>

            <td class="px-3 py-2 border-b border-gray-700">(6(2n-1-1) + 1)εm1 nsk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">f←f·G(S)</td>

            <td class="px-3 py-2 border-b border-gray-700">mk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n+1</td>

            <td class="px-3 py-2 border-b border-gray-700">coefficients of fn(2), gn(2)</td>

            <td class="px-3 py-2 border-b border-gray-700">6(2n-1-1) +2</td>

            <td class="px-3 py-2 border-b border-gray-700">fn(2)(S), gn(2)(S) f←f2n</td>

            <td class="px-3 py-2 border-b border-gray-700">(6(2n-1-1) + 1)εm1 nsk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">f←f·G(S)</td>

            <td class="px-3 py-2 border-b border-gray-700">mk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2n |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">f←f·G(S)</td>

            <td class="px-3 py-2 border-b border-gray-700">mk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (i+1)n |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. The complexity of  <span class="math">S</span> -dependent computations and storage requirements for  <span class="math">n</span>  combined iterations</p>

    <p class="text-gray-300">the  <span class="math">S</span> -dependent precomputation is given by adding  <span class="math">\\deg(g_n)\\mathbf{m}_v = (\\deg(f_n) - 1)\\mathbf{m}_v</span>  to the previous cost, giving</p>

    <div class="my-4 text-center"><span class="math-block">(2 ^ {\\lfloor \\log_ {2} (\\deg (f _ {n})) \\rfloor} - 1) \\mathbf {s} _ {v} + (2 \\cdot \\deg (f _ {n}) - 2 ^ {\\lfloor \\log_ {2} (\\deg (f _ {n})) \\rfloor} - 1) \\mathbf {m} _ {v}.</span></div>

    <p class="text-gray-300">Substituting  <span class="math">\\deg(f_n) = 3(2^{n-1} - 1) + 1</span>  (from (3)) into the above equation requires the evaluation of  <span class="math">2^{\\lfloor \\log_2(3(2^{n-1} - 1) + 1) \\rfloor}</span> . To simplify this expression we rewrite the index as  <span class="math">\\lfloor \\log_2(2^n + 2^{n-1} - 2) \\rfloor = n</span> , so that the total number of  <span class="math">S</span> -dependent computations simplifies to</p>

    <div class="my-4 text-center"><span class="math-block">(2 ^ {n} - 1) \\mathbf {s} _ {v} + (2 ^ {n + 1} - 5) \\mathbf {m} _ {v}. \\tag {4}</span></div>

    <p class="text-gray-300">From Table 2, each of the iterations costs  <span class="math">\\left([6\\cdot (2^{n - 1} - 1) + 2]\\epsilon \\mathbf{m}_1 + n\\mathbf{s}_k + \\mathbf{m}_k\\right)</span> . Summing this cost over the  <span class="math">\\lfloor \\log_{2^n}(m)\\rfloor</span>  iterations, and adding the  <span class="math">S</span> -dependent precomputation in (4), gives the total  <span class="math">S</span> -dependent computation complexity as</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\lfloor \\log_ {2 ^ {n}} (m) \\right\\rfloor \\left(\\left[ 6 \\cdot \\left(2 ^ {n - 1} - 1\\right) + 1 \\right] \\epsilon \\mathbf {m} _ {1} + n \\mathbf {s} _ {k} + \\mathbf {m} _ {k}\\right) + \\left(2 ^ {n} - 1\\right) \\mathbf {s} _ {v} + \\left(2 ^ {n + 1} - 5\\right) \\mathbf {m} _ {v}. \\tag {5}</span></div>

    <p class="text-gray-300">We summarize the total storage and the total costs for all  <span class="math">n</span>  in Table 3. Once more, we reiterate that the total complexity is independent of the field containing the first argument,  <span class="math">\\mathbb{F}_{p^n}</span> , and is only dependent on the field containing the second argument,  <span class="math">\\mathbb{F}_{p^c}</span> . Interestingly, this means that even if the ate and Tate pairings had equal loop lengths, a fixed argument ate pairing ( <span class="math">v = 1</span> ) will still perform faster than a fixed argument Tate pairing ( <span class="math">v = e</span> ) in general. As far as storage goes, the ate pairing will require storing values in the field  <span class="math">\\mathbb{F}_{p^c}</span> , whilst the Tate pairing will store values in the base field  <span class="math">\\mathbb{F}_p</span> . However, because of the shorter loop lengths achieved in the ate pairing, the total storage needed in the ate pairing may still end up being less than for the Tate pairing. Unlike the speedups achieved in [14] and [15] which mainly benefit the Tate pairing, it is clear that our techniques will also speed up the ate pairing when a fixed argument can be exploited. In the next section, we use the complexities in Table 3 to determine the optimal amount of precomputation for implementations over various embedding degrees.</p>

    <p class="text-gray-300">With the ultimate goal of minimizing the dynamic computations incurred in a pairing with a fixed argument, we use the total complexities for the Miller loop in Table 3 to determine the best value of  <span class="math">n</span>  for both the Tate and ate pairings at different security levels. In Table 4, we summarize our results for a variety of common security levels (taken from [20]) and embedding degrees, for both the Tate and ate pairings. At each security level, we list:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Storage ∈ Fpn</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-dependent costs</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2[log2m]</td>

            <td class="px-3 py-2 border-b border-gray-700">log2(m)(e m1 + sk + mk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≥ 2</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n m (6(2n-1-1) + 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n (m) ((6(2n-1-1) + 1)e m1 + nsk + mk) + (2n-1)sv + (2n+1-5)mv</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the optimal <span class="math">^2</span>  length of the Miller loop ( <span class="math">m_{\\mathrm{Tate}}</span>  and  <span class="math">m_{\\mathrm{ate}}</span> , respectively) for both pairings (taken from [17]).</li>

      <li>the optimal value of  <span class="math">n</span> , the number of iterations to merge, based on the analysis in Section 4;</li>

      <li>the overall cost of  <span class="math">S</span> -dependent dynamic Miller loop doubling operations in terms of base field  <span class="math">(\\mathbb{F}_p)</span>  multiplications, assuming that  <span class="math">\\mathbf{s}_1 = 0.8\\mathbf{m}_1</span> , and counting multiplications in fields with extension degrees of the form  <span class="math">k = 2^i 3^j</span> , as  <span class="math">\\mathbf{m}_k = 3^i 5^j\\mathbf{m}_1</span>  (cf. [30]);</li>

      <li>the percentage reductions in Miller loop operations between an optimal  <span class="math">n</span>  implementation (this paper) and (i) the previous precomputation methods [42] (which correspond to  <span class="math">n = 1</span>  herein), (ii) no precomputation, but with optimal delayed multiplications [14].</li>

    </ul>

    <p class="text-gray-300">We point out that these percentage speedups are based on the computation of the Miller loop only, and do not take into account the fixed cost of the final exponentation, so that the relative speedups for the entire pairing computation will be less than those reported in Table 4.</p>

    <p class="text-gray-300">Table 3. The total storage requirements and  <span class="math">S</span>  -dependent complexity for a fixed argument pairing</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bestρ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fp(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fpe(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fpk(bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pairing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#m1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">% Speedup pre.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">no pre.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.000</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">1920</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1843</td>

            <td class="px-3 py-2 border-b border-gray-700">7.8</td>

            <td class="px-3 py-2 border-b border-gray-700">37.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1846</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7</td>

            <td class="px-3 py-2 border-b border-gray-700">37.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.500</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">1920</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">5069</td>

            <td class="px-3 py-2 border-b border-gray-700">11.2</td>

            <td class="px-3 py-2 border-b border-gray-700">30.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">5058</td>

            <td class="px-3 py-2 border-b border-gray-700">11.4</td>

            <td class="px-3 py-2 border-b border-gray-700">30.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1.000</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">2688</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">7308</td>

            <td class="px-3 py-2 border-b border-gray-700">11.8</td>

            <td class="px-3 py-2 border-b border-gray-700">29.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3646</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

            <td class="px-3 py-2 border-b border-gray-700">29.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">1.250</td>

            <td class="px-3 py-2 border-b border-gray-700">280</td>

            <td class="px-3 py-2 border-b border-gray-700">1120</td>

            <td class="px-3 py-2 border-b border-gray-700">4480</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">13460</td>

            <td class="px-3 py-2 border-b border-gray-700">14.6</td>

            <td class="px-3 py-2 border-b border-gray-700">25.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3346</td>

            <td class="px-3 py-2 border-b border-gray-700">15.1</td>

            <td class="px-3 py-2 border-b border-gray-700">26.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1.000</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">3072</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8263</td>

            <td class="px-3 py-2 border-b border-gray-700">12.7</td>

            <td class="px-3 py-2 border-b border-gray-700">30.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4198</td>

            <td class="px-3 py-2 border-b border-gray-700">11.3</td>

            <td class="px-3 py-2 border-b border-gray-700">29.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">1.250</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">1280</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">15368</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">26.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3823</td>

            <td class="px-3 py-2 border-b border-gray-700">15.1</td>

            <td class="px-3 py-2 border-b border-gray-700">26.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">1.333</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">1026</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">13590</td>

            <td class="px-3 py-2 border-b border-gray-700">13.6</td>

            <td class="px-3 py-2 border-b border-gray-700">28.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4697</td>

            <td class="px-3 py-2 border-b border-gray-700">11.1</td>

            <td class="px-3 py-2 border-b border-gray-700">26.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">1.333</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">1536</td>

            <td class="px-3 py-2 border-b border-gray-700">6912</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">20173</td>

            <td class="px-3 py-2 border-b border-gray-700">14.2</td>

            <td class="px-3 py-2 border-b border-gray-700">29.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6881</td>

            <td class="px-3 py-2 border-b border-gray-700">12.5</td>

            <td class="px-3 py-2 border-b border-gray-700">27.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.250</td>

            <td class="px-3 py-2 border-b border-gray-700">478</td>

            <td class="px-3 py-2 border-b border-gray-700">1912</td>

            <td class="px-3 py-2 border-b border-gray-700">9216</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">34540</td>

            <td class="px-3 py-2 border-b border-gray-700">18.2</td>

            <td class="px-3 py-2 border-b border-gray-700">30.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8577</td>

            <td class="px-3 py-2 border-b border-gray-700">18.7</td>

            <td class="px-3 py-2 border-b border-gray-700">30.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.125</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">4608</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">87876</td>

            <td class="px-3 py-2 border-b border-gray-700">17.9</td>

            <td class="px-3 py-2 border-b border-gray-700">25.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">10777</td>

            <td class="px-3 py-2 border-b border-gray-700">19.5</td>

            <td class="px-3 py-2 border-b border-gray-700">27.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">1.167</td>

            <td class="px-3 py-2 border-b border-gray-700">598</td>

            <td class="px-3 py-2 border-b border-gray-700">3588</td>

            <td class="px-3 py-2 border-b border-gray-700">18432</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">102960</td>

            <td class="px-3 py-2 border-b border-gray-700">18.2</td>

            <td class="px-3 py-2 border-b border-gray-700">29.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">13202</td>

            <td class="px-3 py-2 border-b border-gray-700">16.1</td>

            <td class="px-3 py-2 border-b border-gray-700">27.7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. The optimal number of iterations to merge  <span class="math">(n)</span> , the resulting  <span class="math">S</span> -dependent base field operation counts  <span class="math">(\\# \\mathbf{m}_1)</span> , and the percentage speedup compared to previous precomputation (pre.) [42] and no precomputation (no pre.) techniques, for a variety of security levels and embedding degrees  <span class="math">(k)</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Tate and ate pairing multiplication vs. storage costs with  <span class="math">r = 256</span>  and  <span class="math">k = 12</span>  for various  <span class="math">n</span> . Fig. 1.  <span class="math">S</span> -dependent costs for various  <span class="math">n</span>  values for the Tate and ate pairings.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) Tate pairing multiplication costs with different  <span class="math">r</span>  and  <span class="math">k</span>  for various  <span class="math">n</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c) ate pairing multiplication costs with different  <span class="math">r</span>  and  <span class="math">k</span>  for various  <span class="math">n</span> .</p>

    <p class="text-gray-300">In Figure 1(a), we show the operation count (in terms of number of base field multiplications) for the entire  <span class="math">S</span> -dependent dynamic Miller loop doubling operations in the Tate and ate pairings for a curve with  <span class="math">r = 256</span>  and  <span class="math">k = 12</span>  based on the analysis in Section 4, as well as the precomputation storage costs in terms of number of base field elements, for various amounts of precomputation;  <span class="math">n = 0</span>  corresponds to no precomputation, while  <span class="math">n \\geq 1</span>  corresponds to the complexity from Table 3. The optimal amount of precomputation for this case occurs at  <span class="math">n = 3</span> , at which point the precomputation storage costs are 860 base field elements, which is not too prohibitive for many applications.</p>

    <p class="text-gray-300">Figure 1(b) shows the base field multiplication costs for the  <span class="math">S</span> -dependent dynamic Miller loop doubling operations in a Tate pairing for a variety of subgroup sizes and embedding degrees based on the amount  <span class="math">(n)</span>  of precomputation. With the exception of the  <span class="math">r = 160</span>  case, the optimal  <span class="math">n</span>  is 3, meaning for those cases we should use precomputation to merge 3 iterations of the Miller loop at a time, as described in Section 4. Figure 1(c) shows the same costs in an ate pairing.</p>

    <p class="text-gray-300">There are many pairing-based cryptosystems that can benefit from precomputation when one of the arguments is fixed. In Table 5, we have listed some pairing-based cryptosystems that have fixed arguments and hence which can benefit from the improvements in this paper.</p>

    <p class="text-gray-300">In some cases, such as the Boneh-Franklin identity-based encryption scheme [9] or the Chen-Kudla identity-based key agreement protocol [13], one party computes a pairing where the first argument is fixed while the other party computes a pairing where the second argument is fixed; here, our technique can only be applied to speed up one party's pairing computation.</p>

    <p class="text-gray-300">In others cases, such as the McCullagh-Barreto identity based key agreement protocol [33], the two parties employing the cryptosystem can both benefit because they each compute pairings where the fixed value appears in the same argument of the pairing. Our speed-up is also applicable to attribute-based encryption schemes such as those of Goyal et al. [24, §4] and Lewko et al. [31,</p>

    <p class="text-gray-300"><span class="math">\\S 2]</span>  which perform a large number of pairings (one or two for each attribute used in decryption), as in these schemes the second arguments in all these pairing computations are long-term values (fixed across multiple runs of the protocol, though not all identical within a single run of the protocol).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># pairings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fixed arguments</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># pairings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fixed arguments</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Public key encryption</td>

            <td class="px-3 py-2 border-b border-gray-700">Encryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Decryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Boyen-Mei-Waters [12]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ID-based encryption</td>

            <td class="px-3 py-2 border-b border-gray-700">Encryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Decryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Boneh-Franklin [9]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1st</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Boneh-Boyen [7]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Waters [47]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">both in 2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Attribute-based encr.</td>

            <td class="px-3 py-2 border-b border-gray-700">Encryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Decryption</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GPSW [24, §4]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ #attr.</td>

            <td class="px-3 py-2 border-b border-gray-700">all in 1st</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LOSTW [31, §2]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2 · #attr.</td>

            <td class="px-3 py-2 border-b border-gray-700">all in 2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ID-based signatures</td>

            <td class="px-3 py-2 border-b border-gray-700">Signing</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verification</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Waters [47]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 in 2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ID-based key exchange</td>

            <td class="px-3 py-2 border-b border-gray-700">Initiator</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Responder</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Smart-1 [45]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 in 1st, 1 in 2nd</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 in 1st, 1 in 2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chen-Kudla [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1st</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">McCullagh-Barreto [33]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2nd</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Fixed arguments in various pairing-based cryptosystems.</p>

    <p class="text-gray-300">We have shown how using precomputation to merge iterations of the Miller loop in Tate and ate pairings can reduce the cost of the dynamic running time when computing a pairing with one fixed argument and one dynamic argument. This improves the runtime cost by between  <span class="math">25\\%</span>  and  <span class="math">37\\%</span>  when compared to a pairing computation with no precomputation, and up to  <span class="math">19.5\\%</span>  when compared to previous precomputation techniques. While the precomputation stage is somewhat expensive compared to the cost of pairing computation, it can still be run quite quickly (in a few seconds or less) on modern computers, and the amount of precomputation storage required is not prohibitive for many settings. Given the wide variety of pairing-based cryptosystems where one argument (say, a long-term private key or system parameter) is fixed across many protocol runs, we believe our techniques have wide applicability.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Aranha, D.F., López, J., Hankerson, D.: High-speed parallel software implementation of the  <span class="math">\\eta_T</span>  pairing. In: Pieprzyk, J. (ed.) Topics in Cryptology - CT-RSA 2010. Lecture Notes in Computer Science, vol. 5985, pp. 89-105. Springer (2010)</li>

      <li>Arene, C., Lange, T., Naehrig, M., Ritzenthaler, C.: Faster pairing computation. Cryptology ePrint Archive, Report 2009/155 (2009)</li>

      <li>Barreto, P.S.L.M., Galbraith, S.D., O'Eigeartaigh, C., Scott, M.: Efficient pairing computation on supersingular abelian varieties. Designs, Codes and Cryptography 42(3), 239-271 (2007)</li>

      <li>Barreto, P.S.L.M., Kim, H.Y., Lynn, B., Scott, M.: Efficient algorithms for pairing-based cryptosystems. In: Yung, M. (ed.) Advances in Cryptology - Proc. CRYPTO 2002. Lecture Notes in Computer Science, vol. 2442, pp. 354-368. Springer (2002)</li>

      <li>Barreto, P.S.L.M., Lynn, B., Scott, M.: Efficient implementation of pairing-based cryptosystems. J. Cryptology 17(4), 321-334 (2004)</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[6] Benger, N., Scott, M.: Constructing tower extensions for the implementation of pairing-based cryptography. In: Hasan and Helleseth <em>[26]</em></li>

      <li>[7] Boneh, D., Boyen, X.: Efficient selective-ID secure identity-based encryption without random oracles. In: Cachin, C., Camenisch, J. (eds.) Advances in Cryptology – Proc. EUROCRYPT 2004. Lecture Notes in Computer Science, vol. 3027, pp. 223–238. Springer (2004)</li>

      <li>[8] Boneh, D., Boyen, X., Shacham, H.: Short group signatures. In: Franklin <em>[19]</em>, pp. 41–55</li>

      <li>[9] Boneh, D., Franklin, M.: Identity-based encryption from the Weil pairing. In: Kilian, J. (ed.) Advances in Cryptology – Proc. CRYPTO 2001. Lecture Notes in Computer Science, vol. 2139, pp. 213–229. Springer (2001)</li>

      <li>[10] Boneh, D., Gentry, C., Lynn, B., Shacham, H.: Aggregate and verifiably encrypted signatures from bilinear maps. In: Biham, E. (ed.) Advances in Cryptology – Proc. EUROCRYPT 2003. Lecture Notes in Computer Science, vol. 2656, pp. 416–432. Springer (2003)</li>

      <li>[11] Boneh, D., Lynn, B., Shacham, H.: Short signatures from the Weil pairing. J. Cryptology 17(4), 297–319 (2004)</li>

      <li>[12] Boyen, X., Mei, Q., Waters, B.: Direct chosen ciphertext security from identity-based techniques. In: Meadows, C., Syverson, P. (eds.) Proc. 12th ACM Conference on Computer and Communications Security (CCS). pp. 320–329. ACM (2005)</li>

      <li>[13] Chen, L., Kudla, C.: Identity based authenticated key agreement protocols from pairings. In: Proceedings 16th IEEE Computer Security Foundations Workshop (CSWF-16). pp. 219–233. IEEE (2003)</li>

      <li>[14] Costello, C., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Avoiding full extension field arithmetic in pairing computations. In: Progress in Cryptology – Proc. AFRICACRYPT 2010. Lecture Notes in Computer Science, Springer (2010)</li>

      <li>[15] Costello, C., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Delaying mismatched field multiplications in pairing computations. In: Hasan and Helleseth <em>[26]</em></li>

      <li>[16] Costello, C., Hisil, H., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Faster pairings on special Weierstrass curves. In: Shacham and Waters <em>[43]</em>, pp. 89–101</li>

      <li>[17] Costello, C., Lange, T., Naehrig, M.: Faster pairing computations on curves with high-degree twists. In: Nguyen, P.Q., Pointcheval, D. (eds.) Public Key Cryptography (PKC) 2010. Lecture Notes in Computer Science, vol. 6056, pp. 224–242. Springer (2010)</li>

      <li>[18] Devegili, A.J., Scott, M., Dahab, R.: Implementing cryptographic pairings over Barreto-Naehrig curves. In: Takagi, T., Okamoto, T., Okamoto, E., Okamoto, T. (eds.) Pairing-Based Cryptography – Pairing 2007. Lecture Notes in Computer Science, vol. 4575, pp. 197–207. Springer (2007)</li>

      <li>[19] Franklin, M.K. (ed.): Advances in Cryptology – Proc. CRYPTO 2004, Lecture Notes in Computer Science, vol. 3152. Springer (2004)</li>

      <li>[20] Freeman, D., Scott, M., Teske, E.: A taxonomy of pairing-friendly elliptic curves. J. Cryptology 23(2), 224–280 (2010)</li>

      <li>[21] Galbraith, S.D.: Supersingular curves in cryptography. In: Boyd, C. (ed.) Advances in Cryptology – Proc. ASIACRYPT 2001. Lecture Notes in Computer Science, vol. 2248, pp. 495–513. Springer (2001)</li>

      <li>[22] Galbraith, S.D., Harrison, K., Soldera, D.: Implementing the Tate pairing. In: Fieker, C., Kohel, D.R. (eds.) Proc. Algorithmic Number Theory 6th International Symposium (ANTS) 2002. Lecture Notes in Computer Science, vol. 2369, pp. 324–337. Springer (2002)</li>

      <li>[23] Gentry, C., Silverberg, A.: Hierarchical ID-based cryptography. In: Zheng, Y. (ed.) Advances in Cryptology – Proc. ASIACRYPT 2002. Lecture Notes in Computer Science, vol. 2501, pp. 548–566. Springer (2002)</li>

      <li>[24] Goyal, V., Pandey, O., Sahai, A., Waters, B.: Attribute-based encryption for fine-grained access control of encrypted data. In: Wright, R., De Capitani de Vimercati, S., Shmatikov, V. (eds.) Proc. 13th ACM Conference on Computer and Communications Security (CCS). pp. 89–98. ACM (2006)</li>

      <li>[25] Hankerson, D., Menezes, A.J., Scott, M.: Software implementation of pairings. In: Joye, M., Neven, G. (eds.) Identity-Based Cryptography. pp. 188–206. IOS Press (2008)</li>

      <li>[26] Hasan, A., Helleseth, T. (eds.): International Workshop on the Arithmetic of Finite Fields (WAIFI) 2010. Lecture Notes in Computer Science, Springer (2010)</li>

      <li>[27] Hess, F.: Pairing lattices. In: Galbraith, S.D., Paterson, K.G. (eds.) Pairing-Based Cryptography – Pairing 2008. Lecture Notes in Computer Science, vol. 5209, pp. 18–38. Springer (2008)</li>

      <li>[28] Hess, F., Smart, N.P., Vercauteren, F.: The eta pairing revisited. IEEE Transactions on Information Theory 52(10), 4595–4602 (2006)</li>

      <li>[29] Joux, A.: A one round protocol for tripartite Diffie-Hellman. In: Bosma, W. (ed.) Proc. Algorithmic Number Theory 5th International Symposium (ANTS) 2000. Lecture Notes in Computer Science, vol. 1838, pp. 385–394. Springer (2000)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[30] Koblitz, N., Menezes, A.: Pairing-based cryptography at high security levels. In: Smart, N.P. (ed.) Cryptography and Coding – 10th IMA International Conference. Lecture Notes in Computer Science, vol. 3796, pp. 13–36. Springer (2005)</li>

      <li>[31] Lewko, A., Okamoto, T., Sahai, A., Takashima, K., Waters, B.: Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In: Advances in Cryptology – Proc. EUROCRYPT 2010. Lecture Notes in Computer Science, Springer (2010)</li>

      <li>[32] Matsuda, S., Kanayama, N., Hess, F., Okamoto, E.: Optimised versions of the ate and twisted ate pairings. In: Galbraith, S.D. (ed.) Cryptography and Coding – 11th IMA International Conference. Lecture Notes in Computer Science, vol. 4887, pp. 302–312. Springer (2007)</li>

      <li>[33] McCullagh, N., Barreto, P.S.: A new two-party identity-based authenticated key agreement. In: Menezes, A.J. (ed.) Topics in Cryptology — CT-RSA 2005. Lecture Notes in Computer Science, vol. 3376, pp. 262–274. Springer (2005)</li>

      <li>[34] Menezes, A.J.: Elliptic Curve Public Key Cryptosystems. Kluwer Academic Publishers (1993)</li>

      <li>[35] Miller, V.S.: The Weil pairing, and its efficient calculation. Journal of Cryptology 17, 235–261 (2004)</li>

      <li>[36] Naehrig, M., Barreto, P.S.L.M., Schwabe, P.: On compressible pairings and their computation. In: Vaudenay, S. (ed.) Progress in Cryptology – AFRICACRYPT 2008. Lecture Notes in Computer Science, vol. 5023, pp. 371–388. Springer (2008)</li>

      <li>[37] Naehrig, M., Niederhagen, R., Schwabe, P.: New software speed records for cryptographic pairings. Cryptology ePrint Archive, Report 2010/186 (2010)</li>

      <li>[38] Scott, M.: Implementing cryptographic pairings. In: Takagi, T., Okamoto, T., Okamoto, E. (eds.) Pairing-Based Cryptography – Pairing 2007. Lecture Notes in Computer Science, vol. 4575, pp. 177–196. Springer (2007)</li>

      <li>[39] Scott, M., Barreto, P.S.L.M.: Compressed pairings. In: Franklin <em>[19]</em>, pp. 140–156</li>

      <li>[40] Scott, M., Benger, N., Charlemagne, M., Perez, L.J.D., Kachisa, E.J.: Fast hashing to <span class="math">G_{2}</span> on pairing-friendly curves. In: Shacham and Waters <em>[43]</em>, pp. 102–113</li>

      <li>[41] Scott, M., Benger, N., Charlemagne, M., Perez, L.J.D., Kachisa, E.J.: On the final exponentiation for calculating pairings on ordinary elliptic curves. In: Shacham and Waters <em>[43]</em>, pp. 78–88</li>

      <li>[42] Scott, M., Costigan, N., Abdulwahab, W.: Implementing cryptographic pairings on smartcards. In: Goubin, L., Matsui, M. (eds.) Cryptographic Hardware and Embedded Systems (CHES) 2006. Lecture Notes in Computer Science, vol. 4249, pp. 134–147. Springer (2006)</li>

      <li>[43] Shacham, H., Waters, B. (eds.): Pairing-Based Cryptography – Pairing 2009, Lecture Notes in Computer Science, vol. 5671. Springer (2009)</li>

      <li>[44] Shamir, A.: Identity-based cryptosystems and signature schemes. In: Goos, G., Hartmanis, J. (eds.) Advances in Cryptology – Proc. CRYPTO 1984. Lecture Notes in Computer Science, vol. 196, pp. 47–53. Springer (1984)</li>

      <li>[45] Smart, N.P.: Identity-based authenticated key agreement protocol based on Weil pairing. Electronics Letters 38(13), 630–632 (June 2002)</li>

      <li>[46] Vercauteren, F.: Optimal pairings. IEEE Transactions on Information Theory 56(1), 455–461 (2010)</li>

      <li>[47] Waters, B.: Efficient identity-based encryption without random oracles. In: Cramer, R. (ed.) Advances in Cryptology – Proc. EUROCRYPT 2005. Lecture Notes in Computer Science, vol. 3494, pp. 114–127. Springer (2005)</li>

    </ul>`;
---

<BaseLayout title="Fixed Argument Pairings (2010/342)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/342
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
