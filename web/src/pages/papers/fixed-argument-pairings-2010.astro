---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/342';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Fixed Argument Pairings';
const AUTHORS_HTML = 'Craig Costello, Douglas Stebila';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">A common scenario in many pairing-based cryptographic protocols is that one argument in the pairing is &amp;#64257;xed as a long term secret key or a constant parameter in the system. In these situations, the runtime of Miller&rsquo;s algorithm can be signi&amp;#64257;cantly reduced by storing precomputed values that depend on the &amp;#64257;xed argument, prior to the input or existence of the second argument. In light of recent developments in pairing computation, we show that the computation of the Miller loop can be sped up by up to 37% if precomputation is employed, with our method being up to 19.5% faster than the previous precomputation  techniques.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Pairings &middot; Miller&rsquo;s algorithm &middot; Tate pairing &middot; ate pairing &middot; precomputation.</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Boneh and Franklin were among the first to present a pairing-based cryptosystem in 2001, when they exploited the powerful bilinearity property of pairings to construct the first efficient and provably secure identity-based encryption (IBE) scheme [9], answering an open question first posed by Shamir in 1984 [44]. Boneh and Franklin's discovery, alongside Joux's one round tripartite key agreement protocol [29], were major breakthroughs that gave rise to the now thriving field of pairing-based cryptography and a vast array of new pairing-based primitives that followed, including short signatures [11], hierarchical encryption [23], group signatures [8], ring signatures [10], identity-based key agreement schemes [45, 13, 33], an IBE scheme secure in the standard model [47], as well as generalizations of IBE such as attribute-based encryption [24, 31].</p>

    <p class="text-gray-300">The computation of pairings via Miller's algorithm [35] was initially too slow for them to be considered practically viable, but this did not remain the case for long. Much research has concentrated on achieving pairings at high security levels that are efficient enough for industrial applications. Although use of the Weil pairing was initially proposed, it quickly became evident that the computation of the Tate pairing was much faster in practice [9, 21, 22, 4]. A decade after their introduction into cryptosystems, the computation of a pairing has accelerated from older implementations that took a few minutes [34], to current state-of-the-art implementations that take only a few milliseconds [25, 1, 37]. Many of the avenues for improving the computation speed of cryptographic pairings on elliptic curves have been somewhat exhausted:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the Miller loop has been truncated to optimal lengths [3, 28, 32, 46, 27];</li>
      <li>improvements inside the Miller iterations, such as denominator elimination, have been thoroughly explored [4, 5];</li>
      <li>the choice of the groups G<sup>1</sup> and G<sup>2</sup> as the two eigenspaces of the Frobenius endormorphism is now standard [28, 18];</li>
      <li>there is now a flexible array of curve constructions that facilitate fast implementations [20];</li>
      <li>different elliptic curve representations and coordinates systems have been explored in efforts to reduce the field operations encountered when computing the Miller functions [2, 16, 17]; and</li>
      <li>many other improvements have become standard in optimal or restricted implementations, such as compressed pairings [39, 36], optimized field constructions [30, 6], fast hashing [40], and fast final exponentiation [41] techniques.</li>
    </ul>

    <p class="text-gray-300"><sup>?</sup> The first author acknowledges funding from the Queensland Government Smart State PhD Scholarship.</p>

    <p class="text-gray-300">While these techniques have allowed for relatively fast implementations of pairings, there are still some possible improvements that are yet to be explored to their full potential. In this paper we explore one such technique: the implementation of pairings with one argument fixed, which allow for improvements in runtime performance based on precomputations. In the pairing e(R, S) of two points R and S on an elliptic curve, we call the argument R fixed if it is constant in terms of the corresponding protocol that employs the pairing, for example, R is a long-term private key that is &quot;paired&quot; with ephemeral or dynamic values (different S values) at runtime.</p>

    <p class="text-gray-300">Scott [38] was the first to comment on the possibility of exploiting the nature of a fixed argument R, suggesting to precompute all multiples of the point R required in the Miller loop. Scott et al. [42] took this idea further by also precomputing the gradients,  <span class="math">\\lambda_i</span> , of each of the line functions that arise in the Miller iterations, since these are also values depending solely on the first argument R. Essentially, this means that the coefficients of the affine Miller functions have been computed in advance and are just &quot;waiting&quot; as indeterminate functions until S is known, so that they can be evaluated and used to update the Miller function.</p>

    <p class="text-gray-300">We adopt this same approach by performing all computations that are solely dependent on the fixed argument R, and storing these before the second argument S is available. Since R-dependent computations can be performed once only and stored in the long term, it is only the subsequent S-dependent computations that affect the runtime of the pairing algorithm. The question that we address in this paper arises naturally: are there further R-dependent (pre)computations that can be done to reduce the workload encountered when the dynamic second argument S is known?</p>

    <p class="text-gray-300">In light of recent developments in pairing computation [14,15], we address this question by considering another: is it computationally cheaper to evaluate a function before operating on its result, or can it be advantageous to operate on the indeterminate function before evaluating it?</p>

    <p class="text-gray-300">When neither of the pairing arguments are fixed, the results in [14] and [15] show that many cases of pairing implementations favour the latter. In the case of fixed argument pairings, this becomes even more evident when we observe that any computations on the indeterminate Miller functions are entirely R-dependent and can be done in advance. We show that for both the Tate and ate pairings, the Miller loop can be computed with between 25 and 37% fewer field multiplications (or squarings) if an optimal amount of precomputation is performed in the fixed argument, compared to the case when no precomputation is performed.</p>

    <p class="text-gray-300">The rest of this paper is organized as follows. In Section 2, we present background information on computing pairings using Miller's algorithm. In Section 3, we separate the R-dependent precomputations from the S-dependent dynamic computations in preparation for Section 4, where we present our main technical innovation: we show how to merge multiple iterations of the loop in Miller's algorithm in the precomputation stage to reduce the cost of the S-dependent computations. Section 5 presents the optimal number of iterations to merge for various security levels, and Section 6 lists a number of cryptosystems which can benefit from our techniques. We conclude in Section 7.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Let E be an elliptic curve defined over a large prime field  <span class="math">\\mathbb{F}_p</span>  which is given by the short Weierstrass equation  <span class="math">E: y^2 = x^3 + ax + b</span> , the identity element of which is denoted by  <span class="math">\\mathcal{O}</span> . Let r be a large prime and let E[r] be the group of points with order r (the r-torsion) on E. Let k &gt; 1 be the smallest integer such that  <span class="math">r \\mid p^k - 1</span> ; we call k the embedding degree. Let  <span class="math">\\pi_p</span>  be the p-power Frobenius endormorphism on E. The two eigenspaces of  <span class="math">\\pi_p</span> , restricted to the r-torsion on E, form two linearly independent groups of order r, written as  <span class="math">\\mathbb{G}_1 = E[r] \\cap \\ker(\\pi_p - [1])</span>  and  <span class="math">\\mathbb{G}_2 = E[r] \\cap \\ker(\\pi_p - [p])</span> . The group  <span class="math">\\mathbb{G}_1</span>  is defined over the base field  <span class="math">\\mathbb{F}_p</span> , whilst the group  <span class="math">\\mathbb{G}_2</span>  is defined over the full extension field  <span class="math">\\mathbb{F}_{p^k}</span> .</p>

    <p class="text-gray-300">A bilinear pairing e of two points  <span class="math">R, S \\in E</span>  can be computed as</p>

    <p class="text-gray-300"><span class="math">$e(R,S) = f_{m,R}(S)^{(p^k-1)/r},</span>$</p>

    <p class="text-gray-300">where  <span class="math">m \\in \\mathbb{Z}</span> , and  <span class="math">f_{m,R}</span>  is a function with divisor  <span class="math">\\operatorname{div}(f_{m,R}) = m(R) - ([m]R) - (m-1)(\\mathcal{O})</span> . For our purposes, k will always be even, which allows us to write the function  <span class="math">f_{m,R}</span>  as a polynomial in x and y so that  <span class="math">f_{m,R}(x,y)</span>  is evaluated at the coordinates of the point S when the pairing is computed. For the Tate pairing, the first argument R comes from  <span class="math">\\mathbb{G}_1</span>  and the second argument S comes from  <span class="math">\\mathbb{G}_2</span> , whilst the ate pairing takes  <span class="math">R \\in \\mathbb{G}_2</span>  and  <span class="math">S \\in \\mathbb{G}_1</span> . In either case, the function  <span class="math">f_{m,R}(S)</span>  evaluates as an element of the finite field  <span class="math">\\mathbb{F}_{p^k}</span> , and this value is raised to the power  <span class="math">(p^k-1)/r</span>  in the &quot;final exponentiation&quot; stage. The function  <span class="math">f_{m,R}</span>  is called the <em>Miller function</em>, since it is constructed in a double-and-add like fashion using Miller's algorithm, which is described in Algorithm 1.</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Algorithm 1 Miller's affine double-and-add algorithm with denominator elimination</h3>

    <pre><code class="language-text">Input: R = (x_R, y_R), S = (x_S, y_S), m = (m_{l-1}...m_1, m_0)_2.
Output: f_{m,R}(S) \\leftarrow f.
 1: T \\leftarrow R, f \\leftarrow 1.
 2: for i from l-2 to 0 do
           Compute g(x,y) = y - y_T + \\lambda(x_T - x), where \\lambda is the gradient of the tangent line to T.
 4:
           T \\leftarrow [2]T = [2](x_T, y_T).
           g \\leftarrow g(x_S, y_S).
 5:
           f \\leftarrow f^2 \\cdot g.
 6:
           if m_i \\neq 0 then
 7:
                 Compute g(x,y) = y - y_T + \\lambda(x_T - x), where \\lambda is the gradient of the line joining T and R.
 8:
 9:
10:
                 g \\leftarrow g(x_S, y_S).
11:
                  f \\leftarrow f \\cdot g.
12:
           end if
13: end for
14: return f.
</code></pre>

    <p class="text-gray-300">If we were to discard lines 5 and 10 of Algorithm 1, the output would be an indeterminate function  <span class="math">f_{m,R}(x,y)</span>  of degree m, rather than a field element  <span class="math">f_{m,R}(x_S,y_S) \\in \\mathbb{F}_{p^k}</span> . The reason we include lines 5 and 10 and evaluate the intermediate functions in each iteration is because m is usually quite large (for example, no smaller than  <span class="math">2^{20}</span> ), and storing so many coefficients is infeasible; memory constraints force us to evaluate the g functions as we go.</p>

    <p class="text-gray-300">Modern pairing implementations make use of the twisted curve E' of E, to define a group  <span class="math">\\mathbb{G}_2&#x27; \\in E&#x27;</span>  that is isomorphic to  <span class="math">\\mathbb{G}_2 \\in E</span> , but is defined over a smaller subfield  <span class="math">\\mathbb{F}_{p^e}</span>  of  <span class="math">\\mathbb{F}_{p^k}</span> . We let  <span class="math">\\psi : E&#x27; \\to E</span>  be the twisting isomorphism from E' to E, so that  <span class="math">\\psi(\\mathbb{G}_2&#x27;) = \\mathbb{G}_2</span> . A point  <span class="math">P \\in \\mathbb{G}_2</span>  is usually written as  <span class="math">P = P&#x27; \\cdot \\alpha</span> , where  <span class="math">P&#x27; \\in \\mathbb{G}_2&#x27;</span>  is defined over  <span class="math">\\mathbb{F}_{p^e}</span>  and  <span class="math">\\alpha</span>  is an algebraic element used in the twisting isomorphism (cf. [28, 17]). In both the Tate and ate pairings, such points in  <span class="math">\\mathbb{G}_2</span>  are often multiplied by elements in the base field  <span class="math">\\mathbb{F}_p</span> , and because of the representation of  <span class="math">\\mathbb{G}_2</span>  over the twisted curve, these multiplications are counted as e multiplications in the base field.</p>

    <p class="text-gray-300">To count field multiplications and squarings across the different fields employed in pairing computations, we use  <span class="math">\\mathbf{m}_i</span>  and  <span class="math">\\mathbf{s}_i</span>  to respectively denote a multiplication and a squaring in the field  <span class="math">\\mathbb{F}_{p^i}</span> . We maintain generality (across both Tate and ate like pairings) by assuming that the first argument R is written as an element of  <span class="math">\\mathbb{F}_{p^u}</span>  and that the second argument S is written as an element of  <span class="math">\\mathbb{F}_{p^v}</span> , where it is understood that the Tate pairing has (u, v) = (1, e) and that the ate pairing has (u, v) = (e, 1). In both cases, the argument defined over  <span class="math">\\mathbb{F}_{p^k}</span>  is actually treated as an element of  <span class="math">\\mathbb{F}_{p^e}</span>  using  <span class="math">\\mathbb{G}&#x27;_2</span> .</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 R-dependent versus S-dependent Computations</h2>

    <p class="text-gray-300">We begin by separating the R-dependent (fixed) computations from the S-dependent (dynamic) computations. Our goal is to minimize the computational complexity of the S-dependent computations.</p>

    <p class="text-gray-300">When the first argument in the pairing, R, is a fixed or constant parameter in a protocol, Scott et~al.~[42] propose precomputing and storing all the multiples of R (the T values in Algorithm 1) and all of the gradients (the  <span class="math">\\lambda</span>  values) in each of the Miller lines (the functions g). This is essentially the same as writing each of the Miller lines as  <span class="math">g(x,y) = y - \\lambda x - c</span> , where  <span class="math">c = y_T - \\lambda x_T</span>  is precomputed and stored alongside  <span class="math">\\lambda</span>  (see Algorithm 1). We prefer to precompute and store  <span class="math">(\\lambda, c)</span>  at each iteration, rather than  <span class="math">(x_T, y_T, \\lambda)</span> , since this saves an extra multiplication  <span class="math">(\\lambda \\text{ by } x_T)</span>  at runtime and only requires the storage of two values for each iteration, as well as somewhat simplifying the description of what the precomputation achieves. Namely, we do not store the multiples of the point R, since they are not necessarily required once S is input. Instead, we compute all of the R-dependent coefficients of the Miller line functions that are required, in complete preparation for the &quot;arrival&quot; of the argument S.</p>

    <p class="text-gray-300">In this light, fixing one argument in the pairing allows us to split Miller's algorithm into two parts. The first part involves all of the R-dependent (pre)computations that can be performed in advance: computing a set of indeterminate Miller lines defined by  <span class="math">(\\lambda, c)</span> . The second part involves all of the S-dependent computations, namely those which cannot be performed until the argument S is known. We describe the R-dependent precomputations in Algorithm 2 and the S-dependent dynamic computations in Algorithm 3. For ease of exposition, we assume from here on that the Miller lines are of the form  <span class="math">g(x,y) = y + \\tilde{\\lambda}x + \\tilde{c}</span> , instead of the usual  <span class="math">g(x,y) = y - \\lambda x - c</span> , by taking  <span class="math">\\tilde{\\lambda} = -\\lambda</span>  and  <span class="math">\\tilde{c} = -c</span> , and make an abuse of notation by relabeling and writing  <span class="math">g(x,y) = y + \\lambda x + c</span>  from now on. We use #DBL and #ADD in both algorithms to denote the number of doublings and additions, respectively, that occur in the run of Miller's algorithm. Clearly, #DBL = l - 1 (from Algorithm 1) and #ADD is equal to the number of non-zero bits in the binary representation of the loop parameter m (excluding the most significant bit). We also write the binary representation of m from  <span class="math">m = (m_{l-1}...m_1, m_0)_2</span>  to  <span class="math">m = (\\tilde{m}_0, \\tilde{m}_1...\\tilde{m}_{\\#DBL-1}, \\tilde{m}_{\\#DBL})_2</span> , so that  <span class="math">\\tilde{m}_0</span>  is now the most significant bit, and Miller's algorithm proceeds from  <span class="math">\\tilde{m}_1</span>  to  <span class="math">\\tilde{m}_{\\#DBL}</span> ; we relabel so that  <span class="math">m = (m_0, m_1...m_{\\#DBL-1}, m_{\\#DBL})_2</span>  from now on.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6"><strong>Algorithm 2</strong> R-dependent precomputations</h4>

    <pre><code class="language-text">Input: R = (x_R, y_R), m = (m_0, m_1...m_{\\#DBL-1}, m_{\\#DBL})_2.
Output: G_{DBL} = \\{(\\lambda_1, c_1), (\\lambda_2, c_2), ..., (\\lambda_{\\#DBL}, c_{\\#DBL})\\} and
     G_{\\text{ADD}} = \\{(\\lambda&#x27;_1, c&#x27;_1), (\\lambda&#x27;_2, c&#x27;_2), ..., (\\lambda&#x27;_{\\text{\\#ADD}}, c&#x27;_{\\text{\\#ADD}})\\}.
 1: T \\leftarrow R, G_{DBL} \\leftarrow \\{\\emptyset\\}, G_{ADD} \\leftarrow \\{\\emptyset\\}.
 2: for i from 1 to #DBL do
             Compute \\lambda_i and c_i, such that y + \\lambda_i x + c_i is the line tangent to T.
 3:
             T \\leftarrow [2]T.
 4:
 5:
             Append (\\lambda_i, c_i) to G_{DBL}.
 6:
             if m_i \\neq 0 then
                    Compute \\lambda&#x27;_i and c&#x27;_i, such that y + \\lambda&#x27;_i x + c&#x27;_i is the line joining T and R.
 7:
                    T \\leftarrow T + R.
 8:
 9:
                    Append (\\lambda&#x27;_i, c&#x27;_i) to G_{ADD}.
10:
             end if
11: end for
12: return G_{DBL}, G_{ADD}
</code></pre>

    <p class="text-gray-300">It is important to note that we are solely focussed on minimizing the computational complexity of the algorithm that is S-dependent. We are assuming that the R-dependent precomputations are carried out well in advance on a platform that is not too restricted (within reason) with</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6"><strong>Algorithm 3</strong> S-dependent computations</h4>

    <pre><code class="language-text">Input: S = (x_S, y_S), m = (m_0, m_1...m_{\\#DBL-1}, m_{\\#DBL})_2, G_{DBL} and G_{ADD} (from Algorithm 2).
Output: f_{m,R}(S) \\leftarrow f.
 1: f \\leftarrow 1, count&lt;sub&gt;ADD&lt;/sub&gt; \\leftarrow 1.
 2: for i from 1 to #DBL do
 3:
             Compute g \\leftarrow (y_S + \\lambda_i x_S + c_i).
              f \\leftarrow f^2 \\cdot g.
 4:
             if m_i \\neq 0 then
 5:
                     Compute g \\leftarrow (y_S + \\lambda&#x27;_{\\texttt{count}_{ADD}} x_S + c&#x27;_{\\texttt{count}_{ADD}}).
 6:
 7:
                     \\mathtt{count}_{\\mathtt{ADD}} \\leftarrow \\mathtt{count}_{\\mathtt{ADD}} + 1.
 8:
                     f \\leftarrow f \\cdot g.
 9:
             end if
10: end for
11: return f.
</code></pre>

    <p class="text-gray-300">computational time. For example, in pairings where both arguments are dynamic, one would never compute the Miller point operations and the Miller line functions in affine coordinates, as this involves costly field inversions. Such pairings always resort to avoiding these inversions by using projective coordinates, but in these cases the Miller lines that arise are almost always (cf. [17]) of the form  <span class="math">g(x,y) = g_x \\cdot x + g_y \\cdot y + g_0</span> . Employing projective coordinates would certainly reduce the computational time spent performing the R-dependent precomputations, but this would produce slightly more complicated Miller lines (the extra coefficient  <span class="math">g_y</span>  in front of y), and would inevitably slow down the dynamic computations involving S. In the theme of this paper then, we opt for affine coordinates throughout, with the ultimate goal of minimizing the S-dependent runtime. We do point out however, that the methods in this paper are entirely compatible with an implementation where the precomputation complexity might still be somewhat crucial, in which case the precomputation could be performed in projective coordinates. In such cases, one would split the algorithm and the analogous computational cost analysis described in [15].</p>

    <p class="text-gray-300">In Table 1, we present the S-dependent dynamic computational complexity in a typical iteration of Algorithm 3, ignoring the cost of the precomputations in Algorithm 2.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Iteration</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R-dependent values</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Storage <span class="math">\\in \\mathbb{F}_{p^u}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-dependent computations</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Dynamic costs</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_1, c_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_1 \\cdot x_S, f \\leftarrow f^2, f \\leftarrow f \\cdot g</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">e\\mathbf{m}_1 + \\mathbf{s}_k + \\tilde{\\mathbf{m}}_k</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_2,c_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_2 \\cdot x_S, f \\leftarrow f^2, f \\leftarrow f \\cdot g</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">e\\mathbf{m}_1 + \\mathbf{s}_k + \\tilde{\\mathbf{m}}_k</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_i,c_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_i \\cdot x_S, f \\leftarrow f^2, f \\leftarrow f \\cdot g</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">e\\mathbf{m}_1 + \\mathbf{s}_k + \\tilde{\\mathbf{m}}_k</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:<br>:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\#\\mathtt{DBL}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_{\\text{\\#DBL}}, c_{\\text{\\#DBL}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lambda_{\\text{\\#DBL}} \\cdot x_S, f \\leftarrow f^2, f \\leftarrow f \\cdot g</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">e\\mathbf{m}_1 + \\mathbf{s}_k + \\tilde{\\mathbf{m}}_k</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><span class="math">\\textbf{Table 1.} \\ \\textbf{The complexity of } S \\textbf{-dependent computations and storage requirements for Miller&#x27;s double-and-add routine}</span></p>

    <p class="text-gray-300">Table 1 also includes the storage requirements for the Miller lines in each iteration. We do not include the extra storage and S-dependent computations required for the addition steps in our analysis, since additions only occur a small number of times in state-of-the-art implementations that make use of well-chosen, low Hamming-weight loop parameters. In each iteration, the multiplication of the Miller function f by the update g is counted as  <span class="math">\\tilde{\\mathbf{m}}_k</span> , where  <span class="math">\\tilde{\\mathbf{m}}_k</span>  is actually less than a general  <span class="math">\\mathbf{m}_k</span> , since the updates g are sparse. The complexity of  <span class="math">\\tilde{\\mathbf{m}}_k</span>  compared with  <span class="math">\\mathbf{m}_k</span>  depends on the degree of the twist and the nature of the field construction.</p>

    <p class="text-gray-300">The R-dependent precomputations described above are somewhat natural in the context of fixed argument pairings. In the next section, we investigate whether more precomputation can be done to reduce the overall S-dependent complexity (the total of all the entries in the &quot;Dynamic costs&quot; column).</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Further Precomputations: Merging n Iterations at a Time</h2>

    <p class="text-gray-300">It was shown very recently [14, 15] that speedups in pairing computations can be achieved if the Miller lines for consecutive iterations are combined before they are evaluated at the second argument of the pairing. In [15], speedups were achieved by developing a general algorithm for merging n consecutive iterations. This involves multiplying n Miller lines together, each of which is raised to a different exponent depending on how many field squarings it would otherwise encounter in the standard Miller routine, given as</p>

    <p class="text-gray-300"><span class="math">$G_n(x,y) = \\prod_{i=1}^n g_i(x,y)^{2^{n-i}}.</span>$
(1)</p>

    <p class="text-gray-300">The technique in [14] is much the same, except the formulas for the above line product were presented in (slightly faster) explicit formulas, depending on the shape of the curve employed.</p>

    <p class="text-gray-300">Our approach is analogous to that of [15], where we derive an algorithm to give Gn(x, y) in its general form. We note two important differences between the results herein, and those in [15]. Firstly, the Miller lines in this paper are given in affine form, and so the general product in (1) will have a slightly different form. Secondly, the only computational costs we are concerned with are the dynamic S-dependent costs. This means that the (potentially very expensive) computational costs associated with building up the combined products in (1) can be ignored when determining the optimal number of lines to combine.</p>

    <p class="text-gray-300">We start the discussion by determining the nature of the function Gn(x, y), since the Gn(x, y) products will be evaluated at S, and this is the first S-dependent cost incurred in each of the n-ata-time iterations. We reiterate that the cost associated with building the indeterminate Gn(x, y) functions is ignored since the coefficients of these functions are solely R-dependent. We assume that Gn(x, y) is reduced modulo the curve equation y <sup>2</sup> = h(x), so that the result will always be (at most) linear in y, given as</p>

    <p class="text-gray-300"><span class="math">$G_n(x,y) = f_n(x) + g_n(x)y, \\tag{2}</span>$</p>

    <p class="text-gray-300">(where fn(x) and gn(x) are not to be confused with the f and g functions described in the algorithms in the previous sections). The following lemma can be used to determine the exact degree of fn(x) and gn(x) for all n.</p>

    <p class="text-gray-300">Lemma 1. Let y <sup>2</sup> = h(x) define an elliptic curve, where h(x) is a monic polynomial with deg(h) = 3. Let n consecutive affine Miller doubling updates be given by g1(x, y) = y+&lambda;1x+c1,..., gn(x, y) = y + &lambda;nx + cn. If G<sup>n</sup> is defined as in Equation (1), then Gn(x, y) takes the form</p>

    <p class="text-gray-300"><span class="math">$G_n(x,y) = f_n(x) + g_n(x)y,</span>$</p>

    <p class="text-gray-300">where g(x) is a monic polynomial such that deg(gn) = deg(fn) &minus; 1.</p>

    <p class="text-gray-300">Proof. When n = 1, we have G1(x, y) = g1(x, y) = y + &lambda;1x + c<sup>1</sup> = f1(x) + g1(x)y, where f1(x) = &lambda;1x + c and g1(x) = 1, so that deg(g1) = deg(f1) &minus; 1 and g1(x) is trivially monic.</p>

    <p class="text-gray-300">For induction, assume G<sup>k</sup> = fk(x) + gk(x)y, where deg(gk) = deg(fk) &minus; 1 and g<sup>k</sup> is monic. Gk+1 is computed as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} G_{k+1} &amp;= G_k^2 \\cdot g_{k+1} \\\\ &amp;= \\left( f_k(x) + g_k(x) y \\right)^2 \\cdot \\left( y + \\lambda_{k+1} x + c_{k+1} \\right) \\\\ &amp;= \\left( f_k(x)^2 + 2 f_k(x) g_k(x) y + g_k(x)^2 h(x) \\right) (y + \\lambda_{k+1} x + c_{k+1}) \\\\ &amp;= f_{k+1}(x) + g_{k+1}(x) y, \\end{split}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$f_{k+1}(x) = 2f_k(x)g_k(x)h(x) + (f_k(x)^2 + g_k(x)^2h(x))(\\lambda_{k+1}x + c_{k+1})</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$g_{k+1}(x) = f_k(x)^2 + g_k(x)^2 h(x) + 2f_k(x)g_k(x)(\\lambda_{k+1}x + c_{k+1}).</span>$</p>

    <p class="text-gray-300">The degree of  <span class="math">f_{k+1}(x)</span>  is easily seen to be  <span class="math">\\deg(f_{k+1}) = \\deg(f_k) + \\deg(g_k) + \\deg(h) = \\deg(f_k) + \\deg(f_k) + \\deg(f_k) + \\deg(f_k) + 2</span> , and the degree of  <span class="math">g_{k+1}(x)</span>  is  <span class="math">2 \\cdot \\deg(g_k) + \\deg(h) = 2 \\cdot \\deg(f_k) + 1</span> , so that  <span class="math">\\deg(g_{k+1}) = \\deg(f_{k+1}) - 1</span> . Lastly,  <span class="math">g_k(x)^2 h(x)</span>  is the only expression contributing to  <span class="math">g_{k+1}(x)</span>  whose degree is the same as the degree of  <span class="math">g_{k+1}(x)</span> , and  <span class="math">g_k(x)^2 h(x)</span>  is clearly monic (since both  <span class="math">g_k(x)</span>  and  <span class="math">g_k(x)</span>  are monic), so  <span class="math">g_{k+1}(x)</span>  is also monic.</p>

    <p class="text-gray-300">To determine the degrees of  <span class="math">f_n</span>  and  <span class="math">g_n</span> , we couple the initial values,  <span class="math">\\deg(f_1) = 1</span>  and  <span class="math">\\deg(g_1) = 0</span> , with the conditions  <span class="math">\\deg(f_{k+1}) = 2 \\cdot \\deg(f_k) + 2</span>  and  <span class="math">\\deg(g_{k+1}) = 2 \\cdot \\deg(f_k) + 1</span> ; hence</p>

    <p class="text-gray-300"><span class="math">$\\deg(f_n) = 3 \\cdot (2^{n-1} - 1) + 1 \\qquad \\text{and} \\qquad \\deg(g_n) = 3 \\cdot (2^{n-1} - 1), \\tag{3}</span>$</p>

    <p class="text-gray-300">agreeing with the analogous result for projective coordinates in [15, Eq. (10)].</p>

    <p class="text-gray-300">Since we are combining n iterations into one, the R-dependent precomputation stage of the pairing algorithm will now involve two sub-algorithms. Firstly, Algorithm 2 will precompute the  <span class="math">(\\lambda, c)</span>  and  <span class="math">(\\lambda&#x27;, c&#x27;)</span>  pairs as usual. Then, another sub-algorithm will be called to combine these pairs (which define lines  <span class="math">g(x, y) = y + \\lambda x + c</span> ), combining n at a time into products of the form in (2), the degrees of which are described in (3). Since this sub-algorithm deals with n of the  <span class="math">\\lfloor \\log_2(m) \\rfloor</span>  standard Miller iterations at a time, it will involve  <span class="math">\\lfloor \\log_{2n}(m) \\rfloor</span>  iterations.</p>

    <p class="text-gray-300">For exactly the same reason, the modified S-dependent evaluation stage of the pairing algorithm will now also involve  <span class="math">\\lfloor \\log_{2^n}(m) \\rfloor</span>  iterations. We now turn to determining the cost of each of these dynamic iterations. Each of the  <span class="math">G_{n(i)}</span>  takes the form  <span class="math">G_{n(i)}(x,y) = f_{n(i)}(x) + g_{n(i)}(x)y</span> , containing  <span class="math">\\deg(f_n) + 1 + \\deg(g_n) = 2 \\cdot \\deg(f_n) = 6 \\cdot (2^{n-1} - 1) + 2</span>  non-trivial coefficients, since  <span class="math">g_n</span>  is monic. Thus, for each  <span class="math">1 \\le i \\le \\lfloor \\log_{2^n}(m) \\rfloor</span> , we must store  <span class="math">6 \\cdot (2^{n-1} - 1) + 2</span>  elements in  <span class="math">\\mathbb{F}_{p^u}</span> . Apart from the constant term of  <span class="math">f_{n(i)}(x)</span> , every one of these  <span class="math">6 \\cdot (2^{n-1} - 1) + 2</span>  non-trivial coefficients is multiplied by a product of the coordinates of S, each multiplication of which costs  <span class="math">e\\mathbf{m}_1</span> . Thus, the cost of evaluating  <span class="math">G_{n(i)}</span>  at S is  <span class="math">[6 \\cdot (2^{n-1} - 1) + 1]e\\mathbf{m}_1</span> . We summarize the S-dependent &quot;per-iteration&quot; costs in Table 2. Importantly, we note that each of the n-at-a-time iterations will also involve n squarings of the Miller function f, as well as one (rather than n) multiplication of f by G(S) (see [14,15]). For n &gt; 1, this multiplication becomes a general full extension field multiplication  <span class="math">\\mathbf{m}_k</span> , rather than the  <span class="math">\\tilde{\\mathbf{m}}_k</span>  that is reported for n = 1, since G(S) is no longer sparse.</p>

    <p class="text-gray-300">Each of the  <span class="math">\\lfloor \\log_{2^n}(m) \\rfloor</span>  iterations requires the computation of  <span class="math">f_{n(1)}(S_x)</span>  and  <span class="math">g_{n(1)}(S_x) \\cdot S_y</span> . Thus, each iterate requires the same products of  <span class="math">S_x^i</span>  and  <span class="math">S_x^j S_y</span> , where  <span class="math">2 \\leq i \\leq \\deg(f_n)</span>  and  <span class="math">1 \\leq j \\leq \\deg(g_n)</span> , and these products, which are dependent on the dynamic input, are precomputed before the first iteration. We use the term precomputed here carefully, since these S-dependent precomputations are not to be confused with the R-dependent precomputations that don't contribute to the complexity at runtime. Where possible, we would like to use field squarings to determine the  <span class="math">S_x^i</span>  and  <span class="math">S_x^j S_y</span>  terms, rather than the slightly more expensive field multiplications. We can compute the  <span class="math">S_x^i</span>  terms, which range from  <span class="math">S_x^2</span>  to  <span class="math">S_x^{\\deg(f_n)}</span> , where  <span class="math">2 \\leq i \\leq 2^{\\lfloor \\log_2(\\deg(f_n)) \\rfloor}</span> , using one field squaring each (cf.  <span class="math">[14, \\S 5.2]</span> ). The remaining  <span class="math">S_x^i</span>  terms, where  <span class="math">i &gt; 2^{\\lfloor \\log_2(\\deg(f_n)) \\rfloor}</span> , are computed using  <span class="math">(\\deg(f_n) - 2^{\\lfloor \\log_2(\\deg(f_n)) \\rfloor})</span>  field multiplications. These multiplications and squarings occur in the field  <span class="math">\\mathbb{F}_{p^v}</span> , so that the total dynamic cost of obtaining  <span class="math">S_x^i</span>  for  <span class="math">2 \\leq i \\leq \\deg(f_n)</span>  is</p>

    <p class="text-gray-300"><span class="math">$(2^{\\lfloor \\log_2(\\deg(f_n))\\rfloor} - 1)\\mathbf{s}_v + (\\deg(f_n) - 2^{\\lfloor \\log_2(\\deg(f_n))\\rfloor})\\mathbf{m}_v.</span>$</p>

    <p class="text-gray-300">To compute the  <span class="math">S_x^j S_y</span>  products, where  <span class="math">1 \\leq j \\leq \\deg(g_n)</span> , we require  <span class="math">\\deg(g_n)</span>  multiplications<sup>1</sup> since we already have all of the  <span class="math">S_x^j</span> . Each of these multiplications occur in  <span class="math">\\mathbb{F}_{p^v}</span> , so that the total cost of</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> This is the cheapest way to compute these products, as trying to use field squarings to form the products would require us to compute  <span class="math">S_x^j S_y = ((S_x^j + S_y)^2 - S_x^{2j} + S_y^2)</span> ; even though we have  <span class="math">S_y^2</span>  via the curve equation, the squaring  <span class="math">(S_x^j + S_y)^2</span>  would require a full extension field squaring.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Iterations</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R-dependent Storage</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-dependent</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Dynamic</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">values</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\in \\mathbb{F}_{p^u}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">computations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">costs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">coefficients of</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">6(2^{n-1}-1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(1)}(S), g_{n(1)}(S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6(2^{n-1}-1)+1)e\\mathbf{m}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\downarrow</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(1)}, g_{n(1)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f^{2^n}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n\\mathbf{s}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f \\cdot G(S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{m}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">coefficients of</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">6(2^{n-1}-1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(2)}(S), g_{n(2)}(S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6(2^{n-1}-1)+1)e\\mathbf{m}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\downarrow</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(2)}, g_{n(2)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f^{2^n}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n\\mathbf{s}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f \\cdot G(S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{m}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&divide;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">in + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">coefficients of</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">6(2^{n-1}-1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(i)}(S), g_{n(i)}(S)</span> <span class="math">f \\leftarrow f^{2^n}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(6(2^{n-1}-1)+1)e\\mathbf{m}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\downarrow</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f_{n(i)}, g_{n(i)}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f^{2^n}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n\\mathbf{s}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(i+1)n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">f \\leftarrow f \\cdot G(S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{m}_k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&divide;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 2.</strong> The complexity of S-dependent computations and storage requirements for n combined iterations</p>

    <p class="text-gray-300">the S-dependent precomputation is given by adding  <span class="math">\\deg(g_n)\\mathbf{m}_v = (\\deg(f_n) - 1)\\mathbf{m}_v</span>  to the previous cost, giving</p>

    <p class="text-gray-300"><span class="math">$(2^{\\lfloor \\log_2(\\deg(f_n))\\rfloor} - 1)\\mathbf{s}_v + (2 \\cdot \\deg(f_n) - 2^{\\lfloor \\log_2(\\deg(f_n))\\rfloor} - 1)\\mathbf{m}_v.</span>$</p>

    <p class="text-gray-300">Substituting  <span class="math">\\deg(f_n) = 3(2^{n-1}-1)+1</span>  (from (3)) into the above equation requires the evaluation of  <span class="math">2^{\\lfloor \\log_2(3(2^{n-1}-1)+1)\\rfloor}</span> . To simplify this expression we rewrite the index as  <span class="math">\\lfloor \\log_2(2^n+2^{n-1}-2)\\rfloor = n</span> , so that the total number of S-dependent computations simplifies to</p>

    <p class="text-gray-300"><span class="math">$(2^{n} - 1)\\mathbf{s}_{v} + (2^{n+1} - 5)\\mathbf{m}_{v}. \\tag{4}</span>$</p>

    <p class="text-gray-300">From Table 2, each of the iterations costs  <span class="math">([6 \\cdot (2^{n-1} - 1) + 2]e\\mathbf{m}_1 + n\\mathbf{s}_k + \\mathbf{m}_k)</span> . Summing this cost over the  <span class="math">\\lfloor \\log_{2^n}(m) \\rfloor</span>  iterations, and adding the S-dependent precomputation in (4), gives the total S-dependent computation complexity as</p>

    <p class="text-gray-300"><span class="math">$\\lfloor \\log_{2^n}(m) \\rfloor ([6 \\cdot (2^{n-1} - 1) + 1]e\\mathbf{m}_1 + n\\mathbf{s}_k + \\mathbf{m}_k) + (2^n - 1)\\mathbf{s}_v + (2^{n+1} - 5)\\mathbf{m}_v.</span>$
(5)</p>

    <p class="text-gray-300">We summarize the total storage and the total costs for all n in Table 3. Once more, we reiterate that the total complexity is independent of the field containing the first argument,  <span class="math">\\mathbb{F}_{p^u}</span> , and is only dependent on the field containing the second argument,  <span class="math">\\mathbb{F}_{p^v}</span> . Interestingly, this means that even if the ate and Tate pairings had equal loop lengths, a fixed argument ate pairing (v=1) will still perform faster than a fixed argument Tate pairing (v=e) in general. As far as storage goes, the ate pairing will require storing values in the field  <span class="math">\\mathbb{F}_{p^e}</span> , whilst the Tate pairing will store values in the base field  <span class="math">\\mathbb{F}_p</span> . However, because of the shorter loop lengths achieved in the ate pairing, the total storage needed in the ate pairing may still end up being less than for the Tate pairing. Unlike the speedups achieved in [14] and [15] which mainly benefit the Tate pairing, it is clear that our techniques will also speed up the ate pairing when a fixed argument can be exploited. In the next section, we use the complexities in Table 3 to determine the optimal amount of precomputation for implementations over various embedding degrees.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Optimising n</h2>

    <p class="text-gray-300">With the ultimate goal of minimizing the dynamic computations incurred in a pairing with a fixed argument, we use the total complexities for the Miller loop in Table 3 to determine the best value of n for both the Tate and ate pairings at different security levels. In Table 4, we summarize our results for a variety of common security levels (taken from [20]) and embedding degrees, for both the Tate and ate pairings. At each security level, we list:</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Storage <span class="math">\\in \\mathbb{F}_{p^u}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-dependent costs</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2\\lfloor \\log_2 m \\rfloor</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lfloor \\log_2(m) \\rfloor (e\\mathbf{m}_1 + \\mathbf{s}_k + \\tilde{\\mathbf{m}}_k)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq 2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lfloor \\log_{2^n} m \\rfloor (6(2^{n-1}-1)+2)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[\\log_{2^n}(m)]((6(2^{n-1}-1)+1)e\\mathbf{m}_1 + n\\mathbf{s}_k + \\mathbf{m}_k)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+(2^{n}-1)\\mathbf{s}_{v}+(2^{n+1}-5)\\mathbf{m}_{v}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 3.</strong> The total storage requirements and S-dependent complexity for a fixed argument pairing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the optimal<sup>2</sup> length of the Miller loop ( <span class="math">m_{\\text{Tate}}</span>  and  <span class="math">m_{\\text{ate}}</span> , respectively) for both pairings (taken from [17]).;</li>
      <li>the optimal value of n, the number of iterations to merge, based on the analysis in Section 4;</li>
      <li>the overall cost of S-dependent dynamic Miller loop doubling operations in terms of base field  <span class="math">(\\mathbb{F}_p)</span>  multiplications, assuming that  <span class="math">\\mathbf{s}_1 = 0.8\\mathbf{m}_1</span> , and counting multiplications in fields with extension degrees of the form  <span class="math">k = 2^i 3^j</span> , as  <span class="math">\\mathbf{m}_k = 3^i 5^j \\mathbf{m}_1</span>  (cf. [30]);</li>
      <li>the percentage reductions in Miller loop operations between an optimal n implementation (this paper) and (i) the previous precomputation methods [42] (which correspond to n = 1 herein),
(ii) no precomputation, but with optimal delayed multiplications [14].</li>
    </ul>

    <p class="text-gray-300">We point out that these percentage speedups are based on the computation of the Miller loop only, and do not take into account the fixed cost of the final exponentation, so that the relative speedups for the entire pairing computation will be less than those reported in Table 4.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Best</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbb{F}_p</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbb{F}_{p^e}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbb{F}_{p^k}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Pairing</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">m</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#\\mathbf{m}_1</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">% S <sub>I</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">oeedup</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\rho</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pre.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no pre.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">320</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">320</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1920</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1843</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1846</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1920</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5069</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5058</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">224</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">224</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">448</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2688</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7308</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3646</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.250</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">280</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13460</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3346</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3072</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8263</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4198</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.250</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">320</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1280</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4096</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15368</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3823</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.333</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">342</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1026</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4608</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13590</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4697</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.333</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6912</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20173</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6881</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.250</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">478</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1912</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9216</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34540</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8577</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">576</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4608</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">87876</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10777</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.167</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">598</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3588</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18432</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">264</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">102960</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ate</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13202</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27.7</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 4.</strong> The optimal number of iterations to merge (n), the resulting S-dependent base field operation counts  <span class="math">(\\#\\mathbf{m}_1)</span> , and the percentage speedup compared to previous precomputation (pre.) [42] and no precomputation (no pre.) techniques, for a variety of security levels and embedding degrees (k).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup> These loop lengths are commonly  <span class="math">m_{Tate} = \\log(r)/2</span>  and  <span class="math">m_{ate} = \\log(r)/\\phi(k)</span> , corresponding to the twisted ate [28] and optimal ate [46] pairings respectively.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">(a) Tate and ate pairing multiplication vs. storage costs with r = 256 and k = 12 for various n.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">(b) Tate pairing multiplication costs with different r and k for various n.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">(c) ate pairing multiplication costs with different r and k for various n.</p>

    <p class="text-gray-300">Fig. 1. S-dependent costs for various n values for the Tate and ate pairings.</p>

    <p class="text-gray-300">In Figure 1(a), we show the operation count (in terms of number of base field multiplications) for the entire S-dependent dynamic Miller loop doubling operations in the Tate and ate pairings for a curve with r = 256 and k = 12 based on the analysis in Section 4, as well as the precomputation storage costs in terms of number of base field elements, for various amounts of precomputation; n = 0 corresponds to no precomputation, while n &ge; 1 corresponds to the complexity from Table 3. The optimal amount of precomputation for this case occurs at n = 3, at which point the precomputation storage costs are 860 base field elements, which is not too prohibitive for many applications.</p>

    <p class="text-gray-300">Figure 1(b) shows the base field multiplication costs for the S-dependent dynamic Miller loop doubling operations in a Tate pairing for a variety of subgroup sizes and embedding degrees based on the amount (n) of precomputation. With the exception of the r = 160 case, the optimal n is 3, meaning for those cases we should use precomputation to merge 3 iterations of the Miller loop at a time, as described in Section 4. Figure 1(c) shows the same costs in an ate pairing.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Applications</h2>

    <p class="text-gray-300">There are many pairing-based cryptosystems that can benefit from precomputation when one of the arguments is fixed. In Table 5, we have listed some pairing-based cryptosystems that have fixed arguments and hence which can benefit from the improvements in this paper.</p>

    <p class="text-gray-300">In some cases, such as the Boneh-Franklin identity-based encryption scheme [9] or the Chen-Kudla identity-based key agreement protocol [13], one party computes a pairing where the first argument is fixed while the other party computes a pairing where the second argument is fixed; here, our technique can only be applied to speed up one party's pairing computation.</p>

    <p class="text-gray-300">In others cases, such as the McCullagh-Barreto identity based key agreement protocol [33], the two parties employing the cryptosystem can both benefit because they each compute pairings where the fixed value appears in the same argument of the pairing. Our speed-up is also applicable to attribute-based encryption schemes such as those of Goyal et al. [24, &sect;4] and Lewko et al. [31, &sect;2] which perform a large number of pairings (one or two for each attribute used in decryption), as in these schemes the second arguments in all these pairing computations are long-term values (fixed across multiple runs of the protocol, though not all identical within a single run of the protocol).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">#</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">fixed</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">#</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">fixed</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pairings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">arguments</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pairings</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">arguments</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Public key encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Decryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Boyen-Mei-Waters [12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ID-based encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Decryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Boneh-Franklin [9]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1st</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Boneh-Boyen [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Waters [47]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">both in 2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Attribute-based encr.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Encryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Decryption</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GPSW [24, &sect;4]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&le; #attr.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">all in 1st</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LOSTW [31, &sect;2]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&le; 2 &middot; #attr.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">all in 2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ID-based signatures</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Signing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Verification</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Waters [47]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 in 2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ID-based key exchange</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Initiator</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Responder</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Smart-1 [45]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 in 1st, 1 in 2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 in 1st, 1 in 2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Chen-Kudla [13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1st</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">McCullagh-Barreto [33]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5. Fixed arguments in various pairing-based cryptosystems.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Conclusions</h2>

    <p class="text-gray-300">We have shown how using precomputation to merge iterations of the Miller loop in Tate and ate pairings can reduce the cost of the dynamic running time when computing a pairing with one fixed argument and one dynamic argument. This improves the runtime cost by between 25% and 37% when compared to a pairing computation with no precomputation, and up to 19.5% when compared to previous precomputation techniques. While the precomputation stage is somewhat expensive compared to the cost of pairing computation, it can still be run quite quickly (in a few seconds or less) on modern computers, and the amount of precomputation storage required is not prohibitive for many settings. Given the wide variety of pairing-based cryptosystems where one argument (say, a long-term private key or system parameter) is fixed across many protocol runs, we believe our techniques have wide applicability.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Aranha, D.F., L&acute;opez, J., Hankerson, D.: High-speed parallel software implementation of the &eta;<sup>T</sup> pairing. In: Pieprzyk, J. (ed.) Topics in Cryptology &ndash; CT-RSA 2010. Lecture Notes in Computer Science, vol. 5985, pp. 89&ndash;105. Springer (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Arene, C., Lange, T., Naehrig, M., Ritzenthaler, C.: Faster pairing computation. Cryptology ePrint Archive, Report 2009/155 (2009)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Barreto, P.S.L.M., Galbraith, S.D., O'Eigeartaigh, C., Scott, M.: Efficient pairing computation on supersingular abelian varieties. Designs, Codes and Cryptography 42(3), 239&ndash;271 (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Barreto, P.S.L.M., Kim, H.Y., Lynn, B., Scott, M.: Efficient algorithms for pairing-based cryptosystems. In: Yung, M. (ed.) Advances in Cryptology &ndash; Proc. CRYPTO 2002. Lecture Notes in Computer Science, vol. 2442, pp. 354&ndash;368. Springer (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Barreto, P.S.L.M., Lynn, B., Scott, M.: Efficient implementation of pairing-based cryptosystems. J. Cryptology 17(4), 321&ndash;334 (2004)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Benger, N., Scott, M.: Constructing tower extensions for the implementation of pairing-based cryptography. In: Hasan and Helleseth [26]</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boneh, D., Boyen, X.: Efficient selective-ID secure identity-based encryption without random oracles. In: Cachin, C., Camenisch, J. (eds.) Advances in Cryptology &ndash; Proc. EUROCRYPT 2004. Lecture Notes in Computer Science, vol. 3027, pp. 223&ndash;238. Springer (2004)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boneh, D., Boyen, X., Shacham, H.: Short group signatures. In: Franklin [19], pp. 41&ndash;55</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boneh, D., Franklin, M.: Identity-based encryption from the Weil pairing. In: Kilian, J. (ed.) Advances in Cryptology &ndash; Proc. CRYPTO 2001. Lecture Notes in Computer Science, vol. 2139, pp. 213&ndash;229. Springer (2001)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boneh, D., Gentry, C., Lynn, B., Shacham, H.: Aggregate and verifiably encrypted signatures from bilinear maps. In: Biham, E. (ed.) Advances in Cryptology &ndash; Proc. EUROCRYPT 2003. Lecture Notes in Computer Science, vol. 2656, pp. 416&ndash;432. Springer (2003)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boneh, D., Lynn, B., Shacham, H.: Short signatures from the Weil pairing. J. Cryptology 17(4), 297&ndash;319 (2004)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Boyen, X., Mei, Q., Waters, B.: Direct chosen ciphertext security from identity-based techniques. In: Meadows, C., Syverson, P. (eds.) Proc. 12th ACM Conference on Computer and Communications Security (CCS). pp. 320&ndash;329. ACM (2005)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Chen, L., Kudla, C.: Identity based authenticated key agreement protocols from pairings. In: Proceedings 16th IEEE Computer Security Foundations Workshop (CSWF-16). pp. 219&ndash;233. IEEE (2003)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Costello, C., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Avoiding full extension field arithmetic in pairing computations. In: Progress in Cryptology &ndash; Proc. AFRICACRYPT 2010. Lecture Notes in Computer Science, Springer (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Costello, C., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Delaying mismatched field multiplications in pairing computations. In: Hasan and Helleseth [26]</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Costello, C., Hisil, H., Boyd, C., Nieto, J.M.G., Wong, K.K.H.: Faster pairings on special Weierstrass curves. In: Shacham and Waters [43], pp. 89&ndash;101</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Costello, C., Lange, T., Naehrig, M.: Faster pairing computations on curves with high-degree twists. In: Nguyen, P.Q., Pointcheval, D. (eds.) Public Key Cryptography (PKC) 2010. Lecture Notes in Computer Science, vol. 6056, pp. 224&ndash;242. Springer (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Devegili, A.J., Scott, M., Dahab, R.: Implementing cryptographic pairings over Barreto-Naehrig curves. In: Takagi, T., Okamoto, T., Okamoto, E., Okamoto, T. (eds.) Pairing-Based Cryptography &ndash; Pairing 2007. Lecture Notes in Computer Science, vol. 4575, pp. 197&ndash;207. Springer (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Franklin, M.K. (ed.): Advances in Cryptology Proc. CRYPTO 2004, Lecture Notes in Computer Science, vol. 3152. Springer (2004)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Freeman, D., Scott, M., Teske, E.: A taxonomy of pairing-friendly elliptic curves. J. Cryptology 23(2), 224&ndash;280 (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Galbraith, S.D.: Supersingular curves in cryptography. In: Boyd, C. (ed.) Advances in Cryptology Proc. ASIACRYPT 2001. Lecture Notes in Computer Science, vol. 2248, pp. 495&ndash;513. Springer (2001)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Galbraith, S.D., Harrison, K., Soldera, D.: Implementing the Tate pairing. In: Fieker, C., Kohel, D.R. (eds.) Proc. Algorithmic Number Theory 6th International Symposium (ANTS) 2002. Lecture Notes in Computer Science, vol. 2369, pp. 324&ndash;337. Springer (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Gentry, C., Silverberg, A.: Hierarchical ID-based cryptography. In: Zheng, Y. (ed.) Advances in Cryptology &ndash; Proc. ASIACRYPT 2002. Lecture Notes in Computer Science, vol. 2501, pp. 548&ndash;566. Springer (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Goyal, V., Pandey, O., Sahai, A., Waters, B.: Attribute-based encryption for fine-grained access control of encrypted data. In: Wright, R., De Capitani de Vimercati, S., Shmatikov, V. (eds.) Proc. 13th ACM Conference on Computer and Communications Security (CCS). pp. 89&ndash;98. ACM (2006)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hankerson, D., Menezes, A.J., Scott, M.: Software implementation of pairings. In: Joye, M., Neven, G. (eds.) Identity-Based Cryptography. pp. 188&ndash;206. IOS Press (2008)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hasan, A., Helleseth, T. (eds.): International Workshop on the Arithmetic of Finite Fields (WAIFI) 2010. Lecture Notes in Computer Science, Springer (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hess, F.: Pairing lattices. In: Galbraith, S.D., Paterson, K.G. (eds.) Pairing-Based Cryptography Pairing 2008. Lecture Notes in Computer Science, vol. 5209, pp. 18&ndash;38. Springer (2008)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hess, F., Smart, N.P., Vercauteren, F.: The eta pairing revisited. IEEE Transactions on Information Theory 52(10), 4595&ndash;4602 (2006)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Joux, A.: A one round protocol for tripartite Diffie-Hellman. In: Bosma, W. (ed.) Proc. Algorithmic Number Theory 5th International Symposium (ANTS) 2000. Lecture Notes in Computer Science, vol. 1838, pp. 385&ndash;394. Springer (2000)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Koblitz, N., Menezes, A.: Pairing-based cryptography at high security levels. In: Smart, N.P. (ed.) Cryptography and Coding &ndash; 10th IMA International Conference. Lecture Notes in Computer Science, vol. 3796, pp. 13&ndash;36. Springer (2005)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Lewko, A., Okamoto, T., Sahai, A., Takashima, K., Waters, B.: Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In: Advances in Cryptology &ndash; Proc. EUROCRYPT 2010. Lecture Notes in Computer Science, Springer (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Matsuda, S., Kanayama, N., Hess, F., Okamoto, E.: Optimised versions of the ate and twisted ate pairings. In: Galbraith, S.D. (ed.) Cryptography and Coding &ndash; 11th IMA International Conference. Lecture Notes in Computer Science, vol. 4887, pp. 302&ndash;312. Springer (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>McCullagh, N., Barreto, P.S.: A new two-party identity-based authenticated key agreement. In: Menezes, A.J. (ed.) Topics in Cryptology &mdash; CT-RSA 2005. Lecture Notes in Computer Science, vol. 3376, pp. 262&ndash;274. Springer (2005)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Menezes, A.J.: Elliptic Curve Public Key Cryptosystems. Kluwer Academic Publishers (1993)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Miller, V.S.: The Weil pairing, and its efficient calculation. Journal of Cryptology 17, 235&ndash;261 (2004)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Naehrig, M., Barreto, P.S.L.M., Schwabe, P.: On compressible pairings and their computation. In: Vaudenay, S. (ed.) Progress in Cryptology &ndash; AFRICACRYPT 2008. Lecture Notes in Computer Science, vol. 5023, pp. 371&ndash;388. Springer (2008)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Naehrig, M., Niederhagen, R., Schwabe, P.: New software speed records for cryptographic pairings. Cryptology ePrint Archive, Report 2010/186 (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Scott, M.: Implementing cryptographic pairings. In: Takagi, T., Okamoto, T., Okamoto, E. (eds.) Pairing-Based Cryptography &ndash; Pairing 2007. Lecture Notes in Computer Science, vol. 4575, pp. 177&ndash; 196. Springer (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Scott, M., Barreto, P.S.L.M.: Compressed pairings. In: Franklin [19], pp. 140&ndash;156</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Scott, M., Benger, N., Charlemagne, M., Perez, L.J.D., Kachisa, E.J.: Fast hashing to G<sup>2</sup> on pairingfriendly curves. In: Shacham and Waters [43], pp. 102&ndash;113</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Scott, M., Benger, N., Charlemagne, M., Perez, L.J.D., Kachisa, E.J.: On the final exponentiation for calculating pairings on ordinary elliptic curves. In: Shacham and Waters [43], pp. 78&ndash;88</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Scott, M., Costigan, N., Abdulwahab, W.: Implementing cryptographic pairings on smartcards. In: Goubin, L., Matsui, M. (eds.) Cryptographic Hardware and Embedded Systems (CHES) 2006. Lecture Notes in Computer Science, vol. 4249, pp. 134&ndash;147. Springer (2006)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Shacham, H., Waters, B. (eds.): Pairing-Based Cryptography Pairing 2009, Lecture Notes in Computer Science, vol. 5671. Springer (2009)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Shamir, A.: Identity-based cryptosystems and signature schemes. In: Goos, G., Hartmanis, J. (eds.) Advances in Cryptology &ndash; Proc. CRYPTO 1984. Lecture Notes in Computer Science, vol. 196, pp. 47&ndash;53. Springer (1984)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Smart, N.P.: Identity-based authenticated key agreement protocol based on Weil pairing. Electronics Letters 38(13), 630&ndash;632 (June 2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Vercauteren, F.: Optimal pairings. IEEE Transactions on Information Theory 56(1), 455&ndash;461 (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Waters, B.: Efficient identity-based encryption without random oracles. In: Cramer, R. (ed.) Advances in Cryptology &ndash; Proc. EUROCRYPT 2005. Lecture Notes in Computer Science, vol. 3494, pp. 114&ndash;127. Springer (2005)</li>
    </ul></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Fixed Argument Pairings (2010/342)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/342
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="fixed-argument-pairings-2010" />
  </article>
</BaseLayout>
