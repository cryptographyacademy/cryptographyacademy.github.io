---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/545';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'On Trees, Chains and Fast Transactions in the Blockchain';
const AUTHORS_HTML = 'Aggelos Kiayias, Giorgos Panagiotakos';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">A fundamental  open problem in the area of
blockchain protocols is whether the Bitcoin protocol
is the
only solution
for building a secure transaction ledger.
A recently proposed and
widely considered alternative is the
\\GHOST protocol which, notably,
was proposed to be at the core of Ethereum
as well as  other recent proposals for improved Bitcoin-like
systems.
%
The \\GHOST variant is touted as offering superior performance compared to Bitcoin (potentially offering block production
speed up by a factor of more than 40) without a security loss. Motivated by this, in this work, we study
from
a  provable security
point of view
the \\GHOST protocol.

We introduce a new formal framework for the analysis
of blockchain protocols that relies on trees (rather
than chains)  and we showcase the power of the framework
by providing a unified description of the \\GHOST and Bitcoin protocols,
the former of which we extract and formally describe. We then prove that  \\GHOST implements a
\`\`robust transaction ledger&#x27;&#x27; (i.e., possesses liveness and persistence) and hence it is
a provably secure alternative to Bitcoin; moreover, our bound for the liveness parameter is superior to that proven for the bitcoin backbone in line with the original expectation for \\GHOST.
Our proof follows a novel methodology for establishing that \\GHOST is a robust transaction ledger compared to previous works, which may be of independent interest and can be applicable to other blockchain variants.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Bitcoin &middot; GHOST &middot; confirmation time &middot; blockchain &middot; robust public transaction ledger &middot; security</p>
    </section>

    <p class="text-gray-300">The popularity of Bitcoin [19] has lead to a surge in the interest about its core protocol that maintains a distributed data structure called the blockchain. In [9], the core of the Bitcoin protocol was abstracted under the moniker Bitcoin Backbone and it was demonstrated to be a powerful tool for solving consensus, [23, 17], in a synchronous, anonymous and Byzantine setting where (unreliable)</p>

    <p class="text-gray-300"><sup>?</sup> Research supported by ERC project CODAMODA. Part of this work was based in a technical report published in e-print (https://eprint.iacr.org/2015/1019).</p>

    <p class="text-gray-300">broadcast is the communication operation available to the participants, (a problem first considered in [2, 20]). In [9], it was shown that the core protocol provably guarantees two properties: (i) persistence: if a transaction is reported as stable by one node, then it will be also reported as such by any other honest node of the system, (ii) liveness: all honestly generated transactions that are broadcasted are eventually reported as stable by some honest node. This provides a formal framework for proving the security of systems like Bitcoin, since their security can be reduced to the persistence and liveness of the underlying transaction ledger. Furthermore, it provides a way to argue formally about transaction confirmation time since the liveness property is equipped with a delay parameter that specifies the maximum transaction delay that can be caused by an adversary.</p>

    <p class="text-gray-300">Naturally, implementing a robust transaction ledger may be achieved in various other ways, and it is a fundamental open question of the area whether the Bitcoin protocol itself is an &quot;optimal&quot; implementation of a robust transaction ledger. Indeed, many researchers have challenged various aspects of the Bitcoin system and they have proposed modifications in its core operation. Some of the modified systems maintain the protocol structure but modify the hard-coded parameters (like the block generation rate) or the basic primitives, e.g., the way proof of work is performed (a number of alternative proof of work implementations have been proposed using functions like scrypt [24], lyra2 [26] and others). However, more radical modifications are possible that alter the actual operation of the protocol.</p>

    <p class="text-gray-300">One of the most notable such variants is the GHOST protocol, which was suggested by Sompolinsky and Zohar in [27]. After the initial suggestion many cryptocurrencies using variants of the GHOST rule were proposed and implemented. The most popular among them, Ethereum [6] has received substantial research attention [16, 15, 4, 25, 12, 21]. Ethereum is essentially a Bitcoin-like system where transaction processing is Turing-complete and thus it can be used to implement any public functionality in a distributed way. Bitcoin-NG [7] is another popular Bitcoin-like system relying on GHOST that separates blocks in two categories, namely key blocks and microblocks, reflecting the fact that transaction serialization and leader election may be separated.</p>

    <p class="text-gray-300">Unfortunately, the security analysis of [27] is not as general as [9] (e.g., their attacker does not take advantage of providing conflicting information to different honest parties), while the analysis of [9] does not carry to the setting of GHOST. This is because the GHOST rule is a natural, albeit radical, reformulation of how each miner determines the main chain. In GHOST, miners adopt blocks in the structure of a tree. Note that in both Bitcoin and GHOST one can consider parties collecting all mined blocks in a tree data structure. However, while in Bitcoin the miners would choose the most difficult chain as the main chain, in GHOST, they will determine the chain by greedily following the &quot;heaviest observed subtree.&quot; This means that for the same subtree, a Bitcoin miner and a GHOST miner may choose a completely different main chain. Furthermore, it means that the difficulty of the main chain of honest parties does not necessarily increase mono-</p>

    <p class="text-gray-300">tonically (it may decrease at times) and thus a fundamental argument (namely that blockchains monotonically increase) that made the analysis of [9] possible, does not hold anymore.</p>

    <p class="text-gray-300">Our Results. We propose a new analysis framework for blockchain protocols focusing on trees of blocks as opposed to chains as in [9]. Our framework enables us to argue about random variables on the trees of blocks that are formed by the participants. In our framework, we can express concepts like a node being d-dominant, which means that the block corresponding to that node would be preferred by a margin of d compared to other sibling nodes according to a specied weight measure. This actually enables us to unify the description of Bitcoin and GHOST by showing they obey the same rule, but simply for a dierent weight measure.</p>

    <p class="text-gray-300">Using our framework we then provide a rst formal security proof of the GHOST rule for blockchain protocols. Specically, we prove that GHOST is a robust transaction ledger that satises liveness and persistence. We achieve this result, by a new methodology, that reduces the properties of the robust transaction ledger to a single lemma, that we call the fresh block lemma and is informally stated as follows.</p>

    <p class="text-gray-300">Fresh Block Lemma. (Informally) At any point of the execution and for any past sequence of s consecutive rounds, there exists an honest block mined in these rounds, that is contained in the chain of any honest player from this point on.</p>

    <p class="text-gray-300">As we will demonstrate, the fresh block lemma is a powerful tool in the presence of an adversary: we show easily that the properties of the robust transaction ledger reduce to it in a black-box fashion.</p>

    <p class="text-gray-300">In more details our result is as follows. In blockchain protocols there is a predicate parameterized by a security parameter k that determines when a transaction has been stabilized in the ledger. The stable predicate for Bitcoin can be seen to be true whenever the transaction is at least k blocks deep in the blockchain. The stable predicate for GHOST is dierent and is true whenever the block that the transaction belongs to is the root of a subtree of at least k blocks. We prove the following.</p>

    <p class="text-gray-300">Persistence: if in a certain round an honest player reports a transaction tx as stable then whenever an honest party reports tx transaction as stable tx will be in the same position in the ledger.</p>

    <p class="text-gray-300">Liveness: if a transaction is given as input to all honest players continuously for u = &Theta;(k) rounds then all of them will report it as stable.</p>

    <p class="text-gray-300">The above properties will depend on the parameter k of the stable predicate of GHOST; we prove them to hold with a probability of error which drops exponentially in k over all executions of the protocol.</p>

    <p class="text-gray-300">Our proof strategy for persistence and liveness utilizes the fresh block lemma in the following (black-box) manner.</p>

    <p class="text-gray-300">In the case of persistence, it is sucient to ensure that reporting the transaction as stable by any honest player implies that a sucient amount of time has passed so that the fresh block lemma is applicable and has produced a block that is a descendant of the block that contains the transaction. Using the moderate hardness of proofs of work (specically that they are hard enough) it is easy to translate from number of blocks in a subtree to actual running time in terms of rounds. It follows that the fresh block lemma applies and all honest parties will be mining on a subtree rooted at this fresh block for the remaining of the execution. As a result, the transaction will always be reported as stable since it belongs to the heaviest observed path for all of the honest parties.</p>

    <p class="text-gray-300">In the case of liveness, we proceed in two steps. First, for our choice of u, in a time window lasting &Theta;(k) rounds, it will be ensured that the fresh block lemma can be applied once implying that all honest parties will mine in a subtree rooted by a common block that includes the transaction. Then, after another &Theta;(k) rounds, the honest parties will have accumulated enough honest blocks in this subtree to pronounce this transaction as stable. This latter statement requires again the moderate hardness of proofs of work but from the opposite perspective, i.e., that they are easy enough.</p>

    <p class="text-gray-300">The above strategy provides an alternative proof methodology for establishing the properties of a robust transaction ledger compared to previous works that analyzed blockchain protocols, [9], [13] and [22] who reduced the properties of the robust transaction ledger to three other properties called common pre x, chain quality and chain growth. As such, the proof strategy itself may be of independent interest as it could be applicable to other blockchain variants, especially those that are using trees of blocks instead of chains of blocks as in bitcoin in their chain selection rule.</p>

    <p class="text-gray-300">Our results align with the original expectation that GHOST performs better than bitcoin in terms of liveness, since our proven liveness parameter is k+ k (1&minus;&delta;)&alpha; which is superior to the <sup>2</sup><sup>k</sup> (1&minus;&delta;)&gamma; liveness parameter for bitcoin proven in [9]. Note that in both cases k refers to the same conrmation level in the two protocols; in both cases k bounds the probability of the event that the number of uniquely successful rounds exceeds the number of blocks produced by the adversary.</p>

    <p class="text-gray-300">On the generality of the adversarial model. The adversarial model we adopt in this work is the one proposed by Garay et al. [9]. This model is quite general in the sense that, it can captures many attack models that were proposed in the literature. For example, it captures the double spending attacker of [19], the block withholding attacker of [8] (which can be simulated because the adversary can change the order that messages arrive for each honest player) and the eclipse attacker of [5] where the communication of a portion of the honest nodes in the network is completely controlled (eclipsed) by the adversary (this can be simulated by simply considering the eclipsed nodes to be controlled by the adversary and having the adversary honestly execute their program while dropping their incoming messages). For a quantitative analysis of these attacks the reader is referred to [10].</p>

    <p class="text-gray-300">Limitations and directions for future research. Our analysis is in the standard Byzantine model where parties fall into two categories, those that are honest (and follow the protocol) and those that are dishonest and may deviate in an arbitrary (and coordinated) fashion as dictated by the adversary. It is an interesting direction for future work to consider the rational setting where all parties wish to optimize a certain utility function. Designing suitable incentive mechanisms, for instance see [18] for a suggestion related to the GHOST protocol, or examining the requirements for setup assumptions, cf. [1], are related important considerations. Our analysis is in the static setting, i.e., we do not take into account the fact that parties change dynamically and that the protocol calibrates the difficulty of the POW instances to account for that; we note that this may open the possibility for additional attacks, say [3], and hence it is an important point for consideration and future work. Finally, it is interesting to consider our results in more general models such as the semi-synchronous model of [22].</p>

    <p class="text-gray-300"><strong>Organization.</strong> In section 2 we overview the model that we use for expressing the protocols and the theorems regarding the security properties. In section 3 we introduce our new tree-based framework. Then, in section 4 we present our security analysis of an abstraction of the GHOST protocol that demonstrates it is a robust transaction ledger in the static setting.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Model</h3>

    <p class="text-gray-300">For our model we adopt the abstraction proposed in [9]. Specifically, in their setting, called the q-bounded setting, synchronous communication is assumed and each party is allowed q queries to a random oracle. The network supports an anonymous message diffusion mechanism that is guaranteed to deliver messages of all honest parties in each round. The adversary is rushing and adaptive. Rushing here means that in any given round he gets to see all honest players' messages before deciding his own strategy. However, after seeing the messages he is not allowed to query the hashing oracle again in this round. In addition, he has complete control of the order that messages arrive to each player. The model is &quot;flat&quot; in terms of computational power in the sense that all honest parties are assumed to have the same computational power while the adversary has computational power proportional to the number of players that it controls.</p>

    <p class="text-gray-300">The total number of parties is n and the adversary is assumed to control t of them (honest parties don't know any of these parameters). Obtaining a new block is achieved by finding a hash value that is smaller than a difficulty parameter D. The success probability that a single hashing query produces a solution is  <span class="math">p = \\frac{D}{2^{\\kappa}}</span>  where  <span class="math">\\kappa</span>  is the length of the hash. The total hashing power of the honest players is  <span class="math">\\alpha = pq(n-t)</span> , the hashing power of the adversary is  <span class="math">\\beta = pqt</span>  and the total hashing power is  <span class="math">f = \\alpha + \\beta</span> . A number of definitions that will be used extensively are listed below.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Definition 1.</strong> A round is called:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>successful if at least one honest player computes a solution in this round.</li>
      <li>uniquely successful if exactly one honest player computes a solution in this round.</li>
    </ul>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6"><strong>Definition 2.</strong> In an execution blocks are called:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>honest, if mined by an honest party.</li>
      <li>adversarial, if mined by the adversary.</li>
    </ul>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8"><strong>Definition 3.</strong> Some chain notation:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By  <span class="math">C^{\\lceil k \\rceil}</span>  we denote the chain that results by dropping the last k blocks of C.</li>
      <li>We will say that a chain C' extends another chain C if a non-empty prefix of C' is a suffix of C.</li>
    </ul>

    <p class="text-gray-300">In [9], a lower bound to the probabilities of two events, that a round is successful or that is uniquely successful (defined bellow), was established and denoted by  <span class="math">\\gamma_{\\rm u}=\\alpha-\\alpha^2</span> . While this bound is sufficient for the setting of small f, here we will need to use a better lower bound to the probability of those events, denoted by  <span class="math">\\gamma</span> , and with value approximately  <span class="math">\\alpha e^{-\\alpha}</span>  (see Appendix). Observe that  <span class="math">\\gamma&gt;\\gamma_{\\rm u}</span> .</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The GHOST Backbone Protocol</h3>

    <p class="text-gray-300">In order to study the properties of the core Bitcoin protocol, the term <em>Backbone Protocol</em> was introduced in [9]. On this level of abstraction we are only interested on properties of the blockchain, independently from the data stored inside the blocks. The main idea of the Bitcoin Backbone is that honest players, at every round, receive new chains from the network and pick the longest valid one to mine. Then, if they obtain a new block (by finding a small hash), they broadcast their chain at the end of the round.</p>

    <p class="text-gray-300">The same level of abstraction can also be used to express the GHOST protocol. The GHOST Backbone protocol, as presented in [27], is based on the principle that blocks that do not end up in the main chain, should also matter in the chain selection process. In order to achieve this, players store a tree of all mined blocks they have received, and then using the greedy heaviest observed subtree (GHOST) rule, they pick which chain to mine.</p>

    <p class="text-gray-300">At every round, players update their tree by adding valid blocks sent by other players. The same principle as Bitcoin applies; for a block to be added to the tree, it suffices to be a valid child of some other tree block. The adversary can add blocks anywhere he wants in the tree, as long as they are valid. Again, as on Bitcoin, players try to extend the chains they choose by one or more blocks. Finally, in the main function, a tree of blocks is stored and updated at every round. If a player updates his tree, he broadcasts it to all other players.</p>

    <p class="text-gray-300">The protocol is also parameterized by three external functions  <span class="math">V(\\cdot)</span> ,  <span class="math">I(\\cdot)</span> ,  <span class="math">R(\\cdot)</span>  which are called: the input validation predicate, the input contribution function,</p>

    <p class="text-gray-300"><strong>Algorithm 1</strong> The chain selection algorithm. The input is a block tree  <span class="math">\\mathcal{T}</span> . The  <span class="math">|\\cdot|</span>  operator corresponds to the number of nodes of a tree. By  <span class="math">C_1||C_2|</span>  we denote the concatenation of chains  <span class="math">C_1</span> ,  <span class="math">C_2</span> .</p>

    <pre><code class="language-text">1: function GHOST(T)
2:
         B \\leftarrow root(\\mathcal{T})
3:
         if children_{\\mathcal{T}}(B) = \\emptyset then
4:
              {\\bf return}\\ B
5:
         else
6:
              B \\leftarrow argmax_{B&#x27; \\in children_{\\tau}(B)} |subtree_{\\tau}(B&#x27;)|
7:
              return B||\\mathtt{GHOST}(subtree_{\\mathcal{T}}(B))|
8:
         end if
9: end function
</code></pre>

    <p class="text-gray-300">and the chain reading function, respectively.  <span class="math">V(\\cdot)</span>  dictates the structure of the information stored in each block,  <span class="math">I(\\cdot)</span>  determines the data that players put in the block they mine,  <span class="math">R(\\cdot)</span>  specifies how the data in the blocks should be interpreted depending on the application.</p>

    <p class="text-gray-300"><strong>Algorithm 2</strong> The GHOST backbone protocol, parameterized by the <em>input contribution function</em>  <span class="math">I(\\cdot)</span>  and the <em>reading function</em>  <span class="math">R(\\cdot)</span> .  <span class="math">\\mathbf{x}_{\\mathcal{C}}</span>  is the vector of inputs of all block in chain  <span class="math">\\mathcal{C}</span> .</p>

    <pre><code class="language-text">1: \\mathcal{T} \\leftarrow GenesisBlock
                                                                                                                                                   \\triangleright \\mathcal{T} is a tree.
  2: state \\leftarrow \\varepsilon
 3: round \\leftarrow 0
 4: while True do
              \\mathcal{T}_{new} \\leftarrow \\mathsf{update}(\\mathcal{T}, \\mathsf{blocks} \\; \\mathsf{found} \\; \\mathsf{in} \\; \\mathsf{Receive}())
  5:
              \\tilde{\\mathcal{C}} \\leftarrow \\mathtt{GHOST}(\\mathcal{T}_{new})
 6:
              \\langle state, x \\rangle \\leftarrow I(state, \\tilde{\\mathcal{C}}, round, Input(), Receive())
  7:
 8:
              \\mathcal{C}_{\\mathsf{new}} \\leftarrow \\mathsf{pow}(x, \\tilde{\\mathcal{C}})
 9:
              if \\tilde{\\mathcal{C}} \\neq \\mathcal{C}_{new} or \\mathcal{T} \\neq \\mathcal{T}_{new} then
10:
                     \\mathcal{T} \\leftarrow \\mathsf{update}(\\mathcal{T}_{\\mathsf{new}}, \\mathrm{head}(\\mathcal{C}_{\\mathsf{new}}))
                     Broadcast(head(C_{new}))
11:
12:
              end if
13:
              round \\leftarrow round + 1
14:
              if INPUT() contains READ then
                       write R(\\mathbf{x}_{\\mathcal{C}}) to OUTPUT()
15:
16:
               end if
17: end while
</code></pre>

    <p class="text-gray-300">Next, for completeness we present the remaining procedures of the GHOST backbone protocol. Function pow (see Figure 3), which has to do with block mining and is the same as the one defined in the Bitcoin Backbone and function update (see Figure 4) which refers to the way the block tree is updated.</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong> The <em>proof of work</em> function, parameterized by q, D and hash functions  <span class="math">H(\\cdot)</span> ,  <span class="math">G(\\cdot)</span> . The input is  <span class="math">(x, \\mathcal{C})</span> .</p>

    <pre><code class="language-text">1: function pow(x, C)
          if C = \\varepsilon then
                                                                            &#9655; Determine proof of work instance
 2:
 3:
                s \\leftarrow 0
 4:
          else
                \\langle s&#x27;, x&#x27;, ctr&#x27; \\rangle \\leftarrow \\text{head}(\\mathcal{C})
 5:
 6:
                s \\leftarrow H(ctr&#x27;, G(s&#x27;, x&#x27;))
 7:
          end if
          ctr \\leftarrow 1
 8:
 9:
           B \\leftarrow \\varepsilon
10:
           h \\leftarrow G(s, x)
           while (ctr \\leq q) do
11:
                if (H(ctr, h) &lt; D) then
12:
13:
                     B \\leftarrow \\langle s, x, ctr \\rangle
                     break
14:
                end if
15:
16:
                ctr \\leftarrow ctr + 1
           end while
17:
           \\mathcal{C} \\leftarrow \\mathcal{C}B
                                                                                                           \\triangleright Extend chain
18:
19:
           return \\mathcal C
20: end function
</code></pre>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Security Properties</h3>

    <p class="text-gray-300">In [9, Definitions 2&amp;3] two crucial security properties of the Bitcoin backbone protocol were considered, the common prefix and the chain quality property. The common prefix property ensures that two honest players have the same view of the blockchain if they prune a small number of blocks from the tail. On the other hand the chain quality property ensures that honest players chains' do not contain long sequences of adversarial blocks. These properties are defined as predicates over the random variable formed by the concatenation of all parties views' denoted by VIEW <span class="math">_{\\Pi,A,\\mathcal{Z}}^{H(\\cdot)}(\\kappa,q,z)</span> .</p>

    <p class="text-gray-300"><strong>Definition 4 (Common Prefix Property).</strong> The common prefix property  <span class="math">Q_{\\sf cp}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that for any pair of honest players  <span class="math">P_1, P_2</span>  maintaining the chains  <span class="math">C_1, C_2</span>  in  <span class="math">{\\sf VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{H(\\cdot)}(\\kappa, q, z)</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$C_1^{\\lceil k} \\preceq C_2 \\text{ and } C_2^{\\lceil k} \\preceq C_1.</span>$</p>

    <p class="text-gray-300"><strong>Definition 5 (Chain Quality Property).</strong> The chain quality property  <span class="math">Q_{cq}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">\\ell \\in \\mathbb{N}</span>  states that for any honest party P with</p>

    <p class="text-gray-300"><strong>Algorithm 4</strong> The tree update function, parameterized by q, D and hash functions  <span class="math">H(\\cdot)</span> ,  <span class="math">G(\\cdot)</span> . The inputs are a block tree  <span class="math">\\mathcal{T}</span>  and an array of blocks.</p>

    <pre><code class="language-text">1: function update(\\mathcal{T}, B)
         foreach \\langle s, x, ctr \\rangle in \\mathcal{T}
2:
         foreach \\langle s&#x27;, x&#x27;, ctr&#x27; \\rangle in B
3:
         if ((s&#x27; = H(ctr, G(s, x))) \\land (H(ctr&#x27;, G(x&#x27;, ctr&#x27;)) &lt; D)) then
4:
               children_{\\mathcal{T}}(\\langle s, x, ctr \\rangle) = children_{\\mathcal{T}}(\\langle s, x, ctr \\rangle) \\cup \\langle s&#x27;, x&#x27;, ctr&#x27; \\rangle
                                                                                                              &#9654; Add to the
5:
    {\\it tree.}
6:
         end if
7:
         return \\mathcal{T}
8: end function
</code></pre>

    <p class="text-gray-300">chain  <span class="math">\\mathcal{C}</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{H(\\cdot)}(\\kappa,q,z)</span> , it holds that for any  <span class="math">\\ell</span>  consecutive blocks of  <span class="math">\\mathcal{C}</span>  the ratio of adversarial blocks is at most  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">These two properties were shown to hold for the Bitcoin backbone protocol. Formally, in [9, Theorems 9&amp;10] the following were proved:</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Assume f &lt; 1 and  <span class="math">\\gamma_{\\mathsf{u}} \\geq (1 + \\delta)\\lambda\\beta</span> , for some real  <span class="math">\\delta \\in (0,1)</span>  and  <span class="math">\\lambda \\geq 1</span>  such that  <span class="math">\\lambda^2 - f\\lambda - 1 \\geq 0</span> . Let  <span class="math">\\mathcal{S}</span>  be the set of the chains of the honest parties at a given round of the backbone protocol. Then the probability that  <span class="math">\\mathcal{S}</span>  does not satisfy the common-prefix property with parameter k is at most  <span class="math">e^{-\\Omega(\\delta^3 k)}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Assume f&lt;1 and  <span class="math">\\gamma_u\\geq (1+\\delta)\\lambda\\beta</span>  for some  <span class="math">\\delta\\in(0,1)</span> . Suppose  <span class="math">\\mathcal C</span>  belongs to an honest party and consider any  <span class="math">\\ell</span>  consecutive blocks of  <span class="math">\\mathcal C</span> . The probability that the adversary has contributed more than  <span class="math">(1-\\frac{\\delta}{3})\\frac{1}{\\lambda}\\ell</span>  of these blocks is less than  <span class="math">e^{-\\Omega(\\delta^2\\ell)}</span> .</p>

    <p class="text-gray-300">Robust public transaction ledger. In [9] the robust public transaction ledger primitive was presented. It tries to capture the notion of a book where transactions are recorded, and it is used to implement Byzantine Agreement in the honest majority setting.</p>

    <p class="text-gray-300">A public transaction ledger is defined with respect to a set of valid ledgers  <span class="math">\\mathcal{L}</span>  and a set of valid transactions  <span class="math">\\mathcal{T}</span> , each one possessing an efficient membership test. A ledger  <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>  is a vector of sequences of transactions  <span class="math">\\mathbf{tx} \\in \\mathcal{T}</span> . Each transaction  <span class="math">\\mathbf{tx}</span>  may be associated with one or more accounts, denoted  <span class="math">a_1, a_2, \\ldots</span>  Ledgers correspond to chains in the backbone protocols. An oracle Txgen is allowed in the protocol execution that generates valid transactions (this represents transactions that are issued by honest parties). For more details we refer to [9].</p>

    <p class="text-gray-300">We slightly alter the definitions of persistence and liveness so that they are relative to the way parties verify transactions. For example, in Bitcoin a transaction is 'stable' with parameter k if it is at least k blocks deep in the chain. On the</p>

    <p class="text-gray-300">other hand, in GHOST the subtree formed by the block containing a transaction must be of size at least k in order for this transaction to be considered 'stable'. Whenever we talk about the persistence or liveness of Bitcoin or GHOST from now on, we will imply the parameterized versions with the respective definitions of stability that we just mentioned.</p>

    <p class="text-gray-300"><strong>Definition 6.</strong> A protocol  <span class="math">\\Pi</span>  implements a robust public transaction ledger in the q-bounded synchronous setting if it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Persistence: Parameterized by  <span class="math">k \\in \\mathbb{N}</span>  (the &quot;depth&quot; parameter), if in a certain round an honest player reports a transaction tx as 'stable' with parameter k, then whenever an honest party reports it as stable, tx will be in the same position in the ledger.</li>
      <li>Liveness: Parameterized by u, k &isin; N (the &quot;wait time&quot; and &quot;depth&quot; parameters, resp.), provided that a transaction either (i) issued by Txgen, or (ii) neutral, is given as input to all honest players continuously for u consecutive rounds, then all honest parties will report it as 'stable' with parameter k from this round on.</li>
    </ul>

    <p class="text-gray-300">These two properties were shown to hold for the ledger protocol  <span class="math">\\Pi_{PL}</span>  build on top of the Bitcoin Backbone protocol and appropriate instantiation of the functions V, R and I. Formally, in [9, Lemma 15&amp;16] the following were proved:</p>

    <p class="text-gray-300"><strong>Lemma 1 (Persistence).</strong> Suppose f &lt; 1 and  <span class="math">\\gamma_{\\mathsf{u}} \\geq (1 + \\delta)\\lambda\\beta</span> , for some real  <span class="math">\\delta \\in (0,1)</span>  and  <span class="math">\\lambda \\geq 1</span>  such that  <span class="math">\\lambda^2 - f\\lambda - 1 \\geq 0</span> . Protocol  <span class="math">\\Pi_{\\mathsf{PL}}</span>  satisfies Persistence with probability  <span class="math">1 - e^{-\\Omega(\\delta^3 k)}</span> , where k is the depth parameter.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Liveness).</strong> Assume f &lt; 1 and  <span class="math">\\gamma_u \\ge (1+\\delta)\\lambda\\beta</span> , for some  <span class="math">\\delta \\in (0,1)</span> ,  <span class="math">\\lambda \\in [1,\\infty)</span>  and let  <span class="math">k \\in \\mathbb{N}</span> . Further, assume oracle Txgen is unambiguous. Then protocol  <span class="math">\\Pi_{\\mathsf{PL}}</span>  satisfies Liveness with wait time  <span class="math">u = 2k/(1-\\delta)\\gamma_{\\mathsf{u}}</span>  and depth parameter k with probability at least  <span class="math">1 - e^{-\\Omega(\\delta^2 k)}</span> .</p>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 A unified description of Bitcoin and GHOST backbone</h2>

    <p class="text-gray-300">Next, we introduce our new analysis framework for backbone protocols that is focusing on trees of blocks and we show how the description of the Bitcoin and GHOST can be unified. In this model, every player stores all blocks he receives on a tree, starting from a pre-shared block called the Genesis (or  <span class="math">v_{root}</span> ) block. This is the model where GHOST was initially described. Bitcoin, and other possible backbone variants, can also be seen in this model and thus a unified language can be built. We first define block trees (or just trees) that capture the knowledge of honest players (regarding the block tree on different moments at every round).</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> We denote by  <span class="math">\\mathcal{T}_r^P</span>  (resp.  <span class="math">\\mathcal{T}_r</span> ) the tree that is formed from the blocks that player P (resp. at least one honest player) has received up to round r. Similarly,  <span class="math">\\hat{\\mathcal{T}}_r</span>  is the tree that contains  <span class="math">\\mathcal{T}_r</span>  and also includes all blocks mined by honest players at round r. For any tree T and block  <span class="math">b \\in T</span> , we denote by T(b) the subtree of T rooted on b.</p>

    <p class="text-gray-300">Notice that, due to the fact that broadcasts of honest players always succeed, blocks in  <span class="math">\\hat{\\mathcal{T}}_r</span>  are always in  <span class="math">\\mathcal{T}_{r+1}^P</span> . Thus for every honest player P it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{T}_r^P \\subseteq \\mathcal{T}_r \\subseteq \\hat{\\mathcal{T}}_r \\subseteq \\mathcal{T}_{r+1}^P</span>$</p>

    <p class="text-gray-300">Intuitively, heavier trees represent more proof of work. However, there is more than one way to define the weight of a tree. For example, in Bitcoin the heaviest tree is the longest one. On the other hand, for GHOST a heavy tree is one with many nodes. To capture this abstraction we condition our definitions on a norm w that assigns weights on trees. This norm will be responsible for deciding which tree has more proof of work, and thus which tree is favored by the chain selection rule. We choose to omit w from the notation since it will always be clear from the context which norm we use.</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> Let w be a norm defined on trees. For any tree  <span class="math">\\mathcal{T}</span>  let siblings(v) denote the set of nodes in  <span class="math">\\mathcal{T}</span>  that share the same parent with v. Then node v is  <span class="math">\\mathbf{d}</span> -dominant in  <span class="math">\\mathcal{T}</span>  (denoted by  <span class="math">\\mathrm{Dom}_{\\mathcal{T}}(v,d)</span> ) iff</p>

    <p class="text-gray-300"><span class="math">$w(\\mathcal{T}(v)) \\ge d \\land \\forall v&#x27; \\in siblings(v) : w(\\mathcal{T}(v)) \\ge w(\\mathcal{T}(v&#x27;)) + d</span>$</p>

    <p class="text-gray-300">The chain selection rule in the Bitcoin protocol can be described using the notion of the d-dominant node. Let  <span class="math">w(\\mathcal{T})</span>  be the height of some tree  <span class="math">\\mathcal{T}</span> . Each player P, starting from the root of his  <span class="math">\\mathcal{T}_r^P</span>  tree, greedily decides on which block to add on the chain by choosing one of its 0-dominant children and continuing recursively<sup>1</sup> (ties are broken based on time-stamp, or based on which block was received first). Interestingly, the GHOST selection rule can also be described in exactly the same way by setting w to be the number of nodes of the tree. Thus we have a unified way for describing the chain selection rule in both protocols. Building upon this formalism we can describe the paths that fully informed honest players may choose to mine at round r (denoted by HonestPaths(r)) in a quite robust way, thus showcasing the power of our notation.</p>

    <p class="text-gray-300">HonestPaths
<span class="math">$(r) = \\{p = v_{\\text{root}}v_1 \\dots v_k | p \\text{ is a root-leaf path in } \\mathcal{T}_r \\text{ and } \\forall i \\in \\{1, ..., k\\} \\text{ Dom}_{\\mathcal{T}_r}(v_i, 0)\\}</span>$</p>

    <p class="text-gray-300">We conclude this section by presenting two crucial properties that both the Bitcoin and GHOST backbones satisfy. The first property states that by broadcasting k blocks the adversary can decrease the dominance of some block at most by k. Intuitively, it tells us if the adversary's ability to mine new blocks is limited, then his influence over the block tree is also limited. On the other hand, the second property states that uniquely successful rounds increase the dominance only of nodes in the path from the root to the new block.</p>

    <p class="text-gray-300">We will use the term node and block interchangeably from now on.</p>

    <p class="text-gray-300">Proposition 1. For the Bitcoin and GHOST backbone protocols it holds that:</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> This is exactly algorithm 1 with a minor modification. At line 6 the subtree  <span class="math">\\mathcal{T}</span>  that is chosen maximizes  <span class="math">w(\\mathcal{T})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if the adversary broadcast  <span class="math">k \\leq d</span>  blocks at round r-1 then for every block  <span class="math">v \\in \\hat{\\mathcal{T}}_{r-1}</span>  it holds that  <span class="math">\\mathrm{Dom}_{\\hat{\\mathcal{T}}_{r-1}}(v,d)</span>  implies  <span class="math">\\mathrm{Dom}_{\\mathcal{T}_r}(v,d-k)</span> .</li>
      <li>if r is a uniquely successful round and the newly mined block extends a path in HonestPaths(r), then for any block v in  <span class="math">\\mathcal{T}_r</span>  it holds that:  <span class="math">\\mathrm{Dom}_{\\mathcal{T}_r}(v,d)</span>  implies  <span class="math">\\mathrm{Dom}_{\\hat{\\mathcal{T}}_r}(v,d+1)</span>  if and only if v is in the path from  <span class="math">v_{\\mathrm{root}}</span>  to the new block.</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> The lemma stems from the fact that adding only one block in the tree reduces or increases the dominance of some block by at most 1. For the first bullet, adding k blocks one by one, implies that the dominance of any node will reduce or increase by at most k. For the second bullet, notice that dominance increases only for blocks that get heavier. The only blocks that get heavier in this case are the ones in the path from the root to the newly mined block. Since these blocks are in HonestPaths(r), they are at least 0-dominant and so their dominance will further increase. Furthermore, the newly mined block is 1-dominant since it does not have any siblings.</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: An example of the change in dominance after a uniquely successful round. The only nodes which increase their dominance the ones in the path from the root to the newly mined block as stated in Proposition 1.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Security Analysis and Applications</h2>

    <p class="text-gray-300">Next, we prove that the GHOST backbone protocol is sufficient to construct a robust transaction ledger. From now on we assume that w(T) is the total number of nodes of tree T.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The Fresh Block Lemma</h3>

    <p class="text-gray-300">In [9], it was shown that the Bitcoin Backbone satisfies two main properties: common prefix and chain quality. However, another fundamental property needed for their proof, is that the chains of honest players grow at least at the rate of successful rounds. This does not hold for GHOST. The reason is that, if an honest player receives a chain that is heavier than the one he currently has, he will select it, even if it is shorter. To reflect these facts, we develop an argument that is a lot more involved and leads to a power lemma that we call the &quot;fresh block lemma&quot;.</p>

    <p class="text-gray-300">First, we introduce a new notion, that of a path that all of its nodes are dominant up to a certain value. Intuitively, the more dominant a path is, the harder it gets for the adversary to stop honest players from choosing it.</p>

    <p class="text-gray-300"><strong>Definition 9.</strong>  <span class="math">(p_{\\text{dom}}(r,d))</span>  For d &gt; 0,  <span class="math">p_{\\text{dom}}(r,d)</span>  is the longest path  <span class="math">p = v_{\\text{root}}v_1 \\dots v_k</span>  in  <span class="math">\\hat{\\mathcal{T}}_r</span>  s.t.</p>

    <p class="text-gray-300"><span class="math">$p \\neq v_{\\text{root}} \\land \\forall i \\in \\{1, \\dots, k\\} : \\operatorname{Dom}_{\\hat{\\mathcal{T}}_r}(v_i, d)</span>$</p>

    <p class="text-gray-300">If no such path exists  <span class="math">p_{dom}(r, d) = \\bot</span> .</p>

    <p class="text-gray-300">Note that the dominant path  <span class="math">p_{dom}(r, d)</span> , if it is not  <span class="math">\\perp</span> , will be unique (this stems from the requirement that d &gt; 0).</p>

    <p class="text-gray-300">In the next lemma, we show that unless the number of blocks the adversary broadcasts in a round interval is at least as big as the number of uniquely successful rounds that have occurred, an honest block mined in one of these rounds will be deep enough in the chains of honest players. More specifically, for any sequence of m (not necessarily consecutive) uniquely successful rounds starting at some round r', no matter the strategy of the adversary, at round r there will be at least one honest block in  <span class="math">p_{\\text{dom}}(r, m-k)</span>  where k is the number of adversarial blocks that have been released during rounds [r'-1, r-1].</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let  <span class="math">r_1, ..., r_m</span>  be uniquely successful rounds from round r' until round r. If the adversary broadcasts k &lt; m blocks from round r' - 1 until round r - 1, then there exists an honest block b, mined in one of the rounds  <span class="math">r_1, ..., r_m</span>  such that b is in  <span class="math">p_{\\text{dom}}(r, m - k)</span> .</p>

    <p class="text-gray-300"><em>Proof sketch.</em> The proof is based on two observations. Firstly, if the adversary does not broadcast a block in the round before a uniquely successful round s, then the newly mined honest block will be in  <span class="math">p_{\\text{dom}}(s,1)</span> . Secondly, if the adversary broadcasts k &lt; d blocks in the round before a uniquely successful round s, all</p>

    <p class="text-gray-300">blocks in  <span class="math">p_{dom}(s-1,d)</span>  at round s-1 will also be in  <span class="math">p_{dom}(s,d+1-k)</span> . It follows that for each uniquely successful round, unless the adversary broadcasts a block, an honest block will be introduced in the dominant path and will be maintained there unless the adversary broadcasts more blocks than the number of uniquely successful rounds that follow. As a result, in the period from round r' until round r, our assumption that the adversary broadcasts strictly less than m blocks, implies that at least one block will be maintained in  <span class="math">p_{dom}(r, m-k)</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">The fresh block lemma is stated next. Informally, it states that at any point in time, in any past sequence of s consecutive rounds, at least one honest block was mined and is permanently inserted in the chain that every honest player adopts, with overwhelming probability on s.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> (Fresh Block Lemma) Assume  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span> , for some real  <span class="math">\\delta \\in (0,1)</span>  and f &lt; 1. Then, for all  <span class="math">s \\in \\mathbb{N}</span>  and  <span class="math">r \\geq s</span>  it holds that there exists a block mined by an honest player on and after round r - s, that is contained in the chain which any honest player adopts on and after round r with probability  <span class="math">1 - e^{-\\Omega(\\delta^2 s)}</span> .</p>

    <p class="text-gray-300"><em>Proof sketch.</em> The difficulty of proving this lemma stems from the fact that in GHOST, the chains of honest players are not always strictly increasing. That is, honest players may switch from a longer to a shorter chain. Monotonicity allows us to prove many useful things; for example that the adversary cannot use very old blocks in order to maintain a fork as in [9].</p>

    <p class="text-gray-300">To overcome this difficulty, we first show that whenever the adversary forces honest players to work on a different branch of the block tree, he has to broadcast as many blocks as the ones that where mined on uniquely successful rounds on this branch of the tree. Hence, it is hard for the adversary to force honest players to change branches all the time, and moreover, after s rounds this will be impossible due to the fact that  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span> . But if all honest players stay on one branch, the blocks near the root of the branch will permanently enter their chains. We show that at least one of these blocks will be mined by an honest player. By applying this idea in an iterative manner, the lemma follows.</p>

    <p class="text-gray-300">For the full proof of the lemma we refer to the Appendix.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 A robust public transaction ledger</h3>

    <p class="text-gray-300">In [9] it is shown how to instantiate the functions V, R, I so that the resulting protocol, denoted by  <span class="math">\\Pi_{PL}</span> , built on top of the Bitcoin backbone, implements a robust transaction ledger. In this section we show how we can achieve the same goal, using exactly the same instantiation of V,R,I, but on top of the GHOST backbone. We call the resulting protocol,  <span class="math">\\Pi_{PL}^{GHOST}</span> .</p>

    <p class="text-gray-300">Having established that every s rounds a fresh and honest block is inserted permanently in the chain of all players, we are in a position to prove the main</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup> Throughout this work, we only consider executions that run for a polynomial number of rounds in the security parameter  <span class="math">\\kappa</span> .</p>

    <p class="text-gray-300">properties of a robust transaction ledger. Liveness stems from the fact that after s rounds from the time a transaction was issued, an honest block that contains this transaction will stabilize in the chain. Thus, by waiting for at most  <span class="math">s/\\alpha</span>  more rounds, the honest parties will mine enough block so that this transaction becomes 'stable' with parameter s. Persistence is implied by the fact that when a player reports a transaction as stable for the first time, enough time has passed from the time the block containing the transaction was mined, and thus there exists an honest block descending it that has been permanently added to the chain of all honest parties.</p>

    <p class="text-gray-300"><strong>Lemma 5 (Liveness).</strong> Assume  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span> , for some  <span class="math">\\delta \\in (0,1)</span>  and f &lt; 1. Further, assume oracle Txgen is unambiguous. Then for all  <span class="math">k \\in \\mathbb{N}</span>  protocol  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{GHOST}}</span>  satisfies Liveness with wait time  <span class="math">u = k + \\frac{k}{(1-\\delta)\\alpha}</span>  rounds and depth parameter k with probability at least  <span class="math">1 - e^{-\\Omega(\\delta^2 k)}</span> .</p>

    <p class="text-gray-300">Proof. We prove that assuming all honest players receive as input the transaction tx for at least u rounds, any honest party at round r with chain  <span class="math">\\mathcal C</span>  will report tx as 'stable'. By Lemma 4 it follows that with probability  <span class="math">1-e^{-\\Omega(\\delta^2k)}</span>  there exists an honest block mined during rounds [r-u,r-u+k], such that all honest players have this block in the chains they mine from round r-u+k and onward. Without loss of generality this block contains tx. All blocks that honest players mine during the remaining  <span class="math">\\frac{k}{(1-\\delta)\\alpha}</span>  rounds will be descendants of this block. By an application of the Chernoff bound, with probability  <span class="math">1-e^{-\\Omega(\\delta^2k)}</span> , the honest parties will mine at least k blocks in this round interval and thus the lemma follows with the desired probability.</p>

    <p class="text-gray-300"><strong>Lemma 6 (Persistence).</strong> Suppose  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span>  and  <span class="math">(1+\\delta)f \\leq 1</span> , for some real  <span class="math">\\delta \\in (0,1)</span> . Then for all  <span class="math">k \\in \\mathbb{N}</span>  protocol  <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{GHOST}}</span>  satisfies Persistence with probability  <span class="math">1 - e^{-\\Omega(\\delta^2 k)}</span> , where k is the depth parameter.</p>

    <p class="text-gray-300"><em>Proof.</em> Let B be the block that contains transaction tx that the honest party P reported as stable at round r. We will argue that B must have been computed before round r - k, and thus by Lemma 4 all honest players will report it in the same position in their chains.</p>

    <p class="text-gray-300">Let  <span class="math">E_1</span>  be the event where B is computed after round  <span class="math">r-k/((1+\\delta)f) &lt; r-k</span> . The number of descendants of B cannot be greater than the number of solutions Y obtained from the oracle in this amount of rounds. By the Chernoff bound,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[Y \\ge (1+\\delta)f\\frac{k}{(1+\\delta)f}] = \\Pr[Y \\ge k] \\le e^{-\\delta^2 f s/3}.</span>$</p>

    <p class="text-gray-300">Since tx is reported as stable, B must have k descendants and thus  <span class="math">E_1</span>  implies that Y must be greater or equal to k. Hence,  <span class="math">\\Pr[E_1] \\leq \\Pr[Y \\geq k] \\leq e^{-\\delta^2 f s/3}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">E_2</span>  be the event where Lemma 4 does not hold for round r. This happens with probability at most  <span class="math">e^{-\\Omega(\\delta^2 k)}</span> . By the union bound, the event  <span class="math">E_1 \\vee E_2</span>  happens with probability at most  <span class="math">e^{-\\Omega(\\delta^2 k)}</span> . Assuming that  <span class="math">E_1 \\vee E_2</span>  does not</p>

    <p class="text-gray-300">occur, it follows that there exists an honest block B<sup>0</sup> mined on and after round r &minus; k that will be in the chains of all honest players from round r and onward. Hence, B must be an ancestor of B<sup>0</sup> and all honest players will report B and tx at the same position as P from round r and onward. Persistence follows with the desired probability.</p>

    <p class="text-gray-300">Theorem 3. Assuming &gamma; &ge; (1 + &delta;)&beta; and (1 + &delta;)f &le; 1, for some real &delta; &isin; (0, 1), the protocol &Pi;GHOST PL implements a robust transaction ledger.</p>

    <p class="text-gray-300">As a nal note, Lemma 4 is sucient to prove Persistence and Liveness in a black-box way. Compared to the approach of [9], that was further expanded in [13] and [22], only one property, instead of three, of the underlying backbone protocol suces in order to get a robust public transaction ledger in a blackbox manner. On the other hand, the three properties described in these works, common-prex, chain quality and chain growth, also serve as metrics of the eciency of the underlying mechanism and provide more information than the fresh block lemma.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In Advances in CryptologyCRYPTO 2015, pages 379399. Springer, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Aspnes, C. Jackson, and A. Krishnamurthy. Exposing computationallychallenged byzantine impostors. Department of Computer Science, Yale University, New Haven, CT, Tech. Rep, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>L. Bahack. Theoretical bitcoin attacks with less than half of the computational power (draft). Cryptology ePrint Archive, Report 2013/868, 2013. http://eprint. iacr.org/.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Bonneau. Ethiks: Using ethereum to audit a coniks key transparency log.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. G. Ethan Heilman. Alison Kendler, Aviv Zohar. Eclipse attacks on bitcoin's peer-to-peer network. Cryptology ePrint Archive, Report 2015/263, 2015. http: //eprint.iacr.org/.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>ethereum/wiki. A next-generation smart contract and decentralized application platform, October 2015. https://github.com/ethereum/wiki/wiki/White-Paper/.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>I. Eyal, A. E. Gencer, E. G. Sirer, and R. van Renesse. Bitcoin-ng: A scalable blockchain protocol. CoRR, abs/1510.02037, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography, 2014.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Soa, Bulgaria, April 26-30, 2015, Proceedings, Part II, pages 281310, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Gervais, G. O. Karame, K. W&uuml;st, V. Glykantzis, H. Ritzdorf, and S. Capkun. On the security and performance of proof of work blockchains. Cryptology ePrint Archive, Report 2016/555, 2016. http://eprint.iacr.org/2016/555.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Hi&ordm;ak and R. Logo&ordm;ar. A derivation of the mean absolute distance in onedimensional random walk. Tehni&pound;ki glasnik, 5(1):1016, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Juels, A. Kosba, and E. Shi. The ring of gyges: Using smart contracts for crime. aries, 40:54, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Kiayias and G. Panagiotakos. Speed-security tradeos in blockchain protocols. Technical report, IACR: Cryptology ePrint Archive, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Kiayias and G. Panagiotakos. Speed-security tradeos in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015. http://eprint.iacr.org/ 2015/1019.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Kiayias, H.-S. Zhou, and V. Zikas. Fair and robust multi-party computation using a global transaction ledger, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. Technical report, Cryptology ePrint Archive, Report 2015/675, 2015. http://eprint. iacr. org, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382401, 1982.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. D. Lerner. Even faster block-chains with the decor protocol. Cryptology ePrint Archive, Report 2013/881, May 2014. https://bitslog.wordpress.com/2014/ 05/02/decor/.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Okun. Agreement among unacquainted byzantine generals. In P. Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499500. Springer, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Omohundro. Cryptocurrencies, smart contracts, and articial intelligence. AI matters, 1(2):1921, 2014.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Pass, L. Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. Cryptology ePrint Archive, Report 2016/454, 2016. http://eprint.iacr.org/.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228234, 1980.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>C. Percival. Stronger key derivation via sequential memory-hard functions. Selfpublished, pages 116, 2009.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Peterson and J. Krug. Augur: a decentralized, open-source platform for prediction markets. arXiv preprint arXiv:1501.01042, 2015.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. A. Simplicio Jr, L. C. Almeida, E. R. Andrade, P. C. dos Santos, and P. S. Barreto. The lyra2 reference guide. Technical report, version 2.3. 2. Technical report, 2014.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. Financial Cryptography and Data Security, 2015.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">In this section we demonstrate a lower bound on the probability of uniquely successful rounds. This bound allows us to argue about the security of GHOST even when f is larger than 1.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> For
<span class="math">$p &lt; 0.1</span>$
and  <span class="math">a \\in (p, 2k)</span> :  <span class="math">e^{-a-kp} \\le (1-p)^{\\frac{a}{p}-k} \\le e^{-a+kp}</span></p>

    <p class="text-gray-300">Proof. The second inequality is well studied and holds for p &gt; 0. For the rst inequality by solving for a we get a &le; k ln(1&minus;p) 1+ ln(1&minus;p) p which holds for p &lt; 0.1 and a &isin; (p, 2k).</p>

    <p class="text-gray-300">Let &gamma; be a lower bound on the probability of a uniquely successful round (a round where only one block is found). From the event where (n &minus; t) players throw q coins each and exactly one coin toss comes head, the probability of a uniquely successful rounds is at least:</p>

    <p class="text-gray-300"><span class="math">$(n-t)qp(1-p)^{q(n-t)-1} \\ge \\alpha e^{-\\alpha - kp}</span>$</p>

    <p class="text-gray-300">We set &gamma; = ae&minus;a&minus;kp, for the minimum k that satises the relation &alpha; &isin; (p, 2k). This is a substantially better bound that &gamma;<sup>u</sup> and is also a lower bound for the event that at a round is successful. The relation of the two bounds is depicted in Figure 2.</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: Comparison of the lower bounds on the probability of a uniquely successful round, &gamma; and &gamma;u, used respectively in this work and [9]. Notice that &gamma; allows as to argue about security when f is greater than 1.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Proofs</h2>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8">B.1 Proof of Lemma 3</h3>

    <p class="text-gray-300"><em>Proof.</em> We are first going to prove two preliminary claims that show the effect of a uniquely successful round to  <span class="math">p_{\\text{dom}}</span> . The first claim shows that if a uniquely successful round s is not compensated accordingly by the adversary, a newly mined block will be forced into  <span class="math">p_{\\text{dom}}(s,1)</span> .</p>

    <p class="text-gray-300">Claim 1. Let round s be a uniquely successful round and b be the honest block mined at round s. If the adversary does not broadcast any block at round s-1 then  <span class="math">b \\in p_{\\text{dom}}(s,1)</span> .</p>

    <p class="text-gray-300">Proof of Claim. First, notice that since the adversary does not broadcast any block it holds that for any honest player P,  <span class="math">\\mathcal{T}_s</span>  is equal to  <span class="math">\\mathcal{T}_s^P</span> . Therefore, all nodes in the path from  <span class="math">v_{\\text{root}}</span>  to the parent of b are at least 0-dominant in  <span class="math">\\mathcal{T}_s</span>  and thus this path is in HonestPaths(s). Since s is uniquely successful, all conditions of the second bullet of Proposition 1 are met, and thus it is implied that all nodes up to the newly mined block in  <span class="math">\\hat{\\mathcal{T}}_s</span>  are 1-dominant. It follows that  <span class="math">b \\in p_{\\text{dom}}(s, 1)</span> .</p>

    <p class="text-gray-300">The second claim shows the effect of a uniquely successful round s to an existing  <span class="math">p_{\\text{dom}}(s-1,d)</span>  path. Notice that if the adversary broadcasts less than d blocks the same nodes continue to be at least 1-dominant in the following round.</p>

    <p class="text-gray-300">Claim 2. Let round s be a uniquely successful round, b be the honest block mined at round s and  <span class="math">p_{\\text{dom}}(s-1,d) \\neq \\bot</span> . If the adversary broadcasts (i) k &lt; d blocks at round s-1 then  <span class="math">p_{\\text{dom}}(s-1,d) \\subseteq p_{\\text{dom}}(s,d+1-k)</span> , (ii) k=d blocks at round s-1 then either  <span class="math">b \\in p_{\\text{dom}}(s,1)</span>  or  <span class="math">p_{\\text{dom}}(s-1,d) \\subseteq p_{\\text{dom}}(s,1)</span>  and b is a descendant of the last node in  <span class="math">p_{\\text{dom}}(s-1,d)</span> .</p>

    <p class="text-gray-300">Proof of Claim. There are two cases. In the first case suppose the adversary broadcasts k &lt; d blocks. Then, according to the first bullet of Proposition 1, the adversary can lower the dominance in  <span class="math">\\mathcal{T}_s</span>  of nodes in  <span class="math">p_{\\text{dom}}(s-1,d)</span>  by at most k. Thus  <span class="math">p_{\\text{dom}}(s-1,d)</span>  will be a prefix of all the chains in HonestPaths(s). But because s is a uniquely successful round, the dominance in  <span class="math">\\hat{\\mathcal{T}}_s</span>  of all nodes in  <span class="math">p_{\\text{dom}}(s-1,d)</span>  will increase by one. Therefore  <span class="math">p_{\\text{dom}}(s-1,d) \\subseteq p_{\\text{dom}}(s,d+1-k)</span>  and b will be a descendant of the last node in  <span class="math">p_{\\text{dom}}(s-1,d)</span> .</p>

    <p class="text-gray-300">In the second case suppose the adversary broadcasts k=d blocks. If he does not broadcast all of these blocks to reduce the dominance in  <span class="math">\\mathcal{T}_s</span>  of the nodes in  <span class="math">p_{\\text{dom}}(s-1,d)</span> , then  <span class="math">p_{\\text{dom}}(s-1,d)</span>  will be a prefix of all the chains in HonestPaths(s) and as in the previous case,  <span class="math">p_{\\text{dom}}(s-1,d) \\subseteq p_{\\text{dom}}(s,d+1-k)</span>  and b will be a descendant of the last node in  <span class="math">p_{\\text{dom}}(s-1,d)</span> .</p>

    <p class="text-gray-300">Otherwise the adversary will reduce the dominance in  <span class="math">\\mathcal{T}_s</span>  of at least one node in  <span class="math">p_{\\text{dom}}(s-1,d)</span>  to zero. If b is a descendant of the last node in  <span class="math">p_{\\text{dom}}(s-1,d)</span> , then all nodes in  <span class="math">p_{\\text{dom}}(s-1,d)</span>  will be 1-dominant in  <span class="math">\\hat{\\mathcal{T}}_s</span>  and  <span class="math">p_{\\text{dom}}(s-1,d) \\subseteq p_{\\text{dom}}(s,1) = p_{\\text{dom}}(s,d+1-d)</span> . If b is not a descendant of the last node in  <span class="math">p_{\\text{dom}}(s-1,d)</span> , then for the player P that mined this block it holds that  <span class="math">\\mathcal{T}_s^P = \\mathcal{T}_s</span> ,</p>

    <p class="text-gray-300">because he would have not mined a chain that does not contain  <span class="math">p_{\\text{dom}}(s-1,d)</span>  at round s otherwise. Therefore, P at round s was mining a chain that belonged to HonestPaths <span class="math">(s, v_{\\text{root}})</span>  and thus all nodes in the chain are at least 0-dominant in  <span class="math">\\mathcal{T}_s</span> . But because s is a uniquely successful round the dominance of all nodes in the chain that s belongs to will increase by one and thus s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s belongs to s and s and s and s belongs to s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s and s an</p>

    <p class="text-gray-300">Let  <span class="math">b_i</span>  denote the honest block mined at round  <span class="math">r_i</span> . Let us assume that  <span class="math">r = r_m</span> . We are going to prove the lemma using induction on the number of uniquely successful rounds m.</p>

    <p class="text-gray-300">For the base case suppose m=1. The adversary does not broadcast any block until round  <span class="math">r_1-1</span>  and from the first claim  <span class="math">b_1 \\in p_{\\text{dom}}(r_1,1)</span> . Thus the base case is proved. Suppose the lemma holds for m-1 uniquely successful rounds and let  <span class="math">k_1</span>  be the number of blocks that the adversary broadcasts in the round interval  <span class="math">[r&#x27;-1, r_{m-1}-1]</span> . We have two cases.</p>

    <p class="text-gray-300">(First case)  <span class="math">k_1 = m - 1</span>  and the adversary broadcasts no blocks in the rest of the rounds. From the first claim it follows that  <span class="math">b_m \\in p_{\\text{dom}}(r_m, 1)</span> .</p>

    <p class="text-gray-300">(Second case)  <span class="math">k_1 &lt; m-1</span>  and from the induction hypothesis there exist blocks  <span class="math">b&#x27;_1, ..., b&#x27;_{m-1-k_1}</span>  mined by honest players at the uniquely successful rounds  <span class="math">r_1, ..., r_{m-1}</span>  where  <span class="math">b&#x27;_i \\in \\mathrm{p}_{\\mathrm{dom}}(r_{m-1}, i)</span> . Let  <span class="math">k_2</span>  be the number of blocks that the adversary broadcasts until round  <span class="math">r_m-2</span>  and  <span class="math">k_3</span>  the number of blocks he broadcasts at round  <span class="math">r_m-1</span> . If  <span class="math">k_2=m-1</span>  then again from the first claim it follows that  <span class="math">b_m \\in \\mathrm{p}_{\\mathrm{dom}}(r_m,1)</span> . If  <span class="math">k_2 &lt; m-1</span>  then if  <span class="math">k_3 + k_2 = m-1</span>  then from the second claim either  <span class="math">b_m \\in \\mathrm{p}_{\\mathrm{dom}}(r_m,1)</span>  or  <span class="math">b&#x27;_{m-1-k_1} \\in \\mathrm{p}_{\\mathrm{dom}}(r_m,1)</span> . If  <span class="math">k_3 + k_2 &lt; m-1</span>  then again from the second claim at round  <span class="math">r_m, b&#x27;_i \\in \\mathrm{p}_{\\mathrm{dom}}(r_m-1,i)</span>  for i in  <span class="math">\\{k_2 + k_3 + 1, ..., m-1-k_1\\}</span>  and either  <span class="math">b&#x27;_{k_2+k_3}</span>  is in  <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r_m,1)</span>  or  <span class="math">b_m</span>  is in  <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r_m,1)</span> . This completes the induction proof.</p>

    <p class="text-gray-300">We proved that if  <span class="math">k_4 &lt; m</span>  is the number of blocks the adversary broadcasts until round  <span class="math">r_m - 1</span> , then there exists honest blocks  <span class="math">b&#x27;_1, ..., b&#x27;_{m-k_4}</span>  s.t.  <span class="math">b&#x27;_i</span>  is in  <span class="math">p_{\\text{dom}}(r_m, i)</span> . Now in the case  <span class="math">r &gt; r_m</span> , let  <span class="math">k_5 &lt; m - k_4</span>  be the number of blocks the adversary broadcasts in the remaining rounds. The lemma follows easily from the second claim.</p>

    <p class="text-gray-300">Remark 1. Let  <span class="math">r_1, ..., r_m</span>  be uniquely successful rounds up to round r and the honest block mined at round  <span class="math">r_1</span>  be in  <span class="math">p_{\\text{dom}}(r_1, 1)</span> . If the adversary broadcasts k &lt; m blocks from round  <span class="math">r_1</span>  until round r - 1, then there exists an honest block b mined in one of the rounds  <span class="math">r_1, ..., r_m</span>  such that b in  <span class="math">p_{\\text{dom}}(r, m - k)</span> . (to see why the remark holds notice that that blocks that the adversary broadcasts before round  <span class="math">r_1</span>  affect only the dominant path at round  <span class="math">r_1</span> , and not at the following rounds)</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8">B.2 Proof of Lemma 4</h3>

    <p class="text-gray-300"><em>Proof.</em> Let random variable  <span class="math">Z_{s_1,s_2}</span>  (resp.  <span class="math">Z_{s_1,s_2}^{bd}</span> ) denote the number of blocks the adversary computes (resp. broadcasts) from round  <span class="math">s_1</span>  until round  <span class="math">s_2</span> , and random</p>

    <p class="text-gray-300">variable  <span class="math">X_{s_1,s_2}</span>  denote the number of rounds that are uniquely successful in the same interval.</p>

    <p class="text-gray-300">We are first going to prove two preliminary claims. We show that as long as from some round r and afterwards the adversary broadcasts less blocks than the total number of uniquely successful rounds, the chain that any honest player adopts after round r extends  <span class="math">p_{\\text{dom}}(r, X_{1,r} - Z_{1,r})</span> . More generally we can prove the following claim.</p>

    <p class="text-gray-300">Claim 3. Consider any execution such that for all  <span class="math">s_2 \\geq s_1</span>  it holds that  <span class="math">Z_{1,s_2} &lt; X_{1,s_2}</span> . Then, the chain that any honest player adopts after round  <span class="math">s_1</span>  extends  <span class="math">p_{\\text{dom}}(s_1, X_{1,s_1} - Z_{1,s_1})</span> .</p>

    <p class="text-gray-300">Proof of Claim. Since  <span class="math">X_{1,s_1} &gt; Z_{1,s_1}</span>  from Lemma 3 if follows that  <span class="math">p = p_{\\text{dom}}(s_1, X_{1,s_1} - Z_{1,s_1-1}) \\neq \\bot</span> . As long as the number of blocks that the adversary broadcasts at round  <span class="math">s_2</span>  are less than the dominance of the nodes in p in  <span class="math">\\hat{\\mathcal{T}}_{s_2-1}</span> , all honest players at round  <span class="math">s_2</span>  will adopt chains containing p. Thus uniquely successful rounds will increase the dominance of these nodes. But since from the assumptions made,  <span class="math">Z_{1,s_2} &lt; X_{1,s_2}</span> , in all rounds after round  <span class="math">s_1</span> , the nodes in p are at least 1-dominant in every  <span class="math">\\mathcal{T}_{s_2}^P</span>  where P is an honest player; the claim follows.</p>

    <p class="text-gray-300">Next we will show that if successive u.s. rounds occur such that the blocks mined are on different branches, then the adversary must broadcast an adequate number of blocks, as specified below.</p>

    <p class="text-gray-300">Claim 4. Consider any execution where  <span class="math">s_1 &lt; s_2 &lt; \\ldots &lt; s_m</span>  are u.s. rounds and  <span class="math">s_k</span>  is the first u.s. round such that the honest block mined in this round is not a descendant of the honest block mined in round  <span class="math">s_{k-1}</span> , for  <span class="math">k \\in \\{2, \\ldots, m\\}</span> . Then either  <span class="math">Z_{s_1-1,s_m-1}^{bd} &gt; X_{s_1,s_m-1}</span>  or  <span class="math">Z_{s_1-1,s_m-1}^{bd} = X_{s_1,s_m-1}</span>  and the honest block mined at round  <span class="math">s_m</span>  will be in  <span class="math">p_{\\text{dom}}(s_m, 1)</span> .</p>

    <p class="text-gray-300">Proof of Claim. Let  <span class="math">b_1,...,b_m</span>  denote the honest blocks mined at rounds  <span class="math">s_1,...,s_m</span>  respectively. We are going to prove the claim for m=2. Suppose, for the sake of contradiction, that  <span class="math">Z_{s_1-1,s_2-1}^{bd} &lt; X_{s_1,s_2-1}</span> . By the definition of  <span class="math">s_2</span> , the honest blocks mined on all u.s. rounds until round  <span class="math">s_2-1</span>  are descendants of  <span class="math">b_1</span> . From Lemma 3 at least one honest block b computed in one of the u.s. rounds in  <span class="math">[s_1,s_2-1]</span>  will be in  <span class="math">p_{\\text{dom}}(s_2-1,X_{s_1,s_2-1}-Z_{s_1-1,s_2-2}^{bd})</span> . Since from our hypothesis the adversary will broadcast less than  <span class="math">Z_{s_2-1,s_2-1}^{bd} &lt; X_{s_1,s_2-1}-Z_{s_1-1,s_2-2}^{bd}</span>  blocks at round  <span class="math">s_2-1</span> , it is impossible for  <span class="math">b_2</span>  not to be a descendant of b and thus of  <span class="math">b_1</span>  which is a contradiction. Hence,  <span class="math">Z_{s_1-1,s_2-1}^{bd} \\ge X_{s_1,s_2-1}</span> . If  <span class="math">Z_{s_1-1,s_2-1}^{bd} &gt; X_{s_1,s_2-1}</span>  the base case follows. Otherwise,  <span class="math">Z_{s_1-1,s_2-1}^{bd} = X_{s_1,s_2-1}</span>  and we have two cases. In the first case,  <span class="math">X_{s_1,s_2-1} = Z_{s_1-1,s_2-2}^{bd}</span>  and at round round  <span class="math">s_2-1</span>  the adversary does not broadcast any block. From Claim B.1 of Lemma 3,  <span class="math">b_2</span>  will be in  <span class="math">p_{\\text{dom}}(s_2,1)</span> . In the second case, it holds that the adversary broadcasts exactly  <span class="math">X_{s_1,s_2-1} - Z_{s_1-1,s_2-2}^{bd}</span>  blocks at round  <span class="math">s_2-1</span> . From Claim B.1 of Lemma 3, since  <span class="math">b_2</span>  cannot be a descendant of the last node of  <span class="math">p_{\\text{dom}}(s_2-1,1)</span> ,  <span class="math">b_2</span>  will be in  <span class="math">p_{\\text{dom}}(s_2,1)</span> . Hence, the base case follows.</p>

    <p class="text-gray-300">Suppose the lemma holds until round  <span class="math">s_m</span> . By the inductive hypothesis we have two cases. In the first case  <span class="math">Z_{s_1-1,s_m-1}^{bd} &gt; X_{s_1,s_m-1}</span>  which implies  <span class="math">Z_{s_1-1,s_m-1}^{bd} \\geq X_{s_1,s_m}</span> . If no u.s. round happens during rounds  <span class="math">s_m+1,\\ldots,s_{m+1}-1</span>  then from Claim B.1 in the proof of Lemma 3 the claim follows. Otherwise, a u.s. round s' happens during these rounds, where the honest block mined is a descendant of  <span class="math">b_m</span> . Then we can make the same argument as for the base case starting from round s' and get that either  <span class="math">Z_{s&#x27;-1,s_{m+1}-1}^{bd} &gt; X_{s&#x27;,s_{m+1}-1}</span>  or  <span class="math">Z_{s&#x27;-1,s_{m+1}-1}^{bd} = X_{s&#x27;,s_{m+1}-1}</span>  and the honest block mined at round  <span class="math">s_{m+1}</span>  will be in  <span class="math">p_{\\text{dom}}(s_{m+1},1)</span> . Since  <span class="math">Z_{s&#x27;-1,s_{m+1}-1}^{bd} &lt; Z_{s_m-1,s_{m+1}-1}^{bd}</span>  and  <span class="math">X_{s&#x27;,s_{m+1}-1} = X_{s_m+1,s_{m+1}-1}</span> , by the inequality of the inductive hypothesis the claim follows.</p>

    <p class="text-gray-300">In the second case  <span class="math">Z^{bd}_{s_1-1,s_m-1}=X_{s_1,s_m-1}</span>  and the honest block  <span class="math">b_m</span>  mined at round  <span class="math">s_m</span>  will be in  <span class="math">p_{\\text{dom}}(s_m,1)</span> . From Remark 1 of the proof of claim Lemma 3, for an application of this Lemma from rounds  <span class="math">s_m</span>  until  <span class="math">s_{m+1}-1</span>  we can count the adversarial blocks starting from round  <span class="math">s_m</span> . Thus from the same argument as for the base case starting from round  <span class="math">s_m</span>  we get that either  <span class="math">Z^{bd}_{s_m,s_{m+1}-1} &gt; X_{s_m,s_{m+1}-1}</span>  or  <span class="math">Z^{bd}_{s_m,s_{m+1}-1} = X_{s_m,s_{m+1}-1}</span>  and the honest block mined at round  <span class="math">s_m</span>  will be in  <span class="math">p_{\\text{dom}}(s_m,1)</span> . By the equality of the inductive hypothesis the claim follows.</p>

    <p class="text-gray-300">Next, we observe that Lemma 3 as well as Claim B.2 and B.2 can be applied on a subtree of the block tree, if all honest blocks mined after the round the root of the subtree was mined are on this subtree.</p>

    <p class="text-gray-300"><strong>Observation 1.</strong> Let b be an honest block computed at round  <span class="math">s_1</span>  that is in the chains adopted by all honest players after round  <span class="math">s_2</span> . Also, suppose that all blocks mined at u.s. rounds after round  <span class="math">s_1</span>  are descendants of b. Then the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Regarding applications of Lemma 3 and Claim B.2 on the subtree of the block tree rooted on b after round  <span class="math">s_1</span> , we can ignore all blocks that the adversary has mined up to round  <span class="math">s_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Regarding applications of Claim B.2 after round  <span class="math">s_2</span> , we can ignore all blocks that the adversary has mined up to round  <span class="math">s_1</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">To see why the observation holds consider the following. Since the adversary receives block b for the first time at round  <span class="math">s_1 + 1</span> , all blocks that the adversary mines before round  <span class="math">s_1 + 1</span>  cannot be descendants of b. Regarding the first point, blocks that are not descendants of b do not affect the validity of Lemma 3 and Claim B.2 on the subtree of the block tree rooted on b; this is because blocks that are not descendants of b, do not affect the dominance of the nodes of the subtree rooted at b. Regarding the second point, consider the dominant path at round  <span class="math">s_3 &gt; s_2</span>  in the subtree that is rooted on b. Then, this path can be extended up to the root node, since, by our assumption, b is in the chains adopted by all honest players after round  <span class="math">s_2</span> .</p>

    <p class="text-gray-300">We are now ready to prove the lemma. First, we are going to define a set of bad events which we will show that hold with probability exponentially small in s. Assuming these events don't occur we will then show that our lemma is implied, and thus the lemma will follow with overwhelming probability.</p>

    <p class="text-gray-300">Let  <span class="math">BAD(s_1, s_2)</span>  be the event that  <span class="math">X_{s_1, s_2} \\leq Z_{s_1, s_2}</span> . In [9, Lemma 5], by an application of the Chernoff bounds it was proved that assuming that  <span class="math">\\gamma \\geq (1+\\delta)\\beta</span>  for some  <span class="math">\\delta \\in (0, 1)</span> , then with probability at least  <span class="math">(1 - e^{-\\frac{\\beta}{243}\\delta^2 s&#x27;})(1 - e^{-\\frac{\\gamma}{128}\\delta^2 s&#x27;}) \\geq 1 - e^{-(\\min(\\frac{\\beta}{243}, \\frac{\\gamma}{128})\\delta^2 s&#x27; - \\ln(2))}</span>  for any r' &gt; 0, s' &gt; s:</p>

    <p class="text-gray-300"><span class="math">$X_{r&#x27;,r&#x27;+s&#x27;-1} &gt; (1 + \\frac{\\delta}{2})Z_{r&#x27;,r&#x27;+s&#x27;-1}</span>$
(1)</p>

    <p class="text-gray-300">Thus, there exists an appropriate constant  <span class="math">\\epsilon = \\delta^2 \\min(\\frac{\\beta}{243}, \\frac{\\gamma}{128})</span> , independent of r, such that it holds that for any  <span class="math">r&#x27; &gt; 0, s&#x27; \\geq s</span> , BAD(r', r' + s' - 1) occurs with probability at most  <span class="math">e^{-\\epsilon \\delta^2 s&#x27; + \\ln 2}</span> . From an application of the union bound, we get that for the function  <span class="math">g(s) = \\epsilon \\delta^2 s - \\ln 2 + \\ln(1 - e^{-\\epsilon \\delta^2})</span> , the probability that  <span class="math">\\bigvee_{r&#x27; &gt; s} BAD(s_1 + 1, s_1 + r&#x27;)</span>  happens is:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\bigvee_{r&#x27; \\geq s} BAD(s_1 + 1, s_1 + r&#x27;)\\right] \\leq \\sum_{r&#x27; \\geq s} e^{-\\epsilon \\delta^2 r&#x27; + \\ln 2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq e^{\\ln 2} \\sum_{r&#x27; \\geq s} e^{-\\epsilon \\delta^2 r&#x27;}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq e^{\\ln 2} \\frac{e^{-\\epsilon \\delta^2 s}}{1 - e^{-\\epsilon \\delta^2}}</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; e^{-g(s)}</span>$</p>

    <p class="text-gray-300">Until now we have assumed that the execution we are studying is collision-free; no two queries in the oracle return the same value for different inputs. Let COL denote the event where a collision occurs in our execution. The probability of COL in a polynomial number of rounds, is exponentially small on  <span class="math">\\kappa</span> .</p>

    <p class="text-gray-300"><span class="math">$\\Pr[COL] \\le (f\\kappa^c)^2/2^{\\kappa+1} = e^{-\\Omega(\\kappa)} \\le e^{-\\Omega(s)}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">BAD(s_1)</span>  denote the event where  <span class="math">\\bigvee_{r&#x27;\\geq s}BAD(s_1+1,s_1+r&#x27;)</span>  or COL happens. From the union bound the probability that  <span class="math">BAD(s_1)</span>  happens, for any  <span class="math">s_1</span>  is negligible.</p>

    <p class="text-gray-300"><span class="math">$\\Pr[BAD(s_1)] \\le e^{-g(s)} + e^{-\\Omega(s)} \\le e^{-\\Omega(s)}</span>$</p>

    <p class="text-gray-300">We are going to show next that, conditioning on the negation of this event the statement of the lemma follows.</p>

    <p class="text-gray-300">We will use the convention that block  <span class="math">b_i</span>  is mined at round  <span class="math">r_i</span> . Let  <span class="math">b_1</span>  be the most recent honest block that is in the chains that all honest players have adopted on and after round r, such that the blocks mined at all u.s. rounds after round  <span class="math">r_1</span>  are descendants of  <span class="math">b_1</span> . This block is well defined, since in the worst case it is the genesis block. If  <span class="math">r_1</span>  is greater or equal to r-s, then the lemma follows for block  <span class="math">b_1</span>  with probability 1.</p>

    <p class="text-gray-300">Suppose round  <span class="math">r_1</span>  is before round r-s and that  <span class="math">BAD(r_1)</span>  does not happen. The negation of  <span class="math">BAD(r_1)</span>  implies that  <span class="math">X_{r_1+1,r-1+c} &gt; Z_{r_1+1,r-1+c}</span> , for  <span class="math">c \\geq 0</span> . By Lemma 3 and Claim B.2 there exists at least one honest block  <span class="math">b_2</span> , mined in a u.s. round and contained in the chains of all honest players on and after round r. W.l.o.g. let  <span class="math">b_2</span>  be the most recently mined such block. By the definition of  <span class="math">b_1</span> ,  <span class="math">b_2</span>  is a descendant of  <span class="math">b_1</span> . If  <span class="math">r_2</span>  is greater or equal to r-s then the lemma follows, since  <span class="math">b_2</span>  is an honest block mined on and after round r-s that satisfies the conditions of the lemma.</p>

    <p class="text-gray-300">Suppose round  <span class="math">r_2</span>  is before round r-s. Let  <span class="math">r_3</span>  be the earliest u.s. round, such that  <span class="math">b_3</span>  and the blocks mined at all u.s. rounds afterwards are descendants of  <span class="math">b_2</span> . Since  <span class="math">b_2</span>  will be in the chains of all honest players after round r, round  <span class="math">r_3</span>  is well defined. Also let  <span class="math">s_1 &lt; \\ldots &lt; s_m &lt; \\ldots</span>  be the sequence of u.s. rounds after round  <span class="math">r_1</span>  that satisfy the conditions of Claim B.2. That is,  <span class="math">s_k</span>  is the first u.s. round such that the honest block mined in this round is not a descendant of the honest block mined in round  <span class="math">s_{k-1}</span> , for  <span class="math">k \\in \\{2, ..., m\\}</span> . The first u.s. round after round  <span class="math">r_1</span>  corresponds to  <span class="math">s_1</span> .</p>

    <p class="text-gray-300">We will argue that  <span class="math">r_3</span>  is equal to some  <span class="math">s_i &gt; s_1</span>  in the aforementioned sequence. Suppose, for the sake of contradiction that it does not. This implies that the honest block mined at round  <span class="math">r_3</span>  (denoted by  <span class="math">b_3</span> ) is a descendant of the honest block mined at some round  <span class="math">s_i</span>  of the sequence. W.l.o.g. suppose that  <span class="math">s_i</span>  is the largest such round that is before round  <span class="math">r_3</span> . There are three cases. In the first case,  <span class="math">r_2 &lt; s_i &lt; r_3</span> . By the definition of  <span class="math">s_i</span>  and  <span class="math">r_3</span> , the block mined at round  <span class="math">s_i</span>  is an ancestor of  <span class="math">b_3</span>  and also a descendant of  <span class="math">b_2</span> . Hence,  <span class="math">s_i</span>  satisfies the definition of  <span class="math">r_3</span>  which is a contradiction (there is an earlier round than  <span class="math">r_3</span>  with the same property). In the second case,  <span class="math">s_i = r_4</span> , where  <span class="math">b_4</span>  is a descendant of  <span class="math">b_1</span>  and either  <span class="math">b_2 = b_4</span>  or  <span class="math">b_4</span>  is an ancestor of  <span class="math">b_2</span> . Then  <span class="math">b_4</span>  is a block that satisfies the definition of  <span class="math">b_1</span> , and is more recent, which is a contradiction. In the third case,  <span class="math">r_1 &lt; s_i &lt; r_2</span>  and the block mined at round  <span class="math">s_i</span>  is not an ancestor of  <span class="math">b_2</span> . By the definition of  <span class="math">s_i</span> , the honest block mined at round  <span class="math">s_i</span>  is an ancestor of  <span class="math">b_3</span> , that has been mined before round  <span class="math">r_2</span> . But this is contradictory, since no honest block can be an ancestor of  <span class="math">b_3</span> , mined before round  <span class="math">r_2</span> , but not be an ancestor of  <span class="math">b_2</span> .</p>

    <p class="text-gray-300">Since we proved that  <span class="math">r_3</span>  is equal to some  <span class="math">s_i</span>  we can apply Claim B.2 from round  <span class="math">r_1+1</span>  until round  <span class="math">r_3</span> . Again, from Observation 1, regarding applications of Claim B.2 after round  <span class="math">r_1</span>  we can ignore blocks that were mined before round  <span class="math">r_1+1</span> . Then either  <span class="math">Z_{r_1+1,r_3-1}\\geq Z_{r_1+1,r_3-1}^{bd}&gt;X_{r_1+1,r_3-1}</span>  or  <span class="math">Z_{r_1+1,r_3-1}\\geq Z_{r_1+1,r_3-1}^{bd}=X_{r_1+1,r_3-1}</span>  and the honest block mined at round  <span class="math">r_3</span>  will be in  <span class="math">\\operatorname{pdom}(r_3,1)</span> .</p>

    <p class="text-gray-300">Suppose, for the sake of contradiction, that round  <span class="math">r_3</span>  is after round  <span class="math">r_2 + s</span> . Then  <span class="math">(r_3-1)-(r_1+1) \\ge s</span>  and  <span class="math">Z_{r_1+1,r_3-1} \\ge X_{r_1+1,r_3-1}</span> . This is a contradiction, since in this case  <span class="math">\\neg BAD(r_1)</span>  implies  <span class="math">Z_{r_1+1,r_3-1} &lt; X_{r_1+1,r_3-1}</span> . Therefore,  <span class="math">r_3 \\le r_2 + s &lt; r</span> . In addition, notice that  <span class="math">\\neg BAD(r_1)</span>  also implies</p>

    <p class="text-gray-300"><span class="math">$X_{r_1+1,r_2+s} &gt; Z_{r_1+1,r_2+s} \\tag{2}</span>$</p>

    <p class="text-gray-300">We are going to apply Lemma 3 and Observation 1 from round  <span class="math">r_3</span>  until round  <span class="math">r_2 + s</span>  in the subtree rooted at  <span class="math">b_2</span> . According to the analysis we made previously</p>

    <p class="text-gray-300">there are two cases. In the first case,  <span class="math">Z^{bd}_{r_1+1,r_3-1} &gt; X_{r_1+1,r_3-1}</span>  or equivalently  <span class="math">Z^{bd}_{r_1+1,r_3-1} \\geq X_{r_1+1,r_3}</span> . Suppose, for the sake of contradiction, that  <span class="math">r_3 = r_2 + s</span> . Then  <span class="math">Z_{r_1+1,r_2+s-1} \\geq X_{r_1+1,r_2+s}</span> . But this is a contradiction, since  <span class="math">\\neg BAD(r_1)</span>  implies Inequality 2. Therefore,  <span class="math">r_3 &lt; r_2 + s</span> . From Inequality 2:</p>

    <p class="text-gray-300"><span class="math">$X_{r_3+1,r_2+s} \\ge X_{r_1+1,r_2+s} - X_{r_1+1,r_3} &gt; Z_{r_1+1,r_k+s} - Z_{r_1+1,r_3-1}^{bd} \\ge Z_{r_3,r_2+s}^{bd}</span>$</p>

    <p class="text-gray-300">The last inequality, stems from two facts: that we can ignore blocks that were mined before round  <span class="math">r_1 + 1</span>  regarding applications of Lemma 3 and also that the blocks that the adversary broadcasts at distinct rounds are different (adversaries that broadcast the same block multiple times can be ignored without loss of generality).</p>

    <p class="text-gray-300">In the second case,  <span class="math">Z_{r_1+1,r_3-1}^{bd} = X_{r_1+1,r_3-1}</span>  and the honest block mined at round  <span class="math">r_3</span>  will be in  <span class="math">p_{\\text{dom}}(r_3,1)</span> . Again from Inequality 2:</p>

    <p class="text-gray-300"><span class="math">$X_{r_3,r_2+s} = X_{r_1+1,r_2+s} - X_{r_1+1,r_3-1} &gt; Z_{r_1+1,r_k+s} - Z_{r_1+1,r_3-1}^{bd} \\ge Z_{r_3,r_2+s}^{bd}</span>$</p>

    <p class="text-gray-300">The same analysis holds for all rounds after  <span class="math">r_2 + s</span> . By an application of Claim B.2, an honest block b, computed in one of the u.s. rounds after round  <span class="math">r_2</span>  and before round r, will be in the chains that honest players adopt on and after round r. Since  <span class="math">b_2</span>  is the most recently mined block, before round r - s, included in the chain of all honest players, b must have been mined on and after round r - s (since  <span class="math">r_3 &gt; r_2</span> ). Let A be the event that there exists a block mined by an honest player on and after round r - s, that is contained in the chain which any honest player adopts after round r. We have proved that  <span class="math">(\\neg BAD(r_1))</span>  implies A. Then:</p>

    <p class="text-gray-300"><span class="math">$Pr[A] = Pr[A \\land BAD(r_1)] + Pr[A \\land \\neg BAD(r_1)]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq Pr[A \\land \\neg BAD(r_1)]</span>$</p>

    <p class="text-gray-300"><span class="math">$= Pr[A|\\neg BAD(r_1)]Pr[\\neg BAD(r_1)]</span>$</p>

    <p class="text-gray-300"><span class="math">$= Pr[\\neg BAD(r_1)]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq 1 - e^{-g(s)}</span>$</p>

    <p class="text-gray-300">Hence, the lemma holds with probability at least  <span class="math">1 - e^{-g(s)}</span> .</p>

    </section>
`;
---

<BaseLayout title="On Trees, Chains and Fast Transactions in the Blockchain (2016/545)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/545
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries and the GHOST Backbone protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The GHOST Backbone Protocol</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Security Properties</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">A unified description of Bitcoin and GHOST backbone</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Security Analysis and Applications</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The Fresh Block Lemma</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">A robust public transaction ledger</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Probability of uniquely successful rounds</a></li>
        <li>
          <a href="#app-b" class="hover:text-white">Proofs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Proof of Lemma 3</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Proof of Lemma 4</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="on-trees-chains-and-fast-transactions-in-the-blockchain-2016" />
  </article>
</BaseLayout>
