---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/545';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On Trees, Chains and Fast Transactions in the Blockchain';
const AUTHORS_HTML = 'Aggelos Kiayias, Giorgos Panagiotakos';

const CONTENT = `    <p class="text-gray-300">On Trees, Chains and Fast Transactions in the Blockchain</p>

    <p class="text-gray-300">Aggelos Kiayias¹* and Giorgos Panagiotakos¹</p>

    <p class="text-gray-300">School of Informatics, University of Edinburgh {akiayias,giorgos.pan}@inf.ed.ac.uk,</p>

    <p class="text-gray-300">Abstract. A fundamental open problem in the area of blockchain protocols is whether the Bitcoin protocol is the only solution for building a secure transaction ledger. A recently proposed and widely considered alternative is the GHOST protocol which, notably, was proposed to be at the core of Ethereum as well as other recent proposals for improved Bitcoin-like systems. The GHOST variant is touted as offering superior performance compared to Bitcoin (potentially offering block production speed up by a factor of more than 40) without a security loss. Motivated by this, in this work, we study from a provable security point of view the GHOST protocol.</p>

    <p class="text-gray-300">We introduce a new formal framework for the analysis of blockchain protocols that relies on trees (rather than chains) and we showcase the power of the framework by providing a unified description of the GHOST and Bitcoin protocols, the former of which we extract and formally describe. We then prove that GHOST implements a “robust transaction ledger” (i.e., possesses liveness and persistence) and hence it is a provably secure alternative to Bitcoin; moreover, our bound for the liveness parameter is superior to that proven for the bitcoin backbone in line with the original expectation for GHOST. Our proof follows a novel methodology for establishing that GHOST is a robust transaction ledger compared to previous works, which may be of independent interest and can be applicable to other blockchain variants.</p>

    <p class="text-gray-300">Keywords: GHOST, provable security, bitcoin, blockchain protocols</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The popularity of Bitcoin [19] has lead to a surge in the interest about its core protocol that maintains a distributed data structure called the “blockchain.” In [9], the core of the Bitcoin protocol was abstracted under the moniker “Bitcoin Backbone” and it was demonstrated to be a powerful tool for solving consensus, [23, 17], in a synchronous, anonymous and Byzantine setting where (unreliable)</p>

    <p class="text-gray-300">¹ Research supported by ERC project CODAMODA. Part of this work was based in a technical report published in e-print (https://eprint.iacr.org/2015/1019).</p>

    <p class="text-gray-300">broadcast is the communication operation available to the participants, (a problem first considered in <em>[2, 20]</em>). In <em>[9]</em>, it was shown that the core protocol provably guarantees two properties: (i) persistence: if a transaction is reported as stable by one node, then it will be also reported as such by any other honest node of the system, (ii) liveness: all honestly generated transactions that are broadcasted are eventually reported as stable by some honest node. This provides a formal framework for proving the security of systems like Bitcoin, since their security can be reduced to the persistence and liveness of the underlying transaction ledger. Furthermore, it provides a way to argue formally about transaction confirmation time since the liveness property is equipped with a delay parameter that specifies the maximum transaction delay that can be caused by an adversary.</p>

    <p class="text-gray-300">Naturally, implementing a robust transaction ledger may be achieved in various other ways, and it is a fundamental open question of the area whether the Bitcoin protocol itself is an “optimal” implementation of a robust transaction ledger. Indeed, many researchers have challenged various aspects of the Bitcoin system and they have proposed modifications in its core operation. Some of the modified systems maintain the protocol structure but modify the hard-coded parameters (like the block generation rate) or the basic primitives, e.g., the way proof of work is performed (a number of alternative proof of work implementations have been proposed using functions like scrypt <em>[24]</em>, lyra2 <em>[26]</em> and others). However, more radical modifications are possible that alter the actual operation of the protocol.</p>

    <p class="text-gray-300">One of the most notable such variants is the GHOST protocol, which was suggested by Sompolinsky and Zohar in <em>[27]</em>. After the initial suggestion many cryptocurrencies using variants of the GHOST rule were proposed and implemented. The most popular among them, Ethereum <em>[6]</em> has received substantial research attention <em>[16, 15, 4, 25, 12, 21]</em>. Ethereum is essentially a Bitcoin-like system where transaction processing is Turing-complete and thus it can be used to implement any public functionality in a distributed way. Bitcoin-NG <em>[7]</em> is another popular Bitcoin-like system relying on GHOST that separates blocks in two categories, namely key blocks and microblocks, reflecting the fact that transaction serialization and leader election may be separated.</p>

    <p class="text-gray-300">Unfortunately, the security analysis of <em>[27]</em> is not as general as <em>[9]</em> (e.g., their attacker does not take advantage of providing conflicting information to different honest parties), while the analysis of <em>[9]</em> does not carry to the setting of GHOST. This is because the GHOST rule is a natural, albeit radical, reformulation of how each miner determines the main chain. In GHOST, miners adopt blocks in the structure of a tree. Note that in both Bitcoin and GHOST one can consider parties collecting all mined blocks in a tree data structure. However, while in Bitcoin the miners would choose the most difficult chain as the main chain, in GHOST, they will determine the chain by greedily following the “heaviest observed subtree.” This means that for the same subtree, a Bitcoin miner and a GHOST miner may choose a completely different main chain. Furthermore, it means that the difficulty of the main chain of honest parties does not necessarily increase mono</p>

    <p class="text-gray-300">tonically (it may decrease at times) and thus a fundamental argument (namely that blockchains monotonically increase) that made the analysis of <em>[9]</em> possible, does not hold anymore.</p>

    <p class="text-gray-300">Our Results. We propose a new analysis framework for blockchain protocols focusing on trees of blocks as opposed to chains as in <em>[9]</em>. Our framework enables us to argue about random variables on the trees of blocks that are formed by the participants. In our framework, we can express concepts like a node being d-dominant, which means that the block corresponding to that node would be preferred by a margin of <span class="math">d</span> compared to other sibling nodes according to a specified weight measure. This actually enables us to unify the description of Bitcoin and GHOST by showing they obey the same rule, but simply for a different weight measure.</p>

    <p class="text-gray-300">Using our framework we then provide a first formal security proof of the GHOST rule for blockchain protocols. Specifically, we prove that GHOST is a robust transaction ledger that satisfies liveness and persistence. We achieve this result, by a new methodology, that reduces the properties of the robust transaction ledger to a single lemma, that we call the fresh block lemma and is informally stated as follows.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Fresh Block Lemma. (Informally) At any point of the execution and for any past sequence of <span class="math">s</span> consecutive rounds, there exists an honest block mined in these rounds, that is contained in the chain of any honest player from this point on.</p>
    </blockquote>

    <p class="text-gray-300">As we will demonstrate, the fresh block lemma is a powerful tool in the presence of an adversary: we show easily that the properties of the robust transaction ledger reduce to it in a black-box fashion.</p>

    <p class="text-gray-300">In more details our result is as follows. In blockchain protocols there is a predicate parameterized by a security parameter <span class="math">k</span> that determines when a transaction has been stabilized in the ledger. The “stable” predicate for Bitcoin can be seen to be true whenever the transaction is at least <span class="math">k</span> blocks deep in the blockchain. The stable predicate for GHOST is different and is true whenever the block that the transaction belongs to is the root of a subtree of at least <span class="math">k</span> blocks. We prove the following.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Persistence: if in a certain round an honest player reports a transaction <span class="math">tx</span> as stable then whenever an honest party reports <span class="math">tx</span> transaction as stable <span class="math">tx</span> will be in the same position in the ledger.
Liveness: if a transaction is given as input to all honest players continuously for <span class="math">u=\\Theta(k)</span> rounds then all of them will report it as stable.</p>
    </blockquote>

    <p class="text-gray-300">The above properties will depend on the parameter <span class="math">k</span> of the stable predicate of GHOST; we prove them to hold with a probability of error which drops exponentially in <span class="math">k</span> over all executions of the protocol.</p>

    <p class="text-gray-300">Our proof strategy for persistence and liveness utilizes the fresh block lemma in the following (black-box) manner.</p>

    <p class="text-gray-300">In the case of persistence, it is sufficient to ensure that reporting the transaction as stable by any honest player implies that a sufficient amount of time has passed so that the fresh block lemma is applicable and has produced a block that is a descendant of the block that contains the transaction. Using the moderate hardness of proofs of work (specifically that they are <em>hard enough</em>) it is easy to translate from number of blocks in a subtree to actual running time in terms of rounds. It follows that the fresh block lemma applies and all honest parties will be mining on a subtree rooted at this fresh block for the remaining of the execution. As a result, the transaction will always be reported as stable since it belongs to the heaviest observed path for all of the honest parties.</p>

    <p class="text-gray-300">In the case of liveness, we proceed in two steps. First, for our choice of <span class="math">u</span>, in a time window lasting <span class="math">\\Theta(k)</span> rounds, it will be ensured that the fresh block lemma can be applied once implying that all honest parties will mine in a subtree rooted by a common block that includes the transaction. Then, after another <span class="math">\\Theta(k)</span> rounds, the honest parties will have accumulated enough honest blocks in this subtree to pronounce this transaction as stable. This latter statement requires again the moderate hardness of proofs of work but from the opposite perspective, i.e., that they are <em>easy enough</em>.</p>

    <p class="text-gray-300">The above strategy provides an alternative proof methodology for establishing the properties of a robust transaction ledger compared to previous works that analyzed blockchain protocols, <em>[9]</em>, <em>[13]</em> and <em>[22]</em> who reduced the properties of the robust transaction ledger to three other properties called common prefix, chain quality and chain growth. As such, the proof strategy itself may be of independent interest as it could be applicable to other blockchain variants, especially those that are using trees of blocks instead of chains of blocks as in bitcoin in their chain selection rule.</p>

    <p class="text-gray-300">Our results align with the original expectation that GHOST performs better than bitcoin in terms of liveness, since our proven liveness parameter is <span class="math">k+\\frac{k}{(1-\\delta)\\alpha}</span> which is superior to the <span class="math">\\frac{2k}{(1-\\delta)\\gamma}</span> liveness parameter for bitcoin proven in <em>[9]</em>. Note that in both cases <span class="math">k</span> refers to the same confirmation level in the two protocols; in both cases <span class="math">k</span> bounds the probability of the event that the number of uniquely successful rounds exceeds the number of blocks produced by the adversary.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">On the generality of the adversarial model.</h4>

    <p class="text-gray-300">The adversarial model we adopt in this work is the one proposed by Garay et al. <em>[9]</em>. This model is quite general in the sense that, it can captures many attack models that were proposed in the literature. For example, it captures the double spending attacker of <em>[19]</em>, the block withholding attacker of <em>[8]</em> (which can be simulated because the adversary can change the order that messages arrive for each honest player) and the eclipse attacker of <em>[5]</em> where the communication of a portion of the honest nodes in the network is completely controlled (eclipsed) by the adversary (this can be simulated by simply considering the eclipsed nodes to be controlled by the adversary and having the adversary honestly execute their program while dropping their incoming messages). For a quantitative analysis of these attacks the reader is referred to <em>[10]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Limitations and directions for future research. Our analysis is in the standard Byzantine model where parties fall into two categories, those that are honest (and follow the protocol) and those that are dishonest and may deviate in an arbitrary (and coordinated) fashion as dictated by the adversary. It is an interesting direction for future work to consider the rational setting where all parties wish to optimize a certain utility function. Designing suitable incentive mechanisms, for instance see <em>[18]</em> for a suggestion related to the GHOST protocol, or examining the requirements for setup assumptions, cf. <em>[1]</em>, are related important considerations. Our analysis is in the static setting, i.e., we do not take into account the fact that parties change dynamically and that the protocol calibrates the difficulty of the POW instances to account for that; we note that this may open the possibility for additional attacks, say <em>[3]</em>, and hence it is an important point for consideration and future work. Finally, it is interesting to consider our results in more general models such as the semi-synchronous model of <em>[22]</em>.</p>

    <p class="text-gray-300">Organization. In section 2 we overview the model that we use for expressing the protocols and the theorems regarding the security properties. In section 3 we introduce our new tree-based framework. Then, in section 4 we present our security analysis of an abstraction of the GHOST protocol that demonstrates it is a robust transaction ledger in the static setting.</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 Preliminaries and the GHOST Backbone protocol</h2>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.1 Model</h3>

    <p class="text-gray-300">For our model we adopt the abstraction proposed in <em>[9]</em>. Specifically, in their setting, called the <span class="math">q</span>-bounded setting, synchronous communication is assumed and each party is allowed <span class="math">q</span> queries to a random oracle. The network supports an anonymous message diffusion mechanism that is guaranteed to deliver messages of all honest parties in each round. The adversary is rushing and adaptive. Rushing here means that in any given round he gets to see all honest players’ messages before deciding his own strategy. However, after seeing the messages he is not allowed to query the hashing oracle again in this round. In addition, he has complete control of the order that messages arrive to each player. The model is “flat” in terms of computational power in the sense that all honest parties are assumed to have the same computational power while the adversary has computational power proportional to the number of players that it controls.</p>

    <p class="text-gray-300">The total number of parties is <span class="math">n</span> and the adversary is assumed to control <span class="math">t</span> of them (honest parties don’t know any of these parameters). Obtaining a new block is achieved by finding a hash value that is smaller than a difficulty parameter <span class="math">D</span>. The success probability that a single hashing query produces a solution is <span class="math">p=\\frac{D}{2^{\\kappa}}</span> where <span class="math">\\kappa</span> is the length of the hash. The total hashing power of the honest players is <span class="math">\\alpha=pq(n-t)</span>, the hashing power of the adversary is <span class="math">\\beta=pqt</span> and the total hashing power is <span class="math">f=\\alpha+\\beta</span>. A number of definitions that will be used extensively are listed below.</p>

    <p class="text-gray-300">Definition 1. A round is called:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>successful if at least one honest player computes a solution in this round.</li>

      <li>uniquely successful if exactly one honest player computes a solution in this round.</li>

    </ul>

    <p class="text-gray-300">Definition 2. In an execution blocks are called:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>honest, if mined by an honest party.</li>

      <li>adversarial, if mined by the adversary.</li>

    </ul>

    <p class="text-gray-300">Definition 3. Some chain notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By <span class="math">\\mathcal{C}^{\\uparrow k}</span> we denote the chain that results by dropping the last <span class="math">k</span> blocks of <span class="math">\\mathcal{C}</span>.</li>

      <li>We will say that a chain <span class="math">\\mathcal{C}&#x27;</span> extends another chain <span class="math">\\mathcal{C}</span> if a non-empty prefix of <span class="math">\\mathcal{C}&#x27;</span> is a suffix of <span class="math">\\mathcal{C}</span>.</li>

    </ul>

    <p class="text-gray-300">In [9], a lower bound to the probabilities of two events, that a round is successful or that is uniquely successful (defined bellow), was established and denoted by <span class="math">\\gamma_u = \\alpha - \\alpha^2</span>. While this bound is sufficient for the setting of small <span class="math">f</span>, here we will need to use a better lower bound to the probability of those events, denoted by <span class="math">\\gamma</span>, and with value approximately <span class="math">\\alpha e^{-\\alpha}</span> (see Appendix). Observe that <span class="math">\\gamma &amp;gt; \\gamma_u</span>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2.2 The GHOST Backbone Protocol</h2>

    <p class="text-gray-300">In order to study the properties of the core Bitcoin protocol, the term Backbone Protocol was introduced in [9]. On this level of abstraction we are only interested on properties of the blockchain, independently from the data stored inside the blocks. The main idea of the Bitcoin Backbone is that honest players, at every round, receive new chains from the network and pick the longest valid one to mine. Then, if they obtain a new block (by finding a small hash), they broadcast their chain at the end of the round.</p>

    <p class="text-gray-300">The same level of abstraction can also be used to express the GHOST protocol. The GHOST Backbone protocol, as presented in [27], is based on the principle that blocks that do not end up in the main chain, should also matter in the chain selection process. In order to achieve this, players store a tree of all mined blocks they have received, and then using the greedy heaviest observed subtree (GHOST) rule, they pick which chain to mine.</p>

    <p class="text-gray-300">At every round, players update their tree by adding valid blocks sent by other players. The same principle as Bitcoin applies; for a block to be added to the tree, it suffices to be a valid child of some other tree block. The adversary can add blocks anywhere he wants in the tree, as long as they are valid. Again, as on Bitcoin, players try to extend the chains they choose by one or more blocks. Finally, in the main function, a tree of blocks is stored and updated at every round. If a player updates his tree, he broadcasts it to all other players.</p>

    <p class="text-gray-300">The protocol is also parameterized by three external functions <span class="math">\\mathrm{V}(\\cdot)</span>, <span class="math">\\mathrm{I}(\\cdot)</span>, <span class="math">\\mathrm{R}(\\cdot)</span> which are called: the input validation predicate, the input contribution function,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 1 The chain selection algorithm. The input is a block tree <span class="math">\\mathcal{T}</span>. The $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> operator corresponds to the number of nodes of a tree. By </span>C_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_2<span class="math"> we denote the concatenation of chains </span>C_1<span class="math">, </span>C_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1: function GHOST(T) 2: <span class="math">B \\leftarrow \\text{root}(\\mathcal{T})</span> 3: if children<span class="math">\\mathcal{T}(B) = \\emptyset</span> then 4: return B 5: else</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: $B \\leftarrow \\argmax_{B' \\in \\text{children}_{\\mathcal{T}}(B)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{subtree}_{\\mathcal{T}}(B')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8: end if 9: end function</p>

    <p class="text-gray-300">and the chain reading function, respectively. <span class="math">\\mathrm{V}(\\cdot)</span> dictates the structure of the information stored in each block, <span class="math">\\mathrm{I}(\\cdot)</span> determines the data that players put in the block they mine, <span class="math">\\mathrm{R}(\\cdot)</span> specifies how the data in the blocks should be interpreted depending on the application.</p>

    <p class="text-gray-300">Algorithm 2 The GHOST backbone protocol, parameterized by the input contribution function <span class="math">\\mathrm{I}(\\cdot)</span> and the reading function <span class="math">\\mathrm{R}(\\cdot)</span>. <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> is the vector of inputs of all block in chain <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">1: <span class="math">\\mathcal{T} \\leftarrow</span> GenesisBlock <span class="math">\\triangleright \\mathcal{T}</span> is a tree. 2: state <span class="math">\\leftarrow \\varepsilon</span> 3: round <span class="math">\\leftarrow 0</span> 4: while TRUE do 5: <span class="math">\\mathcal{T}_{\\text{new}} \\leftarrow</span> update(<span class="math">\\mathcal{T}</span>, blocks found in RECEIVE()) 6: <span class="math">\\tilde{\\mathcal{C}} \\leftarrow</span> GHOST(<span class="math">\\mathcal{T}_{\\text{new}}</span>) 7: <span class="math">\\langle \\text{state}, x \\rangle \\leftarrow I(\\text{state}, \\tilde{\\mathcal{C}}, \\text{round}, \\text{INPUT}(), \\text{RECEIVE}())</span> 8: <span class="math">\\mathcal{C}_{\\text{new}} \\leftarrow \\text{pow}(x, \\tilde{\\mathcal{C}})</span> 9: if <span class="math">\\tilde{\\mathcal{C}} \\neq \\mathcal{C}_{\\text{new}}</span> or <span class="math">\\mathcal{T} \\neq \\mathcal{T}_{\\text{new}}</span> then 10: <span class="math">\\mathcal{T} \\leftarrow \\text{update}(\\mathcal{T}_{\\text{new}}, \\text{head}(\\mathcal{C}_{\\text{new}}))</span> 11: BROADCAST(head(<span class="math">\\mathcal{C}_{\\text{new}}</span>)) 12: end if 13: round <span class="math">\\leftarrow</span> round + 1 14: if INPUT() contains READ then 15: write <span class="math">R(\\mathbf{x}_{\\mathcal{C}})</span> to OUTPUT() 16: end if 17: end while</p>

    <p class="text-gray-300">Next, for completeness we present the remaining procedures of the GHOST backbone protocol. Function pow (see Figure 3), which has to do with block mining and is the same as the one defined in the Bitcoin Backbone and function update (see Figure 4) which refers to the way the block tree is updated.</p>

    <p class="text-gray-300">Algorithm 3 The proof of work function, parameterized by  <span class="math">q</span> ,  <span class="math">D</span>  and hash functions  <span class="math">H(\\cdot), G(\\cdot)</span> . The input is  <span class="math">(x, \\mathcal{C})</span> . 1: function pow(x, C) 2: if  <span class="math">\\mathcal{C} = \\varepsilon</span>  then 3:  <span class="math">s \\gets 0</span> 4: else 5:  <span class="math">\\langle s&#x27;, x&#x27;, ctr&#x27; \\rangle \\gets \\text{head}(\\mathcal{C})</span> 6:  <span class="math">s \\gets H(ctr&#x27;, G(s&#x27;, x&#x27;))</span> 7: end if 8:  <span class="math">ctr \\gets 1</span> 9:  <span class="math">B \\gets \\varepsilon</span> 10:  <span class="math">h \\gets G(s, x)</span> 11: while  <span class="math">(ctr \\leq q)</span>  do 12: if  <span class="math">(H(ctr, h) &amp;lt; D)</span>  then 13:  <span class="math">B \\gets \\langle s, x, ctr \\rangle</span> 14: break 15: end if 16:  <span class="math">ctr \\gets ctr + 1</span> 17: end while 18:  <span class="math">\\mathcal{C} \\gets \\mathcal{C}B</span> 19: return  <span class="math">\\mathcal{C}</span> 20: end function</p>

    <p class="text-gray-300">In [9, Definitions 2&amp;3] two crucial security properties of the Bitcoin backbone protocol were considered, the common prefix and the chain quality property. The common prefix property ensures that two honest players have the same view of the blockchain if they prune a small number of blocks from the tail. On the other hand the chain quality property ensures that honest players chains' do not contain long sequences of adversarial blocks. These properties are defined as predicates over the random variable formed by the concatenation of all parties views' denoted by  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{H(\\cdot)}(\\kappa, q, z)</span> .</p>

    <p class="text-gray-300">Definition 4 (Common Prefix Property). The common prefix property  <span class="math">Q_{\\mathrm{cp}}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that for any pair of honest players  <span class="math">P_1, P_2</span>  maintaining the chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^{H(\\cdot)}(\\kappa, q, z)</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_1^{\\lceil k}\\preceq \\mathcal{C}_2</span>  and  <span class="math">\\mathcal{C}_2^{\\lceil k}\\preceq \\mathcal{C}_1</span></p>

    <p class="text-gray-300">Definition 5 (Chain Quality Property). The chain quality property  <span class="math">Q_{\\mathrm{cq}}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">\\ell \\in \\mathbb{N}</span>  states that for any honest party  <span class="math">P</span>  with</p>

    <p class="text-gray-300">Algorithm 4 The tree update function, parameterized by <span class="math">q</span>, <span class="math">D</span> and hash functions <span class="math">H(\\cdot), G(\\cdot)</span>. The inputs are a block tree <span class="math">\\mathcal{T}</span> and an array of blocks.</p>

    <p class="text-gray-300">1: function update<span class="math">(\\mathcal{T},B)</span> 2: foreach <span class="math">\\langle s,x,ctr\\rangle</span> in <span class="math">\\mathcal{T}</span> 3: foreach <span class="math">\\langle s&#x27;,x&#x27;,ctr&#x27;\\rangle</span> in <span class="math">B</span> 4: if <span class="math">((s&#x27; = H(ctr, G(s,x))) \\land (H(ctr&#x27;, G(x&#x27;, ctr&#x27;)) &amp;lt; D))</span> then 5: <span class="math">children_{\\mathcal{T}}(\\langle s,x,ctr\\rangle) = children_{\\mathcal{T}}(\\langle s,x,ctr\\rangle) \\cup \\langle s&#x27;,x&#x27;,ctr&#x27;\\rangle</span> ▷ Add to the tree. 6: end if 7: return <span class="math">\\mathcal{T}</span> 8: end function</p>

    <p class="text-gray-300">chain <span class="math">\\mathcal{C}</span> in <span class="math">\\mathrm{VIEW}_{\\Omega, \\mathcal{A}, \\mathcal{S}}^{H(\\cdot)}(\\kappa, q, z)</span>, it holds that for any <span class="math">\\ell</span> consecutive blocks of <span class="math">\\mathcal{C}</span> the ratio of adversarial blocks is at most <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">These two properties were shown to hold for the Bitcoin backbone protocol. Formally, in [9, Theorems 9&amp;10] the following were proved:</p>

    <p class="text-gray-300">Theorem 1. Assume <span class="math">f &amp;lt; 1</span> and <span class="math">\\gamma_u \\geq (1 + \\delta) \\lambda \\beta</span>, for some real <span class="math">\\delta \\in (0,1)</span> and <span class="math">\\lambda \\geq 1</span> such that <span class="math">\\lambda^2 - f \\lambda - 1 \\geq 0</span>. Let <span class="math">\\mathcal{S}</span> be the set of the chains of the honest parties at a given round of the backbone protocol. Then the probability that <span class="math">\\mathcal{S}</span> does not satisfy the common-prefix property with parameter <span class="math">k</span> is at most <span class="math">e^{-\\Omega (\\delta^2 k)}</span>.</p>

    <p class="text-gray-300">Theorem 2. Assume <span class="math">f &amp;lt; 1</span> and <span class="math">\\gamma_u \\geq (1 + \\delta) \\lambda \\beta</span> for some <span class="math">\\delta \\in (0,1)</span>. Suppose <span class="math">\\mathcal{C}</span> belongs to an honest party and consider any <span class="math">\\ell</span> consecutive blocks of <span class="math">\\mathcal{C}</span>. The probability that the adversary has contributed more than <span class="math">(1 - \\frac{\\delta}{3}) \\frac{1}{\\lambda} \\ell</span> of these blocks is less than <span class="math">e^{-\\Omega (\\delta^2 \\ell)}</span>.</p>

    <p class="text-gray-300">Robust public transaction ledger. In [9] the robust public transaction ledger primitive was presented. It tries to capture the notion of a book where transactions are recorded, and it is used to implement Byzantine Agreement in the honest majority setting.</p>

    <p class="text-gray-300">A public transaction ledger is defined with respect to a set of valid ledgers <span class="math">\\mathcal{L}</span> and a set of valid transactions <span class="math">\\mathcal{T}</span>, each one possessing an efficient membership test. A ledger <span class="math">\\mathbf{x} \\in \\mathcal{L}</span> is a vector of sequences of transactions <span class="math">\\mathrm{tx} \\in \\mathcal{T}</span>. Each transaction <span class="math">\\mathrm{tx}</span> may be associated with one or more accounts, denoted <span class="math">a_1, a_2, \\ldots</span>. Ledgers correspond to chains in the backbone protocols. An oracle Txgen is allowed in the protocol execution that generates valid transactions (this represents transactions that are issued by honest parties). For more details we refer to [9].</p>

    <p class="text-gray-300">We slightly alter the definitions of persistence and liveness so that they are relative to the way parties verify transactions. For example, in Bitcoin a transaction is 'stable' with parameter <span class="math">k</span> if it is at least <span class="math">k</span> blocks deep in the chain. On the</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">other hand, in GHOST the subtree formed by the block containing a transaction must be of size at least <span class="math">k</span> in order for this transaction to be considered ‘stable’. Whenever we talk about the persistence or liveness of Bitcoin or GHOST from now on, we will imply the parameterized versions with the respective definitions of stability that we just mentioned.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> implements a <em>robust public transaction ledger</em> in the <span class="math">q</span>-bounded synchronous setting if it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistence: Parameterized by <span class="math">k\\in\\mathbb{N}</span> (the “depth” parameter), if in a certain round an honest player reports a transaction <span class="math">tx</span> as ‘stable’ with parameter <span class="math">k</span>, then whenever an honest party reports it as stable, <span class="math">tx</span> will be in the same position in the ledger.</li>

      <li>Liveness: Parameterized by <span class="math">u,k\\in\\mathbb{N}</span> (the “wait time” and “depth” parameters, resp.), provided that a transaction either (i) issued by Txgen, or (ii) neutral, is given as input to all honest players continuously for <span class="math">u</span> consecutive rounds, then all honest parties will report it as ‘stable’ with parameter <span class="math">k</span> from this round on.</li>

    </ul>

    <p class="text-gray-300">These two properties were shown to hold for the ledger protocol <span class="math">\\Pi_{\\mathsf{PL}}</span> build on top of the Bitcoin Backbone protocol and appropriate instantiation of the functions V, R and I. Formally, in <em>[9, Lemma 15&amp;16]</em> the following were proved:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 1 (Persistence).</h6>

    <p class="text-gray-300">Suppose <span class="math">f&amp;lt;1</span> and <span class="math">\\gamma_{\\mathsf{u}}\\geq(1+\\delta)\\lambda\\beta</span>, for some real <span class="math">\\delta\\in(0,1)</span> and <span class="math">\\lambda\\geq 1</span> such that <span class="math">\\lambda^{2}-f\\lambda-1\\geq 0</span>. Protocol <span class="math">\\Pi_{\\mathsf{PL}}</span> satisfies Persistence with probability <span class="math">1-e^{-\\Omega(\\delta^{2}k)}</span>, where <span class="math">k</span> is the depth parameter.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 2 (Liveness).</h6>

    <p class="text-gray-300">Assume <span class="math">f&amp;lt;1</span> and <span class="math">\\gamma_{\\mathsf{u}}\\geq(1+\\delta)\\lambda\\beta</span>, for some <span class="math">\\delta\\in(0,1)</span>, <span class="math">\\lambda\\in[1,\\infty)</span> and let <span class="math">k\\in\\mathbb{N}</span>. Further, assume oracle Txgen is unambiguous. Then protocol <span class="math">\\Pi_{\\mathsf{PL}}</span> satisfies Liveness with wait time <span class="math">u=2k/(1-\\delta)\\gamma_{\\mathsf{u}}</span> and depth parameter <span class="math">k</span> with probability at least <span class="math">1-e^{-\\Omega(\\delta^{2}k)}</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 A unified description of Bitcoin and GHOST backbone</h2>

    <p class="text-gray-300">Next, we introduce our new analysis framework for backbone protocols that is focusing on trees of blocks and we show how the description of the Bitcoin and GHOST can be unified. In this model, every player stores all blocks he receives on a tree, starting from a pre-shared block called the <em>Genesis</em> (or <span class="math">v_{root}</span>) block. This is the model where GHOST was initially described. Bitcoin, and other possible backbone variants, can also be seen in this model and thus a unified language can be built. We first define block trees (or just trees) that capture the knowledge of honest players (regarding the block tree on different moments at every round).</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">We denote by <span class="math">\\mathcal{T}_{r}^{P}</span> (resp. <span class="math">\\mathcal{T}_{r}</span>) the tree that is formed from the blocks that player <span class="math">P</span> (resp. at least one honest player) has received up to round <span class="math">r</span>. Similarly, <span class="math">\\tilde{\\mathcal{T}}_{r}</span> is the tree that contains <span class="math">\\mathcal{T}_{r}</span> and also includes all blocks mined by honest players at round <span class="math">r</span>. For any tree <span class="math">T</span> and block <span class="math">b\\in T</span>, we denote by <span class="math">T(b)</span> the subtree of <span class="math">T</span> rooted on <span class="math">b</span>.</p>

    <p class="text-gray-300">Notice that, due to the fact that broadcasts of honest players always succeed, blocks in <span class="math">\\hat{\\mathcal{T}}_r</span> are always in <span class="math">\\mathcal{T}_{r+1}^P</span>. Thus for every honest player <span class="math">P</span> it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{T}_r^P \\subseteq \\mathcal{T}_r \\subseteq \\hat{\\mathcal{T}}_r \\subseteq \\mathcal{T}_{r+1}^P</span></div>

    <p class="text-gray-300">Intuitively, heavier trees represent more proof of work. However, there is more than one way to define the weight of a tree. For example, in Bitcoin the heaviest tree is the longest one. On the other hand, for GHOST a heavy tree is one with many nodes. To capture this abstraction we condition our definitions on a norm <span class="math">w</span> that assigns weights on trees. This norm will be responsible for deciding which tree has more proof of work, and thus which tree is favored by the chain selection rule. We choose to omit <span class="math">w</span> from the notation since it will always be clear from the context which norm we use.</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> Let <span class="math">w</span> be a norm defined on trees. For any tree <span class="math">\\mathcal{T}</span> let <span class="math">siblings(v)</span> denote the set of nodes in <span class="math">\\mathcal{T}</span> that share the same parent with <span class="math">v</span>. Then node <span class="math">v</span> is <em>d-dominant</em> in <span class="math">\\mathcal{T}</span> (denoted by <span class="math">\\mathrm{Dom}_{\\mathcal{T}}(v, d)</span>) iff</p>

    <div class="my-4 text-center"><span class="math-block">w(\\mathcal{T}(v)) \\geq d \\wedge \\forall v&#x27; \\in siblings(v): w(\\mathcal{T}(v)) \\geq w(\\mathcal{T}(v&#x27;)) + d</span></div>

    <p class="text-gray-300">The chain selection rule in the Bitcoin protocol can be described using the notion of the <span class="math">d</span>-dominant node. Let <span class="math">w(\\mathcal{T})</span> be the height of some tree <span class="math">\\mathcal{T}</span>. Each player <span class="math">P</span>, starting from the root of his <span class="math">\\mathcal{T}_r^P</span> tree, greedily decides on which block to add on the chain by choosing one of its 0-dominant children and continuing recursively<span class="math">^1</span> (ties are broken based on time-stamp, or based on which block was received first). Interestingly, the GHOST selection rule can also be described in exactly the same way by setting <span class="math">w</span> to be the number of nodes of the tree. Thus we have a unified way for describing the chain selection rule in both protocols. Building upon this formalism we can describe the paths that fully informed honest players may choose to mine at round <span class="math">r</span> (denoted by <span class="math">\\mathrm{HonestPaths}(r)</span>) in a quite robust way, thus showcasing the power of our notation.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\mathrm{HonestPaths}(r) = \\left\\{p = v_{\\mathrm{root}}v_1 \\dots v_k \\mid p \\text{ is a root-leaf path in } \\mathcal{T}_r \\text{ and } \\right. \\\\ \\left. \\forall i \\in \\{1,..,k\\} \\mathrm{Dom}_{\\mathcal{T}_r}(v_i, 0) \\right\\} \\end{array}</span></div>

    <p class="text-gray-300">We conclude this section by presenting two crucial properties that both the Bitcoin and GHOST backbones satisfy. The first property states that by broadcasting <span class="math">k</span> blocks the adversary can decrease the dominance of some block at most by <span class="math">k</span>. Intuitively, it tells us if the adversary's ability to mine new blocks is limited, then his influence over the block tree is also limited. On the other hand, the second property states that uniquely successful rounds increase the dominance only of nodes in the path from the root to the new block.</p>

    <p class="text-gray-300">We will use the term node and block interchangeably from now on.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> For the Bitcoin and GHOST backbone protocols it holds that:</p>

    <p class="text-gray-300"><span class="math">^1</span> This is exactly algorithm 1 with a minor modification. At line 6 the subtree <span class="math">\\mathcal{T}</span> that is chosen maximizes <span class="math">w(\\mathcal{T})</span>.</p>

    <p class="text-gray-300">11</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if the adversary broadcast  <span class="math">k \\leq d</span>  blocks at round  <span class="math">r - 1</span>  then for every block  <span class="math">v \\in \\hat{\\mathcal{T}}_{r - 1}</span>  it holds that  <span class="math">\\mathrm{Dom}_{\\hat{\\mathcal{T}}_{r - 1}}(v, d)</span>  implies  <span class="math">\\mathrm{Dom}_{\\mathcal{T}_r}(v, d - k)</span> .</li>

      <li>if  <span class="math">r</span>  is a uniquely successful round and the newly mined block extends a path in HonestPaths(r), then for any block  <span class="math">v</span>  in  <span class="math">\\mathcal{T}_r</span>  it holds that:  <span class="math">\\mathrm{Dom}_{\\mathcal{T}_r}(v,d)</span>  implies  <span class="math">\\mathrm{Dom}_{\\hat{\\mathcal{T}}_r}(v,d + 1)</span>  if and only if  <span class="math">v</span>  is in the path from  <span class="math">v_{\\mathrm{root}}</span>  to the new block.</li>

    </ul>

    <p class="text-gray-300">Proof. The lemma stems from the fact that adding only one block in the tree reduces or increases the dominance of some block by at most 1. For the first bullet, adding  <span class="math">k</span>  blocks one by one, implies that the dominance of any node will reduce or increase by at most  <span class="math">k</span> . For the second bullet, notice that dominance increases only for blocks that get heavier. The only blocks that get heavier in this case are the ones in the path from the root to the newly mined block. Since these blocks are in HonestPaths(r), they are at least 0-dominant and so their dominance will further increase. Furthermore, the newly mined block is 1-dominant since it does not have any siblings.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1: An example of the change in dominance after a uniquely successful round. The only nodes which increase their dominance are the ones in the path from the root to the newly mined block as stated in Proposition 1.</p>

    <p class="text-gray-300">Next, we prove that the GHOST backbone protocol is sufficient to construct a robust transaction ledger. From now on we assume that <span class="math">w(T)</span> is the total number of nodes of tree <span class="math">T</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4.1 The Fresh Block Lemma</h2>

    <p class="text-gray-300">In [9], it was shown that the Bitcoin Backbone satisfies two main properties: common prefix and chain quality. However, another fundamental property needed for their proof, is that the chains of honest players grow at least at the rate of successful rounds. This does not hold for GHOST. The reason is that, if an honest player receives a chain that is heavier than the one he currently has, he will select it, even if it is shorter. To reflect these facts, we develop an argument that is a lot more involved and leads to a power lemma that we call the "fresh block lemma".</p>

    <p class="text-gray-300">First, we introduce a new notion, that of a path that all of its nodes are dominant up to a certain value. Intuitively, the more dominant a path is, the harder it gets for the adversary to stop honest players from choosing it.</p>

    <p class="text-gray-300"><strong>Definition 9.</strong> <span class="math">(\\mathrm{p}_{\\mathrm{dom}}(r,d))</span> For <span class="math">d &amp;gt; 0</span>, <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r,d)</span> is the longest path <span class="math">p = v_{\\mathrm{root}}v_{1}\\ldots v_{k}</span> in <span class="math">\\mathcal{T}_r</span> s.t.</p>

    <div class="my-4 text-center"><span class="math-block">p \\neq v _ {\\mathrm {r o o t}} \\wedge \\forall i \\in \\{1, \\dots , k \\}: \\operatorname {D o m} _ {\\mathcal {T} _ {r}} (v _ {i}, d)</span></div>

    <p class="text-gray-300">If no such path exists <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r,d) = \\bot</span>.</p>

    <p class="text-gray-300">Note that the dominant path <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r,d)</span>, if it is not <span class="math">\\bot</span>, will be unique (this stems from the requirement that <span class="math">d &amp;gt; 0</span>).</p>

    <p class="text-gray-300">In the next lemma, we show that unless the number of blocks the adversary broadcasts in a round interval is at least as big as the number of uniquely successful rounds that have occurred, an honest block mined in one of these rounds will be deep enough in the chains of honest players. More specifically, for any sequence of <span class="math">m</span> (not necessarily consecutive) uniquely successful rounds starting at some round <span class="math">r&#x27;</span>, no matter the strategy of the adversary, at round <span class="math">r</span> there will be at least one honest block in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r,m - k)</span> where <span class="math">k</span> is the number of adversarial blocks that have been released during rounds <span class="math">[r&#x27; - 1, r - 1]</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">r_1, \\ldots, r_m</span> be uniquely successful rounds from round <span class="math">r&#x27;</span> until round <span class="math">r</span>. If the adversary broadcasts <span class="math">k &amp;lt; m</span> blocks from round <span class="math">r&#x27; - 1</span> until round <span class="math">r - 1</span>, then there exists an honest block <span class="math">b</span>, mined in one of the rounds <span class="math">r_1, \\ldots, r_m</span> such that <span class="math">b</span> is in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r, m - k)</span>.</p>

    <p class="text-gray-300"><strong>Proof sketch.</strong> The proof is based on two observations. Firstly, if the adversary does not broadcast a block in the round before a uniquely successful round <span class="math">s</span>, then the newly mined honest block will be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s,1)</span>. Secondly, if the adversary broadcasts <span class="math">k &amp;lt; d</span> blocks in the round before a uniquely successful round <span class="math">s</span>, all</p>

    <p class="text-gray-300">blocks in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span> at round <span class="math">s - 1</span> will also be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s, d + 1 - k)</span>. It follows that for each uniquely successful round, unless the adversary broadcasts a block, an honest block will be introduced in the dominant path and will be maintained there unless the adversary broadcasts more blocks than the number of uniquely successful rounds that follow. As a result, in the period from round <span class="math">r&#x27;</span> until round <span class="math">r</span>, our assumption that the adversary broadcasts strictly less than <span class="math">m</span> blocks, implies that at least one block will be maintained in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r, m - k)</span>.</p>

    <p class="text-gray-300">The fresh block lemma is stated next. Informally, it states that at any point in time, in any past sequence of <span class="math">s</span> consecutive rounds, at least one honest block was mined and is permanently inserted in the chain that every honest player adopts, with overwhelming probability on <span class="math">s</span>.</p>

    <p class="text-gray-300"><strong>Lemma 4. (Fresh Block Lemma)</strong> Assume <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span>, for some real <span class="math">\\delta \\in (0,1)</span> and <span class="math">f &amp;lt; 1</span>. Then, for all <span class="math">s \\in \\mathbb{N}</span> and <span class="math">r \\geq s</span> it holds that there exists a block mined by an honest player on and after round <span class="math">r - s</span>, that is contained in the chain which any honest player adopts on and after round <span class="math">r</span> with probability <span class="math">1 - e^{-\\Omega (\\delta^2 s)}</span>.</p>

    <p class="text-gray-300"><strong>Proof sketch.</strong> The difficulty of proving this lemma stems from the fact that in GHOST, the chains of honest players are not always strictly increasing. That is, honest players may switch from a longer to a shorter chain. Monotonicity allows us to prove many useful things; for example that the adversary cannot use very old blocks in order to maintain a fork as in [9].</p>

    <p class="text-gray-300">To overcome this difficulty, we first show that whenever the adversary forces honest players to work on a different branch of the block tree, he has to broadcast as many blocks as the ones that were mined on uniquely successful rounds on this branch of the tree. Hence, it is hard for the adversary to force honest players to change branches all the time, and moreover, after <span class="math">s</span> rounds this will be impossible due to the fact that <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span>. But if all honest players stay on one branch, the blocks near the root of the branch will permanently enter their chains. We show that at least one of these blocks will be mined by an honest player. By applying this idea in an iterative manner, the lemma follows.</p>

    <p class="text-gray-300">For the full proof of the lemma we refer to the Appendix.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.2 A robust public transaction ledger</h2>

    <p class="text-gray-300">In [9] it is shown how to instantiate the functions V, R, I so that the resulting protocol, denoted by <span class="math">\\Pi_{\\mathrm{PL}}</span>, built on top of the Bitcoin backbone, implements a robust transaction ledger. In this section we show how we can achieve the same goal, using exactly the same instantiation of V,R,I, but on top of the GHOST backbone. We call the resulting protocol, <span class="math">\\Pi_{\\mathrm{PL}}^{\\mathrm{GHOST}}</span>.</p>

    <p class="text-gray-300">Having established that every <span class="math">s</span> rounds a fresh and honest block is inserted permanently in the chain of all players, we are in a position to prove the main</p>

    <p class="text-gray-300">2 Throughout this work, we only consider executions that run for a polynomial number of rounds in the security parameter <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300">properties of a robust transaction ledger. Liveness stems from the fact that after <span class="math">s</span> rounds from the time a transaction was issued, an honest block that contains this transaction will stabilize in the chain. Thus, by waiting for at most <span class="math">s / \\alpha</span> more rounds, the honest parties will mine enough block so that this transaction becomes 'stable' with parameter <span class="math">s</span>. Persistence is implied by the fact that when a player reports a transaction as stable for the first time, enough time has passed from the time the block containing the transaction was mined, and thus there exists an honest block descending it that has been permanently added to the chain of all honest parties.</p>

    <p class="text-gray-300"><strong>Lemma 5 (Liveness).</strong> Assume <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span>, for some <span class="math">\\delta \\in (0,1)</span> and <span class="math">f &amp;lt; 1</span>. Further, assume oracle Txgen is unambiguous. Then for all <span class="math">k \\in \\mathbb{N}</span> protocol <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SHOST}}</span> satisfies Liveness with wait time <span class="math">u = k + \\frac{k}{(1 - \\delta)\\alpha}</span> rounds and depth parameter <span class="math">k</span> with probability at least <span class="math">1 - e^{-\\Omega (\\delta^2 k)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We prove that assuming all honest players receive as input the transaction <span class="math">tx</span> for at least <span class="math">u</span> rounds, any honest party at round <span class="math">r</span> with chain <span class="math">\\mathcal{C}</span> will report <span class="math">tx</span> as 'stable'. By Lemma 4 it follows that with probability <span class="math">1 - e^{-\\Omega (\\delta^2 k)}</span> there exists an honest block mined during rounds <span class="math">[r - u, r - u + k]</span>, such that all honest players have this block in the chains they mine from round <span class="math">r - u + k</span> and onward. Without loss of generality this block contains <span class="math">tx</span>. All blocks that honest players mine during the remaining <span class="math">\\frac{k}{(1 - \\delta)\\alpha}</span> rounds will be descendants of this block. By an application of the Chernoff bound, with probability <span class="math">1 - e^{-\\Omega (\\delta^2 k)}</span>, the honest parties will mine at least <span class="math">k</span> blocks in this round interval and thus the lemma follows with the desired probability.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Lemma 6 (Persistence).</strong> Suppose <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span> and <span class="math">(1 + \\delta)f \\leq 1</span>, for some real <span class="math">\\delta \\in (0,1)</span>. Then for all <span class="math">k \\in \\mathbb{N}</span> protocol <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{SHOST}}</span> satisfies Persistence with probability <span class="math">1 - e^{-\\Omega (\\delta^2 k)}</span>, where <span class="math">k</span> is the depth parameter.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">B</span> be the block that contains transaction <span class="math">tx</span> that the honest party <span class="math">P</span> reported as stable at round <span class="math">r</span>. We will argue that <span class="math">B</span> must have been computed before round <span class="math">r - k</span>, and thus by Lemma 4 all honest players will report it in the same position in their chains.</p>

    <p class="text-gray-300">Let <span class="math">E_{1}</span> be the event where <span class="math">B</span> is computed after round <span class="math">r - k / ((1 + \\delta)f) &amp;lt; r - k</span>. The number of descendants of <span class="math">B</span> cannot be greater than the number of solutions <span class="math">Y</span> obtained from the oracle in this amount of rounds. By the Chernoff bound,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ Y \\geq (1 + \\delta) f \\frac {k}{(1 + \\delta) f} ] = \\Pr [ Y \\geq k ] \\leq e ^ {- \\delta^ {2} f s / 3}.</span></div>

    <p class="text-gray-300">Since <span class="math">tx</span> is reported as stable, <span class="math">B</span> must have <span class="math">k</span> descendants and thus <span class="math">E_{1}</span> implies that <span class="math">Y</span> must be greater or equal to <span class="math">k</span>. Hence, <span class="math">\\operatorname<em>{Pr}[E_1] \\leq \\operatorname</em>{Pr}[Y \\geq k] \\leq e^{-\\delta^2 fs / 3}</span>.</p>

    <p class="text-gray-300">Let <span class="math">E_{2}</span> be the event where Lemma 4 does not hold for round <span class="math">r</span>. This happens with probability at most <span class="math">e^{-\\Omega (\\delta^2 k)}</span>. By the union bound, the event <span class="math">E_{1} \\vee E_{2}</span> happens with probability at most <span class="math">e^{-\\Omega (\\delta^2 k)}</span>. Assuming that <span class="math">E_{1} \\vee E_{2}</span> does not</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">occur, it follows that there exists an honest block <span class="math">B^{\\prime}</span> mined on and after round <span class="math">r - k</span> that will be in the chains of all honest players from round <span class="math">r</span> and onward. Hence, <span class="math">B</span> must be an ancestor of <span class="math">B^{\\prime}</span> and all honest players will report <span class="math">B</span> and <span class="math">tx</span> at the same position as <span class="math">P</span> from round <span class="math">r</span> and onward. Persistence follows with the desired probability.</p>

    <p class="text-gray-300">Theorem 3. Assuming <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span> and <span class="math">(1 + \\delta)f\\leq 1</span>, for some real <span class="math">\\delta \\in (0,1)</span>, the protocol <span class="math">\\Pi_{\\mathsf{PL}}^{\\mathsf{GNOST}}</span> implements a robust transaction ledger.</p>

    <p class="text-gray-300">As a final note, Lemma 4 is sufficient to prove Persistence and Liveness in a black-box way. Compared to the approach of [9], that was further expanded in [13] and [22], only one property, instead of three, of the underlying "backbone" protocol suffices in order to get a robust public transaction ledger in a black-box manner. On the other hand, the three properties described in these works, common-prefix, chain quality and chain growth, also serve as metrics of the efficiency of the underlying mechanism and provide more information than the fresh block lemma.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Andrychowicz and S. Dziembowski. Pow-based distributed cryptography with no trusted setup. In Advances in Cryptology-CRYPTO 2015, pages 379-399. Springer, 2015.</li>

      <li>J. Aspnes, C. Jackson, and A. Krishnamurthy. Exposing computationally-challenged byzantine impostors. Department of Computer Science, Yale University, New Haven, CT, Tech. Rep, 2005.</li>

      <li>L. Bahack. Theoretical bitcoin attacks with less than half of the computational power (draft). Cryptology ePrint Archive, Report 2013/868, 2013. http://eprint.iacr.org/.</li>

      <li>J. Bonneau. Ethiks: Using ethereum to audit a coniks key transparency log.</li>

      <li>S. G. Ethan Heilman. Alison Kendler, Aviv Zohar. Eclipse attacks on bitcoin's peer-to-peer network. Cryptology ePrint Archive, Report 2015/263, 2015. http://eprint.iacr.org/.</li>

      <li>ethereum/wiki. A next-generation smart contract and decentralized application platform, October 2015. https://github.com/ethereum/wiki/wiki/White-Paper/.</li>

      <li>I. Eyal, A. E. Gencer, E. G. Sirer, and R. van Renesse. Bitcoin-ng: A scalable blockchain protocol. CoRR, abs/1510.02037, 2015.</li>

      <li>I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In <em>Financial Cryptography</em>, 2014.</li>

      <li>J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II, pages 281-310, 2015.</li>

      <li>A. Gervais, G. O. Karame, K. Wüst, V. Glykantzis, H. Ritzdorf, and S. Capkun. On the security and performance of proof of work blockchains. Cryptology ePrint Archive, Report 2016/555, 2016. http://eprint.iacr.org/2016/555.</li>

    </ol>

    <p class="text-gray-300">16</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J. Hižak and R. Logožar. A derivation of the mean absolute distance in one-dimensional random walk. Tehnički glasnik, 5(1):10–16, 2011.</li>

      <li>A. Juels, A. Kosba, and E. Shi. The ring of gyges: Using smart contracts for crime. aries, 40:54, 2015.</li>

      <li>A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. Technical report, IACR: Cryptology ePrint Archive, 2015.</li>

      <li>A. Kiayias and G. Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015. http://eprint.iacr.org/2015/1019.</li>

      <li>A. Kiayias, H.-S. Zhou, and V. Zikas. Fair and robust multi-party computation using a global transaction ledger, 2015.</li>

      <li>A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. Technical report, Cryptology ePrint Archive, Report 2015/675, 2015. http://eprint.iacr.org, 2015.</li>

      <li>L. Lamport, R. E. Shostak, and M. C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.</li>

      <li>S. D. Lerner. Even faster block-chains with the decor protocol. Cryptology ePrint Archive, Report 2013/881, May 2014. https://bitslog.wordpress.com/2014/05/02/decor/.</li>

      <li>S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>M. Okun. Agreement among unacquainted byzantine generals. In P. Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499–500. Springer, 2005.</li>

      <li>S. Omohundro. Cryptocurrencies, smart contracts, and artificial intelligence. AI matters, 1(2):19–21, 2014.</li>

      <li>R. Pass, L. Seeman, and abhi shelat. Analysis of the blockchain protocol in asynchronous networks. Cryptology ePrint Archive, Report 2016/454, 2016. http://eprint.iacr.org/.</li>

      <li>M. C. Pease, R. E. Shostak, and L. Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228–234, 1980.</li>

      <li>C. Percival. Stronger key derivation via sequential memory-hard functions. Self-published, pages 1–16, 2009.</li>

      <li>J. Peterson and J. Krug. Augur: a decentralized, open-source platform for prediction markets. arXiv preprint arXiv:1501.01042, 2015.</li>

      <li>M. A. Simplicio Jr, L. C. Almeida, E. R. Andrade, P. C. dos Santos, and P. S. Barreto. The lyra2 reference guide. Technical report, version 2.3. 2. Technical report, 2014.</li>

      <li>Y. Sompolinsky and A. Zohar. Secure high-rate transaction processing in bitcoin. Financial Cryptography and Data Security, 2015.</li>

    </ol>

    <h2 id="sec-15" class="text-2xl font-bold">Appendix A Probability of uniquely successful rounds</h2>

    <p class="text-gray-300">In this section we demonstrate a lower bound on the probability of uniquely successful rounds. This bound allows us to argue about the security of GHOST even when <span class="math">f</span> is larger than 1.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">For <span class="math">p&amp;lt;0.1</span> and <span class="math">a\\in(p,2k):e^{-a-kp}\\leq(1-p)^{\\frac{a}{p}-k}\\leq e^{-a+kp}</span></p>

    <p class="text-gray-300">Proof. The second inequality is well studied and holds for  <span class="math">p &amp;gt; 0</span> . For the first inequality by solving for  <span class="math">a</span>  we get  <span class="math">a \\leq k\\frac{\\ln(1 - p)}{1 + \\frac{\\ln(1 - p)}{p}}</span>  which holds for  <span class="math">p &amp;lt; 0.1</span>  and  <span class="math">a \\in (p,2k)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\gamma</span>  be a lower bound on the probability of a uniquely successful round (a round where only one block is found). From the event where  <span class="math">(n - t)</span>  players throw  <span class="math">q</span>  coins each and exactly one coin toss comes head, the probability of a uniquely successful rounds is at least:</p>

    <div class="my-4 text-center"><span class="math-block">(n - t) q p (1 - p) ^ {q (n - t) - 1} \\geq \\alpha e ^ {- \\alpha - k p}</span></div>

    <p class="text-gray-300">We set  <span class="math">\\gamma = ae^{-a - kp}</span> , for the minimum  <span class="math">k</span>  that satisfies the relation  <span class="math">\\alpha \\in (p,2k)</span> . This is a substantially better bound that  <span class="math">\\gamma_{u}</span>  and is also a lower bound for the event that at a round is successful. The relation of the two bounds is depicted in Figure 2.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2: Comparison of the lower bounds on the probability of a uniquely successful round,  <span class="math">\\gamma</span>  and  <span class="math">\\gamma_{u}</span> , used respectively in this work and [9]. Notice that  <span class="math">\\gamma</span>  allows as to argue about security when  <span class="math">f</span>  is greater than 1.</p>

    <p class="text-gray-300">B Proofs</p>

    <p class="text-gray-300">B.1 Proof of Lemma 3</p>

    <p class="text-gray-300">Proof. We are first going to prove two preliminary claims that show the effect of a uniquely successful round to <span class="math">\\mathrm{p}_{\\mathrm{dom}}</span>. The first claim shows that if a uniquely successful round <span class="math">s</span> is not compensated accordingly by the adversary, a newly mined block will be forced into <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s,1)</span>.</p>

    <p class="text-gray-300">Claim 1. Let round <span class="math">s</span> be a uniquely successful round and <span class="math">b</span> be the honest block mined at round <span class="math">s</span>. If the adversary does not broadcast any block at round <span class="math">s - 1</span> then <span class="math">b \\in \\mathrm{p}_{\\mathrm{dom}}(s, 1)</span>.</p>

    <p class="text-gray-300">Proof of Claim. First, notice that since the adversary does not broadcast any block it holds that for any honest player <span class="math">P</span>, <span class="math">\\mathcal{T}_s</span> is equal to <span class="math">\\mathcal{T}_s^P</span>. Therefore, all nodes in the path from <span class="math">v_{\\mathrm{root}}</span> to the parent of <span class="math">b</span> are at least 0-dominant in <span class="math">\\mathcal{T}_s</span> and thus this path is in HonestPaths(s). Since <span class="math">s</span> is uniquely successful, all conditions of the second bullet of Proposition 1 are met, and thus it is implied that all nodes up to the newly mined block in <span class="math">\\hat{\\mathcal{T}}_s</span> are 1-dominant. It follows that <span class="math">b \\in \\mathrm{p}_{\\mathrm{dom}}(s, 1)</span>.</p>

    <p class="text-gray-300">The second claim shows the effect of a uniquely successful round <span class="math">s</span> to an existing <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span> path. Notice that if the adversary broadcasts less than <span class="math">d</span> blocks the same nodes continue to be at least 1-dominant in the following round.</p>

    <p class="text-gray-300">Claim 2. Let round <span class="math">s</span> be a uniquely successful round, <span class="math">b</span> be the honest block mined at round <span class="math">s</span> and <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d) \\neq \\bot</span>. If the adversary broadcasts (i) <span class="math">k &amp;lt; d</span> blocks at round <span class="math">s - 1</span> then <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d) \\subseteq \\mathrm{p}_{\\mathrm{dom}}(s, d + 1 - k)</span>, (ii) <span class="math">k = d</span> blocks at round <span class="math">s - 1</span> then either <span class="math">b \\in \\mathrm{p}_{\\mathrm{dom}}(s, 1)</span> or <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d) \\subseteq \\mathrm{p}_{\\mathrm{dom}}(s, 1)</span> and <span class="math">b</span> is a descendant of the last node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span>.</p>

    <p class="text-gray-300">Proof of Claim. There are two cases. In the first case suppose the adversary broadcasts <span class="math">k &amp;lt; d</span> blocks. Then, according to the first bullet of Proposition 1, the adversary can lower the dominance in <span class="math">\\mathcal{T}_s</span> of nodes in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1,d)</span> by at most <span class="math">k</span>. Thus <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1,d)</span> will be a prefix of all the chains in HonestPaths(s). But because <span class="math">s</span> is a uniquely successful round, the dominance in <span class="math">\\hat{\\mathcal{T}}_s</span> of all nodes in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1,d)</span> will increase by one. Therefore <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1,d) \\subseteq \\mathrm{p}_{\\mathrm{dom}}(s,d + 1 - k)</span> and <span class="math">b</span> will be a descendant of the last node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1,d)</span>.</p>

    <p class="text-gray-300">In the second case suppose the adversary broadcasts <span class="math">k = d</span> blocks. If he does not broadcast all of these blocks to reduce the dominance in <span class="math">\\mathcal{T}_s</span> of the nodes in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span>, then <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span> will be a prefix of all the chains in HonestPaths(s) and as in the previous case, <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d) \\subseteq \\mathrm{p}_{\\mathrm{dom}}(s, d + 1 - k)</span> and <span class="math">b</span> will be a descendant of the last node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span>.</p>

    <p class="text-gray-300">Otherwise the adversary will reduce the dominance in <span class="math">\\mathcal{T}_s</span> of at least one node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span> to zero. If <span class="math">b</span> is a descendant of the last node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span>, then all nodes in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span> will be 1-dominant in <span class="math">\\hat{\\mathcal{T}}_s</span> and <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d) \\subseteq \\mathrm{p}_{\\mathrm{dom}}(s, 1) = \\mathrm{p}_{\\mathrm{dom}}(s, d + 1 - d)</span>. If <span class="math">b</span> is not a descendant of the last node in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s - 1, d)</span>, then for the player <span class="math">P</span> that mined this block it holds that <span class="math">\\mathcal{T}_s^P = \\mathcal{T}_s</span>,</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">because he would have not mined a chain that does not contain <span class="math">\\mathrm{p_{dom}}(s - 1,d)</span> at round <span class="math">s</span> otherwise. Therefore, <span class="math">P</span> at round <span class="math">s</span> was mining a chain that belonged to HonestPaths(s, <span class="math">v_{\\mathrm{root}}</span>) and thus all nodes in the chain are at least 0-dominant in <span class="math">\\mathcal{T}_s</span>. But because <span class="math">s</span> is a uniquely successful round the dominance of all nodes in the chain that <span class="math">b</span> belongs to will increase by one and thus <span class="math">b \\in \\mathrm{p_{dom}}(s,1)</span>.</p>

    <p class="text-gray-300">Let <span class="math">b_i</span> denote the honest block mined at round <span class="math">r_i</span>. Let us assume that <span class="math">r = r_m</span>. We are going to prove the lemma using induction on the number of uniquely successful rounds <span class="math">m</span>.</p>

    <p class="text-gray-300">For the base case suppose <span class="math">m = 1</span>. The adversary does not broadcast any block until round <span class="math">r_1 - 1</span> and from the first claim <span class="math">b_1 \\in \\mathrm{p_{dom}}(r_1, 1)</span>. Thus the base case is proved. Suppose the lemma holds for <span class="math">m - 1</span> uniquely successful rounds and let <span class="math">k_1</span> be the number of blocks that the adversary broadcasts in the round interval <span class="math">[r&#x27; - 1, r_{m-1} - 1]</span>. We have two cases.</p>

    <p class="text-gray-300">(First case) <span class="math">k_{1} = m - 1</span> and the adversary broadcasts no blocks in the rest of the rounds. From the first claim it follows that <span class="math">b_{m} \\in \\mathrm{p_{dom}}(r_{m}, 1)</span>.</p>

    <p class="text-gray-300">(Second case) <span class="math">k_{1} &amp;lt; m - 1</span> and from the induction hypothesis there exist blocks <span class="math">b_1&#x27;, \\ldots, b_{m-1-k_1}&#x27;</span> mined by honest players at the uniquely successful rounds <span class="math">r_1, \\ldots, r_{m-1}</span> where <span class="math">b_i&#x27; \\in \\mathrm{p_{dom}}(r_{m-1}, i)</span>. Let <span class="math">k_{2}</span> be the number of blocks that the adversary broadcasts until round <span class="math">r_m - 2</span> and <span class="math">k_{3}</span> the number of blocks he broadcasts at round <span class="math">r_m - 1</span>. If <span class="math">k_{2} = m - 1</span> then again from the first claim it follows that <span class="math">b_m \\in \\mathrm{p_{dom}}(r_m, 1)</span>. If <span class="math">k_{2} &amp;lt; m - 1</span> then if <span class="math">k_{3} + k_{2} = m - 1</span> then from the second claim either <span class="math">b_m \\in \\mathrm{p_{dom}}(r_m, 1)</span> or <span class="math">b_{m-1-k_1}&#x27; \\in \\mathrm{p_{dom}}(r_m, 1)</span>. If <span class="math">k_{3} + k_{2} &amp;lt; m - 1</span> then again from the second claim at round <span class="math">r_m</span>, <span class="math">b_i&#x27; \\in \\mathrm{p_{dom}}(r_m - 1, i)</span> for <span class="math">i</span> in <span class="math">\\{k_{2} + k_{3} + 1, \\ldots, m - 1 - k_{1}\\}</span> and either <span class="math">b_{k_{2} + k_{3}}&#x27;</span> is in <span class="math">\\mathrm{p_{dom}}(r_m, 1)</span> or <span class="math">b_m</span> is in <span class="math">\\mathrm{p_{dom}}(r_m, 1)</span>. This completes the induction proof.</p>

    <p class="text-gray-300">We proved that if <span class="math">k_4 &amp;lt; m</span> is the number of blocks the adversary broadcasts until round <span class="math">r_m - 1</span>, then there exists honest blocks <span class="math">b_1&#x27;,..,b_{m - k_4}&#x27;</span> s.t. <span class="math">b_i&#x27;</span> is in <span class="math">\\mathrm{p_{dom}}(r_m,i)</span>. Now in the case <span class="math">r &amp;gt; r_m</span>, let <span class="math">k_{5} &amp;lt; m - k_{4}</span> be the number of blocks the adversary broadcasts in the remaining rounds. The lemma follows easily from the second claim.</p>

    <p class="text-gray-300">Remark 1. Let <span class="math">r_1, \\ldots, r_m</span> be uniquely successful rounds up to round <span class="math">r</span> and the honest block mined at round <span class="math">r_1</span> be in <span class="math">\\mathrm{p_{dom}}(r_1, 1)</span>. If the adversary broadcasts <span class="math">k &amp;lt; m</span> blocks from round <span class="math">r_1</span> until round <span class="math">r - 1</span>, then there exists an honest block <span class="math">b</span> mined in one of the rounds <span class="math">r_1, \\ldots, r_m</span> such that <span class="math">b</span> in <span class="math">\\mathrm{p_{dom}}(r, m - k)</span>. (to see why the remark holds notice that that blocks that the adversary broadcasts before round <span class="math">r_1</span> affect only the dominant path at round <span class="math">r_1</span>, and not at the following rounds)</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-17" class="text-2xl font-bold">B.2 Proof of Lemma 4</h2>

    <p class="text-gray-300">Proof. Let random variable <span class="math">Z_{s_1,s_2}</span> (resp. <span class="math">Z_{s_1,s_2}^{bd}</span>) denote the number of blocks the adversary computes (resp. broadcasts) from round <span class="math">s_1</span> until round <span class="math">s_2</span>, and random</p>

    <p class="text-gray-300">variable <span class="math">X_{s_1,s_2}</span> denote the number of rounds that are uniquely successful in the same interval.</p>

    <p class="text-gray-300">We are first going to prove two preliminary claims. We show that as long as from some round <span class="math">r</span> and afterwards the adversary broadcasts less blocks than the total number of uniquely successful rounds, the chain that any honest player adopts after round <span class="math">r</span> extends <span class="math">\\mathrm{p}_{\\mathrm{dom}}(r,X_{1,r} - Z_{1,r})</span>. More generally we can prove the following claim.</p>

    <p class="text-gray-300"><strong>Claim 3.</strong> Consider any execution such that for all <span class="math">s_2 \\geq s_1</span> it holds that <span class="math">Z_{1,s_2} &amp;lt; X_{1,s_2}</span>. Then, the chain that any honest player adopts after round <span class="math">s_1</span> extends <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_1, X_{1,s_1} - Z_{1,s_1})</span>.</p>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> Since <span class="math">X_{1,s_1} &amp;gt; Z_{1,s_1}</span> from Lemma 3 if follows that <span class="math">p = \\mathrm{p}_{\\mathrm{dom}}(s_1, X_{1,s_1} - Z_{1,s_1-1}) \\neq \\bot</span>. As long as the number of blocks that the adversary broadcasts at round <span class="math">s_2</span> are less than the dominance of the nodes in <span class="math">p</span> in <span class="math">\\tilde{T}_{s_2-1}</span>, all honest players at round <span class="math">s_2</span> will adopt chains containing <span class="math">p</span>. Thus uniquely successful rounds will increase the dominance of these nodes. But since from the assumptions made, <span class="math">Z_{1,s_2} &amp;lt; X_{1,s_2}</span>, in all rounds after round <span class="math">s_1</span>, the nodes in <span class="math">p</span> are at least 1-dominant in every <span class="math">\\mathcal{T}_{s_2}^P</span> where <span class="math">P</span> is an honest player; the claim follows.</p>

    <p class="text-gray-300">Next we will show that if successive u.s. rounds occur such that the blocks mined are on different branches, then the adversary must broadcast an adequate number of blocks, as specified below.</p>

    <p class="text-gray-300"><strong>Claim 4.</strong> Consider any execution where <span class="math">s_1 &amp;lt; s_2 &amp;lt; \\ldots &amp;lt; s_m</span> are u.s. rounds and <span class="math">s_k</span> is the first u.s. round such that the honest block mined in this round is not a descendant of the honest block mined in round <span class="math">s_{k-1}</span>, for <span class="math">k \\in \\{2,..,m\\}</span>. Then either <span class="math">Z_{s_1 - 1,s_m - 1}^{bd} &amp;gt; X_{s_1,s_m - 1}</span> or <span class="math">Z_{s_1 - 1,s_m - 1}^{bd} = X_{s_1,s_m - 1}</span> and the honest block mined at round <span class="math">s_m</span> will be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_m,1)</span>.</p>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> Let <span class="math">b_{1},..,b_{m}</span> denote the honest blocks mined at rounds <span class="math">s_1,..,s_m</span> respectively. We are going to prove the claim for <span class="math">m = 2</span>. Suppose, for the sake of contradiction, that <span class="math">Z_{s_1 - 1,s_2 - 1}^{bd} &amp;lt; X_{s_1,s_2 - 1}</span>. By the definition of <span class="math">s_2</span>, the honest blocks mined on all u.s. rounds until round <span class="math">s_2 - 1</span> are descendants of <span class="math">b_1</span>. From Lemma 3 at least one honest block <span class="math">b</span> computed in one of the u.s. rounds in <span class="math">[s_1,s_2 - 1]</span> will be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_2 - 1,X_{s_1,s_2 - 1} - Z_{s_1 - 1,s_2 - 2}^{bd})</span>. Since from our hypothesis the adversary will broadcast less than <span class="math">Z_{s_2 - 1,s_2 - 1}^{bd} &amp;lt; X_{s_1,s_2 - 1} - Z_{s_1 - 1,s_2 - 2}^{bd}</span> blocks at round <span class="math">s_2 - 1</span>, it is impossible for <span class="math">b_2</span> not to be a descendant of <span class="math">b</span> and thus of <span class="math">b_1</span> which is a contradiction. Hence, <span class="math">Z_{s_1 - 1,s_2 - 1}^{bd} \\geq X_{s_1,s_2 - 1}</span>. If <span class="math">Z_{s_1 - 1,s_2 - 1}^{bd} &amp;gt; X_{s_1,s_2 - 1}</span> the base case follows. Otherwise, <span class="math">Z_{s_1 - 1,s_2 - 1}^{bd} = X_{s_1,s_2 - 1}</span> and we have two cases. In the first case, <span class="math">X_{s_1,s_2 - 1} = Z_{s_1 - 1,s_2 - 2}^{bd}</span> and at round round <span class="math">s_2 - 1</span> the adversary does not broadcast any block. From Claim B.1 of Lemma 3, <span class="math">b_2</span> will be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_2,1)</span>. In the second case, it holds that the adversary broadcasts exactly <span class="math">X_{s_1,s_2 - 1} - Z_{s_1 - 1,s_2 - 2}^{bd}</span> blocks at round <span class="math">s_2 - 1</span>. From Claim B.1 of Lemma 3, since <span class="math">b_2</span> cannot be a descendant of the last node of <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_2 - 1,1)</span>, <span class="math">b_2</span> will be in <span class="math">\\mathrm{p}_{\\mathrm{dom}}(s_2,1)</span>. Hence, the base case follows.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">Suppose the lemma holds until round <span class="math">s_m</span>. By the inductive hypothesis we have two cases. In the first case <span class="math">Z_{s_1 - 1, s_m - 1}^{bd} &amp;gt; X_{s_1, s_m - 1}</span> which implies <span class="math">Z_{s_1 - 1, s_m - 1}^{bd} \\geq X_{s_1, s_m}</span>. If no u.s. round happens during rounds <span class="math">s_m + 1, \\ldots, s_{m+1} - 1</span> then from Claim B.1 in the proof of Lemma 3 the claim follows. Otherwise, a u.s. round <span class="math">s&#x27;</span> happens during these rounds, where the honest block mined is a descendant of <span class="math">b_m</span>. Then we can make the same argument as for the base case starting from round <span class="math">s&#x27;</span> and get that either <span class="math">Z_{s&#x27; - 1, s_{m+1} - 1}^{bd} &amp;gt; X_{s&#x27;, s_{m+1} - 1}</span> or <span class="math">Z_{s&#x27; - 1, s_{m+1} - 1}^{bd} = X_{s&#x27;, s_{m+1} - 1}</span> and the honest block mined at round <span class="math">s_{m+1}</span> will be in <span class="math">\\mathrm{p_{dom}}(s_{m+1}, 1)</span>. Since <span class="math">Z_{s&#x27; - 1, s_{m+1} - 1}^{bd} &amp;lt; Z_{s_m - 1, s_{m+1} - 1}^{bd}</span> and <span class="math">X_{s&#x27;, s_{m+1} - 1} = X_{s_m + 1, s_{m+1} - 1}</span>, by the inequality of the inductive hypothesis the claim follows.</p>

    <p class="text-gray-300">In the second case <span class="math">Z_{s_1 - 1, s_m - 1}^{bd} = X_{s_1, s_m - 1}</span> and the honest block <span class="math">b_m</span> mined at round <span class="math">s_m</span> will be in <span class="math">\\mathrm{p_{dom}}(s_m, 1)</span>. From Remark 1 of the proof of claim Lemma 3, for an application of this Lemma from rounds <span class="math">s_m</span> until <span class="math">s_{m+1} - 1</span> we can count the adversarial blocks starting from round <span class="math">s_m</span>. Thus from the same argument as for the base case starting from round <span class="math">s_m</span> we get that either <span class="math">Z_{s_m, s_{m+1} - 1}^{bd} &amp;gt; X_{s_m, s_{m+1} - 1}</span> or <span class="math">Z_{s_m, s_{m+1} - 1}^{bd} = X_{s_m, s_{m+1} - 1}</span> and the honest block mined at round <span class="math">s_m</span> will be in <span class="math">\\mathrm{p_{dom}}(s_m, 1)</span>. By the equality of the inductive hypothesis the claim follows.</p>

    <p class="text-gray-300">Next, we observe that Lemma 3 as well as Claim B.2 and B.2 can be applied on a subtree of the block tree, if all honest blocks mined after the round the root of the subtree was mined are on this subtree.</p>

    <p class="text-gray-300"><strong>Observation 1.</strong> Let <span class="math">b</span> be an honest block computed at round <span class="math">s_1</span> that is in the chains adopted by all honest players after round <span class="math">s_2</span>. Also, suppose that all blocks mined at u.s. rounds after round <span class="math">s_1</span> are descendants of <span class="math">b</span>. Then the following hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Regarding applications of Lemma 3 and Claim B.2 on the subtree of the block tree rooted on <span class="math">b</span> after round <span class="math">s_1</span>, we can ignore all blocks that the adversary has mined up to round <span class="math">s_1</span>.</li>

      <li>Regarding applications of Claim B.2 after round <span class="math">s_2</span>, we can ignore all blocks that the adversary has mined up to round <span class="math">s_1</span>.</li>

    </ol>

    <p class="text-gray-300">To see why the observation holds consider the following. Since the adversary receives block <span class="math">b</span> for the first time at round <span class="math">s_1 + 1</span>, all blocks that the adversary mines before round <span class="math">s_1 + 1</span> cannot be descendants of <span class="math">b</span>. Regarding the first point, blocks that are not descendants of <span class="math">b</span> do not affect the validity of Lemma 3 and Claim B.2 on the subtree of the block tree rooted on <span class="math">b</span>; this is because blocks that are not descendants of <span class="math">b</span>, do not affect the dominance of the nodes of the subtree rooted at <span class="math">b</span>. Regarding the second point, consider the dominant path at round <span class="math">s_3 &amp;gt; s_2</span> in the subtree that is rooted on <span class="math">b</span>. Then, this path can be extended up to the root node, since, by our assumption, <span class="math">b</span> is in the chains adopted by all honest players after round <span class="math">s_2</span>.</p>

    <p class="text-gray-300">We are now ready to prove the lemma. First, we are going to define a set of bad events which we will show that hold with probability exponentially small</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">in <span class="math">s</span>. Assuming these events don't occur we will then show that our lemma is implied, and thus the lemma will follow with overwhelming probability.</p>

    <p class="text-gray-300">Let <span class="math">BAD(s_1, s_2)</span> be the event that <span class="math">X_{s_1, s_2} \\leq Z_{s_1, s_2}</span>. In [9, Lemma 5], by an application of the Chernoff bounds it was proved that assuming that <span class="math">\\gamma \\geq (1 + \\delta)\\beta</span> for some <span class="math">\\delta \\in (0,1)</span>, then with probability at least <span class="math">(1 - e^{-\\frac{\\beta}{243}\\delta^2 s&#x27;})(1 - e^{-\\frac{\\gamma}{128}\\delta^2 s&#x27;}) \\geq 1 - e^{-(\\min(\\frac{\\beta}{243}, \\frac{\\gamma}{128})\\delta^2 s&#x27; - \\ln(2))}</span> for any <span class="math">r&#x27; &amp;gt; 0, s&#x27; \\geq s</span>:</p>

    <div class="my-4 text-center"><span class="math-block">X_{r&#x27;, r&#x27; + s&#x27; - 1} &amp;gt; \\left(1 + \\frac{\\delta}{2}\\right) Z_{r&#x27;, r&#x27; + s&#x27; - 1} \\tag{1}</span></div>

    <p class="text-gray-300">Thus, there exists an appropriate constant <span class="math">\\epsilon = \\delta^2\\min (\\frac{\\beta}{243},\\frac{\\gamma}{128})</span>, independent of <span class="math">r</span>, such that it holds that for any <span class="math">r&#x27; &amp;gt; 0,s&#x27;\\geq s</span>, <span class="math">BAD(r&#x27;,r&#x27; + s&#x27; - 1)</span> occurs with probability at most <span class="math">e^{-\\epsilon \\delta^2 s&#x27; + \\ln 2}</span>. From an application of the union bound, we get that for the function <span class="math">g(s) = \\epsilon \\delta^2 s - \\ln 2 + \\ln (1 - e^{-\\epsilon \\delta^2})</span>, the probability that <span class="math">\\bigvee_{r&#x27;\\geq s}BAD(s_1 + 1,s_1 + r&#x27;)</span> happens is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\bigvee_{r&#x27; \\geq s} BAD(s_1 + 1, s_1 + r&#x27;) \\right] \\leq \\sum_{r&#x27; \\geq s} e^{-\\epsilon \\delta^2 r&#x27; + \\ln 2} \\\\ \\leq e^{\\ln 2} \\sum_{r&#x27; \\geq s} e^{-\\epsilon \\delta^2 r&#x27;} \\\\ \\leq e^{\\ln 2} \\frac{e^{-\\epsilon \\delta^2 s}}{1 - e^{-\\epsilon \\delta^2}} \\\\ \\leq e^{-g(s)} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Until now we have assumed that the execution we are studying is collision-free; no two queries in the oracle return the same value for different inputs. Let <span class="math">COL</span> denote the event where a collision occurs in our execution. The probability of <span class="math">COL</span> in a polynomial number of rounds, is exponentially small on <span class="math">\\kappa</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [COL] \\leq (f \\kappa^c)^2 / 2^{\\kappa + 1} = e^{-\\Omega(\\kappa)} \\leq e^{-\\Omega(s)}</span></div>

    <p class="text-gray-300">Let <span class="math">BAD(s_1)</span> denote the event where <span class="math">\\bigvee_{r&#x27; \\geq s} BAD(s_1 + 1, s_1 + r&#x27;)</span> or <span class="math">COL</span> happens. From the union bound the probability that <span class="math">BAD(s_1)</span> happens, for any <span class="math">s_1</span> is negligible.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [BAD(s_1)] \\leq e^{-g(s)} + e^{-\\Omega(s)} \\leq e^{-\\Omega(s)}</span></div>

    <p class="text-gray-300">We are going to show next that, conditioning on the negation of this event the statement of the lemma follows.</p>

    <p class="text-gray-300">We will use the convention that block <span class="math">b_i</span> is mined at round <span class="math">r_i</span>. Let <span class="math">b_1</span> be the most recent honest block that is in the chains that all honest players have adopted on and after round <span class="math">r</span>, such that the blocks mined at all u.s. rounds after round <span class="math">r_1</span> are descendants of <span class="math">b_1</span>. This block is well defined, since in the worst case it is the genesis block. If <span class="math">r_1</span> is greater or equal to <span class="math">r - s</span>, then the lemma follows for block <span class="math">b_1</span> with probability 1.</p>

    <p class="text-gray-300">23</p>

    <p class="text-gray-300">Suppose round <span class="math">r_1</span> is before round <span class="math">r - s</span> and that <span class="math">BAD(r_1)</span> does not happen. The negation of <span class="math">BAD(r_1)</span> implies that <span class="math">X_{r_1 + 1, r - 1 + c} &amp;gt; Z_{r_1 + 1, r - 1 + c}</span>, for <span class="math">c \\geq 0</span>. By Lemma 3 and Claim B.2 there exists at least one honest block <span class="math">b_2</span>, mined in a u.s. round and contained in the chains of all honest players on and after round <span class="math">r</span>. W.l.o.g. let <span class="math">b_2</span> be the most recently mined such block. By the definition of <span class="math">b_1</span>, <span class="math">b_2</span> is a descendant of <span class="math">b_1</span>. If <span class="math">r_2</span> is greater or equal to <span class="math">r - s</span> then the lemma follows, since <span class="math">b_2</span> is an honest block mined on and after round <span class="math">r - s</span> that satisfies the conditions of the lemma.</p>

    <p class="text-gray-300">Suppose round <span class="math">r_2</span> is before round <span class="math">r - s</span>. Let <span class="math">r_3</span> be the earliest u.s. round, such that <span class="math">b_3</span> and the blocks mined at all u.s. rounds afterwards are descendants of <span class="math">b_2</span>. Since <span class="math">b_2</span> will be in the chains of all honest players after round <span class="math">r</span>, round <span class="math">r_3</span> is well defined. Also let <span class="math">s_1 &amp;lt; \\ldots &amp;lt; s_m &amp;lt; \\ldots</span> be the sequence of u.s. rounds after round <span class="math">r_1</span> that satisfy the conditions of Claim B.2. That is, <span class="math">s_k</span> is the first u.s. round such that the honest block mined in this round is not a descendant of the honest block mined in round <span class="math">s_{k-1}</span>, for <span class="math">k \\in \\{2,..,m\\}</span>. The first u.s. round after round <span class="math">r_1</span> corresponds to <span class="math">s_1</span>.</p>

    <p class="text-gray-300">We will argue that <span class="math">r_3</span> is equal to some <span class="math">s_i &amp;gt; s_1</span> in the aforementioned sequence. Suppose, for the sake of contradiction that it does not. This implies that the honest block mined at round <span class="math">r_3</span> (denoted by <span class="math">b_3</span>) is a descendant of the honest block mined at some round <span class="math">s_i</span> of the sequence. W.l.o.g. suppose that <span class="math">s_i</span> is the largest such round that is before round <span class="math">r_3</span>. There are three cases. In the first case, <span class="math">r_2 &amp;lt; s_i &amp;lt; r_3</span>. By the definition of <span class="math">s_i</span> and <span class="math">r_3</span>, the block mined at round <span class="math">s_i</span> is an ancestor of <span class="math">b_3</span> and also a descendant of <span class="math">b_2</span>. Hence, <span class="math">s_i</span> satisfies the definition of <span class="math">r_3</span> which is a contradiction (there is an earlier round than <span class="math">r_3</span> with the same property). In the second case, <span class="math">s_i = r_4</span>, where <span class="math">b_4</span> is a descendant of <span class="math">b_1</span> and either <span class="math">b_2 = b_4</span> or <span class="math">b_4</span> is an ancestor of <span class="math">b_2</span>. Then <span class="math">b_4</span> is a block that satisfies the definition of <span class="math">b_1</span>, and is more recent, which is a contradiction. In the third case, <span class="math">r_1 &amp;lt; s_i &amp;lt; r_2</span> and the block mined at round <span class="math">s_i</span> is not an ancestor of <span class="math">b_2</span>. By the definition of <span class="math">s_i</span>, the honest block mined at round <span class="math">s_i</span> is an ancestor of <span class="math">b_3</span>, that has been mined before round <span class="math">r_2</span>. But this is contradictory, since no honest block can be an ancestor of <span class="math">b_3</span>, mined before round <span class="math">r_2</span>, but not be an ancestor of <span class="math">b_2</span>.</p>

    <p class="text-gray-300">Since we proved that <span class="math">r_3</span> is equal to some <span class="math">s_i</span> we can apply Claim B.2 from round <span class="math">r_1 + 1</span> until round <span class="math">r_3</span>. Again, from Observation 1, regarding applications of Claim B.2 after round <span class="math">r_1</span> we can ignore blocks that were mined before round <span class="math">r_1 + 1</span>. Then either <span class="math">Z_{r_1 + 1,r_3 - 1} \\geq Z_{r_1 + 1,r_3 - 1}^{bd} &amp;gt; X_{r_1 + 1,r_3 - 1}</span> or <span class="math">Z_{r_1 + 1,r_3 - 1} \\geq Z_{r_1 + 1,r_3 - 1}^{bd} = X_{r_1 + 1,r_3 - 1}</span> and the honest block mined at round <span class="math">r_3</span> will be in <span class="math">\\mathrm{p_{dom}}(r_3,1)</span>.</p>

    <p class="text-gray-300">Suppose, for the sake of contradiction, that round <span class="math">r_3</span> is after round <span class="math">r_2 + s</span>. Then <span class="math">(r_3 - 1) - (r_1 + 1) \\geq s</span> and <span class="math">Z_{r_1 + 1, r_3 - 1} \\geq X_{r_1 + 1, r_3 - 1}</span>. This is a contradiction, since in this case <span class="math">\\neg BAD(r_1)</span> implies <span class="math">Z_{r_1 + 1, r_3 - 1} &amp;lt; X_{r_1 + 1, r_3 - 1}</span>. Therefore, <span class="math">r_3 \\leq r_2 + s &amp;lt; r</span>. In addition, notice that <span class="math">\\neg BAD(r_1)</span> also implies</p>

    <div class="my-4 text-center"><span class="math-block">X_{r_1 + 1, r_2 + s} &amp;gt; Z_{r_1 + 1, r_2 + s} \\tag{2}</span></div>

    <p class="text-gray-300">We are going to apply Lemma 3 and Observation 1 from round <span class="math">r_3</span> until round <span class="math">r_2 + s</span> in the subtree rooted at <span class="math">b_2</span>. According to the analysis we made previously</p>

    <p class="text-gray-300">24</p>

    <p class="text-gray-300">there are two cases. In the first case, <span class="math">Z_{r_1 + 1,r_3 - 1}^{bd} &amp;gt; X_{r_1 + 1,r_3 - 1}</span> or equivalently <span class="math">Z_{r_1 + 1,r_3 - 1}^{bd} \\geq X_{r_1 + 1,r_3}</span>. Suppose, for the sake of contradiction, that <span class="math">r_3 = r_2 + s</span>. Then <span class="math">Z_{r_1 + 1,r_2 + s - 1} \\geq X_{r_1 + 1,r_2 + s}</span>. But this is a contradiction, since <span class="math">\\neg BAD(r_1)</span> implies Inequality 2. Therefore, <span class="math">r_3 &amp;lt; r_2 + s</span>. From Inequality 2:</p>

    <div class="my-4 text-center"><span class="math-block">X_{r_3 + 1, r_2 + s} \\geq X_{r_1 + 1, r_2 + s} - X_{r_1 + 1, r_3} &amp;gt; Z_{r_1 + 1, r_k + s} - Z_{r_1 + 1, r_3 - 1}^{bd} \\geq Z_{r_3, r_2 + s}^{bd}</span></div>

    <p class="text-gray-300">The last inequality, stems from two facts: that we can ignore blocks that were mined before round <span class="math">r_1 + 1</span> regarding applications of Lemma 3 and also that the blocks that the adversary broadcasts at distinct rounds are different (adversaries that broadcast the same block multiple times can be ignored without loss of generality).</p>

    <p class="text-gray-300">In the second case, <span class="math">Z_{r_1 + 1,r_3 - 1}^{bd} = X_{r_1 + 1,r_3 - 1}</span> and the honest block mined at round <span class="math">r_3</span> will be in <span class="math">\\mathrm{p_{dom}}(r_3,1)</span>. Again from Inequality 2:</p>

    <div class="my-4 text-center"><span class="math-block">X_{r_3, r_2 + s} = X_{r_1 + 1, r_2 + s} - X_{r_1 + 1, r_3 - 1} &amp;gt; Z_{r_1 + 1, r_k + s} - Z_{r_1 + 1, r_3 - 1}^{bd} \\geq Z_{r_3, r_2 + s}^{bd}</span></div>

    <p class="text-gray-300">The same analysis holds for all rounds after <span class="math">r_2 + s</span>. By an application of Claim B.2, an honest block <span class="math">b</span>, computed in one of the u.s. rounds after round <span class="math">r_2</span> and before round <span class="math">r</span>, will be in the chains that honest players adopt on and after round <span class="math">r</span>. Since <span class="math">b_2</span> is the most recently mined block, before round <span class="math">r - s</span>, included in the chain of all honest players, <span class="math">b</span> must have been mined on and after round <span class="math">r - s</span> (since <span class="math">r_3 &amp;gt; r_2</span>). Let <span class="math">A</span> be the event that there exists a block mined by an honest player on and after round <span class="math">r - s</span>, that is contained in the chain which any honest player adopts after round <span class="math">r</span>. We have proved that <span class="math">(\\neg BAD(r_1))</span> implies <span class="math">A</span>. Then:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr[A] = \\Pr[A \\wedge BAD(r_1)] + \\Pr[A \\wedge \\neg BAD(r_1)] \\\\ \\geq \\Pr[A \\wedge \\neg BAD(r_1)] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Pr[A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg BAD(r_1)] \\Pr[\\neg BAD(r_1)] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\Pr[\\neg BAD(r_1)] \\\\ \\geq 1 - e^{-g(s)} \\end{array} $$</p>

    <p class="text-gray-300">Hence, the lemma holds with probability at least <span class="math">1 - e^{-g(s)}</span>.</p>

    <p class="text-gray-300">25</p>`;
---

<BaseLayout title="On Trees, Chains and Fast Transactions in the Blockchain (2016/545)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/545
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
