---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/538';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Supporting Non-membership Proofs with Bilinear-map  Accumulators';
const AUTHORS_HTML = 'Ivan Damgård, Nikos Triandopoulos';

const CONTENT = `    <p class="text-gray-300">Supporting Non-membership Proofs with Bilinear-map Accumulators</p>

    <p class="text-gray-300">Ivan Damgård * University of Aarhus Denmark</p>

    <p class="text-gray-300">Nikos Triandopoulos † Boston University USA</p>

    <p class="text-gray-300">December 20, 2008</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">In this short note, we present an extension of Nguyen’s bilinear-map based accumulator scheme [8] to support non-membership witnesses and corresponding non-membership proofs, i.e., cryptographic proofs that an element has not been accumulated to a given set. This complements the non-membership proofs developed by Li et al. [7] for the RSA accumulator [2, 3, 5], making the functionality of the bilinear-map accumulator equivalent to that of the RSA accumulator. Our non-membership extension of Nguyen’s scheme [8] makes use of the <span class="math">q</span>-Strong Diffie-Hellman assumption the security of the original scheme is based on.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Dynamic accumulators are cryptographic authentication primitives for optimally verifying set-membership relations. Given a set <span class="math">X</span> of elements, an accumulator can be used to compute an accumulation value, a short (namely, of constant size) secure description <span class="math">A(X)</span> of <span class="math">X</span>, subject to which there exist short (namely, of constant size) witnesses for any element in <span class="math">X</span> that has been “accumulated” to <span class="math">A(X)</span>. Each element-specific witness can be used to provide an efficient (namely, of constant verification time) cryptographic proof that the corresponding element is a member of <span class="math">X</span>. Element insertions in or deletions from set <span class="math">X</span> result in corresponding updates on the accumulation values and the element witnesses.</p>

    <p class="text-gray-300">Accumulators were first introduced by Benaloh and de Mare [3], and were later further studied and extended by Baric and Pfitzmann [2]. Both constructions were based on the RSA exponentiation function and proved secure under the strong RSA assumption. Camenisch and Lysyanskaya [5] further advanced the RSA accumulator by introduced dynamic extensions, as well as privacy-preserving membership proofs. Consequently, many extensions of the RSA accumulator have been proposed, including accumulation of composite integers [11], bounded number of accumulated elements [1], set-up without trapdoor [10], and, finally, non-membership witnesses and corresponding non-membership proofs, introduced by Li et al. [7]. Non-membership witnesses extend the functionality of accumulators by supporting cryptographic proofs that a given element is not a member of the set, that is, it was never accumulated to the current set. Finally, works improving on the efficiency of the RSA accumulator include [6, 9].</p>

    <p class="text-gray-300">*Dept. of Computer Science, University of Aarhus, Aarhus, DK 8200, Denmark. Email: ivan@cs.au.dk. †Dept. of Computer Science, Boston University, Boston, MA 02215, USA. Email: nikos@cs.bu.edu. This research was performed while the author was at University of Aarhus, Denmark.</p>

    <p class="text-gray-300">The first alternative construction of a dynamic accumulator (beyond the one based on RSA) is due to Nguyen <em>[8]</em>. This scheme is based on bilinear pairings and the construction is proven secure under the <span class="math">q</span>-strong Diffie-Hellman assumption <em>[4]</em> on general groups. We refer to this accumulator scheme as bilinear-map accumulator. Recently a new construction based on Paillier’s encryption system has been proposed that additionally offers batch element updates <em>[12]</em>.</p>

    <p class="text-gray-300">In this short note, we describe an extension of Nguyen’s bilinear-map accumulator scheme to support non-membership witnesses and non-membership proofs and prove the security of this extended scheme.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Non-Membership Verification for Bilinear-map Accumulators</h2>

    <p class="text-gray-300">We first present some necessary preliminaries related to the underlying computational hardness assumption our non-membership extension (and also the original scheme by Nguyen <em>[8]</em>) is based on. We then build on Nguyen’s original accumulator scheme to define the new non-membership witnesses, describe their corresponding verification test and finally prove their security.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 The <span class="math">q</span>-strong Diffie-Hellman Assumption</h3>

    <p class="text-gray-300">We first present the <span class="math">q</span>-strong DH assumption <em>[4]</em> over general groups, which has been used in many contexts.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Definition 2.1 (<span class="math">q</span>-Strong Diffie-Hellman Assumption.)</h6>

    <p class="text-gray-300">Let <span class="math">G=&lt;g&gt;</span> be a cyclic group of prime order <span class="math">p</span> and <span class="math">\\kappa\\in\\mathbb{Z}_{p}^{<em>}</span>. Under the <span class="math">q</span>-strong Diffie-Hellman assumption, any probabilistic polynomial-time algorithm <span class="math">A</span> that is given set <span class="math">\\{g^{\\kappa^{i}}:0\\leq i\\leq q\\}</span>, finds a pair <span class="math">(x,g^{\\frac{1}{x+\\kappa}})\\in\\mathbb{Z}_{p}^{</em>}\\times G</span> with at most <span class="math">O(1/p)</span> probability, where the probability is over the random choice of <span class="math">\\kappa\\in\\mathbb{Z}_{p}^{*}</span> and the random bits chosen by <span class="math">A</span>.</p>

    <p class="text-gray-300">In the sequel, whenever operating on group elements in <span class="math">G</span> of prime order <span class="math">p</span>, we always make use of the fact that <span class="math">g^{x}=g^{x\\mod p},x\\in\\mathbb{Z}</span>; i.e., all operations in the exponent can be reduced modulo the group order <span class="math">p</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.2 Accumulators Based on Bilinear Maps</h3>

    <p class="text-gray-300">We now present Nguyen’s scheme and appropriately extend it to support non-membership proofs.</p>

    <p class="text-gray-300">Given the security parameter <span class="math">\\lambda</span>, let <span class="math">G</span> be a multiplicative cyclic group of prime order <span class="math">p</span> that is generated by <span class="math">g</span>, where <span class="math">p</span> grows exponentially with <span class="math">\\lambda</span>. Additionally, group <span class="math">G</span> is chosen such that it supports a (non-degenerate) bilinear pairing to a target cyclic group <span class="math">G_{T}</span> of prime order <span class="math">p</span>. That is, if <span class="math">G</span> is generated by element <span class="math">g</span>, then there exists a bilinear, non-trivial, map <span class="math">e:G\\times G\\rightarrow G_{T}</span> from pairs of elements in <span class="math">G</span> to elements of target group <span class="math">G_{T}</span>, such that for any two integers <span class="math">a,b</span> it holds that <span class="math">e(g^{a},g^{b})=e(g,g)^{ab}</span> and where, additionally, element <span class="math">e(g,g)\\in G_{T}</span> generates <span class="math">G_{T}</span>.</p>

    <p class="text-gray-300">Let <span class="math">A_{\\kappa}:2^{\\mathbb{Z}_{p}^{<em>}}\\rightarrow G</span> be an accumulation function that is parameterized by <span class="math">\\kappa\\in\\mathbb{Z}_{p}^{</em>}</span> and maps sets <span class="math">X</span> of integers in <span class="math">\\mathbb{Z}_{p}^{*}</span> to elements in <span class="math">G</span> according to the mapping</p>

    <p class="text-gray-300"><span class="math">A_{\\kappa}(X)=g^{\\prod_{x\\in X}(x+\\kappa)}\\;.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This has been the accumulation function used by Nguyen in <em>[8]</em> to construct the first accumulator scheme that is not based on the RSA exponentiation function. In Nguyen’s construction, <span class="math">\\kappa</span> is the trapdoor information and set $\\{g^{\\kappa^{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\leq i\\leq q\\}<span class="math"> is the public key, </span>q<span class="math"> in an upper bound on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n$ that grows polynomially with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the security parameter <span class="math">\\lambda=O(\\log p)</span>. Seen as a polynomial on <span class="math">\\kappa</span> of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, let </span>f_{X}(\\kappa)<span class="math"> denote the product in the exponent of </span>A_{\\kappa}(X)$, that is,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f_{X}(\\kappa)\\triangleq\\prod_{x\\in X}(x+\\kappa)\\;.</span></p>

    <p class="text-gray-300">As in <em>[8]</em>, for any <span class="math">x\\in X</span>, we define the <em>membership witness</em> <span class="math">w_{x}\\in G</span> of <span class="math">x</span> with respect to accumulation value <span class="math">A_{\\kappa}(X)</span> to be the value <span class="math">w_{x}</span> satisfying the <em>membership verification test</em></p>

    <p class="text-gray-300"><span class="math">w_{x}^{(x+\\kappa)}=A_{\\kappa}(X)\\;,</span> (1)</p>

    <p class="text-gray-300">which, using the bilinear map <span class="math">e(\\cdot,\\cdot)</span> and the publicly known group element <span class="math">h=g^{\\kappa}</span>, is realized in practice as</p>

    <p class="text-gray-300"><span class="math">e(w_{x},g^{x}\\cdot h)=e(A_{\\kappa}(X),g)\\;.</span> (2)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, any member <span class="math">x</span> of set <span class="math">X</span> has a <em>unique</em> corresponding membership witness <span class="math">w_{x}\\triangleq g^{\\frac{f_{X}(\\kappa)}{x+\\kappa}}=g^{q_{X,x}(\\kappa)}</span> (since $(x+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{X}(\\kappa)<span class="math">), for some polynomial </span>q_{X,x}(\\kappa)<span class="math"> of degree </span>n-1<span class="math"> that is uniquely defined by set </span>X-x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.3 Non-membership Verification for Accumulators Based on Bilinear Maps</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Inspired by the non-membership test proposed by Li <em>et al.</em> in <em>[7]</em> for the RSA accumulator, we introduce <em>non-membership witnesses</em> for the accumulation function <span class="math">A_{\\kappa}(\\cdot)</span>. For any <span class="math">y\\notin X</span>, the <em>non-membership witness</em> <span class="math">\\hat{w}_{y}</span> of <span class="math">y</span> with respect to <span class="math">A_{\\kappa}(X)</span> is a pair of values <span class="math">(w_{y},u_{y})\\in G\\times\\mathbb{Z}_{p}^{*}</span>, subject to the requirements <span class="math">(i)</span> <span class="math">u_{y}\\neq 0</span> and <span class="math">(ii)</span> $(y+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[f_{X}(\\kappa)+u_{y}]$, additionally satisfying the <em>non-membership verification test</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">w_{y}^{(y+\\kappa)}=A_{\\kappa}(X)\\cdot g^{u_{y}}\\;,</span> (3)</p>

    <p class="text-gray-300">which, using the bilinear map <span class="math">e(\\cdot,\\cdot)</span> and the publicly known group element <span class="math">h=g^{\\kappa}</span>, is realized in practice as</p>

    <p class="text-gray-300"><span class="math">e(w_{y},g^{y}\\cdot h)=e(A_{\\kappa}(X)\\cdot g^{u_{y}},g)\\;.</span> (4)</p>

    <p class="text-gray-300">In particular, any non-member <span class="math">y</span> of set <span class="math">X</span> has a <em>unique</em> corresponding non-membership witness <span class="math">\\hat{w}_{y}=(w_{y},u_{y})</span>, by setting</p>

    <p class="text-gray-300"><span class="math">u_{y}\\triangleq-f_{X}(-y)\\mod p=-\\prod_{x\\in X}(x-y)\\mod p\\;,</span> (5)</p>

    <p class="text-gray-300">and then accordingly setting</p>

    <p class="text-gray-300"><span class="math">w_{y}=g^{\\frac{f_{X}(\\kappa)-f_{X}(-y)}{y+\\kappa}}=g^{\\hat{q}_{X}(\\kappa)}\\;,</span> (6)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for some polynomial <span class="math">\\hat{q}_{X}(\\kappa)</span> of degree <span class="math">n-1</span> that is uniquely defined by set <span class="math">X</span>. Note that, since <span class="math">y\\notin X</span>, it holds that <span class="math">u_{y}\\neq 0</span>. Also note that, if <span class="math">h_{X}(\\kappa)=f_{X}(\\kappa)-f_{X}(-y)</span>, then <span class="math">h_{X}(-y)=0</span>, thus it holds that $(y+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{X}(\\kappa)<span class="math"> (thus, justifying the last part of Equation 6) and, in fact, that </span>(y+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[f_{X}(\\kappa)+u_{y}]<span class="math">. Thus, in addition to Equations 3 and 4, the pair of values </span>(w_{y},u_{y})<span class="math"> defined above satisfies the required conditions </span>u_{y}\\neq 0<span class="math"> and </span>(y+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[f_{X}(\\kappa)+u_{y}]<span class="math">. We require that the verification process immediately rejects if </span>u_{y}=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Also, observe that the non-membership witness for <span class="math">y\\notin X</span> can be computed efficiently (in polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> time), using only set </span>X<span class="math"> and the public key, by evaluating polynomial </span>-f_{X}(\\kappa)<span class="math"> on </span>-y<span class="math"> and then computing the group element </span>w_{y}$ through Equation 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">We say that a membership, respectively non-membership, witness <span class="math">w_{x}</span>, respectively <span class="math">\\hat{w}_{y}=(w_{y},u_{y})</span>, is fake if <span class="math">x\\notin X</span>, respectively <span class="math">y\\in X</span>, and, still, the corresponding membership. respectively non-membership, verification test (in particular, expressed through Equations 1 and 3 respectively) is satisfied.</p>

    <p class="text-gray-300">The security of non-membership test relies on the following: if <span class="math">y</span> is in <span class="math">X</span> then <span class="math">y+\\kappa</span> divides polynomial <span class="math">f_{X}(\\kappa)</span>, and therefore <span class="math">y+\\kappa</span> cannot divide polynomial <span class="math">f_{X}(\\kappa)+u_{y}</span> for any choice of <span class="math">u_{y}\\neq 0</span>. (Recall that the verifier first checks whether <span class="math">u_{y}\\neq 0</span>, according to the definition of non-membership witnesses.) Based on the fact that <span class="math">(y+\\kappa)\\nmid[f_{X}(\\kappa)+u_{y}]</span>, one can easily reduce any fake non-membership witness to an attack to the <span class="math">q</span>-Strong DH assumption, using a simple polynomial division and the public key. For completeness we present the security proof for both membership and non-membership witnesses.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Lemma 1</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Under the <span class="math">q</span>-Strong Diffie-Hellman assumption, any PPT algorithm <span class="math">B</span>, given any set <span class="math">X</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math"> and set </span>\\{g^{\\kappa^{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\leq i\\leq q\\}<span class="math">, finds a fake non-membership witness of a member of </span>X<span class="math"> or a fake membership witness of a non-member of </span>X<span class="math"> with respect to </span>A_{\\kappa}(X)<span class="math"> with probability at most </span>O(1/p)<span class="math">, measured over the random choice of </span>\\kappa\\in\\mathbb{Z}_{p}^{*}<span class="math"> and random bits of </span>B$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof: Consider the case of membership witnesses first. Suppose that there exists PPT algorithm <span class="math">B</span> that with non-negligible probability outputs a fake membership witness <span class="math">w_{x}</span> for <span class="math">x\\notin X</span> with respect to <span class="math">A_{\\kappa}(X)</span>. Then, <span class="math">w_{x}^{x+\\kappa}=A_{\\kappa}(X)=g^{f_{X}(\\kappa)}</span>, where $f_{X}(\\kappa)=\\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}c_{i}\\cdot\\kappa^{i}<span class="math">, with </span>c_{i}<span class="math"> being a known coefficient that depends on the elements of </span>X<span class="math">, </span>0\\leq i\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since </span>x\\notin X<span class="math">, it is </span>(x+\\kappa)\\nmid f_{X}(\\kappa)<span class="math">. Thus, using polynomial division and given </span>X,x<span class="math">, one can compute a non zero integer </span>c<span class="math"> and a polynomial </span>q(\\kappa)<span class="math"> of degree </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> such that </span>f_{X}(\\kappa)=c+q(\\kappa)\\cdot(x+\\kappa)<span class="math">. Therefore, </span>w_{x}=g^{q(\\kappa)}\\cdot g^{\\frac{c}{x+\\kappa}}<span class="math"> and </span>g^{\\frac{1}{x+\\kappa}}=[w_{x}\\cdot[g^{q(\\kappa)}]^{-1}]^{c^{-1}}<span class="math">, computed efficiently using the public key, which contradicts the </span>q$-strong DH assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The case of non-membership witnesses is very similar. Indeed, suppose that there exists PPT algorithm <span class="math">B</span> that with non-negligible probability outputs a fake non-membership witness <span class="math">\\hat{w}_{y}=(w_{y},u_{y})</span>, <span class="math">u_{y}\\neq 0</span>, for <span class="math">y\\in X</span> with respect to <span class="math">A_{\\kappa}(X)</span>. Then, <span class="math">w_{y}^{y+\\kappa}=g^{f_{X}(\\kappa)+u_{y}}</span>. Since <span class="math">y\\in X</span>, $(y+\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{X}(\\kappa)<span class="math">, so </span>(y+\\kappa)\\nmid[f_{X}(\\kappa)+u_{y}]<span class="math"> for any </span>u_{y}\\neq 0<span class="math">. Thus, as before, using polynomial division and given </span>u_{y},X,y<span class="math">, one can express </span>f_{X}(\\kappa)+u_{y}<span class="math"> as </span>c+q(\\kappa)\\cdot(y+\\kappa)<span class="math"> for some non zero </span>c<span class="math"> and some polynomial </span>q(\\kappa)<span class="math">. This again allows the efficient computation of </span>g^{\\frac{1}{x+\\kappa}}<span class="math">, contradicting the </span>q$-strong DH assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that both reduction arguments can be extended to the case where fake witnesses are defined with respect to the verification tests of Equations 2 and 4. In this case, knowledge of fake witnesses satisfying equations <span class="math">e(w_{x},g)^{x+\\kappa}=e(g,g)^{f_{X}(\\kappa)}</span> and <span class="math">e(w_{y},g)^{y+\\kappa}=e(g,g)^{f_{X}(\\kappa)+u_{y}}</span>, implies knowledge of <span class="math">w_{x}</span> and <span class="math">(w_{y},u_{y})</span> that correspondingly satisfy <span class="math">w_{x}^{x+\\kappa}=g^{f_{X}(\\kappa)}</span> and <span class="math">w_{y}^{y+\\kappa}=g^{f_{X}(\\kappa)+u_{y}}</span>. <span class="math">\\Box</span></p>

    <p class="text-gray-300">Therefore, we have a new secure non-membership verification test for the accumulation function <span class="math">A_{\\kappa}(\\cdot)</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1 (Non-membership witnesses.)</h6>

    <p class="text-gray-300">Under the <span class="math">q</span>-Strong Diffie-Hellman assumption, for any non-member of set <span class="math">X</span> there exists a unique non-membership witness with respect to the accumulation value <span class="math">A_{\\kappa}(X)</span> and a corresponding efficient and secure non-membership verification test.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Conclusion</h2>

    <p class="text-gray-300">In this short note, we extend the accumulator scheme that is based on bilinear pairings, which was introduced by Nguyen in <em>[8]</em>, to also support non-membership witnesses and corresponding cryptographic proofs of non-membership in a given set. That is, given the (authentic) accumulation value of a set <span class="math">X</span>, the public key, and a corresponding short (of size that is independent of the size of <span class="math">X</span>) non-membership witness, a verifier</p>

    <p class="text-gray-300">an efficiently (in time independent of the size of <span class="math">X</span>) verify that a given element <span class="math">y</span> is not a member of <span class="math">X</span>, i.e., <span class="math">y\\notin X</span>. The security of this new non-membership verification test is proved using the <span class="math">q</span>-strong Diffie-Hellman assumption on general groups, the exact cryptographic assumption the original scheme <em>[8]</em> by Nguyen is based on. Similar to the non-membership extension of the RSA accumulator (see, e.g., <em>[2, 3, 5]</em>) that was proposed by Li et al. in <em>[7]</em>, this non-membership extension enriches the functionality of the bilinear-map accumulator <em>[8]</em> and widens its usability in real-life security applications.</p>

    <h2 id="sec-9" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Melissa Chase for useful discussions related to the topic of this short paper.</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. H. Au, Q. Wu, W. Susilo, and Y. Mu. Compact e-cash from bounded accumulator. In Proceedings of CT-RSA ’07, pages 178–195, 2007.</li>

      <li>[2] N. Barić and B. Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In Proceeding of EUROCRYPT ’97, pages 480–494, 1997.</li>

      <li>[3] J. Benaloh and M. de Mare. One-way accumulators: A decentralized alternative to digital signatures. In Proceeding of EUROCRYPT ’93, pages 274–285, 1994.</li>

      <li>[4] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In Proceedings of Crypto ’04, pages 41–55, 2004.</li>

      <li>[5] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In Proceedings of CRYPTO ’02, pages 61–76, 2002.</li>

      <li>[6] M. T. Goodrich, R. Tamassia, and J. Hasic. An efficient dynamic and distributed cryptographic accumulator. In Proceeding of Information Security Conference (ISC), pages 372–388, 2002.</li>

      <li>[7] J. Li, N. Li, , and R. Xue. Universal accumulators with efficient non-membership proofs. In Proceedings of Conference on Applied Cryptography and Network Security (ACNS), pages 253–269, 2007.</li>

      <li>[8] L. Nguyen. Accumulators from bilinear pairings and applications. In Proceedings of CT-RSA ’05, pages 275–292, 2005.</li>

      <li>[9] C. Papamanthou, R. Tamassia, and N. Triandopoulos. Authenticated hash tables. In Proceedings of ACM Conference on Computer and Communications Security (CCS), pages 437–448, October 2008.</li>

      <li>[10] T. Sander. Efficient accumulators without trapdoor extended abstracts. In Proceedings of International Conference on Information and Communication Security, pages 252–262, 1999.</li>

      <li>[11] G. Tsudik and S. Xu. Accumulating composites and improved group signing. In Proceedings of ASIACRYPT ’03, pages 269–286, 2003.</li>

      <li>[12] P. Wang, H. Wang, and J. Pieprzyk. A new dynamic accumulator for batch updates. In Proceedings of ICICS ’07, pages 98–112, 2007.</li>

    </ul>

    <p class="text-gray-300">-</p>`;
---

<BaseLayout title="Supporting Non-membership Proofs with Bilinear-map  Accumula... (2008/538)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/538
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
