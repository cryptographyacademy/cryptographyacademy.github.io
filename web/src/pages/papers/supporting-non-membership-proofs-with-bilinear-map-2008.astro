---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/538';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Supporting Non-membership Proofs with Bilinear-map  Accumulators';
const AUTHORS_HTML = 'Ivan Damg&aring;rd, Nikos Triandopoulos';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In this short note, we present an extension of Nguyen&#x27;s bilinear-map
based accumulator scheme to support
\\emph{non-membership witnesses} and corresponding
\\emph{non-membership proofs}, i.e., cryptographic proofs that an
element has not been accumulated to a given set. This complements
the non-membership proofs developed by Li \\emph{et
al.} for the RSA
accumulator, making the
functionality of the bilinear-map accumulator equivalent to that of
the RSA accumulator. Our non-membership extension of Nguyen&#x27;s
scheme makes use of the $q$-Strong Diffie-Hellman
assumption the security of the original scheme is based on.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> accumulators &middot; non-membership proofs</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Non-Membership Verification for Bilinear-map Accumulators</h2>

    <p class="text-gray-300">We first present some necessary preliminaries related to the underlying computational hardness assumption our non-membership extension (and also the original scheme by Nguyen [8]) is based on. We then build on Nguyen's original accumulator scheme to define the new non-membership witnesses, describe their corresponding verification test and finally prove their security.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The q-strong Diffie-Hellman Assumption</h3>

    <p class="text-gray-300">We first present the q-strong DH assumption [4] over general groups, which has been used in many contexts.</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (q-Strong Diffie-Hellman Assumption.) Let  <span class="math">G = \\langle g \\rangle</span>  be a cyclic group of prime order p and  <span class="math">\\kappa \\in \\mathbb{Z}_p^*</span> . Under the q-strong Diffie-Hellman assumption, any probabilistic polynomial-time algorithm A that is given set  <span class="math">\\{g^{\\kappa^i}: 0 \\leq i \\leq q\\}</span> , finds a pair  <span class="math">(x, g^{\\frac{1}{x+\\kappa}}) \\in \\mathbb{Z}_p^* \\times G</span>  with at most O(1/p) probability, where the probability is over the random choice of  <span class="math">\\kappa \\in \\mathbb{Z}_p^*</span>  and the random bits chosen by A.</p>

    <p class="text-gray-300">In the sequel, whenever operating on group elements in G of prime order p, we always make use of the fact that  <span class="math">g^x = g^{x \\mod p}</span> ,  <span class="math">x \\in \\mathbb{Z}</span> ; i.e., all operations in the exponent can be reduced modulo the group order p.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Accumulators Based on Bilinear Maps</h3>

    <p class="text-gray-300">We now present Nguyen's scheme and appropriately extend it to support non-membership proofs.</p>

    <p class="text-gray-300">Given the security parameter  <span class="math">\\lambda</span> , let G be a multiplicative cyclic group of prime order p that is generated by g, where p grows exponentially with  <span class="math">\\lambda</span> .<sup>1</sup> Additionally, group G is chosen such that it supports a (non-degenerate) bilinear pairing to a target cyclic group  <span class="math">G_T</span>  of prime order p. That is, if G is generated by element g, then there exists a bilinear, non-trivial, map  <span class="math">e: G \\times G \\to G_T</span>  from pairs of elements in G to elements of target group  <span class="math">G_T</span> , such that for any two integers a, b it holds that  <span class="math">e(g^a, g^b) = e(g, g)^{ab}</span>  and where, additionally, element  <span class="math">e(g, g) \\in G_T</span>  generates  <span class="math">G_T</span> .</p>

    <p class="text-gray-300">Let  <span class="math">A_{\\kappa}: 2^{\\mathbb{Z}_p^*} \\to G</span>  be an accumulation function that is parameterized by  <span class="math">\\kappa \\in \\mathbb{Z}_p^*</span>  and maps sets X of integers in  <span class="math">\\mathbb{Z}_p^*</span>  to elements in G according to the mapping</p>

    <p class="text-gray-300"><span class="math">$A_{\\kappa}(X) = g^{\\prod_{x \\in X} (x + \\kappa)}</span>$
.</p>

    <p class="text-gray-300">This has been the accumulation function used by Nguyen in [8] to construct the first accumulator scheme that is not based on the RSA exponentiation function. In Nguyen's construction,  <span class="math">\\kappa</span>  is the trapdoor information and set  <span class="math">\\{g^{\\kappa^i}|0 \\le i \\le q\\}</span>  is the public key, q in an upper bound on |X| = n that grows polynomially with</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>The security parameter can be equal to the bit-length of either a group element or an exponent in the group (integers modulo p).</p>

    <p class="text-gray-300">the security parameter &lambda; = O(log p). Seen as a polynomial on &kappa; of degree |X| = n, let fX(&kappa;) denote the product in the exponent of A&kappa;(X), that is,</p>

    <p class="text-gray-300"><span class="math">$f_X(\\kappa) \\triangleq \\prod_{x \\in X} (x + \\kappa) .</span>$</p>

    <p class="text-gray-300">As in [8], for any x &isin; X, we define the <em>membership witness</em> w<sup>x</sup> &isin; G of x with respect to accumulation value A&kappa;(X) to be the value w<sup>x</sup> satisfying the <em>membership verification test</em></p>

    <p class="text-gray-300"><span class="math">$w_x^{(x+\\kappa)} = A_\\kappa(X) , \\qquad (1)</span>$</p>

    <p class="text-gray-300">which, using the bilinear map e(&middot;, &middot;) and the publicly known group element h = g &kappa; , is realized in practice as</p>

    <p class="text-gray-300"><span class="math">$e(w_x, g^x \\cdot h) = e(A_\\kappa(X), g) . (2)</span>$</p>

    <p class="text-gray-300">That is, any member x of set X has a <em>unique</em> corresponding membership witness w<sup>x</sup> , g fX(&kappa;) <sup>x</sup>+<sup>&kappa;</sup> = g qX,x(&kappa;) (since (x + &kappa;)|fX(&kappa;)), for some polynomial qX,x(&kappa;) of degree n &minus; 1 that is uniquely defined by set X &minus; x.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8"><strong>2.3 Non-membership Verification for Accumulators Based on Bilinear Maps</strong></h3>

    <p class="text-gray-300">Inspired by the non-membership test proposed by Li <em>et al.</em> in [7] for the RSA accumulator, we introduce <em>nonmembership witnesses</em> for the accumulation function A&kappa;(&middot;). For any y /&isin; X, the <em>non-membership witness</em> w&circ;<sup>y</sup> of y with respect to A&kappa;(X) is a pair of values (wy, uy) &isin; G&times;Z &lowast; p , subject to the requirements (i) u<sup>y</sup> 6= 0 and (ii) (y + &kappa;)|[fX(&kappa;) + uy], additionally satisfying the <em>non-membership verification test</em></p>

    <p class="text-gray-300"><span class="math">$w_y^{(y+\\kappa)} = A_\\kappa(X) \\cdot g^{u_y} , \\qquad (3)</span>$</p>

    <p class="text-gray-300">which, using the bilinear map e(&middot;, &middot;) and the publicly known group element h = g &kappa; , is realized in practice as</p>

    <p class="text-gray-300"><span class="math">$e(w_y, g^y \\cdot h) = e(A_\\kappa(X) \\cdot g^{u_y}, g) . \\tag{4}</span>$</p>

    <p class="text-gray-300">In particular, any non-member y of set X has a <em>unique</em> corresponding non-membership witness w&circ;<sup>y</sup> = (wy, uy), by setting</p>

    <p class="text-gray-300"><span class="math">$u_y \\triangleq -f_X(-y) \\mod p = -\\prod_{x \\in X} (x - y) \\mod p</span>$
, (5)</p>

    <p class="text-gray-300">and then accordingly setting</p>

    <p class="text-gray-300"><span class="math">$w_y = g^{\\frac{f_X(\\kappa) - f_X(-y)}{y + \\kappa}} = g^{\\hat{q}_X(\\kappa)}, \\qquad (6)</span>$</p>

    <p class="text-gray-300">for some polynomial q&circ;X(&kappa;) of degree n &minus; 1 that is uniquely defined by set X. Note that, since y /&isin; X, it holds that u<sup>y</sup> 6= 0. Also note that, if hX(&kappa;) = fX(&kappa;) &minus; fX(&minus;y), then hX(&minus;y) = 0, thus it holds that (y + &kappa;)|hX(&kappa;) (thus, justifying the last part of Equation 6) and, in fact, that (y + &kappa;)|[fX(&kappa;) + uy]. Thus, in addition to Equations 3 and 4, the pair of values (wy, uy) defined above satisfies the required conditions u<sup>y</sup> 6= 0 and (y + &kappa;)|[fX(&kappa;) + uy]. We require that the verification process immediately rejects if u<sup>y</sup> = 0.</p>

    <p class="text-gray-300">Also, observe that the non-membership witness for y /&isin; X can be computed efficiently (in polynomial in |X| time), using only set X and the public key, by evaluating polynomial &minus;fX(&kappa;) on &minus;y and then computing the group element w<sup>y</sup> through Equation 6.</p>

    <p class="text-gray-300">We say that a membership, respectively non-membership, witness  <span class="math">w_x</span> , respectively  <span class="math">\\hat{w}_y = (w_y, u_y)</span> , is fake if  <span class="math">x \\notin X</span> , respectively  <span class="math">y \\in X</span> , and, still, the corresponding membership, respectively non-membership, verification test (in particular, expressed through Equations 1 and 3 respectively) is satisfied.</p>

    <p class="text-gray-300">The security of non-membership test relies on the following: if y is in X then  <span class="math">y+\\kappa</span>  divides polynomial  <span class="math">f_X(\\kappa)</span> , and therefore  <span class="math">y+\\kappa</span>  cannot divide polynomial  <span class="math">f_X(\\kappa)+u_y</span>  for any choice of  <span class="math">u_y\\neq 0</span> . (Recall that the verifier first checks whether  <span class="math">u_y\\neq 0</span> , according to the definition of non-membership witnesses.) Based on the fact that  <span class="math">(y+\\kappa)\\nmid [f_X(\\kappa)+u_y]</span> , one can easily reduce any fake non-membership witness to an attack to the q-Strong DH assumption, using a simple polynomial division and the public key. For completeness we present the security proof for both membership and non-membership witnesses.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> Under the q-Strong Diffie-Hellman assumption, any PPT algorithm B, given any set X,  <span class="math">|X| \\le q</span>  and set  <span class="math">\\{g^{\\kappa^i} | 0 \\le i \\le q\\}</span> , finds a fake non-membership witness of a member of X or a fake membership witness of a non-member of X with respect to  <span class="math">A_{\\kappa}(X)</span>  with probability at most O(1/p), measured over the random choice of  <span class="math">\\kappa \\in \\mathbb{Z}_p^*</span>  and random bits of B.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Consider the case of membership witnesses first. Suppose that there exists PPT algorithm B that with non-negligible probability outputs a fake membership witness  <span class="math">w_x</span>  for  <span class="math">x \\notin X</span>  with respect to  <span class="math">A_{\\kappa}(X)</span> . Then,  <span class="math">w_x^{x+\\kappa} = A_{\\kappa}(X) = g^{f_X(\\kappa)}</span> , where  <span class="math">f_X(\\kappa) = \\sum_{i=0}^{|X|} c_i \\cdot \\kappa^i</span> , with  <span class="math">c_i</span>  being a known coefficient that depends on the elements of X,  <span class="math">0 \\le i \\le |X|</span> . Since  <span class="math">x \\notin X</span> , it is  <span class="math">(x+\\kappa) \\nmid f_X(\\kappa)</span> . Thus, using polynomial division and given X, x, one can compute a non zero integer c and a polynomial  <span class="math">q(\\kappa)</span>  of degree |X|-1 such that  <span class="math">f_X(\\kappa) = c + q(\\kappa) \\cdot (x+\\kappa)</span> . Therefore,  <span class="math">w_x = g^{q(\\kappa)} \\cdot g^{\\frac{c}{x+\\kappa}}</span>  and  <span class="math">g^{\\frac{1}{x+\\kappa}} = [w_x \\cdot [g^{q(\\kappa)}]^{-1}]^{c^{-1}}</span> , computed efficiently using the public key, which contradicts the g-strong DH assumption.</p>

    <p class="text-gray-300">The case of non-membership witnesses is very similar. Indeed, suppose that there exists PPT algorithm B that with non-negligible probability outputs a fake non-membership witness  <span class="math">\\hat{w}_y = (w_y, u_y), u_y \\neq 0</span> , for  <span class="math">y \\in X</span>  with respect to  <span class="math">A_{\\kappa}(X)</span> . Then,  <span class="math">w_y^{y+\\kappa} = g^{f_X(\\kappa)+u_y}</span> . Since  <span class="math">y \\in X</span> ,  <span class="math">(y+\\kappa)|f_X(\\kappa)</span> , so  <span class="math">(y+\\kappa) \\nmid [f_X(\\kappa)+u_y]</span>  for any  <span class="math">u_y \\neq 0</span> . Thus, as before, using polynomial division and given  <span class="math">u_y, X, y</span> , one can express  <span class="math">f_X(\\kappa) + u_y</span>  as  <span class="math">c + q(\\kappa) \\cdot (y + \\kappa)</span>  for some non zero c and some polynomial  <span class="math">q(\\kappa)</span> . This again allows the efficient computation of  <span class="math">g^{\\frac{1}{y+\\kappa}}</span> , contradicting the q-strong DH assumption.</p>

    <p class="text-gray-300">Note that both reduction arguments can be extended to the case where fake witnesses are defined with respect to the verification tests of Equations 2 and 4. In this case, knowledge of fake witnesses satisfying equations  <span class="math">e(w_x,g)^{x+\\kappa}=e(g,g)^{f_X(\\kappa)}</span>  and  <span class="math">e(w_y,g)^{y+\\kappa}=e(g,g)^{f_X(\\kappa)+u_y}</span> , implies knowledge of  <span class="math">w_x</span>  and  <span class="math">(w_y,u_y)</span>  that correspondingly satisfy  <span class="math">w_x^{x+\\kappa}=g^{f_X(\\kappa)}</span>  and  <span class="math">w_y^{y+\\kappa}=g^{f_X(\\kappa)+u_y}</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300">Therefore, we have a new secure non-membership verification test for the accumulation function  <span class="math">A_{\\kappa}(\\cdot)</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1 (Non-membership witnesses.)</strong> Under the q-Strong Diffie-Hellman assumption, for any non-member of set X there exists a unique non-membership witness with respect to the accumulation value  <span class="math">A_{\\kappa}(X)</span>  and a corresponding efficient and secure non-membership verification test.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Conclusion</h2>

    <p class="text-gray-300">In this short note, we extend the accumulator scheme that is based on bilinear pairings, which was introduced by Nguyen in [8], to also support non-membership witnesses and corresponding cryptographic proofs of non-membership in a given set. That is, given the (authentic) accumulation value of a set X, the public key, and a corresponding short (of size that is independent of the size of X) non-membership witness, a verifier</p>

    <p class="text-gray-300">can efficiently (in time independent of the size of X) verify that a given element y is not a member of X, i.e., y /&isin; X. The security of this new non-membership verification test is proved using the q-strong Diffie-Hellman assumption on general groups, the exact cryptographic assumption the original scheme [8] by Nguyen is based on. Similar to the non-membership extension of the RSA accumulator (see, e.g., [2, 3, 5]) that was proposed by Li <em>et al.</em> in [7], this non-membership extension enriches the functionality of the bilinear-map accumulator [8] and widens its usability in real-life security applications.</p>

    <p class="text-gray-300">We thank Melissa Chase for useful discussions related to the topic of this short paper.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] M. H. Au, Q. Wu, W. Susilo, and Y. Mu. Compact e-cash from bounded accumulator. In <em>Proceedings of CT-RSA '07</em>, pages 178&ndash;195, 2007.</li>
      <li>[2] N. Baric and B. Pfitzmann. Collision-free accumulators and fail-stop signature sch &acute; emes without trees. In <em>Proceeding of EUROCRYPT '97</em>, pages 480&ndash;494, 1997.</li>
      <li>[3] J. Benaloh and M. de Mare. One-way accumulators: A decentralized alternative to digital signatures. In <em>Proceeding of EUROCRYPT '93</em>, pages 274&ndash;285, 1994.</li>
      <li>[4] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In <em>Proceedings of Crypto '04</em>, pages 41&ndash;55, 2004.</li>
      <li>[5] J. Camenisch and A. Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In <em>Proceedings of CRYPTO '02</em>, pages 61&ndash;76, 2002.</li>
      <li>[6] M. T. Goodrich, R. Tamassia, and J. Hasic. An efficient dynamic and distributed cryptographic accumulator. In <em>Proceeding of Information Security Conference (ISC)</em>, pages 372&ndash;388, 2002.</li>
      <li>[7] J. Li, N. Li, , and R. Xue. Universal accumulators with efficient non-membership proofs. In <em>Proceedings of Conference on Applied Cryptography and Network Security (ACNS)</em>, pages 253&ndash;269, 2007.</li>
      <li>[8] L. Nguyen. Accumulators from bilinear pairings and applications. In <em>Proceedings of CT-RSA '05</em>, pages 275&ndash;292, 2005.</li>
      <li>[9] C. Papamanthou, R. Tamassia, and N. Triandopoulos. Authenticated hash tables. In <em>Proceedings of ACM Conference on Computer and Communications Security (CCS)</em>, pages 437&ndash;448, October 2008.</li>
      <li>[10] T. Sander. Efficient accumulators without trapdoor extended abstracts. In <em>Proceedings of International Conference on Information and Communication Security</em>, pages 252&ndash;262, 1999.</li>
      <li>[11] G. Tsudik and S. Xu. Accumulating composites and improved group signing. In <em>Proceedings of ASIACRYPT '03</em>, pages 269&ndash;286, 2003.</li>
      <li>[12] P. Wang, H. Wang, and J. Pieprzyk. A new dynamic accumulator for batch updates. In <em>Proceedings of ICICS '07</em>, pages 98&ndash;112, 2007.</li>
    </ul>

    </section>
`;
---

<BaseLayout title="Supporting Non-membership Proofs with Bilinear-map  Accumula... (2008/538)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/538
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="supporting-non-membership-proofs-with-bilinear-map-2008" />
  </article>
</BaseLayout>
