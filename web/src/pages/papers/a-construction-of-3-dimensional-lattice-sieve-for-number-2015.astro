---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1179';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A construction of 3-dimensional lattice sieve for number field sieve over F_{p^n}';
const AUTHORS_HTML = 'Kenichiro Hayasaka, Kazumaro Aoki, Tetsutaro Kobayashi, Tsuyoshi Takagi';

const CONTENT = `    <p class="text-gray-300">A construction of 3-dimensional lattice sieve for number field sieve over <span class="math">\\mathrm{GF}(p^n)^\\star</span></p>

    <p class="text-gray-300">Kenichiro Hayasaka<span class="math">^1</span>, Kazumaro Aoki<span class="math">^2</span>, Tetsutaro Kobayashi<span class="math">^2</span>, and Tsuyoshi Takagi<span class="math">^3</span></p>

    <p class="text-gray-300">Mitsubishi Electric, Japan NTT Secure Platform Laboratories, Japan Kyushu University, Japan</p>

    <p class="text-gray-300">Abstract. The security of pairing-based cryptography is based on the hardness of solving the discrete logarithm problem (DLP) over extension field <span class="math">\\mathrm{GF}(p^n)</span> of characteristic <span class="math">p</span> and degree <span class="math">n</span>. Joux et al. proposed an asymptotically fastest algorithm for solving DLP over <span class="math">\\mathrm{GF}(p^n)</span> (JLSV06-NFS) as the extension of the number field sieve over prime field <span class="math">\\mathrm{GF}(p)</span> (JL03-NFS). The lattice sieve is often used for a large-scaled experiment of solving DLP over <span class="math">\\mathrm{GF}(p)</span> by the number field sieve. Franke and Kleinjung proposed a 2-dimensional lattice sieve which efficiently enumerates all the points in a given sieve region of the lattice. However, we have to consider a sieve region of more than 2 dimensions in the lattice sieve of JLSV06-NFS. In this paper, we extend the Franke-Kleinjung method to 3-dimensional sieve region. We construct an appropriate basis using the Hermite normal form, which can enumerate the points in a given sieve region of the 3-dimensional lattice. From our experiment on <span class="math">\\mathrm{GF}(p^{12})</span> of 303 bits, we are able to enumerate more than <span class="math">90\\%</span> of the points in a sieve region in the lattice generated by special-q. Moreover, we implement the number field sieve using the proposed 3-dimensional lattice sieve. Our implementation of the JLSV06 over <span class="math">\\mathrm{GF}(p^6)</span> of 240 bits is about as efficient as that of the current record over <span class="math">\\mathrm{GF}(p^6)</span> using 3-dimensional line sieve by Zajac.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Let <span class="math">\\mathrm{GF}(p^n)</span> be a finite field of characteristic <span class="math">p</span> and extension degree <span class="math">n</span>. The security of pairing-based cryptography is based on the hardness of the discrete logarithm problem (DLP) over finite field <span class="math">\\mathrm{GF}(p^n)</span>. Recently the complexity of solving the DLP over finite field of small characteristic <span class="math">p</span> has been improved substantially [8, 1]. Thus we are interested in the pairing constructed over finite field of large characteristic in this paper. For example, the optimal ate pairing [21] that uses BN curves [3] and the Tate pairing that uses MNT curves [15] are two efficient classes of computing paring. The security of pairing-based cryptography using these pairings is based on the DLP over finite field <span class="math">\\mathrm{GF}(p^n)</span> of <span class="math">n = 12</span> and <span class="math">n = 6</span>, respectively.</p>

    <p class="text-gray-300">The number field sieve proposed by Joux et al. at CRYPTO '06 (JLSV06-NFS) [10] is the asymptotically fastest algorithm to solve DLP over <span class="math">\\mathrm{GF}(p^n)</span> whose characteristic <span class="math">p</span> is large with respect to extension degree <span class="math">n</span>. JLSV06-NFS is the extension of the number field sieve over a prime field <span class="math">\\mathrm{GF}(p)</span> (JL03-NFS) [9] to an extension field <span class="math">\\mathrm{GF}(p^n)</span>. In order to efficiently implement the number field sieve, we deploy a sieve technique such as the line sieve and the lattice sieve [17]. Recent experiments of JL03-NFS such as [11] show that the lattice sieve is more efficient for a large-scaled implementation to solve the DLP over prime field <span class="math">\\mathrm{GF}(p)</span>.</p>

    <p class="text-gray-300">Franke and Kleinjung proposed an excellent algorithm which can effectively enumerate all the points in a sieve region of 2-dimensional lattice [5, 12]. The Franke-Kleinjung method constructs an appropriate basis <span class="math">(u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}</span> of the 2-dimensional lattice by the</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This work was carried out, when the first author was in the Graduate School of Mathematics, Kyushu University. The preliminary work [7] of this paper was published at the Computer Security Symposium, CSS 2014, held on October 22-24, 2014.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">continued fraction expansion, which satisfies three conditions A1: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math">, A2: </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}-u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math">, A3: </span>u_{1}^{(0)}>0<span class="math"> and </span>u_{1}^{(1)}>0<span class="math">, where </span>I<span class="math"> is a bound of the sieve region. Interestingly, we can exhaustively enumerate all the points of the lattice region in the ascending order of </span>v<span class="math">-coordinate just by repeatedly adding </span>(u_{0}^{(0)},u_{1}^{(0)})<span class="math"> or </span>(u_{0}^{(1)},u_{1}^{(1)})<span class="math">. On the other hand, in the lattice sieve of JLSV06-NFS over extension field GF(</span>p^{n}$), we have to consider the lattice sieve of more than 2 dimensions in general. However, the Franke-Kleinjung method is restricted to the lattice of 2 dimensions due to its construction using the continued fraction expansion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper, we propose an extension of the Franke-Kleinjung method to 3-dimensional case. We classify the basis of a 3-dimensional lattice generated from special-<span class="math">\\mathfrak{q}</span> by Hermite normal form. There are three different classes. The first one is an orthogonal basis, and we simply apply the line sieve in this lattice. The second one contains a two-dimensional orthogonal projection that satisfies the above Conditions A1, A2 and A3, so that we are able to do the Franke-Kleinjung method of 2 dimensions to this lattice. The third one is a non-trivial case. We give the following conditions as a natural extension of the Franke-Kleinjung method. Indeed we constructs a basis <span class="math">\\mathbf{u}^{(0)}=(u_{0}^{(0)},u_{1}^{(0)},u_{2}^{(0)})^{\\mathrm{T}}</span>, <span class="math">\\mathbf{u}^{(1)}=(u_{0}^{(1)},u_{1}^{(1)},u_{2}^{(1)})^{\\mathrm{T}}</span>, <span class="math">\\mathbf{u}^{(2)}=(u_{0}^{(2)},u_{1}^{(2)},u_{2}^{(2)})^{\\mathrm{T}}</span> of the 3-dimensional lattice, which satisfies four conditions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> for </span>a=0,1,2$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u_{2}^{(0)}\\geq 0</span> and <span class="math">u_{2}^{(1)}\\geq 0</span> and <span class="math">u_{2}^{(2)}\\geq 0</span> and <span class="math">u_{2}^{(0)}+u_{2}^{(1)}+u_{2}^{(2)}\\neq 0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_{0}u_{0}^{(0)}+i_{1}u_{0}^{(1)}+i_{2}u_{0}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_{0}u_{1}^{(0)}+i_{1}u_{1}^{(1)}+i_{2}u_{1}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math">, if one of </span>i_{0},i_{1},i_{2}\\in\\mathbb{Z}$ is negative and the others are positive or equal to 0,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">I</span> is a bound of the sieve region. We present an algorithm that generates the basis that satisfies the above conditions assuming such a basis exists. Here we also propose an explicit algorithm that the points in the sieve region can be enumerated in the ascending order of <span class="math">u_{2}</span>-coordinate just by repeatedly adding <span class="math">(u_{0}^{(0)},u_{1}^{(0)},u_{2}^{(0)})</span>, <span class="math">(u_{0}^{(1)},u_{1}^{(1)},u_{2}^{(1)})</span>, or <span class="math">(u_{0}^{(2)},u_{1}^{(2)},u_{2}^{(2)})</span>. Then we prove that all the points of the sieve region can be exhaustively enumerated by the proposed explicit algorithm.</p>

    <p class="text-gray-300">In general the above conditions are not fulfilled in all lattices generated from special-<span class="math">\\mathfrak{q}</span>, namely Condition B4 is not achieved due to some exceptional points in some lattices. Indeed, our experiment on GF(<span class="math">p^{12}</span>) of 303 bits shows that we can generate the basis that satisfies the conditions with a probability of about 74% over 8,000 prime ideals on 10 special-<span class="math">\\mathfrak{q}</span>s. However, our experiment in the same field using the proposed explicit algorithm confirms that we can enumerate more than 90% of points in a sieve region of 3-dimensional lattices generated from the same special-<span class="math">\\mathfrak{q}</span>s, even though the basis does not satisfy the above conditions. From the proposed basis we are able to enumerate almost all the points in a sieve region of 3-dimensional lattice efficiently.</p>

    <p class="text-gray-300">Finally, we compare the running time of our lattice sieve that uses the extension of Franke-Kleinjung method with the current record of GF(<span class="math">p^{6}</span>) of 240 bits by Zajac <em>[22]</em>.</p>

    <p class="text-gray-300">This paper is organized as follows. In Section 2 we give a short overview of the number field sieve. Section 3 describes the line sieve and lattice sieve in multi-dimensions. In Section 4 we explained the lattice sieve proposed by Franke and Kleinjung. In Section 5 we propose an extension of Franke-Kleinjung method to the 3-dimensional lattice. Section 6 presents some data in our experiment on the number field sieve using the proposed lattice sieve. In Section 7 we state the concluding remarks and future works.</p>

    <p class="text-gray-300">In this section, we describe an outline of the number field sieve over an extension field <span class="math">\\mathrm{GF}(p^n)</span> proposed by Joux et al. [10] (JLSV06-NFS) that contains a sieve step implemented with the lattice sieve we focus in this paper.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the polynomial selection step of JLSV06-NFS, we choose two irreducible polynomials <span class="math">f_{1}, f_{2} \\in \\mathbb{Z}[X]</span> s.t. <span class="math">f_{1} \\neq f_{2}</span>, <span class="math">\\deg f_{1} = n</span>, <span class="math">f_{1}</span> are irreducible in <span class="math">\\mathrm{GF}(p)</span> and $f_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{2}<span class="math"> (mod </span>p<span class="math">). Such a polynomial </span>f_{2}<span class="math"> can be generated by adding </span>p<span class="math"> to </span>f_{1}<span class="math">. Then there exists a common root </span>v<span class="math"> of </span>f_{1}(X) = 0<span class="math"> and </span>f_{2}(X) = 0<span class="math"> in </span>\\mathrm{GF}(p^n)<span class="math">. Denote by </span>\\alpha_{1}, \\alpha_{2} \\in \\mathbb{C}<span class="math"> a root of </span>f_{1}(X) = 0<span class="math"> and </span>f_{2}(X) = 0<span class="math">, respectively. We also denote by </span>\\mathcal{O}_1<span class="math"> and </span>\\mathcal{O}_2<span class="math"> the ring of integers of the number fields </span>\\mathbb{Q}(\\alpha_1)<span class="math"> and </span>\\mathbb{Q}(\\alpha_2)<span class="math">, respectively. For the orders </span>\\mathbb{Z}[\\alpha_1] \\subseteq \\mathcal{O}_1<span class="math"> and </span>\\mathbb{Z}[\\alpha_2] \\subseteq \\mathcal{O}_2<span class="math">, there are homomorphism maps </span>\\phi_i: \\mathbb{Z}[\\alpha_i] \\to \\mathrm{GF}(p^n)<span class="math">, </span>\\alpha_i \\mapsto v<span class="math"> (</span>i = 1, 2$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the sieve step, we try to find many relations arisen from both <span class="math">\\mathcal{O}_1</span> and <span class="math">\\mathcal{O}_2</span>. In the beginning of this step, we choose the smoothness bound <span class="math">B_1, B_2 \\in \\mathbb{R}_{&amp;gt;0}</span> and an integer <span class="math">t \\geq 1</span>. For the above polynomials <span class="math">f_1, f_2</span> and a column vector <span class="math">\\mathbf{a} = (a_0, a_1, \\ldots, a_t)^{\\mathrm{T}} \\in \\mathbb{Z}^{t+1}</span>, we define the norm of <span class="math">\\mathbf{a}</span> for <span class="math">f_i</span> as $N_i(\\mathbf{a}) = N_i\\left(\\sum_{j=0}^t a_j \\alpha_i^j\\right) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}(\\sum_{j=0}^t a_j X^j, f_i(X))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\operatorname{Res}(f, g)<span class="math"> denotes the resultant of two polynomials </span>f<span class="math"> and </span>g \\in \\mathbb{Z}[X]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let the factor bases <span class="math">\\mathcal{B}_1, \\mathcal{B}_2</span> be</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {B} _ {i} = \\left\\{(q, g) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l l} q: &amp; \\mathrm {p r i m e}, q \\leq B _ {i}, \\\\ g: &amp; \\mathrm {i r r e d u c i b l e m o n i c p o l y n o m i a l i n G F} (q) [ X ], \\\\ &amp; g \\mid f _ {i} \\bmod q, \\deg g \\leq t \\end{array} \\right. \\right\\} (i = 1, 2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We call a hit tuple <span class="math">\\mathbf{a} = (a_0, a_1, \\ldots, a_t)^{\\mathrm{T}} \\in \\mathbb{Z}^{t+1}</span> if <span class="math">\\mathbf{a}</span> satisfies following conditions: <span class="math">N_1(\\mathbf{a})</span> is <span class="math">B_1</span>-smooth, <span class="math">N_2(\\mathbf{a})</span> is <span class="math">B_2</span>-smooth and <span class="math">\\sum_{j=0}^t a_j X^j</span> is irreducible in <span class="math">\\mathbb{Z}[X]</span>. A hit tuple <span class="math">\\mathbf{a}</span> has a property <span class="math">(\\sum_{j=0}^t a_j \\alpha_i^j) \\mathcal{O}_i = \\prod_{\\mathfrak{q}_{i,j} \\in \\mathcal{B}_i} \\mathfrak{q}_{i,j}^{\\varepsilon_{i,j}}</span> for <span class="math">i = 1</span> and 2, where <span class="math">\\varepsilon_{i,j}</span> is the exponent that we can compute from the prime decomposition of <span class="math">N_i(\\mathbf{a}) = \\prod_{q: \\text{prime}, q \\leq B_i} q^{c_q}</span> for <span class="math">q \\nmid [\\mathcal{O}_i : \\mathbb{Z}[\\alpha_i]]</span>.</p>

    <p class="text-gray-300">From homomorphism maps <span class="math">\\phi_1, \\phi_2</span> and a hit tuple <span class="math">\\mathbf{a}</span>, we obtain the following relation of the discrete logarithm</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {\\mathfrak {q} _ {1, j} \\in \\mathcal {B} _ {1}} \\varepsilon_ {i, j} \\log \\phi_ {1} (\\mathfrak {q} _ {1, j}) + \\sum_ {j = 1} ^ {r _ {1}} \\lambda_ {i, j} \\log \\Lambda_ {1, j} \\equiv \\\\ \\sum_ {\\mathfrak {q} _ {2, j} \\in \\mathcal {B} _ {2}} \\varepsilon_ {i, j} \\log \\phi_ {2} (\\mathfrak {q} _ {2, j}) + \\sum_ {j = 1} ^ {r _ {2}} \\lambda_ {i, j} \\log \\Lambda_ {2, j} \\pmod {p ^ {n} - 1}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\log \\phi_i(\\mathfrak{q}_{i,j})</span> and <span class="math">\\log \\varLambda_{i,j}</span> are called the virtual logarithms [9, 20], <span class="math">\\lambda_{i,j}</span> is the character map proposed by Schirokauer [19] and <span class="math">r_i</span> is the torsion-free rank of <span class="math">\\mathcal{O}_i</span> for <span class="math">i = 1,2</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}_a\\subset \\mathbb{Z}^{t + 1}</span> be the <span class="math">(t + 1)</span>-dimensional sieve region. In the sieve step, we find more than <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n</span> hit tuples <span class="math">\\mathbf{a}</span> in <span class="math">\\mathcal{H}_a</span>.</p>

    <p class="text-gray-300">Finally, in the linear algebra step, we compute <span class="math">\\log \\phi_i(\\mathfrak{q}_{i,j})</span>, <span class="math">\\log \\varLambda_{i,j}</span> (mod <span class="math">p^n - 1</span>) by solving the linear system consists of the relations.</p>

    <p class="text-gray-300">In the following we describe how to find relations of JLSV06-NFS using the line sieve and the lattice sieve in multi-dimensions discussed by Zajac in [23, 6].</p>

    <p class="text-gray-300">3.1 Line sieve in multi-dimensions</p>

    <p class="text-gray-300">In the sieve method, we search hit tuples <span class="math">\\mathbf{a} = (a_0, a_1, \\ldots, a_t)^{\\mathrm{T}}</span> whose norm <span class="math">N_i(\\mathbf{a})</span> is divisible by <span class="math">q^{\\deg g}</span> for all <span class="math">\\mathfrak{q} = (q, g) \\in \\mathcal{B}_i</span>. Note that we have relationship</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g(X) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{j=0}^{t} a_j X^j \\bmod q \\Rightarrow q^{\\deg g} \\mid N_i(\\mathbf{a}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\tag{1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In the following we describe how to find the polynomials that satisfies the sufficient condition in (1), namely polynomials <span class="math">\\sum_{j=0}^{t} a_j X^j</span> divisible by <span class="math">g(X) \\bmod q</span>.</p>

    <p class="text-gray-300">Let <span class="math">I_d</span> be an identity matrix of size <span class="math">d \\times d</span>. The set of all polynomials <span class="math">\\sum_{j=0}^{t} a_j X^j</span> in <span class="math">\\mathbb{Z}[X]</span> of degree less than or equal to <span class="math">t</span> that is divisible by <span class="math">g(X) \\bmod q</span> is generated by the integer linear combination of the columns of the following matrix of size <span class="math">(t + 1) \\times (t + 1)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c} &amp;amp; g_0 &amp;amp; &amp;amp; 0 \\\\ q I_{\\deg g} &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; g_0 \\\\ &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\hline &amp;amp; g_{\\deg g} &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 0 &amp;amp; &amp;amp; \\ddots &amp;amp; \\vdots \\\\ &amp;amp; 0 &amp;amp; &amp;amp; g_{\\deg g} \\end{array} \\right), \\tag{2}</span></div>

    <p class="text-gray-300">where <span class="math">g_0, \\ldots, g_{\\deg g}</span> are the coefficient of the polynomial <span class="math">g(X) = \\sum_{j=0}^{\\deg g} g_j X^j</span>, respectively. Denote by <span class="math">M_{\\mathfrak{q}}</span> the Hermite normal form of this matrix, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">M_{\\mathfrak{q}} = \\left(\\frac{q I_{\\deg g}}{0} \\mid \\frac{T_{\\mathfrak{q}}}{I_{t - \\deg g + 1}}\\right), \\tag{3}</span></div>

    <p class="text-gray-300">where <span class="math">T_{\\mathfrak{q}}</span> is an integer matrix whose size is <span class="math">\\deg g \\times (t - \\deg g + 1)</span>. Therefore we obtain the relationship</p>

    <div class="my-4 text-center"><span class="math-block">(a_0, a_1, \\ldots, a_{\\deg g - 1})^{\\mathrm{T}} \\equiv T_{\\mathfrak{q}} \\left(a_{\\deg g}, a_{\\deg g + 2}, \\ldots, a_{t + 1}\\right)^{\\mathrm{T}} \\bmod q</span></div>

    <p class="text-gray-300">for polynomial <span class="math">\\sum_{j=0}^{t} a_j X^j</span> divisible by <span class="math">g(X) \\bmod q</span>. We namely can find the hit tuple <span class="math">\\mathbf{a} = (a_0, a_1, \\ldots, a_t)^{\\mathrm{T}}</span> by repeatedly adding <span class="math">q</span> to each entry of vector <span class="math">(a_0, a_1, \\ldots, a_{\\deg g - 1})^{\\mathrm{T}}</span>.</p>

    <p class="text-gray-300">3.2 Lattice sieve in multi-dimensions</p>

    <p class="text-gray-300">The lattice sieve tries to find a candidate of hit tuples in the lattice whose points are divisible by <span class="math">\\mathfrak{q} \\in \\mathcal{B}_i</span> (<span class="math">i = 1, 2</span>) (called special- <span class="math">\\mathfrak{q}</span>).</p>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{r} = (r, h) \\in \\mathcal{B}_i</span> (<span class="math">i = 1, 2</span>) be a different element from <span class="math">\\mathfrak{q}</span>, and we define <span class="math">M_{\\mathfrak{r}}</span> and <span class="math">T_{\\mathfrak{r}}</span> be the matrix generated by the same method of Equation (3), where <span class="math">M_{\\mathfrak{r}}</span> and <span class="math">T_{\\mathfrak{r}}</span> are integer matrices whose sizes are <span class="math">(t + 1) \\times (t + 1)</span> and <span class="math">\\deg h \\times (t - \\deg h + 1)</span>, respectively. Then we have the relationship <span class="math">(a_0, a_1, \\ldots, a_{\\deg h - 1})^{\\mathrm{T}} \\equiv T_{\\mathfrak{r}} \\left(a_{\\deg h}, a_{\\deg h + 2}, \\ldots, a_{t + 1}\\right)^{\\mathrm{T}} \\bmod r</span> for polynomial <span class="math">\\sum_{j=0}^{t} a_j X^j</span> divisible by <span class="math">h(X) \\bmod r</span>.</p>

    <p class="text-gray-300">Next, let <span class="math">M_{\\mathfrak{q}}^{\\mathrm{LLL}}</span> be the matrix generated by LLL reduction algorithm [14] from <span class="math">M_{\\mathfrak{q}}</span> of Equation (3). We decompose the <span class="math">(t + 1) \\times (t + 1)</span> matrix <span class="math">M_{\\mathfrak{q}}^{\\mathrm{LLL}}</span> into the <span class="math">\\deg h \\times (t + 1)</span> matrix <span class="math">M_{\\mathfrak{q},1}^{\\mathrm{LLL}}</span> and the <span class="math">(t - \\deg h + 1) \\times (t + 1)</span> matrix <span class="math">M_{\\mathfrak{q},2}^{\\mathrm{LLL}}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M_{\\mathfrak{q}}^{\\mathrm{LLL}} = \\left(\\frac{M_{\\mathfrak{q},1}^{\\mathrm{LLL}}}{M_{\\mathfrak{q},2}^{\\mathrm{LLL}}}\\right). \\tag{4}</span></div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. An example of an enumeration of lattice points with the generated basis  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span>  by the Franke-Kleinjung method on 2 dimensions</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">Then the solution  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^{t+1}</span>  of  <span class="math">(M_{\\mathfrak{q},1}^{\\mathrm{LLL}} - T_{\\mathfrak{r}} M_{\\mathfrak{q},2}^{\\mathrm{LLL}})\\mathbf{x} \\equiv 0 \\pmod{r}</span>  becomes a hit tuple in the lattice whose points divisible by  <span class="math">\\mathfrak{q}</span> . We denote by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  the matrix whose columns are the basis of kernel of the linear map  <span class="math">(M_{\\mathfrak{q},1}^{\\mathrm{LLL}} - T_{\\mathfrak{r}} M_{\\mathfrak{q},2}^{\\mathrm{LLL}}) \\pmod{r}</span> , then  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  becomes a matrix of size  <span class="math">(t+1) \\times (t+1)</span> . The basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  can be generated by the algorithm proposed by Hayasaka et al. [6].</p>

    <p class="text-gray-300">In the lattice sieve we run the points on lattice  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  in the sieve region  <span class="math">\\mathcal{H}_c \\subset \\mathbb{Z}^{t+1}</span>  (c-space):</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {c} = \\left\\{\\left(c _ {0}, c _ {1}, \\dots , c _ {t}\\right) ^ {\\mathrm {T}} \\in \\mathbb {Z} ^ {t + 1} \\mid - I / 2 \\leq c _ {i} &amp;lt;   I / 2 (i = 0, 1, \\dots , t - 1), 0 \\leq c _ {t} &amp;lt;   J \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">I, J \\in \\mathbb{Z}_{&amp;gt;0}</span>  and  <span class="math">I</span>  is even.  <span class="math">I, J</span>  are called the bound of sieve region. One of the main operations in the lattice sieve is to enumerate the points in the sieve region  <span class="math">\\mathcal{H}_c</span>  of lattice  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span> .</p>

    <p class="text-gray-300">In this section, we explain how to efficiently enumerate the points in the two-dimensional lattice proposed by Franke and Kleinjung [5].</p>

    <p class="text-gray-300">Let  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  be the two-dimensional lattice generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^2</span>  defined in Section 3.2 for the case of 2 dimension i.e.  <span class="math">t = 1</span> . Let  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}</span>  be the basis of  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span> . Let  <span class="math">\\mathcal{H}_c^2</span>  be the sieve region such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {c} ^ {2} = \\left\\{\\left(c _ {0}, c _ {1}\\right) ^ {\\mathrm {T}} \\in \\mathbb {Z} ^ {2} \\mid - I / 2 \\leq c _ {0} &amp;lt;   I / 2, 0 \\leq c _ {1} &amp;lt;   J \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">I,J\\in \\mathbb{Z}_{&amp;gt;0}</span>  and  <span class="math">I</span>  is even.</p>

    <p class="text-gray-300">The Franke-Kleinjung method enumerates the points in sieve region  <span class="math">\\mathcal{H}_c^2</span>  by a special basis  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span>  of lattice  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span> , which has the following good properties (See Figure 1 for an example:  <span class="math">\\mathbf{u}^{(1)} = (27,1)^{\\mathrm{T}}</span>  and  <span class="math">\\mathbf{u}^{(0)} = (-47,2)^{\\mathrm{T}}</span>  with  <span class="math">I = 64</span> ). (1) We can exhaustively compute all the points in  <span class="math">\\mathcal{H}_c^2\\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  by adding vector  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(0)} + \\mathbf{u}^{(1)}</span>  recursively. (2) The second coordinate of the points in sieve region  <span class="math">\\mathcal{H}_c^2\\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  generated by the enumeration algorithm is monotonically increasing. Indeed we have the following theorem. We also show a proof which will be extended to the case of 3 dimensions in the proposed method in Section 5.</p>

    <p class="text-gray-300">Theorem 1 ((Franke-Kleinjung [5])). We assume that the basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}</span>  of lattice  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  satisfies the following conditions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A1: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math">, A2: </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}-u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math">, A3: </span>u_{1}^{(0)}>0<span class="math"> and </span>u_{1}^{(1)}>0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathbf{p}=(p_{0},p_{1})^{\\mathrm{T}}</span>, <span class="math">\\mathbf{q}=(q_{0},q_{1})^{\\mathrm{T}}</span> be points in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span>. If <span class="math">q_{1}&gt;p_{1}</span> holds, then <span class="math">\\mathbf{q}=\\mathbf{p}+i\\mathbf{u}^{(0)}+j\\mathbf{u}^{(1)}</span> satisfies <span class="math">i\\geq 0,j\\geq 0</span> and <span class="math">i+j\\neq 0</span>.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From <span class="math">\\mathbf{p},\\mathbf{q}\\in L_{\\mathbf{q},\\mathbf{r}}^{2}</span>, then we have <span class="math">\\mathbf{q}=\\mathbf{p}+i\\mathbf{u}^{(0)}+j\\mathbf{u}^{(1)}</span>, <span class="math">q_{0}=p_{0}+iu_{0}^{(0)}+ju_{0}^{(1)}</span> and <span class="math">q_{1}=p_{1}+iu_{1}^{(0)}+ju_{1}^{(1)}</span>.</p>

    <p class="text-gray-300">At first, both <span class="math">i=0</span> and <span class="math">j=0</span> can not be satisfied due to <span class="math">q_{1}&gt;p_{1}</span>. If <span class="math">i=0</span> and <span class="math">j\\neq 0</span> hold, then we obtain <span class="math">0&lt;q_{1}-p_{1}=ju_{1}^{(1)}</span> and thus <span class="math">j&gt;0</span> from Condition A3. The assertion of the theorem is derived. Similarly, if <span class="math">i\\neq 0</span> and <span class="math">j=0</span> hold, then the theorem holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we assume <span class="math">i\\neq 0</span> and <span class="math">j\\neq 0</span>. We will prove that <span class="math">i&gt;0</span> and <span class="math">j&gt;0</span> hold under the assumption of <span class="math">q_{1}&gt;p_{1}</span> and <span class="math">\\mathbf{p},\\mathbf{q}\\in\\mathcal{H}_{c}^{2}</span>, i.e., <span class="math">-I/2\\leq p_{0}&lt;I/2</span> and <span class="math">-I/2\\leq q_{0}&lt;I/2</span>. At first, if <span class="math">i&lt;0</span> and <span class="math">j&lt;0</span> hold, then we have <span class="math">iu_{1}^{(0)}+ju_{1}^{(1)}&lt;0</span> from Condition A3. However, it contradicts from the assumption of <span class="math">q_{1}&gt;p_{1}</span> due to <span class="math">q_{1}-p_{1}=iu_{1}^{(0)}+ju_{1}^{(1)}</span>. Next, we consider the case that <span class="math">i</span> and <span class="math">j</span> have the different sign. Note that if <span class="math">u_{0}^{(0)}</span> and <span class="math">u_{0}^{(1)}</span> satisfy Conditions A1 and A2, then <span class="math">u_{0}^{(0)}u_{0}^{(1)}&lt;0</span> holds. From <span class="math">u_{0}^{(0)}u_{0}^{(1)}&lt;0</span>, we know that <span class="math">iu_{0}^{(0)}</span> and <span class="math">ju_{0}^{(1)}</span> have the same sign and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}-u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then we obtain </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{0}-p_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iu_{0}^{(0)}+ju_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iu_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ju_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{0}^{(0)}-u_{0}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> from Condition A2. However, it contradicts </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{0}-p_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><I<span class="math"> from the assumption of </span>\\mathbf{p},\\mathbf{q}\\in\\mathcal{H}_{c}^{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, we denote by <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK2}}</span> the basis <span class="math">(\\mathbf{u}^{(0)},\\mathbf{u}^{(1)})</span> that satisfies Conditions A1, A2 and A3 in Theorem 1. Franke and Kleinjung showed that the basis that satisfies Conditions A1, A2 and A3 in Theorem 1 can be generated by the continued fraction method shown in Algorithm 1.</p>

    <p class="text-gray-300">From Theorem 1 Franke-Kleinjung proved the following theorem <em>[5]</em>. We also show the proof which is extended to the case of 3-dimensions.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{u}^{(0)}=(u_{0}^{(0)},u_{1}^{(0)})^{\\mathrm{T}},\\mathbf{u}^{(1)}=(u_{0}^{(1)},u_{1}^{(1)})^{\\mathrm{T}}</span> be the basis of <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{FK2}</span>. Let <span class="math">\\mathbf{p}=(p_{0},p_{1}),\\mathbf{q}=(q_{0},q_{1})</span> be points in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span>. If <span class="math">q_{1}</span> is the smallest among all the points whose second coordinate is larger than <span class="math">p_{1}</span>, then <span class="math">\\mathbf{q}</span> is one of the points <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}</span>, <span class="math">\\mathbf{p}+\\mathbf{u}^{(1)}</span>, or <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}+\\mathbf{u}^{(1)}</span>.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From Theorem 1, we know that all the points, whose second coordinate is larger than <span class="math">p_{1}</span> in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span>, can be obtained by repeatedly adding <span class="math">\\mathbf{u}^{(0)}</span> or <span class="math">\\mathbf{u}^{(1)}</span>. Every time we add point <span class="math">\\mathbf{u}^{(0)}</span> or <span class="math">\\mathbf{v}</span>, then the second coordinate of the resulting point becomes larger from Condition A3. At first note that if <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}</span> is contained in <span class="math">\\mathcal{H}_{c}^{2}</span>, then <span class="math">\\mathbf{p}+\\mathbf{u}^{(1)}\\not\\in\\mathcal{H}_{c}^{2}</span> holds from Condition A2. Therefore, if <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}\\in\\mathcal{H}_{c}^{2}</span> holds, then the second coordinate of <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}</span> is the smallest among all points whose second coordinate is larger than <span class="math">p_{1}</span> in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span>. Similarly, we can prove the case of <span class="math">\\mathbf{p}+\\mathbf{u}^{(1)}\\in\\mathcal{H}_{c}^{2}</span>. Finally, if both <span class="math">\\mathbf{p}+\\mathbf{u}^{(1)}</span> and <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}</span> are not contained in <span class="math">\\mathcal{H}_{c}^{2}</span>, then <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}+\\mathbf{u}^{(1)}\\in\\mathcal{H}_{c}^{2}</span> from Condition A2. Therefore either <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}</span>, <span class="math">\\mathbf{p}+\\mathbf{u}^{(1)}</span>, or <span class="math">\\mathbf{p}+\\mathbf{u}^{(0)}+\\mathbf{u}^{(1)}</span> is contained in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span>.</p>

    <p class="text-gray-300">From this monotonically increasing property, we can enumerate all the points in <span class="math">\\mathcal{H}_{c}^{2}\\cap L_{\\mathbf{q},\\mathbf{r}}^{2}</span> by Algorithm 2.</p>

    <p class="text-gray-300">We stress that the Franke-Kleinjung method for <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{2}</span> is not required in some cases. The Hermite normal form (HNF) of the basis of <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{2}</span> in Section 3.2 becomes one of the following:</p>

    <p class="text-gray-300">\\[ \\text{Cases }1:\\begin{pmatrix}r&z\\\\ 0&1\\end{pmatrix},\\ 2:\\begin{pmatrix}r&0\\\\ 0&1\\end{pmatrix},\\ 3:\\begin{pmatrix}1&0\\\\ 0&r\\end{pmatrix} \\]</p>

    <p class="text-gray-300">where <span class="math">z\\in\\mathbb{Z}_{&gt;0},z&lt;r</span>. The basis is orthogonal in Cases 2 and 3, and thus we can use the line sieve on <span class="math">\\mathbf{c}</span>-space. Therefore we only deal with Case 1 where <span class="math">r&gt;I</span> for the lattices sieve.</p>

    <p class="text-gray-300">|  Algorithm 1: Generation of basis Mq,rFK2 of Franke-Kleinjung method  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: bound of the lattice region I, Mq,r = (u(0), u(1)) = ((u0(0), u1(0))T, (u0(1), u1(1))T) = ((r,0)T, (z,1)T), where r > I and 0 < z < r (Case 1 of HNF in Section 4)  |   |</p>

    <p class="text-gray-300">|  Output: MFk2 that satisfies Conditions A1, A2 and A3 in Theorem 1  |   |</p>

    <p class="text-gray-300">|  1: u(1) ← u(1) - u(0)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≥ I do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: u(0) ← u(0) + au(1), a = [−u0(0)/u0(1)]  |   |</p>

    <p class="text-gray-300">|  4: SWAP(u(0), u(1))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: a ← [(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- I)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] + 1 /* a is the least positive integer s.t.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(0) + au0(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I */</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6: u(0) ← u(0) + au(1)  |   |</p>

    <p class="text-gray-300">|  7: return MFk2 = (u(0), u(1))  |   |</p>

    <p class="text-gray-300">|  Algorithm 2: NEXTFK2(I, MFk2, p)  |   |</p>

    <p class="text-gray-300">|  Input: bound of the lattice region I, MFk2 = (u(0), u(1)) = ((u0(0), u1(0))T, (u0(1), u1(1))T), where u0(0) < 0, point p = (p0, p1)T ∈ Lq,r∩ Hc2  |   |</p>

    <p class="text-gray-300">|  Output: point q = (q0, q1) s.t. q ∈ Lq,r∩ Hc2 and q1 > p1 and q1 - p1 is the least  |   |</p>

    <p class="text-gray-300">|  1: if -I/2 ≤ p0 + u0(0) then return p + u(0)  |   |</p>

    <p class="text-gray-300">|  2: if p0 + u0(1) < I/2 then return p + u(1)  |   |</p>

    <p class="text-gray-300">|  3: return p + u(0) + u(1)  |   |</p>

    <p class="text-gray-300">In this section, we extend the Franke-Kleinjung method of 2 dimensions in Section 4 to that of 3 dimensions. First we give a classification of matrix  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  by Hermite normal form. We then explain the conditions for the proposed basis in 3 dimensions and how to generate such a basis in analogue with Section 4. Finally, we present an enumeration algorithm using the proposed basis of the 3-dimensional lattice.</p>

    <p class="text-gray-300">Let  <span class="math">L_{\\mathbf{q},\\mathbf{r}}^3</span>  be the 3-dimensional lattice generated by the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  of size  <span class="math">3 \\times 3</span>  in Section 3.2 for the case of  <span class="math">t = 2</span> . We classify the HNF matrix  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  to exclude some trivial cases. The HNF of matrix  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  becomes one of the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cases 1: (r z1 z2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 1 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 0 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: (r z1 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 1 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 0 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: (r 0 z2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 1 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 0 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: (r 0 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 1 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 0 1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: (1 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r z2</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

            <td class="px-3 py-2 border-b border-gray-700">6: (1 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

            <td class="px-3 py-2 border-b border-gray-700">7: (1 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 1 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 r</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8: (r 0 z1)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r z2</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

            <td class="px-3 py-2 border-b border-gray-700">9: (r 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r z2</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

            <td class="px-3 py-2 border-b border-gray-700">10: (r 0 z1)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

            <td class="px-3 py-2 border-b border-gray-700">11: (r 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12: (r z1 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 1 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 r</td>

            <td class="px-3 py-2 border-b border-gray-700">13: (r 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 1 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 r</td>

            <td class="px-3 py-2 border-b border-gray-700">14: (1 0 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 r 0</td>

            <td class="px-3 py-2 border-b border-gray-700">0 0 r</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. An example of an enumeration of lattice points with the generated basis  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  by the proposed Franke-Kleinjung method on 3 dimensions</p>

    <p class="text-gray-300">where  <span class="math">z_{1},z_{2}\\in \\mathbb{Z}_{&amp;gt;0},z_{1},z_{2} &amp;lt;   r</span></p>

    <p class="text-gray-300">The basis is orthogonal in Cases 4, 6, 7, 11, 13 and 14, and thus we can efficiently use the line sieve on  <span class="math">\\mathbf{c}</span> -space. Moreover, Cases 2, 3, 5, 9, 10, and 12 contain an orthogonal subspace spanned by the 2-dimensional basis of the Franke-Kleinjung type which are colored by gray. We use the line sieve on the non-colored vector and the 2-dimensional Franke-Kleinjung method for its orthogonal projection. Consequently, we have to consider an HNF matrix  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  that corresponds to one of the Case 1 and 8 in the following.</p>

    <p class="text-gray-300">In this section we extend the conditions of Theorem 1 used in the Franke-Kleinjung method to the lattice of 3 dimensions, and then present how to generate the proposed basis.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{H}_c^3</span>  be the sieve region in  <span class="math">\\mathbb{Z}^3</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {c} ^ {3} = \\left\\{\\left(c _ {0}, c _ {1}, c _ {2}\\right) ^ {\\mathrm {T}} \\in \\mathbb {Z} ^ {3} \\mid - I / 2 \\leq c _ {i} &amp;lt;   I / 2 (i = 0, 1), 0 \\leq c _ {1} &amp;lt;   J \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">I, J \\in \\mathbb{Z}_{&amp;gt;0}</span>  is a bound of lattice region and  <span class="math">I</span>  is even. Our proposed enumeration algorithm can generate all the points in sieve region  <span class="math">\\mathcal{H}_c^3</span>  if we generate an appropriate basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)}, u_2^{(0)})^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)}, u_2^{(1)})^{\\mathrm{T}}</span>  and  <span class="math">\\mathbf{u}^{(2)} = (u_0^{(2)}, u_1^{(2)}, u_2^{(2)})^{\\mathrm{T}}</span>  of lattice  <span class="math">L_{\\mathbf{q},\\mathbf{r}}^3</span>  with the following properties (See Figure 2 for an example:  <span class="math">\\mathbf{u}^{(0)} = (22,39,1)^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{u}^{(1)} = (-63, -12,7)^{\\mathrm{T}}</span> , and  <span class="math">\\mathbf{u}^{(2)} = (45, -49,11)^{\\mathrm{T}}</span>  with  <span class="math">I = 64</span> ). (1) We can exhaustively compute all the points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span>  by adding the linear combination of  <span class="math">\\mathbf{u}^{(0)}</span> ,  <span class="math">\\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span> , recursively. (2) The third coordinate of the points in sieve region  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span>  generated by the enumeration algorithm is monotonically increasing. Indeed we can prove the following theorem.</p>

    <p class="text-gray-300">Theorem 3. We assume that the basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)}, u_2^{(0)})^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)}, u_2^{(1)})^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{u}^{(2)} = (u_0^{(2)}, u_1^{(2)}, u_2^{(2)})^{\\mathrm{T}}</span>  of lattice  <span class="math">L_{\\mathbf{q},\\mathbf{r}}^3</span>  satisfies the following conditions:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B1:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  for  </span>a = 0, 1, 2$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">B3:  <span class="math">u_2^{(0)} \\geq 0</span>  and  <span class="math">u_2^{(1)} \\geq 0</span>  and  <span class="math">u_2^{(2)} \\geq 0</span>  and  <span class="math">u_2^{(0)} + u_2^{(1)} + u_2^{(2)} \\neq 0</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B4:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_0u_0^{(0)} + i_1u_0^{(1)} + i_2u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math">  or  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_0u_1^{(0)} + i_1u_1^{(1)} + i_2u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> , if one of  </span>i_0, i_1, i_2 \\in \\mathbb{Z}$  is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">negative and the others are positive or equal to <span class="math">0</span>. Let <span class="math">\\mathbf{p} = (p_0, p_1, p_2)^\\mathrm{T}</span>, <span class="math">\\mathbf{q} = (q_0, q_1, q_2)^\\mathrm{T}</span> be points in <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> with <span class="math">\\mathbf{p} \\neq \\mathbf{q}</span>. If <span class="math">q_2 \\geq p_2</span> holds, then <span class="math">\\mathbf{q} = \\mathbf{p} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)}</span> satisfies (<span class="math">j_0 \\geq 0, j_1 \\geq 0, j_2 \\geq 0</span> and <span class="math">j_0 + j_1 + j_2 \\neq 0</span>) or (<span class="math">j_0 \\leq 0, j_1 \\leq 0, j_2 \\leq 0</span> and <span class="math">j_0 + j_1 + j_2 \\neq 0</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. From <span class="math">\\mathbf{p}, \\mathbf{q} \\in L_{\\mathbf{q}, \\mathbf{r}}^3</span>, then we have relation <span class="math">\\mathbf{q} = \\mathbf{p} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)}</span>, <span class="math">q_k = p_k + j_0 u_k^{(0)} + j_1 u_k^{(1)} + j_2 u_k^{(2)}</span> for <span class="math">j_0, j_1, j_2 \\in \\mathbb{Z}</span> and <span class="math">k = 0, 1, 2</span>. Moreover, from <span class="math">-I/2 \\leq p_k &amp;lt; I/2</span> and <span class="math">-I/2 \\leq q_k &amp;lt; I/2</span> for <span class="math">k = 0, 1</span>, then we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_k - p_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> for </span>k = 0, 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First of the proof, we prove the theorem in the cases of <span class="math">q_{2} &amp;gt; p_{2}</span>. We first consider the case that some coefficients <span class="math">j_0,j_1,j_2</span> are equal to zero. At first <span class="math">j_0 = j_1 = j_2 = 0</span> can not be satisfied due to <span class="math">q_{2} &amp;gt; p_{2}</span>. If <span class="math">j_0 = 0</span>, <span class="math">j_1 = 0</span> and <span class="math">j_2 \\neq 0</span> hold, then we obtain <span class="math">0 &amp;lt; q_{2} - p_{2} = j_{2}u_{2}^{(2)}</span> and thus <span class="math">j_{2} &amp;gt; 0</span> from Condition B3. The assertion of the theorem is derived. Similarly, two of coefficients <span class="math">j_0,j_1,j_2</span> are zero, the theorem holds. If we assume that one of coefficients <span class="math">j_0,j_1,j_2</span> is zero. In the case of <span class="math">j_0 \\neq 0</span>, <span class="math">j_1 \\neq 0</span> and <span class="math">j_2 = 0</span>. From Conditions B1 and B2, there exists <span class="math">k \\in \\{0,1\\}</span> s.t. <span class="math">u_k^{(0)}u_k^{(1)} &amp;lt; 0</span>. For such <span class="math">k</span>, if <span class="math">j_0</span> and <span class="math">j_1</span> have different sign, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j_0u_k^{(0)} - j_1u_k^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; I<span class="math"> in the same manner of Theorem 1. Then, it contradicts </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_{k} - p_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> for </span>k = 0,1<span class="math">. On the other hand, if </span>j_0 &lt; 0<span class="math"> and </span>j_1 &lt; 0<span class="math"> holds, we have </span>j_0u_2^{(0)} + j_1u_2^{(1)} \\leq 0<span class="math"> from Condition B3. Then, it contradicts </span>q_{2} &gt; p_{2}<span class="math">. Similarly, we can prove that the theorem holds in the case of </span>(j_0 \\neq 0,j_1 = 0,j_2 \\neq 0)<span class="math"> or </span>(j_0 = 0,j_1 \\neq 0,j_2 \\neq 0)<span class="math">. Next, we consider the case of </span>j_0 \\neq 0,j_1 \\neq 0<span class="math">, and </span>j_2 \\neq 0<span class="math">. We will prove that </span>j_0 &gt; 0,j_1 &gt; 0<span class="math"> and </span>j_2 &gt; 0<span class="math"> hold under the assumption of Condition B4, </span>q_{2} &gt; p_{2}<span class="math">, and </span>\\mathbf{p},\\mathbf{q} \\in \\mathcal{H}_c^3<span class="math">, i.e., </span>-I/2 \\leq p_k &lt; I/2<span class="math"> and </span>-I/2 \\leq q_k &lt; I/2<span class="math"> for </span>k = 0,1<span class="math">. Recall that Condition B4 assume that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> for </span>(u_0,u_1,u_2)^\\mathrm{T} = i_0\\mathbf{u}^{(0)} + i_1\\mathbf{u}^{(1)} - i_2\\mathbf{u}^{(2)}<span class="math"> (</span>i_0,i_1,i_2 \\in \\mathbb{Z}_{&gt;0}<span class="math">). At first, if </span>j_0 &lt; 0,j_1 &lt; 0<span class="math"> and </span>j_2 &lt; 0<span class="math"> hold, then we have </span>j_0u_2^{(0)} + j_1u_2^{(1)} + j_2u_2^{(2)} &lt; 0<span class="math"> from Condition B3. However, it contradicts from the assumption of </span>q_{2} &gt; p_{2}<span class="math"> due to </span>q_{2} - p_{2} = j_{0}u_{2}^{(0)} + j_{1}u_{2}^{(1)} + j_{2}u_{2}^{(2)}<span class="math">. Next, we assume that one of </span>j_0,j_1,j_2<span class="math"> is negative. Here we show the case of </span>j_0 &lt; 0,j_1 &gt; 0<span class="math"> and </span>j_2 &gt; 0<span class="math"> (the other cases can be obtained similarly). From Condition B4, we know that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j_0u_0^{(0)} + j_1u_0^{(1)} + j_2u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j_0u_1^{(0)} + j_1u_1^{(1)} + j_2u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> holds. However, it contradicts </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_0 - p_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_1 - p_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> from the assumption of </span>\\mathbf{p},\\mathbf{q} \\in \\mathcal{H}_c^3<span class="math">. Finally, if one of </span>j_0,j_1,j_2$ is negative, then we can show a contradiction using Condition B4 in the same manner.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following, we prove the case of <span class="math">q_{2} = p_{2}</span>. First, we consider the case that some coefficients <span class="math">j_{0}, j_{1}, j_{2}</span> are equal to zero. From <span class="math">\\mathbf{p} \\neq \\mathbf{q}</span> and <span class="math">q_{2} = p_{2}</span> we know that <span class="math">p_{0} \\neq q_{0}</span> or <span class="math">p_{1} \\neq q_{1}</span>. At first <span class="math">j_{0} = j_{1} = j_{2} = 0</span> can not be satisfied due to <span class="math">q_{0} \\neq p_{0}</span> or <span class="math">q_{1} \\neq p_{1}</span>. Second, if two of coefficients <span class="math">j_{0}, j_{1}, j_{2}</span> are zero, the theorem holds. Third, if we assume that one of coefficients <span class="math">j_{0}, j_{1}, j_{2}</span> is zero. We can prove that the theorem in the same manner of the case of <span class="math">q_{2} &amp;gt; p_{2}</span>. Next, we consider the case of <span class="math">j_{0} \\neq 0, j_{1} \\neq 0</span> and <span class="math">j_{2} \\neq 0</span>. At first we assume that two of <span class="math">j_{0}, j_{1}, j_{2}</span> are negative. Here we show the case of <span class="math">j_{0} &amp;lt; 0, j_{1} &amp;gt; 0</span> and <span class="math">j_{2} &amp;gt; 0</span> (the other cases can be obtained similarly). From Condition B4, we know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j_0u_0^{(0)} + j_1u_0^{(1)} + j_2u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j_0u_1^{(0)} + j_1u_1^{(1)} + j_2u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math"> holds. However, it contradicts </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_0 - p_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q_1 - p_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> from the assumption of </span>\\mathbf{p}, \\mathbf{q} \\in \\mathcal{H}_c^3<span class="math">. Finally, if one of </span>j_0, j_1, j_2$ is negative, then we can show a contradiction using Condition B4 in the same manner.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We propose an algorithm for generating <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK3}}</span> that satisfies Conditions B1, B2, B3 and B4. Algorithm 3 presents a procedure to transform <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{3}</span> to <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK3}}</span>. In Algorithm 3, we first reduce <span class="math">u_0</span> and <span class="math">u_1</span>-coordinate of <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span> and <span class="math">\\mathbf{u}^{(2)}</span> to satisfy Condition B1 as Steps 1-6, and we adjust the basis in Steps 7 and 8 to satisfy Conditions B2 and B3. We deal with whether <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK3}}</span> generated by Algorithm 3 satisfies Condition B4 in Section 6.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Step 1 of Algorithm 3, we use Algorithm 1 with respect to <span class="math">u_0</span> and <span class="math">u_1</span>-coordinate of <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span> and <span class="math">\\mathbf{u}^{(2)}</span>, then we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">. Note that we don&#x27;t need to care the values </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_2^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Algorithm 3: Proposed generation of 3-dimensional basis Mq,rFK3  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: region bound I, integer matrix M3,q,r = (u(0), u(1), u(2)) = ((r,0,0)T, (z1,1,0)T, (z2,0,1)T) s.t. r > I, 0 < z1 < r and 0 < z2 < r (Case 1 of HNF in Section 5.1).  |   |</p>

    <p class="text-gray-300">|  Output: reduced integer matrix MFK3  |   |</p>

    <p class="text-gray-300">|  1: reduce by Algorithm 1 with respect to u(0), u(1).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≥ I do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: RADIATE(u(0), u(1), u(2))  |   |</p>

    <p class="text-gray-300">|  4: if sign(u1(0)) = sign(u1(1)) then do REDUCE1(u(0), u(1), u(2))  |   |</p>

    <p class="text-gray-300">|  5: else do REDUCE2(u(0), u(1), u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: if</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then do SWAP(u(2), u(0)) else do SWAP(u(2), u(1))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: if ∃a ∈ {0,1,2} s.t. u2(a) < 0 then u(a) ← -u(a)  |   |</p>

    <p class="text-gray-300">|  8: ADJUST(u(0), u(1), u(2))  |   |</p>

    <p class="text-gray-300">|  9: return MFK3 = (u(0), u(1), u(2))  |   |</p>

    <p class="text-gray-300">|  Algorithm 4: REDUCE1(u(0),u(1),u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: bound of lattice region I, basis u(0),u(1),u(2) of the lattice generated by Mq,r s.t. sign(u1(0)) = sign(u1(1))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Output: reduced basis u(2) s.t.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: (x,y) ← (u(0),u(1)) /<em> (x0,x1,x2) ← (u0(0),u0(0),u0(0)), (y0,y1,y2) ← (u0(1),u0(1),u0(1)) </em>/  |   |</p>

    <p class="text-gray-300">|  2: if x2 > y2 then do SWAP(x,y)  |   |</p>

    <p class="text-gray-300">|  3: else if (x2 = y2) ∧ (x1 > y1) then do SWAP(x,y)  |   |</p>

    <p class="text-gray-300">|  4: while true do  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(2) + x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: u(2) ← u(2) + x  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8: if (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) ∨ (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I) then return u(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9: u(2) ← u(2) + y  |   |</p>

    <p class="text-gray-300">|  10: return u(2)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Steps 2-6, we reduce  <span class="math">u_{1}</span> -coordinate of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  with keeping the condition of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> , where  </span>a = 0, 1<span class="math">  and 2. At first, Step 3 adjusts  </span>\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}<span class="math">  and  </span>\\mathbf{u}^{(2)}<span class="math">  to reduce  </span>\\mathbf{u}^{(2)}<span class="math">  by adding  </span>\\mathbf{u}^{(0)}<span class="math">  and  </span>\\mathbf{u}^{(1)}<span class="math">  with the subroutine RADIATE. The subroutine RADIATE in Algorithm 6 transforms  </span>\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}<span class="math">  and  </span>\\mathbf{u}^{(2)}<span class="math">  to satisfy that the angle between  </span>\\mathbf{x}<span class="math">  and  </span>\\mathbf{y}<span class="math">  is less than  </span>\\pi<span class="math"> , where  </span>\\mathbf{x}<span class="math">  and  </span>\\mathbf{y}<span class="math">  are any two of  </span>\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}<span class="math">  and  </span>\\mathbf{u}^{(2)}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, we generate  <span class="math">\\mathbf{u}^{(2)}</span>  s.t.  $(u_{1}^{(2)}\\leq u_{1}^{(0)})\\lor (u_{1}^{(2)}\\leq u_{1}^{(1)})\\lor (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I)<span class="math">  by adding  </span>\\mathbf{u}^{(1)}<span class="math">  and  </span>\\mathbf{u}^{(2)}<span class="math">  in Steps 4 and 5. If  </span>\\mathrm{sign}(u_1^{(0)}) = \\mathrm{sign}(u_1^{(1)})<span class="math">  holds, we use the subroutine REDUCE1 presented in Algorithm 4, otherwise we use REDUCE2 presented in Algorithm 5. In Step 6, we swap  </span>\\mathbf{u}^{(2)}<span class="math">  for  </span>\\mathbf{u}^{(a)}<span class="math">  s.t.  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(a)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\max (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , where  </span>a\\in \\{0,1\\}<span class="math"> . From Step 6,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  hold at Step 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following, we explain the subroutine REDUCE1. In Steps 1-3 of REDUCE1, we select two bases  <span class="math">\\mathbf{x},\\mathbf{y}\\in \\{\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}\\}</span>  s.t. the elements  <span class="math">x_{2}</span>  (resp.  <span class="math">x_{1}</span> ) is less than or equals to  <span class="math">y_{2}</span>  (resp.  <span class="math">y_{1}</span> ). In Steps 5-7, we reduce  <span class="math">u_{1}^{(2)}</span>  by adding  <span class="math">\\mathbf{x}</span>  with keeping  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> . If  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in Step 6, then  </span>\\mathbf{u}^{(2)}<span class="math">  satisfies  </span>u_{1}^{(2)}\\leq u_{1}^{(0)}<span class="math">  or  </span>u_{1}^{(2)}\\leq u_{1}^{(1)}<span class="math"> . Moreover, if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  holds in Step 6, we have  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math"> , since  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the largest in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  at beginning of REDUCE1, namely then Condition B1 is satisfied. Therefore, we return  </span>\\mathbf{u}^{(2)}<span class="math">  in Step 6. Similarly, Steps 8-9 reduce  </span>u_{1}^{(2)}<span class="math">  by adding  </span>\\mathbf{y}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, we explain the subroutine REDUCE2. At first, we select two bases  <span class="math">\\mathbf{x},\\mathbf{y}\\in</span> <span class="math">\\{\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}\\}</span>  s.t.  <span class="math">\\mathrm{sign}(x_1) = \\mathrm{sign}(u_1^{(2)})</span>  in Step 1. From  <span class="math">\\mathrm{sign}(x_1)\\neq \\mathrm{sign}(y_1)</span>  and  <span class="math">\\mathrm{sign}(x_1)\\neq</span> <span class="math">\\mathrm{sign}(u_1^{(2)})</span>  , we have  <span class="math">\\mathrm{sign}(y_1) = \\mathrm{sign}(u_1^{(2)})</span>  . Therefore, we are able to reduce  <span class="math">u_{1}^{(2)}</span>  by adding</p>

    <p class="text-gray-300">|  Algorithm 5: REDUCE2(u(0),u(1),u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: bound of lattice region I, basis u(0), u(1), u(2) of the lattice generated by Mq,r u(0), u(1), u(2) s.t. sign(u1(0)) ≠ sign(u1(1))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Output: reduced basis u(2) s.t.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: if sign(u1(0)) ≠ sign(u1(2)) then x ← u(0), y ← u(1) else x ← u(1), y ← u(0)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: u(2) ← u(2) + x  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u0(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≥ I do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: u(2) ← u(2) + y  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: if (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) ∨ (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u1(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) then break</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: return u(2)  |   |</p>

    <p class="text-gray-300">|  Algorithm 6: RADIATE(u(0),u(1),u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: basis u(0),u(1),u(2) of the lattice generated by Mq,r  |   |</p>

    <p class="text-gray-300">|  Output: basis u(0),u(1),u(2) s.t. the angle of any two of u(0),u(1),u(2) is less than π  |   |</p>

    <p class="text-gray-300">|  1: if IS_OPPOSITE(u(0),u(1),u(2)) is true then  |   |</p>

    <p class="text-gray-300">|  2: if IS_OPPOSITE(u(1),u(2),u(0)) is false then u(0) ← -u(0)  |   |</p>

    <p class="text-gray-300">|  3: else  |   |</p>

    <p class="text-gray-300">|  4: if IS_OPPOSITE(u(1),u(2),u(0)) is true then u(1) ← -u(1) else u(2) ← -u(2)  |   |</p>

    <p class="text-gray-300">|  5: end if  |   |</p>

    <p class="text-gray-300">|  6: return u(0),u(1),u(2)  |   |</p>

    <p class="text-gray-300">|  Algorithm 7: IS_OPPOSITE(u(0),u(1),u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: basis u(0),u(1),u(2) of the lattice generated by Mg,r  |   |</p>

    <p class="text-gray-300">|  Output: true: if the angle between u(0) and u(a) is less than π for a = 1 and 2, false: otherwise.  |   |</p>

    <p class="text-gray-300">|  1: if u0(0) = 0 then  |   |</p>

    <p class="text-gray-300">|  2: if sign(u0(1)) ≠ sign(u0(2)) then return true else return false  |   |</p>

    <p class="text-gray-300">|  3: g = u1(0)/u0(0)  |   |</p>

    <p class="text-gray-300">|  4: y = gu0(1) - u1(1), z = gu0(2) - u1(2)  |   |</p>

    <p class="text-gray-300">|  5: if sign(y) ≠ sign(z) then return true else return false  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">only  <span class="math">\\mathbf{x}</span> . In Steps 2-6, we reduce  <span class="math">u_{1}^{(2)}</span>  by adding  <span class="math">\\mathbf{x}</span> . However, we use  <span class="math">\\mathbf{y}</span>  if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq I<span class="math">  holds in Steps 4 and 5 to satisfy  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  again. If  </span>\\mathbf{u}^{(2)}<span class="math">  satisfies the condition in Step 6, the termination condition of REDUCE2 holds. Therefore, we break while loop in Step 6 and return  </span>\\mathbf{u}^{(2)}<span class="math"> . Moreover, from the same reason in REDUCE1, if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  holds in Step 2, we also break the while loop and return  </span>\\mathbf{u}^{(2)}<span class="math"> . Therefore, we repeat the procedures in Step 2-6 in Algorithm 3 until  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; I<span class="math">  is satisfied, then we obtain  </span>\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}<span class="math">  and  </span>\\mathbf{u}^{(2)}$  that satisfy Condition B1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, Step 7 of Algorithm 3 negates the bases s.t.  <span class="math">u_{2}</span> -coordinate is negative, and Step 8 adjusts  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  to satisfy Conditions B1 and B2.</p>

    <p class="text-gray-300">In this section, we propose an enumeration algorithm which can exhaustively enumerate all the points in the sieve region  <span class="math">\\mathcal{H}_c^3</span>  using the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK3}}</span>  in the previous section.</p>

    <p class="text-gray-300">At first, we give an order to all the points in  <span class="math">\\mathcal{H}_c^3\\cap L_{\\mathbf{q},\\mathbf{r}}^3</span>  using the property of Theorem 3. Let  <span class="math">\\mathbf{a},\\mathbf{b}</span>  be two points in  <span class="math">\\mathcal{H}_c^3\\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> . From Theorem 3, if the third coordinate of  <span class="math">\\mathbf{a}</span>  is equal to or larger than that of  <span class="math">\\mathbf{b}</span> , then we can write  <span class="math">\\mathbf{a} = \\mathbf{b} + j_0\\mathbf{u}^{(0)} + j_1\\mathbf{u}^{(1)} + j_2\\mathbf{u}^{(2)}</span>  for integers  <span class="math">j_0,j_1,j_2</span>  that satisfy ( <span class="math">j_0\\geq 0,j_1\\geq 0,j_2\\geq 0</span>  and  <span class="math">j_0 + j_1 + j_2\\neq 0</span> ) or ( <span class="math">j_0\\leq 0,j_1\\leq 0,j_2\\leq 0</span></p>

    <p class="text-gray-300">|  Algorithm 8: ADJUST(u(0),u(1),u(2))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: basis u(0),u(1),u(2) of the lattice generated by M3,τ  |   |</p>

    <p class="text-gray-300">|  Output: basis u(0),u(1),u(2) that satisfies Conditions B1 and B2 in Theorem 3  |   |</p>

    <p class="text-gray-300">|  1: for any two x,y of u(0),u(1) and u(2) do  |   |</p>

    <p class="text-gray-300">|  2: z← x - y /<em> (z0,z1,z2) ← (x0 - y0,x1 - y1,x2 - y2) </em>/  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: if (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I) ∧ (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< I) then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: RADIATE(u(0),u(1),u(2))  |   |</p>

    <p class="text-gray-300">|  6: return u(0),u(1),u(2)  |   |</p>

    <p class="text-gray-300">|  Algorithm 9: NEXTFK3(Hx, Fx, Fx)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: bound of lattice region I, point p = (p0, p1, p2)T ∈ L3,τ ∩ Hx, MFx = (u(0), u(1), u(2))  |   |</p>

    <p class="text-gray-300">|  Output: q = (q0, q1, q2)T ∈ L3,τ ∩ Hx, s.t. q2 is the smallest under the condition of q2 > p1  |   |</p>

    <p class="text-gray-300">|  1: while true do  |   |</p>

    <p class="text-gray-300">|  2: r ← p /<em> (r0, r1, r2) ← (p0, p1, p2) </em>/  |   |</p>

    <p class="text-gray-300">|  3: while true do  |   |</p>

    <p class="text-gray-300">|  4: s ← r /<em> (s0, s1, s2) ← (r0, r1, r2) </em>/  |   |</p>

    <p class="text-gray-300">|  5: while true do  |   |</p>

    <p class="text-gray-300">|  6: s ← s + u(0)  |   |</p>

    <p class="text-gray-300">|  7: if s ∈ Hc then return s  |   |</p>

    <p class="text-gray-300">|  8: if I/2 ≤ s0 or I/2 ≤ s1 then break  |   |</p>

    <p class="text-gray-300">|  9: r ← r + u(1)  |   |</p>

    <p class="text-gray-300">|  10: if I/2 ≤ r0 or I/2 ≤ r1 then break  |   |</p>

    <p class="text-gray-300">|  11: p ← p + u(2)  |   |</p>

    <p class="text-gray-300">and  <span class="math">j_0 + j_1 + j_2 \\neq 0</span> ). Note that all integers  <span class="math">j_0, j_1, j_2</span>  become zero simultaneously, if and only if  <span class="math">\\mathbf{a} = \\mathbf{b}</span>  holds. Here, we define  <span class="math">\\mathbf{b} \\prec \\mathbf{a}</span> , if  <span class="math">\\mathbf{a} - \\mathbf{b}</span>  is equal to  <span class="math">j_0\\mathbf{u}^{(0)} + j_1\\mathbf{u}^{(1)} + j_2\\mathbf{u}^{(2)}</span>  for some  <span class="math">j_0 \\geq 0, j_1 \\geq 0, j_2 \\geq 0</span> . Then,  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span>  becomes a totally ordered set by order  <span class="math">\\prec</span> , and we can enumerate the points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span>  by introducing a product order for the pair  <span class="math">(j_0, j_1, j_2)</span>  of  <span class="math">j_0\\mathbf{u}^{(0)} + j_1\\mathbf{u}^{(1)} + j_2\\mathbf{u}^{(2)}</span> . Here we define the product order  <span class="math">(j_0, j_1, j_2) \\leq (j_0&#x27;, j_1&#x27;, j_2&#x27;)</span>  for two pairs  <span class="math">(j_0, j_1, j_2), (j_0&#x27;, j_1&#x27;, j_2&#x27;) \\in \\mathbb{Z}_{&amp;gt;0}^2</span> , if and only if  <span class="math">j_0 \\leq j_0&#x27;</span> ,  <span class="math">j_1 \\leq j_1&#x27;</span>  and  <span class="math">j_2 \\leq j_2&#x27;</span>  hold. In Algorithm 9, we show an algorithm for exhaustively enumerating all points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> . Indeed we can prove the following theorem.</p>

    <p class="text-gray-300">Theorem 4. Let  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)},\\mathbf{u}^{(2)}</span>  be the basis of  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{FK2}</span> . Let  <span class="math">\\mathbf{p} = (p_0,p_1,p_2),\\mathbf{q} = (q_0,q_1,q_2)</span>  be points in  <span class="math">\\mathcal{H}_c^3\\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> . If  <span class="math">q_{2}</span>  is the smallest among all the points whose third coordinate is equal to or larger than that of  <span class="math">p_2</span> , then  <span class="math">\\mathbf{q}</span>  is computed by Algorithm 9.</p>

    <p class="text-gray-300">Proof. From Theorem 3, we know that all the points, whose third coordinate is equal to or larger than  <span class="math">p_w</span>  in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> , can be obtained by repeatedly adding  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span> .</p>

    <p class="text-gray-300">Every time we add basis  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span>  to  <span class="math">\\mathbf{p}</span> , then the third coordinate of the resulting point becomes equal to or larger than that of  <span class="math">\\mathbf{p}</span>  from Condition B3. Note that only one of  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}</span> ,  <span class="math">\\mathbf{p} + \\mathbf{u}^{(1)}</span> , and  <span class="math">\\mathbf{p} + \\mathbf{u}^{(2)}</span>  is contained in  <span class="math">\\mathcal{H}_c^3\\cap L_{\\mathbf{q},\\mathbf{r}}^3</span> . Therefore, Step 1 checks if there exists  <span class="math">a\\in \\{0,1,2\\}</span>  s.t.  <span class="math">\\mathbf{p} + \\mathbf{u}^{(a)}\\in \\mathcal{H}_c</span> , and we return such a point if exists. In Steps 2-6, we deal with the case of adding more than one basis of  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span>  to point  <span class="math">\\mathbf{p}</span> . In this step, we search the smallest pair  <span class="math">(i,j,k)\\in \\mathbb{Z}_{&amp;gt;0}^3</span>  in the sense of the above product order that satisfies  <span class="math">\\mathbf{p} + j_0\\mathbf{u}^{(0)} + j_1\\mathbf{u}^{(1)} + j_2\\mathbf{u}^{(2)}\\in \\mathcal{H}_{\\mathbf{e}}^3</span> . Such a point satisfies the assertion of the theorem.</p>

    <p class="text-gray-300">From Theorem 5.2, we construct an enumeration algorithm for exhaustively enumerating all the points in  <span class="math">\\mathcal{H}_c^3</span>  with  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^{\\mathrm{FK3}}</span>  by repeatedly adding  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span> .</p>

    <p class="text-gray-300">Example 1. We show an example of the basis of the proposed algorithm. We choose an extension field  <span class="math">\\mathrm{GF}(p^n)</span>  of size 303 bits s.t.  <span class="math">p = 38486027</span> ,  <span class="math">n = 12</span> , and choose a polynomial</p>

    <p class="text-gray-300"><span class="math">f_{1}(X) = X^{12} + X^{2} - 1</span> . Additionally, for  <span class="math">f_{1}</span> , we obtain  <span class="math">f_{2}</span>  by adding  <span class="math">p</span>  to  <span class="math">f_{1}</span>  as  <span class="math">f_{2}(X) = f_{1} + p</span> . We take special- <span class="math">\\mathfrak{q}</span>  as  <span class="math">\\mathfrak{q} = (q,g) = (99989,X + 8368)</span> , and the other prime ideal  <span class="math">\\mathfrak{r} = (r,h) = (89107,X + 54851)</span> . Then, we compute the basis as the HNF matrix of  <span class="math">M_{\\mathfrak{q}}, M_{\\mathfrak{r}}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\mathfrak {q}} = \\left( \\begin{array}{c c c} 9 9 9 8 9 &amp;amp; 8 3 6 8 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 8 3 6 8 \\\\ 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right), \\quad M _ {\\mathfrak {r}} = \\left( \\begin{array}{c c c} 8 9 1 0 7 &amp;amp; 5 4 8 5 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 5 4 8 5 1 \\\\ 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right).</span></div>

    <p class="text-gray-300">We obtain the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  and the proposed basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  used for the lattice sieve as follows:</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\mathfrak {q}, \\mathfrak {r}} ^ {3} = \\left( \\begin{array}{c c c} 8 9 1 0 7 &amp;amp; 2 7 0 8 3 &amp;amp; - 5 0 7 9 5 \\\\ 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right), \\quad M _ {\\mathfrak {q}, \\mathfrak {r}} ^ {\\mathrm {F K 3}} = \\left( \\begin{array}{c c c} 2 3 &amp;amp; - 5 7 &amp;amp; 3 5 \\\\ 2 3 &amp;amp; - 1 0 &amp;amp; - 4 8 \\\\ 7 &amp;amp; 2 8 &amp;amp; 1 3 \\end{array} \\right).</span></div>

    <p class="text-gray-300">In this section, we show some results of experiments on the number field sieve for solving the discrete logarithm problem using the proposed lattice sieve of 3 dimensions. We focus on the finite fields of extension degree 6 and 12, which are often used in pairing-based cryptography.</p>

    <p class="text-gray-300">In the following, we show some data of the proposed 3-dimensional lattice sieve. We implemented the sieve step of the number field sieve for solving the discrete logarithm problem over finite field  <span class="math">\\mathrm{GF}(p^{12})</span> . The finite field of extension degree  <span class="math">n = 12</span>  is used for efficient implementation of pairing-based cryptography using BN curves [3].</p>

    <p class="text-gray-300">Table 1. Computational environment in our experiment in Section 6.1</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPU</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intel Core i7-3770 3.40 GHz</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">8 GBytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OS</td>

            <td class="px-3 py-2 border-b border-gray-700">Linux (64 bits)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Language</td>

            <td class="px-3 py-2 border-b border-gray-700">C++</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compiler</td>

            <td class="px-3 py-2 border-b border-gray-700">gcc-4.7.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Library</td>

            <td class="px-3 py-2 border-b border-gray-700">gmp-5.0.5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1 shows the computational environments of our experiment. In order to perform many experiments in this computational resources, we choose a characteristic  <span class="math">p = 38486027</span>  of 26 bits. In the polynomial selection step, we choose a polynomial  <span class="math">f_{1} = x^{12} + x^{2} - 1 \\in \\mathbb{Z}[X]</span> , which is irreducible in  <span class="math">\\mathrm{GF}(p)</span>  and has small coefficients. Then polynomial  <span class="math">f_{2}</span>  is chosen as  <span class="math">f_{2} = f_{1} + p = x^{12} + x^{2} + 38486026</span> .</p>

    <p class="text-gray-300">In our experiment of the 3-dimensional lattice sieve generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  defined in Section 3.2 for the case of  <span class="math">t = 2</span> , we set the following parameters. We choose 10 special-qs s.t.  <span class="math">\\mathfrak{q} = (q,g)\\in \\mathcal{B}_2</span>  from  <span class="math">99871\\leq q\\leq 99989</span> . The bound of sieve region is  <span class="math">I = 2^{k}</span>  ( <span class="math">k = 7,8,\\ldots ,11</span> ),  <span class="math">J = I / 2</span> . We generate prime ideals  <span class="math">\\mathfrak{r} = (r,h)\\in \\mathcal{B}_2</span>  s.t.  <span class="math">I &amp;lt; r\\leq 85386</span>  and  <span class="math">\\deg h = 1</span> . The number of such  <span class="math">\\mathfrak{r}</span>  is about 8000 for one special-  <span class="math">\\mathfrak{q}</span> , namely we deal with about 80000 lattices generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  for one fixed  <span class="math">I</span> .</p>

    <p class="text-gray-300">For chosen special- <span class="math">\\mathfrak{q}</span> ,  <span class="math">I</span>  and  <span class="math">\\mathfrak{r}</span> , we generate the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  by the proposed generation algorithm in Section 5. Table 2 shows some probabilities related to the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  in our experiments. The first column of Table 2 is the number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  we generated for each bound</p>

    <p class="text-gray-300">Table 2. Rate of  <span class="math">{M}_{\\mathrm{q},\\mathrm{r}}^{3}</span>  that satisfies Condition B4</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#M3q,r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B1, B2, B3, B4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B1, B2, B4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B1, B2, B3</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">84005</td>

            <td class="px-3 py-2 border-b border-gray-700">62395 (74%)</td>

            <td class="px-3 py-2 border-b border-gray-700">3724 (4%)</td>

            <td class="px-3 py-2 border-b border-gray-700">18765 (22%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">83865</td>

            <td class="px-3 py-2 border-b border-gray-700">61717 (73%)</td>

            <td class="px-3 py-2 border-b border-gray-700">322 (0%)</td>

            <td class="px-3 py-2 border-b border-gray-700">21918 (26%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">83445</td>

            <td class="px-3 py-2 border-b border-gray-700">55746 (66%)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 (0%)</td>

            <td class="px-3 py-2 border-b border-gray-700">27681 (33%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">82645</td>

            <td class="px-3 py-2 border-b border-gray-700">54204 (65%)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 (0%)</td>

            <td class="px-3 py-2 border-b border-gray-700">28425 (34%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">81185</td>

            <td class="px-3 py-2 border-b border-gray-700">52446 (64%)</td>

            <td class="px-3 py-2 border-b border-gray-700">0 (0%)</td>

            <td class="px-3 py-2 border-b border-gray-700">28725 (35%)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">I</span> . The second column is the number of  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  that satisfies all conditions in Section 5. The third column is the number of  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  that does not satisfy only Condition B3. The fourth column is the number of  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  that does not satisfy only Condition B4. The number of the other types of the basis is less than  <span class="math">2\\%</span>  among the total number of  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span> . About  <span class="math">74\\%</span>  of the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  fulfill all the conditions for  <span class="math">I = 128</span> , namely we are able to compute all the points in  <span class="math">\\mathcal{H}_c^3</span>  in the lattice for the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span> . If the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  does not fulfill them, Condition B4 is critical for all sieve bound in the experiment.</p>

    <p class="text-gray-300">Table 3. Rate of the points that enumerated by  <span class="math">{M}_{\\mathrm{q},\\mathrm{r}}^{3}</span>  that don't satisfies Condition B4</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rate</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">90%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">94%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">96%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">98%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">99%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Once the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  does not fulfill all the conditions in Section 5, Algorithm 9 not always enumerate all the points in the sieve region  <span class="math">\\mathcal{H}_c^3</span> . Table 3 shows the percentages of the points generated by Algorithm 9 over the all points in  <span class="math">\\mathcal{H}_c^3</span>  using the same basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span>  in the previous experiment. Here we assume that the number of all points in  <span class="math">\\mathcal{H}_c^3</span>  as  <span class="math">I^2 J / r</span> . The proposed enumeration algorithm can enumerate more than  <span class="math">90\\%</span>  of the points in the sieve region using the basis  <span class="math">M_{\\mathbf{q},\\mathbf{r}}^3</span> .</p>

    <p class="text-gray-300">In this section, in order to confirm our 3-dimensional lattice sieve works efficiently, we report an experiment on a sieve step of the number field sieve over  <span class="math">\\mathrm{GF}(p^6)</span> . The finite field of extension degree  <span class="math">r</span>  is used for efficient implementation of pairing-based cryptography using MNT curves [15]. Zajac solved the discrete logarithm problem over  <span class="math">\\mathrm{GF}(p^6)</span>  of 240 bits [22] (Zaj08-exp), which is the current record of JLSV06-NFS over finite fields of extension degree 6. We perform an experiment on the proposed lattice using same parameter in the experiment of Zaj08-exp.</p>

    <p class="text-gray-300">Our experiment uses the computers in Table 4. We deploy the parameters in our experiment as similar as possible those used in Zaj08-exp. Zajac solved the discrete logarithm problem over the extension field whose characteristic  <span class="math">p = 1081034284409</span>  of 40 bits, namely the cardinality of  <span class="math">\\mathrm{GF}(p^6)</span>  is</p>

    <p class="text-gray-300">p^6 = 1596014400197077740306072399677175692025917352715453344036177063352145041</p>

    <p class="text-gray-300">Table 4. The data of computers that we use in the experiment in Section 6.2</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPU</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intel Core i7-3770 3.40 GHz ×8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intel Xeon E5-2430L 2.00GHz ×24</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">32 GBytes</td>

            <td class="px-3 py-2 border-b border-gray-700">32 GBytes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OS</td>

            <td class="px-3 py-2 border-b border-gray-700">Linux (64 bits)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Language</td>

            <td class="px-3 py-2 border-b border-gray-700">C++</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Compiler</td>

            <td class="px-3 py-2 border-b border-gray-700">gcc-4.7.2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Library</td>

            <td class="px-3 py-2 border-b border-gray-700">gmp-5.0.5, openmpi-1.6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">of 240 bits. For the extension field, he chose two polynomials</p>

    <div class="my-4 text-center"><span class="math-block">f _ {1} (X) = x ^ {6} - 2 x ^ {5} + x ^ {3} - x + 2,</span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {2} (X) = x ^ {6} - 2 x ^ {5} + x ^ {3} - x + 1 0 8 1 0 3 4 2 8 4 4 1 1.</span></div>

    <p class="text-gray-300">Additionally, he also chose smoothness bounds  <span class="math">B_{1} = B_{2} = 6532326</span>  and 3-dimensional sieve region in a-space  <span class="math">\\mathcal{H}_a</span>  s.t.  <span class="math">-2^{18} \\leq a_0 \\leq 2^{18}</span> ,  <span class="math">-2^{13} \\leq a_1 \\leq 2^{13}</span> ,  <span class="math">1 \\leq a_2 \\leq 1149</span> . In the experiment in Zaj08-exp, he executed 3-dimensional line sieve in  <span class="math">\\mathcal{H}_a</span>  above with elements in factor bases  <span class="math">(q,g) \\in \\mathcal{B}_1 \\cup \\mathcal{B}_2</span>  s.t.  <span class="math">\\deg g = 1</span> .</p>

    <p class="text-gray-300">In our experiment, the same parameter  <span class="math">p</span> ,  <span class="math">n</span> ,  <span class="math">f_1</span> ,  <span class="math">f_2</span> ,  <span class="math">B_1</span>  and  <span class="math">B_2</span>  were implemented. Instead the a-space, our 3-dimensional lattice uses a sieve region over c-space  <span class="math">\\mathcal{H}_c^3</span> . Here, we try to chose the sieve region  <span class="math">\\mathcal{H}_c^3</span>  such that the number of hit tuples we can obtain in  <span class="math">\\mathcal{H}_c^3</span>  is larger than  <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n = 893773</span> . In our 3-dimensional lattice sieve, we choose 223595 special-  <span class="math">\\mathfrak{q} = (q,g)</span>  from  <span class="math">\\mathcal{B}_2</span>  s.t.  <span class="math">3112117 \\leq q \\leq 6532291</span>  and  <span class="math">\\deg g = 1</span> . We executed our lattice sieve for 10 special-  <span class="math">\\mathfrak{q}</span> s that is randomly chosen in  <span class="math">3112117 \\leq q \\leq 6532291</span>  with respect to  <span class="math">\\mathcal{H}_c^3</span>  whose bound of lattice region is  <span class="math">I = 2^k</span>  ( <span class="math">k = 4,5,\\ldots 10</span> ). Then, we estimated the number of hit tuples we obtain for all special-  <span class="math">\\mathfrak{q}</span> s in  <span class="math">3112117 \\leq q \\leq 6532291</span>  with respect to  <span class="math">I = 2^k</span>  ( <span class="math">k = 4,5,\\ldots 10</span> ). From the estimated number of hit tuples for  <span class="math">I = 2^k</span>  ( <span class="math">k = 4,5,\\ldots 10</span> ), we chosen  <span class="math">I = 2^7</span>  since  <span class="math">k = 7</span>  is the least integer s.t. the estimated number of hit tuples is larger than  <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n = 893773</span> .</p>

    <p class="text-gray-300">For example, in the case of special- <span class="math">\\mathfrak{q} = (6532291, X + 1470092)</span>  and  <span class="math">\\mathfrak{r} = (751691, X + 268635)</span> , the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  becomes</p>

    <div class="my-4 text-center"><span class="math-block">M _ {\\mathfrak {q}, \\mathfrak {r}} ^ {\\mathrm {F K 3}} = \\left( \\begin{array}{c c c} 2 3 0 &amp;amp; - 6 &amp;amp; - 3 5 \\\\ - 1 9 2 &amp;amp; 2 3 5 &amp;amp; - 4 2 \\\\ 2 7 &amp;amp; 1 9 &amp;amp; 4 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Then an example of the hit tuple in the lattice generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  is  <span class="math">\\mathbf{a} = (-63189,410,72)^{\\mathrm{T}}</span> , where the norms of  <span class="math">\\mathbf{a}</span>  are</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} N _ {1} (\\mathbf {a}) = 6 2 5 4 2 9 4 9 6 7 1 9 6 9 9 8 9 9 5 6 0 8 9 8 5 3 2 1 3 \\\\ = 4 1 ^ {2} \\times 2 3 7 1 \\times 6 8 6 9 \\times 1 0 1 8 6 3 \\times 4 7 0 0 6 2 1 \\times 4 7 7 1 0 4 9, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} N _ {2} (\\mathbf {a}) = 1 6 3 0 5 2 5 2 4 9 2 7 2 6 6 5 4 9 8 9 8 8 8 4 7 9 4 5 4 3 2 2 1 5 9 7 \\\\ = 7 \\times 1 7 \\times 1 2 9 5 3 \\times 2 2 2 7 1 \\times 1 1 6 4 6 1 \\times 1 3 4 4 4 5 7 \\times 4 6 4 3 8 4 3 \\times 6 5 3 2 2 9 1. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In the result, the whole running time of the lattice sieve was 50996 seconds, namely about 14 hours, and we got 1041417 hit tuples. Then, we eliminated 103842 duplicate hit tuples. Therefore, we obtained 937575 hit tuples in contrast to 1077984 obtained in Zaj08-exp.</p>

    <p class="text-gray-300">Table 5 shows the experimental data in both our implementation and the previous one in Zaj08-exp. Our experiment deploys about 4 time more CPU cores than Zaj08-exp, but the running time reduces from 3 days to 14 hours.</p>

    <p class="text-gray-300">Table 5. Comparison of our experiment with the top record of the number field sieve over  <span class="math">\\mathrm{GF}(p^6)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Zajac [22]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ours</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Year</td>

            <td class="px-3 py-2 border-b border-gray-700">2008</td>

            <td class="px-3 py-2 border-b border-gray-700">2014</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPU and #cores</td>

            <td class="px-3 py-2 border-b border-gray-700">Sempron (2.01GHz) × 8</td>

            <td class="px-3 py-2 border-b border-gray-700">Core i7 (3.40GHz) × 8 Xeon (2.00GHz) × 24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Timing of Sieve</td>

            <td class="px-3 py-2 border-b border-gray-700">3 days</td>

            <td class="px-3 py-2 border-b border-gray-700">14 hours</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sieve</td>

            <td class="px-3 py-2 border-b border-gray-700">3-dim. line sieve</td>

            <td class="px-3 py-2 border-b border-gray-700">3-dim. lattice sieve</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper, we proposed the 3-dimensional lattice sieve as an extension of the Franke-Kleinjung method that is used for the efficient implementation of the number field sieve as an efficient algorithm for enumerating the points in 2-dimensional sieve region.</p>

    <p class="text-gray-300">First, we gave a natural extension of the basis conditions used in the Franke-Kleinjung method to the 3-dimensional case. We proved that the basis that satisfies the conditions is able to exhaustively enumerate all points in the sieve region in 3-dimensional lattice. We then proposed an enumeration algorithm that can trace all the points in 3-dimensional sieve region if such a basis exists. In our experiment of  <span class="math">\\mathrm{GF}(p^{12})</span>  of size 303 bits, the proposed algorithm can enumerate more than  <span class="math">90\\%</span>  of all points in the sieve region of the 3-dimensional lattices, even though the basis does not satisfy the above conditions.</p>

    <p class="text-gray-300">Finally, we compared the running time of the proposed 3-dimensional lattice sieve with the current record of  <span class="math">\\mathrm{GF}(p^6)</span>  of 240 bits by Zajac. In the results, sieve step using our extended 3-dimensional lattice sieve is about as efficient as that of 3-dimensional line sieve by Zajac.</p>

    <p class="text-gray-300">In the future, we try to perform the experiments on solving the DLP using larger  <span class="math">p</span>  with the proposed lattice sieve, and we estimate the secure key-length used in pairing-based cryptography.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Barbulescu, P. Gaudry, A. Joux and E. Thomé, 'A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic', Cryptology ePrint Archive: Report 2013/400, (2013).</li>

      <li>P.S.L.M. Barreto, S. Galbraith, C. O. Eigeartaigh, M. Scott, 'Efficient pairing computation on supersingular abelian varieties', Designs, Codes and Crypt., 42 (2007) 239-271.</li>

      <li>P.S.L.M. Barreto and M. Naehrig, 'Pairing-friendly elliptic curves of prime order', SAC 2005, LNCS, Springer, 3897 (2006) 319-331.</li>

      <li>H. Cohen, A course in computational algebraic number theory, Graduate Texts in Math., Springer, 138 (1993).</li>

      <li>J. Franke and T. Kleinjung, 'Continued fractions and lattice sieve', Workshop record of SHARCS, (2005).</li>

      <li>K. Hayasaka, K. Aoki, T. Kobayashi, T. Takagi, 'An experiment of number field sieve for discrete logarithm problem over  <span class="math">\\mathrm{GF}(p^{12})</span> ', Buchmann Festschrift, LNCS, Springer, 8260 (2013) 108-120.</li>

      <li>K. Hayasaka, K. Aoki, T. Kobayashi, T. Takagi, 'A Verification of 3-dimensional Lattice Sieve', Computer Security Symposium 2014, CSS2014, 1E3-3 (2014) 135-142, . (in Japanese)</li>

      <li>A. Joux, 'A new index calculus algorithm with complexity  <span class="math">L(1/4 + o(1))</span>  in very small characteristic', Cryptology ePrint Archive: Report 2013/095, (2013).</li>

      <li>A. Joux and R. Lercier, 'Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the Gaussian integer method', Math. Comp., 72 (2003) 953-967.</li>

      <li>A. Joux, R. Lercier, N.P. Smart and F. Vercauteren, 'The number field sieve in the medium prime case', CRYPTO '06, LNCS, Springer, 4117 (2006) 326-344.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[11] T. Kleinjung et al., ‘Discrete logarithms in GF(<span class="math">p</span>) - 160 digits’, email to the NMBRTHRY mailing list, (2007). http://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind0702&amp;L=nmbrthry&amp;T=0&amp;P=194.</li>

      <li>[12] T. Kleinjung, K. Aoki, J. Franke, A.K. Lenstra, E. Thomé, J.W. Bos, P. Gaudry, A. Kruppa, P.L. Montgomery, D.A. Osvik, H.J.J. te Riele, A. Timofeev and P. Zimmermann, ‘Factorization of a 768-bit RSA modulus’, CRYPTO ’10, LNCS, Springer, 6223 (2010) 333-350.</li>

      <li>[13] A.K. Lenstra and H.W. Lenstra, The development of the number field sieve, Lecture Notes in Math., Springer, 1554 (1993).</li>

      <li>[14] A.K. Lenstra, H.W. Lenstra and L. Lovász, ‘Factoring polynomials with rational coefficients’, Math. Ann., 261 (1982) 515-534.</li>

      <li>[15] A. Miyaji, M. Nakabayashi and S. Takano, ‘New explicit conditions of elliptic curve traces for FR-reduction’, In IEICE Trans. on Fund., E84-A (5) (2001) 1234-1243.</li>

      <li>[16] B. Murphy, ‘Polynomial selection for the number field sieve integer factorisation algorithm’, PhD. thesis, The Australian National University, (1999).</li>

      <li>[17] J.M. Pollard, ‘The lattice sieve’, 43-49 in <em>[13]</em>.</li>

      <li>[18] C. Pomerance and J. Smith, ‘Reduction of huge, sparse matrices over finite fields via created catastrophes’, Experiment. Math., 1 (1992) 89-94.</li>

      <li>[19] O. Schirokauer, ‘Discrete logarithms and local units’, Philos. Trans. Roy. Soc. London Ser. A, 345 (1993) 409-424.</li>

      <li>[20] O. Schirokauer, ‘Virtual logarithms’, J. Algorithms, 57 (2005) 140-147.</li>

      <li>[21] F. Vercauteren, ‘Optimal pairings’, IEEE Trans. on Info. Theory, 56, (2010) 455-461.</li>

      <li>[22] P. Zajac, ‘Discrete logarithm problem in degree six finite fields’, PhD thesis, Slovak University of Technology, (2008).</li>

      <li>[23] P. Zajac, ‘On the use of the lattice sieve in the 3D NFS’, Tatra Mt. Math. Publ. 45 (2010) 161-172.</li>

    </ul>`;
---

<BaseLayout title="A construction of 3-dimensional lattice sieve for number fie... (2015/1179)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1179
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
