---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/401';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Tower Number Field Sieve Variant of a Recent Polynomial Selection Method';
const AUTHORS_HTML = 'Palash Sarkar, Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">At Asiacrypt 2015, Barbulescu et al. performed a thorough analysis of the tower number field sieve (TNFS) variant of the number field sieve algorithm. More recently, Kim and Barbulescu combined the TNFS variant with several polynomial selection methods including the Generalised Joux-Lercier method and the Conjugation method proposed by Barbulescu et al. at Eurocrypt 2015. Sarkar and Singh (Eurocrypt 2016) proposed a polynomial selection method which subsumes both the GJL and the Conjugation methods. This study was done in the context of the NFS and the multiple NFS (MNFS). The purpose of the present note is to show that the polynomial selection method of Sarkar and Singh subsumes the GJL and the Conjugation methods also in the context of the TNFS and the multiple TNFS variants. This was not clear from the recent work by Kim and Barbulescu. Applying the new polynomial selection method to the TNFS variants results in new asymptotic complexities for certain ranges of primes.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">There has been a recent increase in the interest of applying the number field sieve (NFS) algorithms and its several variants to the study of the discrete logarithm problem on finite fields <span class="math">\\mathbb{F}_{p^{n}}</span> with <span class="math">n&gt;1</span>. The work by Barbulescu et al. <em>[1]</em> at Eurocrypt 2015 proposed two new methods for polynomial selections and worked out the asymptotic complexities of these methods as applied to the NFS algorithm. These polynomial selection methods were named the generalised Joux-Lercier (GJL) method and the Conjugation method. At the same conference, Pierrot <em>[5]</em> showed how to combine these polynomial selection methods with the multiple NFS (MNFS) variant <em>[5]</em> and worked out the corresponding asymptotic complexities. Sarkar and Singh (Eurocrypt 2016) proposed <em>[6]</em> a new polynomial selection method which subsumes both the GJL and the Conjugation methods. Using this method, the asymptotic complexity of both the NFS and the MNFS were worked out in <em>[6]</em>.</p>

    <p class="text-gray-300">At Asiacrypt 2015, Barbulescu et al., <em>[2]</em> presented a detailed analysis of the tower number field sieve (TNFS) variant. In a recent paper, Kim and Barbulescu <em>[4]</em> applied previous polynomial selection methods to the TNFS, the</p>

    <p class="text-gray-300">multiple TNFS (MTNFS) and the special TNFS variants. The polynomial selection methods considered in [4] include the methods from Joux-Lercier-Smart-Vercauteren [3], the GJL and the Conjugation methods from [1] and the polynomial selection method from [6]. The discussion in [4] does not make it clear that the polynomial selection method from [6] subsumes the GJL and the Conjugation methods in the context of TNFS.</p>

    <p class="text-gray-300">The main point of the present note is to properly apply the polynomial selection method of Sarkar and Singh [6] to TNFS. Once this is done, it once more follows that the polynomial selection method from [6] subsumes the GJL and the Conjugation methods for the TNFS variant also.</p>

    <p class="text-gray-300">The polynomial selection method considered in [6] has been called <span class="math">\\mathcal{A}</span>. The modification considered here provides a generalisation of <span class="math">\\mathcal{A}</span> and let us denote the generalisation as <span class="math">\\mathcal{B}</span>. Let the variant of TNFS obtained by using <span class="math">\\mathcal{B}</span> be denoted by TNFS-<span class="math">\\mathcal{B}</span> and similarly denote MTNFS-<span class="math">\\mathcal{B}</span>.</p>

    <p class="text-gray-300">Let <span class="math">Q = p^n</span>, where <span class="math">n = \\eta \\kappa</span> and <span class="math">\\gcd(\\eta, \\kappa) = 1</span>. Suppose that <span class="math">p = L_Q(a, c_p)</span> for some <span class="math">a</span> in <span class="math">(1/3, 2/3)</span> where <span class="math">L_Q</span> is the usual sub-exponential notation. Further suppose that <span class="math">\\eta</span> can be written as <span class="math">\\eta = c_\\eta (\\ln Q / \\ln \\ln Q)^{2/3 - a}</span> and let <span class="math">c_\\theta = c_p c_\\eta</span>. For this setting, the following new asymptotic results are obtained: For <span class="math">c_\\theta \\in [3.39, 20.91]</span>, the complexity of TNFS-<span class="math">\\mathcal{B}</span> is better than the complexities of all previous algorithms whether classical or MNFS. The TMNFS-<span class="math">\\mathcal{B}</span> algorithm provides lower complexity compared to TNFS-<span class="math">\\mathcal{B}</span> algorithm; for <span class="math">c_\\theta \\in (0, 1.12] \\cup [1.45, 3.15]</span>, the complexity of TMNFS-<span class="math">\\mathcal{B}</span> is the same as that of the TMNFS-Conjugation and for <span class="math">c_\\theta \\notin (0, 1.12] \\cup [1.45, 3.15]</span>, the complexity of TMNFS-<span class="math">\\mathcal{B}</span> is lower than that of all previous methods. Figure 1 shows the plot of the asymptotic complexity for both TNFS-<span class="math">\\mathcal{B}</span> and MTNFS-<span class="math">\\mathcal{B}</span>.</p>

    <p class="text-gray-300">In this short note, we do not provide a background on the NFS algorithm. Instead, we refer to the above mentioned papers for a background on NFS and its variants as applied to the discrete logarithm problem.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Using LLL for Polynomial Selection</h2>

    <p class="text-gray-300">The method from [6] uses an idea earlier considered in [1]. We briefly mention this idea.</p>

    <p class="text-gray-300">Let <span class="math">\\varphi(x)</span> be a monic polynomial over the integers <span class="math">\\varphi(x) = x^n + \\varphi_{n-1}x^{n-1} + \\dots + \\varphi_1x + \\varphi_0</span> and <span class="math">r \\geq \\deg(\\varphi)</span> be an integer. Let <span class="math">n = \\deg(\\varphi)</span>. Given <span class="math">\\varphi(x)</span> and <span class="math">r</span>, define an <span class="math">(r+1) \\times (r+1)</span> matrix <span class="math">M_{\\varphi,r}</span> in the following manner.</p>

    <div class="my-4 text-center"><span class="math-block">M_{\\varphi,r} = \\left[ \\begin{array}{cccc} p &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p \\\\ \\varphi_0 &amp;amp; \\varphi_1 &amp;amp; \\dots &amp;amp; \\varphi_{n-1} &amp;amp; 1 \\\\ &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; &amp;amp; \\ddots \\\\ &amp;amp; &amp;amp; \\varphi_0 &amp;amp; \\varphi_1 &amp;amp; \\dots &amp;amp; \\varphi_{n-1} &amp;amp; 1 \\end{array} \\right] \\tag{1}</span></div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Complexity plot for medium prime case</p>

    <p class="text-gray-300">The first <span class="math">n \\times n</span> principal sub-matrix of <span class="math">M_{\\varphi, r}</span> is <span class="math">\\mathrm{diag}[p, p, \\ldots, p]</span> corresponding to the polynomials <span class="math">p, px, \\ldots, px^{n-1}</span>. The last <span class="math">r - n + 1</span> rows correspond to the polynomials <span class="math">\\varphi(x), x\\varphi(x), \\ldots, x^{r-n}\\varphi(x)</span>.</p>

    <p class="text-gray-300">Apply the LLL algorithm to <span class="math">M_{\\varphi, r}</span> and let the first row of the resulting LLL-reduced matrix be <span class="math">[g_0, g_1, \\ldots, g_{r-1}, g_r]</span>. Define</p>

    <div class="my-4 text-center"><span class="math-block">g(x) = g_0 + g_1 x + \\cdots + g_{r-1} x^{r-1} + g_r x^r. \\tag{2}</span></div>

    <p class="text-gray-300">The notation</p>

    <div class="my-4 text-center"><span class="math-block">g = \\mathrm{LLL} \\left(M_{\\varphi, r}\\right) \\tag{3}</span></div>

    <p class="text-gray-300">will be used to denote the polynomial <span class="math">g(x)</span> given by (2). By construction, <span class="math">\\varphi(x)</span> is a factor of <span class="math">g(x)</span> modulo <span class="math">p</span>.</p>

    <p class="text-gray-300">We show how to properly modify the polynomial selection method described in [6] to the TNFS variant.</p>

    <p class="text-gray-300">Consider the field <span class="math">\\mathbb{F}_{p^n}</span> where <span class="math">n = \\eta \\kappa</span> with <span class="math">\\gcd(\\eta, \\kappa) = 1</span>. Let <span class="math">h(z)</span> be an irreducible polynomial over <span class="math">\\mathbb{Z}</span> of degree <span class="math">\\eta</span> and <span class="math">R = \\mathbb{Z}[z] / (h(z))</span>. This is the basic set-up of the tower number field sieve algorithm.</p>

    <p class="text-gray-300">Let  <span class="math">A</span>  be a positive integer. Consider the set of all polynomials  <span class="math">\\phi(x)</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\phi (x) = \\phi_ {0} (z) + \\phi_ {1} (z) x + \\dots + \\phi_ {t - 1} (z) x ^ {t - 1},</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\phi_i(z) \\in \\mathbb{Z}[z]</span> ,  <span class="math">\\deg(\\phi_i) \\leq \\eta - 1</span>  and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq A<span class="math"> . The number of such polynomials  </span>\\phi(x)<span class="math">  is at most  </span>A^{\\eta t}<span class="math"> . We will call any such polynomial to be a sieving polynomial. Sieving is done using such polynomials  </span>\\phi(x)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define  <span class="math">E</span>  to be  <span class="math">E^2 = A^{\\eta t}</span>  and so  <span class="math">A^\\eta = E^{2 / t}</span> . So, the number of possible coefficient polynomials of  <span class="math">\\phi (x)</span>  is  <span class="math">E^{2 / t}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">f</span>  be an irreducible polynomial over the integers. Define</p>

    <div class="my-4 text-center"><span class="math-block">N _ {f} (\\phi) = \\operatorname {R e s} _ {t} \\left(\\operatorname {R e s} _ {x} \\left(\\phi (x), f (x)\\right), h (z)\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  is bounded by an absolute constant  </span>H<span class="math">  and  </span>p = L_Q(\\ell_p,c)<span class="math">  for some  </span>\\ell_p &gt; 1 / 3<span class="math">  and  </span>c &gt; 0$ , then following [2,4], it can be proved that the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N _ {f} (\\phi) \\leq E ^ {2 \\deg (f) / t} \\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}\\right) ^ {t - 1} L _ {Q} (2 / 3, o (1)).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Algorithm  <span class="math">\\mathcal{B}</span>  describes the extension of our previous method to the TNFS setting. Note that if  <span class="math">\\eta = 1</span> , then  <span class="math">\\kappa = n</span>  and  <span class="math">\\mathcal{B}</span>  becomes identical to the polynomial selection algorithm  <span class="math">\\mathcal{A}</span>  defined in [6]. The following result states the basic</p>

    <p class="text-gray-300">Algorithm:  <span class="math">\\mathcal{B}</span> : Polynomial selection for TNFS. Input:  <span class="math">p</span> ,  <span class="math">n = \\eta \\kappa</span> ,  <span class="math">d</span>  (a factor of  <span class="math">\\kappa</span> ) and  <span class="math">r \\geq \\kappa / d</span> . Output:  <span class="math">f(x)</span> ,  <span class="math">g(x)</span>  and  <span class="math">\\varphi(x)</span> . Let  <span class="math">k = \\kappa / d</span> ; repeat Randomly choose a monic irreducible polynomial  <span class="math">A_1(x)</span>  having the following properties:  <span class="math">\\deg A_1(x) = r + 1</span> ;  <span class="math">A_1(x)</span>  is irreducible over the integers;  <span class="math">A_1(x)</span>  has coefficients of size  <span class="math">O(\\ln(p))</span> ; modulo  <span class="math">p</span> ,  <span class="math">A_1(x)</span>  has an irreducible factor  <span class="math">A_2(x)</span>  of degree  <span class="math">k</span> . Randomly choose monic polynomials  <span class="math">C_0(x)</span>  and  <span class="math">C_1(x)</span>  with small coefficients such that  <span class="math">\\deg C_0(x) = d</span>  and  <span class="math">\\deg C_1(x) &amp;lt; d</span> . Define <span class="math">f(x) = \\operatorname{Res}_y(A_1(y), C_0(x) + yC_1(x))</span> ; <span class="math">\\varphi(x) = \\operatorname{Res}_y(A_2(y), C_0(x) + yC_1(x)) \\mod p</span> ; <span class="math">\\psi(x) = \\operatorname{LLL}(M_{A_2,r})</span> ; <span class="math">g(x) = \\operatorname{Res}_y(\\psi(y), C_0(x) + yC_1(x))</span> . until  <span class="math">f(x)</span>  and  <span class="math">g(x)</span>  are irreducible over  <span class="math">\\mathbb{Z}</span>  and  <span class="math">\\varphi(x)</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> . return  <span class="math">f(x)</span> ,  <span class="math">g(x)</span>  and  <span class="math">\\varphi(x)</span> .</p>

    <p class="text-gray-300">properties of Algorithm \\mathcal{B} .</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">The outputs <span class="math">f(x)</span>, <span class="math">g(x)</span> and <span class="math">\\varphi(x)</span> of Algorithm <span class="math">\\mathcal{B}</span> satisfy the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(f)=d(r+1)</span>; <span class="math">\\deg(g)=rd</span> and <span class="math">\\deg(\\varphi)=\\kappa</span>;</li>

      <li>both <span class="math">f(x)</span> and <span class="math">g(x)</span> have <span class="math">\\varphi(x)</span> as a factor modulo <span class="math">p</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(\\ln(p))<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(Q^{1/(d(r+1))})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, if <span class="math">\\phi</span> is a sieving polynomial, then</p>

    <p class="text-gray-300"><span class="math">N_{f}(\\phi)</span> <span class="math">=E^{2d(r+1)/t}\\times L_{Q}(2/3,o(1));</span> (4) <span class="math">N_{g}(\\phi)</span> <span class="math">=E^{2dr/t}\\times Q^{(t-1)/(d(r+1))}\\times L_{Q}(2/3,o(1));</span> (5) <span class="math">N_{f}(\\phi)\\times N_{g}(\\phi)</span> <span class="math">=E^{(2d(2r+1))/t}\\times Q^{(t-1)/(d(r+1))}L_{Q}(2/3,o(1)).</span> (6)</p>

    <p class="text-gray-300">We note the following points.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">d=1</span>, then the norm bound is <span class="math">E^{2(2r+1)/t}Q^{(t-1)/(r+1)}</span> which is the same as that obtained using the GJL method.</li>

      <li>If <span class="math">d=\\kappa</span>, then the norm bound is <span class="math">E^{2\\kappa(2r+1)/t}Q^{(t-1)/(\\kappa(r+1))}</span>. Further, if <span class="math">r=k=1</span>, then the norm bound is the same as that obtained using the Conjugation method. So, for <span class="math">d=\\kappa</span>, Algorithm <span class="math">\\mathcal{B}</span> is a generalisation of the Conjugation method.</li>

      <li>If <span class="math">\\kappa</span> is a prime, then the only values of <span class="math">d</span> are either <span class="math">1</span> or <span class="math">n</span>. The norm bounds in these two cases are covered by the above two points.</li>

      <li>If <span class="math">\\kappa</span> is composite, then there are non-trivial values for <span class="math">d</span> and it is possible to obtain new trade-offs in the norm bound. For concrete situations, this can be of interest. Further, for composite <span class="math">\\kappa</span>, as value of <span class="math">d</span> increases from <span class="math">d=1</span> to <span class="math">d=\\kappa</span>, the norm bound nicely interpolates between the norm bounds of the GJL method and the Conjugation method.</li>

    </ol>

    <h2 id="sec-7" class="text-2xl font-bold">4 Examples</h2>

    <p class="text-gray-300">In this section, we present some of the examples, generated by new polynomial selection algorithm.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Example 1.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> is a 201-bit prime given below.</p>

    <p class="text-gray-300"><span class="math">p=1606938044258990275541962092341162602522202993782792835301611</span> (7)</p>

    <p class="text-gray-300">and <span class="math">n=6</span>. To apply the new polynomial selection algorithm, we have to choose <span class="math">\\eta</span> and <span class="math">\\kappa</span> such that <span class="math">\\eta\\kappa=n</span> and <span class="math">\\gcd(\\eta,\\kappa)=1</span>. We have the following two choices of <span class="math">(\\eta,\\kappa)</span>.</p>

    <p class="text-gray-300">Case 1: Let <span class="math">(\\eta, \\kappa) = (2,3)</span>. Choose <span class="math">d = \\kappa</span>, and so <span class="math">k = \\kappa / d = 1</span>. Taking <span class="math">r = k</span>, we get the following polynomials.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} h(x) = x^{2} + 14x + 20 \\\\ f(x) = x^{6} + 5x^{5} + 6x^{4} + 18x^{3} + 73x^{2} + 52x + 20 \\\\ g(x) = 516378785784706099560748701401x^{3} + 1874354673374387667869084608560x^{2} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>459276162276102007999766811670x + 1683194203609950937495174411516 \\\\</li>

    </ul>

    <p class="text-gray-300">\\phi(x) = x^{3} + 4370464675316262929768958368698673612607491294431378655895x^{2} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>13111394025948788789306875106096020837822473883294135967675x \\\\</li>

      <li>8740929350632525859537916737397347225214982588862757311786 \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, the above polynomials represent the polynomials generated by Conjugation method and we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{100}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we choose <span class="math">r = k + 1</span> i.e., <span class="math">r = 2</span>, we get the following polynomials.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} h(x) = x^{2} + x + 20 \\\\ f(x) = x^{9} + 14x^{8} + 74x^{7} + 183x^{6} + 200x^{5} - 32x^{4} - 375x^{3} - 232x^{2} - 48x - 1 \\\\ g(x) = 46647198736133019425x^{6} + 530869201059776791498x^{5} + 2094297655062561189093x^{4} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3465328474724235168588x^{3} + 2717008192279799547052x^{2} \\\\</li>

      <li>1322043132032704860464x + 290748395825577445032 \\\\</li>

    </ul>

    <p class="text-gray-300">\\phi(x) = x^{3} + 315444052193803149917391335705534526435873425227915090402562x^{2} \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1261776208775212599669565342822138105743493700911660361610232x \\\\</li>

      <li>315444052193803149917391335705534526435873425227915090402559 \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{71}<span class="math">. Thus taking </span>r &gt; k$, gives us the polynomials which are not obtained by Conjugation method.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 2: Let <span class="math">(\\eta, \\kappa) = (3,2)</span>. Taking <span class="math">d = \\kappa</span> and <span class="math">r = 1</span>, we get the following polynomials.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} h(x) = x^{3} + x^{2} + 15x + 7 \\\\ f(x) = x^{4} - x^{3} - 2x^{2} - 7x - 3 \\\\ g(x) = 717175561486984577278242843019x^{2} + 2189435313197775056442946543188x \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2906610874684759633721189386207 \\\\</li>

    </ul>

    <p class="text-gray-300">\\phi(x) = x^{2} + 131396875851816610915684123600060137654000542337369130402554x \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>131396875851816610915684123600060137654000542337369130402555 \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{101}<span class="math">. If we take </span>d=\\kappa<span class="math"> and </span>r=2<span class="math">, we get the following set of polynomials where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{69}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h(x)</span> <span class="math">=x^{3}+x^{2}+{}_{15}x+{}_{7}</span> <span class="math">f(x)</span> <span class="math">=x^{6}-{}_{4}x^{5}-{}_{53}x^{4}-{}_{147}x^{3}-{}_{188}x^{2}-{}_{157}x-{}_{92}</span> <span class="math">g(x)</span> <span class="math">={}_{15087279002722300985}x^{4}+{}_{124616743720753879934}x^{3}+{}_{451785460058994237397}x^{2}</span> <span class="math">\\qquad\\qquad\\qquad+{}_{749764394939964245000}x+{}_{567202989572349792620}</span> <span class="math">\\phi(x)</span> <span class="math">=x^{2}+{}_{459743211307624787973091830151418256356779099860453048165628}x</span> <span class="math">\\qquad\\qquad\\qquad+{}_{1379229633922874363919275490454254769070337299581359144496879}</span></p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Example 2</h6>

    <p class="text-gray-300">Consider the same prime <span class="math">p</span> given by the equation (7). Let <span class="math">n=12</span>. Choose <span class="math">\\eta=3</span> and <span class="math">\\kappa=4</span>. We can now apply the new polynomial selection method by taking <span class="math">d</span> a divisor of <span class="math">\\kappa</span>. Note that for <span class="math">d=1</span>, we get the polynomials which are generated by GJL method, and for <span class="math">d=\\kappa</span> and <span class="math">r=\\kappa/d</span>, we get the polynomials which are generated by Conjugation method.</p>

    <p class="text-gray-300">Let us take <span class="math">d=2</span> and so <span class="math">k=\\kappa/d=2</span>. Choosing <span class="math">r=2</span>, we get the following polynomials using the new polynomial selection method.</p>

    <p class="text-gray-300"><span class="math">h(x)</span> <span class="math">=x^{3}+{}_{6}x^{2}+{}_{17}x+{}_{9}</span> <span class="math">f(x)</span> <span class="math">=x^{6}+{}_{5}x^{5}-{}_{30}x^{4}-{}_{266}x^{3}-{}_{676}x^{2}-{}_{708}x-{}_{272}</span> <span class="math">g(x)</span> <span class="math">={}_{6467759678841805870369474068891432876119}x^{4}+{}_{6502041296101468515405699029621}</span> <span class="math">\\qquad\\qquad\\qquad{}_{6084937901}x^{3}+{}_{222170443795536450104732978193530615480075}x^{2}+{}_{288848458312}</span> <span class="math">\\qquad\\qquad\\qquad{}_{346890039868803933886050843398}x+{}_{131565328984563790448827928636681124756276}</span> <span class="math">\\phi(x)</span> <span class="math">=x^{4}+{}_{524836704622542585952303793367376227408021565148774944064926}x^{3}</span> <span class="math">\\qquad\\qquad\\qquad+{}_{412331973798848955780775364051098068524174598906061062223842}x^{2}</span> <span class="math">\\qquad\\qquad\\qquad+{}_{729366207515760721958696718425775500473208458672566373192896}x</span> <span class="math">\\qquad\\qquad\\qquad+{}_{794222068298485757328798142903843341069485055345502379406598}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx 2^{137}$ and these polynomials are neither covered by GJL method nor by Conjugation method.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">5 Asymptotic Complexity Analysis for the Medium Prime Case</h2>

    <p class="text-gray-300">For <span class="math">1/3&lt;a&lt;2/3</span>, write</p>

    <p class="text-gray-300"><span class="math">p=L_{Q}(a,c_{p}),\\text{ where }c_{p}=\\frac{1}{n}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}\\text{ and so }n=\\frac{1}{c_{p}}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{1-a}.</span> (8)</p>

    <p class="text-gray-300">For each <span class="math">c_{p}</span>, the runtime of the NFS algorithm is the same for the family of finite fields <span class="math">\\mathbb{F}_{p^{n}}</span> where <span class="math">p</span> is given by (8).</p>

    <p class="text-gray-300">Recall that <span class="math">n=\\eta\\kappa</span> where <span class="math">\\gcd(\\eta,\\kappa)=1</span>. Suppose <span class="math">\\eta</span> can be written as</p>

    <p class="text-gray-300"><span class="math">\\eta=c_{\\eta}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{2/3-a}.</span> (9)</p>

    <p class="text-gray-300">Define <span class="math">P=p^{\\eta}</span>. Then</p>

    <p class="text-gray-300"><span class="math">P</span> <span class="math">=L_{Q}(a,c_{p}\\eta)</span> <span class="math">=\\exp\\left(c_{p}\\eta(\\ln Q)^{a}(\\ln\\ln Q)^{1-a}\\right)</span> <span class="math">=\\exp\\left(c_{p}c_{\\eta}\\left(\\frac{\\ln Q}{\\ln\\ln Q}\\right)^{2/3-a}(\\ln Q)^{a}(\\ln\\ln Q)^{1-a}\\right)</span> <span class="math">=\\exp\\left(c_{p}c_{\\eta}(\\ln Q)^{2/3}(\\ln\\ln Q)^{1/3}\\right)</span> <span class="math">=L_{Q}(2/3,c_{p}c_{\\eta}).</span> (10)</p>

    <p class="text-gray-300">So, if <span class="math">p</span> is a medium prime with <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a&lt;2/3</span> and <span class="math">\\eta</span> is given by (9), then <span class="math">P</span> is of the form <span class="math">L_{Q}(2/3,c_{p}c_{\\eta})</span>, i.e., its size corresponds to the boundary case of NFS. The tower number field sieve considers an extension of degree <span class="math">\\kappa</span> over <span class="math">P</span>. So, the extension of degree <span class="math">\\eta\\kappa</span> over a medium size prime <span class="math">p</span> is transformed into an extension of degree <span class="math">\\kappa</span> over a boundary case size prime power <span class="math">P</span>. Consequently, for such a situation, the asymptotic results obtained earlier for the boundary case can be translated to the medium size case.</p>

    <p class="text-gray-300">We recall the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of polynomials to be considered for sieving is <span class="math">E^{2}</span>.</li>

      <li>The factor base is of size <span class="math">B</span>.</li>

    </ol>

    <p class="text-gray-300">Sparse linear algebra using the Lanczos or the block Wiedemann algorithm takes time <span class="math">O(B^{2})</span>. For some <span class="math">0&lt;b&lt;1</span>, let</p>

    <p class="text-gray-300"><span class="math">B=L_{Q}(b,c_{b}).</span> (11)</p>

    <p class="text-gray-300">The value of <span class="math">b</span> will be determined later. Set</p>

    <p class="text-gray-300"><span class="math">E=B</span> (12)</p>

    <p class="text-gray-300">so that asymptotically, the number of sieving polynomials is equal to the time for the linear algebra step.</p>

    <p class="text-gray-300">Let <span class="math">\\pi=\\Psi(\\Gamma,B)</span> be the probability that a random positive integer which is at most <span class="math">\\Gamma</span> is <span class="math">B</span>-smooth. Let <span class="math">\\Gamma=L_{Q}(z,\\zeta)</span> and <span class="math">B=L_{Q}(b,c_{b})</span>. Using the L-notation version of the Canfield-Erdös-Pomerance theorem,</p>

    <p class="text-gray-300"><span class="math">\\left(\\Psi(\\Gamma,B)\\right)^{-1}=L_{Q}\\left(z-b,(z-b)\\frac{\\zeta}{c_{b}}\\right).</span> (13)</p>

    <p class="text-gray-300">Following the usual convention, we assume that the same smoothness probability <span class="math">\\pi</span> holds for the event that a random sieving polynomial <span class="math">\\phi(x)</span> is smooth over the factor base.</p>

    <p class="text-gray-300">The expected number of polynomials to consider for obtaining one relation is <span class="math">\\pi^{-1}</span>. Since <span class="math">B</span> relations are required, obtaining this number of relations requires trying <span class="math">B\\pi^{-1}</span> trials. Balancing the cost of sieving and the linear algebra steps requires <span class="math">B\\pi^{-1} = B^2</span> and so</p>

    <div class="my-4 text-center"><span class="math-block">\\pi^{-1} = B. \\tag{14}</span></div>

    <p class="text-gray-300">Obtaining <span class="math">\\pi^{-1}</span> from (13) and setting it to be equal to <span class="math">B</span> allows solving for <span class="math">c_b</span>. Balancing the costs of the sieving and the linear algebra phases leads to the runtime of the NFS algorithm to be <span class="math">B^2 = L_Q(b, 2c_b)</span>. So, to determine the runtime, we need to determine <span class="math">b</span> and <span class="math">c_b</span>. The value of <span class="math">b</span> will turn out to be <span class="math">1/3</span> and the only real issue is the value of <span class="math">c_b</span>.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let <span class="math">n = \\eta \\kappa</span> and <span class="math">\\kappa = kd</span> for positive integers <span class="math">\\eta, k</span> and <span class="math">d</span>. Using the expressions for <span class="math">p</span> and <span class="math">E(= B)</span> given by (8) and (11), we obtain the following.</p>

    <div class="my-4 text-center"><span class="math-block">\\left. \\begin{aligned} E^{\\frac{2}{1} d(2r+1)} &amp;amp;= L_Q\\left(1 - a + b, \\frac{2c_b(2r+1)}{c_p \\eta kt}\\right); \\\\ Q^{\\frac{t-1}{d(r+1)}} &amp;amp;= L_Q\\left(a, \\frac{kc_p \\eta(t-1)}{(r+1)}\\right). \\end{aligned} \\right\\} \\tag{15}</span></div>

    <p class="text-gray-300">If further <span class="math">\\eta = c_{\\eta}(\\ln Q / \\ln \\ln Q)^{2/3 - a}</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\left. \\begin{aligned} E^{\\frac{2}{1} d(2r+1)} &amp;amp;= L_Q\\left(1/3 + b, \\frac{2c_b(2r+1)}{c_p c_{\\eta} kt}\\right); \\\\ Q^{\\frac{t-1}{d(r+1)}} &amp;amp;= L_Q\\left(2/3, \\frac{kc_p c_{\\eta}(t-1)}{(r+1)}\\right). \\end{aligned} \\right\\} \\tag{16}</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> The second expression follows directly from <span class="math">Q = p^n</span>, <span class="math">p = L_Q(a, c_p)</span> and <span class="math">n = \\eta kd</span>. The computation for obtaining the first expression is the following.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} E^{\\frac{2}{1} d(2r+1)} &amp;amp;= L_Q\\left(b, c_b \\frac{2}{t} d(2r+1)\\right) \\\\ &amp;amp;= \\exp\\left(c_b \\frac{2}{t} (2r+1) \\frac{n}{k \\eta} (\\ln Q)^b (\\ln \\ln Q)^{1-b}\\right) \\\\ &amp;amp;= \\exp\\left(c_b \\frac{2}{c_p \\eta kt} (2r+1) \\left(\\frac{\\ln Q}{\\ln \\ln Q}\\right)^{1-a} (\\ln Q)^b (\\ln \\ln Q)^{1-b}\\right) \\\\ &amp;amp;= L_Q\\left(1 - a + b, \\frac{2c_b(2r+1)}{c_p \\eta kt}\\right). \\end{aligned}</span></div>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let <span class="math">n = \\eta \\kappa</span>; <span class="math">\\gcd(\\eta, \\kappa) = 1</span>; <span class="math">\\kappa = kd</span>; <span class="math">r \\geq k</span>; <span class="math">t \\geq 2</span>; <span class="math">p = L_Q(a, c_p)</span> with <span class="math">1/3 &amp;lt; a &amp;lt; 2/3</span> and <span class="math">0 &amp;lt; c_p &amp;lt; 1</span>; and <span class="math">\\eta = c_{\\eta}(\\ln Q / \\ln \\ln Q)^{2/3 - a}</span>. It is possible to ensure that the runtime of the NFS algorithm with polynomials chosen by Algorithm <span class="math">\\mathcal{B}</span> is <span class="math">L_Q(1/3, 2c_b)</span> where</p>

    <div class="my-4 text-center"><span class="math-block">c_b = \\frac{2r+1}{3c_\\theta kt} + \\sqrt{\\left(\\frac{2r+1}{3c_\\theta kt}\\right)^2 + \\frac{kc_\\theta(t-1)}{3(r+1)}} \\quad \\text{and} \\tag{17}</span></div>

    <div class="my-4 text-center"><span class="math-block">c_\\theta = c_p c_{\\eta}. \\tag{18}</span></div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Setting <span class="math">b=1/3</span>, the two <span class="math">L</span>-expressions given by (16) have the same first component and so the product of the norms is</p>

    <p class="text-gray-300"><span class="math">\\Gamma</span> <span class="math">=L_{Q}\\left(\\frac{2}{3},\\frac{2c_{b}(2r+1)}{c_{p}c_{\\eta}kt}+\\frac{kc_{p}c_{\\eta}(t-1)}{(r+1)}\\right)</span> <span class="math">=L_{Q}\\left(\\frac{2}{3},\\frac{2c_{b}(2r+1)}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{(r+1)}\\right).</span></p>

    <p class="text-gray-300">Then <span class="math">\\pi^{-1}</span> given by (13) is</p>

    <p class="text-gray-300"><span class="math">L_{Q}\\left(\\frac{1}{3},\\frac{1}{3}\\left(\\frac{2(2r+1)}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{c_{b}(r+1)}\\right)\\right).</span></p>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1}=B</span>, we get</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{1}{3}\\left(\\frac{2(2r+1)}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{c_{b}(r+1)}\\right).</span> (19)</p>

    <p class="text-gray-300">Solving the quadratic for <span class="math">c_{b}</span> and choosing the positive root gives</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2r+1}{3c_{\\theta}kt}+\\sqrt{\\left(\\frac{2r+1}{3c_{\\theta}kt}\\right)^{2}+\\frac{kc_{\\theta}(t-1)}{3(r+1)}}.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Note that <span class="math">c_{b}</span> is minimised at <span class="math">c_{p}c_{\\eta}=c_{\\theta}=12^{1/3}</span> whence the corresponding complexity of the TNFS algorithm is <span class="math">L_{Q}(1/3,(48/9)^{1/3})</span>.</p>

    <h2 id="sec-12" class="text-2xl font-bold">6 Multiple Number Field Sieve Variant</h2>

    <p class="text-gray-300">There are two variants of multiple number field sieve algorithm. In the first variant, the image of <span class="math">\\phi(x)</span> needs to be smooth in at least any two of the number fields. In the second variant, the image of <span class="math">\\phi(x)</span> needs to be smooth in the first number field and at least one of the other number fields. We discuss the second variant of MNFS only. In contrast to the number field sieve algorithm, the right number field is replaced by a collection of <span class="math">V</span> number fields in the second variant of MNFS. The sieving polynomial <span class="math">\\phi(x)</span> has to satisfy the smoothness condition on the left number field as before. On the right side, it is sufficient for <span class="math">\\phi(x)</span> to satisfy a smoothness condition on at least one of the <span class="math">V</span> number fields.</p>

    <p class="text-gray-300">Recall that Algorithm <span class="math">\\mathcal{B}</span> produces two polynomials <span class="math">f(x)</span> and <span class="math">g(x)</span> of degrees <span class="math">d(r+1)</span> and <span class="math">dr</span> respectively. The polynomial <span class="math">g(x)</span> is defined as <span class="math">\\text{Res}_{y}(\\psi(y),C_{0}(x)+yC_{1}(x))</span> where <span class="math">\\psi(x)=\\text{LLL}(M_{A_{2},r})</span>, i.e., <span class="math">\\psi(x)</span> is defined from the first row of the matrix obtained after applying the LLL-algorithm to <span class="math">M_{A_{2},r}</span>.</p>

    <p class="text-gray-300">Methods for obtaining the collection of number fields on the right have been mentioned in <em>[5]</em>. We adapt one of these methods to our setting. Consider Algorithm <span class="math">\\mathcal{B}</span>. Let <span class="math">\\psi_{1}(x)</span> be <span class="math">\\psi(x)</span> as above and let <span class="math">\\psi_{2}(x)</span> be the polynomial defined from</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the second row of the matrix <span class="math">M_{A_{2},r}</span>. Define <span class="math">g_{1}(x)=\\mathrm{Res}_{y}(\\psi_{1}(y),C_{0}(x)+yC_{1}(x))</span> and <span class="math">g_{2}(x)=\\mathrm{Res}_{y}(\\psi_{2}(y),C_{0}(x)+yC_{1}(x))</span>. Then choose <span class="math">V-2</span> linear combinations <span class="math">g_{i}(x)=s_{i}g_{1}(x)+t_{i}g_{2}(x)</span>, for <span class="math">i=3,\\ldots,V</span>. Note that the coefficients <span class="math">s_{i}</span> and <span class="math">t_{i}</span> are of the size of <span class="math">\\sqrt{V}</span>. All the <span class="math">g_{i}</span>’s have degree <span class="math">dr</span>. Asymptotically, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=Q^{1/(d(r+1))}<span class="math">. Since we take </span>V=L_{Q}(1/3)<span class="math">, all the </span>g_{i}<span class="math">’s have their infinity norms to be the same as that of </span>g(x)$ given by Proposition 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the left number field, as before, let <span class="math">B</span> be the bound on the norms of the ideals which are in the factor basis defined by <span class="math">f</span>. For each of the right number fields, let <span class="math">B^{\\prime}</span> be the bound on the norms of the ideals which are in the factor basis defined by each of the <span class="math">g_{i}</span>’s. So, the size of the entire factor basis is <span class="math">B+VB^{\\prime}</span>. The following condition balances the left portion and the right portion of the factor basis.</p>

    <p class="text-gray-300"><span class="math">B=VB^{\\prime}.</span> (20)</p>

    <p class="text-gray-300">With this condition, the size of the factor basis is <span class="math">B^{1+o(1)}</span> as in the classical NFS and so asymptotically, the linear algebra step takes time <span class="math">B^{2}</span>. As before, the number of sieving polynomials is <span class="math">E^{2}=B^{2}</span> and the coefficient polynomials of <span class="math">\\phi(x)</span> can take <span class="math">E^{2/t}</span> distinct values.</p>

    <p class="text-gray-300">Let <span class="math">\\pi</span> be the probability that a random sieving polynomial <span class="math">\\phi(x)</span> gives rise to a relation. Let <span class="math">\\pi_{1}</span> be the probability that <span class="math">\\phi(x)</span> is smooth over the left factor basis and <span class="math">\\pi_{2}</span> be the probability that <span class="math">\\phi(x)</span> is smooth over at least one of the right factor bases. Further, let <span class="math">\\Gamma_{1}=\\mathrm{Res}_{x}(f(x),\\phi(x))</span> be the bound on the norm corresponding to the left number field and <span class="math">\\Gamma_{2}=\\mathrm{Res}_{x}(g_{i}(x),\\phi(x))</span> be the bound on the norm for any of the right number fields. Note that <span class="math">\\Gamma_{2}</span> is determined only by the degree and the <span class="math">L_{\\infty}</span>-norm of <span class="math">g_{i}(x)</span> and hence is the same for all <span class="math">g_{i}(x)</span>’s. Heuristically, we have</p>

    <p class="text-gray-300"><span class="math">\\pi_{1}</span> <span class="math">=\\Psi(\\Gamma_{1},B);</span> (21) <span class="math">\\pi_{2}</span> <span class="math">=V\\Psi(\\Gamma_{2},B^{\\prime});</span> <span class="math">\\pi</span> <span class="math">=\\pi_{1}\\times\\pi_{2}.</span></p>

    <p class="text-gray-300">As before, one relation is obtained in about <span class="math">\\pi^{-1}</span> trials and so <span class="math">B</span> relations are obtained in about <span class="math">B\\pi^{-1}</span> trials. Balancing the cost of linear algebra and sieving, we have as before <span class="math">B=\\pi^{-1}</span>.</p>

    <p class="text-gray-300">The following choices of <span class="math">B</span> and <span class="math">V</span> are made.</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{r}E=B=L_{Q}\\left(\\frac{1}{3},c_{b}\\right);\\\\ V=L_{Q}\\left(\\frac{1}{3},c_{v}\\right);\\text{ and so}\\\\ B^{\\prime}=B/V=L_{Q}\\left(\\frac{1}{3},c_{b}-c_{v}\\right).\\end{array} \\] (22)</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Let <span class="math">n=\\eta\\kappa</span>; <span class="math">\\gcd(\\eta,\\kappa)=1</span>; <span class="math">\\kappa=kd</span>; <span class="math">r\\geq k</span>; <span class="math">t\\geq 2</span>; <span class="math">p=L_{Q}(a,c_{p})</span> with <span class="math">1/3&lt;a&lt;2/3</span> and <span class="math">0&lt;c_{p}&lt;1</span>; and <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln\\ln Q)^{2/3-a}</span>. It is possible to ensure that the runtime of the MNFS algorithm is <span class="math">L_{Q}(1/3,2c_{b})</span> where</p>

    <p class="text-gray-300"><span class="math">c_{b}</span> <span class="math">=\\frac{4r+2}{6ktc_{\\theta}}+\\sqrt{\\frac{r(3r+2)}{(3ktc_{\\theta})^{2}}+\\frac{c_{\\theta}k(t-1)}{3(r+1)}}\\text{ and}</span> (23) <span class="math">c_{\\theta}</span> <span class="math">=c_{p}c_{\\eta}.</span></p>

    <p class="text-gray-300">Proof. Note the following computations. For a sieving polynomial <span class="math">\\phi</span>,</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{1}</span> <span class="math">=N_{f}(\\phi)</span> <span class="math">=E^{(2d(r+1))/t}L_{Q}(2/3,o(1))</span> <span class="math">=E^{(2n(r+1))/(\\eta kt)}</span> <span class="math">=L_{Q}\\left(\\frac{2}{3},\\frac{2(r+1)c_{b}}{ktc_{p}c_{\\eta}}\\right);</span> <span class="math">\\pi_{1}^{-1}</span> <span class="math">=L_{Q}\\left(\\frac{1}{3},\\frac{2(r+1)}{3ktc_{\\theta}}\\right);</span> <span class="math">\\Gamma_{2}</span> <span class="math">=N_{g}(\\phi)</span> <span class="math">=E^{(2rd)/t}\\times Q^{(t-1)/(d(r+1))}L_{Q}(2/3,o(1)</span> <span class="math">=E^{(2rn)/(\\eta kt)}\\times Q^{\\eta k(t-1)/(n(r+1))}</span> <span class="math">=L_{Q}\\left(\\frac{2}{3},\\frac{2rc_{b}}{c_{p}c_{\\eta}kt}+\\frac{kc_{p}c_{\\eta}(t-1)}{r+1}\\right);</span> <span class="math">\\pi_{2}^{-1}</span> <span class="math">=L_{Q}\\left(\\frac{1}{3},-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2rc_{b}}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{r+1}\\right)\\right);</span> <span class="math">\\pi^{-1}</span> <span class="math">=L_{Q}\\left(\\frac{1}{3},\\frac{2(r+1)}{3ktc_{\\theta}}-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2rc_{b}}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{r+1}\\right)\\right);</span></p>

    <p class="text-gray-300">From the condition <span class="math">\\pi^{-1}=B</span>, we obtain the following equation.</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{2(r+1)}{3ktc_{p}c_{\\eta}}-c_{v}+\\frac{1}{3(c_{b}-c_{v})}\\left(\\frac{2rc_{b}}{c_{\\theta}kt}+\\frac{kc_{\\theta}(t-1)}{r+1}\\right).</span> (24)</p>

    <p class="text-gray-300">We wish to find <span class="math">c_{v}</span> such that <span class="math">c_{b}</span> is minimised subject to the constraint (24). Using the method of Lagrange multipliers, the partial derivative of (24) with respect to <span class="math">c_{v}</span> gives</p>

    <p class="text-gray-300"><span class="math">c_{v}=\\frac{r+1}{3ktc_{\\theta}}.</span></p>

    <p class="text-gray-300">Using this value of <span class="math">c_{v}</span> in (24) provides the following quadratic in <span class="math">c_{b}</span>.</p>

    <p class="text-gray-300"><span class="math">(3ktc_{\\theta})c_{b}^{2}-(4r+2)c_{b}+\\frac{(r+1)^{2}}{3ktc_{\\theta}}-\\frac{(c_{\\theta}k)^{2}t(t-1)}{r+1}=0.</span></p>

    <p class="text-gray-300">Solving this and taking the positive square root, we obtain</p>

    <p class="text-gray-300"><span class="math">c_{b}=\\frac{4r+2}{6ktc_{\\theta}}+\\sqrt{\\frac{r(3r+2)}{(3ktc_{\\theta})^{2}}+\\frac{c_{\\theta}k(t-1)}{3(r+1)}}.</span> (25)</p>

    <p class="text-gray-300">Hence the overall complexity of MNFS for the boundary case is <span class="math">L_{Q}\\left(\\frac{1}{3},2c_{b}\\right)</span>. ∎</p>

    <p class="text-gray-300">From Theorem 2, the entire analysis carried out in Sections 8.1 and 8.2 of <em>[6]</em> apply with the constant <span class="math">c_{p}</span> replaced by <span class="math">c_{\\theta}</span> leading to the new asymptotic complexity results for the medium prime case that has been mentioned in the introduction.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and François Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, volume 9056 of Lecture Notes in Computer Science, pages 129–155. Springer, 2015.</li>

      <li>[2] Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 31–55. Springer, 2015.</li>

      <li>[3] Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 326–344. Springer, 2006.</li>

      <li>[4] Taechan Kim and Razvan Barbulescu. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/.</li>

      <li>[5] Cécile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 156–170, 2015.</li>

      <li>[6] Palash Sarkar and Shashank Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. Cryptology ePrint Archive, Report 2015/944, 2015. http://eprint.iacr.org/.</li>

    </ul>`;
---

<BaseLayout title="Tower Number Field Sieve Variant of a Recent Polynomial Sele... (2016/401)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/401
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
