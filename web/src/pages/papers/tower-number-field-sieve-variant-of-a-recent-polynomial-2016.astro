---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/401';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Tower Number Field Sieve Variant of a Recent Polynomial Selection Method';
const AUTHORS_HTML = 'Palash Sarkar and Shashank Singh';

const CONTENT = `    <p class="text-gray-300">Palash Sarkar and Shashank Singh</p>

    <p class="text-gray-300">Applied Statistics Unit Indian Statistical Institute palash@isical.ac.in, sha2nk.singh@gmail.com</p>

    <p class="text-gray-300">Abstract. At Asiacrypt 2015, Barbulescu et al. performed a thorough analysis of the tower number field sieve (TNFS) variant of the number field sieve algorithm. More recently, Kim and Barbulescu combined the TNFS variant with several polynomial selection methods including the Generalised Joux-Lercier method and the Conjugation method proposed by Barbulescu et al. at Eurocrypt 2015. Sarkar and Singh (Eurocrypt 2016) proposed a polynomial selection method which subsumes both the GJL and the Conjugation methods. This study was done in the context of the NFS and the multiple NFS (MNFS). The purpose of the present note is to show that the polynomial selection method of Sarkar and Singh subsumes the GJL and the Conjugation methods also in the context of the TNFS and the multiple TNFS variants. This was not clear from the recent work by Kim and Barbulescu. Applying the new polynomial selection method to the TNFS variants results in new asymptotic complexities for certain ranges of primes.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">There has been a recent increase in the interest of applying the number field sieve (NFS) algorithms and its several variants to the study of the discrete logarithm problem on finite fields Fp&lt;sup&gt;n&lt;/sup&gt; with n &gt; 1. The work by Barbulescu et al. [1] at Eurocrypt 2015 proposed two new methods for polynomial selections and worked out the asymptotic complexities of these methods as applied to the NFS algorithm. These polynomial selection methods were named the generalised Joux-Lercier (GJL) method and the Conjugation method. At the same conference, Pierrot [5] showed how to combine these polynomial selection methods with the multiple NFS (MNFS) variant [5] and worked out the corresponding asymptotic complexities. Sarkar and Singh (Eurocrypt 2016) proposed [6] a new polynomial selection method which subsumes both the GJL and the Conjugation methods. Using this method, the asymptotic complexity of both the NFS and the MNFS were worked out in [6].</p>

    <p class="text-gray-300">At Asiacrypt 2015, Barbulescu et al., [2] presented a detailed analysis of the tower number field sieve (TNFS) variant. In a recent paper, Kim and Barbulescu [4] applied previous polynomial selection methods to the TNFS, the multiple TNFS (MTNFS) and the special TNFS variants. The polynomial selection methods considered in [4] include the methods from Joux-Lercier-Smart-Vercauteren [3], the GJL and the Conjugation methods from [1] and the polynomial selection method from [6]. The discussion in [4] does not make it clear that the polynomial selection method from [6] subsumes the GJL and the Conjugation methods in the context of TNFS.</p>

    <p class="text-gray-300">The main point of the present note is to properly apply the polynomial selection method of Sarkar and Singh [6] to TNFS. Once this is done, it once more follows that the polynomial selection method from [6] subsumes the GJL and the Conjugation methods for the TNFS variant also.</p>

    <p class="text-gray-300">The polynomial selection method considered in [6] has been called  <span class="math">\\mathcal{A}</span> . The modification considered here provides a generalisation of  <span class="math">\\mathcal{A}</span>  and let us denote the generalisation as  <span class="math">\\mathcal{B}</span> . Let the variant of TNFS obtained by using  <span class="math">\\mathcal{B}</span>  be denoted by TNFS- <span class="math">\\mathcal{B}</span>  and similarly denote MTNFS- <span class="math">\\mathcal{B}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">Q=p^n</span> , where  <span class="math">n=\\eta\\kappa</span>  and  <span class="math">\\gcd(\\eta,\\kappa)=1</span> . Suppose that  <span class="math">p=L_Q(a,c_p)</span>  for some a in (1/3,2/3) where  <span class="math">L_Q</span>  is the usual sub-exponential notation. Further suppose that  <span class="math">\\eta</span>  can be written as  <span class="math">\\eta=c_{\\eta}(\\ln Q/\\ln \\ln Q)^{2/3-a}</span>  and let  <span class="math">c_{\\theta}=c_{p}c_{\\eta}</span> . For this setting, the following new asymptotic results are obtained: For  <span class="math">c_{\\theta}\\in[3.39,20.91]</span> , the complexity of TNFS- <span class="math">\\mathcal{B}</span>  is better than the complexities of all previous algorithms whether classical or MNFS. The TMNFS- <span class="math">\\mathcal{B}</span>  algorithm provides lower complexity compared to TNFS- <span class="math">\\mathcal{B}</span>  algorithm; for  <span class="math">c_{\\theta}\\in(0,1.12]\\cup[1.45,3.15]</span> , the complexity of TMNFS- <span class="math">\\mathcal{B}</span>  is the same as that of the TMNFS-Conjugation and for  <span class="math">c_{\\theta}\\notin(0,1.12]\\cup[1.45,3.15]</span> , the complexity of TMNFS- <span class="math">\\mathcal{B}</span>  is lower than that of all previous methods. Figure 1 shows the plot of the asymptotic complexity for both TNFS- <span class="math">\\mathcal{B}</span>  and MTNFS- <span class="math">\\mathcal{B}</span> .</p>

    <p class="text-gray-300">In this short note, we do not provide a background on the NFS algorithm. Instead, we refer to the above mentioned papers for a background on NFS and its variants as applied to the discrete logarithm problem.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">2 Using LLL for Polynomial Selection</h4>

    <p class="text-gray-300">The method from [6] uses an idea earlier considered in [1]. We briefly mention this idea.</p>

    <p class="text-gray-300">Let  <span class="math">\\varphi(x)</span>  be a monic polynomial over the integers  <span class="math">\\varphi(x) = x^n + \\varphi_{n-1}x^{n-1} + \\cdots + \\varphi_1 x + \\varphi_0</span>  and  <span class="math">r \\ge \\deg(\\varphi)</span>  be an integer. Let  <span class="math">n = \\deg(\\varphi)</span> . Given  <span class="math">\\varphi(x)</span>  and r, define an  <span class="math">(r+1) \\times (r+1)</span>  matrix  <span class="math">M_{\\varphi,r}</span>  in the following manner.</p>

    <p class="text-gray-300"><span class="math">$M_{\\varphi,r} = \\begin{bmatrix} p &amp; &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; &amp; \\\\ &amp; &amp; p &amp; &amp; \\\\ \\varphi_0 &amp; \\varphi_1 &amp; \\cdots &amp; \\varphi_{n-1} &amp; 1 &amp; \\\\ &amp; &amp; \\ddots &amp; \\ddots &amp; &amp; \\ddots \\\\ &amp; &amp; \\varphi_0 &amp; \\varphi_1 &amp; \\cdots &amp; \\varphi_{n-1} &amp; 1 \\end{bmatrix}</span>$
(1)</p>

    <p class="text-gray-300">    <img src="_page_2_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Complexity plot for medium prime case</p>

    <p class="text-gray-300">The first n × n principal sub-matrix of Mϕ,r is diag[p, p, . . . , p] corresponding to the polynomials p, px, . . . , pxn−&lt;sup&gt;1&lt;/sup&gt; . The last r − n + 1 rows correspond to the polynomials ϕ(x), xϕ(x), . . . , xr−nϕ(x).</p>

    <p class="text-gray-300">Apply the LLL algorithm to Mϕ,r and let the first row of the resulting LLLreduced matrix be [g0, g1, . . . , gr−1, gr]. Define</p>

    <p class="text-gray-300"><span class="math">$g(x) = g_0 + g_1 x + \\dots + g_{r-1} x^{r-1} + g_r x^r.</span>$
(2)</p>

    <p class="text-gray-300">The notation</p>

    <p class="text-gray-300"><span class="math">$g = LLL(M_{\\varphi,r}) \\tag{3}</span>$</p>

    <p class="text-gray-300">will be used to denote the polynomial g(x) given by (2). By construction, ϕ(x) is a factor of g(x) modulo p.</p>

    <h2 id="sec-3" class="text-2xl font-bold">3 A New Polynomial Selection Method for TNFS</h2>

    <p class="text-gray-300">We show how to properly modify the polynomial selection method described in [6] to the TNFS variant.</p>

    <p class="text-gray-300">Consider the field Fp&lt;sup&gt;n&lt;/sup&gt; where n = ηκ with gcd(η, κ) = 1. Let h(z) be an irreducible polynomial over Z of degree η and R = Z[z]/(h(z)). This is the basic set-up of the tower number field sieve algorithm.</p>

    <p class="text-gray-300">Let A be a positive integer. Consider the set of all polynomials φ(x) of the form</p>

    <p class="text-gray-300"><span class="math">$\\phi(x) = \\phi_0(z) + \\phi_1(z)x + \\dots + \\phi_{t-1}(z)x^{t-1},</span>$</p>

    <p class="text-gray-300">where φi(z) ∈ Z[z], deg(φi) ≤ η − 1 and kφik&lt;sup&gt;∞&lt;/sup&gt; ≤ A. The number of such polynomials φ(x) is at most Aηt. We will call any such polynomial to be a sieving polynomial. Sieving is done using such polynomials φ(x).</p>

    <p class="text-gray-300">Define E to be E&lt;sup&gt;2&lt;/sup&gt; = Aηt and so A&lt;sup&gt;η&lt;/sup&gt; = E2/t. So, the number of possible coefficient polynomials of φ(x) is E2/t .</p>

    <p class="text-gray-300">Let f be an irreducible polynomial over the integers. Define</p>

    <p class="text-gray-300"><span class="math">$N_f(\\phi) = \\operatorname{Res}_t(\\operatorname{Res}_x(\\phi(x), f(x)), h(z)).</span>$</p>

    <p class="text-gray-300">If khk&lt;sup&gt;∞&lt;/sup&gt; is bounded by an absolute constant H and p = LQ(<code>p, c) for some </code>&lt;sup&gt;p&lt;/sup&gt; &gt; 1/3 and c &gt; 0, then following [2, 4], it can be proved that the following holds:</p>

    <p class="text-gray-300"><span class="math">$N_f(\\phi) \\le E^{2\\deg(f)/t} (\\|f\\|_{\\infty})^{t-1} L_Q(2/3, o(1)).</span>$</p>

    <p class="text-gray-300">Algorithm B describes the extension of our previous method to the TNFS setting. Note that if η = 1, then κ = n and B becomes identical to the polynomial selection algorithm A defined in [6]. The following result states the basic</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Algorithm: B: Polynomial selection for TNFS.</h4>

    <p class="text-gray-300">Input: p, n = ηκ, d (a factor of κ) and r ≥ κ/d.</p>

    <p class="text-gray-300">Output: f(x), g(x) and ϕ(x).</p>

    <p class="text-gray-300">Let k = κ/d;</p>

    <p class="text-gray-300">repeat</p>

    <p class="text-gray-300">Randomly choose a monic irreducible polynomial A1(x) having the following properties: deg A1(x) = r + 1; A1(x) is irreducible over the integers; A1(x) has coefficients of size O(ln(p)); modulo p, A1(x) has an irreducible factor A2(x) of degree k.</p>

    <p class="text-gray-300">Randomly choose monic polynomials C0(x) and C1(x) with small coefficients such that deg C0(x) = d and deg C1(x) &lt; d. Define</p>

    <p class="text-gray-300"><span class="math">$f(x) = \\text{Res}_{y} (A_{1}(y), C_{0}(x) + y C_{1}(x));</span>$</p>

    <p class="text-gray-300"><span class="math">$\\varphi(x) = \\text{Res}_{y} (A_{2}(y), C_{0}(x) + y C_{1}(x)) \\text{ mod } p;</span>$</p>

    <p class="text-gray-300"><span class="math">$\\psi(x) = \\text{LLL}(M_{A_{2},r});</span>$</p>

    <p class="text-gray-300"><span class="math">$g(x) = \\text{Res}_{y} (\\psi(y), C_{0}(x) + y C_{1}(x)).</span>$</p>

    <p class="text-gray-300">until f(x) and g(x) are irreducible over Z and ϕ(x) is irreducible over Fp. return f(x), g(x) and ϕ(x).</p>

    <p class="text-gray-300">Proposition 1. The outputs f(x), g(x) and ϕ(x) of Algorithm B satisfy the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>deg(f) = d(r + 1); deg(g) = rd and deg(ϕ) = κ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>both f(x) and g(x) have ϕ(x) as a factor modulo p;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>kfk&lt;sup&gt;∞&lt;/sup&gt; = O(ln(p)) and kgk&lt;sup&gt;∞&lt;/sup&gt; = O(Q1/(d(r+1))).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Consequently, if φ is a sieving polynomial, then</p>

    <p class="text-gray-300"><span class="math">$N_f(\\phi) = E^{2d(r+1)/t} \\times L_Q(2/3, o(1));</span>$
(4)</p>

    <p class="text-gray-300"><span class="math">$N_g(\\phi) = E^{2dr/t} \\times Q^{(t-1)/(d(r+1))} \\times L_Q(2/3, o(1));</span>$
(5)</p>

    <p class="text-gray-300"><span class="math">$N_f(\\phi) \\times N_g(\\phi) = E^{(2d(2r+1))/t} \\times Q^{(t-1)/(d(r+1))} L_Q(2/3, o(1)).</span>$
(6)</p>

    <p class="text-gray-300">We note the following points.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If d = 1, then the norm bound is E2(2r+1)/tQ(t−1)/(r+1) which is the same as that obtained using the GJL method.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If d = κ, then the norm bound is E2κ(2r+1)/tQ(t−1)/(κ(r+1)). Further, if r = k = 1, then the norm bound is the same as that obtained using the Conjugation method. So, for d = κ, Algorithm B is a generalisation of the Conjugation method.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If κ is a prime, then the only values of d are either 1 or n. The norm bounds in these two cases are covered by the above two points.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If κ is composite, then there are non-trivial values for d and it is possible to obtain new trade-offs in the norm bound. For concrete situations, this can be of interest. Further, for composite κ, as value of d increases from d = 1 to d = κ, the norm bound nicely interpolates between the norm bounds of the GJL method and the Conjugation method.</li>
    </ol></li>
    </ul>

    <h2 id="sec-5" class="text-2xl font-bold">4 Examples</h2>

    <p class="text-gray-300">In this section, we present some of the examples, generated by new polynomial selection algorithm.</p>

    <p class="text-gray-300">Example 1. Let p is a 201-bit prime given below.</p>

    <pre><code class="language-text">p = 1606938044258990275541962092341162602522202993782792835301611 (7)
</code></pre>

    <p class="text-gray-300">and n = 6. To apply the new polynomial selection algorithm, we have to choose η and κ such that ηκ = n and gcd(η, κ) = 1. We have the following two choices of (η, κ).</p>

    <p class="text-gray-300">Case 1: Let (η, κ) = (2, 3). Choose d = κ, and so k = κ/d = 1. Taking r = k, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} h(x) &amp;= x^2 + 14\\,x + 20 \\\\ f(x) &amp;= x^6 + 5\\,x^5 + 6\\,x^4 + 18\\,x^3 + 73\\,x^2 + 52\\,x + 20 \\\\ g(x) &amp;= 516378785784706099560748701401\\,x^3 + 1874354673374387667869084608560\\,x \\\\ &amp;\\quad + 459276162276102007999766811670\\,x + 1683194203609950937495174411516 \\\\ \\phi(x) &amp;= x^3 + 4370464675316262929768958368698673612607491294431378655895\\,x^2 \\\\ &amp;\\quad + 13111394025948788789306875106096020837822473883294135967675\\,x \\\\ &amp;\\quad + 8740929350632525859537916737397347225214982588862757311786 \\end{split}</span>$</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">Clearly, the above polynomials represents the polynomials generated by Conjugation method and we have kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 100 .</p>

    <p class="text-gray-300">If we choose r = k + 1 i.e., r = 2, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} h(x) &amp;= x^2 + x + 20 \\\\ f(x) &amp;= x^9 + 14\\,x^8 + 74\\,x^7 + 183\\,x^6 + 200\\,x^5 - 32\\,x^4 - 375\\,x^3 - 232\\,x^2 - 48\\,x - 1 \\\\ g(x) &amp;= 46647198736133019425\\,x^6 + 530869201059776791498\\,x^5 + 2094297655062561189093\\,x^4 \\\\ &amp;\\quad + 3465328474724235168588\\,x^3 + 2717008192279799547052\\,x^2 \\\\ &amp;\\quad + 1322043132032704860464\\,x + 290748395825577445032 \\\\ \\phi(x) &amp;= x^3 + 315444052193803149917391335705534526435873425227915090402562\\,x^2 \\\\ &amp;\\quad + 1261776208775212599669565342822138105743493700911660361610232\\,x \\\\ &amp;\\quad + 315444052193803149917391335705534526435873425227915090402559 \\end{split}</span>$</p>

    <p class="text-gray-300">We note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;71&lt;/sup&gt;. Thus taking r &gt; k, gives us the polynomials which are not obtained by Conjugation method.</p>

    <p class="text-gray-300">Case 2: Let (η, κ) = (3, 2). Taking d = κ and r = 1, we get the following polynomials.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} h(x) &amp;= x^3 + x^2 + 15\\,x + 7 \\\\ f(x) &amp;= x^4 - x^3 - 2\\,x^2 - 7\\,x - 3 \\\\ g(x) &amp;= 717175561486984577278242843019\\,x^2 + 2189435313197775056442946543188\\,x \\\\ &amp;\\quad + 2906610874684759633721189386207 \\\\ \\phi(x) &amp;= x^2 + 131396875851816610915684123600060137654000542337369130402554\\,x \\\\ &amp;\\quad + 131396875851816610915684123600060137654000542337369130402555 \\end{split}</span>$</p>

    <p class="text-gray-300">Note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;101&lt;/sup&gt;. If we take d = κ and r = 2, we get the following set of polynomials where kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 69 .</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} h(x) &amp;= x^3 + x^2 + 15\\,x + 7 \\\\ f(x) &amp;= x^6 - 4\\,x^5 - 53\\,x^4 - 147\\,x^3 - 188\\,x^2 - 157\\,x - 92 \\\\ g(x) &amp;= 15087279002722300985\\,x^4 + 124616743720753879934\\,x^3 + 451785460058994237397\\,x^2 \\\\ &amp;\\quad + 749764394939964245000\\,x + 567202989572349792620 \\\\ \\phi(x) &amp;= x^2 + 459743211307624787973091830151418256356779099860453048165628\\,x \\\\ &amp;\\quad + 1379229633922874363919275490454254769070337299581359144496879 \\end{split}</span>$</p>

    <p class="text-gray-300">Example 2. Consider the same prime p given by the equation (7). Let n = 12. Choose η = 3 and κ = 4. We can now apply the new polynomial selection method by taking d a divisor of κ. Note that for d = 1, we get the polynomials which are generated by GJL method, and for d = κ and r = κ/d, we get the polynomials which are generated by Conjugation method.</p>

    <p class="text-gray-300">Let us take d = 2 and so k = κ/d = 2. Choosing r = 2, we get the following polynomials using the new polynomial selection method.</p>

    <p class="text-gray-300"><span class="math">$h(x) = x^3 + 6\\,x^2 + 17\\,x + 9</span>$</p>

    <p class="text-gray-300"><span class="math">$f(x) = x^6 + 5\\,x^5 - 30\\,x^4 - 266\\,x^3 - 676\\,x^2 - 708\\,x - 272</span>$</p>

    <p class="text-gray-300"><span class="math">$g(x) = 6467759678841805870369474068891432876119\\,x^4 + 6502041296101468515405699029621</span>$</p>

    <p class="text-gray-300"><span class="math">$6084937901\\,x^3 + 222170443795536450104732978193530615480075\\,x^2 + 288848458312</span>$</p>

    <p class="text-gray-300"><span class="math">$346890039868803933886050843398x + 131565328984563790448827928636681124756276</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi(x) = x^4 + 524836704622542585952303793367376227408021565148774944064926\\,x^3</span>$</p>

    <p class="text-gray-300"><span class="math">$+ 412331973798848955780775364051098068524174598906061062223842\\,x^2</span>$</p>

    <p class="text-gray-300"><span class="math">$+ 729366207515760721958696718425775500473208458672566373192896\\,x</span>$</p>

    <p class="text-gray-300"><span class="math">$+ 794222068298485757328798142903843341069485055345502379406598</span>$</p>

    <p class="text-gray-300">Note that kgk&lt;sup&gt;∞&lt;/sup&gt; ≈ 2 &lt;sup&gt;137&lt;/sup&gt; and these polynomials are neither covered by GJL method nor by Conjugation method.</p>

    <h2 id="sec-6" class="text-2xl font-bold">5 Asymptotic Complexity Analysis for the Medium Prime Case</h2>

    <p class="text-gray-300">For 1/3 &lt; a &lt; 2/3, write</p>

    <p class="text-gray-300"><span class="math">$p = L_Q(a, c_p), \\text{ where } c_p = \\frac{1}{n} \\left( \\frac{\\ln Q}{\\ln \\ln Q} \\right)^{1-a} \\text{ and so } n = \\frac{1}{c_p} \\left( \\frac{\\ln Q}{\\ln \\ln Q} \\right)^{1-a}.(8)</span>$</p>

    <p class="text-gray-300">For each cp, the runtime of the NFS algorithm is the same for the family of finite fields Fp&lt;sup&gt;n&lt;/sup&gt; where p is given by (8).</p>

    <p class="text-gray-300">Recall that n = ηκ where gcd(η, κ) = 1. Suppose η can be written as</p>

    <p class="text-gray-300"><span class="math">$\\eta = c_{\\eta} \\left( \\frac{\\ln Q}{\\ln \\ln Q} \\right)^{2/3 - a}. \\tag{9}</span>$</p>

    <p class="text-gray-300">Define P = p η . Then</p>

    <p class="text-gray-300"><span class="math">$P = L_{Q}(a, c_{p}\\eta)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\exp\\left(c_{p}\\eta(\\ln Q)^{a}(\\ln \\ln Q)^{1-a}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\exp\\left(c_{p}c_{\\eta}\\left(\\frac{\\ln Q}{\\ln \\ln Q}\\right)^{2/3-a}(\\ln Q)^{a}(\\ln \\ln Q)^{1-a}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\exp\\left(c_{p}c_{\\eta}(\\ln Q)^{2/3}(\\ln \\ln Q)^{1/3}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= L_{Q}(2/3, c_{p}c_{\\eta}). \\tag{10}</span>$</p>

    <p class="text-gray-300">So, if p is a medium prime with p = LQ(a, cp) with 1/3 &lt; a &lt; 2/3 and η is given by (9), then P is of the form LQ(2/3, cpcη), i.e., its size corresponds to the boundary case of NFS. The tower number field sieve considers an extension of degree κ over P. So, the extension of degree ηκ over a medium size prime p is transformed into an extension of degree κ over a boundary case size prime power P. Consequently, for such a situation, the asymptotic results obtained earlier for the boundary case can be translated to the medium size case.</p>

    <p class="text-gray-300">We recall the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The number of polynomials to be considered for sieving is E&lt;sup&gt;2&lt;/sup&gt; .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The factor base is of size B.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Sparse linear algebra using the Lanczos or the block Wiedemann algorithm takes time O(B&lt;sup&gt;2&lt;/sup&gt; ). For some 0 &lt; b &lt; 1, let</p>

    <p class="text-gray-300"><span class="math">$B = L_Q(b, c_b). (11)</span>$</p>

    <p class="text-gray-300">The value of b will be determined later. Set</p>

    <p class="text-gray-300"><span class="math">$E = B \\tag{12}</span>$</p>

    <p class="text-gray-300">so that asymptotically, the number of sieving polynomials is equal to the time for the linear algebra step.</p>

    <p class="text-gray-300">Let π = Ψ(Γ, B) be the probability that a random positive integer which is at most Γ is B-smooth. Let Γ = LQ(z, ζ) and B = LQ(b, cb). Using the L-notation version of the Canfield-Erd¨os-Pomerance theorem,</p>

    <p class="text-gray-300"><span class="math">$(\\Psi(\\Gamma, B))^{-1} = L_Q\\left(z - b, (z - b)\\frac{\\zeta}{c_b}\\right). \\tag{13}</span>$</p>

    <p class="text-gray-300">Following the usual convention, we assume that the same smoothness probability π holds for the event that a random sieving polynomial φ(x) is smooth over the factor base.</p>

    <p class="text-gray-300">The expected number of polynomials to consider for obtaining one relation is π −1 . Since B relations are required, obtaining this number of relations requires trying Bπ−&lt;sup&gt;1&lt;/sup&gt; trials. Balancing the cost of sieving and the linear algebra steps requires Bπ−&lt;sup&gt;1&lt;/sup&gt; = B&lt;sup&gt;2&lt;/sup&gt; and so</p>

    <p class="text-gray-300"><span class="math">$\\pi^{-1} = B. \\tag{14}</span>$</p>

    <p class="text-gray-300">Obtaining π −1 from (13) and setting it to be equal to B allows solving for cb. Balancing the costs of the sieving and the linear algebra phases leads to the runtime of the NFS algorithm to be B&lt;sup&gt;2&lt;/sup&gt; = LQ(b, 2cb). So, to determine the runtime, we need to determine b and cb. The value of b will turn out to be 1/3 and the only real issue is the value of cb.</p>

    <p class="text-gray-300">Lemma 1. Let n = ηκ and κ = kd for positive integers η, k and d. Using the expressions for p and E(= B) given by (8) and (11), we obtain the following.</p>

    <p class="text-gray-300"><span class="math">$E^{\\frac{2}{t}d(2r+1)} = L_Q \\left( 1 - a + b, \\frac{2c_b(2r+1)}{c_p\\eta kt} \\right);</span>$</p>

    <p class="text-gray-300"><span class="math">$Q^{\\frac{t-1}{d(r+1)}} = L_Q \\left( a, \\frac{kc_p\\eta(t-1)}{(r+1)} \\right).</span>$
(15)</p>

    <p class="text-gray-300">If further η = cη(ln Q/ln ln Q) 2/3−a , then</p>

    <p class="text-gray-300"><span class="math">$E^{\\frac{2}{t}d(2r+1)} = L_Q\\left(1/3 + b, \\frac{2c_b(2r+1)}{c_pc_\\eta kt}\\right);</span>$</p>

    <p class="text-gray-300"><span class="math">$Q^{\\frac{t-1}{d(r+1)}} = L_Q\\left(2/3, \\frac{kc_pc_\\eta(t-1)}{(r+1)}\\right).</span>$
(16)</p>

    <p class="text-gray-300">Proof. The second expression follows directly from Q = p &lt;sup&gt;n&lt;/sup&gt;, p = LQ(a, cp) and n = ηkd. The computation for obtaining the first expression is the following.</p>

    <p class="text-gray-300"><span class="math">$E^{\\frac{2}{t}d(2r+1)} = L_Q \\left( b, c_b \\frac{2}{t} d(2r+1) \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\exp \\left( c_b \\frac{2}{t} (2r+1) \\frac{n}{k\\eta} (\\ln Q)^b (\\ln \\ln Q)^{1-b} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\exp \\left( c_b \\frac{2}{c_p \\eta kt} (2r+1) \\left( \\frac{\\ln Q}{\\ln \\ln Q} \\right)^{1-a} (\\ln Q)^b (\\ln \\ln Q)^{1-b} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= L_Q \\left( 1 - a + b, \\frac{2c_b (2r+1)}{c_p \\eta kt} \\right).</span>$</p>

    <p class="text-gray-300">Theorem 1. Let n = ηκ; gcd(η, κ) = 1; κ = kd; r ≥ k; t ≥ 2; p = LQ(a, cp) with 1/3 &lt; a &lt; 2/3 and 0 &lt; c&lt;sup&gt;p&lt;/sup&gt; &lt; 1; and η = cη(ln Q/ln ln Q) 2/3−a . It is possible to ensure that the runtime of the NFS algorithm with polynomials chosen by Algorithm B is LQ(1/3, 2cb) where</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{2r+1}{3c_\\theta kt} + \\sqrt{\\left(\\frac{2r+1}{3c_\\theta kt}\\right)^2 + \\frac{kc_\\theta(t-1)}{3(r+1)}} \\text{ and}</span>$
(17)</p>

    <p class="text-gray-300"><span class="math">$c_{\\theta} = c_p c_{\\eta}. \\tag{18}</span>$</p>

    <p class="text-gray-300">ut</p>

    <p class="text-gray-300">Proof. Setting b = 1/3, the two L-expressions given by (16) have the same first component and so the product of the norms is</p>

    <p class="text-gray-300"><span class="math">$\\Gamma = L_Q \\left( \\frac{2}{3}, \\frac{2c_b(2r+1)}{c_p c_{\\eta} kt} + \\frac{kc_p c_{\\eta}(t-1)}{(r+1)} \\right)</span>$
<span class="math">$= L_Q \\left( \\frac{2}{3}, \\frac{2c_b(2r+1)}{c_{\\theta} kt} + \\frac{kc_{\\theta}(t-1)}{(r+1)} \\right).</span>$</p>

    <p class="text-gray-300">Then π &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; given by (13) is</p>

    <p class="text-gray-300"><span class="math">$L_Q\\left(\\frac{1}{3}, \\frac{1}{3}\\left(\\frac{2(2r+1)}{c_\\theta kt} + \\frac{kc_\\theta(t-1)}{c_b(r+1)}\\right)\\right).</span>$</p>

    <p class="text-gray-300">From the condition π &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; = B, we get</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{1}{3} \\left( \\frac{2(2r+1)}{c_\\theta kt} + \\frac{kc_\\theta(t-1)}{c_b(r+1)} \\right). \\tag{19}</span>$</p>

    <p class="text-gray-300">Solving the quadratic for c&lt;sup&gt;b&lt;/sup&gt; and choosing the positive root gives</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{2r+1}{3c_\\theta kt} + \\sqrt{\\left(\\frac{2r+1}{3c_\\theta kt}\\right)^2 + \\frac{kc_\\theta(t-1)}{3(r+1)}}.</span>$</p>

    <p class="text-gray-300">Note that c&lt;sup&gt;b&lt;/sup&gt; is minimised at cpc&lt;sup&gt;η&lt;/sup&gt; = c&lt;sup&gt;θ&lt;/sup&gt; = 121/&lt;sup&gt;3&lt;/sup&gt; whence the corresponding complexity of the TNFS algorithm is LQ(1/3,(48/9)1/&lt;sup&gt;3&lt;/sup&gt; ).</p>

    <h2 id="sec-7" class="text-2xl font-bold">6 Multiple Number Field Sieve Variant</h2>

    <p class="text-gray-300">There are two variants of multiple number field sieve algorithm. In the first variant, the image of φ(x) needs to be smooth in at least any two of the number fields. In the second variant, the image of φ(x) needs to be smooth in the first number field and at least one of the other number fields. We discuss the second variant of MNFS only. In contrast to the number field sieve algorithm, the right number field is replaced by a collection of V number fields in the second variant of MNFS. The sieving polynomial φ(x) has to satisfy the smoothness condition on the left number field as before. On the right side, it is sufficient for φ(x) to satisfy a smoothness condition on at least one of the V number fields.</p>

    <p class="text-gray-300">Recall that Algorithm B produces two polynomials f(x) and g(x) of degrees d(r+1) and dr respectively. The polynomial g(x) is defined as Resy(ψ(y), C0(x)+ yC1(x)) where ψ(x) = LLL(M&lt;sup&gt;A&lt;/sup&gt;2,r), i.e., ψ(x) is defined from the first row of the matrix obtained after applying the LLL-algorithm to M&lt;sup&gt;A&lt;/sup&gt;2,r.</p>

    <p class="text-gray-300">Methods for obtaining the collection of number fields on the right have been mentioned in [5]. We adapt one of these methods to our setting. Consider Algorithm B. Let ψ1(x) be ψ(x) as above and let ψ2(x) be the polynomial defined from</p>

    <p class="text-gray-300">ut</p>

    <p class="text-gray-300">the second row of the matrix  <span class="math">M_{A_2,r}</span> . Define  <span class="math">g_1(x) = \\operatorname{Res}_y(\\psi_1(y), C_0(x) + yC_1(x))</span>  and  <span class="math">g_2(x) = \\operatorname{Res}_y(\\psi_2(y), C_0(x) + yC_1(x))</span> . Then choose V-2 linear combinations  <span class="math">g_i(x) = s_i g_1(x) + t_i g_2(x)</span> , for  <span class="math">i=3,\\ldots,V</span> . Note that the coefficients  <span class="math">s_i</span>  and  <span class="math">t_i</span>  are of the size of  <span class="math">\\sqrt{V}</span> . All the  <span class="math">g_i</span> 's have degree dr. Asymptotically,  <span class="math">\\|\\psi_2\\|_{\\infty} = \\|\\psi_1\\|_{\\infty} = Q^{1/(d(r+1))}</span> . Since we take  <span class="math">V = L_Q(1/3)</span> , all the  <span class="math">g_i</span> 's have their infinity norms to be the same as that of g(x) given by Proposition 1.</p>

    <p class="text-gray-300">For the left number field, as before, let B be the bound on the norms of the ideals which are in the factor basis defined by f. For each of the right number fields, let B' be the bound on the norms of the ideals which are in the factor basis defined by each of the  <span class="math">g_i</span> 's. So, the size of the entire factor basis is B+VB'. The following condition balances the left portion and the right portion of the factor basis.</p>

    <p class="text-gray-300"><span class="math">$B = VB&#x27;. (20)</span>$</p>

    <p class="text-gray-300">With this condition, the size of the factor basis is  <span class="math">B^{1+o(1)}</span>  as in the classical NFS and so asymptotically, the linear algebra step takes time  <span class="math">B^2</span> . As before, the number of sieving polynomials is  <span class="math">E^2 = B^2</span>  and the coefficient polynomials of  <span class="math">\\phi(x)</span>  can take  <span class="math">E^{2/t}</span>  distinct values.</p>

    <p class="text-gray-300">Let  <span class="math">\\pi</span>  be the probability that a random sieving polynomial  <span class="math">\\phi(x)</span>  gives rise to a relation. Let  <span class="math">\\pi_1</span>  be the probability that  <span class="math">\\phi(x)</span>  is smooth over the left factor basis and  <span class="math">\\pi_2</span>  be the probability that  <span class="math">\\phi(x)</span>  is smooth over at least one of the right factor bases. Further, let  <span class="math">\\Gamma_1 = \\operatorname{Res}_x(f(x), \\phi(x))</span>  be the bound on the norm corresponding to the left number field and  <span class="math">\\Gamma_2 = \\operatorname{Res}_x(g_i(x), \\phi(x))</span>  be the bound on the norm for any of the right number fields. Note that  <span class="math">\\Gamma_2</span>  is determined only by the degree and the  <span class="math">L_{\\infty}</span> -norm of  <span class="math">g_i(x)</span>  and hence is the same for all  <span class="math">g_i(x)</span> 's. Heuristically, we have</p>

    <p class="text-gray-300"><span class="math">$\\pi_1 = \\Psi(\\Gamma_1, B);</span>$
<span class="math">\\pi_2 = V\\Psi(\\Gamma_2, B&#x27;);</span>
<span class="math">\\pi = \\pi_1 \\times \\pi_2.</span>
(21)</p>

    <p class="text-gray-300">As before, one relation is obtained in about  <span class="math">\\pi^{-1}</span>  trials and so B relations are obtained in about  <span class="math">B\\pi^{-1}</span>  trials. Balancing the cost of linear algebra and sieving, we have as before  <span class="math">B=\\pi^{-1}</span> .</p>

    <p class="text-gray-300">The following choices of B and V are made.</p>

    <p class="text-gray-300"><span class="math">$E = B = L_Q(\\frac{1}{3}, c_b);</span>$</p>

    <p class="text-gray-300"><span class="math">$V = L_Q(\\frac{1}{3}, c_v); \\text{ and so}</span>$</p>

    <p class="text-gray-300"><span class="math">$B&#x27; = B/V = L_Q(\\frac{1}{3}, c_b - c_v).</span>$
(22)</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let  <span class="math">n = \\eta \\kappa</span> ;  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> ;  <span class="math">\\kappa = kd</span> ;  <span class="math">r \\geq k</span> ;  <span class="math">t \\geq 2</span> ;  <span class="math">p = L_Q(a, c_p)</span>  with 1/3 &lt; a &lt; 2/3 and  <span class="math">0 &lt; c_p &lt; 1</span> ; and  <span class="math">\\eta = c_{\\eta} (\\ln Q / \\ln \\ln Q)^{2/3-a}</span> . It is possible to ensure that the runtime of the MNFS algorithm is  <span class="math">L_Q(1/3, 2c_b)</span>  where</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{4r+2}{6ktc_{\\theta}} + \\sqrt{\\frac{r(3r+2)}{(3ktc_{\\theta})^2} + \\frac{c_{\\theta}k(t-1)}{3(r+1)}}</span>$
and
<span class="math">$c_{\\theta} = c_p c_{\\eta}.</span>$
(23)</p>

    <p class="text-gray-300">Proof. Note the following computations. For a sieving polynomial φ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Gamma_{1} = N_{f}(\\phi) \\\\ &amp;= E^{(2d(r+1))/t} L_{Q}(2/3, o(1)) \\\\ &amp;= E^{(2n(r+1))/(\\eta kt)} \\\\ &amp;= L_{Q} \\left(\\frac{2}{3}, \\frac{2(r+1)c_{b}}{ktc_{p}c_{\\eta}}\\right); \\\\ &amp;\\pi_{1}^{-1} = L_{Q} \\left(\\frac{1}{3}, \\frac{2(r+1)}{3ktc_{\\theta}}\\right); \\\\ &amp;\\Gamma_{2} = N_{g}(\\phi) \\\\ &amp;= E^{(2rd)/t} \\times Q^{(t-1)/(d(r+1))} L_{Q}(2/3, o(1)) \\\\ &amp;= E^{(2rn)/(\\eta kt)} \\times Q^{\\eta k(t-1)/(n(r+1))} \\\\ &amp;= L_{Q} \\left(\\frac{2}{3}, \\frac{2rc_{b}}{c_{p}c_{\\eta}kt} + \\frac{kc_{p}c_{\\eta}(t-1)}{r+1}\\right); \\\\ &amp;\\pi_{2}^{-1} = L_{Q} \\left(\\frac{1}{3}, -c_{v} + \\frac{1}{3(c_{b} - c_{v})} \\left(\\frac{2rc_{b}}{c_{\\theta}kt} + \\frac{kc_{\\theta}(t-1)}{r+1}\\right)\\right); \\\\ &amp;\\pi^{-1} = L_{Q} \\left(\\frac{1}{3}, \\frac{2(r+1)}{3ktc_{\\theta}} - c_{v} + \\frac{1}{3(c_{b} - c_{v})} \\left(\\frac{2rc_{b}}{c_{\\theta}kt} + \\frac{kc_{\\theta}(t-1)}{r+1}\\right)\\right); \\end{split}</span>$</p>

    <p class="text-gray-300">From the condition π &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; = B, we obtain the following equation.</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{2(r+1)}{3ktc_pc_\\eta} - c_v + \\frac{1}{3(c_b - c_v)} \\left( \\frac{2rc_b}{c_\\theta kt} + \\frac{kc_\\theta(t-1)}{r+1} \\right).</span>$
(24)</p>

    <p class="text-gray-300">We wish to find c&lt;sup&gt;v&lt;/sup&gt; such that c&lt;sup&gt;b&lt;/sup&gt; is minimised subject to the constraint (24). Using the method of Lagrange multipliers, the partial derivative of (24) with respect to c&lt;sup&gt;v&lt;/sup&gt; gives</p>

    <p class="text-gray-300"><span class="math">$c_v = \\frac{r+1}{3ktc_{\\theta}}.</span>$</p>

    <p class="text-gray-300">Using this value of c&lt;sup&gt;v&lt;/sup&gt; in (24) provides the following quadratic in cb.</p>

    <p class="text-gray-300"><span class="math">$(3ktc_{\\theta})c_{b}^{2} - (4r+2)c_{b} + \\frac{(r+1)^{2}}{3ktc_{\\theta}} - \\frac{(c_{\\theta}k)^{2}t(t-1)}{r+1} = 0.</span>$</p>

    <p class="text-gray-300">Solving this and taking the positive square root, we obtain</p>

    <p class="text-gray-300"><span class="math">$c_b = \\frac{4r+2}{6ktc_{\\theta}} + \\sqrt{\\frac{r(3r+2)}{(3ktc_{\\theta})^2} + \\frac{c_{\\theta}k(t-1)}{3(r+1)}}.</span>$
(25)</p>

    <p class="text-gray-300">Hence the overall complexity of MNFS for the boundary case is L&lt;sup&gt;Q&lt;/sup&gt; 1 3 , 2c&lt;sup&gt;b&lt;/sup&gt; . ut</p>

    <p class="text-gray-300">From Theorem 2, the entire analysis carried out in Sections 8.1 and 8.2 of [6] apply with the constant c&lt;sup&gt;p&lt;/sup&gt; replaced by c&lt;sup&gt;θ&lt;/sup&gt; leading to the new asymptotic complexity results for the medium prime case that has been mentioned in the introduction.</p>

    <h2 id="sec-8" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and Fran¸cois Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, volume 9056 of Lecture Notes in Computer Science, pages 129–155. Springer, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung. The tower number field sieve. In Tetsu Iwata and Jung Hee Cheon, editors, Advances in Cryptology - ASIACRYPT 2015 - 21st International Conference on the Theory and Application of Cryptology and Information Security, Auckland, New Zealand, November 29 - December 3, 2015, Proceedings, Part II, volume 9453 of Lecture Notes in Computer Science, pages 31–55. Springer, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux, Reynald Lercier, Nigel P. Smart, and Frederik Vercauteren. The number field sieve in the medium prime case. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 326–344. Springer, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Taechan Kim and Razvan Barbulescu. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C´ecile Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 156–170, 2015.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Palash Sarkar and Shashank Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. Cryptology ePrint Archive, Report 2015/944, 2015. http://eprint.iacr.org/.</li>
    </ol></li>
    </ul>

`;
---

<BaseLayout title="Tower Number Field Sieve Variant of a Recent Polynomial Sele... (2016/401)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/401
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="tower-number-field-sieve-variant-of-a-recent-polynomial-2016" />
  </article>
</BaseLayout>
