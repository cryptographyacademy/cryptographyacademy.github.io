---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/471';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = '5 Extension to Hidden Order Groups';
const AUTHORS_HTML = 'The  $\\Sigma^{\\phi}$ -protocol as defined in §2 can only be used efficiently if the underlying homomorphism is special. To overcome this limitation, we introduce a novel protocol (the  $\\Sigma^{exp}$ -protocol) in §5.1, which yields efficient proofs of knowledge for exponentiation homomorphisms in hidden order groups. The  $\\Sigma^{exp}$ -protocol extends ideas of the Damgård-Fujisaki proof scheme [DF02] and overcomes several limitations of it. In §5.2 and §5.3 we show how the framework given in §2 can be extended to cover the  $\\Sigma^{exp}$ -protocol as well, and we show how to combine the techniques for  $\\Sigma^{\\phi}$ - and  $\\Sigma^{exp}$ -protocols.';

const CONTENT = `    <h3 id="sec-1" class="text-xl font-semibold mt-8">Automatic Generation of Sound Zero-Knowledge Protocols</h3>

    <p class="text-gray-300">Endre Bangerter&lt;sup&gt;1&lt;/sup&gt; , Jan Camenisch&lt;sup&gt;2&lt;/sup&gt; , Stephan Krenn&lt;sup&gt;3&lt;/sup&gt; , Ahmad-Reza Sadeghi&lt;sup&gt;4&lt;/sup&gt; , and Thomas Schneider&lt;sup&gt;4&lt;/sup&gt;</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; Bern University of Applied Sciences, Biel-Bienne, Switzerland endre.bangerter@bfh.ch &lt;sup&gt;2&lt;/sup&gt; Bern University of Applied Sciences, Biel-Bienne and University of Fribourg, Switzerland stephan.krenn@bfh.ch 3 IBM Research, Zurich Research Lab, R¨uschlikon, Switzerland jca@zurich.ibm.com &lt;sup&gt;4&lt;/sup&gt; Horst G¨ortz Institute for IT Security, Ruhr-University Bochum, Germany {ahmad.sadeghi,thomas.schneider}@trust.rub.de</p>

    <p class="text-gray-300">Abstract. Efficient zero-knowledge proofs of knowledge (ZK-PoK) are basic building blocks of many practical cryptographic applications such as identification schemes, group signatures, and secure multiparty computation. Currently, first applications that essentially rely on ZK-POKs are being deployed in the real world. The most prominent example is Direct Anonymous Attestation (DAA), which was adopted by the Trusted Computing Group (TCG) and implemented as one of the functionalities of the cryptographic chip Trusted Platform Module (TPM).</p>

    <p class="text-gray-300">Implementing systems using ZK-PoK turns out to be challenging, since ZK-PoK are, loosely speaking, significantly more complex than standard crypto primitives, such as encryption and signature schemes. As a result, implementation cycles of ZK-PoK are time-consuming and error-prone, in particular for developers with minor or no cryptographic skills.</p>

    <p class="text-gray-300">To overcome these challenges, we have designed and implemented a compiler with corresponding languages that given a high-level ZK-PoK protocol specification automatically generates a sound implementation of this. The output is given in form of Σ-protocols, which are the most efficient protocols for ZK-PoK currently known. Our compiler translates ZK-PoK protocol specifications, written in a high-level protocol description language, into Java code or LATEX documentation of the protocol.</p>

    <p class="text-gray-300">The compiler is based on a unified theoretical framework that encompasses a large number of existing ZK-PoK techniques.Within this framework we present a new efficient ZK-PoK protocol for exponentiation homomorphisms in hidden order groups. Our protocol overcomes several limitations of the existing proof techniques.</p>

    <p class="text-gray-300">Key words: Zero-Knowledge, Protocol Compiler, Language Design</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">A zero-knowledge proof of knowledge (ZK-PoK) is a two-party protocol between a prover and a verifier, which allows the prover to convince the verifier that he knows some secret values (proof of knowledge property), without that the verifier learns anything about them (zero-knowledge property). There are fundamental results showing that all relations in NP have ZK-PoK <a href="#page-19-0">[GMW91]</a>. The corresponding protocols are of theoretical relevance, but much too inefficient in practice.</p>

    <p class="text-gray-300">Essentially, all efficient ZK-PoK protocols used in practice today are based on so called Σprotocols. These are three-move protocols consisting of the first message from the prover, a challenge uniformly chosen at random by the verifier and the corresponding response from the prover again. What is typically being proved using basic Σ-protocols is the knowledge of a preimage under a homomorphism. There are numerous variations of these preimage proofs. For instance, so called &quot;AND-proofs&quot; allow to prove simultaneous knowledge of multiple preimages under possibly different homomorphisms. Similarly there are &quot;OR-proofs&quot;, and one can also show that different preimages fulfill a set of linear relations.</p>

    <p class="text-gray-300">These Σ-protocol based ZK-PoK proof techniques play an important role in applied cryptography. In fact, many practically oriented applications use such proofs as basic building blocks. Examples of such applications include identification schemes <a href="#page-19-1">[Sch91]</a>, interactive verifiable computation <a href="#page-18-0">[CM99]</a>, group signatures <a href="#page-18-1">[Cam98]</a>, secure watermark detection <a href="#page-18-2">[ARS05]</a>, and efficient secure multiparty computation <a href="#page-19-2">[LPS08]</a> - just to name a few.</p>

    <p class="text-gray-300">While many of these applications typically only exist on a specification level, a direction of applied research has produced first applications using ZK-PoKs being deployed in the real world. One prominent example is Direct Anonymous Attestation (DAA) <a href="#page-18-3">[BCC04]</a>, which was adopted by the Trusted Computing Group (TCG), an industry consortium of many IT enterprises, as a privacy enhancing mechanism for remote authentication of computing platforms. Another example is the idemix anonymous credential system <a href="#page-18-4">[CH02]</a>, which was released by IBM into the Eclipse Higgins project, an open source effort dedicated to developing software for &quot;user-centric&quot; identity management.</p>

    <p class="text-gray-300">Up to now, the design and implementation of practical ZK-PoK protocols is done &quot;by hand&quot;. The security proofs of these protocols consist of, loosely speaking, a handful of standard arguments and tricks which are repeated in different constellations over and over again. In fact, past experiences, e.g., during the development of the idemix anonymous credential system <a href="#page-18-4">[CH02]</a> or Direct Anonymous Attestation <a href="#page-18-3">[BCC04]</a> have shown that (i) implementation cycles of ZK-PoK are timeconsuming and error-prone, and (ii) it is hard to achieve resilience against design modifications, i.e., minor changes in the protocol specification can result in substantial implementation work. Moreover, in practice, protocols are often designed by cryptographers and then implemented by software engineers. The former typically are not skilled in implementation matters and the latter have a hard time understanding details and subtleties of ZK-PoK protocols, which are sometimes indeed rather complex. This can lead to a rupture between design and implementation, which can eventually lead to implementation errors. In this paper we aim at tackling these challenges.</p>

    <p class="text-gray-300">Our contributions. To overcome theses challenges, we have designed and implemented a compiler and corresponding languages that given a high-level ZK-PoK protocol specification automatically generates the implementation of the corresponding Σ-protocol. More precisely, we have designed a language which is inspired by the widely used Camenisch-Stadler notation <a href="#page-18-5">[CS97a]</a>. ZK-PoK protocol specifications in this language are then translated by the compiler either into Java or LATEX code. The Java code can be integrated into higher level systems that make use of the corresponding ZK-PoK. The group operations in the generated code are expressed in terms of abstract interfaces. This allows users of the code to plug their preferred libraries into the protocol code by implementing our abstract interfaces. By the same mechanism we assert the algebraic extensibility and flexibility of the code being generated, i.e., to use one's favorite group one simply implements our abstract interfaces with that group. The LATEX code can be used for documenting the protocols and also for verification purposes. To the best of our knowledge, this is the first compiler suite to support the automatic generation of sound ZK-PoK protocols.</p>

    <p class="text-gray-300">The existing theory and collection of ZK-PoK proof techniques and &quot;tricks&quot; using Σ-protocols is vast. The problem however is the lack of a unified theory underlying these techniques. To build our compiler on solid ground, we have developed a unified framework which encompasses a large number (but probably not all) of existing proof techniques. The basis of the framework are simple proofs of knowledge of preimages under homomorphisms. More precisely, we have incorporated the theory by Cramer [Cra96] on special homomorphisms. These are essentially homomorphisms with a known order co-domain and the homomorphisms of the form  <span class="math">\\phi(w) = w^e</span>  underlying, e.g., the RSA scheme.</p>

    <p class="text-gray-300">Exponentiation homomorphisms in hidden order groups (i.e.,  <span class="math">\\phi : \\mathbb{Z}^l \\to \\mathcal{H} : (w_1, \\dots, w_l) \\mapsto h_1^{w_1} \\cdots h_l^{w_l}</span>  with  <span class="math">h_1, \\dots, h_l</span>  being elements of an RSA group) are not special and thus not covered by Cramer's theory. Essentially, all ZK-PoK for such homomorphisms are currently based on the Damgård-Fujisaki (DF) scheme [DF02]. While the DF scheme allows to demonstrate knowledge of preimages of exponentiation homomorphisms in hidden order groups, it is not a proof of knowledge in the strict sense, but loosely speaking, something weaker. In fact, the DF scheme is often wrongly believed to be a proof of knowledge. This is surprising, since the authors of the paper don't make this claim, and describe in detail their proper definition of demonstrating knowledge. In fact, the DF scheme only works for homomorphisms which are generated using an associated setup protocol.</p>

    <p class="text-gray-300">We propose the novel  <span class="math">\\Sigma^{exp}</span> -protocol, which takes up and extends the ideas underlying the DF scheme. The  <span class="math">\\Sigma^{exp}</span> -protocol relies on weaker and simpler setup assumptions than the DF scheme and works for arbitrary exponentiation homomorphisms. In particular, it does not require that homomorphisms are generated according to some specific setup protocol, but only an auxiliary input has to be given to the prover and the verifier. This auxiliary input has to be verified in a setup protocol once, and can then be used for arbitrary exponentiation homomorphisms with less than an arbitrary (but fixed) number of base elements. Also, the  <span class="math">\\Sigma^{exp}</span> -protocol can always be used instead of the DF scheme. This makes the  <span class="math">\\Sigma^{exp}</span> -protocol more appropriate for our unified framework. The  <span class="math">\\Sigma^{exp}</span> -protocol yields computational proofs of knowledge in the auxiliary string model, i.e., under the assumption that the prover and verifier are given some appropriately chosen auxiliary information. This definitional setting is simpler than the rather contrived one, which underlies the DF scheme. This can potentially lead to a simpler and more modular security analysis of applications relying on the  <span class="math">\\Sigma^{exp}</span> -protocol. We believe that the  <span class="math">\\Sigma^{exp}</span> -protocol is a contribution of independent interest.</p>

    <p class="text-gray-300">Finally, our theoretical framework also describes how to compose the basic protocols for preimage proofs mentioned above to obtain &quot;AND&quot; and &quot;AND-OR&quot; proofs, and to prove linear relations among preimages. Therefore we rely on a selection of existing techniques. The unification of ZK-PoK for special homomorphisms and hidden order homomorphisms is novel.</p>

    <p class="text-gray-300">The current version of the compiler - as presented in this paper - implements most of the general framework (excluding the proposed  <span class="math">\\Sigma^{exp}</span> -protocol) and can already be used to automatically generate sound ZK-PoKs for many practical applications in known-order groups including Pedersen Commitments/Verifiable Secret Sharing [Ped92], Schnorr Authentication/Signatures [Sch91], proving in ZK that a number is the product of two safe primes [CM99], Electronic Cash [Bra94,Oka95,CFT98], Group Signatures [CL04], and Ring Signatures [CDS94]. Also supported are ZK-PoKs of a plaintext corresponding to a ciphertext or relations between plaintexts under various encryption schemes such as, RSA [RSA78], Paillier [Pai99], or Damgård-Jurik [DJ01]; these homomorphic encryption schemes are widely used in e-voting and secure multiparty computation.</p>

    <p class="text-gray-300">Currently, we are working on the extension of our compiler for protocols in hidden order groups.</p>

    <p class="text-gray-300"><strong>Related Work.</strong> The compiler presented in this paper was started in [Bri04,CRS05]. We have extended it substantially and present it together with the underlying theoretical framework here.</p>

    <p class="text-gray-300">A profound analysis of  <span class="math">\\Sigma</span> -protocols for special homomorphisms, the so-called  <span class="math">\\Sigma^{\\phi}</span> -protocol, can be found in [Cra96], and the used composition rules can be found in [CDS94]. A first framework for</p>

    <p class="text-gray-300">boolean formulae containing linear relations was done by Brands [Bra97] and extended by Bresson and Stern in [BS02] to a larger class of predicates. The idea underlying our proofs for relations is essentially the same as in [CS97b], where the authors also explain how to obtain efficient proof systems for such formulae. However, all these frameworks are restricted to exponentiation-based homomorphisms in known-order groups only. We extend it to unknown order groups as well. The  <span class="math">\\Sigma^{exp}</span> -protocol extends work of Damgård-Fujisaki [DF02] and overcomes some of their restrictions; similar approaches also appear in [BCM05,Ban05].</p>

    <p class="text-gray-300">Provably secure protocols for two-party secure function evaluation (SFE) can be compiled automatically [MOR03,MNPS04]. Similar to what our compiler does in the context of zero-knowledge protocols, these compilers allow to specify the function to be evaluated in a high-level language and automatically compile this into an executable protocol. They use zero-knowledge protocols as building blocks to prove that players behave honestly. In principle, the verification of the relation to be proven in zero-knowledge can be expressed as a function to which the prover provides the secret witness and which is evaluated in a secure way. The protocols generated by our compiler are much more efficient than this generic approach.</p>

    <p class="text-gray-300">On a lower level, Cryptography Aware language and cOmpiler (CAO) [BNPS05] provides compiler support for efficient and secure low-level implementation of cryptographic primitives resistant against software side-channels [BP05] and applications to elliptic curve cryptography [BMP07].</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;2 General Framework Description</h3>

    <p class="text-gray-300">In this section we present the theoretical framework underlying our compiler. We briefly review the theory by Cramer [Cra96] on  <span class="math">\\Sigma</span> -protocols and proofs of knowledge for special homomorphisms using the  <span class="math">\\Sigma^{\\phi}</span> -protocol in §2.1. On a high level, the class of special homomorphisms consists of homomorphisms where the co-domain is a known order group and of the power homomorphisms  <span class="math">\\phi(w) = w^e</span>  in hidden order groups. In the following §2.2 we describe how to compose  <span class="math">\\Sigma^{\\phi}</span> -protocols to obtain simultaneous proofs of knowledge for preimages under multiple homomorphisms (i.e., &quot;AND composition&quot;), and PoKs for subsets of preimages out of a given set (i.e., &quot;AND - OR composition&quot;). Finally, in §2.3 we present techniques to prove knowledge of linear relations among preimages of homomorphisms; these techniques can be combined in a modular way with the &quot;AND&quot; and &quot;AND-OR&quot; compositions. As a result we obtain a rich language of expressions that can be proved about preimages of homomorphisms, and a simple unified theory underlying these constructions.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;2.1 <span class="math">\\Sigma</span> -protocols and proofs of knowledge for special homomorphisms</h4>

    <p class="text-gray-300">By  <span class="math">s \\in_R S</span>  we denote uniform random choice of element s from set S. The cardinality of S is denoted by #S, and the power set of S by  <span class="math">2^S</span> . We write  <span class="math">(w_i)_{i=1}^n</span>  for the vector  <span class="math">(w_1, \\ldots, w_n)</span> . By  <span class="math">(w_1, \\ldots, w_n)^T</span>  we denote the transposed vector. A mapping  <span class="math">\\phi : \\mathcal{G} \\to \\mathcal{H}</span>  from an additive group  <span class="math">(\\mathcal{G}, +)</span>  into a multiplicative group  <span class="math">(\\mathcal{H}, \\cdot)</span>  is called <em>homomorphism</em>, iff  <span class="math">\\forall a, b \\in \\mathcal{G} : \\phi(a+b) = \\phi(a) \\cdot \\phi(b)</span> . By Im  <span class="math">\\phi</span>  we denote the <em>image of</em>  <span class="math">\\phi</span> , i.e., Im  <span class="math">\\phi = \\{z \\in \\mathcal{H} : \\exists w \\in \\mathcal{G} : z = \\phi(w)\\}</span> . Note that Im  <span class="math">\\phi</span>  is a subgroup of  <span class="math">\\mathcal{H}</span> .</p>

    <p class="text-gray-300">Let R be a binary relation and let  <span class="math">(x, w) \\in R</span> , where w is a witness and x an element of the associated language  <span class="math">L_R</span> . Informally, a proof of knowledge with knowledge error  <span class="math">\\kappa</span>  for R is a pair of interactive algorithms (P, V), such that every (potentially dishonest) prover  <span class="math">P^*</span>  who on input x can make verifier V accept with probability more than  <span class="math">\\kappa(x)</span> , has to know a w', such that  <span class="math">(x, w&#x27;) \\in R</span> ; further, V always accepts for the honest prover P. For a formal definition we refer to [BG93].</p>

    <p class="text-gray-300">A proof of knowledge in the auxiliary string model with knowledge error κ for relation R is a proof of knowledge where P and V additionally are given an auxiliary string α, which is chosen according to some predefined probability distribution. For a formal definition we refer to <a href="#page-19-12">[Dam00]</a>. We note that auxiliary string proofs of knowledge subsume the plain ones. We call a proof of knowledge in the plain or the auxiliary string model computational, if we restrict provers to be probabilistic polynomial-time (PPT) algorithms.</p>

    <p class="text-gray-300">All protocols generated by our compiler fall into the abstract class of Σ-protocols defined next.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;Definition 1 (Σ-protocol). Let R denote a binary relation, and consider a (x, w) ∈ R. Let P1, P2, and V denote arbitrary algorithms and α a (potentially empty) auxiliary string. A protocol between a prover P := P(x, w, α) and a verifier V := V(x, α) is called a Σ-protocol with challenge set C = {0, . . . , c+} if it satisfies the following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>3-move form: The protocol is of the following form:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P sets (r, state) := P1(x, w, α), sends r to V and keeps state secret.</li>
      <li>V sends a random challenge c ∈&lt;sup&gt;R&lt;/sup&gt; C to P</li>
      <li>P computes s := P2(x, w, state, c, α), sends s to V who accepts if predicate V(x, r, c, s, α) = true; otherwise he rejects.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Often r, c, s are referred to as commitment, challenge and response, respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness: For an honest prover, the verifier always accepts.</li>
      <li>Special honest-verifier zero-knowledge: There is a PPT algorithm S, called the simulator, which takes (x, c) as input and outputs a triple (r, c, s) the distribution of which is indistinguishable from the distribution of real communications between prover and verifier.</li>
    </ul>

    <p class="text-gray-300">If α is the empty string, we will omit it as a parameter.</p>

    <p class="text-gray-300">Concrete instances of a Σ-protocol are obtained by defining the algorithms P1, P2, V, and proving the protocol properties required by Definition <a href="#page-4-0">1.</a></p>

    <p class="text-gray-300">The significance of this definition is that the 3-move form and the completeness property underly the proof of knowledge property of all Σ-protocols currently being known. The completeness property of a Σ-protocol trivially corresponds to the completeness property required for a proof of knowledge.</p>

    <p class="text-gray-300">The 3-move form property is more interesting. In fact, based on this property one can show that there is an algorithm that, when given rewinding access to an arbitrary convicing prover in a Σ-protocol, will output two accepting communication triples (r, c&lt;sup&gt;0&lt;/sup&gt; , s0 ) and (r, c00, s00) (i.e., triples such that V(x, r, c&lt;sup&gt;0&lt;/sup&gt; , s0 ) = V(x, r, c00, s00) = true), satisfying c &lt;sup&gt;0&lt;/sup&gt; 6= c &lt;sup&gt;00&lt;/sup&gt;. This property is fundamental, since all currently existing knowledge extractors for Σ-protocols build upon this property. For a proof of this property see, e.g., Damg˚ard <a href="#page-19-13">[Dam04]</a>.</p>

    <p class="text-gray-300">Also, from the special honest-verifier zero-knowledge (special HVZK) property the plain HVZK property of Σ-protocols easily follows. Moreover, there exist techniques that allow to turn a Σprotocol into a zero-knowledge or concurrent zero-knowledge protocol, e.g. <a href="#page-19-12">[Dam00]</a>. The Fiat-Shamir heuristic allows to transform Σ protocols into non-interactive signatures of knowledge <a href="#page-19-14">[FS87]</a>.</p>

    <p class="text-gray-300">Next we describe a concrete Σ-protocol for homomorphisms with a finite domain.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;Definition 2 (Σ&lt;sup&gt;φ&lt;/sup&gt; -protocol). Let be given a homomorphism φ : G → H with a finite domain G and x = φ(w). The Σ&lt;sup&gt;φ&lt;/sup&gt; -protocol with prover P(x, w) and verifier V(x) is defined by choosing the algorithms P1, P2, and V, occurring in the definition of the Σ-protocol, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_1(x, w)</span>  chooses  <span class="math">k \\in_R \\mathcal{G}</span>  and sets  <span class="math">(r, state) := (\\phi(k), k)</span> .</li>
      <li><span class="math">P_2(x, w, state, c)</span>  computes s := k + cw.</li>
      <li>V(x, r, c, s) = true, iff  <span class="math">\\phi(s) = rx^c</span> .</li>
    </ul>

    <p class="text-gray-300">For any  <span class="math">\\phi</span>  with a finite domain the  <span class="math">\\Sigma^{\\phi}</span> -protocol with binary challenge set  <span class="math">\\mathcal{C} = \\{0,1\\}</span>  is a  <span class="math">\\Sigma</span> -protocol according to Definition 1 and it can be shown to be a proof of knowledge with knowledge error 1/2, e.g., [Cra96]. To obtain a sufficiently small knowledge error it needs to be repeated sequentially, e.g., 80 repetitions are required to reduce the knowledge error to  <span class="math">1/2^{80}</span> . The resulting proofs are not sufficiently efficient for many practical applications. For so called <em>special homomorphisms</em> we can obtain much more efficient proofs, since they allow to obtain a small knowledge error in a single execution of the  <span class="math">\\Sigma^{\\phi}</span> -protocol.</p>

    <p class="text-gray-300"><strong>Definition 3 (Special Homomorphism [Cra96]).</strong> A homomorphism  <span class="math">\\phi</span>  is called special, if there is a PPT algorithm that on input  <span class="math">\\phi: \\mathcal{G} \\to \\mathcal{H}</span>  and  <span class="math">x \\in \\text{Im } \\phi</span>  outputs  <span class="math">(u, v) \\in \\mathcal{G} \\times \\mathbb{Z} \\setminus \\{0\\}</span> , such that  <span class="math">x^v = \\phi(u)</span> . For a given  <span class="math">\\phi</span> , the special exponent v being output has to be the same for all x.</p>

    <p class="text-gray-300">Many homomorphisms used in cryptography are special. For example every homomorphism  <span class="math">\\phi</span> , for which a non-zero multiple v of the order of Im  <span class="math">\\phi</span>  is known, is special, since  <span class="math">x^v = 1 = \\phi(0)</span>  for all  <span class="math">x \\in \\text{Im } \\phi</span> . Especially, if the order of  <span class="math">\\mathcal{H}</span>  is known, one can set  <span class="math">v := \\text{ord}(\\mathcal{H})</span> . There are also special homomorphisms for which the order of the image is unknown (and in fact hard to compute). For instance, consider a power homomorphism  <span class="math">\\phi : \\mathbb{Z}_n^* \\to \\mathbb{Z}_n^*, x \\mapsto x^e</span>  where n is an RSA modulus and  <span class="math">e \\in \\mathbb{Z}</span> . Then for every  <span class="math">x \\in \\text{Im } \\phi</span>  the pair (x, e) satisfies  <span class="math">x^e = \\phi(x)</span> , and thus  <span class="math">\\phi</span>  is special. Examples for efficient protocols relying on special homomorphisms are those given by Schnorr [Sch91] and by Guillou and Quisquater [GQ88].</p>

    <p class="text-gray-300">For the proof of the following theorem on special homomorphisms we refer to §A.1:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-1&quot;&gt;&lt;/span&gt;<strong>Theorem 1.</strong> Let  <span class="math">\\phi</span>  be a special homomorphism, and let  <span class="math">c^+</span>  be smaller than the smallest prime dividing its special exponent v. Then the  <span class="math">\\Sigma^{\\phi}</span> -protocol is a  <span class="math">\\Sigma</span> -protocol with challenge set  <span class="math">\\mathcal{C} = \\{0, \\ldots, c^+\\}</span>  according to Definition 1, and a HVZK proof of knowledge with knowledge error  <span class="math">1/\\#\\mathcal{C}</span>  for  <span class="math">\\phi</span> .</p>

    <p class="text-gray-300"><strong>Notation of ZK-PoKs.</strong> We will use the notation introduced in [CS97a] to denote ZK-PoKs. That is, a term like</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{ZPK}\\bigg[(\\omega_1,\\omega_2):x_1=\\phi_1(\\omega_1)\\quad\\wedge\\quad x_2=\\phi_2(\\omega_2)\\quad\\wedge\\quad\\omega_1=a\\omega_2\\bigg]</span>$</p>

    <p class="text-gray-300">means, that knowledge of  <span class="math">w_1, w_2</span>  has to be proven such that  <span class="math">x_1 = \\phi_1(w_1)</span> ,  <span class="math">x_2 = \\phi_2(w_2)</span>  and  <span class="math">w_1 = aw_2</span> . We will stick to the convention that knowledge of variables denoted by Greek letters has to be proven, whereas all other quantities are assumes to be publicly known.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;2.2 Boolean composition of preimage proofs</h4>

    <p class="text-gray-300">In many cryptographic applications simple preimage proofs are not sufficient. Hence we will describe the techniques used in our compiler to prove knowledge of a subset of preimages. To this end, we will consider the case of pure AND-proofs, followed by proofs for arbitrary monotone boolean formulae.</p>

    <p class="text-gray-300"><strong>AND</strong> - <strong>proofs.</strong> First, we consider the pure AND-proof, i.e., proofs of knowledge of multiple preimages under possibly different homomorphisms. Using the notation of Camenisch and Stadler</p>

    <p class="text-gray-300"><a href="#page-18-5">[CS97a]</a> we want to perform the following ZK-PoK:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-3&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathsf{ZPK}\\bigg[(\\omega_i)_{i=1}^m: \\bigwedge_{i=1}^m x_i = \\phi_i(\\omega_i)\\bigg]. \\tag{1}</span>$</p>

    <p class="text-gray-300">Here, the φ&lt;sup&gt;i&lt;/sup&gt; : G&lt;sup&gt;i&lt;/sup&gt; → H&lt;sup&gt;i&lt;/sup&gt; are special homomorphisms. For notational convenience, we will describe the composition of two proofs only (i.e., m = 2); generalisation to an arbitrary m is straightforward. This means, we show how to ZPK-(ω1, ω2) : x&lt;sup&gt;1&lt;/sup&gt; = φ1(ω1) ∧ x&lt;sup&gt;2&lt;/sup&gt; = φ2(ω2) :</p>

    <p class="text-gray-300">To this end, define φ : G1×G&lt;sup&gt;2&lt;/sup&gt; → H1×H&lt;sup&gt;2&lt;/sup&gt; by (w1, w2) 7→ (φ1(w1), φ2(w2)). Set w := (w1, w2) and x := (x1, x2). Then performing ZPK-(ω) : x = φ(ω) proves knowledge of the required preimages, if one chooses c &lt;sup&gt;+&lt;/sup&gt; smaller than the smallest prime dividing lcm(v1, v2), where v&lt;sup&gt;i&lt;/sup&gt; is the special exponent of φ&lt;sup&gt;i&lt;/sup&gt; .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-4&quot;&gt;&lt;/span&gt;Lemma 1. Using the AND-composition technique described above yields a special HVZK proof of knowledge (in the plain model) for the preimages w1, w&lt;sup&gt;2&lt;/sup&gt; under special homomorphisms φ1, φ2.</p>

    <p class="text-gray-300">Proof (Sketch). Note that φ is special with special exponent lcm(v1, v2). Hence, using Theorem <a href="#page-5-1">1</a> we have that the according Σ&lt;sup&gt;φ&lt;/sup&gt; -protocol is a Σ-protocol. ut</p>

    <p class="text-gray-300">Proofs of expressions containing ORs. Let's now consider AND-OR-proofs, i.e., proofs of arbitrary monotone boolean formulae. Let be given x&lt;sup&gt;i&lt;/sup&gt; = φi(wi) for i = 1, . . . , n. Let each φ&lt;sup&gt;i&lt;/sup&gt; be special. Further, let be given a monotone access structure Γ on {1, . . . , n}. That is, Γ ⊆ 2 {1,...,n} satisfying that, if A ∈ Γ and A ⊆ B, then B ∈ Γ. We explain how to construct a ZK-PoK for:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathsf{ZPK}\\bigg[(\\omega_i)_{i=1}^n: \\bigvee_{A \\in \\Gamma} \\bigwedge_{j \\in A} x_j = \\phi_j(\\omega_j)\\bigg]. \\tag{2}</span>$</p>

    <p class="text-gray-300">To this end, we use the technique of Cramer, Damg˚ard and Schoenmakers <a href="#page-18-10">[CDS94]</a>, which uses secret sharing schemes <a href="#page-19-17">[Sha79,</a><a href="#page-18-21">Bla79]</a> to yield efficient HVZK proofs of knowledge for expressions like <a href="#page-6-1">(2)</a>. These PoKs are perfect HVZK in the plain model. For details we refer to <a href="#page-18-10">[CDS94]</a>.</p>

    <p class="text-gray-300">Our compiler uses Shamir's secret sharing scheme <a href="#page-19-17">[Sha79]</a>, which allows to realize any threshold access structure, i.e., there is a k ≤ n, s.t. A ∈ Γ, if and only if #A ≥ k; we stress that this covers OR-proofs, as an OR can be seen as a threshold scheme with k = 1.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;2.3 Relations among preimages</h3>

    <p class="text-gray-300">Next we will describe how homogeneous linear relations among the preimages can be proven. For better understanding, we first consider a simple example, where only one equation has to be satisfied:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathsf{ZPK}\\left[(\\omega_1, \\omega_2) : x_1 = \\phi_1(\\omega_1) \\land x_2 = \\phi_2(\\omega_2) \\land \\omega_2 = b\\omega_1\\right] \\tag{3}</span>$</p>

    <p class="text-gray-300">The idea now is quite simple: first, note that the set Gˆ of pairs satisfying the relation is a subgroup of G 2 ; that is, Gˆ = {(z, bz) : z ∈ G}. So, define φ : G → H ˆ &lt;sup&gt;1&lt;/sup&gt; × H&lt;sup&gt;2&lt;/sup&gt; as the cartesian product of φ&lt;sup&gt;1&lt;/sup&gt; and φ2, and let x := (x1, x2). Then <a href="#page-6-2">(3)</a> can be proven by performing ZPK-(ω) : x = φ(ω) . Note that r ∈&lt;sup&gt;R&lt;/sup&gt; Gˆ can be drawn efficiently by choosing r&lt;sup&gt;1&lt;/sup&gt; ∈&lt;sup&gt;R&lt;/sup&gt; G and setting r := (r1, br1). This is essentially the same idea as in <a href="#page-19-9">[CS97b]</a>, where this technique is used to prove that two discrete logarithms are equal.</p>

    <p class="text-gray-300">Let us now generalize this to the general case, with an arbitrary number of homomorphisms and linear relations. Assume one has m homomorphisms  <span class="math">\\phi_j: \\mathcal{G}^{n_j} \\to \\mathcal{H}_j</span>  and a family of sets  <span class="math">\\Theta \\subseteq 2^{\\{1,\\dots,m\\}}</span> . For each j, let  <span class="math">x_j = \\phi_j(w_{j1},\\dots,w_{jn_j})</span> . We show how to prove the following statement:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathsf{ZPK}\\bigg[\\big((\\omega_{j1},\\ldots,\\omega_{jn_j})_{j=1}^m\\big):\\bigvee_{S\\in\\Theta}\\Big(\\bigwedge_{j\\in S}x_j=\\phi_j(\\omega_{j1},\\ldots,\\omega_{jn_j})\\ \\land\\ \\mathbf{0}=A_S\\cdot((\\omega_{j1},\\ldots,\\omega_{jn_j})_{j\\in S})^T\\Big)\\bigg].</span>$</p>

    <p class="text-gray-300">Here, for each  <span class="math">S \\in \\Theta</span> ,  <span class="math">A_S</span>  denotes an integer matrix with  <span class="math">\\sum_{j \\in S} n_j</span>  columns and as many rows as linear relation have to be satisfied, of the following form:</p>

    <p class="text-gray-300"><span class="math">$A_S = \\begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; * \\cdots &amp; * \\\\ 0 &amp; \\ddots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 1 &amp; * &amp; \\cdots &amp; * &amp; \\cdots &amp; * \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">In the following we assume that all  <span class="math">\\phi_j</span>  in (4) are special homomorphisms, for which the special exponent is a nonzero multiple of ord(Im  <span class="math">\\phi</span> ). Then the 4 can be handled using the composition techniques of §2.2 by additionally performing the following steps for each  <span class="math">S \\in \\Theta</span>  first:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">x_S := (x_j)_{j \\in S}</span>  be the vector consisting of all images in S.</li>
      <li>Define  <span class="math">\\mathcal{G}_S</span>  as the subgroup of  <span class="math">\\prod_{j\\in S} \\mathcal{G}^{n_j}</span>  consisting of all tuples satisfying the linear relations in (4) within the conjunctive clauses corresponding to S. Because of the form of  <span class="math">A_S</span> , random choices can be done efficiently in  <span class="math">\\mathcal{G}_S</span>  by forward substitution.</li>
      <li>The homomorphism  <span class="math">\\phi_S: \\mathcal{G}_S \\to \\prod_{j \\in S} \\mathcal{H}_j</span>  is set to the cartesian product of all  <span class="math">\\phi_j</span>  with  <span class="math">j \\in S</span> .</li>
    </ul>

    <p class="text-gray-300">Using this approach, expression (4) reduces to an OR-proof among the preimages of the  <span class="math">x_S</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{ZPK}\\bigg[\\big((\\omega_{j1},\\ldots,\\omega_{jn_j})_{j=1}^m\\big):\\bigvee_{S\\in\\Theta}x_S=\\phi_S((\\omega_{j1},\\ldots,\\omega_{jn_j})_{j\\in S})\\bigg].</span>$</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let the special exponent  <span class="math">v_j</span>  of  <span class="math">\\phi_j</span>  be a nonzero multiple of the order of Im  <span class="math">\\phi_j</span>  for all  <span class="math">j \\in \\{1, ..., m\\}</span> . Then performing the steps described above yields a  <span class="math">\\Sigma</span> -protocol to prove knowledge of preimages satisfying the conditions in (4).</p>

    <p class="text-gray-300"><em>Proof.</em> We show that all  <span class="math">\\phi_S</span>  are special: As  <span class="math">v_j</span>  is a (nonzero) multiple of the order of Im  <span class="math">\\phi_j</span> , the same holds for  <span class="math">v_S := \\prod_{j \\in S} v_j</span>  and  <span class="math">\\phi_S</span> . Set u = 0 for all  <span class="math">x \\in \\text{Im } \\phi_S</span> . Then  <span class="math">x^{v_S} = 1 = \\phi_S(0)</span>  and the zero-vector trivially satisfies all homogeneous linear equations. So the claim follows by Lemma 1 and the correctness of the OR-composition by [CDS94].</p>

    <p class="text-gray-300">So far we have restricted the domain of each homomorphism to be  <span class="math">\\mathcal{G}^{n_j}</span> . Yet, the above result can easily be generalized to the case of arbitrary domains, as long as all preimage within one linear relation in (4) are elements of the same group. This is already implemented in our compiler.</p>

    <p class="text-gray-300"><strong>Further relations.</strong> Using the methods described so far, it is possible to prove all statements that can algebraically be derived from preimage proofs using boolean composition and linear relations. For instance multiplicative relations can be performed manually with our current compiler:</p>

    <p class="text-gray-300">Example 1 (Multiplicative Relations modulo ord(G)). To prove knowledge of the discrete logarithms w1, w2, w&lt;sup&gt;3&lt;/sup&gt; of x1, x2, x3, satisfying w1w&lt;sup&gt;2&lt;/sup&gt; = w&lt;sup&gt;3&lt;/sup&gt; mod ord(G) one can perform the following proof:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{ZPK}\\bigg[(\\omega_{1},\\omega_{2},\\omega_{3}): x_{1} = g^{\\omega_{1}} \\wedge x_{2} = g^{\\omega_{2}} \\wedge x_{3} = g^{\\omega_{3}} \\wedge x_{3} = x_{1}^{\\omega_{2}}\\bigg].</span>$</p>

    <p class="text-gray-300">Example 2 (Polynomial Relations modulo ord(G)). As a special case of the previous example one can show that one preimage is a power of another one, which together with linear relations allows to prove polynomial relations without constant terms. If in the previous example the relation w&lt;sup&gt;3&lt;/sup&gt; = w 2 &lt;sup&gt;1&lt;/sup&gt; + w&lt;sup&gt;2&lt;/sup&gt; mod ord(G) has to be satisfied, the problem can be reduced to one only containing linear constraints <a href="#page-18-5">[CS97a]</a>, which can be handled as explained before:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{ZPK}\\bigg[(\\omega_1, \\omega_2, \\omega_3, \\mu) : x_1 = g^{\\omega_1} \\wedge x_2 = g^{\\omega_2} \\wedge x_3 = g^{\\omega_3} \\wedge 1 = g^{\\mu} x_1^{-\\omega_1} \\wedge \\omega_3 = \\mu + \\omega_2\\bigg].</span>$</p>

    <p class="text-gray-300">Example 3 (Range Proof ). As suggested in <a href="#page-18-0">[CM99]</a> one can proof knowledge of a preimage ω of x = φ(ω) that lies in a given range, i.e., 2<code>&lt;sup&gt;1&lt;/sup&gt; − 2 </code>&lt;sup&gt;2&lt;/sup&gt; ≤ ω ≤ 2 <code>&lt;sup&gt;1&lt;/sup&gt; + 2</code>&lt;sup&gt;2&lt;/sup&gt; for public constants <code>1, </code>2, by committing to the bits of ω with Pederson's homomorphic commitment scheme <a href="#page-19-4">[Ped92]</a> and then proving that the commitments hide either 0 or 1 and constitute the binary representation of ω.</p>

    <p class="text-gray-300">In the following two sections we describe how our current compiler implements the described general framework in §<a href="#page-8-0">3</a> and give practical examples in §<a href="#page-12-0">4.</a> Theoretically interested readers can safely skip these sections and continue reading in §<a href="#page-13-0">5</a> how the general framework presented in this section can be extended to hidden order groups.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;3 Implementation of the Compiler</h3>

    <p class="text-gray-300">As a proof of concept, we have implemented a compiler that brings the theoretical framework of §<a href="#page-3-1">2</a> into practice. That is, the current version of the compiler supports the Σ&lt;sup&gt;φ&lt;/sup&gt; -protocol (cf. Definition <a href="#page-4-1">2)</a> for proofs of special homomorphisms, especially including all homomorphisms with known-order co-domain. Future versions will also be able to prove exponentiation homomorphisms in unknownorder groups using the techniques described in §<a href="#page-13-0">5.</a></p>

    <p class="text-gray-300">The compiler is based on work in <a href="#page-18-11">[Bri04]</a> and IBM Research and we plan to publish it as an open source project soon. It translates a high-level protocol specification into a complete, sound and HVZK Σ-protocol for special homomorphisms using the techniques of §<a href="#page-5-0">2.2</a> and §<a href="#page-6-0">2.3.</a></p>

    <p class="text-gray-300">The input of the compiler is a protocol specification in a language which is very close to the intuitive and widely used notation of Camenisch-Stadler <a href="#page-18-5">[CS97a]</a> with extensions to specify the underlying algebraic structures precisely.</p>

    <p class="text-gray-300">The output of the compiler is either a human-readable specification of the protocol in LATEX or JAVA source code for prover and verifier that can be compiled into runnable code. The JAVA code corresponds to the algorithms of the Σ-protocol for prover and verifier (P1, P2, V) that can easily be integrated into high-level user applications. Some parameters that can not be inferred by the compiler automatically (like the size of the challenge set) must be chosen by the user according to the theory and provided as constructor arguments. The compiler was designed modularly to be easily extendible with other backends, e.g., to produce C-code for specific embedded platforms.</p>

    <p class="text-gray-300">Next, we describe the semantics of the input language using a practical running example. We discuss two more practical examples to demonstrate the broad applicability of our compiler in §<a href="#page-12-0">4.</a> The complete EBNF specifying the syntax of the input language formally is given in Appendix <a href="#page-21-0">B.</a></p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Overview</h3>

    <p class="text-gray-300">As running example we show how our compiler can be used to automatically generate protocols to prove relations between plaintexts encrypted with the Damg˚ard-Jurik crypto system <a href="#page-19-8">[DJ01]</a>. The running example proves that ciphertext x&lt;sup&gt;a&lt;/sup&gt; is either an encryption of 0 or 1 and that prover knows the plaintext of ciphertexts x&lt;sup&gt;b&lt;/sup&gt; and x&lt;sup&gt;c&lt;/sup&gt; being encryptions of the same message µ, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{ZPK} \\bigg[ (\\mu, (\\rho_i)_{i=1}^4) : (x_a = E(0, \\rho_1) \\vee x_a = E(1, \\rho_2)) \\wedge x_b = E(\\mu, \\rho_3) \\wedge x_c = E(\\mu, \\rho_4) \\bigg].</span>$</p>

    <p class="text-gray-300">with E(., .) denoting the encryption function and ρ&lt;sup&gt;i&lt;/sup&gt; randomization parameters.</p>

    <pre><code class="language-text">// Declarations
     Group Zn, Zm*;
     GroupElement g,x_a,x_b,x_c,rho_[0..3],mu;
     Homomorphism phi_[0..3];
     IntegerConstant n;
// Assignments
     AssignGroupMember(Zn, mu);
     AssignGroupMember(Zm*,{g,x_a,x_b,x_c,rho_[0..3]});
// Definitions
     DefineHomomorphism(phi_0, (rho_0) |-&gt; (rho_0^n));
     DefineHomomorphism(phi_1, (rho_1) |-&gt; (rho_1^n));
     DefineHomomorphism(phi_2, (mu,rho_2) |-&gt; (g^mu * rho_2^n));
     DefineHomomorphism(phi_3, (mu,rho_3) |-&gt; (g^mu * rho_3^n));
// Protocol Specification
     SpecifyProtocol [
       Relation = ([(x_a)=phi_0(rho_0)] || [(x_a*g^(-1))=phi_1(rho_1)])
         &amp;&amp; ([(x_b)=phi_2(mu,rho_2)] &amp;&amp; [(x_c)=phi_3(mu,rho_3)]);
       Target = LATEX;
       Layout = COMPACT;
     ]
</code></pre>

    <p class="text-gray-300">The LATEX output generated by our compiler is given in Appendix <a href="#page-23-0">C.</a></p>

    <p class="text-gray-300">As in the example, all input files are composed of four parts for Declarations (cf. § <a href="#page-9-0">3.2)</a>, Assignments (cf. §<a href="#page-10-0">3.3)</a>, Definitions (cf. §<a href="#page-10-1">3.4)</a>, and Protocol Specification (cf. §<a href="#page-10-2">3.5)</a> in the given order that are described in the following sections.</p>

    <p class="text-gray-300">Line comments starting with // can be inserted at any place, statements are terminated with ';', and arrays are used as shortcut, e.g., rho_[0..3] is equivalent to rho 0,rho 1,rho 2,rho 3.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;3.2 Declarations</h3>

    <p class="text-gray-300">Each variable must be declared as Group, GroupElement, Homomorphism, or IntegerConstant before usage. The order of declarations is arbitrary. For convenience, multiple variables separated with ',' can be declared in the same line.</p>

    <p class="text-gray-300">Most relevant groups are already pre-defined in the compiler while abstraction allows users to add arbitrary groups.</p>

    <p class="text-gray-300">Pre-defined finite additive (Zm) resp. multiplicative (Z ∗ &lt;sup&gt;m&lt;/sup&gt;) groups modulo m are defined as uppercase Z followed by a letter for the modulus and an optional * to indicate the multiplicative group, i.e., Group Zn; declares group (Zn, +) resp. Group Zm*; declares group (Z ∗ &lt;sup&gt;m&lt;/sup&gt;, ∗). In the implementation, the corresponding modulus is given as constructor parameter, e.g., m would be set to n 2 in the running example when used for Paillier crypto system.</p>

    <p class="text-gray-300">Alternatively, abstract groups like Group (G,+) or Group(H,*) can be declared for which an abstract class is generated that allows easy integration of arbitrary groups like elliptic curve groups. The first parameter is the name of the group whereas second parameter denotes whether the group is written additively (+) or multiplicatively (*).</p>

    <p class="text-gray-300">Other declarations have the structure &lt;Type&gt; &lt;VariableName&gt;;, where &lt;Type&gt; is either GroupElement, Homomorphism, or IntegerConstant and &lt;VariableName&gt; has to start with a letter followed by letters, numbers or underscores (_).</p>

    <p class="text-gray-300">The pre-defined parameter names shown in Table <a href="#page-22-0">1</a> in the appendix are reserved for code generation and hence can not be used as variable names. Alternatively, pre-defined parameter names can be changed in the ParameterNames section described later.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;3.3 Assignments</h3>

    <p class="text-gray-300">In this section of the input file, each group element must be assigned to one group declared before. Single group elements can be assigned with AssignGroupMember(Zn,mu);. Multiple group elements are grouped in braces like AssignGroupMember(Zm*,{g,x a,...}); in the running example.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;3.4 Definitions</h3>

    <p class="text-gray-300">Homomorphisms can be defined either concrete or abstract. They must already have been declared before.</p>

    <p class="text-gray-300">Concrete definition maps elements explicitly from domain to co-domain, e.g., DefineHomomorphism(phi 2, (mu,rho 2) |-&gt; (g^mu*rho 2^n)); for homomorphism φ&lt;sup&gt;2&lt;/sup&gt; : (µ, ρ2) 7→ g µ · ρ&lt;sup&gt;2&lt;/sup&gt; n in the running example.</p>

    <p class="text-gray-300">The mapping can consist of group elements (i.e., g) and integer constants (i.e., n) defined before as well as integer numbers (i.e., 1 in the definition of φ1). It must be semantically correct, e.g., only combines group elements of the same group with its group operation. For concrete homomorphisms a class is generated that implements the homomorphism using the corresponding group operations.</p>

    <p class="text-gray-300">Alternatively, abstract definition, e.g., DefineHomomorphism(phi, G 1 # G 2 -&gt; H 1 # H 2);, specifies only the domain (G&lt;sup&gt;1&lt;/sup&gt; × G2) and the co-domain (H&lt;sup&gt;1&lt;/sup&gt; × H2) of the homomorphism φ : G&lt;sup&gt;1&lt;/sup&gt; × G&lt;sup&gt;2&lt;/sup&gt; → H&lt;sup&gt;1&lt;/sup&gt; × H2. An interface is generated that can be instantiated with a corresponding implementation of an arbitrary complex homomorphism.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;3.5 Protocol Specification</h3>

    <p class="text-gray-300">The protocol specification is encapsulated in a block SpecifyProtocol [ . . . ] and contains the specification of the protocol in the order given in this section. Relation and Target must be specified whereas Constraints, ParameterNames and Layout are optional.</p>

    <p class="text-gray-300">Relation (cf. §<a href="#page-5-0">2.2)</a>. Group elements must be related to homomorphisms together with an optional access structure. The relation can be given either in boolean or enumerative description as follows.</p>

    <p class="text-gray-300">Boolean description is close to Camenisch-Stadler notation <a href="#page-18-5">[CS97a]</a>, e.g., the relation in the running example directly corresponds to (x&lt;sup&gt;a&lt;/sup&gt; = φ0(ρ0) ∨ xa/g = φ1(ρ1)) ∧ x&lt;sup&gt;b&lt;/sup&gt; = φ2(µ, ρ2) ∧ x&lt;sup&gt;c&lt;/sup&gt; = φ3(µ, ρ3). It consists of literals encapsulated in [...] that relate preimages via homomorphisms to images. The access structure is specified as monotone boolean operators AND (&amp;&amp;) resp. OR (||) between the literals and is compiled into AND- resp. OR-proofs. Additionally, arithmetic expressions, i.e., semantically correct expressions (cf. previous section) on publicly known values (images, integer constants and integers), can be defined on the left-hand side of the literals, e.g., [(x_a^(5*n))=phi_0(rho_3)].</p>

    <p class="text-gray-300">Alternatively, enumerative description allows more detailed specification of the access structure. The relation of the running example is equivalent to</p>

    <pre><code class="language-text">Relation [
  CommonInput = {(phi_0,(x_a)),(phi_1,(x_a*g^(-1))),(phi_2,(x_b)),(phi_3,(x_c))};
  PreimageInput = {(rho_0),(rho_1),(mu,rho_2),(mu,rho_3)};
  AccessStructure = {{phi_0,phi_2,phi_3},{phi_1,phi_2,phi_3}};
]
</code></pre>

    <p class="text-gray-300">in enumerative description. The common input and the preimage input are both ordered lists of tuples that correspond to each other in number and position. Each tuple of the common input consists of the name of the homomorphism (e.g., phi_i)) followed by the list of its publicly known images (e.g., (x_i)). Each tuple of the preimage input is the list of private preimages (e.g., (rho_0), (rho_1), (mu,rho_2), resp. (mu,rho_3)) of the homomorphism defined in the same position of the common input. Hence, the first position of the example above specifies that x&lt;sup&gt;a&lt;/sup&gt; = φ0(ρ0). The access structure is given as a set of qualified sets that describes its disjunctive normal form (DNF). If an honest prover knows all preimages of one qualified set, e.g., the preimages of φ0, φ&lt;sup&gt;2&lt;/sup&gt; and φ&lt;sup&gt;3&lt;/sup&gt; or those of φ1, φ&lt;sup&gt;2&lt;/sup&gt; and φ&lt;sup&gt;3&lt;/sup&gt; in the example, the honest verifier will accept the proof. The compiler automatically generates a combination of AND and OR-proofs corresponding to the DNF of the specified access structure.</p>

    <p class="text-gray-300">If the access structure is not specified, an abstract class is generated to allow arbitrary implementation of monotone access structures. We have implemented a threshold access structure based on Shamir's Secret Sharing <a href="#page-19-17">[Sha79]</a> to efficiently prove knowledge of k out-of n preimages <a href="#page-18-10">[CDS94]</a>.</p>

    <p class="text-gray-300">Constraints (cf. §<a href="#page-6-0">2.3)</a>. Homogenous linear relations between preimages can be expressed as constraints, e.g., Constraints = (w 1=3*w 2+w 3)&amp;&amp;(w 4=-w 1)&amp;&amp;(w 5=w 6);. For multiplicatively written groups with group operation * the first constraint would be written as (w_1=w_2^3*w_3), the second as w_4=w_1^(-1).</p>

    <p class="text-gray-300">All preimages in one constraint must belong to the same group and the left hand side must always be a single variable. Multiple constraints can be connected with &amp;&amp; and are valid globally for all homomorphisms that depend on the corresponding preimages.</p>

    <p class="text-gray-300">If linear combinations of the same preimages are re-used in multiple homomorphisms, e.g., m in the running example, they are automatically converted into an explicit constraint, i.e., the input in the running example is internally changed to:</p>

    <pre><code class="language-text">Relation =...&amp;&amp;([(x b)=phi 2(mu phi 2,rho 2)]&amp;&amp;[(x c)=phi 3(mu phi 3,rho 3)]);
Constraints = (mu phi 2=mu phi 3);.
</code></pre>

    <p class="text-gray-300">The order of constraints is important in order to avoid cyclic dependencies. If a preimage is assigned on the left hand side of a constraint it must only be used on the right hand side of later constraints only (in left-to-right order). E.g. the order in Constraints = (omega 1=omega 2) &amp;&amp; (omega 3=omega 1); is correct while swapping the two constraints would be invalid. For simplicity, the compiler assigns the variables from left to right so each variable has to be assigned before its value is used in a later assignment. Naturally, cyclic assignments like (omega 1=omega 2) &amp;&amp; (omega 2=omega 1) are impossible with this notation. Future versions of the compiler might find a correct ordering of assignments automatically but still detect cyclic assignments.</p>

    <p class="text-gray-300">ParameterNames. Pre-defined parameter names can be changed from their default name given in Table <a href="#page-22-0">1</a> in the appendix to avoid conflicts with user-defined variable names like ParameterNames{VarRandom=u; VarChallenge=z;}.</p>

    <p class="text-gray-300">Target. The back-end of the compiler used for output generation can be specified as target. Target = JAVA; generates JAVA source code for prover and verifier that can be compiled into runnable code, Target = LATEX; a human-readable summary of the protocol in LATEX.</p>

    <p class="text-gray-300">Layout. The layout of the LATEX output (Target = LATEX;) is set to compact mode by specifying Layout = COMPACT; or verbose mode if Layout is omitted. Compact mode puts together multiple homomorphisms to visualize the protocol specification in a more compact way.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;4 Examples</h3>

    <p class="text-gray-300">We describe two real-world applications demonstrating the broad applicability of our compiler in practice. For lack of space, only the input specifications are given here while the corresponding LATEX outputs generated by the compiler can be found in the appendix.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;4.1 Group Signature Scheme</h3>

    <p class="text-gray-300">A group signature scheme allows members of a group to sign messages s.t. the signature does not reveal their identity. Only a designated group manager is able to identify the group member who issued a given signature. Camenisch and Lysyanskaya [CL04] propose an efficient group signature scheme that extends the approach of [CS97a] to known order groups of prime order q with bilinear maps. The example demonstrates how our compiler can be used to automatically generate the  <span class="math">\\Sigma</span> -protocol underlying their signature proof of knowledge</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SPK}\\bigg[(\\mu,\\rho,\\nu): v_s^\\rho = v_x v_{xy}^\\mu \\wedge c_1 = g^\\nu \\wedge c_2 = h^\\nu \\wedge c_3 = y_1^\\nu g^\\mu \\wedge c_4 = (y_2 y_3^H)^\\nu\\bigg](m)</span>$</p>

    <p class="text-gray-300">where  <span class="math">H := \\mathcal{H}(c_1||c_2||c_3)</span> . The first clause proving knowledge of a CL signature [CL02] is rewritten as  <span class="math">v_x = v_s^{\\rho} v_{xy}^{-\\mu}</span>  in the protocol specification. The generated LATEX output is given in Appendix D.</p>

    <pre><code class="language-text">// Declarations
     Group Zq, (G,*);
     GroupElement g,h,mu,rho,nu,v_x,v_s,v_xy,H,y_[1..3],c_[1..4];
     Homomorphism phi_[0..4];
// Assignments
     AssignGroupMember(Zq, {mu,rho,nu,H});
     AssignGroupMember(G, {g,h,v_x,v_s,v_xy,y_[1..3],c_[1..4]});
// Definitions
     DefineHomomorphism(phi_0, (rho,mu) |-&gt; (v_s^rho * v_xy^(-1*mu)));
     DefineHomomorphism(phi_1, (nu) |-&gt; (g^nu));
     DefineHomomorphism(phi_2, (nu) |-&gt; (h^nu));
     DefineHomomorphism(phi_3, (nu,mu) |-&gt; (y_1^nu * g^mu));
     DefineHomomorphism(phi_4, (nu) |-&gt; ((y_2*y_3^H)^nu));
// Protocol Specification
     SpecifyProtocol [
       Relation = [(v_x) = phi_0(rho, mu)] \\&amp;\\&amp; [(c_1) = phi_1(nu)] \\&amp;\\&amp;
         [(c_2) = phi_2(nu)] \\&amp;\\&amp; [(c_3) = phi_3(nu,mu)] \\&amp;\\&amp; [(c_4) = phi_4(nu)];
       Target = LATEX;
     ]
</code></pre>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;4.2 Ring Signature Scheme</h4>

    <p class="text-gray-300">The second example demonstrates automatic generation of the proofs from a basic ring signature scheme [CDS94] based on a Schnorr signature [Sch91]. Ring signatures are group signatures without a group manager who can unveil the identity of the issuer of a ring signature. A ring signature can</p>

    <p class="text-gray-300">be issued by proving knowledge of one secret key  <span class="math">w_j</span>  of the <em>n</em> public keys  <span class="math">x_1, \\ldots, x_n</span>  associated to the members of the group with the following signature proof of knowledge</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{SPK} \\Big[ (w_1, \\dots, w_n) : x_1 = g^{w_1} \\vee \\dots \\vee x_n = g^{w_n} \\Big] (m).</span>$</p>

    <p class="text-gray-300">The example generates the underlying  <span class="math">\\Sigma</span> -protocol for n=3 members.</p>

    <pre><code class="language-text">// Declarations
     Group Zq, Zp*;
     GroupElement g,x_[1..3],w_[1..3];
     Homomorphism phi_[1..3];
// Assignments
     AssignGroupMember(Zq, {w_[1..3]});
     AssignGroupMember(Zp*, {g,x_[1..3]});
     DefineHomomorphism(phi_1, (w_1) |-&gt; (g^w_1));
     DefineHomomorphism(phi_2, (w_2) \\mapsto (g^w_2));
     DefineHomomorphism(phi_3, (w_3) |-&gt; (g^w_3));
// Protocol Specification
     SpecifyProtocol [
       Relation [
         CommonInput = \\{(phi_1,(x_1)), (phi_2,(x_2)), (phi_3,(x_3))\\};
         PreimageInput = {(w_1),(w_2),(w_3)};
         AccessStructure = {{phi_1},{phi_2},{phi_3}};
       Target = LATEX;
       Layout = COMPACT;
</code></pre>

    <p class="text-gray-300">AccessStructure allows specification of an arbitrary access structure of signers who are qualified to sign on the group's behalf. If AccessStructure is omitted it is generated as abstract class. Instantiation with the implemented threshold access structure yields a ring signature scheme where valid signatures can be issued by cooperation of at least k of the n members of the group [CDS94].</p>

    <p class="text-gray-300">The generated LATEX output is given in Appendix E.</p>

    <p class="text-gray-300">The  <span class="math">\\Sigma^{\\phi}</span> -protocol as defined in §2 can only be used efficiently if the underlying homomorphism is special. To overcome this limitation, we introduce a novel protocol (the  <span class="math">\\Sigma^{exp}</span> -protocol) in §5.1, which yields efficient proofs of knowledge for exponentiation homomorphisms in hidden order groups. The  <span class="math">\\Sigma^{exp}</span> -protocol extends ideas of the Damgård-Fujisaki proof scheme [DF02] and overcomes several limitations of it. In §5.2 and §5.3 we show how the framework given in §2 can be extended to cover the  <span class="math">\\Sigma^{exp}</span> -protocol as well, and we show how to combine the techniques for  <span class="math">\\Sigma^{\\phi}</span> - and  <span class="math">\\Sigma^{exp}</span> -protocols.</p>

    <p class="text-gray-300">The  <span class="math">\\Sigma^{exp}</span> -protocol is not yet implemented in the compiler described in §3 and §4, but the implementation will take place in near future. We present the  <span class="math">\\Sigma^{exp}</span> -protocol here and extend the general framework of §2 to hidden order groups, which we think is of independent interest.</p>

    <p class="text-gray-300">We first note that the  <span class="math">\\Sigma^{\\phi}</span> -protocol is only defined for homomorphisms with a finite domain. It is thus not applicable for exponentiation homomorphisms  <span class="math">\\phi_E = g_1^{w_1} \\dots g_l^{w_l}</span>  in hidden order groups (e.g.,</p>

    <p class="text-gray-300">when  <span class="math">g_1, \\ldots, g_l</span>  are elements of an RSA group); these are mappings of the form  <span class="math">\\phi_E : \\mathbb{Z}^l \\to \\mathcal{H}</span> , having an infinite domain. In this case, the soundness property is not satisfied any more. Yet this is only a technical issue, since the  <span class="math">\\Sigma^{\\phi}</span> -protocol can be easily modified to also work for exponentiations in hidden order groups, e.g. [Ban05]. The more fundamental problem is that the resulting  <span class="math">\\Sigma</span> -protocol is only known to be a proof of knowledge when the challenge set is chosen to be  <span class="math">\\mathcal{C} = \\{0, 1\\}</span> . The resulting proofs are thus not sufficiently efficient for most practical applications.</p>

    <p class="text-gray-300">There are ways around this problem. Bangerter et al [BCM05] discuss protocols and techniques which allow to obtain efficient proofs for homomorphisms in hidden order groups. Yet, the soundness of these techniques relies on rather strong assumptions (i.e., the random oracle model) and most of all are not based on the  <span class="math">\\Sigma</span> -protocol and thus do not fit into our framework. The most widely used technique is the Damgård-Fujisaki (DF) scheme [DF02]. It allows to demonstrate knowledge of a commitment in RSA groups (and other hidden order groups) using a  <span class="math">\\Sigma</span> -protocol. On a high level, the scheme consits of a setup protocol where prover and verifier jointly generate a commitment function. Then, once the prover has committed to some value, he uses a  <span class="math">\\Sigma</span> -protocol to demonstrate knowledge of that value to the verifier. The commitment being used is the exponentiation homomorphism  <span class="math">\\phi_E = g_1^{w_1} g_2^{w_2}</span> . However, the DF scheme can be extended to work for multi-exponentiation with more than two base elements.</p>

    <p class="text-gray-300">It is important to note that the DF scheme, as the authors state explicitly, is <em>not</em> a proof of knowledge, but loosely speaking something weaker. That is the  <span class="math">\\Sigma</span> -protocol used in the DF scheme only demonstrates knowledge for homomorphisms which were priorly generated in the setup phase. Since the setup protocol is rather inefficient, using the DF scheme is only suitable when setup costs can be neglected. In practice, when the DF scheme is used as a sub-protocol of some higher-level application, this is typically the case when the setup protocol is run during system initialization, but not while the system is in interactive use. This in turn means that <em>all</em> homomorphisms for which the DF scheme is to be applied to, need to be known a priori at initialization time.</p>

    <p class="text-gray-300">To overcome these restrictions we present a novel protocol, called  <span class="math">\\Sigma^{exp}</span>  which allows to obtain efficient statistical HVZK proofs of knowledge in the auxiliary string model. It works for any exponentiation homomorphism  <span class="math">\\phi_E = g_1^{w_1} \\dots g_l^{w_l}</span> , in particular in hidden order groups, in the case that the order of Im  <span class="math">\\phi_E</span>  does not contain small prime factors. The protocol extends ideas found in the DF scheme. That is, the soundness of our protocol also relies on the strong RSA assumption and our protocol requires a setup phase similar to the DF scheme. Compared to the DF scheme it has two main advantages. First, the setup protocol only needs to be run once and for all and then our scheme can be used as an efficient proof of knowledge for arbitrary exponentiation homomorphisms (that do not contain more than an arbitrary but fixed number of base elements). Second, our protocol is a proof of knowledge in the auxiliary string model. Technically, this is a simpler and easier to grasp definitional setting than the rather contrived one underlying the DF scheme. This can potentially lead to a simpler and more modular security analysis of applications relying on our protocol. Loosely speaking, our scheme is more flexible than the DF scheme and works for a larger class of exponentiation homomorphisms, and thus it is more appropriate for the theoretical framework underlying our compiler, and probably also for other practical applications as well.</p>

    <p class="text-gray-300">The idea underlying the  <span class="math">\\Sigma^{exp}</span> -protocol is as follows: in the setup phase, we generate a DF commitment function  <span class="math">\\vartheta</span>  and then pass it on as auxiliary input to the  <span class="math">\\Sigma^{exp}</span> . In the protocol we let the prover commit to the preimage of the homomorphisms  <span class="math">\\phi_E</span>  whose knowledge he wants to prove. Then we run a variant of the  <span class="math">\\Sigma</span> -protocol which proves that the committed values are equal to the</p>

    <p class="text-gray-300">preimage of  <span class="math">\\phi_E</span> . The soundness of the scheme then essentially follows from the soundness of the DF scheme.</p>

    <p class="text-gray-300">Let us first describe how to generate the auxiliary  <span class="math">\\vartheta</span> -function. By m we denote an arbitrary but fixed positive integer. Now, one chooses a safe prime modulus n (i.e., n = (2p+1)(2q+1), where p, q, (2p+1), and (2q+1) are primes) and generator g of the sub-group of quadratic residues of  <span class="math">\\mathbb{Z}_n^*</span> . Finally, choose uniform random elements  <span class="math">g_1, \\ldots, g_m</span>  from  <span class="math">\\langle g \\rangle</span> , and define  <span class="math">\\vartheta(x_1, \\ldots, x_{m+1}) = g_1^{x_1} \\cdot \\ldots \\cdot g_m^{x_m} \\cdot g^{x_{m+1}}</span> .</p>

    <p class="text-gray-300">Given an exponentiation homomorphism  <span class="math">\\phi_E : \\mathbb{Z}^l \\to H</span>  let  <span class="math">\\mathcal{G}</span>  denote an arbitrary finite subset of  <span class="math">\\mathbb{Z}^l</span> , which is defined by the integer parameters  <span class="math">T_1, \\ldots, T_l</span>  as follows:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{G} := \\{-T_1, \\dots, T_1\\} \\times \\dots \\times \\{-T_l, \\dots, T_l\\}. \\tag{5}</span>$</p>

    <p class="text-gray-300">The  <span class="math">T_i</span>  can be chosen arbitrarily large and are only needed to control the size of the prover's random choices to ensure that the protocol is statistically HVZK, if  <span class="math">-T_i \\leq w_i \\leq T_i</span>  holds for all  <span class="math">i = 1, \\ldots, l</span> . Using an additional security parameter  <span class="math">k_s &gt; 0</span> , we associate the following set with  <span class="math">\\mathcal{G}</span> :</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathcal{G}&#x27; := \\{-2^{k_s}c^+T_1, \\dots, 2^{k_s}c^+T_1\\} \\times \\dots \\times \\{-2^{k_s}c^+T_l, \\dots, 2^{k_s}c^+T_l\\}. \\tag{6}</span>$</p>

    <p class="text-gray-300">We note that the security parameter  <span class="math">k_s</span>  controls the tightness of statistical HVZK property of the  <span class="math">\\Sigma^{exp}</span> -protocol which we define next.</p>

    <p class="text-gray-300"><strong>Definition 4</strong> ( <span class="math">\\Sigma^{exp}</span> -protocol). Let be given an exponentiation homomorphism  <span class="math">\\phi_E : \\mathbb{Z}^l \\to \\mathcal{H}</span> ,  <span class="math">x = \\phi_E(w)</span> , and  <span class="math">\\vartheta(z_1, \\ldots, z_{m+1}) = g_1^{z_1} \\cdot \\ldots \\cdot g_l^{z_l} \\cdot g^{z_{l+1}}</span>  which is generated as described above. A  <span class="math">\\Sigma^{exp}</span> -protocol with challenge set  <span class="math">\\mathcal{C} = \\{0, \\ldots, c^+\\}</span>  consists of (P,V) performing the joint computation described in Figure 1.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c} \\mathcal{P}(x,w,\\vartheta_{l+1}) &amp; \\mathcal{V}(x,\\vartheta_{l+1}) \\\\ \\hline \\\\ P_1 &amp; \\mathsf{w} \\in_R \\{0,2^{k_s}n\\}; \\, \\mathsf{x} := \\vartheta_{l+1}(w,\\mathsf{w}) \\\\ &amp; r \\in_R \\mathcal{G}&#x27; \\\\ \\\\ \\mathsf{r} \\in_R \\{-2^{2k_s}c^+n,2^{2k_s}c^+n\\} \\\\ &amp; t := \\varphi_E(r) \\\\ &amp; t := \\vartheta_{l+1}(r,\\mathsf{r}) \\\\ \\hline \\\\ P_2 &amp; s := r + cw \\\\ \\hline \\\\ \\mathsf{s} := \\mathsf{r} + cw \\\\ \\hline \\\\ \\mathsf{s} := \\mathsf{r} + cw \\\\ \\hline \\\\ &amp; (s,\\mathsf{s}) \\\\ \\hline \\\\ &amp; (s,\\mathsf{s}) \\\\ \\hline \\\\ &amp; \\mathsf{v} \\text{ if } \\varphi_E(s) = tx^c, \\\\ &amp; \\text{and } \\vartheta_{l+1}(s,\\mathsf{s}) = \\mathsf{t}x^c, \\\\ &amp; \\text{then output } true; \\text{ else output } false \\\\ \\hline \\end{array}</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;<strong>Fig. 1.</strong> Description of the  <span class="math">\\Sigma^{exp}</span> -protocol</p>

    <p class="text-gray-300">Now, the following holds:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-3&quot;&gt;&lt;/span&gt;<strong>Theorem 3.</strong> Under the strong RSA assumption, the  <span class="math">\\Sigma^{exp}</span> -protocol with challenge set  <span class="math">C = \\{0, \\ldots, c^+\\}</span>  is a statistical special HVZK computational proof of knowledge in the auxiliary string model for any exponentiation homomorphism  <span class="math">\\phi_E</span> , if  <span class="math">c^+</span>  is smaller than the smallest prime dividing the order of Im  <span class="math">\\phi_E</span> . The knowledge error is 1/#C + 1/p(|x|), where p() is an arbitrary but fixed polynomial. Especially, the  <span class="math">\\Sigma^{exp}</span> -protocol is a  <span class="math">\\Sigma</span> -protocol according to Definition 1.</p>

    <p class="text-gray-300">For a proof of the theorem we refer to Appendix A.2. Finally, let us sketch how to choose the auxiliary  <span class="math">\\vartheta</span> -function in practice. Most importantly, we observe that one can choose  <span class="math">\\vartheta</span>  once and then use the  <span class="math">\\Sigma^{exp}</span> -protocol for any exponentiation homomorphism using the same  <span class="math">\\vartheta</span> . There are essentially three possible ways to choose  <span class="math">\\vartheta</span> . One is to use the setup protocol of the DF scheme. That is, the verifier chooses  <span class="math">\\vartheta</span>  as outlined above and sends it to the prover. Then it uses a rather inefficient variant of the  <span class="math">\\Sigma</span> - protocol with binary challenges to prove that  <span class="math">g_1, \\ldots, g_l \\in \\langle g \\rangle</span> . This prove is necessary to assert that  <span class="math">\\vartheta</span>  is a hiding commitment function and thus essential for the zero-knowledge property of our protocol. In a real world implementation using the  <span class="math">\\Sigma^{exp}</span> -protocol one would rather either hardcode  <span class="math">\\vartheta</span>  into the system (like other system parameters) or let a trusted third party publish  <span class="math">\\vartheta</span>  along with a certificate vouching that it was generated correctly.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;5.2 Boolean Composition of <span class="math">\\Sigma^{exp}</span> -protocols</h3>

    <p class="text-gray-300">Analogously to §2.2 we show how  <span class="math">\\Sigma^{exp}</span> -protocols can be combined by boolean operators, cf. (1) and (2).</p>

    <p class="text-gray-300"><strong>AND-proofs.</strong> We want to briefly discuss the AND-composition of two  <span class="math">\\Sigma^{exp}</span> -protocols. Let be given  <span class="math">x_1 = \\phi_{E_1}(w_1) = h_{11}^{w_{11}} \\cdots h_{1l_1}^{w_{1l_1}}</span>  and  <span class="math">x_2 = \\phi_{E_2}(w_2) = h_{21}^{w_{21}} \\cdots h_{2l_2}^{w_{2l_2}}</span> . For a direct protocol composition, one would now run the setup phase twice to obtain  <span class="math">\\vartheta_{l_1+1}</span>  and  <span class="math">\\vartheta_{l_2+1}</span> . In the following we show how this can be optimized to avoid unneeded overhead.</p>

    <p class="text-gray-300">By  <span class="math">\\mathcal{G}_i</span>  and  <span class="math">\\mathcal{G}&#x27;_i</span>  we denote the sets described in (5) resp. (6) for  <span class="math">\\phi_{E_1}</span>  and  <span class="math">\\phi_{E_2}</span> . Note that elements in  <span class="math">G_1</span>  and  <span class="math">G&#x27;_1</span>  have  <span class="math">l_1</span>  components, whereas those in  <span class="math">G_2</span>  and  <span class="math">G&#x27;_2</span>  have  <span class="math">l_2</span> . As auxiliary input let be given  <span class="math">\\vartheta_{l+1}</span> , with  <span class="math">l := l_1 + l_2</span> . In contrast to a parallel execution of the protocols, the prover commits to all his random choices (and preimages, resp.) at once, instead of computing a commitment for the random choices (resp., preimages) of each  <span class="math">\\phi_{E_i}</span> . More precisely, the protocol looks like this:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In  <span class="math">\\mathsf{P}_1</span> , the prover draws random choices  <span class="math">\\mathsf{r} \\in_R \\{-2^{2k_s}c^+n, 2^{2k_s}c^+n\\}</span>  and  <span class="math">\\mathsf{w} \\in_R \\{0, 2^{k_s}n\\}</span> , as well as  <span class="math">r_i \\in_R \\mathcal{G}_i&#x27;</span>  for i=1,2. Then he commits to  <span class="math">r_1, r_2</span>  as usual by  <span class="math">t_i := \\phi_{E_i}(r_i)</span> . Now, in contrast to a parallel execution, he commits to  <span class="math">(w_1, w_2)</span>  simultaneously, blinding it using  <span class="math">\\mathsf{w}</span> , by  <span class="math">\\mathsf{x} := \\vartheta_{l+1}(w_1, w_2, \\mathsf{w})</span> . Analogously, he computes  <span class="math">\\mathsf{t} := \\vartheta_{l+1}(r_1, r_2, \\mathsf{r})</span> . The tuple  <span class="math">(\\mathsf{x}, (t_1, t_2), \\mathsf{t})</span>  is sent to the verifier.</li>
      <li>The remaining steps now are a straightforward adaption of the protocol in Figure 1: having received the challenge c, in  <span class="math">P_2</span>  the prover computes responses  <span class="math">s_1 := r_1 + cw_1</span>  and  <span class="math">s_2 := r_2 + cw_2</span> . He sets s := r + cw and sends  <span class="math">((s_1, s_2), s)</span>  to the verifier, who checks that  <span class="math">\\phi_{E_i}(s_i) = t_i x_i^c</span>  for i = 1, 2, and that  <span class="math">\\vartheta_{l+1}(s_1, s_2, s) = \\mathsf{tx}^c</span> .</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;<strong>Lemma 2.</strong> If  <span class="math">c^+</span>  is smaller than the smallest prime dividing  <span class="math">\\operatorname{ord}(\\operatorname{Im} \\phi_{E_1})</span>  or  <span class="math">\\operatorname{ord}(\\operatorname{Im} \\phi_{E_2})</span> , the above composition yields a computational proof of knowledge (in the auxiliary string model) of the preimages of  <span class="math">x_1, x_2</span>  under  <span class="math">\\phi_{E_1}</span>  resp.  <span class="math">\\phi_{E_2}</span> , that satisfies statistical special HVZK property.</p>

    <p class="text-gray-300">The proof is a direct adaption of the proof of Theorem 3 and hence omitted.</p>

    <p class="text-gray-300">If an expression like (1) contains special homomorphisms as well as exponentiation homomorphisms in hidden order groups, the AND-composition is done for the occurring homomorphisms of each class separately, and then the resulting  <span class="math">\\Sigma</span> -protocols are run in parallel using the same challenge c. The following result then follows from Lemma 1 and Lemma 2:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;<strong>Theorem 4.</strong> Let  <span class="math">c^+ \\in \\mathbb{Z}</span>  be smaller than the smallest prime dividing one special exponent of  <span class="math">\\phi_1, \\ldots, \\phi_{m_1}</span>  or one of the orders of  <span class="math">\\operatorname{Im} \\phi_{m_1+1}, \\ldots, \\operatorname{Im} \\phi_m</span> . Then applying the described composition techniques and running the resulting protocols in parallel yields a statistical HVZK, computational</p>

    <p class="text-gray-300">proof of knowledge (in the auxiliary string model) with challenge set C := {0, . . . , c+} and knowledgeerror κ = 1/#C + 1/p(|x|), where p() is an arbitrary but fixed polynomial.</p>

    <p class="text-gray-300">Proofs of expressions containing ORs. For proofs of expressions containing ORs, the corresponding technique given in §<a href="#page-5-0">2.2</a> can be applied without changes: for the results of <a href="#page-18-10">[CDS94]</a> there has to be a HVZK proof of knowledge in form of a Σ-protocol for each predicate in an expression like <a href="#page-6-1">(2)</a>. This is the case here, if one chooses the Σ&lt;sup&gt;φ&lt;/sup&gt; -protocol for all special homomorphisms, and the Σexp-protocol for all exponentiation homomorphisms in hidden order groups. A computational, statistical HVZK, proof of knowledge in the auxiliary string model is obtained, if c &lt;sup&gt;+&lt;/sup&gt; is chosen as, e.g., in Theorem <a href="#page-16-2">4.</a></p>

    <p class="text-gray-300">We are aware that the performance of the output of our compiler can be enhanced by skillfully applying AND-compositions before using this technique. We will consider this in future versions.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;5.3 Relations among preimages</h3>

    <p class="text-gray-300">Essentially the same technique as described in detail in §<a href="#page-6-0">2.3</a> also works for linear constraints among the preimages of exponentiation homomorphisms in the Σexp-protocol. Again the idea is to perform an AND-composition within each AND-term in an expression like <a href="#page-7-0">(4)</a>, but to restrict the sets for the random choices. A small technical issue arises because the sets for random choices are no groups any more, see <a href="#page-15-2">(6)</a>. Hence, in the example given at the beginning of this section, it could happen that br&lt;sup&gt;1&lt;/sup&gt; is not in this set any more. Yet, this problem is easy to overcome: one only has to check that for each component w&lt;sup&gt;i&lt;/sup&gt; the parameter T&lt;sup&gt;i&lt;/sup&gt; is chosen large enough, what can be done very fast because of the form of AS. In the given example this means that T&lt;sup&gt;2&lt;/sup&gt; ≥ |b|T1, where |b| denotes the absolute value of b.</p>

    <p class="text-gray-300">If in <a href="#page-7-0">(4)</a> special homomorphisms appear as well as exponentiation homomorphisms, the constructions are run separately for them.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">6 Conclusion and Future Work</h3>

    <p class="text-gray-300">We have presented a compiler that given a high-level ZK-PoK protocol specification automatically generates a sound implementation of the corresponding Σ-protocol. The initial version of the compiler can already be used for many practical applications as given in the introduction, but is currently restricted to automatic generation of proofs for special homomorphisms, i.e., the framework given in §<a href="#page-3-1">2.</a> Future work will contain the Σexp-protocol together with the theory explained in §<a href="#page-13-0">5</a> and protocols as suggested in <a href="#page-19-3">[DF02,</a><a href="#page-18-15">BCM05]</a> to allow proofs in unknown order groups as well, which in turn will enable to generate more efficient proofs for complex statements like efficient interval proofs.</p>

    <p class="text-gray-300">In order to increase the flexibility of the existing tool, predefined and user-written macros will be supported, which are translated into the input language by a precompiler. Such macros could for example simplify the realization of complex algebraic relations among the preimages. Additionally to Z&lt;sup&gt;n&lt;/sup&gt; and Z ∗ n , other commonly used groups such as groups over elliptic curves and homomorphisms like multiexponentiation homomorphisms could be predefined.</p>

    <p class="text-gray-300">In the theoretical framework in §<a href="#page-3-1">2</a> we give conditions under which the output protocol is a HVZK proof of knowledge. Those can easily be checked manually for special homomorphisms, which are currently implemented in the compiler. Yet, this issue becomes more challenging when the input language of the compiler gets more comprehensive. Thus it is preferable that incorrect inputs (that would result in unsound protocols) are spotlighted automatically. For this reason, an automated formal verification of the output will be implemented.</p>

    <p class="text-gray-300">Last, transformations of the generated Σ-protocols to signature schemes <a href="#page-19-14">[FS87]</a> or concurrent zero-knowledge <a href="#page-19-12">[Dam00]</a> that are also secure against malicious verifiers could be automated easily.</p>

    <p class="text-gray-300">Acknowledgements. The authors would like to thank Thomas Briner who wrote the initial version of the compiler as well as Wilko Henecka who extended the compiler substantially for their support.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-2&quot;&gt;&lt;/span&gt;ARS05. A. Adelsbach, M. Rohe, and A.-R. Sadeghi. Complementing zero-knowledge watermark detection: Proving properties of embedded information without revealing it. Multimedia Systems, 11(2):143–158, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-16&quot;&gt;&lt;/span&gt;Ban05. E. Bangerter. Efficient Zero-Knowledge Proofs of Knowledge for Homomorphisms. PhD thesis, Ruhr-University Bochum, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-3&quot;&gt;&lt;/span&gt;BCC04. E. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In Proc. ACM CCS 2004, pages 132–145. ACM, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-15&quot;&gt;&lt;/span&gt;BCM05. E. Bangerter, J. Camenisch, and U. Maurer. Efficient proofs of knowledge of discrete logarithms and representations in groups with hidden order. In International Workshop on Practice and Theory in Public-Key Cryptography – PKC 05, volume 3386 of LNCS, pages 154–171. Springer, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-20&quot;&gt;&lt;/span&gt;BG93. M. Bellare and O. Goldreich. On defining proofs of knowledge. In Advances in Cryptology – CRYPTO 92, volume 740 of LNCS, pages 390–420. Springer, 1993.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-21&quot;&gt;&lt;/span&gt;Bla79. G. Blakley. Safeguarding cryptographic keys. In National Computer Conference 97, pages 313–317, 1979.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-19&quot;&gt;&lt;/span&gt;BMP07. Manuel Barbosa, Andrew Moss, and Dan Page. Compiler assisted elliptic curve cryptography. In Information Security (IS), volume 4804 of LNCS, pages 1785–1802. Springer, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-17&quot;&gt;&lt;/span&gt;BNPS05. M. Barbosa, R. Noad, D. Page, and N.P. Smart. First steps toward a cryptography-aware language and compiler. Cryptology ePrint Archive, Report 2005/160, 2005. <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-18&quot;&gt;&lt;/span&gt;BP05. Manuel Barbosa and Dan Page. On the automatic construction of indistinguishable operations. Cryptology ePrint Archive, Report 2005/174, 2005. <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-7&quot;&gt;&lt;/span&gt;Bra94. S. Brands. Untraceable off-line cash in wallet with observers. In Advances in Cryptology – CRYPTO 93, volume 773 of LNCS, pages 302–318. Springer, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-13&quot;&gt;&lt;/span&gt;Bra97. S. Brands. Rapid demonstration of linear relations connected by boolean operators. In Advances in Cryptology – EUROCRYPT 97, volume 1233 of LNCS, pages 318–333. Springer, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-11&quot;&gt;&lt;/span&gt;Bri04. T. Briner. Compiler for zero-knowledge proof-of-knowledge protocols. Master's thesis, ETH Zurich, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-14&quot;&gt;&lt;/span&gt;BS02. E. Bresson and J. Stern. Proofs of knowledge for non-monotone discrete-log formulae and applications. In ISC '02: Proceedings of the 5th International Conference on Information Security, pages 272–288. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;Cam98. J. Camenisch. Group Signature Schemes and Payment Systems Based on the Discrete Logarithm Problem. PhD thesis, ETH Zurich, Konstanz, 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-10&quot;&gt;&lt;/span&gt;CDS94. R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In Advances in Cryptology – CRYPTO 94, volume 839 of LNCS, pages 174–187. Springer, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-8&quot;&gt;&lt;/span&gt;CFT98. A. Chan, Y. Frankel, and Y. Tsiounis. Easy come - easy go divisible cash. Technical Report TR-0371-05- 98-582, GTE, 1998. Updated version with corrections.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-4&quot;&gt;&lt;/span&gt;CH02. J. Camenisch and E. V. Herreweghen. Design and implementation of the idemix anonymous credential system. In Proc. ACM CCS 2002, pages 21–30. ACM, 2002. <a href="http://www.zurich.ibm.com/security/idemix/">http://www.zurich.ibm.com/security/</a> <a href="http://www.zurich.ibm.com/security/idemix/">idemix/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-22&quot;&gt;&lt;/span&gt;CL02. J. Camenisch and A. Lysyanskaya. A signature scheme with efficient protocols. In Security in Communication Networks – SCN 2002, volume 2576 of LNCS, pages 268–289, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-9&quot;&gt;&lt;/span&gt;CL04. J. Camenisch and A. Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Advances in Cryptology – CRYPTO 2004, volume 3152 of LNCS, pages 56–72. Springer, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;CM99. J. Camenisch and M. Michels. Proving in zero-knowledge that a number is the product of two safe primes. In Advances in Cryptology – EUROCRYPT 99, volume 1592 of LNCS, pages 107–122. Springer, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-6&quot;&gt;&lt;/span&gt;Cra96. R. Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-12&quot;&gt;&lt;/span&gt;CRS05. J. Camenisch, M. Rohe, and A.-R. Sadeghi. Sokrates - a compiler framework for zero-knowledge protocols. In Western European Workshop on Research in Cryptology – WEWoRC 05, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-5&quot;&gt;&lt;/span&gt;CS97a. J. Camenisch and M. Stadler. Efficient group signature schemes for large groups (extended abstract). In Advances in Cryptology – CRYPTO 97, volume 1294, pages 410–424. Springer, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-9&quot;&gt;&lt;/span&gt;CS97b. J. Camenisch and M. Stadler. Proof systems for general statements about discrete logarithms. Technical Report 260, Institute for Theoretical Computer Science, ETH Zürich, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-18&quot;&gt;&lt;/span&gt;CS03. J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Advances in Cryptology – CRYPTO 2003, volume 2729 of LNCS, pages 126–144. Springer, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-12&quot;&gt;&lt;/span&gt;Dam&lt;br/&gt;00. I. Damgård. Efficient concurrent zero-knowledge in the auxiliary string model. In Advances in Cryptology&lt;br/&gt;
– EUROCRYPT 2000, volume 1807 of LNCS, pages 418–430. Springer, 2000.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-13&quot;&gt;&lt;/span&gt;Dam&lt;br/&gt;04. I. Damgård. On sigma-protocols, 2004. Lecture on Cryptologic Protocol&lt;br/&gt; Theory; Faculty of Science, University of Aarhus.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-3&quot;&gt;&lt;/span&gt;DF02. I. Damgård and E. Fujisaki. A statistically-hiding integer commitment scheme based on groups with hidden order. In <em>Advances in Cryptology – ASIACRYPT 2000</em>, volume 2501 of <em>LNCS</em>, pages 77–85. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-8&quot;&gt;&lt;/span&gt;DJ01. I. Damgård and M. Jurik. A generalisation, a simplification and some applications of paillier's probabilistic public-key system. In <em>Proc. 4th International Workshop on Practice and Theory in Public-Key Cryptography (PKC 2001)</em>, LNCS, pages 119–136. Springer, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-14&quot;&gt;&lt;/span&gt;FS87. A. Fiat and A. Shamir. How to prove yourself: practical solutions to identification and signature problems. In <em>Advances in Cryptology - CRYPTO 86</em>, volume 263 of <em>LNCS</em>, pages 186–194. Springer, 1987.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;GMW91. O. Goldreich, S. Micali, and A. Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. <em>Journal of the ACM</em>, 38(1):691–729, 1991. Preliminary version in 27th FOCS, 1986.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-15&quot;&gt;&lt;/span&gt;GQ88. L. Guillou and J. Quisquater. A practical zero-knowledge protocol fitted to security microprocessor minimizing both transmission and memory. In Advances in Cryptology – EUROCRYPT 88, volume 330 of LNCS, pages 123–128. Springer, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-2&quot;&gt;&lt;/span&gt;LPS08. Y. Lindell, B. Pinkas, and N. Smart. Implementing two-party computation efficiently with security against malicious adversaries. In <em>Security in Communication Networks – SCN 2008</em>, volume 5229 of <em>LNCS</em>, pages 2–20. Springer, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-11&quot;&gt;&lt;/span&gt;MNPS04. D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay — a secure two-party computation system. In USENIX Security '04, 2004. http://www.cs.huji.ac.il/project/Fairplay/fairplay.html.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-10&quot;&gt;&lt;/span&gt;MOR03. P. MacKenzie, A. Oprea, and M. K. Reiter. Automatic generation of two-party computations. In <em>Proc.</em> ACM CCS 2003, pages 210–219. ACM, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-5&quot;&gt;&lt;/span&gt;Oka95. T. Okamoto. An efficient divisible electronic cash scheme. In <em>Advances in Cryptology - CRYPTO 95</em>, volume 963 of <em>LNCS</em>, pages 438–451. Springer, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-7&quot;&gt;&lt;/span&gt;Pai99. P. Paillier. Public-key cryptosystems based on composite degree residuosity classes. In Advances in Cryptology – EUROCRYPT 99, volume 1592 of LNCS, pages 223–238. Springer, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-4&quot;&gt;&lt;/span&gt;Ped92. T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In <em>Advances in Cryptology - CRYPTO 91</em>, volume 576 of <em>LNCS</em>, pages 129–140. Springer, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-6&quot;&gt;&lt;/span&gt;RSA78. R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures and public-key cryptosystems. <em>Communications of the ACM</em>, 21(2):120–126, 1978.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;Sch91. C. Schnorr. Efficient signature generation by smart cards. Journal Of Cryptology, 4(3):161–174, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-19-17&quot;&gt;&lt;/span&gt;Sha79. A. Shamir. How to share a secret. Communications of the ACM, 22(11):612–613, 1979.</p></li>
    </ul>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">A Proofs</h3>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-19-16&quot;&gt;&lt;/span&gt;A.1 Proof of Theorem 1</h4>

    <p class="text-gray-300"><em>Proof.</em> 3-move form and completeness follow from the definition.</p>

    <p class="text-gray-300">For special HVZK consider the following simulator: on input  <span class="math">c \\in \\mathcal{C}</span> , choose  <span class="math">s \\in_R \\mathcal{G}</span>  and set  <span class="math">r := \\phi(s)x^{-c}</span> . Hence, the  <span class="math">\\Sigma^{\\phi}</span> -protocol is a  <span class="math">\\Sigma</span> -protocol according to Definition 1.</p>

    <p class="text-gray-300">For proof of knowledge property consider the following: using standard rewinding arguments, e.g. [Dam04], it is possible to obtain two accepting communication triples (r, c', s') and (r, c'', s'') with  <span class="math">c&#x27; \\neq c&#x27;&#x27;</span>  within the allowed running time of the knowledge extractor as defined by [BG93]. Dividing the corresponding verification equations yields  <span class="math">x^{c&#x27;-c&#x27;&#x27;} = \\phi(s&#x27;-s&#x27;&#x27;)</span> . Since  <span class="math">\\phi</span>  is special,  <span class="math">x^v = \\phi(u)</span> . We have  <span class="math">\\gcd(c&#x27; - c&#x27;&#x27;, v) = 1</span> , as  <span class="math">c^+</span>  is smaller than the smallest prime dividing v. So,  <span class="math">a, b \\in \\mathbb{Z}</span> , s.t. a(c'-c'') + bv = 1 can be found efficiently with extended Euclidean algorithm and by using the homomorphic property of  <span class="math">\\phi</span>  we obtain w' := a(s' - s'') + bu as a preimage.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;A.2 Proof of Theorem 3</h4>

    <p class="text-gray-300"><em>Proof.</em> The first two properties of a  <span class="math">\\Sigma</span> -protocol, i.e., 3-move-form and completeness, are clear. Only the special HVZK and the proof of knowledge properties remain to show.</p>

    <p class="text-gray-300">Let's start with special HVZK: To this end we consider the following simulator S for the  <span class="math">\\Sigma^{exp}</span> -protocol on input  <span class="math">c \\in \\mathcal{C}</span> : Choose  <span class="math">\\mathsf{w}&#x27; \\in_R \\{0,\\ldots,2^{k_s}n\\}</span>  and set  <span class="math">\\mathsf{x}&#x27; := g^{\\mathsf{w}&#x27;}</span> . Choose  <span class="math">s&#x27; \\in \\mathcal{G}&#x27;</span> , and  <span class="math">\\mathsf{s}&#x27; \\in_R \\{-2^{2k_s}c^+n,2^{2k_s}c^+n\\}</span> . Set  <span class="math">t&#x27; := \\phi_E(s&#x27;)x^{-c}</span>  and  <span class="math">\\mathsf{t}&#x27; := \\vartheta_{l+1}(s&#x27;,\\mathsf{s}&#x27;)\\mathsf{x}&#x27;^{-c}</span> . The output of S is then given by  <span class="math">((\\mathsf{x}&#x27;,\\mathsf{t}&#x27;,t&#x27;),c,(s&#x27;,\\mathsf{s}&#x27;))</span> .</p>

    <p class="text-gray-300">We now have to verify that the distribution of these tuples is statistically indistuingishable from the verifier's real view ((x,t,t),c,(s,s)).</p>

    <p class="text-gray-300">Both  <span class="math">(\\mathsf{t},t)</span>  and  <span class="math">(\\mathsf{t}&#x27;,t&#x27;)</span>  are uniquely determined by the other values. So it is sufficient to show that the distributions of  <span class="math">Pr(\\mathsf{x}&#x27;,s&#x27;,\\mathsf{s}&#x27;|c,w)</span>  and  <span class="math">Pr(\\mathsf{x},s,\\mathsf{s}|c,w)</span>  are statistically indistinguishable. To do so, we write  <span class="math">Pr(\\mathsf{x}&#x27;,s&#x27;,\\mathsf{s}&#x27;|c,w) = Pr(s&#x27;,\\mathsf{s}&#x27;|\\mathsf{x}&#x27;,c,w) Pr(\\mathsf{x}&#x27;|c,w)</span>  and  <span class="math">Pr(\\mathsf{x},s,\\mathsf{s}|c,w) = Pr(s,\\mathsf{s}|\\mathsf{x},c,w) Pr(\\mathsf{x}|c,w)</span> , resp..</p>

    <p class="text-gray-300">The distributions of x and x' do not depend on c and w, as their choices do not depend on the secret preimage or the challenge. So we have to show that Pr(x) and Pr(x') are statistically close. Since  <span class="math">w \\in_R \\{0, \\ldots, 2^{k_s}n\\}</span> , which is an interval much larger than the order of g (upper bounded by n), we have that  <span class="math">x = g_1^{w_1} \\cdots g_l^{w_l} \\cdot g^{\\mathbf{W}}</span>  is statistically close to the uniform distribution on  <span class="math">\\langle g \\rangle</span> . On the other hand, with the same argument, the same holds for  <span class="math">x&#x27; = q^{\\mathbf{W}&#x27;}</span> .</p>

    <p class="text-gray-300">So it remains to show that Pr(s', s'|x', c, w) and Pr(s, s|x, c, w) are statistically close. First, note that the components of s are distributed independently; so the following holds:  <span class="math">Pr(s, s|x, c, w) = Pr(s_1|c, w_1) \\cdots Pr(s_l|c, w_l) Pr(s|x, c)</span>  and analogously for Pr(s', s'|x', c, w). Each  <span class="math">s_i</span>  is uniform and random on</p>

    <p class="text-gray-300"><span class="math">$\\{-2^{k_s}T_i + cw_i, \\dots, cw_i + 2^{k_s}T_i\\}</span>$</p>

    <p class="text-gray-300">and each  <span class="math">s&#x27;_i</span>  is uniform and random on</p>

    <p class="text-gray-300"><span class="math">$\\{-2^{k_s}T_i,\\ldots,2^{k_s}T_i\\}.</span>$</p>

    <p class="text-gray-300">So the statistical difference of the distributions is  <span class="math">2cw_i/(2^{k_s+1}T_i)</span>  for each  <span class="math">i=1,\\ldots,l</span> , and therefore negligible in the security parameter  <span class="math">k_s</span> . Similarly, the difference of s and s' is negligible in  <span class="math">k_s</span> . As l is polynomially bounded in  <span class="math">k_s</span> , the sum of these differences is negligible.</p>

    <p class="text-gray-300">Let's turn to the <em>proof of knowledge property</em> now: using standard rewinding arguments we obtain two accepting communication triples, say ((x,t,t),c',(s',s')) and ((x,t,t),c'',(s'',s'')), with  <span class="math">c&#x27; \\neq c&#x27;&#x27;</span> , within the allowed running time of a knowledge-extractor [BG93]. By dividing the corresponding verification equations we obtain</p>

    <p class="text-gray-300"><span class="math">$\\phi_E(\\Delta s) = x^{\\Delta c}</span>$
and  <span class="math">\\vartheta_{l+1}(\\Delta s, \\Delta s) = \\mathsf{x}^{\\Delta c}</span></p>

    <p class="text-gray-300">where  <span class="math">\\Delta c := c&#x27;&#x27; - c&#x27;</span> , and analogously for  <span class="math">\\Delta s</span> ,  <span class="math">\\Delta s</span> . According to [CS03]  <span class="math">\\Delta c | \\Delta s_i</span>  for all i, and  <span class="math">\\Delta c | \\Delta s</span> , as otherwise the prover could factor the RSA-modulus n efficiently. So we have</p>

    <p class="text-gray-300"><span class="math">$w&#x27; = (\\Delta s_1/\\Delta c, \\dots, \\Delta s_l/\\Delta c)</span>$</p>

    <p class="text-gray-300">as a preimage, where the division in the exponent holds over the integers. Particularly, the  <span class="math">\\Sigma^{exp}</span> -protocol is a  <span class="math">\\Sigma</span> -protocol according to Definition 1.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;B EBNF Syntax Definition of the Input Language</h3>

    <p class="text-gray-300">The syntax of the compiler's input language is specified by the following EBNF:</p>

    <pre><code class="language-text">Input ::= Declaration { Declaration } Assignment { Assignment } Definition { Definition } Pro-
   tocol.
Declaration ::= GroupDeclaration | ((&#x27;GroupElement&#x27; | &#x27;Homomorphism&#x27; | &#x27;IntegerConstant&#x27;)
   IdentList )&#x27;;&#x27;.
GroupDeclaration ::= &#x27;Group&#x27; GroupList &#x27;;&#x27;.
GroupList ::= Group { &#x27;,&#x27; Group }.
Group ::= (&#x27;(&#x27; Ident [ ArrayNotation ] &#x27;,&#x27; (&#x27;+&#x27; | &#x27;*&#x27;) &#x27;)&#x27;) | (&#x27;Z&#x27; Letter { &#x27;*&#x27; }).
IdentList ::= Ident [ ArrayNotation ] { &#x27;,&#x27; Ident [ ArrayNotation ] }.
ArrayNotation ::= &#x27;[&#x27; Number &#x27;.&#x27; &#x27;.&#x27; Number &#x27;]&#x27;.
Ident ::= Letter { Letter | Number | &#x27;_&#x27; }.
Letter ::= &#x27;A&#x27; | &#x27;B&#x27; | . . . | &#x27;Z&#x27; | &#x27;a&#x27; | . . . | &#x27;z&#x27;.
Number ::= &#x27;0&#x27; | . . . | &#x27;9&#x27; { &#x27;0&#x27; | . . . | &#x27;9&#x27; }.
Definition ::= HomomorphismDefinition&#x27;;&#x27;.
HomomorphismDefinition ::= &#x27;DefineHomomorphism&#x27; HomomorphismDefinitionList.
HomomorphismDefinitionList ::= &#x27;(&#x27; Ident &#x27;,&#x27; ( AbstractStructure | ConcreteStructure ) &#x27;)&#x27; {
   &#x27;,&#x27; &#x27;(&#x27; Ident &#x27;,&#x27; ( AbstractStructure | ConcreteStructure ) &#x27;)&#x27; }.
ConcreteStructure ::= ( Ident | ( &#x27;(&#x27; IdentList &#x27;)&#x27;) ) &#x27;|-&gt;&#x27; &#x27;(&#x27; Expression { &#x27;,&#x27; Expression } &#x27;)&#x27;.
IdentList ::= Ident [ ArrayNotation ] [ &#x27;,&#x27; IdentList ].
Expression ::= TermList.
TermList ::= Term [ (&#x27;+&#x27;| &#x27;-&#x27;) TermList ].
Term ::= FactorList.
FactorList ::= Factor [ (&#x27;*&#x27;| &#x27;/&#x27;) FactorList ].
Factor ::= ExponentList.
ExponentList ::= Exponent [ &#x27;^&#x27; ExponentList ].
Exponent ::= Ident | Number | (&#x27;(&#x27; Expression &#x27;)&#x27;).
AbstractStructure ::= GroupStructure &#x27;-&gt;&#x27; GroupStructure.
GroupStructure ::= ( Ident | (&#x27;Z&#x27; Letter) | (&#x27;Z&#x27; Letter &#x27;*&#x27;) ) [ &#x27; # &#x27; ( Ident | (&#x27;Z&#x27; Letter { &#x27;*&#x27;})) ].
Assignment ::= &#x27;AssignGroupMember&#x27; GroupMemberAssignmentList &#x27;;&#x27;.
GroupMemberAssignmentList ::= &#x27;(&#x27; Ident &#x27;,&#x27; ( Ident | ( &#x27;{&#x27; Ident [ ArrayNotation ] [ &#x27;,&#x27; Ident
   [ ArrayNotation ] &#x27;}&#x27; ) &#x27;)&#x27; &#x27;,&#x27; [ GroupmemberAssignList ].
Protocol ::= &#x27;SpecifyProtocol&#x27; &#x27;[&#x27; Relation [ Constraints ] [ VariableNames ] Target [ Layout ] &#x27;]&#x27;.
Relation ::= &#x27;Relation&#x27; EnumerativeDescription | BooleanDescription.
EnumerativeDescription ::= &#x27;[&#x27; CommonInput PreImageInput [ AccessStructure ].
CommonInput ::= &#x27;CommonInput&#x27; &#x27;=&#x27; &#x27;{&#x27; CommonInputTuple [ &#x27;,&#x27; CommonInputTuple ] &#x27;}&#x27; &#x27;;&#x27;.
CommonInputTuple ::= &#x27;(&#x27; Ident &#x27;,&#x27; &#x27;(&#x27; Expression { &#x27;,&#x27; Expression } &#x27;)&#x27; &#x27;)&#x27;.
PreImageInput ::= &#x27;PreimageInput&#x27; &#x27;=&#x27; &#x27;{&#x27; PreImageInputTuple { &#x27;,&#x27; PreImageInputTuple } &#x27;}&#x27;
   &#x27;;&#x27;.
PreImageInputTuple ::= &#x27;(&#x27; Ident { &#x27;,&#x27; Ident } &#x27;)&#x27;.
AccessStructure ::= &#x27;AccessStructure&#x27; &#x27;=&#x27; &#x27;{&#x27; QualifiedSet { &#x27;,&#x27; QualifiedSet } &#x27;}&#x27;.
QualifiedSet ::= &#x27;{&#x27; Ident { &#x27;,&#x27; Ident } &#x27;}&#x27;.
BooleanDescription ::= &#x27;=&#x27; BooleanTermList.
BooleanTermList ::= BooleanTerm [ &#x27;||&#x27; BooleanTermList ].
</code></pre>

    <pre><code class="language-text">BooleanTerm ::= BooleanFactorList.
BooleanFactorList ::= BooleanFactor [ &#x27;&amp;&amp;&#x27; BooleanFactorList ].
BooleanFactor ::= HomomorphismRelation | (&#x27;(&#x27; BooleanTermList &#x27;)&#x27;).
HomomorphismRelation ::= &#x27;[&#x27; ImageHomRelationTuple &#x27;=&#x27; Ident &#x27;(&#x27; PreImageHomRelation-
   Tuple &#x27;)&#x27; &#x27;]&#x27;.
PreImageHomRelationTuple ::= Ident { &#x27;,&#x27; Ident }
ImageHomRelationTuple ::= &#x27;(&#x27; Expression &#x27;)&#x27;.
Constraints ::= &#x27;Constraints&#x27; &#x27;=&#x27; ConstraintEquation { &#x27;&amp;&amp;&#x27; ConstraintEquation } &#x27;;&#x27;.
ConstraintEquation ::= &#x27;(&#x27; Ident &#x27;=&#x27; ConstraintTuple { (&#x27;+&#x27;| &#x27;-&#x27; | &#x27;*&#x27; | &#x27;/&#x27;) ConstraintTuple } &#x27;)&#x27;.
ConstraintTuple ::= [ &#x27;-&#x27; ] ( (Number &#x27;*&#x27; Ident) | (Ident &#x27;^&#x27; Number) ).
VariableNames ::= &#x27;ParameterNames&#x27; &#x27;{&#x27; VariableNameDefinition { VariableNameDefinition }
   &#x27;}&#x27;.
VariableNameDefinition ::= ( &#x27;VarRandom&#x27; | &#x27;VarCommit&#x27; | &#x27;VarChallenge&#x27; | &#x27;VarResponse&#x27; |
   &#x27;VarPreimage&#x27; | &#x27;VarImage&#x27; | &#x27;VarHomomorphism&#x27; | &#x27;SecretSharingScheme&#x27; | &#x27;AccessStructure&#x27;
   | &#x27;QualifiedSet&#x27; | &#x27;ChallengeMax&#x27; ) &#x27;=&#x27; Ident &#x27;;&#x27;.
Target ::= &#x27;Target&#x27; &#x27;=&#x27; &#x27;JAVA&#x27; | &#x27;LATEX&#x27; &#x27;;&#x27;.
Layout ::= &#x27;Layout&#x27; &#x27;=&#x27; &#x27;COMPACT&#x27; &#x27;;&#x27;.
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;Table 1. Pre-defined variable names</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Protocol Element</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Default Name Description</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarRandom</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Randomly chosen preimage of prover</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarCommit</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Commitment of prover</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarChallenge</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">c</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Challenge of verifier</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarResponse</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Response of prover</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarPreimage</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">w</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compact mode: preimage</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarImage</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compact mode: image</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">VarHomomorphism</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">zeta</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compact mode: homomorphism</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SecretSharingScheme Theta</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Secret sharing scheme</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AccessStructure</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gamma</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Access structure</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">QualifiedSet</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Qualified set</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ChallengeMax</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">c plus</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+ for&lt;br&gt;[0c+]&lt;br&gt;Challenge maximum c&lt;br&gt;c ∈R</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;C Generated output of running example in §3</h3>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">C.1 Protocol Inputs</h3>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">Homomorphisms as defined in Input File</h3>

    <p class="text-gray-300"><span class="math">$\\phi_0: \\mathbb{Z}_m^* \\to \\mathbb{Z}_m^*, \\, \\rho_0 \\mapsto \\rho_0^n</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_1: \\mathbb{Z}_m^* \\to \\mathbb{Z}_m^*, \\, \\rho_1 \\mapsto \\rho_1^n</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_2: \\mathbb{Z}_n \\times \\mathbb{Z}_m^* \\to \\mathbb{Z}_m^*, \\, (\\mu, \\rho_2) \\mapsto g^{\\mu} \\cdot \\rho_2^n</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_3: \\mathbb{Z}_n \\times \\mathbb{Z}_m^* \\to \\mathbb{Z}_m^*, \\, (\\mu, \\rho_3) \\mapsto g^{\\mu} \\cdot \\rho_3^n</span>$</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">Homomorphisms as used in Protocol</h3>

    <p class="text-gray-300"><span class="math">$\\psi_0 = \\phi_0 \\times \\phi_2 \\times \\phi_3</span>$</p>

    <p class="text-gray-300"><span class="math">$\\psi_1 = \\phi_1 \\times \\phi_2 \\times \\phi_3</span>$</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8"><strong>Common Input</strong></h3>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}: c^+, n</span>   <span class="math">\\mathbb{Z}_m^*: g, x_a, x_b, x_c</span> Secret Sharing Scheme  <span class="math">\\Theta, \\mathbb{Z}_m^*, \\mathbb{Z}_n</span></p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8"><strong>Preimage Input</strong></h3>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_n : \\mu</span>   <span class="math">\\mathbb{Z}_m^* : \\rho_0, \\rho_1, \\rho_2, \\rho_3</span> Qualified Set A</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">Access Structure</h3>

    <p class="text-gray-300"><span class="math">$\\left( (\\rho_0) \\wedge (\\mu, \\rho_2) \\wedge (\\mu, \\rho_3) \\right) \\vee \\left( (\\rho_1) \\wedge (\\mu, \\rho_2) \\wedge (\\mu, \\rho_3) \\right)</span>$</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Constraints on Preimages</h4>

    <p class="text-gray-300"><span class="math">$\\mu_{\\phi_3} = 1 \\cdot \\mu_{\\phi_2}</span>$</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Relation</h4>

    <p class="text-gray-300"><span class="math">\\begin{aligned} \\phi_0 : x_a &amp;= \\rho_0{}^n \\\\ \\phi_1 : x_a \\cdot g^{-1} &amp;= \\rho_1{}^n \\\\ \\phi_2 : x_b &amp;= g^\\mu \\cdot \\rho_2{}^n \\\\ \\phi_3 : x_c &amp;= g^\\mu \\cdot \\rho_3{}^n \\end{aligned}</span></p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">C.2 Protocol in compact Notation</h3>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">Round 1, Prover:</h3>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\rho_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></li>
      <li><span class="math">t_{\\zeta_i} := \\zeta_i(\\rho_{\\zeta_i})</span></li>
    </ul></li>
      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is unknown:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">s_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></li>
      <li><span class="math">c_i \\in_R [0, c^+]</span></li>
      <li><span class="math">t_{\\zeta_i} := \\zeta_i(s_{\\zeta_i}) \\cdot y_{\\zeta_i}^{c_i}</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">    <img src="_page_24_Picture_10.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">Round 2, Verifier:</h3>

    <p class="text-gray-300"><span class="math">c \\in R[0, c^+]</span></p>

    <p class="text-gray-300">C</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">Round 3, Prover:</h3>

    <p class="text-gray-300"><span class="math">(c_0, c_1) := \\text{complete}(c, \\{[c_i]_{\\bar{A}}\\}, \\Gamma^*(n))</span> For each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$s_{\\zeta_i} := \\rho_{\\zeta_i} + (-x_{\\zeta_i}) \\cdot c_i</span>$</p>

    <p class="text-gray-300"><span class="math">$s_{\\zeta_i}, c_i</span>$</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">Round 4, Verifier:</h3>

    <p class="text-gray-300">Check whether</p>

    <p class="text-gray-300">•  <span class="math">s_{1,3} \\stackrel{?}{=} 1 \\cdot s_{1,1}</span></p>

    <p class="text-gray-300">Check for each  <span class="math">\\zeta_i \\in \\{\\psi_0, \\psi_1\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span>  whether</p>

    <p class="text-gray-300">•  <span class="math">t_{\\zeta_i} \\stackrel{?}{=} \\zeta_i(s_{\\zeta_i}) \\cdot y_{\\zeta_i}^{c_i}</span></p>

    <p class="text-gray-300">Check whether isConsistent <span class="math">(c, \\{[c_i]\\}, \\Gamma^*(n))</span>  returns true</p>

    <h2 id="sec-38" class="text-2xl font-bold">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;D Generated output of example in §4.1</h2>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">D.1 Protocol Inputs</h3>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">Homomorphisms as defined in Input File</h3>

    <p class="text-gray-300"><span class="math">$\\phi_{0}: \\mathbb{Z}_{q}^{2} \\to G, \\ (\\rho, \\mu) \\mapsto v_{s}^{\\rho} \\cdot v_{xy}^{(-1 \\cdot \\mu)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_{1}: \\mathbb{Z}_{q} \\to G, \\ \\nu \\mapsto g^{\\nu}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_{2}: \\mathbb{Z}_{q} \\to G, \\ \\nu \\mapsto h^{\\nu}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_{3}: \\mathbb{Z}_{q}^{2} \\to G, \\ (\\nu, \\mu) \\mapsto y_{1}^{\\nu} \\cdot g^{\\mu}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\phi_{4}: \\mathbb{Z}_{q} \\to G, \\ \\nu \\mapsto (y_{2} \\cdot y_{3}^{H})^{\\nu}</span>$</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">Homomorphisms as used in Protocol</h3>

    <p class="text-gray-300"><span class="math">$\\psi_0 = \\phi_0 \\times \\phi_1 \\times \\phi_2 \\times \\phi_3 \\times \\phi_4</span>$</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">Common Input</h3>

    <p class="text-gray-300"><span class="math">G: c_1, c_2, c_3, c_4, g, h, v_s, v_x, v_{xy}, y_1, y_2, y_3</span>   <span class="math">\\mathbb{Z}_q: H</span>   <span class="math">\\mathbb{Z}: c^+</span>  <span class="math">G, \\text{Secret Sharing Scheme } \\Theta, \\mathbb{Z}_q</span></p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8"><strong>Preimage Input</strong></h3>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_q: \\mu, \\nu, \\rho</span> Qualified Set A</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">Access Structure</h3>

    <p class="text-gray-300"><span class="math">$((\\rho,\\mu) \\wedge (\\nu) \\wedge (\\nu) \\wedge (\\nu,\\mu) \\wedge (\\nu))</span>$</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">Constraints on Preimages</h3>

    <p class="text-gray-300">$$\\mu_{\\phi_3} = 1 \\cdot \\mu_{\\phi_0}
\\nu_{\\phi_2} = 1 \\cdot \\nu_{\\phi_1}
\\nu_{\\phi_3} = 1 \\cdot \\nu_{\\phi_1}
\\nu_{\\phi_4} = 1 \\cdot \\nu_{\\phi_1}$$</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Relation</h4>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\phi_0 : v_x &amp;= v_s{}^{\\rho} \\cdot v_{xy}{}^{(-1 \\cdot \\mu)} \\\\ \\phi_1 : c_1 &amp;= g^{\\nu} \\\\ \\phi_2 : c_2 &amp;= h^{\\nu} \\\\ \\phi_3 : c_3 &amp;= y_1{}^{\\nu} \\cdot g^{\\mu} \\\\ \\phi_4 : c_4 &amp;= (y_2 \\cdot y_3{}^H)^{\\nu} \\end{aligned}</span>$</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">D.2 Protocol in verbose Notation</h3>

    <pre><code class="language-text">Round 1, Prover:

r_{0,0} \\in_R \\mathbb{Z}_q

r_{0,1} \\in_R \\mathbb{Z}_q

r_{0,2} \\in_R \\mathbb{Z}_q

r_{0,5} := r_{0,1} \\cdot 1

r_{0,3} := r_{0,2} \\cdot 1

r_{0,4} := r_{0,2} \\cdot 1

r_{0,6} := r_{0,2} \\cdot 1

t_{0,0} := (v_s^{r_{0,0}} \\cdot v_{xy}^{(-1 \\cdot r_{0,1})})

t_{0,1} := (g^{r_{0,2}})

t_{0,2} := (h^{r_{0,3}})

t_{0,3} := (y_1^{r_{0,4}} \\cdot g^{r_{0,5}})

t_{0,4} := ((y_2 \\cdot y_3^H)^{r_{0,6}})
</code></pre>

    <p class="text-gray-300"><span class="math">\\underbrace{t_{0,0},t_{0,1},t_{0,2},t_{0,3},t_{0,4}}_{}</span></p>

    <p class="text-gray-300">Round 2, Verifier:</p>

    <p class="text-gray-300"><span class="math">c \\in_R [0, c^+]</span></p>

    <p class="text-gray-300">c</p>

    <p class="text-gray-300">Round 3, Prover:</p>

    <pre><code class="language-text"> (s_{0,0}, s_{0,1}) := (r_{0,0}, r_{0,1}) + ((-((\\rho, \\mu)))) \\cdot c
 s_{0,2} := r_{0,2} + ((-(\\nu))) \\cdot c
 s_{0,3} := r_{0,3} + ((-(\\nu))) \\cdot c
 (s_{0,4}, s_{0,5}) := (r_{0,4}, r_{0,5}) + ((-((\\nu, \\mu)))) \\cdot c
 s_{0,6} := r_{0,6} + ((-(\\nu))) \\cdot c
</code></pre>

    <p class="text-gray-300"><span class="math">s_{0,0}, s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}, s_{0,6}</span></p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">Round 4, Verifier:</h3>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">Check whether</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">s_{0.5} \\stackrel{?}{=} 1 \\cdot s_{0.1}</span></li>
      <li><span class="math">s_{0,3} \\stackrel{?}{=} 1 \\cdot s_{0,2}</span></li>
      <li><span class="math">s_{0,4} \\stackrel{?}{=} 1 \\cdot s_{0,2}</span></li>
      <li><span class="math">s_{0.6} \\stackrel{?}{=} 1 \\cdot s_{0.2}</span></li>
    </ul>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">Check whether</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">t_{0,0} \\stackrel{?}{=} (v_s^{s_{0,0}} \\cdot v_{xy}^{(-1 \\cdot s_{0,1})}) \\cdot v_x^c</span></p></li>
      <li><p class="text-gray-300"><span class="math">t_{0,1} \\stackrel{?}{=} (g^{s_{0,2}}) \\cdot c_1{}^c</span></p></li>
      <li><p class="text-gray-300"><span class="math">t_{0,1} = (g^{-}) \\cdot c_1</span>   <span class="math">t_{0,2} \\stackrel{?}{=} (h^{s_{0,3}}) \\cdot c_2{}^c</span>   <span class="math">t_{0,3} \\stackrel{?}{=} (y_1{}^{s_{0,4}} \\cdot g^{s_{0,5}}) \\cdot c_3{}^c</span>   <span class="math">t_{0,4} \\stackrel{?}{=} ((y_2 \\cdot y_3{}^H)^{s_{0,6}}) \\cdot c_4{}^c</span></p></li>
    </ul>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;Generated output of example in §4.2 <span class="math">\\mathbf{E}</span></h4>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">E.1<strong>Protocol Inputs</strong></h4>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">Homomorphisms as defined in Input File</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{aligned} \\phi_1: \\mathbb{Z}_q &amp;\\to \\mathbb{Z}_p^*, \\ w_1 \\mapsto g^{w_1} \\\\ \\phi_2: \\mathbb{Z}_q &amp;\\to \\mathbb{Z}_p^*, \\ w_2 \\mapsto g^{w_2} \\end{aligned}</span></li>
      <li><span class="math">\\phi_3: \\mathbb{Z}_q^{\\stackrel{r}{\\longrightarrow}} \\mathbb{Z}_p^{\\stackrel{r}{\\longrightarrow}}, w_3 \\mapsto g^{w_3}</span></li>
    </ul>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">Homomorphisms as used in Protocol</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\phi_1 = \\phi_1</span></li>
      <li><span class="math">\\phi_2 = \\phi_2</span></li>
      <li><span class="math">\\phi_3 = \\phi_3</span></li>
    </ul>

    <h3 id="sec-55" class="text-xl font-semibold mt-8"><strong>Common Input</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{Z}:c^+</span></li>
      <li><span class="math">\\mathbb{Z}_p^*: g, x_1, x_2, x_3</span></li>
    </ul>

    <p class="text-gray-300">Secret Sharing Scheme  <span class="math">\\Theta, \\mathbb{Z}_p^*, \\mathbb{Z}_q</span></p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8"><strong>Preimage Input</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{Z}_q: w_1, w_2, w_3</span></li>
      <li>Qualified Set A</li>
    </ul>

    <p class="text-gray-300">Access Structure
<span class="math">$((w_1)) \\lor ((w_2)) \\lor ((w_3))</span>$</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">Relation</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\phi_1: x_1 = g^{w_1}</span></li>
      <li><span class="math">\\phi_2: x_2 = g^{w_2}</span></li>
      <li><span class="math">\\phi_3: x_3 = g^{w_3}</span></li>
    </ul>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">E.2 Protocol in compact Notation</h3>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">Round 1, Prover:</h3>

    <p class="text-gray-300">For each  <span class="math">\\zeta_i \\in \\{\\phi_1, \\phi_2, \\phi_3\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is known:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">r_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></li>
      <li><span class="math">t_{\\zeta_i} := \\zeta_i(r_{\\zeta_i})</span></li>
    </ul></li>
      <li>if secret  <span class="math">x_{\\zeta_i}</span>  is unknown:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">s_{\\zeta_i} \\in_R \\operatorname{dom}(\\zeta_i)</span></li>
      <li><span class="math">c_i \\in_R [0, c^+]</span></li>
      <li><span class="math">t_{\\zeta_i} := \\zeta_i(s_{\\zeta_i}) \\cdot y_{\\zeta_i}^{c_i}</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">    <img src="_page_28_Picture_10.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">Round 2, Verifier:</h3>

    <p class="text-gray-300"><span class="math">c \\in_R [0, c^+]</span></p>

    <p class="text-gray-300">C</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">Round 3, Prover:</h3>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;(c_0,c_1,c_2) := \\operatorname{complete}(c,\\{[c_i]_{\\bar{A}}\\},\\varGamma^*(n)) \\\\ &amp;\\text{For each } \\zeta_i \\in \\{\\phi_1,\\phi_2,\\phi_3\\} \\text{ with } y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i}): \\end{split}</span>$</p>

    <p class="text-gray-300">– if secret  <span class="math">x_{\\zeta_i}</span>  is known:  <span class="math">s_{\\zeta_i} := r_{\\zeta_i} + (-x_{\\zeta_i}) \\cdot c_i</span></p>

    <p class="text-gray-300"><span class="math">$s_{\\zeta_i}, c_i</span>$</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">Round 4, Verifier:</h3>

    <p class="text-gray-300">Check for each  <span class="math">\\zeta_i \\in \\{\\phi_1, \\phi_2, \\phi_3\\}</span>  with  <span class="math">y_{\\zeta_i} = \\zeta_i(x_{\\zeta_i})</span>  whether</p>

    <p class="text-gray-300">•
<span class="math">$t_{\\zeta_i} \\stackrel{?}{=} \\zeta_i(s_{\\zeta_i}) \\cdot y_{\\zeta_i}^{c_i}</span>$</p>

    <p class="text-gray-300">Check whether isConsistent <span class="math">(c, \\{[c_i]\\}, \\Gamma^*(n))</span>  returns true</p>

`;
---

<BaseLayout title="5 Extension to Hidden Order Groups (2008/471)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/471
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="5-extension-to-hidden-order-groups-2008" />
  </article>
</BaseLayout>
