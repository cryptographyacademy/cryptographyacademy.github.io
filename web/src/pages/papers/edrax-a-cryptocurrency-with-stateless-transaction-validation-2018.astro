---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/968';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Edrax: A Cryptocurrency with Stateless Transaction Validation';
const AUTHORS_HTML = 'Alexander Chepurnoy, Charalampos Papamanthou, Shravan Srinivasan, Yupeng Zhang';

const CONTENT = `    <p class="text-gray-300">Alexander Chepurnoy Ergo Platform and IOHK</p>

    <p class="text-gray-300">Charalampos Papamanthou University of Maryland</p>

    <p class="text-gray-300">Shravan Srinivasan University of Maryland</p>

    <p class="text-gray-300">Yupeng Zhang Texas A&M University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present Edrax, an architecture for cryptocurrencies with stateless transaction validation. In Edrax, miners and validating nodes process transactions and blocks simply by accessing a short commitment of the current state found in the most recent block. Therefore there is no need to store off-chain and on-disk, order-of-gigabytes large validation state. We present two instantiations of Edrax, one in the UTXO model and one in the accounts model. Our UTXO instantiation uses sparse Merkle trees, which are very fast and require no trusted setup. Our accounts instantiation uses a distributed vector commitment, a type of vector commitment that has state-independent updates, meaning it can be synchronized by accessing only update data (e.g., send 5 ETH from Alice to Bob). Towards this goal, we build a new succinct distributed vector commitment based on multiplexer polynomials and zk-SNARKs, that scales up to one billion accounts. We perform an extensive experimental evaluation comparing to other (recently) proposed approaches for stateless transaction validation, showing that sparse Merkle trees and our new distributed vector commitment offer excellent tradeoffs in this application domain.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Decentralized cryptocurrencies and smart contracts such as Bitcoin <em>[32]</em> and Ethereum <em>[4]</em> promise to remove trusted online parties (e.g., banks and escrows) in sake of faster and more secure financial transactions. Their underlying technology, the blockchain, is an ever-growing hashchain built on blocks of incoming transactions that is agreed upon by a dynamic set of nodes participating in the peer-to-peer cryptocurrency network. This ever-growing nature of the blockchain, however, can limit the cryptocurrency scalability, not only in terms of storage required to store all events since genesis, but also in terms of increasing overheads for transaction validation, blockchain verification and initial synchronization.</p>

    <p class="text-gray-300">Most blockchain-based cryptocurrencies known to date consist of two kinds of parties, clients that own coins (e.g., a secret key to a Bitcoin address) and nodes that validate transactions created by the clients. To decide if an incoming transaction is valid so that it can be included in the next block or propagated to a peer, nodes store all the history of transactions so far—namely the whole blockchain. For example, if a new transaction appears requiring 5 bitcoins to be sent from address <span class="math">A</span> to address <span class="math">B</span>, a node must query the blockchain to check whether <span class="math">A</span> has at least 5 bitcoins in his account. Only if this is the case, this transaction is considered valid and is a candidate for appearing on the blockchain.</p>

    <p class="text-gray-300">The blockchain data structure, however, is large (as of May 2020, Bitcoin blockchain is around 280 GB and Ethereum blockchain has exceeded 130 GB) and is growing continuously. Therefore naively querying it will simply take too long. For that reason, most cryptocurrency nodes are typically <em>stateful</em>, maintaining an appropriate index called <em>validation state</em> that is smaller than the blockchain and which is enough for deciding transaction validity. In some cryptocurrencies (e.g., Bitcoin, ZCash, Komodo, Monero, Ergo) the validation state is a set of immutable coins called UTXO (unspent transaction outputs), in Bitcoin jargon. In this UTXO model, a transaction is valid if it spends coins which belong in UTXO. Other cryptocurrencies (e.g., Nxt, Ethereum, Bitshares, NEM, Tezos) organize the validation state as a set of mutable (and potentially long-living) accounts. In this account model, a transaction is valid if it is trying to spend no more tokens than the available balance. Advantages and disadvantages of both approaches are the focus of an ongoing debate in the cryptocurrency community <em>[41]</em>.</p>

    <p class="text-gray-300">Challenges due to stateful validation. Locally maintaining the validation state, however, is quite cumbersome. In particular, the validation state is in the order of GBs (currently the UTXO set in Bitcoin is around 3.7 GB <em>[27]</em> and the authenticated Patricia trie in Ethereum is around 14 GB) and could grow substantially in the coming years. For example, approximately 86,000 Ethereum new accounts/addresses</p>

    <p class="text-gray-300">are currently generated every day [24] and at this rate the Ethereum validation state is expected to double in one year from now. For a new node to enter the network, the validation state needs to be either downloaded and verified or computed from scratch, making such synchronization an extremely slow process [25] (looking ahead, our approach enables incoming miners to validate transactions instantly, by just accessing the most recent block). Also, being in the order of GBs, the validation state is stored on disk (e.g., the geth Ethereum implementation stores the authenticated Patricia Trie using Google's levelDB [26]), leading to slow transaction validation due to expensive I/Os [37]. This has facilitated various DoS attacks like the one that affected Ethereum in 2016 [40], where adversarially-crafted transactions required a large number of disk accesses causing block validation times to reach 60 seconds! Finally, having to store such large state to verify transactions can lead to disadvantaged miners that cannot dedicate large storage resources [9]. Other practical issues/system-level components (e.g., storage rent, sharding) that can benefit via erasure of the validation state have been extensively analyzed [25].</p>

    <p class="text-gray-300">We address the above by designing and implementing EDRAX, a cryptocurrency protocol where all nodes can check the validity of transactions without having to store any local validation state, i.e., validation state can be maintained, in the form of a short cryptographic commitment, as part of the cryptocurrency blocks on-chain. EDRAX comes in two versions, one supporting the UTXO model and one for the account model. EDRAX's architecture can be seen in Figure 1.</p>

    <p class="text-gray-300">Block commitment, local proofs, transactions. In EDRAX, each block  <span class="math">b</span>  includes a constant-size block commitment of the current validation state (the one that includes all transactions up to block  <span class="math">b</span> ). Clients, along with their coins, store short local proofs that their coins can be spent with respect to the aforementioned block commitment. A local proof is included, with the traditional digital signature, in an EDRAX transaction, enabling miners and validating nodes to verify transactions by accessing the latest commitment.</p>

    <p class="text-gray-300">Local proofs &amp; commitment synchronization. In EDRAX, Alice's local proof for a coin with respect to commitment  <span class="math">\\mathsf{com}_t</span>  at time  <span class="math">t</span>  will be outdated at time  <span class="math">t + 1</span> , after Bob's transactions are incorporated in the blockchain and  <span class="math">\\mathsf{com}_t</span>  changes to  <span class="math">\\mathsf{com}_{t + 1}</span> . EDRAX enables Alice to synchronize her local proofs efficiently by accessing, from the blockchain, the updates that took place between  <span class="math">t</span>  and  <span class="math">t + 1</span> . (The synchronization cost can be large, in particular when Alice has been offline for a long time. In Section 7 where we discuss an optimization using "proof-serving nodes".) Similarly, EDRAX allows miners to easily synchronize the block commitment from  <span class="math">\\mathsf{com}_t</span>  to  <span class="math">\\mathsf{com}_{t + 1}</span>  to incorporate new transactions. The new commitment will be part of the new block.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: EDRAX architecture. Transactions include proofs. Miners verify transactions using the block commitment  <span class="math">\\mathsf{com}_t</span>  stored at the last block  <span class="math">t</span> , an updated version of which is included in the next block  <span class="math">t + 1</span> . Clients synchronize their local proofs after the new block is produced.</p>

    <p class="text-gray-300">Bootstrapping &amp; storage impact. To validate incoming transactions, a newly spawned node in EDRAX just requires the latest block commitment. Thus bootstrapping in EDRAX just requires downloading block headers since the genesis, which is just in MBs (This is in contrast to Bitcoin or Ethereum where gigabytes must be downloaded to start verifying transactions.) We also remark that, unlike transaction signatures, proofs are not fundamentally necessary to verify the EDRAX blockchain—they serve as an efficiency optimization: A miner can simply use the proof to quickly verify an incoming transaction and later discard the proof from his local storage. Thus the size of the blockchain does not necessarily increase.</p>

    <p class="text-gray-300">As warm-up, we show in Section 3 how to provide stateless transaction validation in the UTXO model by using Merkle trees. Recall that in the UTXO model, miners and validating nodes are maintaining a set  <span class="math">S</span>  of unspent transaction outputs. Whenever a new transaction  <span class="math">tx</span>  appears that has input  <span class="math">x</span>  and output  <span class="math">y</span> , nodes must first check whether input  <span class="math">x</span>  belongs in  <span class="math">S</span> , and if so, update set  <span class="math">S</span>  by removing  <span class="math">x</span>  and inserting the new output  <span class="math">y</span> . Our construction represents  <span class="math">S</span>  with a sparse Merkle tree of  <span class="math">2^{W}</span>  leaves where  <span class="math">2^{W}</span>  is the maximum number of outputs that can ever be generated, e.g.,  <span class="math">W = 40</span> . (In Section 7 we suggest an optimization with less leaves using authenticated red-black trees.) At leaf  <span class="math">i</span>  we store the  <span class="math">i</span> -th transaction output that was inserted into set  <span class="math">S</span> . To delete a leaf  <span class="math">j</span> , we just set the value of this leaf to be null. We then naturally define the commitment to be the root of the underlying Merkle tree and local proofs as Merkle tree proofs. The above approach allows insertions and deletions to be performed by miners and validating nodes only if the whole Merkle tree is stored</p>

    <p class="text-gray-300">as commitment which is very large. In Section 3 we show how to append a new output <span class="math">y</span> to <span class="math">S</span> by having nodes access only the local proof of the most recent output ever inserted in <span class="math">S</span> (of size <span class="math">O(W)</span>). Similarly, deletion of Alice’s spent input <span class="math">x</span> from <span class="math">S</span> can be performed by having nodes process Alice’s local proof used to prove membership of <span class="math">x</span> in <span class="math">S</span>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Edrax for accounts via distributed vector commitments</h3>

    <p class="text-gray-300">In the account model, nodes maintain a vector of all account balances which serves as validation state. Whenever Alice wishes to send <span class="math">\\delta</span> tokens to Bob, she posts a transaction including this information. To verify this transaction, nodes must access the balances vector to check whether Alice has at least <span class="math">\\delta</span> tokens in her account.</p>

    <p class="text-gray-300">Why Merkle trees are insufficient. One could consider using Merkle trees to provide stateless validation in the account model as well: Build a Merkle tree on top of the account balances, define the block commitment as the Merkle digest and have the owner of account <span class="math">i</span> maintain a Merkle proof for the balance at position <span class="math">i</span> as her local proof. However, there is a fundamental problem with such an approach. Assume Alice’s balance is <span class="math">v_{A}</span> tokens and Bob’s balance is <span class="math">v_{B}</span> tokens. Whenever Alice wants to send, say, 5 tokens to Bob, Alice needs to include a Merkle tree proof proving her current balance is <span class="math">v_{A}\\geq 5</span>. Once the miner verifies the proof, the miner can process the verified proof to efficiently update the new digest so as to reflect Alice’s new account balance as <span class="math">v_{A}-5</span>. Unfortunately, due to the nature of Merkle trees, Alice’s local proof does not suffice to update Bob’s new balance to <span class="math">v_{B}+5</span> as well unless Alice includes Bob’s local proof in her transaction. However, this would require Alice to contact Bob and ask for his proof every time she sends money to him which is not how cryptocurrencies work! (This is even worse if Alice’s transaction has many recipients.) Instead Alice should be able to send money to Bob by accessing a fixed public address.</p>

    <p class="text-gray-300">Our approach: Distributed vector commitments. Our observation is that any instantiation of, what we call, distributed vector commitments <em>[17, 34, 29]</em>, addresses the above problem. In a distributed vector commitment (DVC), Alice stores a constant-size commitment <span class="math">\\mathsf{C}</span> of an <span class="math">n</span>-sized vector <span class="math">\\mathbf{a}</span>. The vector <span class="math">\\mathbf{a}</span> itself is not stored by Alice but is distributed among <span class="math">n</span> parties, each party holding a proof <span class="math">\\pi_{i}</span> with respect to <span class="math">\\mathsf{C}</span>, in addition to element <span class="math">a_{i}</span>. When Alice wishes to update a vector element at index <span class="math">u</span> by <span class="math">\\delta</span> units, she should be able to update <span class="math">\\mathsf{C}</span> to <span class="math">\\mathsf{C}^{\\prime}</span> easily by having access only to the information <span class="math">(u,\\delta)</span>. That is, unlike Merkle trees, updates are state-independent. Similarly, when party <span class="math">i</span> learns about the update <span class="math">(u,\\delta)</span>, he should be able to efficiently update his proof to <span class="math">\\pi_{i}^{\\prime}</span> with respect to the new commitment <span class="math">\\mathsf{C}^{\\prime}</span>, again only by accessing <span class="math">(u,\\delta)</span>. Distributed vector commitments are fundamentally different than plain vector commitments such as Merkle trees and accumulator-based vector commitments <em>[14]</em>—these have updates that are not state-independent (for details see Section 1.5 and Section 1.6).</p>

    <p class="text-gray-300">Distributed vector commitments are perfect fit for implementing Edrax in the account model by naturally viewing account balances as a vector <span class="math">\\mathbf{v}</span> and by storing <span class="math">\\mathsf{C}=com(\\mathbf{v})</span> as the block commitment: A SPEND transaction is of the form <span class="math">[\\pi_{i},v_{i},i\\rightarrow j,\\delta]</span> meaning a client <span class="math">i</span> owning <span class="math">v_{i}</span> tokens wants to send <span class="math">\\delta\\leq v_{i}</span> tokens to client <span class="math">j</span>; Proof <span class="math">\\pi_{i}</span> enable miners to check that <span class="math">\\delta\\leq v_{i}</span>; Information <span class="math">i\\rightarrow j,\\delta</span> allows miners to update <span class="math">\\mathsf{C}</span> to reflect <span class="math">v_{i}=v_{i}-\\delta</span> and <span class="math">v_{j}=v_{j}+\\delta</span> so as to include it in the next block—it also allows all other clients to synchronize their proofs <span class="math">\\pi_{k}</span> accordingly. The detailed protocol is in Section 5.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.4 New DVC via multiplexers and SNARKs</h3>

    <p class="text-gray-300">A thorough literature review of distributed vector commitments revealed several inefficiencies of existing approaches (see Section 1.6). Therefore we design and implement a new distributed vector commitment for Edrax—see Section 4. Our construction uses the <span class="math">\\ell</span>-variate “multiplexer" polynomial <span class="math">f(\\mathbf{x})</span> to represent a vector of <span class="math">n=2^{\\ell}</span> entries. For example, the multilinear extension for the vector <span class="math">V=[5\\ 2\\ 8\\ 3]</span> is the polynomial <span class="math">f(x_{1},x_{2})=5\\cdot(1-x_{2})(1-x_{1})+2\\cdot(1-x_{2})x_{1}+8\\cdot x_{2}(1-x_{1})+3\\cdot x_{2}x_{1}</span>. Which implies that, <span class="math">f(0,0)=V[0],f(0,1)=V[1],f(1,0)=V[2],</span> and<span class="math">f(1,1)=V[3]</span>. The commitment is then computed as <span class="math">g^{f(\\mathbf{s})}</span>, where <span class="math">g</span> is a generator of an EC group and <span class="math">\\mathbf{s}</span> is a random point that is kept secret.</p>

    <p class="text-gray-300">A proof for a vector element in the above construction has size <span class="math">\\ell</span> and takes <span class="math">O(\\ell)</span> time to verify. We reduce these costs to constant (which translate in a significant reduction in block sizes and miners and validating nodes computation) by using a zk-SNARK on the verification algorithm. While this sounds easy from a theory perspective, it is quite challenging in practice since the verification computation that must be “snarked" involves bilinear pairing operations.</p>

    <p class="text-gray-300">Our construction finally features an <span class="math">O(\\ell)</span>-time algorithm for synchronizing proof <span class="math">\\pi_{i}</span> for a point <span class="math">i\\in\\{0,1\\}^{\\ell}</span> given update <span class="math">(j,\\delta)</span> where <span class="math">j</span> is another point in <span class="math">\\{0,1\\}^{\\ell}</span>—see Algorithm DeltaPol in Section 4.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.5 Comparison with Boneh et al. <em>[14]</em></h3>

    <p class="text-gray-300">The most closely-related work to Edrax is the recent work by Boneh et al. <em>[14]</em> which built RSA-based accumulators for stateless transaction validation in the UTXO model. Unlike our sparse Merkle-tree approach, their construction supports proof batching, which can drastically decrease the block size (For all transactions in the block, one constant-size proof is required, while Merkle trees require one logarithmic-sized proof per transaction.) Their construction can also be instantiated with class groups, avoiding trusted setup, as our sparse Merkle trees do. RSA operations and class groups are however costly compared to SHA-2 hashing and the practical</p>

    <p class="text-gray-300">overhead can be large. In particular, RSA accumulators add an overhead close to <span class="math">17\\times</span> when compared to sparse Merkle trees. Also, when one focuses on <em>no-trusted setup</em>, the best approach for UTXO settings, then Merkle trees is a clear winner by a far bigger gap, since using class groups adds large overhead (In this regime, a Bitcoin block validation has an overhead of approximately <span class="math">18\\times</span> and miners have an overhead of <span class="math">13600\\times</span> compared to sparse Merkle trees.) <em>Boneh et al. [14]</em> also introduce a new vector commitment based on their RSA accumulator construction and propose to apply it for stateless transaction validation in the account model. However, their vector commitment is <em>not</em> a distributed vector commitment: To update <span class="math">\\mathsf{C}</span> to <span class="math">\\mathsf{C}^{\\prime}</span>, Alice requires, in addition to <span class="math">(u,\\delta)</span>, the proof <span class="math">\\pi_{u}</span> (this is also indicated in their definition as “advice" <span class="math">\\tau</span>). Therefore, their vector commitment is not suitable for stateless validation for accounts as we explained before. A detailed evaluation and comparison is presented in Section 6.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.6 Comparison to other DVCs</h3>

    <p class="text-gray-300">Succinctly representing vectors using multilinear extensions was introduced by <em>Zhang et al. [42, 43]</em> for a different application, where proofs are larger and no efficient proof synchronization algorithms are presented.</p>

    <p class="text-gray-300">Distributed vector commitments that can be used to implement Edrax were also introduced by <em>Catalano and Fiore [17]</em>, one based on elliptic curve groups and one based on the RSA cryptosystem. These approaches do not seem to scale. In particular, the EC-based construction <em>[17]</em> has public parameters of quadratic size. Similarly while the RSA-based construction <em>[17]</em> has better verification complexities than our proposed commitment, it requires linear time for proof update (and so does a recent RSA-based work by <em>Campanelli et al. [16]</em>), leading to very slow proof synchronization (around 145 hours for <span class="math">2^{30}</span> accounts). The DVC scheme by <em>Krupp et al. [28]</em> is using <em>[17]</em> as a black-box (additionally offering a “Chameleon" property), thus inheriting its inefficiency. The recent work of <em>Gorbunov et al. [22]</em> introduces PointProofs, a DVC with update keys of linear size. Finally, subsequent to this work, <em>Tomescu et al. [39]</em> present a new DVC that supports aggregation of proofs and has short update keys.</p>

    <p class="text-gray-300">All the above distributed vector commitments have trusted setup. To the best of our knowledge there are two distributed vector commitments with no trusted setup. The lattice-based Merkle tree by <em>Papamanthou et al. [34]</em> (polylogarithmic asymptotic costs) and the recent generalization of an RSA-based DVC <em>[17]</em> to hidden order groups by <em>Lai and Malavolta [29]</em> (linear update proof costs). Both do not scale in practice due to costs associated with lattices and class groups respectively. We present a detailed comparison of the asymptotic costs of our construction with other distributed vector commitments in Table 1, as well as detailed experimental comparison of our distributed vector commitment with the RSA-based one <em>[17]</em> in Section 6.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.7 Implementation and evaluation</h3>

    <p class="text-gray-300">In Section 6 we implement both instantiations of Edrax and evaluate the performance. Our evaluation has three main findings: First, for the UTXO setting, while sparse Merkle trees increase the size of the block by a logarithmic factor, they significantly (<span class="math">17\\times</span>) outperform recently-proposed accumulator-based approaches <em>[14]</em> in terms of computation (e.g., block validation), especially when compared to their equivalent no-trusted setup instantiations based on class groups (<span class="math">18\\times</span>). Second, for the accounts setting, while our vector commitment verification is slower (6s more to verify a block) compared to the only other practical distributed vector commitment <em>[17]</em>, it features a logarithmic-time algorithm (as opposed to linear) for updating local coin proofs, which translates to several orders of magnitude savings (<span class="math">5825\\times</span>) from a cryptocurrency client perspective.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We now give background material on bilinear maps, multilinear extensions, sparse Merkle trees and vector commitments.</p>

    <p class="text-gray-300">Bilinear pairings. We denote by <span class="math">(p,\\mathbb{G},\\mathbb{G}_{T},e,g)\\leftarrow\\texttt{BilGen}(1^{\\lambda})</span> generation of bilinear-map parameters, where <span class="math">\\mathbb{G}</span>, <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">p</span>, with <span class="math">g</span> a generator of <span class="math">\\mathbb{G}</span>, and where <span class="math">e:\\mathbb{G}\\times\\mathbb{G}\\rightarrow\\mathbb{G}_{T}</span> is an efficient map, i.e., for all <span class="math">P,Q\\in\\mathbb{G}</span> and <span class="math">a,b\\in\\mathbb{Z}_{p}</span> it is <span class="math">e(P^{a},Q^{b})=e(P,Q)^{ab}</span>. To prove security we will be using the <span class="math">q</span>-Strong Bilinear Diffie-Hellman assumption <em>[13]</em> (<span class="math">q</span>-SBDH) on the groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{T}</span> that we formally define in the Appendix—see Assumption 1.</p>

    <p class="text-gray-300">Multilinear extension polynomial of vectors. Let <span class="math">\\mathbb{F}</span> be a field (e.g., <span class="math">\\mathbb{Z}_{p}</span>) and let <span class="math">n=2^{\\ell}</span>. Let <span class="math">i\\in\\{0,\\ldots,n-1\\}</span> and let <span class="math">i_{k}</span> denote its bit at position <span class="math">k</span> in binary. For a vector <span class="math">\\textbf{a}=[a_{0},\\ldots,a_{n-1}]</span> with elements in the field <span class="math">\\mathbb{F}</span>, we define its multilinear extension polynomial <span class="math">f_{\\textbf{a}}:\\mathbb{F}^{\\ell}\\rightarrow\\mathbb{F}</span> as a polynomial of <span class="math">\\ell</span> variables that servers as a multiplexer for the vector a, i.e.,</p>

    <p class="text-gray-300"><span class="math">f_{\\textbf{a}}(x_{1},\\ldots,x_{\\ell})=\\sum_{i=0}^{n-1}\\left(a_{i}\\cdot\\prod_{k=1}^{\\ell}\\texttt{select}_{i_{k}}(x_{k})\\right)\\,,</span> (1)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">\\[ \\texttt{select}_{i_{k}}(x_{k})=\\begin{cases}x_{k}&\\text{if }i_{k}=1\\\\ 1-x_{k}&\\text{if }i_{k}=0\\end{cases}\\,. \\] (2)</p>

    <p class="text-gray-300">Note that polynomial <span class="math">f_{\\textbf{a}}</span> is the unique multilinear polynomial such that for all <span class="math">i</span> with binary representation <span class="math">i_{\\ell},\\ldots,i_{1}</span> it is <span class="math">f_{\\textbf{a}}(i_{1},\\ldots,i_{\\ell})=a_{i}</span>. For example, for <span class="math">\\textbf{a}=[5\\ 2\\ 8\\ 3]</span> the polynomial <span class="math">f_{\\textbf{a}}(x_{1},x_{2})</span> equals</p>

    <p class="text-gray-300"><span class="math">5\\cdot(1-x_{2})(1-x_{1})+2\\cdot(1-x_{2})x_{1}+8\\cdot x_{2}(1-x_{1})+3\\cdot x_{2}x_{1}\\,.</span></p>

    <p class="text-gray-300">To simplify, we sometimes represent point <span class="math">(x_{1},\\ldots,x_{\\ell})</span> as x. The following polynomial decomposition from <em>[42]</em> is useful.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 2.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any multilinear polynomial <span class="math">f:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> and for <span class="math">\\mathbf{t}\\in\\mathbb{F}^{\\ell}</span>, there exist polynomials <span class="math">q_{i}</span> such that <span class="math">f(\\mathbf{x})-f(\\mathbf{t})=\\sum_{i=1}^{r}(x_{i}-t_{i})q_{i}(\\mathbf{x})</span>. Moreover, all <span class="math">q_{i}</span> can be computed in $O(2^{\\ell})=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Preprocessing zk-SNARKs. Let <span class="math">\\mathcal{L}</span> be an NP relation such that <span class="math">\\mathbf{x}\\in\\mathcal{L}</span> if and only if there exists a witness <span class="math">\\mathbf{w}</span> such that <span class="math">\\mathcal{L}(\\mathbf{x},\\mathbf{w})=1</span>. A (zero-knowledge) Succinct Noninteractive ARgument of Knowledge (zk-SNARK) <em>[36]</em> for <span class="math">\\mathcal{L}</span> allows a verifier to efficiently verify that <span class="math">\\mathbf{x}\\in\\mathcal{L}</span>, without using <span class="math">\\mathbf{w}</span>, but via a small proof provided by an untrusted prover. A zk-SNARK consists of three polynomial-time algorithms, <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(PK,VK)\\leftarrow\\mathcal{G}(1^{\\lambda},\\mathcal{L})</span>: Key generation algorithm generates the proving and verifying key for the program <span class="math">\\mathcal{L}</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\mathcal{P}(PK,\\mathbf{x},\\mathbf{w})</span>: The prover generates a succinct proof <span class="math">\\pi</span> to prove that there exists <span class="math">\\mathbf{w}</span> such that <span class="math">\\mathcal{L}(\\mathbf{x},\\mathbf{w})=1</span>.</li>

      <li><span class="math">\\{0,1\\}\\leftarrow\\mathcal{V}(VK,\\pi,\\mathbf{x})</span>: The verifier checks if the proof <span class="math">\\pi</span> is valid for <span class="math">\\mathbf{x}</span> using the verifying key <span class="math">VK</span>.</li>

    </ol>

    <p class="text-gray-300">Informally, zk-SNARKs have two properties: First, zero-knowledge, meaning that a verifying proof <span class="math">\\pi</span> does not reveal anything beyond the validity of the statement; Second, knowledge-soundness, meaning that if the verifier accepts a proof for <span class="math">x</span>, the prover “knows” a witness <span class="math">w</span> for <span class="math">x</span> and therefore <span class="math">x\\in\\mathcal{L}</span> (moreover the witness <span class="math">w</span> can be extracted by inspecting the prover’s tape). For our application we will not be using the zero-knowledge property. We give the formal definition of knowledge-soundness in the Appendix—see Definition 3.</p>

    <p class="text-gray-300">Sparse Merkle trees. Sparse Merkle trees are Merkle trees <em>[30]</em> built over key-value pairs <span class="math">(k_{i},v_{i})</span> whose keys <span class="math">k_{i}</span> are drawn from a large domain <span class="math">[0,1,\\ldots,2^{W}-1]</span>. In particular, data item <span class="math">(k_{i},v_{i})</span> is stored at the <span class="math">k_{i}</span>-th leaf of the tree (the tree has a total of <span class="math">2^{W}</span> leaves). We define a natural labeling for all nodes of the sparse Merkle tree: Root takes label <span class="math">\\varepsilon</span>, his left child takes label <span class="math">0</span>, his right child takes label <span class="math">1</span>, his leftmost grandchild takes label <span class="math">00</span> and so on.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">W</span>-bit leaf <span class="math">k_{i}</span> that stores the data element <span class="math">(k_{i},v_{i})</span> we define the commitment of leaf <span class="math">k_{i}</span> as $\\operatorname{com}(k_{i})=k_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{i}<span class="math">. For leaves </span>\\ell<span class="math"> that do not store a key we set </span>\\operatorname{com}(\\ell)=null<span class="math">. For every internal node </span>u<span class="math"> of the Merkle tree we define the commitment of </span>u<span class="math"> as </span>\\operatorname{com}(u)=H(\\operatorname{com}(v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\operatorname{com}(w)})<span class="math">, if either </span>\\operatorname{com}(v)<span class="math"> or </span>\\operatorname{com}(w)<span class="math"> is not null and </span>\\operatorname{com}(u)=null<span class="math"> otherwise. Here, </span>v<span class="math"> is the left child of </span>u<span class="math"> and </span>w<span class="math"> is the right child of </span>u<span class="math"> and </span>H$ is a collision-resistant hash function such as SHA-2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Single item verification and deletion. For data item <span class="math">(k,v)</span> let <span class="math">path(k)</span> be the ordered set of nodes on the path from <span class="math">k</span> to the root <span class="math">\\varepsilon</span> and let <span class="math">sib(k)</span> be the ordered set of siblings of nodes on <span class="math">path(k)</span>. Recall that the proof <span class="math">\\pi(k)</span> for <span class="math">(k,v)</span>, with respect to the commitment of the root <span class="math">\\operatorname{com}(\\varepsilon)</span> is the set <span class="math">\\operatorname{com}(k)\\cup\\{\\operatorname{com}(v):v\\in sib(k)\\}</span>. In particular, to verify the proof, one can run a verification algorithm</p>

    <p class="text-gray-300"><span class="math">d\\leftarrow\\texttt{verifyMerkle}(k,v,\\pi(k))</span> (3)</p>

    <p class="text-gray-300">that recomputes the commitment of the root. If <span class="math">d=\\operatorname{com}(\\varepsilon)</span> the verification is successful and one can be assured (except with negligible probability) that <span class="math">(k,v)</span> is the <span class="math">k</span>-th leaf of the sparse Merkle tree. After a successful verification, the verification algorithm can also be used to update <span class="math">\\operatorname{com}(\\varepsilon)</span> when <span class="math">(k,v)</span> is deleted from the tree. In particular one can run <span class="math">\\operatorname{verify}(k,null,\\pi(k))</span> to output the new commitment <span class="math">d^{\\prime}</span>. The proof size is <span class="math">O(W)</span> and the verification complexity is <span class="math">O(W)</span>.</p>

    <p class="text-gray-300">Batch verification and deletion. The above approach can be generalized for verifying a set of data items <span class="math">S=\\{(k_{1},v_{1}),\\ldots,(k_{t},v_{t})\\}</span> at once. In particular let <span class="math">path(S)</span> be the union of <span class="math">path(k_{i})</span> and let <span class="math">sib(S)</span> be the union of <span class="math">sib(k_{i})</span>. The proof <span class="math">\\pi(S)</span> for all <span class="math">(k_{1},v_{1}),\\ldots,(k_{t},v_{t})</span> in <span class="math">S</span>, with respect to the commitment of the root <span class="math">\\operatorname{com}(\\varepsilon)</span> is the set <span class="math">\\cup_{i}\\operatorname{com}(k_{i})\\cup\\{\\operatorname{com}(v):v\\in sib(S)\\}</span>. In this case we can call <span class="math">\\operatorname{verifyMerkle}(S,\\pi(S))</span> to recompute the commitment of the sparse Merkle tree and verify all elements in <span class="math">S</span>, as well as <span class="math">\\operatorname{verifyMerkle}(\\{(k_{1},null),\\ldots,(k_{t},null)\\},\\pi(S))</span> for the batch deletion of all data elements in <span class="math">S</span>.</p>

    <p class="text-gray-300">Distributed vector commitments. We now give the definition of a distributed vector commitment.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 1 (Distributed Vector Commitment).</h6>

    <p class="text-gray-300">A distributed vector commitment <span class="math">\\mathsf{DVC}</span> consists of six ppt algorithms:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>: Given security parameter <span class="math">\\lambda</span> and vector length <span class="math">n</span>, it outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{C}\\leftarrow\\mathsf{Com}_{\\mathsf{pp}}(a_{0},\\ldots,a_{n-1})</span>: Given <span class="math">\\mathbf{a}=(a_{0},\\ldots,a_{n-1})</span>, it outputs a commitment <span class="math">\\mathsf{C}</span>.</li>

      <li><span class="math">\\pi_{i}\\leftarrow\\mathsf{Open}_{\\mathsf{pp}}(i,v,\\mathbf{a})</span>: Given index <span class="math">i</span>, value <span class="math">v</span> and <span class="math">\\mathbf{a}</span>, it outputs proof <span class="math">\\pi_{i}</span>.</li>

      <li><span class="math">\\{0,1\\}\\leftarrow\\mathsf{Ver}_{\\mathsf{pp}}(\\mathsf{C},i,v,\\pi)</span>: Given commitment <span class="math">\\mathsf{C}</span>, an index <span class="math">i</span>, a value <span class="math">v</span> and a proof <span class="math">\\pi</span> it either accepts or rejects.</li>

      <li><span class="math">\\mathsf{C^{\\prime}}\\leftarrow\\mathsf{UpdateCom}_{\\mathsf{pp}}(u,\\delta,\\mathsf{C})</span>: Given update <span class="math">(u,\\delta)</span> and commitment <span class="math">\\mathsf{C}</span>, it outputs the updated commitment <span class="math">\\mathsf{C^{\\prime}}</span>.</li>

      <li><span class="math">\\pi^{\\prime}_{i}\\leftarrow\\mathsf{UpdateProof}_{\\mathsf{pp}}(u,\\delta,\\pi_{i})</span>: Given update <span class="math">(u,\\delta)</span> and a proof <span class="math">\\pi_{i}</span>, it outputs the updated proof <span class="math">\\pi^{\\prime}_{i}</span>.</li>

    </ol>

    <p class="text-gray-300">The correctness definition for DVC is in the Appendix—Definition 4. We now present the soundness definition.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2 (Soundness of distributed vector commitment).</h6>

    <p class="text-gray-300">Consider the following experiment that takes as input the security parameter <span class="math">\\lambda</span> and outputs vector <span class="math">\\mathbf{a}</span>, index <span class="math">i</span>, value <span class="math">a</span> and <span class="math">a</span> bit <span class="math">b</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">n</span> be output by the adversary <span class="math">\\mathcal{A}</span>;</li>

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>;</li>

      <li>Let <span class="math">\\mathbf{a}=[a_{0},\\ldots,a_{n-1}]</span> be output by <span class="math">\\mathcal{A}</span>;</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}\\gets \\mathrm{Com}_{\\mathrm{pp}}(\\mathbf{a})</span> for  <span class="math">i = 1,\\dots ,t = poly(\\lambda)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>  outputs  <span class="math">(u, \\delta)</span>  and let  <span class="math">\\mathbf{a}</span>  be the updated vector;</li>

      <li><span class="math">\\mathsf{C} \\gets \\mathsf{UpdateCom}_{\\mathsf{pp}}(u, \\delta, \\mathsf{C})</span> ;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>  outputs  <span class="math">i, a, \\pi</span>  and let  <span class="math">b \\gets \\operatorname{Ver}_{\\mathrm{pp}}(C, i, a, \\pi)</span> .</li>

      <li>return  <span class="math">(\\mathbf{a}, i, a, b)</span> ;</li>

    </ul>

    <p class="text-gray-300">A distributed vector commitment scheme is sound if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the probability  <span class="math">b = 1</span>  and  <span class="math">a \\neq a_i</span> , where  <span class="math">a_i</span>  is the value at  <span class="math">i</span>  is negligible.</p>

    <p class="text-gray-300">Recall the UTXO-based model follows the design of Bitcoin-like cryptocurrencies, where validating a transaction  <span class="math">tx</span>  depends on whether its inputs belong to a set of unspent transaction outputs (or UTXO) that is maintained by the miners. Once this condition is verified, the spent inputs of  <span class="math">tx</span>  are removed from UTXO and the new outputs of  <span class="math">tx</span>  are added to UTXO. We first describe a version of EDRAX in this model.</p>

    <p class="text-gray-300">Representing UTXO as a sparse Merkle tree. We will represent the UTXO set as a sparse Merkle hash tree. A similar approach has been used in Zcash [10]—unlike Zcash, however, here we remove a transaction output from the Merkle tree after it is spent by marking it as null, see Figure 2. In particular each element of the UTXO is of the form  <span class="math">(i, [pk, v])</span>  where  <span class="math">i</span>  is the an increasing timestamp/counter indicating when this output was added to the UTXO (and serves as the "key" in the sparse Merkle tree) and  <span class="math">[pk, v]</span>  contains the public key  <span class="math">pk</span>  and EDRAX units  <span class="math">v</span>  that this output can be spent to (and serves as the "value" in the sparse Merkle tree).</p>

    <p class="text-gray-300">Block commitment. Every block  <span class="math">b</span>  at time  <span class="math">t</span>  ( <span class="math">t</span>  refers to the rank of the block in the blockchain) in UTXO EDRAX contains the following information as block commitment.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The UTXO commitment  <span class="math">\\mathsf{com}_t</span>  which is the root commitment of the sparse Merkle tree built on transaction outputs that have been generated up to block  <span class="math">b</span> , block  <span class="math">b</span>  included (for outputs that have already been spent we mark them as null);</li>

      <li>The Merkle tree proof of the most recent entry in the UTXO, i.e., the Merkle tree proof corresponding to the last output of the last transaction in the last block  <span class="math">b</span> . We call this proof most recent proof and we denote it as  <span class="math">\\pi_t</span> .</li>

    </ol>

    <p class="text-gray-300">Client state. A EDRAX client stores the list  <span class="math">\\mathcal{L}</span>  of his unspent transaction outputs  <span class="math">(i, [pk_i, v_i])</span>  (ones for which he knows respective secret keys  <span class="math">sk_i</span> ) and respective Merkle proofs  <span class="math">\\pi(i)</span> .</p>

    <p class="text-gray-300">SPEND transaction. For simplifying exposition, suppose Alice wants to create a transaction  <span class="math">tx</span>  that spends a transaction</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 2: Evolution of the sparse Merkle tree on the UTXO set. In Tree A, the UTXO set contains 4 unspent outputs that were added with timestamps 0, 4, 5 and 7. The outputs that were added with timestamps 1, 2, 3 and 6 have already been spent (and thus deleted/nullified). We highlight with green color the nodes that constitute the most recent proof  <span class="math">\\pi(7)</span> . In Tree B a new transaction  <span class="math">tx</span>  with input 4 appears in the system (thus 4 must be deleted from the tree), causing the most recent proof  <span class="math">\\pi(7)</span>  to change one of its hashes to  $H(null</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dig(5))<span class="math"> , indicated with dark green color. The output of  </span>tx<span class="math">  is added in Tree C at the next position 8, causing the update of the most recent proof from  </span>\\pi(7)<span class="math">  to  </span>\\pi(8)<span class="math"> . Note  </span>\\pi(8)<span class="math">  in Tree C can be computed from  </span>\\pi(7)$  in Tree B using Algorithm 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">output  <span class="math">(x, [pk, v])</span>  in her local list  <span class="math">\\mathcal{L}</span>  to a specific public key PK (we can trivially generalize the SPEND transaction for multiple inputs and outputs). Let  <span class="math">sk</span>  be the corresponding secret key to  <span class="math">pk</span> . Alice constructs and signs, using  <span class="math">sk</span> , the transaction:</p>

    <div class="my-4 text-center"><span class="math-block">[ (x, [ p k, v ]), \\pi (x), \\mathrm {P K} ].</span></div>

    <p class="text-gray-300">To be valid,  <span class="math">\\pi (x)</span>  must refer to the last block, i.e., at time  <span class="math">t</span></p>

    <p class="text-gray-300">New block creation. Suppose the last block that was computed is block  <span class="math">t</span>  and miners are competing for block  <span class="math">t + 1</span> . For that miners collect incoming SPEND transactions of the type</p>

    <div class="my-4 text-center"><span class="math-block">[ (x, [ p k, v ]), \\pi (x), \\mathrm {P K} ], s i g</span></div>

    <p class="text-gray-300">and decide using the block commitment at block  <span class="math">t</span>  whether to include a transaction in block  <span class="math">t + 1</span>  as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(transaction signature verification) Check that signature  <span class="math">sig</span>  is valid under public key  <span class="math">pk</span> ;</li>

      <li>(verifying membership of transaction input in UTXO) Run</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {v e r i f y M e r k l e} (x, [ p k, v ], \\pi (x))</span></div>

    <p class="text-gray-300">as in Relation 3 to output a hash  <span class="math">d</span> . If  <span class="math">d</span>  equals  <span class="math">\\mathsf{com}_t</span>  (part of the block commitment), then the miner is assured  <span class="math">(x, [pk, v])</span>  exists in the UTXO set and thus can be spent.</p>

    <p class="text-gray-300">The time required for verifying a transaction is  <span class="math">O(W)</span>  since one Merkle tree proof must be verified per transaction. The</p>

    <p class="text-gray-300">transactions that satisfy the above checks are candidates for the next block. The block has size <span class="math">O(m\\cdot W)</span> where <span class="math">m</span> is the number of transactions in the block. Finally, in the new block <span class="math">t+1</span>, miners must also include the updated UTXO commitment, i.e., <span class="math">\\mathsf{com}_{t+1}</span> and the new most recent proof <span class="math">\\pi_{t+1}</span>. We describe this procedure next.</p>

    <p class="text-gray-300">Creating the new block commitment. We first show how to create the new block commitment <span class="math">\\mathsf{com}_{t}</span>, <span class="math">\\pi_{t}</span> for one transaction <span class="math">[(x,[pk,v]),\\pi(x),\\mathsf{PK}]</span> with one input and one output and then we generalize to multiple transactions—see Figure 2. In particular, to compute <span class="math">\\mathsf{com}_{t+1}</span> and <span class="math">\\pi_{t+1}</span> given <span class="math">\\mathsf{com}_{t}</span> and <span class="math">\\pi_{t}</span> the miners perform the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(deleting transaction input from UTXO) Update the UTXO commitment <span class="math">\\mathsf{com}_{t}</span> to <span class="math">d^{\\prime}</span> to not contain spent input <span class="math">(x,[pk,v])</span> anymore by running <span class="math">d^{\\prime}\\leftarrow\\texttt{verifyMerkle}(x,\\mathit{null},\\pi(x))</span> as we described in Section 2;</li>

      <li>(updating most recent proof due to deletion) Let <span class="math">cnt</span> be the timestamp corresponding to the most recent proof <span class="math">\\pi_{t}</span>. For every node <span class="math">v\\in\\mathit{sib}(cnt)\\cap\\mathit{path}(x)</span> replace every commitment <span class="math">\\mathsf{com}(v)</span> in the most recent proof <span class="math">\\pi_{t}</span> with the new commitments <span class="math">\\mathsf{com}(v)</span> as computed by running algorithm <span class="math">\\mathsf{verifyMerkle}(x,\\mathit{null},\\pi(x))</span> above leading to a new proof <span class="math">\\pi^{\\prime}</span>—see Tree B in Figure 2.</li>

      <li>(adding transaction output to UTXO) The new transaction output should now be stored at leaf <span class="math">cnt+1</span> as <span class="math">(cnt+1),[\\mathsf{PK},v])</span>. Because of the addition of the new leaf, the most recent proof <span class="math">\\pi^{\\prime}=\\pi(cnt)</span> computed above must be updated to <span class="math">\\pi_{t}=\\pi(cnt+1)</span>. Intuitively this can be done since <span class="math">\\pi_{t}</span> is “to the right" of <span class="math">\\pi^{\\prime}</span>—see UpdateMostRecentProof (Algorithm 3 in the Appendix) for the detailed pseudocode and Tree C in Figure 3. After <span class="math">\\pi_{t+1}</span> is computed, miners can finally update the UTXO commitment by running <span class="math">\\mathsf{verifyMerkle}(cnt+1,[\\mathsf{PK},v],\\pi_{t})</span> which will output the final commitment <span class="math">\\mathsf{com}_{t+1}</span>.</li>

    </ol>

    <p class="text-gray-300">Processing multiple inputs and outputs. To process a block with more than one transactions with more than one inputs and outputs (as it typically happens in practice), miners must perform <em>batch verification</em> and <em>batch deletion</em> to verify and delete the inputs from the UTXO, as described in Section 2. This not just an optimization, but it is needed for correctness (otherwise proofs will be out-of-sync). Finally, to add the new outputs to the UTXO, the miners run Step (3) above as many times as the number of new outputs generated in the block. Updating the block commitment with the above steps takes <span class="math">O(m\\cdot W)</span> time where <span class="math">m</span> is the total number of transaction inputs and outputs in the block.</p>

    <p class="text-gray-300">Proof computation & synchronization. For an unspent output <span class="math">(x,[pk,v])</span> in the UTXO, let <span class="math">\\pi(x)</span> be the proof stored locally by the client with respect to time <span class="math">t</span>. To synchronize <span class="math">\\pi(x)</span> for time <span class="math">t+1</span>, the client must process all transactions in the block at time <span class="math">t+1</span> by performing the same steps as the miners above. But instead of outputting commitment <span class="math">\\mathsf{com}_{t+1}</span> at time <span class="math">t+1</span> and most recent proof <span class="math">\\pi_{t+1}</span> at time <span class="math">t+1</span>, he just replaces the affected commitments in <span class="math">\\pi(x)</span>, due batch deletion and addition of the new outputs. In general, to synchronize between <span class="math">t_{1}</span> and <span class="math">t_{2}</span>, he repeats this process <span class="math">t_{2}-t_{1}</span> times.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4 DVC Construction</h2>

    <p class="text-gray-300">We now present our new distributed vector commitment construction used in the implementation of account-based Edrax. We present all algorithms in detail, as defined in Definition 1, then we show correctness as defined in Definition 4 in Appendix and soundness, as required by Definition 2.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.1 Detailed construction</h3>

    <p class="text-gray-300">Our construction, among other things, will be using a zk-SNARK as a black box, on an NP relation of logarithmic size (therefore the prover will be quite efficient). We formally describe this relation in the following.</p>

    <p class="text-gray-300">The NP relation <span class="math">\\mathcal{L}_{\\mathbf{g}}</span>. Let now <span class="math">(p,\\mathbb{G},\\mathbb{G}_{T},e,g)</span> be the output of <span class="math">\\mathsf{BilGen}(1^{\\lambda})</span> and let <span class="math">\\ell=\\log n</span>. Let now <span class="math">\\mathbf{g}=[g_{1},\\ldots,g_{\\ell}]</span> be <span class="math">\\ell</span> fixed group elements of <span class="math">\\mathbb{G}</span>. Consider now the following NP relation <span class="math">\\mathcal{L}_{\\mathbf{g}}</span> that contains elements <span class="math">(\\mathsf{C},i,v)\\in(\\mathbb{G}\\times\\mathbb{Z}_{p}\\times\\mathbb{Z}_{p})</span> iff there exists group elements <span class="math">w_{1},\\ldots,w_{\\ell}</span> in <span class="math">\\mathbb{G}</span> such that</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{C}\\cdot g^{-\\nu},g)</span> <span class="math">=</span> <span class="math">\\prod_{k=1}^{\\ell}e(g_{k}\\cdot g^{-i_{k}},w_{k})</span> <span class="math">i</span> <span class="math">=</span> <span class="math">\\sum_{k=1}^{\\ell}i_{k}2^{k-1}</span> <span class="math">i_{k}(1-i_{k})</span> <span class="math">=</span> <span class="math">0\\text{ for }k=1,\\ldots,\\ell</span></p>

    <p class="text-gray-300">i.e., <span class="math">i_{1},\\ldots,i_{\\ell}</span> is the binary representation of <span class="math">i</span>. Note now that the witness in the above relation is <span class="math">(w_{1},\\ldots,w_{k},i_{1},\\ldots,i_{k})</span>. We now describe the DVC algorithms in detail.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>: Let <span class="math">(p,\\mathbb{G},\\mathbb{G}_{T},e,g)</span> be the output of <span class="math">\\mathsf{BilGen}(1^{\\lambda})</span>. Let <span class="math">\\ell=\\log n</span> and let <span class="math">\\mathcal{S}</span> be the powerset of <span class="math">\\{1,2,\\ldots,\\ell\\}</span>. Select <span class="math">s_{1},\\ldots,s_{\\ell}</span> randomly from <span class="math">\\mathbb{F}</span> and set</p>

    <p class="text-gray-300"><span class="math">\\mathsf{prk}=\\left\\{g^{\\prod_{i\\in S}s_{i}}:S\\in\\mathcal{S}\\right\\}\\text{ and }\\mathbf{g}=[g^{s_{1}},\\ldots,g^{s_{\\ell}}]\\,.</span></p>

    <p class="text-gray-300">Also for all <span class="math">u=0,\\ldots,n-1</span>, we define the update key for position <span class="math">u</span> to contain the following <span class="math">\\ell</span> group elements, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{upk}_{u}=\\left\\{g^{\\prod_{i=1}^{t}\\mathsf{select}_{u_{k}}(s_{k})}:t\\in[\\ell]\\right\\}=\\left\\{\\mathsf{upk}_{u,t}:t\\in[\\ell]\\right\\}\\,.</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{select}_{u_{k}}(s_{k})</span> is by Equation 2. For example, for <span class="math">\\ell=3</span>, public parameters <span class="math">\\mathsf{pp}</span> will contain</p>

    <p class="text-gray-300"><span class="math">g,g^{s_{1}},g^{s_{2}},g^{s_{1}s_{2}},g^{s_{1}s_{3}},g^{s_{2}s_{3}},g^{s_{1}s_{2}s_{3}},</span></p>

    <p class="text-gray-300">Algorithm 1 Algorithm for computing the polynomials that are required to update the proof at position  <span class="math">i</span>  on update  <span class="math">(u,\\delta)</span> . 1: procedure  <span class="math">[\\Delta_{\\ell}(\\mathbf{x}),\\dots,\\Delta_{1}(\\mathbf{x})]\\gets \\mathrm{DELTAPOL}(u,\\delta ,i,\\ell)</span> 2: if  <span class="math">\\ell &amp;gt;0</span>  then 3: if msb of  <span class="math">u</span>  is 0 and msb of  <span class="math">i</span>  is 1 then return  <span class="math">\\left[-\\delta \\cdot \\prod_{k = 1}^{\\ell -1}\\mathrm{select}_{u_k}(x_k),0,\\ldots ,0\\right]</span>  . 4: if msb of  <span class="math">u</span>  is 1 and msb of  <span class="math">i</span>  is 0 then return  <span class="math">\\left[+\\delta \\cdot \\prod_{k = 1}^{\\ell -1}\\mathrm{select}_{u_k}(x_k),0,\\ldots ,0\\right]</span>  . 5: if msb of  <span class="math">u</span>  is 0 and msb of  <span class="math">i</span>  is 0 then return  <span class="math">\\left[-\\delta \\cdot \\prod_{k = 1}^{\\ell -1}\\mathrm{select}_{u_k}(x_k),\\mathrm{DELTAPOL}(u\\bmod 2^\\ell ,\\delta ,i\\bmod 2^\\ell ,\\ell -1)\\right]</span>  . 6: if msb of  <span class="math">u</span>  is 1 and msb of  <span class="math">i</span>  is 1 then return  <span class="math">\\left[+\\delta \\cdot \\prod_{k = 1}^{\\ell -1}\\mathrm{select}_{u_k}(x_k),\\mathrm{DELTAPOL}(u\\bmod 2^\\ell ,\\delta ,i\\bmod 2^\\ell ,\\ell -1)\\right]</span>  ;</p>

    <p class="text-gray-300">while the update key  <span class="math">\\mathsf{upk}_0</span>  will contain</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{g ^ {1 - s _ {1}}, g ^ {(1 - s _ {1}) (1 - s _ {2})}, g ^ {(1 - s _ {1}) (1 - s _ {2}) (1 - s _ {3})} \\right\\}.</span></div>

    <p class="text-gray-300">Let now  <span class="math">(PK, VK) \\gets \\mathcal{G}(1^{\\lambda}, \\mathcal{L}_{\\mathbf{g}})</span> , where  <span class="math">\\mathcal{G}</span>  generates public parameters of the zk-SNARK for  <span class="math">\\mathcal{L}_{\\mathbf{g}}</span> . All prk,  <span class="math">\\mathrm{upk}_u</span>  ( <span class="math">u = 0, \\dots, n-1</span> ) and  <span class="math">(PK, VK)</span>  comprise the parameters pp of the distributed vector commitment.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C} \\gets \\mathsf{Com}_{\\mathsf{pp}}(a_0, \\ldots, a_{n-1})</span> : Set  <span class="math">\\mathsf{C} = g^{f_{\\mathbf{a}}(s_1, \\ldots, s_\\ell)}</span> , where  <span class="math">f_{\\mathbf{a}}</span>  is the multilinear extension polynomial of the vector  <span class="math">\\mathbf{a} = [a_0, \\ldots, a_{n-1}]</span>  as defined in Equation 1.</p>

    <p class="text-gray-300"><span class="math">\\pi_i \\gets \\mathrm{Open}_{\\mathrm{pp}}(i, v, \\mathbf{a})</span> : Let  <span class="math">i_\\ell, \\ldots, i_1</span>  be the binary representation of  <span class="math">i</span> . As  <span class="math">v = f_{\\mathbf{a}}(i_1, \\ldots, i_\\ell)</span> , using polynomial decomposition, compute polynomials  <span class="math">q_1, \\ldots, q_\\ell</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {\\mathbf {a}} (\\mathbf {x}) - v = \\sum_ {k = 1} ^ {\\ell} \\left(x _ {k} - i _ {k}\\right) q _ {k} (\\mathbf {x}).</span></div>

    <p class="text-gray-300">Compute elements  <span class="math">\\{g^{q_1(\\mathbf{s})},\\dots ,g^{q_\\ell (\\mathbf{s})}\\}</span> . To compute polynomials  <span class="math">q_{1},\\ldots ,q_{\\ell}</span> , we divide  <span class="math">f_{\\mathbf{a}}(\\mathbf{x}) - f_{\\mathbf{a}}(i_1,\\dots ,i_\\ell)</span>  by  <span class="math">x_{\\ell} - i_{\\ell}</span>  and set  <span class="math">q_{\\ell}</span>  as the quotient polynomial of the division, which is a multilinear polynomial with variables  <span class="math">x_{1},\\ldots ,x_{\\ell -1}</span> . The remainder is a multilinear polynomial with variables  <span class="math">x_{1},\\ldots ,x_{\\ell -1}</span> , which we divide by  <span class="math">x_{\\ell -1} - i_{\\ell -1}</span>  to get  <span class="math">q_{\\ell -1}</span> . We repeat recursively until we get  <span class="math">q_{1}</span> . Let now  <span class="math">\\mathsf{C} = g^{f_{\\mathbf{a}}(s_1,\\dots ,s_\\ell)}</span> . Note that  <span class="math">(\\mathsf{C},i,v)\\in \\mathcal{L}_{\\mathbf{g}}</span>  with witness  <span class="math">\\{w_{1} = g^{q_{1}(\\mathbf{s})},\\dots ,w_{\\ell} = g^{q_{\\ell}(\\mathbf{s})}\\}</span> . The final proof is</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {i} \\leftarrow \\mathcal {P} (P K, (\\mathrm {C}, i, v), \\{w _ {1}, \\dots , w _ {\\ell} \\}).</span></div>

    <p class="text-gray-300">We note here that  <span class="math">\\{w_{1},\\ldots ,w_{\\ell}\\}</span>  would suffice as proof of  <span class="math">\\nu</span>  at index  <span class="math">i</span>  but consists of  <span class="math">\\log n</span>  elements. zk-SNARKs allow us to compress the proof to a constant number of elements.</p>

    <p class="text-gray-300"><span class="math">\\{0,1\\} \\gets \\mathrm{Ver}_{\\mathrm{pp}}(C,i,v,\\pi)</span> : To verify that  <span class="math">\\nu</span>  is the opening at position  <span class="math">i</span>  of  <span class="math">C</span> , we verify the zk-SNARK proof  <span class="math">\\pi</span>  by invoking  <span class="math">\\{0,1\\} \\gets \\mathcal{V}(VK,\\pi ,(C,i,v))</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}^{\\prime}\\gets \\mathsf{UpdateCom}_{\\mathsf{pp}}(u,\\delta ,\\mathsf{C})</span>  : Compute new commitment as</p>

    <div class="my-4 text-center"><span class="math-block">C ^ {\\prime} = C \\cdot \\left[ g ^ {\\prod_ {k = 1} ^ {\\ell} \\operatorname {s e l e c t} _ {u _ {k}} \\left(x _ {k}\\right)} \\right] ^ {\\delta} = \\operatorname {d i g} \\cdot \\left[ \\operatorname {u p k} _ {u, \\ell} \\right] ^ {\\delta}.</span></div>

    <p class="text-gray-300">From the above note  <span class="math">\\mathsf{upk}_{u,\\ell}</span>  is sufficient to update the digest.</p>

    <p class="text-gray-300"><span class="math">\\pi_i&#x27; \\gets \\text{UpdateProof}_{\\mathrm{pp}}(u, \\delta, \\pi_i)</span> : Assume the witness  <span class="math">w</span>  used to generate  <span class="math">\\pi_i</span>  is available as  <span class="math">w_1, \\ldots, w_\\ell</span>  (in practice this can be proof metadata used only for updating the proof, but not for verification). For  <span class="math">i = 1</span>  to  <span class="math">\\ell</span>  set</p>

    <div class="my-4 text-center"><span class="math-block">w _ {i} ^ {\\prime} = w _ {i} \\cdot g ^ {\\Delta_ {i} (\\mathbf {s})},</span></div>

    <p class="text-gray-300">where  <span class="math">\\Delta_{\\ell}(\\mathbf{x}),\\ldots ,\\Delta_{1}(\\mathbf{x})</span>  are the polynomials computed by calling DELTAPOL(u,  <span class="math">\\delta ,i,\\ell</span>  ) (see Algorithm 1). Note that it is very easy to modify DELTAPOL to output the terms  <span class="math">g^{\\Delta_i(\\mathbf{s})}</span>  directly by allowing it to access the update key  <span class="math">\\mathsf{upk}_u</span>  of  <span class="math">u</span>  (so instead for computing, for example, the polynomial  <span class="math">-\\delta \\cdot \\prod_{k = 1}^{\\ell -1}\\mathrm{select}_{u_k}(x_k)</span>  it can just directly output  <span class="math">[\\mathsf{upk}_{u,\\ell -1}]^{-\\delta})</span>  To output the new proof, we can call</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {i} ^ {\\prime} \\leftarrow \\mathcal {P} (P K, (\\mathrm {C} ^ {\\prime}, i, v), \\{w _ {1} ^ {\\prime}, \\dots , w _ {\\ell} ^ {\\prime} \\}),</span></div>

    <p class="text-gray-300">where  <span class="math">C^\\prime</span>  is computed  <span class="math">C^\\prime \\gets \\mathsf{UpdateCom}_{\\mathsf{pp}}(u,\\delta ,\\mathsf{C})</span></p>

    <p class="text-gray-300">To prove correctness of our scheme according to Definition 4, we need to prove correctness of Algorithm DELTAPOL (Algorithm 1). We give the proof in the Appendix—see Lemma 7.1. Correctness of the rest of the scheme follows by inspection.</p>

    <p class="text-gray-300">Concerning security, our distributed vector commitment can be viewed as an application of the selectively-secure verifiable polynomial delegation scheme in [33], for the multilinear polynomial of Relation 1. While selective security is very weak in general, we show it is enough for our application. This is because a vector commitment requires evaluating the polynomial on a fixed number of points, i.e., on the hypercube  <span class="math">\\{0,1\\}^{\\ell}</span>  and not on arbitrary (exponentially-many) points in  <span class="math">\\mathbb{Z}_p^\\ell</span> . We provide the detailed proof in the following.</p>

    <p class="text-gray-300">Theorem 4.1. The distributed vector commitment scheme presented above is sound (according to Definition 2) under Assumption 1 and assuming knowledge-soundness of the underlying zk-SNARK as defined in Definition 3.</p>

    <p class="text-gray-300">Proof. We now prove the soundness of the distributed vector commitment. First an  <span class="math">\\ell</span> -SBDH instance</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(p, \\mathbb {G}, \\mathbb {G} _ {T}, e, g\\right), g ^ {s}, \\dots , g ^ {s ^ {\\ell}}\\right)</span></div>

    <p class="text-gray-300">Table 1: Comparison of our EDRAX DVC with existing DVCs that have short keys for updating proofs.  <span class="math">n</span>  is the size of the vector.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Open</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UpdateComm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">UpdateProof</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trusted Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[17] (EC)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[17] and [16] (RSA)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[39] (EC)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[34] (lattices)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[29] (class groups)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">EDRAX</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n log log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is given to adversary  <span class="math">\\mathcal{A}_1</span> . Then  <span class="math">\\mathcal{A}_1</span>  picks random  <span class="math">b \\in \\{0, 1\\}^\\ell</span>  (such that  <span class="math">2^\\ell</span>  is poly( <span class="math">\\lambda</span> ) and implicitly computes  <span class="math">s_1 = s</span>  and  <span class="math">s_i = r_i \\cdot (s - b_1) + b_i</span>  where  <span class="math">r_i</span>  are random. Now, given</p>

    <p class="text-gray-300"><span class="math">g^{s},\\ldots ,g^{s^{\\ell}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_1</span>  can easily compute  <span class="math">\\mathsf{pp}</span> , which he all gives to  <span class="math">\\mathcal{A}_2</span> . Moreover, these keys are indistinguishable from Gen's output since the  <span class="math">r_i</span> 's have been picked at random. We now show that if  <span class="math">\\mathcal{A}_2</span>  is able to break soundness as defined in Definition 2 (by providing a forgery  <span class="math">(x,a,\\pi)</span>  to  <span class="math">\\mathcal{A}_1</span> ) then  <span class="math">\\mathcal{A}_1</span>  will be able to use that forgery and break Assumption 1.</p>

    <p class="text-gray-300">Indeed, given a vector  <span class="math">\\mathbf{a}</span>  and the corresponding commitment  <span class="math">C</span> , suppose  <span class="math">\\mathcal{A}_2</span>  is able to output a forgery  <span class="math">(x,a,\\pi)</span>  such that it holds  <span class="math">1 \\leftarrow \\operatorname{Ver}_{\\mathsf{pp}}(C,x,a,\\pi)</span>  and  <span class="math">a \\neq a_x</span> , where  <span class="math">a_x</span>  is the current value at index  <span class="math">x</span>  of  <span class="math">\\mathbf{a}</span>  after a possible sequence of updates. Let us assume that the index  <span class="math">x</span>  that  <span class="math">\\mathcal{A}_2</span>  chose to forge is the index  <span class="math">b</span>  that  <span class="math">\\mathcal{A}_1</span>  picked previously to compute the secrets  <span class="math">s_i</span> —namely  <span class="math">x = b</span> . Note that the probability of that event is  <span class="math">1/2^\\ell = 1/poly(\\lambda)</span> . Now, since  <span class="math">1 \\leftarrow \\mathcal{V}(VK,\\pi,(C,x,a))</span> , by the knowledge-soundness of the zk-SNARK (see Definition 3) there exists an extractor that can retrieve  <span class="math">w_1, \\ldots, w_\\ell</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(g ^ {f _ {\\mathbf {a}} \\left(s _ {1}, \\dots , s _ {\\ell}\\right) - a}, g\\right) = \\prod_ {i = 1} ^ {\\ell} e \\left(g ^ {s _ {i} - b _ {i}}, w _ {i}\\right) \\\\ \\Leftrightarrow e \\left(g ^ {f _ {\\mathbf {a}} \\left(s _ {1}, \\dots , s _ {\\ell}\\right) - a _ {x} + \\left(a _ {x} - a\\right)}, g\\right) = \\prod_ {i = 1} ^ {\\ell} e \\left(g ^ {s _ {i} - b _ {i}}, w _ {i}\\right) \\\\ \\Leftrightarrow e \\left(g ^ {\\sum_ {i = 1} ^ {\\ell} \\left(s _ {i} - b _ {i}\\right) q _ {i} \\left(s _ {1}, \\dots , s _ {\\ell}\\right) + \\left(a _ {x} - a\\right)}, g\\right) = \\prod_ {i = 1} ^ {\\ell} e \\left(g ^ {s _ {i} - b _ {i}}, w _ {i}\\right) \\\\ \\Leftrightarrow e (g, g) ^ {a _ {x} - a} = \\prod_ {i = 1} ^ {\\ell} e \\left(g, \\frac {w _ {i}}{g ^ {q _ {i} (s _ {1} , \\dots , s _ {\\ell})}}\\right) ^ {s _ {i} - b _ {i}} \\\\ = e \\left(g, \\frac {w _ {1}}{g ^ {q _ {1} (s _ {1} , \\dots , s _ {\\ell})}}\\right) ^ {s - b _ {1}} \\prod_ {i = 2} ^ {\\ell} e \\left(g, \\frac {w _ {i}}{g ^ {q _ {i} (s _ {1} , \\dots , s _ {\\ell})}}\\right) ^ {r _ {i} (s - b _ {1})} \\\\ \\Leftrightarrow e (g, g) ^ {\\frac {a _ {x} - a}{s - b _ {1}}} = e \\left(g, \\frac {w _ {1}}{g ^ {q _ {1} (s _ {1} , \\dots , s _ {\\ell})}}\\right) \\prod_ {i = 2} ^ {\\ell} e \\left(g, \\frac {w _ {i}}{g ^ {q _ {i} (s _ {1} , \\dots , s _ {\\ell})}}\\right) ^ {r _ {i}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore  <span class="math">\\mathcal{A}_1</span>  can compute  <span class="math">e(g,g)^{1 / (s - b_1)}</span>  with probability  <span class="math">1 / poly(\\lambda)</span>  which breaks Assumption 1.</p>

    <p class="text-gray-300">Gen runs is time  <span class="math">O(n)</span> , since some elements of prk share parts of the exponent and some update keys across indices are the same. E.g., indices that differ only in the msb will share  <span class="math">\\ell - 1</span>  update keys. Producing the public parameters of the zk-SNARK does not add to the asymptotic cost of Gen since the NP relation used is of logarithmic size. Com runs in time  <span class="math">O(n)</span>  since one exponentiation per vector element is required. The size of pp is  <span class="math">O(n)</span> , again due to overlap of update keys. Now, due to the use of zk-SNARKs, verification costs (verification key, proof size and verification time) are all  <span class="math">O(1)</span> . The running time of Open is  <span class="math">O(n)</span> , due to Lemma 2.1. UpdateCom runs in  <span class="math">O(1)</span>  time and UpdateProof runs in  <span class="math">O(\\log n \\log \\log n)</span>  time in the worst case (the extra log log n factor comes from the SNARK prover). We present a detailed comparison of the asymptotics of our construction with other DVCs in Table 1.</p>

    <p class="text-gray-300">Note that as in the EC distributed vector commitment construction of Catalano and Fiore [17] (that has public parameters of quadratic size), our UpdateProof algorithm allows for fixed update key for an index  <span class="math">i</span> , that can be used to update all proofs  <span class="math">\\pi_j</span> , irrespective of the index  <span class="math">j</span> . This is contrast to other constructions, such as the RSA-based construction of Catalano and Fiore [17] and the recent one by Lai and Malavolta [29], where for each combination of  <span class="math">i</span>  and  <span class="math">j</span>  a different update key is required. This would be cumbersome in our application of stateless validation: When one would wish to post a transaction, he would have to include the  <span class="math">n</span>  update keys for the sender and  <span class="math">n</span>  update keys for the recipient, so that any party  <span class="math">j</span>  can update their proofs  <span class="math">\\pi_j</span>  to reflect the decrease in the sender's balance and the increase in the recipient's balance. Since this is not possible, to update the proof  <span class="math">\\pi_j</span> , party  <span class="math">j</span>  would have to compute his "custom" update key, which leads to linear computation time for synchronizing the local proofs (as opposed to our UpdateProof's logarithmic).</p>

    <p class="text-gray-300">We now describe our version of EDRAX stateless cryptocurrency that uses balances (such as Nxt, Ethereum, Bitshares, NEM, Tezos). Recall in such systems the miners maintain a</p>

    <p class="text-gray-300">database with balances and transaction validity is checked against this database (instead of UTXO). To implement Edrax in the account-based model, we can in theory use any distributed vector commitment scheme (as given in Definition 1) as a black box. Our evaluation uses the scheme described in Section 4, which, to the best of our knowledge, is the most efficient both asymptotically and in practice.</p>

    <p class="text-gray-300">Setup. Just like Zcash [10], Edrax requires an one-time setup phase. In particular given an upper bound <span class="math">n</span> on the number of accounts that Edrax can support and the security parameter <span class="math">\\lambda</span>, algorithm <span class="math">\\mathsf{Gen}(1^{\\lambda},n)</span> is executed outputting the public parameters <span class="math">\\mathsf{pp}</span>. Recall that the public parameters contain prover key <span class="math">\\mathsf{prk}</span>, the verification key <span class="math">\\mathsf{vrk}</span> and update keys <span class="math">\\mathsf{upk}_i</span>—all these are hardcoded into the Edrax reference software client. As an optimization one can just hardcode a Merkle tree digest of these parameters (since they can be quite large) and retrieve them as required during the build—this technique is used in Zcash, for example. Finally, to mitigate the risk of trapdoor leakage during execution of <span class="math">\\mathsf{Gen}</span>, we can use a secure multiparty computation protocol as in [15].</p>

    <p class="text-gray-300">Block commitment. For each block <span class="math">b</span> at time <span class="math">t</span> Edrax miners include, along with transaction data, two constant-size values, that comprise the block commitment:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The account commitment <span class="math">\\mathsf{com}_t</span> which is a summary (hash) of the account balances in the system up to block <span class="math">b</span>, block <span class="math">b</span> included. It is computed using a DVC scheme as in Definition 1. It is initialized by running <span class="math">\\mathsf{C} \\gets \\mathsf{Com}_{\\mathsf{pp}}(0, \\ldots, 0)</span> which, in our implementation, is <span class="math">g^0 = \\mathbf{1}</span>, where <span class="math">\\mathbf{1}</span> denotes the identity element of group <span class="math">\\mathbb{G}</span>. In general the commitment <span class="math">\\mathsf{com}_t</span> will be on a vector <span class="math">\\mathbf{a}</span> that stores mappings of public keys to balances. Our implementation does that by storing mappings of the type</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i \\rightarrow [ h (\\mathsf {P K})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b a l a n c e ]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">i</span> is in <span class="math">\\{0,1,\\ldots ,n - 1\\}</span> and is assigned by miners for a specific public key <span class="math">\\mathsf{PK}</span>—this assignment is triggered via a special INIT transaction serving as "registration" for a new user and is described in the following. <span class="math">^{67}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The account counter <span class="math">cnt_{t}</span> that indicates how many INIT transactions have occurred up to block <span class="math">b</span>, block <span class="math">b</span> included—roughly speaking this indicates how many accounts are in the system. It is initialized as 0.</li>

    </ol>

    <p class="text-gray-300">Client state. Apart from a public and a secret key required in other cryptocurrencies, an Edrax client is required to store the local proof <span class="math">\\pi</span> for the value of his balance with respect to the account commitment <span class="math">\\mathsf{com}_t</span>. Since this is a zk-SNARK proof for the relation <span class="math">\\mathcal{L}_{\\mathbf{g}}</span>, the client also stores the NP witness <span class="math">w_{1},\\ldots ,w_{\\ell}</span>. In our implementation, proof <span class="math">\\pi</span> is small, around 268 bytes. Also in our implementation each proof is initialized by running the zk-SNARK prove algorithm on the witness <span class="math">(\\mathbf{1},\\dots ,\\mathbf{1})</span> where <span class="math">\\mathbf{1}</span> is the group identity element.</p>

    <p class="text-gray-300">INIT transaction. Just like in Bitcoin and Ethereum, the first time Alice ever wants to use Edrax, she creates a pair of private and public keys <span class="math">(sk_{a},pk_{a})</span> (e.g., using elliptic curve cryptography). Recall however that Edrax represents accounts as integers in <span class="math">\\{0,1,\\ldots ,n - 1\\}</span> (where, in our implementation <span class="math">n</span> is around <span class="math">2^{30}</span>) and therefore a mechanism to map Alice's public key <span class="math">pk_{a}</span> to an integer <span class="math">i\\in \\{0,\\dots ,n - 1\\}</span> must exist. To achieve that, Edrax offers an INIT transaction for Alice to map her public key <span class="math">pk_{a}</span> to the next available index <span class="math">i</span>. In particular Alice constructs and signs, using <span class="math">sk_{a}</span>, the transaction</p>

    <div class="my-4 text-center"><span class="math-block">[ \\text {I N I T}, p k _ {a} ].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Looking forward, after registering a mapping of an index <span class="math">i</span> to <span class="math">pk</span>, this transaction will implicitly define Alice's public key <span class="math">\\mathsf{PK}_a</span> as $[pk_a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{upk}_{i,l}]<span class="math"> where recall that </span>\\mathsf{upk}_{i,\\ell}<span class="math"> is the update key of the distributed vector commitment scheme. For example, for </span>\\ell = 2<span class="math"> and </span>i = 0<span class="math">, </span>\\mathsf{upk}_{0,\\ell} = g^{(s_1 - 1)(s_2 - 1)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SPEND transaction. Let us assume that Alice has public key $\\mathsf{PK}_a = [pk_a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{upk}_{i,l}]<span class="math">, corresponding secret key </span>sk_{a}<span class="math"> and current balance equal to </span>v^{\\prime}<span class="math"> Edrax units. She wants to send </span>v\\leq v^{\\prime}<span class="math"> Edrax units to Bob with public key </span>\\mathsf{PK}_b = [pk_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{upk}_{j,l}]$. Alice constructs and signs the following transaction:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\mathrm {P K} _ {a}, \\mathrm {P K} _ {b}, v, \\pi_ {i}, v ^ {\\prime} \\right],</span></div>

    <p class="text-gray-300">meaning that public key <span class="math">\\mathsf{PK}_a</span> wishes to send <span class="math">v</span> Edrax units to public key <span class="math">\\mathsf{PK}_b</span> and <span class="math">\\pi_i</span> is her local proof proving that <span class="math">\\mathsf{PK}_a</span> has enough funds <span class="math">v&#x27; \\geq v</span> (wrt the latest account commitment <span class="math">\\mathsf{com}_t</span>) to support this transaction. Note the transaction overhead is independent of the accounts number <span class="math">n</span>.</p>

    <p class="text-gray-300">New block creation. Again, assume the last block that was computed is block <span class="math">t</span> and miners compete for block <span class="math">t + 1</span>. Miners then collect new INIT and SPEND transactions of the type</p>

    <div class="my-4 text-center"><span class="math-block">[ \\text {I N I T}, p k ], \\text {s i g} \\text {a n d} [ \\mathrm {P K} _ {a}, \\mathrm {P K} _ {b}, v, \\pi_ {i}, v ^ {\\prime} ], \\text {s i g}</span></div>

    <p class="text-gray-300">respectively. For an INIT transaction to be candidate for inclusion in block <span class="math">t + 1</span>, it is enough that its signature verifies. To decide if a SPEND transaction <span class="math">[\\mathsf{PK}_a, \\mathsf{PK}_b, v, \\pi_i, v&#x27;]</span>, sig can be included in the next block the miner performs the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">\\mathsf{PK}_a</span> as $[pk_a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{upk}_{i,l}]<span class="math"> and check whether </span>sig<span class="math"> is a valid signature under </span>pk_{a}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check whether <span class="math">v \\leq v&#x27;</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Check whether $1\\leftarrow\\mathsf{Ver}_{\\mathsf{pp}}(\\mathsf{com}_{t},i,h(\\mathsf{PK}_{a})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v^{\\prime},\\pi_{i})<span class="math"> where </span>\\mathsf{com}_{t}<span class="math"> is the account commitment of the block at time </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The new block has size <span class="math">O(m)</span> where <span class="math">m</span> is the number of transactions included in the block. Finally, in the new block <span class="math">t+1</span>, miners must also include the updated account commitment <span class="math">\\mathsf{com}_{t+1}</span> and the new account counter <span class="math">\\mathsf{cnt}_{t+1}</span>. We describe how miners compute these values next.</p>

    <p class="text-gray-300">Creating the new block commitment. To update the block commitment the miners initially set <span class="math">cnt\\leftarrow\\mathsf{cnt}_{t}</span> and <span class="math">com\\leftarrow\\mathsf{com}_{t}</span>. Then they consider INIT transactions first and SPEND transactions later. In particular for every verified INIT transaction <span class="math">[{\\tt INIT},pk],sig</span> sent by Alice to be included in block <span class="math">t+1</span> the miners set <span class="math">cnt=cnt+1</span> and implicitly assign the updated index <span class="math">cnt</span> to <span class="math">pk</span>. Then they set</p>

    <p class="text-gray-300"><span class="math">com\\leftarrow\\mathsf{UpdateCom}_{\\mathsf{pp}}(com,cnt,\\delta)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\delta=h(\\mathsf{PK})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0<span class="math"> (we assume Alice begins with 0 balance) and where </span>\\mathsf{PK}=[pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cnt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\mathsf{upk}}_{cnt,l}]<span class="math">. This operation essentially registers Alice’s public key to a specific index </span>cnt<span class="math">. Then for every verified SPEND transaction </span>[\\mathsf{PK}_{a},\\mathsf{PK}_{b},v,\\pi_{i},v^{\\prime}],sig$ the miners set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">com\\leftarrow\\mathsf{UpdateCom}_{\\mathsf{pp}}(com,i,-v)\\,,</span></p>

    <p class="text-gray-300">and then again</p>

    <p class="text-gray-300"><span class="math">com\\leftarrow\\mathsf{UpdateCom}_{\\mathsf{pp}}(com,j,+v)\\,.</span></p>

    <p class="text-gray-300">Note from the public parameters <span class="math">\\mathsf{pp}</span> only <span class="math">{\\mathsf{upk}}_{i,\\ell}</span> and <span class="math">{\\mathsf{upk}}_{j,\\ell}</span> are required to perform the above, already contained in the transactions. The above operation updates the sender and receiver balances. Finally the miners set <span class="math">\\mathsf{cnt}_{t+1}\\leftarrow cnt</span> and <span class="math">\\mathsf{com}_{t+1}\\leftarrow com</span> and output the new block commitment.</p>

    <p class="text-gray-300">Proof synchronization. Let <span class="math">\\pi</span> be Alice’s local proof that corresponds to the state of the system up until block <span class="math">t</span>. Now assume some transactions are taking place and block <span class="math">t+1</span> is created. Alice’s local proof <span class="math">\\pi</span> is no longer valid and Alice must synchronize her proof to make sure it incorporates all updates <span class="math">(u_{1},\\delta_{1}),(u_{2},\\delta_{2}),\\ldots,(u_{p},\\delta_{p})</span> that were included in block <span class="math">t+1</span>. To do that she executes Algorithm 2 by running <span class="math">\\pi\\leftarrow\\mathsf{SyncProof}((u_{1},\\delta_{1}),\\ldots,(u_{p},\\delta_{p}),\\pi)</span> and outputs a new synchronized proof <span class="math">\\pi</span>. Note that since the SPEND transactions only contains element <span class="math">{\\mathsf{upk}}_{i,\\ell}</span>, Alice can fetch the rest of the update keys (e.g., <span class="math">{\\mathsf{upk}}_{u_{i},1},\\ldots,{\\mathsf{upk}}_{u_{i},\\ell-1}</span>) from an untrusted server, verify them using the hash of the reference software, and then update the local proof. Note also that Alice does not have to synchronize her proof at every new block. She just has to synchronize her proof whenever she wants to spend some Edrax units to someone else in which case she must process all the blocks since her proof was last synchronized in the same way as above. Note that the time to synchronize after <span class="math">p</span> updates is <span class="math">O(p\\log n)</span>, due to the efficiency of DeltaPol.</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Edrax Evaluation</h2>

    <p class="text-gray-300">In this section, we present the evaluation of Edrax in both UTXO and accounts model. In subsection 6.1, we compare the Sparse Merkle Tree (SMT) of Edrax with RSA groups and class groups used in <em>[14]</em>. And in subsection 6.2, we compare the performance of our distributed vector commitment scheme used in the accounts model with other DVCs.</p>

    <p class="text-gray-300">Experimental setup. We implement the sparse Merkle tree scheme in Scala using the Scrypto library <em>[8]</em>. And we implement our DVC in C++ using standard cryptographic and arithmetic precision libraries. Recall that our distributed vector commitment scheme comprises of multiplexer polynomials and zk-SNARKs. We implement the multiplexer polynomial using the GMP library <em>[5]</em> and the libff <em>[2]</em> for field arithmetic and elliptic curve pairings. We implement the zk-SNARK for the NP language <span class="math">\\mathcal{L}_{\\mathbf{g}}</span> defined in Section 4, using the zk-SNARK by Groth <em>[23]</em>, implemented in libsnark <em>[12]</em>.</p>

    <p class="text-gray-300">We perform the experiments of our schemes on an Amazon EC2 c4.4xlarge machine with 30GB of RAM and an Intel Xeon E5-2666v3 CPU with 16 2.9GHz virtual cores. We perform 10 runs and report their average for each data point of running time, unless stated otherwise.</p>

    <p class="text-gray-300">zk-SNARK for NP language <span class="math">\\mathcal{L}_{\\mathbf{g}}</span>, A zk-SNARK consisting of <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> instantiated by an elliptic curve <span class="math">E</span> defined over a field <span class="math">\\mathbb{F}_{q}</span> proves satisfiability of NP statements over <span class="math">\\mathbb{F}_{r}</span>, where <span class="math">\\mathbb{F}_{r}=\\#E(\\mathbb{F}_{q})</span>. But recall that membership verification <span class="math">\\mathcal{L}_{\\mathbf{g}}</span> involves pairing computations over <span class="math">\\mathbb{F}_{q}</span> and therefore our SNARK logic should encode operations over field <span class="math">\\mathbb{F}_{q}</span>, rather than <span class="math">\\mathbb{F}_{r}</span>. As noted in prior works <em>[11]</em>, it is impossible to find a curve where <span class="math">q=r</span>. We adopt the MNT curves approach from <em>[11]</em> and thus we instantiate the polynomial evaluation scheme with a curve <span class="math">E_{1}</span> over <span class="math">\\mathbb{F}_{q_{1}}</span> and the SNARK scheme with a curve <span class="math">E_{2}</span> over <span class="math">\\mathbb{F}_{q_{2}}</span> such that <span class="math">\\#E_{2}(\\mathbb{F}_{q_{2}})=\\mathbb{F}_{q_{1}}</span>. In particular, in our implementation, the polynomial evaluation scheme produces witnesses that are elements over the MNT6 curve and our zk-SNARK scheme is instantiated over MNT4 curve.</p>

    <p class="text-gray-300">Arithmetic circuit for verifying membership in <span class="math">\\mathcal{L}_{\\mathbf{g}}</span>, It can been seen from Section 4 that verifying membership in <span class="math">\\mathcal{L}_{\\mathbf{g}}</span> consists of performing pairing operations (whose primary components are the Miller algorithm and the final exponentiation), exponentiating group elements to values <span class="math">i_{1},\\ldots,i_{k}</span>, checking to see that <span class="math">i_{1},\\ldots,i_{k}</span> are bits and in particular that they constitute the binary representation of value <span class="math">i</span>. . The en</p>

    <p class="text-gray-300">Algorithm 2 Algorithm for synchronizing the proof so that updates <span class="math">(u_{1},\\delta_{1}),\\ldots,(u_{t},\\delta_{t})</span> are included. 1:procedure <span class="math">\\pi\\leftarrow\\mathsf{SyncProof}((u_{1},\\delta_{1}),\\ldots,(u_{p},\\delta_{p}),\\pi)</span> 2: for <span class="math">i=1,\\ldots,p</span> do 3: <span class="math">\\pi\\leftarrow\\mathsf{UpdateProof}_{\\mathsf{pp}}(u_{i},\\delta_{i},\\pi)</span>; 4: return <span class="math">\\pi</span>;</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Table 2: Sparse merkle trees vs. groups of unknown order. (Time taken for 1000 runs of the same operation)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">primitive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">trusted setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof (bytes)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verify (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">update local proof (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">471</td>

            <td class="px-3 py-2 border-b border-gray-700">707</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">class groups</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">6095</td>

            <td class="px-3 py-2 border-b border-gray-700">9142</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SMT (W = 40)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">371</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Mining and validation per block of 1000 transactions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Accumulator</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EDRAX (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">class groups (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mining</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">21850</td>

            <td class="px-3 py-2 border-b border-gray-700">3590387</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Validation</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">4646</td>

            <td class="px-3 py-2 border-b border-gray-700">4925</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">tire verification consists of 787K multiplication gates and the peak memory usage is 2,214 MB even for  <span class="math">\\ell = 30</span> .</p>

    <p class="text-gray-300">A sparse Merkle tree (SMT) can be considered as a form of cryptographic accumulator. In this subsection, we compare our construction with other accumulators proposed by the concurrent work of Boneh et al. [14] which is based on groups of unknown order (RSA and class groups). We compare the performance of bare-bone primitives that make up the accumulators (micro-benchmarks) and the performance of the accumulators in the blockchain setting with available optimizations enabled (macro-benchmarks).</p>

    <p class="text-gray-300">In all our experiments, we set the height of the SMT to  <span class="math">W = 40</span> , as this value is sufficient to support the total number of transaction outputs ever generated in Bitcoin—right now this number is about 765 million (computed using the BlockSci tool [6]). We also instantiate the RSA accumulator and the class group accumulator at accepted 2048-bit security level across all experiments. Also in our experiments, we assume a block size of 1000 transactions, each with single input and single output coin.</p>

    <p class="text-gray-300">Microbenchmarks. In Table 2, we micro-benchmark the performance of SMT with other primitives. The accumulators based on RSA and class groups are space efficient, as a membership proof is just one group element. Thus they add minimal storage overhead when compared to sparse Merkle trees. However, it is computationally cheaper to verify the membership of an element in SMT over other primitives, as the overhead of hashing using a lightweight SHA-2 hash function is lower than the cost exponentiating in RSA or class group. Similarly it is cheaper to update the local membership proofs in SMT than other primitives. Note that in our experiments, we consider an update as either an addition of element to the accumulated set (requires one exponentiation) or deletion of an element from the set (requires two exponentiations). Moreover, SMTs do not require trusted setup, unlike RSA-based accumulators. Even though class groups do not require a trusted setup, it is simply too expensive to perform group operations. Due to the lack of a standard library to perform</p>

    <p class="text-gray-300">Table 4: One-time setup in our DVC for various values of  <span class="math">\\ell</span> . The notation * means estimation due to long running times. Time taken can be reduced by a factor of  <span class="math">10 \\times</span>  using Lim-Lee exponentiation [7]. Alternative EC representations can reduce the size of the keys [23].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyGen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">memory usage</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prk size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vrk & upk size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">5,519s</td>

            <td class="px-3 py-2 border-b border-gray-700">20GB</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3GB</td>

            <td class="px-3 py-2 border-b border-gray-700">11.8KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">11,122s</td>

            <td class="px-3 py-2 border-b border-gray-700">30GB</td>

            <td class="px-3 py-2 border-b border-gray-700">10.5GB</td>

            <td class="px-3 py-2 border-b border-gray-700">12.3KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">45,556s</td>

            <td class="px-3 py-2 border-b border-gray-700">30GB</td>

            <td class="px-3 py-2 border-b border-gray-700">41.4GB</td>

            <td class="px-3 py-2 border-b border-gray-700">13.2KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">96,965s</td>

            <td class="px-3 py-2 border-b border-gray-700">30GB</td>

            <td class="px-3 py-2 border-b border-gray-700">83.6GB</td>

            <td class="px-3 py-2 border-b border-gray-700">14.2KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">230,453s*</td>

            <td class="px-3 py-2 border-b border-gray-700">40GB</td>

            <td class="px-3 py-2 border-b border-gray-700">165GB</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">operations using class groups, we use the VDF implementation from Chia Network to estimate the overhead of class group [3]. Thus the numbers reported in Table 2 is a conservative evaluation (lower bound) of the overhead of classgroup operations.</p>

    <p class="text-gray-300">Macrobenchmarks. In Table 3, we macro-benchmark the performance of EDRAX with the accumulator construction proposed by Boneh et al. [14] in the blockchain setting with optimizations such as batching and aggregation. We extend the implementation of the rust accumulators library [1] to measure the performance of RSA accumulators [14].</p>

    <p class="text-gray-300">Note that the mining costs are substantially higher (compared to validation) in groups of unknown order as every miner must: (i) verify every transaction in the block first (requires expensive group exponentiations); (ii) aggregate the proofs using the batching techniques (requires multiplication of large primes and computing Bezouts coefficients for every TX); (iii) add new coins to the accumulated set; (iv) generate membership proofs for element added to the set by factorizing the aggregate membership proof.</p>

    <p class="text-gray-300">In this section, we evaluate the performance of our new distributed vector commitment scheme and justify its practicality over other DVC schemes listed in Table 1. Due to the impracticality of class group objects, we exclude [29] from our comparison. Thus we limit the comparison only with the lattice-based vector commitment from [38] and the RSA-based vector commitment from Catalano et al. [17].</p>

    <p class="text-gray-300">One-time setup. The costliest part of our vector commitment scheme is the one-time setup to generate the prover, update, and verification keys. Such an expensive setup is not present in the lattice-based scheme (whose setup involves just a constant-time sampling of two lattice-based hash functions) but is required for the RSA-based DVC [17] whose linear-time setup involves generating primes for each vector index. Moreover using Lim-Lee [7] exponentiation techniques, setup time can be reduce by a factor of  <span class="math">10 \\times</span> .</p>

    <p class="text-gray-300">Results for our scheme are provided in Table 4. As shown in the table, it takes 5,519s to generate the keys for a vector of</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Proof size and verification times.</p>

    <p class="text-gray-300">32 million elements, which is close to the current number of accounts in Ethereum [18]. Most of the time in key generation is spent on computing exponentiations in the base group, which can be easily parallelized.</p>

    <p class="text-gray-300">Moreover, our implementation stores the prover key on disk, so it can scale to a larger  <span class="math">\\ell</span>  as long as the disk size is larger than the proving key size. The overhead for disk I/O is already included in the key generation time reported in Table 4. We remark that EDRAX nodes do not require the multilinear polynomial evaluation scheme's prover key—just the update key and verification key are sufficient to function in the distributed setting. Both the verification key and the update key for one element are less than  <span class="math">15\\mathrm{KB}</span>  for  <span class="math">\\ell \\leq 30</span>  and grow logarithmically with the elements in the vector.</p>

    <p class="text-gray-300">Proof size and verification time. Figure 3 shows the comparison of proof size and the verification time. Our scheme is asymptotically better than the lattice scheme and comparable to the RSA scheme. In practice, the proof size is less than  <span class="math">0.15\\mathrm{KB}</span>  for  <span class="math">\\ell \\leq 32</span>  in our scheme, while it is  <span class="math">62 - 78\\mathrm{KB}</span>  in the lattice scheme and it is  <span class="math">0.256\\mathrm{KB}</span>  in the RSA scheme. This is because the SNARK proof is three group elements whereas the proof of the RSA scheme is one group element.</p>

    <p class="text-gray-300">For verification time, our scheme outperforms lattice-based schemes both in asymptotics and practice (7ms vs 210ms). However, despite the comparable asymptotics with the RSA-based scheme, in practice RSA-based schemes fare better than our approach. This is because our verifier performs expensive pairings to verify the proof, whereas the RSA based scheme performs cheaper modular exponentiations to verify the proof.</p>

    <p class="text-gray-300">Digest update and proof synchronization. Figure 4 shows the time to update the digest and to synchronize a local proof. Our scheme requires  <span class="math">35\\mu s</span>  to update the digest and  <span class="math">89\\mu s</span>  (amortized) to synchronize the proof for one element. Recall that our proof update algorithm is logarithmic in the vector size. In the lattice based schemes, both updating the digest and the proof takes around  <span class="math">790~\\mathrm{ms}</span>  for  <span class="math">\\ell = 25</span>  and grows logarithmically with  <span class="math">\\ell</span> . On the contrary, proof update in RSA-based VC is very expensive: It features a linear-time algorithm, which involves computing the product of primes associated with each position of the vector and performing modular exponentiations. In reality the RSA-based VC requires around 14.5 hours to update the proof of a single position in the vector of size  <span class="math">2^{30}</span>  (which is the number of accounts in eth now).</p>

    <p class="text-gray-300">Main finding. To summarize, our DVC is the pragmatic</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Time for digest update and proof synchronization. RSA scheme [17] is not shown: it takes  <span class="math">14.5\\mathrm{hr}</span>  to synchronize.</p>

    <p class="text-gray-300">choice, as it outperforms other DVCs both asymptotically and practically in one of the most crucial operations in the stateless blockchain setting, the proof update. Our DVC also has comparable asymptotic proof size and verification time.</p>

    <p class="text-gray-300">The security of EDRAX is based on the security of the underlying sparse Merkle tree (for UTXO) and the underlying vector commitment (for accounts setting). In particular we note that EDRAX satisfies the security definition presented in Section 2 of [20] (which appeared in EUROCRYPT [21]): The only difference between EDRAX and the protocol proved secure in [20] is the way the validation predicate  <span class="math">V(X_{C})</span>  (page 13) is implemented: Instead of maintaining a large state variable for accounts/UTXO to implement  <span class="math">V(X_{C})</span> , EDRAX saves space by maintaining just a small digest of accounts/UTXO and validates  <span class="math">X_{C}</span>  using client provided proofs. Clearly, for the same  <span class="math">X_{C}</span> , both implementations of  <span class="math">V(X_{C})</span>  output the same bit with overwhelming probability, due to DVC/SMT soundness. Therefore, EDRAX's real-world execution almost never deviates from the protocol proved secure in [20] and as such it is secure based on [20].</p>

    <p class="text-gray-300">In this paper we presented EDRAX, an architecture (and two different implementations) for stateless transaction validation in cryptocurrencies. Our concrete implementations are first steps—in future more practical authenticated structures or vector commitments can be used as replacement, leading to even better performance. Here we outline future research.</p>

    <p class="text-gray-300">Authenticated balanced trees instead of sparse Merkle trees. The fixed structure of sparse Merkle trees allows flexible updates even without the need for storing the entire tree locally. However, they have proofs,  <span class="math">O(W)</span> , irrespective of the current size of the UTXO. We believe one can implement the EDRAX UTXO using an authenticated balanced tree that maintains a proof size  <span class="math">O(\\log n)</span> , where  <span class="math">n</span>  is the current size of the UTXO. Prior works have studied authenticated skip lists and authenticated trees, but it is not clear how these data structures can be updated with just the most recent proof [31, 35]. UTREEXO [19], that appeared after the first version of EDRAX, solves this problem by using a series of trees that</p>

    <p class="text-gray-300">have a number of leaves that are powers of two, depending on the current size of UTXO.</p>

    <p class="text-gray-300">Proof-serving nodes. Unlike existing cryptocurrencies, Edrax clients are required to synchronize their proof before posting a new transaction. This changes the user experience for clients and introduces a modest cost. To alleviate this cost, we can extend the Edrax architecture to contain untrusted proof-serving nodes (e.g., an Amazon machine) that do not participate in the blockchain consensus, which are responsible for storing and serving up-to-date proofs. Note that there is no requirement that they serve correct proofs: If the provided proof is correct (which can be checked by using blockchain digest), then this proof can be readily used, otherwise the client can always use the “default" setting and synchronize his proof by using the algorithms presented before.</p>

    <p class="text-gray-300">Supporting smart contracts in the stateless setting. In the smart contract setting, the flow of money will depend of the execution of some contract code on the current contract state. Hence for Alice to post a contract-triggering transaction she must provide a proof of correctness of the current contract state for Edrax nodes to execute on. Two challenges are: (i) who is storing the contract state as any client can post transactions to trigger a contract execution; (ii) how to avoid including the contract state as part of the transaction (the contract state might be too large). We leave this a future work.</p>

    <h2 id="sec-27" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] “Accumulators with class groups,” https://github.com/cambrian/accumulator.</li>

      <li>[2] “C++ library for finite fields and elliptic curves,” https://github.com/scipr-lab/libff.</li>

      <li>[3] “Chia vdf challange,” https://github.com/Chia-Network/oldvdf-competition.</li>

      <li>[4] “Ethereum white paper,” https://github.com/ethereum/wiki/wiki/white-paper.”</li>

      <li>[5] “The GNU multiple precision arithmetic library,” https://gmplib.org/.</li>

      <li>[6] “https://github.com/citp/blocksci.”</li>

      <li>[7] “Libra zk reference implementation,” https://github.com/sunblaze-ucb/Libra/blob/Libra/implementation/src/VPD/inputvpd.cpp.</li>

      <li>[8] “Scrypto,” https://github.com/input-output-hk/scrypto.</li>

      <li>[9] “Utxo uh-oh…," http://gavinandresen.ninja/utxo-uhoh.”</li>

      <li>[10] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza, “Zerocash: Decentralized anonymous payments from bitcoin,” in <em>2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014</em>, 2014, pp. 459–474.</li>

      <li>[11] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Scalable zero knowledge via cycles of elliptic curves,” in <em>Annual Cryptology Conference</em>. Springer, 2014, pp. 276–294.</li>

      <li>[12] ——, “Succinct non-interactive zero knowledge for a von neumann architecture,” in <em>Proceedings of the 23rd USENIX Conference on Security Symposium</em>, ser. SEC’14. USA: USENIX Association, 2014, p. 781–796.</li>

      <li>[13] D. Boneh and X. Boyen, “Short signatures without random oracles,” in <em>International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, 2004, pp. 56–73.</li>

      <li>[14] D. Boneh, B. Bünz, and B. Fisch, “Batching techniques for accumulators with applications to iops and stateless blockchains,” in <em>CRYPTO</em>, 2019.</li>

      <li>[15] S. Bowe, A. Gabizon, and M. Green, “A multi-party protocol for constructing the public parameters of the pinocchio zk-snark,” in <em>International Conference on Financial Cryptography and Data Security</em>. Springer, 2018.</li>

      <li>[16] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, and L. Nizzardo, “Vector commitment techniques and applications to verifiable decentralized storage,” <em>IACR Cryptol. ePrint Arch.</em>, vol. 2020, p. 149, 2020. [Online]. Available: https://eprint.iacr.org/2020/149</li>

      <li>[17] D. Catalano and D. Fiore, “Vector commitments and their applications,” in <em>Public-Key Cryptography - PKC 2013 - 16th International Conference on Practice and Theory in Public-Key Cryptography, Nara, Japan, February 26 - March 1, 2013. Proceedings</em>, 2013, pp. 55–72.</li>

      <li>[18] E. U. A. G. Chart, “https://etherscan.io/chart/address.”</li>

      <li>[19] T. Dryja, “Utreexo: A dynamic hash-based accumulator optimized for the bitcoin utxo set,” Cryptology ePrint Archive, Report 2019/611, 2019.</li>

      <li>[20] J. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol: Analysis and applications,” Cryptology ePrint Archive, Report 2014/765, 2014, https://eprint.iacr.org/2014/765.</li>

      <li>[21] J. A. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol: Analysis and applications,” in *Advances in Cryptology - EUROCRYPT 2015 - 34th</li>

    </ul>

    <p class="text-gray-300">Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II, ser. Lecture Notes in Computer Science, E. Oswald and M. Fischlin, Eds., vol. 9057. Springer, 2015, pp. 281–310.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang, “Pointproofs: Aggregating proofs for multiple vector commitments,” IACR Cryptol. ePrint Arch., vol. 2020, p. 419, 2020. [Online]. Available: https://eprint.iacr.org/2020/419</li>

      <li>[23] J. Groth, “On the size of pairing-based non-interactive arguments,” in Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, 2016, pp. 305–326.</li>

      <li>[24] https://etherscan.io/chart/address.</li>

      <li>[25] https://ethresear.ch/t/the-stateless-client concept/172.</li>

      <li>[26] https://medium.com/cybermiles/diving-into-ethereums-world-state c893102030ed.</li>

      <li>[27] https://statoshi.info/dashboard/db/unspent-transaction-output set.</li>

      <li>[28] J. Krupp, D. Schröder, M. Simkin, D. Fiore, G. Ateniese, and S. Nürnberger, “Nearly optimal verifiable data streaming,” in Public-Key Cryptography - PKC 2016 - 19th IACR International Conference on Practice and Theory in Public-Key Cryptography, Taipei, Taiwan, 2016, pp. 417–445.</li>

      <li>[29] R. W. F. Lai and G. Malavolta, “Subvector commitments with application to succinct arguments,” in Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part I, 2019, pp. 530–560.</li>

      <li>[30] R. C. Merkle, “A certified digital signature,” in Advances in Cryptology - CRYPTO ’89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, 1989, pp. 218–238.</li>

      <li>[31] A. Miller, M. Hicks, J. Katz, and E. Shi, “Authenticated data structures, generically,” in The 41st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’14, San Diego, CA, USA, January 20-21, 2014.</li>

      <li>[32] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” http://bitcoin.org/bitcoin.pdf.”</li>

      <li>[33] C. Papamanthou, E. Shi, and R. Tamassia, “Signatures of correct computation,” in Theory of Cryptography. Springer, 2013, pp. 222–242.</li>

      <li>[34] C. Papamanthou, E. Shi, R. Tamassia, and K. Yi, “Streaming authenticated data structures,” in Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, 2013, pp. 353–370.</li>

      <li>[35] C. Papamanthou and R. Tamassia, “Time and space efficient algorithms for two-party authenticated data structures,” in Information and Communications Security, 9th International Conference, ICICS 2007, Zhengzhou, China, December 12-15, 2007, Proceedings, 2007, pp. 1–15.</li>

      <li>[36] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio: Nearly practical verifiable computation,” in 2013 IEEE Symposium on Security and Privacy, SP 2013, Berkeley, CA, USA, May 19-22, 2013, 2013, pp. 238–252.</li>

      <li>[37] S. Ponnapalli, A. Shah, A. Tai, S. Banerjee, V. Chidambaram, D. Malkhi, and M. Wei, “Scalable and efficient data authentication for decentralized systems,” 2019.</li>

      <li>[38] Y. Qian, Y. Zhang, X. Chen, and C. Papamanthou, “Streaming authenticated data structures: Abstraction and implementation,” in Proceedings of the 6th edition of the ACM Workshop on Cloud Computing Security, CCSW ’14, Scottsdale, Arizona, USA, November 7, 2014, 2014, pp. 129–139.</li>

      <li>[39] A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich, “Aggregatable subvector commitments for stateless cryptocurrencies,” Cryptology ePrint Archive, Report 2020/527, 2020, https://eprint.iacr.org/2020/527.</li>

      <li>[40] . h. e.-s.-a.-n.-s. Vitalik Buterin. Transaction spam attack: Next steps.</li>

      <li>[41] J. Zahnentferner, “Chimeric ledgers: Translating and unifying utxo-based and account-based cryptocurrencies,” Cryptology ePrint Archive, Report 2018/262, 2018, https://eprint.iacr.org/2018/262.</li>

      <li>[42] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou, “vRAM: Faster verifiable ram with program-independent preprocessing,” in 2018 IEEE Symposium on Security and Privacy (SP), vol. 00, pp. 203–220. [Online]. Available: doi.ieeecomputersociety.org/10.1109/SP.2018.00013</li>

    </ul>

    <p class="text-gray-300">[43] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou, “vsql: Verifying arbitrary sql queries over dynamic outsourced databases,” in 2017 IEEE Symposium on Security and Privacy (SP), 2017, pp. 863–880.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Appendix</h2>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">7.1 Correctness of DeltaPol</h3>

    <p class="text-gray-300">The proof of correctness of our new vector commitment scheme lies upon proving the correctness of DeltaPol used to update the witness for an index <span class="math">i</span>, when another update <span class="math">(u,\\delta)</span> takes place on an index <span class="math">u</span>. To see why DeltaPol correctly performs this task, note that before the update <span class="math">(u,\\delta)</span>, witness <span class="math">w_{i}</span> consists of <span class="math">\\{g^{q_{i}(\\mathbf{x})},\\ldots,g^{q_{i}(\\mathbf{x})}\\}</span> where polynomials <span class="math">q_{i}(\\mathbf{x})</span> satisfy <span class="math">f_{\\mathbf{a}}(x_{1},\\ldots,x_{\\ell})-a_{i}=\\sum_{k=1}^{\\ell}(x_{k}-i_{k})\\cdot q_{k}(\\mathbf{x})</span>. Due to the update <span class="math">(u,\\delta)</span>, the digest <span class="math">f_{\\mathbf{a}}(x_{1},\\ldots,x_{\\ell})</span> increases by <span class="math">\\delta\\cdot\\prod_{k=1}^{\\ell}\\operatorname{select}_{u_{k}}(x_{k})</span> and therefore polynomials <span class="math">q_{i}(\\mathbf{x})</span> should be adjusted to <span class="math">q_{i}(\\mathbf{x})+\\Delta_{i}(\\mathbf{x})</span> to accommodate this change, as described in the following lemma:</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 7.1.</h6>

    <p class="text-gray-300">Algorithm <span class="math">\\operatorname{DeltaPol}(u,\\delta,i,\\ell)</span> correctly computes polynomials <span class="math">\\Delta_{\\ell}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> such that</p>

    <p class="text-gray-300"><span class="math">\\delta\\cdot\\prod_{k=1}^{\\ell}\\operatorname{select}_{u_{k}}(x_{k})=\\sum_{k=1}^{\\ell}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,,\\text{ if }u\\neq i</span> (4)</p>

    <p class="text-gray-300">or</p>

    <p class="text-gray-300"><span class="math">\\delta\\cdot\\prod_{k=1}^{\\ell}\\operatorname{select}_{u_{k}}(x_{k})-\\delta=\\sum_{k=1}^{\\ell}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,,\\text{ if }u=i\\,,</span> (5)</p>

    <p class="text-gray-300">where <span class="math">i_{k}</span> is the <span class="math">k</span>-th bit of <span class="math">i</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By induction on <span class="math">\\ell</span>. For the base case, note that Algorithm <span class="math">\\operatorname{DeltaPol}(u,\\delta,i,1)</span> outputs <span class="math">\\Delta_{1}(\\mathbf{x})=-\\delta</span> in case <span class="math">u</span> is 0 and <span class="math">i</span> is 1 or both <span class="math">u</span> and <span class="math">i</span> are 0 and <span class="math">\\Delta_{1}(\\mathbf{x})=\\delta</span> in case <span class="math">u</span> is 1 and <span class="math">i</span> is 0 or both <span class="math">u</span> and <span class="math">i</span> are 1. Indeed <span class="math">\\Delta_{1}(\\mathbf{x})</span> does satisfy the relations above as we prove in the following by considering all four possible cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u=0</span> and <span class="math">i=1</span>. In this case Relation 4 is indeed satisfied as <span class="math">\\delta\\cdot(1-x_{1})=(x_{1}-1)\\cdot(-\\delta)</span>.</li>

      <li><span class="math">u=0</span> and <span class="math">i=0</span>. In this case Relation 5 is indeed satisfied as <span class="math">\\delta\\cdot(1-x_{1})-\\delta=x_{1}\\cdot(-\\delta)</span>.</li>

      <li><span class="math">u=1</span> and <span class="math">i=0</span>. In this case Relation 4 is indeed satisfied as <span class="math">\\delta\\cdot x_{1}=(x_{1}-0)\\cdot\\delta</span>.</li>

      <li><span class="math">u=1</span> and <span class="math">i=1</span>. In this case Relation 5 is indeed satisfied as <span class="math">\\delta\\cdot x_{1}-\\delta=(x_{1}-1)\\cdot\\delta</span>.</li>

    </ol>

    <p class="text-gray-300">For the inductive hypothesis, assume <span class="math">\\operatorname{DeltaPol}(u,\\delta,i,\\ell-1)</span> outputs polynomials <span class="math">\\Delta_{\\ell-1}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> that satisfy either Relation 4 or Relation 5 (depending whether <span class="math">u=i</span> or not). We prove the same claim for <span class="math">\\operatorname{DeltaPol}(u,\\delta,i,\\ell)</span> by considering the following cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If msb of <span class="math">u</span> is 0 and msb of <span class="math">i</span> is 1, then the algorithm returns <span class="math">\\Delta_{\\ell}(\\mathbf{x})=-\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})</span> and <span class="math">\\Delta_{i}(\\mathbf{x})=0</span> for all <span class="math">i&lt;\\ell</span>. Since <span class="math">u\\neq i</span>, these polynomials must satisfy Relation 4 which can be rewritten as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\delta\\cdot(1-x_{\\ell})\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})=(x_{\\ell}-1)\\cdot\\Delta_{\\ell}(\\mathbf{x})+\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,.</span></p>

    <p class="text-gray-300">It is easy to see that this is indeed the case by simple substitution.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If msb of <span class="math">u</span> is 0 and msb of <span class="math">i</span> is 0, then the algorithm returns <span class="math">\\Delta_{\\ell}(\\mathbf{x})=-\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})</span> along with <span class="math">\\Delta_{\\ell-1}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> as output by <span class="math">\\operatorname{DeltaPol}(u\\bmod 2^{\\ell},\\delta,i\\bmod 2^{\\ell},\\ell-1)</span>. We distinguish two subcases.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u\\neq i</span>. In this case polynomials <span class="math">\\Delta_{\\ell}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> must satisfy Relation 4 which can be rewritten as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\delta\\cdot(1-x_{\\ell})\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})=x_{\\ell}\\cdot\\Delta_{\\ell}(\\mathbf{x})+\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,.</span></p>

    <p class="text-gray-300">By substituting the output polynomials and by using our inductive hypothesis that states <span class="math">\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})=\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})</span> it is easy to see that this is indeed the case.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u=i</span>. In this case polynomials <span class="math">\\Delta_{\\ell}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> must satisfy Relation 5 which can be rewritten as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\delta\\cdot(1-x_{\\ell})\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})-\\delta=x_{\\ell}\\cdot\\Delta_{\\ell}(\\mathbf{x})+\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,.</span></p>

    <p class="text-gray-300">By substituting the output polynomials and by using our inductive hypothesis that states <span class="math">\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})-\\delta=\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})</span> it is easy to see that this is indeed the case.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If msb of <span class="math">u</span> is 1 and msb of <span class="math">i</span> is 0, then algorithm returns <span class="math">\\Delta_{\\ell}(\\mathbf{x})=\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})</span> and <span class="math">\\Delta_{i}(\\mathbf{x})=0</span> for all <span class="math">i&lt;\\ell</span>. Since <span class="math">u\\neq i</span>, these polynomials must satisfy Relation 4 which can be written as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\delta\\cdot x_{\\ell}\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})=x_{\\ell}\\cdot\\Delta_{\\ell}(\\mathbf{x})+\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,.</span></p>

    <p class="text-gray-300">It is easy to see that this is indeed the case by simple substitution.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If msb of <span class="math">u</span> is 1 and msb of <span class="math">i</span> is 1, then the algorithm returns <span class="math">\\Delta_{\\ell}(\\mathbf{x})=\\delta\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})</span> along with <span class="math">\\Delta_{\\ell-1}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> as output by <span class="math">\\operatorname{DeltaPol}(u\\bmod 2^{\\ell},\\delta,i\\bmod 2^{\\ell},\\ell-1)</span>. We distinguish two subcases.</li>

      <li><span class="math">u\\neq i</span>. In this case polynomials <span class="math">\\Delta_{\\ell}(\\mathbf{x}),\\ldots,\\Delta_{1}(\\mathbf{x})</span> must satisfy Relation 4 which can be rewritten as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\delta\\cdot x_{\\ell}\\cdot\\prod_{k=1}^{\\ell-1}\\operatorname{select}_{u_{k}}(x_{k})=x_{\\ell}\\cdot\\Delta_{\\ell}(\\mathbf{x})+\\sum_{k=1}^{\\ell-1}(x_{k}-i_{k})\\cdot\\Delta_{k}(\\mathbf{x})\\,.</span></p>

    <p class="text-gray-300">By substituting the output polynomials and by using our inductive hypothesis that states  <span class="math">\\delta \\cdot \\prod_{k=1}^{\\ell-1} \\mathrm{select}_{u_k}(x_k) = \\sum_{k=1}^{\\ell-1} (x_k - i_k) \\cdot \\Delta_k(\\mathbf{x})</span>  it is easy to see that this is indeed the case.</p>

    <p class="text-gray-300">(b)  <span class="math">u = i</span> . In this case polynomials  <span class="math">\\Delta_{\\ell}(\\mathbf{x}), \\ldots, \\Delta_1(\\mathbf{x})</span>  must satisfy Relation 5 which can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block">\\delta \\cdot (1 - x _ {\\ell}) \\cdot \\prod_ {k = 1} ^ {\\ell - 1} \\operatorname {s e l e c t} _ {u _ {k}} (x _ {k}) - \\delta = x _ {\\ell} \\cdot \\Delta_ {\\ell} (\\mathbf {x}) + \\sum_ {k = 1} ^ {\\ell - 1} (x _ {k} - i _ {k}) \\cdot \\Delta_ {k} (\\mathbf {x}).</span></div>

    <p class="text-gray-300">By substituting the output polynomials and by using our inductive hypothesis that states  <span class="math">\\delta \\cdot \\prod_{k=1}^{\\ell-1} \\mathrm{select}_{u_k}(x_k) - \\delta = \\sum_{k=1}^{\\ell-1} (x_k - i_k) \\cdot \\Delta_k(\\mathbf{x})</span>  it is easy to see that this is indeed the case.</p>

    <p class="text-gray-300">Assumption 1 ([13]  <span class="math">q</span> -Strong Bilinear Diffie-Hellman ( <span class="math">q</span> -SBDH)). For any PPT adversary  <span class="math">\\mathcal{A}</span> , the following probability is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (p, \\mathbb {G}, \\mathbb {G} _ {T}, e, g) \\leftarrow \\operatorname {G e n} (1 ^ {\\lambda}); \\\\ s \\stackrel {{R}} {{\\leftarrow}} \\mathbb {Z} _ {p} ^ {*}, \\\\ \\sigma = ((p, \\mathbb {G}, \\mathbb {G} _ {T}, e, g), g ^ {s}, \\ldots , g ^ {s ^ {q}}): \\\\ (x, e (g, g) ^ {\\frac {1}{2 + q}}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\sigma) \\end{array} \\right].</span></div>

    <p class="text-gray-300">Definition 3 (Knowledge-soundness of zk-SNARK). We say that the a zk-SNARK  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  has knowledge-soundness if for any PPT  <span class="math">\\mathcal{A}</span>  and any NP relation  <span class="math">\\mathcal{R}</span> , there is a polynomial time extractor  <span class="math">\\mathcal{E}</span>  such that the probability</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; (P V, V K) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathcal {R}); \\\\ 1 \\leftarrow \\mathcal {V} (V K, \\pi , \\mathbf {x}) &amp;amp; (\\mathbf {x}, \\pi) \\leftarrow \\mathcal {A} (P K, V K); \\\\ &amp;amp; \\mathbf {w} \\leftarrow \\mathcal {E} (P K, V K); \\\\ &amp;amp; \\mathcal {R} (\\mathbf {x}, \\mathbf {w}) \\neq 1 \\end{array} \\right]</span></div>

    <p class="text-gray-300">is negligible.</p>

    <p class="text-gray-300">Definition 4 (Correctness of distributed vector commitment). A distributed vector commitment is correct, if for all  <span class="math">\\lambda \\in \\mathbb{N}</span>  and  <span class="math">n = \\mathrm{poly}(\\lambda)</span> , for all public parameters  <span class="math">\\mathsf{pp} \\gets \\mathsf{Gen}(1^{\\lambda}, n)</span> , for all vectors  <span class="math">\\mathbf{a} = [a_0, \\ldots, a_{n-1}]</span> , if  <span class="math">\\mathsf{C}</span>  is computed by  <span class="math">\\mathsf{Com}_{\\mathsf{pp}}(\\mathbf{a})</span>  and  <span class="math">\\pi_i</span> , for all  <span class="math">i</span> , is a proof generated  <span class="math">\\mathsf{Open}_{\\mathsf{pp}}(i, \\mathbf{a}, a_i)</span> , then for a polynomial number of updates  <span class="math">(u, \\delta)</span>  if  <span class="math">\\mathsf{C}</span>  and  <span class="math">\\pi_i</span> , for all  <span class="math">i</span> , are produced by calls to  <span class="math">\\mathsf{UpdateCom}_{\\mathsf{pp}}(u, \\delta, \\mathsf{C})</span>  and  <span class="math">\\mathsf{UpdateProof}_{\\mathsf{pp}}(u, \\delta, \\pi_i)</span>  respectively then for all  <span class="math">i</span>  it is  <span class="math">\\Pr[1 \\leftarrow \\mathsf{Ver}_{\\mathsf{pp}}(\\mathsf{C}, i, a_i, \\pi_i)] = 1</span> , where  <span class="math">a_i</span>  is the value at index  <span class="math">i</span>  after all updates took place.</p>

    <p class="text-gray-300">|  Algorithm 3 Algorithm for updating most recent proof when a new output [PK, v] is generated.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2:</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse π(cnt) as d0, ..., dW where d0 is cnt</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[pk, v'];</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3:</td>

            <td class="px-3 py-2 border-b border-gray-700">Initialize π(cnt + 1) as δ0, ..., δW where δ0 is (cnt + 1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[PK, v] and δi = null for i > 0;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4:</td>

            <td class="px-3 py-2 border-b border-gray-700">Let the binary representations of cnt and cnt + 1 be B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bk, ..., b0 and B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">βk, ..., b0 respectively, where B is their common prefix;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5:</td>

            <td class="px-3 py-2 border-b border-gray-700">Set q =</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">- 1;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6:</td>

            <td class="px-3 py-2 border-b border-gray-700">Copy the last q hashes from π(cnt) to the last q positions of π(cnt + 1);</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7:</td>

            <td class="px-3 py-2 border-b border-gray-700">Let π contain the first W - q hashes of π(cnt);</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8:</td>

            <td class="px-3 py-2 border-b border-gray-700">Run d ← verifyMerkle(cnt, [pk, v], π);</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9:</td>

            <td class="px-3 py-2 border-b border-gray-700">Set δW-q+1 = d and δi = null for all 0 < i < W - q + 1;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10:</td>

            <td class="px-3 py-2 border-b border-gray-700">return π(cnt + 1);</td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Edrax: A Cryptocurrency with Stateless Transaction Validatio... (2018/968)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/968
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
