---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/499';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof-Carrying Data from Accumulation Schemes';
const AUTHORS_HTML = 'Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz benedikt@cs.stanford.edu Stanford University Alessandro Chiesa alexch@berkeley.edu UC Berkeley Pratyush Mishra pratyush@berkeley.edu UC Berkeley Nicholas Spooner nick.spooner@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Recursive proof composition has been shown to lead to powerful primitives such as incrementally-verifiable computation (IVC) and proof-carrying data (PCD). All existing approaches to recursive composition take a succinct non-interactive argument of knowledge (SNARK) and use it to prove a statement about its own verifier. This technique requires that the verifier run in time sublinear in the size of the statement it is checking, a strong requirement that restricts the class of SNARKs from which PCD can be built. This in turn restricts the efficiency and security properties of the resulting scheme.</p>

    <p class="text-gray-300">Bowe, Grigg, and Hopwood (ePrint 2019/1021) outlined a novel approach to recursive composition, and applied it to a particular SNARK construction which does <em>not</em> have a sublinear-time verifier. However, they omit details about this approach and do not prove that it satisfies any security property. Nonetheless, schemes based on their ideas have already been implemented in software.</p>

    <p class="text-gray-300">In this work we present a collection of results that establish the theoretical foundations for a generalization of the above approach. We define an <em>accumulation scheme</em> for a non-interactive argument, and show that this suffices to construct PCD, even if the argument itself does not have a sublinear-time verifier. Moreover we give constructions of accumulation schemes for SNARKs, which yield PCD schemes with novel efficiency and security features.</p>

    <p class="text-gray-300">Keywords: succinct arguments; proof-carrying data; recursive proof composition</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our contributions  3 1.2 Related work  6</p>

    <p class="text-gray-300">2  Techniques  8 2.1 PCD from arguments with accumulation schemes  8 2.2 Accumulation schemes  10 2.3 Constructing arguments with accumulation schemes  11 2.4 Accumulation schemes for polynomial commitments  12</p>

    <p class="text-gray-300">3  Preliminaries  16 3.1 Non-interactive arguments in the ROM  16 3.2 Proof-carrying data  17 3.3 Instantiating the random oracle  18 3.4 Post-quantum security  18 3.5 Commitment schemes  19 3.6 Polynomial commitments  20</p>

    <p class="text-gray-300">4  Accumulation schemes  22 4.1 Definition  22 4.2 Accumulation schemes for certain predicates  23</p>

    <p class="text-gray-300">5  Proof-carrying data from accumulation schemes  24 5.1 Construction  25 5.2 Efficiency  26 5.3 Completeness  27 5.4 Knowledge soundness  27 5.5 Zero knowledge  29 5.6 Post-quantum security  29</p>

    <p class="text-gray-300">6  Accumulation schemes for non-interactive arguments  31 6.1 Construction  32 6.2 Completeness  32 6.3 Soundness  33 6.4 Zero knowledge  34</p>

    <p class="text-gray-300">7  Accumulating polynomial commitments based on discrete logarithms  36 7.1 Construction  36 7.2 Proof of Theorem 7.1  37</p>

    <p class="text-gray-300">8  Accumulating polynomial commitments based on bilinear groups  42 8.1 Construction  42 8.2 Proof of Theorem 8.1  43</p>

    <p class="text-gray-300">A  Construction of <span class="math">PC_{OL}</span>  48 A.1 Pedersen commitments  48 A.2 Construction  48 A.3 Security  50</p>

    <p class="text-gray-300">Acknowledgements  52</p>

    <p class="text-gray-300">References  52</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300"><em>Proof-carrying data</em> (PCD) <em>[x10]</em> is a cryptographic primitive that enables mutually distrustful parties to perform distributed computations that run indefinitely, while ensuring that every intermediate state of the computation can be succinctly verified. PCD supports computations defined on (possibly infinite) directed acyclic graphs, with messages passed along directed edges. Verification is facilitated by attaching to each message a succinct proof of correctness. This is a generalization of the notion of <em>incrementally-verifiable computation</em> (IVC) due to <em>[x23]</em>, which can be viewed as PCD for the path graph (i.e., for automata). PCD has found applications in enforcing language semantics <em>[x11]</em>, verifiable MapReduce computations <em>[x12]</em>, image authentication <em>[x20]</em>, succinct blockchains <em>[x14, x18, x1]</em>, and others.</p>

    <p class="text-gray-300">Recursive composition. Prior to this work, the only known method for constructing PCD was from <em>recursive composition</em> of succinct non-interactive arguments (SNARGs) <em>[x2, x3, x13]</em>. This method informally works as follows. A proof that the computation was executed correctly for <span class="math">t</span> steps consists of a proof of the claim “the <span class="math">t</span>-th step of the computation was executed correctly, and there exists a proof that the computation was executed correctly for <span class="math">t-1</span> steps”. The latter part of the claim is expressed using the SNARG verifier itself. This construction yields secure PCD (with IVC as a special case) provided the SNARG satisfies an adaptive knowledge soundness property (i.e., is a SNARK). The efficiency and security properties of the resulting PCD scheme correspond to those of a single invocation of the SNARK.</p>

    <p class="text-gray-300">Limitations of recursion. Recursion as realized in prior work requires proving a statement that contains a description of the SNARK verifier. In particular, for efficiency, we must ensure that the statement we are proving (essentially) <em>does not grow</em> with the number of recursion steps <span class="math">t</span>. For example, if the representation of the verifier were to grow even <em>linearly</em> with the statement it is verifying, then the size of the statement to be checked would grow <em>exponentially</em> in <span class="math">t</span>. Therefore, prior works have achieved efficiency by focusing on SNARKs which admit sublinear-time verification: either SNARKs for machine computations <em>[x2]</em> or preprocessing SNARKs for circuit computations <em>[x3, x13]</em>. Requiring sublinear-time verification significantly restricts our choice of SNARK, which limits what we can achieve for PCD.</p>

    <p class="text-gray-300">In addition to the above asymptotic considerations, recursion raises additional considerations concerning concrete efficiency. All SNARK constructions require that statements be encoded as instances of some particular (algebraic) NP-complete problem, and difficulties often arise when encoding the SNARK verifier itself as such an instance. The most well-known example of this is in recursive composition of pairing-based SNARKs, since the verifier performs operations over a finite field that is necessarily different from the field supported “natively” by the NP-complete problem <em>[x3]</em>. This type of problem also appears when recursing SNARKs whose verifiers make heavy use of cryptographic hash functions <em>[x13]</em>.</p>

    <p class="text-gray-300">A new technique. Bowe, Grigg, and Hopwood <em>[x6]</em> suggest an exciting novel approach to recursive composition that replaces the SNARK verifier in the circuit with a simpler algorithm. This algorithm does not itself verify the previous proof <span class="math">\\pi_{t-1}</span>. Instead, it adds the proof to an <em>accumulator</em> for verification at the end. The accumulator must not grow in size. A key contribution of <em>[x6]</em> is to sketch a mechanism by which this might be achieved for a particular SNARK construction. While they prove this SNARK construction secure, they do not include definitions or proofs of security for their recursive technique. Nonetheless, practitioners have already built software based on these ideas <em>[x15, x16]</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our contributions</h3>

    <p class="text-gray-300">In this work we provide a collection of results that establish the theoretical foundations for the above approach. We introduce the cryptographic object, an <em>accumulation scheme</em>, that enables this technique, and prove that it</p>

    <p class="text-gray-300">suffices for constructing PCD. We then provide generic tools for building accumulation schemes, as well as several concrete instantiations. Our framework establishes the security of schemes that are already being used by practitioners, and we believe that it will simplify and facilitate further research in this area.</p>

    <p class="text-gray-300">Accumulation schemes. We introduce the notion of an <em>accumulation scheme</em> for a predicate <span class="math">\\Phi\\colon X\\to\\{0,1\\}</span>. This formalizes, and generalizes, an idea outlined in <em>[x1]</em>. An accumulation scheme is best understood in the context of the following process. Consider an infinite stream <span class="math">\\mathsf{q}_{1},\\mathsf{q}_{2},\\ldots</span> with each <span class="math">\\mathsf{q}_{i}\\in X</span>. We augment this stream with <em>accumulators</em> <span class="math">\\mathsf{acc}_{i}</span> as follows: at time <span class="math">i</span>, the <em>accumulation prover</em> receives <span class="math">(\\mathsf{q}_{i},\\mathsf{acc}_{i-1})</span> and computes <span class="math">\\mathsf{acc}_{i}</span>; the <em>accumulation verifier</em> receives <span class="math">(\\mathsf{q}_{i},\\mathsf{acc}_{i-1},\\mathsf{acc}_{i})</span> and checks that <span class="math">\\mathsf{acc}_{i-1}</span> and <span class="math">\\mathsf{q}_{i}</span> were correctly accumulated into <span class="math">\\mathsf{acc}_{i}</span> (if not, the process ends). Then at any time <span class="math">t</span>, the <em>decider</em> can validate <span class="math">\\mathsf{acc}_{t}</span>, which establishes that, for <em>all</em> <span class="math">i\\in[t]</span>, <span class="math">\\Phi(\\mathsf{q}_{i})=1</span>. All three algorithms are stateless. To avoid trivial constructions, we want (i) the accumulation verifier to be more efficient than <span class="math">\\Phi</span>, and (ii) the size of an accumulator (and hence the running time of the three algorithms) does not grow over time. Accumulation schemes are powerful, as we demonstrate next.</p>

    <p class="text-gray-300">Recursion from accumulation. We say that a SNARK has an accumulation scheme if the predicate corresponding to its verifier has an accumulation scheme (so <span class="math">X</span> is a set of instance-proof pairs). We show that any SNARK having an accumulation scheme where the <em>accumulation verifier</em> is sublinear can be used to build a proof-carrying data (PCD) scheme, <em>even if the SNARK verifier is not itself sublinear</em>. This broadens the class of SNARKs from which PCD can be built. Similarly to <em>[x10]</em>, we show that if the SNARK and accumulation scheme are post-quantum secure, so is the PCD scheme. (Though it remains an open question whether there are non-trivial accumulation schemes for post-quantum SNARKs.)</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">There is an efficient transformation that compiles any SNARK with an efficient accumulation scheme into a PCD scheme. If the SNARK and its accumulation scheme are zero knowledge, then the PCD scheme is also zero knowledge. Additionally, if the SNARK and its accumulation scheme are post-quantum secure then the PCD scheme is also post-quantum secure.</p>

    <p class="text-gray-300">The above theorem holds in the standard model (where all parties have access to a common reference string, but no oracles). Since our construction makes non-black-box use of the accumulation scheme verifier, the theorem does not carry over to the random oracle model (ROM). It remains an intriguing open problem to determine whether or not SNARKs in the ROM imply PCD in the ROM (and if the latter is even possible).</p>

    <p class="text-gray-300">Note that we require a suitable definition of zero knowledge for an accumulation scheme. This is not trivial, and our definition is informed by what is required for Theorem 1 and what our constructions achieve.</p>

    <p class="text-gray-300">Proof-carrying data is a powerful primitive: it implies IVC and, further assuming collision-resistant hash functions, also efficient SNARKs for machine computations. Hence, Theorem 1 may be viewed as an extension of the “bootstrapping” theorem of <em>[x3]</em> to certain non-succinct-verifier SNARKs.</p>

    <p class="text-gray-300">See Section 2.1 for a summary of the ideas behind Theorem 1, and Section 5 for technical details.</p>

    <p class="text-gray-300">Accumulation from accumulation. Given the above, a natural question is: where do accumulation schemes for SNARKs come from? In <em>[x1]</em> it was informally observed that a specific SNARK construction, based on the hardness of the discrete logarithm problem, has an accumulation scheme. To show this, <em>[x1]</em> first observe that the verifier in the SNARK construction is sublinear <em>except for</em> the evaluation of a certain predicate (checking an opening of a polynomial commitment <em>[x16]</em>), then outline a construction which is essentially an accumulation scheme for that predicate.</p>

    <p class="text-gray-300">We prove that this idea is a special case of a general paradigm for building accumulation schemes for SNARKs.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <p class="text-gray-300">There is an efficient transformation that, given a SNARK whose verifier is succinct when given oracle access to a “simpler” predicate, and an accumulation scheme for that predicate, constructs</p>

    <p class="text-gray-300">an accumulation scheme for the SNARK. Moreover, this transformation preserves zero knowledge and post-quantum security of the accumulation scheme.</p>

    <p class="text-gray-300">The construction underlying Theorem 2 is black-box. In particular, if both the SNARK and the accumulation scheme for the predicate are secure with respect to an oracle, then the resulting accumulation scheme for the SNARK is secure with respect to that oracle.</p>

    <p class="text-gray-300">See Section 2.3 for a summary of the ideas behind Theorem 2, and Section 6 for technical details.</p>

    <p class="text-gray-300">Accumulating polynomial commitments. Several works [MBKM19; GWC19; CHMMVW20] have constructed SNARKs whose verifiers are succinct relative to a specific predicate: checking the opening of a polynomial commitment [KZG10]. We prove that two natural polynomial commitment schemes possess accumulation schemes in the random oracle model:  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> , a scheme based on the security of discrete logarithms [BCCGP16; BBBPWM18; WTSTW18]; and  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> , a scheme based on knowledge assumptions in bilinear groups [KZG10; CHMMVW20].</p>

    <p class="text-gray-300">Theorem 3 (informal). In the random oracle model, there exist (zero knowledge) accumulation schemes for  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  and  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span>  that achieve the efficiency outlined in the table below ( <span class="math">n</span>  denotes the number of evaluation proofs, and  <span class="math">d</span>  denotes the degree of committed polynomials).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomial commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost to check evaluation proofs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost to check an accumulation step</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost to check final accumulator</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">accumulator size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PCDL</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG + RO</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(nd) G mults.</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(n log d) G mults.</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(d) G mults.</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(log d) G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PCAGM</td>

            <td class="px-3 py-2 border-b border-gray-700">AGM + RO</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(n) pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(n) G1 mults.</td>

            <td class="px-3 py-2 border-b border-gray-700">1 pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For both schemes the cost of checking that an accumulation step was performed correctly is much less than the cost of checking an evaluation proof. We can apply Theorem 2 to combine either of these accumulation schemes for polynomial commitments with any of the aforementioned predicate-efficient SNARKs, which yields concrete accumulation schemes for these SNARKs with the same efficiency benefits.</p>

    <p class="text-gray-300">We remark that our accumulation scheme for  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  is a variation of a construction presented in [BGH19], and so our result establishes the security of a type of construction used by practitioners.</p>

    <p class="text-gray-300">We sketch the constructions underlying Theorem 3 in Section 2.4, and provide details in Sections 7 and 8.</p>

    <p class="text-gray-300">New constructions of PCD. By combining our results, we (heuristically) obtain constructions of PCD that achieve new properties. Namely, starting from either  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  or  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> , we can apply Theorem 2 to a suitable SNARK to obtain a SNARK with an accumulation scheme in the random oracle model. Then we can instantiate the random oracle, obtaining a SNARK and accumulation scheme with heuristic security in the standard (CRS) model, to which we apply Theorem 1 to obtain a corresponding PCD scheme. Depending on whether we started with  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  or  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> , we get a PCD scheme with different features, as summarized below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> : PCD based on discrete logarithms. We obtain a PCD scheme in the uniform reference string model (i.e., without secret parameters) and small argument sizes. In contrast, prior PCD schemes require structured reference strings [BCTV14] or have larger argument sizes [COS20]. Moreover, our PCD scheme can be efficiently instantiated from any cycle of elliptic curves [SS11]. In contrast, prior PCD schemes with small argument size use cycles of pairing-friendly elliptic curves [BCTV14; CCW19], which are more expensive.</li>

      <li>From  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> : lightweight PCD based on bilinear groups. The recursive statement inside this PCD scheme does not involve checking any pairing computations, because pairings are deferred to a verification that occurs outside the recursive statement. In contrast, the recursive statements in prior PCD schemes based on pairing-based SNARKs were more expensive because they checked pairing computations [BCTV14].</li>

    </ul>

    <p class="text-gray-300">Note again that our constructions of PCD are <em>heuristic</em> as they involve instantiating the random oracle of certain SNARK constructions with an appropriate hash function. This is because Theorem 3 is proven in the random oracle model, but Theorem 1 is explicitly <em>not</em> (as is the case for all prior IVC/PCD constructions <em>[x18, x1, x2, x10]</em>). There is evidence that this limitation might be inherent <em>[x5]</em>.</p>

    <p class="text-gray-300">Open problem: accumulation in the standard model. All known constructions of accumulation schemes for non-interactive arguments make use of either random oracles (as in our constructions) or knowledge assumptions (e.g., the “trivial” construction from succinct-verifier SNARKs). A natural question, then, is whether there exist constructions of accumulation schemes for non-interactive arguments, or any other interesting predicate, from standard assumptions, or any assumptions which are not known to imply SNARKs. A related question is whether there is a black-box impossibility for accumulation schemes similar to the result for SNARGs of <em>[x11]</em>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <p class="text-gray-300">Below we survey prior constructions of IVC/PCD.</p>

    <p class="text-gray-300">PCD from SNARKs. Bitansky, Canetti, Chiesa, and Tromer <em>[x1]</em> proved that recursive composition of SNARKs for machine computations implies PCD for constant-depth graphs, and that this in turn implies IVC for polynomial-time machine computations. From the perspective of concrete efficiency, however, one can achieve more efficient recursive composition by using <em>preprocessing</em> SNARKs for circuits rather than SNARKs for machines <em>[x2, x3]</em>; this observation has led to real-world applications <em>[x4, x1]</em>. The features of the PCD scheme obtained from recursion depends on the features of the underlying preprocessing SNARK. Below we summarize the features of the two known constructions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PCD from pairing-based SNARKs. Ben-Sasson, Chiesa, Tromer, and Virza <em>[x2]</em> used pairing-based SNARKs with a special algebraic property to achieve efficient recursive composition with very small argument sizes (linear in the security parameter <span class="math">\\lambda</span>). The use of pairing-based SNARKs has two main downsides. First, they require sampling a <em>structured reference string</em> involving secret values (“toxic waste”) that, if revealed, compromise security. Second, the verifier performs operations over a finite field that is necessarily different from the field supported “natively” by the statement it is checking. To avoid expensive simulation of field arithmetic, the construction uses <em>pairing-friendly cycles of elliptic curves</em>, which severely restricts the choice of field in applications and requires a large base field for security.</li>

      <li>PCD from IOP-based SNARKs. Chiesa, Ojha, and Spooner <em>[x3]</em> used a holographic IOP to construct a preprocessing SNARK that is unconditionally secure in the (quantum) random oracle model, which heuristically implies a post-quantum preprocessing SNARK in the <em>uniform reference string</em> model (i.e., without toxic waste). They then proved that any post-quantum SNARK leads to a post-quantum PCD scheme via recursive composition. The downside of this construction is that, given known holographic IOPs, the argument size is larger, currently at <span class="math">O(\\lambda^{2}\\log^{2}N)</span> bits for circuits of size <span class="math">N</span>.</li>

    </ul>

    <p class="text-gray-300">IVC from homomorphic encryption. Naor, Paneth, and Rothblum <em>[x14]</em> obtain a notion of IVC by using somewhat homomorphic encryption and an information-theoretic object called an “incremental PCP”. The key feature of their scheme is that security holds under falsifiable assumptions.</p>

    <p class="text-gray-300">There are two drawbacks, however, that restrict the use of the notion of IVC that their scheme achieves.</p>

    <p class="text-gray-300">First, the computation to be verified must be <em>deterministic</em> (this appears necessary for schemes based on falsifiable assumptions given known impossibility results <em>[x11]</em>). Second, and more subtly, completeness holds only in the case where intermediate proofs were honestly generated. This means that the following</p>

    <p class="text-gray-300">attack may be possible: an adversary provides an intermediate proof that verifies, but it is impossible for honest parties to generate new proofs for subsequent computations. Our construction of PCD achieves the stronger condition that completeness holds so long as intermediate proofs verify, ruling out this attack.</p>

    <p class="text-gray-300">Both nondeterministic computation and the stronger completeness notion (achieved by all SNARK-based PCD schemes) are necessary for many of the applications of IVC/PCD.</p>

    <p class="text-gray-300">2 Techniques</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 PCD from arguments with accumulation schemes</h3>

    <p class="text-gray-300">We summarize the main ideas behind Theorem 1, which obtains proof-carrying data (PCD) from any succinct non-interactive argument of knowledge (SNARK) that has an accumulation scheme. For the sake of exposition, in this section we focus on the special case of IVC, which can be viewed as repeated application of a circuit <span class="math">F</span>. Specifically, we wish to check a claim of the form “<span class="math">F^{T}(z_{0})=z_{T}</span>” where <span class="math">F^{T}</span> denotes <span class="math">F</span> composed with itself <span class="math">T</span> times.</p>

    <p class="text-gray-300">Prior work: recursion from succinct verification. Recall that in previous approaches to efficient recursive composition <em>[x1, x10]</em>, at each step <span class="math">i</span> we prove a claim of the form “<span class="math">z_{i}=F(z_{i-1})</span>, and there exists a proof <span class="math">\\pi_{i-1}</span> that attests to the correctness of <span class="math">z_{i-1}</span>”. This claim is expressed using a circuit <span class="math">R</span> which is the conjunction of <span class="math">F</span> with a circuit representing the SNARK verifier; in particular, the size of the claim is at least the size of the verifier circuit. If the size of the verifier circuit grows linearly (or more) with the size of the claim being checked, then verifying the final proof becomes more costly than the original computation.</p>

    <p class="text-gray-300">For this reason, these works focus on SNARKs with <em>succinct verification</em>, where the verifier runs in time <em>sublinear</em> in the size of the claim. In this case, the size of the claim essentially <em>does not grow</em> with the number of recursive steps, and so checking the final proof costs roughly the same as checking a single step.</p>

    <p class="text-gray-300">Succinct verification is a seemingly paradoxical requirement: the verifier does not even have time to <em>read</em> the circuit <span class="math">R</span>. One way to sidestep this issue is <em>preprocessing</em>: one designs an algorithm that, at the beginning of the recursion, computes a small cryptographic digest of <span class="math">R</span>, which the recursive verifier can use instead of reading <span class="math">R</span> directly. Because this preprocessing need only be performed once for the given <span class="math">R</span> in an offline phase, it has almost no effect on the performance of each recursive step (in the later online phase).</p>

    <p class="text-gray-300">A new paradigm: IVC from accumulation. Even allowing for preprocessing, succinct verification remains a strong requirement, and there are many SNARKs that are not known to satisfy it (e.g., <em>[x2, x1, x3, x11, x4]</em>). Bowe, Grigg, and Hopwood <em>[x5]</em> suggested a further relaxation of succinctness that appears to still suffice for recursive composition: a type of “post-processing”. Their observation is as follows: if a SNARK is such that we can efficiently “defer” the verification of a claim in a way that does not grow in cost with the number of claims to be checked, then we can hope to achieve recursive composition by deferring the verification of all claims to the end.</p>

    <p class="text-gray-300">In the remainder of this section, we will give an overview of the proof of Theorem 1, our construction of PCD from SNARKs that have this “post-processing” property. We note that this relaxation of requirements is useful because, as suggested in <em>[x5]</em>, it leads to new constructions of PCD with desirable properties (see discussion at the end of Section 1.1). In fact, some of these efficiency features are already being exploited by practitioners working on recursing SNARKs <em>[x12, x13]</em>.</p>

    <p class="text-gray-300">The specific property we require, which we discuss more formally in the next section, is that the SNARK has an <em>accumulation scheme</em>. This is a generalization of the idea described in <em>[x5]</em>. Informally, an accumulation scheme consists of three algorithms: an accumulation prover, an accumulation verifier, and a decider. The accumulation prover is tasked with taking an instance-proof pair <span class="math">(z,\\pi)</span> and a previous accumulator acc, and producing a new accumulator acc<em> that “includes” the new instance. The accumulation verifier, given <span class="math">((z,\\pi),\\textsf{acc},\\textsf{acc}^{</em>})</span>, checks that acc<em> was computed correctly (i.e., that it accumulates <span class="math">(z,\\pi)</span>) into acc). Finally the decider, given a single accumulator acc, performs a single check that simultaneously ensures that </em>every* instance-proof pair accumulated in acc verifies.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Given such an accumulation scheme, we can construct IVC as follows. Given a previous instance <span class="math">z_{i}</span>, proof <span class="math">\\pi_{i}</span>, and accumulator <span class="math">\\mathsf{acc}_{i}</span>, the IVC prover first accumulates <span class="math">(z_{i},\\pi_{i})</span> with <span class="math">\\mathsf{acc}_{i}</span> to obtain a new accumulator <span class="math">\\mathsf{acc}_{i+1}</span>. The IVC prover also generates a SNARK proof <span class="math">\\pi_{i+1}</span> of the claim: “<span class="math">z_{i+1}=F(z_{i})</span>, and there exist a proof <span class="math">\\pi_{i}</span> and an accumulator <span class="math">\\mathsf{acc}_{i}</span> such that the accumulation verifier accepts <span class="math">((z_{i},\\pi_{i}),\\mathsf{acc}_{i},\\mathsf{acc}_{i+1})</span>”, expressed as a circuit <span class="math">R</span>. The final IVC proof then consists of <span class="math">(\\pi_{T},\\mathsf{acc}_{T})</span>. The IVC verifier checks such a proof by running the SNARK verifier on <span class="math">\\pi_{T}</span> and the accumulation scheme decider on <span class="math">\\mathsf{acc}_{T}</span>.</p>

    <p class="text-gray-300">Why does this achieve IVC? Throughout the computation we maintain the invariant that if <span class="math">\\mathsf{acc}_{i}</span> is a valid accumulator (according to the decider) and <span class="math">\\pi_{i}</span> is a valid proof, then the computation is correct up to the <span class="math">i</span>-th step. Clearly if this holds at time <span class="math">T</span> then the IVC verifier successfully checks the entire computation. Observe that if we were able to prove that “<span class="math">z_{i+1}=F(z_{i})</span>, <span class="math">\\pi_{i}</span> is a valid proof, and <span class="math">\\mathsf{acc}_{i}</span> is a valid accumulator”, by applying the invariant we would be able to conclude that the computation is correct up to step <span class="math">i+1</span>. Unfortunately we are not able to prove this directly, for two reasons: (i) proving that <span class="math">\\pi_{i}</span> is a valid proof requires proving a statement about the argument verifier, which may not be sublinear, and (ii) proving that <span class="math">\\mathsf{acc}_{i}</span> is a valid accumulator requires proving a statement about the decider, which may not be sublinear.</p>

    <p class="text-gray-300">Instead of proving this claim directly, we “defer” it by having the prover accumulate <span class="math">(z_{i},\\pi_{i})</span> into <span class="math">\\mathsf{acc}_{i}</span> to obtain a new accumulator <span class="math">\\mathsf{acc}_{i+1}</span>. The soundness property of the accumulation scheme ensures that if <span class="math">\\mathsf{acc}_{i+1}</span> is valid and the accumulation verifier accepts <span class="math">((z_{i},\\pi_{i}),\\mathsf{acc}_{i},\\mathsf{acc}_{i+1})</span>, then <span class="math">\\pi_{i}</span> is a valid proof and <span class="math">\\mathsf{acc}_{i}</span> is a valid accumulator. Thus all that remains to maintain the invariant is for the prover to prove that the accumulation verifier accepts; this is possible provided that the accumulation verifier is sublinear.</p>

    <p class="text-gray-300">From sketch to proof. In Section 5, we give the formal details of our construction and a proof of correctness. In particular, we show how to construct PCD, a more general primitive than IVC. In the PCD setting, rather than each computation step having a single input <span class="math">z_{i}</span>, it receives <span class="math">m</span> inputs from different nodes. Proving correctness hence requires proving that all of these inputs were computed correctly. For our construction, this entails checking <span class="math">m</span> proofs and <span class="math">m</span> accumulators. To do this, we extend the definition of an accumulation scheme to allow accumulating multiple instance-proof pairs and multiple “old” accumulators.</p>

    <p class="text-gray-300">We now informally discuss the properties of our PCD construction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficiency requirements. Observe that the statement to be proved includes only the accumulation verifier, and so the only efficiency requirement for obtaining PCD is that this algorithm run in time sublinear in the size of the circuit <span class="math">R</span>. This implies, in particular, that an accumulator must be of size sublinear in the size of <span class="math">R</span>, and hence must not grow with each accumulation step. The SNARK verifier and the decider algorithm need only be efficient in the usual sense (i.e., polynomial-time). See Section 5.2 for a detailed analysis.</li>

      <li>Soundness. We prove that the PCD scheme is sound provided that the SNARK is knowledge sound (i.e., is an adaptively-secure argument of knowledge) and the accumulation scheme is sound (see Section 2.2 for more on what this means). We stress that in both cases security should be in the standard (CRS) model, without any random oracles (as in prior PCD constructions). See Section 5.4 for details.</li>

      <li>Zero knowledge. We prove that the PCD scheme is zero knowledge, if the underlying SNARK and accumulation scheme are both zero knowledge (for this part we also formulate a suitable notion of zero knowledge for accumulation schemes as discussed shortly in Section 2.2). See Section 5.5 for details.</li>

      <li>Post-quantum security. We also prove that if both the SNARK and accumulation scheme are post-quantum secure, then so is the resulting PCD scheme. Here by post-quantum secure we mean that the relevant security properties continue to hold even against polynomial-size quantum circuits, as opposed to just polynomial-size classical circuits. See Section 5.6 for details.</li>

    </ul>

    <p class="text-gray-300">2.2 Accumulation schemes</p>

    <p class="text-gray-300">A significant contribution of this work is formulating a general notion of an accumulation scheme. An accumulation scheme for a non-interactive argument as described above is a particular instance of this definition; in subsequent sections we will apply the definition in other settings.</p>

    <p class="text-gray-300">We first give an informal definition that captures the key features of an accumulation scheme. For clarity this is stated for the (minimal) case of a single predicate input q and a single “old” accumulator acc; we later extend this in the natural way to <span class="math">n</span> predicate inputs and <span class="math">m</span> “old” accumulators.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.1 (informal).</h6>

    <p class="text-gray-300">An accumulation scheme for a predicate <span class="math">\\Phi\\colon X\\to\\{0,1\\}</span> consists of a triple of algorithms <span class="math">(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span>, known as the prover, verifier, and decider, that satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness: For all accumulators acc and predicate inputs <span class="math">\\mathsf{q}\\in X</span>, if <span class="math">\\mathrm{D}(\\mathsf{acc})=1</span> and <span class="math">\\Phi(\\mathsf{q})=1</span>, then for <span class="math">\\mathsf{acc}^{\\star}\\leftarrow\\mathrm{P}(\\mathsf{acc},\\mathsf{q})</span> it holds that <span class="math">\\mathrm{V}(\\mathsf{acc},\\mathsf{q},\\mathsf{acc}^{\\star})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{acc}^{\\star})=1</span>.</li>

      <li>Soundness: For all efficiently-generated accumulators <span class="math">\\mathsf{acc},\\mathsf{acc}^{\\star}</span> and predicate inputs <span class="math">\\mathsf{q}\\in X</span>, if <span class="math">\\mathrm{D}(\\mathsf{acc}^{\\star})=1</span> and <span class="math">\\mathrm{V}(\\mathsf{acc},\\mathsf{q},\\mathsf{acc}^{\\star})=1</span> then, with all but negligible probability, <span class="math">\\Phi(\\mathsf{q})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{acc})=1</span>.</li>

    </ul>

    <p class="text-gray-300">An accumulation scheme for a SNARK is an accumulation scheme for the predicate induced by the argument verifier; in this case the predicate input q consists of an instance-proof pair <span class="math">(\\mathbf{\\Xi},\\pi)</span>. Note that the completeness requirement does not place any restriction on how the previous accumulator acc is generated; we require that completeness holds for any acc the decider <span class="math">\\mathrm{D}</span> determines to be valid, and any q for which the predicate <span class="math">\\Phi</span> holds. This is needed to obtain a similarly strong notion of completeness for PCD, required for applications where accumulation is done by multiple parties that do not trust one another.</p>

    <p class="text-gray-300">Zero knowledge. For our PCD application, the notion of zero knowledge for an accumulation scheme that we use is the following: one can sample a “fake” accumulator that is indistinguishable from a real accumulator <span class="math">\\mathsf{acc}^{\\star}</span>, without knowing anything about the old accumulator <span class="math">\\mathsf{acc}</span> and predicate input q that were accumulated in <span class="math">\\mathsf{acc}^{\\star}</span>. The existence of the accumulation verifier <span class="math">\\mathrm{V}</span> complicates matters here: if the adversary knows <span class="math">\\mathsf{acc}</span> and q, then it is easy to distinguish a real accumulator from a fake one using <span class="math">\\mathrm{V}</span>. We resolve this issue by modifying Definition 2.1 to have the accumulation prover <span class="math">\\mathrm{P}</span> produce a verification proof <span class="math">\\pi_{\\mathrm{V}}</span> in addition to the new accumulator <span class="math">\\mathsf{acc}^{\\star}</span>. Then <span class="math">\\mathrm{V}</span> uses <span class="math">\\pi_{\\mathrm{V}}</span> in verifying the accumulator, but <span class="math">\\pi_{\\mathrm{V}}</span> is not required for subsequent accumulation. In our application, the simulator then does not have to simulate <span class="math">\\pi_{\\mathrm{V}}</span>. This avoids the problem described: even if the adversary knows <span class="math">\\mathsf{acc}</span> and q, unless <span class="math">\\pi_{\\mathrm{V}}</span> is correct, <span class="math">\\mathrm{V}</span> can simply reject, as it would for a “fake” accumulator. Our informal definition is as follows.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.2.</h6>

    <p class="text-gray-300">An accumulation scheme for <span class="math">\\Phi</span> is zero knowledge if there exists an efficient simulator <span class="math">\\mathrm{S}</span> such that for all accumulators <span class="math">\\mathsf{acc}</span> and inputs <span class="math">\\mathsf{q}\\in X</span> such that <span class="math">\\mathrm{D}(\\mathsf{acc})=1</span> and <span class="math">\\Phi(\\mathsf{q})=1</span>, the distribution of <span class="math">\\mathsf{acc}^{\\star}</span> when <span class="math">(\\mathsf{acc}^{\\star},\\pi_{\\mathrm{V}})\\leftarrow\\mathrm{P}(\\mathsf{acc},\\mathsf{q})</span> is computationally indistinguishable from <span class="math">\\mathsf{acc}^{\\star}\\leftarrow\\mathrm{S}(1^{\\lambda})</span>.</p>

    <p class="text-gray-300">Predicate specification. The above informal definitions omit many important details; we now highlight some of these. Suppose that, as required for IVC/PCD, we have some fixed circuit <span class="math">R</span> for which we want to accumulate pairs <span class="math">(\\mathbf{\\Xi}_{i},\\pi_{i})</span>, where <span class="math">\\pi_{i}</span> is a SNARK proof that there exists <span class="math">\\mathsf{w}_{i}</span> such that <span class="math">R(\\mathbf{\\Xi}_{i},\\mathsf{w}_{i})=1</span>. In this case the predicate corresponding to the verifier depends not only on the pair <span class="math">(\\mathbf{\\Xi}_{i},\\pi_{i})</span>, but also on the circuit <span class="math">R</span>, as well as the public parameters of the argument scheme <span class="math">\\mathsf{pp}</span> and (often) a random oracle <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Moreover, each of these inputs has different security and efficiency considerations. The security of the SNARK (and the accumulation scheme) can only be guaranteed with high probability over public parameters drawn by the generator algorithm of the SNARK, and over the random oracle. The circuit <span class="math">R</span> may be chosen adversarially, but cannot be part of the input q because it is too large; it must be fixed at the beginning.</p>

    <p class="text-gray-300">These considerations lead us to define an accumulation scheme with respect to both a predicate <span class="math">\\Phi\\colon\\mathcal{U}(<em>)\\times(\\{0,1\\}^{</em>})^{3}\\to\\{0,1\\}</span> and a predicate-specification algorithm <span class="math">\\mathcal{H}</span>. We then adapt Definition 2.1 to hold</p>

    <p class="text-gray-300">for the predicate <span class="math">\\Phi(\\rho,\\mathsf{pp}_{\\Phi},\\mathsf{i}_{\\Phi},\\cdot)</span> where <span class="math">\\rho</span> is a random oracle, <span class="math">\\mathsf{pp}_{\\Phi}</span> is output by <span class="math">\\mathcal{H}^{\\rho}</span>, and <span class="math">\\mathsf{i}_{\\Phi}</span> is chosen adversarially. In our SNARK example, <span class="math">\\mathcal{H}</span> is equal to the SNARK generator, <span class="math">\\mathsf{i}_{\\Phi}</span> is the circuit <span class="math">R</span>, and <span class="math">\\Phi(\\rho,\\mathsf{pp},R,(\\Xi,\\pi))=\\mathcal{V}^{\\rho}(\\mathsf{pp},R,\\Xi,\\pi)</span>. For a more precise description, see Section 4.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 2.3 (helped verification).</h6>

    <p class="text-gray-300">We compare accumulation schemes for SNARKs with the notion of “helped verification” <em>[x11]</em>. In a SNARK with helped verification, an untrusted party known as the <em>helper</em> can, given <span class="math">n</span> proofs, produce an auxiliary proof that enables checking the <span class="math">n</span> proofs at lower cost than that of checking each proof individually. This batching capability can be viewed as a special case of accumulation, as it applies to <span class="math">n</span> “fresh” proofs only; there is no notion of batching “old” accumulators. It is unclear whether the weaker notion of helped verification alone suffices to construct IVC/PCD schemes.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Constructing arguments with accumulation schemes</h3>

    <p class="text-gray-300">A key ingredient in our construction of PCD is a SNARK that has an accumulation scheme (see Section 2.1). Below we summarize the ideas behind Theorem 2, by explaining how to construct accumulation schemes for SNARKs whose verifier is succinct relative to an oracle predicate <span class="math">\\Phi_{\\circ}</span> that itself has an accumulation scheme.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Predicate-efficient SNARKs.</h5>

    <p class="text-gray-300">We call a SNARK <span class="math">\\mathsf{ARG}</span> for <em>predicate-efficient</em> with respect to a predicate <span class="math">\\Phi_{\\circ}</span> if its verifier <span class="math">\\mathcal{V}</span> operates as follows: (i) run a fast “inner” verifier <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> to produce a bit <span class="math">b</span> and query set <span class="math">Q</span>; (ii) accept iff <span class="math">b=1</span> and for all <span class="math">\\mathsf{q}\\in Q</span>, <span class="math">\\Phi_{\\circ}(\\mathsf{q})=1</span>. In essence, <span class="math">\\mathcal{V}</span> can be viewed as a circuit with “oracle gates” for <span class="math">\\Phi_{\\circ}</span>. The aim is for <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> to be significantly more efficient than <span class="math">\\mathcal{V}</span>; that is, the queries to <span class="math">\\Phi_{\\circ}</span> capture the “expensive” part of the computation of <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">As noted in Section 1.1, one can view recent SNARK constructions <em>[x11, x10, x12]</em> as being predicate-efficient with respect to a “polynomial commitment” predicate. We discuss how to construct accumulation schemes for these predicates below in Section 2.4.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Accumulation scheme for predicate-efficient SNARKs.</h5>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}</span> be a SNARK that is predicate-efficient with respect to a predicate <span class="math">\\Phi_{\\circ}</span>, and let <span class="math">\\mathsf{AS}_{\\circ}</span> be an accumulation scheme for <span class="math">\\Phi_{\\circ}</span>. To check <span class="math">n</span> proofs, instead of directly invoking the SNARK verifier <span class="math">\\mathcal{V}</span>, we can first run <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> <span class="math">n</span> times to generate <span class="math">n</span> query sets for <span class="math">\\Phi_{\\circ}</span>, and then, instead of invoking <span class="math">\\Phi_{\\circ}</span> on each of these sets, we can accumulate these queries using <span class="math">\\mathsf{AS}_{\\circ}</span>. Below we sketch the construction of an accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> for <span class="math">\\mathsf{ARG}</span> based on this idea.</p>

    <p class="text-gray-300">To accumulate <span class="math">n</span> instance-proof pairs <span class="math">[(\\Xi_{i},\\pi_{i})]_{i=1}^{n}</span> starting from an old accumulator <span class="math">\\mathsf{acc}</span>, the accumulation prover <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{P}</span> first invokes the inner verifier <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> on each <span class="math">(\\Xi_{i},\\pi_{i})</span> to generate a query set <span class="math">Q_{i}</span> for <span class="math">\\Phi_{\\circ}</span>, accumulates their union <span class="math">Q=\\cup_{i=1}^{n}Q_{i}</span> into <span class="math">\\mathsf{acc}</span> using <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{P}</span>, and finally outputs the resulting accumulator <span class="math">\\mathsf{acc}^{\\star}</span>. To check that <span class="math">\\mathsf{acc}^{\\star}</span> indeed accumulates <span class="math">[(\\Xi_{i},\\pi_{i})]_{i=1}^{n}</span> into <span class="math">\\mathsf{acc}</span>, the accumulation verifier <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{V}</span> first checks, for each <span class="math">i</span>, whether the inner verifier <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> accepts <span class="math">(\\Xi_{i},\\pi_{i})</span>, and then invokes <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span> to check whether <span class="math">\\mathsf{acc}^{\\star}</span> correctly accumulates the query set <span class="math">Q=\\cup_{i=1}^{n}Q_{i}</span>. Finally, to decide whether <span class="math">\\mathsf{acc}^{\\star}</span> is a valid accumulator, the accumulation scheme decider <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{D}</span> simply invokes <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}</span>.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">From sketch to proof.</h5>

    <p class="text-gray-300">The foregoing sketch omits details required to construct a scheme that satisfies the “full” definition of accumulation schemes as stated in Section 4. For instance, as noted in Section 2.3, the predicate <span class="math">\\Phi_{\\circ}</span> may be be an oracle predicate, and could depend on the public parameters of the SNARK <span class="math">\\mathsf{ARG}</span>. We handle this by requiring that the accumulation scheme for <span class="math">\\Phi_{\\circ}</span> uses the SNARK generator <span class="math">\\mathcal{G}</span> as its predicate specification algorithm. We also show that zero knowledge and post-quantum security are preserved. See Section 6 for a formal treatment of these issues, along with security proofs.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">From predicate-efficient SNARKs to PCD.</h5>

    <p class="text-gray-300">In order to build an accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> that suffices for PCD, <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}_{\\circ}</span> must satisfy certain efficiency properties. In particular, when verifying satisfiability</p>

    <p class="text-gray-300">for a circuit of size <span class="math">N</span>, the running time of <span class="math">\\mathsf{AS}_{\\text{\\tiny ARG}}.\\mathrm{V}</span> must be sublinear in <span class="math">N</span>, which means in turn that the running times of <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> and <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span>, as well as the size of the query set <span class="math">Q</span>, must be sublinear in <span class="math">N</span>. Crucially, however, <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}</span> need only run in time polynomial in <span class="math">N</span>. For further discussion, see Remark 6.3.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.4 Accumulation schemes for polynomial commitments</h3>

    <p class="text-gray-300">As noted in Section 2.3, several SNARK constructions (e.g., <em>[x14, x11, x10]</em>) are predicate-efficient with respect to an underlying <em>polynomial commitment</em>, which means that constructing an accumulation scheme for the latter leads (via Theorem 2) to an accumulation scheme for the whole SNARK.</p>

    <p class="text-gray-300">Informally, a polynomial commitment scheme (PC scheme) is a cryptographic primitive that enables one to produce a commitment <span class="math">C</span> to a polynomial <span class="math">p</span>, and then to prove that this committed polynomial evaluates to a claimed value <span class="math">v</span> at a desired point <span class="math">z</span>. (See Section 3.6 for a definition.) An accumulation scheme for a PC scheme thus accumulates claims of the form “<span class="math">C</span> commits to <span class="math">p</span> such that <span class="math">p(z)=v</span>” for arbitrary polynomials <span class="math">p</span> and evaluation points <span class="math">z</span>.</p>

    <p class="text-gray-300">In this section, we explain the ideas behind Theorem 3, by sketching how to construct (zero knowledge) accumulation schemes for two popular (hiding) polynomial commitment schemes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>In Section 2.4.1, we sketch our accumulation scheme for <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span>, a polynomial commitment scheme derived from <em>[x2, x3, x11]</em> that is based on the hardness of discrete logarithms.</li>

      <li>In Section 2.4.2, we sketch our accumulation scheme for <span class="math">\\mathsf{PC}_{\\text{\\tiny AGM}}</span>, a polynomial commitment scheme based on knowledge assumptions over bilinear groups <em>[x16, x10]</em>.</li>

    </ul>

    <p class="text-gray-300">In each case, the running time of the accumulation verifier will be sublinear in the degree of the polynomial, and the accumulator itself will not grow with the number of accumulation steps. This allows the schemes to be used, in conjunction with a suitable predicate-efficient SNARK, to construct PCD.</p>

    <p class="text-gray-300">We remark that each of our accumulation schemes is proved secure in the random oracle model by invoking a useful lemma about “zero-finding games” for committed polynomials (Lemma 3.3). Security also requires that the random oracle used for an accumulation scheme for a PC scheme is domain-separated from the random oracle used by the PC scheme itself.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">2.4.1 Accumulation scheme for <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span></h4>

    <p class="text-gray-300">We sketch our accumulation scheme for <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span>. For univariate polynomials of degree less than <span class="math">d</span>, <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span> achieves evaluation proofs of size <span class="math">O(\\lambda\\log d)</span> in the random oracle model, and assuming the hardness of the discrete logarithm problem in a prime order group <span class="math">\\mathbb{G}</span>. In particular, there are no secret parameters (so-called “toxic waste”). However, <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span> has poor verification complexity: checking an evaluation proof requires <span class="math">\\Omega(d)</span> scalar multiplications in <span class="math">\\mathbb{G}</span>. Bowe, Grigg, and Hopwood <em>[x2]</em> suggested a way to amortize this cost across a batch of <span class="math">n</span> proofs. Below we show that their idea leads to an accumulation scheme for <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span> with an accumulation verifier that uses only <span class="math">O(n\\log d)</span> scalar multiplications instead of the naive <span class="math">\\Theta(n\\cdot d)</span>, and with an accumulator of size <span class="math">O(\\log d)</span> elements in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Summary of <span class="math">\\mathsf{PC}_{\\text{\\tiny DL}}</span> (see Appendix A for details). The committer and receiver both sample (consistently via the random oracle) a list of group elements <span class="math">\\{G_{0},G_{1},\\ldots,G_{d}\\}\\in\\mathbb{G}^{d+1}</span> in a group <span class="math">\\mathbb{G}</span> of prime order <span class="math">q</span> (written additively). A commitment to a polynomial <span class="math">p(X)=\\sum_{i=0}^{d}a_{i}X^{i}\\in\\mathbb{F}_{q}^{\\leq d}[X]</span> is then given by <span class="math">C:=\\sum_{i=0}^{d}a_{i}G_{i}</span>. To prove that the committed polynomial <span class="math">p</span> evaluates to <span class="math">v</span> at a given point <span class="math">z\\in\\mathbb{F}_{q}</span>, it suffices to prove that the triple <span class="math">(C,z,v)</span> satisfies the following NP statement:</p>

    <p class="text-gray-300"><span class="math">\\exists\\,a_{0},\\ldots,a_{d}\\in\\mathbb{F}\\text{ s.t. }v=\\sum_{i=0}^{d}a_{i}z^{i}\\text{ and }\\,C=\\sum_{i=0}^{d}a_{i}G_{i}\\enspace.</span></p>

    <p class="text-gray-300">This is a special case of an <em>inner product argument</em> (IPA), as defined in <em>[x1]</em>, which proves the inner product of two committed vectors. The receiver simply verifies this inner product argument to check the evaluation. The fact that the vector <span class="math">(1,z,\\ldots,z^{d})</span> is known to the verifier and has a certain structure is exploited in the accumulation scheme that we describe below.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Accumulation scheme for the IPA.</h4>

    <p class="text-gray-300">Our accumulation scheme relies on a special structure of the IPA verifier: it generates <span class="math">O(\\log d)</span> challenges using the random oracle, then performs cheap checks requiring <span class="math">O(\\log d)</span> field and group operations, and finally performs an expensive check requiring <span class="math">\\Omega(d)</span> scalar multiplications. This latter check asserts consistency between the challenges and a group element <span class="math">U</span> contained in the proof. Hence, the IPA verifier is succinct <em>barring the expensive check</em>, and so constructing an accumulation scheme for the IPA reduces to the task of constructing an accumulation scheme for the expensive check involving <span class="math">U</span>.</p>

    <p class="text-gray-300">To do this, we rely on an idea of Bowe, Grigg, and Hopwood <em>[x2]</em>, which itself builds on an observation in <em>[x3]</em>. Namely, letting <span class="math">(\\xi_{1},\\ldots,\\xi_{\\log_{2}d})</span> be the protocol’s challenges, <span class="math">U</span> can be viewed as a commitment to the polynomial <span class="math">h(X):=\\prod_{i=0}^{\\log_{2}(d)-1}(1+\\xi_{\\log_{2}(d)-i}X^{2^{i}})\\in\\mathbb{F}_{q}^{\\leq d}[X]</span>. This polynomial has the special property that it can be evaluated at any point in just <span class="math">O(\\log d)</span> field operations (exponentially smaller than its degree <span class="math">d</span>). This allows transforming the expensive check on <span class="math">U</span> into a check that is amenable to batching: instead of directly checking that <span class="math">U</span> is a commitment to <span class="math">h</span>, one can instead check that the polynomial committed inside <span class="math">U</span> agrees with <span class="math">h</span> at a challenge point <span class="math">z</span> sampled via the random oracle.</p>

    <p class="text-gray-300">We leverage this idea as follows. When accumulating evaluation claims about multiple polynomials <span class="math">p_{1},\\ldots,p_{n}</span>, applying the foregoing transformation results in <span class="math">n</span> checks of the form “check that the polynomial contained in <span class="math">U_{i}</span> evaluates to <span class="math">h_{i}(z)</span> at the point <span class="math">z</span>”. Because these are all claims for the correct evaluation of the polynomials <span class="math">h_{i}</span> at <em>the same point <span class="math">z</span></em>, we can accumulate them via standard homomorphic techniques. We now summarize how we apply this idea to construct our accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>.</p>

    <p class="text-gray-300">Accumulators in our accumulation scheme have the same form as the instances to be accumulated: they are tuples of the form <span class="math">(C,z,v,\\pi)</span> where <span class="math">\\pi</span> is an evaluation proof for the claim “<span class="math">p(z)=v</span>” and <span class="math">p</span> is the polynomial committed in <span class="math">C</span>. For simplicity, below we consider the case of accumulating one old accumulator <span class="math">\\mathsf{acc}=(C_{1},z_{1},v_{1},\\pi_{1})</span> and one instance <span class="math">(C_{2},z_{2},v_{2},\\pi_{2})</span> into a new accumulator <span class="math">\\mathsf{acc}^{\\star}=(C,z,v,\\pi)</span>.</p>

    <p class="text-gray-300"><em>Accumulation prover <span class="math">\\mathrm{P}</span>:</em> compute the new accumulator <span class="math">\\mathsf{acc}^{\\star}=(C,z,v,\\pi)</span> from the old accumulator <span class="math">\\mathsf{acc}=(C_{1},z_{1},v_{1},\\pi_{1})</span> and the instance <span class="math">(C_{2},z_{2},v_{2},\\pi_{2})</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">U_{1},U_{2}</span> from <span class="math">\\pi_{1},\\pi_{2}</span> respectively. As described above, these elements can be viewed as commitments to polynomials <span class="math">h_{1},h_{2}</span> defined by the challenges derived from <span class="math">\\pi_{1},\\pi_{2}</span>.</li>

      <li>Use the random oracle <span class="math">\\rho</span> to compute the random challenge <span class="math">\\alpha:=\\rho([(h_{1},U_{1}),(h_{2},U_{2})])</span>.</li>

      <li>Compute <span class="math">C:=U_{1}+\\alpha U_{2}</span>, which is a polynomial commitment to <span class="math">p(X):=h_{1}(X)+\\alpha h_{2}(X)</span>.</li>

      <li>Compute the challenge point <span class="math">z:=\\rho(C,p)</span>, where <span class="math">p</span> is uniquely represented via the tuple <span class="math">([h_{1},h_{2}],\\alpha)</span>.</li>

      <li>Construct an evaluation proof <span class="math">\\pi</span> for the claim “<span class="math">p(z)=v</span>”. (This step is the only expensive one.)</li>

      <li>Output the new accumulator <span class="math">\\mathsf{acc}^{\\star}:=(C,z,v,\\pi)</span>.</li>

    </ul>

    <p class="text-gray-300"><em>Accumulation verifier <span class="math">\\mathrm{V}</span>:</em> to check that the new accumulator <span class="math">\\mathsf{acc}^{\\star}=(C,z,v,\\pi)</span> was correctly generated from the old accumulator <span class="math">\\mathsf{acc}=(C_{1},z_{1},v_{1},\\pi_{1})</span> and the instance <span class="math">(C_{2},z_{2},v_{2},\\pi_{2})</span>, first compute the challenges <span class="math">\\alpha</span> and <span class="math">z</span> from the random oracle as above, and then check that (a) <span class="math">(C_{1},z_{1},v_{1},\\pi_{1})</span> and <span class="math">(C_{2},z_{2},v_{2},\\pi_{2})</span> pass the cheap checks of the IPA verifier, (b) <span class="math">C=U_{1}+\\alpha U_{2}</span>, and (c) <span class="math">h_{1}(z)+\\alpha h_{2}(z)=v</span>.</p>

    <p class="text-gray-300"><em>Decider <span class="math">\\mathrm{D}</span>:</em> on input the (final) accumulator <span class="math">\\mathsf{acc}^{\\star}=(C,z,v,\\pi)</span>, check that <span class="math">\\pi</span> is a valid evaluation proof for the claim that the polynomial committed inside <span class="math">C</span> evaluates to <span class="math">v</span> at the point <span class="math">z</span>.</p>

    <p class="text-gray-300">This construction achieves the efficiency summarized in Theorem 3.</p>

    <p class="text-gray-300">We additionally achieve zero knowledge accumulation for the hiding variant of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> (also described in Appendix A). Informally, the accumulation prover randomizes <span class="math">\\mathsf{acc}^{\\star}</span> by including a new random polynomial</p>

    <p class="text-gray-300"><span class="math">h_{0}</span> in the accumulation step. This ensures that the evaluation claim in <span class="math">\\mathsf{acc}^{\\star}</span> is for a random polynomial, thus hiding all information about the original evaluation claims. To allow the accumulation verifier to check that this randomization was performed correctly, the prover includes <span class="math">h_{0}</span> in an auxiliary proof <span class="math">\\pi_{\\mathrm{V}}</span>.</p>

    <p class="text-gray-300">In Section 7, we show how to extend the above accumulation scheme to accumulate any number of old accumulators and instances. Our security proof for the resulting accumulation scheme relies on the hardness of zero-finding games (Lemma 3.3), and the security of <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">2.4.2 Accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span></h4>

    <p class="text-gray-300">We sketch our accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span>. Checking an evaluation proof in <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span> requires 1 pairing, and so checking <span class="math">n</span> evaluation proofs requires <span class="math">n</span> pairings. <span class="math">\\mathsf{AS}</span> improves upon this as follows: the accumulation verifier <span class="math">\\mathrm{V}</span> only performs <span class="math">O(n)</span> scalar multiplications in <span class="math">\\mathbb{G}_{1}</span> in order to check the accumulation of <span class="math">n</span> evaluation proofs, while the decider <span class="math">\\mathrm{D}</span> performs only a single pairing in order to check the resulting accumulator. This is much cheaper: it reduces the number of pairings from <span class="math">n</span> to <span class="math">1</span>, and also defers this single pairing to the end of the accumulation (the decider). In particular, when instantiating the PCD construction outlined in Section 2.1 with a <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span>-based SNARK and our accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span>, we can eliminate <em>all</em> pairings from the circuit being verified in the PCD construction.</p>

    <p class="text-gray-300">Below we explain how standard techniques for batching pairings using random linear combinations <em>[x1]</em> allow us to realize an accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span> with these desirable properties.</p>

    <p class="text-gray-300">Summary of <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span>. The committer key <span class="math">\\mathsf{ck}</span> and receiver key <span class="math">\\mathsf{rk}</span> for a given maximum degree bound <span class="math">D</span> are group elements from a bilinear group <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,G,H,e)</span>: <span class="math">\\mathsf{ck}:=\\{G,\\beta G,\\ldots,\\beta^{D}G\\}\\in\\mathbb{G}_{1}^{D+1}</span> consists of group elements encoding powers of a random field element <span class="math">\\beta</span>, while <span class="math">\\mathsf{rk}:=(G,H,\\beta H)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}^{2}</span>.</p>

    <p class="text-gray-300">A commitment to a polynomial <span class="math">p\\in\\mathbb{F}_{q}^{&lt;D}[X]</span> is the group element <span class="math">C:=p(\\beta)G\\in\\mathbb{G}_{1}</span>. To prove that <span class="math">p</span> evaluates to <span class="math">v</span> at a given point <span class="math">z\\in\\mathbb{F}_{q}</span>, the sender computes a “witness polynomial” <span class="math">w(X):=(p(X)-v)/(X-z)</span>, and outputs the evaluation proof <span class="math">\\pi:=w(\\beta)G\\in\\mathbb{G}_{1}</span>. The receiver can check this proof by checking the pairing equation <span class="math">e(C-vG,H)=e(\\pi,\\beta H-zH)</span>. This pairing equation is the focus of our accumulation scheme below. (This summary omits details about degree enforcement and about hiding.)</p>

    <p class="text-gray-300">Accumulation scheme. We construct an accumulation scheme <span class="math">\\mathsf{AS}=(\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> for <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span> by relying on standard techniques for batching pairing equations. Suppose that we wish to simultaneously check the validity of <span class="math">n</span> instances <span class="math">[(C_{i},z_{i},v_{i},\\pi_{i})]_{i=1}^{n}</span>. First, rewrite the pairing check for the <span class="math">i</span>-th instance as follows:</p>

    <p class="text-gray-300"><span class="math">e(C_{i}-v_{i}G,H)=e(\\pi_{i},\\beta H-z_{i}H)\\ \\Longleftrightarrow\\ e(C_{i}-v_{i}G+z_{i}\\pi_{i},H)=e(\\pi_{i},\\beta H)\\ \\ .</span> (1)</p>

    <p class="text-gray-300">After the rewrite, the <span class="math">\\mathbb{G}_{2}</span> inputs to both pairings do not depend on the claim being checked. This allows batching the pairing checks by taking a random linear combination with respect to a random challenge <span class="math">r:=\\rho([C_{i},z_{i},v_{i},\\pi_{i}]_{i=1}^{n})</span> computed from the random oracle, resulting in the following combined equation:</p>

    <p class="text-gray-300"><span class="math">e(\\sum_{i=1}^{n}r^{i}(C_{i}-v_{i}G+z_{i}\\pi_{i}),H)=e(\\sum_{i=1}^{n}r^{i}\\pi_{i},\\beta H)\\ \\ .</span> (2)</p>

    <p class="text-gray-300">We now have a pairing equation involving an “accumulated commitment” <span class="math">C^{\\star}:=\\sum_{i=1}^{n}r^{i}(C_{i}-v_{i}G+z_{i}\\pi_{i})</span> and an “accumulated proof” <span class="math">\\pi^{\\star}:=\\sum_{i=1}^{n}r^{i}\\pi_{i}</span>. This observation leads to the accumulation scheme below.</p>

    <p class="text-gray-300">An accumulator in <span class="math">\\mathsf{AS}</span> consists of a commitment-proof pair <span class="math">(C^{\\star},\\pi^{\\star})</span>, which the decider <span class="math">\\mathrm{D}</span> validates by checking that <span class="math">e(C^{\\star},H)=e(\\pi^{\\star},\\beta H)</span>. Moreover, observe that by Eq. (1), checking the validity of a claimed evaluation <span class="math">(C,z,v,\\pi)</span> within <span class="math">\\mathsf{PC}_{\\textsc{agm}}</span> corresponds to checking that the “accumulator” <span class="math">(C-vG+z\\pi,\\pi)</span> is accepted by the decider <span class="math">\\mathrm{D}</span>. Thus we can restrict our discussion to accumulating <em>accumulators</em>.</p>

    <p class="text-gray-300">The accumulation prover <span class="math">\\mathrm{P}</span>, on input a list of old accumulators <span class="math">[\\mathsf{acc}_{i}]_{i=1}^{n}=[(C^{\\star}_{i},\\pi^{\\star}_{i})]_{i=1}^{n}</span>, computes a random challenge <span class="math">r:=\\rho([\\mathsf{acc}_{i}]_{i=1}^{n})</span>, constructs <span class="math">C^{\\star}:=\\sum_{i=1}^{n}r^{i}C^{\\star}_{i}</span> and <span class="math">\\pi^{\\star}:=\\sum_{i=1}^{n}r^{i}\\pi^{\\star}_{i}</span>, and outputs</p>

    <p class="text-gray-300">the new accumulator <span class="math">\\mathsf{acc}^{\\star}:=(C^{\\star},\\pi^{\\star})\\in\\mathbb{G}_{1}^{2}</span>. To check that <span class="math">\\mathsf{acc}^{\\star}</span> accumulates <span class="math">[\\mathsf{acc}_{i}]_{i=1}^{n}</span>, the accumulation verifier <span class="math">\\mathrm{V}</span> simply invokes <span class="math">\\mathrm{P}</span> and checks that its output matches the claimed new accumulator <span class="math">\\mathsf{acc}^{\\star}</span>.</p>

    <p class="text-gray-300">To achieve zero knowledge accumulation, the accumulation prover randomizes <span class="math">\\mathsf{acc}^{\\star}</span> by including in it an extra “old” accumulator corresponding to a random polynomial, which statistically hides the accumulated claims. To allow the accumulation verifier to check that this randomization was performed correctly, the prover includes this old accumulator in an auxiliary proof <span class="math">\\pi_{\\mathrm{V}}</span>.</p>

    <p class="text-gray-300">This construction achieves the efficiency summarized in Theorem 3.</p>

    <p class="text-gray-300">In Section 8, we show how to extend the above accumulation scheme to account for additional features of <span class="math">\\mathsf{PC}_{\\text{\\tiny AGM}}</span> (degree enforcement and hiding). Our security proof for the resulting accumulation scheme relies on the hardness of zero-finding games (Lemma 3.3).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Indexed relations. An indexed relation  <span class="math">\\mathcal{R}</span>  is a set of triples  <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})</span>  where  <span class="math">\\mathfrak{i}</span>  is the index,  <span class="math">\\mathfrak{x}</span>  is the instance, and  <span class="math">\\mathfrak{w}</span>  is the witness; the corresponding indexed language  <span class="math">\\mathcal{L}(\\mathcal{R})</span>  is the set of pairs  <span class="math">(\\mathfrak{i},\\mathfrak{x})</span>  for which there exists a witness  <span class="math">\\mathfrak{w}</span>  such that  <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w}) \\in \\mathcal{R}</span> . For example, the indexed relation of satisfiable boolean circuits consists of triples where  <span class="math">\\mathfrak{i}</span>  is the description of a boolean circuit,  <span class="math">\\mathfrak{x}</span>  is a partial assignment to its input wires, and  <span class="math">\\mathfrak{w}</span>  is an assignment to the remaining wires that makes the circuit to output 0.</p>

    <p class="text-gray-300">Security parameters. For simplicity of notation, we assume that all public parameters have length at least  <span class="math">\\lambda</span> , so that algorithms which receive such parameters can run in time  <span class="math">\\mathrm{poly}(\\lambda)</span> .</p>

    <p class="text-gray-300">Random oracles. We denote by  <span class="math">\\mathcal{U}(\\lambda)</span>  the set of all functions that map  <span class="math">\\{0,1\\}^<em></span>  to  <span class="math">\\{0,1\\}^\\lambda</span> . We denote by  <span class="math">\\mathcal{U}(</em>)</span>  the set  <span class="math">\\bigcup_{\\lambda \\in \\mathbb{N}} \\mathcal{U}(\\lambda)</span> . A random oracle with security parameter  <span class="math">\\lambda</span>  is a function  <span class="math">\\rho: \\{0,1\\}^* \\to \\{0,1\\}^\\lambda</span>  sampled uniformly at random from  <span class="math">\\mathcal{U}(\\lambda)</span> .</p>

    <p class="text-gray-300">A tuple of algorithms  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  is a (preprocessing) non-interactive argument in the random oracle model (ROM) for an indexed relation  <span class="math">\\mathcal{R}</span>  if the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every adversary  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {w}) \\notin \\mathcal {R} &amp;amp; \\mathfrak {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\vee &amp;amp; (\\mathfrak {i}, \\mathfrak {x}, \\mathfrak {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathfrak {p p}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathfrak {x}, \\pi) = 1 &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathfrak {p p}, \\mathfrak {i}) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k}, \\mathfrak {x}, \\mathfrak {w}) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For every polynomial-size adversary  <span class="math">\\tilde{\\mathcal{P}}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\mathfrak {i}, \\mathfrak {x}) \\notin \\mathcal {L} (\\mathcal {R}) &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\wedge &amp;amp; \\mathfrak {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathcal {V} ^ {\\rho} (\\mathrm {i v k}, \\mathfrak {x}, \\pi) = 1 &amp;amp; (\\mathfrak {i}, \\mathfrak {x}, \\pi) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathfrak {p p}) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathfrak {p p}, \\mathfrak {i}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">The above formulation of completeness allows  <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})</span>  to depend on the random oracle  <span class="math">\\rho</span>  and public parameters  <span class="math">\\mathfrak{pp}</span> , and the above formulation of soundness allows  <span class="math">(\\mathfrak{i},\\mathfrak{x})</span>  to depend on the random oracle  <span class="math">\\rho</span>  and public parameters  <span class="math">\\mathfrak{pp}</span> .</p>

    <p class="text-gray-300">Our PCD construction makes use of the stronger property of knowledge soundness, and optionally also the property of (statistical) zero knowledge. We define both of these properties below. Note that this definition is stronger the standard definition of knowledge soundness; this is required to prove post-quantum security in Theorem 5.2. This stronger definition is similar to the notion of witness-extended emulation [Lin03].</p>

    <p class="text-gray-300">Knowledge soundness. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has knowledge soundness if for every polynomial-size adversary  <span class="math">\\tilde{\\mathcal{P}}</span>  and every polynomial-size auxiliary input distribution  <span class="math">\\mathcal{D}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\forall j \\in [ \\ell ], \\left(\\mathcal {V} ^ {\\rho} (\\mathrm {i v k} _ {j}, \\mathfrak {x} _ {j}, \\pi_ {j}) = 1 \\right. &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\downarrow &amp;amp; \\mathfrak {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ (\\mathfrak {i} _ {j}, \\mathfrak {x} _ {j}, \\mathfrak {w} _ {j}) \\in \\mathcal {R}) &amp;amp; z \\leftarrow \\mathcal {D} ^ {\\rho} (\\mathfrak {p p}) \\\\ &amp;amp; (\\vec {\\mathfrak {i}}, \\vec {\\mathfrak {x}}, \\vec {\\pi}, \\mathsf {a u x}, \\vec {\\mathfrak {w}}) \\leftarrow \\mathcal {E} ^ {\\rho} (\\mathfrak {p p}, z) \\\\ &amp;amp; \\forall j, (\\mathrm {i p k} _ {j}, \\mathrm {i v k} _ {j}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathfrak {p p}, \\mathfrak {i} _ {j}) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">and, moreover, the following distributions are statistically close (as a function of  <span class="math">\\lambda</span> )</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{c c} (\\rho , \\mathsf {p p}, \\vec {\\mathbb {i}}, &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\vec {\\mathbb {x}}, \\vec {\\pi}, \\mathsf {a u x}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ &amp;amp; z \\leftarrow \\mathcal {D} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\vec {\\mathbb {i}}, \\vec {\\mathbb {x}}, \\vec {\\pi}, \\mathsf {a u x}) \\leftarrow \\tilde {\\mathcal {P}} ^ {\\rho} (\\mathsf {p p}, z) \\end{array} \\right\\} \\quad \\text {a n d} \\quad \\left\\{ \\begin{array}{c c} (\\rho , \\mathsf {p p}, \\vec {\\mathbb {i}}, &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\vec {\\mathbb {x}}, \\vec {\\pi}, \\mathsf {a u x}) &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ &amp;amp; z \\leftarrow \\mathcal {D} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\vec {\\mathbb {i}}, \\vec {\\mathbb {x}}, \\vec {\\pi}, \\mathsf {a u x}, \\vec {\\mathsf {w}}) \\leftarrow \\mathcal {E} ^ {\\rho} (\\mathsf {p p}, z) \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">The above definition is polynomially related to the standard definition of adaptive knowledge soundness, which does not consider a vector of outputs or an auxiliary output by the prover.</p>

    <p class="text-gray-300">Zero knowledge. We say that  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">S</span>  such that for every polynomial-size honest adversary  <span class="math">\\mathcal{A}</span>  the distributions below are computationally indistinguishable:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\rho , \\mathsf {p p}, \\mathbb {i}, \\mathbb {x}, \\pi) &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ &amp;amp; (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {I} ^ {\\rho} (\\mathsf {p p}, \\mathbb {i}) \\\\ &amp;amp; \\pi \\leftarrow \\mathcal {P} ^ {\\rho} (\\mathrm {i p k}, \\mathbb {x}, \\mathbb {w}) \\end{array} \\right\\} \\quad \\text {a n d} \\quad \\left\\{ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ (\\mathsf {p p}, \\tau) \\leftarrow \\mathcal {S} ^ {\\rho} (\\mathbb {i}, \\mathbb {x}) \\\\ (\\mathbb {i}, \\mathbb {x}, \\mathbb {w}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ (\\pi , \\mu) \\leftarrow \\mathcal {S} ^ {\\rho} (\\mathsf {p p}, \\mathbb {i}, \\mathbb {x}, \\tau) \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Above,  <span class="math">\\rho[\\mu]</span>  is the function that, on input  <span class="math">x</span> , equals  <span class="math">\\mu(x)</span>  if  <span class="math">\\mu</span>  is defined on  <span class="math">x</span> , or  <span class="math">\\rho(x)</span>  otherwise. This definition uses explicitly-programmable random oracles [BR93]. (Non-interactive zero knowledge with non-programmable random oracles is impossible for non-trivial languages [Pas03; BCS16].)</p>

    <p class="text-gray-300">A triple of algorithms  <span class="math">\\mathsf{PCD} = (\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>  is a (preprocessing) proof-carrying data scheme (PCD scheme) for a class of compliance predicates  <span class="math">\\mathsf{F}</span>  if the properties below hold.</p>

    <p class="text-gray-300">Definition 3.1. A transcript  <span class="math">\\mathsf{T}</span>  is a directed acyclic graph where each vertex  <span class="math">u\\in V(\\mathsf{T})</span>  is labeled by local data  <span class="math">z_{\\mathrm{loc}}^{(u)}</span>  and each edge  <span class="math">e\\in E(\\mathsf{T})</span>  is labeled by a message  <span class="math">z^{(e)}\\neq \\bot</span> . The output of a transcript  <span class="math">\\mathsf{T}</span> , denoted  <span class="math">\\mathsf{o}(\\mathsf{T})</span> , is  <span class="math">z^{(e)}</span>  where  <span class="math">e = (u,v)</span>  is the lexicographically-first edge such that  <span class="math">v</span>  is a sink.</p>

    <p class="text-gray-300">Definition 3.2. A vertex  <span class="math">u \\in V(\\mathsf{T})</span>  is  <span class="math">\\varphi</span> -compliant for  <span class="math">\\varphi \\in \\mathsf{F}</span>  if for all outgoing edges  <span class="math">e = (u, v) \\in E(\\mathsf{T})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(base case) if  <span class="math">u</span>  has no incoming edges,  <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, \\bot, \\ldots, \\bot)</span>  accepts;</li>

      <li>(recursive case) if  <span class="math">u</span>  has incoming edges  <span class="math">e_1, \\ldots, e_m</span> ,  <span class="math">\\varphi(z^{(e)}, z_{\\mathrm{loc}}^{(u)}, z^{(e_1)}, \\ldots, z^{(e_m)})</span>  accepts.</li>

    </ul>

    <p class="text-gray-300">We say that  <span class="math">\\mathsf{T}</span>  is  <span class="math">\\varphi</span> -compliant if all of its vertices are  <span class="math">\\varphi</span> -compliant.</p>

    <p class="text-gray-300">Completeness. For every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\left(\\varphi \\in \\mathsf {F} \\wedge \\left(\\forall i, z _ {i} = \\bot \\lor \\forall i, \\mathbb {V} (\\mathsf {i v k}, z _ {i}, \\pi_ {i}) = 1\\right) \\wedge \\right. &amp;amp; \\mathbb {P P} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ \\varphi (z, z _ {\\mathsf {l o c}}, z _ {1}, \\ldots , z _ {m}) \\mathsf {a c c e p t s} \\\\ \\Downarrow &amp;amp; (\\varphi , z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathbb {P P}) \\\\ \\mathbb {V} (\\mathsf {i v k}, z, \\pi) = 1 &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathbb {P P}, \\varphi) \\\\ &amp;amp; \\pi \\leftarrow \\mathbb {P} (\\mathsf {i p k}, z, z _ {\\mathsf {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Knowledge soundness. We say that  <span class="math">\\mathsf{PCD} = (\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>  has knowledge soundness if there exists some polynomial  <span class="math">e</span>  such that for every polynomial-size adversary  <span class="math">\\tilde{\\mathbb{P}}</span> , there exists an extractor  <span class="math">\\mathbb{E}</span>  of size at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbb{P}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\left(\\varphi \\in \\mathsf {F} \\wedge \\mathbb {V} (\\mathsf {i v k}, \\mathsf {o} (\\mathsf {T}), \\pi) = 1\\right) &amp;amp; \\mathfrak {p p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; (\\varphi , \\pi , \\mathsf {T}) \\leftarrow \\mathbb {E} (\\mathfrak {p p}) \\\\ \\mathsf {T} \\text {i s} \\varphi \\text {- c o m p l i a n t} &amp;amp; (\\mathsf {i p k}, \\mathsf {i v k}) \\leftarrow \\mathbb {I} (\\mathfrak {p p}, \\varphi) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">and, moreover, the following distributions are statistically close:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{(\\varphi , \\mathsf {o}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathbb {p p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ (\\varphi , \\mathsf {o}, \\pi) \\leftarrow \\tilde {\\mathbb {P}} (\\mathbb {p p}) \\end{array} \\right. \\right\\} \\quad \\text {a n d} \\quad \\left\\{(\\varphi , \\mathsf {o} (\\mathsf {T}), \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathbb {p p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ (\\varphi , \\pi , \\mathsf {T}) \\leftarrow \\mathbb {E} (\\mathbb {p p}) \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Zero knowledge. We say that  <span class="math">\\mathsf{PCD} = (\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  <span class="math">\\mathbb{S}</span>  such that for every polynomial-size honest adversary  <span class="math">\\mathcal{A}</span>  the distributions below are computationally indistinguishable:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{c} \\mathbb {p p} \\leftarrow \\mathbb {G} (1 ^ {\\lambda}) \\\\ (\\mathbb {p p}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathbb {p p}) \\\\ (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathbb {I} (\\mathbb {p p}, \\varphi) \\\\ \\pi \\leftarrow \\mathbb {P} (\\mathrm {i p k}, \\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\end{array} \\right\\} \\quad \\text {a n d} \\quad \\left\\{ \\begin{array}{c} (\\mathbb {p p}, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathbb {p p}, \\tau) \\leftarrow \\mathbb {S} \\\\ (\\varphi , z, z _ {\\mathrm {l o c}}, [ z _ {i}, \\pi_ {i} ] _ {i = 1} ^ {m}) \\leftarrow \\mathcal {A} (\\mathbb {p p}) \\\\ \\pi \\leftarrow \\mathbb {S} (\\varphi , z, \\tau) \\end{array} \\right. \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In this case,  <span class="math">\\mathcal{A}</span>  is honest if it outputs, with probability 1,  <span class="math">(\\varphi ,z,z_{\\mathrm{loc}},[z_i,\\pi_i]_{i = 1}^m)</span>  such that  <span class="math">\\varphi \\in \\mathsf{F},\\mathbb{V}(\\mathsf{ivk},z_i,\\pi_i) = 1</span>  for all  <span class="math">i</span> , and  <span class="math">\\varphi (z,z_{\\mathrm{loc}},z_1,\\ldots ,z_m)</span>  accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The generator  <span class="math">\\mathbb{G}</span> , prover  <span class="math">\\mathbb{P}</span> , indexer  <span class="math">\\mathbb{I}</span>  and verifier  <span class="math">\\mathbb{V}</span>  run in polynomial time. A proof  <span class="math">\\pi</span>  has size  $\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ; in particular, it is not permitted to grow with each application of  </span>\\mathbb{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-24" class="text-2xl font-bold">3.3 Instantiating the random oracle</h2>

    <p class="text-gray-300">Almost all of the results in this paper are proved in the random oracle model, and so we give definitions which include random oracles. The single exception is our construction of proof-carrying data, in Section 5.1. We do not know how to build PCD schemes which are secure in the random oracle model from any standard assumption. Instead, we show that assuming the existence of a non-interactive argument with security in the standard (CRS) model, we obtain a PCD scheme which is also secure in the standard (CRS) model.</p>

    <p class="text-gray-300">For this reason, the definition of PCD above is stated in the standard model (without oracles). We do not explicitly define non-interactive arguments in the standard model; the definition is easily obtained by removing the random oracle from the definition presented in Section 3.1.</p>

    <h2 id="sec-25" class="text-2xl font-bold">3.4 Post-quantum security</h2>

    <p class="text-gray-300">The definitions of both non-interactive arguments (in the standard model) and proof-carrying data can be strengthened, in a straightforward way, to express post-quantum security. In particular, we replace "polynomial-size circuit" and "polynomial-time algorithm" with their quantum analogues. Since we do not prove post-quantum security of any construction in the random oracle model, we do not discuss the quantum random oracle model.</p>

    <p class="text-gray-300">A commitment scheme  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit})</span>  enables one to create binding commitments to messages.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CM.Setup, on input a message format  <span class="math">L</span> , outputs public parameters  <span class="math">\\mathsf{pp}</span> ; this specifies a message universe  <span class="math">\\mathcal{M}_{\\mathsf{pp}}</span>  and a commitment universe  <span class="math">\\mathcal{C}_{\\mathsf{pp}}</span> .</li>

      <li>CM.Trim, on input public parameters pp and a trim specification  <span class="math">\\ell</span> , outputs a commitment key ck containing a description of a message space  <span class="math">\\mathcal{M}_{\\mathrm{ck}} \\subseteq \\mathcal{M}_{\\mathrm{pp}}</span>  (corresponding to  <span class="math">\\ell</span> ).</li>

      <li>CM.Commit, on input a commitment key ck, a message  <span class="math">m \\in \\mathcal{M}_{\\mathrm{ck}}</span>  and randomness  <span class="math">\\omega</span> , outputs a commitment  <span class="math">C \\in \\mathcal{C}_{\\mathrm{pp}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CM is binding if, for every message format  <span class="math">L</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda)<span class="math"> , and for every efficient adversary  </span>\\mathcal{A}$ , the following holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} m _ {1} \\in \\mathcal {M} _ {\\mathrm {c k} _ {1}}, m _ {2} \\in \\mathcal {M} _ {\\mathrm {c k} _ {2}}, m _ {1} \\neq m _ {2} &amp;amp; \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {C M . S e t u p} ^ {\\rho} (1 ^ {\\lambda}, L) \\\\ (\\ell_ {1}, m _ {1}, \\omega_ {1}), (\\ell_ {2}, m _ {2}, \\omega_ {2})) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ \\wedge &amp;amp; \\mathsf {c k} _ {1} \\leftarrow \\mathsf {C M . T r i m} ^ {\\rho} (\\mathsf {p p}, \\ell_ {1}) \\\\ \\mathsf {c k} _ {2} \\leftarrow \\mathsf {C M . T r i m} ^ {\\rho} (\\mathsf {p p}, \\ell_ {2}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Note that  <span class="math">m_{1}\\neq m_{2}</span>  is well-defined since  <span class="math">\\mathcal{M}_{\\mathrm{ck}_1},\\mathcal{M}_{\\mathrm{ck}_2}\\subseteq \\mathcal{M}_{\\mathrm{pp}}</span></p>

    <p class="text-gray-300">We now give a useful lemma, which bounds the probability that applying the random oracle to a commitment to a polynomial yields a zero of that polynomial. We refer to this as a zero-finding game.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 3.3. Let  <span class="math">F\\colon \\mathbb{N}\\to \\mathbb{N}</span> , and  <span class="math">\\mathsf{CM} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit})</span>  be a commitment scheme. Fix a number of variables  <span class="math">M\\in \\mathbb{N}</span>  and maximum degree  <span class="math">N\\in \\mathbb{N}</span> . Then for every family of (not necessarily efficient) functions  <span class="math">\\{f_{\\mathsf{pp}}\\}_{\\mathsf{pp}}</span>  and fields  <span class="math">\\{\\mathbb{F}_{\\mathsf{pp}}\\}_{\\mathsf{pp}}</span>  where  <span class="math">f_{\\mathsf{pp}}\\colon \\mathcal{M}_{\\mathsf{pp}}\\to \\mathbb{F}_{\\mathsf{pp}}^{\\leq N}[X_1,\\ldots ,X_M]</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{\\mathsf{pp}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq F(\\lambda)<span class="math"> ; for every message format  </span>L<span class="math">  and efficient  </span>t<span class="math"> -query oracle algorithm  </span>\\mathcal{A}$ , the following holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ p \\not \\equiv 0 &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {C M . S e t u p} (1 ^ {\\lambda}, L) \\\\ \\wedge &amp;amp; (\\ell , \\mathfrak {p} \\in \\mathcal {M} _ {\\mathsf {c k}}, \\omega) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ p (z) = 0 &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {C M . T r i m} (\\mathsf {p p}, \\ell) \\\\ &amp;amp; C \\leftarrow \\mathsf {C M . C o m m i t} (\\mathsf {c k}, \\mathfrak {p}; \\omega) \\\\ &amp;amp; z \\in \\mathbb {F} _ {\\mathsf {p p}} ^ {N} \\leftarrow \\rho (C) \\\\ &amp;amp; p \\leftarrow f _ {\\mathsf {p p}} (\\mathfrak {p}) \\end{array} \\right] \\leq \\sqrt {(t + 1) \\cdot \\frac {M N}{F (\\lambda)}} + \\operatorname {n e g l} (\\lambda) .</span></div>

    <p class="text-gray-300">If CM is perfectly binding, then the above holds also for computationally-unbounded  <span class="math">t</span> -query adversaries  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathcal{A}</span>  be an adversary which wins with probability  <span class="math">\\delta</span>  in the above game; we construct an adversary  <span class="math">\\mathcal{B}</span>  which breaks the binding of the commitment scheme with probability at least  <span class="math">\\delta^2 / (t + 1) - \\frac{MN}{F(\\lambda)}</span> .</p>

    <p class="text-gray-300">Note first that we may assume that  <span class="math">\\mathcal{A}</span>  always queries  <span class="math">C\\gets \\mathsf{CM. Commit}(\\mathsf{ck},\\mathfrak{p};\\omega)</span>  for its output  <span class="math">(\\mathfrak{p},\\omega)</span> , by increasing the query bound from  <span class="math">t</span>  to  <span class="math">t + 1</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run  <span class="math">(\\ell, \\mathfrak{p}, \\omega) \\gets \\mathcal{A}^{\\rho}(\\mathsf{pp})</span> , simulating its queries to  <span class="math">\\rho</span> .</li>

      <li>Compute  <span class="math">\\mathsf{ck}\\gets \\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp},\\ell)</span></li>

      <li>Obtain  <span class="math">C \\gets \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, \\mathfrak{p}; \\omega)</span> .</li>

      <li>Rewind  <span class="math">\\mathcal{A}</span>  to the query  <span class="math">\\rho(C)</span>  and run to the end, drawing fresh randomness for this and subsequent oracle queries, to obtain  <span class="math">(\\ell&#x27;, \\mathfrak{p}&#x27;, \\omega&#x27;)</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">((\\ell,\\mathfrak{p},\\omega),(\\ell^{\\prime},\\mathfrak{p}^{\\prime},\\omega^{\\prime}))</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ck}^{\\prime}:=\\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp},\\ell^{\\prime})</span>, <span class="math">C^{\\prime}:=\\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}^{\\prime},\\mathfrak{p}^{\\prime};\\omega^{\\prime})</span>, <span class="math">\\bm{z}:=\\rho(C)</span>, <span class="math">\\bm{z}^{\\prime}:=\\rho(C^{\\prime})</span>, <span class="math">p:=f_{\\mathsf{pp}}(\\mathfrak{p})</span> and <span class="math">p^{\\prime}:=f_{\\mathsf{pp}}(\\mathfrak{p}^{\\prime})</span>. By the forking lemma, the probability that <span class="math">p(\\bm{z})=p^{\\prime}(\\bm{z}^{\\prime})=0</span> and <span class="math">C=C^{\\prime}</span> is at least <span class="math">\\delta^{2}/(t+1)</span>; call this event <span class="math">E</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\Pr[E]\\leq\\Pr[E\\wedge(p=p^{\\prime})]+\\Pr[E\\wedge(p\\neq p^{\\prime})]\\leq MN/F(\\lambda)+\\Pr[E\\wedge(\\mathfrak{p}\\neq\\mathfrak{p}^{\\prime})]\\enspace.</span></p>

    <p class="text-gray-300">The lemma follows by noting that <span class="math">E\\wedge(\\mathfrak{p}\\neq\\mathfrak{p}^{\\prime})</span> implies that <span class="math">\\mathcal{B}</span> breaks the binding property of <span class="math">\\mathsf{CM}</span>. ∎</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 3.4.</h6>

    <p class="text-gray-300">For Lemma 3.3 to hold, the algorithms of <span class="math">\\mathsf{CM}</span> <em>must not</em> have access to the random oracle <span class="math">\\rho</span> used to generate the challenge point <span class="math">\\bm{z}</span>. The lemma is otherwise black-box with respect to <span class="math">\\mathsf{CM}</span>, and so <span class="math">\\mathsf{CM}</span> itself may use other oracles. The lemma continues to hold when <span class="math">\\mathcal{A}</span> has access to these additional oracles. We use this fact later to justify the security of domain separation.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">3.6 Polynomial commitments</h3>

    <p class="text-gray-300">A polynomial commitment scheme is a cryptographic primitive that enables a sender to commit to a polynomial <span class="math">p</span> over a field <span class="math">\\mathbb{F}</span> and then later prove the correct evaluation of the polynomial at a desired point. In more detail, a polynomial commitment scheme <span class="math">\\mathsf{PC}</span> is a tuple of algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Check})</span> with the following syntax and properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}.\\mathsf{Setup}^{\\rho}(1^{\\lambda},D)\\to\\mathsf{pp}</span>. On input a security parameter <span class="math">\\lambda</span> (in unary), and a maximum degree bound <span class="math">D\\in\\mathbb{N}</span>, <span class="math">\\mathsf{PC}.\\mathsf{Setup}</span> samples public parameters <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span>. The parameters contain the description of a finite field <span class="math">\\mathbb{F}</span> (which has size that is super-polynomial in <span class="math">\\lambda</span>).</li>

      <li><span class="math">\\mathsf{PC}.\\mathsf{Trim}^{\\rho}(\\mathsf{pp},[d_{i}]_{i=1}^{n})\\to(\\mathsf{ck},\\mathsf{rk})</span>. On input public parameters <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span>, and degree bounds <span class="math">[d_{i}]_{i=1}^{n}</span>, <span class="math">\\mathsf{PC}.\\mathsf{Trim}</span> deterministically computes a key pair <span class="math">(\\mathsf{ck},\\mathsf{rk})</span> that is specialized to <span class="math">[d_{i}]_{i=1}^{n}</span>.</li>

      <li><span class="math">\\mathsf{PC}.\\mathsf{Commit}^{\\rho}(\\mathsf{ck},p,d;\\omega)\\to C</span>. On input <span class="math">\\mathsf{ck}</span>, a univariate polynomial <span class="math">p</span> over the field <span class="math">\\mathbb{F}</span>, and a degree bound <span class="math">d</span> such that <span class="math">\\deg(p)\\leq d\\in[d_{i}]_{i=1}^{n}</span>, <span class="math">\\mathsf{PC}.\\mathsf{Commit}</span> outputs a commitment <span class="math">C</span> to the polynomial <span class="math">p</span>. The randomness <span class="math">\\omega</span> is used if the commitment <span class="math">C</span> is hiding.</li>

      <li><span class="math">\\mathsf{PC}.\\mathsf{Open}^{\\rho}(\\mathsf{ck},p,C,d,z;\\omega)\\to\\pi</span>. On input the commitment key <span class="math">\\mathsf{ck}</span>, a univariate polynomial <span class="math">p</span> over the field <span class="math">\\mathbb{F}</span>, a commitment <span class="math">C</span> to <span class="math">p</span>, a degree bound <span class="math">d</span>, an evaluation point <span class="math">z</span>, and commitment randomness <span class="math">\\omega</span>, <span class="math">\\mathsf{PC}.\\mathsf{Open}</span> outputs an evaluation proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{PC}.\\mathsf{Check}^{\\rho}(\\mathsf{rk},C,d,z,v,\\pi)\\to b</span>. On input the receiver key <span class="math">\\mathsf{rk}</span>, a commitment <span class="math">C</span>, a degree bound <span class="math">d</span>, an evaluation point <span class="math">z</span>, a claimed evaluation <span class="math">v</span>, and an evaluation proof <span class="math">\\pi</span>, <span class="math">\\mathsf{PC}.\\mathsf{Check}</span> checks that the degree bound <span class="math">d\\in[d_{i}]_{i=1}^{n}</span>, and outputs <span class="math">1</span> if <span class="math">\\pi</span> attests that the polynomial <span class="math">p</span> committed in <span class="math">C</span> has degree at most <span class="math">d</span> and evaluates to <span class="math">v</span> at <span class="math">z</span>.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme <span class="math">\\mathsf{PC}</span> must be such that <span class="math">(\\mathsf{PC}.\\mathsf{Setup},\\mathsf{PC}.\\mathsf{Trim},\\mathsf{PC}.\\mathsf{Commit})</span> is a (binding) commitment scheme for bounded-degree polynomials over a field. The message format <span class="math">L</span> is equal to the maximum degree bound <span class="math">D</span>; the message universe is the set of polynomials over some field <span class="math">\\mathbb{F}</span> of degree at most <span class="math">D</span>. The trim specification <span class="math">\\ell</span> is equal to the list of degree bounds <span class="math">[d_{i}]_{i=1}^{n}</span>; the corresponding message space is the set of polynomials over <span class="math">\\mathbb{F}</span> of degree at most <span class="math">\\max_{i}d_{i}</span>.</p>

    <p class="text-gray-300">A polynomial commitment scheme must also satisfy the following additional properties.</p>

    <p class="text-gray-300">Completeness. For every maximum degree bound  <span class="math">D = \\mathrm{poly}(\\lambda) \\in \\mathbb{N}</span>  and every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; p p \\leftarrow \\mathsf {P C . S e t u p} ^ {\\rho} (1 ^ {\\lambda}, D) \\\\ d \\in [ d _ {i} ] _ {i = 1} ^ {n} &amp;amp; ([ d _ {i} ] _ {i = 1} ^ {n}, p, d, z, \\omega) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ \\deg (p) \\leq d \\leq D &amp;amp; (\\mathsf {c k}, \\mathsf {r k}) \\leftarrow \\mathsf {P C . T r i m} ^ {\\rho} (\\mathsf {p p}, [ d _ {i} ] _ {i = 1} ^ {n}) \\\\ \\Downarrow &amp;amp; C \\leftarrow \\mathsf {P C . C o m m i t} ^ {\\rho} (\\mathsf {c k}, p, d; \\omega) \\\\ \\mathsf {P C . C h e c k} ^ {\\rho} (\\mathsf {r k}, C, d, z, v, \\pi) = 1 &amp;amp; v \\leftarrow p (z) \\\\ &amp;amp; \\pi \\leftarrow \\mathsf {P C . O p e n} ^ {\\rho} (\\mathsf {c k}, p, C, d, z; \\omega) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Extractability. For every maximum degree bound  <span class="math">D = \\mathrm{poly}(\\lambda) \\in \\mathbb{N}</span>  and polynomial-size adversary  <span class="math">\\mathcal{A}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that the following holds.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {P C . C h e c k} ^ {\\rho} (\\mathsf {r k}, C, d, z, v, \\pi) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {P C . S e t u p} ^ {\\rho} (1 ^ {\\lambda}, D) \\\\ C = \\mathsf {P C . C o m m i t} ^ {\\rho} (\\mathsf {c k}, p, d; \\omega) &amp;amp; ([ d _ {i} ] _ {i = 1} ^ {n}, (C, d, z, v), \\pi) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}) \\\\ v = p (z) &amp;amp; (p, \\omega) \\leftarrow \\mathcal {E} ^ {\\rho} (\\mathsf {p p}) \\\\ d \\in [ d _ {i} ] _ {i = 1} ^ {n} &amp;amp; (\\mathsf {c k}, \\mathsf {r k}) \\leftarrow \\mathsf {P C . T r i m} ^ {\\rho} (\\mathsf {p p}, [ d _ {i} ] _ {i = 1} ^ {n}) \\end{array} \\right] \\geq 1 - \\mathrm {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">Hiding. There exists a stateful polynomial-time simulator  <span class="math">S</span>  such that, for every maximum degree bound  <span class="math">D = \\mathrm{poly}(\\lambda) \\in \\mathbb{N}</span>  and stateful polynomial-size adversary  <span class="math">\\mathcal{A}</span> , the output distributions of the following games are statistically close:</p>

    <p class="text-gray-300">Real  <span class="math">(1^{\\lambda},D,\\mathcal{A})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

      <li><span class="math">\\mathsf{pp}\\gets \\mathsf{PC.Setup}^{\\rho}(1^{\\lambda},D)</span></li>

      <li><span class="math">(p,d)\\gets \\mathcal{A}^{\\rho}(\\mathsf{pp})</span></li>

      <li><span class="math">(\\mathsf{ck},\\mathsf{rk})\\gets \\mathsf{PC.Trim}^{\\rho}(\\mathsf{pp},d)</span></li>

      <li>Sample commitment randomness  <span class="math">\\omega</span> .</li>

      <li><span class="math">C\\gets \\mathsf{PC.Commit}^{\\rho}(\\mathsf{ck},p,d;\\omega)</span></li>

      <li><span class="math">z\\gets \\mathcal{A}^{\\rho}(C)</span></li>

      <li>Sample opening randomness  <span class="math">r</span> .</li>

      <li><span class="math">\\pi \\gets \\mathsf{PC.Open}^{\\rho}(\\mathsf{ck},p,C,d,z;\\omega ,r)</span></li>

      <li>Output  <span class="math">(\\rho, \\mathsf{pp}, p, d, C, z, \\pi)</span> .</li>

    </ol>

    <p class="text-gray-300">Ideal  <span class="math">(1^{\\lambda},D,\\mathcal{A})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho \\gets \\mathcal{U}(\\lambda)</span></li>

      <li><span class="math">(\\mathsf{pp},\\mathsf{trap})\\gets \\mathcal{S}.\\mathsf{Setup}^{\\rho}(1^{\\lambda},D).</span></li>

      <li><span class="math">(p,d)\\gets \\mathcal{A}^{\\rho}(\\mathsf{pp})</span></li>

      <li><span class="math">C\\gets \\mathcal{S}.\\mathrm{Commit}^{\\rho}(\\mathrm{trap},d)</span></li>

      <li><span class="math">z\\gets \\mathcal{A}^{\\rho}(C)</span></li>

      <li><span class="math">(\\mu, \\pi) \\gets S. \\mathrm{Open}^{\\rho}(z, p(z))</span> .</li>

      <li>Output  <span class="math">(\\rho[\\mu], \\mathsf{pp}, p, d, C, z, \\pi)</span> .</li>

    </ol>

    <p class="text-gray-300">In Section 4.1 we formally define an accumulation scheme. In Section 4.2 we define accumulation schemes for predicates related to the cryptographic primitives used in this paper.</p>

    <p class="text-gray-300">Let  <span class="math">\\Phi \\colon \\mathcal{U}(<em>) \\times (\\{0,1\\}^</em>)^3 \\to \\{0,1\\}</span>  be a predicate (for clarity we write  <span class="math">\\Phi^\\rho(\\mathsf{pp}_\\Phi, \\mathsf{i}_\\Phi, \\mathsf{q})</span>  for  <span class="math">\\Phi(\\rho, \\mathsf{pp}_\\Phi, \\mathsf{i}_\\Phi, \\mathsf{q})</span> ). Let  <span class="math">\\mathcal{H}</span>  be a randomized algorithm with access to a (random) oracle, which outputs predicate parameters  <span class="math">\\mathsf{pp}_\\Phi</span> .</p>

    <p class="text-gray-300">An accumulation scheme for  <span class="math">(\\Phi, \\mathcal{H})</span>  is a tuple of algorithms  <span class="math">\\mathsf{AS} = (\\mathrm{G}, \\mathrm{I}, \\mathrm{P}, \\mathrm{V}, \\mathrm{D})</span>  all of which have access to the same random oracle  <span class="math">\\rho</span> . The algorithms have the following syntax and properties.</p>

    <p class="text-gray-300">Syntax. The algorithms comprising AS have the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: On input a security parameter  <span class="math">\\lambda</span>  (in unary), G samples and outputs public parameters pp.</li>

      <li>Indexer: On input public parameters  <span class="math">\\mathsf{pp}</span> , predicate parameters  <span class="math">\\mathsf{pp}_{\\Phi}</span>  (generated by  <span class="math">\\mathcal{H}</span> ), and a predicate index  <span class="math">\\mathrm{i}_{\\Phi}</span> , I deterministically computes and outputs a triple  <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk})</span>  consisting of an accumulator proving key  <span class="math">\\mathsf{apk}</span> , an accumulator verification key  <span class="math">\\mathsf{avk}</span> , and a decision key  <span class="math">\\mathsf{dk}</span> .</li>

      <li>Accumulation prover: On input the accumulator proving key  <span class="math">\\mathsf{apk}</span> , inputs  <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span> , and old accumulators  <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> , P outputs a new accumulator acc and a proof  <span class="math">\\pi_{\\mathrm{V}}</span>  for the accumulation verifier.</li>

      <li>Accumulation verifier: On input the accumulator verification key  <span class="math">\\mathsf{avk}</span> , inputs  <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span> , accumulator instances  <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> , a new accumulator instance acc, and a proof  <span class="math">\\pi_{\\mathrm{V}}</span> , V outputs a bit indicating whether a correctly accumulates  <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span>  and  <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> .</li>

      <li>Decider: On input the decision key  <span class="math">\\mathrm{dk}</span> , and an accumulator acc, D outputs a bit indicating whether acc is a valid accumulator.</li>

    </ul>

    <p class="text-gray-300">These algorithms must satisfy two properties, completeness and soundness, defined below. We additionally define a notion of zero knowledge that we will rely on to achieve zero knowledge PCD (see Section 5).</p>

    <p class="text-gray-300">Completeness. For all (unbounded) adversaries  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall j \\in [ m ],   \\mathrm {D} ^ {\\rho} (\\mathsf {d k}, \\mathsf {a c c} _ {j}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall i \\in [ n ],   \\Phi^ {\\rho} (\\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}, \\mathsf {q} _ {i}) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} _ {\\Phi} \\leftarrow \\mathcal {H} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathrm {V} ^ {\\rho} (\\mathsf {a v k}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}, \\mathsf {a c c}, \\pi_ {\\mathrm {V}}) = 1 &amp;amp; (\\mathsf {i} _ {\\Phi}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}) \\\\ &amp;amp; (\\mathsf {a c c}, \\pi_ {\\mathrm {V}}) \\leftarrow \\mathrm {P} ^ {\\rho} (\\mathsf {a p k}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Note that for  <span class="math">m = n = 0</span> , the precondition on the left-hand side holds vacuously; this is required for the completeness condition to be non-trivial.</p>

    <p class="text-gray-300">Soundness. For every polynomial-size adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {V} ^ {\\rho} (\\mathsf {a v k}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}, \\mathsf {a c c}, \\pi_ {\\mathrm {V}}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {D} ^ {\\rho} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; \\mathsf {p p} \\leftarrow \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} _ {\\Phi} \\leftarrow \\mathcal {H} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\forall j \\in [ m ],   \\mathrm {D} ^ {\\rho} (\\mathsf {d k}, \\mathsf {a c c} _ {j}) = 1 &amp;amp; \\left( \\begin{array}{c c c} \\mathrm {i} _ {\\Phi} &amp;amp; [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n} &amp;amp; [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m} \\\\ &amp;amp; \\mathsf {a c c} &amp;amp; \\pi_ {\\mathrm {V}} \\end{array} \\right) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\Phi}, \\mathsf {i} _ {\\Phi}) \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)  .</span></div>

    <p class="text-gray-300">3We remark that in some schemes it is important, for the sake of efficiency, for the indexer I to have oracle access to the predicate parameters  <span class="math">\\mathsf{pp}_{\\Phi}</span>  and predicate index  <span class="math">\\mathrm{i}_{\\Phi}</span> , rather than reading them in full. All of our constructions and statements extend, in a straightforward way, to this case.</p>

    <p class="text-gray-300">Zero knowledge. There exists a polynomial-time simulator S such that for every polynomial-size "honest" adversary  <span class="math">\\mathcal{A}</span>  (see below) the following distributions are (statistically/computationally) indistinguishable:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ρ, pp, acc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ←U(λ) pp←Gρ(1λ) ppΦ←Hρ(1λ) (iΦ, [q_i]n=1, [acc_j]n=1)←Aρ(pp, ppΦ) (apk, avk, dk)←Pρ(pp, ppΦ, iΦ) (acc, πV)←Pρ(apk, [q_i]n=1, [acc_j]n=1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  and  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ρ[μ], pp, acc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ←U(λ) (pp,τ)←Sρ(1λ) ppΦ←Hρ(1λ) (iΦ, [q_i]n=1, [acc_j]n=1)←Aρ(pp, ppΦ) (acc,μ)←Sρ(ppΦ,τ, iΦ)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here  <span class="math">\\mathcal{A}</span>  is honest if it outputs, with probability 1, a tuple  <span class="math">(\\mathrm{i}_{\\Phi}, [\\mathfrak{q}_i]_{i=1}^n, [\\mathrm{acc}_j]_{j=1}^m)</span>  such that  <span class="math">\\Phi^\\rho(\\mathsf{pp}_{\\Phi}, \\mathrm{i}_{\\Phi}, \\mathfrak{q}_i) = 1</span>  and  <span class="math">\\mathrm{D}^\\rho(\\mathrm{dk}, \\mathrm{acc}_j) = 1</span>  for all  <span class="math">i \\in [n]</span>  and  <span class="math">j \\in [m]</span> . Note that the simulator S is not required to simulate the accumulation verifier proof  <span class="math">\\pi_{\\mathrm{V}}</span> .</p>

    <p class="text-gray-300">Security in the standard model. The corresponding security definitions in the standard (CRS) model are obtained from the above by removing the random oracle  <span class="math">\\rho</span>  wherever it appears.</p>

    <p class="text-gray-300">Post-quantum security. The post-quantum analogues of the above definitions are obtained by modifying the soundness and zero knowledge guarantees to quantify over polynomial-size quantum adversaries  <span class="math">\\mathcal{A}</span> ; we also strengthen the zero knowledge guarantee to require quantum computational indistinguishability (although we do not permit S to be quantum). In the random oracle variant of the definitions, we should also allow the adversary superposition access to the random oracle (i.e., require security in the quantum random oracle model [BDFLSZ11]). Note, however, that this latter issue is not relevant to the present work: our only result on post-quantum security is Theorem 5.2, which is in the standard (CRS) model.</p>

    <p class="text-gray-300">We conclude by specializing the definition of an accumulation scheme to the case of predicates induced by the verifier in a non-interactive argument (Definition 4.1) and in a polynomial commitment scheme (Definition 4.2).</p>

    <p class="text-gray-300">Definition 4.1 (accumulation for ARG). A non-interactive argument system  <span class="math">\\mathsf{ARG} = (\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>  has an accumulation scheme if the pair  <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{G})</span>  has an accumulation scheme, where  <span class="math">\\Phi_{\\mathcal{V}}</span>  is defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\Phi_{\\mathcal{V}}^{\\rho}(\\mathrm{i}_{\\Phi} = (\\mathsf{pp},\\mathbb{i}),\\mathsf{q} = (\\Xi ,\\pi))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\gets \\mathcal{I}^{\\rho}(\\mathsf{pp},\\mathbb{i}).</span></li>

      <li>Output  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk},\\Xi ,\\pi)</span></li>

    </ol>

    <p class="text-gray-300">Definition 4.2 (accumulation for PC). A polynomial commitment scheme  <span class="math">\\mathsf{PC} = (\\mathsf{Setup},\\mathsf{Trim},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Check})</span>  has an accumulation scheme if, for every  <span class="math">D(\\lambda) = \\mathrm{poly}(\\lambda)</span> , the pair  <span class="math">(\\Phi_{\\mathsf{PC}},\\mathcal{H}_{\\mathsf{PC},D})</span>  defined below has an accumulation scheme.</p>

    <p class="text-gray-300"><span class="math">\\Phi_{\\mathsf{PC}}^{\\rho}(\\mathrm{i}_{\\Phi} = (\\mathsf{pp}_{\\mathsf{PC}},[d_i]_{i = 1}^n),q = ((C,d,z,v),\\pi))</span>  ：  <span class="math">\\mathcal{H}_{\\mathsf{PC},D}^{\\rho}(1^{\\lambda})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{ck},\\mathsf{rk})\\gets \\mathsf{PC}.\\mathsf{Trim}^{\\rho}(\\mathsf{pp}_{\\mathsf{PC}},[d_i]_{i = 1}^n).</span>  Output  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}\\gets \\mathsf{PC}.Set\\mathsf{up}^{\\rho}(1^{\\lambda},D(\\lambda))</span></li>

      <li>Output PC.Check <span class="math">^{\\rho}</span> (rk, C, d, z, v, π).</li>

    </ol>

    <p class="text-gray-300">5 Proof-carrying data from accumulation schemes</p>

    <p class="text-gray-300">We formally restate and then prove Theorem 1, which provides a construction of proof-carrying data (PCD) from any SNARK that has an accumulation scheme with certain efficiency properties.</p>

    <p class="text-gray-300">First, we provide some notation for these properties.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> be an accumulation scheme for a non-interactive argument (see Section 6). We denote by <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span> the circuit corresponding to the computation of the accumulation verifier <span class="math">\\mathrm{V}</span>, for security parameter <span class="math">\\lambda</span>, when checking the accumulation of <span class="math">m</span> instance-proof pairs and accumulators, on an index of size at most <span class="math">N</span>, where each instance is of size at most <span class="math">k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">\\mathsf{v}(\\lambda,m,N,k)</span> the size of the circuit <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span>, by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{avk}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the size of the accumulator verification key </span>\\mathsf{avk}<span class="math">, and by </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{acc}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ the size of an accumulator.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that here we have specified that the size of <span class="math">\\mathsf{acc}</span> is bounded by a function of <span class="math">\\lambda,m,N</span>; in particular, it <em>may not</em> depend on the number of instances accumulated.</p>

    <p class="text-gray-300">When we invoke the accumulation verifier in our construction of PCD, an instance will consist of an accumulator verification key, an accumulator, and some additional data of size <span class="math">\\ell</span>. Thus the size of the accumulation verifier circuit used in the scheme is given by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{v}^{*}(\\lambda,m,N,\\ell):=\\mathsf{v}(\\lambda,m,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{avk}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{acc}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The notion of “sublinear verification” which is important here is that <span class="math">\\mathsf{v}^{*}</span> is sublinear in <span class="math">N</span>. The following theorem shows that when this is the case, this accumulation scheme can be used to construct PCD.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Theorem 5.2.</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathrm{T}</span> such that if <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> is a SNARK for circuit satisfiability and <span class="math">\\mathsf{AS}</span> is an accumulation scheme for <span class="math">\\mathsf{ARG}</span> then <span class="math">\\mathsf{PCD}=(\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V}):=\\mathrm{T}(\\mathsf{ARG},\\mathsf{AS})</span> is a PCD scheme for constant-depth compliance predicates, provided</p>

    <p class="text-gray-300"><span class="math">\\exists\\,\\epsilon\\in(0,1)\\text{ and a polynomial }\\alpha\\text{ s.t. }\\mathsf{v}^{*}(\\lambda,m,N,\\ell)=O(N^{1-\\epsilon}\\cdot\\alpha(\\lambda,m,\\ell))\\enspace.</span></p>

    <p class="text-gray-300">Moreover:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}</span> are secure against quantum adversaries, then <span class="math">\\mathsf{PCD}</span> is secure against quantum adversaries.</li>

      <li>If <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}</span> are (post-quantum) zero knowledge, then <span class="math">\\mathsf{PCD}</span> is (post-quantum) zero knowledge.</li>

      <li>If the size of the predicate <span class="math">\\varphi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span> is <span class="math">f=\\omega(\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span> then:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the cost of running <span class="math">\\mathbb{I}</span> is equal to the cost of running both <span class="math">\\mathcal{I}</span> and <span class="math">\\mathrm{I}</span> on an index of size <span class="math">f+o(f)</span>;</li>

      <li>the cost of running <span class="math">\\mathbb{P}</span> is equal to the cost of accumulating <span class="math">m</span> instance-proof pairs using <span class="math">\\mathrm{P}</span>, and running <span class="math">\\mathcal{P}</span>, on an index of size <span class="math">f+o(f)</span> and instance of size <span class="math">o(f)</span>;</li>

      <li>the cost of running <span class="math">\\mathbb{V}</span> is equal to the cost of running both <span class="math">\\mathcal{V}</span> and <span class="math">\\mathrm{D}</span> on an index of size <span class="math">f+o(f)</span> and an instance of size <span class="math">o(f)</span>.</li>

    </ul>

    <p class="text-gray-300">This last point gives the conditions for a <em>sublinear additive</em> recursive overhead; i.e., when the <em>additional</em> cost of proving that <span class="math">\\varphi</span> is satisfied recursively is asymptotically smaller than the cost of proving that <span class="math">\\varphi</span> is satisfied locally. Note that the smaller the compliance predicate <span class="math">\\varphi</span>, the more efficient the accumulation scheme has to be in order to achieve this.</p>

    <p class="text-gray-300">Our PCD construction and its proof of security follow those given in <em>[x10]</em>, except for several important differences.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In <em>[x10]</em>, the circuit on which the SNARK prover is invoked contains the SNARK verifier circuit. In our setting, this is not possible in general since the verifier may not be succinct. Instead, we invoke the SNARK prover on a circuit containing the accumulation verifier circuit.</li>

      <li>The PCD proof consists of both a SNARK proof <span class="math">\\pi</span> and an accumulator <span class="math">\\mathsf{acc}</span>; verifying the computation requires running the SNARK verifier on <span class="math">\\pi</span> and the accumulation scheme decider on <span class="math">\\mathsf{acc}</span>.</li>

      <li>Since the security of the accumulation scheme is proved separately to the security of the SNARK itself, we require that the SNARK remain secure with respect to the auxiliary input distribution induced by the public parameters of the accumulation scheme.</li>

    </ul>

    <p class="text-gray-300">The rest of this section is dedicated to proving Theorem 5.2: in Section 5.1 we construct the PCD scheme; in Section 5.2 we prove that accumulation verifiers that are sublinear suffice for PCD; in Section 5.3 we prove completeness; in Section 5.4 we prove knowledge soundness; in Section 5.5 we discuss zero knowledge; and in Section 5.6 we discuss post-quantum security.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Remark 5.3.</h6>

    <p class="text-gray-300">Theorem 5.2 yields PCD that is secure for constant-depth compliance predicates. The depth restriction is necessary because of the recursive invocation of the extractor: if the extractor has size <span class="math">e(n)=n^{c}</span>, then recursively applying the extractor <span class="math">d</span> times (for a depth-<span class="math">d</span> predicate) yields a circuit of size <span class="math">n^{c^{d}}</span>, which for <span class="math">d=\\omega(1)</span> is superpolynomial. Under a subexponential knowledge assumption one can increase <span class="math">d</span> to <span class="math">o(\\log n)</span>.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">5.1 Construction</h3>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> be a non-interactive argument for circuit satisfiability, and let <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> be an accumulation scheme for <span class="math">\\mathsf{ARG}</span>. Below we construct a PCD scheme <span class="math">\\mathsf{PCD}=(\\mathbb{G},\\mathbb{I},\\mathbb{P},\\mathbb{V})</span>.</p>

    <p class="text-gray-300">Given a compliance predicate <span class="math">\\varphi\\colon\\mathbb{F}^{(m+2)\\ell}\\to\\mathbb{F}</span>, the circuit that realizes the recursion is as follows.</p>

    <p class="text-gray-300"><span class="math">R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi}\\big{(}(\\mathsf{avk},z,\\mathsf{acc}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m},\\pi_{\\mathrm{V}})\\big{)}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the compliance predicate <span class="math">\\varphi(z,z_{\\mathsf{loc}},z_{1},\\ldots,z_{m})</span> accepts.</li>

      <li>If there exists <span class="math">i\\in[m]</span> such that <span class="math">z_{i}\\neq\\bot</span>, check that the SNARK accumulation verifier accepts:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}(\\mathsf{avk},[(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m},\\mathsf{acc},\\pi_{\\mathrm{V}})=1\\enspace.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the above checks hold, output <span class="math">1</span>; otherwise, output <span class="math">0</span>.</li>

    </ol>

    <p class="text-gray-300">Above, <span class="math">\\mathrm{V}^{(\\lambda,m,N,k)}</span> refers to the circuit representation of <span class="math">\\mathrm{V}</span> with input size appropriate for security parameter <span class="math">\\lambda</span>, number of instance-proof pairs and accumulators <span class="math">m</span>, index size <span class="math">N</span>, and instance size <span class="math">k</span>.</p>

    <p class="text-gray-300">Next we describe the generator <span class="math">\\mathbb{G}</span>, indexer <span class="math">\\mathbb{I}</span>, prover <span class="math">\\mathbb{P}</span>, and verifier <span class="math">\\mathbb{V}</span> of the PCD scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{G}(1^{\\lambda})</span>: Sample <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span> and <span class="math">\\mathsf{pp}_{\\mathsf{AS}}\\leftarrow\\mathrm{G}(1^{\\lambda})</span>, and output <span class="math">\\mathbb{pp}\\vcentcolon=(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span>.</li>

      <li><span class="math">\\mathbb{I}(\\mathbb{pp},\\varphi)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute the integer $N:=N(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,\\ell)<span class="math">, where </span>N$ is defined in Lemma 5.4 below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the index key pair <span class="math">(\\mathrm{ipk},\\mathrm{ivk})\\leftarrow\\mathcal{I}(\\mathsf{pp},R)</span> for the circuit <span class="math">R</span> for the SNARK.</li>

      <li>Compute the index key triple <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk})\\leftarrow\\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}},\\mathrm{i}_{\\Phi}=(\\mathsf{pp},R))</span> for the accumulator.</li>

      <li>Output <span class="math">\\mathsf{ipk}:=(\\mathrm{ipk},\\mathsf{apk})</span> and <span class="math">\\mathsf{ivk}:=(\\mathrm{ivk},\\mathsf{dk},\\mathsf{avk})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{P}(\\mathsf{ipk},z,z_{\\mathsf{loc}},[z_{i},(\\pi_{i},\\mathsf{acc}_{i})]_{i=1}^{m})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">z_{i}=\\bot</span> for all <span class="math">i\\in[m]</span> then set <span class="math">(\\mathsf{acc},\\pi_{\\mathrm{V}})\\leftarrow\\mathrm{P}(\\mathsf{apk},\\bot)</span>.</li>

      <li>If <span class="math">z_{i}\\neq\\bot</span> for some <span class="math">i\\in[m]</span> then compute <span class="math">(\\mathsf{acc},\\pi_{\\mathrm{V}})\\leftarrow\\mathrm{P}(\\mathsf{apk},[(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m})</span>.</li>

      <li>Compute <span class="math">\\pi\\leftarrow\\mathcal{P}\\big{(}\\mathrm{ipk},(\\mathsf{avk},z,\\mathsf{acc}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m},\\pi_{\\mathrm{V}})\\big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">##</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\pi,\\mathsf{acc})</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{V}(\\mathsf{ivk},z,(\\pi,\\mathsf{acc}))</span>: Accept if both <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}),\\pi)</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})</span> accept.</li>

    </ul>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.2 Efficiency</h3>

    <p class="text-gray-300">Denote by <span class="math">f</span> the size of the compliance predicate <span class="math">\\varphi</span> as an R1CS instance. In the above construction, the explicit input consists of the accumulator verification key <span class="math">\\mathsf{avk}</span>, whose size depends on <span class="math">N</span> and <span class="math">\\lambda</span>, a message <span class="math">z</span> whose size is <span class="math">\\ell</span> (independent of <span class="math">N</span>), and an accumulator <span class="math">\\mathsf{acc}</span> whose size depends on <span class="math">N</span> and <span class="math">\\lambda</span>. The security parameter <span class="math">\\lambda</span> is independent of <span class="math">N</span>. The circuit <span class="math">R^{(\\lambda,N,k)}_{\\mathrm{V},\\varphi}</span> on which we wish to invoke <span class="math">\\mathrm{V}</span> is of size</p>

    <p class="text-gray-300"><span class="math">S(\\lambda,f,m,\\ell,N)=f+S_{0}(m,\\ell)+\\mathsf{v}^{*}(\\lambda,m,N,\\ell)\\quad\\text{for some}\\quad S_{0}(m,\\ell)=O(m\\ell)\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">recalling that $\\mathsf{v}^{*}(\\lambda,m,N,\\ell)=\\mathsf{v}(\\lambda,m,N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{avk}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{acc}(\\lambda,m,N)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The goal of this section to find the (asymptotically) smallest index size bound function <span class="math">N</span> such that <span class="math">S(\\lambda,f,m,\\ell,N(\\lambda,f,m,\\ell))\\leq N(\\lambda,f,m,\\ell)</span>. This ensures that the circuit for checking an index of size <span class="math">N</span> is of size at most <span class="math">N</span>, which permits recursion.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 5.4.</h6>

    <p class="text-gray-300">Suppose that for every security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, arity <span class="math">m</span>, and message size <span class="math">\\ell\\in\\mathbb{N}</span> the ratio of accumulation verifier circuit size to index size <span class="math">\\mathsf{v}^{*}(\\lambda,m,N,\\ell)/N</span> is monotone decreasing in <span class="math">N</span>. Then there exists a size function <span class="math">N(\\lambda,f,m,\\ell)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\forall\\,\\lambda,f,m,\\ell\\in\\mathbb{N}\\quad S(\\lambda,f,m,\\ell,N(\\lambda,f,m,\\ell))\\leq N(\\lambda,f,m,\\ell)\\enspace.</span></p>

    <p class="text-gray-300">Moreover if for some <span class="math">\\epsilon&gt;0</span> and some increasing function <span class="math">\\alpha</span> it holds that, for all <span class="math">N,\\lambda,m,\\ell</span> sufficiently large,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{v}^{*}(\\lambda,m,N,\\ell)\\leq N^{1-\\epsilon}\\alpha(\\lambda,m,\\ell)</span></p>

    <p class="text-gray-300">then, for all <span class="math">\\lambda,m,\\ell</span> sufficiently large,</p>

    <p class="text-gray-300"><span class="math">N(\\lambda,f,m,\\ell)\\leq O(f+\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})\\enspace.</span></p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">N_{0}:=N_{0}(\\lambda,m,\\ell)</span> be the smallest integer such that <span class="math">\\mathsf{v}^{*}(\\lambda,m,N_{0},\\ell)/N_{0}&lt;1/2</span>; this exists because of the monotone decreasing condition. Let <span class="math">N(\\lambda,f,m,\\ell):=\\max(N_{0}(\\lambda,m,\\ell),2(f+S_{0}(m,\\ell)))</span>. Then for <span class="math">N:=N(\\lambda,f,m,\\ell)</span> it holds that</p>

    <p class="text-gray-300"><span class="math">S(\\lambda,f,m,\\ell,N)=f+S_{0}(m,\\ell)+N\\cdot\\mathsf{v}^{*}(\\lambda,m,N,\\ell)/N&lt;N/2+N/2=N\\enspace.</span></p>

    <p class="text-gray-300">Clearly <span class="math">f+S_{0}(m,\\ell)=O(f)</span>. Now suppose that <span class="math">\\mathsf{v}^{*}(\\lambda,m,N,\\ell)\\leq N^{1-\\epsilon}\\alpha(\\lambda,m,\\ell)</span> for all sufficiently large <span class="math">N,\\lambda,m,\\ell</span>. Let <span class="math">N^{\\prime}(\\lambda,m,\\ell):=(2\\cdot\\alpha(\\lambda,m,\\ell))^{1/\\epsilon}</span>. Then since <span class="math">\\alpha</span> is increasing, for sufficiently large <span class="math">\\lambda,m,\\ell</span>, for <span class="math">N^{\\prime}:=N^{\\prime}(\\lambda,m,\\ell)</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{v}^{*}(\\lambda,m,N^{\\prime},\\ell)/N^{\\prime}&lt;\\alpha(\\lambda,m,\\ell)\\cdot(2\\alpha(\\lambda,m,\\ell))^{-1}=1/2\\enspace.</span></p>

    <p class="text-gray-300">Hence <span class="math">N_{0}\\leq N^{\\prime}=(2\\cdot\\alpha(\\lambda,m,\\ell))^{1/\\epsilon}</span>, for sufficiently large <span class="math">\\lambda,m,\\ell</span>, and so <span class="math">N(\\lambda,f,m,\\ell)\\leq O(f+\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span>. ∎</p>

    <p class="text-gray-300">We can now bound the size of the recursive circuit.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Corollary 5.5.</h6>

    <p class="text-gray-300">For the function <span class="math">N</span> above, <span class="math">S(\\lambda,f,m,\\ell,N)=f+O(f^{1-\\epsilon}\\cdot\\alpha(\\lambda,m,\\ell)+\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Using the expression for <span class="math">S</span> above, and the bound on <span class="math">N</span>,</p>

    <p class="text-gray-300"><span class="math">S(\\lambda,f,m,\\ell,N)</span> <span class="math">=f+O(m\\ell)+\\mathsf{v}^{*}(\\lambda,m,N,\\ell)</span> <span class="math">=f+O(N^{1-\\epsilon}\\alpha(\\lambda,m,\\ell))</span> <span class="math">=f+O(f^{1-\\epsilon}\\cdot\\alpha(\\lambda,m,\\ell)+\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})\\enspace.</span> ∎</p>

    <p class="text-gray-300">In particular if <span class="math">f=\\omega(\\alpha(\\lambda,m,\\ell)^{1/\\epsilon})</span> then this is <span class="math">f+o(f)</span>, and so the stated efficiency bounds hold.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.3 Completeness</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be any adversary that causes the completeness condition of <span class="math">\\mathsf{PCD}</span> to be satisfied with probability <span class="math">p</span>. We construct an adversary <span class="math">\\mathcal{B}</span>, as follows, that causes the completeness condition of <span class="math">\\mathsf{AS}</span> to be satisfied with probability at most <span class="math">p</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathbb{pp}:=(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span> and compute <span class="math">(\\varphi,z,z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m})\\leftarrow\\mathcal{A}(\\mathbb{pp}).</span></li>

      <li>Run <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk})\\leftarrow\\mathsf{I}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp},R_{\\mathsf{V},\\varphi}^{(\\lambda,N,k)}).</span></li>

      <li>Output <span class="math">(R_{\\mathsf{V},\\varphi}^{(\\lambda,N,k)},[(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m}).</span></li>

    </ol>

    <p class="text-gray-300">Suppose that <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\varphi,z,z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m})</span> such that the completeness precondition is satisfied, but <span class="math">\\mathbb{V}(\\mathsf{ivk},z,(\\pi,\\mathsf{acc}))=0</span>. Then, by construction of <span class="math">\\mathbb{V}</span>, it holds that either <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}),\\pi)=0</span> or <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>. If <span class="math">z_{i}=\\bot</span> for all <span class="math">i</span>, then by perfect completeness of <span class="math">\\mathsf{ARG}</span> both of these algorithms output <span class="math">1</span>; hence there exists <span class="math">i</span> such that <span class="math">z_{i}\\neq\\bot</span>. Hence it holds that for all <span class="math">i</span>, <span class="math">\\mathbb{V}(\\mathsf{ivk},z_{i},(\\pi_{i},\\mathsf{acc}_{i}))=1</span>, whence for all <span class="math">i</span>, <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i})=\\Phi_{\\mathcal{V}}(\\mathsf{pp},R_{\\mathsf{V},\\varphi}^{(\\lambda,N,k)},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc}_{i})=1</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}(\\mathrm{ivk},(\\mathsf{avk},z,\\mathsf{acc}),\\pi)=0</span>, then, by perfect completeness of <span class="math">\\mathsf{ARG}</span>, we know that <span class="math">R_{\\mathsf{V},\\varphi}^{(\\lambda,N,k)}</span> rejects <span class="math">\\big{(}(\\mathsf{avk},z,\\mathsf{acc}),(z_{\\mathsf{loc}},[z_{i},\\pi_{i},\\mathsf{acc}_{i}]_{i=1}^{m}),\\pi_{\\mathsf{V}}\\big{)}</span>, and so <span class="math">\\mathrm{V}(\\mathsf{avk},[(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m},\\mathsf{acc})=0</span>. Otherwise, <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>.</p>

    <p class="text-gray-300">Now consider the completeness experiment for <span class="math">\\mathsf{AS}</span> with adversary <span class="math">\\mathcal{B}</span>. Since <span class="math">\\mathsf{pp}</span>, <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> are drawn identically to the <span class="math">\\mathsf{PCD}</span> experiment, the distribution of the output of <span class="math">\\mathcal{A}</span> is identical. Hence in particular it holds that for all <span class="math">i</span>, <span class="math">\\Phi_{\\mathcal{V}}(\\mathsf{pp},R_{\\mathsf{V},\\varphi}^{(\\lambda,N,k)},(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i})=1</span> and <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc}_{i})=1</span>. By the above, it holds that either <span class="math">\\mathrm{V}(\\mathsf{avk},[(\\mathsf{avk},z_{i},\\mathsf{acc}_{i}),\\pi_{i}]_{i=1}^{m},[\\mathsf{acc}_{i}]_{i=1}^{m},\\mathsf{acc})=0</span> or <span class="math">\\mathrm{D}(\\mathsf{dk},\\mathsf{acc})=0</span>, and so <span class="math">\\mathcal{B}_{1},\\mathcal{B}_{2}</span> cause the completeness condition for <span class="math">\\mathsf{AS}</span> to be satisfied with probability at most <span class="math">p</span>.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.4 Knowledge soundness</h3>

    <p class="text-gray-300">Since the extracted transcript <span class="math">\\mathsf{T}</span> will be a tree, we find it convenient to associate the label <span class="math">z^{(u,v)}</span> of the unique outgoing edge of a node <span class="math">u</span> with the node <span class="math">u</span> itself, so that the node <span class="math">u</span> is labelled with <span class="math">(z^{(u)},z_{\\mathsf{loc}}^{(u)})</span>. For the purposes of the proof we also associate with each node <span class="math">u</span> a SNARK proof <span class="math">\\pi^{(u)}</span> and an accumulator <span class="math">\\mathsf{acc}^{(u)}</span>, so that the full label for a node is <span class="math">(z^{(u)},z_{\\mathsf{loc}}^{(u)},\\pi^{(u)},\\mathsf{acc}^{(u)})</span>. It is straightforward to transform such a transcript into one that satisfies Definition 3.1.</p>

    <p class="text-gray-300">Given a malicious prover <span class="math">\\bar{\\mathbb{P}}</span>, we will define an extractor <span class="math">\\mathbb{E}_{\\bar{\\mathbb{P}}}</span> that satisfies knowledge soundness. In the process we construct a sequence of extractors <span class="math">\\mathbb{E}_{1},\\ldots,\\mathbb{E}_{d}</span> for <span class="math">d:=d(\\varphi)</span> (the depth of <span class="math">\\varphi</span>); <span class="math">\\mathbb{E}_{j}</span> outputs a tree of depth <span class="math">j+1</span>. Let <span class="math">\\mathbb{E}_{0}(\\mathbb{pp})</span> run <span class="math">(\\varphi,\\mathsf{o},\\pi,\\mathsf{acc})\\leftarrow\\bar{\\mathbb{P}}(\\mathbb{pp})</span> and output <span class="math">(\\varphi,\\mathsf{T}_{0})</span>, where <span class="math">\\mathsf{T}_{0}</span> is a single node labeled with <span class="math">(\\mathsf{o},\\pi,\\mathsf{acc})</span>. Let <span class="math">l_{\\mathsf{T}}(j)</span> denote the vertices of <span class="math">\\mathsf{T}</span> at depth <span class="math">j</span>; <span class="math">l_{\\mathsf{T}}(0):=\\emptyset</span> and <span class="math">l_{\\mathsf{T}}(1)</span> is the singleton containing the root.</p>

    <p class="text-gray-300">Now we define the extractor <span class="math">\\mathbb{E}_j</span> inductively for each <span class="math">j \\in [d]</span>. Suppose we have already constructed <span class="math">\\mathbb{E}_{j-1}</span>. We construct a SNARK prover <span class="math">\\tilde{\\mathcal{P}}_j</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{P}}_j(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\varphi, \\mathsf{T}_{j-1}) \\gets \\mathbb{E}_{j-1}(\\mathsf{pp}, \\mathsf{pp}_{\\mathsf{AS}})</span>.</li>

      <li>For each vertex <span class="math">v \\in l_{\\mathsf{T}_{j-1}}(j)</span>, denote its label by <span class="math">(z^{(v)}, \\pi^{(v)}, \\mathsf{acc}^{(v)})</span>.</li>

      <li>Run the argument indexer <span class="math">(\\mathrm{ipk}, \\mathrm{ivk}) \\gets \\mathcal{I}(\\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda, N, k)})</span>. Run the accumulator indexer <span class="math">(\\mathsf{apk}, \\mathsf{dk}, \\mathsf{avk}) \\gets \\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda, N, k)})</span>.</li>

      <li>Output</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\vec {\\mathbf {s}}, \\vec {\\mathbf {x}}, \\vec {\\pi}, \\mathsf {a u x}) := \\left(\\vec {R}, (\\mathsf {a v k}, z ^ {(v)}, \\mathsf {a c c} ^ {(v)}) _ {v \\in l _ {\\mathsf {T} _ {j - 1}} (j)}, (\\pi^ {(v)}) _ {v \\in l _ {\\mathsf {T} _ {j - 1}} (j)}, (\\varphi , \\mathsf {T} _ {j - 1})\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\vec{R}</span> is the vector <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)},\\ldots ,R_{\\mathrm{V},\\varphi}^{(\\lambda ,N,k)})</span> of the appropriate length.</p>

    <p class="text-gray-300">Next let <span class="math">\\mathcal{E}_{\\tilde{\\mathcal{P}}_j}</span> be the extractor that corresponds to <span class="math">\\tilde{\\mathcal{P}}_j</span>, via the knowledge soundness of the non-interactive argument ARG. Finally the extractor <span class="math">\\mathbb{E}_j</span> is defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_j(\\mathbb{P}\\mathbb{P} = (\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the extractor <span class="math">(\\vec{\\mathbf{s}},\\vec{\\mathbf{x}},\\vec{\\pi},\\mathsf{aux},\\vec{\\mathbf{w}})\\gets \\mathcal{E}_{\\tilde{\\mathcal{P}}_j}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}})</span>.</li>

      <li>Parse the auxiliary output aux as <span class="math">(\\varphi, \\mathsf{T}&#x27;)</span>.</li>

      <li>If <span class="math">\\mathsf{T}&#x27;</span> is not a transcript of depth <span class="math">j</span>, abort.</li>

      <li>Output <span class="math">(\\varphi, \\mathsf{T}_j)</span> where <span class="math">\\mathsf{T}_j</span> is the transcript constructed from <span class="math">\\mathsf{T}&#x27;</span> by doing the following for each vertex <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>obtain the local data <span class="math">z_{\\mathrm{loc}}^{(v)}</span> and input messages <span class="math">\\left(z_{i},\\pi_{i},\\mathsf{acc}_{i}\\right)_{i\\in [m]}</span> from <span class="math">\\mathbb{W}^{(v)}</span>;</li>

      <li>append <span class="math">z_{\\mathrm{loc}}^{(v)}</span> to the label of <span class="math">v</span>, and if there exists any <span class="math">z_{i}</span> with <span class="math">z_{i} \\neq \\bot</span>, attach <span class="math">m</span> children to <span class="math">v</span> where the <span class="math">i</span>-th child is labeled with <span class="math">(z_{i}, \\pi_{i}, \\mathsf{acc}_{i})</span>.</li>

    </ul>

    <p class="text-gray-300">The extractor <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> runs <span class="math">(\\varphi, \\mathsf{T}_d) \\gets \\mathbb{E}_d(\\mathsf{urs})</span> and outputs <span class="math">(\\varphi, (\\pi, \\mathsf{acc}), \\mathsf{T}_d)</span>, where <span class="math">(z, z_{\\mathrm{loc}}, \\pi, \\mathsf{acc})</span> labels the root node.</p>

    <p class="text-gray-300">We now show that <span class="math">\\mathbb{E}_{\\tilde{\\mathbb{P}}}</span> has polynomial size and that it outputs a transcript that is <span class="math">\\varphi</span>-compliant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Size of the extractor. <span class="math">\\tilde{\\mathcal{P}}_j</span> is a circuit of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ O(2^j)<span class="math">, so </span>\\mathcal{E}_{\\tilde{\\mathcal{P}}_j}<span class="math"> is a circuit of size </span>e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ O(2^j))<span class="math">. Then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ c \\cdot 2^j)<span class="math"> for some </span>c \\in \\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A solution to this recurrence (for <span class="math">e(n) \\geq n</span>) is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e^{(j)}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbb{P}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ j \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2c \\cdot 2^j)<span class="math">, where </span>e^{(j)}<span class="math"> is the function </span>e<span class="math"> iterated </span>j<span class="math"> times. Hence in particular if </span>d(\\varphi)<span class="math"> is a constant, </span>\\mathbb{E}_{\\tilde{\\mathbb{P}}}$ is a circuit of polynomial size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Correctness of the extractor. Suppose that <span class="math">\\tilde{\\mathbb{P}}</span> causes <span class="math">\\mathbb{V}</span> to accept with probability <span class="math">\\mu</span>. We show by induction that, for all <span class="math">j \\in \\{0, \\dots, d\\}</span>, the transcript <span class="math">\\mathsf{T}_j</span> output by <span class="math">\\mathbb{E}_j</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j</span>, and that for all <span class="math">v \\in \\mathsf{T}</span>, both <span class="math">\\mathcal{V}(\\mathrm{ivk}, (\\mathsf{avk}, z^{(v)}, \\mathsf{acc}^{(v)}), \\pi^{(v)})</span> and <span class="math">\\mathrm{D}(\\mathsf{dk}, \\mathsf{acc}^{(v)})</span> accept, with probability <span class="math">\\mu - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">For <span class="math">j = 0</span> the statement is implied by <span class="math">\\mathbb{V}</span> accepting with probability <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">Now suppose that <span class="math">\\mathsf{T}_{j-1} \\gets \\mathbb{E}_{j-1}</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j-1</span>, and that both <span class="math">\\mathcal{V}(\\mathrm{ivk}, (\\mathsf{avk}, z^{(v)}, \\mathsf{acc}^{(v)}), \\pi^{(v)})</span> and <span class="math">\\mathrm{D}(\\mathsf{dk}, \\mathsf{acc}^{(v)})</span> accept for all <span class="math">v \\in \\mathsf{T}_{j-1}</span>, with probability <span class="math">\\mu - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Let <span class="math">(\\vec{\\mathbf{s}}, (\\mathsf{avk}_v, z^{(v)}, \\mathsf{acc}^{(v)})_v, (\\pi^{(v)})_v, (\\varphi, \\mathsf{T}&#x27;), \\vec{\\mathbf{w}}) \\gets \\mathcal{E}_{\\tilde{\\mathcal{P}}_j}</span>.</p>

    <p class="text-gray-300">By knowledge soundness of ARG, with probability <span class="math">\\mu -\\mathrm{negl}(\\lambda)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">v</span> is labeled with <span class="math">(z^{(v)}, \\pi^{(v)}, \\mathsf{acc}^{(v)})</span> and <span class="math">\\mathsf{avk}_v = \\mathsf{avk}</span> where <span class="math">(\\mathsf{apk}, \\mathsf{dk}, \\mathsf{avk}) \\gets \\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}}, \\Phi)</span>,</li>

      <li>for every vertex <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>, <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}, (\\mathsf{avk}, z^{(v)}, \\mathsf{acc}^{(v)}), \\mathbb{W}^{(v)}) \\in \\mathcal{R}_{\\mathrm{R1CS}},</span> and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>by induction <span class="math">\\mathsf{T}^{\\prime}</span> is <span class="math">\\varphi</span>-compliant up to depth <span class="math">j - 1</span> and <span class="math">\\mathrm{D}(\\mathrm{dk},\\mathrm{acc}^{(v)})</span> accepts for all <span class="math">v\\in \\mathsf{T}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Here we use the auxiliary output in the knowledge soundness definition of ARG to ensure consistency between the values <span class="math">z^{(v)}</span> and <span class="math">\\mathsf{T}&#x27;</span>, and to ensure that <span class="math">\\mathsf{T}&#x27;</span> is <span class="math">\\varphi</span>-compliant.</p>

    <p class="text-gray-300">Consider some <span class="math">v \\in l_{\\mathsf{T}&#x27;}(j)</span>. Since <span class="math">(R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}, (\\mathsf{avk}_v, z^{(v)}, \\mathsf{acc}^{(v)}), \\mathsf{w}^{(v)}) \\in \\mathcal{R}_{\\mathrm{R1CS}}</span>, we obtain from <span class="math">\\mathsf{w}^{(v)}</span> either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>local data <span class="math">z_{\\mathrm{loc}}</span>, input messages <span class="math">\\left(z_i, \\pi_i, \\mathsf{acc}_i\\right)_{i \\in [m]}</span> and proof <span class="math">\\pi_{\\mathrm{V}}</span> such that <span class="math">\\varphi(z^{(v)}, z_{\\mathrm{loc}}, z_1, \\ldots, z_m)</span> accepts and the accumulation verifier <span class="math">\\mathrm{V}^{(\\lambda, N, k)}(\\mathsf{avk}, [(\\mathsf{avk}, z_i, \\mathsf{acc}_i), \\pi_i]_{i=1}^m, [\\mathsf{acc}_i]_{i=1}^m, \\mathsf{acc}^{(v)}, \\pi_{\\mathrm{V}})</span> accepts; or</li>

      <li>local data <span class="math">z_{\\mathrm{loc}}</span> such that <span class="math">\\varphi(z^{(v)}, z_{\\mathrm{loc}}, \\bot, \\dots, \\bot)</span> accepts.</li>

    </ul>

    <p class="text-gray-300">In both cases we append <span class="math">z_{\\mathrm{loc}}^{(v)} \\coloneqq z_{\\mathrm{loc}}</span> to the label of <span class="math">v</span>. In the latter case, <span class="math">v</span> has no children and so is <span class="math">\\varphi</span>-compliant by the base case condition. In the former case we label the children of <span class="math">v</span> with <span class="math">(z_i, \\pi_i, \\mathsf{acc}_i)</span>, and so <span class="math">v</span> is <span class="math">\\varphi</span>-compliant. Moreover, by the soundness of the accumulation scheme, since <span class="math">\\mathrm{D}(\\mathrm{dk}, \\mathrm{acc}^{(v)})</span> and the accumulation verifier accept, it holds that for all descendants <span class="math">w</span>, <span class="math">\\mathrm{D}(\\mathrm{dk}, \\mathrm{acc}^{(w)})</span> accepts and <span class="math">\\Phi_{\\mathcal{V}}(\\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}, (\\mathsf{avk}, z_{\\mathrm{in}}^{(w)}, \\mathsf{acc}^{(w)}), \\pi_{\\mathrm{in}}^{(w)}) = \\mathcal{V}(\\mathrm{ivk}, (\\mathsf{avk}, z_{\\mathrm{in}}^{(w)}, \\mathsf{acc}^{(w)}), \\pi_{\\mathrm{in}}^{(w)})</span> accepts.</p>

    <p class="text-gray-300">Hence by induction, <span class="math">(\\varphi, \\pi, \\mathsf{T}) \\gets \\mathbb{E}</span> has <span class="math">\\varphi</span>-compliant <span class="math">\\mathsf{T}</span>.</p>

    <p class="text-gray-300">Since <span class="math">(\\varphi, \\mathsf{o}(\\mathsf{T}), \\pi)</span> are "passed up" from <span class="math">\\tilde{\\mathbb{P}}</span> via a series of <span class="math">d</span> extractors, the distribution output by <span class="math">\\mathbb{E}</span> is statistically close to the output of <span class="math">\\tilde{\\mathbb{P}}</span> by the knowledge soundness of ARG.</p>

    <h2 id="sec-43" class="text-2xl font-bold">5.5 Zero knowledge</h2>

    <p class="text-gray-300">The simulator <span class="math">\\mathbb{S}</span> operates as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathbb{S}(1^{\\lambda})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate <span class="math">(\\mathsf{pp}_{\\mathsf{AS}}, \\tau_{\\mathsf{AS}}) \\gets \\mathrm{S}(1^{\\lambda})</span>, and <span class="math">(\\mathsf{pp}, \\tau) \\gets \\mathcal{S}(1^{\\lambda})</span>.</li>

      <li>Output <span class="math">(\\mathbb{P}\\mathbb{P} = (\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}),(\\tau ,\\tau_{\\mathsf{AS}}))</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbb{S}(\\mathbb{P}\\mathbb{P} = (\\mathsf{pp},\\mathsf{pp}_{\\mathsf{AS}}),\\varphi ,z,(\\tau ,\\tau_{\\mathsf{AS}}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathsf{acc} \\gets \\mathrm{S}(\\mathsf{pp}_{\\mathsf{AS}}, \\mathsf{pp}, R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}, \\tau_{\\mathsf{AS}})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{apk},\\mathsf{dk},\\mathsf{avk}) \\gets \\mathrm{I}(\\mathsf{pp}_{\\mathsf{AS}},(\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)}))</span>.</li>

      <li>Compute <span class="math">\\pi \\gets \\mathcal{S}(\\mathsf{pp},R_{\\mathrm{V},\\varphi}^{(\\lambda,N,k)},(\\mathsf{avk},z,\\mathsf{acc}),\\tau)</span>.</li>

      <li>Output <span class="math">(\\pi, \\mathrm{acc})</span>.</li>

    </ol>

    <p class="text-gray-300">We consider the following sequence of hybrids.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{H}_0</span>: The original experiment.</li>

      <li><span class="math">\\mathbf{H}_1</span>: As <span class="math">\\mathbf{H}_0</span>, but the public parameters <span class="math">\\mathsf{pp}</span> and proof <span class="math">\\pi</span> are generated by the simulator <span class="math">\\mathcal{S}</span> for ARG.</li>

      <li><span class="math">\\mathbf{H}_2</span>: As <span class="math">\\mathbf{H}_1</span>, but the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> and accumulator <span class="math">\\mathsf{acc}</span> is generated by the simulator <span class="math">\\mathbb{S}</span> for AS. Observe that if <span class="math">\\mathbf{H}_0</span> and <span class="math">\\mathbf{H}_2</span> are indistinguishable, then <span class="math">\\mathbb{S}</span> witnesses the zero knowledge property for PCD.</li>

    </ul>

    <p class="text-gray-300">Since <span class="math">\\mathcal{A}</span> is honest (for PCD), by completeness of AS it induces an honest adversary for ARG, whence <span class="math">\\mathbf{H}_0</span> and <span class="math">\\mathbf{H}_1</span> are indistinguishable by the zero knowledge property of ARG. Note that since they are part of the witness, the input and accumulator lists <span class="math">[q_i]_{i=1}^n, [\\mathsf{acc}_j]_{j=1}^m</span> and verifier proof <span class="math">\\pi_{\\mathrm{V}}</span> are not used in <span class="math">\\mathbf{H}_1</span>. Hence, since <span class="math">\\mathcal{A}</span> induces an honest adversary for AS and the simulated <span class="math">\\mathsf{pp}</span> is indistinguishable from <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^\\lambda)</span>, <span class="math">\\mathbf{H}_1, \\mathbf{H}_2</span> are indistinguishable by the zero knowledge property of AS. This establishes that <span class="math">\\mathbf{H}_0, \\mathbf{H}_2</span> are indistinguishable.</p>

    <h2 id="sec-44" class="text-2xl font-bold">5.6 Post-quantum security</h2>

    <p class="text-gray-300">We consider post-quantum knowledge soundness and zero knowledge.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Knowledge soundness.</h4>

    <p class="text-gray-300">In the quantum setting, <span class="math">\\tilde{\\mathbb{P}}</span> is taken to be a polynomial-size <em>quantum</em> circuit; hence also <span class="math">\\tilde{\\mathcal{P}}_{j},\\mathcal{E}_{\\tilde{\\mathcal{P}}_{j}},\\mathbb{E}_{j}</span> are quantum circuits for all <span class="math">j</span>, as is the final extractor <span class="math">\\mathbb{E}</span>. Our definition of knowledge soundness is such that this proof then generalizes immediately to show security against quantum adversaries. In particular, the only difficulty arising from quantum adversaries is that they can generate their own randomness, whereas in the classical case we can force an adversary to behave deterministically by fixing its randomness. This is accounted for by the distributional requirement placed on the extractor of the argument system <span class="math">\\mathsf{ARG}</span>.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">Zero knowledge.</h4>

    <p class="text-gray-300">From the argument in the preceding section it is clear that, by modifying the definitions of zero knowledge as appropriate for the quantum setting, if <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}</span> both achieve post-quantum zero knowledge, then so does <span class="math">\\mathsf{PCD}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6 Accumulation schemes for non-interactive arguments</p>

    <p class="text-gray-300">We formally restate and then prove Theorem 2, which provides a way to “lift” an accumulation scheme for a predicate into an accumulation scheme for any non-interactive argument whose verifier is succinct when given oracle access to that predicate. Below we define the notion of a predicate-efficient non-interactive argument and then state the theorem that we prove.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> be a non-interactive argument, <span class="math">\\Phi_{\\circ}\\colon\\mathcal{U}(<em>)\\times(\\{0,1\\}^{</em>})^{3}\\to\\{0,1\\}</span> a predicate, and <span class="math">T,\\mathsf{t}\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}</span>. We say that <span class="math">\\mathsf{ARG}</span> is <span class="math">(T,\\mathsf{t})</span>-predicate-efficient with respect to <span class="math">\\Phi_{\\circ}</span> if the following conditions hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The index verification key <span class="math">\\mathrm{ivk}</span> has the form <span class="math">(\\mathsf{i}_{\\circ},\\mathrm{ivk}_{\\mathsf{pe}})</span>.</li>

      <li>The verifier <span class="math">\\mathcal{V}</span> is equivalent to the following decision procedure, for some oracle algorithm <span class="math">\\mathcal{V}_{\\mathsf{pe}}</span>: compute <span class="math">(b,Q_{i})\\leftarrow\\mathcal{V}_{\\mathsf{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathsf{pe}},\\mathtt{x},\\pi)</span>; output <span class="math">1</span> if and only if (a) <span class="math">b=1</span>, and (b) for each <span class="math">\\mathsf{q}\\in Q_{i}</span>, <span class="math">\\Phi_{\\circ}^{\\rho}(\\mathsf{pp},\\mathsf{i}_{\\circ},\\mathsf{q}_{i})=1</span>.</li>

      <li><span class="math">\\mathcal{V}_{\\mathsf{pe}}</span> runs in time <span class="math">T(N,k)</span>, and the number of queries <span class="math">\\mathsf{t}</span> to <span class="math">\\Phi_{\\circ}</span> equals <span class="math">\\mathsf{t}(N,k)</span> for indices <span class="math">\\mathsf{i}</span> of size <span class="math">N</span> and instances <span class="math">\\mathtt{x}</span> of size <span class="math">k</span>.</li>

    </ul>

    <p class="text-gray-300">The following theorem shows that an accumulation scheme for <span class="math">(\\Phi_{\\circ},\\mathcal{G})</span> implies an accumulation scheme for <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{G})</span>, where <span class="math">\\Phi_{\\mathcal{V}}</span> is as specified in Definition 4.1.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{ARG}</span> be a non-interactive argument that is <span class="math">(T,\\mathsf{t})</span>-predicate-efficient with respect to <span class="math">\\Phi_{\\circ}</span>. If <span class="math">(\\Phi_{\\circ},\\mathcal{G})</span> has an accumulation scheme <span class="math">\\mathsf{AS}_{\\circ}</span>, then <span class="math">\\mathsf{ARG}</span> has an accumulation scheme <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> with the efficiency properties below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{G}^{\\rho}(1^{\\lambda})</span> takes time equal to <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{G}^{\\rho}(1^{\\lambda})</span>.</li>

      <li>Indexer: <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{I}^{\\rho}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp},\\mathsf{i})</span> takes time equal to the time to run <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{I}^{\\rho}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{i}_{\\circ})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Accumulation prover: <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{P}^{\\rho}(\\mathsf{apk},[(\\mathtt{x}_{i},\\pi_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m})</span> runs in time $\\sum_{i=1}^{n}T(N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> plus the time taken to run </span>\\mathsf{AS}_{\\circ}.\\mathrm{P}^{\\rho}(\\mathsf{apk}_{\\circ},Q,[\\mathsf{acc}_{j}]_{j=1}^{m})<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\sum_{i=1}^{n}\\mathsf{t}(N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decider: <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc})</span> takes time equal to <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc})</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, if <span class="math">\\mathsf{AS}_{\\circ}</span> is post-quantum secure, then so is <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>, and if <span class="math">\\mathsf{AS}_{\\circ}</span> is zero knowledge, so is <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>.</p>

    <p class="text-gray-300">The rest of this section is dedicated to proving Theorem 6.2: in Section 6.1 we describe the construction of an accumulation scheme for the argument scheme, from which the stated efficiency properties are clear; in Section 6.2 we argue completeness; in Section 6.3 we argue soundness; in Section 6.4 we argue zero knowledge.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 6.3 (efficiency for PCD).</h6>

    <p class="text-gray-300">We briefly discuss the properties required of <span class="math">\\mathsf{ARG}</span> and <span class="math">\\mathsf{AS}_{\\circ}</span> so that, applying Theorem 6.2, we obtain an accumulation scheme suitable for the PCD construction in Section 5. Recall that Theorem 5.2 states that a PCD scheme can be obtained from any SNARK for circuit satisfiability with an accumulation scheme whose accumulation verifier runs in time that is sub-linear in the size <span class="math">N</span> of the circuit. Hence <span class="math">\\mathsf{ARG}</span> must be <span class="math">(T,\\mathsf{t})</span>-predicate-efficient for <span class="math">T,\\mathsf{t}=o(N)</span>, and <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span> must run in time <span class="math">o(N)</span>. In particular, since it is an input to <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span>, the size of an accumulator <span class="math">\\mathsf{acc}</span> for <span class="math">\\mathsf{AS}_{\\circ}</span> must be <span class="math">o(N)</span>. The number of inputs <span class="math">n</span> and accumulators <span class="math">m</span> are both equal to the arity of the compliance predicate and may be regarded as constant. There is no restriction on the running time of <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Remark 6.4.</h6>

    <p class="text-gray-300">Definition 6.1 (and hence Theorem 6.2) restricts <span class="math">\\mathcal{V}</span>’s access to <span class="math">\\Phi_{\\circ}</span>: <span class="math">\\mathcal{V}</span> must reject if any of its queries to <span class="math">\\Phi_{\\circ}</span> are answered with <span class="math">0</span>. In particular, the queries of <span class="math">\\mathcal{V}</span> to <span class="math">\\Phi_{\\circ}</span> are non-adaptive. This is necessary so that the accumulator does not grow with the number of accumulated queries.</p>

    <p class="text-gray-300">We construct the accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>  for  <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{H}_{\\mathsf{ARG}})</span>  (specified in Definition 4.1). The efficiency properties stated in Theorem 6.2 follow from the construction below.</p>

    <p class="text-gray-300">Data structures. An accumulator acc for  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>  is the accumulator for the underlying accumulation scheme  <span class="math">\\mathsf{AS}_{\\circ}</span> .</p>

    <p class="text-gray-300">Generator. On input the security parameter  <span class="math">\\lambda</span>  (in unary),  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> . G samples public parameters  <span class="math">\\mathsf{pp} \\gets \\mathsf{AS}_{\\circ}</span> .  <span class="math">\\mathsf{G}^{\\rho}(1^{\\lambda})</span>  for the accumulation scheme for  <span class="math">(\\Phi_{\\circ}, \\mathcal{H}_{\\circ})</span> , and outputs  <span class="math">\\mathsf{pp}</span> .</p>

    <p class="text-gray-300">Indexer. On input public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> , succinct argument parameters  <span class="math">\\mathsf{pp}</span>  and index  <span class="math">\\mathbf{i}</span> ,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> . I computes index keys  <span class="math">(\\mathrm{ipk}, \\mathrm{ivk} = (\\mathrm{i}_{\\circ}, \\mathrm{ivk}_{\\mathsf{pe}})) \\gets \\mathcal{I}(\\mathsf{pp}, \\mathbf{i})</span>  and accumulation keys  <span class="math">(\\mathsf{apk}_{\\circ}, \\mathsf{avk}_{\\circ}, \\mathsf{dk}_{\\circ}) \\gets \\mathsf{AS}_{\\circ}</span> .  <span class="math">\\mathsf{I}^{\\rho}(\\mathsf{pp}, \\mathrm{i}_{\\circ})</span>  and outputs the accumulation keys  <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk}) := ((\\mathsf{apk}_{\\circ}, \\mathrm{ivk}_{\\mathsf{pe}}), (\\mathsf{avk}_{\\circ}, \\mathrm{ivk}_{\\mathsf{pe}}), \\mathsf{dk}_{\\circ})</span> .</p>

    <p class="text-gray-300">Accumulation prover. On input the accumulator proving key  <span class="math">\\mathsf{apk} = (\\mathsf{apk}_{\\circ}, \\mathsf{ivk}_{\\mathsf{pe}})</span> , instance-proof pairs  <span class="math">[(x_i, \\pi_i)]_{i=1}^n</span> , and old accumulators  <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> ,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> . P computes a new accumulator acc and proof  <span class="math">\\pi_{\\mathrm{V}}</span>  as follows: for each  <span class="math">i \\in [n]</span> , compute  <span class="math">(b_i, Q_i) \\gets \\mathcal{V}_{\\mathsf{pe}}^\\rho(\\mathsf{ivk}_{\\mathsf{pe}}, x_i, \\pi_i)</span> ; then output the new accumulator and proof  <span class="math">(\\mathsf{acc}, \\pi_{\\mathrm{V}}) \\gets \\mathsf{AS}_{\\circ}</span> .  <span class="math">\\mathsf{P}^{\\rho}(\\mathsf{apk}_{\\circ}, \\cup_{i=1}^n Q_i, [\\mathsf{acc}_j]_{j=1}^m)</span> .</p>

    <p class="text-gray-300">Accumulation verifier. On input the accumulation verification key  <span class="math">\\mathsf{avk} = (\\mathsf{avk}_{\\circ}, \\mathsf{ivk}_{\\mathsf{pe}})</span> , instance-proof pairs  <span class="math">[(x_i, \\pi_i)]_{i=1}^n</span> , old accumulators  <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> , the new accumulator acc, and a proof  <span class="math">\\pi_{\\mathrm{V}}</span> ,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> . V works as follows. For each  <span class="math">i \\in [n]</span> , compute  <span class="math">(b_i, Q_i) \\gets \\mathcal{V}_{\\mathsf{pe}}^\\rho(\\mathsf{ivk}_{\\mathsf{pe}}, x_i, \\pi_i)</span> , and check that  <span class="math">b_i = 1</span> , and then accept if the new accumulator is valid, i.e.,  <span class="math">\\mathsf{AS}_{\\circ}</span> .  <span class="math">\\mathsf{V}^{\\rho}(\\mathsf{avk}_{\\circ}, Q := \\cup_{i=1}^{n} Q_i, [\\mathsf{acc}_j]_{j=1}^m, \\mathsf{acc}, \\pi_{\\mathrm{V}}) = 1</span> .</p>

    <p class="text-gray-300">Decider. On input decision key  <span class="math">\\mathrm{dk} = \\mathrm{dk}_{\\circ}</span>  and accumulator acc,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span> . D accepts if  <span class="math">\\mathsf{AS}_{\\circ}</span> .  <span class="math">\\mathsf{D}^{\\rho}(\\mathsf{dk}_{\\circ}, \\mathsf{acc}) = 1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be a (possibly inefficient) adversary that breaks the completeness of the accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>  for  <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{G})</span>  in Section 6.1. That is, the following probability is non-zero:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall j \\in [ m ], \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathrm {a c c} _ {j}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall i \\in [ n ], \\Phi_ {\\mathrm {V}} ^ {\\rho} (\\mathrm {p p}, \\mathrm {i}, (\\mathrm {x} _ {i}, \\pi_ {i})) = 1 &amp;amp; \\mathrm {p p} _ {\\mathrm {A S}} \\leftarrow \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\Downarrow &amp;amp; \\mathrm {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {V} ^ {\\rho} \\left( \\begin{array}{c c} \\mathrm {a v k} &amp;amp; [ (\\mathrm {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n} \\\\ &amp;amp; \\mathrm {a c c} \\pi_ {\\mathrm {V}} \\end{array} \\right) &amp;amp; (\\mathrm {i}, [ (\\mathrm {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n}, [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {p p} _ {\\mathrm {A S}}, \\mathrm {p p}) \\\\ \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathrm {a c c}) = 1 &amp;amp; (\\mathrm {a c c}, \\pi_ {\\mathrm {V}}) \\leftarrow \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {P} ^ {\\rho} \\left( \\begin{array}{c c} \\mathrm {a p k} &amp;amp; [ (\\mathrm {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n} \\\\ &amp;amp; [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m} \\end{array} \\right) \\end{array} \\right]. \\tag {3}</span></div>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{A}</span>  to construct adversary  <span class="math">\\mathcal{B}</span>  that breaks the completeness of the accumulation scheme  <span class="math">\\mathrm{AS}_{\\circ}</span>  for  <span class="math">(\\Phi_{\\circ},\\mathcal{G})</span> . That is,  <span class="math">\\mathcal{B}</span>  makes the following probability nonzero:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall j \\in [ m ], \\mathrm {A S} _ {\\circ}. \\mathrm {D} ^ {\\rho} \\left(\\mathrm {p p} _ {\\circ}, \\mathrm {d k} _ {\\circ}, \\mathrm {a c c} _ {j}\\right) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\forall i \\in [ n ], \\Phi_ {\\circ} ^ {\\rho} \\left(\\mathrm {p p}, \\mathrm {i} _ {\\circ}, \\mathrm {q} _ {i}\\right) = 1 &amp;amp; \\mathrm {p p} _ {\\circ} \\leftarrow \\mathrm {A S} _ {\\circ}. \\mathrm {G} ^ {\\rho} \\left(1 ^ {\\lambda}\\right) \\\\ \\Downarrow &amp;amp; \\mathrm {p p} \\leftarrow \\mathcal {G} ^ {\\rho} \\left(1 ^ {\\lambda}\\right) \\\\ \\mathrm {A S} _ {\\circ}. \\mathrm {V} ^ {\\rho} \\left( \\begin{array}{l l} \\mathrm {a v k} _ {\\circ} &amp;amp; [ \\mathrm {q} _ {i} ] _ {i = 1} ^ {n} \\\\ &amp;amp; \\mathrm {a c c} \\pi_ {\\mathrm {V}} \\end{array} \\right) = 1 &amp;amp; \\left( \\begin{array}{l l} (\\mathrm {i} _ {\\circ}, [ \\mathrm {q} _ {i} ] _ {i = 1} ^ {n}, [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m}) \\leftarrow \\mathcal {B} ^ {\\rho} (\\mathrm {p p} _ {\\circ}, \\mathrm {p p}) \\\\ (\\mathrm {a p k} _ {\\circ}, \\mathrm {a v k} _ {\\circ}, \\mathrm {d k} _ {\\circ}) \\leftarrow \\mathrm {A S} _ {\\circ}. \\mathrm {I} ^ {\\rho} (\\mathrm {p p} _ {\\circ}, \\mathrm {p p}, \\mathrm {i} _ {\\circ}) \\\\ (\\mathrm {a c c}, \\pi_ {\\mathrm {V}}) \\leftarrow \\mathrm {A S} _ {\\circ}. \\mathrm {P} ^ {\\rho} \\left( \\begin{array}{l l} \\mathrm {a p k} _ {\\circ} &amp;amp; [ \\mathrm {q} _ {i} ] _ {i = 1} ^ {n} \\\\ &amp;amp; [ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m} \\end{array} \\right) \\end{array} \\right] \\end{array} \\right]. \\tag {4}</span></div>

    <p class="text-gray-300">We define the adversary  <span class="math">\\mathcal{B}</span>  to operate as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho}(\\mathsf{pp}_{\\circ},\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\dot{\\mathbf{i}},[(\\mathfrak{x}_i,\\pi_i)]_{i = 1}^n,[acc_j]_j^m)_j = \\mathcal{A}^\\rho (\\mathsf{pp}_{\\mathsf{AS}} = \\mathsf{pp}_{\\circ},\\mathsf{pp})</span></li>

      <li>Compute  <span class="math">(\\mathrm{ipk},\\mathrm{ivk} = (\\mathrm{i}_{\\circ},\\mathrm{ivk}_{\\mathrm{pe}}))\\gets \\mathcal{I}^{\\rho}(\\mathsf{pp},\\dot{\\mathbf{i}})</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  , compute  <span class="math">(b_{i},Q_{i})\\gets \\mathcal{V}_{\\mathrm{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathrm{pe}},\\mathfrak{x}_i,\\pi_i)</span></li>

      <li>Set  <span class="math">Q \\coloneqq \\cup_{i=1}^{n} Q_i</span>  and output  <span class="math">(\\mathrm{i}_{\\circ}, Q, [\\mathrm{acc}_j]_j^m)</span> .</li>

    </ol>

    <p class="text-gray-300">By construction, the distribution of  <span class="math">\\rho</span> ,  <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span>  and  <span class="math">\\mathsf{pp}</span>  are identical in both experiments, and hence so is the output of  <span class="math">\\mathcal{A}</span> . It remains to show that for every fixed choice of these variables, the implication in Eq. (4) does not hold. We first use Eq. (3) to argue that the premises of the implication in Eq. (4) are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">j \\in [m]</span> , we know that  <span class="math">\\mathsf{AS}_{\\circ} \\cdot \\mathsf{D}^{\\rho}(\\mathsf{dk}_{\\circ}, \\mathsf{acc}_j) = 1</span>  because  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}} \\cdot \\mathsf{D}^{\\rho}(\\mathsf{dk}, \\mathsf{acc}_j) = 1</span> , and so the corresponding condition in Eq. (4) is satisfied.</li>

      <li>For each  <span class="math">i \\in [n]</span> ,  <span class="math">\\Phi_{\\mathcal{V}}^{\\rho}(\\mathsf{pp}, \\dot{\\mathbf{i}}, (\\mathfrak{x}_i, \\pi_i)) = 1</span> . This means that  <span class="math">\\mathcal{V}^{\\rho}(\\mathrm{ivk}, \\mathfrak{x}_i, \\pi_i) = 1</span> , which in turn implies that  <span class="math">\\mathcal{V}_{\\mathrm{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathrm{pe}}, \\mathfrak{x}_i, \\pi_i) = (1, Q_i)</span>  and, for each query  <span class="math">\\mathfrak{q} \\in Q_i</span> , the predicate  <span class="math">\\Phi_{\\circ}^{\\rho}(\\mathsf{pp}, \\dot{\\mathbf{i}}_{\\circ}, \\mathfrak{q}) = 1</span> . Hence, for each  <span class="math">\\mathfrak{q} \\in Q = \\cup_{i=1}^{n} Q_i</span> ,  <span class="math">\\Phi_{\\circ}^{\\rho}(\\mathsf{pp}, \\dot{\\mathbf{i}}_{\\circ}, \\mathfrak{q}) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">We are now left to show that at least one of  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}^{\\rho}(\\mathsf{avk}_{\\circ},\\cup_{i = 1}^{n}Q_{i},[\\mathsf{acc}_{j}]_{j = 1}^{m},\\mathsf{acc},\\pi_{\\mathrm{V}})</span>  or  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc})</span>  rejects. We do this by considering each case.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By construction,  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc})</span>  rejects if and only if  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc})</span>  rejects.</li>

      <li>By construction,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{V}^{\\rho}(\\mathsf{avk},[(\\mathfrak{x}_i,\\pi_i)]_{i = 1}^n,[acc_j]_{j = 1}^m,\\mathsf{acc},\\pi_{\\mathrm{V}})</span>  rejects if at least one of the following conditions is satisfied:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some  <span class="math">i \\in [n]</span> ,  <span class="math">\\mathcal{V}_{\\mathrm{pe}}</span>  rejects:  <span class="math">\\mathcal{V}_{\\mathrm{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathrm{pe}}, \\mathfrak{x}_i, \\pi_i) = (0, Q_i)</span> .</li>

      <li><span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span>  rejects:  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}^{\\rho}(\\mathsf{avk}_{\\circ},Q = \\cup_{i = 1}^{n}Q_{i},[\\mathsf{acc}_{j}]_{j = 1}^{m},\\mathsf{acc},\\pi_{\\mathrm{V}}) = 0.</span></li>

    </ul>

    <p class="text-gray-300">However, because  <span class="math">\\Phi_{\\mathcal{V}}^{\\rho}\\big(\\mathsf{pp},\\dot{\\mathbf{i}},(\\mathfrak{x}_i,\\pi_i)\\big) = 1</span> , we know that  <span class="math">\\mathcal{V}_{\\mathrm{pe}}</span>  accepts. Hence, if  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{V}</span>  rejects, it must be because  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}</span>  also rejects.</p>

    <p class="text-gray-300">Together, these cases imply that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf {A S} _ {\\mathsf {A R G}}. \\mathrm {V} ^ {\\rho} (\\mathsf {a v k}, [ (\\mathfrak {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n}, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}, \\mathsf {a c c}, \\pi_ {\\mathrm {V}}) = 0 \\lor \\mathsf {A S} _ {\\mathsf {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathsf {d k}, \\mathsf {a c c}) = 0 \\\\ \\begin{array}{c} \\Downarrow \\\\ \\Downarrow \\end{array} \\\\ \\mathsf {A S} _ {\\circ}. \\mathrm {V} ^ {\\rho} (\\mathsf {a v k} _ {\\circ}, Q, [ \\mathsf {a c c} _ {j} ] _ {j = 1} ^ {m}, \\mathsf {a c c}, \\pi_ {\\mathrm {V}}) = 0 \\quad \\vee \\quad \\mathsf {A S} _ {\\circ}. \\mathrm {D} ^ {\\rho} (\\mathsf {d k} _ {\\circ}, \\mathsf {a c c}) = 0. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Thus if  <span class="math">\\mathcal{A}</span>  breaks completeness of the accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>  for  <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{H}_{\\mathsf{ARG}})</span>  then  <span class="math">\\mathcal{B}</span>  breaks completeness of the accumulation scheme  <span class="math">\\mathsf{AS}_{\\circ}</span>  for  <span class="math">(\\Phi_{\\circ},\\mathcal{H}_{\\circ})</span>  (a contradiction).</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}</span>  be an efficient adversary that breaks the soundness of the accumulation scheme  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>  for  <span class="math">(\\Phi_{\\mathcal{V}},\\mathcal{G})</span> . This means that the following probability is non-negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {V} ^ {\\rho} \\left( \\begin{array}{c c} \\mathrm {a v k} &amp;amp; [ (\\mathfrak {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n} \\\\ \\mathrm {a c c} &amp;amp; \\pi_ {\\mathrm {V}} \\end{array} \\right) = 1 \\\\ \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathrm {a c c}) = 1 \\\\ \\Downarrow \\\\ \\forall j \\in [ m ], \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathrm {a c c} _ {j}) = 1 \\\\ \\forall i \\in [ n ], \\Phi_ {\\mathcal {V}} ^ {\\rho} \\left(\\mathrm {p p}, \\mathrm {i}, (\\mathfrak {x} _ {i}, \\pi_ {i})\\right) = 1 \\end{array} \\right] \\begin{array}{c c} \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {p p} _ {\\mathrm {A S}} \\leftarrow \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathrm {p p} \\leftarrow \\mathcal {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\left(\\mathrm {i} &amp;amp; [ (\\mathfrak {x} _ {i}, \\pi_ {i}) ] _ {i = 1} ^ {n} \\\\ \\mathrm {a c c} &amp;amp; \\pi_ {\\mathrm {V}} \\end{array} \\left( \\begin{array}{c c} \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m} \\\\ \\mathrm {a c c} _ {j} ] _ {j = 1} ^ {m} \\end{array} \\right) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {p p} _ {\\mathrm {A S}}, \\mathrm {p p}) \\\\ (\\mathrm {a p k}, \\mathrm {a v k}, \\mathrm {d k}) \\leftarrow \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {I} ^ {\\rho} (\\mathrm {p p} _ {\\mathrm {A S}}, \\mathrm {p p}, \\dot {\\mathrm {i}}) \\end{array} .</span></div>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{A}</span>  to construct an adversary  <span class="math">\\mathcal{B}</span>  that breaks the soundness of the accumulation scheme  <span class="math">\\mathrm{AS}_{\\circ}</span>  for  <span class="math">(\\Phi_{\\circ},\\mathcal{G})</span> . That is,  <span class="math">\\mathcal{B}</span>  makes the following probability non-negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {A S} _ {\\circ}. \\mathrm {V} ^ {\\rho} \\left(\\mathrm {a v k} _ {\\circ}, \\left[ q _ {i} \\right] _ {i = 1} ^ {n}, \\left[ \\mathrm {a c c} _ {j} \\right] _ {j = 1} ^ {m}, \\mathrm {a c c}, \\pi_ {\\mathrm {V}}\\right) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {A S} _ {\\circ}. \\mathrm {D} ^ {\\rho} \\left(\\mathrm {d k} _ {\\circ}, \\mathrm {a c c}\\right) = 1 &amp;amp; \\mathrm {p p} _ {\\circ} \\leftarrow \\mathrm {A S} _ {\\circ}. \\mathrm {G} ^ {\\rho} \\left(1 ^ {\\lambda}\\right) \\\\ \\Downarrow &amp;amp; \\mathrm {p p} \\leftarrow \\mathcal {G} ^ {\\rho} \\left(1 ^ {\\lambda}\\right) \\\\ \\forall j \\in [ m ], \\mathrm {A S} _ {\\circ}. \\mathrm {D} ^ {\\rho} \\left(\\mathrm {d k} _ {\\circ}, \\mathrm {a c c} _ {j}\\right) = 1 &amp;amp; \\left( \\begin{array}{c c c} \\mathrm {i} _ {\\circ} &amp;amp; \\left[ q _ {i} \\right] _ {i = 1} ^ {n} &amp;amp; \\left[ \\mathrm {a c c} _ {j} \\right] _ {j = 1} ^ {m} \\\\ &amp;amp; \\mathrm {a c c} &amp;amp; \\pi_ {\\mathrm {V}} \\end{array} \\right) \\leftarrow \\mathcal {B} ^ {\\rho} \\left(\\mathrm {p p} _ {\\circ}, \\mathrm {p p}\\right) \\\\ \\forall i \\in [ n ], \\Phi^ {\\rho} (\\mathrm {p p}, \\mathrm {i} _ {\\circ}, \\mathrm {q} _ {i}) = 1 &amp;amp; \\left(\\mathrm {a p k} _ {\\circ}, \\mathrm {a v k} _ {\\circ}, \\mathrm {d k} _ {\\circ}\\right) \\leftarrow \\mathrm {A S} _ {\\circ}. \\mathrm {I} ^ {\\rho} \\left(\\mathrm {p p} _ {\\circ}, \\mathrm {i} _ {\\circ}\\right) \\end{array} \\right]. \\tag {6}</span></div>

    <p class="text-gray-300">We define the adversary  <span class="math">\\mathcal{B}</span>  to operate as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho}(\\mathsf{pp}_{\\circ},\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\dot{\\mathfrak{i}},[(\\mathfrak{x}_i,\\pi_i)]_{i = 1}^n,[acc_j]_j^m,\\mathrm{acc},\\pi_{\\mathrm{V}})\\gets \\mathcal{A}^\\rho (\\mathsf{pp}_{\\mathrm{AS}} = \\mathsf{pp}_{\\circ},\\mathsf{pp}).</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  , compute  <span class="math">(b_{i},Q_{i})\\gets \\mathcal{V}_{\\mathrm{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathrm{pe}},\\mathfrak{x}_{i},\\pi_{i})</span></li>

      <li>Set  <span class="math">Q \\coloneqq \\cup_{i=1}^{n} Q_i</span>  and output  <span class="math">(Q, [\\mathrm{acc}_j]_j^m, i_\\circ, \\mathrm{acc}, \\pi_V)</span> .</li>

    </ol>

    <p class="text-gray-300">By construction, the distribution of  <span class="math">\\rho</span> ,  <span class="math">\\mathsf{pp}_{\\mathrm{AS}}</span> , and  <span class="math">\\mathsf{pp}</span>  are identical in both experiments, and hence so is the output of  <span class="math">\\mathcal{A}</span> . It remains to show that for every fixed choice of these variables, the implication in Eq. (6) does not hold. We start by using Eq. (5) to argue that the premises of the implication in Eq. (6) are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By construction,  <span class="math">\\mathsf{AS}_{\\circ}.\\mathsf{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc}) = \\mathsf{AS}_{\\mathsf{ARG}}.\\mathsf{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc})</span></li>

      <li>By construction of  <span class="math">\\mathrm{V}</span> , we know that if  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{V}^{\\rho}(\\mathsf{avk},[(\\mathfrak{x}_i,\\pi_i)]_{i = 1}^n,[acc_j]_j^m,\\mathsf{acc},\\pi_{\\mathrm{V}})</span>  accepts, then  <span class="math">\\mathsf{AS}_{\\circ}.\\mathrm{V}^{\\rho}(\\mathsf{apk}_{\\circ},Q\\coloneqq \\cup_{i = 1}^{n}Q_{i},[acc_{j}]_{j = 1}^{m},\\mathsf{acc},\\pi_{\\mathrm{V}})</span>  also accepts.</li>

    </ul>

    <p class="text-gray-300">We are now left to show that at least one of the following occurs: (a) for some  <span class="math">j \\in [m]</span> ,  <span class="math">\\mathsf{AS}_{\\circ}.\\mathsf{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc}_{j})</span>  rejects, or (b) for some  <span class="math">\\mathfrak{q} \\in Q</span> ,  <span class="math">\\Phi_{\\circ}^{\\rho}(\\mathsf{pp},\\mathrm{i}_{\\circ},\\mathfrak{q}) = 0</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By construction,  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathsf{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc}_j) = 0</span>  for some  <span class="math">j\\in [m]</span>  implies that  <span class="math">\\mathsf{AS}_{\\circ}.\\mathsf{D}^{\\rho}(\\mathsf{dk}_{\\circ},\\mathsf{acc}_j) = 0</span></li>

      <li>We know that  <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}.\\mathrm{V}^{\\rho}(\\mathsf{avk},[(\\mathfrak{x}_i,\\pi_i)]_{i = 1}^n,[acc_j]_j^m,\\mathsf{acc},\\pi_{\\mathrm{V}}) = 1</span> . Hence, for each  <span class="math">i\\in [n]</span> ,  <span class="math">\\mathcal{V}_{\\mathrm{pe}}^{\\rho}(\\mathrm{ivk}_{\\mathrm{pe}},\\mathfrak{x}_i,\\pi_i)</span>  accepts and outputs a query set  <span class="math">Q_{i}</span> . This in turn implies that if there does exist  <span class="math">k\\in [n]</span>  such that  <span class="math">\\Phi_{\\mathcal{V}}^{\\rho}(\\mathsf{pp},\\dot{\\mathfrak{i}},(\\mathfrak{x}_k,\\pi_k))</span>  rejects, then there exists  <span class="math">\\mathfrak{q}\\in Q_k\\subseteq Q</span>  such that  <span class="math">\\Phi_{\\circ}^{\\rho}(\\mathsf{pp},\\mathrm{i}_{\\circ},\\mathfrak{q}) = 0</span> .</li>

    </ul>

    <p class="text-gray-300">Together, these cases imply that</p>

    <div class="my-4 text-center"><span class="math-block">\\exists j \\in [ m ] \\text {s . t .} \\mathrm {A S} _ {\\mathrm {A R G}}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathrm {a c c} _ {j}) = 0 \\vee \\exists i \\in [ n ] \\text {s . t .} \\Phi_ {\\mathcal {V}} ^ {\\rho} (\\mathrm {p p}, \\dot {\\mathrm {i}}, (\\mathrm {x} _ {i}, \\pi_ {i})) = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Downarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">\\exists j \\in [ m ] \\text {s . t .} \\mathrm {A S} _ {\\circ}. \\mathrm {D} ^ {\\rho} (\\mathrm {d k} _ {\\circ}, \\mathrm {a c c} _ {j}) = 0 \\vee \\exists \\mathrm {q} \\in Q \\text {s . t .} \\Phi_ {\\circ} ^ {\\rho} (\\mathrm {p p}, \\mathrm {i} _ {\\circ}, \\mathrm {q}) = 0</span></div>

    <p class="text-gray-300">Hence  <span class="math">\\mathcal{B}</span>  breaks the soundness of  <span class="math">\\mathrm{AS}_{\\circ}</span>  whenever  <span class="math">\\mathcal{A}</span>  breaks the soundness of  <span class="math">\\mathrm{AS}_{\\mathrm{ARG}}</span> .</p>

    <p class="text-gray-300">Post-quantum security. Note that the soundness argument applies equally to quantum adversaries  <span class="math">\\mathcal{A}</span> , and so if  <span class="math">\\mathrm{AS}_{\\circ}</span>  is post-quantum secure, then so is  <span class="math">\\mathrm{AS}_{\\mathrm{ARG}}</span> .</p>

    <p class="text-gray-300">We construct the simulator  <span class="math">\\mathrm{S}_{\\mathrm{ARG}}</span>  for  <span class="math">\\mathrm{AS}_{\\mathrm{ARG}}</span>  using the simulator  <span class="math">\\mathrm{S}_{\\circ}</span>  for  <span class="math">\\mathrm{AS}_{\\circ}</span> . The first stage of  <span class="math">\\mathrm{S}_{\\mathrm{ARG}}</span>  is identical to  <span class="math">\\mathrm{S}_{\\circ}</span> :  <span class="math">\\mathrm{S}_{\\mathrm{ARG}}(1^{\\lambda}) = \\mathrm{S}_{\\circ}(1^{\\lambda})</span> . The second stage is as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{S}_{\\mathrm{ARG}}(\\mathsf{pp},\\tau ,\\dot{\\mathsf{i}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run (ipk, ivk = (i, ivkpe)) ← I^ρ(pp, i).</li>

      <li>Output  <span class="math">(\\mathrm{acc},\\mu)\\gets \\mathrm{S}_{\\circ}(\\mathrm{pp},\\tau ,\\mathrm{i}_{\\circ})</span></li>

    </ol>

    <p class="text-gray-300">For an “honest” adversary <span class="math">\\mathcal{A}</span> for <span class="math">\\mathsf{AS}_{\\mathsf{ARG}}</span>, the adversary <span class="math">\\mathcal{B}</span> described in Section 6.2 is an “honest” adversary for <span class="math">\\mathsf{AS}_{\\circ}</span>. Moreover, the “view” of <span class="math">\\mathrm{S}_{\\circ}</span> is the same when <span class="math">\\mathrm{S}_{\\mathsf{ARG}}</span> is interacting with <span class="math">\\mathcal{A}</span> as when <span class="math">\\mathrm{S}_{\\circ}</span> is interacting directly with <span class="math">\\mathcal{B}</span>. Hence, the zero knowledge property of <span class="math">\\mathsf{AS}_{\\circ}</span> ensures that the output of <span class="math">\\mathrm{S}_{\\mathsf{ARG}}</span> is indistinguishable from that in the honest case.</p>

    <p class="text-gray-300">Post-quantum security. We simply observe that this argument also implies that quantum computational indistinguishability is preserved, and continues to hold when <span class="math">\\mathcal{A}</span> is a quantum circuit.</p>

    <p class="text-gray-300">7 Accumulating polynomial commitments based on discrete logarithms</p>

    <p class="text-gray-300">We construct an accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>, a polynomial commitment scheme that is inspired from several prior works <em>[x1, x2, x3]</em> and which we describe in Appendix A.</p>

    <p class="text-gray-300">The scheme <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> is secure in the random oracle model assuming hardness of the discrete logarithm problem, and has the attractive feature that evaluation proofs are <span class="math">O(\\log d)</span> elements in <span class="math">\\mathbb{G}</span>, where <span class="math">d</span> is the degree of the committed polynomial. However, <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> has the drawback that checking an evaluation proof requires <span class="math">O(d)</span> scalar multiplications in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Our accumulation scheme for <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>, which is based on the batching ideas of <em>[x4]</em>, enables deferring the expensive check to the decider: the accumulation verifier <span class="math">\\mathrm{V}</span> only requires <span class="math">O(\\log d)</span> scalar multiplications per accumulation, while the decider <span class="math">\\mathrm{D}</span> requires <span class="math">O(d)</span> scalar multiplications. Hence, checking <span class="math">n</span> evaluation proofs requires a total of <span class="math">O(n\\log d+d)</span> scalar multiplications, as opposed to <span class="math">\\Omega(n\\cdot d)</span> for the naive approach.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 7.1.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> described in Appendix A is a polynomial commitment scheme then the tuple <span class="math">\\mathsf{AS}=(\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span> constructed in Section 7.1 is a zero-knowledge accumulation scheme in the random oracle model for <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>. <span class="math">\\mathsf{AS}</span> achieves the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathrm{G}(1^{\\lambda})</span> runs in time <span class="math">O(\\lambda)</span>.</li>

      <li>Indexer: <span class="math">\\mathrm{I}(\\mathsf{pp},\\mathsf{i}_{\\Phi})</span> runs in time <span class="math">O_{\\lambda}(d)</span>.</li>

      <li>Accumulation prover: The time of <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[((C_{i},d_{i},z_{i},v_{i}),\\pi_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m})</span> is dominated by the time to perform <span class="math">O(n+m+d)</span> scalar multiplications in <span class="math">\\mathbb{G}</span>.</li>

      <li>Accumulator size: The output accumulator is a polynomial commitment consisting of one element in <span class="math">\\mathbb{G}</span> plus an evaluation proof consisting of <span class="math">O(\\log d)</span> elements in <span class="math">\\mathbb{G}</span>.</li>

      <li>Accumulation proof size: The accumulation proof <span class="math">\\pi_{\\mathrm{V}}</span> consists of two elements in <span class="math">\\mathbb{F}_{q}</span> and one element in <span class="math">\\mathbb{G}</span>.</li>

      <li>Accumulation verifier: The time of <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[((C_{i},d_{i},z_{i},v_{i}),\\pi_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m},\\mathsf{acc})</span> is dominated by the time to perform <span class="math">O((n+m)\\cdot\\log d)</span> scalar multiplications in <span class="math">\\mathbb{G}</span>.</li>

      <li>Decider: The time of <span class="math">\\mathrm{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc})</span> is dominated by the time to perform <span class="math">O(d)</span> scalar multiplications in <span class="math">\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">Recall that obtaining an accumulation scheme for a polynomial commitment scheme entails obtaining an accumulation scheme for the pair <span class="math">(\\Phi_{\\mathsf{PC}},\\mathcal{H}_{\\textsc{pc},D})</span> specified in Definition 4.2.</p>

    <p class="text-gray-300">We remark that Theorem 7.1 considers the special case of accumulating claims about a single degree bound (when the input to <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>.<span class="math">\\mathsf{Trim}</span> is a singleton). We leave the case of multiple degree bounds to future work (and believe that the degree enforcement techniques in <em>[x10]</em> would work in this setting).</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">7.1 Construction</h3>

    <p class="text-gray-300">We present our accumulation scheme <span class="math">\\mathsf{AS}</span> for <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>. Recall that the definition of an accumulation scheme requires simultaneous accumulation of previous accumulators and of new instances. In <span class="math">\\mathsf{AS}</span> below, accumulators and instances are both evaluation proofs for openings of committed polynomials. That is, an accumulator <span class="math">\\mathsf{acc}</span> and an instance <span class="math">\\mathsf{q}</span> are both of the form <span class="math">((C,d,z,v),\\pi)</span>. Furthermore, the predicate <span class="math">\\Phi_{\\mathsf{PC}}</span> (from Definition 4.2) and the accumulation decider <span class="math">\\mathrm{D}</span> are identical, and so there is no distinction between new instances and previous accumulators. Below, we exploit this to simplify exposition by accumulating only instances.</p>

    <p class="text-gray-300">Our construction below uses algorithms from <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> defined in Appendix A. In particular, we use the subroutine <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{SuccinctCheck}</span> (see Figure 2) which is the “succinct” part of <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{Check}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the algorithms of both <span class="math">\\mathsf{AS}</span> and <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> use random oracles. For security, we must ensure that the random oracle used by the algorithms of <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> differs from that used by the algorithms of <span class="math">\\mathsf{AS}</span>. We do so by relying on domain separation: we derive two different random oracles $\\rho_{0}(\\cdot):=\\rho(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math"> (for </span>\\mathsf{PC}_{\\textsc{dl}}$) and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\rho_{1}(\\cdot) \\coloneqq \\rho(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math">  (for AS) from the common random oracle  </span>\\rho<span class="math"> . Below, as in the rest of the paper, we use  </span>[n]<span class="math">  to specifically denote the set of integers  </span>\\{1,\\dots ,n\\}$ . We highlight in blue the parts of the construction that are only necessary to make the accumulator zero-knowledge. If zero-knowledge is not required these parts can be dropped without affecting soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Generator. On input a security parameter  <span class="math">1^{\\lambda}</span> , the generator  <span class="math">G</span>  outputs  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">Indexer. On input the accumulator parameters  <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> , the  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> , and a predicate index  <span class="math">\\mathsf{i}_{\\Phi} = D</span> , the indexer I proceeds as follows. Compute the committer and receiver keys  <span class="math">(\\mathsf{ck}_{\\mathsf{PC}}, \\mathsf{rk}_{\\mathsf{PC}}) := \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{PC}}, D)</span> . Parse  <span class="math">\\mathsf{ck}_{\\mathsf{PC}}</span>  as a tuple  <span class="math">(\\mathsf{ck}, H)</span> , and  <span class="math">\\mathsf{ck}</span>  as  <span class="math">(\\langle \\mathsf{group} \\rangle, \\mathsf{hk}, S)</span> . Additionally, compute the committer key for committing to linear polynomials:  <span class="math">\\mathsf{ck}_{\\mathsf{PC}}^{(1)} := \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{PC}}, 1)</span> . Set  <span class="math">\\mathsf{rk} := (\\langle \\mathsf{group} \\rangle, S, H, D)</span> ,  <span class="math">\\mathsf{avk} := (\\mathsf{rk}, \\mathsf{ck}_{\\mathsf{PC}}^{(1)})</span> , and output the accumulator proving key  <span class="math">\\mathsf{apk} := (\\mathsf{ck}_{\\mathsf{PC}}, \\mathsf{avk})</span> , the accumulator verification key  <span class="math">\\mathsf{avk}</span> , and decision key  <span class="math">\\mathsf{dk} := \\mathsf{rk}_{\\mathsf{PC}}</span> .</p>

    <p class="text-gray-300">Common subroutine. The accumulation prover and verifier share a common subroutine, described below.</p>

    <p class="text-gray-300"><span class="math">T^{\\rho}(\\mathsf{avk},[\\mathsf{q}_i]_{i = 1}^n,\\pi_{\\mathrm{V}})</span>  ..</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse avk as  <span class="math">(\\mathsf{rk},\\mathsf{ck}_{\\mathsf{PC}}^{(1)})</span>  , and rk as  <span class="math">(\\langle \\mathrm{group}\\rangle = (\\mathbb{G},q,G),S,H,D)</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  .. (a) Parse  <span class="math">\\mathfrak{q}_i</span>  as a tuple  <span class="math">((C_i,d_i,z_i,v_i),\\pi_i)</span>  (b) Compute  <span class="math">(h_i(X),U_i)\\coloneqq \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{SucinctCheck}^{\\rho_0}(\\mathsf{rk},C_i,z_i,v_i,\\pi_i)</span>  (see Figure 2).</li>

      <li>For each  <span class="math">i</span>  in  <span class="math">[n]</span>  , check that  <span class="math">d_{i} = D</span>  . (We accumulate only the degree bound  <span class="math">D</span>  .)</li>

      <li>Parse  <span class="math">\\pi_{\\mathrm{V}}</span>  as  <span class="math">(h_0,U_0,\\omega)</span>  , where  <span class="math">h_0(X) = aX + b\\in \\mathbb{F}_q[X]</span> <span class="math">U_{0}\\in \\mathbb{G}</span>  , and  <span class="math">\\omega \\in \\mathbb{F}_q</span></li>

      <li>Check that  <span class="math">U_{0}</span>  is a deterministic commitment to  <span class="math">h_0</span> :  <span class="math">U_{0} = \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Commit}^{\\rho_{0}}(\\mathsf{ck}_{\\mathsf{PC}}^{(1)},h;\\omega = \\bot)</span></li>

      <li>Compute the challenge  <span class="math">\\alpha \\coloneqq \\rho_1([h_i,U_i]_{i = 0}^n)\\in \\mathbb{F}_q</span></li>

      <li>Set the polynomial  <span class="math">h(X) \\coloneqq \\sum_{i=0}^{n} \\alpha^i h_i(X) \\in \\mathbb{F}_q[X]</span> .</li>

      <li>Compute the accumulated commitment  <span class="math">C\\coloneqq \\sum_{i = 0}^{n}\\alpha^{i}U_{i}</span></li>

      <li>Compute the challenge  <span class="math">z\\coloneqq \\rho_1(C,h)\\in \\mathbb{F}_q</span></li>

      <li>Randomize  <span class="math">C\\colon \\bar{C}\\coloneqq C + \\omega S\\in \\mathbb{G}</span></li>

      <li>Output  <span class="math">(\\bar{C},d,z,h(X))</span></li>

    </ol>

    <p class="text-gray-300">Accumulation prover. On input the accumulator proving key  <span class="math">\\mathsf{apk} = (\\mathsf{ck}_{\\mathsf{PC}},\\mathsf{avk})</span> , and new inputs  <span class="math">[\\mathbf{q}_i]_{i = 1}^n</span> , the accumulation prover  <span class="math">\\mathrm{P}</span>  proceeds as follows. Sample a random linear polynomial  <span class="math">h_0\\in \\mathbb{F}_q[X]</span>  and then compute a deterministic commitment to  <span class="math">h_0</span> :  <span class="math">U_{0}\\coloneqq \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Commit}^{\\rho_{0}}(\\mathsf{ck}_{\\mathsf{PC}},h_{0},d;\\omega = \\bot)</span> . Sample commitment randomness  <span class="math">\\omega \\in \\mathbb{F}_q</span> , and set  <span class="math">\\pi_{\\mathrm{V}}\\coloneqq (h_0,U_0,\\omega)</span> . Then, compute the tuple  <span class="math">(C,d,z,h(X))\\coloneqq T^{\\rho}(\\mathsf{avk},[\\mathbf{q}_i]_{i = 1}^n,\\pi_{\\mathrm{V}})</span> . Compute the evaluation  <span class="math">v\\coloneqq h(z)</span> , and generate the hiding evaluation proof  <span class="math">\\pi \\coloneqq \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Open}^{\\rho_0}(\\mathsf{ck}_{\\mathsf{PC}},h(X),\\bar{C},d,z;\\omega)</span> . Finally, output the accumulator  <span class="math">\\mathsf{acc} = ((\\bar{C},d,z,v),\\pi)</span>  and the accumulation proof  <span class="math">\\pi_{\\mathrm{V}}</span> .</p>

    <p class="text-gray-300">Accumulation verifier. On input the accumulator verification key  <span class="math">\\mathsf{avk}</span> , new inputs  <span class="math">[\\mathbf{q}_i]_{i=1}^n</span> , and a new accumulator  <span class="math">\\mathsf{acc} = ((\\bar{C}, d, z, v), \\pi)</span> , the accumulation verifier  <span class="math">\\mathrm{V}</span>  computes  <span class="math">(\\bar{C}&#x27;, d&#x27;, z&#x27;, h(X)) := T^\\rho(\\mathsf{avk}, [\\mathbf{q}_i]_{i=1}^n, \\pi_{\\mathrm{V}})</span> , and checks that  <span class="math">\\bar{C}&#x27; = \\bar{C}</span> ,  <span class="math">d&#x27; = d</span> ,  <span class="math">z&#x27; = z</span> , and  <span class="math">h(z) = v</span> .</p>

    <p class="text-gray-300">Decider. On input  <span class="math">\\mathrm{dk} = \\mathrm{rk}_{\\mathsf{PC}}</span>  and  <span class="math">\\mathrm{acc} = ((\\bar{C},d,z,v),\\pi)</span> , the decider  <span class="math">\\mathrm{D}</span>  outputs  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Check}^{\\rho_0}(\\mathsf{rk}_{\\mathsf{PC}},C,d,z,v,\\pi)</span> .</p>

    <p class="text-gray-300">Recall that when the commitment randomness  <span class="math">\\omega</span>  is  <span class="math">\\perp</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . Commit is a deterministic function of  <span class="math">\\mathsf{ck}</span>  and the committed polynomial. Below we will write "A is a commitment to  <span class="math">p</span> " when  <span class="math">A = \\mathsf{PC}_{\\mathsf{DL}}</span> . Commit(ck,  <span class="math">p</span> ;  <span class="math">\\omega =</span></p>

    <p class="text-gray-300"><span class="math">\\perp</span>  (and “ <span class="math">A</span>  is not a commitment to  <span class="math">p</span> ” when  <span class="math">A \\neq \\mathsf{PC}_{\\mathsf{DL}}</span> . Commit  <span class="math">(\\mathsf{ck}, p; \\omega = \\perp)</span> ); the value of  <span class="math">\\mathsf{ck}</span>  will be clear from context (and is also equal to  <span class="math">\\mathsf{rk}</span> ).</p>

    <p class="text-gray-300">To simplify our proofs below, we note that both instances and accumulators have the same form: they consist of claims about the correct evaluation of a committed polynomial. Note also that both the predicate  <span class="math">\\Phi_{\\mathsf{PC}}</span>  and the decider D check the same condition: that the claim of correct evaluation holds. This observation allows us to simplify our definitions of both completeness and soundness to only consider the accumulation of instances, and to omit old accumulators.</p>

    <p class="text-gray-300">Completeness. We can consider the following simplified definition of completeness: for all (unbounded) adversaries  <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\forall i \\in [ n ], \\Phi_ {\\mathsf {P C}} ^ {\\rho} (\\mathsf {p p} _ {\\mathsf {P C}}, \\mathsf {i} _ {\\Phi}, \\mathsf {q} _ {i}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\Downarrow &amp;amp; \\mathsf {p p} \\leftarrow \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathrm {V} ^ {\\rho} (\\mathsf {a v k}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}, \\mathsf {a c c}, \\pi_ {\\mathrm {V}}) = 1 &amp;amp; \\mathsf {p p} _ {\\mathsf {P C}} \\leftarrow \\mathcal {H} _ {\\mathsf {P C}, D} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\mathrm {D} ^ {\\rho} (\\mathsf {d k}, \\mathsf {a c c}) = 1 &amp;amp; (\\mathsf {i} _ {\\Phi}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\mathsf {P C}}) \\\\ &amp;amp; (\\mathsf {a p k}, \\mathsf {a v k}, \\mathsf {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathsf {p p}, \\mathsf {p p} _ {\\mathsf {P C}}, \\mathsf {i} _ {\\Phi}) \\\\ &amp;amp; (\\mathsf {a c c}, \\pi_ {\\mathrm {V}}) \\leftarrow \\mathrm {P} ^ {\\rho} (\\mathsf {a p k}, [ \\mathsf {q} _ {i} ] _ {i = 1} ^ {n}) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">We prove this directly.</p>

    <p class="text-gray-300">First, since for each  <span class="math">i \\in [n]</span>  we have  <span class="math">\\Phi_{\\mathsf{PC}}^{\\rho}(\\mathsf{pp}_{\\mathsf{PC}}, \\mathsf{i}_{\\Phi}, \\mathsf{q}_i) = 1</span> , we know that  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . Check <span class="math">^{\\rho_0}</span>  ( <span class="math">\\mathsf{rk}, C_i, d_i, z_i, v_i, \\pi_i</span> ) = 1, where  <span class="math">\\mathsf{q}_i = ((C_i, d_i, z_i, v_i), \\pi_i)</span> . This in turn means that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . SuccinctCheck <span class="math">^{\\rho_0}</span>  ( <span class="math">\\langle \\text{group} \\rangle, C_i, d_i, z_i, v_i, \\pi_i</span> ) accepts and outputs  <span class="math">(h_i, U_i)</span> ; and that</li>

      <li><span class="math">U_{i}</span>  is a commitment to the polynomial  <span class="math">h_{i}</span> .</li>

    </ul>

    <p class="text-gray-300">Next, since the new accumulator acc and the accumulation proof  <span class="math">\\pi_{\\mathrm{V}}</span>  are generated honestly (i.e.,  <span class="math">(\\mathsf{acc} = ((\\bar{C},d,z,v),\\pi),\\pi_{\\mathrm{V}} = (h_0,U_0,\\omega)) = \\mathrm{P}^{\\rho}(\\mathsf{apk},[\\mathsf{q}_i]_{i = 1}^n))</span> , the following statements hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment  <span class="math">C</span>  equals the linear combination  <span class="math">\\sum_{i=0}^{n} \\alpha^i U_i</span> , so  <span class="math">C</span>  is a commitment to  <span class="math">h = \\sum_{i=0}^{n} \\alpha^i h_i</span> , and  <span class="math">\\bar{C}</span>  is a commitment to  <span class="math">h</span>  under the randomness  <span class="math">\\omega</span>  (as each  <span class="math">U_i</span>  is a commitment to the polynomial  <span class="math">h_i</span> , and  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  is a homomorphic commitment scheme).</li>

      <li>The evaluation of  <span class="math">h</span>  at  <span class="math">z</span>  equals  <span class="math">v</span>  (i.e.,  <span class="math">v = h(z)</span> ).</li>

      <li><span class="math">\\pi = \\mathsf{PC}_{\\mathsf{DL}}</span> . Open <span class="math">^{\\rho_0}</span> (ck,  <span class="math">h(X), \\bar{C}, d, z; \\omega</span> ) is an honestly-generated proof of a true statement.</li>

    </ul>

    <p class="text-gray-300">Together, these points imply that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation verifier accepts. Recall that the accumulation verifier V: (a) runs the same subroutine  <span class="math">T</span>  that the prover P runs, and checks that the output matches the one in the claimed (honest) accumulator; and (b) checks that  <span class="math">v = h(z)</span> . Both of these checks pass because the accumulation prover is honest.</li>

      <li>The decider accepts. We know that  <span class="math">v = h(z)</span> ,  <span class="math">\\bar{C}</span>  is a commitment to  <span class="math">h</span>  under randomness  <span class="math">\\omega</span> , and that  <span class="math">\\pi</span>  is an honestly-generated proof that  <span class="math">\\bar{C}</span>  commits to a polynomial which evaluates to  <span class="math">v</span>  at  <span class="math">z</span> . By completeness of  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> , D accepts.</li>

    </ol>

    <p class="text-gray-300">We conclude that the accumulation scheme AS constructed in Section 7.1 is complete.</p>

    <p class="text-gray-300">Soundness. Similarly to the completeness case, we consider a simplified version of the definition of soundness in Section 4. This simpler definition requires that the following probability is negligible for every</p>

    <p class="text-gray-300">polynomial-size adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathrm {V} ^ {\\rho} (\\mathbf {a v k}, [ \\mathbf {q} _ {i} ] _ {i = 1} ^ {n}, \\mathbf {a c c}, \\pi_ {\\mathrm {V}}) = 1 &amp;amp; \\rho \\leftarrow \\mathcal {U} (\\lambda) \\\\ \\mathrm {D} ^ {\\rho} (\\mathrm {d k}, \\mathbf {a c c}) = 1 &amp;amp; \\mathrm {p p} \\leftarrow \\mathrm {G} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; \\mathrm {p p} _ {\\mathrm {P C}} \\leftarrow \\mathcal {H} _ {\\mathrm {P C}, D} ^ {\\rho} (1 ^ {\\lambda}) \\\\ \\exists i \\in [ n ], \\Phi_ {\\mathrm {P C}} ^ {\\rho} \\left(\\mathrm {p p} _ {\\mathrm {P C}}, \\mathrm {i} _ {\\Phi}, \\mathrm {q} _ {i}\\right) = 0 &amp;amp; \\left(\\mathrm {i} _ {\\Phi}, [ \\mathrm {q} _ {i} ] _ {i = 1} ^ {n}, \\mathrm {a c c}, \\pi_ {\\mathrm {V}}) \\leftarrow \\mathcal {A} ^ {\\rho} (\\mathrm {p p}, \\mathrm {p p} _ {\\mathrm {P C}}) \\\\ &amp;amp; (\\mathrm {a p k}, \\mathrm {a v k}, \\mathrm {d k}) \\leftarrow \\mathrm {I} ^ {\\rho} (\\mathrm {p p}, \\mathrm {p p} _ {\\mathrm {P C}}, \\mathrm {i} _ {\\Phi}) \\end{array} \\right]. \\tag {7}</span></div>

    <p class="text-gray-300">Fix a polynomial-size adversary <span class="math">\\mathcal{A}</span> and degree bound <span class="math">D</span>, and denote by <span class="math">\\delta</span> the above probability for these choices. We will construct an adversary for the zero-finding game in Lemma 3.3 that wins with probability <span class="math">\\delta /2 - \\mathrm{negl}(\\lambda)</span>, from which it follows that <span class="math">\\delta</span> is negligible (since <span class="math">q</span> is superpolynomial in <span class="math">\\lambda</span>).</p>

    <p class="text-gray-300">We first describe the commitment schemes <span class="math">\\mathsf{CM}_1, \\mathsf{CM}_2</span> used in the zero-finding games. Both schemes have common setup and trimming algorithms, and public parameters <span class="math">\\mathsf{pp}</span> equal to the public parameters of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> with maximum degree <span class="math">L</span>. The message space <span class="math">\\mathcal{M}_{\\mathsf{pp}}</span> for <span class="math">\\mathsf{CM}_1</span> consists of tuples <span class="math">(p, h)</span>, where <span class="math">p</span> and <span class="math">h</span> are univariate polynomials of degree at most <span class="math">L</span>. Note that <span class="math">h</span> is uniquely represented by <span class="math">([h_i]_{i=0}^n, \\alpha)</span>, where each <span class="math">h_i</span> is a univariate polynomial of degree <span class="math">L</span>, and <span class="math">\\alpha \\in \\mathbb{F}_q</span>. The message space <span class="math">\\mathcal{M}_{\\mathsf{pp}}</span> for <span class="math">\\mathsf{CM}_2</span> consists of lists of pairs <span class="math">[(h_i, U_i)]_{i=0}^n</span>, where each <span class="math">h_i</span> is a univariate polynomial of degree at most <span class="math">L</span>, and each <span class="math">U_i</span> is a group element.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_j.\\mathsf{Setup}^{\\rho_0}(1^\\lambda ,L)</span>: Output <span class="math">\\mathsf{pp}\\gets \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Setup}^{\\rho_0}(1^\\lambda ,L)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_j.\\mathsf{Trim}^{\\rho_0}(\\mathsf{pp},n,N)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathrm{ck}_0,\\mathrm{rk}_0)\\gets \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Trim}^{\\rho_0}(\\mathsf{pp},N)</span></li>

      <li>Output <span class="math">\\mathsf{ck} := (\\mathsf{ck}_0, n)</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_1</span> <span class="math">\\mathsf{Commit}(\\mathsf{ck} = (\\mathsf{ck}_0,n),\\mathfrak{p} = (p,h);r)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit to <span class="math">p</span>: <span class="math">C \\gets \\mathsf{PC}_{\\mathsf{DL}}</span>. Commit(ck0, p; <span class="math">\\omega = \\bot</span>).</li>

      <li>Output <span class="math">(C,h)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{CM}_2</span> <span class="math">\\mathsf{Commit}(\\mathsf{ck},\\mathfrak{p} = ([(h_i,U_i)]_{i = 0}^n);r)</span>: Output <span class="math">\\mathfrak{p}</span></p>

    <p class="text-gray-300">Both commitment schemes are binding. It remains to specify the families of functions <span class="math">\\{f_{\\mathsf{pp}}^{(1)}\\}_{\\mathsf{pp}}, \\{f_{\\mathsf{pp}}^{(2)}\\}_{\\mathsf{pp}}</span> that we use in the respective zero-finding games. We define <span class="math">f_{\\mathsf{pp}}^{(1)}(p, h = ([h_i]_{i=0}^n, \\alpha)) := p - \\sum_{i=0}^{n} \\alpha^i h_i</span>, and</p>

    <p class="text-gray-300"><span class="math">f_{\\mathsf{pp}}^{(2)}(\\mathfrak{p} = ([(h_i,U_i)]_{i = 0}^n))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct the key pair <span class="math">(\\mathrm{ck}_0,\\mathrm{rk}_0)\\coloneqq \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Trim}(\\mathsf{pp}_{\\mathsf{PC}},\\deg (h_1))</span></li>

      <li>For each <span class="math">i\\in \\{0,\\dots ,n\\}</span>, construct a <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> commitment to <span class="math">h_i</span>: <span class="math">B_{i}\\gets \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Commit}(\\mathsf{ck}_0,h_i;\\bot)</span></li>

      <li>For each <span class="math">i\\in \\{0,\\dots ,n\\}</span>, compute <span class="math">a_{i}\\in \\mathbb{F}_{q}</span> such that <span class="math">a_{i}G = U_{i} - B_{i}</span></li>

      <li>Output the polynomial <span class="math">a(Z) \\coloneqq \\sum_{i=0}^{n} a_i Z^i</span>.</li>

    </ol>

    <p class="text-gray-300">We next describe an adversary <span class="math">\\mathcal{C}</span> against <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>, which simply runs the soundness experiment for the accumulation scheme and outputs acc as output by <span class="math">\\mathcal{A}</span>. For convenience we also have <span class="math">\\mathcal{C}</span> output <span class="math">[q_i]_{i=1}^n</span> and <span class="math">\\pi_{\\mathrm{V}}</span>; this will be ignored by the extractor.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}^{\\rho}(\\mathsf{pp}_{\\mathsf{PC}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set AS public parameters <span class="math">\\mathsf{pp}_{\\mathsf{AS}}\\coloneqq 1^{\\lambda}</span></li>

      <li>Compute <span class="math">(\\mathrm{i}_{\\Phi},[\\mathbf{q}_i]_{i = 1}^n,\\mathrm{acc},\\pi_{\\mathrm{V}})\\gets \\mathcal{A}^{\\rho}(\\mathsf{pp}_{\\mathsf{AS}},\\mathsf{pp}_{\\mathsf{PC}})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathrm{i}_{\\Phi}</span>  as the degree bound  <span class="math">N</span> .</li>

      <li>Output  <span class="math">(N, \\mathrm{acc} = ((\\bar{C}, d, z, v), \\pi); [\\mathfrak{q}_i]_{i=1}^n, \\pi_{\\mathrm{V}})</span> .</li>

    </ol>

    <p class="text-gray-300">We use the extractor  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  corresponding to  <span class="math">\\mathcal{C}</span>  to construct adversaries  <span class="math">\\mathcal{B}_1, \\mathcal{B}_2</span>  for zero-finding games against  <span class="math">(\\mathsf{CM}_1, \\{f_{\\mathsf{pp}}^{(1)}\\}_{\\mathsf{pp}}), (\\mathsf{CM}_2, \\{f_{\\mathsf{pp}}^{(2)}\\}_{\\mathsf{pp}})</span>  respectively, with  <span class="math">L = D</span>  where  <span class="math">D = \\mathrm{poly}(\\lambda)</span>  is the maximum degree parameter as in the soundness experiment for the accumulation scheme.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_j^\\rho (\\mathsf{pp})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(N,\\mathrm{acc},[\\mathfrak{q}_i]_{i = 1}^n,\\pi_{\\mathrm{V}})\\gets \\mathcal{C}^\\rho (\\mathsf{pp})</span></li>

      <li>Parse  <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span>  as  <span class="math">[(C_i, d_i, z_i, v_i), \\pi_i)]_{i=1}^n</span> , and  <span class="math">\\pi_{\\mathrm{V}}</span>  as  <span class="math">(h_0, U_0, \\omega)</span> .</li>

      <li>Compute  <span class="math">p\\gets \\mathcal{E}_{\\mathcal{C}}^{\\rho}(\\mathsf{pp})</span></li>

      <li>For each  <span class="math">i\\in [n]</span>  , obtain  <span class="math">h_i</span>  and  <span class="math">U_{i}</span>  from  <span class="math">\\pi_{i}</span></li>

      <li>Compute  <span class="math">\\alpha \\coloneqq \\rho_{1}([h_{i},U_{i})]_{i = 0}^{n})</span></li>

      <li>If  <span class="math">j = 1</span> , output  <span class="math">((n, N), (p, h := ([h_i]_{i=0}^n, \\alpha)))</span> . If  <span class="math">j = 2</span> , output  <span class="math">((n, N), ([(h_i, U_i)]_{i=0}^n))</span> .</li>

    </ol>

    <p class="text-gray-300">We show that either  <span class="math">\\mathcal{B}_1</span>  or  <span class="math">\\mathcal{B}_2</span>  wins its respective zero-finding game with probability at least  <span class="math">\\delta / 2 - \\mathrm{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">Since D accepts with probability  <span class="math">\\delta</span> , and by the extraction property of  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> , the following holds with probability at least  <span class="math">\\delta - \\mathrm{negl}(\\lambda)</span> :  <span class="math">\\mathcal{E}_{\\mathcal{C}}</span>  outputs a polynomial  <span class="math">p</span>  such that  <span class="math">\\bar{C}</span>  is a commitment to  <span class="math">p</span>  with randomness  <span class="math">\\omega</span>  (and so  <span class="math">C</span>  is a deterministic commitment to  <span class="math">p</span> ),  <span class="math">p(z) = v</span> , and  <span class="math">\\deg(p) \\leq d</span> ; and, moreover,  <span class="math">(\\mathsf{acc}, [\\mathfrak{q}_i]_{i=1}^n, \\pi_{\\mathrm{V}})</span>  satisfies the left-hand side of Eq. (7). This latter point implies that, parsing  <span class="math">\\mathfrak{q}_i</span>  as  <span class="math">((C_i, d_i, z_i, v_i), \\pi_i)</span>  and letting  <span class="math">(h_i, U_i) := \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{SucinctCheck}^{\\rho_0}(\\mathsf{rk}, C_i, d_i, z_i, v_i, \\pi_i)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Since  <span class="math">\\mathrm{V}^{\\rho}(\\mathrm{avk}, [\\mathfrak{q}_i]_{i=1}^n, \\mathrm{acc}, \\pi_{\\mathrm{V}})</span>  accepts, the following are true: (a) for each  <span class="math">i \\in [n]</span> ,  <span class="math">\\mathsf{PC}_{\\mathrm{DL}}.\\mathrm{SucinctCheck}</span>  accepts; (b)  <span class="math">U_0</span>  is a commitment to  <span class="math">h_0</span> ; and (c) parsing acc as  <span class="math">((C, d, z, v), \\pi)</span>  and setting  <span class="math">\\alpha := \\rho_1([h_i, U_i]_{i=0}^n)</span> , we have that  <span class="math">z = \\rho_1(C, [h_i]_{i=0}^n, \\alpha)</span> ,  <span class="math">C = \\sum_{i=0}^{n} \\alpha^i U_i</span> , and  <span class="math">v = \\sum_{i=0}^{n} \\alpha^i h_i(z)</span> .</li>

      <li>For some  <span class="math">i \\in [n]</span> ,  <span class="math">\\Phi_{\\mathsf{PC}}^{\\rho}(\\mathsf{pp}_{\\mathsf{PC}}, \\mathsf{i}_{\\Phi}, \\mathfrak{q}_i) = \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Check}^{\\rho_0}(\\mathsf{rk}, (C_i, d_i, z_i, v_i), \\pi_i) = 0</span> . By construction (see Appendix A.2), this implies that either  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{SucinctCheck}</span>  rejects, or the group element  <span class="math">U_i</span>  is not a commitment to  <span class="math">h_i</span> .</li>

    </ul>

    <p class="text-gray-300">The above tells us that there exists some  <span class="math">i \\in [n]</span>  such that  <span class="math">U_i</span>  is not a commitment to  <span class="math">h_i</span> . In other words, if we define  <span class="math">B_i := \\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Commit}(\\mathsf{ck}, h_i)</span> , then there exists an  <span class="math">i \\in [n]</span>  such that  <span class="math">U_i \\neq B_i</span> . Letting  <span class="math">a_i \\in \\mathbb{F}_q</span>  be such that  <span class="math">a_i G = U_i - B_i</span> , we deduce that the polynomial  <span class="math">a(Z) = \\sum_{i=0}^{n} a_i Z^i</span>  is not identically zero.</p>

    <p class="text-gray-300">There are then two cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C \\neq \\sum_{i=0}^{n} \\alpha^i B_i</span> . Then since  <span class="math">C</span>  is a commitment to  <span class="math">p</span> ,  <span class="math">p(X) - h(X)</span>  is not identically zero, but  <span class="math">p(z) = v = h(z)</span> . Hence  <span class="math">\\mathcal{B}_1</span>  wins the zero-finding game against  <span class="math">(\\mathsf{CM}_1, \\{f_{\\mathsf{pp}}^{(1)}\\}_{\\mathsf{pp}})</span> .</li>

      <li><span class="math">C = \\sum_{i=0}^{n} \\alpha^i B_i</span> . Then since  <span class="math">C = \\sum_{i=0}^{n} \\alpha^i U_i</span> ,  <span class="math">\\alpha</span>  is a zero of the polynomial  <span class="math">a(Z)</span> . Hence  <span class="math">\\mathcal{B}_2</span>  wins the zero-finding game against  <span class="math">(\\mathsf{CM}_2, \\{f_{\\mathsf{pp}}^{(2)}\\}_{\\mathsf{pp}})</span> .</li>

    </ol>

    <p class="text-gray-300">Since at least one of these two cases occurs with probability at least  <span class="math">\\delta /2 - \\mathrm{negl}(\\lambda)</span> , the claim follows.</p>

    <p class="text-gray-300">Zero knowledge. We show that if  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  is hiding, then AS is zero knowledge. We do so by constructing an efficient simulator S for AS from the simulator  <span class="math">S</span>  for  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . During the setup phase,  <span class="math">\\mathrm{S}^{\\rho}(1^{\\lambda})</span>  outputs pp  <span class="math">\\leftarrow</span> <span class="math">\\mathrm{G}^{\\rho}(1^{\\lambda})</span> . Then, during the proving phase,  <span class="math">\\mathrm{S}^{\\rho}(\\mathsf{pp},\\tau ,\\mathrm{i}_{\\Phi})</span> : (a) samples a random polynomial  <span class="math">s(X)\\in \\mathbb{F}_q^{\\leq d}[X]</span>  and an evaluation point  <span class="math">z\\in \\mathbb{F}_q</span> ; (b) computes a simulated commitment for  <span class="math">s</span> :  <span class="math">C\\gets S.\\mathrm{Commit}^{\\rho_0}(\\mathrm{trap}:= \\mathsf{pp},d)</span> ; (c) computes a simulated evaluation proof:  <span class="math">(\\mu ,\\pi)\\gets S.\\mathrm{Open}^{\\rho_0}(z,v:= s(z))</span> ; and (d) outputs  <span class="math">(\\mu ,\\mathrm{acc}:= ((C,d,z,v),\\pi))</span> . (Note that for  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> , the simulation trapdoor just equals the  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  public parameters pp.)</p>

    <p class="text-gray-300">First, the hiding property of <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> ensures that the programmed random oracle is indistinguishable from an honestly sampled random oracle. Next, the simulated public parameters are identical to the honest ones, and so the output of the setup phase is identically distributed in both cases.</p>

    <p class="text-gray-300">We are left to argue that the accumulators are computationally indistinguishable. First, in both cases, since <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> is hiding, then the commitments are indistinguishable. Next, in the honest case, the evaluation point <span class="math">z</span> is the evaluation of the random oracle on input <span class="math">(C,h)</span> where <span class="math">h</span> is unpredictable; hence it is indistinguishable from random. Since <span class="math">h_{0}</span> is chosen at random, <span class="math">h(z)</span> is identically distributed to <span class="math">s(z)</span>. Finally, because <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> is hiding, then the evaluation proofs are indistinguishable. Thus, the simulated accumulator is indistinguishable from the honest accumulator, and so <span class="math">\\mathsf{AS}</span> is zero knowledge.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">We now analyze the efficiency of our accumulation scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Generator:</em> <span class="math">\\mathrm{G}^{\\rho}(1^{\\lambda})</span> outputs <span class="math">1^{\\lambda}</span>, and hence takes <span class="math">O(\\lambda)</span> time.</li>

      <li><em>Indexer:</em> <span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{PC}},\\mathsf{i}_{\\Phi})</span> runs <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{Trim}</span> and outputs <span class="math">(\\mathsf{apk},\\mathsf{dk}):=(\\mathsf{ck},\\mathsf{rk})</span>, which have size <span class="math">O_{\\lambda}(d)</span>, and also <span class="math">\\mathsf{avk}</span>, which has size <span class="math">O_{\\lambda}(1)</span>. This takes time <span class="math">O_{\\lambda}(d)</span>.</li>

      <li><em>Accumulation prover:</em> The time of <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[((C_{i},d_{i},z_{i},v_{i}),\\pi_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m})</span> is dominated by running <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{Open}</span>, which uses <span class="math">3d</span> scalar multiplications for each <span class="math">i</span>, for a total of <span class="math">3d\\cdot n</span> scalar multiplications.</li>

      <li><em>Accumulator size:</em> The accumulator <span class="math">\\mathsf{acc}</span> consists of an evaluation claim and a proof. The total size is <span class="math">2\\log_{2}(d)+1</span> elements in <span class="math">\\mathbb{G}</span> (<span class="math">2\\log_{2}(d)</span> group elements for the proof and <span class="math">1</span> for the commitment) and a constant number of field elements.</li>

      <li><em>Accumulation proof size:</em> The accumulation proof <span class="math">\\pi_{\\mathrm{V}}</span> consists of a linear polynomial <span class="math">h_{0}</span> which can be represented in two elements in <span class="math">\\mathbb{F}_{q}</span>, and a commitment <span class="math">U_{0}</span>, which is an element of <span class="math">\\mathbb{G}</span>.</li>

      <li><em>Accumulation verifier:</em> <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[((C_{i},d_{i},z_{i},v_{i}),\\pi_{i})]_{i=1}^{n},[\\mathsf{acc}_{j}]_{j=1}^{m},\\mathsf{acc})</span> runs <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{SuccinctCheck}</span> as a subroutine, which requires <span class="math">(2\\log_{2}(d)+2)</span> scalar multiplications per iteration among <span class="math">n</span> iterations. (Note that <span class="math">h</span> is succinctly represented, and can be evaluated in <span class="math">O(\\log d)</span> field operations).</li>

      <li><em>Decider:</em> <span class="math">\\mathrm{D}^{\\rho}(\\mathsf{dk},\\mathsf{acc})</span> runs <span class="math">\\mathsf{PC}_{\\textsc{dl}}.\\mathsf{Check}</span>, which requires uses <span class="math">O(d)</span> scalar multiplications.</li>

    </ul>

    <p class="text-gray-300">We construct an accumulation scheme for the pairing-based polynomial commitment scheme  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>  [KZG10; CHMMVW20]. The main feature of our accumulation scheme is that, while invoking  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span> . Check to check  <span class="math">n</span>  evaluation proofs requires  <span class="math">O(n)</span>  pairings, verifying an accumulation of these proofs is much cheaper: it requires only  <span class="math">O(n)</span>  scalar multiplications in  <span class="math">\\mathbb{G}_1</span>  to run the accumulation scheme verifier  <span class="math">\\mathrm{V}</span> , plus one pairing to run the decider  <span class="math">\\mathrm{D}</span> . In more detail, we prove the following theorem.</p>

    <p class="text-gray-300">Theorem 8.1. The tuple  <span class="math">\\mathsf{AS} = (\\mathrm{G},\\mathrm{I},\\mathrm{P},\\mathrm{V},\\mathrm{D})</span>  constructed in Section 8.1 is a zero knowledge accumulation scheme in the random oracle model for the polynomial commitment scheme  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>  described in Fig. 1. AS achieves the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator:  <span class="math">\\mathrm{G}^{\\rho}(1^{\\lambda})</span>  runs in  <span class="math">\\operatorname{poly}(\\lambda)</span>  time.</li>

      <li>Indexer:  <span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathrm{i}_{\\Phi})</span>  runs in  <span class="math">\\operatorname{poly}(\\lambda)</span>  time.</li>

      <li>Accumulation prover: The time of  <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[((C_i,d_i,z_i,v_i),\\pi_i)]_{i = 1}^{n},[\\mathsf{acc}_j]_{j = 1}^{m})</span>  is dominated by the time to perform  <span class="math">O(n + m)</span>  scalar multiplications in  <span class="math">\\mathbb{G}_1</span> .</li>

      <li>Accumulator size: The accumulator acc consists of two elements in  <span class="math">\\mathbb{G}_1</span> .</li>

      <li>Accumulation proof size: The accumulation proof  <span class="math">\\pi_{\\mathrm{V}}</span>  consists of two elements in  <span class="math">\\mathbb{G}_1</span> .</li>

      <li>Accumulation verifier: The time of  <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[((C_i,d_i,z_i,v_i),\\pi_i)]_{i = 1}^{n},[\\mathsf{acc}_j]_{j = 1}^{m},\\mathsf{acc},\\pi_{\\mathrm{V}})</span>  is dominated by the time to perform  <span class="math">O(n + m)</span>  scalar multiplications in  <span class="math">\\mathbb{G}_1</span> .</li>

      <li>Decider: The time of  <span class="math">\\mathrm{D}^{\\rho}(\\mathrm{dk},\\mathrm{acc})</span>  is dominated by the time to perform 1 pairing.</li>

    </ul>

    <p class="text-gray-300">We proceed as follows: in Section 8.1 we describe our accumulation scheme; and then in Section 8.2 we prove that it fulfills Theorem 8.1. Recall that obtaining an accumulation scheme for a polynomial commitment scheme involves obtaining an accumulation scheme for the pair  <span class="math">(\\Phi_{\\mathsf{PC}},\\mathcal{H}_{\\mathsf{PC},D})</span>  specified in Definition 4.2.</p>

    <p class="text-gray-300">Throughout, we highlight in blue the parts of  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>  used for the hiding property, and the corresponding parts of our accumulation scheme dealing with these; they can be dropped if no hiding is used for  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithms of  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>  and of AS use random oracles, but for security they have to be distinct. For this we use domain separation: we derive two different random oracles  $\\rho_0(\\cdot) \\coloneqq \\rho(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math">  (for  </span>\\mathsf{PC}_{\\mathrm{AGM}}<span class="math"> ) and  </span>\\rho_1(\\cdot) \\coloneqq \\rho(1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math">  (for AS) from the common random oracle  </span>\\rho$  that all algorithms have access to.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Generator. On input a security parameter  <span class="math">\\lambda</span>  (written in unary), G outputs  <span class="math">1^{\\lambda}</span> .</p>

    <p class="text-gray-300">Indexer. On input the accumulator parameters  <span class="math">\\mathsf{pp}_{\\mathsf{AS}}</span> , the  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span>  public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> , and a predicate index  <span class="math">\\mathrm{i}_{\\Phi} = [d_i]_{i=1}^n</span> , the indexer I computes the receiver key  <span class="math">\\mathsf{rk}</span>  the same way as  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> . Trim, and outputs  <span class="math">(\\mathsf{apk}, \\mathsf{avk}, \\mathsf{dk}) := (\\mathsf{rk}, \\mathsf{rk}, \\mathsf{rk})</span> .</p>

    <p class="text-gray-300">The accumulation prover and the accumulation verifier both rely on the following common subroutine:</p>

    <p class="text-gray-300">ComputeAcc <span class="math">^{\\rho}</span>  ( <span class="math">\\mathsf{avk}, [\\mathsf{q}_i]_i = 1, [\\mathsf{acc}_j]_j = 1, \\pi_{\\mathrm{V}}</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">[\\mathbf{q}_i]_{i = 1}^n</span>  as  <span class="math">[(C_i,d_i,z_i,v_i),\\pi_i)]_{i = 1}^n</span></li>

      <li>Parse  <span class="math">\\pi_{\\mathrm{V}}</span>  as  <span class="math">(s\\beta G,sG)</span></li>

      <li>Obtain the supported degree bounds  <span class="math">\\pmb{d}</span>  from  <span class="math">\\mathsf{apk} = \\mathsf{rk}</span> .</li>

      <li>For each  <span class="math">i\\in [n]</span></li>

    </ol>

    <p class="text-gray-300">(a) Check that  <span class="math">d_{i}\\in \\pmb{d}</span> (b) Parse the commitment  <span class="math">C_i</span>  as a tuple  <span class="math">(U_i, S_i) \\in \\mathbb{G}_1^2</span> . (c) Generate the  <span class="math">i</span> -th opening challenge  <span class="math">\\xi_{i} := \\rho_{0}(\\mathsf{rk}, d_{i}, C_{i}, z_{i}, v_{i}) \\in \\mathbb{F}_{q}</span> .</p>

    <p class="text-gray-300">(d) Parse the proof <span class="math">\\pi_i</span> as <span class="math">(W_i, \\bar{v}_i)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">j \\in [m]</span>, parse the <span class="math">j</span>-th old accumulator <span class="math">\\mathsf{acc}_j</span> as a tuple <span class="math">(C_j^\\star, \\pi_j^\\star) \\in \\mathbb{G}_1^2</span>.</li>

      <li>Compute the new accumulation challenge <span class="math">r \\in \\mathbb{F}_q</span> as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">r := \\rho_1(r\\mathsf{k}, [((C_i, d_i, z_i, v_i), \\pi_i)]_{i=1}^n, [\\mathsf{acc}_j]_j^m, \\pi_V).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accumulate commitments and proofs as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Compute <span class="math">C := \\sum_{i=1}^n r^{i-1}((U_i - v_i G) + \\xi_i (S_i - v_i \\beta^{D-d_i} G) - \\bar{v}_i \\gamma G + z_i W_i)</span>. (b) Accumulate old accumulated commitments: <span class="math">C^\\star := C + \\sum_{j=1}^m r^{n+j-1} C_j^\\star + r^{n+m} \\cdot s \\beta G</span>. (c) Accumulate all old and new proofs: <span class="math">\\pi^\\star := \\sum_{i=1}^n r^{i-1} W_i + \\sum_{j=1}^m r^{n+j-1} \\pi_j^\\star + r^{n+m} \\cdot s G</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the new accumulator <span class="math">\\mathsf{acc} := (C^\\star, \\pi^\\star)</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Accumulation prover.</strong> On input the accumulator proving key <span class="math">\\mathsf{apk}</span>, new inputs <span class="math">[\\mathbf{q}_i]_{i=1}^n</span>, and old accumulators <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span>, <span class="math">\\mathrm{P}</span> computes a new accumulator <span class="math">\\mathsf{acc}</span> as follows. Sample a random scalar <span class="math">s \\in \\mathbb{F}_q</span>, set the accumulation proof <span class="math">\\pi_{\\mathrm{V}} := (s\\beta G, sG)</span>, compute the new accumulator <span class="math">\\mathsf{acc} := \\mathsf{ComputeAcc}^\\rho(\\mathsf{apk} = \\mathsf{avk}, [\\mathbf{q}_i]_{i=1}^n, [\\mathsf{acc}_j]_{j=1}^m, \\pi_{\\mathrm{V}})</span>, and output <span class="math">(\\mathsf{acc}, \\pi_{\\mathrm{V}})</span>.</p>

    <p class="text-gray-300"><strong>Accumulation verifier.</strong> On input the accumulator verification key <span class="math">\\mathsf{avk}</span>, new instances <span class="math">[\\mathbf{q}_i]_{i=1}^n</span>, old accumulators <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span>, and a new accumulator <span class="math">\\mathsf{acc}</span>, <span class="math">\\mathrm{V}</span> checks that <span class="math">\\mathsf{acc}</span> accumulates <span class="math">[\\mathbf{q}_i]_{i=1}^n</span> and <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> simply by running the common subroutine ComputeAcc, i.e. by checking that <span class="math-block"> \\mathsf{acc} = \\mathsf{ComputeAcc}^\\rho(\\mathsf{avk}, [\\mathbf{q}_i]_{i=1}^n, [\\mathsf{acc}_j]_j^m, \\pi_{\\mathrm{V}}). </span> <strong>Decider.</strong> On input the decision key <span class="math">\\mathsf{dk}</span> and an accumulator <span class="math">\\mathsf{acc}</span>, <span class="math">\\mathrm{D}</span> checks the validity of <span class="math">\\mathsf{acc}</span> by parsing <span class="math">\\mathsf{acc}</span> as a tuple <span class="math">(C^\\star, \\pi^\\star) \\in \\mathbb{G}_1^2</span> and checking that <span class="math">e(C^\\star, H) = e(\\pi^\\star, \\beta H)</span>.</p>

    <h2 id="sec-61" class="text-2xl font-bold">8.2 Proof of Theorem 8.1</h2>

    <p class="text-gray-300">Note that in the foregoing construction, one can view the accumulation proof <span class="math">\\pi_{\\mathrm{V}} = (s\\beta G, sG)</span> as an accumulator because it passes the decider's pairing check: <span class="math">e(s\\beta G, H) = e(sG, \\beta H)</span>. We adopt this viewpoint below, and omit explicit discussion of <span class="math">\\pi_{\\mathrm{V}}</span> in both the completeness and soundness proofs. This is a valid change because it never weakens the adversary: in the completeness proof, the honest prover simply adds another honest old accumulator to the list sampled by the adversary <span class="math">\\mathcal{A}</span>, and in the soundness proof the adversary <span class="math">\\mathcal{A}</span> already samples old accumulators.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> We argue completeness directly. First, we follow [CHMMVW20] and rewrite the pairing equation in <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>. Check as follows: <span class="math-block"> \\begin{aligned} e(C&#x27; - vG - \\bar{v}\\gamma G, H) &amp;amp;= e(W, \\beta H - zH) \\\\ &amp;amp;= e(W, \\beta H) - e(W, zH) \\\\ &amp;amp;= e(W, \\beta H) - e(zW, H) \\\\ \\Longrightarrow e(C&#x27; - vG - \\bar{v}\\gamma G + zW, H) &amp;amp;= e(W, \\beta H). \\end{aligned} </span></p>

    <p class="text-gray-300">Now, we want to show that AS.P, when given accepting inputs <span class="math">[(C_i, d_i, z_i, v_i), \\pi_i)]_{i=1}^n</span> and old accumulators <span class="math">[\\mathsf{acc}_j]_{j=1}^m</span> that are accepted by AS.D, outputs a new accumulator <span class="math">\\mathsf{acc}</span> such that AS.V successfully verifies that <span class="math">\\mathsf{acc}</span> is the accumulation of <span class="math">[(C_i, d_i, z_i, v_i), \\pi_i)]_{i=1}^n</span> and <span class="math">[\\mathsf{acc}_j]_j^m</span>, and that AS.D accepts <span class="math">\\mathsf{acc}</span>.</p>

    <p class="text-gray-300">First, since for each <span class="math">i \\in [n]</span>, <span class="math">\\Phi_{\\mathsf{PC}}(\\mathrm{i}_{\\Phi}, (C_i, z_i, d_i, v_i), \\pi_i) = 1</span>, we know that <span class="math">e(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G, H) = e(W_i, \\beta H - z_i H)</span>, which, by the foregoing manipulation, implies that <span class="math">e(C&#x27; - vG - \\bar{v}_i \\gamma G + z_i W_i, H) = e(W_i, \\beta H)</span>. Hence, for any choice of <span class="math">r \\in \\mathbb{F}_q</span>, it holds that <span class="math-block"> e\\left(\\sum_{i=1}^n r^{i-1} \\left(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + zW_i\\right), H\\right) = e\\left(\\sum_{i=1}^n r^{i-1} W_i, \\beta H\\right). \\tag{8} </span></p>

    <p class="text-gray-300">Next, since for each <span class="math">j \\in [m]</span>, <span class="math">\\mathsf{acc}_j</span> is accepted by D, we know that <span class="math">e(C_j^\\star, H) = e(\\pi_j^\\star, \\beta H)</span>. Hence, for any choice of <span class="math">r \\in \\mathbb{F}_q</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\sum_{j=1}^{m} r^{n+j-1} C_j^\\star, H\\right) = e \\left(\\sum_{j=1}^{m} r^{n+j-1} \\pi_j^\\star, \\beta H\\right). \\tag{9}</span></div>

    <p class="text-gray-300">Adding Equations (8) and (9), we obtain that <span class="math">e(C^{\\star}, H) = e(\\pi^{\\star}, \\beta H)</span>, and hence <span class="math">\\mathsf{AS.D}(\\mathsf{dk}, \\mathsf{acc} = (C^{\\star}, \\pi^{\\star})) = 1</span>, as required. Furthermore, <span class="math">\\mathrm{V}</span> accepts as it just runs the common subroutine P. Hence AS achieves completeness.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Recall that we must show that the following probability is negligible for all polynomial-size adversaries <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span>:</p>

    <p class="text-gray-300">$$ \\Pr \\left[ \\begin{array}{c} \\mathrm{V}^{\\rho}(\\mathrm{avk}, [\\mathfrak{q}_i]_{i=1}^n, [\\mathrm{acc}_j]_{j=1}^m, \\mathrm{acc}) = 1 \\\\ \\mathrm{D}^{\\rho}(\\mathrm{dk}, \\mathrm{acc}) = 1 \\\\ \\land \\\\ \\left(\\exists j \\in [m], \\mathrm{D}^{\\rho}(\\mathrm{dk}, \\mathrm{acc}_j) = 0 \\lor \\right. \\\\ \\exists i \\in [n], \\Phi_{\\mathrm{PC}}^{\\rho}(\\mathrm{i}_{\\Phi}, \\mathfrak{q}_i, \\pi_i) = 0</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array} \\right] \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\rho \\leftarrow \\mathcal{U}(\\lambda) \\\\ \\mathsf{pp} \\leftarrow \\mathrm{G}^{\\rho}(1^{\\lambda}) \\\\ (\\mathrm{i}_{\\Phi}, \\mathrm{aux}) \\leftarrow \\mathcal{H}_{\\mathrm{PC},D}^{\\rho, \\mathcal{A}_1}(\\mathsf{pp}) \\\\ \\left([\\mathfrak{q}_i]_{i=1}^n, [\\mathrm{acc}_j]_{j=1}^m, \\mathrm{acc}\\right) \\leftarrow \\mathcal{A}_2^{\\rho}(\\mathsf{pp}, \\mathrm{i}_{\\Phi}, \\mathrm{aux}) \\\\ (\\mathrm{apk}, \\mathrm{avk}, \\mathrm{dk}) \\leftarrow \\mathrm{I}^{\\rho}(\\mathsf{pp}, \\mathrm{i}_{\\Phi}) \\end{array} \\right. \\right]. \\tag{10} $$</p>

    <p class="text-gray-300">First, we rewrite the pairing equation check in the decider D as follows:</p>

    <div class="my-4 text-center"><span class="math-block">e(C^{\\star}, H) = e(\\pi^{\\star}, \\beta H)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Updownarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\sum_{i} r^{i-1}\\left(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + z_i W_i\\right), H\\right) + e\\left(\\sum_{j} r^{n+j-1} C_j^{\\star}, H\\right) = e\\left(\\sum_{i} r^{i-1} W_i, \\beta H\\right) + e\\left(\\sum_{j} r_1^{n+j-1} \\pi_j^{\\star}, \\beta H\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Updownarrow</span></div>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\sum_{i} r^{i-1}\\left(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + z_i W_i\\right), H\\right) - e\\left(\\sum_{i} r^{i-1} W_i, \\beta H\\right) = e\\left(\\sum_{j} r^{n+j-1} \\pi_j^{\\star}, \\beta H\\right) - e\\left(\\sum_{j} r^{n+j-1} C_j^{\\star}, H\\right)</span></div>

    <p class="text-gray-300">Writing <span class="math">\\mathbb{G}_T</span> operations additively, this is equivalent to:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{n} r^{i-1}\\left(e\\left(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + z_i W_i, H\\right) - e(W_i, \\beta H)\\right) = \\sum_{j=1}^{m} r^{n+j-1}\\left(e(\\pi_j^{\\star}, \\beta H) - e(C_j^{\\star}, H)\\right)</span></div>

    <p class="text-gray-300">We define a function <span class="math">s\\colon \\mathbb{F}_q\\to \\mathbb{G}_T</span>:</p>

    <div class="my-4 text-center"><span class="math-block">s(X) := \\sum_{i=1}^{n} X^{i-1}\\left(e\\left(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + z_i W_i, H\\right) - e(W_i, \\beta H)\\right) - \\sum_{j=1}^{m} X^{n+j-1}\\left(e(\\pi_j^{\\star}, \\beta H) - e(C_j^{\\star}, H)\\right),</span></div>

    <p class="text-gray-300">along with an associated polynomial <span class="math">\\hat{s}(X) = \\sum_{i=1}^{m+n} a_i X^{i-1} \\in \\mathbb{F}_q[X]</span>, where <span class="math">a_i \\in \\mathbb{F}_q</span> is such that the coefficient of <span class="math">X^{i-1}</span> in the above expression is equal to <span class="math">a_i G_T</span> for some fixed generator <span class="math">G_T</span> of <span class="math">\\mathbb{G}_T</span>. Note that, for all <span class="math">r \\in \\mathbb{F}_q</span>, <span class="math">\\hat{s}(r) = 0</span> if and only if <span class="math">s(r) = 0</span>.</p>

    <p class="text-gray-300">If the pairing equation <span class="math">e(C^{\\star}, H) = e(\\pi^{\\star}, \\beta H)</span> holds, then <span class="math">s(r) = 0</span>, whence <span class="math">\\hat{s}(r) = 0</span>. Furthermore, observe that <span class="math">\\hat{s}</span> is identically zero if and only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i</span> in <span class="math">[n]</span>, the coefficient of <span class="math">X^{i-1}</span> is zero. That is, each <span class="math">e(C_i&#x27; - v_i G - \\bar{v}_i \\gamma G + z_i W_i, H) - e(\\pi_i, \\beta H) = 0</span>, which in turn means that the predicate <span class="math">\\Phi_{\\mathrm{PC}}(\\mathrm{i}_{\\Phi}, \\mathfrak{q}_i, \\pi_i)</span> accepts.</li>

      <li>For each <span class="math">j</span> in <span class="math">[m]</span>, the coefficient of <span class="math">X^{n+j-1}</span> is zero. That is, each <span class="math">e(C_j^{\\star}, H) - e(\\pi_j^{\\star}, \\beta H) = 0</span>, which in turn means that the decider <span class="math">\\mathrm{D}(\\mathrm{dk}, \\mathrm{acc}_j)</span> accepts.</li>

    </ul>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">Together, this means that the implication in Eq. (10) is equivalent to the condition that  <span class="math">\\hat{s} \\neq 0</span>  but  <span class="math">\\hat{s}(r) = 0</span> .</p>

    <p class="text-gray-300">To show that this occurs with negligible probability, we define a zero-finding game and apply Lemma 3.3. We define a commitment scheme  <span class="math">\\mathsf{CM}&#x27; = (\\mathsf{Setup},\\mathsf{Commit})</span>  and associated family of mapping functions  <span class="math">\\{f_{\\mathsf{pp}}\\}_{\\mathsf{pp}}</span> . The message space  <span class="math">\\mathcal{M}_{\\mathsf{pp}}</span>  for  <span class="math">\\mathsf{CM}&#x27;</span>  is  <span class="math">\\mathbb{G}_1^{n + m}</span> .</p>

    <p class="text-gray-300">CM'.Setup <span class="math">^{\\rho_0}</span>  ( <span class="math">1^\\lambda, L = (m,n)</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a bilinear group</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\langle \\mathrm{group}\\rangle = (\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,G,H,e)\\gets \\mathrm{SampleGrp}^{\\rho_0}(1^\\lambda).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\beta, \\gamma \\in \\mathbb{F}_q</span> .</li>

      <li>Set the public parameters  <span class="math">\\mathsf{pp} = (\\langle \\mathsf{group}\\rangle ,\\beta ,\\gamma ,m,n)</span></li>

      <li>Output pp.</li>

    </ol>

    <p class="text-gray-300">CM'.Commit(pp, p ∈ Mpp; r): Output p.</p>

    <p class="text-gray-300"><span class="math">f_{\\mathsf{pp}}(\\mathfrak{p}\\in \\mathcal{M}_{\\mathsf{pp}})\\to p</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathfrak{p}</span>  as  <span class="math">(A_{1},\\ldots A_{n + m})</span></li>

      <li>Let  <span class="math">G_{T} = e(G, H)</span>  be a generator of  <span class="math">\\mathbb{G}_T</span> .</li>

      <li>Compute  <span class="math">a_{i}\\in \\mathbb{F}_{q}</span>  such that  <span class="math">A_{i} = a_{i}G_{T}</span></li>

      <li>Output the bivariate polynomial  <span class="math">\\hat{s}(X) := \\sum_{i=1}^{n+m} a_i X^{i-1}</span> .</li>

    </ol>

    <p class="text-gray-300">Fix a choice of  <span class="math">D \\in \\mathbb{N}</span>  (inside  <span class="math">\\mathcal{H}_{\\mathrm{PC},D}</span>  from Definition 4.2) that maximizes the success probability of the adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> . We use  <span class="math">\\mathcal{A}</span>  to construct an adversary  <span class="math">\\mathcal{B}</span>  against Lemma 3.3 for  <span class="math">\\mathsf{CM}&#x27;</span>  and  <span class="math">\\{f_{\\mathsf{pp}}\\}_{\\mathsf{pp}}</span> :</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}^{\\rho}(\\mathsf{pp}_{\\mathsf{CM}^{\\prime}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{pp}_{\\mathsf{CM}&#x27;}</span>  as  <span class="math">(\\langle \\mathsf{group}\\rangle ,\\beta ,\\gamma ,m,n)</span></li>

      <li>Compute multiples of  <span class="math">G</span>  as follows:  <span class="math">\\pmb{\\Sigma} := \\left( \\begin{array}{cccc} G &amp;amp; \\beta G &amp;amp; \\beta^2 G &amp;amp; \\dots &amp;amp; \\beta^D G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^2 G &amp;amp; \\dots &amp;amp; \\gamma \\beta^D G \\end{array} \\right) \\in \\mathbb{G}_1^{2D + 2}</span> .</li>

      <li>Set  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span>  public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}} := (\\langle \\mathsf{group} \\rangle, \\Sigma, \\beta H)</span> .</li>

      <li>Set AS public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{AS}} := 1^{\\lambda}</span> .</li>

      <li>Compute the predicate index  <span class="math">\\mathrm{i}_{\\Phi}</span>  as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">(\\mathbb{i},\\mathrm{aux})\\gets \\mathcal{A}_1^\\rho (\\mathsf{pp}_{\\mathsf{PC}},\\mathsf{pp}_{\\mathsf{AS}})</span> (b) Set  <span class="math">\\mathrm{i}_{\\Phi} := (\\mathrm{i}, \\mathrm{pp}_{\\mathrm{PC}})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">([\\mathfrak{q}_i]_{i = 1}^n,[acc_j]_{j = 1}^m,\\mathrm{acc})\\gets \\mathcal{A}_2^\\rho (\\mathsf{pp}_{\\mathsf{AS}},\\mathrm{i}_{\\Phi},\\mathrm{aux}).</span></li>

      <li>Parse  <span class="math">[\\mathfrak{q}_i]_{i=1}^n</span>  as  <span class="math">[(C_i, d_i, z_i, v_i), \\pi_i)]_{i=1}^n</span> , and  <span class="math">[\\mathrm{acc}_j]_{j=1}^m</span>  as  <span class="math">[(C_j^\\star, \\pi_j^\\star)]_{j=1}^m</span> .</li>

      <li>For each  <span class="math">i\\in [n]</span>  , set  <span class="math">A_{i}\\coloneqq e(C_{i}^{\\prime} - v_{i}G - \\bar{v}_{i}\\gamma G + z_{i}W_{i},H) - e(W_{i},\\beta H).</span></li>

      <li>For each  <span class="math">j \\in [m]</span> , set  <span class="math">A_{n+j} := e(\\pi_j^\\star, \\beta H) - e(C_j^\\star, H)</span> .</li>

      <li>Output  <span class="math">\\mathfrak{p} := ([A_i]_{i=1}^{n+m})</span> .</li>

    </ol>

    <p class="text-gray-300">Notice that if  <span class="math">\\mathcal{A}</span>  succeeds, then  <span class="math">f(\\mathfrak{p}) = \\hat{s} \\neq 0</span> , but  <span class="math">\\hat{s}(r) = 0</span> . This is exactly the winning condition for Lemma 3.3, and so  <span class="math">\\mathcal{B}</span>  succeeds whenever  <span class="math">\\mathcal{A}</span>  does. This means that if  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\delta</span> , then  <span class="math">\\mathcal{B}</span>  succeeds in the zero-finding game with probability  <span class="math">\\delta</span> , and so  <span class="math">\\delta \\leq \\mathrm{negl}(\\lambda)</span>  (since  <span class="math">q</span>  is superpolynomial).</p>

    <p class="text-gray-300">Zero knowledge. We demonstrate that AS is zero knowledge by constructing an efficient simulator S. During the setup phase,  <span class="math">\\mathrm{S}^{\\rho}(1^{\\lambda})</span>  computes  <span class="math">\\mathsf{pp} \\gets \\mathrm{G}^{\\rho}(1^{\\lambda})</span> , and outputs  <span class="math">(\\mathsf{pp}, \\tau = \\bot)</span> . Then, during the proving phase,  <span class="math">\\mathrm{S}^{\\rho}(\\mathsf{pp}, \\tau, \\mathrm{i}_{\\Phi})</span>  samples a random scalar  <span class="math">s \\in \\mathbb{F}_q</span> , sets  <span class="math">(C^{\\star}, \\pi^{\\star}) := (s\\beta G, sG)</span> , and outputs the accumulator  <span class="math">\\mathrm{acc} := (C^{\\star}, \\pi^{\\star})</span> . Note that the simulator does not program the random oracle. This implies that AS is zero knowledge, because the simulated public parameters are identical to the honest ones, and the accumulators are identically distributed: in both cases, the accumulator consists of a pair of random group elements.</p>

    <p class="text-gray-300">Efficiency. We now analyze the efficiency of our accumulation scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator:  <span class="math">\\mathrm{G}^{\\rho}(1^{\\lambda})</span>  outputs  <span class="math">1^{\\lambda}</span> , and hence takes  <span class="math">\\mathrm{poly}(\\lambda)</span>  time.</li>

      <li>Indexer:  <span class="math">\\mathrm{I}^{\\rho}(\\mathsf{pp},\\mathsf{pp}_{\\mathsf{PC}},\\mathrm{i}_{\\Phi})</span>  takes time poly(λ).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accumulation prover: <span class="math">\\mathrm{P}^{\\rho}(\\mathsf{apk},[((C_i,d_i,z_i,v_i),\\pi_i)]_{i = 1}^n,[\\mathsf{acc}_j]_{j = 1}^m)</span> invokes the subroutine ComputeAcc, which in turn computes <span class="math">O(1)</span> linear combinations of <span class="math">O(n + m)</span> elements in <span class="math">\\mathbb{G}_1</span>, and so requires time equal to <span class="math">O(n + m)</span> scalar multiplications in <span class="math">\\mathbb{G}_1</span>.</li>

      <li>Accumulator size: The accumulator acc consists of a pair <span class="math">(C^{\\star},\\pi^{\\star})</span> of elements in <span class="math">\\mathbb{G}_1</span>.</li>

      <li>Accumulation proof size: The accumulation proof <span class="math">\\pi_{\\mathrm{V}}</span> consists of two elements in <span class="math">\\mathbb{G}_1</span>.</li>

      <li>Accumulation verifier: <span class="math">\\mathrm{V}^{\\rho}(\\mathsf{avk},[((C_i,d_i,z_i,v_i),\\pi_i)]_{i = 1}^n,[\\mathsf{acc}_j]_{j = 1}^m,\\mathsf{acc},\\pi_{\\mathrm{V}})</span> simply invokes the common subroutine ComputeAcc, and so runs in the same time as P.</li>

      <li>Decider: <span class="math">\\mathrm{D}^{\\rho}(\\mathrm{dk},\\mathrm{acc})</span> performs one pairing, and so its running time is as claimed.</li>

    </ul>

    <p class="text-gray-300">46</p>

    <p class="text-gray-300">All algorithms below have access to the same random oracle  <span class="math">\\rho_0</span> .</p>

    <p class="text-gray-300">Setup. On input a security parameter  <span class="math">\\lambda</span>  (in unary) and a maximum degree  <span class="math">D</span> ,  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span> . Setup samples public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span>  as follows. Sample a bilinear group  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, G, H, e) \\gets \\mathsf{SampleGrp}^{\\rho_0}(1^{\\lambda})</span> , and then sample a field element  <span class="math">\\beta \\in \\mathbb{F}_q</span> . Compute</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} := \\left( \\begin{array}{c c c c c} G &amp;amp; \\beta G &amp;amp; \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\gamma \\beta^ {2} G &amp;amp; \\ldots &amp;amp; \\gamma \\beta^ {D} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {2 D + 2}.</span></div>

    <p class="text-gray-300">Output  <span class="math">\\mathsf{pp}_{\\mathsf{PC}} := (\\langle \\mathsf{group} \\rangle, \\Sigma, \\beta H)</span> .</p>

    <p class="text-gray-300">Trim. Given oracle access to public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> , and on input a list of degree bounds  <span class="math">[d_i]_{i=1}^n</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> . Trim specializes the public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span>  to the degree bounds  <span class="math">[d_i]_{i=1}^n</span>  as follows. Compute  <span class="math">d := \\max_{i \\in [n]} (d_1, \\ldots, d_n)</span> . From the powers  <span class="math">\\pmb{\\Sigma}</span>  in  <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> , select  <span class="math">\\pmb{\\Sigma}_{\\mathsf{ck}}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} _ {\\mathrm {c k}} := \\left( \\begin{array}{c c c c c c c c} G &amp;amp; \\beta G &amp;amp; \\ldots &amp;amp; \\beta^ {d} G &amp;amp; \\beta^ {D - d} G &amp;amp; \\beta^ {D - d + 1} G &amp;amp; \\ldots &amp;amp; \\beta^ {D} G \\\\ \\gamma G &amp;amp; \\gamma \\beta G &amp;amp; \\ldots &amp;amp; \\gamma \\beta^ {d} G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {3 d + 3}.</span></div>

    <p class="text-gray-300">Select  <span class="math">\\Sigma_{\\mathsf{rk}} := \\{\\beta^{D - d_i}G\\}_{i\\in [n]}</span> . Set the commitment key  <span class="math">\\mathsf{ck} := (\\langle \\mathsf{group}\\rangle, D, \\Sigma_{\\mathsf{ck}})</span>  and receiver key  <span class="math">\\mathsf{rk} := (D, \\langle \\mathsf{group}\\rangle, \\Sigma_{\\mathsf{rk}}, \\gamma G, \\beta H, [d_i]_{i=1}^n)</span> . Output  <span class="math">(\\mathsf{ck}, \\mathsf{rk})</span> .</p>

    <p class="text-gray-300">Commit. On input the commitment key ck, a univariate polynomial  <span class="math">p</span>  over the field  <span class="math">\\mathbb{F}_q</span> , a degree bound  <span class="math">d</span> , and commitment randomness  <span class="math">(\\omega, \\omega^{\\star})</span> ,  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span> . Commit computes a commitment to  <span class="math">p</span>  as follows. Obtain the supported degree bounds  <span class="math">[d_i]_{i=1}^n</span>  from ck. If  <span class="math">\\deg(p) &amp;gt; d</span>  or  <span class="math">d \\notin [d_i]_{i=1}^n</span> , abort. If  <span class="math">\\omega</span>  and  <span class="math">\\omega^{\\star}</span>  are not  <span class="math">\\bot</span> , then obtain from them random univariate polynomials  <span class="math">\\bar{p}</span>  and  <span class="math">\\bar{p}^{\\star}</span>  of degree  <span class="math">\\deg(p)</span> ; otherwise, set  <span class="math">\\bar{p}</span>  and  <span class="math">\\bar{p}^{\\star}</span>  to be the zero polynomial. Compute an "unshifted" commitment  <span class="math">U := p(\\beta)G + \\bar{p}(\\beta)\\gamma G</span>  and a "shifted" commitment  <span class="math">S := \\beta^{D-d_i}p(\\beta)G + \\bar{p}^{\\star}(\\beta)\\gamma G</span> . Finally, output  <span class="math">C := (U,S)</span> . Note that the  <span class="math">U</span>  and  <span class="math">S</span>  can be computed as linear combinations of terms in ck.</p>

    <p class="text-gray-300">Open. On input the commitment key ck, a univariate polynomial  <span class="math">p</span>  over the field  <span class="math">\\mathbb{F}_q</span> , a commitment  <span class="math">C</span>  to  <span class="math">p</span> , a degree bound  <span class="math">d</span> , an evaluation point  <span class="math">z</span> , and commitment randomness  <span class="math">(\\omega, \\omega^{\\star})</span> ,  <span class="math">\\mathsf{PC}_{\\mathrm{AGM}}</span> . Open computes an opening proof  <span class="math">\\pi</span>  as follows.</p>

    <p class="text-gray-300">Obtain the supported degree bounds  <span class="math">[d_i]_{i=1}^n</span>  from ck. If  <span class="math">\\omega</span>  and  <span class="math">\\omega^\\star</span>  are not  <span class="math">\\perp</span> , then obtain from them random univariate polynomials  <span class="math">\\bar{p}</span>  and  <span class="math">\\bar{p}^\\star</span>  of degree  <span class="math">\\deg(p)</span> ; otherwise, set  <span class="math">\\bar{p}</span>  and  <span class="math">\\bar{p}^\\star</span>  to be the zero polynomial. If  <span class="math">\\deg(p) &amp;gt; d</span>  or  <span class="math">d \\notin [d_i]_{i=1}^n</span> , abort. Compute the evaluation  <span class="math">v := p(z)</span>  and the opening challenge  <span class="math">\\xi := \\rho_0(\\mathsf{rk}, d, C, z, v) \\in \\mathbb{F}_q</span> . Then, define the polynomial  <span class="math">p^\\star(X) := X^{D-d}p(X) - X^{D-d}p(z)</span> , and compute a witness polynomial  <span class="math">w(X) := \\frac{p(X) - p(z)}{X - z}</span>  for  <span class="math">p</span> , and a witness polynomial  <span class="math">w^\\star(X) := X^{D-d}w(X)</span>  for  <span class="math">p^\\star</span> . Combine these into  <span class="math">w&#x27; := w + \\xi w^\\star</span> . Compute witness polynomials  <span class="math">\\bar{w}(X) := \\frac{\\bar{p}(X) - \\bar{p}(z)}{X - z}</span>  for  <span class="math">\\bar{p}</span>  and  <span class="math">\\bar{w}^\\star(X) := \\frac{\\bar{p}^\\star(X) - \\bar{p}^\\star(z)}{X - z}</span>  for  <span class="math">\\bar{p}^\\star</span> . Combine these into  <span class="math">\\bar{w}&#x27; := \\bar{w} + \\xi \\bar{w}^\\star</span> . Compute the evaluation  <span class="math">\\bar{v} := \\bar{w}&#x27;(z)</span> .</p>

    <p class="text-gray-300">Compute  <span class="math">W \\coloneqq w&#x27;(\\beta)G + \\bar{w}&#x27;(\\beta)\\gamma G</span> , and output the evaluation proof  <span class="math">\\pi \\coloneqq (W,\\bar{v})</span> .</p>

    <p class="text-gray-300">Check. On input the receiver key  <span class="math">\\mathsf{rk}</span> , a commitment  <span class="math">C</span> , a degree bound  <span class="math">d</span> , an evaluation point  <span class="math">z</span> , a claimed evaluation  <span class="math">v</span> , a evaluation proof  <span class="math">\\pi</span> ,  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> . Check proceeds as follows.</p>

    <p class="text-gray-300">If  <span class="math">d \\notin \\mathsf{rk}</span> , abort. Parse the commitment  <span class="math">C</span>  as a tuple  <span class="math">(U, S) \\in \\mathbb{G}_1^2</span> . Parse the proof  <span class="math">\\pi</span>  as  <span class="math">(W, \\bar{v}) \\in \\mathbb{G}_1 \\times \\mathbb{F}_q</span> . Compute the opening challenge  <span class="math">\\xi := \\rho_0(\\mathsf{rk}, C, z, d, v)</span> . Compute the combined commitment  <span class="math">C&#x27; := U + \\xi S</span> , and check the evaluation proof via the equality  <span class="math">e(C&#x27; - vG - v\\beta^{D - d}G - \\bar{v}\\gamma G, H) = e(W, \\beta H - zH)</span> .</p>

    <p class="text-gray-300">Figure 1: The polynomial commitment scheme  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> . Note that this scheme differs from the one described in [CHMMVW20] in that above  <span class="math">\\mathsf{PC}_{\\mathsf{AGM}}</span> . Check take as input the commitment, and generates an opening challenge by evaluating a random oracle on the commitment, whereas in [CHMMVW20], the opening challenge is provided as an explicit external input.</p>

    <p class="text-gray-300">A Construction of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span></p>

    <p class="text-gray-300">We describe <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>, a polynomial commitment scheme based on the discrete logarithm problem that is inspired by several prior works <em>[x1, x2, x3]</em>. This section is organized as follows: in Appendix A.1 we define Pedersen commitments; in Appendix A.2 we provide the construction of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>; and in Appendix A.3 we discuss the security of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Throughout the section we highlight in blue the parts of the construction that are necessary to make the commitment scheme hiding.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">A.1 Pedersen commitments</h3>

    <p class="text-gray-300">The Pedersen commitment scheme <em>[x24]</em> is a binding commitment on vectors of field elements that is linearly homomorphic with respect to both the commitment key and the committed elements.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{CM.Setup}</span>, on input a security parameter <span class="math">\\lambda</span> (written in unary) and a message format <span class="math">L\\in\\mathbb{N}</span>, samples public parameters <span class="math">\\mathsf{pp}=(\\langle\\mathsf{group}\\rangle,\\bm{\\Sigma},S)</span> where <span class="math">\\langle\\mathsf{group}\\rangle=(\\mathbb{G},q,G)\\leftarrow\\mathsf{SampleGrp}^{\\rho}(1^{\\lambda})</span> is a description of a group of prime order, and <span class="math">(S,\\bm{\\Sigma}=(G_{1},\\ldots,G_{L}))</span> are independent uniformly-sampled generators for <span class="math">\\mathbb{G}</span>.</li>

      <li><span class="math">\\mathsf{CM.Trim}</span>, on input public parameters <span class="math">\\mathsf{pp}</span> and a trim specification <span class="math">\\ell\\in\\mathbb{N}</span>, selects <span class="math">\\mathsf{hk}:=(G_{1},\\ldots,G_{\\ell})\\in\\mathbb{G}^{\\ell}</span> from <span class="math">\\bm{\\Sigma}</span> and outputs <span class="math">\\mathsf{ck}:=(\\langle\\mathsf{group}\\rangle,\\mathsf{hk},S)</span>. The message space is <span class="math">\\mathcal{M}:=\\mathbb{F}_{q}^{\\ell}</span>.</li>

      <li><span class="math">\\mathsf{CM.Commit}</span>, on input a commitment key <span class="math">\\mathsf{ck}=(\\langle\\mathsf{group}\\rangle,\\mathsf{hk},S)</span>, a message <span class="math">m\\in\\mathcal{M}=\\mathbb{F}_{q}^{\\ell}</span>, and commitment randomness <span class="math">\\omega\\in\\mathbb{F}_{q}</span>, computes the commitment <span class="math">C</span> as follows. If <span class="math">\\omega=\\bot</span>, set <span class="math">\\omega:=0</span>. Then, compute the commitment <span class="math">C:=\\omega S+\\sum_{i=1}^{\\ell}m_{i}G_{i}\\in\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">The Pedersen commitment scheme is binding provided the discrete logarithm problem is hard for <span class="math">\\mathsf{SampleGrp}</span>. Observe that for fixed <span class="math">\\omega</span>, the commitment algorithm <span class="math">\\mathsf{CM.Commit}</span> is a deterministic function of <span class="math">\\mathsf{ck}</span> and <span class="math">m</span>. Below we use <span class="math">\\mathsf{CM.Commit}_{\\mathsf{hk}}(m)</span> to denote the deterministic commitment <span class="math">\\mathsf{CM.Commit}(\\mathsf{ck},m;\\omega=\\bot)</span>, where <span class="math">\\mathsf{ck}=(\\langle\\mathsf{group}\\rangle,\\mathsf{hk},S)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that <span class="math">\\mathsf{CM.Commit}</span> satisfies the following bilinearity property: if <span class="math">\\mathsf{ck}=(\\langle\\mathsf{group}\\rangle,\\mathsf{hk},S)</span> and <span class="math">\\mathsf{ck}^{\\prime}=(\\langle\\mathsf{group}\\rangle,\\mathsf{hk}^{\\prime},S)</span> have the same group description and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hk}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{ck},\\vec{a};\\ \\omega_{a})+\\mathsf{Commit}(\\mathsf{ck},\\vec{b};\\ \\omega_{b})</span> <span class="math">=\\mathsf{Commit}(\\mathsf{ck},\\vec{a}+\\vec{b};\\ \\omega_{a}+\\omega_{b})\\quad\\text{and}</span> <span class="math">\\mathsf{CM.Commit}_{\\mathsf{hk}}(\\vec{a})+\\mathsf{CM.Commit}_{\\mathsf{hk}^{\\prime}}(\\vec{a})</span> <span class="math">=\\mathsf{CM.Commit}_{\\mathsf{hk}+\\mathsf{hk}^{\\prime}}(\\vec{a})\\enspace,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{hk}+\\mathsf{hk}^{\\prime}</span> denotes addition in the group <span class="math">\\mathbb{G}^{\\ell}</span>. Note that the foregoing bilinearity property implies that <span class="math">\\mathsf{CM.Commit}_{\\mathsf{hk}}(\\vec{a})=\\mathsf{CM.Commit}_{x^{-1}\\cdot\\mathsf{hk}}(x\\cdot\\vec{a})</span> for all <span class="math">x\\in\\mathbb{F}_{q}^{*}</span>.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">A.2 Construction</h3>

    <p class="text-gray-300">In our construction below, all algorithms have oracle access to the same random oracle <span class="math">\\rho_{0}</span>. We assume without loss of generality that expressions of the form <span class="math">d+1</span> and <span class="math">D+1</span> are powers of <span class="math">2</span>. For a vector <span class="math">\\vec{a}\\in S^{n}</span> for any set <span class="math">S</span>, we use the notation <span class="math">\\mathbf{l}(\\vec{a}):=(a_{1},\\ldots,a_{n/2})</span> and <span class="math">\\mathbf{r}(\\vec{a}):=(a_{n/2+1},\\ldots,a_{n})</span> to denote the left and right halves of <span class="math">\\vec{a}</span>, respectively.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Setup.</h6>

    <p class="text-gray-300">On input security parameter <span class="math">\\lambda</span> (written in unary) and a maximum supported degree <span class="math">D</span>, <span class="math">\\mathsf{PC}_{\\mathsf{DL}}.\\mathsf{Setup}</span> samples public parameters <span class="math">\\mathsf{pp}=(\\langle\\mathsf{group}\\rangle=(\\mathbb{G},q,G),\\bm{\\Sigma},S)\\leftarrow\\mathsf{CM.Setup}^{\\rho_{0}}(1^{\\lambda},D+1)</span>, samples a random generator <span class="math">H\\leftarrow\\rho_{0}(\\mathsf{pp})</span> in the group <span class="math">\\mathbb{G}</span>, and outputs the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{PC}}:=(\\mathsf{pp},H)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Trim. Given oracle access to the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> and a single degree bound <span class="math">d</span> that is at most <span class="math">D</span>, <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Trim specializes the public parameters for the degree bounds as follows: parse <span class="math">\\mathsf{pp}_{\\mathsf{PC}}</span> as <span class="math">(\\mathsf{pp}, H)</span>, compute <span class="math">\\mathsf{ck} \\gets \\mathsf{CM}.\\mathsf{Trim}(\\mathsf{pp}, d + 1)</span>, and output <span class="math">(\\mathsf{ck}_{\\mathsf{PC}}, \\mathsf{rk}_{\\mathsf{PC}}) := ((\\mathsf{ck}, H), (\\mathsf{ck}, H))</span>. (We note that we consider the case where <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Trim only receives a single degree bound <span class="math">d</span> rather than a vector of degrees <span class="math">[d_i]_{i=1}^n</span>. We omit details for this more general case.)</p>

    <p class="text-gray-300">Commit. On input the commitment key <span class="math">\\mathsf{ck}_{\\mathsf{PC}} = (\\mathsf{ck}, H)</span>, a univariate polynomial <span class="math">p</span> over the field <span class="math">\\mathbb{F}_q</span>, a degree bound <span class="math">d</span>, and commitment randomness <span class="math">\\omega</span>, <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Commit outputs <span class="math">C := \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, \\vec{c}, \\omega)</span>, where <span class="math">\\vec{c} = (c_0, \\ldots, c_d)</span> are the coefficients of <span class="math">p</span>.</p>

    <p class="text-gray-300">Open. On input the commitment key <span class="math">\\mathsf{ck}_{\\mathsf{PC}} = (\\mathsf{ck}, H)</span>, a univariate polynomial <span class="math">p(X)</span>, a commitment <span class="math">C</span> to <span class="math">p</span>, a degree bound <span class="math">d</span>, an evaluation point <span class="math">z</span>, and commitment randomness <span class="math">\\omega</span>, <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Open computes an evaluation proof <span class="math">\\pi</span> by using (a variant of) the inner product argument in [BCCGP16; BBBPWM18] as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the evaluation <span class="math">v \\coloneqq p(z) \\in \\mathbb{F}_q</span>.</li>

      <li>Sample a random polynomial <span class="math">\\bar{p} \\in \\mathbb{F}_{\\bar{q}}^{\\leq d}[X]</span> such that <span class="math">\\bar{p}(z) = 0</span>.</li>

      <li>Sample corresponding commitment randomness <span class="math">\\bar{\\omega} \\in \\mathbb{F}_q</span>.</li>

      <li>Compute a hiding commitment to <span class="math">\\bar{p}</span>: <span class="math">\\bar{C} \\gets \\mathsf{CM}.\\mathsf{Commit}^{\\rho_0}(\\mathsf{ck}, \\bar{p}; \\bar{\\omega}) \\in \\mathbb{G}</span>.</li>

      <li>Compute the challenge <span class="math">\\alpha \\coloneqq \\rho (C,z,v,\\bar{C})\\in \\mathbb{F}_q^*</span>.</li>

      <li>Compute the polynomial <span class="math">p&#x27; := p + \\alpha \\bar{p} = \\sum_{i=0}^{d} c_i X^i \\in \\mathbb{F}_q[X]</span>.</li>

      <li>Compute commitment randomness <span class="math">\\omega&#x27; := \\omega + \\alpha \\bar{\\omega} \\in \\mathbb{F}_q</span>.</li>

      <li>Compute a non-hiding commitment to <span class="math">p&#x27;</span>: <span class="math">C&#x27; := C + \\alpha \\bar{C} - \\omega&#x27;S \\in \\mathbb{G}</span>.</li>

    </ol>

    <p class="text-gray-300">Compute the 0-th challenge field element <span class="math">\\xi_0 \\coloneqq \\rho_0(C&#x27;, z, v) \\in \\mathbb{F}_q</span>, and use it to compute the group element <span class="math">H&#x27; \\coloneqq \\xi_0 H \\in \\mathbb{G}</span>. Initialize the following vectors:</p>

    <div class="my-4 text-center"><span class="math-block">\\vec{c}_0 := (c_0, c_1, \\dots, c_d) \\in \\mathbb{F}_q^{d+1} \\quad \\text{and} \\quad \\vec{z}_0 := (1, z, \\dots, z^d) \\in \\mathbb{F}_q^{d+1} \\quad \\text{and} \\quad \\vec{G}_0 := (G_0, G_1, \\dots, G_d) \\in \\mathbb{G}^{d+1}.</span></div>

    <p class="text-gray-300">Next, for each <span class="math">i \\in [\\log (d + 1)]</span>, perform the following steps:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Setting $\\Sigma_{\\mathrm{L}} := \\mathbf{l}(\\vec{G}_{i-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H'<span class="math">, compute the left commitment </span>L_i := \\mathsf{CM}.\\mathsf{Commit}_{\\Sigma_{\\mathrm{L}}}\\big(\\mathbf{r}(\\vec{c}_{i-1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\mathbf{r}(\\vec{c}_{i-1}), \\mathbf{l}(\\vec{z}_{i-1}) \\rangle \\big)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate the <span class="math">i</span>-th challenge <span class="math">\\xi_i := \\rho_0(\\xi_{i-1}, L_i, R_i) \\in \\mathbb{F}_q</span>.</li>

      <li>Construct the commitment key for the next round: <span class="math">\\vec{G}_i := \\mathbf{l}(\\vec{G}_{i-1}) + \\xi_i \\cdot \\mathbf{r}(\\vec{G}_{i-1})</span>.</li>

      <li>Construct commitment inputs for the next round: <span class="math">\\vec{c}_i := \\mathbf{l}(\\vec{c}_{i-1}) + \\xi_i^{-1} \\cdot \\mathbf{r}(\\vec{c}_{i-1})</span> and <span class="math">\\vec{z}_i := \\mathbf{l}(\\vec{z}_{i-1}) + \\xi_i \\cdot \\mathbf{r}(\\vec{z}_{i-1})</span>.</li>

    </ol>

    <p class="text-gray-300">Finally, set <span class="math">U \\coloneqq G_{\\log (d + 1)}</span>, <span class="math">c \\coloneqq c_{\\log (d + 1)}</span>, and output the evaluation proof <span class="math">\\pi \\coloneqq (\\vec{L}, \\vec{R}, U, c, \\bar{C}, \\omega&#x27;)</span>.</p>

    <p class="text-gray-300">Check. On input the receiver key <span class="math">\\mathsf{rk}_{\\mathsf{PC}} = (\\mathsf{ck}, H)</span>, a commitment <span class="math">C</span>, a degree bound <span class="math">d</span>, an evaluation point <span class="math">z</span>, a claimed evaluation <span class="math">v</span>, and an evaluation proof <span class="math">\\pi</span>, <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. Check verifies the evaluation proof by invoking the verifier of the inner product argument as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ck as <span class="math">(\\langle \\mathsf{group} \\rangle, \\mathsf{hk}, S)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Set $d' :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{hk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathsf{rk} := (\\langle \\mathsf{group} \\rangle, S, H, d&#x27;)</span>.</li>

      <li>Check that <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. SuccinctCheck<span class="math">^{\\rho_0}(\\mathsf{rk}, C, d, z, v, \\pi)</span> accepts and outputs <span class="math">(h, U)</span>. (See Figure 2).</li>

      <li>Check that <span class="math">U = \\mathsf{CM}.\\mathsf{Commit}(\\mathsf{ck}, \\vec{h})</span>, where <span class="math">\\vec{h}</span> is the coefficient vector of the polynomial <span class="math">h</span>.</li>

    </ol>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  SuccinctCheck  <span class="math">\\rho_0</span>  (rk,  <span class="math">C,d,z,v,\\pi</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse rk as  <span class="math">(\\langle \\mathrm{group}\\rangle ,S,H,d^{\\prime})</span>  , and  <span class="math">\\pi</span>  as  <span class="math">(\\vec{L},\\vec{R},U,c,\\bar{C},\\omega^{\\prime})</span></li>

      <li>Check that  <span class="math">d = d&#x27;</span> .</li>

      <li>Compute the challenge  <span class="math">\\alpha \\coloneqq \\rho_0(C,z,v,\\bar{C})\\in \\mathbb{F}_q^*</span></li>

      <li>Compute the non-hiding commitment  <span class="math">C&#x27; \\coloneqq C + \\alpha \\bar{C} - \\omega&#x27; S \\in \\mathbb{G}</span> .</li>

      <li>Compute the 0-th challenge  <span class="math">\\xi_0\\coloneqq \\rho_0(C&#x27;,z,v)</span>  , and set  <span class="math">H^{\\prime}\\coloneqq \\xi_{0}H\\in \\mathbb{G}</span></li>

      <li>Compute the group element  <span class="math">C_0 \\coloneqq C&#x27; + vH&#x27; \\in \\mathbb{G}</span> .</li>

      <li>For each  <span class="math">i\\in [\\log (d + 1)]</span>  ..</li>

    </ol>

    <p class="text-gray-300">(a) Generate the  <span class="math">i</span> -th challenge:  <span class="math">\\xi_{i} := \\rho_{0}(\\xi_{i-1}, L_{i}, R_{i}) \\in \\mathbb{F}_{q}</span> . (b) Compute the  <span class="math">i</span> -th commitment:  <span class="math">C_i \\coloneqq \\xi_i^{-1} L_i + C_{i-1} + \\xi_i R_i \\in \\mathbb{G}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the univariate polynomial  <span class="math">h(X) \\coloneqq \\prod_{i=0}^{\\log(d+1)-1} \\left(1 + \\xi_{\\log(d+1)-i} X^{2^i}\\right) \\in \\mathbb{F}_q[X]</span> .</li>

      <li>Compute the evaluation  <span class="math">v&#x27; \\coloneqq c \\cdot h(z) \\in \\mathbb{F}_q</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10. Check that  $C_{\\log (d + 1)} = \\mathsf{CM}. \\mathsf{Commit}_{\\Sigma}(c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v')<span class="math"> , where  </span>\\Sigma = (U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H')$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">(h,U)</span></li>

    </ol>

    <p class="text-gray-300">Figure 2: The subroutine  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . SuccinctCheck that is invoked by  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> . Check and by our accumulation scheme.</p>

    <p class="text-gray-300">We construct the following simulator  <span class="math">S</span>  for  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S.Setupρ0(1λ,D): 1. Compute pp := PCDL.Setupρ(1λ). 2. Output (pp, trap := pp).</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S.Openρ0(z,v): 1. Sample a random challenge α ∈ Fq*. 2. Sample a random polynomial p ∈ Fq≤d[X] such that p(z) = v/α. 3. Sample a commitment randomness ω ∈ Fq. 4. Compute a hiding commitment to p: C← CM.Commitρ0(ck, p; ω). 5. Define the programming function μ(C, z, v, C) := α. 6. Proceed as in PCDL.Open to compute the evaluation proof π. 7. Output (μ, π).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  S.Commitρ0(trap = pp, d): 1. Compute (ck, rk) := PC.Trimρ0(pp, d). 2. Sample commitment randomness ω ∈ Fq. 3. Output C := PCDL.Commitρ0(ck, 0, d; ω). |   |</p>

    <p class="text-gray-300">We now informally argue that the output of  <span class="math">S</span>  is computationally indistinguishable from that of an honest execution. First, the public parameters are both honestly sampled. Next, the hiding property of CM means that commitments are uniformly random group elements, and are hence identically distributed in both cases. Next, in both cases the inner product argument is performed with respect to a polynomial  <span class="math">p&#x27;</span>  drawn independently and uniformly conditioned on  <span class="math">p&#x27;(v) = z</span> , and so these are identically distributed. Finally, for any polynomial-time adversary the programmed random oracle  <span class="math">\\rho[\\mu]</span>  is indistinguishable from the honestly sampled random oracle  <span class="math">\\rho</span>  because  <span class="math">S</span>  programs it at the point  <span class="math">(C, z, v, \\bar{C})</span> , which has sufficiently high entropy due to the randomness of  <span class="math">\\bar{C}</span> .</p>

    <p class="text-gray-300">It is conjectured that if the Pedersen commitment scheme is binding, then  <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>  constructed in Appendix A.2 is a polynomial commitment scheme in the random oracle model (Section 3.6). Below we summarize what is currently known about this conjecture.</p>

    <p class="text-gray-300">Recall that in <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>, the algorithms <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>.Open and <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span>.Check are obtained by applying the Fiat–Shamir transformation <em>[x10]</em> to a public-coin “inner-product” argument system. We first discuss the security of this interactive argument, and then discuss the security (in the random oracle model) of the non-interactive argument obtained after applying the Fiat–Shamir transformation.</p>

    <p class="text-gray-300">Security of the interactive argument. A sequence of works <em>[x2, x4, x11]</em> have shown how to construct various inner-product arguments of knowledge from any doubly-homomorphic commitment scheme by explicitly constructing an efficient rewinding extractor. The inner-product argument used in <span class="math">\\mathsf{PC}_{\\textsc{dl}}</span> is a special case of an inner-product argument in <em>[x5]</em>, and thus inherits its knowledge soundness guarantees.</p>

    <p class="text-gray-300">Security of the resulting non-interactive argument. It is known from folklore that applying the Fiat–Shamir transformation to a public-coin <span class="math">k</span>-round interactive argument of knowledge with negligible soundness error yields a non-interactive argument of knowledge in the random-oracle model where the extractor <span class="math">\\mathcal{E}</span> runs in time exponential in <span class="math">k</span>. In more detail, to extract from an adversary that makes <span class="math">\\mathsf{t}</span> queries to the random oracle, <span class="math">\\mathcal{E}</span> runs in time <span class="math">\\mathsf{t}^{O(k)}</span>. In our setting, the inner-product argument has <span class="math">k=O(\\log d)</span> rounds, which means that if we apply this folklore result, we would obtain an extractor that runs in superpolynomial (but subexponential) time <span class="math">\\mathsf{t}^{O(\\log d)}=2^{O(\\log(\\lambda)^{2})}</span>. It remains an interesting open problem to construct an extractor that runs in polynomial time.</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">The authors thank William Lin for pointing out an error in a prior version of the construction of <span class="math">\\mathsf{PC}_{\\mathsf{DL}}</span>. This research was supported in part by: the Berkeley Haas Blockchain Initiative and a donation from the Ethereum Foundation. Benedikt Bünz performed part of the work while visiting the Simons Institute for the Theory of Computing.</p>

    <h2 id="sec-68" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[BBBPWM18] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&P ’18. 2018, pp. 315–334.</li>

      <li>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCGGHJ17] J. Bootle, A. Cerulli, E. Ghadafi, J. Groth, M. Hajiabadi, and S. K. Jakobsen. “Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability”. In: Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security. ASIACRYPT ’17. 2017, pp. 336–365.</li>

      <li>[BCRSVW19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. Full version available at https://eprint.iacr.org/2018/828. 2019, pp. 103–128.</li>

      <li>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: Proceedings of the 34th Annual International Cryptology Conference. CRYPTO ’14. 2014, pp. 276–294.</li>

      <li>[BDFLSZ11] D. Boneh, Ö. Dagdelen, M. Fischlin, A. Lehmann, C. Schaffner, and M. Zhandry. “Random Oracles in a Quantum World”. In: Proceedings of the 17th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’11. 2011, pp. 41–69.</li>

      <li>[BGH19] S. Bowe, J. Grigg, and D. Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019.</li>

      <li>[BMMV19] B. Bünz, M. Maller, P. Mishra, and N. Vesely. Proofs for Inner Pairing Products and Applications. Cryptology ePrint Archive, Report 2019/1177. 2019.</li>

      <li>[BMRS20] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Report 2020/352. 2020.</li>

    </ul>

    <p class="text-gray-300">[BR93] M. Bellare and P. Rogaway. “Random Oracles Are Practical: A Paradigm for Designing Efficient Protocols”. In: Proceedings of the 1st ACM Conference on Computer and Communications Security. CCS ’93. 1993, pp. 62–73.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CCW19] A. Chiesa, L. Chua, and M. Weidner. “On Cycles of Pairing-Friendly Elliptic Curves”. In: SIAM Journal on Applied Algebra and Geometry 3.2 (2019), pp. 175–192.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[CL20] A. Chiesa and S. Liu. “On the Impossibility of Probabilistic Proofs in Relativized Worlds”. In: Proceedings of the 11th Innovations in Theoretical Computer Science Conference. ITCS ’20. 2020, 57:1–57:30.</li>

      <li>[Co17] O(1) Labs. Coda Cryptocurrency. https://codaprotocol.com/. 2017.</li>

      <li>[COS20] A. Chiesa, D. Ojha, and N. Spooner. “Fractal: Post-Quantum and Transparent Recursive Proofs from Holography”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020.</li>

      <li>[CT10] A. Chiesa and E. Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: Proceedings of the 1st Symposium on Innovations in Computer Science. ICS ’10. 2010, pp. 310–331.</li>

      <li>[CTV13] S. Chong, E. Tromer, and J. A. Vaughan. Enforcing Language Semantics Using Proof-Carrying Data. Cryptology ePrint Archive, Report 2013/513. 2013.</li>

      <li>[CTV15] A. Chiesa, E. Tromer, and M. Virza. “Cluster Computing in Zero Knowledge”. In: Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’15. 2015, pp. 371–403.</li>

      <li>[FS86] A. Fiat and A. Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: Proceedings of the 6th Annual International Cryptology Conference. CRYPTO ’86. 1986, pp. 186–194.</li>

      <li>[GW11] C. Gentry and D. Wichs. “Separating Succinct Non-Interactive Arguments From All Falsifiable Assumptions”. In: Proceedings of the 43rd Annual ACM Symposium on Theory of Computing. STOC ’11. 2011, pp. 99–108.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019.</li>

      <li>[Halo19] S. Bowe, J. Grigg, and D. Hopwood. Halo. 2019. URL: https://github.com/ebfull/halo.</li>

      <li>[KB20] A. Kattis and J. Bonneau. Proof of Necessary Work: Succinct State Verification with Fairness Guarantees. Cryptology ePrint Archive, Report 2020/190. 2020.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 177–194.</li>

      <li>[Lin03] Y. Lindell. “Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation”. In: Journal of Cryptology 16.3 (2003), pp. 143–184.</li>

      <li>[MBKM19] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings”. In: Proceedings of the 26th ACM Conference on Computer and Communications Security. CCS ’19. 2019.</li>

      <li>[NPR19] M. Naor, O. Paneth, and G. N. Rothblum. “Incrementally Verifiable Computation via Incremental PCPs”. In: Proceedings of the 17th International Conference on the Theory of Cryptography. TCC ’19. 2019, pp. 552–576.</li>

    </ul>

    <p class="text-gray-300">[NT16] A. Naveh and E. Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: <em>Proceedings of the 37th IEEE Symposium on Security and Privacy</em>. S&amp;P ’16. 2016, pp. 255–271.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Pas03] R. Pass. “On Deniability in the Common Reference String and Random Oracle Model”. In: <em>Proceedings of the 23rd Annual International Cryptology Conference</em>. CRYPTO ’03. 2003, pp. 316–337.</li>

      <li>[Ped92] T. P. Pedersen. “Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing”. In: <em>Proceedings of the 11th Annual International Cryptology Conference</em>. CRYPTO ’91. 1992, pp. 129–140.</li>

      <li>[Pickles20] O(1) Labs. <em>Pickles</em>. URL: https://github.com/o1-labs/marlin.</li>

      <li>[SS11] J. H. Silverman and K. E. Stange. “Amicable Pairs and Aliquot Cycles for Elliptic Curves”. In: <em>Experimental Mathematics</em> 20.3 (2011), pp. 329–357.</li>

      <li>[Val08] P. Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: <em>Proceedings of the 5th Theory of Cryptography Conference</em>. TCC ’08. 2008, pp. 1–18.</li>

      <li>[WTSTW18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: <em>Proceedings of the 39th IEEE Symposium on Security and Privacy</em>. S&amp;P ’18. 2018, pp. 926–943.</li>

    </ul>`;
---

<BaseLayout title="Proof-Carrying Data from Accumulation Schemes (2020/499)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/499
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
