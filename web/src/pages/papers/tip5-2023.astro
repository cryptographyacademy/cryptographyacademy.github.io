---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/107';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-13';
---

<BaseLayout title="Tip5 (2023/107)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        The Tip5 Hash Function for Recursive STARKs
      </h1>
      <p class="text-gray-400 mb-2">
        Alan Szepieniec, Alexander Lemmens, Jan Ferdinand Sauer,
        Bobbin Threadbare, Al Kindi
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/107
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                The Application: Recursive STARKs</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                What About Lookup Gates?</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Specification</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                High-Level Overview</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                S-Box Layer</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Linear Layer</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Round Constants</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                Fixed-Length versus Variable-Length</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Implementation Aspects</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Montgomery Representation</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                MDS Matrix Multiplication</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                CPU Performance</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Arithmetization</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Lookup Argument</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Cascade Construction</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Narrow Lookup Tables</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Periodic Constraints</a>
            </li>
            <li>
              <a href="#sec-4.5"
                class="hover:text-white">
                Periodic Interpolants</a>
            </li>
            <li>
              <a href="#sec-4.6"
                class="hover:text-white">
                Correct Decomposition of Elements Modulo p</a>
            </li>
            <li>
              <a href="#sec-4.7"
                class="hover:text-white">
                Arithmetization of Tip5</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Security Analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Statistical Attacks</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Linear Cryptanalysis</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Differential Cryptanalysis</a>
            </li>
            <li>
              <a href="#sec-5.4"
                class="hover:text-white">
                Algebraic Attacks</a>
            </li>
            <li>
              <a href="#sec-5.5"
                class="hover:text-white">
                Univariate</a>
            </li>
            <li>
              <a href="#sec-5.6"
                class="hover:text-white">
                Straightforward Grobner Basis</a>
            </li>
            <li>
              <a href="#sec-5.7"
                class="hover:text-white">
                Split S-box</a>
            </li>
            <li>
              <a href="#sec-5.8"
                class="hover:text-white">
                Linear Approximation</a>
            </li>
            <li>
              <a href="#sec-5.9"
                class="hover:text-white">
                Fixing</a>
            </li>
            <li>
              <a href="#sec-5.10"
                class="hover:text-white">
                Skip Two Rounds</a>
            </li>
            <li>
              <a href="#sec-5.11"
                class="hover:text-white">
                Cryptanalysis Summary</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Conclusion</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        This paper specifies a new arithmetization-oriented hash
        function called Tip5. It uses the SHARK design strategy [RDP+96]
        with low-degree power maps in combination with lookup tables,
        and is tailored to the field with
        <span class="math">p = 2^&#123;64&#125; - 2^&#123;32&#125; + 1</span> elements.
      </p>
      <p class="text-gray-300">
        The context motivating this design is the recursive
        verification of STARKs. This context imposes particular design
        constraints, and therefore the hash function's arithmetization
        is discussed at length.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        In the context of succinctly verifiable and zero-knowledge
        proof systems for arbitrary computation, standard hash
        functions such as SHA3 and Blake3 are disfavored due to their
        expensive arithmetizations. Specifically, the representation of
        these hash functions in terms of polynomials is sizeable, and
        induces a matching cost on the proof system that uses it. In
        this setting, arithmetization-oriented hash functions are
        preferred instead as these were designed with an efficient
        arithmetization in mind.
      </p>
      <p class="text-gray-300">
        In the space of arithmetization-oriented hash functions, three
        design strategies stand out.
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-3
        ml-4 my-4">
        <li>
          The <strong>Marvellous</strong> design strategy [AAB+20], best
          known for its member Rescue-Prime [SAD20], introduced the idea
          of alternating S-box layers where even layers compute
          low-degree permutations in one direction and odd layers
          compute low-degree permutations in the opposite direction.
          As a result, a small number of rounds guarantees that the
          algebraic degree of the cipher is sufficiently high when
          attacked from any direction. Moreover, in the specific case
          of Rescue-Prime, two consecutive S-box layers can be folded
          together into one low-degree arithmetization. This folding
          technique yields essentially two rounds of the cipher for
          the price of one cycle in the arithmetic virtual machine.
          Since the publication of the Marvellous design strategy,
          there has been very little progress in cryptanalyzing Rescue
          and Rescue-Prime.
        </li>
        <li>
          The <strong>Hades</strong> design strategy [GLR+20], best known
          for its member Poseidon [GKR+21], introduces a distinction
          between full rounds and partial rounds. All rounds consist
          of a layer of S-boxes, a linear diffusion layer, and an
          injection of constants. What sets partial and full rounds
          apart is the number of S-boxes: in partial rounds this
          number is one, whereas in full rounds every state element is
          mapped by the S-box. The full rounds, located at the
          beginning and the end of the cipher, defend against
          statistical attacks. The large number of partial rounds in
          the middle defend against algebraic attacks by increasing
          the degree of polynomials describing the function.
        </li>
        <li>
          <strong>Reinforced Concrete</strong> [GKL+22] introduced the use
          of lookup tables in an otherwise arithmetization-oriented
          cipher. The lookup table can be evaluated efficiently on CPUs
          as well as proven efficiently in a zero-knowledge or
          succinctly verifiable proof system using Plookup [GWC19] or
          techniques derived from there. Moreover, represented as
          polynomials over a finite field, non-trivial lookup tables
          have maximal degree. Therefore, the use of lookup tables
          provides a robust way to resist algebraic attacks including
          attacks relying on Grobner bases. The downside of this
          technique is that the lookup tables cannot be too large; that
          therefore the field elements must be decomposed into chunks
          which are then looked up; and that the prover must establish
          the correct decomposition and recomposition of these chunks.
          This process leads to an expensive arithmetization and does
          not generalize well to arbitrary fields.
        </li>
      </ol>
      <p class="text-gray-300">
        This note proposes a new hash function. It uses the SHARK
        design strategy, on which Marvellous is based, of using full
        S-box layers interleaved with MDS matrices. The S-boxes come
        in two types. The first is built from a table lookup that
        computes the cube map in
        <span class="math">\mathbb&#123;F&#125;_&#123;2^8+1&#125;</span> but offset by
        one. This function is fast to compute. In addition, its
        algebraic degree over
        <span class="math">\mathbb&#123;F&#125;_p</span> is large, providing
        resistance against Grobner basis attacks. The second type is
        the regular forward
        <span class="math">\alpha</span>th power map found in Rescue
        and Poseidon, where
        <span class="math">\alpha</span> is the smallest integer such
        that
        <span class="math">\gcd(\alpha, p-1) = 1</span>. As this
        second type of S-boxes constitutes the majority in every S-box
        layer, they suffice to provide defense against statistical
        attacks through the wide-trail argument [DR20].
      </p>

      <!-- Table 1: Summary of parameters -->
      <div id="table-1" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 1.</strong> Summary of parameters.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Parameter</th>
              <th class="text-left py-2 pr-4">Symbol</th>
              <th class="text-left py-2">Value</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">field modulus</td>
              <td class="py-2 pr-4">
                <span class="math">p</span>
              </td>
              <td class="py-2">
                <span class="math">2^&#123;64&#125; - 2^&#123;32&#125; + 1</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">number of rounds</td>
              <td class="py-2 pr-4">
                <span class="math">N</span>
              </td>
              <td class="py-2">5</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">state size</td>
              <td class="py-2 pr-4">
                <span class="math">m</span>
              </td>
              <td class="py-2">16</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">sponge rate</td>
              <td class="py-2 pr-4">
                <span class="math">r</span>
              </td>
              <td class="py-2">10</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">sponge capacity</td>
              <td class="py-2 pr-4">
                <span class="math">c</span>
              </td>
              <td class="py-2">6</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">digest length</td>
              <td class="py-2 pr-4">
                <span class="math">d</span>
              </td>
              <td class="py-2">5</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">power map exponent</td>
              <td class="py-2 pr-4">
                <span class="math">\alpha</span>
              </td>
              <td class="py-2">7</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                number of split-and-lookups per round
              </td>
              <td class="py-2 pr-4">
                <span class="math">s</span>
              </td>
              <td class="py-2">4</td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 1.1 The Application: Recursive STARKs -->
      <h3 id="sec-1.1" class="text-lg font-semibold mt-6">
        1.1 The Application: Recursive STARKs
      </h3>
      <p class="text-gray-300">
        The hash function proposed here is designed not for a general
        purpose but specifically for integration into STARK [BBH+19] engines
        and specifically for the purpose of enabling the recursive
        proof of the correct execution of a STARK verifier. This
        application informs all design choices. The hash function may
        be used elsewhere, for instance in circuit-based SNARKs or MPC
        applications, but these alternative uses are not motivations
        for particular design choices.
      </p>
      <p class="text-gray-300">
        For example: there are SNARKs that work for either model of
        computation, arithmetic circuits or state machines. Both types
        of SNARKs benefit from using arithmetization-oriented
        functions, but even so, a given function may be more supportive
        of the one or the other model. In particular, state machines
        work by applying a step function iteratively to a mutable
        state. The collection of these states is called the trace and
        it is integral if it satisfies local constraints &mdash;
        namely, the step function was correctly computed between every
        consecutive pair. This step function is independent of the
        cycle. Hash functions defined in terms of different round
        functions are less conducive to this model of computation than
        hash functions with uniform round functions.
      </p>
      <p class="text-gray-300">
        Another important consideration related to the chosen model of
        computation is the separation of the processor and the hasher
        into distinct functional units. Each functional unit has a
        different step function. Both units generate execution traces.
        Moreover, there is an argument that proves the correct relation
        between these two traces; it is not too dissimilar from a
        communication bus that allows the processor to send queries to
        the hash coprocessor and receive responses back.
        Asymptotically speaking, the prover's running time is
        dominated by computing NTTs (number theoretic transforms) on
        vectors whose length is proportional to the largest of all
        execution traces. For recursively proving the correct
        verification of a STARK proof, however, the workload in terms
        of computing hashes exceeds that of all other tasks combined.
        As a result, hash functions with short execution traces are
        preferable and can even be so at the expense of more registers.
      </p>
      <p class="text-gray-300">
        The particular type of hashing that constitutes the bulk of the
        verifier's work is the verification of Merkle authentication
        paths. To this end, the hash function must support efficient
        two-to-one hashing. In the specific case of sponge-based hash
        functions, it is imperative that two-to-one hashing can be
        achieved with one absorbing step and one squeezing step &mdash;
        so that only one invocation of the permutation is needed. As a
        result, the sponge state must be sufficiently wide.
      </p>
      <p class="text-gray-300">
        Based on these design constraints, we select Rescue-Prime [SAD20]
        as the starting point even though Poseidon is about
        <span class="math">4\times</span> faster on CPU in the given
        context [Thr]. Rescue-Prime's security against both algebraic
        and statistical attacks seems to grow with the state size, and
        so the relatively large minimum state width is compensated for
        with a relatively small number of (uniform) rounds.
      </p>

      <!-- 1.2 What About Lookup Gates? -->
      <h3 id="sec-1.2" class="text-lg font-semibold mt-6">
        1.2 What About Lookup Gates?
      </h3>
      <p class="text-gray-300">
        While lookup tables were well-known and well-used in the
        construction of traditional ciphers, it was not until the
        advent of the Plookup technique [GW20] that the correct lookup
        could be proven in addition to executed. This technique
        presents an intriguing new tool in the
        arithmetization-oriented cipher designer's toolbox. Lookup
        tables are designed to break algebras; and so it should come
        as no surprise that there does not seem to be an efficient way
        to algebraically attack ciphers that use them. Moreover,
        lookup gates can typically be evaluated in only a handful of
        cycles on a modern CPU.
      </p>
      <p class="text-gray-300">
        Despite Rescue's impeccable track record, algebraic attacks
        relying on Grobner basis algorithms remain poorly understood.
        For most parameters, a Grobner basis attack is the cheapest
        and so it is used to set the number of rounds. However, the
        inclusion of lookup gates promises to completely explode the
        complexity of a whole range of algebraic attacks including
        those involving Grobner bases. As such, lookup gates can not
        only defend against as-yet-undiscovered attack strategies, but
        can also reduce the number of rounds needed for a target
        security level.
      </p>
      <p class="text-gray-300">
        In theory, the NTT ought to be the prover's bottleneck because
        its complexity is asymptotically the largest. However, in
        practice, the prover's running time is dominated by the
        complexity of computing Merkle trees. Lookup gates promise to
        replace the computationally expensive alpha-inverse power maps
        used in Rescue by cheaper operations at no discernible cost to
        security. As a result, by switching to a hash function that
        has lookup gates rather than alpha-inverse power maps, the
        performance bottleneck may shift from building Merkle trees to
        NTT, where it ought to be.
      </p>
      <p class="text-gray-300">
        The inclusion of lookup gates is not free. The lookup argument
        requires extra columns and constraints and the lookup table
        itself must be arithmetized as well. The key question raised
        by and studied in this article is therefore:
      </p>
      <p class="text-gray-300 italic">
        Does the performance improvement of a hash function with
        lookup gates compensate for its more complex arithmetization?
      </p>
      <p class="text-gray-300">
        Jumping ahead, the answer is a definite "yes". In the end,
        both factors affect the single metric of interest, which is
        the running time of the prover as it proves the correct
        execution of the verifier.
      </p>
      <p class="text-gray-300">
        To support this claim, this article proposes a hash function
        making use of lookup gates in &sect;&nbsp;2; discusses
        implementation aspects related to fast CPU performance in
        &sect;&nbsp;3; and presents arithmetization techniques of
        independent interest including a novel lookup argument in
        &sect;&nbsp;4.
      </p>
      <p class="text-gray-300">
        The quantum of qualification relativizing the above positive
        answer is the question of security. In order to make the
        comparison fair, both hash function candidates must offer
        comparable levels of security. The best we can do on this
        front is analyze the proposed hash function in the light of
        relevant attack strategies and argue that they all have an
        infeasible complexity. These attacks are discussed in
        &sect;&nbsp;5.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. SPECIFICATION                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Specification</h2>

      <!-- 2.1 High-Level Overview -->
      <h3 id="sec-2.1" class="text-lg font-semibold mt-6">
        2.1 High-Level Overview
      </h3>
      <p class="text-gray-300">
        Tip5 is a sponge construction [BDP+12] instantiated with a
        permutation
        <span class="math">f: \mathbb&#123;F&#125;_p^m \to \mathbb&#123;F&#125;_p^m</span>
        and a state of
        <span class="math">m = 16</span> field elements. In every
        iteration of the absorbing phase,
        <span class="math">r = 10</span> field elements are read from
        the input and replace the first
        <span class="math">r</span> elements of the state. In every
        iteration of the squeezing phase, the first
        <span class="math">r = 10</span> elements of the state are
        read and appended to the output. Between every absorbing or
        squeezing iteration, the function
        <span class="math">f</span> is applied to the state. This
        description defines a function whose output has infinite
        length; the Tip5 hash function truncates this output to
        <span class="math">d = 5</span> field elements.
      </p>
      <p class="text-gray-300 text-sm italic my-4">
        [Figure 1: Sponge construction with 3 absorbing iterations
        and 2 squeezing iterations. Following [5, &sect;4.3], this
        sponge construction absorbs by overwriting the rate part of
        the state, whereas absorbing is traditionally defined in terms
        of adding into it.]
      </p>
      <p class="text-gray-300">
        The permutation
        <span class="math">f: \mathbb&#123;F&#125;_p^m \to \mathbb&#123;F&#125;_p^m</span>
        consists of
        <span class="math">N = 5</span> rounds, which are each
        identical except for the independently uniformly pseudorandom
        round constants. Every round consists of 3 steps:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-3
        ml-4 my-4">
        <li>
          <strong>S-box layer.</strong> Every state element is mapped
          by an S-box. The first
          <span class="math">s = 4</span> elements are mapped by
          <span class="math">S: \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p</span>
          and the other elements are mapped by
          <span class="math">T: \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p</span>.
          Both types of S-boxes are permutations on
          <span class="math">\mathbb&#123;F&#125;_p</span>.
        </li>
        <li>
          <strong>Linear layer.</strong> The state vector is
          multiplied with a
          <span class="math">m \times m</span> MDS matrix.
        </li>
        <li>
          <strong>Round constants.</strong> A designated round
          constant, sampled independently for every round and state
          element, is added to every state element.
        </li>
      </ol>

      <!-- 2.2 S-Box Layer -->
      <h3 id="sec-2.2" class="text-lg font-semibold mt-6">
        2.2 S-Box Layer
      </h3>
      <p class="text-gray-300">
        There are two types of S-boxes,
        <span class="math">S</span> and
        <span class="math">T</span>. The latter is the regular
        forward <span class="math">\alpha</span>th power map already
        used in Rescue-Prime:
        <span class="math">T: x \mapsto x^\alpha</span>. For the
        field with
        <span class="math">2^&#123;64&#125; - 2^&#123;32&#125; + 1</span> elements,
        <span class="math">\alpha = 7</span> since any smaller
        positive exponent does not define a permutation.
      </p>
      <p class="text-gray-300 text-sm italic my-4">
        [Figure 2: The Tip5 permutation. The
        <span class="math">\oplus</span> indicates addition of
        constants, but the wires for the constants were omitted for
        space.]
      </p>
      <p class="text-gray-300">
        The former type of S-box,
        <span class="math">S</span>, is more involved and may be
        called the <em>split-and-lookup</em> map. It is defined as
        follows:
      </p>
      <div class="math-block">
        S: \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p, \quad x \mapsto R^&#123;-1&#125;
        \cdot \rho \circ L^8 \circ \sigma(R \cdot x)
      </div>
      <p class="text-gray-300">The components are:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-3
        ml-4 my-4">
        <li>
          <span class="math">R</span> is the field element congruent
          to <span class="math">2^&#123;64&#125;</span> modulo
          <span class="math">p</span>. Multiplication with
          <span class="math">R</span> maps
          <span class="math">x</span> from the canonical
          representation of field elements to Montgomery form. This
          map is applied in anticipation of efficient implementations,
          where field elements are represented in Montgomery form to
          begin with.
        </li>
        <li>
          <span class="math">\sigma: \mathbb&#123;F&#125;_p \to
          \mathbb&#123;F&#125;_p^8, \; x \mapsto (a,b,c,d,e,f,g,h)</span>
          where all outputs are at most 8 bits wide and
          <span class="math">x = a + 2^8 b + 2^&#123;16&#125; c + 2^&#123;24&#125; d +
          2^&#123;32&#125; e + 2^&#123;40&#125; f + 2^&#123;48&#125; g + 2^&#123;56&#125; h</span>. In
          essence, <span class="math">\sigma</span> decomposes a
          field element's canonical representation into bytes, and
          <span class="math">\sigma(R \cdot x)</span> decomposes the
          Montgomery representation of
          <span class="math">x</span> into bytes.
        </li>
        <li>
          <span class="math">L: \mathbb&#123;F&#125;_p \to
          \mathbb&#123;F&#125;_p</span> is defined only for field elements that
          are at most 8 bits wide. Identifying this subset of
          <span class="math">\mathbb&#123;F&#125;_p</span> with
          <span class="math">\mathbb&#123;F&#125;_&#123;2^8+1&#125;</span>, the lookup
          table <span class="math">L</span> computes
          <span class="math">L: \mathbb&#123;F&#125;_&#123;2^8+1&#125; \to
          \mathbb&#123;F&#125;_&#123;2^8+1&#125;, \; x \mapsto (x+1)^3 - 1</span>.
        </li>
        <li>
          <span class="math">\rho: \mathbb&#123;F&#125;_p^8 \to
          \mathbb&#123;F&#125;_p</span> computes the inverse of
          <span class="math">\sigma</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        The inverse of this S-box is
        <span class="math">x \mapsto R \cdot \rho \circ (L^&#123;-1&#125;)^8
        \circ \sigma(R^&#123;-1&#125; \cdot x)</span>.
      </p>
      <p class="text-gray-300">
        Note that <span class="math">L</span> has three fixed points:
        0, 255 and
        <span class="math">256 \equiv -1 \bmod 257</span>. Since 256
        is the only point not representable in 8 bits, it follows that
        <span class="math">L</span> is a permutation on
        <span class="math">\&#123;0, \ldots, 255\&#125;</span> as well as on
        <span class="math">\mathbb&#123;F&#125;_&#123;257&#125;</span>.
      </p>
      <p class="text-gray-300">
        The first two fixed points ensure that
        <span class="math">\rho \circ L^8 \circ \sigma</span>, seen
        as a map from and to 64-bit integers, sends
        <code>0xffffffff00000000</code>
        <span class="math">\equiv -1 \bmod p</span> to
        <code>0xffffffff00000000</code>; sends integers greater than
        <span class="math">p - 1</span> to integers greater than
        <span class="math">p - 1</span>; and sends integers less than
        <span class="math">p - 1</span> to integers less than
        <span class="math">p - 1</span>. It follows that
        <span class="math">S</span> is a permutation on
        <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>

      <!-- 2.3 Linear Layer -->
      <h3 id="sec-2.3" class="text-lg font-semibold mt-6">
        2.3 Linear Layer
      </h3>
      <p class="text-gray-300">
        In the linear step, the state vector
        <span class="math">\mathbf&#123;x&#125; \in \mathbb&#123;F&#125;_p^m</span> is
        sent to <span class="math">M\mathbf&#123;x&#125;</span> where
        <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;16 \times 16&#125;</span>
        is a circulant MDS matrix chosen to admit a fast
        matrix-vector product calculation (see &sect;&nbsp;3.2).
        <span class="math">M</span> is defined by the first column:
      </p>
      <div class="my-4 p-4 rounded bg-gray-800/50 overflow-x-auto">
        <code class="text-sm text-gray-300">
          [61402, 1108, 28750, 33823, 7454, 43244, 53865, 12034,
          56951, 27521, 41351, 40901, 12021, 59689, 26798, 17845]
        </code>
      </div>
      <p class="text-gray-300">
        These numbers were derived from the SHA-256 hash of the ASCII
        string "Tip5" by dividing the digest into 16-bit chunks.
      </p>

      <!-- 2.4 Round Constants -->
      <h3 id="sec-2.4" class="text-lg font-semibold mt-6">
        2.4 Round Constants
      </h3>
      <p class="text-gray-300">
        The constants are determined by concatenating the byte
        <span class="math">i</span> (for the
        <span class="math">i</span>th constant, starting from zero) to
        the ASCII string "Tip5", hashing the string of 5 bytes using
        Blake3, taking the first 16 bytes of the digest, interpreting
        them as an integer in least-significant-byte-first order,
        reducing the integer modulo
        <span class="math">p</span>, and multiplying the resulting
        field element by
        <span class="math">R^&#123;-1&#125;</span> which is the inverse of
        <span class="math">2^&#123;64&#125;</span> modulo
        <span class="math">p</span>. This process is repeated
        <span class="math">mN</span> times to get as many round
        constants. The
        <span class="math">(mi + j)</span>th constant is used for the
        <span class="math">j</span>th state element in the
        <span class="math">i</span>th round.
      </p>

      <!-- 2.5 Fixed-Length versus Variable-Length -->
      <h3 id="sec-2.5" class="text-lg font-semibold mt-6">
        2.5 Fixed-Length versus Variable-Length
      </h3>
      <p class="text-gray-300">
        The hash function comes in two modes of operation, depending
        on whether the input is fixed-length or variable-length.
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-3
        ml-4 my-4">
        <li>
          When the input is <strong>fixed length</strong> (and in this
          case the length is always exactly
          <span class="math">r = 10</span>), all capacity elements
          are initialized to 1. There is no need to pad the input.
          There is only one absorption.
        </li>
        <li>
          When the input is <strong>variable-length</strong>, it is
          padded by appending a 1 followed by the minimal number of
          0's necessary to make the padded input length a multiple of
          <span class="math">r</span>. The capacity is initialized to
          all zeros and the input is absorbed over multiple iterations.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 3. IMPLEMENTATION ASPECTS                                    -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Implementation Aspects</h2>

      <!-- 3.1 Montgomery Representation -->
      <h3 id="sec-3.1" class="text-lg font-semibold mt-6">
        3.1 Montgomery Representation
      </h3>
      <p class="text-gray-300">
        A field element
        <span class="math">a \in \mathbb&#123;F&#125;_p</span> is represented
        as the integer
        <span class="math">\bar&#123;a&#125; \in \&#123;0, \ldots, p-1\&#125;</span>
        congruent to
        <span class="math">a \cdot R</span> modulo
        <span class="math">p</span>, where
        <span class="math">R = 2^&#123;64&#125;</span>. The benefit of this
        representation is a faster multiplication algorithm: the
        product <span class="math">c = ab</span> is calculated by
        first calculating the integer product
        <span class="math">\bar&#123;a&#125; \cdot \bar&#123;b&#125;</span> and following
        this up with <em>Montgomery reduction</em>, which sends
        <span class="math">\bar&#123;a&#125; \cdot \bar&#123;b&#125;</span> to
        <span class="math">\bar&#123;c&#125;</span>. We refer to Pornin's
        explanation [Por22] for a concise but comprehensive overview of
        Montgomery representation of elements in this field.
      </p>
      <p class="text-gray-300">
        The split-and-lookup S-box anticipates the use of Montgomery
        representation. Specifically, the S-box
      </p>
      <div class="math-block">
        S: \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p, \quad x \mapsto R^&#123;-1&#125;
        \cdot \rho \circ L^8 \circ \sigma(R \cdot x)
      </div>
      <p class="text-gray-300">becomes</p>
      <div class="math-block">
        S': \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p, \quad x \mapsto \rho'
        \circ L^8 \circ \sigma'(x)
      </div>
      <p class="text-gray-300">
        where <span class="math">\sigma'</span> decomposes the integer
        <span class="math">\bar&#123;a&#125;</span> into raw bytes, and
        <span class="math">\rho'</span> recomposes the raw bytes
        accordingly.
      </p>

      <!-- 3.2 MDS Matrix Multiplication -->
      <h3 id="sec-3.2" class="text-lg font-semibold mt-6">
        3.2 MDS Matrix Multiplication
      </h3>
      <p class="text-gray-300">
        In the linear step, the state vector
        <span class="math">\mathbf&#123;x&#125;</span> is sent to
        <span class="math">M\mathbf&#123;x&#125;</span> where
        <span class="math">M</span> is the circulant MDS matrix. All
        the entries in this matrix are small positive integers. The
        purpose of this design choice is to delay modular reduction.
        Specifically, the matrix-vector multiplication is computed over
        the integers twice, once for the high 32 bits of the input
        vector, and once for the low 32 bits. Afterwards, the two
        output vectors are added over the integers (with the
        appropriate shift) before being reduced modulo
        <span class="math">p</span>.
      </p>
      <p class="text-gray-300">
        Another salient property of the MDS matrix is the fact that it
        is circulant. Using the well-known NTT-based multiplication
        trick, the matrix-vector product for a circulant matrix can be
        computed in only
        <span class="math">O(m \log m)</span> operations via
      </p>
      <div class="math-block">
        M\mathbf&#123;x&#125; = \text&#123;NTT&#125;^&#123;-1&#125;(\text&#123;NTT&#125;(M_&#123;[:,0]&#125;) \circ
        \text&#123;NTT&#125;(\mathbf&#123;x&#125;)),
      </div>
      <p class="text-gray-300">
        where <span class="math">\circ</span> denotes the Hadamard
        (element-wise) product.
      </p>
      <p class="text-gray-300">
        The reason why the NTT-based multiplication trick works is
        because there is an isomorphism between circulant matrices and
        elements of the quotient ring
        <span class="math">R_p =
        \mathbb&#123;F&#125;_p[X]/\langle X^m - 1 \rangle</span>. The elements
        of this ring are uniquely determined by their reduced
        representative modulo
        <span class="math">X^m - 1</span>, or by their list of
        reduced representatives modulo any list of polynomials whose
        product is <span class="math">X^m - 1</span>. The irreducible
        factors of <span class="math">X^m - 1</span> are
        <span class="math">X - \xi^i</span>, where
        <span class="math">\xi</span> is a primitive
        <span class="math">m</span>th root of unity; and by reducing
        a polynomial modulo these factors we get its evaluation in
        <span class="math">\xi^i</span>. The NTT is precisely the
        transformation that sends a polynomial to its list of
        evaluations in <span class="math">\xi^i</span>.
      </p>
      <p class="text-gray-300">
        However, while the field
        <span class="math">\mathbb&#123;F&#125;_p</span> does have an
        <span class="math">m</span>th root of unity, the ring of
        integers does not. To deal with this difficulty, we use an
        alternative factorization of
        <span class="math">X^m - 1</span>. In the first step we split
        the polynomial product modulo
        <span class="math">X^m - 1</span> into two polynomial
        products, modulo
        <span class="math">X^&#123;m/2&#125; - 1</span> and
        <span class="math">X^&#123;m/2&#125; + 1</span> respectively. The first
        product can be computed recursively. The second product is
        split again into polynomial products modulo
        <span class="math">X^&#123;m/4&#125; + \xi^4</span> and
        <span class="math">X^&#123;m/4&#125; - \xi^4</span> respectively, where
        <span class="math">\xi^4</span> is a square root of
        <span class="math">-1</span>. The coefficients are represented
        as complex numbers, <em>i.e.</em>, with a real part and an
        imaginary part. As a result of this representation, computing
        the product modulo
        <span class="math">X^&#123;m/4&#125; + \xi^4</span> gives the matching
        result modulo
        <span class="math">X^&#123;m/4&#125; - \xi^4</span> for free through
        complex conjugation. The polynomial product before reduction is
        computed with Karatsuba's method [KO62].
      </p>

      <!-- 3.3 CPU Performance -->
      <h3 id="sec-3.3" class="text-lg font-semibold mt-6">
        3.3 CPU Performance
      </h3>
      <p class="text-gray-300">
        These benchmarks were obtained on an Intel Core i7-10750H CPU
        @ 2.60GHz. On this machine, Tip5 is
        <span class="math">21.37\times</span> faster than
        Rescue-Prime Optimized and
        <span class="math">8.16\times</span> faster than Poseidon.
        The implementation is available at [Nep].
      </p>

      <!-- Table 2: CPU performance comparison -->
      <div id="table-2" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 2.</strong> CPU performance comparison.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Hash Function</th>
              <th class="text-left py-2">
                Time [<span class="math">\mu</span>s]
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Rescue-Prime</td>
              <td class="py-2">18.186</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Rescue-Prime Optimized</td>
              <td class="py-2">14.357</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Poseidon</td>
              <td class="py-2">6.940</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Tip5</td>
              <td class="py-2">0.851</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. ARITHMETIZATION                                           -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Arithmetization</h2>
      <p class="text-gray-300">
        Arithmetization refers to the task of finding representations
        of computations in terms of lists of finite field elements
        satisfying low-degree multivariate polynomial constraints, as
        well as to the concrete representation that this task results
        in. There are various representations, reflecting the various
        models of computation.
      </p>
      <p class="text-gray-300">
        This section describes standalone arithmetization techniques
        for the AET/AIR computational representation, which is what
        underlies the STARK proof system. When composed in the right
        way, these techniques result in an arithmetization for Tip5.
        For an in-depth exposition of the details of this
        representation and the pipeline for generating and verifying a
        STARK proof from it, we refer to the "Anatomy of a STARK" [Sze]
        and "BrainSTARK" [Szeb] tutorials. We use the terminology from
        these sources.
      </p>

      <!-- 4.1 Lookup Argument -->
      <h3 id="sec-4.1" class="text-lg font-semibold mt-6">
        4.1 Lookup Argument
      </h3>
      <p class="text-gray-300">
        In the next sections we present a novel lookup argument in the
        AIR/AET model. It is a special case of subset arguments
        because it establishes that the rows of one table called the
        client are a subset of the rows of another, called the server.
        More specifically, by selecting only those columns labeled
        "input" or "output" any subset argument including the one
        presented here can be used to establish that the input and
        output pairs appearing in the client satisfy the relation
        between inputs and outputs defined by the server. The outputs
        can be thought of as having been looked up in the server's
        lookup table.
      </p>

      <h4 class="text-base font-semibold mt-4 text-gray-200">
        Bezout Argument
      </h4>
      <p class="text-gray-300">
        Using random weights
        <span class="math">a, b</span> from the verifier, the input
        and output columns are compressed into one random linear
        combination. It then suffices to show that the set of random
        linear combinations used by the client is a subset of the
        random linear combinations appearing in the server.
      </p>
      <p class="text-gray-300">
        Let
        <span class="math">\&#123;\text&#123;combo&#125;_i\&#125;_i</span> denote the set
        of input-output pairs, each compressed into a random linear
        combination using
        <span class="math">a</span> and
        <span class="math">b</span>, that are looked up at least once.
        The client and server both define a product polynomial whose
        factors are those random linear combinations offsetting
        <span class="math">X</span>:
      </p>
      <div class="math-block">
        \text&#123;rpc&#125;(X) = \prod_i (X - \text&#123;combo&#125;_i)^&#123;m_i&#125;
      </div>
      <div class="math-block">
        \text&#123;rps&#125;(X) = \prod_i (X - \text&#123;combo&#125;_i)
      </div>
      <p class="text-gray-300">
        The difference between these two polynomials is the
        multiplicities
        <span class="math">m_i</span> of their roots, which is 1 for
        the server and possibly greater than 1 for the client. The
        letters "rp" suggest that the evaluation of these polynomials
        in <span class="math">\alpha</span> can be computed by running
        product columns, once
        <span class="math">\alpha</span> is known. But merely
        comparing the values
        <span class="math">\text&#123;rpc&#125;(\alpha)</span> and
        <span class="math">\text&#123;rps&#125;(\alpha)</span> does not suffice
        to establish the subset relation because the multiplicities of
        the roots are different.
      </p>
      <p class="text-gray-300">
        The following Bezout relation argument eliminates these
        multiplicities, enabling a test for subset relationship by
        probing a polynomial identity in the random point
        <span class="math">\alpha</span>.
      </p>
      <p class="text-gray-300">
        In addition to a running product, the client defines a formal
        derivative. Let
        <span class="math">\text&#123;fdc&#125;(X)</span> denote this
        polynomial:
      </p>
      <div class="math-block">
        \text&#123;fdc&#125;(X) = \sum_i m_i (X - \text&#123;combo&#125;_i)^&#123;m_i - 1&#125;
        \prod_&#123;j \neq i&#125; (X - \text&#123;combo&#125;_j)^&#123;m_j&#125; =
        \frac&#123;\mathrm&#123;d&#125;&#125;&#123;\mathrm&#123;d&#125;X&#125; \text&#123;rpc&#125;(X)
      </div>
      <p class="text-gray-300">
        Likewise, the server defines a formal derivative as well,
        except this one is weighted by multiplicity:
      </p>
      <div class="math-block">
        \text&#123;mwfds&#125;(X) = \sum_i m_i \prod_&#123;j \neq i&#125;
        (X - \text&#123;combo&#125;_j)
      </div>
      <p class="text-gray-300">
        On the side of the client, the running product and its formal
        derivative satisfy the following Bezout relation:
        <span class="math">\text&#123;rpc&#125;(X) \cdot x(X) + \text&#123;fdc&#125;(X)
        \cdot y(X) = g(X)</span>, where
        <span class="math">g(X)</span> is the greatest common divisor
        and <span class="math">x(X)</span> and
        <span class="math">y(X)</span> are Bezout coefficient
        polynomials. Then
        <span class="math">\text&#123;rpc&#125;(X)/g(X)</span> is the
        square-free polynomial with the same roots as
        <span class="math">\text&#123;rpc&#125;(X)</span>, and thus equal to
        <span class="math">\text&#123;rps&#125;(X)</span> of the server.
        Moreover, a similar relationship holds for the formal
        derivatives:
        <span class="math">\text&#123;fdc&#125;(X)/g(X) =
        \text&#123;mwfds&#125;(X)</span>. By eliminating
        <span class="math">g(X)</span> we get the identity of
        polynomials
        <span class="math">\text&#123;rpc&#125;(X) \cdot \text&#123;mwfds&#125;(X) =
        \text&#123;fdc&#125;(X) \cdot \text&#123;rps&#125;(X)</span>. The objective is to
        test this identity in the random point
        <span class="math">\alpha</span>.
      </p>
      <p class="text-gray-300">
        The cheating prover who uses an input-output pair in the client
        that is not present in the server must use a polynomial
        <span class="math">\text&#123;rpc&#125;(X)</span> with at least one root
        that <span class="math">\text&#123;rps&#125;(X)</span> does not share.
        As a result, the polynomial identity is not satisfied because
        this root occurs in the left hand side with multiplicity one
        greater than in the right hand side. By the Schwarz-Zippel
        lemma, the probability that the identity holds in the random
        point <span class="math">\alpha</span> is at most
        <span class="math">\frac&#123;1 + m/2&#125;&#123;|\mathbb&#123;F&#125;_p|&#125; \cdot
        T</span>, where
        <span class="math">T</span> is the height of the table.
      </p>

      <h4 class="text-base font-semibold mt-4 text-gray-200">
        Optimization with Logarithmic Derivatives
      </h4>
      <p class="text-gray-300">
        The above intuition gives rise to an AET and an AIR for
        checking it. Indeed, the values
        <span class="math">\text&#123;rpc&#125;(\alpha), \text&#123;fdc&#125;(\alpha),
        \text&#123;rps&#125;(\alpha)</span>, and
        <span class="math">\text&#123;mwfds&#125;(\alpha)</span> can all be
        computed via running accumulator columns. However, it turns out
        there is an optimization that reduces the number of columns at
        the expense of one batch-inversion for the prover. This
        optimization is inspired by Haboeck's lookup argument [Hab22] but
        ultimately that argument is tailored to Multilinear IOPs. The
        present optimization can be seen as lifting that technique to
        the AET/AIR setting, albeit derived differently.
      </p>
      <p class="text-gray-300">
        The logarithmic derivative of a polynomial
        <span class="math">f(X)</span> is defined as
        <span class="math">\frac&#123;f'(X)&#125;&#123;f(X)&#125;</span>. It is so named
        because the logarithmic derivative of the product of two
        polynomials is the sum of their logarithmic derivatives:
      </p>
      <div class="math-block">
        \frac&#123;1&#125;&#123;f(X)g(X)&#125; \cdot
        \frac&#123;\mathrm&#123;d&#125;(f(X)g(X))&#125;&#123;\mathrm&#123;d&#125;X&#125; =
        \frac&#123;f'(X)&#125;&#123;f(X)&#125; + \frac&#123;g'(X)&#125;&#123;g(X)&#125;
      </div>
      <p class="text-gray-300">
        Observe that the polynomial identity
      </p>
      <div class="math-block">
        \text&#123;rpc&#125;(X) \cdot \text&#123;mwfds&#125;(X) = \text&#123;fdc&#125;(X)
        \cdot \text&#123;rps&#125;(X)
      </div>
      <p class="text-gray-300">
        can be re-written in terms of logarithmic derivatives:
      </p>
      <div class="math-block">
        \frac&#123;\text&#123;fdc&#125;(X)&#125;&#123;\text&#123;rpc&#125;(X)&#125; =
        \frac&#123;\text&#123;mwfds&#125;(X)&#125;&#123;\text&#123;rps&#125;(X)&#125; = \sum_i
        \frac&#123;m_i&#125;&#123;X - \text&#123;combo&#125;_i&#125;
      </div>
      <p class="text-gray-300">
        On the side of the server, two columns are needed to probe
        this identity in the random point
        <span class="math">\alpha</span>.
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-3
        ml-4 my-4">
        <li>
          base column <strong>mul</strong> contains the multiplicity
          with which the given row is queried;
        </li>
        <li>
          the running product
          <span class="math">\text&#123;rps&#125;</span> and
          multiplicity-weighted formal derivative
          <span class="math">\text&#123;mwfds&#125;</span> are merged into the
          single extension column <strong>sum</strong>, which contains
          the running sum of
          <span class="math">\text&#123;mul&#125;/(\alpha -
          \text&#123;combo&#125;)</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        On the side of the client only one extension column is needed.
        Specifically, the running product
        <span class="math">\text&#123;rpc&#125;</span> and formal derivative
        <span class="math">\text&#123;fdc&#125;</span> are merged into a single
        column, the logarithmic derivative
        <strong>ldc</strong>. To update
        <strong>ldc</strong>, recall that the standard running product
        column <span class="math">\text&#123;rpc&#125;</span> is defined to
        accumulate one factor in every row. Moreover,
        <strong>ldc</strong> is defined to contain the logarithmic
        derivative of <span class="math">\text&#123;rpc&#125;</span> in every
        row, so we can use the eponymous property to populate it.
        Specifically, the would-have-been running product update rule
        <span class="math">\text&#123;rpc&#125;^* = \text&#123;rpc&#125; \cdot (\alpha -
        \text&#123;combo&#125;^*)</span> becomes
        <span class="math">\text&#123;ldc&#125;^* = \text&#123;ldc&#125; + 1/(\alpha -
        \text&#123;combo&#125;^*)</span>, where the asterisk
        <span class="math">*</span> indicates the respective element
        from the next row.
      </p>
      <p class="text-gray-300">
        The update rules
        <span class="math">\text&#123;sum&#125;^* = \text&#123;sum&#125; +
        \text&#123;mul&#125;^*/(\alpha - \text&#123;combo&#125;^*)</span> and
        <span class="math">\text&#123;ldc&#125;^* = \text&#123;ldc&#125; + 1/(\alpha -
        \text&#123;combo&#125;^*)</span> can be converted to AIR constraints of
        low degree by multiplying left and right hand sides by
        <span class="math">(\alpha - \text&#123;combo&#125;^*)</span>.
      </p>

      <!-- 4.2 Cascade Construction -->
      <h3 id="sec-4.2" class="text-lg font-semibold mt-6">
        4.2 Cascade Construction
      </h3>
      <p class="text-gray-300">
        The cascade construction arithmetizes a lookup gate composed
        of two lookups of half the width in terms of the
        arithmetizations of those components. It introduces a new
        table, called the cascade table. While the construction does
        complicate the arithmetization, the tradeoff can be worth it
        when the narrow lookup table gives rise to a more performant
        arithmetization than the wide one.
      </p>
      <p class="text-gray-300">
        The cascade table is the server authenticating
        <span class="math">2n</span>-bit wide input-output pairs to
        the external client. Internally, every input or output element
        is represented as two limbs of
        <span class="math">n</span> bits. To authenticate the
        <span class="math">n</span>-bit wide input-output pairs, the
        cascade table is the client of an
        <span class="math">n</span>-bit wide lookup argument with an
        external server.
      </p>
      <p class="text-gray-300">
        A cascade table consists of 5 base columns and 3 extension
        columns. The extension columns are defined relative to
        challenges
        <span class="math">a, b, c, d, \beta, \gamma</span>. The
        Latin letters denote weights used to compress columns, and the
        Greek letters denote indeterminates.
      </p>
      <p class="text-gray-300">The base columns are:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          <strong>lkinhi</strong> and <strong>lkinlo</strong>, the high
          and low limbs of the lookup input;
        </li>
        <li>
          <strong>lkouthi</strong> and <strong>lkoutlo</strong>, the
          high and low limbs of the lookup output;
        </li>
        <li>
          <strong>mul</strong>, the multiplicity with which the given
          row is being queried by the external client.
        </li>
      </ul>
      <p class="text-gray-300">The extension columns are:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          <strong>sum</strong>, which contains the running sum of
          inverses;
        </li>
        <li>
          <strong>ldhi</strong> and <strong>ldlo</strong>, the running
          logarithmic derivatives of the high and low input-output
          pairs.
        </li>
      </ul>
      <p class="text-gray-300">
        The AIR constraints can be inferred from &sect;&nbsp;4.1
        covering the lookup argument. Note that when the cascade table
        is wearing the server hat, the random linear combinations are
        given by
      </p>
      <div class="math-block">
        \text&#123;combo&#125; = 2^w \cdot a \cdot \text&#123;lkinhi&#125; + a \cdot
        \text&#123;lkinlo&#125; + 2^w \cdot b \cdot \text&#123;lkouthi&#125; + b \cdot
        \text&#123;lkoutlo&#125;,
      </div>
      <p class="text-gray-300">
        where <span class="math">w</span> is the width (in bits) of
        each limb. When the cascade table is wearing the client hat,
        the random linear combinations are given by
      </p>
      <div class="math-block">
        \text&#123;combo&#125; = c \cdot \text&#123;lkinhi&#125; + d \cdot \text&#123;lkouthi&#125;
      </div>
      <p class="text-gray-300">and</p>
      <div class="math-block">
        \text&#123;combo&#125; = c \cdot \text&#123;lkinlo&#125; + d \cdot \text&#123;lkoutlo&#125;.
      </div>
      <p class="text-gray-300">
        To see why the construction is sound, suppose a malicious
        prover attempts to prove that a pair
        <span class="math">(\text&#123;lkin&#125;^*, \text&#123;lkout&#125;^*)</span>
        belongs to the wide lookup relation when it does not. Then
        either the cascade table contains a corresponding row
        <span class="math">(\text&#123;lkinhi&#125;, \text&#123;lkinlo&#125;,
        \text&#123;lkouthi&#125;, \text&#123;lkoutlo&#125;, \text&#123;mul&#125;)</span>,
        <em>i.e.</em>, such that
        <span class="math">\text&#123;lkin&#125;^* = 2^w \cdot \text&#123;lkinhi&#125; +
        \text&#123;lkinlo&#125;</span> and
        <span class="math">\text&#123;lkout&#125;^* = 2^w \cdot \text&#123;lkouthi&#125;
        + \text&#123;lkoutlo&#125;</span> and
        <span class="math">\text&#123;mul&#125; \neq 0</span>; or the cascade
        table does not contain such a corresponding row. The latter
        case implies a failure of the client-cascade lookup argument.
        The probability of this event is bounded by the soundness
        error of the lookup argument. The former case implies one of
        two propositions:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          The server table contains a row
          <span class="math">(\text&#123;lkinhi&#125;, \text&#123;lkouthi&#125;,
          \text&#123;mul&#125;)</span> with
          <span class="math">\text&#123;mul&#125; \neq 0</span>.
        </li>
        <li>
          The server table contains a row
          <span class="math">(\text&#123;lkinlo&#125;, \text&#123;lkoutlo&#125;,
          \text&#123;mul&#125;)</span> with
          <span class="math">\text&#123;mul&#125; \neq 0</span>.
        </li>
      </ol>
      <p class="text-gray-300">
        The propositions cannot both be true because that would imply
        that
        <span class="math">(\text&#123;lkin&#125;^*, \text&#123;lkout&#125;^*)</span>
        does satisfy the wide lookup map relation. Therefore, one or
        both of these propositions must be false, implying at least one
        violation of the cascade-server subset argument. Once again,
        the probability of this event is bounded by the soundness error
        of the lookup argument.
      </p>
      <p class="text-gray-300">
        It is possible to arrange multiple cascade tables in sequence.
        This enables the decomposition of very large composite lookup
        maps into tiny components. The tradeoff is that the number of
        rows can increase by up to a factor two for every cascade
        level. However, as the tables get narrower they start becoming
        saturated faster. For instance, an 8-bit wide lookup table can
        only hold 256 rows.
      </p>

      <!-- 4.3 Narrow Lookup Tables -->
      <h3 id="sec-4.3" class="text-lg font-semibold mt-6">
        4.3 Narrow Lookup Tables
      </h3>
      <p class="text-gray-300">
        Reducing the arithmetization of a large composite lookup map to
        that of a small primitive lookup map only makes sense if the
        small lookup map admits an efficient arithmetization. Indeed,
        if the lookup map is not too wide &mdash; say, a handful of
        bits &mdash; then the following technique applies.
      </p>
      <p class="text-gray-300">
        Let <span class="math">n</span> be the number of bits in the
        input. The verifier locally evaluates a polynomial of degree
        <span class="math">2^n - 1</span> to obtain a single scalar
        value that authenticates the entire lookup table. This scalar
        is a parameter in the AIR that verifies the correct computation
        of this polynomial row-by-row.
      </p>
      <p class="text-gray-300">
        Specifically, let
        <span class="math">c, d, \delta</span> be challenges supplied
        by the verifier. The lookup table consists of three columns.
        Base columns <strong>lkin</strong> and <strong>lkout</strong>
        contain all possible input-output pairs. Extension column
        <strong>re</strong> contains a running evaluation.
      </p>
      <p class="text-gray-300">
        The AIR constraints constrain <strong>re</strong> to computing
        a running evaluation of the polynomial whose coefficients are
        given by
        <span class="math">c \cdot \text&#123;lkin&#125; + d \cdot
        \text&#123;lkout&#125;</span>. Specifically, let
        <span class="math">*</span> denote the corresponding element
        from the next row. Then there are three AIR constraints
        involving <strong>re</strong>:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          <strong>Initial constraint.</strong> The running evaluation
          column has accumulated the update determined by the first
          row:
          <span class="math">c \cdot \text&#123;lkin&#125; + d \cdot
          \text&#123;lkout&#125; - \text&#123;re&#125;</span>.
        </li>
        <li>
          <strong>Transition constraint.</strong> The running
          evaluation column accumulates the update determined by the
          next row:
          <span class="math">\delta \cdot \text&#123;re&#125; + c \cdot
          \text&#123;lkin&#125;^* + d \cdot \text&#123;lkout&#125;^* -
          \text&#123;re&#125;^*</span>.
        </li>
        <li>
          <strong>Terminal constraint.</strong> The value of the
          running evaluation column in the last row matches with the
          value of <span class="math">f(X)</span> at
          <span class="math">\delta</span>:
          <span class="math">f(\delta) - \text&#123;re&#125;</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        The polynomial <span class="math">f(X)</span> is evaluated by
        the verifier locally. The coefficient of
        <span class="math">X^&#123;(2^n - 1 - i)&#125;</span> in
        <span class="math">f(X)</span> is
        <span class="math">c \cdot \text&#123;lkin&#125;_i + d \cdot
        \text&#123;lkout&#125;_i</span>, where
        <span class="math">(\text&#123;lkin&#125;_i, \text&#123;lkout&#125;_i)</span> is
        the <span class="math">i</span>th input-output pair. Since the
        degree of <span class="math">f(X)</span> is
        <span class="math">2^n - 1</span>, this evaluation is fast if
        <span class="math">n</span> is small.
      </p>
      <p class="text-gray-300">
        This lookup table crucially relies on the fact that all rows
        are present, even those rows that are not being looked up. In
        contrast, rows in cascade tables only need to be present if
        they are being looked up at some point.
      </p>

      <!-- 4.4 Periodic Constraints -->
      <h3 id="sec-4.4" class="text-lg font-semibold mt-6">
        4.4 Periodic Constraints
      </h3>
      <p class="text-gray-300">
        A periodic constraint is one that applies in every row
        congruent to <span class="math">x</span> modulo
        <span class="math">y</span>. Its implementation requires a
        periodic zerofier. We describe here a technique for building
        this primitive.
      </p>
      <p class="text-gray-300">
        Let
        <span class="math">H = \langle \omega \rangle</span> be the
        subgroup and
        <span class="math">(\omega^i)_i</span> the sequence of order
        and length <span class="math">N</span> over which the trace is
        interpolated, and suppose
        <span class="math">y \mid N</span>. The zerofier for a
        subgroup of order <span class="math">k</span> is
        <span class="math">X^k - 1</span>, since it evaluates to zero
        in every element of the subgroup and is the smallest-degree
        monic polynomial that does so. Therefore,
        <span class="math">Z(X) = X^&#123;N/y&#125; - 1</span> is a zerofier
        for the order <span class="math">N/y</span> subgroup of
        <span class="math">H</span>. It evaluates to zero on every
        point <span class="math">\omega^i</span> of the sequence where
        <span class="math">i</span> is congruent to 0 modulo
        <span class="math">y</span>. The coset zerofier
        <span class="math">(X \cdot \omega^&#123;-x&#125;)^&#123;N/y&#125; - 1</span>
        evaluates to 0 in points
        <span class="math">\omega^i</span> of the sequence where
        <span class="math">i \equiv x \pmod&#123;y&#125;</span>. The product of
        such coset zerofiers is a zerofier for an arbitrary set of
        congruence classes modulo <span class="math">y</span>.
      </p>
      <p class="text-gray-300">
        A periodic constraint is simply a constraint whose
        corresponding zerofier is not zero on the whole interpolation
        group <span class="math">H</span> but on a subgroup of it or
        coset thereof. The constraint is active in those points where
        the zerofier evaluates to zero, and inactive elsewhere.
      </p>

      <!-- 4.5 Periodic Interpolants -->
      <h3 id="sec-4.5" class="text-lg font-semibold mt-6">
        4.5 Periodic Interpolants
      </h3>
      <p class="text-gray-300">
        A periodic interpolant is a polynomial that repeats a sequence
        of values
        <span class="math">(v_0, \ldots, v_&#123;k-1&#125;)</span> of length
        <span class="math">k</span> when evaluated on the powers of a
        generator <span class="math">\omega</span>. An AIR constraint
        that integrates such an interpolant is individualized to the
        row, or more specifically, to the row's index's congruence
        class modulo <span class="math">k</span>. It can be used to
        prove that the correct round constants were added into the
        state in each row. To the best of our knowledge this technique
        was first described in Buterin's STARK tutorial [But18].
      </p>
      <p class="text-gray-300">
        Let <span class="math">N</span> be the padded trace length,
        suppose <span class="math">k \mid N</span>, and let
        <span class="math">\omega</span> generate the subgroup over
        which the trace is interpolated. Then the polynomial
        <span class="math">g(X) = X^&#123;N/k&#125;</span> sends
        <span class="math">\omega^i</span> to
        <span class="math">\zeta^i</span> where
        <span class="math">\zeta</span> is a
        <span class="math">k</span>th root of unity. Let
        <span class="math">f(X)</span> be the interpolant through
        <span class="math">(v_0, \ldots, v_&#123;k-1&#125;)</span> on the
        powers of <span class="math">\zeta</span>. Then
        <span class="math">f \circ g</span> is the periodic
        interpolant through
        <span class="math">(v_0, \ldots, v_&#123;k-1&#125;)</span> on the
        powers of <span class="math">\omega</span>.
      </p>

      <!-- 4.6 Correct Decomposition of Elements Modulo p -->
      <h3 id="sec-4.6" class="text-lg font-semibold mt-6">
        4.6 Correct Decomposition of Elements Modulo p
      </h3>
      <p class="text-gray-300">
        The lookup argument can establish that
        <span class="math">(a, b, c, d)</span> all have at most 16
        bits. However, it does not suffice to establish that
        <span class="math">a + 2^&#123;16&#125; \cdot b + 2^&#123;32&#125; \cdot c +
        2^&#123;48&#125; \cdot d &lt; p</span>. To prove this, an additional
        constraint is needed, namely
        <span class="math">(1 - (c + 2^&#123;16&#125; \cdot d - 2^&#123;32&#125; + 1)
        \cdot e) \cdot (a + 2^&#123;16&#125; \cdot b) = 0</span>. In this
        expression, <span class="math">e</span> is the inverse-or-zero
        of
        <span class="math">(c + 2^&#123;16&#125; \cdot d - 2^&#123;32&#125; + 1)</span>,
        which is to say, either
        <span class="math">e = (c + 2^&#123;16&#125; \cdot d - 2^&#123;32&#125; + 1) =
        0</span> or
        <span class="math">e \cdot (c + 2^&#123;16&#125; \cdot d - 2^&#123;32&#125; + 1)
        = 1</span>. To see why the constraint works, observe that for
        valid field elements,
        <span class="math">c + 2^&#123;16&#125; \cdot d = 2^&#123;32&#125; - 1
        \Rightarrow a + 2^&#123;16&#125; \cdot b = 0</span>. Indeed, the left
        factor evaluates to 1 only when
        <span class="math">c + 2^&#123;16&#125; \cdot d = 2^&#123;32&#125; - 1</span>,
        and in this case the right factor must evaluate to zero.
      </p>

      <!-- 4.7 Arithmetization of Tip5 -->
      <h3 id="sec-4.7" class="text-lg font-semibold mt-6">
        4.7 Arithmetization of Tip5
      </h3>
      <p class="text-gray-300">
        We present here only a high-level overview of the
        arithmetization of Tip5. In particular, we omit discussion of
        constraints in favor of the columns of the various tables and
        their effect on prover complexity. The effect on prover
        complexity due to constraints scales linearly with the number
        of columns and is concretely negligible. Moreover, the
        constraints can be inferred from the above descriptions. For a
        complete specification, we refer to the document "Triton
        Improvement Proposal 0005" [SLS23].
      </p>
      <p class="text-gray-300">
        There are three tables: the <strong>Hash Table</strong> which
        evaluates the Tip5 permutation every 8 rows, the
        <strong>Cascade Table</strong> which translates 16-bit wide
        lookups into 8-bit wide lookups, and the
        <strong>Lookup Table</strong> which contains all possible 8-bit
        lookup pairs. There is a lookup argument between the Hash Table
        and the Cascade Table, and another between the Cascade Table
        and the Lookup Table. The Lookup Table uses the narrow lookup
        arithmetization technique described above. All tables have one
        column indicating whether rows are padding rows.
      </p>
      <p class="text-gray-300">
        The <strong>Hash Table</strong> has 49 base columns and 16
        extension columns, subdivided as follows:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          one padding indicator <strong>pad</strong>;
        </li>
        <li>
          12 regular sponge state elements
          <strong>st[BBH+19]</strong> through <strong>st[TVM]</strong>;
        </li>
        <li>
          the remaining 4 sponge state elements are represented as
          16-bit wide chunks for easy lookup and in input-output pairs:
          <strong>lkin[0]</strong> through <strong>lkin[TVM]</strong>
          and <strong>lkout[0]</strong> through
          <strong>lkout[TVM]</strong>;
        </li>
        <li>
          one extension column for every input-output pair that is to
          be looked up: <strong>ldc[0]</strong> through
          <strong>ldc[TVM]</strong>;
        </li>
        <li>
          4 inverse-or-zero columns <strong>ioz[0]</strong> through
          <strong>ioz[BBL+22]</strong> to establish that the four 16-bit
          limbs that are being looked up represent a correct
          decomposition of some field element modulo
          <span class="math">p</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        The round count <span class="math">N = 5</span> requires
        periodic zerofiers and periodic interpolants. Certain
        consistency or transition constraints are activated only on
        rows congruent to <span class="math">j</span> modulo 8, for
        various <span class="math">j</span>.
      </p>
      <p class="text-gray-300">
        The <strong>Cascade Table</strong> has exactly those columns
        described in &sect;&nbsp;4.2 in addition to one padding
        indicator <strong>pad</strong>. The total number of columns is
        therefore 6 base columns and 3 extension columns.
      </p>
      <p class="text-gray-300">
        The <strong>Lookup Table</strong> has 4 base columns and 2
        extension columns:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          <strong>pad</strong> is the padding indicator;
        </li>
        <li>
          <strong>lkin</strong> and <strong>lkout</strong> contain the
          input and the output of the input-output pairs, respectively;
        </li>
        <li>
          <strong>mul</strong> contains the multiplicity with which
          they are queried;
        </li>
        <li>
          <strong>sum</strong> contains the running sum of inverses for
          the lookup argument;
        </li>
        <li>
          <strong>re</strong> contains the running evaluation to
          establish the correct list of input-output pairs.
        </li>
      </ul>
      <p class="text-gray-300">
        In total, the entire arithmetization of the Tip5 hash function
        requires 59 base columns and 21 extension columns. This number
        omits the columns needed for cross-table relations between the
        Hash Table and other tables, but these columns are also
        necessary if a different hash function not requiring lookup
        arguments is used instead, such as Rescue-Prime.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. SECURITY ANALYSIS                                         -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Security Analysis</h2>

      <!-- 5.1 Statistical Attacks -->
      <h3 id="sec-5.1" class="text-lg font-semibold mt-6">
        5.1 Statistical Attacks
      </h3>
      <p class="text-gray-300">
        Statistical attacks exploit the far-from-random likelihood of
        propagation of specially crafted patterns of values through
        various components of the cipher. In linear cryptanalysis [MY92]
        the pattern in question is an affine relation between the wires
        connecting a subcircuit to the rest. In differential
        cryptanalysis [BS90] the pattern in question is a known difference
        in the values taken by a wire across two invocations of the
        cipher.
      </p>
      <p class="text-gray-300">
        While the split-and-lookup S-boxes contribute somewhat to
        resistance against linear and differential cryptanalysis, the
        hash function's resistance against these lines of attack is
        most easily argued from the
        <span class="math">\alpha</span>th power maps alone.
        Specifically, these S-boxes have strong linear and differential
        properties and their combination with the MDS matrix enables a
        straightforward derivation of bounds on the probability of
        propagation of linear and differential patterns following the
        wide trail argument [DR20].
      </p>

      <!-- 5.2 Linear Cryptanalysis -->
      <h3 id="sec-5.2" class="text-lg font-semibold mt-6">
        5.2 Linear Cryptanalysis
      </h3>
      <p class="text-gray-300">
        The maximum expected probability of a non-trivial linear
        pattern
        <span class="math">(a, b, c)</span> being satisfied across an
        <span class="math">\alpha</span>th power S-box is
      </p>
      <div class="math-block">
        \max_&#123;a,b,c&#125; \Pr\left[a \cdot x + b \cdot x^\alpha + c =
        0\right] = \frac&#123;\alpha&#125;&#123;p&#125;.
      </div>
      <p class="text-gray-300">
        The MDS matrix guarantees that in every consecutive pair of
        rounds, at least
        <span class="math">m + 1</span> S-boxes are linearly active.
        But in every consecutive pair of rounds, there are only
        <span class="math">2s</span> split-and-lookup maps, so at
        least
        <span class="math">m + 1 - 2s</span>
        <span class="math">\alpha</span>th power S-boxes must be
        linearly active. The probability that a linear pattern is
        satisfied across two rounds is therefore at most
        <span class="math">\left(\frac&#123;\alpha&#125;&#123;p&#125;\right)^&#123;m+1-2s&#125;
        \approx 2^&#123;-551&#125;</span>.
      </p>

      <!-- 5.3 Differential Cryptanalysis -->
      <h3 id="sec-5.3" class="text-lg font-semibold mt-6">
        5.3 Differential Cryptanalysis
      </h3>
      <p class="text-gray-300">
        The maximum expected probability that a non-trivial
        differential pattern
        <span class="math">\Delta x \mapsto \Delta y</span> holds
        across an <span class="math">\alpha</span>th power S-box is
      </p>
      <div class="math-block">
        \max_&#123;\Delta x, \Delta y&#125; \Pr\left[(x + \Delta x)^\alpha -
        x^\alpha = \Delta y\right] = \frac&#123;\alpha - 1&#125;&#123;p&#125;.
      </div>
      <p class="text-gray-300">
        Once again, the MDS matrix guarantees that in every consecutive
        pair of rounds, at least
        <span class="math">m + 1 - 2s</span>
        <span class="math">\alpha</span>th power S-boxes are
        differentially active. The probability of a differential
        pattern being satisfied across two rounds is therefore
        <span class="math">\left(\frac&#123;\alpha - 1&#125;&#123;p&#125;\right)^&#123;m+1-2s&#125;
        \approx 2^&#123;-552&#125;</span>.
      </p>
      <p class="text-gray-300">
        Note that this small probability also rules out a boomerang
        attack [28, 16], which relies on the presence of two
        complementary differential patterns, jointly spanning the whole
        cipher, and at least one of which must span at least two
        rounds.
      </p>

      <!-- 5.4 Algebraic Attacks -->
      <h3 id="sec-5.4" class="text-lg font-semibold mt-6">
        5.4 Algebraic Attacks
      </h3>
      <p class="text-gray-300">
        Algebraic attacks leverage polynomial arithmetic to attack
        primitives. These are particularly relevant for
        arithmetization-oriented ciphers because they are designed to
        admit a succinct description in terms of polynomials.
      </p>
      <p class="text-gray-300">
        The CICO problem [5, &sect;8.2.4] provides an algebraic
        description of preimage search on sponge-based hash functions.
        In the context of Tip5, the initial S-box can be ignored. As
        the remaining components of the first round are linear, the
        net effect is that the attacker gets one round for free.
      </p>

      <!-- 5.5 Univariate -->
      <h3 id="sec-5.5" class="text-lg font-semibold mt-6">
        5.5 Univariate
      </h3>
      <p class="text-gray-300">
        Every function to and from a finite field can be represented
        by a polynomial. When the polynomial corresponding to a block
        cipher or hash function has a sufficiently low degree,
        algorithms for univariate polynomial arithmetic such as
        interpolation or computing GCDs may suffice to break the
        primitive. In the case of hash functions, polynomial
        factorization to find the roots gives rise to a preimage
        attack [RAS20].
      </p>
      <p class="text-gray-300">
        This root-finding attack is infeasible when applied to Tip5
        for two reasons. First, the degree of every output coordinate
        in terms of any indeterminate input is on the order of
        <span class="math">p \approx 2^&#123;64&#125;</span> due to the
        inclusion of the split-and-lookup gates, which do not have a
        low-degree polynomial representation. Second, the output of
        the hash function consists of 5 field elements, and so the
        natural field for univariate attack strategies is not
        <span class="math">\mathbb&#123;F&#125;_p</span> but
        <span class="math">\mathbb&#123;F&#125;_&#123;p^5&#125;</span>. But since the MDS
        matrix is
        <span class="math">\mathbb&#123;F&#125;_p</span>-linear and not
        <span class="math">\mathbb&#123;F&#125;_&#123;p^5&#125;</span>-linear, the
        resulting polynomial's degree is on the order of
        <span class="math">p^5 \approx 2^&#123;320&#125;</span>.
      </p>

      <!-- 5.6 Straightforward Grobner Basis -->
      <h3 id="sec-5.6" class="text-lg font-semibold mt-6">
        5.6 Straightforward Grobner Basis
      </h3>
      <p class="text-gray-300">
        There are
        <span class="math">m(N+1)</span> wires in total, but after
        dropping the initial S-boxes of the first round,
        <span class="math">N</span> variables appear in only
        <span class="math">N</span> equations and linearly so, and so
        they can be eliminated. Moreover
        <span class="math">d</span> variables are given by the digest,
        so there are
        <span class="math">mN - d</span> variables in total. There
        are as many equations. Their degrees are:
      </p>
      <ol class="list-decimal list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          <span class="math">p - 1</span> (or close to
          <span class="math">p - 1</span>) if it describes a
          split-and-lookup map;
        </li>
        <li>
          <span class="math">\alpha</span> if it describes a forward
          <span class="math">\alpha</span>th power map.
        </li>
      </ol>
      <p class="text-gray-300">
        The Macaulay bound exceeds
        <span class="math">p</span>. Therefore it pays to add the
        field equation
        <span class="math">x^p - x</span> for every variable
        <span class="math">x</span>. This addition has the effect of
        restricting the degree to
        <span class="math">p - 1</span> in every variable.
      </p>
      <p class="text-gray-300">
        The Macaulay matrix at this degree has
        <span class="math">\binom&#123;p-1+mN-d&#125;&#123;mN-d&#125;</span> columns and
        as many rows. Assuming that the matrix is dense, finding a
        kernel vector using sparse linear algebra methods takes this
        number <em>squared</em> operations. For one round and setting
        the other parameters as above, this square is approximately
        equal to <span class="math">2^&#123;1236&#125;</span>.
      </p>

      <!-- 5.7 Split S-box -->
      <h3 id="sec-5.7" class="text-lg font-semibold mt-6">
        5.7 Split S-box
      </h3>
      <p class="text-gray-300">
        The above analysis assigns two variables to every
        split-and-lookup gate: one for the input, and one for the
        output. A natural alternative is to encode the splitting into
        bytes and their recombination into field elements as polynomial
        equations, giving rise to eight (one for each
        <span class="math">L</span>-map) variables for each
        split-and-lookup gate. The polynomial equations for splitting
        field elements and recombining bytes mirror their AIR
        counterparts. However, the lookup arguments do not have
        analogues in polynomial equations. Instead, every
        <span class="math">L</span>-map generates a polynomial
        equation of degree 256.
      </p>
      <p class="text-gray-300">
        With this representation of the split-and-lookup S-boxes there
        are
        <span class="math">mN - d + 7Ns</span> variables, not
        counting those that were introduced to simulate inequalities.
        Conversely, there are as many equations, not counting the
        inequalities. Of these equations,
        <span class="math">8Ns</span> have degree 256.
      </p>
      <p class="text-gray-300">
        In order to derive an estimate of the complexity of solving
        this system of polynomial equations, we simplify the analysis
        with unverified assumptions. First, we assume (optimistically
        from the point of view of the attacker) that the polynomial
        system's concrete degree of regularity is 256, matching with
        the highest degree of the starting polynomials. Second, we
        assume (pessimistically from the point of view of the attacker)
        that the Macaulay matrix at this degree is dense.
      </p>
      <p class="text-gray-300">
        The Macaulay matrix at degree 256 has
        <span class="math">\binom&#123;256 + mN - d + 7Ns&#125;&#123;mN - d +
        7Ns&#125;</span> columns. Finding a kernel vector using sparse
        linear algebra methods takes this number <em>squared</em>
        operations, or roughly
        <span class="math">2^&#123;324&#125;</span> field operations to attack
        one round.
      </p>

      <!-- 5.8 Linear Approximation -->
      <h3 id="sec-5.8" class="text-lg font-semibold mt-6">
        5.8 Linear Approximation
      </h3>
      <p class="text-gray-300">
        An alternative to representing the split-and-lookup gates
        exactly is to replace them with their best linear
        approximations in the polynomial model of the primitive. The
        resulting solution represents a successful attack (<em>i.e.</em>,
        a second preimage) if it happens to coincide with the variety
        of the <em>exact</em> system of polynomials, <em>i.e.</em>,
        the one without approximations. By modeling the solution found
        via polynomial system solving as a random element from the
        approximate variety, it is possible to estimate the probability
        that it lives also in the exact variety. Specifically: we count
        the number of approximated maps and the number of points they
        agree with their targets in.
      </p>
      <p class="text-gray-300">
        One linear approximation to the split-and-lookup map agrees
        in 240 points, corresponding to the 2 fixed points of
        <span class="math">L</span>, repeated 8 times, except for 16
        values that cannot be reached because they correspond to 64-bit
        integers greater than <span class="math">p</span>. Inside 1
        round there are <span class="math">s</span> split-and-lookup
        maps and the probability that they all send one of these
        agreeable points to their correct destination is
        <span class="math">\left(\frac&#123;240&#125;&#123;p&#125;\right)^s</span>. For
        the given parameters this probability is less than
        <span class="math">2^&#123;-224&#125;</span> in one round. In other
        words, if we were to attack a single round with this technique,
        the produced solution would be correct (<em>i.e.</em>, a valid
        (second) preimage) with this probability.
      </p>
      <p class="text-gray-300">
        Barring cancellations of approximation errors, and assuming
        that the state vectors are independent and uniform before they
        enter into a round, the probability of correct approximation
        drops exponentially in the number of rounds, by about
        <span class="math">\left(\frac&#123;240&#125;&#123;p&#125;\right)^s \approx
        2^&#123;-224&#125;</span> per round.
      </p>

      <!-- 5.9 Fixing -->
      <h3 id="sec-5.9" class="text-lg font-semibold mt-6">
        5.9 Fixing
      </h3>
      <p class="text-gray-300">
        Another technique to leverage Grobner basis techniques consists
        of fixing the values on the wires into and out of the
        split-and-lookup S-boxes at random. The standard polynomial
        model of the cipher, <em>i.e.</em>, without fixing wires,
        consists of a polynomial system with high degree polynomials
        but
        <span class="math">r - d = 5</span> degrees of freedom.
        Fixing the wires reduces the polynomials' degrees but at the
        expense of reducing the number of degrees of freedom by
        <span class="math">s</span> degrees for each round covered by
        the attack. Attacking a single round (in addition to the
        ignored initial S-box layer) is feasible as the system of
        equations retains 1 degree of freedom. But for the whole cipher
        (still ignoring the initial S-box layer) the system of
        equations has
        <span class="math">r - d - (N - 1)s = -11</span> degrees of
        "freedom". A random system of equations with this degree of
        over-determinedness can be expected to have a solution with
        probability on the order of
        <span class="math">p^&#123;-11&#125; \approx 2^&#123;-704&#125;</span>.
      </p>

      <!-- 5.10 Skip Two Rounds -->
      <h3 id="sec-5.10" class="text-lg font-semibold mt-6">
        5.10 Skip Two Rounds
      </h3>
      <p class="text-gray-300">
        Bariant et al. [BBL+22] introduce a clever technique enabling the
        algebraic attacker to bypass one or two rounds at the start of
        the cipher. It crucially relies on the fact that the nonlinear
        components in the skipped rounds can be represented as
        monomials. It does not apply to Tip5 because the
        split-and-lookup S-boxes are not monomials. To see this,
        observe that counterexamples
        <span class="math">(a, b)</span> exist such that
        <span class="math">S(a)S(b) \neq S(ab)</span>, for instance
        <span class="math">a = b = 16</span>.
      </p>

      <!-- 5.11 Cryptanalysis Summary -->
      <h3 id="sec-5.11" class="text-lg font-semibold mt-6">
        5.11 Cryptanalysis Summary
      </h3>
      <p class="text-gray-300">
        The table below summarizes the minimum number of rounds after
        which the cipher is secure against various attacks. We consider
        only attacks with reasonable success probability
        (<em>i.e.</em>, approximately one) and feasible complexity
        (<em>i.e.</em>, less than
        <span class="math">2^&#123;192&#125;</span>, corresponding to a
        classical brute force collision search with optimistic memory).
      </p>

      <!-- Table 4: Summary of Necessary Round Count by Attack -->
      <div id="table-4" class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 4.</strong> Summary of Necessary Round Count
          by Attack.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Attack</th>
              <th class="text-left py-2"># Rounds</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr>
              <td class="py-1 pr-4 text-gray-400 font-semibold"
                colspan="2">Statistical</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Linear cryptanalysis (&sect;&nbsp;5.2)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Differential cryptanalysis (&sect;&nbsp;5.3)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Boomerang (&sect;&nbsp;5.3)
              </td>
              <td class="py-2">3</td>
            </tr>
            <tr>
              <td class="py-1 pr-4 text-gray-400 font-semibold"
                colspan="2">Algebraic</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Univariate (&sect;&nbsp;5.5)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Straightforward Grobner basis (&sect;&nbsp;5.6)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Split S-box (&sect;&nbsp;5.7)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Linear approximation (&sect;&nbsp;5.8)
              </td>
              <td class="py-2">2</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4 pl-4">
                Fixing wire values (&sect;&nbsp;5.9)
              </td>
              <td class="py-2">3</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p class="text-gray-300">
        While the attack that fixes wire values performs the best on
        paper, the attack with the split representation of the S-box
        ranks second. Moreover, the latter's complexity analysis relies
        on the unverified pessimistic (from the attacker's point of
        view) assumption on the density of the Macaulay matrix. With
        these observations in mind, the round count
        <span class="math">N = 5</span> was set to provide a roughly
        50% security margin.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONCLUSION                                                -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Conclusion</h2>
      <p class="text-gray-300">
        We set out to investigate whether switching from Rescue-Prime
        to Tip5 would yield a net performance improvement. We close
        with an answer to this question.
      </p>
      <p class="text-gray-300">
        For programs of reasonable size we find that 80% of proof
        generation time is spent hashing. Most of the remaining time
        is spent computing NTTs. Of the hashing steps, 90% of the time
        is spent hashing single rows of the low-degree extended trace
        table into leafs; the rest is spent building Merkle trees out
        of these leafs.
      </p>
      <p class="text-gray-300">
        The arithmetization does not change the number of rows, so the
        <span class="math">21.37\times</span> speedup of Table 2
        applies directly to the Merkle tree steps. The other two steps,
        hashing rows and computing NTTs, depend on the new number of
        columns.
      </p>
      <p class="text-gray-300">
        For Rescue-Prime and Rescue-Prime Optimized there are 16
        columns for storing the sponge state. While there are more
        round constants per round in Rescue-Prime and Rescue-Prime
        Optimized than in Tip5, in the particular case of Rescue-Prime
        Optimized these round constants do not increase the number of
        columns because their correct addition can be enforced via
        periodic interpolants. So the total number of columns for
        Rescue-Prime Optimized is 16. This number compares to Tip5's
        59 base columns and 21 extension columns. In the context of
        Triton VM [TVM], the extension columns take values from
        <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span>, so this total is
        equivalent to
        <span class="math">59 + 3 \cdot 21 = 122</span> base columns.
      </p>
      <p class="text-gray-300">
        The VM has 168 base-column equivalents not related to hashing.
        So swapping out Rescue-Prime for Tip5 makes the column count
        go from
        <span class="math">168 + 16 = 184</span> to
        <span class="math">168 + 122 = 290</span>. In other words,
        there are
        <span class="math">1.58\times</span> more columns.
      </p>
      <p class="text-gray-300">
        In terms of the NTT step: there are
        <span class="math">1.58\times</span> more NTTs to compute, but
        they all have the same length. So this step will take
        <span class="math">1.58\times</span> as much time.
      </p>
      <p class="text-gray-300">
        In terms of hashing the rows, the rows are
        <span class="math">1.58\times</span> longer, but the hash
        function is 21.37 times faster. So this task will take
        <span class="math">1.58/21.37 = 0.074\times</span> as much
        time.
      </p>
      <p class="text-gray-300">
        Putting the three steps together we find a new running time of
        <span class="math">0.2 \cdot 1.58 + 0.8 \cdot (0.9 \cdot
        0.074 + 0.1/21.37) = 0.373</span> times the old running time.
        Equivalently, switching to Tip5 yields a
        <span class="math">2.68\times</span> speedup.
      </p>
      <p class="text-gray-300">
        While this comparison already favors Tip5, it relies on
        several assumptions that are biased in favor of Rescue-Prime.
        Specifically:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-2
        ml-4 my-4">
        <li>
          Of the time not spent hashing, only about 18% is spent on
          NTTs, not 20%, and only some of the difference scales with
          the number of columns.
        </li>
        <li>
          Due to compiler optimizations, running an NTT on a vector of
          <span class="math">\mathbb&#123;F&#125;_&#123;p^3&#125;</span> elements is
          slightly more than
          <span class="math">2\times</span> slower than an NTT on a
          vector of
          <span class="math">\mathbb&#123;F&#125;_p</span> elements, rather than
          <span class="math">3\times</span>.
        </li>
        <li>
          The degree of the AIR is 7 in both cases. However, there is
          a natural tradeoff to reduce the prover time by shrinking the
          AIR degree at the expense of extra columns. Rescue-Prime has
          16 columns that would need to be expanded into multiple
          columns each in order to reduce the AIR degree, whereas Tip5
          only has 12 such columns.
        </li>
        <li>
          Rescue-Prime (not Optimized) has 8 rounds; since the first
          and last states must be represented, this means that the
          trace for one invocation of Rescue-Prime does not fit in 8
          rows. Using 9 rows requires introducing an extra column (not
          to mention high-degree AIR constraints) for keeping track of
          the round number. The alternative is to use periodic
          constraints or periodic interpolants, but this bumps the
          number of rows per hash invocation to the next power of 2,
          which is 16 in this case.
        </li>
      </ul>
      <p class="text-gray-300">
        <strong>Acknowledgements.</strong> Some of the ideas that this
        article expands on were first raised in the course of the
        Rescue-Prime Optimization project [AKM+22]. We also thank Robin
        Salen for feedback and corrections.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li>
          <span class="text-gray-500">[AAB+20]</span>
          Aly, Ashur, Ben-Sasson, Dhooghe, Szepieniec.
          <em>Design of symmetric-key primitives for advanced
          cryptographic protocols</em>. IACR Trans. Symmetric
          Cryptol. 2020(3), 1&ndash;45 (2020).
        </li>
        <li>
          <span class="text-gray-500">[AKM+22]</span>
          Ashur, Kindi, Meier, Szepieniec, Threadbare.
          <em>Rescue-prime optimized</em>.
          <a
            href="https://eprint.iacr.org/2022/1577"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2022/1577</a>.
          <a href="/papers/rescue-prime-optimized-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[BBL+22]</span>
          Bariant, Bouvier, Leurent, Perrin.
          <em>Algebraic attacks against some
          arithmetization-oriented primitives</em>. IACR Trans.
          Symmetric Cryptol. 2022(3), 73&ndash;101 (2022).
        </li>
        <li>
          <span class="text-gray-500">[BBH+19]</span>
          Ben-Sasson, Bentov, Horesh, Riabzev.
          <em>Scalable zero knowledge with no trusted setup</em>.
          CRYPTO 2019, LNCS 11694, pp. 701&ndash;732.
        </li>
        <li>
          <span class="text-gray-500">[BDP+12]</span>
          Bertoni, Daemen, Peeters, Van Assche.
          <em>Cryptographic sponge functions</em> (2012).
        </li>
        <li>
          <span class="text-gray-500">[BS90]</span>
          Biham, Shamir.
          <em>Differential cryptanalysis of DES-like
          cryptosystems</em>. CRYPTO '90, LNCS 537, pp. 2&ndash;21.
        </li>
        <li>
          <span class="text-gray-500">[But18]</span>
          Buterin.
          <em>Part 3</em> (STARK tutorial).
          <a
            href="https://vitalik.ca/general/2018/07/21/starks_part_3.html"
            target="_blank"
            rel="noopener noreferrer"
          >vitalik.ca</a>.
        </li>
        <li>
          <span class="text-gray-500">[DR20]</span>
          Daemen, Rijmen.
          <em>The Design of Rijndael &mdash; The Advanced Encryption
          Standard (AES)</em>, Second Edition. Springer (2020).
        </li>
        <li>
          <span class="text-gray-500">[GW20]</span>
          Gabizon, Williamson.
          <em>plookup: A simplified polynomial protocol for lookup
          tables</em>.
          <a
            href="https://eprint.iacr.org/2020/315"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2020/315</a>.
          <a href="/papers/plookup-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GWC19]</span>
          Gabizon, Williamson, Ciobotaru.
          <em>PLONK: permutations over Lagrange-bases for
          oecumenical noninteractive arguments of knowledge</em>.
          <a
            href="https://eprint.iacr.org/2019/953"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2019/953</a>.
          <a href="/papers/plonk-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKL+22]</span>
          Grassi, Khovratovich, Luftenegger, Rechberger,
          Schofnegger, Walch.
          <em>Reinforced concrete: A fast hash function for
          verifiable computation</em>. ACM CCS 2022, pp.
          1323&ndash;1335.
          <a href="/papers/reinforced-concrete-2021" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKR+21]</span>
          Grassi, Khovratovich, Rechberger, Roy, Schofnegger.
          <em>Poseidon: A new hash function for zero-knowledge proof
          systems</em>. USENIX Security 2021, pp. 519&ndash;535.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GLR+20]</span>
          Grassi, Luftenegger, Rechberger, Rotaru, Schofnegger.
          <em>On a generalization of substitution-permutation
          networks: The HADES design strategy</em>. EUROCRYPT 2020,
          LNCS 12106, pp. 674&ndash;704.
          <a href="/papers/hades-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[Hab22]</span>
          Haboeck.
          <em>Multivariate lookups based on logarithmic
          derivatives</em>.
          <a
            href="https://eprint.iacr.org/2022/1530"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2022/1530</a>.
          <a href="/papers/logup-multivariate-lookups-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[TVM]</span>
          jan-ferdinand, sshine, Sword-Smith, aszepieniec et al.
          <em>Triton VM</em>.
          <a
            href="https://triton-vm.org/"
            target="_blank"
            rel="noopener noreferrer"
          >triton-vm.org</a>.
        </li>
        <li>
          <span class="text-gray-500">[JP07]</span>
          Joux, Peyrin.
          <em>Hash functions and the (amplified) boomerang
          attack</em>. CRYPTO 2007, LNCS 4622, pp. 244&ndash;263.
        </li>
        <li>
          <span class="text-gray-500">[KO62]</span>
          Karatsuba, Ofman.
          <em>Multiplication of many-digital numbers by automatic
          computers</em> (1962).
        </li>
        <li>
          <span class="text-gray-500">[MY92]</span>
          Matsui, Yamagishi.
          <em>A new method for known plaintext attack of FEAL
          cipher</em>. EUROCRYPT '92, LNCS 658, pp. 81&ndash;91.
        </li>
        <li>
          <span class="text-gray-500">[Por22]</span>
          Pornin.
          <em>Ecgfp5: a specialized elliptic curve</em>.
          <a
            href="https://eprint.iacr.org/2022/274"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2022/274</a>.
          <a href="/papers/ecgfp5-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[RDP+96]</span>
          Rijmen, Daemen, Preneel, Bosselaers, De Win.
          <em>The cipher SHARK</em>. FSE 1996, LNCS 1039, pp.
          99&ndash;111.
        </li>
        <li>
          <span class="text-gray-500">[RAS20]</span>
          Roy, Andreeva, Sauer.
          <em>Interpolation cryptanalysis of unbalanced Feistel
          networks with low degree round functions</em>. SAC 2020,
          LNCS 12804, pp. 273&ndash;300.
        </li>
        <li>
          <span class="text-gray-500">[Nep]</span>
          Sword-Smith, sshine, jan-ferdinand et al.
          <em>twenty-first</em>.
          <a
            href="https://github.com/Neptune-Crypto/twenty-first"
            target="_blank"
            rel="noopener noreferrer"
          >github.com/Neptune-Crypto/twenty-first</a>.
        </li>
        <li>
          <span class="text-gray-500">[Sze]</span>
          Szepieniec.
          <em>Anatomy of a STARK</em>.
          <a
            href="https://aszepieniec.github.io/stark-anatomy/"
            target="_blank"
            rel="noopener noreferrer"
          >aszepieniec.github.io/stark-anatomy</a>.
        </li>
        <li>
          <span class="text-gray-500">[Szeb]</span>
          Szepieniec.
          <em>BrainSTARK</em>.
          <a
            href="https://aszepieniec.github.io/stark-brainfuck/"
            target="_blank"
            rel="noopener noreferrer"
          >aszepieniec.github.io/stark-brainfuck</a>.
        </li>
        <li>
          <span class="text-gray-500">[SAD20]</span>
          Szepieniec, Ashur, Dhooghe.
          <em>Rescue-prime: a standard specification (SoK)</em>.
          <a
            href="https://eprint.iacr.org/2020/1143"
            target="_blank"
            rel="noopener noreferrer"
          >eprint 2020/1143</a>.
          <a href="/papers/rescue-prime-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[SLS23]</span>
          Szepieniec, Lemmens, Sauer.
          <em>Tip-0005</em> (2023).
          <a
            href="https://github.com/TritonVM/triton-vm/blob/asz/tip5/tips/tip-0005/tip-0005.md"
            target="_blank"
            rel="noopener noreferrer"
          >github.com/TritonVM</a>.
        </li>
        <li>
          <span class="text-gray-500">[Thr]</span>
          Threadbare.
          <em>Miden VM hash functions</em>.
          <a
            href="https://github.com/0xPolygonMiden/crypto/tree/main/benches#comparison"
            target="_blank"
            rel="noopener noreferrer"
          >github.com/0xPolygonMiden</a>.
        </li>
        <li>
          <span class="text-gray-500">[Wag99]</span>
          Wagner.
          <em>The boomerang attack</em>. FSE 1999, LNCS 1636, pp.
          156&ndash;170.
        </li>
        <li>
          <span class="text-gray-500">[Plonky2]</span>
          wborgeaud, dlubarov et al.
          <em>Plonky2</em>.
          <a
            href="https://github.com/mir-protocol/plonky2"
            target="_blank"
            rel="noopener noreferrer"
          >github.com/mir-protocol/plonky2</a>.
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
