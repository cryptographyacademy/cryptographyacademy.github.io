---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2007/278';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Framework for Iterative Hash Functions - HAIFA';
const AUTHORS_HTML = 'Eli Biham, Orr Dunkelman';

const CONTENT = `    <p class="text-gray-300">A Framework for Iterative Hash Functions — HAIFA*</p>

    <p class="text-gray-300">Eli Biham<span class="math">^{1<strong>}</span>  Orr Dunkelman<span class="math">^{2</strong>*}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Computer Science Department, Technion. Haifa 32000, Israel biham@cs.technion.ac.il</p>

    <p class="text-gray-300"><span class="math">^{2}</span> Katholieke Universiteit Leuven Department of Electrical Engineering ESAT/SCD-COSIC Kasteelpark Arenberg 10, B-3001 Leuven-Heverlee, Belgium orr.dunkelman@esat.kuleuven.be</p>

    <p class="text-gray-300">Abstract. Since the seminal works of Merkle and Damgård on the iteration of compression functions, hash functions were built from compression functions using the Merkle-Damgård construction. Recently, several flaws in this construction were identified, allowing for second pre-image attacks and chosen target pre-image attacks on such hash functions even when the underlying compression functions are secure.</p>

    <p class="text-gray-300">In this paper we propose the HAsh Iterative FrAmework (HAIFA). Our framework can fix many of the flaws while supporting several additional properties such as defining families of hash functions and supporting variable hash size. HAIFA allows for an online computation of the hash function in one pass with a fixed amount of memory independently of the size of the message.</p>

    <p class="text-gray-300">Besides our proposal, the recent attacks initiated research on the way compression functions are to be iterated. We show that most recent proposals such as randomized hashing, the enveloped Merkle-Damgård, and the RMC and ROX modes can be all be instantiated as part of the HAsh Iterative FrAmework (HAIFA).</p>

    <p class="text-gray-300">Keywords: Merkle-Damgård, randomized hashing, Enveloped Merkle-Damgård, RMC, ROX, Wide pipe, HAIFA</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Cryptographic hash functions play an increasingly important role in cryptography. Many primitives and protocols rely on the existence of secure cryptographic</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An initial version of this work was presented in the hash function workshop in Krakow, June 2005 and in the second NIST hash function workshop 2006 in Santa Barbara, August 2006.</li>

    </ul>

    <p class="text-gray-300">** This work was supported in part by the Israel MOD Research and Technology Unit.</p>

    <p class="text-gray-300">*** This work was supported in part by the Concerted Research Action (GOA) Ambiorics 2005/11 of the Flemish Government and by the IAP Programme P6/26 BCRYPT of the Belgian State (Belgian Science Policy).</p>

    <p class="text-gray-300">hash functions. Hash functions are usually constructed by means of iterating a cryptographic compression function, while trying to maintain the following three requirements:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pre-image resistance: Given <span class="math">y=H(x)</span> it is hard to find <span class="math">x^{\\prime}</span> s.t. <span class="math">H(x^{\\prime})=y</span>.</li>

      <li>Second pre-image resistance: Given <span class="math">x</span> it is hard to find <span class="math">x^{\\prime}</span> s.t. <span class="math">H(x)=H(x^{\\prime})</span>.</li>

      <li>Collision resistance: It is hard to find <span class="math">x,x^{\\prime}</span> s.t. <span class="math">H(x)=H(x^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">The most widely used mode of iteration is the Merkle-Damgård construction <em>[9, 17, 18]</em>. The simple iteration method maintains the collision resistance of the compression function. The pre-image and second pre-image resistance of the compression function were also thought to be preserved in the Merkle-Damgård construction. However, counter examples for these beliefs were suggested recently.</p>

    <p class="text-gray-300">The first evidence for this was by Dean <em>[10]</em> who showed that fix-points of the compression function can be used for a second pre-image attacks against long messages using <span class="math">O(m\\cdot 2^{m/2})</span> time and <span class="math">O(m\\cdot 2^{m/2})</span> memory (where <span class="math">m</span> is the digest size). Later, Kelsey and Schneier have proposed the same ideas, while removing the assumption that fix-points can easily be found <em>[15]</em>. This improvement was achieved using Joux’s multi-collision attack on iterated hash functions <em>[13]</em>.</p>

    <p class="text-gray-300">The previous attacks have used very long messages. This led Kelsey and Kohno to show that using a simple pre-computation it is possible to reduce the time requirements of chosen target pre-image attacks for relatively short messages <em>[14]</em>. The total time complexity of the attack is much below the expected <span class="math">O(2^{m})</span>.</p>

    <p class="text-gray-300">In this work we suggest the HAsh Iterative FrAmework (HAIFA) to replace the Merkle-Damgård construction. HAIFA maintains the good properties of the Merkle-Damgård construction while adding to the security of the transformation, as well as to the scalability of the transformation.</p>

    <p class="text-gray-300">HAIFA has several attractive properties: simplicity, maintaining the collision resistance of the compressions function, increasing the security of iterative hash functions against (second) pre-image attacks, and the prevention of easy-to-use fix-points of the compression function. HAIFA also supports variable hash size and has a built-in support for defining families of hash functions as part of the framework. HAIFA also posses the online hashing property of the Merkle-Damgård construction. The computation of a HAIFA hash function requires one pass on the message, without keeping the entire message in memory, and while using a fixed amount of memory for the hashing of each block.</p>

    <p class="text-gray-300">Along with recent advances in finding collisions on wide spread hash functions from the MD family <em>[5, 6, 21, 22, 23, 24]</em>, this motivated many suggestions to strengthen hash functions and modes of iteration. These suggestions are either aimed at reducing the security requirements from the compression function <em>[11]</em> or at proposing a mechanism to securely iterate a compression function <em>[1, 2, 3, 7]</em>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The randomized hashing scheme <em>[11]</em> proposed by Krawczyk and Halevi aims to reduce the requirements on the collision resistance of the compression function in a collision resistant hash function. By randomizing the actual inputs to the compression functions, the existence of a collision in the compression function can be masked. This change is mostly useful for digital signatures (preventing the attack scenario where the attacker finds two colliding messages and asks the victim to sign the first).</p>

    <p class="text-gray-300">The enveloped Merkle-Damgård construction <em>[3]</em> was proposed by Bellare and Ristenpart as a method to maintain the collision resistance, the pseudorandom and the pseudorandom family properties of the compression function. This is very useful for constructions which require the pseudorandom properties of the hash function, e.g., in cases where the hash function is used in MACs.</p>

    <p class="text-gray-300">The last recent proposals for modes of iteration are the RMC <em>[1]</em> and ROX <em>[2]</em> by Andreeva et al. These two modes aim at preserving the collision resistance of the compression function, along with the second pre-image resistance (Sec) and the pre-image resistance (Pre), and their everywhere and always variants, aSec, eSec, aPre, and ePre.</p>

    <p class="text-gray-300">Besides suggesting modes of iteration for the compression functions, recent research also suggests using larger internal state <em>[16]</em>. The approach, named wide pipe, mitigate the flaws of iterated hashing by using a larger internal state than the output size. This approach leads to the fact that internal collisions, i.e., collisions in the chaining value, are eventually as hard as finding a pre-image of the hash function itself (assuming a good compression function is being used).</p>

    <p class="text-gray-300">After presenting HAIFA, we show that HAIFA can be used to instantiate any of these modes. Thus, a HAIFA compression function can easily be made to follow each of these suggestions according to the properties sought by the designer. For example, as a ROX hash function can be instantiated using the HAIFA framework, it is possible to construct a HAIFA hash function that maintains the (a/e)Sec and (a/e)Pre properties of the compression function.</p>

    <p class="text-gray-300">This paper is organized as follows: In Section 2 we describe the Merkle-Damgård construction and various results regarding the construction. In Section 3 we propose HAIFA. We discuss the security aspects of HAIFA in Section 4. We show how to implement the randomized hashing scheme, the enveloped Merkle-Damgård, and the RMC and ROX constructions using a HAIFA hash function in Section 5. We compare the above constructions with HAIFA in Section 6. Finally, Section 7 summarizes the paper.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 The Merkle-Damgård Constructions and its Pitfalls</h2>

    <p class="text-gray-300">The Merkle-Damgård construction is a simple and elegant way to transform a compression function <span class="math">C_{MD}:\\{0,1\\}^{m_{c}}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{m_{c}}</span> into a hash function <em>[17, 18, 9]</em>. Throughout this paper <span class="math">m_{c}</span> denotes the size of the chaining value, and <span class="math">n</span> denotes the block size for the compression function. We also denote by <span class="math">m</span> the hash output length (in many cases <span class="math">m=m_{c}</span>).</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The message <span class="math">M</span> is padded with its length (after additional padding to make the message a multiple of the block size <span class="math">n</span> after the final padding), and the message is divided into blocks of <span class="math">n</span> bits each, <span class="math">M=M_{1}M_{2}M_{3}\\ldots M_{k}</span>. An initial chaining value <span class="math">h_{0}=IV\\in\\{0,1\\}^{m_{c}}</span> is set for the hash function (also called initialization vector) and the following process is repeated <span class="math">k</span> times:</p>

    <p class="text-gray-300"><span class="math">h_{i}=C_{MD}(h_{i-1},M_{i})</span></p>

    <p class="text-gray-300">The final <span class="math">h_{k}</span> is outputted as the hash value, i.e., <span class="math">H(M)=h_{k}</span>.</p>

    <p class="text-gray-300">It is easy to prove that once a collision in the hash function <span class="math">H(\\cdot)</span> is found, then a collision of the compression function <span class="math">C_{MD}(\\cdot)</span> is found as well <em>[17, 18, 9]</em>. Thus, the Merkle-Damgård construction retains the collision resistance of the compression function.</p>

    <p class="text-gray-300">When from <span class="math">h_{i}=C_{MD}(h_{i-1},M_{i})</span> and <span class="math">M_{i}</span> the value of <span class="math">h_{i-1}</span> can be easily computed, a pre-image attack on <span class="math">H(\\cdot)</span> can be mounted using a birthday attack <em>[25]</em>. However, the opposite statement is not true. Even if an inversion attack on <span class="math">C_{MD}(\\cdot)</span> requires <span class="math">O(2^{m})</span> operations, the security claims for the hash function <span class="math">H(\\cdot)</span> cannot offer security better than <span class="math">O(2^{m/2})</span>. This surprising property was first noted by Dean <em>[10]</em>, which went unnoticed until rediscovered (and expanded) by Kelsey and Schneier <em>[15]</em>.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Fixed Points, Expandable Messages, and Finding Second Pre-Images</h3>

    <p class="text-gray-300">It was widely believed by the cryptographic community that the security proof of the Merkle-Damgård construction applies also to second pre-image attacks. However, Dean <em>[10]</em> noticed that this is not true for long messages if the compression function has easy to find fix-points. His observations were later generalized by Kelsey and Schneier <em>[15]</em> that used the multi-collision technique to eliminate the need for easily found fix-points.</p>

    <p class="text-gray-300">Let us consider a long message <span class="math">M=M_{1}M_{2}\\ldots M_{l}</span> that is processed using <span class="math">H(\\cdot)</span>, a Merkle-Damgård hash function, when the message length is not padded (the Merkle-Damgård strengthening). An attacker that wishes to construct a message <span class="math">M^{<em>}</span> such that <span class="math">H(M^{</em>})=H(M)</span> can randomly select messages <span class="math">M^{\\prime}</span> until <span class="math">H(M^{\\prime})</span> equals to any of the <span class="math">l</span> chaining values found during the computation of <span class="math">H(M)</span>. Once such an instance is found, the attacker can concatenate to <span class="math">M^{\\prime}</span> the message blocks of <span class="math">M</span> that are hashed starting from the given chaining value, resulting with <span class="math">M^{<em>}</span> such that <span class="math">H(M^{</em>})=H(M)</span>. This attack is foiled by the Merkle-Damgård strengthening, as the message length which is appended to the message is expected to differ for <span class="math">M</span> and <span class="math">M^{*}</span>.</p>

    <p class="text-gray-300">Assume that the compression function <span class="math">C_{MD}</span> is such that finding fix-points is easy, i.e., it is easy to find <span class="math">(h,M)</span> satisfying <span class="math">h=C_{MD}(h,M)</span>. This is the case for the Davies-Meyer construction that takes a block cipher <span class="math">E</span> that accept <span class="math">m_{c}</span>-bit plaintexts and <span class="math">n</span>-bit keys and sets</p>

    <p class="text-gray-300"><span class="math">h_{i}=C_{MD}(h_{i-1},M_{i})=E_{M_{i}}(h_{i-1})\\oplus h_{i-1}.</span></p>

    <p class="text-gray-300">For such a compression function it is easy to find fix-points by computing <span class="math">h=E_{M}^{-1}(0)</span> for randomly selected messages <span class="math">M</span>.</p>

    <p class="text-gray-300">Dean uses these fix-points to bypass the Merkle-Damgård strengthening. His attack has three main steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finding <span class="math">O(2^{m_{c}/2})</span> fix-points denoted by <span class="math">A=(h,m)</span>.</li>

      <li>Selecting <span class="math">O(2^{m_{c}/2})</span> single blocks and computing their chaining value denoted by <span class="math">B=(C_{MD}(IV,\\tilde{m}),\\tilde{m})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Finding a collision between a chaining value and a fixed point, i.e., between chaining values in <span class="math">A</span> and in <span class="math">B</span>. Let the colliding chaining be <span class="math">h</span>, and denote the corresponding message block (found in <span class="math">A</span>) by <span class="math">m</span>, i.e., <span class="math">(h,m)\\in A</span>, and denote the message block associated with <span class="math">h</span> in <span class="math">B</span> by <span class="math">\\tilde{m}</span>, i.e., <span class="math">(h,\\tilde{m})\\in B</span>. The attacker repeats the previous attack starting from the message $\\tilde{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m$ (i.e., trying to add blocks that cause the same chaining values as the original message) and fixes the length by iterating the fixed point as many times as needed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Once such a message is found, it is easy to expand the number of blocks in the message to the appropriate length by repeating the fix-points as many times as needed.</p>

    <p class="text-gray-300">Kelsey and Schneier transformed the attack to the case where fix-points are not easily found. While Dean’s expandable message could be extended by a repetition of a single block, in their attack they use the multi-collision technique to produce an expandable message. They replace the first two steps in Dean’s attack in the following procedure. In each iteration <span class="math">1\\leq i\\leq t</span> of the procedure a collision between a one block message and a <span class="math">2^{i-1}+1</span> block message is found. This procedure finds a chaining value that can be reached by messages of lengths between <span class="math">t</span> and <span class="math">2^{t+1}+t-1</span> blocks. Then, from this chaining value the third step of Dean’s attack is executed, and the length of the found message is controlled by the expandable prefix.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.2 Multi-Collisions in Iterative Hash Functions</h3>

    <p class="text-gray-300">Joux identified the fact that when iterative hash functions are used, finding multi-collisions, i.e., a set of messages with the same hash value, is almost as easy as finding a single collision <em>[13]</em>. His main observation is the fact that in iterative hashing schemes, such as the Merkle-Damgård, it impossible to find a collision for each block, e.g., for any <span class="math">h_{i-1}</span> finding <span class="math">M_{i}</span> and <span class="math">M_{i}^{<em>}</span> such that <span class="math">C_{MD}(h_{i-1},M_{i})=C_{MD}(h_{i-1},M_{i}^{</em>})</span>. Finding <span class="math">t</span> such one block collision (each starting from the chaining value produced by the previous block collision) it is possible to construct <span class="math">2^{t}</span> messages with the same hash value by selecting for <span class="math">i</span>th block of the message either <span class="math">M_{i}</span> or <span class="math">M_{i}^{*}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Joux also observed that the concatenation of two hash functions, i.e., $H(x)=H_{1}(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{2}(x)<span class="math">, is not more secure against collision attacks than the stronger of the two underlying hash functions. Moreover, concatenation of several iterative hash functions is as secure as the stronger of the hash functions (up to some a factor of </span>m^{k-1}<span class="math">, where </span>k$ is the number of hash functions).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">It is worth mentioning that using fix-points of several blocks, Joux proved that the concatenation of hash functions is as secure against pre-image attacks as the strongest of all the hash functions. These results have disproved several widely believed assumptions on the behavior of hash functions.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.3 Herding Iterative Hash Functions</h3>

    <p class="text-gray-300">Kelsey and Kohno have observed that it is possible to perform a time-memory tradeoff for several instances of pre-image attacks <em>[14]</em>. In their attack, an attacker commits to a public digest value that corresponds to some meaningful message, e.g., prediction of the outcome of NIST’s hash function competition. After the announcement of the result, the attacker publishes a message that has the pre-published digest value and contains the correct information along with some suffix.</p>

    <p class="text-gray-300">The attack is based on selecting the digest value carefully, helping the attacker to perform a pre-image attack on this value. In the pre-computation phase, the attacker starts with <span class="math">2^{t}</span> possible chaining values <span class="math">h_{i}</span> (these values can either be randomly selected or fixed in advance). The attacker then chooses <span class="math">O(2^{m_{c}/2-t/2})</span> single blocks, and for each chaining value and each block computes the output of the compression function given this input. The large amount of generated chaining values is expected to generate collisions. More precisely, it is expected that for each starting chaining value there is another chaining value, such that they are compressed to the same chaining value (not necessarily under the same message block). For each chaining value the attacker stores the message block that causes a collision in the table, and repeats the above process with the newly found chaining values. Once the attacker has only one chaining value, it is used to compute the digest value to be published (maybe after padding or some other message extension).</p>

    <p class="text-gray-300">In the online phase of the attack, the attacker needs to perform only <span class="math">O(2^{m_{c}-t})</span> operations until a message whose chaining value is among the <span class="math">2^{t}</span> original values is found. Once such a message is found, the attacker can retrieve from the stored date the message blocks that would lead to the designated digest.</p>

    <p class="text-gray-300">We note that unlike the previous attacks that require long messages, this attack appends relatively short suffix (about <span class="math">t</span> blocks) to the “real” message. We also note, that the total time complexity of the attack is about <span class="math">O(2^{m_{c}/2+t/2})</span> off-line operations for the first step of the attack and <span class="math">O(2^{m_{c}-t})</span> online operations for the second step. For <span class="math">t=m_{c}/3</span> the overall time complexity of this attack is <span class="math">O(2^{2m_{c}/3})</span> for finding a pre-image.</p>

    <h2 id="sec-5" class="text-2xl font-bold">3 The HAsh Iterative FrAmework (HAIFA)</h2>

    <p class="text-gray-300">We propose the HAsh Iterative FrAmework to solve many of the pitfalls of the Merkle-Damgård construction. The main ideas behind HAIFA are the introduction of number of bits that were hashed so far and a salt value into the compression functions. Formally, instead of using a compression function</p>

    <p class="text-gray-300">of the form <span class="math">C_{MD}:\\{0,1\\}^{m_{c}}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{m_{c}}</span>, we propose to use <span class="math">C:\\{0,1\\}^{m_{c}}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{b}\\times\\{0,1\\}^{s}\\rightarrow\\{0,1\\}^{m_{c}}</span>, i.e., in HAIFA the chaining value <span class="math">h_{i}</span> is computed as</p>

    <p class="text-gray-300"><span class="math">h_{i}=C(h_{i-1},M_{i},\\#bits,salt),</span></p>

    <p class="text-gray-300">where <span class="math">\\#bits</span> is the number of bits hashed so far and <span class="math">salt</span> is a salt value.</p>

    <p class="text-gray-300">Thus, to hash a message <span class="math">M</span> using <span class="math">C(\\cdot)</span> and the salt <span class="math">salt</span> and obtaining <span class="math">m</span> bits of digest value (as long as <span class="math">m\\leq m_{c}</span>), the following operations are performed:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pad <span class="math">M</span> according to the padding scheme described in Section 3.1.</li>

      <li>Compute <span class="math">IV_{m}</span> the initial value for a digest of size <span class="math">m</span> using the prescribed way in Section 3.2.</li>

      <li>Iteratively digest the padded message using <span class="math">C(\\cdot)</span>, starting from the initial value <span class="math">IV_{m}</span> and using the salt. We note that in case an additional block is padded to the message, the compression function is called on this block with <span class="math">\\#bits=0</span>.</li>

      <li>Truncate the final chaining value if needed (see Section 3.2).</li>

    </ol>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 The Padding Scheme</h3>

    <p class="text-gray-300">The padding scheme used in HAIFA is very similar to the one used in the Merkle-Damgård construction: In HAIFA the message is padded with 1, as many needed 0’s, the length of the message encoded in a fixed number of bits, and the digest size:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pad a single bit of 1.</li>

      <li>Pad as many 0 bits as needed such that the length of the padded message (with the 1 bit and the 0’s) is congruent modulo <span class="math">n</span> to <span class="math">(n-(t+r))</span>.</li>

      <li>Pad the message length encoded in <span class="math">t</span> bits.</li>

      <li>Pad the digest size encoded in <span class="math">r</span> bits.</li>

    </ol>

    <p class="text-gray-300">Adding the digest size ensures that even if two messages <span class="math">M_{1}</span> and <span class="math">M_{2}</span> are found, such that under <span class="math">IV_{l_{1}}</span> and <span class="math">IV_{l_{2}}</span> (<span class="math">M_{1}</span> hashed to obtain <span class="math">l_{1}</span> bits and <span class="math">M_{2}</span> hashed to a digest of <span class="math">l_{2}</span> bits) their chaining values collide, then the last block changes this behavior. This approach is similar to the one used in the Merkle-Damgård strengthening, even though it deals with a scenario of variable output sizes.</p>

    <p class="text-gray-300">We note that when a full padding block is added for the hashing (i.e., the full original message was already processed by the previous calls to the compression function, and the full message size was already input to the previous call), the compression function is called with the number of bits hashed so far set to zero. This allows for the compression function to identify whether this is the last block and moreover, whether this is a full padding block. It is easy to see that when the number of bits hashed so far is not a multiple of the block length, then this is certainly the last block (and the question whether there is a full padding block can be easily deduced from the length of the message). We note that for the null</p>

    <p class="text-gray-300">string there is a padding of a full padding block anyway. Appendix A contains the exact algorithm for finding the last block of the message.</p>

    <p class="text-gray-300">The security is not affected by this method, as the length of the message is necessarily embedded in the full padding block, and was already input to the previous call to the compression function.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.2 Variable Hash Size</h3>

    <p class="text-gray-300">Different digest sizes are needed for different applications. This fact has motivated NIST to publish SHA-224 and SHA-384 as truncated variants of SHA-256 and SHA-512, respectively. We note that these truncated hash functions use the same construction, but with different initial values.</p>

    <p class="text-gray-300">Our framework supports truncation that allows arbitrary digest sizes (up to the output size of the compression function), while securing the construction against attacks that try to find two messages that have similar digest values. This problem eliminates the easy solution of just taking the number of output bits from the output of the compression function.</p>

    <p class="text-gray-300">Let <span class="math">IV</span> be an initial value chosen by the designer of the compression function, and let <span class="math">m</span> be the required length of the output. For producing hash values of <span class="math">m</span> bits the following initial value is computed</p>

    <p class="text-gray-300"><span class="math">IV_{m}=C(IV,m,0,0).</span></p>

    <p class="text-gray-300">The value <span class="math">m</span> is encoded in the first <span class="math">r</span> bits, followed by a single bit 1, and <span class="math">n-r-1</span> 0’s. In other words, <span class="math">m</span> is found in the first <span class="math">r</span> bits of the block. We note that even though <span class="math">\\#bits=0</span>, this call is distinct from all other calls to the compression function. This is due to the fact that the only other call to the compression function with <span class="math">\\#bits=0</span> is in the case of using an additional padding block, for which the message block is either all 0’s or a 1 followed by as many 0’s as needed, whereas in this case the message block contains the encoding of <span class="math">m</span>.</p>

    <p class="text-gray-300">After the final block is processed, the digest is composed of the <span class="math">m</span> first bits of <span class="math">h_{t}</span>, where <span class="math">h_{t}</span> is the last chaining value. We advise implementors to make sure that these <span class="math">m</span> bits are the most diffused bits of the chaining value.</p>

    <p class="text-gray-300">This suggestion allows for supporting various digest lengths in a simple and straightforward way. An implementation of a HAIFA-based hash function requires only the value of <span class="math">IV</span> for the ability to produce any hash length, while in implementations where only a single output length <span class="math">l</span> is needed, <span class="math">IV_{l}</span> can be precomputed and hardcoded into the implementation.</p>

    <h2 id="sec-8" class="text-2xl font-bold">4 The Security of HAIFA Hash Functions</h2>

    <p class="text-gray-300">We first note that proving the HAIFA hash function is collision resistant if the underlying compression function is collision resistant is quite easy. The same arguments that are used to prove that the Merkle-Damgård construction retains</p>

    <p class="text-gray-300">the collision resistance of the underlying compression function, can be used to prove that HAIFA does so as well. We consider the strongest definition of a collision in the compression function where the attacker has a control over all input parameters to the compression function and tries to generate the same output. Let <span class="math">M_{1}</span> and <span class="math">M_{2}</span> be the two colliding messages with respective lengths <span class="math">l_{1}</span> and <span class="math">l_{2}</span>. If <span class="math">l_{1}</span> and <span class="math">l_{2}</span> are different, then the paddings are necessarily different (due to the different length), and a collision in the compression function is found. If the lengths of the messages are the same, one can start from the joint digest and trace backwards till the point where the inputs to the compression function differ. For example, if the messages are hashed with a different salt, then the last block is necessarily a collision. Otherwise, both messages were hashed with the same salt and have the same length (and thus have the same <span class="math">\\#bits</span> in each call to the compression function), and the same argument as the one for the Merkle-Damgård mode shows that there must exist a message block <span class="math">i</span> such that <span class="math">M_{i}^{1}\\neq M_{i}^{2}</span> or <span class="math">h_{i-1}^{1}\\neq h_{i-1}^{2}</span> (where the superscript denotes the corresponding message), for which <span class="math">C(h_{i-1}^{1},M_{1}^{i},s,i\\cdot n)=C(h_{i-1}^{2},M_{2}^{i},s,i\\cdot n)</span>.</p>

    <p class="text-gray-300">We note that any iterative construction can be attacked by some of the attacks described in Section 2. However, as noted before, using our ideas, it is possible to reduce the applicability of these attacks, by preventing an efficient pre-computation that reduces the online computational phase of these attacks.</p>

    <p class="text-gray-300">We continue by first discussing some of the security reasons behind the added parameters to the compression function. Then we analyze the general security feature of a HAIFA hash function.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.1 Number of Bits Hashed so Far</h3>

    <p class="text-gray-300">The inclusion of the number of bits hashed so far was suggested (with small variants) in order to prevent the easy exploitation of fix-points. The attacker is forced to work harder in order to find fix-points. While for <span class="math">C_{MD}</span>, once a fix-point <span class="math">(h,M)</span> such that <span class="math">h=C_{MD}(h,M)</span> is found, it can be used as many times as the attacker sees fit <em>[10, 15]</em>. Even if the compression function does not mix the <span class="math">\\#bits</span> parameter well, once an attacker finds a fix-point of the form <span class="math">(h,M,\\#bits,salt)</span> such that <span class="math">h=C(h,M,\\#bits,salt)</span>, she cannot concatenate it to itself as many times as she wishes because the number of bits hashed so far has changed.</p>

    <p class="text-gray-300">We note that it is possible to use the number of blocks that were treated so far instead. However, current schemes keep track of the number of bits hashed so far which is used for for the padding, rather than the number of blocks. Thus, it is easier for implementations to consider only one parameter (number of bits) rather two (somewhat related) parameters (number of bits and number of blocks).</p>

    <p class="text-gray-300">It is interesting to consider message authentication codes based on the following HAIFA hash function <span class="math">H(\\cdot)</span>: <span class="math">MAC_{k}(M)=H(k,M)</span>. While for a Merkle-Damgård construction or suggestions that use the number of blocks hashed so far, this suggestion is clearly not secure against message expansion techniques, for HAIFA this construction is secure. The reason for that is that the last block (or the one before it, in case an additional padding block is added) is compressed</p>

    <p class="text-gray-300">with the number of bits that were processed so far. If this value is not a multiple of a block, then the resulting digest does not equal the chaining value that is needed to the expansion of the message. If the message is a multiple of a block, then an additional block is hashed (with the parameter <span class="math">\\#bits</span> set to 0). Thus, the chaining value required for the expansion remains obscure to the attacker.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.2 Salt</h3>

    <p class="text-gray-300">The <span class="math">salt</span> parameter can be considered as defining a family of hash functions as needed by the formal definitions of <em>[19]</em> in order to ensure the security of the family of hash functions. This parameter can be viewed as an instance of the randomized hashing concept, thus, inheriting all the “goodies” such concept provides:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ability to define the security of the hash function in the theoretical model.</li>

      <li>Transformation of all attacks on the hash function that can use precomputation from an off-line part and an on-line part to only on-line parts (as the exact <span class="math">salt</span> is not known in advance).</li>

      <li>Increasing the security of digital signatures, as the signer chooses the <span class="math">salt</span> value, and thus, any attack aiming at finding two messages with the same hash value has to take the <span class="math">salt</span> into consideration.</li>

    </ul>

    <p class="text-gray-300">We note that the salt can be application specific (e.g., a string identifying the application), a serial number that follows the application (e.g., the serial number of the message signed), a counter, or a random string. It is obvious that <span class="math">s</span> can also be set as a combination of these values.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.3 Security against the Multi-Collision Attack</h3>

    <p class="text-gray-300">Let us consider the multi-collision attack. This attack works against all iterative hashing schemes, independent of their structure. While the time complexity for finding collisions for each block is not different in our framework than in the Merkle-Damgård construction, an attacker cannot pre-compute these multi-collisions before the choosing of the salt value.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.4 Preventing Attacks Based on Fix-Points</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As noted before, our framework prevents Dean’s attack, as it is highly unlikely that some fix-point of the compression function can be repeated. We note that the existence of an additional random input is not sufficient to ensure security against this kind of attacks. For example, when considering the randomized hashing modes proposed in <em>[11]</em> it is evident that this attack still applies to them. Dean’s attack can be easily applied to the randomized Merkle-Damgård constructions $H_{r}(M)=H(M\\oplus(r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r))<span class="math"> and </span>\\tilde{H}_{r}(M)=H_{r}(0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M)$, as once a fix-point is found, it remains a fix-point for these constructions. We note that the first two steps of Dean’s attack can be mounted off-line just as in Dean’s attack on regular Merkle-Damgård hash functions for these two constructions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for Kelsey and Schneier’s attack, just like in Joux’s multi-collision attack, the attacker has to know the value of the salt before being able to generate the expandable message. Thus, an attacker who tries to generate a second pre-image, has to wait till the original message and salt are provided (or generate an expandable message for each and every possible salt).</p>

    <p class="text-gray-300">We conclude by noting that like in Joux’s multi-collision attack, once the attacker is given the salt, the attacker can repeat the Kelsey and Schneier attack.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.5 Mitigating the Herding Attack</h3>

    <p class="text-gray-300">Under HAIFA, the precomputation phase of the herding attack is infeasible without the knowledge of the salt that is used. We note that if a security of <span class="math">O(2^{m})</span> against pre-image attacks such as the herding attack is requested, then the size of the salt must be at least <span class="math">m_{c}/2</span> bits long, in order to prevent the herding attack. We also note that when the attacker is the one choosing the salt, then the herding attack cannot be avoided, but due to the <span class="math">\\#bits</span> parameters, the attacker can mount the attack starting from one specific point (rather than moving the diamond structure around and compensating using an expandable message after the diamond structure).</p>

    <p class="text-gray-300">We note that if the length of the salt is short, then an attacker can still use precomputation to overcome the security proposed by HAIFA. It is therefore recommended that the salt length would be of 64 bits at least, or at least <span class="math">m_{c}/2</span> bits when possible.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.6 Final Notes about the Security of HAIFA</h3>

    <p class="text-gray-300">The approach of increasing the chaining value was promoted in <em>[16]</em> and it may seem that our suggestion supports this approach. However, the analysis in <em>[16]</em> assumes that the hash function is a “good” hash function for all the bits of the chaining value, and the compression function does not accept the additional inputs that HAIFA support. Therefore, a large increase in <span class="math">m_{c}</span> is needed (typically, doubling the size). In our approach the <span class="math">salt</span> and <span class="math">\\#bits</span> parameters are treated separately from the chaining value, and allow us to protect from the weakness of a short chaining value without doubling the size of the chaining values. Thus, it is expected that HAIFA hash functions will be faster than wide hash constructions.</p>

    <p class="text-gray-300">We conclude that the security of a Merkle-Damgård hash function against a pre-image attacks is equivalent to its security against collision attacks. For HAIFA this is not the case, as we have shown earlier. We give the security level of an ideal hash function and of the Merkle-Damgård and HAIFA constructions (under two cases — with a variable salt, and with a fixed salt) in Table 1.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 Modeling Other Constructions in HAIFA</h2>

    <p class="text-gray-300">In this section we show that recent proposals for modes of iteration can be viewed as an instance of HAIFA. This shows that the interface proposed by HAIFA is robust enough for any of the possible proposals for modes of iteration.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type of Attack</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ideal Hash Function =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MD ≥</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HAIFA fixed salt ≥</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HAIFA with (distinct) salts ≥</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Preimage</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One-of-many pre-image (k' < 2s targets)</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k'</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k'</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k'</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Second-pre-image (k blocks)</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">One-of-many second pre-image(k blocks in total, k' < 2s messages)</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k'</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/k'</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Collision</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/2</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multi-collision (k-collision)</td>

            <td class="px-3 py-2 border-b border-gray-700">2mc(k-1)/k</td>

            <td class="px-3 py-2 border-b border-gray-700">[log2k]2mc/2</td>

            <td class="px-3 py-2 border-b border-gray-700">[log2k]2mc/2</td>

            <td class="px-3 py-2 border-b border-gray-700">[log2k]2mc/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Herding [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Offline: 2mc/2+t/2</td>

            <td class="px-3 py-2 border-b border-gray-700">Offline: 2mc/2+t/2</td>

            <td class="px-3 py-2 border-b border-gray-700">Offline: 2mc/2+t/2+s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Online: 2mc-t</td>

            <td class="px-3 py-2 border-b border-gray-700">Online: 2mc-t</td>

            <td class="px-3 py-2 border-b border-gray-700">Online: 2mc-t</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The figures are given for MD and HAIFA hash functions that use an ideal compression function.</p>

    <p class="text-gray-300">Table 1. Complexities of Attacks on Merkle-Damgård and HAIFA Hash Functions with Comparison for an Ideal Hash Function</p>

    <p class="text-gray-300">We note that in these constructions the padding schemes are not compatible with the added digest size to the padding. This can be solved easily during the identification of the last block by removing it in the compression function. We also note that in the following constructions, HAIFA's padding scheme does not affect any of the security properties of the hash functions.</p>

    <p class="text-gray-300">The main purpose of randomized hashing is to reduce the level of requirements from the compression function in order to achieve a collision-resistant hash function [11]. The randomized hashing is especially useful for digital signatures, where the collision resistance is the most important requirement from the hash function. In order to achieve these properties the following two constructions were suggested:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} H _ {r} \\left(M _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {k}\\right) \\stackrel {\\text {d e f}} {=} H \\left(M _ {1} \\oplus r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {2} \\oplus r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {k} \\oplus r\\right) \\\\ \\tilde {H} _ {r} (M) \\stackrel {\\text {d e f}} {=} H _ {r} (0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M) = H (r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {1} \\oplus r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {2} \\oplus r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M _ {k} \\oplus r) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">H</span>  is a Merkle-Damgård hash function.</p>

    <p class="text-gray-300">It is easy to see that by setting the salt to  <span class="math">s = r</span>  and ignoring the input of number of bits, we can instantiate a randomized hashing scheme in a HAIFA compression function. Let  <span class="math">C_{MD}</span>  be the compression function used in the randomized hashing, thus we set:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {H A I F A 1} \\left(h _ {i - 1}, M _ {i}, \\# b i t s, s\\right) = C _ {M D} \\left(h _ {i - 1}, M _ {i} \\oplus s\\right),</span></div>

    <p class="text-gray-300">which would result in an implementation of <span class="math">H_{r}</span>, i.e., <span class="math">HAIFA^{C_{HAIFA1}} = H_{r}^{C_{MD}}</span>.</p>

    <p class="text-gray-300">To implement <span class="math">\\tilde{H}_r</span>, we use a slightly modified construction:</p>

    <div class="my-4 text-center"><span class="math-block">C_{HAIFA2}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C_{MD}(C_{MD}(h_{i-1}, s), M_i \\oplus s) &amp;amp; \\text{If } 0 &amp;lt; \\#bits \\leq n \\\\ C_{MD}(h_{i-1}, M_i \\oplus s) &amp;amp; \\text{Otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">It is easy to see that for any non-empty message, the first block is hashed only after the random value is hashed. For the empty message (null string) the computed hash is <span class="math">C_{MD}(IV, s)</span> which is the value that would have been computed for <span class="math">\\tilde{H}_r(\\cdot)</span>. We conclude that <span class="math">HAIFA^{C_{HAIFA2}} = \\tilde{H}_r^{C_{MD}}</span>.</p>

    <p class="text-gray-300">Note that in both cases, if the variable message length feature is not wanted it can be ignored by letting <span class="math">h_i = C(h_{i-1}, M_i, \\#bits, s) = h_{i-1}</span> if the following conditions hold: <span class="math">\\#bits = 0</span>, the field that contains the digest size in the padding is set to 0.</p>

    <h2 id="sec-17" class="text-2xl font-bold">5.2 Enveloped Merkle-Damgård</h2>

    <p class="text-gray-300">The Enveloped Merkle-Damgård [3] is a proposal for a mode of iteration that preserves the following three properties: collision resistance, pseudorandom oracle, and pseudorandom family. In order to achieve this, the Merkle-Damgård construction is altered in the following manner:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The padding scheme pads the message with 1, as many 0's as requires, and the message length, such that the padded message, <span class="math">PAD_{EMD}(M)</span> has a length which equals to <span class="math">n - m_c \\mod n</span>.</li>

      <li>The final digest value is computed as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_k = C_{MD}(IV_2, h_{k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_k),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for a second initialization vector <span class="math">IV_2</span>.</p>

    <p class="text-gray-300">Let <span class="math">C_{MD}</span> be the compression function used for the enveloped Merkle-Damgård, and let <span class="math">C_{HAIFA3}</span> be defined as:</p>

    <p class="text-gray-300">$$ C_{HAIFA3}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{MD}(IV_2, h_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fix\\_pad(M_i)) &amp; \\text{Last block} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C_{MD}(h_{i-1}, M_i) &amp; \\text{Otherwise} \\end{cases} $$</p>

    <p class="text-gray-300">As noted earlier, identifying the last block is a trivial operation in HAIFA. Thus, it is easy to see that <span class="math">HAIFA^{C_{HAIFA3}} = EMD^{C_{MD}}</span>, i.e., the suggested HAIFA hash function is equivalent to the enveloped Merkle-Damgård one.</p>

    <p class="text-gray-300">As the padding scheme used in the enveloped Merkle-Damgård scheme is slightly different than the one used in HAIFA. Fixing the padding in the last block <span class="math">fix\\_pad(\\cdot)</span> can be done as the HAIFA padding can be easily shortened. When the first <span class="math">m_c</span> zero bits of the padding (assuming <span class="math">m_c &amp;lt; n</span>) can be removed in the last block, then the operation is straightforward. If there are not sufficiently such bits, then a full padding block would have been needed in the enveloped Merkle-Damgård, and the generation of the correct full padding block can be done in the compression function.</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">5.3 RMC and ROX</p>

    <p class="text-gray-300">The RMC <em>[1]</em> construction suggests a method to preserve seven properties of a compression function <span class="math">C_{RMC}:\\{0,1\\}^{m_{c}}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{k}\\rightarrow\\{0,1\\}^{m_{c}}</span> in the hash function <span class="math">RMC^{RO_{1},RO_{2}}:\\{0,1\\}^{k}\\times\\{0,1\\}^{s}\\times\\{0,1\\}^{<em>}\\rightarrow\\{0,1\\}^{m}</span>. The preserved properties are collision resistance, Second pre-image resistance, and pre-image resistance, along with their everywhere and always variants. The RMC construction maintains these properties by using the XOR-linear hash scheme </em>[4]*. The construction uses two random oracles (with fixed output length). The first random oracle <span class="math">RO_{1}</span> is used to produce strings which are XORed to the chaining values (just like in the XOR-linear scheme). The second random oracle <span class="math">RO_{2}</span> is used for the padding scheme.</p>

    <p class="text-gray-300">Let <span class="math">\\nu(i)</span> be the largest number <span class="math">j</span> for which <span class="math">2^{j}</span> divides <span class="math">i</span>. As in the XOR-linear construction, when hashing block <span class="math">i</span>, the string <span class="math">\\mu_{\\nu(i)}</span> is XORed to the chaining value, unlike the XOR-linear scheme, this value is computed using a call to the random oracle <span class="math">RO_{1}</span>. The parameters to the random oracle are the key of the hash function (corresponding to our salt) and a salt along with the encoding of <span class="math">\\nu(i)</span>, i.e., let the key be denoted by <span class="math">K</span> and the salt by <span class="math">s</span>, then</p>

    <p class="text-gray-300"><span class="math">\\mu_{\\nu(i)}=RO_{1}(K,s,\\nu(i)).</span></p>

    <p class="text-gray-300">We note that the output of the random oracle is of length <span class="math">m_{c}</span> bits.</p>

    <p class="text-gray-300">The padding scheme is composed of as many calls to <span class="math">RO_{2}</span> that are needed to achieve the right length of padding (with some minimal length of padding), where in each call <span class="math">RO_{2}</span> is called with the key <span class="math">K</span>, the salt <span class="math">s</span>, and the serial call number. The padding scheme is out of the scope of our paper, but we shall denote it as <span class="math">pad_{RMC}(K,s,M)</span>.</p>

    <p class="text-gray-300">The RMC hash function that uses <span class="math">RO_{1},RO_{2}</span> and <span class="math">C_{RMC}</span> is the following scheme:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Pad <span class="math">M</span> using <span class="math">RO_{2}(K,s,M)</span>, where <span class="math">K</span> is the key (of length <span class="math">k</span> bits) and <span class="math">s</span> is the salt. Denote the padded message by $padded_{RMC}(M)=M_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">h_{0}=IV</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Generate <span class="math">\\mu_{i}=RO_{1}(K,s,i)</span>, for $i=0,\\ldots,\\lceil\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\rceil$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=1,\\ldots,l</span> compute <span class="math">h_{i}=C_{RMC}(h_{i-1}\\oplus\\mu_{\\nu(i)},M_{i},K)</span>.</li>

    </ul>

    <p class="text-gray-300">To support the RMC mode we embed the salt and the key in the salt of HAIFA. Thus,</p>

    <p class="text-gray-300">\\[ C_{HAIFA4}(h_{i-1},M_{i},\\#bits,s)=\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\begin{array}[]{ll}C_{RMC}(h_{i-1}\\oplus RO_{1}(s_{1},s_{2},\\nu(i)),M_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pad_{RO2(s_{1},s_{2})})&\\text{Last block}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C_{RMC}(h_{i-1}\\oplus RO_{1}(s_{1},s_{2},\\nu(i)),M_{i},s_{1})&\\text{Otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">where <span class="math">s=(s_{1},s_{2})</span>, i.e., the salt is composed of the concatenation of the key and the salt of RMC. We note that computing <span class="math">\\nu(i)</span> in HAIFA is very easy, as it involves dividing the #bits parameter by <span class="math">n</span> to obtain the block number, and then compute <span class="math">\\nu(i)</span> as in RMC.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Given the above transformation, and assuming that both hash functions use the same random oracles, then <span class="math">HAIFA^{C_{HAIFA4}}=RMC^{C_{RMC}}</span>.</p>

    <p class="text-gray-300">In <em>[2]</em> the RMC construction was slightly improved, and some parameters were changed a little bit to suggest the ROX construction. Let <span class="math">C_{MD}</span> be the compression function, then <span class="math">ROX^{RO_{1},RO_{2}}_{C_{MD}}:\\{0,1\\}^{k}\\times\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{m}</span> is defined as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Pad <span class="math">M</span> using <span class="math">RO_{2}(K,M)</span>, where <span class="math">K</span> is the key (of length <span class="math">k</span> bits). Denote the padded message by $padded_{ROX}(M)=M_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">h_{0}=IV</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Generate <span class="math">\\mu_{i}=RO_{1}(K,\\tilde{m},i)</span>, for $i=0,\\ldots,\\lceil\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\rceil<span class="math">, where </span>\\tilde{m}<span class="math"> is the first </span>k$ bits of the message.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=1,\\ldots,l</span> compute <span class="math">h_{i}=C_{MD}(h_{i-1}\\oplus\\mu_{\\nu(i)},M_{i})</span>.</li>

    </ul>

    <p class="text-gray-300">We note that <span class="math">M</span> replaces the salt <span class="math">s</span> from RMC. We set the size of the salt to <span class="math">2k</span>, where the first half of the salt is <span class="math">K</span>, and the second half is <span class="math">m</span> (which are known immediately once the first block is hashed).</p>

    <p class="text-gray-300">Thus, <span class="math">C_{HAIFA5}:\\{0,1\\}_{c}^{m}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{b}\\times\\{0,1\\}^{2k}</span> is as follows:</p>

    <p class="text-gray-300"><span class="math">C_{HAIFA5}(h_{i-1},M_{i},\\#bits,s)=</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{\\begin{array}[]{ll}C_{MD}(h_{i-1}\\oplus RO_{1}(s_{1},s_{2},\\nu(i)),M_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pad_{RO2(s_{1})})&\\text{Last block}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C_{MD}(h_{i-1}\\oplus RO_{1}(s_{1},s_{2},\\nu(i)),M_{i})&\\text{Otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">Where <span class="math">s=(s_{1},s_{2})</span>, and <span class="math">s_{2}=first_{k}(M)</span> (the value of <span class="math">s_{1}</span> is set by the user as well as part of the “key” to the hash function). It is easy to see that <span class="math">HAIFA^{C_{HAIFA5}}=ROX^{C_{MD}}</span> given the access to the “same” random oracles.</p>

    <p class="text-gray-300">Another possible reduction is based on increasing the chaining value by <span class="math">k</span> bits which are initialized to <span class="math">0</span>. When the first block is processed, these <span class="math">k</span> bits are set to <span class="math">first_{k}(M)</span> (in the first block <span class="math">0&lt;\\#bits\\leq n</span>), and then this value is not altered, while being transfered to all the following calls for the compression function.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.4 Wide-Pipe Hash Constructions</h3>

    <p class="text-gray-300">The wide-pipe hash design principal was introduced by Lucks in <em>[16]</em> to reduce the effects of attacks based on internal collisions on the hash function. By increasing the chaining value size, e.g., choosing <span class="math">m_{c}=2m</span> (in a double-pipe construction), the cost of the attacks based on internal collisions is at least <span class="math">2^{m_{c}/2}=2^{m}</span>, thus allowing for a <span class="math">2^{m}</span> security goal against pre-image and second pre-image attacks.</p>

    <p class="text-gray-300">The scheme employs two compression functions. The first one is <span class="math">C^{\\prime}:\\{0,1\\}^{m_{c}}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{m_{c}}</span>, while the second one is <span class="math">C^{\\prime\\prime}:\\{0,1\\}^{m_{c}}\\rightarrow\\{0,1\\}^{m}</span>. The digest value is computed like in the Merkle-Damgård construction using <span class="math">C^{\\prime}(\\cdot)</span> as the compression function. Then, the computed chaining value is compressed using one call to <span class="math">C^{\\prime\\prime}(\\cdot)</span> to produce the digest.</p>

    <p class="text-gray-300">It is easy to see that transforming the wide pipe strategy into a HAIFA construction is a straightforward (and very similar to the transformation used</p>

    <p class="text-gray-300">in the EMD mode):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ C_{HAIFA6}(h_{i-1},M_{i},\\#bits,s)=\\left\\{\\begin{array}[]{ll}C^{\\prime\\prime}(C^{\\prime}(IV_{2},h_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fix\\_pad(M_{i})))&\\text{Last block}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">C^{\\prime}(h_{i-1},M_{i})&\\text{Otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">As noted earlier, identifying the last block is a trivial operation in HAIFA. Thus, it is easy to see that <span class="math">HAIFA^{C_{HAIFA6}}=WidePipe^{C^{\\prime},C^{\\prime\\prime}}</span>, i.e., the suggested HAIFA hash function is equivalent to the wide pipe hash function.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6 Comparing Other Constructions with HAIFA</h2>

    <p class="text-gray-300">While other constructions propose different security assurances, they lack in the security against realistic and practical attacks. For example, Joux’s multi-collision attack is applicable against EMD with the same ease it is applicable against Merkle-Damgård. Unlike HAIFA where the collisions are to be chosen after the salt is known, in EMD this can even be in an off-line manner.</p>

    <p class="text-gray-300">For the randomized hashing scheme, Joux’s multi-collision attack can be performed off-line, where the actual multi-collision is updated according to the random string afterwards, or can be performed in an on-line manner (once the random value is known). The long second pre-image attack can also be easily applied to the randomized hashing scheme, as the pre-processing of the messages is independent of the random string (which can later be XORed into the message to suggest the actual pre-image). The herding attack is also easily applicable to the randomized hashing scheme, as again, the only difference in the attack is the fact that resulting message is to be XORed with the random string (block by block). This problems are addressed in HAIFA by the stronger diffusion of the salt into the compression function, thus, eliminating the easy use of the pre-computed values.</p>

    <p class="text-gray-300">The EMD scheme is mostly Merkle-Damgård, and thus, it is not surprising that all the mentioned attacks are applicable with the same ease to EMD. Thus, EMD proposes no additional security against any of these attacks. As noted earlier, the application of the multi-collision attack can be done off-line. It is quite obvious that security wise, HAIFA can offer a greater deal of security over the this mode.</p>

    <p class="text-gray-300">The RMC and ROX transformation are as susceptible to multi-collision attacks as all the other iterated constructions. We note that just like in a general HAIFA hash function, the salt has to be known (transforming the attack to an on-line attack when this is relevant). Due to the keying, the long second pre-image attacks are no longer possible as the change of the key affects the compressed values in a non-predictable way. As for the herding attack, while the herding attack can always be applied against any iterated construction when the key is known. When the key is unknown, the attacker has to try all possible keys. Unlike a general HAIFA hash function, the attacker can still manipulate the location of the diamond structure, by using a sequence of <span class="math">\\mu(i)</span> which repeats several times, e.g., 1,2,1,3,1,2,1,…. This allows for the shift of the diamond</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Type of Attack</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Randomized Hashing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EMD</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RMC & ROX</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Double Pipe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HAIFA</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multi-collision</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">App.*</td>

            <td class="px-3 py-2 border-b border-gray-700">Not App.</td>

            <td class="px-3 py-2 border-b border-gray-700">App.*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Long Second Preimage</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Not App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Not App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Not App.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Herding</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Partially App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Not App.</td>

            <td class="px-3 py-2 border-b border-gray-700">Almost Not App.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>— When the salt is known</li>

    </ul>

    <p class="text-gray-300">App. — Applicable</p>

    <p class="text-gray-300">Table 2. Comparison of the Various Modes of Iteration</p>

    <p class="text-gray-300">structure (when adding at the end of the diamond structure an expandable message to compensate for the different possible locations). Thus, RMC and ROX are almost as secure against the herding attack as HAIFA hash function can achieve.</p>

    <p class="text-gray-300">While the wide-pipe offers better security against attacks based on internal collision, such a hash function requires an additional memory to achieve this security. In HAIFA, the only additional parameter which has to be stored is the salt (the #bits parameter is stored for the Merkle-Damgård strengthening anyway). Thus, to ensure the security of a HAIFA construction against the herding attack, a salt of size  <span class="math">m / 2</span>  is sufficient, while to achieve the same goal in the wide-pipe strategy, one needs to increase the internal state by a factor of 2. Thus, while the internal memory of a wide-pipe is  <span class="math">2m</span> , in HAIFA a  <span class="math">1.5m</span>  bits of memory are sufficient.</p>

    <p class="text-gray-300">Moreover, in the case of a salt, its effect on the compression function can be relatively mild and scarce (e.g., mixed every few rounds if the designer so chooses), while in the wide-pipe strategy, insufficient mixing of the additional state is a security hazard. Hence, the additional performance load and the more complex hash functions of the wide-pipe strategy might not be suitable for constrained applications.</p>

    <p class="text-gray-300">In Table 2 we summarize these results.</p>

    <p class="text-gray-300">In this paper we have presented HAIFA as a replacement for the Merkle-Damgård construction. The main differences are the addition of the number of bits hashed so far to the compression function along with a salt value. In cases where there is no need to add salt (e.g., message authentication codes) it is possible to set its value to 0.</p>

    <p class="text-gray-300">We note that even today's compression functions can be used in HAIFA hash functions by changing the API of such compression functions. For example, by setting in SHA-1 64 bits (out of the 512 bits of each block) to represent the number of bits hashed so far, and 64 bits to represent the salt, the new compression function would hash 384 bits per call of the compression function.</p>

    <p class="text-gray-300">This increases the computational effort of hashing long messages by a factor of about 4/3, but at the same time provides security against various attacks. New hash functions are expected to mix the salt and the number of bits much more efficiently.</p>

    <p class="text-gray-300">We showed that the API of the HAIFA framework is sufficient to support recently proposed modes of operation. This shows that the interface suggested by HAIFA is sufficient for any modern hash function design, and thus we suggest that the new hash function designers should support the API of HAIFA. In case they wish to achieve some specific security property, they can choose a compression function with properties which make HAIFA meet the requirements.</p>

    <p class="text-gray-300">Finally, we recommend that new hash functions should be designed under the HAsh Iterative FrAmework.</p>

    <h2 id="sec-21" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors wish to thank William Speirs and Praveen Gauravaram for pointing out typos in previous versions of this paper.</p>

    <h2 id="sec-22" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Elena Andreeva, Gregory Neven, Bart Preneel, Thomas Shrimpton, <em>Seven-Properties-Preserving Iterated Hashing: The RMC Construction</em>, ECRYPT document STVL4-KUL15-RMC-1.0, private communications, 2006.</li>

      <li>[2] Elena Andreeva, Gregory Neven, Bart Preneel, Thomas Shrimpton, <em>Seven-Properties-Preserving Iterated Hashing: ROX</em>, ECRYPT document STVL4-KUL15-ROX-2.0, private communications, 2007.</li>

      <li>[3] Mihir Bellare, Thomas Ristenpart, <em>Multi-Property-Preserving Hash Domain Extension: The EMD Transform</em>, NIST 2nd hash function workshop, Santa Barbara, August 2006.</li>

      <li>[4] Mihir Bellare, Philip Rogaway, <em>Collision-resistant hashing: Towards making UOWHFs practical</em>, dvances in Cryptology, proceedings of CRYPTO 1997, Lecture Notes in Computer Science 1294, pp. 470–484, Springer-Verlag, 1997.</li>

      <li>[5] Eli Biham, Rafi Chen, <em>Near-Collisions of SHA-0</em>, Advances in Cryptology, proceedings of CRYPTO 2004, Lecture Notes in Computer Science 3152, pp. 290–305, Springer-Verlag, 2004.</li>

      <li>[6] Eli Biham, Rafi Chen, Antoine Joux, Patrick Carribault, Christophe Lemuet, William Jalby, <em>Collisions of SHA-0 and Reduced SHA-1</em>, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3621, pp. 36–57, 2005.</li>

      <li>[7] Eli Biham, Orr Dunkelman, <em>A Framework for Iterative Hash Functions — HAIFA</em>, NIST 2nd hash function workshop, Santa Barbara, August 2006.</li>

      <li>[8] Florent Chabaud, Antoine Joux, <em>Differential Collisions in SHA-0</em>, Advances in Cryptology, proceedings of CRYPTO 1998, Lecture Notes in Computer Science 1462, pp. 56–71, Springer-Verlag, 1998.</li>

      <li>[9] Ivan Damgård, <em>A Design Principle for Hash Functions</em>, Advances in Cryptology, proceedings of CRYPTO 1989, Lecture Notes in Computer Science 435, pp. 416–427, Springer-Verlag, 1990.</li>

      <li>[</li>

    </ul>

    <p class="text-gray-300">10] Richard D. Dean, <em>Formal Aspects of Mobile Code Security.</em>, Ph.D. dissertation, Princeton University, 1999.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[11] Shai Halevei, Hugo Krawczyk, <em>Strengthening Digital Signatures via Randomized Hashing</em>, Advances in Cryptology, proceedings of CRYPTO 2006, Lecture Notes in Computer Science 4117, pp. 41–59, Springer-Verlag, 2006.</li>

      <li>[12] Jonathan J. Hoch, Adi Shamir, <em>Breaking the ICE — Finding Multicollisions in Iterated Concatenated and Expanded (ICE) Hash Functions</em>, preproceedings of Fast Software Encryption 2006, pp. 199–214, 2006.</li>

      <li>[13] Antoine Joux, <em>Multicollisions in Iterated Hash Functions</em>, Advances in Cryptology, proceedings of CRYPTO 2004, Lecture Notes in Computer Science 3152, pp. 306–316, Springer-Verlag, 2004.</li>

      <li>[14] John Kelsey, Tadayoshi Kohno, <em>Herding Hash Functions and the Nostradamus Attack</em>, preproceedings of Cryptographic Hash Workshop, held in NIST, Gaithersburg, Maryland, 2005.</li>

      <li>[15] John Kelsey, Bruce Schneier, <em>Second Preimages on n-Bit Hash Functions for Much Less than <span class="math">2^{n}</span></em>, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 474–490, Springer-Verlag, 2005.</li>

      <li>[16] Stefan Lucks, <em>A Failure-Friendly Design Principle for Hash Functions</em>, Advances in Cryptology, proceedings of ASIACRYPT 2005, Lecture Notes in Computer Science 3788, pp. 474–494, Springer-Verlag, 2005.</li>

      <li>[17] Ralph C. Merkle, <em>Secrecy, Authentication, and Public Key Systems</em>, UMI Research press, 1982.</li>

      <li>[18] Ralph C. Merkle, <em>One Way Hash Functions and DES</em>, Advances in Cryptology, proceedings of CRYPTO 1989, Lecture Notes in Computer Science 435, pp. 428–446, Springer-Verlag, 1990.</li>

      <li>[19] Phillip Rogaway, Thomas Shrimpton, <em>Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision Resistance</em>, proceedings of Fast Software Encryption 2004, Lecture Notes in Computer Science 3017, pp. 371–388, Springer-Verlag, 2004.</li>

      <li>[20] US National Bureau of Standards, <em>Secure Hash Standard</em>, Federal Information Processing Standards Publications No. 180-2, 2002.</li>

      <li>[21] Xiaoyun Wang, Xuejia Lai, Dengguo Feng, Hui Chen, Xiuyuan Yu, <em>Cryptanalysis of the Hash Functions MD4 and RIPEMD</em>, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 1–18, 2005.</li>

      <li>[22] Xiaoyun Wang, Yiqun Lisa Yin, Hongbo Yu, <em>Finding Collisions in the Full SHA-1</em>, Advances in Cryptology, proceedings of CRYPTO 2005, Lecture Notes in Computer Science 3621, pp. 17–36, 2005.</li>

      <li>[23] Xiaoyun Wang, Hongbo Yu, <em>How to Break MD5 and Other Hash Functions</em>, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 19–35, 2005.</li>

      <li>[24] Xiaoyun Wang, Hongbo Yu, Yiqun Lisa Yin, <em>Efficient Collision Search Attacks on SHA-0</em>, Advances in Cryptology, proceedings of CRYPTO 2005, Lecture Notes in Computer Science 3621, pp. 1–16, 2005.</li>

      <li>[25] Gideon Yuval, <em>How to Swindle Rabin</em>, Cryptologia, Vol. 3, pp. 187–190, 1979.</li>

    </ul>

    <h2 id="sec-23" class="text-2xl font-bold">Appendix A Identifying the Last Block in HAIFA</h2>

    <p class="text-gray-300">Some of our reductions are based on the fact that the last block is easily identified by the compression function itself. This can be done by the compression function</p>

    <p class="text-gray-300">by using the inputs in the following manner: In case (<span class="math">\\#bits\\bmod n)&lt;n-(t+r)</span> and <span class="math">\\#bits&gt;0</span>, then this is the last message block, and no full padding block is added. Otherwise, there are two options: <span class="math">\\#bits\\neq 0\\bmod n</span>, which means that a full padding block with <span class="math">\\#bits=0</span> is coming just after it, and <span class="math">\\#bits=0\\bmod n</span>. The latter case covers the following possible events:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This is an intermediate block of the message.</li>

      <li>This is a call to the compression function during the computation of <span class="math">IV_{m}</span>.</li>

      <li>This is a call to the compression function for a full padding block.</li>

    </ul>

    <p class="text-gray-300">The first case is easy to identify, by <span class="math">\\#bits&gt;0</span>. In this case, this is not the actual last block that is compressed.</p>

    <p class="text-gray-300">For the remaining cases, <span class="math">\\#bits=0</span>. If the call is during the computation of <span class="math">IV_{m}</span>, then the last <span class="math">r</span> bits of the message block are <span class="math">0</span>. Otherwise, i.e., this is a full padding block, it has one of two forms <span class="math">10^{n-r-t-1}\\text{encode}_{t}(\\text{length})\\text{encode}_{r}(m)</span> or <span class="math">0^{n-r-t}\\text{encode}_{t}(\\text{length})\\text{encode}_{r}(m)</span> where <span class="math">\\text{length}</span> is the length of the message.</p>

    <p class="text-gray-300">We conclude that all these options lead to the following algorithm to determine whether this is the last message block (or whether this is the computation of <span class="math">IV_{m}</span>):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\#bits\\neq 0\\bmod n</span> return “Last block”.</li>

      <li>If <span class="math">\\#bits=0</span> and the <span class="math">r</span> last bits of <span class="math">M_{i}</span> are equal to <span class="math">0</span>, return “Computation of <span class="math">IV_{m}</span>”.</li>

      <li>If <span class="math">\\#bits=0</span> and the <span class="math">r</span> last bits of <span class="math">M_{i}</span> are not equal to <span class="math">0</span>, return “Last block”.</li>

      <li>Return “Not the last block”.</li>

    </ol>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="A Framework for Iterative Hash Functions - HAIFA (2007/278)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2007 &middot; eprint 2007/278
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
