---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2007/278';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'A Framework for Iterative Hash Functions - HAIFA';
const AUTHORS_HTML = 'Eli Biham, Orr Dunkelman';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Since the seminal works of Merkle and Damgard on the iteration of compression functions, hash functions were built from compression functions using the Merkle-Damgard construction. Recently, several flaws in this construction were identified, allowing for pre-image attacks and second pre-image attacks on such hash functions even when the underlying compression functions are secure.

In this paper we propose the HAsh Iterative FrAmework (HAIFA). Our framework can fix many of the flaws while supporting several additional properties such as defining families of hash functions and supporting variable hash size. HAIFA allows for an online computation  of the hash function in one pass with a fixed amount of memory independently of the size of the message.

Besides our proposal, the recent attacks initiated research on the way compression functions are to be iterated. We show that most recent proposals such as randomized hashing, the enveloped Merkle-Damgard, and the RMC and ROX modes can be all be instantiated as part of the HAsh Iterative FrAmework (HAIFA).</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Merkle-Damgard &middot; randomized hashing &middot; Enveloped Merkle-Damgard &middot; RMC &middot; ROX &middot; Wide pipe &middot; HAIFA</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Cryptographic hash functions play an increasingly important role in cryptography. Many primitives and protocols rely on the existence of secure cryptographic</p>

    <p class="text-gray-300"><sup>?</sup> An initial version of this work was presented in the hash function workshop in Krakow, June 2005 and in the second NIST hash function workshop 2006 in Santa Barbara, August 2006.</p>

    <p class="text-gray-300"><sup>??</sup> This work was supported in part by the Israel MOD Research and Technology Unit.</p>

    <p class="text-gray-300"><sup>? ? ?</sup> This work was supported in part by the Concerted Research Action (GOA) Ambiorics 2005/11 of the Flemish Government and by the IAP Programme P6/26 BCRYPT of the Belgian State (Belgian Science Policy).</p>

    <p class="text-gray-300">hash functions. Hash functions are usually constructed by means of iterating a cryptographic compression function, while trying to maintain the following three requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pre-image resistance: Given y = H(x) it is hard to find x 0 s.t. H(x 0 ) = y.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Second pre-image resistance: Given x it is hard to find x 0 s.t. H(x) = H(x 0 ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Collision resistance: It is hard to find x, x<sup>0</sup> s.t. H(x) = H(x 0 ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The most widely used mode of iteration is the Merkle-Damg&#730;ard construction [9, 17, 18]. The simple iteration method maintains the collision resistance of the compression function. The pre-image and second pre-image resistance of the compression function were also thought to be preserved in the Merkle-Damg&#730;ard construction. However, counter examples for these beliefs were suggested recently.</p>

    <p class="text-gray-300">The first evidence for this was by Dean [10] who showed that fix-points of the compression function can be used for a second pre-image attacks against long messages using O(m&middot;2 m/2 ) time and O(m&middot;2 m/2 ) memory (where m is the digest size). Later, Kelsey and Schneier have proposed the same ideas, while removing the assumption that fix-points can easily be found [15]. This improvement was achieved using Joux's multi-collision attack on iterated hash functions [13].</p>

    <p class="text-gray-300">The previous attacks have used very long messages. This led Kelsey and Kohno to show that using a simple pre-computation it is possible to reduce the time requirements of chosen target pre-image attacks<sup>1</sup> for relatively short messages [14]. The total time complexity of the attack is much below the expected O(2m).</p>

    <p class="text-gray-300">In this work we suggest the HAsh Iterative FrAmework (HAIFA) to replace the Merkle-Damg&#730;ard construction. HAIFA maintains the good properties of the Merkle-Damg&#730;ard construction while adding to the security of the transformation, as well as to the scalability of the transformation.</p>

    <p class="text-gray-300">HAIFA has several attractive properties: simplicity, maintaining the collision resistance of the compressions function, increasing the security of iterative hash functions against (second) pre-image attacks, and the prevention of easy-to-use fix-points of the compression function. HAIFA also supports variable hash size and has a built-in support for defining families of hash functions as part of the framework. HAIFA also posses the online hashing property of the Merkle-Damg&#730;ard construction. The computation of a HAIFA hash function requires one pass on the message, without keeping the entire message in memory, and while using a fixed amount of memory for the hashing of each block.</p>

    <p class="text-gray-300">Along with recent advances in finding collisions on wide spread hash functions from the MD family [5, 6, 21&ndash;24], this motivated many suggestions to strengthen hash functions and modes of iteration. These suggestions are either aimed at reducing the security requirements from the compression function [11] or at proposing a mechanism to securely iterate a compression function [1&ndash;3, 7].</p>

    <p class="text-gray-300"><sup>1</sup> The herding attack can be deployed in the following scenario: The attacker publishes in advance a digest value. Then, given a previously unknown message, the attacker finds a pre-image to the digest value that contains the unknown message.</p>

    <p class="text-gray-300">The randomized hashing scheme [11] proposed by Krawczyk and Halevi aims to reduce the requirements on the collision resistance of the compression function in a collision resistant hash function. By randomizing the actual inputs to the compression functions, the existence of a collision in the compression function can be masked. This change is mostly useful for digital signatures (preventing the attack scenario where the attacker finds two colliding messages and asks the victim to sign the first).</p>

    <p class="text-gray-300">The enveloped Merkle-Damg&#730;ard construction [3] was proposed by Bellare and Ristenpart as a method to maintain the collision resistance, the pseudorandom and the pseudorandom family properties of the compression function. This is very useful for constructions which require the pseudorandom properties of the hash function, e.g., in cases where the hash function is used in MACs.</p>

    <p class="text-gray-300">The last recent proposals for modes of iteration are the RMC [1] and ROX [2] by Andreeva et al. These two modes aim at preserving the collision resistance of the compression function, along with the second pre-image resistance (Sec) and the pre-image resistance (Pre), and their everywhere and always variants, aSec, eSec, aPre, and ePre.</p>

    <p class="text-gray-300">Besides suggesting modes of iteration for the compression functions, recent research also suggests using larger internal state [16]. The approach, named wide pipe, mitigate the flaws of iterated hashing by using a larger internal state than the output size. This approach leads to the fact that internal collisions, i.e., collisions in the chaining value, are eventually as hard as finding a pre-image of the hash function itself (assuming a good compression function is being used).</p>

    <p class="text-gray-300">After presenting HAIFA, we show that HAIFA can be used to instantiate any of these modes. Thus, a HAIFA compression function can easily be made to follow each of these suggestions according to the properties sought by the designer. For example, as a ROX hash function can be instantiated using the HAIFA framework, it is possible to construct a HAIFA hash function that maintains the (a/e)Sec and (a/e)Pre properties of the compression function.</p>

    <p class="text-gray-300">This paper is organized as follows: In Section 2 we describe the Merkle-Damg&#730;ard construction and various results regarding the construction. In Section 3 we propose HAIFA. We discuss the security aspects of HAIFA in Section 4. We show how to implement the randomized hashing scheme, the enveloped Merkle-Damg&#730;ard, and the RMC and ROX constructions using a HAIFA hash function in Section 5. We compare the above constructions with HAIFA in Section 6. Finally, Section 7 summarizes the paper.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 The Merkle-Damg&#730;ard Constructions and its Pitfalls</h2>

    <p class="text-gray-300">The Merkle-Damg&#730;ard construction is a simple and elegant way to transform a compression function CMD : {0, 1} <sup>m</sup><sup>c</sup> &times; {0, 1} <sup>n</sup> &rarr; {0, 1} m<sup>c</sup> into a hash function [9, 17, 18]. Throughout this paper m<sup>c</sup> denotes the size of the chaining value, and n denotes the block size for the compression function. We also denote by m the hash output length (in many cases m = mc).</p>

    <p class="text-gray-300">The message M is padded with its length (after additional padding to make the message a multiple of the block size n after the final padding), and the message is divided into blocks of n bits each, M = M1M2M<sup>3</sup> . . . Mk. An initial chaining value h<sup>0</sup> = IV &isin; {0, 1} m<sup>c</sup> is set for the hash function (also called initialization vector) and the following process is repeated k times:</p>

    <p class="text-gray-300"><span class="math">$h_i = C_{MD}(h_{i-1}, M_i)</span>$</p>

    <p class="text-gray-300">The final h<sup>k</sup> is outputted as the hash value, i.e., H(M) = hk.</p>

    <p class="text-gray-300">It is easy to prove that once a collision in the hash function H(&middot;) is found, then a collision of the compression function CMD(&middot;) is found as well [9, 17, 18]. Thus, the Merkle-Damg&#730;ard construction retains the collision resistance of the compression function.</p>

    <p class="text-gray-300">When from h<sup>i</sup> = CMD(hi&minus;1, Mi) and M<sup>i</sup> the value of hi&minus;<sup>1</sup> can be easily computed, a pre-image attack on H(&middot;) can be mounted using a birthday attack [25]. However, the opposite statement is not true. Even if an inversion attack on CMD(&middot;) requires O(2m) operations, the security claims for the hash function H(&middot;) cannot offer security better than O(2m/<sup>2</sup> ). This surprising property was first noted by Dean [10], which went unnoticed until rediscovered (and expanded) by Kelsey and Schneier [15].</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Fixed Points, Expandable Messages, and Finding Second Pre-Images</h3>

    <p class="text-gray-300">It was widely believed by the cryptographic community that the security proof of the Merkle-Damg&#730;ard construction applies also to second pre-image attacks. However, Dean [10] noticed that this is not true for long messages if the compression function has easy to find fix-points. His observations were later generalized by Kelsey and Schneier [15] that used the multi-collision technique to eliminate the need for easily found fix-points.</p>

    <p class="text-gray-300">Let us consider a long message M = M1M<sup>2</sup> . . . M<sup>l</sup> that is processed using H(&middot;), a Merkle-Damg&#730;ard hash function, when the message length is not padded (the Merkle-Damg&#730;ard strengthening). An attacker that wishes to construct a message M<sup>&lowast;</sup> such that H(M<sup>&lowast;</sup> ) = H(M) can randomly select messages M<sup>0</sup> until H(M<sup>0</sup> ) equals to any of the l chaining values found during the computation of H(M). Once such an instance is found, the attacker can concatenate to M<sup>0</sup> the message blocks of M that are hashed starting from the given chaining value, resulting with M<sup>&lowast;</sup> such that H(M<sup>&lowast;</sup> ) = H(M). This attack is foiled by the Merkle-Damg&#730;ard strengthening, as the message length which is appended to the message is expected to differ for M and M<sup>&lowast;</sup> .</p>

    <p class="text-gray-300">Assume that the compression function CMD is such that finding fix-points is easy, i.e., it is easy to find (h, M) satisfying h = CMD(h, M). This is the case for the Davies-Meyer construction that takes a block cipher E that accept mc-bit plaintexts and n-bit keys and sets</p>

    <p class="text-gray-300"><span class="math">$h_i = C_{MD}(h_{i-1}, M_i) = E_{M_i}(h_{i-1}) \\oplus h_{i-1}.</span>$</p>

    <p class="text-gray-300">For such a compression function it is easy to find fix-points by computing  <span class="math">h = E_M^{-1}(0)</span>  for randomly selected messages M.</p>

    <p class="text-gray-300">Dean uses these fix-points to bypass the Merkle-Damg&aring;rd strengthening. His attack has three main steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finding  <span class="math">O(2^{m_c/2})</span>  fix-points denoted by A = (h, m).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Selecting  <span class="math">O(2^{m_c/2})</span>  single blocks and computing their chaining value denoted by  <span class="math">B = (C_{MD}(IV, \\tilde{m}), \\tilde{m})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finding a collision between a chaining value and a fixed point, i.e., between chaining values in A and in B. Let the colliding chaining be h, and denote the corresponding message block (found in A) by m, i.e.,  <span class="math">(h,m) \\in A</span> , and denote the message block associated with h in B by  <span class="math">\\tilde{m}</span> , i.e.,  <span class="math">(h,\\tilde{m}) \\in B</span> . The attacker repeats the previous attack starting from the message  <span class="math">\\tilde{m}||m</span>  (i.e., trying to add blocks that cause the same chaining values as the original message) and fixes the length by iterating the fixed point as many times as needed.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Once such a message is found, it is easy to expand the number of blocks in the message to the appropriate length by repeating the fix-points as many times as needed.</p>

    <p class="text-gray-300">Kelsey and Schneier transformed the attack to the case where fix-points are not easily found. While Dean's expandable message could be extended by a repetition of a single block, in their attack they use the multi-collision technique to produce an expandable message. They replace the first two steps in Dean's attack in the following procedure. In each iteration  <span class="math">1 \\le i \\le t</span>  of the procedure a collision between a one block message and a  <span class="math">2^{i-1} + 1</span>  block message is found. This procedure finds a chaining value that can be reached by messages of lengths between t and  <span class="math">2^{t+1} + t - 1</span>  blocks. Then, from this chaining value the third step of Dean's attack is executed, and the length of the found message is controlled by the expandable prefix.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Multi-Collisions in Iterative Hash Functions</h3>

    <p class="text-gray-300">Joux identified the fact that when iterative hash functions are used, finding multi-collisions, i.e., a set of messages with the same hash value, is almost as easy as finding a single collision [13]. His main observation is the fact that in iterative hashing schemes, such as the Merkle-Damg&aring;rd, it impossible to find a collision for each block, e.g., for any  <span class="math">h_{i-1}</span>  finding  <span class="math">M_i</span>  and  <span class="math">M_i^*</span>  such that  <span class="math">C_{MD}(h_{i-1}, M_i) = C_{MD}(h_{i-1}, M_i^*)</span> . Finding t such one block collision (each starting from the chaining value produced by the previous block collision) it is possible to construct  <span class="math">2^t</span>  messages with the same hash value by selecting for ith block of the message either  <span class="math">M_i</span>  or  <span class="math">M_i^*</span> .</p>

    <p class="text-gray-300">Joux also observed that the concatenation of two hash functions, i.e.,  <span class="math">H(x) = H_1(x)||H_2(x)</span> , is not more secure against collision attacks than the stronger of the two underlying hash functions. Moreover, concatenation of several iterative hash functions is as secure as the stronger of the hash functions (up to some a factor of  <span class="math">m^{k-1}</span> , where k is the number of hash functions).</p>

    <p class="text-gray-300">It is worth mentioning that using fix-points of several blocks, Joux proved that the concatenation of hash functions is as secure against pre-image attacks as the strongest of all the hash functions. These results have disproved several widely believed assumptions on the behavior of hash functions.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Herding Iterative Hash Functions</h3>

    <p class="text-gray-300">Kelsey and Kohno have observed that it is possible to perform a time-memory tradeoff for several instances of pre-image attacks [14]. In their attack, an attacker commits to a public digest value that corresponds to some meaningful message, e.g., prediction of the outcome of NIST's hash function competition. After the announcement of the result, the attacker publishes a message that has the pre-published digest value and contains the correct information along with some suffix.</p>

    <p class="text-gray-300">The attack is based on selecting the digest value carefully, helping the attacker to perform a pre-image attack on this value. In the pre-computation phase, the attacker starts with 2<sup>t</sup> possible chaining values h<sup>i</sup> (these values can either be randomly selected or fixed in advance). The attacker then chooses O(2mc/2&minus;t/<sup>2</sup> ) single blocks, and for each chaining value and each block computes the output of the compression function given this input. The large amount of generated chaining values is expected to generate collisions. More precisely, it is expected that for each starting chaining value there is another chaining value, such that they are compressed to the same chaining value (not necessarily under the same message block). For each chaining value the attacker stores the message block that causes a collision in the table, and repeats the above process with the newly found chaining values. Once the attacker has only one chaining value, it is used to compute the digest value to be published (maybe after padding or some other message extension).</p>

    <p class="text-gray-300">In the online phase of the attack, the attacker needs to perform only O(2mc&minus;<sup>t</sup> ) operations until a message whose chaining value is among the 2<sup>t</sup> original values is found. Once such a message is found, the attacker can retrieve from the stored date the message blocks that would lead to the designated digest.</p>

    <p class="text-gray-300">We note that unlike the previous attacks that require long messages, this attack appends relatively short suffix (about t blocks) to the &quot;real&quot; message. We also note, that the total time complexity of the attack is about O(2mc/2+t/<sup>2</sup> ) off-line operations for the first step of the attack and O(2mc&minus;<sup>t</sup> ) online operations for the second step. For t = mc/3 the overall time complexity of this attack is O(22mc/<sup>3</sup> ) for finding a pre-image.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 The HAsh Iterative FrAmework (HAIFA)</h2>

    <p class="text-gray-300">We propose the HAsh Iterative FrAmework to solve many of the pitfalls of the Merkle-Damg&#730;ard construction. The main ideas behind HAIFA are the introduction of number of bits that were hashed so far and a salt value into the compression functions. Formally, instead of using a compression function of the form  <span class="math">C_{MD}: \\{0,1\\}^{m_c} \\times \\{0,1\\}^n \\to \\{0,1\\}^{m_c}</span> , we propose to use  <span class="math">C: \\{0,1\\}^{m_c} \\times \\{0,1\\}^n \\times \\{0,1\\}^b \\times \\{0,1\\}^s \\to \\{0,1\\}^{m_c}</span> , i.e., in HAIFA the chaining value  <span class="math">h_i</span>  is computed as</p>

    <p class="text-gray-300"><span class="math">$h_i = C(h_{i-1}, M_i, \\#bits, salt),</span>$</p>

    <p class="text-gray-300">where #bits is the number of bits hashed so far and salt is a salt value.</p>

    <p class="text-gray-300">Thus, to hash a message M using  <span class="math">C(\\cdot)</span>  and the salt salt and obtaining m bits of digest value (as long as  <span class="math">m \\le m_c</span> ), the following operations are performed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad M according to the padding scheme described in Section 3.1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">IV_m</span>  the initial value for a digest of size m using the prescribed way in Section 3.2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Iteratively digest the padded message using  <span class="math">C(\\cdot)</span> , starting from the initial value  <span class="math">IV_m</span>  and using the salt. We note that in case an additional block is padded to the message, the compression function is called on this block with #bits = 0.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Truncate the final chaining value if needed (see Section 3.2).</li>
    </ol></li>
    </ul>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 The Padding Scheme</h3>

    <p class="text-gray-300">The padding scheme used in HAIFA is very similar to the one used in the Merkle-Damg&aring;rd construction: In HAIFA the message is padded with 1, as many needed 0's, the length of the message encoded in a fixed number of bits, and the digest size:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad a single bit of 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad as many 0 bits as needed such that the length of the padded message (with the 1 bit and the 0's) is congruent modulo n to (n (t + r)).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad the message length encoded in t bits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad the digest size encoded in r bits.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Adding the digest size ensures that even if two messages  <span class="math">M_1</span>  and  <span class="math">M_2</span>  are found, such that under  <span class="math">IV_{l_1}</span>  and  <span class="math">IV_{l_2}</span>  ( <span class="math">M_1</span>  hashed to obtain  <span class="math">l_1</span>  bits and  <span class="math">M_2</span>  hashed to a digest of  <span class="math">l_2</span>  bits) their chaining values collide, then the last block changes this behavior. This approach is similar to the one used in the Merkle-Damg&aring;rd strengthening, even though it deals with a scenario of variable output sizes.</p>

    <p class="text-gray-300">We note that when a full padding block is added for the hashing (i.e., the full original message was already processed by the previous calls to the compression function, and the full message size was already input to the previous call), the compression function is called with the number of bits hashed so far set to zero. This allows for the compression function to identify whether this is the last block and moreover, whether this is a full padding block. It is easy to see that when the number of bits hashed so far is not a multiple of the block length, then this is certainly the last block (and the question whether there is a full padding block can be easily deduced from the length of the message). We note that for the null</p>

    <p class="text-gray-300">string there is a padding of a full padding block anyway. Appendix A contains the exact algorithm for finding the last block of the message.</p>

    <p class="text-gray-300">The security is not affected by this method, as the length of the message is necessarily embedded in the full padding block, and was already input to the previous call to the compression function.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Variable Hash Size</h3>

    <p class="text-gray-300">Different digest sizes are needed for different applications. This fact has motivated NIST to publish SHA-224 and SHA-384 as truncated variants of SHA-256 and SHA-512, respectively. We note that these truncated hash functions use the same construction, but with different initial values.</p>

    <p class="text-gray-300">Our framework supports truncation that allows arbitrary digest sizes (up to the output size of the compression function), while securing the construction against attacks that try to find two messages that have similar digest values. This problem eliminates the easy solution of just taking the number of output bits from the output of the compression function.</p>

    <p class="text-gray-300">Let IV be an initial value chosen by the designer of the compression function, and let m be the required length of the output. For producing hash values of m bits the following initial value is computed<sup>2</sup></p>

    <p class="text-gray-300"><span class="math">$IV_m = C(IV, m, 0, 0).</span>$</p>

    <p class="text-gray-300">The value m is encoded in the first r bits, followed by a single bit 1, and n&minus;r&minus;1 0's. In other words, m is found in the first r bits of the block. We note that even though #bits = 0, this call is distinct from all other calls to the compression function. This is due to the fact that the only other call to the compression function with #bits = 0 is in the case of using an additional padding block, for which the message block is either all 0's or a 1 followed by as many 0's as needed, whereas in this case the message block contains the encoding of m.</p>

    <p class="text-gray-300">After the final block is processed, the digest is composed of the m first bits of ht, where h<sup>t</sup> is the last chaining value. We advise implementors to make sure that these m bits are the most diffused bits of the chaining value.</p>

    <p class="text-gray-300">This suggestion allows for supporting various digest lengths in a simple and straightforward way. An implementation of a HAIFA-based hash function requires only the value of IV for the ability to produce any hash length, while in implementations where only a single output length l is needed, IV<sup>l</sup> can be precomputed and hardcoded into the implementation.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 The Security of HAIFA Hash Functions</h2>

    <p class="text-gray-300">We first note that proving the HAIFA hash function is collision resistant if the underlying compression function is collision resistant is quite easy. The same arguments that are used to prove that the Merkle-Damg&#730;ard construction retains</p>

    <p class="text-gray-300"><sup>2</sup> We alert the reader that in [7] a typo suggested that IV<sup>m</sup> = C(m, IV, 0, 0).</p>

    <p class="text-gray-300">the collision resistance of the underlying compression function, can be used to prove that HAIFA does so as well. We consider the strongest definition of a collision in the compression function where the attacker has a control over all input parameters to the compression function and tries to generate the same output. Let  <span class="math">M_1</span>  and  <span class="math">M_2</span>  be the two colliding messages with respective lengths  <span class="math">l_1</span>  and  <span class="math">l_2</span> . If  <span class="math">l_1</span>  and  <span class="math">l_2</span>  are different, then the paddings are necessarily different (due to the different length), and a collision in the compression function is found. If the lengths of the messages are the same, one can start from the joint digest and trace backwards till the point where the inputs to the compression function differ. For example, if the messages are hashed with a different salt, then the last block is necessarily a collision. Otherwise, both messages were hashed with the same salt and have the same length (and thus have the same #bits in each call to the compression function), and the same argument as the one for the Merkle-Damg&aring;rd mode shows that there must exist a message block i such that  <span class="math">M_i^1 \\neq M_i^2</span>  or  <span class="math">h_{i-1}^1 \\neq h_{i-1}^2</span>  (where the superscript denotes the corresponding message), for which  <span class="math">C(h_{i-1}^1, M_1^i, s, i \\cdot n) = C(h_{i-1}^2, M_2^i, s, i \\cdot n)</span> .</p>

    <p class="text-gray-300">We note that any iterative construction can be attacked by some of the attacks described in Section 2. However, as noted before, using our ideas, it is possible to reduce the applicability of these attacks, by preventing an efficient pre-computation that reduces the online computational phase of these attacks.</p>

    <p class="text-gray-300">We continue by first discussing some of the security reasons behind the added parameters to the compression function. Then we analyze the general security feature of a HAIFA hash function.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Number of Bits Hashed so Far</h3>

    <p class="text-gray-300">The inclusion of the number of bits hashed so far was suggested (with small variants) in order to prevent the easy exploitation of fix-points. The attacker is forced to work harder in order to find fix-points. While for  <span class="math">C_{MD}</span> , once a fix-point (h, M) such that  <span class="math">h = C_{MD}(h, M)</span>  is found, it can be used as many times as the attacker sees fit [10, 15]. Even if the compression function does not mix the #bits parameter well, once an attacker finds a fix-point of the form (h, M, #bits, salt) such that h = C(h, M, #bits, salt), she cannot concatenate it to itself as many times as she wishes because the number of bits hashed so far has changed.</p>

    <p class="text-gray-300">We note that it is possible to use the number of blocks that were treated so far instead. However, current schemes keep track of the number of bits hashed so far which is used for for the padding, rather than the number of blocks. Thus, it is easier for implementations to consider only one parameter (number of bits) rather two (somewhat related) parameters (number of bits and number of blocks).</p>

    <p class="text-gray-300">It is interesting to consider message authentication codes based on the following HAIFA hash function  <span class="math">H(\\cdot)</span> :  <span class="math">MAC_k(M) = H(k, M)</span> . While for a Merkle-Damg&aring;rd construction or suggestions that use the number of blocks hashed so far, this suggestion is clearly not secure against message expansion techniques, for HAIFA this construction is secure. The reason for that is that the last block (or the one before it, in case an additional padding block is added) is compressed</p>

    <p class="text-gray-300">with the number of bits that were processed so far. If this value is not a multiple of a block, then the resulting digest does not equal the chaining value that is needed to the expansion of the message. If the message is a multiple of a block, then an additional block is hashed (with the parameter #bits set to 0). Thus, the chaining value required for the expansion remains obscure to the attacker.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Salt</h3>

    <p class="text-gray-300">The salt parameter can be considered as defining a family of hash functions as needed by the formal definitions of [19] in order to ensure the security of the family of hash functions. This parameter can be viewed as an instance of the randomized hashing concept, thus, inheriting all the &quot;goodies&quot; such concept provides:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ability to define the security of the hash function in the theoretical model.</li>
      <li>Transformation of all attacks on the hash function that can use precomputation from an off-line part and an on-line part to only on-line parts (as the exact salt is not known in advance).</li>
      <li>Increasing the security of digital signatures, as the signer chooses the salt value, and thus, any attack aiming at finding two messages with the same hash value has to take the salt into consideration.</li>
    </ul>

    <p class="text-gray-300">We note that the salt can be application specific (e.g., a string identifying the application), a serial number that follows the application (e.g., the serial number of the message signed), a counter, or a random string. It is obvious that s can also be set as a combination of these values.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Security against the Multi-Collision Attack</h3>

    <p class="text-gray-300">Let us consider the multi-collision attack. This attack works against all iterative hashing schemes, independent of their structure. While the time complexity for finding collisions for each block is not different in our framework than in the Merkle-Damg&#730;ard construction, an attacker cannot pre-compute these multicollisions before the choosing of the salt value.</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Preventing Attacks Based on Fix-Points</h3>

    <p class="text-gray-300">As noted before, our framework prevents Dean's attack, as it is highly unlikely that some fix-point of the compression function can be repeated. We note that the existence of an additional random input is not sufficient to ensure security against this kind of attacks. For example, when considering the randomized hashing modes proposed in [11] it is evident that this attack still applies to them. Dean's attack can be easily applied to the randomized Merkle-Damg&#730;ard constructions Hr(M) = H(M &oplus; (r|r|r . . . |r)) and H&tilde; <sup>r</sup>(M) = Hr(0|M), as once a fix-point is found, it remains a fix-point for these constructions. We note that the first two steps of Dean's attack can be mounted off-line just as in Dean's attack on regular Merkle-Damg&#730;ard hash functions for these two constructions.</p>

    <p class="text-gray-300">As for Kelsey and Schneier's attack, just like in Joux's multi-collision attack, the attacker has to know the value of the salt before being able to generate the expandable message. Thus, an attacker who tries to generate a second preimage, has to wait till the original message and salt are provided (or generate an expandable message for each and every possible salt).</p>

    <p class="text-gray-300">We conclude by noting that like in Joux's multi-collision attack, once the attacker is given the salt, the attacker can repeat the Kelsey and Schneier attack.</p>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">4.5 Mitigating the Herding Attack</h3>

    <p class="text-gray-300">Under HAIFA, the precomputation phase of the herding attack is infeasible without the knowledge of the salt that is used. We note that if a security of O(2m) against pre-image attacks such as the herding attack is requested, then the size of the salt must be at least mc/2 bits long, in order to prevent the herding attack. We also note that when the attacker is the one choosing the salt, then the herding attack cannot be avoided, but due to the #bits parameters, the attacker can mount the attack starting from one specific point (rather than moving the diamond structure around and compensating using an expandable message after the diamond structure).</p>

    <p class="text-gray-300">We note that if the length of the salt is short, then an attacker can still use precomputation to overcome the security proposed by HAIFA. It is therefore recommended that the salt length would be of 64 bits at least, or at least mc/2 bits when possible.</p>

      <h3 id="sec-4.6" class="text-xl font-semibold mt-8">4.6 Final Notes about the Security of HAIFA</h3>

    <p class="text-gray-300">The approach of increasing the chaining value was promoted in [16] and it may seem that our suggestion supports this approach. However, the analysis in [16] assumes that the hash function is a &quot;good&quot; hash function for all the bits of the chaining value, and the compression function does not accept the additional inputs that HAIFA support. Therefore, a large increase in m<sup>c</sup> is needed (typically, doubling the size). In our approach the salt and #bits parameters are treated separately from the chaining value, and allow us to protect from the weakness of a short chaining value without doubling the size of the chaining values. Thus, it is expected that HAIFA hash functions will be faster than wide hash constructions.</p>

    <p class="text-gray-300">We conclude that the security of a Merkle-Damg&#730;ard hash function against a pre-image attacks is equivalent to its security against collision attacks. For HAIFA this is not the case, as we have shown earlier. We give the security level of an ideal hash function and of the Merkle-Damg&#730;ard and HAIFA constructions (under two cases &mdash; with a variable salt, and with a fixed salt) in Table 1.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Modeling Other Constructions in HAIFA</h2>

    <p class="text-gray-300">In this section we show that recent proposals for modes of iteration can be viewed as an instance of HAIFA. This shows that the interface proposed by HAIFA is robust enough for any of the possible proposals for modes of iteration.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Type of Attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ideal Hash</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">MD</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">HAIFA HAIFA</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">fixed salt</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">with (distinct) salts</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Preimage</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">One-of-many pre-image</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k&#x27;</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k&#x27;</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k&#x27;</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(k&#x27; &lt; 2^s \\text{ targets})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Second-pre-image</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(k  blocks)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">One-of-many second</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k&#x27;</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}/k&#x27;</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pre-image(k blocks in</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">total, <span class="math">k&#x27; &lt; 2^s</span> messages</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Collision</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c/2}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi-collision <span class="math">(k</span> -collision)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{m_c(k-1)/k}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil \\log_2 k \\rceil 2^{m_c/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil \\log_2 k \\rceil 2^{m_c/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil \\log_2 k \\rceil 2^{m_c/2}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Herding [14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Offline: <span class="math">2^{m_c/2+t/2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Offline: <span class="math">2^{m_c/2+t/2}</span> Offline: <span class="math">2^{m_c/2+t/2+s}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Online: <span class="math">2^{m_c-t}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Online: <span class="math">2^{m_c-t}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Online: <span class="math">2^{m_c-t}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">The figures are given for MD and HAIFA hash functions that use an ideal compression function.</p>

    <p class="text-gray-300"><strong>Table 1.</strong> Complexities of Attacks on Merkle-Damg&aring;rd and HAIFA Hash Functions with Comparison for an Ideal Hash Function</p>

    <p class="text-gray-300">We note that in these constructions the padding schemes are not compatible with the added digest size to the padding. This can be solved easily during the identification of the last block by removing it in the compression function. We also note that in the following constructions, HAIFA's padding scheme does not affect any of the security properties of the hash functions.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Randomized Hashing</h3>

    <p class="text-gray-300">The main purpose of randomized hashing is to reduce the level of requirements from the compression function in order to achieve a collision-resistant hash function [11]. The randomized hashing is especially useful for digital signatures, where the collision resistance is the most important requirement from the hash function. In order to achieve these properties the following two constructions were suggested:</p>

    <p class="text-gray-300"><span class="math">$H_r(M_1||M_2||\\dots||M_k) \\stackrel{def}{=} H(M_1 \\oplus r||M_2 \\oplus r||\\dots||M_k \\oplus r)</span>$
<span class="math">$\\tilde{H}_r(M) \\stackrel{def}{=} H_r(0||M) = H(r||M_1 \\oplus r||M_2 \\oplus r||\\dots||M_k \\oplus r)</span>$</p>

    <p class="text-gray-300">where H is a Merkle-Damg&aring;rd hash function.</p>

    <p class="text-gray-300">It is easy to see that by setting the salt to s=r and ignoring the input of number of bits, we can instantiate a randomized hashing scheme in a HAIFA compression function. Let  <span class="math">C_{MD}</span>  be the compression function used in the randomized hashing, thus we set:</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA1}(h_{i-1}, M_i, \\#bits, s) = C_{MD}(h_{i-1}, M_i \\oplus s),</span>$</p>

    <p class="text-gray-300">which would result in an implementation of  <span class="math">H_r</span> , i.e.,  <span class="math">HAIFA^{C_{HAIFA1}} = H_r^{C_{MD}}</span> . To implement  <span class="math">\\tilde{H}_r</span> , we use a slightly modified construction:</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA2}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C_{MD}(C_{MD}(h_{i-1}, s), M_i \\oplus s) &amp; \\text{If } 0 &lt; \\#bits \\leq n \\\\ C_{MD}(h_{i-1}, M_i \\oplus s) &amp; \\text{Otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">It is easy to see that for any non-empty message, the first block is hashed only after the random value is hashed. For the empty message (null string) the computed hash is  <span class="math">C_{MD}(IV,s)</span>  which is the value that would have been computed for  <span class="math">\\tilde{H}_r(\\cdot)</span> . We conclude that  <span class="math">HAIFA^{C_{HAIFA2}} = \\tilde{H}_r^{C_{MD}}</span> .</p>

    <p class="text-gray-300">Note that in both cases, if the variable message length feature is not wanted it can be ignored by letting  <span class="math">h_i = C(h_{i-1}, M_i, \\#bits, s) = h_{i-1}</span>  if the following conditions hold: #bits = 0, the field that contains the digest size in the padding is set to 0.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Enveloped Merkle-Damg&aring;rd</h3>

    <p class="text-gray-300">The Enveloped Merkle-Damg&aring;rd [3] is a proposal for a mode of iteration that preserves the following three properties: collision resistance, pseudorandom oracle, and pseudorandom family. In order to achieve this, the Merkle-Damg&aring;rd construction is altered in the following manner:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The padding scheme pads the message with 1, as many 0's as requires, and the message length, such that the padded message,  <span class="math">PAD_{EMD}(M)</span>  has a length which equals to  <span class="math">n m_c \\mod n</span> .</li>
      <li>The final digest value is computed as</li>
    </ul>

    <p class="text-gray-300"><span class="math">$h_k = C_{MD}(IV_2, h_{k-1}||M_k),</span>$</p>

    <p class="text-gray-300">for a second initialization vector  <span class="math">IV_2</span> .</p>

    <p class="text-gray-300">Let  <span class="math">C_{MD}</span>  be the compression function used for the enveloped Merkle-Damg&aring;rd, and let  <span class="math">C_{HAIFA3}</span>  be defined as:</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA3}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C_{MD}(IV_2, h_{i-1}||fix\\_pad(M_i)) &amp; \\text{Last block} \\\\ C_{MD}(h_{i-1}, M_i) &amp; \\text{Otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">As noted earlier, identifying the last block is a trivial operation in HAIFA. Thus, it is easy to see that  <span class="math">HAIFA^{C_{HAIFA3}} = EMD^{C_{MD}}</span> , i.e., the suggested HAIFA hash function is equivalent to the enveloped Merkle-Damg&aring;rd one.</p>

    <p class="text-gray-300">As the padding scheme used in the enveloped Merkle-Damg&aring;rd scheme is slightly different than the one used in HAIFA. Fixing the padding in the last block  <span class="math">fix_-pad(\\cdot)</span>  can be done as the HAIFA padding can be easily shortened. When the first  <span class="math">m_c</span>  zero bits of the padding (assuming  <span class="math">m_c &lt; n</span> ) can be removed in the last block, then the operation is straightforward. If there are not sufficiently such bits, then a full padding block would have been needed in the enveloped Merkle-Damg&aring;rd, and the generation of the correct full padding block can be done in the compression function.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 RMC and ROX</h3>

    <p class="text-gray-300">The RMC [1] construction suggests a method to preserve seven properties of a compression function  <span class="math">C_{RMC}: \\{0,1\\}^{m_c} \\times \\{0,1\\}^n \\times \\{0,1\\}^k \\to \\{0,1\\}^{m_c}</span>  in the hash function  <span class="math">RMC^{RO_1,RO_2}: \\{0,1\\}^k \\times \\{0,1\\}^s \\times \\{0,1\\}^* \\to \\{0,1\\}^m</span> . The preserved properties are collision resistance, Second pre-image resistance, and pre-image resistance, along with their everywhere and always variants. The RMC construction maintains these properties by using the XOR-linear hash scheme [4]. The construction uses two random oracles (with fixed output length). The first random oracle  <span class="math">RO_1</span>  is used to produce strings which are XORed to the chaining values (just like in the XOR-linear scheme). The second random oracle  <span class="math">RO_2</span>  is used for the padding scheme.</p>

    <p class="text-gray-300">Let  <span class="math">\\nu(i)</span>  be the largest number j for which  <span class="math">2^j</span>  divides i. As in the XOR-linear construction, when hashing block i, the string  <span class="math">\\mu_{\\nu(i)}</span>  is XORed to the chaining value, unlike the XOR-linear scheme, this value is computed using a call to the random oracle  <span class="math">RO_1</span> . The parameters to the random oracle are the key of the hash function (corresponding to our salt) and a salt along with the encoding of  <span class="math">\\nu(i)</span> , i.e., let the key be denoted by K and the salt by s, then</p>

    <p class="text-gray-300"><span class="math">$\\mu_{\\nu(i)} = RO_1(K, s, \\nu(i)).</span>$</p>

    <p class="text-gray-300">We note that the output of the random oracle is of length  <span class="math">m_c</span>  bits.</p>

    <p class="text-gray-300">The padding scheme is composed of as many calls to  <span class="math">RO_2</span>  that are needed to achieve the right length of padding (with some minimal length of padding), where in each call  <span class="math">RO_2</span>  is called with the key K, the salt s, and the serial call number. The padding scheme is out of the scope of our paper, but we shall denote it as  <span class="math">pad_{RMC}(K, s, M)</span> .</p>

    <p class="text-gray-300">The RMC hash function that uses  <span class="math">RO_1, RO_2</span>  and  <span class="math">C_{RMC}</span>  is the following scheme:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad M using  <span class="math">RO_2(K, s, M)</span> , where K is the key (of length k bits) and s is the salt. Denote the padded message by  <span class="math">padded_{RMC}(M) = M_1||M_2||\\dots||M_t</span> .</li>
      <li>Set  <span class="math">h_0 = IV</span> .</li>
      <li>Generate  <span class="math">\\mu_i = RO_1(K, s, i)</span> , for  <span class="math">i = 0, \\dots, \\lceil \\log_2(|M|) \\rceil</span> .</li>
      <li>For  <span class="math">i = 1, \\ldots, l</span>  compute  <span class="math">h_i = C_{RMC}(h_{i-1} \\oplus \\mu_{\\nu(i)}, M_i, K)</span> .</li>
    </ul>

    <p class="text-gray-300">To support the RMC mode we embed the salt and the key in the salt of HAIFA. Thus,</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA4}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C_{RMC}(h_{i-1} \\oplus RO_1(s_1, s_2, \\nu(i)), M_i || pad_{RO2(s_1, s_2)}) &amp; \\text{Last block} \\\\ C_{RMC}(h_{i-1} \\oplus RO_1(s_1, s_2, \\nu(i)), M_i, s_1) &amp; \\text{Otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">where  <span class="math">s = (s_1, s_2)</span> , i.e., the salt is composed of the concatenation of the key and the salt of RMC. We note that computing  <span class="math">\\nu(i)</span>  in HAIFA is very easy, as it involves dividing the #bits parameter by n to obtain the block number, and then compute  <span class="math">\\nu(i)</span>  as in RMC.</p>

    <p class="text-gray-300">Given the above transformation, and assuming that both hash functions use the same random oracles, then  <span class="math">HAIFA^{C_{HAIFA4}} = RMC^{C_{RMC}}</span> .</p>

    <p class="text-gray-300">In [2] the RMC construction was slightly improved, and some parameters were changed a little bit to suggest the ROX construction. Let  <span class="math">C_{MD}</span>  be the compression function, then  <span class="math">ROX_{C_{MD}}^{RO_1,RO_2}:\\{0,1\\}^k\\times\\{0,1\\}^*\\to\\{0,1\\}^m</span>  is defined as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad M using  <span class="math">RO_2(K, M)</span> , where K is the key (of length k bits). Denote the padded message by  <span class="math">padded_{ROX}(M) = M_1||M_2||\\dots||M_t</span> .</li>
      <li>Set  <span class="math">h_0 = IV</span> .</li>
      <li>Generate  <span class="math">\\mu_i = RO_1(K, \\tilde{m}, i)</span> , for  <span class="math">i = 0, \\dots, \\lceil \\log_2(|M|) \\rceil</span> , where  <span class="math">\\tilde{m}</span>  is the first k bits of the message.</li>
      <li>For  <span class="math">i = 1, \\ldots, l</span>  compute  <span class="math">h_i = C_{MD}(h_{i-1} \\oplus \\mu_{\\nu(i)}, M_i)</span> .</li>
    </ul>

    <p class="text-gray-300">We note that M replaces the salt s from RMC. We set the size of the salt to 2k, where the first half of the salt is K, and the second half is m (which are known immediately once the first block is hashed).</p>

    <p class="text-gray-300">Thus,  <span class="math">C_{HAIFA5}: \\{0,1\\}_c^m \\times \\{0,1\\}^n \\times \\{0,1\\}^b \\times \\{0,1\\}^{2k}</span>  is as follows:</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA5}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C_{MD}(h_{i-1} \\oplus RO_1(s_1, s_2, \\nu(i)), M_i || pad_{RO2(s_1)}) &amp; \\text{Last block} \\\\ C_{MD}(h_{i-1} \\oplus RO_1(s_1, s_2, \\nu(i)), M_i) &amp; \\text{Otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">Where  <span class="math">s = (s_1, s_2)</span> , and  <span class="math">s_2 = first_k(M)</span>  (the value of  <span class="math">s_1</span>  is set by the user as well as part of the &quot;key&quot; to the hash function). It is easy to see that  <span class="math">HAIFA^{C_{HAIFA5}} = ROX^{C_{MD}}</span>  given the access to the &quot;same&quot; random oracles.</p>

    <p class="text-gray-300">Another possible reduction is based on increasing the chaining value by k bits which are initialized to 0. When the first block is processed, these k bits are set to  <span class="math">first_k(M)</span>  (in the first block  <span class="math">0 &lt; \\#bits \\le n</span> ), and then this value is not altered, while being transferred to all the following calls for the compression function.</p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Wide-Pipe Hash Constructions</h3>

    <p class="text-gray-300">The wide-pipe hash design principal was introduced by Lucks in [16] to reduce the effects of attacks based on internal collisions on the hash function. By increasing the chaining value size, e.g., choosing  <span class="math">m_c = 2m</span>  (in a double-pipe construction), the cost of the attacks based on internal collisions is at least  <span class="math">2^{m_c/2} = 2^m</span> , thus allowing for a  <span class="math">2^m</span>  security goal against pre-image and second pre-image attacks.</p>

    <p class="text-gray-300">The scheme employs two compression functions. The first one is  <span class="math">C&#x27;: \\{0,1\\}^{m_c} \\times \\{0,1\\}^n \\to \\{0,1\\}^{m_c}</span> , while the second one is  <span class="math">C&#x27;&#x27;: \\{0,1\\}^{m_c} \\to \\{0,1\\}^m</span> . The digest value is computed like in the Merkle-Damg&aring;rd construction using  <span class="math">C&#x27;(\\cdot)</span>  as the compression function. Then, the computed chaining value is compressed using one call to  <span class="math">C&#x27;&#x27;(\\cdot)</span>  to produce the digest.</p>

    <p class="text-gray-300">It is easy to see that transforming the wide pipe strategy into a HAIFA construction is a straightforward (and very similar to the transformation used</p>

    <p class="text-gray-300">in the EMD mode):</p>

    <p class="text-gray-300"><span class="math">$C_{HAIFA6}(h_{i-1}, M_i, \\#bits, s) = \\begin{cases} C&#x27;&#x27;(C&#x27;(IV_2, h_{i-1}||fix\\_pad(M_i))) &amp; \\text{Last block} \\\\ C&#x27;(h_{i-1}, M_i) &amp; \\text{Otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">As noted earlier, identifying the last block is a trivial operation in HAIFA. Thus, it is easy to see that  <span class="math">HAIFA^{C_{HAIFA6}} = WidePipe^{C&#x27;,C&#x27;&#x27;}</span> , i.e., the suggested HAIFA hash function is equivalent to the wide pipe hash function.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Comparing Other Constructions with HAIFA</h2>

    <p class="text-gray-300">While other constructions propose different security assurances, they lack in the security against realistic and practical attacks. For example, Joux's multicollision attack is applicable against EMD with the same ease it is applicable against Merkle-Damg&aring;rd. Unlike HAIFA where the collisions are to be chosen after the salt is known, in EMD this can even be in an off-line manner.</p>

    <p class="text-gray-300">For the randomized hashing scheme, Joux's multi-collision attack can be performed off-line, where the actual multi-collision is updated according to the random string afterwards, or can be performed in an on-line manner (once the random value is known). The long second pre-image attack can also be easily applied to the randomized hashing scheme, as the pre-processing of the messages is independent of the random string (which can later be XORed into the message to suggest the actual pre-image). The herding attack is also easily applicable to the randomized hashing scheme, as again, the only difference in the attack is the fact that resulting message is to be XORed with the random string (block by block). This problems are addressed in HAIFA by the stronger diffusion of the salt into the compression function, thus, eliminating the easy use of the pre-computed values.</p>

    <p class="text-gray-300">The EMD scheme is mostly Merkle-Damg&aring;rd, and thus, it is not surprising that all the mentioned attacks are applicable with the same ease to EMD. Thus, EMD proposes no additional security against any of these attacks. As noted earlier, the application of the multi-collision attack can be done off-line. It is quite obvious that security wise, HAIFA can offer a greater deal of security over the this mode.</p>

    <p class="text-gray-300">The RMC and ROX transformation are as susceptible to multi-collision attacks as all the other iterated constructions. We note that just like in a general HAIFA hash function, the salt has to be known (transforming the attack to an on-line attack when this is relevant). Due to the keying, the long second pre-image attacks are no longer possible as the change of the key affects the compressed values in a non-predictable way. As for the herding attack, while the herding attack can always be applied against any iterated construction when the key is known. When the key is unknown, the attacker has to try all possible keys. Unlike a general HAIFA hash function, the attacker can still manipulate the location of the diamond structure, by using a sequence of  <span class="math">\\mu(i)</span>  which repeats several times, e.g., 1,2,1,3,1,2,1,.... This allows for the shift of the diamond</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Type of Attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Randomized</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">EMD</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RMC &amp; ROX Double Pipe</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">HAIFA</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hashing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multi-collision</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.&lowast;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Not App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.&lowast;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Long Second Preimage</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Not App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Not App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Not App.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Herding</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Partially App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Not App.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Almost Not</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><sup>&lowast;</sup> &mdash; When the salt is known</p>

    <p class="text-gray-300">App. &mdash; Applicable</p>

    <p class="text-gray-300">Table 2. Comparison of the Various Modes of Iteration</p>

    <p class="text-gray-300">structure (when adding at the end of the diamond structure an expandable message to compensate for the different possible locations). Thus, RMC and ROX are almost as secure against the herding attack as HAIFA hash function can achieve.</p>

    <p class="text-gray-300">While the wide-pipe offers better security against attacks based on internal collision, such a hash function requires an additional memory to achieve this security. In HAIFA, the only additional parameter which has to be stored is the salt (the #bits parameter is stored for the Merkle-Damg&#730;ard strengthening anyway). Thus, to ensure the security of a HAIFA construction against the herding attack, a salt of size m/2 is sufficient, while to achieve the same goal in the wide-pipe strategy, one needs to increase the internal state by a factor of 2. Thus, while the internal memory of a wide-pipe is 2m, in HAIFA a 1.5m bits of memory are sufficient.</p>

    <p class="text-gray-300">Moreover, in the case of a salt, its effect on the compression function can be relatively mild and scarce (e.g., mixed every few rounds if the designer so chooses), while in the wide-pipe strategy, insufficient mixing of the additional state is a security hazard. Hence, the additional performance load and the more complex hash functions of the wide-pipe strategy might not be suitable for constrained applications.</p>

    <p class="text-gray-300">In Table 2 we summarize these results.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Summary</h2>

    <p class="text-gray-300">In this paper we have presented HAIFA as a replacement for the Merkle-Damg&#730;ard construction. The main differences are the addition of the number of bits hashed so far to the compression function along with a salt value. In cases where there is no need to add salt (e.g., message authentication codes) it is possible to set its value to 0.</p>

    <p class="text-gray-300">We note that even today's compression functions can be used in HAIFA hash functions by changing the API of such compression functions. For example, by setting in SHA-1 64 bits (out of the 512 bits of each block) to represent the number of bits hashed so far, and 64 bits to represent the salt, the new compression function would hash 384 bits per call of the compression function. This increases the computational effort of hashing long messages by a factor of about 4/3, but at the same time provides security against various attacks. New hash functions are expected to mix the salt and the number of bits much more efficiently.</p>

    <p class="text-gray-300">We showed that the API of the HAIFA framework is sufficient to support recently proposed modes of operation. This shows that the interface suggested by HAIFA is sufficient for any modern hash function design, and thus we suggest that the new hash function designers should support the API of HAIFA. In case they wish to achieve some specific security property, they can choose a compression function with properties which make HAIFA meet the requirements.</p>

    <p class="text-gray-300">Finally, we recommend that new hash functions should be designed under the HAsh Iterative FrAmework.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors wish to thank William Speirs and Praveen Gauravaram for pointing out typos in previous versions of this paper.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Elena Andreeva, Gregory Neven, Bart Preneel, Thomas Shrimpton, Seven-Properties-Preserving Iterated Hashing: The RMC Construction, ECRYPT document STVL4-KUL15-RMC-1.0, private communications, 2006.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Elena Andreeva, Gregory Neven, Bart Preneel, Thomas Shrimpton, Seven-Properties-Preserving Iterated Hashing: ROX, ECRYPT document STVL4- KUL15-ROX-2.0, private communications, 2007.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Mihir Bellare, Thomas Ristenpart, Multi-Property-Preserving Hash Domain Extension: The EMD Transform, NIST 2nd hash function workshop, Santa Barbara, August 2006.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Mihir Bellare, Philip Rogaway, Collision-resistant hashing: Towards making UOWHFs practical, dvances in Cryptology, proceedings of CRYPTO 1997, Lecture Notes in Computer Science 1294, pp. 470&ndash;484, Springer-Verlag, 1997.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Eli Biham, Rafi Chen, Near-Collisions of SHA-0, Advances in Cryptology, proceedings of CRYPTO 2004, Lecture Notes in Computer Science 3152, pp. 290&ndash;305, Springer-Verlag, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Eli Biham, Rafi Chen, Antoine Joux, Patrick Carribault, Christophe Lemuet, William Jalby, Collisions of SHA-0 and Reduced SHA-1, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3621, pp. 36&ndash;57, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Eli Biham, Orr Dunkelman, A Framework for Iterative Hash Functions HAIFA, NIST 2nd hash function workshop, Santa Barbara, August 2006.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Florent Chabaud, Antoine Joux, Differential Collisions in SHA-0, Advances in Cryptology, proceedings of CRYPTO 1998, Lecture Notes in Computer Science 1462, pp. 56&ndash;71, Springer-Verlag, 1998.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ivan Damg&#730;ard, A Design Principle for Hash Functions, Advances in Cryptology, proceedings of CRYPTO 1989, Lecture Notes in Computer Science 435, pp. 416&ndash; 427, Springer-Verlag, 1990.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Richared D. Dean, Formal Aspects of Mobile Code Security., Ph.D. dissertation, Princeton University, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Shai Halevei, Hugo Krawczyk, Strengthening Digital Signatures via Randomized Hashing, Advances in Cryptology, proceedings of CRYPTO 2006, Lecture Notes in Computer Science 4117, pp. 41&ndash;59, Springer-Verlag, 2006.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Jonathan J. Hoch, Adi Shamir, Breaking the ICE Finding Multicollisions in Iterated Concatenated and Expanded (ICE) Hash Functions, preproceedings of Fast Software Encryption 2006, pp. 199&ndash;214, 2006.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Antoine Joux, Multicollisions in Iterated Hash Functions, Advances in Cryptology, proceedings of CRYPTO 2004, Lecture Notes in Computer Science 3152, pp. 306&ndash; 316, Springer-Verlag, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>John Kelsey, Tadayoshi Kohno, Herding Hash Functions and the Nostradamus Attack, preproceedings of Cryptographic Hash Workshop, held in NIST, Gaithersburg, Maryland, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>John Kelsey, Bruce Schneier, Second Preimages on n-Bit Hash Functions for Much Less than 2 n , Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 474&ndash;490, Springer-Verlag, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Stefan Lucks, A Failure-Friendly Design Principle for Hash Functions, Advances in Cryptology, proceedings of ASIACRYPT 2005, Lecture Notes in Computer Science 3788, pp. 474&ndash;494, Springer-Verlag, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ralph C. Merkle, Secrecy, Authentication, and Public Key Systems, UMI Research press, 1982.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ralph C. Merkle, One Way Hash Functions and DES, Advances in Cryptology, proceedings of CRYPTO 1989, Lecture Notes in Computer Science 435, pp. 428&ndash; 446, Springer-Verlag, 1990.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Phillip Rogaway, Thomas Shrimpton, Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision Resistance, proceedings of Fast Software Encryption 2004, Lecture Notes in Computer Science 3017, pp. 371&ndash;388, Springer-Verlag, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>US National Bureau of Standards, Secure Hash Standard, Federal Information Processing Standards Publications No. 180-2, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Xiaoyun Wang, Xuejia Lai, Dengguo Feng, Hui Chen, Xiuyuan Yu, Cryptanalysis of the Hash Functions MD4 and RIPEMD, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 1&ndash;18, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Xiaoyun Wang, Yiqun Lisa Yin, Hongbo Yu, Finding Collisions in the Full SHA-1, Advances in Cryptology, proceedings of CRYPTO 2005, Lecture Notes in Computer Science 3621, pp. 17&ndash;36, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Xiaoyun Wang, Hongbo Yu, How to Break MD5 and Other Hash Functions, Advances in Cryptology, proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science 3494, pp. 19&ndash;35, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Xiaoyun Wang, Hongbo Yu, Yiqun Lisa Yin, Efficient Collision Search Attacks on SHA-0, Advances in Cryptology, proceedings of CRYPTO 2005, Lecture Notes in Computer Science 3621, pp. 1&ndash;16, 2005.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Gideon Yuval, How to Swindle Rabin, Cryptologia, Vol. 3, pp. 187&ndash;190, 1979.</li>
    </ul></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Identifying the Last Block in HAIFA</h2>

    <p class="text-gray-300">Some of our reductions are based on the fact that the last block is easily identified by the compression function itself. This can be done by the compression function by using the inputs in the following manner: In case (#bits mod n) &lt; n&minus;(t+r) and #bits &gt; 0, then this is the last message block, and no full padding block is added. Otherwise, there are two options: #bits 6= 0 mod n, which means that a full padding block with #bits = 0 is coming just after it, and #bits = 0 mod n. The latter case covers the following possible events:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>This is an intermediate block of the message.</li>
      <li>This is a call to the compression function during the computation of IVm.</li>
      <li>This is a call to the compression function for a full padding block.</li>
    </ul>

    <p class="text-gray-300">The first case is easy to identify, by #bits &gt; 0. In this case, this is not the actual last block that is compressed.</p>

    <p class="text-gray-300">For the remaining cases, #bits = 0. If the call is during the computation of IVm, then the last r bits of the message block are 0. Otherwise, i.e., this is a full padding block, it has one of two forms 10n&minus;r&minus;t&minus;<sup>1</sup> encodet(length)encoder(m) or 0 n&minus;r&minus;t encodet(length)encoder(m) where length is the length of the message.</p>

    <p class="text-gray-300">We conclude that all these options lead to the following algorithm to determine whether this is the last message block (or whether this is the computation of IVm):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If #bits 6= 0 mod n return &quot;Last block&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If #bits = 0 and the r last bits of M<sup>i</sup> are equal to 0, return &quot;Computation of IVm&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If #bits = 0 and the r last bits of M<sup>i</sup> are not equal to 0, return &quot;Last block&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Return &quot;Not the last block&quot;.</li>
    </ol></li>
    </ul>

    </section>
`;
---

<BaseLayout title="A Framework for Iterative Hash Functions - HAIFA (2007/278)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2007 &middot; eprint 2007/278
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-framework-for-iterative-hash-functions-haifa-2007" />
  </article>
</BaseLayout>
