---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/317';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
---

<BaseLayout title="Two Simple Code-Verification Voting Protocols (2011/317)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Two Simple Code-Verification Voting Protocols
      </h1>
      <p class="text-gray-400 mb-2">
        Helger Lipmaa
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; Full Version &middot; eprint 2011/317
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
        &middot; 289s on modal (Tesla T4)
        &middot; sha256:fd34c9bf1572d5af...
      </p>
    </header>

    <section class="paper-content">
      <h3 id="helger-lipmaa" class="text-xl font-semibold mt-8 mb-3">Helger Lipmaa</h3>
      <p class="text-gray-300">Cybernetica AS, Estonia Tallinn University, Estonia</p>
      <p class="text-gray-300"><strong>Abstract.</strong> Norwegian nationwide Internet voting will make use of a setting that we will call the codeverification voting. The concrete protocol that will be used in Norway was proposed by Scytl and improved by Gjøsteen. As we show, Gjøsteen's protocol has several undesirable properties. In particular, one of the online servers shares the secret key with the offline tallier. Even without considering that, the coalition of two online voting servers can breach voter privacy. We propose two new code-verification voting protocols. The first protocol separates the secret keys, and is as efficient as Gjøsteen's protocol. The second protocol provides voter privacy against the coalition of online voting servers but is somewhat less efficient. While the new protocols are more secure than the protocol that is going to be used in the Norwegian nationwide Internet voting, they are based on the same setting, so as to minimize the required infrastructural changes.</p>
      <p class="text-gray-300"><strong>Keywords.</strong> Code-verification voting, Internet voting, malicious voter PC.</p>
      <h4 id="1-introduction" class="text-lg font-semibold mt-6 mb-2">1 Introduction</h4>
      <p class="text-gray-300">Several nations are moving towards using Internet voting to elect their political representatives. One can use any of standard cryptographic protocols, coupled with relevant organizational means, to secure Internet voting against malicious voting servers. Instead, the weakest link is the voter PCs that may be corrupted by various malware. It is important to achieve Internet voting security even in such a case, without considerably changing the user experience or introducing unreasonable assumptions that may hamper accessibility (like requiring all voters to perform expensive mental arithmetics, entering long pseudorandom numbers, or to own special PIN-calculators; we omit citations).</p>
      <p class="text-gray-300">Heiberg, Lipmaa and Van Laenen [HLV10] proposed a concrete Internet voting setting where the voters can verify that their votes reached the central voting servers even when the voter PCs are malicious. In this <em>codeverification voting</em> setting (that will be used in the Norwegian nationwide Internet voting), there are two extra out-of-the-band channels, a prechannel and a postchannel, that are completely independent of the voter PCs. Before the Internet voting period starts, voter v obtains via the prechannel a code sheet that lists all candidates c with the corresponding voter-dependent random integrity check codes  <span class="math">\mathsf&#123;Code&#125;_v[c]</span> . After that, during the actual Internet voting, the voter v selects a concrete candidate number  <span class="math">c^<em></span> . He inputs  <span class="math">c^</em></span>  to his PC by using a suitable user interface, and the PC sends encrypted  <span class="math">c^<em></span>  to the vote collector. The correspondence between  <span class="math">c^</em></span>  and the actual candidate is publicly known, and thus there is no need for the voter to enter a long pseudo-random string as in say code voting [Cha01]. It was strongly felt by Norwegian authorities that the usability advantages of code-verification voting are more important than the security advantages of code voting.</p>
      <p class="text-gray-300">The vote collector executes a suitable cryptographic protocol with another central server, the messenger, after which the messenger obtains the value  <span class="math">\mathsf&#123;Code&#125;_v[c^<em>]</span> . Finally, the messenger sends the integrity check code  <span class="math">\mathsf&#123;Code&#125;_v[c^</em>]</span>  to the voter v over the postchannel (for example, by sending an SMS). In parallel, the vote collector stores all encrypted values of  <span class="math">c^<em></span> . To limit the efficiency of coercion, the code-verification setting also supports revoting, after which the vote collector stores the encrypted value of the "new" version of  <span class="math">c^</em></span> . Due to the possibility of revoting, the postchannel must be independent of the voter PCs. At the end of the allotted Internet voting period, the vote collector forwards encrypted votes to the (offline) tallier, who then decrypts and tallies the votes. One can use various existing cryptographic protocols to ensure the correctness of the last step. See [HLV10] for more discussion about the setting.</p>
      <p class="text-gray-300">Two different code-verification voting protocols have been proposed thus far. In [HLV10], Heiberg, Lipmaa and Van Laenen proposed a protocol where the codes  <span class="math">\mathsf&#123;Code&#125;_v[c]</span>  are uniformly random. The voter PC sends an encrypted candidate number c to the vote collector, who applies a so called proxy oblivious transfer protocol [HLV10] to the ciphertext, obtaining a ciphertext of  <span class="math">\mathsf&#123;Code&#125;_v[c]</span> , and sends the result to the messenger. The computational complexity of the proxy oblivious transfer protocol is linear in the number  <span class="math">\Gamma</span>  of candidates, and becomes relatively</p>
      <sup>\*</sup> Draft, June 16, 2011. The result dates back to Spring 2010.
      <p class="text-gray-300">inefficient for already say Γ &gt; 5. In particular, [\[HLV10\]](#page-11-0) did not specify how to make their protocol secure against malicious voting servers, assuming that the vote collector is semihonest; security against a malicious vote collector can be achieved by using standard yet relatively inefficient techniques. Moreover, in this protocol it is possible that the online servers (the vote collector and the messenger) collaborate to breach the voter privacy; in this case, implementing a secure tallier (by say using mixnets) would be a clear overkill.</p>
      <p class="text-gray-300">Norwegian nationwide e-voting will use alternative code-verification protocol by Gjøsteen [\[Gjø10\]](#page-11-2).[1](#page-1-0) In this protocol, the integrity check codes are not random, but pseudorandom. More precisely, every code Codev[c] is computed as a composition of three pseudorandom functions, respectively "owned" by the voter PC, vote collector and by the messenger. Due to this, Gjøsteen manages to design an efficient code-verification voting protocol with computational complexity that does not depend on the number of candidates. As a tradeoff, Gjøsteen's protocol requires a setup phase, where a number of servers, who share the secrets of all voter PCs, the vote collector, and the messenger, precompute the integrity check codes so as they can be forwarded to voters over the prechannel. (This phase is not precisely specified in [\[Gjø10\]](#page-11-2).)</p>
      <p class="text-gray-300">To increase efficiency, Gjøsteen's protocol uses a few additional tricks. First, the coalition of two online servers (the vote collector and the messenger) shares the secret key of the tallier (an offline server, that can be implemented in a distributed fashion by using say mixnets). This may become a serious accountability problem, especially since the coalition of online servers can completely breach voter privacy.[2](#page-1-1) If the secret keys are separated, then the Gjøsteen's protocol automatically becomes less efficient (intuitively, this is due to the fact that as in the protocol of [\[HLV10\]](#page-11-0), then the voter PC has to encrypt the candidate number by using two different public keys, and then prove in zero-knowledge that this was done correctly). Moreover, even without sharing the tallier's secret key, the coalition of two online servers, the vote collector and the messenger, can breach the voter privacy, since they can verify whether the output of a voter PC is equal to the application of the first pseudorandom function to any concrete candidate. See Sect. [3](#page-4-0) for more discussion on both existing protocols.</p>
      <p class="text-gray-300">Our Contributions. We propose two new code-verification voting protocols that are both more secure than Gjøsteen's protocol. The first protocol does not provide privacy against the coalition of two malicious online voting servers, but is computationally more efficient than the second protocol due to a more efficient non-interactive zero-knowledge (NIZK) proof. It is however somewhat more secure than Gjøsteen's protocol since the online servers do not share tallier's secret key. The second protocol guarantees said privacy, while being computationally less efficient. In both cases, we adapt Gjøsteen's main optimization (that is, the integrity check codes are computed as superpositions of independent pseudorandom function families), but we construct the whole protocol in a way that facilitates efficient construction of NIZK proofs that are needed to achieve security in malicious model.</p>
      <p class="text-gray-300">As the code-verification protocols from [\[HLV10](#page-11-0)[,Gjø10\]](#page-11-2), the new protocols use the Elgamal cryptosystem [\[Elg85\]](#page-11-3) over a prime-order cyclic group G. The choice of Elgamal is motivated by practical considerations: first, by its homomorphic properties that facilitate efficient protocol design, second by its efficiency (particularly over elliptic curves), and third, since it is sufficiently standard to be supported by Hardware Security Modules. We also need an arbitrary secure pseudorandom function family, and an arbitrary secure signature scheme. In the second protocol, we also need Pedersen's commitment scheme. Moreover, as in [\[HLV10](#page-11-0)[,Gjø10\]](#page-11-2), we only require two online voting servers, the vote collector and the messenger.</p>
      <p class="text-gray-300">In the new code-verification voting protocols, integrity check code is computed by two (and not three, as in the protocol of [\[Gjø10\]](#page-11-2)) parties, the voter PC and the messenger. On the other hand, the messenger and the tallier have independent keys (unlike in [\[Gjø10\]](#page-11-2)), and in the second new protocol, the coalition of the vote collector and the messenger cannot decrypt the votes (unlike both in [\[HLV10\]](#page-11-0) and [\[Gjø10\]](#page-11-2)). It it also easy to implement the messenger by using more than one 1 servers, such that every server applies its own pseudorandom function to the output of the previous one, thus decreasing dependency on a single messenger server.</p>
      <p class="text-gray-300">Both new protocols separate the keys of the online servers and the tallier, thus making it reasonable to implement the tallier in a distributed way. (If the online servers share tallier's secret key, then using secure multi-party computation to implement tallier's operations would clearly be an overkill.) The main difference between the two new protocols is that the first protocol does not protect voter privacy against the coalition of two online servers, the vote collector and the messenger, while the second does. On the other hand, the first protocol is about twice as</p>
      <span id="page-1-0"></span><sup>1</sup> This protocol was designed by Scytl, and then modified by Gjøsteen. However, since [\[Gjø10\]](#page-11-2) does not clarify the precise contribution of Scytl, we will call it Gjøsteen's protocol.
      <span id="page-1-1"></span><sup>2</sup> Norwegian government seems to be aware also of this problem, see [\[Bul10,](#page-11-4) slide 18], where it is stated that to alleviate this issue, the servers will be separated logically, geographically (by 600 km) and organizationally (in two different authorities, under two different ministries).
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Protocol</td><td class="border border-gray-700 px-3 py-1">Voter PC</td><td class="border border-gray-700 px-3 py-1">Vote Collector</td><td class="border border-gray-700 px-3 py-1">Messenger</td><td class="border border-gray-700 px-3 py-1">Setup phase</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">[HLV10] (7γ + 10) · e + 1 · s (2Γ + 6γ + 8) · e + 1 · v + 1 · s Γ · e + 1 · v</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">No</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">[Gjø10]</td><td class="border border-gray-700 px-3 py-1">3 · e + 1 · s</td><td class="border border-gray-700 px-3 py-1">8 · e + 1 · v + 1 · s</td><td class="border border-gray-700 px-3 py-1">10 · e + 1 · v</td><td class="border border-gray-700 px-3 py-1">Yes</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Sect. 4</td><td class="border border-gray-700 px-3 py-1">12 · e + 1 · s</td><td class="border border-gray-700 px-3 py-1">9 · e + 1 · v + 1 · s</td><td class="border border-gray-700 px-3 py-1">10 · e + 2 · v</td><td class="border border-gray-700 px-3 py-1">Yes</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Sect. 5</td><td class="border border-gray-700 px-3 py-1">16 · e + 1 · s</td><td class="border border-gray-700 px-3 py-1">17 · e + 1 · v + 1 · s</td><td class="border border-gray-700 px-3 py-1">18 · e + 2 · v</td><td class="border border-gray-700 px-3 py-1">Yes</td></tr>
      </tbody></table></div>
      <span id="page-2-0"></span>Table 1. The computational complexity of the protocols from [\[HLV10\]](#page-11-0), [\[Gjø10\]](#page-11-2) and of the two protocols from the current paper. The numbers for [\[HLV10\]](#page-11-0) do not include the cost of a NIZK proof from the vote collector to the messenger. The protocol from [\[Gjø10\]](#page-11-2) assumes that the messenger and the tallier share a common secret/public key, which makes the protocol about twice more efficient than it would be otherwise.
      <p class="text-gray-300">efficient as the second protocol. See Sect. [4](#page-5-0) for a precise description—including the security analysis—of the first protocol. The differences between the first and the second protocol are outlined in Sect. [5.](#page-9-0)</p>
      <p class="text-gray-300">We present short and informal proofs that both new protocols (if applied in combination with a secure cryptographic shuffle and mixnets) are secure against any single malicious party (the voter PC, the vote collector, the messenger, and the tallier). More precisely, if the voter PC is malicious, the protocol remains correct. If the vote collector or the messenger is malicious, then the protocol remains correct and private. If the tallier is malicious and the shuffle is secure, then the protocol remains correct. The protocol is not universally verifiable, since it involves revoting to protect against coercion. However, all voters can verify that their own last vote was included. We also show that if both online voting servers (the vote collector and the messenger) are malicious and collaborate, then the second (but not the first) new protocol remains private.</p>
      <p class="text-gray-300">Efficiency comparison of the protocols from [\[HLV10\]](#page-11-0), [\[Gjø10\]](#page-11-2) and the current paper is given in Table [1.](#page-2-0) The numbers are given by a vote attempt, and thus we have not counted in the cost of the subprotocol between the vote collector and the tallier (which may say include a cryptographic shuffle in all 3 cases), since this is done after the end of the Internet voting period. Here, the constant before e/v/s denotes the number of exponentiations, signature verifications and signings, respectively. Throughout this paper, Γ is the number of candidates, and γ = dlog<sup>2</sup> Γe. In the case of [\[HLV10\]](#page-11-0), we have not included the cost of the likely expensive NIZK proof that the vote collector follows the proxy oblivious protocol. On the other hand, the protocol of [\[HLV10\]](#page-11-0) includes another NIZK proof that the candidate number c ∗ that the voter PC encrypted belongs to the set of valid candidates; the rest of the protocols have no such NIZK proof.</p>
      <p class="text-gray-300">In the case of [\[Gjø10\]](#page-11-2), we emphasize that Gjøsteen's protocol achieves somewhat better efficiency due to the fact that the messenger and the tallier share the public/secret key, and thus there is no need to construct and verify a NIZK proof that the voter PC has encrypted the same value with two public keys. As mentioned before, we find that this solution is bad from the accountability standpoint.</p>
      <p class="text-gray-300"><em>Possible criticisms.</em> Recall that Gjøsteen's protocol will be used in Norwegian nationwide Internet voting. While it is considerably more efficient than the code-verification protocol from [\[HLV10\]](#page-11-0), it also suffers from a number of weaknesses. Our paper addressed some of the weaknesses (while being practically as efficient), but it still shares some others. E.g., as in the case of Gjøsteen's protocol, <em>all</em> voters share the same secret key. The difference is that in our protocol, if the coalition of two online servers want to breach voter privacy, they have to obtain that key on top of their own secret keys, while in Gjøsteen's protocol, the servers can just mutually share their own secret keys.</p>
      <p class="text-gray-300">Another important shortcoming is the need for the voters to obtain the table of verification codes before the start of the Internet voting period. Again, this weakness is shared with Gjøsteen's protocol, and the Norwegian authorities have already worked on corresponding trusted infrastructure to alleviate this problem [\[Bul10\]](#page-11-4).</p>
      <p class="text-gray-300">It is an interesting open problem to eliminate the two above mentioned weaknesses without blowing up the computation. Our work can ben seen as a step in this direction.</p>
      <h2 id="span-id-page-2-1-span-2-preliminaries" class="text-2xl font-bold mt-10 mb-4"><span id="page-2-1"></span>2 Preliminaries</h2>
      <p class="text-gray-300">Notation. All logarithms are on basis 2. k is the security parameter, we assume that k = 80. x ← X denotes assignment; if X is a set or a randomized algorithm, then x ← X denotes a random selection of x from the set or from the possible outputs of X as specified by the algorithm. In the case of integer operations, we will explicitly mention the modulus, like in z ← a + b mod q. Γ denotes the number of candidates.</p>
      <p class="text-gray-300"><strong>Hash Functions and Random Oracle Model.</strong> Function  <span class="math">H:A\to B</span>  is a hash function if |B|&lt;|A|. We usually need to assume that H is a random oracle. I.e., the value of H(x) is completely unpredictable if one has not seen H(x) before. In practice, one would instantiate H with a strong cryptographic hash function like SHA2 or the future winner of the SHA3 competition. While there exist cryptographic protocols and primitives which are secure in the random oracle model but which are insecure given any "real" function [CGH98], all known such examples are quite contrived.</p>
      <p class="text-gray-300"><strong>Signature Schemes.</strong> A signature scheme  <span class="math">SC = (Gen^&#123;sc&#125;, Sign, Ver)</span>  is a triple of efficient algorithms, where  <span class="math">Gen^&#123;sc&#125;</span>  is a randomized key generation function, Sign is a (possibly randomized) signing algorithm and Ver is a verification algorithm. A signature scheme is EUF-CMA (existentially unforgeable against chosen message attacks) secure, if it is computationally infeasible to generate a valid signature to a message that was not queried from the oracle, given access to an oracle who signs messages chosen by the adversary. In the new protocols, any of the well-known EUF-CMA secure signature schemes can be used. However, since Internet voting is most probably going to use the existing PKI infrastructure of the relevant country, the most prudent approach is to rely on whatever signature scheme has been implemented in the corresponding ID-cards.</p>
      <p class="text-gray-300"><strong>Public-Key Cryptosystems.</strong> Let PKC = (GenPkc, Enc, Dec) be a public-key cryptosystem, where GenPkc is a randomized key generation algorithm that on input  <span class="math">1^k</span> , for randomizer r, outputs a new secret/public key pair  <span class="math">(\mathsf&#123;sk&#125;,\mathsf&#123;pk&#125;) \leftarrow \mathsf&#123;GenPkc&#125;(1^k)</span> , Enc is a randomized encryption algorithm with  <span class="math">c = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r)</span> , and Dec is a decryption algorithm with  <span class="math">\mathsf&#123;Dec&#125;_&#123;\mathsf&#123;sk&#125;&#125;(c) = m'</span> . If  <span class="math">(\mathsf&#123;sk&#125;,\mathsf&#123;pk&#125;) \leftarrow \mathsf&#123;GenPkc&#125;(1^k)</span> , then  <span class="math">\mathsf&#123;Dec&#125;_&#123;\mathsf&#123;sk&#125;&#125;(\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r)) = m</span>  for all valid m and r. We denote  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r)</span>  for a randomly chosen r by  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m)</span> . A public-key cryptosystem is CPA-secure if the ciphertext distributions corresponding to any two plaintext messages are computationally indistinguishable.</p>
      <p class="text-gray-300">In the Elgamal cryptosystem [Elg85], one fixes a cyclic group  <span class="math">\mathbb G</span>  of prime order  <span class="math">2^&#123;2k+1&#125; &gt; q &gt; 2^&#123;2k&#125;</span> , together with a generator g of  <span class="math">\mathbb G</span> . Then,  <span class="math">\mathsf&#123;GenPkc&#125;(1^k)</span>  generates a random  <span class="math">\mathsf&#123;sk&#125; \leftarrow \mathbb Z_q</span> , and sets  <span class="math">\mathsf&#123;pk&#125; \leftarrow g^&#123;\mathsf&#123;sk&#125;&#125;</span> . On input  <span class="math">m \in \mathbb G</span> , the encryption algorithm generates a new random  <span class="math">r \leftarrow \mathbb Z_q</span> , and sets  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r) := (m \cdot \mathsf&#123;pk&#125;^r, g^r)</span> . On input  <span class="math">c = (c_1, c_2) \in \mathbb G^2</span> , the decryption algorithm outputs  <span class="math">m' \leftarrow c_1/c_2^&#123;\mathsf&#123;sk&#125;&#125;</span> . Elgamal is multiplicatively homomorphic. That is,  <span class="math">\mathsf&#123;Dec&#125;_&#123;\mathsf&#123;sk&#125;&#125;(\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m_1;r_1) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m_2;r_2)) = m_1 \cdot m_2</span>  for all  <span class="math">(\mathsf&#123;sk&#125;,\mathsf&#123;pk&#125;) \in \mathsf&#123;GenPkc&#125;(1^k)</span> , and all  <span class="math">m, r_1, r_2</span> . The Elgamal cryptosystem is CPA-secure under the decisional Diffie-Hellman assumption.</p>
      <p class="text-gray-300">Commitment Schemes. Let COM = (GenCom, Com, Open) be a commitment scheme, where GenCom is a randomized key generation algorithm that on input  <span class="math">1^k</span>  outputs a new public key pk  <span class="math">\leftarrow</span>  GenCom <span class="math">(1^k)</span> , Com is a randomized encryption algorithm with  <span class="math">(c,d) = \mathsf&#123;Com&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r')</span>  where c is the commitment and d is the decommitment value, and Open is an opening algorithm with  <span class="math">\mathsf&#123;Open&#125;_&#123;\mathsf&#123;pk&#125;&#125;(c,d) = m'</span> . It is required that if  <span class="math">\mathsf&#123;pk&#125; \leftarrow \mathsf&#123;GenCom&#125;(1^k)</span> , then  <span class="math">\mathsf&#123;Open&#125;_&#123;\mathsf&#123;pk&#125;&#125;(\mathsf&#123;Com&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r')) = m</span>  for all valid m and r'. We denote  <span class="math">\mathsf&#123;Com&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r)</span>  for a randomly chosen r also just as  <span class="math">\mathsf&#123;Com&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m)</span> . A (statistically hiding) commitment algorithm is required to be statistically hiding (that is, the distributions of commitments of any two messages are statistically close) and computationally binding (no polynomial-time adversary can open a commitment to two different messages, except with a negligible probability).</p>
      <p class="text-gray-300">The Pedersen commitment scheme [Ped91] works in the same setting as the Elgamal cryptosystem, in a group  <span class="math">\mathbb G</span>  of prime order q, with generator g. Here,  <span class="math">\mathsf&#123;GenCom&#125;(1^k)</span>  generates a random  <span class="math">\mathsf&#123;pk&#125; \leftarrow \mathbb G</span> . On input  <span class="math">m \in \mathbb G</span> , the commitment algorithm generates a random  <span class="math">r \leftarrow \mathbb Z_q</span> , and sets  <span class="math">\mathsf&#123;Com&#125;_&#123;\mathsf&#123;pk&#125;&#125;(m;r) := (m \cdot \mathsf&#123;pk&#125;^r, r)</span> . Thus,  <span class="math">m \cdot \mathsf&#123;pk&#125;^r</span>  is the commitment value, and d = r is the decommitment value. On input (c,r), the opening algorithm outputs  <span class="math">\mathsf&#123;Open&#125;_&#123;\mathsf&#123;pk&#125;&#125;(c,r) = c/\mathsf&#123;pk&#125;^r</span> . If the decisional Diffie-Hellman assumption holds, then the Pedersen commitment scheme is statistically hiding and computationally binding.</p>
      <p class="text-gray-300">Non-Interactive Zero-Knowledge Proof of Knowledge. Let L be an arbitrary NP-language, and let  <span class="math">R = \&#123;(x,y)\&#125;</span>  where  <span class="math">x \in L</span>  and y is the corresponding NP-witness. A  <span class="math">\Sigma</span> -protocol  <span class="math">(P_1, V_1, P_2, V_2)</span>  for a relation R is a three-message protocol between a prover and a verifier (both stateful), such that (1) the prover and verifier have a common input x, and the prover has a private input y, (2) the prover sends the first  <span class="math">(P_1)</span>  and the third  <span class="math">(P_2)</span>  message, and the verifier sends the second message  <span class="math">V_1</span> , after which the verifier either rejects or accepts (by using  <span class="math">V_2</span> ), (3) the protocol is public-coin: i.e., the verifier chooses her response  <span class="math">V_1</span>  completely randomly from some predefined set, (4) the protocol satisfies the security properties of correctness, special honest-verifier zero-knowledge (SHVZK), and special soundness. A protocol run is the tuple (x; i, c, r) where (i, c, r) are the three messages of this protocol. A protocol run is accepting, if an honest verifier accepts this run, on having input x and seeing the messages i, c, and r.</p>
      <p class="text-gray-300">More precisely, a  <span class="math">\Sigma</span> -protocol is <em>correct</em> if for any  <span class="math">(x,y) \in R</span> , an honest verifier accepts all runs with an honest prover. A  <span class="math">\Sigma</span> -protocol has the property of <em>special soundness</em> if one can construct an efficient simulator that, given any two accepting runs  <span class="math">(x; \mathfrak&#123;i&#125;, c_1, \mathfrak&#123;r&#125;_1)</span>  and  <span class="math">(x; \mathfrak&#123;i&#125;, c_2, \mathfrak&#123;r&#125;_2)</span>  with  <span class="math">c_1 \neq c_2</span> , outputs a y such that  <span class="math">(x,y) \in R</span> . A  <span class="math">\Sigma</span> -protocol has the property of SHVZK if there exists an efficient simulator that, given as input an arbitrary  <span class="math">x \in L</span>  (without corresponding y), can construct accepting runs  <span class="math">(x; \mathfrak&#123;i&#125;^<em>, \mathfrak&#123;c&#125;^</em>, \mathfrak&#123;r&#125;^<em>)</span>  such that (a) the simulator starts by choosing  <span class="math">\mathfrak&#123;c&#125;^</em></span>  and</p>
      <p class="text-gray-300">r ∗ , and only then computes i ∗ , and (b) the resulting distribution (x; i ∗ ,c ∗ ,r ∗ ) is computationally indistinguishable from the distribution (x; i,c,r) of runs between an honest prover and an honest verifier.</p>
      <p class="text-gray-300">Based on an arbitrary Σ-protocol, one can build a non-interactive zero-knowledge (NIZK) proof of knowledge in the random oracle model, by using the Fiat-Shamir heuristic [\[FS86\]](#page-11-7). I.e., given (x, y) ∈ R and a random oracle H [\[BR93\]](#page-11-8), the corresponding NIZK proof of knowledge π is equal to (i,c,r), where i ← P1(x, y), c ← H(param, x, i), and r ← P2(x, y,c), where param is the set of public parameters (like the description of the underlying group, etc). See [\[CDS94\]](#page-11-9). We use the next common notation. A NIZK proof of knowledge PK(α, · · · : R(. . .)) is for relation R, where the prover has to prove the knowledge of variables denoted by Greek letters α, . . . . All other variables are known to both the prover and the verifier. E.g., PK(µ, ρ : y = Encpk(µ; ρ) ∧ µ ∈ &#123;0, 1&#125;) denotes a NIZK proof of knowledge that the prover knows a Boolean µ and some ρ such that y = Encpk(µ; ρ).</p>
      <h2 id="span-id-page-4-0-span-3-previous-code-verification-voting-protocols" class="text-2xl font-bold mt-10 mb-4"><span id="page-4-0"></span>3 Previous Code-Verification Voting Protocols</h2>
      <p class="text-gray-300">The Heiberg-Lipmaa-Van Laenen Protocol. We provide a longer description of the Heiberg, Lipmaa and Van Laenen [\[HLV10\]](#page-11-0) code-verification protocol in App. [A.](#page-12-0)</p>
      <p class="text-gray-300">The Heiberg-Lipmaa-Van Laenen protocol provides security against any single party. More precisely, it achieves privacy against a malicious vote collector or a messenger (but not against their coalition, or against the voter PC). It provides correctness in the presence of either a malicious voter PC, a semihonest vote collector (correctness against a malicious vote collector is achievable, but costly), and a semihonest messenger, but not against their coalitions. One can achieve additional privacy and correctness by including a cryptographic shuffle. See [\[HLV10\]](#page-11-0) for more details.</p>
      <p class="text-gray-300">Gjøsteen's Protocol. Recently, Gjøsteen [\[Gjø10\]](#page-11-2) proposed a more efficient Internet voting protocol in the same setting, where the (online) computational complexity of the protocol does not depend on Γ. In Gjøsteen's protocol, the values Codev[c] are not random, but computed as a superposition of three pseudorandom functions: one pseudorandom function by the voter PC, another one (exponentiation by a random integer yv) by the vote collector (named the ballot box in [\[Gjø10\]](#page-11-2)), and the third one by the messenger (named the receipt generator in [\[Gjø10\]](#page-11-2)). Thus, the final pseudorandom mapping c 7→ Codev[c] is a composition of those three pseudorandom functions. Due to this trick, one does not have to use the costly proxy oblivious transfer protocol, and in particular, the computational complexity of Gjøsteen's protocol does not depend on Γ. The revoting part is handled similarly as in [\[HLV10\]](#page-11-0). Currently, it seems that Gjøsteen's protocol will be used in Norwegian Internet voting.</p>
      <p class="text-gray-300">As a drawback compared to the Heiberg-Lipmaa-Van Laenen protocol, Gjøsteen's protocol requires an offline setup phase, where a number of trusted servers—the process is not specified in [\[Gjø10\]](#page-11-2)—compute the values Codev[c] for every c and v. To do this, the setup servers must possess all secrets, required to evaluate all three pseudorandom functions. On the one hand, presence of such a setup phase seems to be necessary for the Gjøsteen's optimization to work. On the other hand, the setup servers have to be highly secured, and they also must have secure access to the prechannel but also secure channels to all voter PCs, the vote collector, and the messenger, to forward them the corresponding secrets. We emphasize however, that since the setup phase is an offline step, one can use time-consuming cryptographic techniques (without going into details, secure multi-party computation) to secure the operation of the setup servers. To secure the channels, one must use organizational means decoupled with strong cryptography. As in [\[Gjø10\]](#page-11-2), we will omit further discussion of the setup phase. The Norwegian government seems to be aware of these problems, see [\[Bul10,](#page-11-4) slide 16], where it is stated that pre-election sharing of secrets is cumbersome and vulnerable. However, they see it as a necessary evil. <em>The setup phase will also be present in the new code-verification voting protocols of the current paper.</em></p>
      <p class="text-gray-300">As another drawback, in Gjøsteen's protocol it is assumed that the coalition of two online servers (the messenger and the vote collector) share tallier's secret key, which makes the protocol less accountable since the coalition of malicious online servers can sometimes accuse honest tallier, and vice versa. Another obvious attack is when a dishonest vote collector sends the votes to the dishonest messenger for decryption. (The same attack can also be applied to the Heiberg-Lipmaa-Van Laenen protocol.) Thus, the privacy can be breached even when the tallier is honest. This is a serious problem in practice, since in the real Internet voting systems, the vote tallying should be performed offline, and thus it is not so easy to attack the tallier. Moreover, the functions of the tallier can be distributed by using say mix-nets, and the computational cost of this is not so important since tallying is done after the Internet voting period ends. However, the vote collector and the messenger are online entities, and distributing them would be computationally costly. Thus, we emphasize that in an Internet voting protocol, malicious <em>online</em> servers should not be able to breach the voter privacy.</p>
      <p class="text-gray-300">Interestingly, even if the messenger and the tallier did not share the same key pair, it is still possible for the coalition of online servers to breach the voter privacy, since together they can compute the output y = f(c)</p>
      <p class="text-gray-300">![](_page_5_Figure_0.jpeg)</p>
      <span id="page-5-1"></span>Fig. 1. The first new code-verification protocol, simplified
      <p class="text-gray-300">of the first pseudorandom function (the one, computed by the voter PC) on c, and they can just check whether  <span class="math">y = f(c^<em>)</span>  for some candidate  <span class="math">c^</em></span> . One could try to solve this problem by assuming that every voter PC has a different pseudorandom function  <span class="math">f_v</span> , not known by the online servers, but known by the tallier. However, in this case the tallier would obtain voter-dependent values  <span class="math">f_v(c)</span>  which is bad from the privacy viewpoint.</p>
      <p class="text-gray-300">We now present a slightly more precise description of Gjøsteen's protocol:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. The voter's PC Elgamal-encrypts (the garbled) vote f(c) (the function f is not precisely specified in [Gjø10]) by using a product (Elgamal) public key pkt = pkvc · pkm of public keys of the vote collector and the messenger. The result is  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(f(c)) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;\cdot\mathsf&#123;pkvc&#125;&#125;(f(c);r) = (f(c)\mathsf&#123;pkt&#125;^r,g^r)</span>  for random r.</li>
        <li>2. The vote collector decrypts the ciphertext partially, by applying the knowledge of her secret key skvc, and then takes the resulting ciphertext  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(f(c)) \leftarrow (f(c)\mathsf&#123;pkt&#125;^r/(g^r)^&#123;\mathsf&#123;skvc&#125;&#125;, g^r) = (f(c)\mathsf&#123;pkm&#125;^r, g^r)</span>  to the power  <span class="math">x_v</span> , where  <span class="math">x_v</span>  is a voter-dependent secret key. He sends  <span class="math">\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(f(c)^&#123;x_v&#125;) = (f(c)^&#123;x_v&#125;\mathsf&#123;pkt&#125;^&#123;rx_v&#125;, g^&#123;rx_v&#125;)</span>  to the messenger.</li>
        <li>3. The messenger decrypts the message, and obtains  <span class="math">f(c)^&#123;x_v&#125;</span> . He applies another pseudorandom function h to this, obtaining  <span class="math">h(f(c)^&#123;x_v&#125;)</span> .</li>
      </ul>
      <p class="text-gray-300">To achieve security in the malicious model, the second step has to be accompanied by a NIZK proof of correctness. This NIZK proof is somewhat expensive — while it was not specified in [Gjø10], by our calculations, it requires the prover (the voter PC) to perform 5 exponentiations, and the verifier to perform 9 exponentiations. In the case the keys of the tallier and the messenger were separated to tackle the mentioned accountability problem, it seems that the vote collector would also have to partially decrypt (and present a NIZK proof of correctness) the ciphertext that the voter PC meant to send to the tallier. Finally, Gjøsteen's paper [Gjø10] does not specify the secret keys, or what pseudorandom functions will really be used. In the new protocols, we have tried to be more precise on such accounts.</p>
      <h4 id="span-id-page-5-0-span-4-first-new-code-verification-protocol" class="text-lg font-semibold mt-6 mb-2"><span id="page-5-0"></span>4 First New Code-Verification Protocol</h4>
      <p class="text-gray-300">In this section, we propose the first new code-verification protocol. It is more efficient than the second one, but it does not provide privacy against the coalition of online servers. A <em>simplified</em> version of this protocol is depicted by Fig. 1.</p>
      <p class="text-gray-300">Setting. Let garble = &#123;garble<sub>k1</sub>&#125; be a public pseudorandom function family where every garble<sub>k1</sub> is a function from the set of all candidates  <span class="math">\&#123;c\&#125;</span>  to  <span class="math">\mathbb&#123;G&#125;</span> . We implement garble<sub>k1</sub> as  <span class="math">garble_&#123;k1&#125;(c) := g^&#123;AES_&#123;k1&#125;(c)&#125;</span> , where g is a fixed generator of  <span class="math">\mathbb&#123;G&#125;</span> . Here, k1 is not known by the messenger and the tallier<sup>3</sup>, while it is known to the voter PCs. All voter PCs v have a secret key  <span class="math">x_v \leftarrow \mathbb&#123;Z&#125;_p</span> . The voter PCs publish the values  <span class="math">h_v \leftarrow g^&#123;x_v&#125;</span> . Let prf be another public pseudorandom function family (in practice, AES followed by truncation) from  <span class="math">\mathbb&#123;G&#125;</span>  (in practice, from some one-to-one bit-representation of the elements of  <span class="math">\mathbb&#123;G&#125;</span> ) to the set of codes. The messenger also has a secret key k2 for prf.</p>
      <span id="page-5-2"></span><sup>&</sup>lt;sup&gt;3</sup> This can be achieved by organizational security. Similar assumptions are made in [Gjø10].
      <p class="text-gray-300"><strong>Setup phase.</strong> As in [Gjø10], the new protocols need a setup phase. During the setup phase—before the Internet voting starts—, some trusted third parties compute jointly all the integrity check codes. Since this process must finish before Internet voting starts, one can use any of the existing secure multi-party computation based protocols, by using a set of independent setup servers, in this phase. (See [Gjø10] for a discussion. As already mentioned, the Norwegian government is aware of the accompanying problems, and has accepted them due to the lack of efficient setup-less solutions.) More precisely, one integrity check code  <span class="math">Code_v[c]</span>  is computed as  <span class="math">Code_v[c] = prf_&#123;k2&#125;(h_v^&#123;AES_&#123;k1&#125;(c)&#125;)</span> . Thus, the setup servers have to know (in a secret-shared form) the values k1,  <span class="math">h_v</span>  and k2. Note that  <span class="math">h_v \leftarrow g^&#123;x_v&#125;</span>  for a random secret  <span class="math">x_v</span> . The setup servers securely forward the values  <span class="math">Code_v[c]</span>  to the party who later sends the codes to the voters over prechannel, and also send k1 to all potential voter PCs, k2 to the messenger,  <span class="math">h_v</span>  and  <span class="math">x_v</span>  to the voter v's PC. The key k1 must remain secret from the tallier, but has to be sent to the auditors (see the description of the tallier's operation later in this section).</p>
      <p class="text-gray-300"><strong>Protocol:</strong> One Internet Vote Attempt. Voter v casts a vote for candidate  <span class="math">c \in \mathbb&#123;Z&#125;</span> , that is, inputs c to the PC by using some user interface, not necessarily as a number. The voter PC prepares two encryptions of the vote c, as  <span class="math">E_t \leftarrow \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathsf&#123;AES&#125;_&#123;\mathsf&#123;kl&#125;&#125;(c)&#125;) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(\mathsf&#123;garble&#125;_&#123;\mathsf&#123;kl&#125;&#125;(c))</span>  and  <span class="math">E_m \leftarrow \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mathsf&#123;AES&#125;_&#123;\mathsf&#123;kl&#125;&#125;(c)&#125;) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(\mathsf&#123;garble&#125;_&#123;\mathsf&#123;kl&#125;&#125;(c)^&#123;x_v&#125;)</span> , where pkt is the tallier's public key and pkm is the messenger's public key. It then generates a non-interactive zero-knowledge proof of knowledge for</p>
      <span id="page-6-1"></span>
      <div class="math-block">\pi = \text&#123;PK&#125;(\mu_1, \mu_2, \rho_1, \rho_2 : E_t = \text&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;; \rho_1) \land E_m = \text&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mu_1&#125;; \rho_2) \land h_v = g^&#123;\mu_2&#125;) \ , \tag&#123;1&#125;</div>
      <p class="text-gray-300">that is, that the decryption of  <span class="math">E_m</span>  (under the secret key of the messenger) is equal to the  <span class="math">x_v</span> th power of the decryption of  <span class="math">E_t</span>  (under the secret key of the tallier), and in addition it knows the value  <span class="math">x_v</span> . The voter's PC generates a random number sid (session ID of this protocol instance).</p>
      <p class="text-gray-300">It then signs  <span class="math">\sigma \leftarrow \operatorname&#123;Sign&#125;_v(sid, \mathbf&#123;1&#125;, v, E_t, E_m, \pi, time_v)</span>  (where  <span class="math">time_v</span>  is the time of voting according to the PC's clock, and  <span class="math">\mathbf&#123;1&#125;</span>  is included as a unique marker that separates this signature from signatures given in other purposes), and sends the result</p>
      <div class="math-block">(sid, \mathbf&#123;1&#125;, v, E_t, E_m, \pi, time_v, \sigma)</div>
      <p class="text-gray-300">to the vote collector.</p>
      <p class="text-gray-300">The vote collector verifies the signature and the NIZK proof. Upon success, the vote collector computes signature  <span class="math">\sigma' \leftarrow \operatorname&#123;Sign&#125;_&#123;vc&#125;(sid, \mathbf&#123;2&#125;, v, E_m, \pi', time_&#123;vc&#125;)</span>  (where  <span class="math">time_&#123;vc&#125;</span>  is the time when the vote collector received this vote<sup>4</sup>) and sends</p>
      <div class="math-block">(sid, \mathbf&#123;2&#125;, v, E_t, E_m, \pi, time_v, \sigma, \pi', time_&#123;vc&#125;, \sigma')</div>
      <p class="text-gray-300">to the messenger. The messenger verifies both signatures  <span class="math">\sigma</span>  and  <span class="math">\sigma'</span> , and the NIZK proof  <span class="math">\pi</span> . Upon success, he decrypts  <span class="math">E_m</span> , obtaining garble<sub>k1</sub> <span class="math">(c)^&#123;x_v&#125; = h_v^&#123;\mathsf&#123;AES_&#123;k1&#125;&#125;(c)&#125;</span> . (Thus, the messenger should either not know k1 or any of the values  <span class="math">h_v</span> .) The messenger, who has another secret key k2, then computes  <span class="math">c' \leftarrow \mathsf&#123;prf&#125;_&#123;k2&#125;(\mathsf&#123;garble&#125;(c)^&#123;x_v&#125;)</span> , where prf is some fixed and public pseudorandom function family. The messenger also has a lexicographically ordered table of all values  <span class="math">H(\mathsf&#123;prf&#125;_&#123;k2&#125;(\mathsf&#123;garble&#125;(z)^&#123;x_v&#125;)) = H(\mathsf&#123;Code&#125;_v[z])</span>  for all possible candidates z. He checks that H(c') belongs to this table (which takes  <span class="math">\Theta(\log \Gamma)</span>  non-cryptographic operations by using binary search, where  <span class="math">\Gamma</span>  is again the number of candidates, or  <span class="math">\Theta(1)</span>  non-cryptographic operations by using a hash table). If it does not, then he complains to an arbiter/auditor that the voter PC cheated. This comparison step gives us some additional security, compared just to the case where the messenger sends out the SMS even when the candidate was invalid. It also saves an SMS message in the case the voter PC has encoded a bogus candidate — this can be important to avoid DDOS attacks. If such issues are not considered important, the comparison step can be omitted.</p>
      <p class="text-gray-300">If messenger's verifications succeed, it sends  <span class="math">(c', time_m)</span>  back to the voter by the postchannel, where  <span class="math">time_m</span>  is messenger's current time. The voter checks that  <span class="math">c' = \mathsf&#123;Code&#125;_v[c]</span>  where c is a candidate he voted for at time moment approximately equal to  <span class="math">time_m</span> . If this verification is unsuccessful, the voter revotes by using either a computer, or goes later to the voting station for paper voting.</p>
      <p class="text-gray-300">In parallel to message 2, the vote collector will store</p>
      <div class="math-block">(sid, v, E_t, E_m, \pi, \pi', time_v, time_&#123;vc&#125;, \sigma, \sigma')</div>
      <p class="text-gray-300">.</p>
      <p class="text-gray-300">If a previous such entry for the same v existed, it will be overwritten.</p>
      <p class="text-gray-300"><strong>Postcomputation.</strong> At the end of the Internet voting period, the vote collector will forward all stored entries, with the entire file (i.e., the collection of all stored entries) signed once by the vote collector, to the tallier. To eliminate the trust in vote collector, this step must be implemented by using a vote shuffle protocol, see e.g. [Gro03,GL07].)</p>
      <span id="page-6-0"></span><sup>&</sup>lt;sup&gt;4</sup> In actual e-voting, one can add extra steps in the case where  $time_v$  and  $time_&#123;vc&#125;$  differ too much. We will not consider this issue in this paper, and just assume that voter PC's clock is synchronized with that of the vote collector and the messenger.
      <p class="text-gray-300"><strong>Tallier's Operation.</strong> After receiving all (encrypted) votes from the vote collector, a semihonest tallier verifies two signatures ( <span class="math">\sigma</span>  and  <span class="math">\sigma'</span> ) per voter, and then decrypts all values  <span class="math">E_t</span> , obtaining values  <span class="math">d = \mathsf&#123;garble&#125;_&#123;\mathsf&#123;k1&#125;&#125;(\cdot)</span>  for some candidates. To provide security against malicious tallier, one can use standard cryptographic techniques (mixnet followed by NIZK proofs of correct decryption). As mentioned before, this step is outside of the scope of the current paper. The mixnets and corresponding NIZK proofs are however standard in cryptographic literature. See [Gjø10] for discussion.</p>
      <p class="text-gray-300">She will then tally the votes, and then send the tally  <span class="math">\&#123;(\sharp votes, \mathsf&#123;garble&#125;_&#123;k1&#125;(c))\&#125;</span>  for garbled candidates to the auditors (human beings). The auditors have a (say in a printed) sorted list  <span class="math">\&#123;(\mathsf&#123;garble&#125;_&#123;k1&#125;(c), c)\&#125;</span>  for all candidates c, and thus can associate the tallies with real candidates c, getting a list  <span class="math">\&#123;(\sharp votes, c)\&#125;</span> . This list is finally published.</p>
      <p class="text-gray-300">The final step of the tallier can be implemented differently, depending on the desired trade-off between the security, the cost of implementation and the usability. In the first alternative, there is another server (independent of the tallier), who has access to the table  <span class="math">\&#123;(\text&#123;garble&#125;_&#123;k1&#125;(c),c)\&#125;</span> . This server receives the list  <span class="math">\&#123;(\sharp votes,\text&#123;garble&#125;_&#123;k1&#125;(c))\&#125;</span>  from the tallier, and then outputs the list  <span class="math">\&#123;(\sharp votes,c)\&#125;</span> . That step requires very little computational power if we trust this server — otherwise, the server might need to output a NIZK proof of correct operation. This alternative has better usability (since human beings do not have to associate the lists), essentially the same security (since here the tallier does not know the actual candidates), but one more server compared to the solution of the previous paragraph. In the second alternative, the tallier actually has access to the list  <span class="math">\&#123;(\text&#123;garble&#125;_&#123;k1&#125;(c),c)\&#125;</span>  and thus can compute the tally  <span class="math">\&#123;(\sharp votes,c)\&#125;</span>  by herself. This alternative has better usability (since human beings do not have to associate the lists), the same cost but somewhat worse security (since if the tallier is not honest, she can ignore votes cast for candidates she does not like) compared to the solution in the previous paragraph. That problem can be alleviated by raising computational cost by letting the server to present a (relatively costly) NIZK proof of correct operation.</p>
      <h3 id="4-1-non-interactive-zero-knowledge-proof" class="text-xl font-semibold mt-8 mb-3">4.1 Non-Interactive Zero-Knowledge Proof</h3>
      <p class="text-gray-300">We need a NIZK proof of knowledge for  <span class="math">\mathrm&#123;PK&#125;(\mu_1,\mu_2,\rho_1,\rho_2:E_t=\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;;\rho_1)\wedge E_m=\mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;\mu_1&#125;_v;\rho_2)\wedge h_v=g^&#123;\mu_2&#125;).</span>  The interactive version of this NIZK (that is, a  <span class="math">\Sigma</span> -protocol) is as follows (assuming that g is a group generator,  <span class="math">k\geq 80</span>  is the security parameter, and q is the order of the group):</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. The prover generates  <span class="math">m_1, m_2, r_1, r_2 \leftarrow \mathbb&#123;Z&#125;_q</span> , and sets  <span class="math">\mathfrak&#123;i&#125;_1 \leftarrow \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1&#125;; \overline&#123;r_1&#125;)</span> ,  <span class="math">\mathfrak&#123;i&#125;_2 \leftarrow \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;m_1&#125;; r_2)</span> ,  <span class="math">\mathfrak&#123;i&#125;_3 \leftarrow g^&#123;m_2&#125;</span> . He sends  <span class="math">(\mathfrak&#123;i&#125;_1, \mathfrak&#123;i&#125;_2, \mathfrak&#123;i&#125;_3)</span>  to the verifier.</li>
        <li>2. The verifier sends  <span class="math">\mathfrak&#123;c&#125; \leftarrow \&#123;0,1\&#125;^k</span>  to the prover.</li>
        <li>3. The prover sends  <span class="math">\mathfrak&#123;r&#125;_1 \leftarrow m_1 + \mathfrak&#123;c&#125; \cdot \mu_1</span> ,  <span class="math">\mathfrak&#123;r&#125;_2 \leftarrow r_1 + \mathfrak&#123;c&#125; \cdot \rho_1</span> ,  <span class="math">\mathfrak&#123;r&#125;_3 \leftarrow r_2 + \mathfrak&#123;c&#125; \cdot \rho_2</span> ,  <span class="math">\mathfrak&#123;r&#125;_4 \leftarrow m_2 + \mathfrak&#123;c&#125; \cdot \mu_2</span>  to the verifier.</li>
        <li>4. The verifier accepts iff  <span class="math">\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;;\mathfrak&#123;r&#125;_2)=\mathfrak&#123;i&#125;_1\cdot E_t^&#123;\mathfrak&#123;c&#125;&#125;, \operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkm&#125;&#125;(h_v^&#123;\mathfrak&#123;r&#125;_1&#125;;\mathfrak&#123;r&#125;_3)=\mathfrak&#123;i&#125;_2\cdot E_m^&#123;\mathfrak&#123;c&#125;&#125;</span>  and  <span class="math">g^&#123;\mathfrak&#123;r&#125;_4&#125;=\mathfrak&#123;i&#125;_3\cdot h_v^&#123;\mathfrak&#123;c&#125;&#125;.</span></li>
      </ul>
      <p class="text-gray-300">The proof that this  <span class="math">\Sigma</span> -protocol satisfies the properties of correctness, special soundness and SHVZK is standard.</p>
      <p class="text-gray-300"><strong>Lemma 1.</strong> The above  <span class="math">\Sigma</span> -protocol is correct and satisfies the properties of special soundness and special honest-verifier zero-knowledge.</p>
      <p class="text-gray-300">``` \begin&#123;array&#125;&#123;l&#125; \textit&#123;Proof.&#125; \;\; \mathsf&#123;CORRECTNESS.&#125; \;\; \mathsf&#123;Clearly,&#125; \;\; \mathsf&#123;i&#125;_1 \cdot E^&#123;\mathfrak&#123;c&#125;&#125;_t = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1&#125;;r_1) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;c&#125; \cdot \mu_1&#125;;\mathfrak&#123;c&#125; \cdot \rho_1) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;;r_1+\mathfrak&#123;c&#125; \cdot \rho_1) \\ \rho_1) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;;\mathfrak&#123;r&#125;_2), \;\; \mathsf&#123;i&#125;_2 \cdot E^&#123;\mathfrak&#123;c&#125;&#125;_m = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1&#125;_v;r_2) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123;c&#125; \cdot \rho_2) = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h^&#123;m_1+\mathfrak&#123;c&#125; \cdot \mu_1&#125;_v;r_2+\mathfrak&#123; ```</p>
      <p class="text-gray-300">SPECIAL SOUNDNESS. First, assume that  <span class="math">\mathfrak&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;; \mathfrak&#123;r&#125;_2)</span>  and  <span class="math">\mathfrak&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1'&#125;; \mathfrak&#123;r&#125;_2')</span> , where  <span class="math">\mathfrak&#123;c&#125; \neq \mathfrak&#123;c&#125;'</span> . Then  <span class="math">E_t^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1'&#125;; \mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')</span> , and thus  <span class="math">E_t = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;(\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')&#125;; (\mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'))</span> . Thus, given two accepting views, one can find  <span class="math">\mu_1 = (\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> , and  <span class="math">\rho_1 = (\mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> , such that  <span class="math">E_t = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;; \rho_1)</span> .</p>
      <p class="text-gray-300">Second, assume that  <span class="math">\mathbf&#123;i&#125;_2 \cdot E_m^&#123;\mathfrak&#123;c&#125;&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mathfrak&#123;r&#125;_1&#125;;\mathfrak&#123;r&#125;_3)</span>  and  <span class="math">\mathbf&#123;i&#125;_2 \cdot E_m^&#123;\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mathfrak&#123;r&#125;'_1&#125;;\mathfrak&#123;r&#125;'_3)</span> . Then  <span class="math">E_m^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;'_1&#125;;\mathfrak&#123;r&#125;_3-\mathfrak&#123;r&#125;'_3)</span> , or  <span class="math">E_m = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(h_v^&#123;\mu_1&#125;;\rho_2)</span>  for  <span class="math">\mu_1 = (\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;'_1)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span>  (as before) and  <span class="math">\rho_2 = (\mathfrak&#123;r&#125;_3-\mathfrak&#123;r&#125;'_3)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> .</p>
      <p class="text-gray-300">Third, assume that  <span class="math">\mathbf&#123;i&#125;_3 \cdot h_v^&#123;\mathfrak&#123;c&#125;&#125; = g^&#123;\mathfrak&#123;r&#125;_4&#125;</span>  and  <span class="math">\mathbf&#123;i&#125;_3 \cdot h_v^&#123;\mathfrak&#123;c&#125;'&#125; = g^&#123;\mathfrak&#123;r&#125;'_4&#125;</span>  for  <span class="math">\mathfrak&#123;c&#125; \neq \mathfrak&#123;c&#125;'</span> . Then  <span class="math">h_v^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = g^&#123;\mathfrak&#123;r&#125;_4-\mathfrak&#123;r&#125;'_4&#125;</span> , or  <span class="math">h_v = g^&#123;\mu_2&#125;</span>  for  <span class="math">\mu_2 = (\mathfrak&#123;r&#125;_4 - \mathfrak&#123;r&#125;'_4)/(\mathfrak&#123;c&#125; - \mathfrak&#123;c&#125;')</span> .</p>
      <p class="text-gray-300">SPECIAL HONEST-VERIFIER ZERO-KNOWLEDGE. The simulator can first choose all values  <span class="math">\mathfrak&#123;c&#125;</span> ,  <span class="math">\mathfrak&#123;r&#125;_1,\ldots,\mathfrak&#123;r&#125;_4</span>  randomly, and then choose  <span class="math">\mathfrak&#123;i&#125;_1,\mathfrak&#123;i&#125;_2</span>  and  <span class="math">\mathfrak&#123;i&#125;_3</span>  such that they satisfy the verification. For example,  <span class="math">\mathfrak&#123;i&#125;_3\leftarrow h_v^&#123;-\mathfrak&#123;c&#125;&#125;\cdot g^&#123;\mathfrak&#123;r&#125;_4&#125;</span> . Clearly, the view created by the simulator is indistinguishable from the view in an actual run, given that the verifier is honest.</p>
      <p class="text-gray-300">Thus, one can use the Fiat-Shamir heuristic to transform it to a NIZK proof of knowledge. If Elgamal is used, the prover (that is, the voter PC) needs to perform 6 exponentiations, and the verifier (the vote collector) has to perform 9 exponentiations. In the actual code-verification voting protocol of this section, m = garblek1(c).</p>
      <h3 id="4-2-implementation" class="text-xl font-semibold mt-8 mb-3">4.2 Implementation</h3>
      <p class="text-gray-300">We consider the implementation of Elgamal by conservatively using 283-bit elliptic curves over binary fields; this corresponds to the security provided by 141-bit long symmetric keys. According to [http://www.shamus.](http://www.shamus.ie/index.php?page=Elliptic-Curve-point-multiplication) [ie/index.php?page=Elliptic-Curve-point-multiplication](http://www.shamus.ie/index.php?page=Elliptic-Curve-point-multiplication), an elliptic point multiplication (i.e., exponentiation in Elgamal) takes on average 3.56 milliseconds. We note that in Estonian Internet voting in 2009, with slightly more than 100 000 total Internet voters, 4 500 votes were cast during the peak hour. See &lt;http://www.vvk.ee/public/pics/EP09kokkuakt.jpg&gt; for a distribution of the number of votes per hour during that Internet voting period.</p>
      <p class="text-gray-300">The voter PC executes 6 exponentiations to compute E<sup>t</sup> and Em, 6 exponentiations to compute π, and 1 signing. Thus in total it executes 12 exponentiations (≈ 42.72 milliseconds), and signs 1 signature.</p>
      <p class="text-gray-300">The vote collector executes a signature verification, 9 exponentiations to verify π, and signs one message. For exponentiations alone, he spends 7 · 3.56 ≈ 32.04 milliseconds, and thus can handle—ignoring the time that is required to sign and verify signatures—more than 112 000 votes per hour.</p>
      <p class="text-gray-300">The messenger verifies two signatures, verifies one NIZK proof (9 exponentiations), and performs 1 exponentiation to decrypt Em, computes prf (insignificant) and then log<sup>2</sup> Γ non-cryptographic operations (insignificant). Thus, when we only count the 9 + 1 = 10 exponentiations, the messenger can handle more than 101 000 votes a hour, and its throughput is in practice restricted by the ability of sending messages on the postchannel. In the case the latter throughput is not sufficiently high, one can run several messengers in parallel.</p>
      <p class="text-gray-300">After the Internet voting period ends, in the simplest case the vote collector will compute only one more signature. The tallier will perform 1 exponentiation (decryption) and one signature verification per voter, and then (say) sorts the values. This is very close to the optimal (1 million exponentiations can be done in about one hour), but in the case of very large scale elections, one might still need a Hardware Security Module. However, as said, the vote collector ought to perform cryptographic shuffle, and also the tallier's operation should be secured by using mixnets and a suitable NIZK proof of correctness. Since this step is done after the Internet voting period ends, the exact computational efficiency of this step is not such a big concern.</p>
      <h3 id="span-id-page-8-0-span-4-3-security-guarantees" class="text-xl font-semibold mt-8 mb-3"><span id="page-8-0"></span>4.3 Security Guarantees</h3>
      <p class="text-gray-300">Security against Malicious Voter PC: In the code-verification voting protocol of this section, the voter PC sees the candidate name c, and thus the protocol does not guarantee privacy against malicious PC. It is unclear how to avoid this without changing the voting user interface dramatically (e.g., by requiring the voter to enter long random numbers, as in code voting). On the other hand, the voter PC can disrupt the protocol by not forwarding the voter's candidate (which will be detected by the voter due to the lack of a returning message from the postchannel), or sending inconsistent information (which will be detected by the NIZK proofs and/or wrong return code).</p>
      <p class="text-gray-300">Even if the voter PC could gain both the read and write access to the postchannel between the messenger and all voters (but without corrupting the messenger), creating a correct integrity check code requires it to compute prfk2 on a previously unseen value h AESk1(c) <sup>v</sup> , which is intractable, assuming that prf is a secure pseudorandom function family and k2 is only known to the messenger. The only bad case is if the voter PC has both the read and the write access to the postchannel, and the voter votes according to pattern A-B-A (i.e., after voting for candidate A, the same voter votes for candidate B and then again for candidate A). Now, the voter PC could send B to the vote collector, while sending the integrity check code for A over the postchannel. (See [\[HLV10\]](#page-11-0) for discussion.) To avoid this attack, it is required that the postchannel is independent of the voter PCs (voter PCs have neither read or write access to the postchannel) — e.g., SMS. Thus we have informally proven the next lemma.</p>
      <p class="text-gray-300">Lemma 2. <em>The code-verification protocol of this section guarantees correctness against malicious voter PCs, assuming that</em> prf <em>is a secure pseudorandom function family, the used signature scheme is secure,</em> H <em>is a random oracle, the postchannel is independent from the voter PCs and that the voter verifies the messages obtained from the postchannel.</em></p>
      <p class="text-gray-300">Note that verification by voters is necessary in any case, and is not too difficult for voters. Because the biggest danger in the case of Internet voting is massively distributed malware that addresses a large number of voters, then to guarantee the correctness of Internet voting with "large probability", it is sufficient that a sufficiently large fraction of voters verifies the correctness of codes. We omit further discussion.</p>
      <p class="text-gray-300">Security against Malicious Vote Collector: One can easily see that the next lemma holds.</p>
      <p class="text-gray-300"><strong>Lemma 3.</strong> Privacy against a malicious vote collector is guaranteed since Elgamal is semantically secure. The correctness of the vote collector's first operation (sending of an encrypted check code to the messenger) is guaranteed trivially, given that the used signature scheme is secure, H is a random oracle, and that the messenger performs all required verifications.</p>
      <p class="text-gray-300">The new voting protocol of this paper does however <em>not</em> guarantee that the vote collector forwards correct ciphertexts to the tallier. Without revoting, this could be achieved by using a standard cryptographic shuffle protocol [Gro03,GL07]. With revoting, this proof will be much very complex, since the vote collector has to somehow prove that the shuffled vote was the last one from every e-voter. To prevent coercion, it is unreasonable to assume anyhow that an Internet voting protocol provides universal verifiability. Thus, we can assume that there is an internal (incorruptible) auditor (say, the tallier itself), who can verify the correctness of the shuffle, but without knowing whether the vote collector included the last e-vote from every voter. On the other hand, one should allow the voters to later go physically to a (paper-)voting station, and verify whether in their own concrete case <em>their</em> last e-vote was used.</p>
      <p class="text-gray-300">Security against Malicious Messenger: Malicious messenger can obviously always refuse sending codes on postchannel, or send codes when not asked to. In such cases the voter will be alerted, but will not be completely sure of the origin of the problem. Sending correct codes corresponding to a wrong candidate (say, for c) is only possible when the messenger has already seen the same voter voting for exactly the same c before, e.g., in an A-B-A pattern as before. (Note that the messenger does not know c, he just knows that the vote is for the same c as before.) Otherwise, the messenger has to be able to compute, from value  <span class="math">c^<em></span>  the value  <span class="math">h_v^&#123;\mathsf&#123;AES&#125;_&#123;\mathsf&#123;kl&#125;&#125;(c^</em>)&#125;</span> , which is impossible since the messenger does not know k1, and AES is a pseudorandom function family. In either case, the voter sees that the code is incorrect. Thus, if verification of a integrity check code is not successful, then either the voter PC was malicious, or the messenger was malicious. If the messenger is malicious, then the voter does not see the code at all, a completely random code, or a code for incorrect candidate. Assuming that AES is a pseudorandom function family and the messenger does not know k1, the latter can only happen during revoting. Security against Malicious Tallier: The tallier part can be secured by using standard cryptographic techniques like mixnets. Moreover, there exist relatively efficient NIZK proofs of correct decryption. (We emphasize that specifying the shuffle protocol or the operation of tallier is not the subject of the current paper.) The fact that the tallier does not know k2, and thus only sees values garble, (c), provides some additional protection in the case the shuffle fails or the tallier "fails" on nonpreferred tallies.</p>
      <p class="text-gray-300">Security against Coalition of Malicious Vote Collector And Messenger: The coalition of a malicious vote collector and a malicious messenger sees both the values  <span class="math">h_v</span>  and  <span class="math">y = \mathsf&#123;garble&#125;_&#123;\mathsf&#123;k&#125;1&#125;(c)^&#123;x_v&#125; = h_v^&#123;\mathsf&#123;AES&#125;_&#123;\mathsf&#123;k&#125;1&#125;(c)&#125;</span> , as computed by a voter PC. Since the coalition can also recover k1 by collaborating with any of malicious voter PCs, they can test, for every candidate  <span class="math">c^<em></span> , whether  <span class="math">y = h_v^&#123;\mathsf&#123;AES&#125;_&#123;\mathsf&#123;k&#125;1&#125;(c^</em>)&#125;</span> , and thus completely breach the privacy of voters even in the case the voter PCs are honest.</p>
      <h3 id="span-id-page-9-0-span-5-second-new-code-verification-voting-protocol" class="text-xl font-semibold mt-8 mb-3"><span id="page-9-0"></span>5 Second New Code-Verification Voting Protocol</h3>
      <p class="text-gray-300">As mentioned at the end of Sect. 4.3, in the code-verification voting protocol of Sect. 4, coalition of a malicious vote collector and a malicious messenger can completely breach voter privacy. To avoid this, we modify the protocol of Sect. 4 in one crucial aspect: instead of publishing the values  <span class="math">h_v = g^&#123;x_v&#125;</span> , we publish the Pedersen commitments  <span class="math">C_v \leftarrow g^&#123;x_v&#125; h^&#123;r_v&#125;</span>  to  <span class="math">x_v</span> , where  <span class="math">h \leftarrow \mathbb&#123;G&#125;</span>  is a new random public key, and a random coin  <span class="math">r_v</span> . This does not change the overall protocol much. In what follows, we will give a quick overview of the changes.</p>
      <p class="text-gray-300">In the setup phase, all parties have additional access to the public key h (used by the commitment scheme, see Sect. 2), while no party knows the corresponding secret key. Instead of  <span class="math">h_v</span> , the values  <span class="math">C_v \leftarrow g^&#123;x_v&#125;h^&#123;r_v&#125;</span>  are published. The setup servers must also know the values  <span class="math">h_v</span>  (even if in a secret-shared form). In the actual protocol, we basically only need to replace the NIZK proof of knowledge. Instead of a NIZK proof of knowledge for Eq. (1), we need here a NIZK proof of knowledge for</p>
      <span id="page-9-1"></span>
      <div class="math-block">\pi' = PK(\mu_1, \mu_2, \rho_1, \rho_2, \rho_3 : E_t = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;; \rho_1) \land C_v = \mathsf&#123;Com&#125;_h(g^&#123;\mu_2&#125;; \rho_3) \land E_m = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(g^&#123;\mu_1 \mu_2&#125;; \rho_2)) ,</div>
      <p class="text-gray-300">(2)</p>
      <p class="text-gray-300">this proof of knowledge will be constructed in Sect. 5.1. There are no further changes between this protocol, and the code-verification protocol of Sect. 4. (Thus, also this protocol follows Fig. 1.)</p>
      <h4 id="span-id-page-10-0-span-5-1-second-nizk-protocol" class="text-lg font-semibold mt-6 mb-2"><span id="page-10-0"></span>5.1 Second NIZK Protocol</h4>
      <p class="text-gray-300">We need a NIZK proof of knowledge for Eq. (2), in the case of the Elgamal cryptosystem and the Pedersen commitment scheme. Let  <span class="math">E_t=(e_&#123;t1&#125;,e_&#123;t2&#125;)</span> , where supposedly  <span class="math">e_&#123;t1&#125;=g^&#123;\mu_1&#125; \operatorname&#123;pkt&#125;^&#123;\rho_1&#125;</span>  and  <span class="math">e_&#123;t2&#125;=g^&#123;\rho_1&#125;</span> . Let  <span class="math">E_m=(e_&#123;m1&#125;,e_&#123;m2&#125;)</span> , where supposedly  <span class="math">e_&#123;m1&#125;=g^&#123;\mu_1\mu_2&#125; \operatorname&#123;pkm&#125;^&#123;\rho_2&#125;</span>  and  <span class="math">e_&#123;m2&#125;=g^&#123;\rho_2&#125;</span> . Thus, we need that  <span class="math">E_m=(g^&#123;\mu_1\mu_2&#125; \operatorname&#123;pkm&#125;^&#123;\rho_2&#125;,g^&#123;\rho_2&#125;)=(e^&#123;\mu_2&#125;_&#123;t1&#125;\operatorname&#123;pkm&#125;^&#123;\rho_2&#125;\operatorname&#123;pkt&#125;^&#123;-\rho_1\mu_2&#125;,e^&#123;\mu_2&#125;_&#123;t2&#125;g^&#123;\rho_2-\mu_2\rho_1&#125;)=E^&#123;\mu_2&#125;_t\cdot\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkt&#125;&#125;(0;-\rho_1\mu_2)\cdot\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkm&#125;&#125;(0;\rho_2).</span>  To construct a truly efficient protocol, we note that for the security of the voting protocol of this section, it is not really necessary that the penultimate randomness in this expression is equal to  <span class="math">-\rho_1\mu_2</span> . So instead of the original proof of knowledge for Eq. (2), we will next construct a  <span class="math">\Sigma</span> -protocol for  <span class="math">\operatorname&#123;PK&#125;(\mu_1,\mu_2,\rho_1,\rho_2,\rho_3,\rho_4:E_t=\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;;\rho_1)\wedge C_v=\operatorname&#123;Com&#125;_h(g^&#123;\mu_2&#125;;\rho_2)\wedge E_m=E^&#123;\mu_2&#125;_t\cdot\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkt&#125;&#125;(0;\rho_3)\cdot\operatorname&#123;Enc&#125;_&#123;\operatorname&#123;pkm&#125;&#125;(0;\rho_4)).</span></p>
      <p class="text-gray-300">The corresponding  <span class="math">\Sigma</span> -protocol is as follows (assuming that g is a group generator,  <span class="math">k \geq 80</span>  is the security parameter, and q is the order of the group):</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. The prover generates  <span class="math">m_1, m_2, r_1, r_2, r_3, r_4 \leftarrow \mathbb&#123;Z&#125;_q</span> , and sets  <span class="math">\mathfrak&#123;i&#125;_1 \leftarrow \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1&#125;; r_1)</span> ,  <span class="math">\mathfrak&#123;i&#125;_2 \leftarrow \mathsf&#123;Com&#125;_h(g^&#123;m_2&#125;; r_2)</span> , and  <span class="math">\mathfrak&#123;i&#125;_3 \leftarrow E_t^&#123;m_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; r_3) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; r_4)</span> . He sends  <span class="math">(\mathfrak&#123;i&#125;_1, \mathfrak&#123;i&#125;_2, \mathfrak&#123;i&#125;_3)</span>  to the verifier.</li>
        <li>2. The verifier sends  <span class="math">\mathfrak&#123;c&#125; \leftarrow \&#123;0,1\&#125;^k</span>  to the prover.</li>
        <li>3. The prover sends  <span class="math">\mathfrak&#123;r&#125;_1 \leftarrow m_1 + \mathfrak&#123;c&#125; \cdot \mu_1</span> ,  <span class="math">\mathfrak&#123;r&#125;_2 \leftarrow r_1 + \mathfrak&#123;c&#125; \cdot \rho_1</span> ,  <span class="math">\mathfrak&#123;r&#125;_3 \leftarrow m_2 + \mathfrak&#123;c&#125; \cdot \mu_2</span> ,  <span class="math">\mathfrak&#123;r&#125;_4 \leftarrow r_2 + \mathfrak&#123;c&#125; \cdot \rho_2</span> ,  <span class="math">\mathfrak&#123;r&#125;_5 \leftarrow r_3 + \mathfrak&#123;c&#125; \cdot \rho_3</span> ,  <span class="math">\mathfrak&#123;r&#125;_6 \leftarrow r_4 + \mathfrak&#123;c&#125; \cdot \rho_4</span>  to the verifier.</li>
        <li>4. The verifier accepts iff  <span class="math">\mathfrak&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;&#125; = \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;; \mathfrak&#123;r&#125;_2), \ \mathfrak&#123;i&#125;_2 \cdot C_v^&#123;\mathfrak&#123;c&#125;&#125; = \mathsf&#123;Com&#125;_h(g^&#123;\mathfrak&#123;r&#125;_3&#125;; \mathfrak&#123;r&#125;_4), \ \mathsf&#123;and&#125; \ \mathfrak&#123;i&#125;_3 \cdot E_m^&#123;\mathfrak&#123;c&#125;&#125; = E_t^&#123;\mathfrak&#123;r&#125;_3&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; \mathfrak&#123;r&#125;_5) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; \mathfrak&#123;r&#125;_6).</span></li>
      </ul>
      <p class="text-gray-300"><strong>Lemma 4.</strong> The above  <span class="math">\Sigma</span> -protocol is correct and satisfies the properties of special soundness and special honest-verifier zero-knowledge.</p>
      <p class="text-gray-300"><span class="math">\begin&#123;aligned&#125; &\textit&#123;Proof.&#125; \;\; \text&#123;CORRECTNESS. Clearly,&#125; \; \mathbf&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;&#125; = \text&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1&#125;; r_1) \cdot \text&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;c&#125; \cdot \mu_1&#125;; \mathfrak&#123;c&#125; \cdot \rho_1) = \text&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;m_1 + \mathfrak&#123;c&#125; \cdot \mu_1&#125;; r_1 + \mathfrak&#123;c&#125; \cdot \rho_1) = \text&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;; \mathfrak&#123;r&#125;_2), \\ &\mathsf&#123;i&#125;_2 \cdot C_v^&#123;\mathfrak&#123;c&#125;&#125; = \text&#123;Com&#125;_h(g^&#123;m_2&#125;; r_3) \cdot \text&#123;Com&#125;_h(g^&#123;\mathfrak&#123;c&#125; \cdot \mu_2&#125;; \mathfrak&#123;c&#125; \cdot \rho_3) = \text&#123;Com&#125;_h(g^&#123;\mathfrak&#123;r&#125;_3&#125;; \mathfrak&#123;r&#125;_4), \\ &\mathsf&#123;and&#125; \end&#123;aligned&#125;</span></p>
      <div class="math-block">\begin&#123;split&#125; \mathbf&#123;i&#125;_3 \cdot E_m^&#123;\mathfrak&#123;c&#125;&#125; &= E_t^&#123;m_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; r_3) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; r_4) \cdot E_t^&#123;\mathfrak&#123;c&#125; \cdot \mu_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; \mathfrak&#123;c&#125; \cdot \rho_3) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; \mathfrak&#123;c&#125; \cdot \rho_4) \\ &= E_t^&#123;m_2 + \mathfrak&#123;c&#125; \cdot \mu_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; r_3 + \mathfrak&#123;c&#125; \cdot \rho_3) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; r_4 + \mathfrak&#123;c&#125; \cdot \rho_4) \\ &= E_t^&#123;\mathfrak&#123;r&#125;_3&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0; \mathfrak&#123;r&#125;_5) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0; \mathfrak&#123;r&#125;_6) \ . \end&#123;split&#125;</div>
      <p class="text-gray-300">SPECIAL SOUNDNESS. First, assume that  <span class="math">\mathbf&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1&#125;; \mathfrak&#123;r&#125;_2)</span>  and  <span class="math">\mathbf&#123;i&#125;_1 \cdot E_t^&#123;\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1'&#125;; \mathfrak&#123;r&#125;_2')</span> , where  <span class="math">\mathfrak&#123;c&#125; \neq \mathfrak&#123;c&#125;'</span> . Then  <span class="math">E_t^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1'&#125;; \mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')</span> , and thus  <span class="math">E_t = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;(\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')&#125;; (\mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'))</span> . Thus, given two accepting views, one can find  <span class="math">\mu_1 = (\mathfrak&#123;r&#125;_1-\mathfrak&#123;r&#125;_1')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> , and  <span class="math">\rho_1 = (\mathfrak&#123;r&#125;_2-\mathfrak&#123;r&#125;_2')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> , such that  <span class="math">E_t = \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(g^&#123;\mu_1&#125;; \rho_1)</span> . Second, assume that  <span class="math">\mathfrak&#123;i&#125;_2 \cdot C_v^&#123;\mathfrak&#123;c&#125;&#125; = \operatorname&#123;Com&#125;_h(g^&#123;\mathfrak&#123;r&#125;_3&#125;; \mathfrak&#123;r&#125;_4)</span>  and  <span class="math">\mathfrak&#123;i&#125;_2 \cdot C_v^&#123;\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Com&#125;_h(g^&#123;\mathfrak&#123;r&#125;_3'&#125;; \mathfrak&#123;r&#125;_4')</span> . Then  <span class="math">C_v^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = \operatorname&#123;Com&#125;_h(g^&#123;\mathfrak&#123;r&#125;_3-\mathfrak&#123;r&#125;_3'&#125;; \mathfrak&#123;r&#125;_4-\mathfrak&#123;r&#125;_4')</span> , or  <span class="math">C_v = \operatorname&#123;Com&#125;_h(g^&#123;\mu_2&#125;; \rho_3)</span>  for  <span class="math">\mu_2 = (\mathfrak&#123;r&#125;_3 - \mathfrak&#123;r&#125;_3')/(\mathfrak&#123;c&#125; - \mathfrak&#123;c&#125;')</span>  and  <span class="math">\rho_3 = (\mathfrak&#123;r&#125;_4 - \mathfrak&#123;r&#125;_4')/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> .</p>
      <p class="text-gray-300">Third, assume that  <span class="math">\mathbf&#123;i&#125;_3 \cdot E_m^&#123;\mathfrak&#123;c&#125;&#125; = E_t^&#123;\mathfrak&#123;r&#125;_3&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;\mathfrak&#123;r&#125;_5) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;\mathfrak&#123;r&#125;_6)</span>  and  <span class="math">\mathbf&#123;i&#125;_2 \cdot E_m^&#123;\mathfrak&#123;c&#125;'&#125; = E_t^&#123;\mathfrak&#123;r&#125;'_3&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;\mathfrak&#123;r&#125;'_5) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;\mathfrak&#123;r&#125;'_6)</span> . Then  <span class="math">E_m^&#123;\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'&#125; = E_t^&#123;\mathfrak&#123;r&#125;_3-\mathfrak&#123;r&#125;'_3&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;\mathfrak&#123;r&#125;_5-\mathfrak&#123;r&#125;'_5) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;\mathfrak&#123;r&#125;_6-\mathfrak&#123;r&#125;'_6)</span> , or  <span class="math">E_m = E_t^&#123;\mu_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;(\mathfrak&#123;r&#125;_5-\mathfrak&#123;r&#125;'_5)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;(\mathfrak&#123;r&#125;_6-\mathfrak&#123;r&#125;'_6)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;'))</span> . Define  <span class="math">\rho_3 = (\mathfrak&#123;r&#125;_5-\mathfrak&#123;r&#125;'_5)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span>  and  <span class="math">\rho_4 = (\mathfrak&#123;r&#125;_6-\mathfrak&#123;r&#125;'_6)/(\mathfrak&#123;c&#125;-\mathfrak&#123;c&#125;')</span> , then  <span class="math">E_m = E_t^&#123;\mu_2&#125; \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;\rho_3) \cdot \mathsf&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;\rho_4)</span>  as needed.</p>
      <p class="text-gray-300">SPECIAL HONEST-VERIFIER ZERO-KNOWLEDGE. The simulator can first choose all values  <span class="math">\mathfrak&#123;c&#125;</span> ,  <span class="math">\mathfrak&#123;r&#125;_1,\ldots,\mathfrak&#123;r&#125;_6</span>  randomly, and then choose  <span class="math">\mathfrak&#123;i&#125;_1</span> ,  <span class="math">\mathfrak&#123;i&#125;_2</span>  and  <span class="math">\mathfrak&#123;i&#125;_3</span>  such that they satisfy the verification. For example,  <span class="math">\mathfrak&#123;i&#125;_3\leftarrow E_m^&#123;-\mathfrak&#123;c&#125;&#125;\cdot E_t^&#123;\mathfrak&#123;r&#125;_3&#125;\cdot \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkt&#125;&#125;(0;\mathfrak&#123;r&#125;_5)\cdot \operatorname&#123;Enc&#125;_&#123;\mathsf&#123;pkm&#125;&#125;(0;\mathfrak&#123;r&#125;_6)</span> . Clearly, the view created by the simulator is indistinguishable from the view in an actual run, given that the verifier is honest.</p>
      <p class="text-gray-300">Note that in this  <span class="math">\Sigma</span> -protocol,  <span class="math">\mathfrak&#123;i&#125;_3=E_t^&#123;m_2&#125;\cdot(\mathsf&#123;pkt&#125;^&#123;r_3&#125;\mathsf&#123;pkm&#125;^&#123;r_4&#125;,g^&#123;r_3+r_4&#125;)</span> . Thus, the prover has to perform 10 exponentiations. The verifier has to perform 17 exponentiations.</p>
      <h3 id="5-2-implementation-of-second-protocol" class="text-xl font-semibold mt-8 mb-3">5.2 Implementation of Second Protocol</h3>
      <p class="text-gray-300">From the perspective of implementation, the only substantial difference between the two new code-verification protocols is that in the protocol of Sect. 5, one requires a different NIZK protocol. Thus, in the protocol of the current section, the voter PC executes 16 exponentiations, and signs 1 message. The vote collector executes a signature verification, 17 exponentiations to verify  <span class="math">\pi</span> , and signs one message. For exponentiations alone, he spends  <span class="math">17 \cdot 3.56 \approx 60.52</span>  milliseconds, and thus can handle—taking into account only time, required for exponentiations—about  <span class="math">59\,000</span>  votes per hour. The messenger verifies two signatures, and performs 18 exponentiations, being thus able to handle about  <span class="math">56\,000</span>  messages per hour, when only counting the exponentiations.</p>
      <h3 id="5-3-security-guarantees-of-second-protocol" class="text-xl font-semibold mt-8 mb-3">5.3 Security Guarantees of Second Protocol</h3>
      <p class="text-gray-300">Most of the security analysis of Sect. [4.3](#page-8-0) apply applies to the protocol of the current section, with one crucial difference. Namely, in the case of a coalition between malicious vote collector and malicious messenger, the coalition does not know the value h<sup>v</sup> = g <sup>x</sup><sup>v</sup> , and thus cannot verify, whether the value y is equal to h AESk1(c) <sup>v</sup> for any fixed value c or not. Thus, in this protocol, coalition of online servers cannot breach voter privacy.</p>
      <h2 id="6-application-to-code-voting" class="text-2xl font-bold mt-10 mb-4">6 Application to Code Voting</h2>
      <p class="text-gray-300">The code-verification voting setting is similar to that of code voting [\[Cha01\]](#page-11-1). The main difference is that in codeverification voting, the voters just enter c to the PCs, by using any favorite user interface, while in code voting, the voters enter long random numbers. This makes privacy against malicious voter PCs achievable in the code-voting setting but not in the code-verification setting. However, it was felt in Norway that code-voting-like approaches were inapplicable due to usability concerns. Another important difference is that in code-verification voting, at least as it will be implemented in Norway, support for revoting is mandatory. Nevertheless, the two new codeverification voting protocols are also applicable in the code-voting setting. In a nutshell, in the case of code voting, a similar composition of two pseudorandom functions can be defined to map voter's (pseudorandom) input code to the (pseudorandom) integrity check code. For example, one can assume that the input code of voter v is equal to g −fv(c) , where f<sup>v</sup> is some voter-specific function, unknown to the voter PC. We omit further discussion.</p>
      <p class="text-gray-300">Acknowledgments. The author was supported by Estonian Science Foundation, grant #8058, and European Union through the European Regional Development Fund.</p>
      <h2 id="references" class="text-2xl font-bold mt-10 mb-4">References</h2>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li><span id="page-11-8"></span>BR93. Mihir Bellare and Phillip Rogaway. Random Oracles are Practical: A Paradigm for Designing Efficient Protocols. In Victoria Ashby, editor, *ACM CCS 1993*, pages 62–73, Fairfax, Virginia, 3–5 November 1993. ACM Press.</li>
        <li><span id="page-11-4"></span>Bul10. Christian Bull. Open Source e-Voting - the Norwegian approach. In *Swiss E-Voting Workshop 2010*, University of Fribourg, Switzerland, September 6, 2010. Invited talk. Slides available from [http://www.e-voting-cc.ch/](http://www.e-voting-cc.ch/index.php/en/workshop10) [index.php/en/workshop10](http://www.e-voting-cc.ch/index.php/en/workshop10), as of December 2010.</li>
        <li><span id="page-11-9"></span>CDS94. Ronald Cramer, Ivan Damgard, and Berry Schoenmakers. Proofs of Partial Knowledge and Simplified Design of ˚ Witness Hiding Protocols. In Yvo G. Desmedt, editor, *CRYPTO 1994*, volume 839 of *LNCS*, pages 174–187, Santa Barbara, USA, August 21–25 1994. Springer-Verlag.</li>
        <li><span id="page-11-5"></span>CGH98. Ran Canetti, Oded Goldreich, and Shai Halevi. The Random Oracle Methodology, Revisited. In *STOC 1998*, pages 209–218, New York, May 23–26, 1998.</li>
        <li><span id="page-11-1"></span>Cha01. David Chaum. SureVote: Technical Overview. In *WOTE 2001*, 2001. Available from [http://www.vote.](http://www.vote.caltech.edu/wote01/pdfs/surevote.pdf) [caltech.edu/wote01/pdfs/surevote.pdf](http://www.vote.caltech.edu/wote01/pdfs/surevote.pdf), as of August, 2010.</li>
        <li><span id="page-11-3"></span>Elg85. Taher Elgamal. A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. *IEEE Transactions on Information Theory*, 31(4):469–472, 1985.</li>
        <li><span id="page-11-7"></span>FS86. Amos Fiat and Adi Shamir. How to Prove Yourself: Practical Solutions to Identification and Signature Problems. In Andrew M. Odlyzko, editor, *CRYPTO 1986*, volume 263 of *LNCS*, pages 186–194, Santa Barbara, California, USA, 11–15 August 1986. Springer-Verlag, 1987.</li>
        <li><span id="page-11-2"></span>Gjø10. Kristian Gjøsteen. Analysis of an Internet Voting Protocol. Technical Report 2010/380, International Association for Cryptologic Research, July 5, 2010. Available at http://eprint.iacr.org/2010/380.</li>
        <li><span id="page-11-11"></span>GL07. Jens Groth and Steve Lu. Verifiable Shuffle of Large Size Ciphertexts. In Tatsuaki Okamoto and Xiaoyun Wang, editors, *PKC 2007*, volume 4450 of *LNCS*, pages 377–392, Beijing, China, April 16–20, 2007. Springer-Verlag.</li>
        <li><span id="page-11-10"></span>Gro03. Jens Groth. A Verifiable Secret Shuffle of Homomorphic Encryptions. In Yvo Desmedt, editor, *PKC 2003*, volume 2567 of *LNCS*, pages 145–160, Miami, Florida, USA, January6–8, 2003. Springer-Verlag.</li>
        <li><span id="page-11-0"></span>HLV10. Sven Heiberg, Helger Lipmaa, and Filip Van Laenen. On E-Vote Integrity in the Case of Malicious Voter Computers. In Dimitris Gritzalis, Bart Preneel, and Marianthi Theoharidou, editors, *ESORICS 2010*, volume 6345 of *LNCS*, pages 373–388, Athens, Greece, September 20–22, 2010. Springer-Verlag.</li>
        <li><span id="page-11-6"></span>Ped91. Torben P. Pedersen. Non-Interactive And Information-Theoretic Secure Verifiable Secret Sharing. In Joan Feigenbaum, editor, *CRYPTO 1991*, volume 576 of *LNCS*, pages 129–140, Santa Barbara, California, USA, August 11–15, 1991. Springer-Verlag, 1992.</li>
      </ul>
      <p class="text-gray-300">The code-verification voting protocol by Heiberg, Lipmaa and Van Laenen [\[HLV10\]](#page-11-0) has computational complexity (by both the vote collector and the messenger) that is linear in the number Γ of the candidates. More precisely, in this protocol, the voter PC generates two ciphertexts E<sup>m</sup> and E<sup>t</sup> that encrypt the candidate number c ∗ , by using respectively the public keys of the messenger and the tallier. It sends the ciphertexts, together with a noninteractive zero-knowledge (NIZK) proof of knowledge of correctness (i.e., that E<sup>m</sup> and E<sup>t</sup> encrypt the same valid candidate number), to the vote collector. The vote collector verifies the NIZK proof.</p>
      <p class="text-gray-300">Upon success, the vote collector transforms E<sup>m</sup> to an encryption of Codev[c ∗ ] under the messenger's public key, by using proxy oblivious transfer. The vote collector sends the result to the messenger. The messenger "decrypts" the result, obtains Codev[c ∗ ], and sends it to the voter (not to the voter PC!) by using the postchannel. In parallel, the vote collector retains Et. Finally, the voters can revote, and then the same protocol is executed. In particular, for every voter, the vote collector keeps the last version of Et, and after the end of the Internet voting period, forwards them to the tallier.</p>
      <p class="text-gray-300">The computational complexity of a single e-vote attempt in the Heiberg-Lipmaa-Van Laenen Internet voting protocol is dominated by that of the proxy oblivious transfer: since the codes are supposed to be random, there are no obvious ways of making the computational complexity of this step smaller than Θ(Γ), where Γ is the number of candidates. (See [\[HLV10\]](#page-11-0) for a discussion.) This is true even in the case when we only aim to achieve security against semihonest voting servers (and a malicious voter PC); achieving security against malicious voting servers will be even more costly.</p>
    </section>
    <PaperHistory slug="two-simple-code-verification-voting-protocols-2011" />
  </article>
</BaseLayout>
