---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/317';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Two Simple Code-Verification Voting Protocols';
const AUTHORS_HTML = 'Helger Lipmaa';

const CONTENT = `    <p class="text-gray-300">Helger Lipmaa</p>

    <p class="text-gray-300"><span class="math">^{1}</span> Cybernetica AS, Estonia <span class="math">^{2}</span> Tallinn University, Estonia</p>

    <p class="text-gray-300">Abstract. Norwegian nationwide Internet voting will make use of a setting that we will call the code-verification voting. The concrete protocol that will be used in Norway was proposed by Scytl and improved by Gjøsteen. As we show, Gjøsteen's protocol has several undesirable properties. In particular, one of the online servers shares the secret key with the offline taller. Even without considering that, the coalition of two online voting servers can breach voter privacy. We propose two new code-verification voting protocols. The first protocol separates the secret keys, and is as efficient as Gjøsteen's protocol. The second protocol provides voter privacy against the coalition of online voting servers but is somewhat less efficient. While the new protocols are more secure than the protocol that is going to be used in the Norwegian nationwide Internet voting, they are based on the same setting, so as to minimize the required infrastructural changes.</p>

    <p class="text-gray-300">Keywords. Code-verification voting, Internet voting, malicious voter PC.</p>

    <p class="text-gray-300">Several nations are moving towards using Internet voting to elect their political representatives. One can use any of standard cryptographic protocols, coupled with relevant organizational means, to secure Internet voting against malicious voting servers. Instead, the weakest link is the voter PCs that may be corrupted by various malware. It is important to achieve Internet voting security even in such a case, without considerably changing the user experience or introducing unreasonable assumptions that may hamper accessibility (like requiring all voters to perform expensive mental arithmetics, entering long pseudorandom numbers, or to own special PIN-calculators; we omit citations).</p>

    <p class="text-gray-300">Heiberg, Lipmaa and Van Laenen [HLV10] proposed a concrete Internet voting setting where the voters can verify that their votes reached the central voting servers even when the voter PCs are malicious. In this code-verification voting setting (that will be used in the Norwegian nationwide Internet voting), there are two extra out-of-the-band channels, a prechannel and a postchannel, that are completely independent of the voter PCs. Before the Internet voting period starts, voter <span class="math">v</span> obtains via the prechannel a code sheet that lists all candidates <span class="math">c</span> with the corresponding voter-dependent random integrity check codes <span class="math">\\mathsf{Code}_v[c]</span>. After that, during the actual Internet voting, the voter <span class="math">v</span> selects a concrete candidate number <span class="math">c^<em></span>. He inputs <span class="math">c^</em></span> to his PC by using a suitable user interface, and the PC sends encrypted <span class="math">c^<em></span> to the vote collector. The correspondence between <span class="math">c^</em></span> and the actual candidate is publicly known, and thus there is no need for the voter to enter a long pseudo-random string as in say code voting [Cha01]. It was strongly felt by Norwegian authorities that the usability advantages of code-verification voting are more important than the security advantages of code voting.</p>

    <p class="text-gray-300">The vote collector executes a suitable cryptographic protocol with another central server, the messenger, after which the messenger obtains the value <span class="math">\\mathsf{Code}_v[c^<em>]</span>. Finally, the messenger sends the integrity check code <span class="math">\\mathsf{Code}_v[c^</em>]</span> to the voter <span class="math">v</span> over the postchannel (for example, by sending an SMS). In parallel, the vote collector stores all encrypted values of <span class="math">c^<em></span>. To limit the efficiency of coercion, the code-verification setting also supports revoting, after which the vote collector stores the encrypted value of the "new" version of <span class="math">c^</em></span>. Due to the possibility of revoting, the postchannel must be independent of the voter PCs. At the end of the allotted Internet voting period, the vote collector forwards encrypted votes to the (offline) taller, who then decrypts and tallies the votes. One can use various existing cryptographic protocols to ensure the correctness of the last step. See [HLV10] for more discussion about the setting.</p>

    <p class="text-gray-300">Two different code-verification voting protocols have been proposed thus far. In [HLV10], Heiberg, Lipmaa and Van Laenen proposed a protocol where the codes <span class="math">\\mathsf{Code}_v[c]</span> are uniformly random. The voter PC sends an encrypted candidate number <span class="math">c</span> to the vote collector, who applies a so-called proxy oblivious transfer protocol [HLV10] to the ciphertext, obtaining a ciphertext of <span class="math">\\mathsf{Code}_v[c]</span>, and sends the result to the messenger. The computational complexity of the proxy oblivious transfer protocol is linear in the number <span class="math">I&#x27;</span> of candidates, and becomes relatively</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Draft, June 16, 2011. The result dates back to Spring 2010.</li>

    </ul>

    <p class="text-gray-300">inefficient for already say <span class="math">\\Gamma&amp;gt;5</span>. In particular, <em>[x13]</em> did not specify how to make their protocol secure against malicious voting servers, assuming that the vote collector is semihonest; security against a malicious vote collector can be achieved by using standard yet relatively inefficient techniques. Moreover, in this protocol it is possible that the online servers (the vote collector and the messenger) collaborate to breach the voter privacy; in this case, implementing a secure tallier (by say using mixnets) would be a clear overkill.</p>

    <p class="text-gray-300">Norwegian nationwide e-voting will use alternative code-verification protocol by Gjøsteen <em>[x11]</em>. In this protocol, the integrity check codes are not random, but pseudorandom. More precisely, every code <span class="math">\\mathsf{Code}_{v}[c]</span> is computed as a composition of three pseudorandom functions, respectively “owned” by the voter PC, vote collector and by the messenger. Due to this, Gjøsteen manages to design an efficient code-verification voting protocol with computational complexity that does not depend on the number of candidates. As a tradeoff, Gjøsteen’s protocol requires a setup phase, where a number of servers, who share the secrets of all voter PCs, the vote collector, and the messenger, precompute the integrity check codes so as they can be forwarded to voters over the prechannel. (This phase is not precisely specified in <em>[x11]</em>.)</p>

    <p class="text-gray-300">To increase efficiency, Gjøsteen’s protocol uses a few additional tricks. First, the coalition of two online servers (the vote collector and the messenger) shares the secret key of the tallier (an offline server, that can be implemented in a distributed fashion by using say mixnets). This may become a serious accountability problem, especially since the coalition of online servers can completely breach voter privacy. If the secret keys are separated, then the Gjøsteen’s protocol automatically becomes less efficient (intuitively, this is due to the fact that as in the protocol of <em>[x13]</em>, then the voter PC has to encrypt the candidate number by using two different public keys, and then prove in zero-knowledge that this was done correctly). Moreover, even without sharing the tallier’s secret key, the coalition of two online servers, the vote collector and the messenger, can breach the voter privacy, since they can verify whether the output of a voter PC is equal to the application of the first pseudorandom function to any concrete candidate. See Sect. 3 for more discussion on both existing protocols.</p>

    <p class="text-gray-300">Our Contributions. We propose two new code-verification voting protocols that are both more secure than Gjøsteen’s protocol. The first protocol does not provide privacy against the coalition of two malicious online voting servers, but is computationally more efficient than the second protocol due to a more efficient non-interactive zero-knowledge (NIZK) proof. It is however somewhat more secure than Gjøsteen’s protocol since the online servers do not share tallier’s secret key. The second protocol guarantees said privacy, while being computationally less efficient. In both cases, we adapt Gjøsteen’s main optimization (that is, the integrity check codes are computed as superpositions of independent pseudorandom function families), but we construct the whole protocol in a way that facilitates efficient construction of NIZK proofs that are needed to achieve security in malicious model.</p>

    <p class="text-gray-300">As the code-verification protocols from <em>[x13, x11]</em>, the new protocols use the Elgamal cryptosystem <em>[x6]</em> over a prime-order cyclic group <span class="math">\\mathbb{G}</span>. The choice of Elgamal is motivated by practical considerations: first, by its homomorphic properties that facilitate efficient protocol design, second by its efficiency (particularly over elliptic curves), and third, since it is sufficiently standard to be supported by Hardware Security Modules. We also need an arbitrary secure pseudorandom function family, and an arbitrary secure signature scheme. In the second protocol, we also need Pedersen’s commitment scheme. Moreover, as in <em>[x13, x11]</em>, we only require two online voting servers, the vote collector and the messenger.</p>

    <p class="text-gray-300">In the new code-verification voting protocols, integrity check code is computed by two (and not three, as in the protocol of <em>[x11]</em>) parties, the voter PC and the messenger. On the other hand, the messenger and the tallier have independent keys (unlike in <em>[x11]</em>), and in the second new protocol, the coalition of the vote collector and the messenger cannot decrypt the votes (unlike both in <em>[x13]</em> and <em>[x11]</em>). It it also easy to implement the messenger by using more than one <span class="math">1</span> servers, such that every server applies its own pseudorandom function to the output of the previous one, thus decreasing dependency on a single messenger server.</p>

    <p class="text-gray-300">Both new protocols separate the keys of the online servers and the tallier, thus making it reasonable to implement the tallier in a distributed way. (If the online servers share tallier’s secret key, then using secure multi-party computation to implement tallier’s operations would clearly be an overkill.) The main difference between the two new protocols is that the first protocol does not protect voter privacy against the coalition of two online servers, the vote collector and the messenger, while the second does. On the other hand, the first protocol is about twice as</p>

    <p class="text-gray-300">This protocol was designed by Scytl, and then modified by Gjøsteen. However, since [Gjø10] does not clarify the precise contribution of Scytl, we will call it Gjøsteen's protocol.</p>

    <p class="text-gray-300">2 Norwegian government seems to be aware also of this problem, see [Bul10, slide 18], where it is stated that to alleviate this issue, the servers will be separated logically, geographically (by 600\\mathrm{km} ) and organizationally (in two different authorities, under two different ministries).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Voter PC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vote Collector</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Messenger</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup phase</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[HLV10]</td>

            <td class="px-3 py-2 border-b border-gray-700">(7γ + 10) · e + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">(2Γ + 6γ + 8) · e + 1 · v + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">Γ · e + 1 · v</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gjø10]</td>

            <td class="px-3 py-2 border-b border-gray-700">3 · e + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">8 · e + 1 · v + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">10 · e + 1 · v</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 4</td>

            <td class="px-3 py-2 border-b border-gray-700">12 · e + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">9 · e + 1 · v + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">10 · e + 2 · v</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sect. 5</td>

            <td class="px-3 py-2 border-b border-gray-700">16 · e + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">17 · e + 1 · v + 1 · s</td>

            <td class="px-3 py-2 border-b border-gray-700">18 · e + 2 · v</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. The computational complexity of the protocols from [HLV10], [Gjø10] and of the two protocols from the current paper. The numbers for [HLV10] do not include the cost of a NIZK proof from the vote collector to the messenger. The protocol from [Gjø10] assumes that the messenger and the tallier share a common secret/public key, which makes the protocol about twice more efficient than it would be otherwise.</p>

    <p class="text-gray-300">efficient as the second protocol. See Sect. 4 for a precise description—including the security analysis—of the first protocol. The differences between the first and the second protocol are outlined in Sect. 5.</p>

    <p class="text-gray-300">We present short and informal proofs that both new protocols (if applied in combination with a secure cryptographic shuffle and mixnets) are secure against any single malicious party (the voter PC, the vote collector, the messenger, and the tallier). More precisely, if the voter PC is malicious, the protocol remains correct. If the vote collector or the messenger is malicious, then the protocol remains correct and private. If the tallier is malicious and the shuffle is secure, then the protocol remains correct. The protocol is not universally verifiable, since it involves revoting to protect against coercion. However, all voters can verify that their own last vote was included. We also show that if both online voting servers (the vote collector and the messenger) are malicious and collaborate, then the second (but not the first) new protocol remains private.</p>

    <p class="text-gray-300">Efficiency comparison of the protocols from [HLV10], [Gjø10] and the current paper is given in Table 1. The numbers are given by a vote attempt, and thus we have not counted in the cost of the subprotocol between the vote collector and the tallier (which may say include a cryptographic shuffle in all 3 cases), since this is done after the end of the Internet voting period. Here, the constant before  <span class="math">e / v / s</span>  denotes the number of exponentiations, signature verifications and signings, respectively. Throughout this paper,  <span class="math">\\Gamma</span>  is the number of candidates, and  <span class="math">\\gamma = \\lceil \\log_2\\Gamma \\rceil</span> . In the case of [HLV10], we have not included the cost of the likely expensive NIZK proof that the vote collector follows the proxy oblivious protocol. On the other hand, the protocol of [HLV10] includes another NIZK proof that the candidate number  <span class="math">c^*</span>  that the voter PC encrypted belongs to the set of valid candidates; the rest of the protocols have no such NIZK proof.</p>

    <p class="text-gray-300">In the case of [Gjø10], we emphasize that Gjøsteen's protocol achieves somewhat better efficiency due to the fact that the messenger and the tallier share the public/secret key, and thus there is no need to construct and verify a NIZK proof that the voter PC has encrypted the same value with two public keys. As mentioned before, we find that this solution is bad from the accountability standpoint.</p>

    <p class="text-gray-300">Possible criticisms. Recall that Gjøsteen's protocol will be used in Norwegian nationwide Internet voting. While it is considerably more efficient than the code-verification protocol from [HLV10], it also suffers from a number of weaknesses. Our paper addressed some of the weaknesses (while being practically as efficient), but it still shares some others. E.g., as in the case of Gjøsteen's protocol, all voters share the same secret key. The difference is that in our protocol, if the coalition of two online servers want to breach voter privacy, they have to obtain that key on top of their own secret keys, while in Gjøsteen's protocol, the servers can just mutually share their own secret keys.</p>

    <p class="text-gray-300">Another important shortcoming is the need for the voters to obtain the table of verification codes before the start of the Internet voting period. Again, this weakness is shared with Gjøsteen's protocol, and the Norwegian authorities have already worked on corresponding trusted infrastructure to alleviate this problem [Bul10].</p>

    <p class="text-gray-300">It is an interesting open problem to eliminate the two above mentioned weaknesses without blowing up the computation. Our work can be seen as a step in this direction.</p>

    <p class="text-gray-300">Notation. All logarithms are on basis 2.  <span class="math">k</span>  is the security parameter, we assume that  <span class="math">k = 80</span> .  <span class="math">x \\gets X</span>  denotes assignment; if  <span class="math">X</span>  is a set or a randomized algorithm, then  <span class="math">x \\gets X</span>  denotes a random selection of  <span class="math">x</span>  from the set or from the possible outputs of  <span class="math">X</span>  as specified by the algorithm. In the case of integer operations, we will explicitly mention the modulus, like in  <span class="math">z \\gets a + b \\mod q</span> .  <span class="math">\\Gamma</span>  denotes the number of candidates.</p>

    <p class="text-gray-300">.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash Functions and Random Oracle Model. Function <span class="math">H:A\\to B</span> is a hash function if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We usually need to assume that </span>H<span class="math"> is a random oracle. I.e., the value of </span>H(x)<span class="math"> is completely unpredictable if one has not seen </span>H(x)<span class="math"> before. In practice, one would instantiate </span>H$ with a strong cryptographic hash function like SHA2 or the future winner of the SHA3 competition. While there exist cryptographic protocols and primitives which are secure in the random oracle model but which are insecure given any “real” function <em>[x10]</em>, all known such examples are quite contrived.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Signature Schemes. A signature scheme <span class="math">\\mathsf{SC}=(\\mathsf{Gen}^{\\mathsf{sc}},\\mathsf{Sign},\\mathsf{Ver})</span> is a triple of efficient algorithms, where <span class="math">\\mathsf{Gen}^{\\mathsf{sc}}</span> is a randomized key generation function, <span class="math">\\mathsf{Sign}</span> is a (possibly randomized) signing algorithm and <span class="math">\\mathsf{Ver}</span> is a verification algorithm. A signature scheme is EUF-CMA (existentially unforgeable against chosen message attacks) secure, if it is computationally infeasible to generate a valid signature to a message that was not queried from the oracle, given access to an oracle who signs messages chosen by the adversary. In the new protocols, any of the well-known EUF-CMA secure signature schemes can be used. However, since Internet voting is most probably going to use the existing PKI infrastructure of the relevant country, the most prudent approach is to rely on whatever signature scheme has been implemented in the corresponding ID-cards.</p>

    <p class="text-gray-300">Public-Key Cryptosystems. Let <span class="math">\\mathsf{PKC}=(\\mathsf{GenPkc},\\mathsf{Enc},\\mathsf{Dec})</span> be a public-key cryptosystem, where <span class="math">\\mathsf{GenPkc}</span> is a randomized key generation algorithm that on input <span class="math">1^{k}</span>, for randomizer <span class="math">r</span>, outputs a new secret/public key pair <span class="math">(\\mathsf{sk},\\mathsf{pk})\\leftarrow\\mathsf{GenPkc}(1^{k})</span>, <span class="math">\\mathsf{Enc}</span> is a randomized encryption algorithm with <span class="math">c=\\mathsf{Enc}_{\\mathsf{pk}}(m;r)</span>, and <span class="math">\\mathsf{Dec}</span> is a decryption algorithm with <span class="math">\\mathsf{Dec}_{\\mathsf{sk}}(c)=m^{\\prime}</span>. If <span class="math">(\\mathsf{sk},\\mathsf{pk})\\leftarrow\\mathsf{GenPkc}(1^{k})</span>, then <span class="math">\\mathsf{Dec}_{\\mathsf{sk}}(\\mathsf{Enc}_{\\mathsf{pk}}(m;r))=m</span> for all valid <span class="math">m</span> and <span class="math">r</span>. We denote <span class="math">\\mathsf{Enc}_{\\mathsf{pk}}(m;r)</span> for a randomly chosen <span class="math">r</span> by <span class="math">\\mathsf{Enc}_{\\mathsf{pk}}(m)</span>. A public-key cryptosystem is CPA-secure if the ciphertext distributions corresponding to any two plaintext messages are computationally indistinguishable.</p>

    <p class="text-gray-300">In the Elgamal cryptosystem <em>[x14]</em>, one fixes a cyclic group <span class="math">\\mathbb{G}</span> of prime order <span class="math">2^{2k+1}&gt;q&gt;2^{2k}</span>, together with a generator <span class="math">g</span> of <span class="math">\\mathbb{G}</span>. Then, <span class="math">\\mathsf{GenPkc}(1^{k})</span> generates a random <span class="math">\\mathsf{sk}\\leftarrow\\mathbb{Z}_{q}</span>, and sets <span class="math">\\mathsf{pk}\\leftarrow g^{\\mathsf{sk}}</span>. On input <span class="math">m\\in\\mathbb{G}</span>, the encryption algorithm generates a new random <span class="math">r\\leftarrow\\mathbb{Z}_{q}</span>, and sets <span class="math">\\mathsf{Enc}_{\\mathsf{pk}}(m;r):=(m\\cdot\\mathsf{pk}^{r},g^{r})</span>. On input <span class="math">c=(c_{1},c_{2})\\in\\mathbb{G}^{2}</span>, the decryption algorithm outputs <span class="math">m^{\\prime}\\leftarrow c_{1}/c_{2}^{\\mathsf{sk}}</span>. Elgamal is multiplicatively homomorphic. That is, <span class="math">\\mathsf{Dec}_{\\mathsf{sk}}(\\mathsf{Enc}_{\\mathsf{pk}}(m_{1};r_{1})\\cdot\\mathsf{Enc}_{\\mathsf{pk}}(m_{2};r_{2}))=m_{1}\\cdot m_{2}</span> for all <span class="math">(\\mathsf{sk},\\mathsf{pk})\\in\\mathsf{GenPkc}(1^{k})</span>, and all <span class="math">m,r_{1},r_{2}</span>. The Elgamal cryptosystem is CPA-secure under the decisional Diffie-Hellman assumption.</p>

    <p class="text-gray-300">Commitment Schemes. Let <span class="math">\\mathsf{COM}=(\\mathsf{GenCom},\\mathsf{Com},\\mathsf{Open})</span> be a commitment scheme, where <span class="math">\\mathsf{GenCom}</span> is a randomized key generation algorithm that on input <span class="math">1^{k}</span> outputs a new public key <span class="math">\\mathsf{pk}\\leftarrow\\mathsf{GenCom}(1^{k})</span>, <span class="math">\\mathsf{Com}</span> is a randomized encryption algorithm with <span class="math">(c,d)=\\mathsf{Com}_{\\mathsf{pk}}(m;r^{\\prime})</span> where <span class="math">c</span> is the commitment and <span class="math">d</span> is the decommitment value, and <span class="math">\\mathsf{Open}</span> is an opening algorithm with <span class="math">\\mathsf{Open}_{\\mathsf{pk}}(c,d)=m^{\\prime}</span>. It is required that if <span class="math">\\mathsf{pk}\\leftarrow\\mathsf{GenCom}(1^{k})</span>, then <span class="math">\\mathsf{Open}_{\\mathsf{pk}}(\\mathsf{Com}_{\\mathsf{pk}}(m;r^{\\prime}))=m</span> for all valid <span class="math">m</span> and <span class="math">r^{\\prime}</span>. We denote <span class="math">\\mathsf{Com}_{\\mathsf{pk}}(m;r)</span> for a randomly chosen <span class="math">r</span> also just as <span class="math">\\mathsf{Com}_{\\mathsf{pk}}(m)</span>. A (statistically hiding) commitment algorithm is required to be statistically hiding (that is, the distributions of commitments of any two messages are statistically close) and computationally binding (no polynomial-time adversary can open a commitment to two different messages, except with a negligible probability).</p>

    <p class="text-gray-300">The Pedersen commitment scheme <em>[x22]</em> works in the same setting as the Elgamal cryptosystem, in a group <span class="math">\\mathbb{G}</span> of prime order <span class="math">q</span>, with generator <span class="math">g</span>. Here, <span class="math">\\mathsf{GenCom}(1^{k})</span> generates a random <span class="math">\\mathsf{pk}\\leftarrow\\mathbb{G}</span>. On input <span class="math">m\\in\\mathbb{G}</span>, the commitment algorithm generates a random <span class="math">r\\leftarrow\\mathbb{Z}_{q}</span>, and sets <span class="math">\\mathsf{Com}_{\\mathsf{pk}}(m;r):=(m\\cdot\\mathsf{pk}^{r},r)</span>. Thus, <span class="math">m\\cdot\\mathsf{pk}^{r}</span> is the commitment value, and <span class="math">d=r</span> is the decommitment value. On input <span class="math">(c,r)</span>, the opening algorithm outputs <span class="math">\\mathsf{Open}_{\\mathsf{pk}}(c,r)=c/\\mathsf{pk}^{r}</span>. If the decisional Diffie-Hellman assumption holds, then the Pedersen commitment scheme is statistically hiding and computationally binding.</p>

    <p class="text-gray-300">Non-Interactive Zero-Knowledge Proof of Knowledge. Let <span class="math">L</span> be an arbitrary NP-language, and let <span class="math">R=\\{(x,y)\\}</span> where <span class="math">x\\in L</span> and <span class="math">y</span> is the corresponding NP-witness. A <span class="math">\\Sigma</span>-protocol <span class="math">(P_{1},V_{1},P_{2},V_{2})</span> for a relation <span class="math">R</span> is a three-message protocol between a prover and a verifier (both stateful), such that (1) the prover and verifier have a common input <span class="math">x</span>, and the prover has a private input <span class="math">y</span>, (2) the prover sends the first (<span class="math">P_{1}</span>) and the third (<span class="math">P_{2}</span>) message, and the verifier sends the second message <span class="math">V_{1}</span>, after which the verifier either rejects or accepts (by using <span class="math">V_{2}</span>), (3) the protocol is public-coin: i.e., the verifier chooses her response <span class="math">V_{1}</span> completely randomly from some predefined set, (4) the protocol satisfies the security properties of correctness, special honest-verifier zero-knowledge (SHVZK), and special soundness. A protocol run is the tuple <span class="math">(x;\\mathsf{i},\\mathsf{c},\\mathsf{r})</span> where <span class="math">(\\mathsf{i},\\mathsf{c},\\mathsf{r})</span> are the three messages of this protocol. A protocol run is <em>accepting</em>, if an honest verifier accepts this run, on having input <span class="math">x</span> and seeing the messages <span class="math">\\mathsf{i}</span>, <span class="math">\\mathsf{c}</span>, and <span class="math">\\mathsf{r}</span>.</p>

    <p class="text-gray-300">More precisely, a <span class="math">\\Sigma</span>-protocol is <em>correct</em> if for any <span class="math">(x,y)\\in R</span>, an honest verifier accepts all runs with an honest prover. A <span class="math">\\Sigma</span>-protocol has the property of <em>special soundness</em> if one can construct an efficient simulator that, given any two accepting runs <span class="math">(x;\\mathsf{i},c_{1},\\mathsf{r}_{1})</span> and <span class="math">(x;\\mathsf{i},c_{2},\\mathsf{r}_{2})</span> with <span class="math">c_{1}\\neq c_{2}</span>, outputs a <span class="math">y</span> such that <span class="math">(x,y)\\in R</span>. A <span class="math">\\Sigma</span>-protocol has the property of SHVZK if there exists an efficient simulator that, given as input an arbitrary <span class="math">x\\in L</span> (without corresponding <span class="math">y</span>), can construct accepting runs <span class="math">(x;\\mathsf{i}^{<em>},\\mathsf{c}^{</em>},\\mathsf{r}^{<em>})</span> such that (a) the simulator starts by choosing <span class="math">\\mathsf{c}^{</em>}</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{r}^{<em>}</span>, and only then computes <span class="math">\\mathfrak{i}^{</em>}</span>, and (b) the resulting distribution <span class="math">(x;\\mathfrak{i}^{<em>},\\mathfrak{c}^{</em>},\\mathfrak{r}^{*})</span> is computationally indistinguishable from the distribution <span class="math">(x;\\mathfrak{i},\\mathfrak{c},\\mathfrak{r})</span> of runs between an honest prover and an honest verifier.</p>

    <p class="text-gray-300">Based on an arbitrary <span class="math">\\Sigma</span>-protocol, one can build a non-interactive zero-knowledge (NIZK) proof of knowledge in the random oracle model, by using the Fiat-Shamir heuristic <em>[x10]</em>. I.e., given <span class="math">(x,y)\\in R</span> and a random oracle <span class="math">H</span> <em>[x3]</em>, the corresponding NIZK proof of knowledge <span class="math">\\pi</span> is equal to <span class="math">(\\mathfrak{i},\\mathfrak{c},\\mathfrak{r})</span>, where <span class="math">\\mathfrak{i}\\leftarrow P_{1}(x,y)</span>, <span class="math">\\mathfrak{c}\\leftarrow H(param,x,\\mathfrak{i})</span>, and <span class="math">\\mathfrak{r}\\leftarrow P_{2}(x,y,\\mathfrak{c})</span>, where <span class="math">param</span> is the set of public parameters (like the description of the underlying group, etc). See <em>[x9]</em>. We use the next common notation. A NIZK proof of knowledge <span class="math">\\mathrm{PK}(\\alpha,\\cdots:R(\\dots))</span> is for relation <span class="math">R</span>, where the prover has to prove the knowledge of variables denoted by Greek letters <span class="math">\\alpha,\\dots</span>. All other variables are known to both the prover and the verifier. E.g., <span class="math">\\mathrm{PK}(\\mu,\\rho:y=\\mathsf{Enc}_{\\mathsf{pk}}(\\mu;\\rho)\\wedge\\mu\\in\\{0,1\\})</span> denotes a NIZK proof of knowledge that the prover knows a Boolean <span class="math">\\mu</span> and some <span class="math">\\rho</span> such that <span class="math">y=\\mathsf{Enc}_{\\mathsf{pk}}(\\mu;\\rho)</span>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Previous Code-Verification Voting Protocols</h2>

    <p class="text-gray-300">The Heiberg-Lipmaa-Van Laenen Protocol. We provide a longer description of the Heiberg, Lipmaa and Van Laenen <em>[x14]</em> code-verification protocol in App. A.</p>

    <p class="text-gray-300">The Heiberg-Lipmaa-Van Laenen protocol provides security against any single party. More precisely, it achieves privacy against a malicious vote collector or a messenger (but not against their coalition, or against the voter PC). It provides correctness in the presence of either a malicious voter PC, a semihonest vote collector (correctness against a malicious vote collector is achievable, but costly), and a semihonest messenger, but not against their coalitions. One can achieve additional privacy and correctness by including a cryptographic shuffle. See <em>[x14]</em> for more details.</p>

    <p class="text-gray-300">Gjøsteen’s Protocol. Recently, Gjøsteen <em>[x16]</em> proposed a more efficient Internet voting protocol in the same setting, where the (online) computational complexity of the protocol does not depend on <span class="math">\\Gamma</span>. In Gjøsteen’s protocol, the values <span class="math">\\mathsf{Code}_{v}[c]</span> are not random, but computed as a superposition of three pseudorandom functions: one pseudorandom function by the voter PC, another one (exponentiation by a random integer <span class="math">y_{v}</span>) by the vote collector (named the ballot box in <em>[x16]</em>), and the third one by the messenger (named the receipt generator in <em>[x16]</em>). Thus, the final pseudorandom mapping <span class="math">c\\mapsto\\mathsf{Code}_{v}[c]</span> is a composition of those three pseudorandom functions. Due to this trick, one does not have to use the costly proxy oblivious transfer protocol, and in particular, the computational complexity of Gjøsteen’s protocol does not depend on <span class="math">\\Gamma</span>. The revoting part is handled similarly as in <em>[x14]</em>. Currently, it seems that Gjøsteen’s protocol will be used in Norwegian Internet voting.</p>

    <p class="text-gray-300">As a drawback compared to the Heiberg-Lipmaa-Van Laenen protocol, Gjøsteen’s protocol requires an offline setup phase, where a number of trusted servers—the process is not specified in <em>[x16]</em>—compute the values <span class="math">\\mathsf{Code}_{v}[c]</span> for every <span class="math">c</span> and <span class="math">v</span>. To do this, the setup servers must possess all secrets, required to evaluate all three pseudorandom functions. On the one hand, presence of such a setup phase seems to be necessary for the Gjøsteen’s optimization to work. On the other hand, the setup servers have to be highly secured, and they also must have secure access to the prechannel but also secure channels to all voter PCs, the vote collector, and the messenger, to forward them the corresponding secrets. We emphasize however, that since the setup phase is an offline step, one can use time-consuming cryptographic techniques (without going into details, secure multi-party computation) to secure the operation of the setup servers. To secure the channels, one must use organizational means decoupled with strong cryptography. As in <em>[x16]</em>, we will omit further discussion of the setup phase. The Norwegian government seems to be aware of these problems, see <em>[x5, slide 16]</em>, where it is stated that pre-election sharing of secrets is cumbersome and vulnerable. However, they see it as a necessary evil. The setup phase will also be present in the new code-verification voting protocols of the current paper.</p>

    <p class="text-gray-300">As another drawback, in Gjøsteen’s protocol it is assumed that the coalition of two online servers (the messenger and the vote collector) share tallier’s secret key, which makes the protocol less accountable since the coalition of malicious online servers can sometimes accuse honest tallier, and vice versa. Another obvious attack is when a dishonest vote collector sends the votes to the dishonest messenger for decryption. (The same attack can also be applied to the Heiberg-Lipmaa-Van Laenen protocol.) Thus, the privacy can be breached even when the tallier is honest. This is a serious problem in practice, since in the real Internet voting systems, the vote tallying should be performed offline, and thus it is not so easy to attack the tallier. Moreover, the functions of the tallier can be distributed by using say mix-nets, and the computational cost of this is not so important since tallying is done after the Internet voting period ends. However, the vote collector and the messenger are online entities, and distributing them would be computationally costly. Thus, we emphasize that in an Internet voting protocol, malicious online servers should not be able to breach the voter privacy.</p>

    <p class="text-gray-300">Interestingly, even if the messenger and the tallier did not share the same key pair, it is still possible for the coalition of online servers to breach the voter privacy, since together they can compute the output <span class="math">y=f(c)</span></p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. The first new code-verification protocol, simplified</p>

    <p class="text-gray-300">of the first pseudorandom function (the one, computed by the voter PC) on  <span class="math">c</span> , and they can just check whether  <span class="math">y = f(c^{<em>})</span>  for some candidate  <span class="math">c^{</em>}</span> . One could try to solve this problem by assuming that every voter PC has a different pseudorandom function  <span class="math">f_{v}</span> , not known by the online servers, but known by the tallier. However, in this case the tallier would obtain voter-dependent values  <span class="math">f_{v}(c)</span>  which is bad from the privacy viewpoint.</p>

    <p class="text-gray-300">We now present a slightly more precise description of Gjøsteen's protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The voter's PC Elgamal-encrypts (the garbled) vote  <span class="math">f(c)</span>  (the function  <span class="math">f</span>  is not precisely specified in [Gjø10]) by using a product (Elgamal) public key  <span class="math">\\mathsf{pkt} = \\mathsf{pkvc} \\cdot \\mathsf{pkm}</span>  of public keys of the vote collector and the messenger. The result is  <span class="math">\\mathsf{Enc}_{\\mathsf{pkt}}(f(c)) = \\mathsf{Enc}_{\\mathsf{pkm}\\cdot \\mathsf{pkvc}}(f(c);r) = (f(c)\\mathsf{pkt}^r,g^r)</span>  for random  <span class="math">r</span> .</li>

      <li>The vote collector decrypts the ciphertext partially, by applying the knowledge of her secret key skvc, and then takes the resulting ciphertext  <span class="math">\\mathsf{Enc}_{\\mathsf{pkm}}(f(c)) \\gets (f(c)\\mathsf{pkt}^r / (g^r)^{\\mathsf{skvc}}, g^r) = (f(c)\\mathsf{pkm}^r, g^r)</span>  to the power  <span class="math">x_v</span> , where  <span class="math">x_v</span>  is a voter-dependent secret key. He sends  <span class="math">\\mathsf{Enc}_{\\mathsf{pkm}}(f(c)^{x_v}) = (f(c)^{x_v}\\mathsf{pkt}^{rx_v}, g^{rx_v})</span>  to the messenger.</li>

      <li>The messenger decrypts the message, and obtains  <span class="math">f(c)^{x_v}</span> . He applies another pseudorandom function  <span class="math">h</span>  to this, obtaining  <span class="math">h(f(c)^{x_v})</span> .</li>

    </ol>

    <p class="text-gray-300">To achieve security in the malicious model, the second step has to be accompanied by a NIZK proof of correctness. This NIZK proof is somewhat expensive — while it was not specified in [Gjø10], by our calculations, it requires the prover (the voter PC) to perform 5 exponentiations, and the verifier to perform 9 exponentiations. In the case the keys of the tallier and the messenger were separated to tackle the mentioned accountability problem, it seems that the vote collector would also have to partially decrypt (and present a NIZK proof of correctness) the ciphertext that the voter PC meant to send to the tallier. Finally, Gjøsteen's paper [Gjø10] does not specify the secret keys, or what pseudorandom functions will really be used. In the new protocols, we have tried to be more precise on such accounts.</p>

    <p class="text-gray-300">In this section, we propose the first new code-verification protocol. It is more efficient than the second one, but it does not provide privacy against the coalition of online servers. A simplified version of this protocol is depicted by Fig. 1.</p>

    <p class="text-gray-300">Setting. Let garble = {garblek1} be a public pseudorandom function family where every garblek1 is a function from the set of all candidates  <span class="math">\\{c\\}</span>  to  <span class="math">\\mathbb{G}</span> . We implement garblek1 as garblek1(c) :=  <span class="math">g^{\\mathrm{AESk1}(c)}</span> , where  <span class="math">g</span>  is a fixed generator of  <span class="math">\\mathbb{G}</span> . Here, k1 is not known by the messenger and the tallier, while it is known to the voter PCs. All voter PCs  <span class="math">v</span>  have a secret key  <span class="math">x_v \\gets \\mathbb{Z}_p</span> . The voter PCs publish the values  <span class="math">h_v \\gets g^{x_v}</span> . Let prf be another public pseudorandom function family (in practice, AES followed by truncation) from  <span class="math">\\mathbb{G}</span>  (in practice, from some one-to-one bit-representation of the elements of  <span class="math">\\mathbb{G}</span> ) to the set of codes. The messenger also has a secret key k2 for prf.</p>

    <p class="text-gray-300">Setup phase. As in <em>[x10]</em>, the new protocols need a setup phase. During the setup phase—before the Internet voting starts—, some trusted third parties compute jointly all the integrity check codes. Since this process must finish before Internet voting starts, one can use any of the existing secure multi-party computation based protocols, by using a set of independent setup servers, in this phase. (See <em>[x10]</em> for a discussion. As already mentioned, the Norwegian government is aware of the accompanying problems, and has accepted them due to the lack of efficient setup-less solutions.) More precisely, one integrity check code <span class="math">\\mathsf{Code}_{v}[c]</span> is computed as <span class="math">\\mathsf{Code}_{v}[c]=\\mathsf{prf}_{\\mathsf{k2}}(h_{v}^{\\mathsf{AES}_{\\mathsf{k1}}(c)})</span>. Thus, the setup servers have to know (in a secret-shared form) the values <span class="math">\\mathsf{k1}</span>, <span class="math">h_{v}</span> and <span class="math">\\mathsf{k2}</span>. Note that <span class="math">h_{v}\\leftarrow g^{x_{v}}</span> for a random secret <span class="math">x_{v}</span>. The setup servers securely forward the values <span class="math">\\mathsf{Code}_{v}[c]</span> to the party who later sends the codes to the voters over prechannel, and also send <span class="math">\\mathsf{k1}</span> to all potential voter PCs, <span class="math">\\mathsf{k2}</span> to the messenger, <span class="math">h_{v}</span> and <span class="math">x_{v}</span> to the voter <span class="math">v</span>’s PC. The key <span class="math">\\mathsf{k1}</span> must remain secret from the tallier, but has to be sent to the auditors (see the description of the tallier’s operation later in this section).</p>

    <p class="text-gray-300">Protocol: One Internet Vote Attempt. Voter <span class="math">v</span> casts a vote for candidate <span class="math">c\\in\\mathbb{Z}</span>, that is, inputs <span class="math">c</span> to the PC by using some user interface, not necessarily as a number. The voter PC prepares two encryptions of the vote <span class="math">c</span>, as <span class="math">E_{t}\\leftarrow\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathsf{AES}_{\\mathsf{k1}}(c)})=\\mathsf{Enc}_{\\mathsf{pkt}}(\\mathsf{garble}_{\\mathsf{k1}}(c))</span> and <span class="math">E_{m}\\leftarrow\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathsf{AES}_{\\mathsf{k1}}(c)})=\\mathsf{Enc}_{\\mathsf{pkm}}(\\mathsf{garble}_{\\mathsf{k1}}(c)^{x_{v}})</span>, where <span class="math">\\mathsf{pkt}</span> is the tallier’s public key and <span class="math">\\mathsf{pkm}</span> is the messenger’s public key. It then generates a non-interactive zero-knowledge proof of knowledge for</p>

    <p class="text-gray-300"><span class="math">\\pi=\\mathrm{PK}(\\mu_{1},\\mu_{2},\\rho_{1},\\rho_{2}:E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mu_{1}};\\rho_{1})\\wedge E_{m}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mu_{1}};\\rho_{2})\\wedge h_{v}=g^{\\mu_{2}})\\enspace,</span> (1)</p>

    <p class="text-gray-300">that is, that the decryption of <span class="math">E_{m}</span> (under the secret key of the messenger) is equal to the <span class="math">x_{v}</span>th power of the decryption of <span class="math">E_{t}</span> (under the secret key of the tallier), and in addition it knows the value <span class="math">x_{v}</span>. The voter’s PC generates a random number <span class="math">sid</span> (session ID of this protocol instance).</p>

    <p class="text-gray-300">It then signs <span class="math">\\sigma\\leftarrow\\mathsf{Sign}_{v}(sid,\\mathbf{1},v,E_{t},E_{m},\\pi,time_{v})</span> (where <span class="math">time_{v}</span> is the time of voting according to the PC’s clock, and <span class="math">\\mathbf{1}</span> is included as a unique marker that separates this signature from signatures given in other purposes), and sends the result</p>

    <p class="text-gray-300"><span class="math">(sid,\\mathbf{1},v,E_{t},E_{m},\\pi,time_{v},\\sigma)</span></p>

    <p class="text-gray-300">to the vote collector.</p>

    <p class="text-gray-300">The vote collector verifies the signature and the NIZK proof. Upon success, the vote collector computes signature <span class="math">\\sigma^{\\prime}\\leftarrow\\mathsf{Sign}_{vc}(sid,\\mathbf{2},v,E_{m},\\pi^{\\prime},time_{vc})</span> (where <span class="math">time_{vc}</span> is the time when the vote collector received this vote) and sends</p>

    <p class="text-gray-300"><span class="math">(sid,\\mathbf{2},v,E_{t},E_{m},\\pi,time_{v},\\sigma,\\pi^{\\prime},time_{vc},\\sigma^{\\prime})</span></p>

    <p class="text-gray-300">to the messenger. The messenger verifies both signatures <span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span>, and the NIZK proof <span class="math">\\pi</span>. Upon success, he decrypts <span class="math">E_{m}</span>, obtaining <span class="math">\\mathsf{garble}_{\\mathsf{k1}}(c)^{x_{v}}=h_{v}^{\\mathsf{AES}_{\\mathsf{k1}}(c)}</span>. (Thus, the messenger should either not know <span class="math">\\mathsf{k1}</span> or any of the values <span class="math">h_{v}</span>.) The messenger, who has another secret key <span class="math">\\mathsf{k2}</span>, then computes <span class="math">c^{\\prime}\\leftarrow\\mathsf{prf}_{\\mathsf{k2}}(\\mathsf{garble}(c)^{x_{v}})</span>, where <span class="math">\\mathsf{prf}</span> is some fixed and public pseudorandom function family. The messenger also has a lexicographically ordered table of all values <span class="math">H(\\mathsf{prf}_{\\mathsf{k2}}(\\mathsf{garble}(z)^{x_{v}}))=H(\\mathsf{Code}_{v}[z])</span> for all possible candidates <span class="math">z</span>. He checks that <span class="math">H(c^{\\prime})</span> belongs to this table (which takes <span class="math">\\Theta(\\log\\Gamma)</span> non-cryptographic operations by using binary search, where <span class="math">\\Gamma</span> is again the number of candidates, or <span class="math">\\Theta(1)</span> non-cryptographic operations by using a hash table). If it does not, then he complains to an arbiter/auditor that the voter PC cheated. This comparison step gives us some additional security, compared just to the case where the messenger sends out the SMS even when the candidate was invalid. It also saves an SMS message in the case the voter PC has encoded a bogus candidate — this can be important to avoid DDOS attacks. If such issues are not considered important, the comparison step can be omitted.</p>

    <p class="text-gray-300">If messenger’s verifications succeed, it sends <span class="math">(c^{\\prime},time_{m})</span> back to the voter by the postchannel, where <span class="math">time_{m}</span> is messenger’s current time. The voter checks that <span class="math">c^{\\prime}=\\mathsf{Code}_{v}[c]</span> where <span class="math">c</span> is a candidate he voted for at time moment approximately equal to <span class="math">time_{m}</span>. If this verification is unsuccessful, the voter revotes by using either a computer, or goes later to the voting station for paper voting.</p>

    <p class="text-gray-300">In parallel to message 2, the vote collector will store</p>

    <p class="text-gray-300"><span class="math">(sid,v,E_{t},E_{m},\\pi,\\pi^{\\prime},time_{v},time_{vc},\\sigma,\\sigma^{\\prime})\\enspace.</span></p>

    <p class="text-gray-300">If a previous such entry for the same <span class="math">v</span> existed, it will be overwritten.</p>

    <p class="text-gray-300">Postcomputation. At the end of the Internet voting period, the vote collector will forward all stored entries, with the entire file (i.e., the collection of all stored entries) signed once by the vote collector, to the tallier. To eliminate the trust in vote collector, this step must be implemented by using a vote shuffle protocol, see e.g. <em>[x12, x13]</em>.)</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Tallier’s Operation. After receiving all (encrypted) votes from the vote collector, a semihonest tallier verifies two signatures (<span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span>) per voter, and then decrypts all values <span class="math">E_{t}</span>, obtaining values <span class="math">d=\\mathsf{garble}_{\\mathsf{k1}}(\\cdot)</span> for some candidates. To provide security against malicious tallier, one can use standard cryptographic techniques (mixnet followed by NIZK proofs of correct decryption). As mentioned before, this step is outside of the scope of the current paper. The mixnets and corresponding NIZK proofs are however standard in cryptographic literature. See <em>[x11]</em> for discussion.</p>

    <p class="text-gray-300">She will then tally the votes, and then send the tally <span class="math">\\{(\\sharp votes,\\mathsf{garble}_{\\mathsf{k1}}(c))\\}</span> for garbled candidates to the auditors (human beings). The auditors have a (say in a printed) sorted list <span class="math">\\{(\\mathsf{garble}_{\\mathsf{k1}}(c),c)\\}</span> for all candidates <span class="math">c</span>, and thus can associate the tallies with real candidates <span class="math">c</span>, getting a list <span class="math">\\{(\\sharp votes,c)\\}</span>. This list is finally published.</p>

    <p class="text-gray-300">The final step of the tallier can be implemented differently, depending on the desired trade-off between the security, the cost of implementation and the usability. In the first alternative, there is another server (independent of the tallier), who has access to the table <span class="math">\\{(\\mathsf{garble}_{\\mathsf{k1}}(c),c)\\}</span>. This server receives the list <span class="math">\\{(\\sharp votes,\\mathsf{garble}_{\\mathsf{k1}}(c))\\}</span> from the tallier, and then outputs the list <span class="math">\\{(\\sharp votes,c)\\}</span>. That step requires very little computational power if we trust this server — otherwise, the server might need to output a NIZK proof of correct operation. This alternative has better usability (since human beings do not have to associate the lists), essentially the same security (since here the tallier does not know the actual candidates), but one more server compared to the solution of the previous paragraph. In the second alternative, the tallier actually has access to the list <span class="math">\\{(\\mathsf{garble}_{\\mathsf{k1}}(c),c)\\}</span> and thus can compute the tally <span class="math">\\{(\\sharp votes,c)\\}</span> by herself. This alternative has better usability (since human beings do not have to associate the lists), the same cost but somewhat worse security (since if the tallier is not honest, she can ignore votes cast for candidates she does not like) compared to the solution in the previous paragraph. That problem can be alleviated by raising computational cost by letting the server to present a (relatively costly) NIZK proof of correct operation.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">4.1 Non-Interactive Zero-Knowledge Proof</h3>

    <p class="text-gray-300">We need a NIZK proof of knowledge for <span class="math">\\mathrm{PK}(\\mu_{1},\\mu_{2},\\rho_{1},\\rho_{2}:E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mu_{1}};\\rho_{1})\\wedge E_{m}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mu_{1}};\\rho_{2})\\wedge h_{v}=g^{\\mu_{2}})</span>. The interactive version of this NIZK (that is, a <span class="math">\\Sigma</span>-protocol) is as follows (assuming that <span class="math">g</span> is a group generator, <span class="math">k\\geq 80</span> is the security parameter, and <span class="math">q</span> is the order of the group):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover generates <span class="math">m_{1},m_{2},r_{1},r_{2}\\leftarrow\\mathbb{Z}_{q}</span>, and sets <span class="math">\\mathfrak{i}_{1}\\leftarrow\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}};r_{1})</span>, <span class="math">\\mathfrak{i}_{2}\\leftarrow\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{m_{1}};r_{2})</span>, <span class="math">\\mathfrak{i}_{3}\\leftarrow g^{m_{2}}</span>. He sends <span class="math">(\\mathfrak{i}_{1},\\mathfrak{i}_{2},\\mathfrak{i}_{3})</span> to the verifier.</li>

      <li>The verifier sends <span class="math">\\mathfrak{c}\\leftarrow\\{0,1\\}^{k}</span> to the prover.</li>

      <li>The prover sends <span class="math">\\mathfrak{r}_{1}\\leftarrow m_{1}+\\mathfrak{c}\\cdot\\mu_{1}</span>, <span class="math">\\mathfrak{r}_{2}\\leftarrow r_{1}+\\mathfrak{c}\\cdot\\rho_{1}</span>, <span class="math">\\mathfrak{r}_{3}\\leftarrow r_{2}+\\mathfrak{c}\\cdot\\rho_{2}</span>, <span class="math">\\mathfrak{r}_{4}\\leftarrow m_{2}+\\mathfrak{c}\\cdot\\mu_{2}</span> to the verifier.</li>

      <li>The verifier accepts iff <span class="math">\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})=\\mathfrak{i}_{1}\\cdot E_{t}^{\\mathfrak{r}}</span>, <span class="math">\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{r}_{1}};\\mathfrak{r}_{3})=\\mathfrak{i}_{2}\\cdot E_{m}^{\\mathfrak{r}}</span> and <span class="math">g^{\\mathfrak{r}_{4}}=\\mathfrak{i}_{3}\\cdot h_{v}^{\\mathfrak{r}}</span>.</li>

    </ol>

    <p class="text-gray-300">The proof that this <span class="math">\\Sigma</span>-protocol satisfies the properties of correctness, special soundness and SHVZK is standard.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">The above <span class="math">\\Sigma</span>-protocol is correct and satisfies the properties of special soundness and special honest-verifier zero-knowledge.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness. Clearly, <span class="math">\\mathfrak{i}_{1}\\cdot E_{t}^{\\mathfrak{r}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}};r_{1})\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{c}\\cdot\\mu_{1}};\\mathfrak{c}\\cdot\\rho_{1})=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}+\\mathfrak{c}\\cdot\\mu_{1}};r_{1}+\\mathfrak{c}\\cdot\\rho_{1})=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})</span>, <span class="math">\\mathfrak{i}_{2}\\cdot E_{m}^{\\mathfrak{r}}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{m_{1}};r_{2})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{c}\\cdot\\mu_{1}};\\mathfrak{c}\\cdot\\rho_{2})=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{m_{1}+\\mathfrak{c}\\cdot\\mu_{1}};r_{2}+\\mathfrak{c}\\cdot\\rho_{2})=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{r}_{4}};\\mathfrak{r}_{3})</span> and <span class="math">\\mathfrak{i}_{3}\\cdot h_{v}^{\\mathfrak{c}}=g^{m_{2}+\\mathfrak{c}\\cdot\\mu_{2}}=g^{\\mathfrak{r}_{4}}</span>.</p>

    <p class="text-gray-300">Special soundness. First, assume that <span class="math">\\mathfrak{i}_{1}\\cdot E_{t}^{\\mathfrak{c}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})</span> and <span class="math">\\mathfrak{i}_{1}\\cdot E_{t}^{\\mathfrak{c}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{2}^{\\prime})</span>, where <span class="math">\\mathfrak{c}\\neq\\mathfrak{c}^{\\prime}</span>. Then <span class="math">E_{t}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})</span>, and thus <span class="math">E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{(\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})};(\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime}))</span>. Thus, given two accepting views, one can find <span class="math">\\mu_{1}=(\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>, and <span class="math">\\rho_{1}=(\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>, such that <span class="math">E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mu_{1}};\\rho_{1})</span>.</p>

    <p class="text-gray-300">Second, assume that <span class="math">\\mathfrak{i}_{2}\\cdot E_{m}^{\\mathfrak{r}}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{r}_{1}};\\mathfrak{r}_{3})</span> and <span class="math">\\mathfrak{i}_{2}\\cdot E_{m}^{\\mathfrak{r}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{3}^{\\prime})</span>. Then <span class="math">E_{m}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{3}-\\mathfrak{r}_{3}^{\\prime})</span>, or <span class="math">E_{m}=\\mathsf{Enc}_{\\mathsf{pkm}}(h_{v}^{\\mu_{1}};\\rho_{2})</span> for <span class="math">\\mu_{1}=(\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span> (as before) and <span class="math">\\rho_{2}=(\\mathfrak{r}_{3}-\\mathfrak{r}_{3}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>.</p>

    <p class="text-gray-300">Third, assume that <span class="math">\\mathfrak{i}_{3}\\cdot h_{v}^{\\mathfrak{c}}=g^{\\mathfrak{r}_{4}}</span> and <span class="math">\\mathfrak{i}_{3}\\cdot h_{v}^{\\mathfrak{c}^{\\prime}}=g^{\\mathfrak{r}_{4}^{\\prime}}</span> for <span class="math">\\mathfrak{c}\\neq\\mathfrak{c}^{\\prime}</span>. Then <span class="math">h_{v}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=g^{\\mathfrak{r}_{4}-\\mathfrak{r}_{4}^{\\prime}}</span>, or <span class="math">h_{v}=g^{\\mu_{2}}</span> for <span class="math">\\mu_{2}=(\\mathfrak{r}_{4}-\\mathfrak{r}_{4}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>.</p>

    <p class="text-gray-300">Special honest-verifier zero-knowledge. The simulator can first choose all values <span class="math">\\mathfrak{c}</span>, <span class="math">\\mathfrak{r}_{1}</span>, …, <span class="math">\\mathfrak{r}_{4}</span> randomly, and then choose <span class="math">\\mathfrak{i}_{1}</span>, <span class="math">\\mathfrak{i}_{2}</span> and <span class="math">\\mathfrak{i}_{3}</span> such that they satisfy the verification. For example, <span class="math">\\mathfrak{i}_{3}\\leftarrow h_{v}^{-\\mathfrak{r}}\\cdot g^{\\mathfrak{r}_{4}}</span>. Clearly, the view created by the simulator is indistinguishable from the view in an actual run, given that the verifier is honest. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Thus, one can use the Fiat-Shamir heuristic to transform it to a NIZK proof of knowledge. If Elgamal is used, the prover (that is, the voter PC) needs to perform <span class="math">6</span> exponentiations, and the verifier (the vote collector) has to perform <span class="math">9</span> exponentiations. In the actual code-verification voting protocol of this section, <span class="math">m=\\mathsf{garble}_{\\mathsf{k1}}(c)</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.2 Implementation</h3>

    <p class="text-gray-300">We consider the implementation of Elgamal by conservatively using <span class="math">283</span>-bit elliptic curves over binary fields; this corresponds to the security provided by <span class="math">141</span>-bit long symmetric keys. According to http://www.shamus.ie/index.php?page=Elliptic-Curve-point-multiplication, an elliptic point multiplication (i.e., exponentiation in Elgamal) takes on average <span class="math">3.56</span> milliseconds. We note that in Estonian Internet voting in 2009, with slightly more than <span class="math">100\\,000</span> total Internet voters, <span class="math">4\\,500</span> votes were cast during the peak hour. See http://www.vvk.ee/public/pics/EP09kokkuakt.jpg for a distribution of the number of votes per hour during that Internet voting period.</p>

    <p class="text-gray-300">The voter PC executes <span class="math">6</span> exponentiations to compute <span class="math">E_{t}</span> and <span class="math">E_{m}</span>, <span class="math">6</span> exponentiations to compute <span class="math">\\pi</span>, and <span class="math">1</span> signing. Thus in total it executes <span class="math">12</span> exponentiations (<span class="math">\\approx 42.72</span> milliseconds), and signs <span class="math">1</span> signature.</p>

    <p class="text-gray-300">The vote collector executes a signature verification, <span class="math">9</span> exponentiations to verify <span class="math">\\pi</span>, and signs one message. For exponentiations alone, he spends <span class="math">7\\cdot 3.56\\approx 32.04</span> milliseconds, and thus can handle—ignoring the time that is required to sign and verify signatures—more than <span class="math">112\\,000</span> votes per hour.</p>

    <p class="text-gray-300">The messenger verifies two signatures, verifies one NIZK proof (<span class="math">9</span> exponentiations), and performs <span class="math">1</span> exponentiation to decrypt <span class="math">E_{m}</span>, computes <span class="math">\\mathsf{prf}</span> (insignificant) and then <span class="math">\\log_{2}\\Gamma</span> non-cryptographic operations (insignificant). Thus, when we only count the <span class="math">9+1=10</span> exponentiations, the messenger can handle more than <span class="math">101\\,000</span> votes a hour, and its throughput is in practice restricted by the ability of sending messages on the postchannel. In the case the latter throughput is not sufficiently high, one can run several messengers in parallel.</p>

    <p class="text-gray-300">After the Internet voting period ends, in the simplest case the vote collector will compute only one more signature. The tallier will perform <span class="math">1</span> exponentiation (decryption) and one signature verification per voter, and then (say) sorts the values. This is very close to the optimal (<span class="math">1</span> million exponentiations can be done in about one hour), but in the case of very large scale elections, one might still need a Hardware Security Module. However, as said, the vote collector ought to perform cryptographic shuffle, and also the tallier’s operation should be secured by using mixnets and a suitable NIZK proof of correctness. Since this step is done after the Internet voting period ends, the exact computational efficiency of this step is not such a big concern.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.3 Security Guarantees</h3>

    <p class="text-gray-300">Security against Malicious Voter PC: In the code-verification voting protocol of this section, the voter PC sees the candidate name <span class="math">c</span>, and thus the protocol does not guarantee privacy against malicious PC. It is unclear how to avoid this without changing the voting user interface dramatically (e.g., by requiring the voter to enter long random numbers, as in code voting). On the other hand, the voter PC can disrupt the protocol by not forwarding the voter’s candidate (which will be detected by the voter due to the lack of a returning message from the postchannel), or sending inconsistent information (which will be detected by the NIZK proofs and/or wrong return code).</p>

    <p class="text-gray-300">Even if the voter PC could gain both the read and write access to the postchannel between the messenger and all voters (but without corrupting the messenger), creating a correct integrity check code requires it to compute <span class="math">\\mathsf{prf}_{\\mathsf{k2}}</span> on a previously unseen value <span class="math">h_{v}^{\\mathsf{AES}_{\\mathsf{k1}}(c)}</span>, which is intractable, assuming that <span class="math">\\mathsf{prf}</span> is a secure pseudorandom function family and <span class="math">\\mathsf{k2}</span> is only known to the messenger. The only bad case is if the voter PC has both the read and the write access to the postchannel, and the voter votes according to pattern A-B-A (i.e., after voting for candidate A, the same voter votes for candidate B and then again for candidate A). Now, the voter PC could send B to the vote collector, while sending the integrity check code for A over the postchannel. (See <em>[x14]</em> for discussion.) To avoid this attack, it is required that the postchannel is independent of the voter PCs (voter PCs have neither read or write access to the postchannel) — e.g., SMS. Thus we have informally proven the next lemma.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">The code-verification protocol of this section guarantees correctness against malicious voter PCs, assuming that <span class="math">\\mathsf{prf}</span> is a secure pseudorandom function family, the used signature scheme is secure, <span class="math">H</span> is a random oracle, the postchannel is independent from the voter PCs and that the voter verifies the messages obtained from the postchannel.</p>

    <p class="text-gray-300">Note that verification by voters is necessary in any case, and is not too difficult for voters. Because the biggest danger in the case of Internet voting is massively distributed malware that addresses a large number of voters,</p>

    <p class="text-gray-300">then to guarantee the correctness of Internet voting with “large probability”, it is sufficient that a sufficiently large fraction of voters verifies the correctness of codes. We omit further discussion.</p>

    <p class="text-gray-300">Security against Malicious Vote Collector: One can easily see that the next lemma holds.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Privacy against a malicious vote collector is guaranteed since Elgamal is semantically secure. The correctness of the vote collector’s first operation (sending of an encrypted check code to the messenger) is guaranteed trivially, given that the used signature scheme is secure, <span class="math">H</span> is a random oracle, and that the messenger performs all required verifications.</p>

    <p class="text-gray-300">The new voting protocol of this paper does however <em>not</em> guarantee that the vote collector forwards correct ciphertexts to the tallier. Without revoting, this could be achieved by using a standard cryptographic shuffle protocol <em>[x10, x11]</em>. With revoting, this proof will be much very complex, since the vote collector has to somehow prove that the shuffled vote was the last one from every e-voter. To prevent coercion, it is unreasonable to assume anyhow that an Internet voting protocol provides universal verifiability. Thus, we can assume that there is an internal (incorruptible) auditor (say, the tallier itself), who can verify the correctness of the shuffle, but without knowing whether the vote collector included the last e-vote from every voter. On the other hand, one should allow the voters to later go physically to a (paper-)voting station, and verify whether in their own concrete case <em>their</em> last e-vote was used.</p>

    <p class="text-gray-300">Security against Malicious Messenger: Malicious messenger can obviously always refuse sending codes on postchannel, or send codes when not asked to. In such cases the voter will be alerted, but will not be completely sure of the origin of the problem. Sending correct codes corresponding to a wrong candidate (say, for <span class="math">c</span>) is only possible when the messenger has already seen the same voter voting for exactly the same <span class="math">c</span> before, e.g., in an A-B-A pattern as before. (Note that the messenger does not know <span class="math">c</span>, he just knows that the vote is for the same <span class="math">c</span> as before.) Otherwise, the messenger has to be able to compute, from value <span class="math">c^{<em>}</span> the value <span class="math">h_{v}^{\\mathsf{AES_{k1}}(c^{</em>})}</span>, which is impossible since the messenger does not know <span class="math">\\mathsf{k1}</span>, and <span class="math">\\mathsf{AES}</span> is a pseudorandom function family. In either case, the voter sees that the code is incorrect. Thus, if verification of a integrity check code is not successful, then either the voter PC was malicious, or the messenger was malicious. If the messenger is malicious, then the voter does not see the code at all, a completely random code, or a code for incorrect candidate. Assuming that <span class="math">\\mathsf{AES}</span> is a pseudorandom function family and the messenger does not know <span class="math">\\mathsf{k1}</span>, the latter can only happen during revoting.</p>

    <p class="text-gray-300">Security against Malicious Tallier: The tallier part can be secured by using standard cryptographic techniques like mixnets. Moreover, there exist relatively efficient NIZK proofs of correct decryption. (We emphasize that specifying the shuffle protocol or the operation of tallier is not the subject of the current paper.) The fact that the tallier does not know <span class="math">\\mathsf{k2}</span>, and thus only sees values <span class="math">\\mathsf{garble_{k1}}(c)</span>, provides some additional protection in the case the shuffle fails or the tallier “fails” on nonpreferred tallies.</p>

    <p class="text-gray-300">Security against Coalition of Malicious Vote Collector <em>And</em> Messenger: The coalition of a malicious vote collector and a malicious messenger sees both the values <span class="math">h_{v}</span> and <span class="math">y=\\mathsf{garble_{k1}}(c)^{x_{v}}=h_{v}^{\\mathsf{AES_{k1}}(c)}</span>, as computed by a voter PC. Since the coalition can also recover <span class="math">\\mathsf{k1}</span> by collaborating with any of malicious voter PCs, they can test, for every candidate <span class="math">c^{<em>}</span>, whether <span class="math">y=h_{v}^{\\mathsf{AES_{k1}}(c^{</em>})}</span>, and thus completely breach the privacy of voters even in the case the voter PCs are honest.</p>

    <h2 id="sec-13" class="text-2xl font-bold">5 Second New Code-Verification Voting Protocol</h2>

    <p class="text-gray-300">As mentioned at the end of Sect. 4.3, in the code-verification voting protocol of Sect. 4, coalition of a malicious vote collector and a malicious messenger can completely breach voter privacy. To avoid this, we modify the protocol of Sect. 4 in one crucial aspect: instead of publishing the values <span class="math">h_{v}=g^{x_{v}}</span>, we publish the Pedersen commitments <span class="math">C_{v}\\leftarrow g^{x_{v}}h^{r_{v}}</span> to <span class="math">x_{v}</span>, where <span class="math">h\\leftarrow\\mathbb{G}</span> is a new random public key, and a random coin <span class="math">r_{v}</span>. This does not change the overall protocol much. In what follows, we will give a quick overview of the changes.</p>

    <p class="text-gray-300">In the setup phase, all parties have additional access to the public key <span class="math">h</span> (used by the commitment scheme, see Sect. 2), while no party knows the corresponding secret key. Instead of <span class="math">h_{v}</span>, the values <span class="math">C_{v}\\leftarrow g^{x_{v}}h^{r_{v}}</span> are published. The setup servers must also know the values <span class="math">h_{v}</span> (even if in a secret-shared form). In the actual protocol, we basically only need to replace the NIZK proof of knowledge. Instead of a NIZK proof of knowledge for Eq. (1), we need here a NIZK proof of knowledge for</p>

    <p class="text-gray-300"><span class="math">\\pi^{\\prime}=\\mathrm{PK}(\\mu_{1},\\mu_{2},\\rho_{1},\\rho_{2},\\rho_{3}:E_{t}</span> <span class="math">=\\mathsf{Enc_{pkt}}(g^{\\mu_{1}};\\rho_{1})\\wedge C_{v}=\\mathsf{Com}_{h}(g^{\\mu_{2}};\\rho_{3})\\wedge</span> (2) <span class="math">E_{m}</span> <span class="math">=\\mathsf{Enc_{pkm}}(g^{\\mu_{1}\\mu_{2}};\\rho_{2}))\\enspace,</span></p>

    <p class="text-gray-300">this proof of knowledge will be constructed in Sect. 5.1. There are no further changes between this protocol, and the code-verification protocol of Sect. 4. (Thus, also this protocol follows Fig. 1.)</p>

    <p class="text-gray-300">5.1 Second NIZK Protocol</p>

    <p class="text-gray-300">We need a NIZK proof of knowledge for Eq. (2), in the case of the Elgamal cryptosystem and the Pedersen commitment scheme. Let <span class="math">E_{t}=(e_{t1},e_{t2})</span>, where supposedly <span class="math">e_{t1}=g^{\\mu_{1}}\\mathsf{pkt}^{\\rho_{1}}</span> and <span class="math">e_{t2}=g^{\\rho_{1}}</span>. Let <span class="math">E_{m}=(e_{m1},e_{m2})</span>, where supposedly <span class="math">e_{m1}=g^{\\mu_{1}\\mu_{2}}\\mathsf{pkm}^{\\rho_{2}}</span> and <span class="math">e_{m_{2}}=g^{\\rho_{2}}</span>. Thus, we need that <span class="math">E_{m}=(g^{\\mu_{1}\\mu_{2}}\\mathsf{pkm}^{\\rho_{2}},g^{\\rho_{2}})=(e_{t1}^{\\mu_{2}}\\mathsf{pkm}^{\\rho_{2}}\\mathsf{pkt}^{-\\rho_{1}\\mu_{2}},e_{t2}^{\\mu_{2}}g^{\\rho_{2}-\\mu_{2}\\rho_{1}})=E_{t}^{\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;-\\rho_{1}\\mu_{2})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\rho_{2})</span>. To construct a truly efficient protocol, we note that for the security of the voting protocol of this section, it is not really necessary that the penultimate randomness in this expression is equal to <span class="math">-\\rho_{1}\\mu_{2}</span>. So instead of the original proof of knowledge for Eq. (2), we will next construct a <span class="math">\\Sigma</span>-protocol for <span class="math">\\mathsf{PK}(\\mu_{1},\\mu_{2},\\rho_{1},\\rho_{2},\\rho_{3},\\rho_{4}:E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mu_{1}};\\rho_{1})\\wedge C_{v}=\\mathsf{Com}_{h}(g^{\\mu_{2}};\\rho_{2})\\wedge E_{m}=E_{t}^{\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\rho_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\rho_{4}))</span>.</p>

    <p class="text-gray-300">The corresponding <span class="math">\\Sigma</span>-protocol is as follows (assuming that <span class="math">g</span> is a group generator, <span class="math">k\\geq 80</span> is the security parameter, and <span class="math">q</span> is the order of the group):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover generates <span class="math">m_{1},m_{2},r_{1},r_{2},r_{3},r_{4}\\leftarrow\\mathbb{Z}_{q}</span>, and sets <span class="math">\\mathsf{i}_{1}\\leftarrow\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}};r_{1})</span>, <span class="math">\\mathsf{i}_{2}\\leftarrow\\mathsf{Com}_{h}(g^{m_{2}};r_{2})</span>, and <span class="math">\\mathsf{i}_{3}\\leftarrow E_{t}^{m_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;r_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;r_{4})</span>. He sends <span class="math">(\\mathsf{i}_{1},\\mathsf{i}_{2},\\mathsf{i}_{3})</span> to the verifier.</li>

      <li>The verifier sends <span class="math">\\mathfrak{c}\\leftarrow\\{0,1\\}^{k}</span> to the prover.</li>

      <li>The prover sends <span class="math">\\mathfrak{r}_{1}\\leftarrow m_{1}+\\mathfrak{c}\\cdot\\mu_{1}</span>, <span class="math">\\mathfrak{r}_{2}\\leftarrow r_{1}+\\mathfrak{c}\\cdot\\rho_{1}</span>, <span class="math">\\mathfrak{r}_{3}\\leftarrow m_{2}+\\mathfrak{c}\\cdot\\mu_{2}</span>, <span class="math">\\mathfrak{r}_{4}\\leftarrow r_{2}+\\mathfrak{c}\\cdot\\rho_{2}</span>, <span class="math">\\mathfrak{r}_{5}\\leftarrow r_{3}+\\mathfrak{c}\\cdot\\rho_{3}</span>, <span class="math">\\mathfrak{r}_{6}\\leftarrow r_{4}+\\mathfrak{c}\\cdot\\rho_{4}</span> to the verifier.</li>

      <li>The verifier accepts iff <span class="math">\\mathsf{i}_{1}\\cdot E_{t}^{\\mathfrak{c}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})</span>, <span class="math">\\mathsf{i}_{2}\\cdot C_{v}^{\\mathfrak{c}}=\\mathsf{Com}_{h}(g^{\\mathfrak{r}_{3}};\\mathfrak{r}_{4})</span>, and <span class="math">\\mathsf{i}_{3}\\cdot E_{m}^{\\mathfrak{c}}=E_{t}^{\\mathfrak{r}_{3}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6})</span>.</li>

    </ol>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">The above <span class="math">\\Sigma</span>-protocol is correct and satisfies the properties of special soundness and special honest-verifier zero-knowledge.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness. Clearly, <span class="math">\\mathsf{i}_{1}\\cdot E_{t}^{\\mathfrak{c}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}};r_{1})\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{c}\\cdot\\mu_{1}};\\mathfrak{c}\\cdot\\rho_{1})=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{m_{1}+\\mathfrak{c}\\cdot\\mu_{1}};r_{1}+\\mathfrak{c}\\cdot\\rho_{1})=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})</span>, <span class="math">\\mathsf{i}_{2}\\cdot C_{v}^{\\mathfrak{c}}=\\mathsf{Com}_{h}(g^{m_{2}};r_{3})\\cdot\\mathsf{Com}_{h}(g^{\\mathfrak{c}\\cdot\\mu_{2}};\\mathfrak{c}\\cdot\\rho_{3})=\\mathsf{Com}_{h}(g^{\\mathfrak{r}_{3}};\\mathfrak{r}_{4})</span>, and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{i}_{3}\\cdot E_{m}^{\\mathfrak{c}}</span> <span class="math">=E_{t}^{m_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;r_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;r_{4})\\cdot E_{t}^{\\mathfrak{c}\\cdot\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{c}\\cdot\\rho_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{c}\\cdot\\rho_{4})</span> <span class="math">=</span> <span class="math">E_{t}^{m_{2}+\\mathfrak{c}\\cdot\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;r_{3}+\\mathfrak{c}\\cdot\\rho_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;r_{4}+\\mathfrak{c}\\cdot\\rho_{4})</span> <span class="math">=</span> <span class="math">E_{t}^{\\mathfrak{r}_{3}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6})\\enspace.</span></p>

    <p class="text-gray-300">Special soundness. First, assume that <span class="math">\\mathsf{i}_{1}\\cdot E_{t}^{\\mathfrak{c}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}};\\mathfrak{r}_{2})</span> and <span class="math">\\mathsf{i}_{1}\\cdot E_{t}^{\\mathfrak{c}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{2}^{\\prime})</span>, where <span class="math">\\mathfrak{c}\\neq\\mathfrak{c}^{\\prime}</span>. Then <span class="math">E_{t}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime}};\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})</span>, and thus <span class="math">E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{(\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})};(\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime}))</span>. Thus, given two accepting views, one can find <span class="math">\\mu_{1}=(\\mathfrak{r}_{1}-\\mathfrak{r}_{1}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>, and <span class="math">\\rho_{1}=(\\mathfrak{r}_{2}-\\mathfrak{r}_{2}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>, such that <span class="math">E_{t}=\\mathsf{Enc}_{\\mathsf{pkt}}(g^{\\mu_{1}};\\rho_{1})</span>.</p>

    <p class="text-gray-300">Second, assume that <span class="math">\\mathsf{i}_{2}\\cdot C_{v}^{\\mathfrak{c}}=\\mathsf{Com}_{h}(g^{\\mathfrak{r}_{3}};\\mathfrak{r}_{4})</span> and <span class="math">\\mathsf{i}_{2}\\cdot C_{v}^{\\mathfrak{c}^{\\prime}}=\\mathsf{Com}_{h}(g^{\\mathfrak{r}_{3}^{\\prime}};\\mathfrak{r}_{4}^{\\prime})</span>. Then <span class="math">C_{v}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=\\mathsf{Com}_{h}(g^{\\mathfrak{r}_{3}-\\mathfrak{r}_{3}^{\\prime}};\\mathfrak{r}_{4}-\\mathfrak{r}_{4})</span>, or <span class="math">C_{v}=\\mathsf{Com}_{h}(g^{\\mu_{2}};\\rho_{3})</span> for <span class="math">\\mu_{2}=(\\mathfrak{r}_{3}-\\mathfrak{r}_{3}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span> and <span class="math">\\rho_{3}=(\\mathfrak{r}_{4}-\\mathfrak{r}_{4}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>.</p>

    <p class="text-gray-300">Third, assume that <span class="math">\\mathsf{i}_{3}\\cdot E_{m}^{\\mathfrak{c}}=E_{t}^{\\mathfrak{r}_{3}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6})</span> and <span class="math">\\mathsf{i}_{2}\\cdot E_{m}^{\\mathfrak{c}^{\\prime}}=E_{t}^{\\mathfrak{r}_{5}^{\\prime}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5}^{\\prime})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6}^{\\prime})</span>. Then <span class="math">E_{m}^{\\mathfrak{c}-\\mathfrak{c}^{\\prime}}=E_{t}^{\\mathfrak{r}_{3}-\\mathfrak{r}_{3}^{\\prime}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5}-\\mathfrak{r}_{5}^{\\prime})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6}-\\mathfrak{r}_{6}^{\\prime})</span>, or <span class="math">E_{m}=E_{t}^{\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;(\\mathfrak{r}_{5}-\\mathfrak{r}_{5}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime}))\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;(\\mathfrak{r}_{6}-\\mathfrak{r}_{6}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime}))</span>. Define <span class="math">\\rho_{3}=(\\mathfrak{r}_{5}-\\mathfrak{r}_{5}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span> and <span class="math">\\rho_{4}=(\\mathfrak{r}_{6}-\\mathfrak{r}_{6}^{\\prime})/(\\mathfrak{c}-\\mathfrak{c}^{\\prime})</span>, then <span class="math">E_{m}=E_{t}^{\\mu_{2}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\rho_{3})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\rho_{4})</span> as needed.</p>

    <p class="text-gray-300">Special honest-verifier zero-knowledge. The simulator can first choose all values <span class="math">\\mathfrak{c}</span>, <span class="math">\\mathfrak{r}_{1}</span>, …, <span class="math">\\mathfrak{r}_{6}</span> randomly, and then choose <span class="math">\\mathsf{i}_{1}</span>, <span class="math">\\mathsf{i}_{2}</span> and <span class="math">\\mathsf{i}_{3}</span> such that they satisfy the verification. For example, <span class="math">\\mathsf{i}_{3}\\leftarrow E_{m}^{-\\mathfrak{c}}\\cdot E_{t}^{\\mathfrak{r}_{3}}\\cdot\\mathsf{Enc}_{\\mathsf{pkt}}(0;\\mathfrak{r}_{5})\\cdot\\mathsf{Enc}_{\\mathsf{pkm}}(0;\\mathfrak{r}_{6})</span>. Clearly, the view created by the simulator is indistinguishable from the view in an actual run, given that the verifier is honest. ∎</p>

    <p class="text-gray-300">Note that in this <span class="math">\\Sigma</span>-protocol, <span class="math">\\mathsf{i}_{3}=E_{t}^{m_{2}}\\cdot(\\mathsf{pkt}^{r_{3}}\\mathsf{pkm}^{r_{4}},g^{r_{3}+r_{4}})</span>. Thus, the prover has to perform <span class="math">10</span> exponentiations. The verifier has to perform <span class="math">17</span> exponentiations.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">5.2 Implementation of Second Protocol</h3>

    <p class="text-gray-300">From the perspective of implementation, the only substantial difference between the two new code-verification protocols is that in the protocol of Sect. 5, one requires a different NIZK protocol. Thus, in the protocol of the current section, the voter PC executes <span class="math">16</span> exponentiations, and signs <span class="math">1</span> message. The vote collector executes a signature verification, <span class="math">17</span> exponentiations to verify <span class="math">\\pi</span>, and signs one message. For exponentiations alone, he spends <span class="math">17\\cdot 3.56\\approx 60.52</span> milliseconds, and thus can handle—taking into account only time, required for exponentiations—about <span class="math">59\\,000</span> votes per hour. The messenger verifies two signatures, and performs <span class="math">18</span> exponentiations, being thus able to handle about <span class="math">56\\,000</span> messages per hour, when only counting the exponentiations.</p>

    <p class="text-gray-300">5.3 Security Guarantees of Second Protocol</p>

    <p class="text-gray-300">Most of the security analysis of Sect. 4.3 apply applies to the protocol of the current section, with one crucial difference. Namely, in the case of a coalition between malicious vote collector and malicious messenger, the coalition does not know the value <span class="math">h_{v}=g^{s_{z}}</span>, and thus cannot verify, whether the value <span class="math">y</span> is equal to <span class="math">h_{v}^{\\text{AES}_{\\text{vi}}(c)}</span> for any fixed value <span class="math">c</span> or not. Thus, in this protocol, coalition of online servers cannot breach voter privacy.</p>

    <h2 id="sec-17" class="text-2xl font-bold">6 Application to Code Voting</h2>

    <p class="text-gray-300">The code-verification voting setting is similar to that of code voting <em>[x10]</em>. The main difference is that in code-verification voting, the voters just enter <span class="math">c</span> to the PCs, by using any favorite user interface, while in code voting, the voters enter long random numbers. This makes privacy against malicious voter PCs achievable in the code-voting setting but not in the code-verification setting. However, it was felt in Norway that code-voting-like approaches were inapplicable due to usability concerns. Another important difference is that in code-verification voting, at least as it will be implemented in Norway, support for revoting is mandatory. Nevertheless, the two new code-verification voting protocols are also applicable in the code-voting setting. In a nutshell, in the case of code voting, a similar composition of two pseudorandom functions can be defined to map voter’s (pseudorandom) input code to the (pseudorandom) integrity check code. For example, one can assume that the input code of voter <span class="math">v</span> is equal to <span class="math">g^{-f_{v}(c)}</span>, where <span class="math">f_{v}</span> is some voter-specific function, unknown to the voter PC. We omit further discussion.</p>

    <p class="text-gray-300">Acknowledgments. The author was supported by Estonian Science Foundation, grant #8058, and European Union through the European Regional Development Fund.</p>

    <h2 id="sec-18" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random Oracles are Practical: A Paradigm for Designing Efficient Protocols. In Victoria Ashby, editor, ACM CCS 1993, pages 62–73, Fairfax, Virginia, 3–5 November 1993. ACM Press.</li>

      <li>[Bul10] Christian Bull. Open Source e-Voting - the Norwegian approach. In Swiss E-Voting Workshop 2010, University of Fribourg, Switzerland, September 6, 2010. Invited talk. Slides available from http://www.e-voting-cc.ch/index.php/en/workshop10, as of December 2010.</li>

      <li>[CDS94] Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of Partial Knowledge and Simplified Design of Witness Hiding Protocols. In Yvo G. Desmedt, editor, CRYPTO 1994, volume 839 of LNCS, pages 174–187, Santa Barbara, USA, August 21–25 1994. Springer-Verlag.</li>

      <li>[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The Random Oracle Methodology, Revisited. In STOC 1998, pages 209–218, New York, May 23–26, 1998.</li>

      <li>[Cha01] David Chaum. SureVote: Technical Overview. In WOTE 2001, 2001. Available from http://www.vote.caltech.edu/wote01/pdfs/surevote.pdf, as of August, 2010.</li>

      <li>[Elg85] Taher Elgamal. A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. IEEE Transactions on Information Theory, 31(4):469–472, 1985.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. How to Prove Yourself: Practical Solutions to Identification and Signature Problems. In Andrew M. Odlyzko, editor, CRYPTO 1986, volume 263 of LNCS, pages 186–194, Santa Barbara, California, USA, 11–15 August 1986. Springer-Verlag, 1987.</li>

      <li>[Gjø10] Kristian Gjøsteen. Analysis of an Internet Voting Protocol. Technical Report 2010/380, International Association for Cryptologic Research, July 5, 2010. Available at http://eprint.iacr.org/2010/380.</li>

      <li>[GL07] Jens Groth and Steve Lu. Verifiable Shuffle of Large Size Ciphertexts. In Tatsuaki Okamoto and Xiaoyun Wang, editors, PKC 2007, volume 4450 of LNCS, pages 377–392, Beijing, China, April 16–20, 2007. Springer-Verlag.</li>

      <li>[Gro03] Jens Groth. A Verifiable Secret Shuffle of Homomorphic Encryptions. In Yvo Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 145–160, Miami, Florida, USA, January6–8, 2003. Springer-Verlag.</li>

      <li>[HLV10] Sven Heiberg, Helger Lipmaa, and Filip Van Laenen. On E-Vote Integrity in the Case of Malicious Voter Computers. In Dimitris Gritzalis, Bart Preneel, and Marianthi Theoharidou, editors, ESORICS 2010, volume 6345 of LNCS, pages 373–388, Athens, Greece, September 20–22, 2010. Springer-Verlag.</li>

      <li>[Ped91] Torben P. Pedersen. Non-Interactive And Information-Theoretic Secure Verifiable Secret Sharing. In Joan Feigenbaum, editor, CRYPTO 1991, volume 576 of LNCS, pages 129–140, Santa Barbara, California, USA, August 11–15, 1991. Springer-Verlag, 1992.</li>

    </ul>

    <p class="text-gray-300">A Description of Protocol from <em>[x13]</em></p>

    <p class="text-gray-300">The code-verification voting protocol by Heiberg, Lipmaa and Van Laenen <em>[x13]</em> has computational complexity (by both the vote collector and the messenger) that is linear in the number <span class="math">\\Gamma</span> of the candidates. More precisely, in this protocol, the voter PC generates two ciphertexts <span class="math">E_{m}</span> and <span class="math">E_{t}</span> that encrypt the candidate number <span class="math">c^{*}</span>, by using respectively the public keys of the messenger and the tallier. It sends the ciphertexts, together with a non-interactive zero-knowledge (NIZK) proof of knowledge of correctness (i.e., that <span class="math">E_{m}</span> and <span class="math">E_{t}</span> encrypt the same valid candidate number), to the vote collector. The vote collector verifies the NIZK proof.</p>

    <p class="text-gray-300">Upon success, the vote collector transforms <span class="math">E_{m}</span> to an encryption of <span class="math">\\mathsf{Code}_{v}[c^{<em>}]</span> under the messenger’s public key, by using proxy oblivious transfer. The vote collector sends the result to the messenger. The messenger “decrypts” the result, obtains <span class="math">\\mathsf{Code}_{v}[c^{</em>}]</span>, and sends it to the voter (not to the voter PC!) by using the postchannel. In parallel, the vote collector retains <span class="math">E_{t}</span>. Finally, the voters can revote, and then the same protocol is executed. In particular, for every voter, the vote collector keeps the last version of <span class="math">E_{t}</span>, and after the end of the Internet voting period, forwards them to the tallier.</p>

    <p class="text-gray-300">The computational complexity of a single e-vote attempt in the Heiberg-Lipmaa-Van Laenen Internet voting protocol is dominated by that of the proxy oblivious transfer: since the codes are supposed to be random, there are no obvious ways of making the computational complexity of this step smaller than <span class="math">\\Theta(\\Gamma)</span>, where <span class="math">\\Gamma</span> is the number of candidates. (See <em>[x13]</em> for a discussion.) This is true even in the case when we only aim to achieve security against semihonest voting servers (and a malicious voter PC); achieving security against malicious voting servers will be even more costly.</p>`;
---

<BaseLayout title="Two Simple Code-Verification Voting Protocols (2011/317)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/317
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
