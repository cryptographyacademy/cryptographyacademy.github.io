---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1021';
---

<BaseLayout title="Recursive Proof Composition - Halo (2019/1021)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Recursive Proof Composition without a Trusted Setup
      </h1>
      <p class="text-gray-400 mb-2">
        Sean Bowe, Jack Grigg, Daira Hopwood
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; Full Version &middot; eprint 2019/1021
      </p>
      <div class="flex gap-4 text-sm">
        <a href={EPRINT_URL} target="_blank" rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300">
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a href={EPRINT_URL} target="_blank" rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300">cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract" class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1" class="hover:text-white">
                Our Contributions</a>
            </li>
            <li>
              <a href="#sec-1.2" class="hover:text-white">
                Concurrent Work</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1" class="hover:text-white">
                Zero-Knowledge Arguments of Knowledge</a>
            </li>
            <li>
              <a href="#sec-2.2" class="hover:text-white">
                Groups</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">
            Polynomial Commitments</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1" class="hover:text-white">
                Protocol Description</a>
            </li>
            <li>
              <a href="#sec-3.2" class="hover:text-white">
                Amortization Strategy</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">
            Nested Amortization</a>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">
            Main Argument</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1" class="hover:text-white">
                Central Argument</a>
            </li>
            <li>
              <a href="#sec-5.2" class="hover:text-white">
                Full Protocol</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">
            Implementation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-6.1" class="hover:text-white">
                Cycles of Curves</a>
            </li>
            <li>
              <a href="#sec-6.2" class="hover:text-white">
                Endomorphism-based Optimizations</a>
            </li>
            <li>
              <a href="#sec-6.3" class="hover:text-white">
                Other Optimizations</a>
            </li>
            <li>
              <a href="#sec-6.4" class="hover:text-white">
                Evaluation</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">
            Conclusion</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1" class="hover:text-white">
                Future Work</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#references" class="hover:text-white">
            References</a>
        </li>
        <li>
          <a href="#appendix-a" class="hover:text-white">
            Appendix A: Proof of Theorem 1</a>
        </li>
        <li>
          <a href="#appendix-b" class="hover:text-white">
            Appendix B: Proof of Theorem 2</a>
        </li>
        <li>
          <a href="#appendix-c" class="hover:text-white">
            Appendix C: Proof for Algorithm 1</a>
        </li>
      </ol>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Abstract</h2>
      <p class="text-gray-300">
        Non-interactive arguments of knowledge are powerful cryptographic
        tools that can be used to demonstrate the faithful execution of
        arbitrary computations with publicly verifiable proofs.
        Increasingly efficient protocols have been described in recent
        years, with verification time and/or communication complexity
        that is sublinear in the size of the computation being described.
        These efficiencies can be exploited to realize recursive proof
        composition: the concept of proofs that attest to the correctness
        of other instances of themselves, thereby allowing large
        computational effort to be incrementally verified. All previously
        known realizations of recursive proof composition have required a
        trusted setup and cycles of expensive pairing-friendly elliptic
        curves. We obtain and implement Halo, the first practical
        example of recursive proof composition without a trusted setup,
        using the discrete log assumption over normal cycles of elliptic
        curves. In the process we develop several novel techniques that
        may be of independent interest.
      </p>
      <p class="text-gray-400 text-sm mt-2">
        <strong>Keywords:</strong> recursive proofs &middot;
        incrementally verifiable computation &middot; zero knowledge
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1 INTRODUCTION                                               -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">1 Introduction</h2>

      <p class="text-gray-300">
        Proofs of knowledge [24], introduced by Goldwasser, Micali and
        Rackoff, allow us to demonstrate knowledge of a satisfying
        witness to some NP statement. If these proofs also do not reveal
        anything about the witness we refer to them as zero-knowledge
        proofs of knowledge. The works of Kilian, Micali and others
        showed that proofs of knowledge could be non-interactive, and
        that these proofs could even be smaller than the statement being
        proven. [31,33,10,9] In the decades since, significant
        reductions in the size and verification time of such protocols
        have been made, culminating in zero-knowledge succinct
        non-interactive arguments of knowledge, or zk-SNARKs for short.
        Today, the most efficient zk-SNARKs require pairing-friendly
        elliptic curves and trusted setup assumptions as in [25] but in
        return admit small, constant-size proofs with constant-time
        verification.
      </p>

      <p class="text-gray-300 mt-4">
        One of the motivating use cases for zk-SNARKs is the application
        of verifiable computation [23], whereby computations can be
        delegated to an untrusted third party who returns the result as
        well as a cryptographic proof that the result is correct. Ideally
        this proof would be asymptotically smaller and less expensive to
        check than the computation itself, a property of zk-SNARKs that
        we call succinctness. A direct consequence of a succinct argument
        is the concept of incrementally verifiable computation [36] in
        which proofs not only attest to the correct execution of a
        computation but also, by exploiting succinctness, the validity of
        a previous proof. In this way a large and virtually unbounded
        amount of computation can be verified with a single proof, and
        with this proof alone we may extend the computation with further
        proofs.
      </p>

      <p class="text-gray-300 mt-4">
        As a concrete motivation for incrementally verifiable
        computation, consider a blockchain network that requires all
        participants in the network to download the entire history of the
        blockchain and validate each individual state transition
        (transaction) merely in order to validate and process
        <em>new</em> state changes. SNARKs allow us to partially address
        this scalability problem by outsourcing some of these
        verification steps to a third party. However, the participant
        still must download and check each proof. Incrementally
        verifiable computation solves this issue, allowing a single proof
        to inductively demonstrate the correctness of many previous
        proofs. The participant in the blockchain network need only
        download the current state of the network as well as a single
        proof that this state is correct. Further proofs of state changes
        can be constructed with the latest proof alone, allowing active
        participants to prune old state changes.
      </p>

      <p class="text-gray-300 mt-4">
        We can obtain incremental verifiable computation via recursive
        proof composition, i.e. proofs that can feasibly attest to the
        correctness of other instances of themselves. These proofs can be
        used to ensure the satisfaction of compliance predicates between
        old and new states, leading to concepts such as proof-carrying
        data [19] which can be extended to obtain verifiable distributed
        computations as in [8]. The first practical realization of
        recursive proof composition was shown in [4] and relies on
        SNARKs built over pairing-friendly elliptic curves. Elliptic
        curve groups are typically instantiated over a base field
        <span class="math">\mathbb&#123;F&#125;_p</span>, but these
        groups are often of a prime order
        <span class="math">q \neq p</span> so that the SNARK
        construction, which demonstrates satisfiability of an arithmetic
        circuit over the scalar field
        <span class="math">\mathbb&#123;F&#125;_q</span>, cannot
        efficiently encode the
        <span class="math">\mathbb&#123;F&#125;_p</span> arithmetic
        needed to verify its own proofs. The authors of [4] sidestep
        this issue by constructing a 2-cycle of pairing-friendly elliptic
        curves such that the base field of either curve is the scalar
        field of the other. Unfortunately, only a single family of
        pairing-friendly curves is known to admit cycles of this form
        [16], and due to their low embedding degrees secure curves in
        this family must be constructed over large (780-bit) fields,
        disturbing performance. Perhaps more importantly, all known
        pairing-based SNARKs require a trusted setup.
      </p>

      <p class="text-gray-300 mt-4">
        In theory it should be possible to instantiate recursive proof
        composition using any zk-SNARK, and in recent years protocols
        such as STARKs [3] offer alternatives to pairing-based SNARKs
        that do not require trusted setups. However, recursive proof
        composition has never been practically realized with these
        protocols due to large constants; for example STARKs have proofs
        that are hundreds of kilobytes in size even for relatively simple
        computations.
      </p>

      <!-- 1.1 Our Contributions -->
      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Our Contributions</h3>

      <p class="text-gray-300">
        We present Halo, the first practical realization of recursive
        proof composition without a trusted setup. As in [4], we use a
        cycle of elliptic curves such that proofs constructed with one
        curve can efficiently verify proofs constructed over the other.
        However, neither curve is pairing-friendly; the cycle consists of
        normal 255-bit prime-order curves that are conjectured to
        approach the 128-bit security level. Such cycles are easy to
        construct, as discussed in
        <a href="#sec-6.1" class="text-blue-400 hover:text-blue-300">
        Section 6.1</a>. Proof size and verification time in our
        protocol does not increase with the depth of recursion.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Polynomial Commitments with Amortized
        Succinctness</strong> &ensp;
        In <a href="#sec-3" class="text-blue-400 hover:text-blue-300">
        Section 3</a> we present a new polynomial commitment scheme
        based on the inner product argument of [12,13], inspired by a
        similar protocol from [37]. We make a novel observation that, by
        exploiting the smooth structure of vectors that the verifier must
        work with, we can amortize away (across many proofs) the
        linear-time verification operation for commitment openings with
        the assistance of an untrusted third party &ldquo;helper.&rdquo;
        In particular, instead of performing a linear-time operation for
        each commitment opening proof, the helper provides the claimed
        output of these linear-time operations for each proof and then
        uses a new argument to demonstrate that every claimed output was
        correct. This new argument requires that the verifier perform the
        same linear-time operation, but this time only once for the
        entire batch of proofs. This strategy allows us to build proofs
        for arithmetic circuit satisfiability in which the marginal
        verification time is logarithmic in the size of the circuit,
        improving asymptotically over Bulletproofs [13]. This is similar
        to the helped variant of the Sonic protocol [32, Section 8],
        except that our approach avoids the need for a trusted setup.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Nested Amortization</strong> &ensp;
        All previously known attempts at achieving recursive proof
        composition have followed a similar strategy: build a fully
        succinct, non-interactive argument system and then construct a
        verification circuit for this system. Due to the succinctness
        property, at some threshold the verification circuit will be
        smaller than the size of the circuit being checked, allowing
        arbitrary-depth recursion to be achieved. Argument systems based
        on elliptic curve groups have the smallest communication
        complexity known in the literature, but currently they either
        require trusted setups (as in all pairing-based SNARKs) or have
        linear-time verifiers (as in Bulletproofs [13]) and so are not
        fully succinct.
      </p>

      <p class="text-gray-300 mt-4">
        Our primary contribution is a novel approach for reducing the
        verification circuit size by exploiting the amortization strategy
        explained previously. In short, the verification circuit never
        performs linear-time operations itself, but rather takes the
        input and (claimed) output of the linear-time operation to be
        public inputs to the circuit, i.e. they are encoded in the
        statement being proven. The circuit proceeds on the assumption
        that the claimed output is correct and so the circuit is
        sublinear in size. This effectively defers the full verification
        of the &ldquo;inner&rdquo; proof to the verifier, who must also
        perform a similar linear-time operation to check the
        &ldquo;outer&rdquo; proof. Using the amortization argument
        described previously, the verifier can collapse these two
        computations together into one with the assistance of a helper.
        In the recursive context we simply embed the verifier of this
        amortization argument at each depth of the recursion so as to
        continually collapse the cost of verifying arguments. The
        linear-time verification operation is thus only performed once at
        the end of the recursive chain, and never as part of the
        verification circuit itself, bypassing the conventional need for
        a fully succinct argument and in fact avoiding the need for
        pre-processing.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Implementation</strong> &ensp;
        We fully implement our protocol in
        <a href="#sec-6" class="text-blue-400 hover:text-blue-300">
        Section 6</a> to demonstrate its practicality and assist in
        comparison with future work. In the process, we describe a
        2-cycle of elliptic curves &ndash; which we refer to as
        Tweedledum and Tweedledee, respectively &ndash; with attractive
        performance and security. We instantiate an argument for
        arithmetic circuit satisfiability over each elliptic curve group,
        exploiting their cyclic nature to efficiently express
        verification circuits as in [4]. The curves we choose are also
        specifically designed to support certain endomorphisms which we
        exploit to reduce the size of our verification circuit in
        various novel ways described in
        <a href="#sec-6.2" class="text-blue-400 hover:text-blue-300">
        Section 6.2</a>, which are likely of independent interest.
      </p>

      <!-- 1.2 Concurrent Work -->
      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Concurrent Work</h3>

      <p class="text-gray-300">
        In concurrent work, Fractal [18] is a proposed recursive
        zero-knowledge protocol based on recent efficient low-degree
        testing techniques, with plausible post-quantum security and full
        succinctness. Our work is not fully succinct (in that the
        verifier&rsquo;s work is linear in the circuit size) but our
        fully-recursive proofs are 3.5 KiB in size, compared to
        Fractal&rsquo;s which are over 120 KiB in size at the 128-bit
        security level. Further, Halo&rsquo;s recursion
        threshold<span class="math">^1</span> is less than
        <span class="math">2^&#123;17&#125;</span> multiplication
        gates &mdash; at least an order of magnitude smaller than
        Fractal&rsquo;s &mdash; which has the potential for
        substantially reducing proving time/memory requirements.
      </p>

      <p class="text-gray-300 mt-4">
        Supersonic [14] is a recent zk-SNARK based on groups of unknown
        order, which does not require a trusted setup. It is not clear to
        us if recursion can be practically achieved using this scheme or,
        if so, how competitive it would be with our results.
      </p>

      <p class="text-gray-400 text-sm mt-4">
        <span class="math">^1</span> The recursion threshold is the number of
        (multiplication) gates in the smallest circuit that can achieve
        arbitrary-depth proof composition.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2 PRELIMINARIES                                              -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">2 Preliminaries</h2>

      <p class="text-gray-300">
        We take <span class="math">\lambda</span> as our security
        parameter, and unless explicitly noted, all algorithms and
        adversaries are probabilistic interactive Turing machines that
        run in polynomial time in this security parameter. We use
        <span class="math">\mathrm&#123;negl&#125;(\lambda)</span> to
        describe a function that is negligible in
        <span class="math">\lambda</span>.
      </p>

      <!-- 2.1 Zero-Knowledge Arguments of Knowledge -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Zero-Knowledge Arguments of Knowledge</h3>

      <p class="text-gray-300">
        Zero-knowledge proofs of knowledge allow a prover
        <span class="math">\mathcal&#123;P&#125;</span> to demonstrate
        knowledge of a witness
        <span class="math">w</span> such that
        <span class="math">(x,w) \in \mathcal&#123;R&#125;</span> for a
        polynomial-time decidable relation
        <span class="math">\mathcal&#123;R&#125;</span> and some
        statement <span class="math">x</span>, without revealing any
        information about <span class="math">w</span> to the verifier
        <span class="math">\mathcal&#123;V&#125;</span> of the proof
        except that which can be inferred from the truth of the
        statement. We&rsquo;ll write relations in the form
        <span class="math">\&#123;(\text&#123;statement&#125;; \text&#123;witness&#125;) : \text&#123;predicate&#125;\&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        We will work with arguments of knowledge which assume
        computationally bounded provers. We will model
        <span class="math">\mathcal&#123;P&#125;, \mathcal&#123;V&#125;</span>
        as interactive algorithms, with a preliminary algorithm Setup
        that produces a common reference string
        <span class="math">\sigma</span>. We will denote the transcript
        of the interaction as
        <span class="math">\langle \mathcal&#123;P&#125;(\sigma, x, w), \mathcal&#123;V&#125;(\sigma, x; \rho) \rangle</span>,
        with the verifier&rsquo;s internal randomness
        <span class="math">\rho</span> sometimes being omitted.
      </p>

      <!-- Definition 1 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 1 (Perfect Completeness)</p>
        <p class="text-gray-300">
          <span class="math">(\mathsf&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          has perfect completeness if for all non-uniform
          polynomial-time adversaries
          <span class="math">\mathcal&#123;A&#125;</span>
        </p>
        <div class="math-block">
          \Pr\left[(x,w) \notin \mathcal&#123;R&#125; \,\vee\, \langle \mathcal&#123;P&#125;(\sigma,x,w), \mathcal&#123;V&#125;(\sigma,x)\rangle \text&#123; accepts&#125; \middle| \begin&#123;array&#125;&#123;l&#125; \sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda) \\ (x,w) \leftarrow \mathcal&#123;A&#125;(\sigma) \end&#123;array&#125;\right] = 1
        </div>
      </div>

      <!-- Definition 2 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 2 (Computational Witness-Extended Emulation)</p>
        <p class="text-gray-300">
          <span class="math">(\mathsf&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          has witness-extended emulation if for all deterministic
          polynomial-time
          <span class="math">\mathcal&#123;P&#125;^*</span> there exists
          an expected polynomial-time emulator
          <span class="math">\mathcal&#123;E&#125;</span> such that for
          all pairs of interactive adversaries
          <span class="math">\mathcal&#123;A&#125;_1, \mathcal&#123;A&#125;_2</span>
        </p>
        <div class="math-block">
          \left| \Pr \left[ \mathcal&#123;A&#125;_1(tr) = 1 \middle| \begin&#123;array&#125;&#123;l&#125; \sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda) \\ (x, s) \leftarrow \mathcal&#123;A&#125;_2(\sigma) \\ tr \leftarrow \langle \mathcal&#123;P&#125;^*(\sigma, x, s), \mathcal&#123;V&#125;(\sigma, x) \rangle \end&#123;array&#125; \right] - \Pr \left[ \begin&#123;array&#125;&#123;c&#125; \mathcal&#123;A&#125;_1(tr) = 1 \\ \wedge (tr \text&#123; accepts&#125; \Rightarrow (x, w) \in \mathcal&#123;R&#125;) \end&#123;array&#125; \middle| \begin&#123;array&#125;&#123;l&#125; \sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda) \\ (x, s) \leftarrow \mathcal&#123;A&#125;_2(\sigma) \\ (tr, w) \leftarrow \mathcal&#123;E&#125;^&#123;\mathcal&#123;O&#125;&#125;(\sigma, x) \end&#123;array&#125; \right] \right| \leq \mathrm&#123;negl&#125;(\lambda)
        </div>
        <p class="text-gray-300 mt-2">
          where the oracle is given by
          <span class="math">\mathcal&#123;O&#125; = \langle \mathcal&#123;P&#125;^*(\sigma, x, s), \mathcal&#123;V&#125;(\sigma, x) \rangle</span>
          and permits rewinding to a specific point and resuming with
          fresh randomness for the verifier from that point onward. We
          also define computational witness-extended emulation by
          restricting to non-uniform polynomial-time adversaries
          <span class="math">\mathcal&#123;A&#125;_1</span> and
          <span class="math">\mathcal&#123;A&#125;_2</span>.
        </p>
      </div>

      <!-- Definition 3 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 3 (Argument of Knowledge)</p>
        <p class="text-gray-300">
          <span class="math">(\mathsf&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          is an argument of knowledge if it has perfect completeness and
          computational witness-extended emulation.
        </p>
      </div>

      <!-- Definition 4 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 4 (Public-Coin)</p>
        <p class="text-gray-300">
          <span class="math">(\mathsf&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          is a public-coin argument if the verifier chooses their
          messages uniformly at random and independently of the messages
          sent by the prover, i.e., the challenges correspond to the
          verifier&rsquo;s randomness
          <span class="math">\rho</span>.
        </p>
      </div>

      <!-- Definition 5 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 5 (Perfect Special Honest-Verifier Zero
          Knowledge)</p>
        <p class="text-gray-300">
          <span class="math">(\mathsf&#123;Setup&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          has perfect special honest-verifier zero knowledge (PSHVZK) if
          for all non-uniform polynomial-time adversaries
          <span class="math">\mathcal&#123;A&#125;_1, \mathcal&#123;A&#125;_2</span>
          and polynomially decidable relation
          <span class="math">\mathcal&#123;R&#125;</span> with
          <span class="math">(x, w) \in \mathcal&#123;R&#125;</span>
          there exists a probabilistic polynomial-time simulator
          <span class="math">\mathcal&#123;S&#125;</span> such that
        </p>
        <div class="math-block">
          \Pr\left[ \mathcal&#123;A&#125;_1(tr,\sigma,x) = 1 \middle| \begin&#123;array&#125;&#123;l&#125; \sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda) \\ (x,w,\rho) \leftarrow \mathcal&#123;A&#125;_2(\sigma) \\ tr \leftarrow \langle \mathcal&#123;P&#125;(\sigma,x,w), \mathcal&#123;V&#125;(\sigma,x;\rho) \rangle \end&#123;array&#125; \right] = \Pr\left[ \mathcal&#123;A&#125;_1(tr,\sigma,x) = 1 \middle| \begin&#123;array&#125;&#123;l&#125; \sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda) \\ (x,w,\rho) \leftarrow \mathcal&#123;A&#125;_2(\sigma) \\ tr \leftarrow \mathcal&#123;S&#125;(\sigma,x,\rho) \end&#123;array&#125; \right]
        </div>
        <p class="text-gray-300 mt-2">
          where <span class="math">\rho</span> is the verifier&rsquo;s
          internal randomness.
        </p>
      </div>

      <!-- 2.2 Groups -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Groups</h3>

      <p class="text-gray-300">
        We use the notation
        <span class="math">\mathbb&#123;G&#125;</span> for a group of
        prime order <span class="math">p</span>, and
        <span class="math">\mathbb&#123;F&#125;_p</span> to denote its
        scalar field. We will often write the field as
        <span class="math">\mathbb&#123;F&#125;</span> if the size of
        the field is implied or unimportant. Rather than drawing verifier
        challenges from
        <span class="math">\mathbb&#123;F&#125;^&#123;\times&#125;</span>
        we will draw them instead from a challenge space
        <span class="math">\mathbb&#123;I&#125; \subset \mathbb&#123;F&#125;^&#123;\times&#125;</span>
        that is of size
        <span class="math">2^&#123;\lambda&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        We use uppercase letters to denote group elements, and lowercase
        letters to denote scalars. Group operations are written
        additively, and scalar multiplication is denoted by
        <span class="math">[a] G</span> for
        <span class="math">a \in \mathbb&#123;F&#125;</span> and
        <span class="math">G \in \mathbb&#123;G&#125;</span>. The
        additive identity in
        <span class="math">\mathbb&#123;G&#125;</span> is written as
        <span class="math">\mathcal&#123;O&#125;</span>. We use
        boldface variable names for vectors, such that
        <span class="math">\mathbf&#123;a&#125;</span> is a vector of
        scalars and <span class="math">\mathbf&#123;G&#125;</span> is a
        vector of group elements. All vectors are zero-indexed unless
        explicitly noted.
      </p>

      <p class="text-gray-300 mt-4">
        We write the inner product
        <span class="math">a_0b_0 + a_1b_1 + \cdots + a_&#123;n-1&#125;b_&#123;n-1&#125;</span>
        of scalar vectors
        <span class="math">\mathbf&#123;a&#125;, \mathbf&#123;b&#125; \in \mathbb&#123;F&#125;^n</span>,
        as
        <span class="math">\langle \mathbf&#123;a&#125;, \mathbf&#123;b&#125; \rangle</span>.
        Similarly we write the multiscalar multiplication
        <span class="math">[a_0]G_0 + [a_1]G_1 + \cdots + [a_&#123;n-1&#125;]G_&#123;n-1&#125;</span>
        of a scalar vector
        <span class="math">\mathbf&#123;a&#125; \in \mathbb&#123;F&#125;^n</span>
        with a vector of group elements
        <span class="math">\mathbf&#123;G&#125; \in \mathbb&#123;G&#125;^n</span>,
        as
        <span class="math">\langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle</span>.
        We will sometimes write
        <span class="math">\mathbf&#123;G&#125;_&#123;\mathrm&#123;lo&#125;&#125;</span>
        or
        <span class="math">\mathbf&#123;G&#125;_&#123;\mathrm&#123;hi&#125;&#125;</span>
        to refer to the first half or second half of a vector of group
        elements or scalars.
      </p>

      <!-- Definition 6 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 6 (Discrete Log Relation Assumption)</p>
        <p class="text-gray-300">
          For all adversaries
          <span class="math">\mathcal&#123;A&#125;</span> and for all
          <span class="math">n \geq 2</span>
        </p>
        <div class="math-block">
          \Pr\left[\mathbf&#123;G&#125; \stackrel&#123;\$&#125;&#123;\leftarrow&#125; \mathbb&#123;G&#125;^n;\; \mathbf&#123;a&#125; \in \mathbb&#123;F&#125;^n \leftarrow \mathcal&#123;A&#125;(\mathbb&#123;G&#125;, \mathbf&#123;G&#125;) : \exists\, \mathbf&#123;a&#125;_i \neq 0 \;\wedge\; \langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle = \mathcal&#123;O&#125;\right] \leq \mathrm&#123;negl&#125;(\lambda)
        </div>
        <p class="text-gray-300 mt-2">
          The discrete log relation assumption generalizes the discrete
          log assumption to arbitrary numbers of random group elements.
          We say that
          <span class="math">\langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle = \mathcal&#123;O&#125;</span>
          is a non-trivial discrete log relation between elements of
          <span class="math">\mathbf&#123;G&#125;</span> when at least
          one of <span class="math">\mathbf&#123;a&#125;</span> is
          nonzero.
        </p>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3 POLYNOMIAL COMMITMENTS                                     -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">3 Polynomial Commitments</h2>

      <p class="text-gray-300">
        Polynomial commitment schemes [30] form a fundamental building
        block in many modern arguments of knowledge. [32,17,22,14] In
        these schemes, a prover can construct commitments to polynomials
        and then later provably evaluate the committed polynomials at
        arbitrary points. We present a univariate polynomial commitment
        scheme
        <span class="math">(\mathsf&#123;Setup&#125;, \mathsf&#123;Commit&#125;, \mathsf&#123;Open&#125;, \mathsf&#123;VerifyOpen&#125;)</span>
        based on the multivariate scheme of [37], which is itself a
        variant of the inner product argument first presented in [12],
        with adaptations from Bulletproofs [13].
      </p>

      <p class="text-gray-300 mt-4">
        First, for a given degree bound
        <span class="math">d-1</span> we define
        <span class="math">\mathsf&#123;Setup&#125;(1^\lambda, d)</span>
        as an algorithm that produces a common reference string
        <span class="math">\sigma = (\mathbb&#123;G&#125;, \mathbb&#123;F&#125;_p, \mathbf&#123;G&#125;, H)</span>
        for group <span class="math">\mathbb&#123;G&#125;</span> of
        prime order <span class="math">p</span>, with random
        <span class="math">\mathbf&#123;G&#125; \in \mathbb&#123;G&#125;^d</span>
        and <span class="math">H \in \mathbb&#123;G&#125;</span>. Let
        <span class="math">\mathsf&#123;Commit&#125;</span> be defined
        as
      </p>

      <div class="math-block">
        \mathsf&#123;Commit&#125;(\sigma, p(X); r) = \langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle + [r]H
      </div>

      <p class="text-gray-300 mt-4">
        for blinding factor <span class="math">r</span>, where
        <span class="math">\mathbf&#123;a&#125;_i \in \mathbb&#123;F&#125;</span>
        is the coefficient for the <span class="math">i</span>th degree
        term of <span class="math">p(X)</span>, and
        <span class="math">p(X) \in \mathbb&#123;F&#125;_p[X]</span>
        is of maximal degree <span class="math">d-1</span>. We will
        sometimes omit the blinding factor
        <span class="math">r</span> if it is either implicit or
        unnecessary. This is a Pedersen vector commitment to the
        polynomial coefficients, and we remark that such commitments are
        perfectly hiding and additively homomorphic:
        <span class="math">\forall\, a, b, r, s \in \mathbb&#123;F&#125;_p</span>
        and
        <span class="math">p(X), q(X) \in \mathbb&#123;F&#125;_p[X]</span>
        we have
      </p>

      <div class="math-block">
        [a]\,\mathsf&#123;Commit&#125;(\sigma,p(X);r) + [b]\,\mathsf&#123;Commit&#125;(\sigma,q(X);s) = \mathsf&#123;Commit&#125;(\sigma,a \cdot p(X)+b \cdot q(X);ar+bs)
      </div>

      <p class="text-gray-300 mt-4">
        We will have
        <span class="math">(\mathsf&#123;Setup&#125;, \mathsf&#123;Open&#125;, \mathsf&#123;VerifyOpen&#125;)</span>
        be a PSHVZK argument of knowledge for the relation
      </p>

      <div class="math-block">
        \left\&#123; ((P,x,v);(\mathbf&#123;a&#125;,r)): P = \langle \mathbf&#123;a&#125;,\mathbf&#123;G&#125; \rangle + [r]H \;\wedge\; v = \langle \mathbf&#123;a&#125;,(1,x,x^2,\ldots,x^&#123;d-1&#125;) \rangle \right\&#125;
      </div>

      <p class="text-gray-300 mt-4">
        which will allow a prover to demonstrate to a verifier that the
        polynomial contained &ldquo;inside&rdquo; the commitment
        <span class="math">P</span> evaluates to
        <span class="math">v</span> at <span class="math">x</span>,
        and moreover, that the committed polynomial has maximum degree
        <span class="math">d-1</span>.
      </p>

      <!-- 3.1 Protocol Description -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Protocol Description</h3>

      <p class="text-gray-300">
        The protocol takes the polynomial commitment
        <span class="math">P</span>, point
        <span class="math">x</span>, and claimed evaluation
        <span class="math">v</span> as common inputs. In the first move
        the verifier
        <span class="math">\mathsf&#123;VerifyOpen&#125;</span> sends a
        random group element
        <span class="math">U \in \mathbb&#123;G&#125;</span>. Both
        parties compute
      </p>

      <div class="math-block">
        P' = P + [v]\, U
      </div>

      <p class="text-gray-300 mt-4">
        and begin an argument (described next) to demonstrate that the
        prover <span class="math">\mathsf&#123;Open&#125;</span> knows
        <span class="math">\mathbf&#123;a&#125; \in \mathbb&#123;F&#125;_p^d</span>
        and <span class="math">r, v' \in \mathbb&#123;F&#125;_p</span>
        such that
      </p>

      <div class="math-block">
        P' = \langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle + [r]H + [v']U
      </div>

      <p class="text-gray-300 mt-4">
        and that
        <span class="math">v' = \langle \mathbf&#123;a&#125;, (1, x, x^2, \ldots, x^&#123;d-1&#125;) \rangle</span>.
        As the prover did not know <span class="math">U</span> in
        advance, this establishes that
        <span class="math">v = v'</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Modified Inner Product</strong> &ensp;
        Bulletproofs [13] presents a variant of the inner product
        argument [12] in which a prover aims to convince a verifier that
        they know
        <span class="math">\mathbf&#123;a&#125;, \mathbf&#123;b&#125; \in \mathbb&#123;F&#125;^d</span>
        such that
      </p>

      <div class="math-block">
        P' = \langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle + \langle \mathbf&#123;b&#125;, \mathbf&#123;H&#125; \rangle + [\langle \mathbf&#123;a&#125;, \mathbf&#123;b&#125; \rangle]\, U
      </div>

      <p class="text-gray-300 mt-4">
        for some given <span class="math">P'</span>, and random
        generators
        <span class="math">\mathbf&#123;G&#125;, \mathbf&#123;H&#125; \in \mathbb&#123;G&#125;^d, U \in \mathbb&#123;G&#125;</span>.
        We use a variant of this argument in which the second vector
        <span class="math">\mathbf&#123;b&#125; = (1, x, x^2, \ldots, x^&#123;n-1&#125;)</span>
        is fixed for the given choice of <span class="math">x</span>,
        and known to both the prover and verifier. As a result no vector
        <span class="math">\mathbf&#123;H&#125;</span> is necessary.
        Further, we allow an additional generator
        <span class="math">H</span> to serve as a mechanism for
        perfectly blinding both prover messages and the commitment
        <span class="math">P'</span> itself.
      </p>

      <p class="text-gray-300 mt-4">
        Assume <span class="math">d = 2^k</span> for
        <span class="math">k > 0</span>. Initializing for the prover
        <span class="math">\mathbf&#123;G&#125;' := \mathbf&#123;G&#125;, \mathbf&#123;a&#125;' := \mathbf&#123;a&#125;, \mathbf&#123;b&#125;' := \mathbf&#123;b&#125;</span>,
        we will proceed in <span class="math">k</span> rounds of
        interaction, where in the <span class="math">j</span>th round
        (starting with <span class="math">j = k</span> and finishing
        with <span class="math">j = 1</span>) the prover sends
      </p>

      <div class="math-block">
        L_&#123;j&#125; = \langle \mathbf&#123;a&#125;'_&#123;\mathrm&#123;lo&#125;&#125;, \mathbf&#123;G&#125;'_&#123;\mathrm&#123;hi&#125;&#125; \rangle + [l_&#123;j&#125;]H + [\langle \mathbf&#123;a&#125;'_&#123;\mathrm&#123;lo&#125;&#125;, \mathbf&#123;b&#125;'_&#123;\mathrm&#123;hi&#125;&#125; \rangle]\, U
      </div>
      <div class="math-block">
        R_&#123;j&#125; = \langle \mathbf&#123;a&#125;'_&#123;\mathrm&#123;hi&#125;&#125;, \mathbf&#123;G&#125;'_&#123;\mathrm&#123;lo&#125;&#125; \rangle + [r_&#123;j&#125;]H + [\langle \mathbf&#123;a&#125;'_&#123;\mathrm&#123;hi&#125;&#125;, \mathbf&#123;b&#125;'_&#123;\mathrm&#123;lo&#125;&#125; \rangle]\, U
      </div>

      <p class="text-gray-300 mt-4">
        with random blinding factors
        <span class="math">l_j, r_j \in \mathbb&#123;F&#125;_p</span>.
        The verifier responds with a random challenge
        <span class="math">u_j \in \mathbb&#123;I&#125;</span> and the
        prover computes
      </p>

      <div class="math-block">
        \mathbf&#123;a&#125;' \leftarrow \mathbf&#123;a&#125;'_&#123;\mathrm&#123;hi&#125;&#125; \cdot u_j^&#123;-1&#125; + \mathbf&#123;a&#125;'_&#123;\mathrm&#123;lo&#125;&#125; \cdot u_j
      </div>
      <div class="math-block">
        \mathbf&#123;b&#125;' \leftarrow \mathbf&#123;b&#125;'_&#123;\mathrm&#123;lo&#125;&#125; \cdot u_j^&#123;-1&#125; + \mathbf&#123;b&#125;'_&#123;\mathrm&#123;hi&#125;&#125; \cdot u_j
      </div>
      <div class="math-block">
        \mathbf&#123;G&#125;' \leftarrow \mathbf&#123;G&#125;'_&#123;\mathrm&#123;lo&#125;&#125; \cdot u_j^&#123;-1&#125; + \mathbf&#123;G&#125;'_&#123;\mathrm&#123;hi&#125;&#125; \cdot u_j
      </div>

      <p class="text-gray-300 mt-4">
        for the next round. After the final round,
        <span class="math">\mathbf&#123;G&#125;', \mathbf&#123;a&#125;', \mathbf&#123;b&#125;'</span>
        are each of length 1. Note that the verifier can compute
        <span class="math">G = \mathbf&#123;G&#125;'_0</span> as
        <span class="math">\langle \mathbf&#123;s&#125;, \mathbf&#123;G&#125; \rangle</span>
        and <span class="math">b = \mathbf&#123;b&#125;'_0</span> as
        <span class="math">\langle \mathbf&#123;s&#125;, \mathbf&#123;b&#125; \rangle</span>
        where <span class="math">\mathbf&#123;s&#125;</span> has a
        binary counting structure arising from the fact that in each
        round the inverted challenges are used to scale bases in the
        first half
        <span class="math">\mathbf&#123;G&#125;'_&#123;\mathrm&#123;lo&#125;&#125;</span>,
        while the ordinary challenges scale the bases in the second half
        <span class="math">\mathbf&#123;G&#125;'_&#123;\mathrm&#123;hi&#125;&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        The verifier next computes
      </p>

      <div class="math-block">
        Q = \sum_&#123;j=1&#125;^&#123;k&#125; [u_j^2]\,L_j + P' + \sum_&#123;j=1&#125;^&#123;k&#125; [u_j^&#123;-2&#125;]\,R_j
      </div>

      <p class="text-gray-300 mt-4">
        and the prover proceeds to demonstrate knowledge of
        <span class="math">a=\mathbf&#123;a&#125;'_0</span> and
        synthetic blinding factor
        <span class="math">r'=\sum_&#123;j=1&#125;^k(l_ju_j^2)+r+\sum_&#123;j=1&#125;^k(r_ju_j^&#123;-2&#125;)</span>
        such that
      </p>

      <div class="math-block">
        Q = [a]\, G + [r']\,H + [ab]\, U = [a]\,(G + [b]\, U) + [r']\,H \qquad (2)
      </div>

      <p class="text-gray-300 mt-4">
        which establishes the claim that
        <span class="math">v = v' = \langle \mathbf&#123;a&#125;, \mathbf&#123;b&#125; \rangle</span>
        as described in [13, Section 3].
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Zero-Knowledge Opening</strong> &ensp;
        The prover demonstrates knowledge of
        <span class="math">a, r' \in \mathbb&#123;F&#125;_p</span> such
        that Equation 2 is satisfied, without revealing
        <span class="math">a, r'</span>, in order to establish the
        claim without revealing anything else about the committed
        polynomial. We use a generalized Schnorr protocol that is
        modified from the protocol in [37, Appendix A.3] to improve
        efficiency.
      </p>

      <p class="text-gray-300 mt-4">
        The prover begins by sampling random
        <span class="math">d, s \in \mathbb&#123;F&#125;_p</span> and
        sending
      </p>

      <div class="math-block">
        R = [d](G + [b]U) + [s]H
      </div>

      <p class="text-gray-300 mt-4">
        which the verifier responds to with random challenge
        <span class="math">c \in \mathbb&#123;I&#125;</span>. The
        prover now sends
      </p>

      <div class="math-block">
        z_1 = ac + d \qquad z_2 = cr' + s
      </div>

      <p class="text-gray-300 mt-4">
        and the verifier accepts if
        <span class="math">[c]\, Q + R = [z_1]\,(G + [b]U) + [z_2]\,H</span>.
      </p>

      <!-- Theorem 1 -->
      <div class="formal-block formal-block-theorem my-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 1</p>
        <p class="text-gray-300">
          The protocol presented in
          <a href="#sec-3.1"
            class="text-blue-400 hover:text-blue-300">
            Section 3.1</a> has perfect completeness, computational
          witness-extended emulation, and perfect special honest-verifier
          zero knowledge.
        </p>
        <p class="text-gray-300 mt-2">
          This proof appears in
          <a href="#appendix-a"
            class="text-blue-400 hover:text-blue-300">
            Appendix A</a>.
        </p>
      </div>

      <!-- 3.2 Amortization Strategy -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Amortization Strategy</h3>

      <p class="text-gray-300">
        The polynomial commitment scheme just described suffers from an
        undesirable asymptotic property: although the communication
        complexity is logarithmic in the degree bound, the verifier must
        compute
        <span class="math">G = \langle \mathbf&#123;s&#125;, \mathbf&#123;G&#125; \rangle</span>
        and
        <span class="math">b = \langle \mathbf&#123;s&#125;, \mathbf&#123;b&#125; \rangle</span>
        to accept the argument. One of our novel observations is to
        exploit the structure of
        <span class="math">\mathbf&#123;s&#125;</span> and
        <span class="math">\mathbf&#123;b&#125;</span> by defining a
        polynomial
      </p>

      <div class="math-block">
        g(X, u_1, u_2, \ldots, u_k) = \prod_&#123;i=1&#125;^k (u_i + u_i^&#123;-1&#125; X^&#123;2^&#123;i-1&#125;&#125;) \qquad (3)
      </div>

      <p class="text-gray-300 mt-4">
        such that
        <span class="math">b = \langle \mathbf&#123;s&#125;, \mathbf&#123;b&#125; \rangle = g(x, u_1, u_2, \ldots, u_k)</span>
        which can be computed by the verifier in logarithmic time. This
        alone seems uninteresting, as computing
        <span class="math">G</span> still requires a linear-time
        multiscalar multiplication. However, observe that
      </p>

      <div class="math-block">
        G = \mathsf&#123;Commit&#125;(\sigma, g(X, u_1, u_2, \ldots, u_k))
      </div>

      <p class="text-gray-300 mt-4">
        which suggests the following strategy: instead of the verifier
        computing <span class="math">G</span> itself for multiple
        (independent) arguments, it can ask an untrusted third-party
        &ldquo;helper&rdquo; to compute each
        <span class="math">G_1, G_2, \ldots, G_m</span> for
        <span class="math">m</span> separate arguments and provide an
        argument that each are correct by demonstrating that a random
        linear combination of the commitments opens at a random point to
        a value that the verifier can compute in time
        <span class="math">O(m \log(d))</span>. Due to the degree bound
        of the polynomial commitment scheme the helper convinces the
        verifier with high probability (given a large enough field) only
        if the claimed commitments are correct. This new argument itself
        requires an invocation of the polynomial commitment opening
        protocol, and so the verifier still must ultimately perform a
        linear-time operation. However, the verifier has traded
        <span class="math">m</span> linear-time operations for one,
        with a marginal cost that is logarithmic in the degree bound.
        This is of crucial importance for our later techniques.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4 NESTED AMORTIZATION                                        -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">4 Nested Amortization</h2>

      <p class="text-gray-300">
        The general approach for achieving recursive proof composition is
        to first obtain a non-interactive argument of knowledge for
        arithmetic circuit satisfiability (i.e.
        <span class="math">\mathcal&#123;C&#125;(x, w) = 1</span> for
        auxiliary input <span class="math">w</span> and public input
        <span class="math">x</span>), and then to encode the
        verification algorithm for this argument into such an arithmetic
        circuit. Assuming that the verification circuit for a proof is
        sublinear in the size of the circuit that the proof reasons
        about, then at some threshold it will be possible to recursively
        verify proofs. In our setting we do not have a protocol which can
        be fully verified in sublinear time, and so naively applying this
        strategy will not yield results beyond fixed-depth composition.
        Instead, we devise a novel technique which allows us to avoid
        fully verifying proofs at each layer of the recursion, leveraging
        the fact that our protocol in
        <a href="#sec-5" class="text-blue-400 hover:text-blue-300">
        Section 5</a> has sublinear marginal verification time and
        logarithmic proof size.
      </p>

      <p class="text-gray-300 mt-4">
        Arithmetic circuits are often encoded into systems of constraints
        such that, given a satisfying assignment of variables (the
        prover&rsquo;s witness), the satisfaction of the constraint
        system implies the satisfiability of the circuit. The inherent
        non-determinism in this process means that some expensive
        operations can be performed more efficiently when the prover is
        allowed to assist. As an example, in circuits where a field
        inversion of a variable <span class="math">u</span> must be
        computed, rather than exponentiating &ldquo;in the circuit&rdquo;
        (<span class="math">u^&#123;p-2&#125;</span> which requires
        <span class="math">\log(p)</span> multiplication constraints),
        the prover can instead witness
        <span class="math">v = u^&#123;-1&#125;</span> and show that it
        is the correct inverse with the single multiplication constraint
        <span class="math">uv = 1</span>. We will exploit this
        non-determinism in a slightly different way: when our circuit
        contains an expensive fixed operation
        <span class="math">f</span> that is invoked with some input
        <span class="math">x</span> we will instead allow the prover to
        witness <span class="math">y = f(x)</span> and then take
        <span class="math">(x, y)</span> as public inputs to the
        circuit. The circuit can then proceed under the assumption that
        <span class="math">y</span> is correct, delegating the
        responsibility of checking the correctness of
        <span class="math">y</span> to the verifier of the proof.
      </p>

      <p class="text-gray-300 mt-4">
        In the context of proof composition, we apply this optimization
        so that a verification circuit for a proof will not perform any
        linear-time (or otherwise expensive) operation
        <span class="math">f</span> but rather take their inputs and
        the prover&rsquo;s alleged outputs
        <span class="math">(x, y)</span> as public inputs to its own
        circuit. Observe that as proofs are continually composed,
        increasing instances of <span class="math">(x, y)</span>
        accumulate because the verification circuit will not check them
        but rather continually delegate these checks to its verifier. In
        order to prevent this runaway cost we introduce an amortization
        strategy: given instances <span class="math">(x, y)</span> and
        <span class="math">(x', y')</span>, the prover will provide a
        non-interactive proof that
        <span class="math">y = f(x)</span> and
        <span class="math">y' = f(x')</span> as a witness to the
        verification circuit, and the verification circuit will check
        this proof. In order to fully check this amortization proof the
        verification circuit may need to perform a linear-time (or
        otherwise expensive) operation. However, if this operation is
        equivalent to invoking <span class="math">f</span> then the
        verifier has collapsed the two instances
        <span class="math">(x, y)</span> and
        <span class="math">(x', y')</span> into a single fresh instance
        <span class="math">(x'', y'')</span>, allowing us to
        continually amortize away the cost of invoking
        <span class="math">f</span> as proofs are composed. It is only
        &ldquo;outside&rdquo; of the circuit that
        <span class="math">f</span> is invoked once by the ultimate
        verifier, demonstrating the correctness of the entire underlying
        tree of proofs by induction. We refer to this strategy as
        &ldquo;nested amortization.&rdquo;
      </p>

      <p class="text-gray-300 mt-4">
        The public-coin PSHVZK argument of knowledge for arithmetic
        circuit satisfiability described in
        <a href="#sec-5" class="text-blue-400 hover:text-blue-300">
        Section 5</a> is designed to exploit this nested amortization
        strategy, leveraging the polynomial commitment amortization
        technique we explored in
        <a href="#sec-3.2" class="text-blue-400 hover:text-blue-300">
        Section 3.2</a>. The setting is described as a stream of
        arguments from the prover to the verifier, where the verifier
        will maintain logarithmic-size state and perform
        logarithmic-time operations to partially verify each proof in
        sequence. Finally, at the end of a stream of proofs the verifier
        will choose to accept or reject all of them simultaneously in
        linear time. By applying the Fiat&ndash;Shamir heuristic [21] in
        <a href="#sec-6" class="text-blue-400 hover:text-blue-300">
        Section 6</a> we can transform this argument into a
        non-interactive zero-knowledge argument of knowledge. The result
        is then grafted to the nested amortization technique, where the
        &ldquo;state&rdquo; maintained by the verifier is merely the
        deferred values that are shepherded through public inputs. This
        leads directly to a recursive proof of arbitrary
        depth<span class="math">^2</span> where the verifier outside of the circuit will
        be responsible only for checking the correctness of the verifier
        state once, with a linear-time operation that is never performed
        inside the circuit.
      </p>

      <p class="text-gray-400 text-sm mt-4">
        <span class="math">^2</span> We remark that, theoretically, the knowledge
        extractor requires a number of transcripts from the prover that
        increases exponentially as the depth increases. However, there
        are no known attacks and this concern is often disregarded in
        practice. In any case, applications can sometimes sidestep this
        theoretical concern by restricting to a fixed-depth tree of
        proofs as in [8].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5 MAIN ARGUMENT                                              -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">5 Main Argument</h2>

      <p class="text-gray-300">
        The main argument of Sonic [32] allows a prover to demonstrate
        the satisfiability of an arithmetic circuit (e.g.,
        <span class="math">\mathcal&#123;C&#125;(x, w) = 1</span>) for
        some public input <span class="math">x</span> and auxiliary
        input <span class="math">w</span>. Our main protocol is a
        variant of Sonic that is adapted to the polynomial commitment
        scheme described in
        <a href="#sec-3" class="text-blue-400 hover:text-blue-300">
        Section 3</a>. We will work within a restricted setting to aid
        later exposition: the circuit
        <span class="math">\mathcal&#123;C&#125;</span> is fixed, and
        the prover will repeatedly interact with the verifier to engage
        in multiple arguments in sequence. Our goal will be for the
        verifier to perform logarithmic marginal work in choosing to
        accept or reject all of the arguments simultaneously, leveraging
        the technique described in
        <a href="#sec-3.2" class="text-blue-400 hover:text-blue-300">
        Section 3.2</a> as well as an analogous technique described in
        Section 8 of [32].
      </p>

      <p class="text-gray-300 mt-4">
        In all of the following let
        <span class="math">N, Q, k</span> be integers such that
        <span class="math">d = 4N = 2^k</span> and
        <span class="math">3Q &lt; d</span>. Let the common reference
        string
        <span class="math">\sigma \leftarrow \mathsf&#123;Setup&#125;(1^\lambda, d)</span>
        be shared between the prover and verifier.
      </p>

      <!-- 5.1 Central Argument -->
      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Central Argument</h3>

      <p class="text-gray-300">
        The prover aims to demonstrate that
        <span class="math">\mathcal&#123;C&#125;(x, w) = 1</span> for
        public input <span class="math">x</span> and auxiliary (witness)
        input <span class="math">w</span> without revealing
        <span class="math">w</span>. It will do so by demonstrating
        that a system of arithmetic constraints that encodes
        <span class="math">\mathcal&#123;C&#125;</span> is satisfied for
        witness
        <span class="math">\mathbf&#123;a&#125;, \mathbf&#123;b&#125;, \mathbf&#123;c&#125; \in \mathbb&#123;F&#125;^N</span>
        known only to the prover and some instance
        <span class="math">\mathbf&#123;k&#125; \in \mathbb&#123;F&#125;^Q</span>
        which encodes the public inputs. This system of constraints
        consists of <span class="math">N</span> multiplication
        constraints, where the <span class="math">i</span>th such
        constraint is of the form
      </p>

      <div class="math-block">
        \mathbf&#123;a&#125;_i \cdot \mathbf&#123;b&#125;_i = \mathbf&#123;c&#125;_i
      </div>

      <p class="text-gray-300 mt-4">
        and <span class="math">Q</span> linear constraints, where the
        <span class="math">q</span>th such constraint is of the form
      </p>

      <div class="math-block">
        \left(\sum_&#123;i=1&#125;^&#123;N&#125;\mathbf&#123;a&#125;_&#123;i&#125;\cdot(\mathbf&#123;u&#125;_&#123;q&#125;)_&#123;i&#125;\right)+\left(\sum_&#123;i=1&#125;^&#123;N&#125;\mathbf&#123;b&#125;_&#123;i&#125;\cdot(\mathbf&#123;v&#125;_&#123;q&#125;)_&#123;i&#125;\right)+\left(\sum_&#123;i=1&#125;^&#123;N&#125;\mathbf&#123;c&#125;_&#123;i&#125;\cdot(\mathbf&#123;w&#125;_&#123;q&#125;)_&#123;i&#125;\right)=\mathbf&#123;k&#125;_&#123;q&#125;
      </div>

      <p class="text-gray-300 mt-4">
        for some fixed
        <span class="math">\mathbf&#123;u&#125;_q, \mathbf&#123;v&#125;_q, \mathbf&#123;w&#125;_q \in \mathbb&#123;F&#125;^N</span>
        that encode <span class="math">\mathcal&#123;C&#125;</span>.
        Just as in [32] we will embed all of these constraints into a
        single equation in formal indeterminate
        <span class="math">Y</span>
      </p>

      <div class="math-block">
        \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;a&#125;_&#123;i&#125; \cdot Y^N u_&#123;i&#125;(Y) + \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;b&#125;_&#123;i&#125; \cdot Y^N v_&#123;i&#125;(Y) + \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;c&#125;_&#123;i&#125; \cdot (Y^N w_&#123;i&#125;(Y) - Y^&#123;i&#125; - Y^&#123;-i&#125;) + \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;a&#125;_&#123;i&#125;\mathbf&#123;b&#125;_&#123;i&#125; \cdot (Y^&#123;i&#125; + Y^&#123;-i&#125;) - Y^N k(Y) = 0 \qquad (4)
      </div>

      <p class="text-gray-300 mt-4">
        where we define the polynomials
      </p>

      <div class="math-block">
        u_i(Y) = \sum_&#123;q=1&#125;^&#123;Q&#125; Y^q(\mathbf&#123;u&#125;_q)_i \qquad v_i(Y) = \sum_&#123;q=1&#125;^&#123;Q&#125; Y^q(\mathbf&#123;v&#125;_q)_i \qquad w_i(Y) = \sum_&#123;q=1&#125;^&#123;Q&#125; Y^q(\mathbf&#123;w&#125;_q)_i \qquad k(Y) = \sum_&#123;q=1&#125;^&#123;Q&#125; Y^q \mathbf&#123;k&#125;_q
      </div>

      <p class="text-gray-300 mt-4">
        such that given a choice of
        <span class="math">\mathbf&#123;a&#125;, \mathbf&#123;b&#125;, \mathbf&#123;c&#125;, \mathbf&#123;k&#125;</span>
        we have that Equation 4 holds at all points when the constraint
        system is satisfied. Given a second formal indeterminate
        <span class="math">X</span> let us define the polynomials
      </p>

      <div class="math-block">
        \begin&#123;aligned&#125;
        r(X,Y) &amp;= \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;a&#125;_&#123;i&#125; X^&#123;i&#125; Y^&#123;i&#125; + \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;b&#125;_&#123;i&#125; X^&#123;-i&#125; Y^&#123;-i&#125; + \sum_&#123;i=1&#125;^&#123;N&#125; \mathbf&#123;c&#125;_&#123;i&#125; X^&#123;-i-N&#125; Y^&#123;-i-N&#125; \\
        s(X,Y) &amp;= \sum_&#123;i=1&#125;^&#123;N&#125; u_&#123;i&#125;(Y) X^&#123;-i&#125; + \sum_&#123;i=1&#125;^&#123;N&#125; v_&#123;i&#125;(Y) X^&#123;i&#125; + \sum_&#123;i=1&#125;^&#123;N&#125; w_&#123;i&#125;(Y) X^&#123;i+N&#125; \\
        s'(X,Y) &amp;= Y^&#123;N&#125; s(X,Y) - \sum_&#123;i=1&#125;^&#123;N&#125; (Y^&#123;i&#125; + Y^&#123;-i&#125;) X^&#123;i+N&#125; \\
        t(X,Y) &amp;= r(X,1)(r(X,Y) + s'(X,Y)) - Y^&#123;N&#125; k(Y)
        \end&#123;aligned&#125;
      </div>

      <p class="text-gray-300 mt-4">
        such that the constant term of
        <span class="math">t(X,Y)</span> is exactly the left-hand side
        of Equation 4. Observe that because
        <span class="math">r(X,Y) = r(XY,1)</span> the prover can
        commit to <span class="math">r(X,Y)</span> using a univariate
        polynomial commitment scheme, i.e.
        <span class="math">\mathsf&#123;Commit&#125;(\sigma, r(X,1))</span>.
        The remaining polynomials are fully determined by this choice of
        <span class="math">r(X,Y)</span> and do not depend on the
        witness
        <span class="math">\mathbf&#123;a&#125;, \mathbf&#123;b&#125;, \mathbf&#123;c&#125;</span>.
        The general strategy is for the prover to send a commitment to
        <span class="math">r(X,Y)</span> and then to demonstrate that
        the constant term of <span class="math">t(X,Y)</span> is the
        zero polynomial.
      </p>

      <!-- 5.2 Full Protocol -->
      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Full Protocol</h3>

      <p class="text-gray-300">
        We now bring together a full description of the protocol. The
        prover and verifier will engage in a series of PSHVZK arguments
        of knowledge for the relation
        <span class="math">\mathcal&#123;R&#125;</span> defined as
      </p>

      <div class="math-block">
        \mathcal&#123;R&#125; = \left\&#123; ((G_&#123;\text&#123;old&#125;&#125;, S_&#123;\text&#123;old&#125;&#125;, y_&#123;\text&#123;old&#125;&#125;, (u_&#123;\text&#123;old&#125;&#125;)_1, \ldots, (u_&#123;\text&#123;old&#125;&#125;)_k, \mathbf&#123;k&#125;); (\mathbf&#123;a&#125;, \mathbf&#123;b&#125;, \mathbf&#123;c&#125;)) : \forall i\; (\mathbf&#123;a&#125;_i \cdot \mathbf&#123;b&#125;_i = \mathbf&#123;c&#125;_i) \;\wedge\; \ldots \right\&#125; \qquad (5)
      </div>

      <p class="text-gray-300 mt-4">
        where the verifier will not immediately choose to accept or
        reject each individual argument, as it requires the computation
        of
        <span class="math">G_&#123;\text&#123;new&#125;&#125;, S_&#123;\text&#123;new&#125;&#125;</span>
        each requiring linear time in
        <span class="math">|\mathcal&#123;C&#125;|</span>. Instead the
        prover will take the values as
        <span class="math">G_&#123;\text&#123;old&#125;&#125;, S_&#123;\text&#123;old&#125;&#125;</span>
        for the next argument and suspend its decision to accept. After
        the final argument the verifier will check the values
        <span class="math">G_&#123;\text&#123;new&#125;&#125;, S_&#123;\text&#123;new&#125;&#125;</span>
        in linear time.
      </p>

      <!-- Theorem 2 -->
      <div class="formal-block formal-block-theorem my-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 2</p>
        <p class="text-gray-300">
          The protocol presented in Figure 1 has perfect completeness,
          perfect special honest-verifier zero knowledge, and
          computational witness-extended emulation.
        </p>
        <p class="text-gray-300 mt-2">
          This proof appears in
          <a href="#appendix-b"
            class="text-blue-400 hover:text-blue-300">
            Appendix B</a>.
        </p>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 6 IMPLEMENTATION                                             -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">6 Implementation</h2>

      <p class="text-gray-300">
        We apply the Fiat&ndash;Shamir heuristic to the protocol from
        <a href="#sec-5" class="text-blue-400 hover:text-blue-300">
        Section 5</a> to obtain a non-interactive argument of knowledge
        that is secure in the random oracle model and has perfect zero
        knowledge. The verifier&rsquo;s challenges are substituted for
        outputs of a secure hash function over the transcript of messages
        sent previously by the prover. We instantiate this scheme in the
        uniform random string model by taking the group elements in
        <span class="math">\sigma</span> as outputs of a hash function
        that models a random function.
      </p>

      <p class="text-gray-300 mt-4">
        In practice we will use the Rescue [1] algebraic hash function
        for prime fields to obtain verifier challenges. We instantiate it
        with a duplex sponge construction [7] where prover messages are
        &ldquo;absorbed&rdquo; and verifier challenges are
        &ldquo;squeezed.&rdquo;
      </p>

      <!-- 6.1 Cycles of Curves -->
      <h3 id="sec-6.1" class="text-xl font-semibold mt-8 mb-3">
        6.1 Cycles of Curves</h3>

      <p class="text-gray-300">
        The partial verification operation for a proof (which is encoded
        in the circuit) is dominated by group operations. If we were to
        instantiate our protocol over an arbitrary elliptic curve
        <span class="math">E</span> over base field
        <span class="math">\mathbb&#123;F&#125;_p</span>, for security
        reasons we must obtain a group of prime order
        <span class="math">q \neq p</span>. This presents a challenge
        as our protocol will demonstrate arithmetic circuit satisfaction
        over the scalar field
        <span class="math">\mathbb&#123;F&#125;_q</span>, and
        simulating
        <span class="math">\mathbb&#123;F&#125;_p</span> arithmetic
        over a distinct field is expensive. This efficiency problem was
        addressed in [4] by finding a &ldquo;2-cycle&rdquo;
        <span class="math">E_p, E_q</span> of elliptic curves,
        constructed over the base fields
        <span class="math">\mathbb&#123;F&#125;_p</span> and
        <span class="math">\mathbb&#123;F&#125;_q</span> respectively,
        such that
        <span class="math">\#E_p = q</span> and
        <span class="math">\#E_q = p</span>.
      </p>

      <p class="text-gray-300 mt-4">
        We performed a search for the 2-cycle used in our
        implementation, seeking curves that had highly 2-adic scalar
        fields. We affectionately refer to the resulting curves as
        Tweedledum and Tweedledee [15]:
      </p>

      <div class="math-block">
        E_p/\mathbb&#123;F&#125;_p: y^2 = x^3 + 5 \;\text&#123; of order &#125;\; q \;\text&#123; (Tweedledum)&#125;
      </div>
      <div class="math-block">
        E_q/\mathbb&#123;F&#125;_q: y^2 = x^3 + 5 \;\text&#123; of order &#125;\; p \;\text&#123; (Tweedledee)&#125;
      </div>

      <p class="text-gray-300 mt-4">
        where <span class="math">p</span> and
        <span class="math">q</span> are 255-bit primes:
      </p>

      <div class="math-block">
        p = 2^&#123;254&#125; + 4707489545178046908921067385359695873
      </div>
      <div class="math-block">
        q = 2^&#123;254&#125; + 4707489544292117082687961190295928833
      </div>

      <p class="text-gray-300 mt-4">
        Both curves have 126-bit security against Pollard rho
        attacks.<span class="math">^3</span>
      </p>

      <p class="text-gray-400 text-sm mt-4">
        <span class="math">^3</span> A conservative estimate of the available
        improvement to Pollard rho is that on a group of prime order
        <span class="math">q</span> with an automorphism group of order
        6, the attack cost is
        <span class="math">\sqrt&#123;\frac&#123;\pi q&#125;&#123;12&#125;&#125;</span>,
        as compared to
        <span class="math">\sqrt&#123;\frac&#123;\pi q&#125;&#123;4&#125;&#125;</span>
        using only the negation map as described in [6]. That is, the
        maximum speed-up is only a factor of
        <span class="math">\sqrt&#123;3&#125; \approx 1.732</span> for
        a given success probability.
      </p>

      <!-- 6.2 Endomorphism-based Optimizations -->
      <h3 id="sec-6.2" class="text-xl font-semibold mt-8 mb-3">
        6.2 Endomorphism-based Optimizations</h3>

      <p class="text-gray-300">
        Our method of searching for 2-cycles finds curves
        <span class="math">E/\mathbb&#123;F&#125;_p</span> with an
        endomorphism <span class="math">\phi</span> defined on
        <span class="math">\mathbb&#123;F&#125;_p</span>-rational
        points by
        <span class="math">\phi((x,y)) = (\zeta_p x, y)</span>, where
        <span class="math">\phi(P) = [\zeta_q]P</span> for some
        <span class="math">\zeta_q \in \mathbb&#123;F&#125;_q</span>
        of multiplicative order 3. We leverage this endomorphism to
        optimize the multiplication of group elements by challenges,
        which is the dominating cost of partial proof verification in the
        circuit.
      </p>

      <p class="text-gray-300 mt-4">
        Algorithm 1 can be implemented with 3.5 multiplication
        constraints per bit of
        <span class="math">\mathbf&#123;r&#125;</span>. We show in
        <a href="#appendix-c"
          class="text-blue-400 hover:text-blue-300">Appendix C</a>
        that this algorithm is equivalent to computing
        <span class="math">[n(\mathbf&#123;r&#125;)]P</span> where for
        the Tweedledum and Tweedledee curves with
        <span class="math">\lambda = 128</span>,
        <span class="math">n:\&#123;0,1\&#125;^\lambda \mapsto \mathbb&#123;I&#125;</span>
        is injective.
      </p>

      <!-- 6.3 Other Optimizations -->
      <h3 id="sec-6.3" class="text-xl font-semibold mt-8 mb-3">
        6.3 Other Optimizations</h3>

      <p class="text-gray-300">
        In the polynomial commitment scheme described in
        <a href="#sec-3" class="text-blue-400 hover:text-blue-300">
        Section 3</a> the verifier samples a challenge
        <span class="math">u</span> in each round of the modified inner
        product argument. The verifier will compute
        <span class="math">[u^&#123;-2&#125;]L</span> and
        <span class="math">[u^2]R</span> in each round to check the
        proof. It is possible for the prover to witness
        <span class="math">L' = [u^&#123;-2&#125;]L</span> and then in
        the circuit multiply <span class="math">L'</span> by
        <span class="math">u^2</span> to obtain the expected value
        <span class="math">L</span>, demonstrating the correctness of
        <span class="math">L'</span>. In order to improve the
        performance of computing
        <span class="math">[u^2]P</span> for arbitrary
        <span class="math">P \in \mathbb&#123;G&#125;</span> we modify
        the protocol so that the verifier samples its challenge as
        <span class="math">u^2</span> instead.
      </p>

      <!-- 6.4 Evaluation -->
      <h3 id="sec-6.4" class="text-xl font-semibold mt-8 mb-3">
        6.4 Evaluation</h3>

      <p class="text-gray-300">
        We obtain benchmarks for our protocol on a 16-core Intel
        i9-7960X CPU @ 2.80 GHz, using 16 threads. Recursion is achieved
        at a cross-over point that is just below
        <span class="math">2^&#123;17&#125;</span> multiplication gates.
        Fully recursive proofs in our protocol are at least 3.5 KiB in
        size.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7 CONCLUSION                                                 -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">7 Conclusion</h2>

      <p class="text-gray-300">
        We devised a novel strategy (nested amortization) for achieving a
        practical realization of recursive proof composition without a
        trusted setup. After several optimizations we obtain a fully
        recursive proof that is only 3.5 KiB in size at the 128-bit
        security level. We implement our scheme to show that it is
        efficient to create and verify proofs on consumer hardware.
      </p>

      <p class="text-gray-300 mt-4">
        In the process we obtained a modified variant of the polynomial
        commitment scheme from [37] and observed a new technique for
        amortizing away the cost of verifying many inner product
        arguments. We also devised a proving system with marginal
        verification time that is logarithmic in the size of the circuit,
        improving asymptotically on Bulletproofs [13] and realizing the
        &ldquo;helped&rdquo; mode of Sonic [32] without the need for
        pairings or trusted setups.
      </p>

      <!-- 7.1 Future Work -->
      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 Future Work</h3>

      <p class="text-gray-300">
        We remark that our nested amortization technique can be applied
        using cycles of elliptic curves such that only one curve is
        pairing-friendly, and a pairing-based SNARK can be constructed on
        one end of the cycle instead; this is trivial to obtain using
        Barreto&ndash;Naehrig [2] curves with an embedding degree of 12,
        which allows for the use of smaller fields to improve performance
        compared to MNT4/MNT6 cycles proposed in [4].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">References</h2>
      <ol class="list-decimal list-inside space-y-2
        text-sm text-gray-400">
        <li>Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S.,
          Szepieniec, A.: Efficient symmetric primitives for advanced
          cryptographic protocols. ePrint 2019/426.</li>
        <li>Barreto, P., Naehrig, M.: Pairing-friendly elliptic curves
          of prime order. ePrint 2005/133.</li>
        <li>Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.:
          Scalable, transparent, and post-quantum secure computational
          integrity. ePrint 2018/046.</li>
        <li>Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable
          Zero Knowledge via cycles of elliptic curves. CRYPTO 2014.
          ePrint 2014/595.</li>
        <li>Bernstein, D., Lange, T.: SafeCurves: choosing safe curves
          for elliptic-curve cryptography.</li>
        <li>Bernstein, D., Lange, T., Schwabe, P.: On the correct use
          of the negation map in the Pollard rho method. PKC 2011.</li>
        <li>Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.:
          Duplexing the sponge: Single-pass authenticated encryption and
          other applications. SAC 2012. ePrint 2011/499.</li>
        <li>Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive
          composition and bootstrapping for SNARKs and Proof-Carrying
          Data. STOC 2013. ePrint 2012/095.</li>
        <li>Blum, M., De Santis, A., Micali, S., Persiano, G.:
          Noninteractive Zero-Knowledge. SIAM J. Comput. 20(6),
          1991.</li>
        <li>Blum, M., Feldman, P., Micali, S.: Proving security against
          chosen ciphertext attacks. CRYPTO 1988.</li>
        <li>Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Efficient
          polynomial commitment schemes for multiple points and
          polynomials. ePrint 2020/081.</li>
        <li>Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.:
          Efficient Zero-Knowledge arguments for arithmetic circuits in
          the Discrete Log setting. EUROCRYPT 2016.
          ePrint 2016/263.</li>
        <li>Bunz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P.,
          Maxwell, G.: Bulletproofs: Short proofs for confidential
          transactions and more. IEEE S&amp;P 2018.
          ePrint 2017/1066.</li>
        <li>Bunz, B., Fisch, B., Szepieniec, A.: Transparent SNARKs
          from DARK compilers. ePrint 2019/1229.</li>
        <li>Carroll, L.: Through the Looking-Glass, and What Alice Found
          There. Macmillan and Co. (1872).</li>
        <li>Chiesa, A., Chua, L.: On cycles of pairing-friendly elliptic
          curves. SIAM J. Appl. Algebra Geometry 3(2), 2018.</li>
        <li>Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N.,
          Ward, N.: Marlin: Preprocessing zkSNARKs with universal and
          updatable SRS. ePrint 2019/1047.</li>
        <li>Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and
          transparent recursive proofs from holography.
          ePrint 2019/1076.</li>
        <li>Chiesa, A., Tromer, E.: Proof-Carrying Data and hearsay
          arguments from signature cards. ICS 2010.</li>
        <li>Duursma, I., Gaudry, P., Morain, F.: Speeding up the
          discrete log computation on curves with automorphisms.
          ASIACRYPT 1999.</li>
        <li>Fiat, A., Shamir, A.: How to prove yourself: Practical
          solutions to identification and signature problems.
          CRYPTO 1986.</li>
        <li>Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK:
          Permutations over Lagrange-bases for Oecumenical
          Noninteractive arguments of Knowledge.
          ePrint 2019/953.</li>
        <li>Gennaro, R., Gentry, C., Parno, B.: Non-interactive
          verifiable computing: Outsourcing computation to untrusted
          workers. CRYPTO 2010. ePrint 2009/547.</li>
        <li>Goldwasser, S., Micali, S., Rackoff, C.: The knowledge
          complexity of interactive proof systems. SIAM J. Comput. 18(1),
          1989.</li>
        <li>Groth, J.: On the size of pairing-based non-interactive
          arguments. ePrint 2016/260.</li>
        <li>Hopwood, D.: GitHub repository &lsquo;daira/tweedle&rsquo;:
          Generator and supporting evidence for security of the
          Tweedledum/Tweedledee pair of elliptic curves.</li>
        <li>Hopwood, D.: GitHub repository &lsquo;zcash/zcash&rsquo;:
          Issue 3924 &ndash; Faster variable-base scalar multiplication
          in zk-SNARK circuits.</li>
        <li>Hopwood, D., Bowe, S., Hornby, T., Wilcox, N.: Zcash
          protocol specification.</li>
        <li>Hopwood, D., Israel, R.: Under what conditions on A and v is
          the size of the sumset
          <span class="math">v \cdot A + A</span> over
          <span class="math">\mathbb&#123;F&#125;_p</span> equal or
          close to
          <span class="math">|A|^2</span>? MathOverflow.</li>
        <li>Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size
          commitments to polynomials and their applications.
          ASIACRYPT 2010.</li>
        <li>Kilian, J.: A Note on Efficient Zero-knowledge Proofs and
          Arguments. STOC 1992.</li>
        <li>Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic:
          Zero-Knowledge SNARKs from linear-size universal and updatable
          Structured Reference Strings. CCS 2019.
          ePrint 2019/099.</li>
        <li>Micali, S.: Computationally sound proofs. SIAM J. Comput.
          30(4), 2000.</li>
        <li>Renes, J., Costello, C., Batina, L.: Complete addition
          formulas for prime order elliptic curves.
          ePrint 2015/1060.</li>
        <li>Susella, R., Montrasio, S.: A compact and exception-free
          ladder for all short Weierstrass elliptic curves.
          CARDIS 2016.</li>
        <li>Valiant, P.: Incrementally verifiable computation or proofs
          of knowledge imply time/space efficiency. TCC 2008.</li>
        <li>Wahby, R.S., Tzialla, I., abhi shelat, Thaler, J.,
          Walfish, M.: Doubly-efficient zk-SNARKs without trusted setup.
          ePrint 2017/1132.</li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-a" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        Appendix A: Proof of Theorem 1</h2>

      <p class="text-gray-300">
        <em>Proof.</em> Perfect completeness follows trivially. In order
        to establish perfect special honest-verifier zero knowledge we
        demonstrate that a simulator
        <span class="math">\mathcal&#123;S&#125;</span> exists which,
        when given the verifier&rsquo;s randomness and the statement,
        can produce a transcript that is equally distributed with
        transcripts from an honest prover that has a witness.
      </p>

      <p class="text-gray-300 mt-4">
        In each round of the modified inner product argument the
        simulator will simply output random group elements, which are
        distributed identically to the honest prover&rsquo;s outputs.
        Upon calculation of <span class="math">Q</span> the simulator
        chooses
        <span class="math">d, s \in \mathbb&#123;F&#125;_p</span> at
        random and uses its access to <span class="math">c</span> to
        send the verifier
      </p>

      <div class="math-block">
        R = [d](G + [b]U) + [s]H - [c]Q
      </div>

      <p class="text-gray-300 mt-4">
        which has the same distribution as the honest prover. Finally,
        since by definition we have
      </p>

      <div class="math-block">
        [c]\, Q + R = [d]\, (G + [b] U) + [s]\, H
      </div>

      <p class="text-gray-300 mt-4">
        the simulator sends
        <span class="math">z_1 = d</span> and
        <span class="math">z_2 = s</span>, which are again distributed
        the same as an honest prover, and which satisfy the
        verifier&rsquo;s check.
      </p>

      <p class="text-gray-300 mt-4">
        In order to show computational witness-extended emulation we
        first prove the existence of an extractor
        <span class="math">\mathcal&#123;X&#125;_&#123;\text&#123;poly&#125;&#125;</span>
        which, with full access to an adversary
        <span class="math">\mathcal&#123;P&#125;^*</span> that outputs
        accepting transcripts, can extract a witness in expected
        polynomial time. We show that we can extract
        <span class="math">a, r'</span> such that
      </p>

      <div class="math-block">
        Q = [a]\, (G + [b]\, U) + [r']\, H \qquad (6)
      </div>

      <p class="text-gray-300 mt-4">
        by rewinding
        <span class="math">\mathcal&#123;P&#125;^*</span> once and
        continuing the argument with fresh challenge
        <span class="math">c'</span>. If
        <span class="math">\mathcal&#123;P&#125;^*</span> succeeds in
        both arguments, then we have pairs of responses
        <span class="math">(z_1, z_2)</span> and
        <span class="math">(z'_1, z'_2)</span> such that
      </p>

      <div class="math-block">
        [c]\, Q + R = [z_1]\, (G + [b] U) + [z_2]\, H
      </div>
      <div class="math-block">
        [c']\, Q + R = [z'_1]\, (G + [b] U) + [z'_2]\, H
      </div>

      <p class="text-gray-300 mt-4">
        Observe by the equalities
        <span class="math">ac + d = z_1</span> and
        <span class="math">ac' + d = z'_1</span> and the fact that
        <span class="math">c \neq c'</span> that
        <span class="math">a, d</span> are fully determined, and
        similarly for <span class="math">r', s</span>. If it is then
        not the case that
        <span class="math">Q = [a](G + [b]U) + [r']H</span> we have
        extracted a non-trivial discrete log relation between
        <span class="math">G, U, H</span>.
      </p>

      <p class="text-gray-300 mt-4">
        We now proceed with our extracted
        <span class="math">a, r'</span> to obtain a witness
        <span class="math">\mathbf&#123;a&#125;, v'</span> such that
      </p>

      <div class="math-block">
        P' = \langle \mathbf&#123;a&#125;, \mathbf&#123;G&#125; \rangle + [r]H + [v']U \qquad (7)
      </div>

      <p class="text-gray-300 mt-4">
        and that
        <span class="math">v' = \langle \mathbf&#123;a&#125;, (1, x, x^2, \ldots, x^&#123;n-1&#125;) \rangle</span>.
        We see that our extractor
        <span class="math">\mathcal&#123;X&#125;_&#123;\text&#123;poly&#125;&#125;</span>
        is efficient (requiring
        <span class="math">4d^2</span> transcripts in total, which is
        polynomial in <span class="math">\lambda</span>) and so by the
        general forking lemma [13, Theorem 6] we have shown
        computational witness-extended emulation.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-b" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        Appendix B: Proof of Theorem 2</h2>

      <!-- Lemma 1 -->
      <div class="formal-block formal-block-lemma my-6">
        <p class="font-semibold text-amber-400 mb-2">Lemma 1</p>
        <p class="text-gray-300">
          Let
          <span class="math">p(X) \in \mathbb&#123;F&#125;[X]</span>
          be a polynomial of maximal degree
          <span class="math">d-1</span>, and let
          <span class="math">q(X) \in \mathbb&#123;F&#125;[X]</span>
          be a polynomial of maximal degree
          <span class="math">d-1</span> such that
          <span class="math">q(x) = (p(x)-v)/(x-y)</span> holds for
          <span class="math">d+1</span> distinct values
          <span class="math">x_1, x_2, \ldots, x_&#123;d+1&#125; \in \mathbb&#123;F&#125;</span>
          and some fixed
          <span class="math">y \in \mathbb&#123;F&#125; \setminus \&#123;x_1, x_2, \ldots, x_&#123;d+1&#125;\&#125;</span>
          and fixed
          <span class="math">v \in \mathbb&#123;F&#125;</span>.
          Then <span class="math">p(y) = v</span>.
        </p>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Let
        <span class="math">f(X) = q(X) \cdot (X - y)</span> be a
        polynomial of maximal degree <span class="math">d</span>, and
        let <span class="math">g(X) = p(X) - v</span> be a polynomial
        of maximal degree <span class="math">d - 1</span>. Since we
        have that <span class="math">f(X) = g(X)</span> over a domain
        of size <span class="math">d + 1</span>, by the degree bounds
        of <span class="math">f(X)</span> and
        <span class="math">g(X)</span> this gives us that
        <span class="math">f(X) = g(X)</span>. Following the definition
        of <span class="math">f(X)</span> we have that
        <span class="math">g(X)</span> is perfectly divisible by
        <span class="math">(X - y)</span> and so by the factor theorem
        <span class="math">p(y) = v</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <em>Proof of Theorem 2.</em> Perfect completeness follows from
        the perfect completeness of the polynomial commitment opening
        argument. Perfect special honest-verifier zero knowledge is shown
        with a simulator
        <span class="math">\mathcal&#123;S&#125;</span> that behaves
        identically to the honest prover except that it outputs random
        <span class="math">R, T_&#123;\text&#123;lo&#125;&#125;, T_&#123;\text&#123;hi&#125;&#125;, H \in \mathbb&#123;G&#125;</span>
        and supplies random
        <span class="math">v_1, v_5, v_6, v_9, v_&#123;10&#125;, v_&#123;12&#125; \in \mathbb&#123;F&#125;</span>
        such that the verifier&rsquo;s check is satisfied.
      </p>

      <p class="text-gray-300 mt-4">
        In total the extractor
        <span class="math">\mathcal&#123;X&#125;</span> requires
        <span class="math">5 \cdot (d+1) \cdot 5 \cdot 7 \cdot 2d \cdot d \cdot d</span>
        invocations of the extractor
        <span class="math">\mathcal&#123;X&#125;_&#123;\text&#123;poly&#125;&#125;</span>
        which is polynomial in <span class="math">\lambda</span> and so
        by the general forking lemma [13, Theorem 6] we have shown
        computational witness-extended emulation.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX C                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-c" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        Appendix C: Proof for Algorithm 1</h2>

      <p class="text-gray-300">
        Collecting the scalars by which
        <span class="math">\phi_p(P)</span> and
        <span class="math">P</span> are multiplied, we see that
        Algorithm 1 is equivalent to Algorithm 2, which outputs
        <span class="math">[a\zeta_q + b]P</span>. The equivalence
        holds because invariants
        <span class="math">\mathrm&#123;Acc&#125; = [a]\phi_p(P) + [b]P = [a\zeta_q + b]P</span>
        and
        <span class="math">S_i = [\mathbf&#123;c&#125;_i]\phi_p(P) + [\mathbf&#123;d&#125;_i]P = [\mathbf&#123;c&#125;_i\zeta_q + \mathbf&#123;d&#125;_i]P</span>
        are maintained at corresponding steps.
      </p>

      <!-- Lemma 2 -->
      <div class="formal-block formal-block-lemma my-6">
        <p class="font-semibold text-amber-400 mb-2">Lemma 2</p>
        <p class="text-gray-300">
          For <span class="math">k \geq 0</span>,
          <span class="math">(\mathbf&#123;c&#125;, \mathbf&#123;d&#125;) \in M_k \mapsto \left(\sum_&#123;j=0&#125;^&#123;k-1&#125; \mathbf&#123;c&#125;_j 2^j,\; \sum_&#123;j=0&#125;^&#123;k-1&#125; \mathbf&#123;d&#125;_j 2^j\right)</span>
          is injective.
        </p>
      </div>

      <p class="text-gray-300">
        <strong>Corollary 1.</strong>
        <span class="math">\mathbf&#123;r&#125; \mapsto (a, b)</span>
        is injective, following from Lemma 2 and the relations
        <span class="math">a = 2^&#123;\lambda/2&#125; + 1 + 2\sum_&#123;j=0&#125;^&#123;\lambda/2-1&#125; \mathbf&#123;c&#125;_j 2^j</span>
        and
        <span class="math">b = 2^&#123;\lambda/2&#125; + 1 + 2\sum_&#123;j=0&#125;^&#123;\lambda/2-1&#125; \mathbf&#123;d&#125;_j 2^j</span>
        in Algorithm 2.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Corollary 2.</strong> Let
        <span class="math">n_p(\mathbf&#123;r&#125;) = (a_&#123;\mathbf&#123;r&#125;&#125;\zeta_q + b_&#123;\mathbf&#123;r&#125;&#125;) \bmod q</span>
        as computed by Algorithm 2 for
        <span class="math">\lambda = 128</span>, and similarly for
        <span class="math">n_q</span>, where
        <span class="math">p, q, \zeta_p</span> and
        <span class="math">\zeta_q</span> are as defined for the
        Tweedledum and Tweedledee curves
        (<a href="#sec-6.1"
          class="text-blue-400 hover:text-blue-300">Section 6.1</a>).
        Then <span class="math">n_p</span> and
        <span class="math">n_q</span> are injective.
      </p>

      <p class="text-gray-300 mt-4">
        Hence, on each curve, sampling
        <span class="math">\mathbf&#123;r&#125;</span> uniformly at
        random from
        <span class="math">\&#123;0,1\&#125;^\lambda</span> and
        computing
        <span class="math">[n(\mathbf&#123;r&#125;)]P</span> via
        Algorithm 1 will be equivalent to sampling the challenge scalar
        uniformly at random from
        <span class="math">\mathbb&#123;I&#125;</span>. This is
        sufficient for security of our protocol, which does not depend on
        the specific set
        <span class="math">\mathbb&#123;I&#125;</span> but only that
        its size is at least
        <span class="math">2^\lambda</span>.
      </p>
    </section>

  </article>
</BaseLayout>
