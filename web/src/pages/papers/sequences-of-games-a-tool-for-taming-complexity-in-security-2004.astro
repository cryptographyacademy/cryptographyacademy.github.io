---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/332';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Sequences of games: a tool for taming complexity in security proofs';
const AUTHORS_HTML = 'Victor Shoup';

const CONTENT = `    <p class="text-gray-300">Sequences of Games: A Tool for Taming Complexity in Security Proofs</p>

    <p class="text-gray-300">Victor Shoup</p>

    <p class="text-gray-300">January 18, 2006</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">This paper is brief tutorial on a technique for structuring security proofs as sequences games.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Security proofs in cryptography may sometimes be organized as sequences of games. In certain circumstances, this can be a useful tool in taming the complexity of security proofs that might otherwise become so messy, complicated, and subtle as to be nearly impossible to verify. This technique appears in the literature in various styles, and with various degrees of rigor and formality. This paper is meant to serve as a brief tutorial on one particular “style” of employing this technique, which seems to achieve a reasonable level of mathematical rigor and clarity, while not getting bogged down with too much formalism or overly restrictive rules. We do not make any particular claims of originality — it is simply hoped that others might profit from some of the ideas discussed here in reasoning about security.</p>

    <p class="text-gray-300">At the outset, it should be noted that this technique is certainly not applicable to all security proofs. Moreover, even when this technique is applicable, it is only a tool for organizing a proof — the actual <em>ideas</em> for a cryptographic construction and security analysis must come from elsewhere.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 The Basic Idea</h3>

    <p class="text-gray-300">Security for cryptograptic primitives is typically defined as an <em>attack game</em> played between an <em>adversary</em> and some benign entity, which we call the <em>challenger</em>. Both adversary and challenger are probabilstic processes that communicate with each other, and so we can model the game as a probability space. Typically, the definition of security is tied to some particular event <span class="math">S</span>. Security means that for every “efficient” adversary, the probability that event <span class="math">S</span> occurs is “very close to” some specified “target probabilty”: typically, either 0, 1/2, or the probability of some event <span class="math">T</span> in some other game in which the same adversary is interacting with a different challenger.</p>

    <p class="text-gray-300">*First public version: Nov. 30, 2004</p>

    <p class="text-gray-300">†Computer Science Dept. NYU. shoup@cs.nyu.edu</p>

    <p class="text-gray-300">In the formal definitions, there is a security parameter: an integer tending to infinity, and in the previous paragraph, “efficient” means time bounded by a polynomial in the security parameter, and “very close to” means the difference is smaller than the inverse of any polynomial in the security parameter, for sufficiently large values of the security parameter. The term of art is negligibly close to, and a quantity that is negliglibly close to zero is just called negligible. For simplicity, we shall for the most part avoid any further discussion of the security parameter, and it shall be assumed that all algorithms, adversaries, etc., take this value as an implicit input.</p>

    <p class="text-gray-300">Now, to prove security using the sequence-of-games approach, one prodceeds as follows. One constructs a sequence of games, Game 0, Game 1, …, Game <span class="math">n</span>, where Game 0 is the original attack game with respect to a given adversary and cryptographic primitive. Let <span class="math">S_{0}</span> be the event <span class="math">S</span>, and for <span class="math">i=1,\\ldots,n</span>, the construction defines an event <span class="math">S_{i}</span> in Game <span class="math">i</span>, usually in a way naturally related to the definition of <span class="math">S</span>. The proof shows that <span class="math">\\Pr[S_{i}]</span> is negligibly close to <span class="math">\\Pr[S_{i+1}]</span> for <span class="math">i=0,\\ldots,n-1</span>, and that <span class="math">\\Pr[S_{n}]</span> is equal (or negligibly close) to the “target probability.” From this, and the fact that <span class="math">n</span> is a constant, it follows that <span class="math">\\Pr[S]</span> is negligibly close to the “target probability,” and security is proved.</p>

    <p class="text-gray-300">That is the general framework of such a proof. However, in constructing such proofs, it is desirable that the changes between succesive games are very small, so that analyzing the change is as simple as possible. From experience, it seems that transitions between successive games can be restricted to one of three types:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transitions based on indistinguishability. In such a transition, a small change is made that, if detected by the adversary, would imply an efficient method of distinguishing between two distributions that are indistinguishable (either statistically or computationally). For example, suppose <span class="math">P_{1}</span> and <span class="math">P_{2}</span> are assumed to be computationally indistinguishable distributions. To prove that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{i}]-\\Pr[S_{i+1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible, one argues that there exists a distinguishing algorithm </span>D<span class="math"> that “interpolates” between Game </span>i<span class="math"> and Game </span>i+1<span class="math">, so that when given an element drawn from distribution </span>P_{1}<span class="math"> as input, </span>D<span class="math"> outputs </span>1<span class="math"> with probability </span>\\Pr[S_{i}]<span class="math">, and when given an element drawn from distribution </span>P_{2}<span class="math"> as input, </span>D<span class="math"> outputs </span>1<span class="math"> with probabilty </span>\\Pr[S_{i+1}]<span class="math">. The indistinguishability assumption then implies that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{i}]-\\Pr[S_{i+1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is negligible. Usually, the construction of </span>D<span class="math"> is obvious, provided the changes made in the transition are minimal. Typically, one designs the two games so that they could easily be rewritten as a single “hybrid” game that takes an auxilliary input — if the auxiallary input is drawn from </span>P_{1}<span class="math">, you get Game </span>i<span class="math">, and if drawn from </span>P_{2}<span class="math">, you get Game </span>i+1<span class="math">. The distinguisher then simply runs this single hybrid game with its input, and outputs </span>1$ if the appropriate event occurs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Transitions based on failure events. In such a transition, one argues that Games <span class="math">i</span> and <span class="math">i+1</span> proceed identically unless a certain “failure event” <span class="math">F</span> occurs. To make this type of argument as cleanly as possible, it is best if the two games are defined on the same underlying probability space — the only differences between the two games are the rules for computing certain random variables. When done this way, saying that the two games proceed identically unless <span class="math">F</span> occurs is equivalent to saying that</p>

    <p class="text-gray-300"><span class="math">S_{i}\\wedge\\neg F\\iff S_{i+1}\\wedge\\neg F,</span></p>

    <p class="text-gray-300">that is, the events <span class="math">S_{i}\\wedge\\neg F</span> and <span class="math">S_{i+1}\\wedge\\neg F</span> are the same. If this is true, then we can use the</p>

    <p class="text-gray-300">following fact, which is completely trivial, yet is so often used in these types of proofs that it deserves a name:</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Lemma 1 (Difference Lemma).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">A,B,F</span> be events defined in some probability distribution, and suppose that <span class="math">A\\wedge\\neg F\\iff B\\wedge\\neg F</span>. Then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A]-\\Pr[B]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-4" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This is a simple calculation. We have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A]-\\Pr[B]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A\\wedge F]+\\Pr[A\\wedge\\neg F]-\\Pr[B\\wedge F]-\\Pr[B\\wedge\\neg F]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\leq\\Pr[F].</span></p>

    <p class="text-gray-300">The second equality follows from the assumption that <span class="math">A\\wedge\\neg F\\iff B\\wedge\\neg F</span>, and so in particular, <span class="math">\\Pr[A\\wedge\\neg F]=\\Pr[B\\wedge\\neg F]</span>. The final inequality follows from the fact that both <span class="math">\\Pr[A\\wedge F]</span> and <span class="math">\\Pr[B\\wedge F]</span> are numbers between <span class="math">0</span> and <span class="math">\\Pr[F]</span>. <span class="math">\\Box</span></p>

    <p class="text-gray-300">So to prove that <span class="math">\\Pr[S_{i}]</span> is negligibly close to <span class="math">\\Pr[S_{i+1}]</span>, it suffices to prove that <span class="math">\\Pr[F]</span> is negligible. Sometimes, this is done using a security assumption (i.e., when <span class="math">F</span> occurs, the adversary has found a collision in a hash function, or forged a MAC), while at other times, it can be done using a purely information-theoretic argument.</p>

    <p class="text-gray-300">Usually, the event <span class="math">F</span> is defined and analyzed in terms of the random variables of one of the two adjacent games. The choice is arbitrary, but typically, one of the games will be more suitable than the other in terms of allowing a clear proof.</p>

    <p class="text-gray-300">In some particularly challenging circumstances, it may be difficult to analyze the event <span class="math">F</span> in either game. In fact, the analysis of <span class="math">F</span> may require its own sequence of games sprouting off in a different direction, or the sequence of games for <span class="math">F</span> may coincide with the sequence of games for <span class="math">S</span>, so that <span class="math">\\Pr[F]</span> finally gets pinned down in Game <span class="math">j</span> for <span class="math">j&gt;i+1</span>. This technique is sometimes crucial in side-stepping potential circularities.</p>

    <p class="text-gray-300">Bridging steps. The third type of transition introduces a bridging step, which is typically a way of restating how certain quantities can be computed in a completely equivalent way. The change is purely conceptual, and <span class="math">\\Pr[S_{i}]=\\Pr[S_{i+1}]</span>. The reason for doing this is to prepare the ground for a transition of one of the above two types. While in principle, such a bridging step may seem unnecessary, without it, the proof would be much harder to follow.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As mentioned above, in a transition based on a failure event, it is best if the two successive games are understood to be defined on the same underlying probability space. This is an important point, which we repeat here for emphasis — it seems that proofs are easiest to understand if one does not need to compare “corresponding” events across distinct and (by design) quite different probability spaces. Actually, it is good practice to simply have all the games in the sequence defined on the same underlying probability space. However, the Difference Lemma generalizes in the obvious way as follows: if <span class="math">A</span>, <span class="math">B</span>, <span class="math">F_{1}</span> and <span class="math">F_{2}</span> are events such that <span class="math">\\Pr[A\\wedge\\neg F_{1}]=\\Pr[B\\wedge\\neg F_{2}]</span> and <span class="math">\\Pr[F_{1}]=\\Pr[F_{2}]</span>, then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[A]-\\Pr[B]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{1}]$. With this generalized version, one may (if one wishes) analyze transitions based on failure events when the underlying probability spaces are not the same.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">“Hybrid arguments” have been used extensively in cryptography for many years. Such an argument is essentially a sequence of transitions based on indistinguishability. An early example that clearly illustrates this technique is Goldreich, Goldwasser, and Micali’s paper <em>[x10]</em> on constructing pseudo-random functions (although this is by no means the earliest application of a hybrid argument). Note that in some applications, such as <em>[x10]</em>, one in fact makes a non-constant number of transitions, which requires an additional, probabilistic argument.</p>

    <p class="text-gray-300">Although some might use the term “hybrid argument” to include proofs that use transitions based on both indistinguishability and failure events, that seems to be somewhat of a stretch of terminology. An early example of a proof that is clearly structured as a sequence of games that involves transitions based on both indistinguishability and failure events is Bellare and Goldwasser’s paper <em>[x3]</em>.</p>

    <p class="text-gray-300">Kilian and Rogaway’s paper <em>[x17]</em> on DESX initiates a somewhat more formal approach to sequences of games. That paper essentially uses the Difference Lemma, specialized to their particular setting. Subsequently, Rogaway has refined and applied this technique in numerous works with several co-authors. We refer the reader to the paper <em>[x4]</em> by Bellare and Rogaway that gives a detailed introduction to the methodology, as well as references to papers where it has been used. However, we comment briefly on some of the differences between the technique discussed in this paper, and that advocated in <em>[x4]</em>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Bellare and Rogaway’s approach, games are programs and are treated as purely syntactic objects subject to formal manipulation. In contrast, we view games as probability spaces and random variables defined over them, and do not insist on any particular syntactic formalism beyond that convenient to make a rigorous mathematical argument.</li>

      <li>In Bellare and Rogaway’s approach, transitions based on failure events are restricted to events in which an executing program explicitly sets a particular boolean variable to true. In contrast, we do not suggest that events need to be explicitly “announced.”</li>

      <li>In Bellare and Rogaway’s approach, when the execution behaviors of two games are compared, two distinct probability spaces are involved, and probabilities of “corresponding” events across probability spaces must be compared. In contrast, we suggest that games should be defined on a common probability space, so that when discussing, say, a particular failure event <span class="math">F</span>, there is literally just one event, not a pair of corresponding events in two different probability spaces.</li>

    </ul>

    <p class="text-gray-300">In the end, we think that the choice between the style advocated in <em>[x4]</em> and that suggested here is mainly a matter of taste and convenience.</p>

    <p class="text-gray-300">The author has used proofs organized as sequences of games extensively in his own work <em>[x21, x22, x23, x24, x16, x18, x19]</em> and has found them to be an indispensable tool — while some of the proofs in these papers could be structured differently, it is hard to imagine how most of them could be done in a more clear and convincing way without sequences of games (note that all but the first two papers above adhere to the rule suggested here of defining games to operate on the same probability space). Other authors</p>

    <p class="text-gray-300">have also been using very similar proof styles recently *[x1, x3, x2, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99, x100, x101, x102, x103, x104, x105, x106, x107, x108, x109, x110, x111, x112, x113, x114, x115, x116, x117, x118, x119, x120, x121, x122, x123, x124, x125, x126, x127, x128, x129, x130, x131, x132, x133, x134, x135, x136, x137, x138, x139, x140, x141, x142, x143, x144, x145, x146, x147, x148, x149, x150, x151, x152, x153, x154, x155, x156, x157, x158, x159, x160, x161, x162, x163, x164, x165, x166, x167, x168, x169, x170, x171, x172, x173, x174, x175, x176, x177, x178, x179, x180, x181, x182, x183, x184, x185, x186, x187, x188, x189, x190, x191, x192, x193, x194, x195, x196, x197, x198, x199, x200, x201, x202, x203, x204, x205, x206, x207, x208, x209, x210, x211, x212, x213, x214, x215, x216, x217, x218, x219, x220, x221, x222, x223, x224, x225, x226, x227, x228, x229, x230, x231, x232, x233, x234, x235, x236, x237, x238, x239, x240, x241, x242, x243, x244, x245, x246, x247, x248, x249, x250, x251, x252, x253, x254, x255, x256, x257, x258, x259, x260, x261, x262, x263, x264, x265, x266, x267, x268, x269, x270, x271, x272, x273, x274, x275, x276, x277, x278, x279, x280, x281, x282, x283, x284, x285, x286, x287, x288, x289, x290, x291, x292, x293, x294, x295, x296, x297, x298, x299, x300, x301, x302, x303, x304, x305, x306, x307, x308, x309, x310, x311, x312, x313, x314, x315, x316, x317, x318, x319, x320, x321, x322, x323, x324, x325, x326, x327, x328, x329, x330, x331, x332, x333, x334, x335, x336, x337, x338, x339, x340, x341, x342, x343, x344, x345, x346, x347, x348, x349, x350, x351, x352, x353, x354, x355, x356, x357, x358, x359, x360, x361, x362, x363, x364, x365, x366, x367, x368, x369, x370, x371, x372, x373, x374, x375, x376, x377, x378, x379, x380, x381, x382, x383, x384, x385, x386, x387, x388, x389, x390, x391, x392, x393, x394, x395, x396, x397, x398, x399, x400, x401, x402, x403, x404, x405, x406, x407, x408, x409, x410, x411, x412, x413, x414, x415, x416, x417, x418, x419, x420, x421, x422, x423, x424, x425, x426, x427, x428, x429, x430, x431, x432, x433, x434, x435, x436, x437, x438, x439, x440, x441, x442, x443, x444</p>

    <p class="text-gray-300"><span class="math">x_{1}</span>, and so on, all the way to <span class="math">x_{n}</span>, the predicate <span class="math">\\phi(x_{1},\\ldots,x_{n})</span> is true. We allow the predicate <span class="math">\\phi</span> to involve the execution of probabilistic algorithms.</p>

    <p class="text-gray-300">If <span class="math">X</span> is a probability distribution on a sample space <span class="math">\\mathcal{X}</span>, then <span class="math">[X]</span> denotes the subset of elements of <span class="math">\\mathcal{X}</span> that occur with non-zero probability.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 ElGamal Encryption</h2>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.1 Basic Definitions</h3>

    <p class="text-gray-300">We first recall the basic definition of a public-key encryption scheme, and the notion of semantic security.</p>

    <p class="text-gray-300">A public-key encryption scheme is a triple of probabilistic algorithms <span class="math">(KeyGen,E,D)</span>. The key generation algorithm <span class="math">KeyGen</span> takes no input (other than an implied security parameter, and perhaps other system parameters), and outputs a public-key/secret-key pair <span class="math">(pk,sk)</span>. The encryption algorithm <span class="math">E</span> takes as input a public key <span class="math">pk</span> and a message <span class="math">m</span>, selected from a message space <span class="math">M</span>, and outputs a ciphertext <span class="math">\\psi</span>. The decryption algorithm takes as input a secret key <span class="math">sk</span> and ciphertext <span class="math">\\psi</span>, and outputs a message <span class="math">m</span>.</p>

    <p class="text-gray-300">The basic correctness requirement is that decryption “undoes” encryption. That is, for all <span class="math">m\\in M</span>, all <span class="math">(pk,sk)\\in[KeyGen()]</span>, all <span class="math">\\psi\\in[E(pk,m)]</span>, and all <span class="math">m^{\\prime}\\in[D(sk,\\psi)]</span>, we have <span class="math">m=m^{\\prime}</span>. This definition can be relaxed in a number of ways; for example, we may only insist that it is computationally infeasible to find a message for which decryption does not “undo” its encryption.</p>

    <p class="text-gray-300">The notion of semantic security intuitively says that an adversary cannot effectively distinguish between the encryption of two messages of his choosing (this definition comes from <em>[x10]</em>, where is called <em>polynomial indistinguishability</em>, and <em>semantic security</em> is actually the name of a syntactically different, but equivalent, characterization). This is formally defined via a game between an adversary and a challenger.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger computes <span class="math">(pk,sk)\\xleftarrow{\\scriptstyle\\ddagger}KeyGen()</span>, and gives <span class="math">pk</span> to the adversary.</li>

      <li>The adversary chooses two messages <span class="math">m_{0},m_{1}\\in M</span>, and gives these to the challenger.</li>

      <li>The challenger computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">b\\xleftarrow{\\scriptstyle\\ddagger}\\{0,1\\},\\ \\psi\\xleftarrow{\\scriptstyle\\ddagger}E(pk,m_{b})</span></p>

    <p class="text-gray-300">and gives the “target ciphertext” <span class="math">\\psi</span> to the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define the <em>SS-advantage</em> of the adversary to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[b=\\hat{b}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. <em>Semantic security</em> means that any efficient adversary’s SS-advantage is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.2 The ElGamal Encryption Scheme</h3>

    <p class="text-gray-300">We next recall ElGamal encryption. Let <span class="math">G</span> be a group of prime order <span class="math">q</span>, and let <span class="math">\\gamma\\in G</span> be a generator (we view the descriptions of <span class="math">G</span> and <span class="math">\\gamma</span>, including the value <span class="math">q</span>, to be part of a set of implied system parameters).</p>

    <p class="text-gray-300">The key generation algorithm computes <span class="math">(pk,sk)</span> as follows:</p>

    <p class="text-gray-300"><span class="math">x\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ \\alpha\\leftarrow\\gamma^{x},\\ pk\\leftarrow\\alpha,\\ sk\\leftarrow x.</span></p>

    <p class="text-gray-300">The message space for the algorithm is <span class="math">G</span>. To encrypt a message <span class="math">m\\in G</span>, the encryption algorithm computes a ciphertext <span class="math">\\psi</span> as follows:</p>

    <p class="text-gray-300"><span class="math">y\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ \\beta\\leftarrow\\gamma^{y},\\ \\delta\\leftarrow\\alpha^{y},\\ \\zeta\\leftarrow\\delta\\cdot m,\\ \\psi\\leftarrow(\\beta,\\zeta).</span></p>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext <span class="math">(\\beta,\\zeta)</span>, and computes <span class="math">m</span> as follows:</p>

    <p class="text-gray-300"><span class="math">m\\leftarrow\\zeta/\\beta^{x}.</span></p>

    <p class="text-gray-300">It is clear that decryption “undoes” encryption. Indeed, if <span class="math">\\beta=\\gamma^{y}</span> and <span class="math">\\zeta=\\alpha^{y}\\cdot m</span>, then</p>

    <p class="text-gray-300"><span class="math">\\zeta/\\beta^{x}=\\alpha^{y}m/\\beta^{x}=(\\gamma^{x})^{y}m/(\\gamma^{y})^{x}=\\gamma^{xy}m/\\gamma^{xy}=m.</span></p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.3 Security Analysis</h3>

    <p class="text-gray-300">ElGamal encryption is semantically secure under the Decisional Diffie-Hellman (DDH) assumption. This is the assumption that it is hard to distinguish triples of the form <span class="math">(\\gamma^{x},\\gamma^{y},\\gamma^{xy})</span> from triples of the form <span class="math">(\\gamma^{x},\\gamma^{y},\\gamma^{z})</span>, where <span class="math">x</span>, <span class="math">y</span>, and <span class="math">z</span> are random elements of <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">The DDH assumption is more precisely formulated as follows. Let <span class="math">D</span> be an algorithm that takes as input triples of group elements, and outputs a bit. We define the <em>DDH-advantage</em> of <span class="math">D</span> to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[x,y\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q}:D(\\gamma^{x},\\gamma^{y},\\gamma^{xy})=1]-\\Pr[x,y,z\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q}:D(\\gamma^{x},\\gamma^{y},\\gamma^{z})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The DDH assumption (for <span class="math">G</span>) is the assumption that any efficient algorithm’s DDH-advantage is negligible.</p>

    <p class="text-gray-300">We now give a proof of the semantic security of ElGamal encryption under the DDH assumption, using a sequence of games.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Game 0.</h6>

    <p class="text-gray-300">Fix an efficient adversary <span class="math">A</span>. Let us define Game 0 to be the attack game against <span class="math">A</span> in the definition of semantic security. To make things more precise and more concrete, we may describe the attack game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">x\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q}</span>, <span class="math">\\alpha\\leftarrow\\gamma^{x}</span> <span class="math">r\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}R</span>, <span class="math">(m_{0},m_{1})\\leftarrow A(r,\\alpha)</span> <span class="math">b\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\{0,1\\}</span>, <span class="math">y\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\mathbb{Z}_{q}</span>, <span class="math">\\beta\\leftarrow\\gamma^{y}</span>, <span class="math">\\delta\\leftarrow\\alpha^{y}</span>, <span class="math">\\zeta\\leftarrow\\delta\\cdot m_{b}</span> <span class="math">\\hat{b}\\leftarrow A(r,\\alpha,\\beta,\\zeta)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the above, we have modeled the adversary <span class="math">A</span> is a deterministic algorithm that takes as input “random coins” <span class="math">r</span> sampled uniformly from some set <span class="math">R</span>. It should be evident that this algorithm faithfully represents the attack game. If we define <span class="math">S_{0}</span> to be the event that <span class="math">b=\\hat{b}</span>, then the adversary’s SS-advantage is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Game 1. [This is a transition based on indistinguishability.] We now make one small change to the above game. Namely, instead of computing <span class="math">\\delta</span> as <span class="math">\\alpha^y</span>, we compute it as <span class="math">\\gamma^z</span> for randomly chosen <span class="math">z \\in \\mathbb{Z}_q</span>. We can describe the resulting game algorithmically as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q, \\alpha \\leftarrow \\gamma^x \\\\ r \\stackrel{\\iota}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha) \\\\ b \\stackrel{\\iota}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, \\boxed{z \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q, \\delta \\leftarrow \\gamma^z,} \\zeta \\leftarrow \\delta \\cdot m_b \\\\ \\hat{b} \\leftarrow A(r, \\alpha, \\beta, \\zeta) \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">S_1</span> be the event that <span class="math">b = \\hat{b}</span> in Game 1.</p>

    <p class="text-gray-300">Claim 1. <span class="math">\\operatorname{Pr}[S_1] = 1/2</span>. This follows from the fact that in Game 2, <span class="math">\\delta</span> is effectively a one-time pad, and as such, the adversary's output <span class="math">\\hat{b}</span> is independent of the hidden bit <span class="math">b</span>. To prove this more rigorously, it will suffice to show that <span class="math">b, r, \\alpha, \\beta, \\zeta</span> are mutually independent, since from this, it follows that <span class="math">b</span> and <span class="math">\\hat{b} = A(r, \\alpha, \\beta, \\zeta)</span> are independent. First observe that by construction, <span class="math">b, r, \\alpha, \\beta, \\delta</span> are mutually independent. It will suffice to show that conditioned on any fixed values of <span class="math">b, r, \\alpha, \\beta</span>, the conditional distribution of <span class="math">\\zeta</span> is the uniform distribution over <span class="math">G</span>. Now, if <span class="math">b, r, \\alpha, \\beta</span> are fixed, then so are <span class="math">m_0, m_1</span>, since they are determined by <span class="math">r, \\alpha</span>; moreover, by independence, the conditional distribution of <span class="math">\\delta</span> is the uniform distribution on <span class="math">G</span>, and hence from this, one sees that the conditional distribution of <span class="math">\\zeta = \\delta \\cdot m_b</span> is the uniform distribution on <span class="math">G</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 2. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[S_0] - \\operatorname{Pr}[S_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\epsilon_{\\mathrm{ddh}}<span class="math">, where </span>\\epsilon_{\\mathrm{ddh}}$ is the DDH-advantage of some efficient algorithm (and hence negligible under the DDH assumption).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of this is essentially the observation that in Game 0, the triple <span class="math">(\\alpha, \\beta, \\delta)</span> is of the form <span class="math">(\\gamma^x, \\gamma^y, \\gamma^{xy})</span>, while in Game 1, it is of the form <span class="math">(\\gamma^x, \\gamma^y, \\gamma^z)</span>, and so the adversary should not notice the difference, under the DDH assumption. To be more precise, our distinguishing algorithm <span class="math">D</span> works as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text{Algorithm } D(\\alpha, \\beta, \\delta) \\\\ r \\stackrel{\\iota}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha) \\\\ b \\stackrel{\\iota}{\\leftarrow} \\{0, 1\\}, \\zeta \\leftarrow \\delta \\cdot m_b \\\\ \\hat{b} \\leftarrow A(r, \\alpha, \\beta, \\zeta) \\\\ \\text{if } b = \\hat{b} \\\\ \\text{then output } 1 \\\\ \\text{else output } 0 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Algorithm <span class="math">D</span> effectively "interpolates" between Games 0 and 1. If the input to <span class="math">D</span> is of the form <span class="math">(\\gamma^x, \\gamma^y, \\gamma^{xy})</span>, then computation proceeds just as in Game 0, and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[x, y \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^{xy}) = 1] = \\operatorname{Pr}[S_0].</span></div>

    <p class="text-gray-300">If the input to <span class="math">D</span> is of the form <span class="math">(\\gamma^x, \\gamma^y, \\gamma^z)</span>, then computation proceeds just as in Game 1, and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}[x, y, z \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q : D(\\gamma^x, \\gamma^y, \\gamma^z) = 1] = \\operatorname{Pr}[S_1].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From this, it follows that the DDH-advantage of <span class="math">D</span> is equal to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. That completes the proof of Claim 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Claim 1 and Claim 2, we see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\mathrm{ddh}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and this is negligible. That completes the proof of security of ElGamal encryption.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.4 Hashed ElGamal</h3>

    <p class="text-gray-300">For a number of reasons, it is convenient to work with messages that are bit strings, say, of length <span class="math">\\ell</span>, rather than group elements. Because of this, one may choose to use a “hashed” version of the ElGamal encryption scheme.</p>

    <p class="text-gray-300">This scheme makes use of a family of keyed “hash” functions <span class="math">\\mathcal{H}:=\\{H_{k}\\}_{k\\in K}</span>, where each <span class="math">H_{k}</span> is a function mapping <span class="math">G</span> to <span class="math">\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">The key generation algorithm computes <span class="math">(pk,sk)</span> as follows:</p>

    <p class="text-gray-300"><span class="math">x\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}K,\\ \\alpha\\leftarrow\\gamma^{x},\\ pk\\leftarrow(\\alpha,k),\\ sk\\leftarrow(x,k).</span></p>

    <p class="text-gray-300">To encrypt a message <span class="math">m\\in\\{0,1\\}^{\\ell}</span>, the encryption algorithm computes a ciphertext <span class="math">\\psi</span> as follows:</p>

    <p class="text-gray-300"><span class="math">y\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ \\beta\\leftarrow\\gamma^{y},\\ \\delta\\leftarrow\\alpha^{y},\\ h\\leftarrow H_{k}(\\delta),\\ v\\leftarrow h\\oplus m,\\ \\psi\\leftarrow(\\beta,v).</span></p>

    <p class="text-gray-300">The decryption algorithm takes as input a ciphertext <span class="math">(\\beta,v)</span>, and computes <span class="math">m</span> as follows:</p>

    <p class="text-gray-300"><span class="math">m\\leftarrow H_{k}(\\beta^{x})\\oplus v.</span></p>

    <p class="text-gray-300">The reader may easily verify that decryption “undoes” encryption.</p>

    <p class="text-gray-300">As for semantic security, this can be proven under the DDH assumption and the assumption that the family of hash functions <span class="math">\\mathcal{H}</span> is “entropy smoothing.” Loosely speaking, this means that it is hard to distinguish <span class="math">(k,H_{k}(\\delta))</span> from <span class="math">(k,h)</span>, where <span class="math">k</span> is a random element of <span class="math">K</span>, <span class="math">\\delta</span> is a random element of <span class="math">G</span>, and <span class="math">h</span> is a random element of <span class="math">\\{0,1\\}^{\\ell}</span>. More formally, let <span class="math">D</span> be an algorithm that takes as input an element of <span class="math">K</span> and an element of <span class="math">\\{0,1\\}^{\\ell}</span>, and outputs a bit. We define the ES-advantage of <span class="math">D</span> to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}K,\\ \\delta\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}G:D(k,H_{k}(\\delta))=1]-\\Pr[k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}K,\\ h\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}\\{0,1\\}^{\\ell}:D(k,h)=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say <span class="math">\\mathcal{H}</span> is <em>entropy smoothing</em> if every efficient algorithm’s ES-advantage is negligible.</p>

    <p class="text-gray-300">It is in fact possible to construct entropy smoothing hash function families without additional hypothesis (the Leftover Hash Lemma may be used for this <em>[x10]</em>). However, these may be somewhat less practical than <em>ad hoc</em> hash function families for which the entropy smoothing property is only a (perfectly reasonable) conjecture; moreover, our definition also allows entropy smoothers that use pseudo-random bit generation techniques as well.</p>

    <p class="text-gray-300">We now sketch the proof of semantic security of hashed ElGamal encryption, under the DDH assumption and the assumption that <span class="math">\\mathcal{H}</span> is entropy smoothing.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Game 0. This is the original attack game, which we can state algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">x \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\downarrow}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\downarrow}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span></p>

    <p class="text-gray-300"><span class="math">b \\stackrel{\\downarrow}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, \\delta \\leftarrow \\alpha^y, h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span></p>

    <p class="text-gray-300"><span class="math">\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span></p>

    <p class="text-gray-300">We define <span class="math">S_0</span> to be the event that <span class="math">b = \\hat{b}</span> in Game 0.</p>

    <p class="text-gray-300">Game 1. [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing <span class="math">\\delta</span> as <span class="math">\\gamma^z</span> for random <span class="math">z \\in \\mathbb{Z}_q</span>. We can state Game 1 algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">x \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\downarrow}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\downarrow}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span></p>

    <p class="text-gray-300"><span class="math">b \\stackrel{\\downarrow}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, \\boxed{z \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, \\delta \\leftarrow \\gamma^z,} h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span></p>

    <p class="text-gray-300"><span class="math">\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span></p>

    <p class="text-gray-300">Let <span class="math">S_1</span> be the event that <span class="math">b = \\hat{b}</span> in Game 1. We claim that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {0} \\right] - \\Pr \\left[ S _ {1} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\epsilon_ {\\mathrm {d d h}}, \\tag {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{ddh}}</span> is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof of this is almost identical to the proof of the corresponding claim for "plain" ElGamal. Indeed, the following algorithm <span class="math">D</span> "interpolates" between Game 0 and Game 1, and so has DDH-advantage equal to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[S_0] - \\operatorname</em>{Pr}[S_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm <span class="math">D(\\alpha, \\beta, \\delta)</span></p>

    <p class="text-gray-300"><span class="math">k \\stackrel{\\downarrow}{\\leftarrow} K</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\downarrow}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span></p>

    <p class="text-gray-300"><span class="math">b \\stackrel{\\downarrow}{\\leftarrow} \\{0, 1\\}, h \\leftarrow H_k(\\delta), v \\leftarrow h \\oplus m_b</span></p>

    <p class="text-gray-300"><span class="math">\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span></p>

    <p class="text-gray-300">if <span class="math">b = \\hat{b}</span></p>

    <p class="text-gray-300">then output 1</p>

    <p class="text-gray-300">else output 0</p>

    <p class="text-gray-300">Game 2. [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing <span class="math">h</span> by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:</p>

    <p class="text-gray-300"><span class="math">x \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, k \\stackrel{\\downarrow}{\\leftarrow} K, \\alpha \\leftarrow \\gamma^x</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\downarrow}{\\leftarrow} R, (m_0, m_1) \\leftarrow A(r, \\alpha, k)</span></p>

    <p class="text-gray-300"><span class="math">b \\stackrel{\\downarrow}{\\leftarrow} \\{0, 1\\}, y \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, \\beta \\leftarrow \\gamma^y, z \\stackrel{\\downarrow}{\\leftarrow} \\mathbb{Z}_q, \\delta \\leftarrow \\gamma^z, \\boxed{h \\stackrel{\\downarrow}{\\leftarrow} \\{0, 1\\}^\\ell,} v \\leftarrow h \\oplus m_b</span></p>

    <p class="text-gray-300"><span class="math">\\hat{b} \\leftarrow A(r, \\alpha, k, \\beta, v)</span></p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">Observe that <span class="math">\\delta</span> plays no role in Game 2.</p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event that <span class="math">b=\\hat{b}</span> in Game 2. We claim that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\text{es}},$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\text{es}}</span> the ES-advantage of some efficient algorithm (which is negligible assuming <span class="math">\\mathcal{H}</span> is entropy smoothing).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is proved using the same idea as before: any difference between <span class="math">\\Pr[S_{1}]</span> and <span class="math">\\Pr[S_{2}]</span> can be parlayed into a corresponding ES-advantage. Indeed, it is easy to see that the following algorithm <span class="math">D^{\\prime}</span> “interpolates” between Game 1 and Game 2, and so has ES-advantage equal to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm <span class="math">D^{\\prime}(k,h)</span> <span class="math">x\\stackrel{{\\scriptstyle k}}{{\\leftarrow}}\\mathbb{Z}_{q}</span>, <span class="math">\\alpha\\leftarrow\\gamma^{x}</span> <span class="math">r\\stackrel{{\\scriptstyle t}}{{\\leftarrow}}R</span>, <span class="math">(m_{0},m_{1})\\leftarrow A(r,\\alpha,k)</span> <span class="math">b\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\{0,1\\}</span>, <span class="math">y\\stackrel{{\\scriptstyle k}}{{\\leftarrow}}\\mathbb{Z}_{q}</span>, <span class="math">\\beta\\leftarrow\\gamma^{y}</span>, <span class="math">v\\leftarrow h\\oplus m_{b}</span> <span class="math">\\hat{b}\\leftarrow A(r,\\alpha,k,\\beta,v)</span> if <span class="math">b=\\hat{b}</span> then output 1 else output 0</p>

    <p class="text-gray-300">Finally, as <span class="math">h</span> acts like a one-time pad in Game 2, it is evident that</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{2}]=1/2.</span> (3)</p>

    <p class="text-gray-300">Combining (1), (2), and (3), we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{\\text{ddh}}+\\epsilon_{\\text{es}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is negligible, since both <span class="math">\\epsilon_{\\text{ddh}}</span> and <span class="math">\\epsilon_{\\text{es}}</span> are negligible.</p>

    <p class="text-gray-300">This proof illustrates how one can utilize more than one intractability assumption in a proof of security in a clean and simple way.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Pseudo-Random Functions</h2>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Basic Definitions</h3>

    <p class="text-gray-300">Let <span class="math">\\ell_{1}</span> and <span class="math">\\ell_{2}</span> be positive integers (which are actually polynomially bounded functions in a security parameter). Let <span class="math">\\mathcal{F}:=\\{F_{s}\\}_{s\\in S}</span> be a family of keyed functions, where each function <span class="math">F_{s}</span> maps <span class="math">\\{0,1\\}^{\\ell_{1}}</span> to <span class="math">\\{0,1\\}^{\\ell_{2}}</span>. Let <span class="math">\\Gamma_{\\ell_{1},\\ell_{2}}</span> denote the set of all functions from <span class="math">\\{0,1\\}^{\\ell_{1}}</span> to <span class="math">\\{0,1\\}^{\\ell_{2}}</span>. Informally, we say that <span class="math">\\mathcal{F}</span> is pseudo-random if it is hard to distinguish a random function drawn from <span class="math">\\mathcal{F}</span> from a random function drawn from <span class="math">\\Gamma_{\\ell_{1},\\ell_{2}}</span>, given black box access to such a function (this notion was introduced in <em>[x11]</em>).</p>

    <p class="text-gray-300">More formally, consider an adversary <span class="math">A</span> that has oracle access to a function in <span class="math">\\Gamma_{\\ell_{1},\\ell_{2}}</span>, and suppose that <span class="math">A</span> always outputs a bit. Define the <em>PRF-advantage</em> of <span class="math">A</span> to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[s\\stackrel{{\\scriptstyle t}}{{\\leftarrow}}S:A^{F_{s}}()=1]-\\Pr[f\\stackrel{{\\scriptstyle t}}{{\\leftarrow}}\\Gamma_{\\ell_{1},\\ell_{2}}:A^{f}()]=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathcal{F}</span> is <em>pseudo-random</em> if any efficient adversary’s PRF-advantage is negligible.</p>

    <p class="text-gray-300">4.2 Extending the Input Length with a Universal Hash Function</p>

    <p class="text-gray-300">We now present one construction that allows one to stretch the input length of a pseudo-random family of functions. Let <span class="math">\\ell</span> be a positive integer with <span class="math">\\ell&gt;\\ell_{1}</span>. Let <span class="math">\\mathcal{H}:=\\{H_{k}\\}_{k\\in K}</span> be a family of keyed hash functions, where each <span class="math">H_{k}</span> maps <span class="math">\\{0,1\\}^{\\ell}</span> to <span class="math">\\{0,1\\}^{\\ell_{1}}</span>. Let us assume that <span class="math">\\mathcal{H}</span> is an <span class="math">\\epsilon_{\\text{uh}}</span>-universal family of hash functions, where <span class="math">\\epsilon_{\\text{uh}}</span> is negligible. This means that for all <span class="math">w,w^{\\prime}\\in\\{0,1\\}^{\\ell}</span> with <span class="math">w\\neq w^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}K:H_{k}(w)=H_{k}(w^{\\prime})]\\leq\\epsilon_{\\text{uh}}.</span></p>

    <p class="text-gray-300">There are many ways to construct such families of hash functions.</p>

    <p class="text-gray-300">Now define the family of functions</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}^{\\prime}:=\\{F^{\\prime}_{k,s}\\}_{(k,s)\\in K\\times S},</span></p>

    <p class="text-gray-300">where each <span class="math">F^{\\prime}_{k,s}</span> is the function from <span class="math">\\{0,1\\}^{\\ell}</span> into <span class="math">\\{0,1\\}^{\\ell_{2}}</span> that sends <span class="math">w\\in\\{0,1\\}^{\\ell}</span> to <span class="math">F_{s}(H_{k}(w))</span>.</p>

    <p class="text-gray-300">We shall now prove that if <span class="math">\\mathcal{F}</span> is pseudo-random, then <span class="math">\\mathcal{F}^{\\prime}</span> is pseudo-random.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Game 0.</h6>

    <p class="text-gray-300">This game represents the computation of an adversary given oracle access to a function drawn at random from <span class="math">\\mathcal{F}^{\\prime}</span>. Without loss of generality, we may assume that the adversary makes exactly <span class="math">q</span> queries to its oracle, and never repeats any queries (regardless of the oracle responses). We may present this computation algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}K</span>, <span class="math">s\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}S</span> <span class="math">r\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">w_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">x_{i}\\leftarrow H_{k}(w_{i})\\in\\{0,1\\}^{\\ell_{1}}</span> <span class="math">y_{i}\\leftarrow F_{s}(x_{i})\\in\\{0,1\\}^{\\ell_{2}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">The idea behind our notation is that the adversary is modeled as a deterministic algorithm <span class="math">A</span>, and we supply its random coins <span class="math">r\\in R</span> as input, and in loop iteration <span class="math">i</span>, the adversary computes its next query <span class="math">w_{i}</span> as a function of its coins and the results <span class="math">y_{1},\\ldots,y_{i-1}</span> of its previous queries <span class="math">w_{1},\\ldots,w_{i-1}</span>. We are assuming that <span class="math">A</span> operates in such a way that the values <span class="math">w_{1},\\ldots,w_{q}</span> are always distinct.</p>

    <p class="text-gray-300">Let <span class="math">S_{0}</span> be the event that the output <span class="math">b=1</span> in Game 0.</p>

    <p class="text-gray-300">Our goal is to transform this game into a game that is equivalent to the computation of the adversary given oracle access to a random element of <span class="math">\\Gamma_{\\ell,\\ell_{2}}</span>, so that the probability that <span class="math">b=1</span> in the latter game is negligibly close to <span class="math">\\Pr[S_{0}]</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Game 1.</h6>

    <p class="text-gray-300">[This is a transition based on indistinguishability.] We now modify Game 0 so that we use a truly random function from <span class="math">\\ell_{1}</span> bits to <span class="math">\\ell_{2}</span> bits, in place of <span class="math">F_{s}</span>. Intuitively, the pseudo-randomness property of <span class="math">\\mathcal{F}</span> should guarantee that this modification has only a negligible effect on the behavior of the adversary. Algorithmically, Game 1 looks like this:</p>

    <p class="text-gray-300"><span class="math">k\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}K,\\boxed{f\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}\\Gamma_{\\ell_{1},\\ell_{2}}}</span> <span class="math">r\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">w_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">x_{i}\\leftarrow H_{k}(w_{i})\\in\\{0,1\\}^{\\ell_{1}}</span> <span class="math">\\boxed{y_{i}\\leftarrow f(x_{i})\\in\\{0,1\\}^{\\ell_{2}}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">We claim that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\rm prf},$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\epsilon_{\\rm prf}</span> is the PDF-advantage, relative to <span class="math">\\mathcal{F}</span>, of some efficient adversary (which is negligible assuming <span class="math">\\mathcal{F}</span> is pseudo-random). Indeed, the following adversary essentially “interpolates” between Games 0 and 1, and so has PRF-advantage, with respect to <span class="math">\\mathcal{F}</span>, exactly equal to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Oracle machine <span class="math">D^{\\mathcal{O}}</span></p>

    <p class="text-gray-300"><span class="math">k\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}K</span>, <span class="math">r\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">w_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">x_{i}\\leftarrow H_{k}(w_{i})\\in\\{0,1\\}^{\\ell_{1}}</span> <span class="math">y_{i}\\leftarrow\\mathcal{O}(x_{i})\\in\\{0,1\\}^{\\ell_{2}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Game 2.</h6>

    <p class="text-gray-300">[This transition is a bridging step.] We now make a purely conceptual change to Game 1. Intuitively, one can think of a black box containing the random function <span class="math">f</span> as a box with a little “gnome” inside: the gnome keeps a table of previous input/output pairs, and if a query is made that matches one of the previous inputs, the corresponding output is returned, and otherwise, an output value is chosen at random, and a new input/output pair is added to the table (see Figure 1). Based on this, we get the following equivalent formulation of Game 1:</p>

    <p class="text-gray-300"><span class="math">k\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}K,\\boxed{Y_{1},\\ldots,Y_{q}\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}\\{0,1\\}^{\\ell_{2}}}</span> <span class="math">r\\stackrel{{\\scriptstyle\\updownarrow}}{{&lt;}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">w_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">x_{i}\\leftarrow H_{k}(w_{i})\\in\\{0,1\\}^{\\ell_{1}}</span> <span class="math">\\boxed{\\text{if }x_{i}=x_{j}\\text{ for some }j&lt;i\\text{ then }y_{i}\\leftarrow y_{j}\\text{ else }y_{i}\\leftarrow Y_{i}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event that <span class="math">b=1</span> in Game 2. Since the change in going from Game 1 to Game 2 was purely conceptual, we clearly have</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{2}]=\\Pr[S_{1}].</span> (5)</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A gnome implementation of a random function</p>

    <p class="text-gray-300">Game 3. [This is a transition based on a failure event.] We now modify Game 2 so that our gnome is "forgetful," and does not perform any consistency checks in calculating the  <span class="math">y_{i}</span>  values:</p>

    <p class="text-gray-300"><span class="math">k\\stackrel {\\xi}{\\leftarrow}K,Y_1,\\ldots ,Y_q\\stackrel {\\xi}{\\leftarrow}\\{0,1\\}^{\\ell_2}</span></p>

    <p class="text-gray-300"><span class="math">r\\stackrel {\\iota}{\\leftarrow}R</span></p>

    <p class="text-gray-300">for  <span class="math">i\\gets 1\\dots q</span>  do</p>

    <p class="text-gray-300"><span class="math">w_{i}\\gets A(r,y_{1},\\ldots ,y_{i - 1})\\in \\{0,1\\}^{\\ell}</span></p>

    <p class="text-gray-300"><span class="math">x_{i}\\gets H_{k}(w_{i})\\in \\{0,1\\}^{\\ell_{1}}</span></p>

    <p class="text-gray-300"><span class="math">y_{i}\\gets Y_{i}</span></p>

    <p class="text-gray-300"><span class="math">b\\gets A(r,y_1,\\ldots ,y_q)\\in \\{0,1\\}</span></p>

    <p class="text-gray-300">output  <span class="math">b</span></p>

    <p class="text-gray-300">Define  <span class="math">S_{3}</span>  to be the event that  <span class="math">b = 1</span>  in Game 3. Define  <span class="math">F</span>  to be the event that in Game 3,  <span class="math">x_{i} = x_{j}</span>  for some  <span class="math">i,j</span>  with  <span class="math">i \\neq j</span> .</p>

    <p class="text-gray-300">Observe that  <span class="math">k</span>  and  <span class="math">x_{1},\\ldots ,x_{q}</span>  play no role in Game 3, other than to define the event  <span class="math">F</span> . In particular, the random variables  <span class="math">k,r,y_{1},\\ldots ,y_{q}</span>  are mutually independent.</p>

    <p class="text-gray-300">We view Games 2 and 3 as operating on the same underlying probability space, so that the values of  <span class="math">k, r, Y_1, \\ldots, Y_q</span>  are identical in both games. It is not hard to see that Games 2 and 3 proceed identically, unless event  <span class="math">F</span>  occurs. In particular, if  <span class="math">F</span>  does not occur, then the output in both games is identical. This is fairly obvious, but since this is our first example of this technique, let us make a more formal argument (in later examples, we will not do this). Select any fixed values  <span class="math">k, r, Y_1, \\ldots, Y_q</span>  such that  <span class="math">F</span>  does not occur. We prove by induction on  <span class="math">i = 0, \\ldots, q</span> , the values  <span class="math">w_1, x_1, y_1, \\ldots, w_i, x_i, y_i</span>  are computed identically in both games. The case  <span class="math">i = 0</span>  is trivially true. Now we let  <span class="math">i &amp;gt; 0</span> , assume the claim for  <span class="math">i - 1</span> , and prove it for  <span class="math">i</span> . As the claim holds for  <span class="math">i - 1</span> , the value  <span class="math">w_i</span>  is computed in the same way as  <span class="math">A(r, y_1, \\ldots, y_{i-1})</span>  in both games, and hence  <span class="math">x_i</span>  is computed in the same way as  <span class="math">H_k(w_i)</span>  in both games. When it comes to computing  <span class="math">y_i</span> , we see that since  <span class="math">F</span>  does not hold, the values  <span class="math">x_1, \\ldots, x_i</span>  are distinct (and are computed in the same way in both games); therefore,</p>

    <p class="text-gray-300">both games <span class="math">y_{i}</span> is assigned the value <span class="math">Y_{i}</span>. That completes the induction proof. It follows that when <span class="math">F</span> does not occur, both games compute <span class="math">y_{1},\\ldots,y_{q}</span> in the same way, and hence both compute <span class="math">b=A(r,y_{1},\\ldots,y_{q})</span> in the same way.</p>

    <p class="text-gray-300">In the previous paragraph, we argued that if <span class="math">F</span> does not occur, then both games output the same value. This is the same as saying that <span class="math">S_{2}\\wedge\\neg F\\iff S_{3}\\wedge\\neg F</span>. Therefore, by the Difference Lemma, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{2}]-\\Pr[S_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F].$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F]\\leq\\epsilon_{\\text{uh}}\\cdot\\frac{q^{2}}{2}.</span> (7)</p>

    <p class="text-gray-300">The analysis is all done with respect to Game 3. To prove this inequality, it suffices to prove it conditioned on any fixed values of <span class="math">r,y_{1},\\ldots,y_{q}</span>. In this conditional probability distribution, the values <span class="math">w_{1},\\ldots,w_{q}</span> are fixed (as they are determined by <span class="math">r,y_{1},\\ldots,y_{q}</span>), while <span class="math">k</span> is uniformly distributed over <span class="math">K</span> (by independence). For any fixed pair of indices <span class="math">i,j</span>, with <span class="math">i\\neq j</span>, by the universal hash property of <span class="math">\\mathcal{H}</span>, and by our assumption that the adversary never repeats any queries, we have <span class="math">w_{i}\\neq w_{j}</span>, and hence</p>

    <p class="text-gray-300"><span class="math">\\Pr[H_{k}(w_{i})=H_{k}(w_{j})]\\leq\\epsilon_{\\text{uh}}.</span></p>

    <p class="text-gray-300">Since there are <span class="math">q(q-1)/2</span> such pairs of indices, the inequality (7) follows from the union bound.</p>

    <p class="text-gray-300">Note that while one could have carried out the above analysis with respect to Game 2, it is conceptually much easier to carry it out in Game 3. In general, in applying the Difference Lemma, one can choose to analyze the probability of the “failure event” in either of the two adjacent games, but one will usually be easier to work with than the other.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the values of <span class="math">k</span> and <span class="math">x_{1},\\ldots,x_{q}</span> play no role in Game 3, it is not hard to see that in fact, Game 3 is equivalent to the computation of the adversary given oracle access to a function drawn at random from <span class="math">\\Gamma_{\\ell,\\ell_{2}}</span>: each successive (and by assumption, distinct) query yields a random result. Thus, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is equal to the PRF-advantage of the adversary. It then follows from (4), (5), (6), and (7) that the PRF-advantage of the adversary is bounded by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\text{prf}}+\\epsilon_{\\text{uh}}\\cdot\\frac{q^{2}}{2},</span></p>

    <p class="text-gray-300">which is negligible.</p>

    <h2 id="sec-17" class="text-2xl font-bold">5 Pseudo-Random Permutations</h2>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be a positive integer. Let <span class="math">\\mathcal{P}:=\\{P_{s}\\}_{s\\in S}</span> be a family of keyed functions, where each <span class="math">P_{s}</span> is a <em>permutation</em> on <span class="math">\\{0,1\\}^{\\ell}</span>. Let <span class="math">\\Pi_{\\ell}</span> denote the set of all permutations on <span class="math">\\{0,1\\}^{\\ell}</span>. Informally, we say that <span class="math">\\mathcal{P}</span> is pseudo-random if it is hard to distinguish a random permutation drawn from <span class="math">\\mathcal{P}</span> from a random permutation drawn from <span class="math">\\Pi_{\\ell}</span>, given black box access to such a permutation.</p>

    <p class="text-gray-300">More formally, consider an adversary <span class="math">A</span> that has oracle access to a function in <span class="math">\\Gamma_{\\ell,\\ell}</span>, and suppose that <span class="math">A</span> always outputs a single bit. Define the <em>PRP-advantage</em> of <span class="math">A</span> to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[s\\xleftarrow{i}S:A^{P_{s}}()=1]-\\Pr[\\pi\\xleftarrow{i}\\Pi_{\\ell}:A^{\\pi}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathcal{P}</span> is <em>pseudo-random</em> if any efficient oracle machine’s PRP-advantage is negligible.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.1 Random Functions vs. Random Permutations</h3>

    <p class="text-gray-300">One of the things we want to do is to present a proof that every pseudo-random permutation family is also a pseudo-random function family. But first, we consider the slightly simpler problem of distinguishing random functions from random permutations. Suppose you are given a black box that contains either a random function on <span class="math">\\ell</span> bits or a random permutation on <span class="math">\\ell</span> bits, and your task is to determine which is the case. If you make roughly <span class="math">2^{\\ell/2}</span> queries, then (by the birthday paradox) you would expect to see some outputs that are equal, if the box contains a function rather than a permutation. This would allow you to determine, with reasonably high probability, the contents of the box. We want to rigorously prove that there is really no better way to determine what is inside the box.</p>

    <p class="text-gray-300">Again, let <span class="math">A</span> be an adversary given oracle access to a function in <span class="math">\\Gamma_{\\ell,\\ell}</span>. We define its RF/RP-advantage to be</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[f\\stackrel{{\\scriptstyle\\scriptstyle\\ell}}{{\\leftarrow}}\\Gamma_{\\ell,\\ell}:A^{f}()=1]-\\Pr[\\pi\\stackrel{{\\scriptstyle\\scriptstyle\\ell}}{{\\leftarrow}}\\Pi_{\\ell}:A^{\\pi}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We shall now show that for any oracle machine that makes at most <span class="math">q</span> queries to its oracle, its RF/RP-advantage is at most</p>

    <p class="text-gray-300"><span class="math">\\frac{q^{2}}{2}\\cdot 2^{-\\ell}.</span></p>

    <p class="text-gray-300">As usual, we make this argument by considering a sequence of games.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Game 0.</h6>

    <p class="text-gray-300">This game represents the computation of an adversary <span class="math">A</span> given oracle access to a random permutation. Let us assume that <span class="math">A</span> makes precisely <span class="math">q</span> queries, and that each of these queries is distinct. We may write this game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">\\pi\\stackrel{{\\scriptstyle\\scriptstyle i}}{{\\leftarrow}}\\Pi_{\\ell}</span> <span class="math">r\\stackrel{{\\scriptstyle\\scriptstyle i}}{{\\leftarrow}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">x_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">y_{i}\\leftarrow\\pi(x_{i})</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">As usual, we assume that the queries <span class="math">x_{1},\\ldots,x_{q}</span> are always distinct. Define <span class="math">S_{0}</span> to be the event that <span class="math">b=1</span> in Game 0.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Game 1.</h6>

    <p class="text-gray-300">[This transition is a bridging step.] We now transform Game 1 into a new game involving “gnomes,” as in §4.2. Our strategy is to first build a game that uses a “faithful gnome” that makes all the appropriate consistency checks. In the next game, we will use a “forgetful gnome” that does not bother with consistency checks, but that otherwise behaves identically. The idea is that we can model oracle access to a random permutation as a little “gnome” who keeps track input/output pairs, but now, the gnome has to make sure outputs as well as inputs are consistent:</p>

    <p class="text-gray-300"><span class="math">Y_{1},\\ldots,Y_{q}\\xleftarrow{i}\\{0,1\\}^{\\ell}</span> <span class="math">r\\xleftarrow{i}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">x_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">\\boxed{\\text{if }Y_{i}\\in\\{y_{1},\\ldots,y_{i-1}\\}\\text{ then }y_{i}\\xleftarrow{i}\\{0,1\\}^{\\ell}\\setminus\\{y_{1},\\ldots,y_{i-1}\\}\\text{ else }y_{i}\\leftarrow Y_{i}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">Recall that we are assuming that the inputs <span class="math">x_{1},\\ldots,x_{q}</span> are always distinct, so our “gnome” does not have to watch for duplicate inputs. Our “gnome” uses the random value <span class="math">Y_{i}</span> as the “default value” for <span class="math">\\pi(x_{i})</span>, unless that value has already been used as a previous output, in which case the “gnome” chooses the value of <span class="math">\\pi(x_{i})</span> at random from all unused output values.</p>

    <p class="text-gray-300">Let <span class="math">S_{1}</span> be the event that <span class="math">b=1</span> in Game 1. It is evident that Game 1 is equivalent to Game 0 from the point of view of the adversary, and therefore:</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{1}]=\\Pr[S_{0}].</span> (8)</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Game 2.</h6>

    <p class="text-gray-300">[This is a transition based on a failure event.] As promised, we now make our gnome “forgetful,” by simply dropping the output consistency checks:</p>

    <p class="text-gray-300"><span class="math">Y_{1},\\ldots,Y_{q}\\xleftarrow{i}\\{0,1\\}^{\\ell}</span> <span class="math">r\\xleftarrow{i}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">x_{i}\\leftarrow A(r,y_{1},\\ldots,y_{i-1})\\in\\{0,1\\}^{\\ell}</span> <span class="math">\\boxed{y_{i}\\leftarrow Y_{i}}</span> <span class="math">b\\leftarrow A(r,y_{1},\\ldots,y_{q})\\in\\{0,1\\}</span> output <span class="math">b</span></p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event that <span class="math">b=1</span> in Game 2. Let <span class="math">F</span> be the event that <span class="math">Y_{i}=Y_{j}</span> for some <span class="math">i\\neq j</span>. Let us view Games 1 and 2 as operating on the same underlying probability space, so the values of <span class="math">r,Y_{1},\\ldots,Y_{q}</span> are identical in both games. It is evident that these two games proceed identically unless the event <span class="math">F</span> occurs; that is, <span class="math">S_{1}\\wedge\\neg F\\iff S_{2}\\wedge\\neg F</span>. Therefore, by the Difference Lemma, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F].$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, <span class="math">F</span> is the union of <span class="math">\\binom{q}{2}</span> events, each of which occurs with probability <span class="math">2^{-\\ell}</span> (clearly, <span class="math">\\Pr[Y_{i}=Y_{j}]=2^{-\\ell}</span>, for <span class="math">i\\neq j</span>), and so by the union bound, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F]\\leq\\frac{q^{2}}{2}\\cdot 2^{-\\ell}.</span> (10)</p>

    <p class="text-gray-300">Finally, note that Game 2 is fully equivalent to the computation of the adversary given oracle access to a random function. Thus, its RF/RP-advantage is equal to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and by (8), (9), and (10), this is at most</p>

    <p class="text-gray-300"><span class="math">\\frac{q^{2}}{2}\\cdot 2^{-\\ell}.</span></p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.2 Pseudo-Random Functions vs. Pseudo-Random Permutations</h3>

    <p class="text-gray-300">We now show that if <span class="math">\\ell</span> is suitably large, so that <span class="math">2^{-\\ell}</span> is negligible, then any pseudo-random permutation family <span class="math">\\mathcal{P}:=\\{P_{s}\\}_{s\\in S}</span> is also a pseudo-random <em>function</em> family. This follows quite easily from the definitions and the fact proved in §5.1 bounding the RF/RP-advantage of any adversary.</p>

    <p class="text-gray-300">Let us fix an efficient adversary <span class="math">A</span>, and show that its PRF-advantage, with respect to <span class="math">\\mathcal{P}</span>, is negligible. Assume that the oracle machine always makes at most <span class="math">q</span> queries (since the adversary is efficient, this means that <span class="math">q</span> is bounded by a polynomial in a security parameter).</p>

    <p class="text-gray-300">Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\text{prf}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[s\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}S:A^{P_{s}}()=1]-\\Pr[f\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}}{{\\leftarrow}}\\Gamma_{\\ell,\\ell}:A^{f}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">be the PRF-advantage of <span class="math">A</span>. We want to show that <span class="math">\\epsilon_{\\text{prf}}</span> is negligible. Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\text{prp}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[s\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}S:A^{P_{s}}()=1]-\\Pr[\\pi\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Pi_{\\ell}:A^{\\pi}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">be the PRP-advantage of <span class="math">A</span>. By assumption, <span class="math">\\epsilon_{\\text{prp}}</span> is negligible. Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\text{rf/rp}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[f\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Gamma_{\\ell,\\ell}:A^{f}()=1]-\\Pr[\\pi\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Pi_{\\ell}:A^{\\pi}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">be the RF/RP-advantage of <span class="math">A</span>. From the analysis in §5.1, we know that</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\text{rf/rp}}\\leq\\frac{q^{2}}{2}\\cdot 2^{-\\ell},</span></p>

    <p class="text-gray-300">which is negligible, assuming <span class="math">2^{-\\ell}</span> is negligible. Finally, it is easy to see that by the triangle inequality, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\epsilon_{\\text{prf}}</span> $=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[s\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}S:A^{P_{s}}()=1]-\\Pr[f\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Gamma_{\\ell,\\text{\\emph{ell}}}:A^{f}()=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr[\\pi\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Pi_{\\ell}:A^{\\pi}()=1]-\\Pr[f\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle\\epsilon}}{{\\leftarrow}}\\Gamma_{\\ell,\\ell}:A^{f}()=1]</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\epsilon_{\\text{prp}}+\\epsilon_{\\text{rf/rp}},</span></p>

    <p class="text-gray-300">which is negligible.</p>

    <h2 id="sec-23" class="text-2xl font-bold">6 The Luby-Rackoff Construction</h2>

    <p class="text-gray-300">We now give an analysis of the Luby-Rackoff construction for building a pseudo-random permutation family out of a pseudo-random function family <em>[x10]</em>. Since it is really no harder to do, we analyze the variation of Naor and Reingold <em>[x13]</em>, which uses a pairwise independent family of hash functions (or something slightly weaker) at one of the stages of the construction.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}:=\\{F_{s}\\}_{s\\in S}</span> be a pseudo-random family of functions, where each <span class="math">F_{s}</span> maps <span class="math">\\ell</span>-bit strings to <span class="math">\\ell</span>-bit strings.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}:=\\{H_{k}\\}_{k\\in K}</span> an <span class="math">\\epsilon_{axu}</span>-almost-XOR-universal family of hash functions on <span class="math">\\ell</span>-bits, meaning that each <span class="math">H_{k}</span> maps <span class="math">\\ell</span>-bit strings to <span class="math">\\ell</span>-bit strings, and for all <span class="math">x,x^{\\prime},y\\in\\{0,1\\}^{\\ell}</span>, with <span class="math">x\\neq x^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[k\\stackrel{{\\scriptstyle\\iota}}{{\\leftarrow}}K:H_{k}(x)\\oplus H_{k}(x^{\\prime})=y]\\leq\\epsilon_{\\text{axu}}.</span></p>

    <p class="text-gray-300">We assume that <span class="math">\\epsilon_{\\text{axu}}</span> is negligible.</p>

    <p class="text-gray-300">The Luby-Rackoff construction builds a pseudo-random permutation family that acts on <span class="math">2\\ell</span>-bit strings as follows. A Luby-Rackoff key consists of a triple <span class="math">(k,s_{1},s_{2})</span>, with <span class="math">k\\in K</span> and <span class="math">s_{1},s_{2}\\in S</span>. Let us interpret inputs and outputs as pairs of <span class="math">\\ell</span>-bit strings. Given <span class="math">u,v\\in\\{0,1\\}^{\\ell}</span> as input, the Luby-Rackoff algorithm runs as follows:</p>

    <p class="text-gray-300"><span class="math">w</span> <span class="math">\\leftarrow u\\oplus H_{k}(v)</span> <span class="math">x</span> <span class="math">\\leftarrow v\\oplus F_{s_{1}}(w)</span> <span class="math">y</span> <span class="math">\\leftarrow w\\oplus F_{s_{2}}(x)</span></p>

    <p class="text-gray-300">The output is <span class="math">x,y</span>.</p>

    <p class="text-gray-300">It is easy to verify that the function computed by this algorithm is a permutation, and indeed, it is easy to invert the permutation given the key. We want to show that this construction is a pseudo-random permutation family, under the assumptions above, and the assumption that <span class="math">2^{-\\ell}</span> is negligible. To this end, by the result in §5.1, it will suffice to show that this construction is a pseudo-random function family.</p>

    <p class="text-gray-300">Game 0. This game represents the computation of an adversary given oracle access to the Luby-Rackoff construction, for random keys <span class="math">k,s_{1},s_{2}</span>. We assume that the adversary makes exactly <span class="math">q</span> oracle queries, and that all of these are distinct. We can present this game algorithmically as follows:</p>

    <p class="text-gray-300"><span class="math">k\\stackrel{{\\scriptstyle\\iota}}{{\\leftarrow}}K</span>, <span class="math">s_{1}\\stackrel{{\\scriptstyle\\iota}}{{\\leftarrow}}S</span>, <span class="math">s_{2}\\stackrel{{\\scriptstyle\\iota}}{{\\leftarrow}}S</span> <span class="math">r\\stackrel{{\\scriptstyle\\iota}}{{\\leftarrow}}R</span> for <span class="math">i\\leftarrow 1\\ldots q</span> do <span class="math">(u_{i},v_{i})\\leftarrow A(r,x_{1},y_{1},\\ldots,x_{i-1},y_{i-1})</span> <span class="math">w_{i}\\leftarrow u_{i}\\oplus H_{k}(v_{i})</span> <span class="math">x_{i}\\leftarrow v_{i}\\oplus F_{s_{1}}(w_{i})</span> <span class="math">y_{i}\\leftarrow w_{i}\\oplus F_{s_{2}}(x_{i})</span> <span class="math">b\\leftarrow A(r,x_{1},y_{1},\\ldots,x_{q},y_{q})</span> output <span class="math">b</span></p>

    <p class="text-gray-300">We are assuming that for all <span class="math">i\\neq j</span>, we may have <span class="math">u_{i}=u_{j}</span> or <span class="math">v_{i}=v_{j}</span>, but not both. Let <span class="math">S_{0}</span> be the event that <span class="math">b=1</span> in Game 0.</p>

    <p class="text-gray-300">Game 1. [This is a transition based on indistinguishability, plus a bridging step.] We now modify Game 0, replacing <span class="math">F_{s_{1}}</span> be a truly random function. To save steps, let us implement our random function directly as a “faithful gnome”:</p>

    <p class="text-gray-300"><span class="math">k \\stackrel{\\iota}{\\leftarrow} K, \\boxed{X_1, \\ldots, X_q \\leftarrow \\{0, 1\\}^\\ell}, s_2 \\stackrel{\\iota}{\\leftarrow} S</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\iota}{\\leftarrow} R</span></p>

    <p class="text-gray-300">for <span class="math">i \\leftarrow 1 \\ldots q</span> do</p>

    <p class="text-gray-300"><span class="math">(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\ldots, x_{i-1}, y_{i-1})</span></p>

    <p class="text-gray-300"><span class="math">w_i \\leftarrow u_i \\oplus H_k(v_i)</span></p>

    <p class="text-gray-300"><span class="math">\\boxed{\\{ \\text{if } w_i = w_j \\text{ for some } j &amp;lt; i \\text{ then } x_i&#x27; \\leftarrow x_j&#x27; \\text{ else } x_i&#x27; \\leftarrow X_i \\}, x_i \\leftarrow v_i \\oplus x_i&#x27;}</span></p>

    <p class="text-gray-300"><span class="math">y_i \\leftarrow w_i \\oplus F_{s_2}(x_i)</span></p>

    <p class="text-gray-300"><span class="math">b \\leftarrow A(r, x_1, y_1, \\ldots, x_q, y_q)</span></p>

    <p class="text-gray-300">output <span class="math">b</span></p>

    <p class="text-gray-300">The intuition is that <span class="math">x_i&#x27;</span> represents the output of a random function on input <span class="math">w_i</span>. The default value for <span class="math">x_i&#x27;</span> is <span class="math">X_i</span>, but this default value is overridden if <span class="math">w_i</span> is equal to some previous input <span class="math">w_j</span>.</p>

    <p class="text-gray-300">Let <span class="math">S_1</span> be the event that <span class="math">b = 1</span> in Game 1. By a (by now) very familiar argument, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S_0 \\right] - \\Pr \\left[ S_1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\epsilon_{\\mathrm{prf}}, \\tag{11}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{prf}}</span> is the PRF-advantage of some efficient adversary, and therefore negligible. Indeed, it is evident that the following adversary <span class="math">D</span> does the job:</p>

    <p class="text-gray-300">Oracle machine <span class="math">D^{\\mathcal{O}}</span></p>

    <p class="text-gray-300"><span class="math">k \\stackrel{\\iota}{\\leftarrow} K, s_2 \\stackrel{\\iota}{\\leftarrow} S</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\iota}{\\leftarrow} R</span></p>

    <p class="text-gray-300">for <span class="math">i \\leftarrow 1 \\ldots q</span> do</p>

    <p class="text-gray-300"><span class="math">(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\ldots, x_{i-1}, y_{i-1})</span></p>

    <p class="text-gray-300"><span class="math">w_i \\leftarrow u_i \\oplus H_k(v_i)</span></p>

    <p class="text-gray-300"><span class="math">x_i \\leftarrow v_i \\oplus \\mathcal{O}(w_i)</span></p>

    <p class="text-gray-300"><span class="math">y_i \\leftarrow w_i \\oplus F_{s_2}(x_i)</span></p>

    <p class="text-gray-300"><span class="math">b \\leftarrow A(r, x_1, y_1, \\ldots, x_q, y_q)</span></p>

    <p class="text-gray-300">output <span class="math">b</span></p>

    <p class="text-gray-300"><strong>Game 2.</strong> [This is also a transition based on indistinguishability, plus a bridging step.] Next, we naturally replace <span class="math">F_{s_2}</span> by a truly random function. Again, let us implement our random function directly as a “faithful gnome”:</p>

    <p class="text-gray-300"><span class="math">k \\stackrel{\\iota}{\\leftarrow} K, X_1, \\ldots, X_q \\leftarrow \\{0, 1\\}^\\ell, \\boxed{Y_1, \\ldots, Y_q \\stackrel{\\iota}{\\leftarrow} \\{0, 1\\}^\\ell}</span></p>

    <p class="text-gray-300"><span class="math">r \\stackrel{\\iota}{\\leftarrow} R</span></p>

    <p class="text-gray-300">for <span class="math">i \\leftarrow 1 \\ldots q</span> do</p>

    <p class="text-gray-300"><span class="math">(u_i, v_i) \\leftarrow A(r, x_1, y_1, \\ldots, x_{i-1}, y_{i-1})</span></p>

    <p class="text-gray-300"><span class="math">w_i \\leftarrow u_i \\oplus H_k(v_i)</span></p>

    <p class="text-gray-300"><span class="math">\\{ \\text{if } w_i = w_j \\text{ for some } j &amp;lt; i \\text{ then } x_i&#x27; \\leftarrow x_j&#x27; \\text{ else } x_i&#x27; \\leftarrow X_i \\}, x_i \\leftarrow v_i \\oplus x_i&#x27;</span></p>

    <p class="text-gray-300"><span class="math">\\boxed{\\{ \\text{if } x_i = x_j \\text{ for some } j &amp;lt; i \\text{ then } y_i&#x27; \\leftarrow y_j&#x27; \\text{ else } y_i&#x27; \\leftarrow Y_i \\}, y_i \\leftarrow w_i \\oplus y_i&#x27;}</span></p>

    <p class="text-gray-300"><span class="math">b \\leftarrow A(r, x_1, y_1, \\ldots, x_q, y_q)</span></p>

    <p class="text-gray-300">output <span class="math">b</span></p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event that <span class="math">b=1</span> in Game 2. Again, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\mathrm{prf}}^{\\prime},$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{prf}}^{\\prime}</span> is the PRF-advantage of some efficient adversary, and therefore negligible. Indeed, it is evident that the following adversary <span class="math">D^{\\prime}</span> does the job:</p>

    <p class="text-gray-300">Oracle machine <span class="math">(D^{\\prime})^{\\mathcal{O}}</span></p>

    <p class="text-gray-300">$k\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</p>

    <p class="text-gray-300">Let <span class="math">S_{3}</span> be the event that <span class="math">b=1</span> in Game 3.</p>

    <p class="text-gray-300">Claim. In Game 3, the random variables <span class="math">k,r,x_{1},y_{1},\\ldots,x_{q},y_{q}</span> are mutually independent. Observe that <span class="math">k</span> and <span class="math">r</span> are independent by construction. Now condition on any fixed values of <span class="math">k</span> and <span class="math">r</span>. The first query <span class="math">(u_{1},v_{1})</span> is now fixed, and hence so is <span class="math">w_{1}</span>; however, <span class="math">X_{1}</span> and <span class="math">Y_{1}</span> are both easily seen to still be uniformly and independently distributed in this conditional probability distribution, and so <span class="math">x_{1}</span> and <span class="math">y_{1}</span> are also uniformly and independently distributed. One continues the argument, conditioning on fixed values of <span class="math">x_{1},y_{1}</span>, observing that now <span class="math">u_{2},v_{2}</span>, and <span class="math">w_{2}</span> are also fixed, and that <span class="math">x_{2}</span> and <span class="math">y_{2}</span> are uniformly and independently distributed. The claim should now be clear.</p>

    <p class="text-gray-300">Let <span class="math">F_{1}</span> be the event that <span class="math">w_{i}=w_{j}</span> for some <span class="math">i\\neq j</span> in Game 3. Let <span class="math">F_{2}</span> be the event that <span class="math">x_{i}=x_{j}</span> for some <span class="math">i\\neq j</span> in Game 3. Let <span class="math">F:=F_{1}\\vee F_{2}</span>. Games 2 and 3 proceed identically so long as <span class="math">F</span> does not occur, and so by the Difference Lemma (and the union bound), we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{2}]-\\Pr[S_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F]\\leq\\Pr[F_{1}]+\\Pr[F_{2}].$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the fact that <span class="math">x_{1},\\ldots,x_{q}</span> are mutually independent (see claim), it is obvious that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{2}]\\leq\\frac{q^{2}}{2}\\cdot 2^{-\\ell}.</span> (14)</p>

    <p class="text-gray-300">Let us now analyze the event <span class="math">F_{1}</span>. We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{1}]\\leq\\frac{q^{2}}{2}\\cdot\\epsilon_{\\rm axu}.</span> (15)</p>

    <p class="text-gray-300">To prove this, it suffices to prove it conditioned on any fixed values of <span class="math">r,x_{1},y_{1},\\ldots,x_{q},y_{q}</span>. If these values are fixed, then so are <span class="math">u_{1},v_{1},\\ldots,u_{q},v_{q}</span>. However, by independence (see claim), the variable <span class="math">k</span> is still uniformly distributed over <span class="math">K</span>. Now consider any fixed pair of indices <span class="math">i,j</span>, with <span class="math">i\\neq j</span>. Suppose first that <span class="math">v_{i}=v_{j}</span>. Then by assumption, we must have <span class="math">u_{i}\\neq u_{j}</span>, and it is easy to see that <span class="math">w_{i}\\neq w_{j}</span> for all <span class="math">k</span>. Next suppose that <span class="math">v_{i}\\neq v_{j}</span>. Then by the almost-XOR-universal property for <span class="math">\\mathcal{H}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[H_{k}(v_{i})\\oplus H_{k}(v_{j})=u_{i}\\oplus u_{j}]\\leq\\epsilon_{\\rm axu}.</span></p>

    <p class="text-gray-300">Thus, we have shown that for all pairs <span class="math">i,j</span> with <span class="math">i\\neq j</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[w_{i}=w_{j}]\\leq\\epsilon_{\\rm axu}.</span></p>

    <p class="text-gray-300">The inequality (15) follows from the union bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As another consequence of the claim, we observe that Game 3 represents the computation of the adversary given oracle access to a random function. Thus, the adversary’s PRF-advantage is equal to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. From this, and (11), (12), (13), (14), and (15), we conclude that the PRF-advantage of our adversary is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\rm prf}+\\epsilon_{\\rm prf}^{\\prime}+\\frac{q^{2}}{2}(\\epsilon_{\\rm axu}+2^{-\\ell}),</span></p>

    <p class="text-gray-300">which is negligible.</p>

    <p class="text-gray-300">That concludes the proof, but we make one remark about the proof “strategy.” One might have been tempted to take smaller steps: making the first gnome forgetful in one step, and making the second gnome forgetful in the second step. However, this would not be convenient. If we make only the first gnome forgetful, the resulting game is not “nice enough” to allow one to easily establish a bound on the “failure probability.” It is better to make both gnomes forgetful at once, thus getting a very nice game in which it is easy to analyze both “failure probabilities.” In general, finding a good strategy for how to modify games, and the order in which to modify them, etc., is a bit of a “black art.”</p>

    <h2 id="sec-24" class="text-2xl font-bold">7 Chosen Ciphertext Secure Symmetric Encryption</h2>

    <p class="text-gray-300">In this section and the next, we now present some more elaborate examples. This section studies a chosen ciphertext secure symmetric-key encryption scheme.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">7.1 Basic Definitions</h3>

    <p class="text-gray-300">A symmetric-key encryption scheme is a triple of probabilistic algorithms <span class="math">(KeyGen,E,D)</span>. The key generation algorithm <span class="math">KeyGen</span> takes no input (other than an implied security parameter, and perhaps other system parameters), and outputs a key <span class="math">k</span>. The encryption algorithm <span class="math">E</span> takes as input a key <span class="math">k</span> and a message <span class="math">m</span>, selected from a message space <span class="math">M</span>, and outputs a ciphertext <span class="math">\\psi</span>. The decryption algorithm takes as input a key <span class="math">k</span> and a ciphertext <span class="math">\\psi</span>, and outputs a message <span class="math">m</span>.</p>

    <p class="text-gray-300">As for any encryption scheme, the basic correctness requirement is that decryption “undoes” encryption. That is, for all <span class="math">m\\in M</span>, all <span class="math">k\\in[KeyGen()]</span>, all <span class="math">\\psi\\in[E(k,m)]</span>, and all <span class="math">m^{\\prime}\\in[D(k,\\psi)]</span>, we have <span class="math">m=m^{\\prime}</span>.</p>

    <p class="text-gray-300">The notion of chosen ciphertext security is defined via a game between an adversary and a challenger:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger computes <span class="math">k\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}KeyGen()</span>, and <span class="math">b\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}\\{0,1\\}</span>.</li>

      <li>The adversary makes a sequence of queries to the challenger. Each query is of one of two types:</li>

    </ul>

    <p class="text-gray-300">The adversary submits two messages <span class="math">m_{0},m_{1}\\in M</span> to the challenger. The challenger sends back <span class="math">\\psi\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}E(k,m_{b})</span> to the adversary. The adversary submits <span class="math">\\psi^{\\prime}</span> to the challenger, subject to the restriction that <span class="math">\\psi^{\\prime}</span> is not equal to the ciphertext output by any previous encryption query. The challenger sends back <span class="math">m^{\\prime}\\stackrel{{\\scriptstyle\\downarrow}}{{\\leftarrow}}D(k,\\psi^{\\prime})</span> to the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adversary outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define the <em>CCA-advantage</em> of the adversary to be $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[b=\\hat{b}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. <em>Chosen ciphertext security</em> means that any efficient adversary’s CCA-advantage is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.2 A Simple Construction</p>

    <p class="text-gray-300">We can easily build a chosen-ciphertext secure symmetric encryption scheme out of two components.</p>

    <p class="text-gray-300">The first component is a pseudo-random family of functions <span class="math">\\mathcal{F}:=\\{F_{s}\\}_{s\\in S}</span>, where each <span class="math">F_{s}</span> maps <span class="math">n</span>-bit strings to <span class="math">\\ell</span>-bit strings. It is assumed that <span class="math">2^{-n}</span> is negligible. Also, the message space for the encryption scheme will be <span class="math">\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">The second component is a “message authentication code,” which we shall define as an unpredictable function family <span class="math">\\mathcal{H}:=\\{H_{k}\\}_{k\\in K}</span>, where each <span class="math">H_{k}</span> is a function mapping <span class="math">(n+\\ell)</span>-bit strings to <span class="math">w</span>-bit strings. The property for <span class="math">H</span> we are assuming is defined in terms of a game between an adversary and a challenger:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger selects <span class="math">k\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle 4}}{{\\leftarrow}}}K</span>.</li>

      <li>The adversary makes a sequence of queries to the challenger. Each query is a string <span class="math">y\\in\\{0,1\\}^{n+\\ell}</span>. The challenger gives the adversary <span class="math">t\\leftarrow H_{k}(y)</span>.</li>

      <li>The adversary outputs a pair <span class="math">(y^{<em>},t^{</em>})</span>.</li>

    </ul>

    <p class="text-gray-300">The adversary wins the above game if <span class="math">H_{k}(y^{<em>})=t^{</em>}</span> and <span class="math">y^{*}</span> is not equal to any <span class="math">y</span>-value submitted to the challenger during the game. The adversary’s UF-advantage is defined to be the probability that the adversary wins the above game. The assumption that <span class="math">\\mathcal{H}</span> is an unpredictable function family is the assumption that every efficient adversary’s UF-advantage is negligible.</p>

    <p class="text-gray-300">The encryption scheme works as follows. A key for the scheme is a pair <span class="math">(s,k)</span>, with <span class="math">s\\in S</span> and <span class="math">k\\in K</span>, each chosen at random.</p>

    <p class="text-gray-300">To encrypt a message <span class="math">m\\in\\{0,1\\}^{\\ell}</span>, the encryption algorithm computes the ciphertext <span class="math">\\psi</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$x\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle 4}}{{\\leftarrow}}\\{0,1\\}^{n},\\ c\\leftarrow F_{s}(x)\\oplus m,\\ t\\leftarrow H_{k}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ c),\\ \\psi\\leftarrow(x,c,t).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To decrypt a ciphertext <span class="math">\\psi</span>, which we may assume to be of the form <span class="math">(x,c,t)</span>, with <span class="math">x\\in\\{0,1\\}^{n},c\\in\\{0,1\\}^{\\ell},t\\in\\{0,1\\}^{w}</span>, the decryption algorithm computes <span class="math">m</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\text{if }H_{k}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ c)=t\\text{ then }m\\leftarrow F_{s}(x)\\oplus c\\text{ else }m\\leftarrow\\text{\`\`reject''}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, we may assume that “reject” is a default message encoded as an <span class="math">\\ell</span>-bit string, or we may assume that we allow the decryption algorithm to return a special value that is not in the message space (for our purposes, it does not matter).</p>

    <p class="text-gray-300">The reader may easily verify that decryption “undoes” encryption.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">7.3 Security Analysis</h3>

    <p class="text-gray-300">We now give a security proof as a sequence of games. Because it would be rather unwieldy, we do not give an explicit, low-level, algorithmic description of these games, but it should by now be clear that this could be done in principle. Rather, we give only a high-level description of Game 0, and brief descriptions of the modifications between successive games.</p>

    <p class="text-gray-300">Game 0. This is the original attack game with respect to a given efficient adversary <span class="math">A</span>. At the beginning of the game, the challenger computes</p>

    <p class="text-gray-300"><span class="math">s\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}S,\\;k\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}K,\\;b\\stackrel{{\\scriptstyle\\mathfrak{i}}}{{\\leftarrow}}\\{0,1\\}.</span></p>

    <p class="text-gray-300">We assume that <span class="math">A</span> makes exactly <span class="math">q</span> encryption queries, where for <span class="math">i=1,\\ldots,q</span>, the <span class="math">i</span>th query is <span class="math">(m_{i0},m_{i1})</span>, and the corresponding ciphertext is <span class="math">\\psi_{i}=(x_{i},c_{i},t_{i})</span>, which is computed by the challenger by encrypting <span class="math">m_{ib}</span> under the key <span class="math">(s,k)</span> . Also, we assume that the adversary makes exactly <span class="math">q^{\\prime}</span> decryption queries, where for <span class="math">j=1,\\ldots,q^{\\prime}</span>, the <span class="math">j</span>th such query is <span class="math">\\psi^{\\prime}_{j}=(x^{\\prime}_{j},c^{\\prime}_{j},t^{\\prime}_{j})</span>, which the challenger decrypts under the key <span class="math">(s,k)</span>. For <span class="math">j=1,\\ldots,q^{\\prime}</span>, let us define <span class="math">Q_{j}</span> to be the number of encryption queries made prior to the <span class="math">j</span>th decryption query. We assume all queries are syntactically well formed, and that <span class="math">A</span> never submits <span class="math">\\psi^{\\prime}_{j}</span> for decryption with <span class="math">\\psi^{\\prime}_{j}=\\psi_{i}</span> for <span class="math">i\\leq Q_{j}</span>. At the end of the game, the adversary outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>. Let <span class="math">S_{0}</span> be the event that <span class="math">b=\\hat{b}</span> in this game.</p>

    <p class="text-gray-300">Game 1. This is the same as Game 0, except that we modify the way the challenger responds to decryption queries. Namely, we have the challenger respond with “reject” to <em>all</em> submitted ciphertexts, without performing any of the steps of the decryption algorithm.</p>

    <p class="text-gray-300">Let <span class="math">S_{1}</span> be the event that <span class="math">b=\\hat{b}</span> in Game 1. Let <span class="math">F</span> be the event in Game 1 that for some <span class="math">j=1,\\ldots,q^{\\prime}</span>, we have <span class="math">H_{k}(x^{\\prime}_{j}\\mid\\mid c^{\\prime}_{j})=t^{\\prime}_{j}</span>. It is clear that Games 0 and 1 proceed identically unless <span class="math">F</span> occurs (as usual, both games are understood to be defined on the same underlying probability space); therefore, by the Difference Lemma, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F].$ (16)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to bound <span class="math">\\Pr[F]</span>. We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F]\\leq q^{\\prime}\\cdot\\epsilon_{\\mathrm{uf}},</span> (17)</p>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{uf}}</span> is the UF-advantage of some efficient adversary <span class="math">B</span>, which by assumption is negligible.</p>

    <p class="text-gray-300">To prove this, we first make the following observations. Consider the <span class="math">j</span>th decryption query <span class="math">\\psi^{\\prime}_{j}=(x^{\\prime}_{j},c^{\\prime}_{j},t^{\\prime}_{j})</span>. There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x^{\\prime}_{j},c^{\\prime}_{j})=(x_{i},c_{i})</span> for some <span class="math">i=1,\\ldots,Q_{j}</span>. In this case, as <span class="math">\\psi^{\\prime}_{j}\\neq\\psi_{i}</span>, we must have <span class="math">t^{\\prime}_{j}\\neq t_{i}</span>, and since <span class="math">t_{i}=H_{k}(x_{i}\\mid\\mid c_{i})</span>, we must have <span class="math">t^{\\prime}_{j}\\neq H_{k}(x^{\\prime}_{j}\\mid\\mid c^{\\prime}_{j})</span>.</li>

      <li><span class="math">(x^{\\prime}_{j},c^{\\prime}_{j})\\neq(x_{i},c_{i})</span> for all <span class="math">i=1,\\ldots,Q_{j}</span>. In this case, if <span class="math">t^{\\prime}_{j}=H_{k}(x^{\\prime}_{j}\\mid\\mid c^{\\prime}_{j})</span>, the adversary has effectively predicted the value of <span class="math">H_{k}</span> at a new point, and we can use him to build an adversary with a corresponding UF-advantage.</li>

    </ul>

    <p class="text-gray-300">Based on the above discussion, we can easily construct an efficient adversary <span class="math">B</span> with UF-advantage at least <span class="math">\\Pr[F]/q^{\\prime}</span>, which proves (17). We describe <span class="math">B</span> as an oracle machine that makes use of <span class="math">A</span></p>

    <p class="text-gray-300">Oracle machine <span class="math">B^{\\mathcal{O}}</span></p>

    <div class="my-4 text-center"><span class="math-block">s \\stackrel{\\iota}{\\leftarrow} S, \\, b \\stackrel{\\dot{\\varepsilon}}{\\leftarrow} \\{0, 1\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">j^{*} \\xleftarrow{\\xi} \\{1, \\dots, q&#x27;\\}</span></div>

    <p class="text-gray-300">Run adversary <span class="math">A</span>:</p>

    <p class="text-gray-300">Upon the <span class="math">i</span>th encryption query <span class="math">(m_{i0}, m_{i1})</span> do:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i \\xleftarrow{\\xi} \\{0, 1\\}^n, \\, c_i \\leftarrow F_s(x_i) \\oplus m_{ib}, \\, t_i \\leftarrow \\mathcal{O}(x_i \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">give <span class="math">\\psi_i = (x_i, c_i, t_i)</span> to <span class="math">A</span></p>

    <p class="text-gray-300">Upon the <span class="math">j</span>th decryption query <span class="math">\\psi_j&#x27; = (x_j&#x27;, c_j&#x27;, t_j&#x27;)</span> do:</p>

    <p class="text-gray-300">if <span class="math">j &amp;lt; j^*</span> then</p>

    <p class="text-gray-300">give “reject” to <span class="math">A</span></p>

    <p class="text-gray-300">else — when <span class="math">j = j^*</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">output $y^* = x_j' \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>t^* = t_j'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">halt</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us analyze <span class="math">B</span> when given oracle access to <span class="math">H_k</span>, for randomly chosen <span class="math">k \\in K</span>. Let <span class="math">\\psi_1&#x27;, \\ldots, \\psi_{q&#x27;}&#x27;</span> denote the decryption queries that would be processed by <span class="math">B</span> if we let it run without halting it at the <span class="math">j^<em></span>th such query. The value of <span class="math">(\\psi_1&#x27;, \\ldots, \\psi_{q&#x27;})&#x27;</span> is completely determined by the coins of <span class="math">A</span>, along with the values <span class="math">s, b,</span> and <span class="math">k</span>, and as such, is independent of <span class="math">j^</em></span>. Let <span class="math">\\tilde{F}</span> be the event that $H_k(x_j' \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j') = t_j'<span class="math"> for some </span>j = 1, \\ldots, q'<span class="math">. Then by construction, we have </span>\\operatorname{Pr}[\\tilde{F}] = \\operatorname{Pr}[F]<span class="math">. If </span>\\tilde{F}<span class="math"> occurs, we can define </span>j_0<span class="math"> to be the least </span>j<span class="math"> such that </span>H_k(x_j' \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j') = t_j'<span class="math">. We know that </span>x_{j_0}' \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{j_0}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is not among the queries made to the oracle for </span>H_k<span class="math"> in processing the encryption queries made prior to processing decryption query </span>j_0<span class="math">. Therefore, the UF-advantage of </span>B<span class="math"> is at least </span>\\operatorname{Pr}[\\tilde{F} \\wedge j^* = j_0]<span class="math">, and by independence, the latter probability is equal to </span>\\operatorname{Pr}[F]/q'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Game 2.</strong> In this game, we replace <span class="math">F_s</span> by a truly random function <span class="math">f</span>. To save a step, let us implement <span class="math">f</span> by using a “faithful gnome.” To do this, the challenger makes the following computations on the <span class="math">i</span>th encryption query <span class="math">(m_{i0}, m_{i1})</span> to obtain the ciphertext <span class="math">\\psi_i = (x_i, c_i, t_i)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">x_i \\xleftarrow{\\xi} \\{0, 1\\}^n, \\, P_i \\xleftarrow{\\xi} \\{0, 1\\}^\\ell</span></div>

    <p class="text-gray-300">if <span class="math">x_i = x_j</span> for some <span class="math">j &amp;lt; i</span> then <span class="math">p_i \\leftarrow p_j</span> else <span class="math">p_i \\leftarrow P_i</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i \\leftarrow p_i \\oplus m_{ib}, \\, t_i \\leftarrow H_k(x_i \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">S_2</span> be the event that <span class="math">b = \\hat{b}</span> in Game 2. By a familiar argument, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_1] - \\Pr[S_2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\epsilon_{\\mathrm{prf}}, \\tag{18}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{prf}}</span> is the PRF-advantage of some efficient adversary, and hence by assumption, negligible. Indeed, the following adversary <span class="math">D</span> does the job:</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">Oracle machine <span class="math">D^{\\mathcal{O}}</span></p>

    <p class="text-gray-300">$k\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</p>

    <p class="text-gray-300"><span class="math">H_{k}:G\\to\\{0,1\\}^{\\ell}</span> as a random oracle; that is, for the purposes of analysis, the function <span class="math">H_{k}</span> is modeled as a truly random function, to which both the adversary and the challenger have oracle (i.e., “black box”) access. Thus, for any particular <span class="math">\\lambda\\in G</span>, the value of <span class="math">H_{k}(\\lambda)</span> may be obtained only by giving the value <span class="math">\\lambda</span> to a special “hash oracle,” who responds with the value <span class="math">H_{k}(\\lambda)</span>. In this model, there is no real reason to view the hash function as keyed, but we will continue to do so, just to maintain consistency with the notation in §3.4.</p>

    <p class="text-gray-300">Hashed ElGamal encryption is semantically secure in the random oracle model under the Computational Diffie-Hellman (CDH) assumption. This is the assumption that given <span class="math">\\gamma^{x}</span> and <span class="math">\\gamma^{y}</span>, it is hard to compute <span class="math">\\gamma^{xy}</span>. Here, <span class="math">x</span> and <span class="math">y</span> are random elements of <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">The CDH assumption is more precisely formulated as follows. Let <span class="math">B</span> be an algorithm that takes as input a pair of group elements, and outputs a group element. We define the CDH-advantage of <span class="math">B</span> to be</p>

    <p class="text-gray-300"><span class="math">\\Pr[x,y\\stackrel{{\\scriptstyle\\scriptscriptstyle\\xi}}{{\\leftarrow}}\\mathbb{Z}_{q}:B(\\gamma^{x},\\gamma^{y})=\\gamma^{xy}].</span></p>

    <p class="text-gray-300">The CDH assumption (for <span class="math">G</span>) is the assumption that any efficient algorithm’s CDH-advantage is negligible.</p>

    <p class="text-gray-300">Clearly, the DDH assumption implies the CDH assumption, although the converse need not necessarily hold. One awkward aspect of the CDH assumption is that if the DDH assumption is indeed true, then we cannot efficiently verify the correctness of the output of an algorithm that attempts to compute <span class="math">\\gamma^{xy}</span> given <span class="math">\\gamma^{x}</span> and <span class="math">\\gamma^{y}</span>. Because of this, in our security proof, we shall actually consider a slightly different formulation of the CDH assumption. Let <span class="math">C</span> be an algorithm that takes as input a pair of group elements, and outputs a list of group elements. We define the list CDH-advantage of <span class="math">C</span> to be</p>

    <p class="text-gray-300"><span class="math">\\Pr[x,y\\stackrel{{\\scriptstyle\\scriptscriptstyle\\xi}}{{\\leftarrow}}\\mathbb{Z}_{q}:\\gamma^{xy}\\in C(\\gamma^{x},\\gamma^{y})].</span></p>

    <p class="text-gray-300">It is clear that the CDH assumption implies that any efficient algorithm’s list CDH-advantage is negligible. Indeed, if <span class="math">C</span> has non-negligible list CDH advantage, then we can build an algorithm <span class="math">B</span> with non-negligible CDH advantage as follows: algorithm <span class="math">B</span> simply runs algorithm <span class="math">C</span> and then outputs one group element, chosen at random from among those in <span class="math">C</span>’s output list.</p>

    <p class="text-gray-300">We now give a security proof as a sequence of games. As in the previous section, we only give a high-level description of Game 0, and describe only the differences between successive games.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Game 0.</h6>

    <p class="text-gray-300">This is the original attack game with respect to a given efficient adversary <span class="math">A</span>. At the beginning of the game, the challenger computes <span class="math">x\\stackrel{{\\scriptstyle\\scriptscriptstyle\\xi}}{{\\leftarrow}}\\mathbb{Z}_{q}</span> and <span class="math">\\alpha\\leftarrow\\gamma^{x}</span>, and gives <span class="math">\\alpha</span> to <span class="math">A</span>. Conceptually, the challenger has access to an oracle for the random function <span class="math">H_{k}</span>.</p>

    <p class="text-gray-300">Next, <span class="math">A</span> makes a sequence of queries to the challenger. There are two types of queries:</p>

    <p class="text-gray-300">A presents the challenger with <span class="math">\\lambda\\in G</span>, who responds to <span class="math">A</span>’s query with the value <span class="math">H_{k}(\\lambda)\\in\\{0,1\\}^{\\ell}</span>. A submits two messages <span class="math">m_{0},m_{1}\\in\\{0,1\\}^{\\ell}</span> to the challenger, who responds to <span class="math">A</span>’s query with the value <span class="math">(\\beta,v)</span>, computed as follows:</p>

    <p class="text-gray-300"><span class="math">b\\stackrel{{\\scriptstyle\\scriptscriptstyle\\xi}}{{\\leftarrow}}\\{0,1\\},\\ y\\stackrel{{\\scriptstyle\\scriptscriptstyle\\xi}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ \\beta\\leftarrow\\gamma^{y},\\ \\delta\\leftarrow\\alpha^{y},\\ h\\leftarrow H_{k}(\\delta),\\ v\\leftarrow h\\oplus m_{b}.</span></p>

    <p class="text-gray-300">Moreover, while the adversary may make any number of hash oracle queries, he may make at most one encryption query. Without loss of generality, we assume the adversary makes exactly one encryption query.</p>

    <p class="text-gray-300">At the end of the game, <span class="math">A</span> outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>. Let <span class="math">S_{0}</span> be the event that <span class="math">b=\\hat{b}</span> in Game 0.</p>

    <p class="text-gray-300">Here, we make several conceptual changes. First, we make the challenger generate the random value <span class="math">y\\in\\mathbb{Z}_{q}</span> at the beginning of the game. Second, at the beginning of the game, the challenger also computes <span class="math">h^{+}\\xleftarrow{\\mathfrak{t}}\\{0,1\\}^{\\ell}</span>. Moreover, we modify the way the challenger responds to queries as follows:</p>

    <p class="text-gray-300">Given a query <span class="math">\\lambda\\in G</span>, if <span class="math">\\lambda=\\alpha^{y}</span>, respond with <span class="math">h^{+}</span>, otherwise, respond with <span class="math">H_{k}(\\lambda)</span>. Given a query <span class="math">m_{0},m_{1}\\in\\{0,1\\}^{\\ell}</span>, respond with <span class="math">(\\beta,v)</span>, computed as follows:</p>

    <p class="text-gray-300"><span class="math">b\\xleftarrow{\\mathfrak{t}}\\{0,1\\},\\ \\beta\\leftarrow\\gamma^{y},\\ v\\leftarrow h^{+}\\oplus m_{b}.</span></p>

    <p class="text-gray-300">Let <span class="math">S_{1}</span> be the event that <span class="math">b=\\hat{b}</span> in Game 1. It should be clear that</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{1}]=\\Pr[S_{0}].</span> (22)</p>

    <p class="text-gray-300">Indeed, all we have really done is to effectively replace the value of <span class="math">H_{k}(\\alpha^{y})</span> by <span class="math">h^{+}</span> consistently throughout the game, both in the hash oracle queries and in the encryption query.</p>

    <p class="text-gray-300">This is the same as Game 1, except that the challenger now reverts to the rule used for responding to hash oracle queries in Game 0. That is, given a hash oracle query <span class="math">\\lambda\\in G</span>, the challenger now simply responds with <span class="math">H_{k}(\\lambda)</span>. However, the challenger responds to the encryption query just as in Game 1; in particular, the value <span class="math">h^{+}</span> is only used to “‘mask” <span class="math">m_{b}</span> in the encryption query, and the value <span class="math">y</span> is only used to compute <span class="math">\\beta</span> in the encryption query.</p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event that <span class="math">b=\\hat{b}</span> in Game 2.</p>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{2}]=1/2.</span> (23)</p>

    <p class="text-gray-300">This follows directly from the fact that in Game 2, <span class="math">h^{+}</span> is effectively used as a one-time pad.</p>

    <p class="text-gray-300">Now let <span class="math">F</span> be the event that the adversary makes an encryption oracle query <span class="math">\\lambda</span> in Game 2 with <span class="math">\\lambda=\\alpha^{y}</span>. It is evident that Games 1 and 2 proceed identically unless <span class="math">F</span> occurs. Therefore, by the Difference Lemma, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F].$ (24)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F]=\\epsilon_{\\mathrm{lcdh}},</span> (25)</p>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathrm{lcdh}}</span> is the list CDH-advantage of some efficient algorithm <span class="math">C</span> (which is negligible under the CDH assumption). Algorithm <span class="math">C</span> runs as follows. It takes as input <span class="math">\\alpha=\\gamma^{x}</span> and <span class="math">\\beta=\\gamma^{y}</span>. It then interacts with <span class="math">A</span>, playing the role of the challenger in Game 2, but using the given values of <span class="math">\\alpha</span> and <span class="math">\\beta</span>. At game’s end, <span class="math">C</span> outputs the list of all hash oracle queries made by <span class="math">A</span>. Some implementation notes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger in Game 2 never needs the values of <span class="math">x</span> and <span class="math">y</span> except to compute <span class="math">\\alpha</span> and <span class="math">\\beta</span>; therefore, algorithm <span class="math">C</span> does not need either <span class="math">x</span> or <span class="math">y</span>.</li>

      <li>Algorithm <span class="math">C</span> implements <span class="math">H_{k}</span> using the usual “gnome” implementation. Note that the only queries made to <span class="math">H_{k}</span> in Game 2 are by the challenger in response to the adversary’s hash oracle queries.</li>

    </ul>

    <p class="text-gray-300">It should be clear that the probability that <span class="math">C</span>’s output list contains <span class="math">\\alpha^{y}</span> is precisely equal to <span class="math">\\Pr[F]</span>.</p>

    <p class="text-gray-300">Combining (22), (23), (24), and (25), we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{\\text{lcdh}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is negligible.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">Thanks to Alex Dent and Antonio Nicolosi for their comments on preliminary drafts.</p>

    <h2 id="sec-29" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFP04] M. Abdalla, P.-A. Fouque, and D. Pointcheval. Password-based authenticated key exchange in the three party setting. Available at http://eprint.iacr.org/2004/233, 2004. To appear, PKC 2005.</li>

      <li>[BCP02a] E. Bresson, O. Chevassut, and D. Pointcheval. Dynamic group Diffie-Hellman key exchange under standard assumptions. In Advances in Cryptology–Eurocrypt 2002, pages 321–336, 2002. Full version avalable at http://www.di.ens.fr/~pointche.</li>

      <li>[BCP02b] E. Bresson, O. Chevassut, and D. Pointcheval. Group Diffie-Hellman key exchange secure against dictionary attack. In Advances in Cryptology–Asiacrypt 2002, pages 497–514, 2002. Full version avalable at http://www.di.ens.fr/~pointche.</li>

      <li>[BCP03] E. Bresson, O. Chevassut, and D. Pointcheval. Security proofs for an efficient password-based key exchange. In Proc. 10th ACM Conference on Computer and Communications Security, pages 241–250, 2003. Full version avalable at http://www.di.ens.fr/~pointche.</li>

      <li>[BG89] M. Bellare and S. Goldwasser. New paradigms for digital signatures andd message authentication based on non-interactive zero knowledge proofs. In Advances in Cryptology–Crypto ’89, pages 194–211, 1989.</li>

      <li>[BK04] D. Boneh and J. Katz. Improved efficiency for CCA-secure cryptosystems built using identity-based encryption. Available at http://eprint.iacr.org/2004/261, 2004. To appear, CT-RSA 2005.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BR93] M. Bellare and P. Rogaway. Random oracles are practical: a paradigm for designing efficient protocols. In First ACM Conference on Computer and Communications Security, pages 62–73, 1993.</li>

      <li>[BR04] M. Bellare and P. Rogaway. The game-playing technique. Available at http://eprint.iacr.org/2004/331, 2004.</li>

      <li>[CPP04] D. Catalano, D. Pointcheval, and T. Pornin. IPAKE: Isomorphisms for password-based authenticated key exchange. In Advances in Cryptology–Crypto 2004, pages 477–493, 2004. Full version at www.di.ens.fr/~pointche.</li>

      <li>[CS02] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for adaptive chosen ciphertext secure public key encryption. In Advances in Cryptology–Eurocrypt 2002, pages 45–64, 2002. Full version at http://eprint.iacr.org/2001/085.</li>

      <li>[CS03a] J. Camenisch and V. Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Advances in Cryptology–Crypto 2003, pages 126–144, 2003. Full version at http://eprint.iacr.org/2002/161.</li>

      <li>[CS03b] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM Journal on Computing, 33:167–226, 2003. Preliminary version at http://eprint.iacr.org/2001/108.</li>

      <li>[Den03] A. Dent. A designer’s guide to KEMs. In Proc. 9th IMA Conf. on Coding and Cryptography (LNCS 2898), 2003. Full version at http://eprint.iacr.org/2002/174.</li>

      <li>[DF03] Y. Dodis and N. Fazio. Public key trace and revoke scheme secure against adaptive chosen ciphertext attack. In Proc. 2003 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2003), 2003. Full version at http://eprint.iacr.org/2003/095.</li>

      <li>[DFJW04] Y. Dodis, M. J. Freedman, S. Jarecki, and S. Walfish. Versatile padding schemes for joint signature and encryption. In Proc. 11th ACM Conference on Computer and Communications Security, 2004. Full verssion at http://eprint.iacr.org/2004/020.</li>

      <li>[DFKY03] Y. Dodis, N. Fazio, A. Kiayias, and M. Yung. Scalable public-key tracing and revoking. In Proc. 22nd ACM Symposium on Principles of Distributed Computing, 2003. Full version at http://eprint.iacr.org/2004/160.</li>

      <li>[FOPS04] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern. RSA-OAEP is secure under the RSA assumption. Journal of Cryptology, 17(2):81–104, 2004.</li>

      <li>[GaPMV03] D. Galindo, S. Martín abd P. Morillo, and J. L. Villar. Fujisaki-Okamoto IND-CCA hybrid encryption revisted, 2003. Available at http://eprint.iacr.org/2003/107; to appear, Int. J. Inf. Secur.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GGM86] O. Goldreich, S. Goldwasser, and S. Micali. How to construct random functions. Journal of the ACM, 33:210–217, 1986.</li>

      <li>[GM84] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, 1984.</li>

      <li>[Gol01] O. Goldreich. Foundations of Cryptography: Basic Tools. Cambridge University Press, 2001.</li>

      <li>[GS04] R. Gennaro and V. Shoup. A note on an encryption scheme of Kurosawa and Desmedt. Available at http://eprint.iacr.org/2004/194, 2004.</li>

      <li>[IZ89] R. Impagliazzo and D. Zuckermann. How to recycle random bits. In 30th Annual Symposium on Foundations of Computer Science, pages 248–253, 1989.</li>

      <li>[KD04] K. Kurosawa and Y. Desmedt. A new paradigm of hybrid encryption scheme. In Advances in Cryptology–Crypto 2004, pages 426–442, 2004. Full version at http://kuro.cis.ibaraki.ac.jp/~kurosawa.</li>

      <li>[KR96] J. Kilian and P. Rogaway. How to protect DES against exhaustive key search. In Advances in Cryptology–Crypto ’96, pages 252–267, 1996.</li>

      <li>[LR88] M. Luby and C. Rackoff. How to construct pseudorandom permutaations from pseudorandom functions. SIAM Journal on Computing, 17(2):373–386, 1988.</li>

      <li>[NR99] M. Naor and O. Reingold. On the construction of pseudo-random permutations: Luby-Rackoff revisited. Journal of Cryptology, 12(1):29–66, 1999.</li>

      <li>[Poi04] D. Pointcheval. Provable security for public key schemes, 2004. Available at http://www.di.ens.fr/~pointche.</li>

      <li>[PP03] D. H. Phan and D. Pointcheval. Chosen ciphertext security without redundancy. In Advances in Cryptology–Asiacrypt 2003, pages 1–18, 2003. Full version avalable at http://www.di.ens.fr/~pointche.</li>

      <li>[Sho00] V. Shoup. Using hash functions as a hedge against chosen ciphertext attack. In Advances in Cryptology–Eurocrypt 2000, pages 275–288, 2000.</li>

      <li>[Sho01] V. Shoup. A proposal for an ISO standard for public key encryption. Available at http://eprint.iacr.org/2001/112, 2001.</li>

      <li>[Sho02] V. Shoup. OAEP reconsidered. Journal of Cryptology, 15(4):223–249, 2002. Extended abstract in Crypto 2001. Available online at http://eprint.iacr.org/2000/060.</li>

      <li>[SS00] T. Schweinberger and V. Shoup. ACE: The Advanced Cryptographic Engine. Available at http://eprint.iacr.org/2000/022, 2000.</li>

    </ul>

    <p class="text-gray-300">[SWP04] R. Steinfeld, H. Wang, and J. Pieprzyk. Efficient extension of standard Schnorr/RSA signatures into universal designated-verifier signatures. In Proc. 2004 International Workshop on Practice and Theory in Public Key Cryptography (PKC 2004), pages 86–100, 2004. Full version at http://eprint.iacr.org/2003/193.</p>`;
---

<BaseLayout title="Sequences of games: a tool for taming complexity in security... (2004/332)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/332
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
